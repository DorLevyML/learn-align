push   %r15
mov    %rsi,%r15
push   %r14
push   %r13
mov    %rcx,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
mov    %rdx,0x18(%rsp)
callq  35 <argmatch+0x25>
mov    (%r15),%r14
test   %r14,%r14
je     162 <argmatch+0x152>
xor    %ebx,%ebx
test   %rbp,%rbp
mov    %rax,%r12
movb   $0x0,0x17(%rsp)
movq   $0xffffffffffffffff,0x8(%rsp)
jne    97 <argmatch+0x87>
jmpq   11a <argmatch+0x10a>
xchg   %ax,%ax
imul   %r13,%rdi
mov    %r13,%rdx
mov    %rbp,%rsi
add    0x18(%rsp),%rdi
callq  74 <argmatch+0x64>
test   %eax,%eax
movzbl 0x17(%rsp),%eax
mov    $0x1,%ecx
cmovne %ecx,%eax
mov    %al,0x17(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  a6 <argmatch+0x96>
test   %eax,%eax
jne    87 <argmatch+0x77>
mov    %r14,%rdi
callq  b2 <argmatch+0xa2>
cmp    %r12,%rax
je     150 <argmatch+0x140>
mov    0x8(%rsp),%rdi
cmp    $0xffffffffffffffff,%rdi
jne    60 <argmatch+0x50>
mov    %rbx,0x8(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
jne    97 <argmatch+0x87>
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x17(%rsp)
mov    $0xfffffffffffffffe,%rax
jne    f3 <argmatch+0xe3>
mov    0x8(%rsp),%rax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
movb   $0x1,0x17(%rsp)
add    $0x1,%rbx
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  129 <argmatch+0x119>
test   %eax,%eax
jne    10d <argmatch+0xfd>
mov    %r14,%rdi
callq  135 <argmatch+0x125>
cmp    %r12,%rax
je     150 <argmatch+0x140>
cmpq   $0xffffffffffffffff,0x8(%rsp)
jne    108 <argmatch+0xf8>
mov    %rbx,0x8(%rsp)
jmp    10d <argmatch+0xfd>
nopl   0x0(%rax)
add    $0x28,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
movq   $0xffffffffffffffff,0x8(%rsp)
jmp    ee <argmatch+0xde>
nopl   (%rax)
<<<sep_in_sample>>>
argmatch (const char *arg, const char *const *arglist,
          const char *vallist, size_t valsize)
{
  size_t i;
  size_t arglen;
  ptrdiff_t matchind = -1;
  _Bool ambiguous = 0;
  arglen = strlen (arg);
  for (i = 0; arglist[i]; i++)
    {
      if (!strncmp (arglist[i], arg, arglen))
        {
          if (strlen (arglist[i]) == arglen)
            return i;
          else if (matchind == -1)
            matchind = i;
          else
            {
              if (vallist == ((void *)0)
                  || memcmp (vallist + valsize * matchind,
                             vallist + valsize * i, valsize))
                {
                  ambiguous = 1;
                }
            }
        }
    }
  if (ambiguous)
    return -2;
  else
    return matchind;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 7
21 6
22 6
23 6
24 6
25 20
26 20
27 20
28 20
29 20
30 23
31 23
32 23
33 23
34 23
35 9
36 9
37 9
38 9
39 9
40 11
41 11
42 11
43 11
44 11
45 11
46 13
47 13
48 13
49 13
50 15
51 15
52 15
53 16
54 9
55 9
56 9
57 9
58 9
59 9
60 28
61 29
62 28
63 31
64 32
65 32
66 32
67 32
68 32
69 32
70 32
71 32
72 32
73 23
74 9
75 9
76 9
77 9
78 11
79 11
80 11
81 11
82 11
83 11
84 13
85 13
86 13
87 13
88 15
89 15
90 16
91 16
92 16
93 32
94 14
95 32
96 32
97 32
98 32
99 32
100 32
101 32
102 6
103 6
104 6
<<<sep_out_sample>>>
push   %r15
mov    (%rdi),%r15
push   %r14
test   %r15,%r15
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%r14
je     2892 <gsl_matrix_scale+0x122>
movapd %xmm0,%xmm2
lea    0x0(,%r14,8),%rax
xor    %ebp,%ebp
xor    %r9d,%r9d
xor    %ebx,%ebx
unpcklpd %xmm2,%xmm2
mov    %rax,-0x10(%rsp)
nopw   0x0(%rax,%rax,1)
test   %rcx,%rcx
je     287d <gsl_matrix_scale+0x10d>
mov    0x18(%rdi),%r11
mov    %rcx,%rsi
lea    (%r11,%r9,1),%rdx
mov    %rdx,%rax
shl    $0x3c,%rax
shr    $0x3f,%rax
cmp    %rcx,%rax
cmova  %rcx,%rax
cmp    $0x3,%rcx
ja     28a0 <gsl_matrix_scale+0x130>
movsd  (%rdx),%xmm1
cmp    $0x1,%rsi
mov    $0x1,%r10d
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rdx)
je     2826 <gsl_matrix_scale+0xb6>
lea    0x8(%r11,%r9,1),%rax
cmp    $0x3,%rsi
mov    $0x2,%r10b
movsd  (%rax),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rax)
jne    2826 <gsl_matrix_scale+0xb6>
lea    0x10(%r11,%r9,1),%rax
mov    $0x3,%r10b
movsd  (%rax),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rax)
cmp    %rsi,%rcx
je     287d <gsl_matrix_scale+0x10d>
mov    %rcx,%r12
sub    %rsi,%r12
mov    %r12,%r8
shr    %r8
mov    %r8,%r13
add    %r13,%r13
je     286a <gsl_matrix_scale+0xfa>
lea    (%rdx,%rsi,8),%rsi
xor    %eax,%eax
xor    %edx,%edx
movapd (%rsi,%rax,1),%xmm1
add    $0x1,%rdx
mulpd  %xmm2,%xmm1
movapd %xmm1,(%rsi,%rax,1)
add    $0x10,%rax
cmp    %rdx,%r8
ja     2847 <gsl_matrix_scale+0xd7>
add    %r13,%r10
cmp    %r13,%r12
je     287d <gsl_matrix_scale+0x10d>
add    %rbp,%r10
lea    (%r11,%r10,8),%rax
movsd  (%rax),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rax)
add    $0x1,%rbx
add    -0x10(%rsp),%r9
add    %r14,%rbp
cmp    %r15,%rbx
jne    27b0 <gsl_matrix_scale+0x40>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
xor    %eax,%eax
pop    %r15
retq   
nop
test   %rax,%rax
jne    28af <gsl_matrix_scale+0x13f>
xor    %esi,%esi
xor    %r10d,%r10d
jmpq   282b <gsl_matrix_scale+0xbb>
mov    %rax,%rsi
jmpq   27e0 <gsl_matrix_scale+0x70>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_scale (gsl_matrix * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 7
5 2
6 2
7 2
8 2
9 4
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 11
33 11
34 9
35 11
36 11
37 11
38 11
39 11
40 9
41 11
42 11
43 11
44 11
45 11
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 11
55 11
56 11
57 11
58 11
59 11
60 2
61 2
62 11
63 11
64 11
65 11
66 11
67 11
68 11
69 11
70 11
71 11
72 11
73 11
74 11
75 11
76 11
77 7
78 7
79 7
80 7
81 7
82 15
83 15
84 15
85 15
86 15
87 15
88 15
89 15
90 15
91 15
92 15
93 9
94 9
95 9
96 9
97 9
98 9
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
movzbl %sil,%esi
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
mov    0x163c(%rdi,%rax,8),%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
get_track_preemphasis_image(const void *p_user_data, track_t i_track)
{
  const _img_private_t *p_env = p_user_data;
  return ( p_env->tocent[i_track-p_env->gen.i_first_track].flags
    & PRE_EMPHASIS ) ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     5a3 <add_history_time+0x53>
movslq 0x0(%rip),%rax        # 565 <add_history_time+0x15>
test   %eax,%eax
jle    5a3 <add_history_time+0x53>
mov    0x0(%rip),%rdx        # 570 <add_history_time+0x20>
mov    -0x8(%rdx,%rax,8),%rbp
mov    0x8(%rbp),%rdi
test   %rdi,%rdi
je     583 <add_history_time+0x33>
callq  583 <add_history_time+0x33>
mov    %rbx,%rdi
callq  58b <add_history_time+0x3b>
lea    0x1(%rax),%rdi
callq  594 <add_history_time+0x44>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  59f <add_history_time+0x4f>
mov    %rax,0x8(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_history_time (string)
     const char *string;
{
  HIST_ENTRY *hs;
  if (string == 0 || history_length < 1)
    return;
  hs = the_history[history_length - 1];
  if (hs->timestamp) free (hs->timestamp);
  hs->timestamp = strcpy (xmalloc (1 + strlen (string)), (string));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rdi
xor    %eax,%eax
mov    %rsi,%rdx
mov    $0x0,%esi
callq  36 <print_dir+0x16>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
print_dir(int flag, const char *dir, void *data)
{
 FILE *fp = data;
 fprintf(fp, "%s\n", dir);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     3817 <freeunit+0x37>
mov    0x0(%rip),%rbp        # 37f6 <freeunit+0x16>
mov    %r12,%rbx
nopl   0x0(%rax)
cmp    0x0(%rbp),%rdi
je     380b <freeunit+0x2b>
callq  380b <freeunit+0x2b>
add    $0x8,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    3800 <freeunit+0x20>
mov    0x320(%r12),%rdi
lea    0x320(%r12),%rbx
test   %rdi,%rdi
je     384f <freeunit+0x6f>
mov    0x0(%rip),%rbp        # 3833 <freeunit+0x53>
nopl   0x0(%rax,%rax,1)
cmp    0x0(%rbp),%rdi
je     3843 <freeunit+0x63>
callq  3843 <freeunit+0x63>
add    $0x8,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    3838 <freeunit+0x58>
movq   $0x0,0x320(%r12)
movq   $0x0,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
freeunit(struct unittype *theunit)
{
   char **ptr;
   for(ptr = theunit->numerator; *ptr; ptr++)
     if (*ptr != NULLUNIT) free(*ptr);
   for(ptr = theunit->denominator; *ptr; ptr++)
     if (*ptr != NULLUNIT) free(*ptr);
   theunit->numerator[0] = 0;
   theunit->denominator[0] = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
16 4
17 4
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 6
28 6
29 6
30 6
31 9
32 8
33 10
34 10
35 10
36 10
37 10
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     620 <hash_delete_at+0x20>
mov    0x0(%rip),%rdx        # 60f <hash_delete_at+0xf>
cmp    %rdx,%rax
je     620 <hash_delete_at+0x20>
mov    %rdx,(%rsi)
subq   $0x1,0x30(%rdi)
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_delete_at (struct hash_table *ht, const void *slot)
{
  void *item = *(void **) slot;
  if (!((item) == 0 || (void *) (item) == hash_deleted_item))
    {
      *(void const **) slot = hash_deleted_item;
      ht->ht_fill--;
      return item;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 6
8 7
9 8
10 8
11 11
12 12
13 12
<<<sep_out_sample>>>
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 8a <nettle_ccm_aes192_decrypt+0xa>
mov    %rsi,%rax
lea    0x28(%rdi),%rsi
mov    %rcx,%r9
mov    %rax,%rcx
jmpq   9c <nettle_ccm_aes192_decrypt+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_ccm_decrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes192_encrypt,
       length, dst, src);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <osip_content_length_init+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
test   %rax,%rax
je     30 <osip_content_length_init+0x30>
callq  *%rax
test   %rax,%rax
mov    %rax,(%rbx)
je     37 <osip_content_length_init+0x37>
movq   $0x0,(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
callq  35 <osip_content_length_init+0x35>
jmp    17 <osip_content_length_init+0x17>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
osip_content_length_init (osip_content_length_t ** cl)
{
  *cl = (osip_content_length_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_content_length_t)):malloc(sizeof (osip_content_length_t)));
  if (*cl == ((void *)0))
    return -4;
  (*cl)->value = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 3
10 4
11 6
12 7
13 8
14 8
15 8
16 3
17 3
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
movzwl (%rdi),%eax
cmp    $0x1,%rdx
cvtsi2sd %eax,%xmm1
subsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
jbe    c85 <gsl_stats_ushort_lag1_autocorrelation_m+0x95>
add    %rsi,%rsi
fldz   
mov    $0x1,%eax
lea    (%rdi,%rsi,1),%rcx
jmp    c54 <gsl_stats_ushort_lag1_autocorrelation_m+0x64>
nop
movzwl (%rdi),%r8d
add    %rsi,%rcx
add    %rsi,%rdi
cmp    %rdx,%rax
cvtsi2sd %r8d,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fmul   %st(2),%st
fsub   %st(3),%st
fdiv   %st(1),%st
faddp  %st,%st(3)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(3),%st
fdivp  %st,%st(1)
faddp  %st,%st(2)
je     c90 <gsl_stats_ushort_lag1_autocorrelation_m+0xa0>
movzwl (%rcx),%r8d
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
test   %rax,%rax
cvtsi2sd %r8d,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fildll -0x18(%rsp)
jns    c20 <gsl_stats_ushort_lag1_autocorrelation_m+0x30>
fadds  0x0(%rip)        # c83 <gsl_stats_ushort_lag1_autocorrelation_m+0x93>
jmp    c20 <gsl_stats_ushort_lag1_autocorrelation_m+0x30>
fldz   
nopw   0x0(%rax,%rax,1)
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_lag1_autocorrelation_m (const unsigned short data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 7
3 6
4 6
5 6
6 6
7 6
8 7
9 7
10 5
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 7
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 12
29 12
30 12
31 12
32 7
33 10
34 11
35 11
36 11
37 10
38 10
39 10
40 10
41 11
42 11
43 11
44 11
45 5
46 5
47 14
48 15
49 15
50 16
51 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1687 <get_shortcut+0x7>
test   %rax,%rax
je     16c0 <get_shortcut+0x40>
mov    0x0(%rip),%edx        # 1692 <get_shortcut+0x12>
movzbl 0x0(%rip),%ecx        # 1699 <get_shortcut+0x19>
jmp    16a9 <get_shortcut+0x29>
nopl   0x0(%rax,%rax,1)
mov    0x28(%rax),%rax
test   %rax,%rax
je     16c0 <get_shortcut+0x40>
test   %edx,0x10(%rax)
je     16a0 <get_shortcut+0x20>
mov    0xc(%rax),%esi
cmp    %esi,(%rdi)
jne    16a0 <get_shortcut+0x20>
cmp    %cl,0x8(%rax)
jne    16a0 <get_shortcut+0x20>
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_shortcut(int *kbinput)
{
    sc *s;
    for (s = sclist; s != ((void *)0); s = s->next) {
 if ((s->menus & currmenu) && *kbinput == s->keycode &&
     meta_key == s->meta) {
     return s;
 }
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 11
19 11
20 10
21 11
22 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     60 <osip_mutex_destroy+0x20>
callq  4e <osip_mutex_destroy+0xe>
mov    0x0(%rip),%rax        # 55 <osip_mutex_destroy+0x15>
mov    %rbx,%rdi
test   %rax,%rax
je     68 <osip_mutex_destroy+0x28>
pop    %rbx
jmpq   *%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   75 <osip_mutex_destroy+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_mutex_destroy (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return;
  pthread_mutex_destroy (mut);
  { if (mut!=((void *)0)) { if (osip_free_func) osip_free_func(mut); else free(mut);} };
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 6
6 7
7 7
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 8
17 7
18 7
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b7 <oldgnu_fixup_header+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0xc,%esi
lea    0x1e3(%rax),%rdi
callq  cc <oldgnu_fixup_header+0x1c>
mov    0x18(%rbx),%rdx
mov    0x88(%rdx),%rcx
mov    %rcx,0x118(%rdx)
xor    %ecx,%ecx
test   %rax,%rax
cmovns %rax,%rcx
not    %rax
mov    %rcx,0x88(%rdx)
shr    $0x3f,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
oldgnu_fixup_header (struct tar_sparse_file *file)
{
  off_t realsize = off_from_header (current_header->oldgnu_header.realsize, sizeof (current_header->oldgnu_header.realsize));
  file->stat_info->archive_file_size = file->stat_info->stat.st_size;
  file->stat_info->stat.st_size = ((0) < (realsize) ? (realsize) : (0));
  return 0 <= realsize;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 5
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
mov    (%rdi),%rsi
cmp    %rsi,0x8(%rdi)
cmovbe 0x8(%rdi),%rsi
mov    0x10(%rdi),%rcx
test   %rsi,%rsi
je     20a4 <gsl_matrix_long_double_add_diagonal+0x44>
movsd  %xmm0,-0x10(%rsp)
mov    0x18(%rdi),%rax
add    $0x1,%rcx
shl    $0x4,%rcx
xor    %edx,%edx
fldl   -0x10(%rsp)
nopl   (%rax)
fldt   (%rax)
add    $0x1,%rdx
fadd   %st(1),%st
fstpt  (%rax)
add    %rcx,%rax
cmp    %rsi,%rdx
jne    2090 <gsl_matrix_long_double_add_diagonal+0x30>
fstp   %st(0)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_add_diagonal (gsl_matrix_long_double * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 10
15 8
16 10
17 10
18 10
19 8
20 8
21 8
22 13
23 13
24 13
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 28b7 <asm_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_set_out (FILE * out_str )
{
        asm_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1c46 <psget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psget_lineno (void)
{
    return pslineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_isnonneg (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 18
2 18
3 18
<<<sep_out_sample>>>
jmpq   3045 <cpp_alloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_alloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 77 <close_dribble_file+0x7>
test   %rdi,%rdi
je     a0 <close_dribble_file+0x30>
sub    $0x8,%rsp
callq  85 <close_dribble_file+0x15>
mov    0x0(%rip),%rdi        # 8c <close_dribble_file+0x1c>
callq  91 <close_dribble_file+0x21>
movq   $0x0,0x0(%rip)        # 9c <close_dribble_file+0x2c>
add    $0x8,%rsp
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_dribble_file (void)
{
  if (info_dribble_file)
    {
      fflush (info_dribble_file);
      fclose (info_dribble_file);
      info_dribble_file = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 6
7 6
8 7
9 9
10 9
11 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl (%rdi),%edi
callq  11 <cdio_audio_get_msf_seconds+0x11>
movzbl 0x1(%rbx),%edi
movzbl %al,%ebp
callq  1d <cdio_audio_get_msf_seconds+0x1d>
mov    $0x3c,%edx
add    $0x8,%rsp
movzbl %al,%eax
imul   %edx,%ebp
pop    %rbx
add    %ebp,%eax
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_audio_get_msf_seconds(msf_t *p_msf)
{
  return
    cdio_from_bcd8(p_msf->m)*60 + cdio_from_bcd8(p_msf->s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 5
15 4
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  f0 <mu_get_homedir+0x10>
test   %rax,%rax
je     108 <mu_get_homedir+0x28>
add    $0x8,%rsp
mov    %rax,%rdi
pop    %rbx
pop    %rbp
jmpq   103 <mu_get_homedir+0x23>
nopl   0x0(%rax,%rax,1)
callq  10d <mu_get_homedir+0x2d>
mov    %eax,%edi
callq  114 <mu_get_homedir+0x34>
test   %rax,%rax
mov    %rax,%rbx
je     13a <mu_get_homedir+0x5a>
mov    0x28(%rax),%rdi
callq  125 <mu_get_homedir+0x45>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  130 <mu_get_homedir+0x50>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    133 <mu_get_homedir+0x53>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_get_homedir (void)
{
  char *homedir = getenv ("HOME");
  if (homedir)
    homedir = strdup (homedir);
  else
    {
      struct mu_auth_data *auth = mu_get_auth_by_uid (geteuid ());
      if (!auth)
 return ((void *)0);
      homedir = strdup (auth->dir);
      mu_auth_data_free (auth);
    }
  return homedir;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 4
7 4
8 15
9 5
10 15
11 15
12 5
13 5
14 8
15 8
16 8
17 9
18 8
19 9
20 11
21 11
22 12
23 11
24 12
25 11
26 15
27 15
28 15
29 15
30 10
31 10
32 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     2ac0 <gsl_sort_vector_char_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab5 <gsl_sort_vector_char_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  2ad1 <gsl_sort_vector_char_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_char_index (gsl_permutation * permutation, const gsl_vector_char * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_char_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,%rax
mov    %edi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  a7f <smtp_reply_get+0x1f>
add    $0x18,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_reply_get (int method, NET_STREAM sd, ANUBIS_SMTP_REPLY reply)
{
  struct net_reader_closure clos;
  clos.method = method;
  clos.stream = sd;
  smtp_reply_read (reply, _net_reader, &clos);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 6
6 6
7 6
8 6
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # df6 <gsl_vector_ushort_const_ptr+0x6>
test   %eax,%eax
je     dff <gsl_vector_ushort_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    e10 <gsl_vector_ushort_const_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e2d <gsl_vector_ushort_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_const_ptr (const gsl_vector_ushort * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_ushort.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const unsigned short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
sub    $0x38,%rsp
movzbl %r9b,%r9d
movzbl %r8b,%r8d
mov    0x40(%rsp),%rax
movzbl %cl,%ecx
mov    %r9d,0x18(%rsp)
mov    %r8d,0x10(%rsp)
mov    %ecx,0x8(%rsp)
xor    %r9d,%r9d
movq   $0x0,(%rsp)
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %rax,0x20(%rsp)
callq  0 <create_pipe>
add    $0x38,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_pipe_bidi (const char *progname,
                  const char *prog_path, char **prog_argv,
                  _Bool null_stderr,
                  _Bool slave_process, _Bool exit_on_error,
                  int fd[2])
{
  pid_t result = create_pipe (progname, prog_path, prog_argv,
                              1, 1, ((void *)0), ((void *)0),
                              null_stderr, slave_process, exit_on_error,
                              fd);
  return result;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 12
16 12
17 12
<<<sep_out_sample>>>
test   %r8,%r8
je     50 <gsl_stats_long_double_wmean+0x50>
fldz   
shl    $0x4,%rsi
shl    $0x4,%rcx
xor    %eax,%eax
fld    %st(0)
fld    %st(1)
nopl   (%rax)
fldt   (%rdi)
fucomi %st(3),%st
jbe    30 <gsl_stats_long_double_wmean+0x30>
fadd   %st,%st(2)
fldt   (%rdx)
fsub   %st(2),%st
fxch   %st(1)
fdiv   %st(3),%st
fmulp  %st,%st(1)
faddp  %st,%st(1)
jmp    32 <gsl_stats_long_double_wmean+0x32>
xchg   %ax,%ax
fstp   %st(0)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    18 <gsl_stats_long_double_wmean+0x18>
fstp   %st(1)
fstp   %st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_wmean (const long double w[], const size_t wstride, const long double data[], const size_t stride, const size_t size)
{
  long double wmean = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      long double wi = w[i * wstride];
      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 4
5 12
6 6
7 4
8 3
9 3
10 8
11 9
12 9
13 11
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 16
35 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     73 <mu_charset_lookup+0x73>
mov    0x0(%rip),%rdi        # 15 <mu_charset_lookup+0x15>
movq   $0x0,0x0(%rip)        # 20 <mu_charset_lookup+0x20>
test   %rdi,%rdi
je     73 <mu_charset_lookup+0x73>
test   %rsi,%rsi
mov    %rsi,%rbp
je     ac <mu_charset_lookup+0xac>
nopl   (%rax)
mov    %rbx,%rsi
callq  38 <mu_charset_lookup+0x38>
test   %eax,%eax
jne    58 <mu_charset_lookup+0x58>
mov    0x0(%rip),%rax        # 43 <mu_charset_lookup+0x43>
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     87 <mu_charset_lookup+0x87>
mov    %rbp,%rsi
callq  54 <mu_charset_lookup+0x54>
test   %eax,%eax
jne    80 <mu_charset_lookup+0x80>
mov    0x0(%rip),%rax        # 5f <mu_charset_lookup+0x5f>
mov    0x18(%rax),%rdi
lea    0x18(%rax),%rdx
mov    %rdx,0x0(%rip)        # 6e <mu_charset_lookup+0x6e>
test   %rdi,%rdi
jne    30 <mu_charset_lookup+0x30>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 87 <mu_charset_lookup+0x87>
mov    0x10(%rax),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x18(%rax),%rdi
lea    0x18(%rax),%rdx
mov    %rdx,0x0(%rip)        # a7 <mu_charset_lookup+0xa7>
test   %rdi,%rdi
je     73 <mu_charset_lookup+0x73>
mov    %rbx,%rsi
callq  b4 <mu_charset_lookup+0xb4>
test   %eax,%eax
mov    0x0(%rip),%rax        # bd <mu_charset_lookup+0xbd>
jne    98 <mu_charset_lookup+0x98>
jmp    87 <mu_charset_lookup+0x87>
<<<sep_in_sample>>>
mu_charset_lookup (char *lang, char *terr)
{
  static struct langtab *p;
  if (!lang)
    return ((void *)0);
  for (p = langtab; p->lang; p++)
    if (mu_c_strcasecmp (p->lang, lang) == 0
 && (terr == ((void *)0)
     || p->terr == ((void *)0)
     || !mu_c_strcasecmp (p->terr, terr) == 0))
      return p->charset;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 6
28 6
29 6
30 6
31 6
32 6
33 13
34 5
35 13
36 13
37 13
38 13
39 13
40 11
41 13
42 13
43 13
44 13
45 13
46 6
47 6
48 6
49 6
50 6
51 7
52 7
53 7
54 7
55 7
56 7
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm2        # 10 <gsl_cdf_rayleigh_P+0x10>
movapd %xmm2,(%rsp)
movapd %xmm0,%xmm1
xorpd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 29 <gsl_cdf_rayleigh_P+0x29>
movapd %xmm1,%xmm0
callq  32 <gsl_cdf_rayleigh_P+0x32>
movapd (%rsp),%xmm2
add    $0x18,%rsp
xorpd  %xmm2,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_rayleigh_P (const double x, const double sigma)
{
  double u = x / sigma;
  double P = -expm1 (-u*u/2);
  return P;
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 4
14 6
<<<sep_out_sample>>>
mov    0x2278(%rdi),%rax
test   %rax,%rax
je     10 <VSetClipRect+0x10>
jmpq   *%rax
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
VSetClipRect (Viewport *v, int x1, int y1, int x2, int y2)
{
  if (v->SetClipRect) {
    v->SetClipRect(v, x1, y1, x2, y2);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_diagonal (gsl_matrix_int * m)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_int v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 29d6 <java_get_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_get_debug (void)
{
        return java__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   $0x1,%dil
mov    $0x68,%edx
jne    1280 <nettle_gosthash94_init+0x50>
test   $0x2,%dil
jne    1290 <nettle_gosthash94_init+0x60>
test   $0x4,%dil
jne    12a8 <nettle_gosthash94_init+0x78>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     1260 <nettle_gosthash94_init+0x30>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     126f <nettle_gosthash94_init+0x3f>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     1277 <nettle_gosthash94_init+0x47>
movb   $0x0,(%rdi)
repz retq 
nopl   0x0(%rax)
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0x67,%dl
test   $0x2,%dil
je     1241 <nettle_gosthash94_init+0x11>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     1247 <nettle_gosthash94_init+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    1247 <nettle_gosthash94_init+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gosthash94_init (struct gosthash94_ctx *ctx)
{
    memset (ctx, 0, sizeof (struct gosthash94_ctx));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     d14 <gsl_vector_long_double_scale+0x34>
movsd  %xmm0,-0x10(%rsp)
mov    0x10(%rdi),%rax
shl    $0x4,%rsi
xor    %edx,%edx
fldl   -0x10(%rsp)
fldt   (%rax)
add    $0x1,%rdx
fmul   %st(1),%st
fstpt  (%rax)
add    %rsi,%rax
cmp    %rcx,%rdx
jne    d00 <gsl_vector_long_double_scale+0x20>
fstp   %st(0)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_scale (gsl_vector_long_double * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 6
12 8
13 8
14 8
15 6
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
mov    (%rdi),%rax
cmp    0x8(%rsi),%rax
je     258 <gsl_multiroot_fsolver_set+0x38>
mov    $0x13,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  24a <gsl_multiroot_fsolver_set+0x2a>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
cmp    (%rdx),%rax
je     280 <gsl_multiroot_fsolver_set+0x60>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  276 <gsl_multiroot_fsolver_set+0x56>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   (%rax)
mov    %rsi,0x8(%rbx)
mov    %rdx,%rsi
callq  28c <gsl_multiroot_fsolver_set+0x6c>
mov    (%rbx),%rax
mov    0x18(%rbx),%rcx
mov    0x10(%rbx),%rdx
mov    0x8(%rbx),%rsi
mov    0x28(%rbx),%rdi
mov    0x20(%rbx),%r8
pop    %rbx
mov    0x18(%rax),%rax
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fsolver_set (gsl_multiroot_fsolver * s,
                           gsl_multiroot_function * f,
                           const gsl_vector * x)
{
  if (s->x->size != f->n)
    {
      do { gsl_error ("function incompatible with solver size", "fsolver.c", 110, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  if (x->size != f->n)
    {
      do { gsl_error ("vector length not compatible with function", "fsolver.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  s->function = f;
  gsl_vector_memcpy(s->x,x);
  return (s->type->set) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 16
13 16
14 16
15 16
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 16
24 16
25 16
26 16
27 13
28 14
29 14
30 15
31 15
32 15
33 15
34 15
35 15
36 16
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  f1 <suffix+0x11>
cmp    $0x2,%eax
jg     120 <suffix+0x40>
mov    0x0(%rip),%rdi        # fd <suffix+0x1d>
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  10c <suffix+0x2c>
mov    $0x1,%edi
callq  116 <suffix+0x36>
nopw   %cs:0x0(%rax,%rax,1)
movslq %eax,%rdx
mov    $0x0,%edi
mov    $0x3,%ecx
lea    -0x2(%rbx,%rdx,1),%r8
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     170 <suffix+0x90>
cmp    $0x4,%eax
jle    f6 <suffix+0x16>
lea    -0x4(%rbx,%rdx,1),%rax
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    f6 <suffix+0x16>
movb   $0x0,(%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   168 <suffix+0x88>
nopl   0x0(%rax,%rax,1)
movb   $0x0,(%r8)
jmp    157 <suffix+0x77>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
suffix(char name[], char suff[])
{
  int n;
  n = strlen(name);
  if (n > 2 && !strcmp(name + n - 2, ".c"))
    {
      name[n - 2] = '\0';
      strcat(name, suff);
    }
  else if (n > 4 && !strcmp(name + n - 4, ".sbs"))
    {
      name[n - 4] = '\0';
      strcat(name, suff);
    }
  else
    {
      fprintf(stderr, "dap: name must end in .c or .sbs: %s\n", name);
      exit(1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 17
10 17
11 17
12 17
13 17
14 18
15 18
16 18
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 12
33 20
34 13
35 13
36 20
37 20
38 13
39 13
40 7
41 7
42 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     12e <a_word_hash_1+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    110 <a_word_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
a_word_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct a_word const *) key)->str)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 9a6 <_rl_fix_point+0x6>
mov    0x0(%rip),%eax        # 9ac <_rl_fix_point+0xc>
cmp    %eax,%edx
jle    9d0 <_rl_fix_point+0x30>
mov    %eax,0x0(%rip)        # 9b6 <_rl_fix_point+0x16>
test   %edi,%edi
je     9c8 <_rl_fix_point+0x28>
mov    0x0(%rip),%edx        # 9c0 <_rl_fix_point+0x20>
cmp    %edx,%eax
jl     9e0 <_rl_fix_point+0x40>
test   %edx,%edx
js     9f0 <_rl_fix_point+0x50>
repz retq 
nopw   0x0(%rax,%rax,1)
test   %edx,%edx
jns    9b6 <_rl_fix_point+0x16>
movl   $0x0,0x0(%rip)        # 9de <_rl_fix_point+0x3e>
jmp    9b6 <_rl_fix_point+0x16>
mov    %eax,0x0(%rip)        # 9e6 <_rl_fix_point+0x46>
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 9fa <_rl_fix_point+0x5a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  do { if (rl_point > rl_end) rl_point = rl_end; else if (rl_point < 0) rl_point = 0; } while (0);
  if (fix_mark_too)
    do { if (rl_mark > rl_end) rl_mark = rl_end; else if (rl_mark < 0) rl_mark = 0; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x600,%rsp
movswl 0x2(%rdi),%eax
mov    0x20(%rdi),%rdi
test   %eax,%eax
lea    -0x1(%rax),%esi
jle    c2 <VGetPlanes+0xc2>
mov    %esi,%edx
mov    %rsp,%rcx
xor    %r8d,%r8d
lea    0x3(%rdx,%rdx,2),%rdx
lea    (%rdi,%rdx,8),%r10
mov    %rdi,%rdx
jmp    3e <VGetPlanes+0x3e>
nopl   0x0(%rax)
mov    %r8d,%esi
mov    %r9d,%r8d
movslq %esi,%rsi
movsd  0x8(%rdx),%xmm3
lea    (%rsi,%rsi,2),%rsi
movsd  0x10(%rdx),%xmm1
movapd %xmm3,%xmm2
add    $0x18,%rdx
lea    (%rdi,%rsi,8),%rsi
movapd %xmm1,%xmm0
add    $0x18,%rcx
lea    0x1(%r8),%r9d
movsd  0x10(%rsi),%xmm5
movsd  0x8(%rsi),%xmm4
mulsd  %xmm5,%xmm2
mulsd  %xmm4,%xmm0
subsd  %xmm0,%xmm2
movsd  -0x18(%rdx),%xmm0
mulsd  %xmm0,%xmm5
mulsd  %xmm4,%xmm0
movsd  %xmm2,-0x18(%rcx)
movsd  (%rsi),%xmm2
mulsd  %xmm2,%xmm1
mulsd  %xmm3,%xmm2
subsd  %xmm5,%xmm1
subsd  %xmm2,%xmm0
movsd  %xmm1,-0x10(%rcx)
movsd  %xmm0,-0x8(%rcx)
cmp    %r10,%rdx
jne    38 <VGetPlanes+0x38>
lea    (%rax,%rax,2),%rdx
mov    %rsp,%rsi
shl    $0x3,%rdx
callq  c2 <VGetPlanes+0xc2>
add    $0x600,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
VGetPlanes(VPolygon * poly)
{
 VPoint tmp[64], *p;
 int i, lasti;
 lasti = poly->numVtces - 1;
 p = poly->vertex;
 for (i = 0; i < poly->numVtces; ++i) {
  tmp[i].x = p->y * poly->vertex[lasti].z - p->z *
   poly->vertex[lasti].y;
  tmp[i].y = p->z * poly->vertex[lasti].x - p->x *
   poly->vertex[lasti].z;
  tmp[i].z = p->x * poly->vertex[lasti].y - p->y *
   poly->vertex[lasti].x;
  lasti = i;
  p++;
 }
 for (i = 0; i < poly->numVtces; ++i)
  poly->vertex[i] = tmp[i];
 return poly;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 6
6 7
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 15
25 8
26 8
27 8
28 7
29 8
30 9
31 8
32 8
33 8
34 10
35 10
36 12
37 8
38 10
39 10
40 12
41 10
42 12
43 10
44 12
45 7
46 7
47 18
48 18
49 18
50 18
51 20
52 20
53 20
54 20
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm8        # 4b9 <hyperg_1F1_1_series+0x9>
xorpd  %xmm9,%xmm9
movapd %xmm8,%xmm7
movapd %xmm8,%xmm2
movapd %xmm8,%xmm3
movsd  0x0(%rip),%xmm6        # 4d5 <hyperg_1F1_1_series+0x25>
movsd  0x0(%rip),%xmm13        # 4de <hyperg_1F1_1_series+0x2e>
movsd  0x0(%rip),%xmm12        # 4e7 <hyperg_1F1_1_series+0x37>
movsd  0x0(%rip),%xmm11        # 4f0 <hyperg_1F1_1_series+0x40>
movapd %xmm0,%xmm4
movapd %xmm1,%xmm5
addsd  %xmm7,%xmm4
addsd  %xmm8,%xmm7
subsd  %xmm8,%xmm4
divsd  %xmm4,%xmm5
mulsd  %xmm5,%xmm2
addsd  %xmm2,%xmm3
movapd %xmm2,%xmm10
andpd  %xmm6,%xmm10
movapd %xmm3,%xmm5
movapd %xmm10,%xmm4
andpd  %xmm6,%xmm5
mulsd  %xmm13,%xmm4
mulsd  %xmm12,%xmm5
addsd  %xmm5,%xmm4
addsd  %xmm4,%xmm9
movapd %xmm2,%xmm4
divsd  %xmm3,%xmm4
andpd  %xmm6,%xmm4
ucomisd %xmm11,%xmm4
ja     4f0 <hyperg_1F1_1_series+0x40>
addsd  %xmm10,%xmm10
movsd  %xmm3,(%rdi)
xor    %eax,%eax
addsd  %xmm9,%xmm10
movsd  %xmm10,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hyperg_1F1_1_series(const double b, const double x, gsl_sf_result * result)
{
  double sum_val = 1.0;
  double sum_err = 0.0;
  double term = 1.0;
  double n = 1.0;
  while(fabs(term/sum_val) > 0.25*2.2204460492503131e-16) {
    term *= x/(b+n-1);
    sum_val += term;
    sum_err += 8.0*2.2204460492503131e-16*fabs(term) + 2.2204460492503131e-16*fabs(sum_val);
    n += 1.0;
  }
  result->val = sum_val;
  result->err = sum_err;
  result->err += 2.0 * fabs(term);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 5
5 3
6 3
7 3
8 3
9 3
10 8
11 8
12 8
13 11
14 8
15 8
16 8
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 7
28 7
29 7
30 7
31 7
32 15
33 13
34 17
35 15
36 15
37 17
38 17
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    %rdx,%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdx
mov    (%rdi),%rdi
jmpq   2b6 <gsl_spline_eval_deriv2_e+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline_eval_deriv2_e (const gsl_spline * spline,
                          double x,
                          gsl_interp_accel * a,
                          double * d2)
{
  return gsl_interp_eval_deriv2_e (spline->interp,
                                   spline->x, spline->y,
                                   x, a, d2);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
cmp    %esi,%eax
jb     70 <xdrumem_inline+0x20>
sub    %esi,%eax
movslq %esi,%rsi
mov    %eax,0x28(%rdi)
mov    0x18(%rdi),%rax
add    %rax,%rsi
mov    %rsi,0x18(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdrumem_inline(register XDR * xdrs, int len)
{
 long *buf = 0;
 if (xdrs->x_handy >= len) {
  xdrs->x_handy -= len;
  buf = (long *) xdrs->x_private;
  xdrs->x_private += len;
 }
 return (buf);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 7
6 5
7 6
8 7
9 7
10 7
11 7
12 3
13 10
14 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     10 <cdio_stream_close+0x10>
mov    0x38(%rdi),%eax
test   %eax,%eax
jne    18 <cdio_stream_close+0x18>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
xor    %eax,%eax
callq  24 <cdio_stream_close+0x24>
mov    (%rbx),%rdi
callq  *0x28(%rbx)
movl   $0x0,0x38(%rbx)
movq   $0x0,0x40(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_stream_close(CdioDataSource_t *p_obj)
{
  if (!p_obj) return;
  if (p_obj->is_open) {
    cdio_debug ("closed source...");
    p_obj->op.close(p_obj->user_data);
    p_obj->is_open = 0;
    p_obj->position = 0;
  }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 10
9 10
10 10
11 5
12 5
13 5
14 6
15 6
16 7
17 8
18 10
19 10
20 10
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
push   %r12
push   %rbp
mov    %r8d,%ebp
push   %rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 237 <findlev+0x17>
lea    (%rax,%rax,2),%r8
shl    $0x5,%r8
mov    0x0(%r8),%rax
mov    (%rax,%rdi,4),%eax
cmp    $0xffffffff,%eax
je     2f0 <findlev+0xd0>
test   %eax,%eax
jne    2a0 <findlev+0x80>
test   %ebp,%ebp
mov    $0xffffffff,%eax
jle    2dd <findlev+0xbd>
mov    0x0(%r8),%rax
mov    (%rax,%rdi,4),%eax
cmp    (%rdx),%eax
je     332 <findlev+0x112>
add    $0x4,%rdx
xor    %ebx,%ebx
jmp    289 <findlev+0x69>
nopl   0x0(%rax)
add    $0x4,%rdx
cmp    %eax,-0x4(%rdx)
je     2db <findlev+0xbb>
add    $0x1,%ebx
cmp    %ebp,%ebx
jne    280 <findlev+0x60>
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
test   %ebp,%ebp
jle    290 <findlev+0x70>
mov    0x0(%r8),%rax
mov    %rcx,%r12
xor    %ebx,%ebx
mov    (%rax,%rdi,8),%r13
jmp    2cb <findlev+0xab>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%ebx
add    $0x8,%r12
cmp    %ebp,%ebx
je     290 <findlev+0x70>
mov    (%r12),%rsi
mov    %r13,%rdi
callq  2d7 <findlev+0xb7>
test   %eax,%eax
jne    2c0 <findlev+0xa0>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
test   %ebp,%ebp
jle    2dd <findlev+0xbd>
mov    0x0(%r8),%rdx
movsd  (%rdx,%rdi,8),%xmm0
ucomisd (%rsi),%xmm0
jnp    326 <findlev+0x106>
add    $0x8,%rsi
xor    %ebx,%ebx
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    %ebp,%ebx
je     2dd <findlev+0xbd>
add    $0x8,%rsi
ucomisd -0x8(%rsi),%xmm0
jp     310 <findlev+0xf0>
jne    310 <findlev+0xf0>
jmp    2db <findlev+0xbb>
nopw   %cs:0x0(%rax,%rax,1)
jne    306 <findlev+0xe6>
xor    %ebx,%ebx
jmp    2db <findlev+0xbb>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findlev(int class, double dlevel[], int ilevel[], char *slevel[], int nlevels)
{
  int v;
  if (dap_obs[dap_ono].do_len[class] == (-1))
    {
      for (v = 0; v < nlevels; v++)
 {
   if (dap_obs[dap_ono].do_dbl[class] ==
       dlevel[v])
     break;
 }
    }
  else if (dap_obs[dap_ono].do_len[class] == 0)
    {
      for (v = 0; v < nlevels; v++)
 {
   if (dap_obs[dap_ono].do_int[class] ==
       ilevel[v])
     break;
 }
    }
  else
    {
      for (v = 0; v < nlevels; v++)
 {
   if (!strcmp(dap_obs[dap_ono].do_str[class],
        slevel[v]))
     break;
 }
    }
  if (v < nlevels)
    return v;
  return -1;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 13
16 13
17 15
18 33
19 15
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 15
32 15
33 15
34 34
35 33
36 34
37 34
38 34
39 34
40 34
41 24
42 24
43 24
44 24
45 24
46 24
47 24
48 24
49 24
50 24
51 24
52 24
53 26
54 26
55 26
56 26
57 26
58 24
59 34
60 34
61 34
62 34
63 34
64 34
65 34
66 6
67 6
68 8
69 8
70 8
71 8
72 8
73 8
74 8
75 6
76 6
77 6
78 6
79 8
80 8
81 8
82 8
83 8
84 8
85 17
86 17
87 17
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 18 <close_stdin+0x8>
mov    %rbx,%rdi
callq  20 <close_stdin+0x10>
test   %rax,%rax
mov    %rbx,%rdi
jne    80 <close_stdin+0x70>
callq  2d <close_stdin+0x1d>
test   %eax,%eax
je     b2 <close_stdin+0xa2>
nopl   (%rax)
mov    0x0(%rip),%rdi        # 3f <close_stdin+0x2f>
test   %rdi,%rdi
je     c0 <close_stdin+0xb0>
callq  49 <close_stdin+0x39>
mov    %rax,%rbx
callq  51 <close_stdin+0x41>
mov    (%rax),%esi
mov    $0x0,%r8d
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  6a <close_stdin+0x5a>
callq  6f <close_stdin+0x5f>
mov    0x0(%rip),%edi        # 75 <close_stdin+0x65>
callq  7a <close_stdin+0x6a>
nopw   0x0(%rax,%rax,1)
xor    %esi,%esi
mov    $0x1,%edx
callq  8c <close_stdin+0x7c>
test   %eax,%eax
mov    0x0(%rip),%rdi        # 95 <close_stdin+0x85>
jne    28 <close_stdin+0x18>
callq  9c <close_stdin+0x8c>
mov    0x0(%rip),%rdi        # a3 <close_stdin+0x93>
mov    %eax,%ebx
callq  aa <close_stdin+0x9a>
test   %eax,%eax
jne    38 <close_stdin+0x28>
test   %ebx,%ebx
jne    38 <close_stdin+0x28>
pop    %rbx
jmpq   b8 <close_stdin+0xa8>
nopl   0x0(%rax,%rax,1)
callq  c5 <close_stdin+0xb5>
mov    (%rax),%esi
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  da <close_stdin+0xca>
jmp    6a <close_stdin+0x5a>
<<<sep_in_sample>>>
close_stdin (void)
{
  _Bool fail = 0;
  if (freadahead (stdin) > 0)
    {
      if (rpl_fseeko (stdin, 0, 1) == 0 && rpl_fflush (stdin) != 0)
        fail = 1;
    }
  if (close_stream (stdin) != 0)
    fail = 1;
  if (fail)
    {
      char const *close_error = ((const char *) ("error closing file"));
      if (file_name)
        error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
               close_error);
      else
        error (0, (*__errno_location ()), "%s", close_error);
    }
  close_stdout ();
  if (fail)
    _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 14
13 14
14 14
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 15
25 20
26 22
27 22
28 22
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 9
37 6
38 9
39 9
40 9
41 11
42 11
43 23
44 20
45 20
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 18
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     c0 <osip_from_free+0x50>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     87 <osip_from_free+0x17>
callq  87 <osip_from_free+0x17>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     9d <osip_from_free+0x2d>
mov    0x0(%rip),%rax        # 96 <osip_from_free+0x26>
test   %rax,%rax
je     d8 <osip_from_free+0x68>
callq  *%rax
lea    0x10(%rbx),%rdi
callq  a6 <osip_from_free+0x36>
mov    0x0(%rip),%rax        # ad <osip_from_free+0x3d>
mov    %rbx,%rdi
test   %rax,%rax
je     c8 <osip_from_free+0x58>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   d5 <osip_from_free+0x65>
nopl   (%rax)
callq  dd <osip_from_free+0x6d>
jmp    9d <osip_from_free+0x2d>
nop
<<<sep_in_sample>>>
osip_from_free (osip_from_t * from)
{
  if (from == ((void *)0))
    return;
  if (from->url != ((void *)0)) {
    osip_uri_free (from->url);
  }
  { if (from->displayname!=((void *)0)) { if (osip_free_func) osip_free_func(from->displayname); else free(from->displayname);} };
  osip_uri_param_freelist(&from->gen_params);
  { if (from!=((void *)0)) { if (osip_free_func) osip_free_func(from); else free(from);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 10
19 10
20 10
21 10
22 11
23 10
24 10
25 11
26 11
27 11
28 11
29 11
30 10
31 10
32 8
33 8
34 8
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x64,%edx
je     230 <sv_compquery+0x30>
cmpb   $0x0,(%rdi)
je     230 <sv_compquery+0x30>
sub    $0x8,%rsp
callq  218 <sv_compquery+0x18>
xor    %edx,%edx
test   %eax,%eax
cmovns %eax,%edx
xor    %eax,%eax
mov    %edx,0x0(%rip)        # 227 <sv_compquery+0x27>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    %edx,0x0(%rip)        # 236 <sv_compquery+0x36>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sv_compquery (value)
     const char *value;
{
  int nval = 100;
  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
 nval = 0;
    }
  rl_completion_query_items = nval;
  return 0;
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 5
5 5
6 3
7 7
8 7
9 7
10 7
11 13
12 11
13 13
14 13
15 13
16 11
17 13
18 13
19 13
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     3b40 <gsl_block_short_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    (%rcx,%rcx,1),%r14
mov    %rsi,%rbx
jne    3aec <gsl_block_short_raw_fwrite+0x3c>
jmp    3b30 <gsl_block_short_raw_fwrite+0x80>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     3b30 <gsl_block_short_raw_fwrite+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x2,%esi
mov    %rbx,%rdi
callq  3b01 <gsl_block_short_raw_fwrite+0x51>
cmp    $0x1,%rax
je     3ae0 <gsl_block_short_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b20 <gsl_block_short_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x2,%esi
callq  3b4d <gsl_block_short_raw_fwrite+0x9d>
cmp    %r12,%rax
je     3b30 <gsl_block_short_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b6b <gsl_block_short_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    3b25 <gsl_block_short_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_raw_fwrite (FILE * stream, const short * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 1 * sizeof (short), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 1 * i * stride,
                                1 * sizeof (short),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 8 <calcRho+0x8>
ucomisd %xmm0,%xmm1
jae    b8 <calcRho+0xb8>
divsd  0x0(%rip),%xmm0        # 1a <calcRho+0x1a>
movq   $0x0,0x0(%rip)        # 25 <calcRho+0x25>
mov    $0x0,%eax
movsd  0x0(%rip),%xmm1        # 32 <calcRho+0x32>
ucomisd %xmm1,%xmm0
jbe    d1 <calcRho+0xd1>
nopl   0x0(%rax)
mov    %rax,%rdx
add    $0x18,%rax
movsd  (%rax),%xmm1
ucomisd %xmm1,%xmm0
ja     40 <calcRho+0x40>
mov    %rdx,0x0(%rip)        # 58 <calcRho+0x58>
movsd  (%rdx),%xmm2
movapd %xmm0,%xmm5
movsd  0x10(%rdx),%xmm4
movsd  0x28(%rdx),%xmm3
subsd  %xmm2,%xmm1
subsd  %xmm2,%xmm5
subsd  %xmm4,%xmm3
movapd %xmm5,%xmm2
divsd  %xmm1,%xmm3
mulsd  %xmm3,%xmm2
addsd  %xmm4,%xmm2
movsd  %xmm2,(%rdi)
movsd  0x8(%rdx),%xmm3
movsd  0x20(%rdx),%xmm2
subsd  (%rdx),%xmm0
subsd  %xmm3,%xmm2
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
addsd  %xmm3,%xmm0
divsd  0x0(%rip),%xmm0        # b0 <calcRho+0xb0>
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  c7 <calcRho+0xc7>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
mov    $0x0,%edx
jmp    58 <calcRho+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
calcRho(double alt, double *mach)
{
 double deltaAlt, b;
 extern void airProperties(double h, double *rho, double *mach1);
 double rho;
 if (alt <= 60000.0) {
  airProperties(alt, &rho, mach);
  return rho;
 }
 alt = alt / 1000.0;
 for (rhop = rhoTable; alt > (rhop + 1)->alt; ++rhop);
 deltaAlt = (rhop + 1)->alt - rhop->alt;
 b = ((rhop + 1)->mach1 - rhop->mach1) / deltaAlt;
 *mach = rhop->mach1 + b * (alt - rhop->alt);
 b = ((rhop + 1)->rho - rhop->rho) / deltaAlt;
 return (rhop->rho + b * (alt - rhop->alt)) / 10000.0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 10
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 12
18 14
19 13
20 13
21 12
22 14
23 13
24 14
25 13
26 14
27 14
28 14
29 15
30 15
31 16
32 15
33 15
34 16
35 16
36 16
37 16
38 16
39 2
40 7
41 7
42 7
43 8
44 17
45 17
46 11
47 11
48 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    $0xa78,%rdi
jg     860 <__gmpn_hgcd_reduce_itch+0x30>
sub    %rsi,%rdi
callq  84d <__gmpn_hgcd_reduce_itch+0x1d>
lea    -0x1(%rbx,%rbp,1),%rdx
cmp    %rdx,%rax
cmovl  %rdx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
sub    %rsi,%rbx
mov    %rbx,%rdi
callq  86b <__gmpn_hgcd_reduce_itch+0x3b>
add    $0x8,%rsp
lea    (%rax,%rbx,2),%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_hgcd_reduce_itch (mp_size_t n, mp_size_t p)
{
  mp_size_t itch;
  if ((! ((__builtin_constant_p (2681) && (2681) == 0) || (!(__builtin_constant_p (2681) && (2681) == 9223372036854775807L) && (n) >= (2681)))))
    {
      itch = __gmpn_hgcd_itch (n-p);
      if (itch < n + p - 1)
 itch = n + p - 1;
    }
  else
    {
      itch = 2*(n-p) + __gmpn_hgcd_itch (n-p);
    }
  return itch;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 7
11 7
12 7
13 15
14 15
15 15
16 15
17 12
18 12
19 12
20 15
21 12
22 15
23 15
24 15
25 15
<<<sep_out_sample>>>
xor    %r8d,%r8d
test   %rcx,%rcx
lea    0x0(,%rdx,8),%r10
je     1078 <gsl_permute_ulong_inverse+0x78>
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    1029 <gsl_permute_ulong_inverse+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     1020 <gsl_permute_ulong_inverse+0x20>
cmp    %r8,%rax
jb     106f <gsl_permute_ulong_inverse+0x6f>
mov    (%rdi,%rax,8),%rdx
cmp    %r8,%rdx
je     106f <gsl_permute_ulong_inverse+0x6f>
imul   %r10,%rax
mov    (%rsi,%rax,1),%r9
jmp    104b <gsl_permute_ulong_inverse+0x4b>
nopl   0x0(%rax)
mov    %r11,%r9
mov    %r10,%rax
imul   %rdx,%rax
add    %rsi,%rax
mov    (%rax),%r11
mov    %r9,(%rax)
mov    (%rdi,%rdx,8),%rdx
cmp    %rdx,%r8
jne    1048 <gsl_permute_ulong_inverse+0x48>
mov    %r10,%rax
imul   %r8,%rax
mov    %r11,(%rsi,%rax,1)
add    $0x1,%r8
cmp    %rcx,%r8
jne    1010 <gsl_permute_ulong_inverse+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_ulong_inverse (const size_t * p, unsigned long * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned long t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned long r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 18
4 4
5 6
6 7
7 7
8 7
9 8
10 7
11 7
12 9
13 9
14 11
15 12
16 12
17 18
18 18
19 18
20 18
21 23
22 23
23 23
24 23
25 23
26 24
27 28
28 19
29 19
30 31
31 31
32 31
33 4
34 4
35 4
36 35
37 35
38 35
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
control_set_driver_null (void *vstate, const gsl_odeiv2_driver * d)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
movapd %xmm0,%xmm1
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
movsd  %xmm1,0x8(%rsp)
callq  588 <gsl_sf_bessel_Kn_e+0x18>
movsd  0x8(%rsp),%xmm1
mov    %eax,%ebp
movsd  0x0(%rip),%xmm0        # 598 <gsl_sf_bessel_Kn_e+0x28>
xorpd  %xmm1,%xmm0
callq  5a1 <gsl_sf_bessel_Kn_e+0x31>
movsd  (%rbx),%xmm2
mov    %ebp,%eax
movsd  0x8(%rsp),%xmm1
mulsd  %xmm0,%xmm2
mulsd  0x0(%rip),%xmm1        # 5b9 <gsl_sf_bessel_Kn_e+0x49>
movsd  0x0(%rip),%xmm3        # 5c1 <gsl_sf_bessel_Kn_e+0x51>
mulsd  0x8(%rbx),%xmm0
movsd  %xmm2,(%rbx)
andpd  %xmm3,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_bessel_Kn_e(const int n, const double x, gsl_sf_result * result)
{
  const int status = gsl_sf_bessel_Kn_scaled_e(n, x, result);
  const double ex = exp(-x);
  result->val *= ex;
  result->err *= ex;
  result->err += x * 2.2204460492503131e-16 * fabs(result->val);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 3
10 4
11 4
12 4
13 5
14 9
15 7
16 5
17 7
18 7
19 6
20 5
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rax
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rdi),%rdi
mov    %rsp,%rsi
callq  *0x10(%rax)
test   %rax,%rax
mov    %rax,%rbx
jle    7c <read_cb+0x2c>
mov    (%rsp),%rsi
mov    %rax,%rdx
mov    %rbp,%rdi
callq  7c <read_cb+0x2c>
add    $0x18,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_cb (thandle_t ctx,
  tdata_t data,
  tsize_t size)
{
  struct EXTRACTOR_ExtractContext *ec = ctx;
  void *ptr;
  ssize_t ret;
  ret = ec->read (ec->cls, &ptr, size);
  if (ret > 0)
    memcpy (data, ptr, ret);
  return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 9
10 8
11 9
12 10
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
cmp    %r9,%r10
jbe    652 <hash_get_entries+0x62>
xor    %ecx,%ecx
mov    (%r9),%r8
test   %r8,%r8
je     641 <hash_get_entries+0x51>
cmp    %rcx,%rdx
jbe    64a <hash_get_entries+0x5a>
lea    0x1(%rcx),%rax
mov    %r8,(%rsi,%rcx,8)
mov    0x8(%r9),%rcx
test   %rcx,%rcx
je     63a <hash_get_entries+0x4a>
nopl   0x0(%rax)
cmp    %rdx,%rax
je     650 <hash_get_entries+0x60>
mov    (%rcx),%r8
add    $0x1,%rax
mov    %r8,-0x8(%rsi,%rax,8)
mov    0x8(%rcx),%rcx
test   %rcx,%rcx
jne    620 <hash_get_entries+0x30>
mov    0x8(%rdi),%r10
mov    %rax,%rcx
add    $0x10,%r9
cmp    %r10,%r9
jb     5fe <hash_get_entries+0xe>
mov    %rcx,%rax
retq   
xchg   %ax,%ax
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_entries (const Hash_table *table, void **buffer,
                  size_t buffer_size)
{
  size_t counter = 0;
  struct hash_entry const *bucket;
  struct hash_entry const *cursor;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          for (cursor = bucket; cursor; cursor = cursor->next)
            {
              if (counter >= buffer_size)
                return counter;
              buffer[counter++] = cursor->data;
            }
        }
    }
  return counter;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 4
6 9
7 9
8 9
9 13
10 13
11 15
12 15
13 11
14 11
15 11
16 11
17 13
18 13
19 15
20 15
21 15
22 11
23 11
24 11
25 11
26 15
27 7
28 7
29 7
30 13
31 13
32 13
33 20
34 4
35 4
36 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmwrap (void)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     750 <gsl_vector_complex_float_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  745 <gsl_vector_complex_float_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     79a <gsl_vector_complex_float_add+0x7a>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rdx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %ecx,%ecx
nop
movss  (%rax),%xmm0
add    $0x1,%rcx
addss  (%rdx),%xmm0
movss  %xmm0,(%rax)
movss  0x4(%rax),%xmm0
addss  0x4(%rdx),%xmm0
add    %r9,%rdx
movss  %xmm0,0x4(%rax)
add    %r10,%rax
cmp    %r8,%rcx
jne    770 <gsl_vector_complex_float_add+0x50>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_vector_complex_float_add (gsl_vector_complex_float * a, const gsl_vector_complex_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_complex_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[2 * i * stride_a] += b->data[2 * i * stride_b];
          a->data[2 * i * stride_a + 1] += b->data[2 * i * stride_b + 1];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 20
12 20
13 20
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 16
29 16
30 16
31 16
32 16
33 13
34 13
35 18
36 20
37 20
<<<sep_out_sample>>>
sub    $0x18,%rsp
movslq %esi,%rsi
xor    %ecx,%ecx
mov    %rsi,(%rsp)
mov    %rsp,%r8
mov    %rdi,%rsi
xor    %edx,%edx
mov    $0x20,%edi
movq   $0x0,0x8(%rsp)
callq  1038 <empty+0x28>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
empty (fd_set *mask, int sec)
{
  struct timeval t;
  t.tv_sec = (long) sec;
  t.tv_usec = 0;
  return (select (32, mask, (fd_set *) 0, (fd_set *) 0, &t));
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 4
5 6
6 6
7 6
8 6
9 5
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x28,%rsp
movsd  0x0(%rip),%xmm2        # 2c8c <sturf+0xc>
ucomisd %xmm2,%xmm0
jnp    2df8 <sturf+0x178>
xorpd  %xmm6,%xmm6
subsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm1        # 2ca6 <sturf+0x26>
movapd %xmm0,%xmm3
ucomisd %xmm6,%xmm1
divsd  %xmm2,%xmm3
jnp    2d80 <sturf+0x100>
movapd %xmm3,%xmm0
movsd  %xmm1,0x18(%rsp)
movsd  %xmm3,0x8(%rsp)
movsd  %xmm2,0x10(%rsp)
callq  2cd3 <sturf+0x53>
movsd  0x18(%rsp),%xmm1
movsd  0x8(%rsp),%xmm3
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 2ceb <sturf+0x6b>
movsd  0x0(%rip),%xmm4        # 2cf3 <sturf+0x73>
mulsd  0x0(%rip),%xmm1        # 2cfb <sturf+0x7b>
movsd  0x0(%rip),%xmm5        # 2d03 <sturf+0x83>
mulsd  %xmm3,%xmm1
mulsd  %xmm3,%xmm1
divsd  0x0(%rip),%xmm1        # 2d13 <sturf+0x93>
subsd  %xmm1,%xmm0
xorpd  %xmm1,%xmm1
andpd  %xmm0,%xmm4
ucomisd %xmm4,%xmm5
jb     2d6d <sturf+0xed>
movsd  %xmm3,0x18(%rsp)
callq  2d30 <sturf+0xb0>
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm3        # 2d44 <sturf+0xc4>
movsd  0x0(%rip),%xmm0        # 2d4c <sturf+0xcc>
mulsd  %xmm3,%xmm0
callq  14f0 <range>
movsd  0x8(%rsp),%xmm1
movsd  0x10(%rsp),%xmm2
mulsd  %xmm0,%xmm1
mulsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
movapd %xmm1,%xmm0
add    $0x28,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
jne    2cb8 <sturf+0x38>
movsd  0x0(%rip),%xmm0        # 2d8e <sturf+0x10e>
movsd  %xmm2,0x18(%rsp)
mulsd  %xmm3,%xmm0
movsd  %xmm3,0x10(%rsp)
mulsd  %xmm3,%xmm0
divsd  0x0(%rip),%xmm0        # 2daa <sturf+0x12a>
callq  2daf <sturf+0x12f>
movsd  0x10(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm3        # 2dc3 <sturf+0x143>
movsd  0x0(%rip),%xmm0        # 2dcb <sturf+0x14b>
mulsd  %xmm3,%xmm0
callq  14f0 <range>
movsd  0x8(%rsp),%xmm1
movsd  0x18(%rsp),%xmm2
add    $0x28,%rsp
mulsd  %xmm0,%xmm1
mulsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
movapd %xmm1,%xmm0
retq   
nopl   (%rax)
xorpd  %xmm1,%xmm1
jne    2c96 <sturf+0x16>
movapd %xmm1,%xmm0
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sturf(double s0)
{
  double s;
  double s1;
  double tmp;
  if (s0 == 1.0)
    return 0.0;
  s1 = 1.0 - s0;
  s = s0 / s1;
  if (dendfm1 == 0.0)
    return exp(-0.5 * s * s / 2.7182818284590450908) * range(pt * s * 0.60653065971263343973) / (s1 * s1);
  tmp = dendfm1 * log(s) - 0.5 * ddendf * s * s / 2.7182818284590450908;
  if (finite(tmp))
    return exp(tmp) * range(pt * s * 0.60653065971263343973) / (s1 * s1);
  return 0.0;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 10
6 8
7 10
8 9
9 10
10 9
11 10
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 13
22 12
23 13
24 12
25 12
26 12
27 12
28 15
29 13
30 13
31 13
32 13
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 16
46 16
47 16
48 16
49 10
50 11
51 11
52 11
53 11
54 11
55 11
56 11
57 11
58 11
59 11
60 11
61 11
62 11
63 11
64 11
65 16
66 11
67 11
68 11
69 16
70 16
71 16
72 7
73 6
74 16
75 16
76 16
77 16
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1951 <gsl_matrix_uint_fwrite+0x91>
lea    0x0(,%r15,4),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    190e <gsl_matrix_uint_fwrite+0x4e>
jmp    1940 <gsl_matrix_uint_fwrite+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1940 <gsl_matrix_uint_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1925 <gsl_matrix_uint_fwrite+0x65>
test   %eax,%eax
je     1900 <gsl_matrix_uint_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1974 <gsl_matrix_uint_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_fwrite (FILE * stream, const gsl_matrix_uint * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uint_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uint_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
test   %eax,%eax
je     2f0 <output_char+0x10>
repz retq 
nopl   0x0(%rax)
mov    0x8(%rdi),%rdi
movsbl %sil,%esi
jmpq   2fd <output_char+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
output_char (struct output * out, unsigned char c)
{
  if (out->to_void)
    return;
  ds_strccat (out->chunk, c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 5
<<<sep_out_sample>>>
test   %esi,%esi
jle    1180 <lm_dont+0x10>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   118a <lm_dont+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_dont (unsigned char *cmd, int len)
{
  if (len < 1)
    {
             printf ("lm_dont: no command!!!\n");
      return;
    }
  switch (cmd[0])
    {
    case 2:
    default:
      break;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
xor    %edx,%edx
mov    %rsi,%rcx
test   %rsi,%rsi
setg   %dl
shr    $0x3f,%rcx
sub    %ecx,%edx
movslq %eax,%rcx
cmp    %eax,%edx
jne    48 <__gmpz_cmp_si+0x48>
test   %rcx,%rcx
je     48 <__gmpz_cmp_si+0x48>
mov    0x8(%rdi),%rdx
mov    (%rdx),%rcx
mov    %rsi,%rdx
sar    $0x3f,%rdx
xor    %rdx,%rsi
sub    %rdx,%rsi
cmp    %rcx,%rsi
je     50 <__gmpz_cmp_si+0x50>
mov    %eax,%edx
neg    %edx
cmp    %rcx,%rsi
cmovae %edx,%eax
retq   
nopl   0x0(%rax)
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
__gmpz_cmp_si (mpz_srcptr u, signed long int v_digit)
{
  mp_size_t vsize, usize;
  usize = ((u)->_mp_size);
  vsize = (v_digit > 0) - (v_digit < 0);
  if ((usize == 0) | (usize != vsize))
    return usize - vsize;
  else {
    mp_limb_t u_digit, absv_digit;
    u_digit = ((u)->_mp_d)[0];
    absv_digit = ((v_digit) >= 0 ? ((unsigned long) (v_digit)) : (- (((unsigned long) ((v_digit) + 1)) - 1)));
    if (u_digit == absv_digit)
      return 0;
    if (u_digit > absv_digit)
      return usize;
    else
      return -usize;
  }
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 10
14 10
15 11
16 11
17 11
18 11
19 12
20 12
21 17
22 17
23 17
24 17
25 17
26 17
27 7
28 7
29 7
30 13
31 19
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  449 <fputs_nl+0x9>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  456 <fputs_nl+0x16>
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fputs_nl(const char *s, FILE *op)
{
 fputs(s, op);
 _IO_putc ('\n', op);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     190 <gsl_eigen_symmv_free+0x40>
mov    0x20(%rdi),%rdi
callq  162 <gsl_eigen_symmv_free+0x12>
mov    0x18(%rbx),%rdi
callq  16b <gsl_eigen_symmv_free+0x1b>
mov    0x10(%rbx),%rdi
callq  174 <gsl_eigen_symmv_free+0x24>
mov    0x8(%rbx),%rdi
callq  17d <gsl_eigen_symmv_free+0x2d>
mov    %rbx,%rdi
pop    %rbx
jmpq   186 <gsl_eigen_symmv_free+0x36>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_symmv_free (gsl_eigen_symmv_workspace * w)
{
  if (!w) { return ; };
  free(w->gs);
  free(w->gc);
  free(w->sd);
  free(w->d);
  free(w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 9
15 8
16 8
17 9
18 9
19 9
<<<sep_out_sample>>>
test   %rdx,%rdx
xorpd  %xmm0,%xmm0
je     3a6 <gsl_stats_char_median_from_sorted_data+0x36>
lea    -0x1(%rdx),%rax
shr    %rdx
shr    %rax
cmp    %rdx,%rax
je     3b0 <gsl_stats_char_median_from_sorted_data+0x40>
imul   %rsi,%rax
imul   %rsi,%rdx
movsbl (%rdi,%rax,1),%ecx
movsbl (%rdi,%rdx,1),%eax
add    %ecx,%eax
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 3a6 <gsl_stats_char_median_from_sorted_data+0x36>
repz retq 
nopl   0x0(%rax,%rax,1)
imul   %rsi,%rax
movsbl (%rdi,%rax,1),%eax
cvtsi2sd %eax,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_char_median_from_sorted_data (const char sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 6
5 7
6 6
7 10
8 10
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 19
17 19
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1aa6 <run_error_trap+0x6>
and    $0x51,%eax
cmp    $0x1,%eax
je     1ab0 <run_error_trap+0x10>
repz retq 
mov    $0x0,%esi
mov    $0x42,%edi
jmpq   260 <_run_trap_internal>
nop
<<<sep_in_sample>>>
run_error_trap ()
{
  if ((sigmodes[65 +1] & 0x1) && ((sigmodes[65 +1] & 0x40) == 0) && (sigmodes[65 +1] & 0x10) == 0)
    _run_trap_internal (65 +1, "error trap");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
<<<sep_out_sample>>>
lea    -0x1(%rsi),%rax
cmp    0x30(%rdi),%rax
jae    29c <gl_array_previous_node+0xc>
repz retq 
push   %rax
callq  2a2 <gl_array_previous_node+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_previous_node (gl_list_t list, gl_list_node_t node)
{
  unsigned long index = ((unsigned long)(node) - 1);
  if (!(index < list->count))
    abort ();
  if (index > 0)
    return (gl_list_node_t)(unsigned long)(size_t)((index - 1) + 1);
  else
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 10
5 2
6 5
7 5
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
cmp    $0x2,%edi
je     24 <main+0x24>
mov    (%rsi),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  19 <main+0x19>
mov    $0x1,%eax
add    $0x20,%rsp
pop    %rbx
retq   
mov    0x8(%rsi),%rdi
callq  2d <main+0x2d>
xor    %ecx,%ecx
movzwl %ax,%esi
xor    %edx,%edx
xor    %eax,%eax
movl   $0x0,0x10(%rsp)
movl   $0x78,0x8(%rsp)
movl   $0x3,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x9,%edi
callq  63 <main+0x63>
test   %rax,%rax
mov    %rax,%rbx
je     83 <main+0x83>
mov    0x0(%rip),%rdi        # 72 <main+0x72>
callq  77 <main+0x77>
mov    %rbx,%rdi
callq  7f <main+0x7f>
xor    %eax,%eax
jmp    1e <main+0x1e>
mov    $0x1,%eax
jmp    1e <main+0x1e>
<<<sep_in_sample>>>
main (int argc, char *const *argv)
{
  struct MHD_Daemon *d;
  if (argc != 2)
    {
      printf ("%s PORT\n", argv[0]);
      return 1;
    }
  d = MHD_start_daemon (
   MHD_USE_SELECT_INTERNALLY | MHD_USE_DEBUG,
                        atoi (argv[1]),
                        ((void *)0), ((void *)0), &ahc_echo, "<html><head><title>libmicrohttpd demo</title></head><body>libmicrohttpd demo</body></html>",
   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,
   MHD_OPTION_END);
  if (d == ((void *)0))
    return 1;
  (void) _IO_getc (stdin);
  MHD_stop_daemon (d);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 20
11 20
12 20
13 11
14 11
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 15
27 9
28 15
29 17
30 17
31 18
32 18
33 19
34 19
35 16
36 16
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 29f <do_para_begin+0xf>
mov    0x20(%rax),%rbx
cmp    0x8(%rax),%rbx
je     2d1 <do_para_begin+0x41>
mov    %rbx,%rdx
jmp    2b4 <do_para_begin+0x24>
xchg   %ax,%ax
mov    0x20(%rax),%rdx
mov    0x18(%rdx),%rdi
subq   $0x1,0x40(%rax)
mov    %rdi,0x20(%rax)
callq  2c6 <do_para_begin+0x36>
test   %al,%al
mov    0x0(%rip),%rax        # 2cf <do_para_begin+0x3f>
je     2b0 <do_para_begin+0x20>
test   %bpl,%bpl
movq   $0x0,0x30(%rax)
jne    2e8 <do_para_begin+0x58>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   2f6 <do_para_begin+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_para_begin(_Bool allow_update)
{
    filestruct *current_save = openfile->current;
    if (openfile->current != openfile->fileage) {
 do {
     openfile->current = openfile->current->prev;
     openfile->current_y--;
 } while (!begpar(openfile->current));
    }
    openfile->current_x = 0;
    if (allow_update)
 edit_redraw(current_save);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 7
15 6
16 8
17 8
18 8
19 8
20 11
21 10
22 11
23 13
24 13
25 13
26 13
27 13
28 13
29 12
30 13
31 13
32 12
33 12
<<<sep_out_sample>>>
mov    (%rcx),%rax
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  void (**addfnptr) (struct exclude *, char const *, int) = data;
  (*addfnptr) (ex, pattern, options);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
movzwl %r9w,%ebp
push   %rbx
sub    $0x18,%rsp
cmp    $0xffff,%r9w
je     14f <VdbeFillRectangle+0x7f>
cmp    0x2288(%rdi),%rbp
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%r13d
mov    %ecx,%r14d
mov    0x168(%rdi),%r15
je     12c <VdbeFillRectangle+0x5c>
mov    0x170(%rdi),%rsi
mov    0x148(%rdi),%rdi
mov    %rbp,%rdx
mov    %r8d,0xc(%rsp)
callq  120 <VdbeFillRectangle+0x50>
mov    0xc(%rsp),%r8d
mov    %rbp,0x2288(%rbx)
mov    0x170(%rbx),%rdx
mov    0x148(%rbx),%rdi
mov    %r14d,%r9d
mov    %r8d,(%rsp)
mov    %r12d,%ecx
mov    %r13d,%r8d
mov    %r15,%rsi
callq  14f <VdbeFillRectangle+0x7f>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
VdbeFillRectangle(Viewport *v,
    int x, int y, int w, int h, Color color)
{
  Drawable d;
  if (color != 0xffff) {
    d = (Drawable) v->dbeDrawable;
    if (color != v->lastPixel) {
      XSetForeground (v->dpy, v->gc, color);
      v->lastPixel = color;
    }
    XFillRectangle(v->dpy, d, v->gc, x, y, w, h);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 6
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0x98(%rsi),%rsi
mov    0x20(%rax),%rax
jmpq   *%rax
<<<sep_in_sample>>>
gsl_multifit_nlinear_rcond (double *rcond, const gsl_multifit_nlinear_workspace * w)
{
  int status = (w->type->rcond) (rcond, w->state);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    %rdi,%rbx
mov    $0x15,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  145b <WriteIncludes+0x1b>
mov    %rbx,%rcx
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1472 <WriteIncludes+0x32>
mov    %rbx,%rcx
mov    $0x12,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1489 <WriteIncludes+0x49>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14a0 <WriteIncludes+0x60>
mov    %rbx,%rcx
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14b7 <WriteIncludes+0x77>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14ce <WriteIncludes+0x8e>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14e5 <WriteIncludes+0xa5>
mov    %rbx,%rcx
mov    $0x16,%edx
mov    $0x1,%esi
pop    %rbx
mov    $0x0,%edi
jmpq   14fd <WriteIncludes+0xbd>
nopl   (%rax)
<<<sep_in_sample>>>
WriteIncludes (PFILE pfile)
{
  fprintf (pfile, "\n#include <stdlib.h>\n");
  fprintf (pfile, "#include <stdio.h>\n");
  fprintf (pfile, "#include <math.h>\n");
  fprintf (pfile, "#include <string.h>\n");
  fprintf (pfile, "#include <float.h>\n");
  fprintf (pfile, "#include \"modelu.h\"\n");
  fprintf (pfile, "#include \"random.h\"\n");
  fprintf (pfile, "#include \"yourcode.h\"\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 8
31 8
32 8
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 11
42 10
43 10
44 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # b <give_usage+0xb>
mov    $0x0,%edi
xor    %eax,%eax
callq  17 <give_usage+0x17>
add    $0x8,%rsp
jmpq   20 <give_usage+0x20>
<<<sep_in_sample>>>
give_usage(void)
{
  printf ("Usage: %s [-hrR] [-n <recs>] <files>\n          [--num <recs>] [--raw] [--reverse] [--help]\n",
          program_name);
  print_wtmp_file_location ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 6
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  16a9 <xdr_dis_repair_type+0x9>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_repair_type(xdrs, objp)
	XDR *xdrs;
	dis_repair_type *objp;
{
	if (!xdr_byte_u_short(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 9
6 5
7 9
8 9
<<<sep_out_sample>>>
jmpq   15 <std_control_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
std_control_free (void *vstate)
{
  std_control_state_t *state = (std_control_state_t *) vstate;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    3238 <gsl_vector_int_set_basis+0x48>
shl    $0x2,%rdi
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     3222 <gsl_vector_int_set_basis+0x32>
xchg   %ax,%ax
add    $0x1,%rax
movl   $0x0,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    3210 <gsl_vector_int_set_basis+0x20>
imul   %rsi,%rdi
xor    %eax,%eax
movl   $0x1,(%r8,%rdi,1)
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3255 <gsl_vector_int_set_basis+0x65>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_set_basis (gsl_vector_int * v, size_t i)
{
  int * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const int zero = 0 ;
  const int one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(int *) (data + 1 * k * stride) = zero;
    }
  *(int *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 13
16 13
17 17
18 18
19 17
20 18
21 18
22 2
23 11
24 11
25 11
26 11
27 11
28 11
29 19
30 19
31 19
<<<sep_out_sample>>>
movl   $0x0,0x30(%rdi)
movl   $0x0,0x34(%rdi)
movzbl 0x3(%rsi),%eax
movzbl 0x2(%rsi),%edx
shl    $0x18,%eax
shl    $0x10,%edx
or     %edx,%eax
movzbl (%rsi),%edx
or     %edx,%eax
movzbl 0x1(%rsi),%edx
shl    $0x8,%edx
or     %edx,%eax
mov    %eax,0x38(%rdi)
movzbl 0x7(%rsi),%eax
movzbl 0x6(%rsi),%edx
shl    $0x18,%eax
shl    $0x10,%edx
or     %edx,%eax
movzbl 0x4(%rsi),%edx
or     %edx,%eax
movzbl 0x5(%rsi),%edx
shl    $0x8,%edx
or     %edx,%eax
mov    %eax,0x3c(%rdi)
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_chacha_set_nonce(struct chacha_ctx *ctx, const uint8_t *nonce)
{
  ctx->state[12] = 0;
  ctx->state[13] = 0;
  ctx->state[14] = ( (((uint32_t) (nonce + 0)[3]) << 24) | (((uint32_t) (nonce + 0)[2]) << 16) | (((uint32_t) (nonce + 0)[1]) << 8) | ((uint32_t) (nonce + 0)[0]));
  ctx->state[15] = ( (((uint32_t) (nonce + 4)[3]) << 24) | (((uint32_t) (nonce + 4)[2]) << 16) | (((uint32_t) (nonce + 4)[1]) << 8) | ((uint32_t) (nonce + 4)[0]));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1c38 <array_reference+0x78>
mov    0x10(%rdi),%eax
test   %eax,%eax
je     1c38 <array_reference+0x78>
cmp    %rsi,0x8(%rdi)
jl     1c38 <array_reference+0x78>
mov    0x0(%rip),%rax        # 1bd9 <array_reference+0x19>
test   %rax,%rax
je     1be3 <array_reference+0x23>
cmp    %rax,%rdi
je     1c40 <array_reference+0x80>
mov    0x18(%rdi),%rdx
mov    0x10(%rdx),%rax
jmp    1bf9 <array_reference+0x39>
nopl   (%rax)
cmp    %rsi,(%rax)
je     1c20 <array_reference+0x60>
mov    0x10(%rax),%rax
cmp    %rax,%rdx
jne    1bf0 <array_reference+0x30>
movq   $0x0,0x0(%rip)        # 1c09 <array_reference+0x49>
movq   $0x0,0x0(%rip)        # 1c14 <array_reference+0x54>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    %rax,0x0(%rip)        # 1c27 <array_reference+0x67>
mov    %rdi,0x0(%rip)        # 1c2e <array_reference+0x6e>
mov    0x8(%rax),%rax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 1c47 <array_reference+0x87>
cmp    (%rax),%rsi
jl     1be3 <array_reference+0x23>
mov    0x18(%rdi),%rdx
jmp    1bf9 <array_reference+0x39>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
array_reference(a, i)
ARRAY *a;
arrayind_t i;
{
 register ARRAY_ELEMENT *ae, *start;
 if (a == 0 || ((a)->num_elements == 0))
  return((char *) ((void *)0));
 if (i > ((a)->max_index))
  return((char *)((void *)0));
 start = ((lastarray && (a) == lastarray) && i >= ((lastref)->ind)) ? lastref : ((a->head)->next);
 for (ae = start; ae != a->head; ae = ((ae)->next))
  if (((ae)->ind) == i) {
   do { lastarray = (a); lastref = (ae); } while (0);
   return(((ae)->value));
  }
 do { lastarray = 0; lastref = 0; } while (0);
 return((char *) ((void *)0));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 8
7 8
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 12
18 12
19 11
20 11
21 11
22 16
23 16
24 17
25 17
26 17
27 13
28 13
29 14
30 14
31 14
32 7
33 18
34 18
35 10
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    $0x0,%edi
mov    (%rax),%rsi
xor    %eax,%eax
jmpq   d0 <cprintf>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_case_command_head (case_command)
     CASE_COM *case_command;
{
  cprintf ("case %s in ", case_command->word->word);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%dil
setbe  %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_digit_p (char c)
{
  return ((c >= '0') && (c <= '9'));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
test   %eax,%eax
mov    0x8(%rdi),%rax
jne    60 <next+0x20>
mov    0x8(%rax),%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x10(%rax),%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next (void *owner)
{
  struct list_iterator *itr = owner;
  if (itr->backwards)
    itr->cur = itr->cur->prev;
  else
    itr->cur = itr->cur->next;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 7
6 7
7 9
8 9
9 9
10 5
11 5
12 9
13 9
14 9
<<<sep_out_sample>>>
cmp    $0x1,%esi
je     11a0 <lm_mode+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
movzbl (%rdi),%ecx
mov    0x0(%rip),%eax        # 11a9 <lm_mode+0x19>
and    $0x1b,%eax
movzbl %cl,%esi
cmp    %esi,%eax
je     1195 <lm_mode+0x5>
test   $0x4,%cl
jne    1195 <lm_mode+0x5>
and    $0x1b,%ecx
sub    $0x8,%rsp
test   %edx,%edx
movzbl %cl,%eax
mov    %eax,0x0(%rip)        # 11ca <lm_mode+0x3a>
jne    11cf <lm_mode+0x3f>
or     $0x4,%ecx
mov    $0x0,%edi
mov    %cl,0x0(%rip)        # 11da <lm_mode+0x4a>
callq  11df <lm_mode+0x4f>
cmp    $0x7,%eax
jle    1220 <lm_mode+0x90>
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11f8 <lm_mode+0x68>
mov    $0x5,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
callq  120c <lm_mode+0x7c>
xor    %edi,%edi
add    $0x8,%rsp
jmpq   1217 <lm_mode+0x87>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  122a <lm_mode+0x9a>
jmp    120c <lm_mode+0x7c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
lm_mode (unsigned char *cmd, int len, int init)
{
  if (len != 1)
    return;
  if ((linemode & 0x1f & ~0x04) == *cmd)
    return;
  if (*cmd & 0x04)
    return;
  linemode = *cmd & (0x1f & ~0x04);
  str_lm_mode[4] = linemode;
  if (!init)
    str_lm_mode[4] |= 0x04;
  if ((ring_empty_count(&netoring)) > (int) sizeof (str_lm_mode))
    {
      ring_supply_data (&netoring, str_lm_mode, sizeof (str_lm_mode));
      printsub ('>', &str_lm_mode[2], sizeof (str_lm_mode) - 2);
    }
  else
    printf ("lm_mode: not enough room in buffer\n");
  setconnmode (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
13 9
14 2
15 11
16 9
17 9
18 11
19 12
20 13
21 12
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 16
30 16
31 16
32 16
33 20
34 21
35 20
36 20
37 19
38 19
39 19
40 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 2b <getnewunit+0xb>
movslq (%rbx),%r12
cmp    $0x63,%r12d
jg     78 <getnewunit+0x58>
lea    0x0(%rip),%rsi        # 3b <getnewunit+0x1b>
mov    $0x648,%edi
callq  45 <getnewunit+0x25>
mov    0x0(%rip),%rbp        # 4c <getnewunit+0x2c>
mov    %rax,0x0(%rbp,%r12,8)
movslq (%rbx),%rax
mov    0x0(%rbp,%rax,8),%rdi
test   %rdi,%rdi
je     78 <getnewunit+0x58>
callq  63 <getnewunit+0x43>
movslq (%rbx),%rax
lea    0x1(%rax),%edx
mov    0x0(%rbp,%rax,8),%rax
mov    %edx,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
getnewunit()
{
  if (nextunit>=100)
    return 0;
  memtable[nextunit] = (struct unittype *)
    mymalloc(sizeof(struct unittype),"(getnewunit)");
  if (!memtable[nextunit])
    return 0;
  initializeunit(memtable[nextunit]);
  return memtable[nextunit++];
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 6
9 6
10 6
11 5
12 5
13 7
14 7
15 7
16 7
17 9
18 10
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 4
30 11
31 11
32 11
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    (%rsi),%eax
test   %rdi,%rdi
je     132 <growbuffer+0x12>
test   %eax,%eax
jne    150 <growbuffer+0x30>
add    $0x64,%eax
mov    %eax,(%rsi)
movslq %eax,%rdi
callq  13f <growbuffer+0x1f>
mov    %rax,(%rbx)
test   %rax,%rax
je     162 <growbuffer+0x42>
pop    %rbx
retq   
nopl   0x0(%rax)
add    $0x64,%eax
mov    %eax,(%rsi)
movslq %eax,%rsi
callq  15d <growbuffer+0x3d>
mov    %rax,(%rbx)
jmp    142 <growbuffer+0x22>
mov    0x0(%rip),%rax        # 169 <growbuffer+0x49>
lea    0x0(%rip),%rsi        # 170 <growbuffer+0x50>
mov    (%rax),%rdx
mov    0x0(%rip),%rax        # 17a <growbuffer+0x5a>
mov    (%rax),%rdi
xor    %eax,%eax
callq  184 <growbuffer+0x64>
mov    $0x1,%edi
callq  18e <growbuffer+0x6e>
xchg   %ax,%ax
<<<sep_in_sample>>>
growbuffer(char **buf, int *bufsize)
{
  int usemalloc;
  usemalloc = !*buf || !*bufsize;
  *bufsize += 100;
  if (usemalloc)
    *buf = malloc(*bufsize);
  else
    *buf = realloc(*buf,*bufsize);
  if (!*buf){
    fprintf(stderr, "%s: memory allocation error (growbuffer)\n",progname);
    exit(1);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 10
15 10
16 14
17 14
18 14
19 5
20 5
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 12
33 12
34 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_min_fminimizer_name (const gsl_min_fminimizer * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rstat_min(gsl_rstat_workspace *w)
{
  return w->min;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     1dc0 <gsl_block_float_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    0x0(,%rcx,4),%r14
mov    %rsi,%rbx
jne    1d6c <gsl_block_float_raw_fwrite+0x3c>
jmp    1db0 <gsl_block_float_raw_fwrite+0x80>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     1db0 <gsl_block_float_raw_fwrite+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  1d81 <gsl_block_float_raw_fwrite+0x51>
cmp    $0x1,%rax
je     1d60 <gsl_block_float_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1da0 <gsl_block_float_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x4,%esi
callq  1dcd <gsl_block_float_raw_fwrite+0x9d>
cmp    %r12,%rax
je     1db0 <gsl_block_float_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1deb <gsl_block_float_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    1da5 <gsl_block_float_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_float_raw_fwrite (FILE * stream, const float * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 1 * sizeof (float), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 1 * i * stride,
                                1 * sizeof (float),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
jne    1261 <mu_address_contains_email+0x21>
jmp    1280 <mu_address_contains_email+0x40>
nopl   0x0(%rax,%rax,1)
mov    0x38(%rbx),%rbx
test   %rbx,%rbx
je     1280 <mu_address_contains_email+0x40>
mov    0x18(%rbx),%rdi
mov    %rbp,%rsi
callq  126d <mu_address_contains_email+0x2d>
test   %eax,%eax
jne    1258 <mu_address_contains_email+0x18>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_address_contains_email (mu_address_t addr, const char *email)
{
  for (; addr; addr = addr->next)
    if (mu_c_strcasecmp (addr->email, email) == 0)
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 7
19 5
20 7
21 7
22 7
23 7
24 7
25 6
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     62a <assoc_remove_quoted_nulls+0x6a>
mov    0xc(%rdi),%eax
test   %eax,%eax
je     62a <assoc_remove_quoted_nulls+0x6a>
mov    0x8(%rdi),%edx
xor    %r12d,%r12d
xor    %ebp,%ebp
test   %edx,%edx
jle    61c <assoc_remove_quoted_nulls+0x5c>
nopl   (%rax)
mov    0x0(%r13),%rax
mov    (%rax,%r12,1),%rbx
test   %rbx,%rbx
je     611 <assoc_remove_quoted_nulls+0x51>
nopl   (%rax)
mov    0x10(%rbx),%rdi
callq  601 <assoc_remove_quoted_nulls+0x41>
mov    %rax,0x10(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    5f8 <assoc_remove_quoted_nulls+0x38>
mov    0x8(%r13),%edx
add    $0x1,%ebp
add    $0x8,%r12
cmp    %edx,%ebp
jl     5e8 <assoc_remove_quoted_nulls+0x28>
add    $0x8,%rsp
mov    %r13,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assoc_remove_quoted_nulls (h)
     HASH_TABLE *h;
{
  int i;
  BUCKET_CONTENTS *tlist;
  char *t;
  if (h == 0 || ((h)->nentries == 0))
    return ((HASH_TABLE *)((void *)0));
  for (i = 0; i < h->nbuckets; i++)
    for (tlist = ((h && (i < h->nbuckets)) ? h->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); tlist; tlist = tlist->next)
      {
 t = remove_quoted_nulls ((char *)tlist->data);
 tlist->data = t;
      }
  return h;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 13
26 10
27 10
28 10
29 10
30 9
31 9
32 9
33 9
34 16
35 9
36 16
37 16
38 16
39 16
40 16
41 16
42 8
43 16
44 16
45 16
46 16
47 16
48 16
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    %rsi,0x8(%rdi)
jbe    1fe0 <gsl_vector_long_alloc_col_from_matrix+0x50>
mov    $0x28,%edi
callq  1fac <gsl_vector_long_alloc_col_from_matrix+0x1c>
test   %rax,%rax
je     2002 <gsl_vector_long_alloc_col_from_matrix+0x72>
mov    0x18(%rbx),%rdx
lea    (%rdx,%rbp,8),%rdx
mov    %rdx,0x10(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    0x10(%rbx),%rdx
movq   $0x0,0x18(%rax)
mov    %rdx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xd2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ff9 <gsl_vector_long_alloc_col_from_matrix+0x69>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x8,%ecx
mov    $0xda,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  201b <gsl_vector_long_alloc_col_from_matrix+0x8b>
xor    %eax,%eax
jmp    1fd3 <gsl_vector_long_alloc_col_from_matrix+0x43>
nop
<<<sep_in_sample>>>
gsl_vector_long_alloc_col_from_matrix (gsl_matrix_long * m,
                                              const size_t j)
{
  gsl_vector_long * v;
  const size_t N = m->size2;
  if (j >= N)
    {
      do { gsl_error ("column index is out of range", "getset_source.c", 210, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_long *) malloc (sizeof (gsl_vector_long));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 218
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * j ;
  v->size = m->size1;
  v->stride = m->tda;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 10
9 10
10 11
11 11
12 20
13 20
14 20
15 21
16 21
17 22
18 23
19 22
20 25
21 25
22 25
23 25
24 25
25 8
26 8
27 8
28 8
29 8
30 25
31 8
32 25
33 25
34 25
35 13
36 13
37 13
38 13
39 13
40 17
41 17
42 17
<<<sep_out_sample>>>
push   %r12
mov    $0x1,%esi
push   %rbp
mov    %edi,%ebp
mov    $0x30,%edi
movslq %ebp,%r12
push   %rbx
callq  18 <strhash_open+0x18>
mov    %r12,%rsi
mov    $0x8,%edi
mov    %rax,%rbx
callq  28 <strhash_open+0x28>
test   %ebp,%ebp
mov    %rax,0x8(%rbx)
jle    42 <strhash_open+0x42>
lea    0x0(,%r12,8),%rdx
xor    %esi,%esi
mov    %rax,%rdi
callq  42 <strhash_open+0x42>
mov    %ebp,(%rbx)
callq  49 <strhash_open+0x49>
movq   $0x0,0x18(%rbx)
mov    %rax,0x10(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
strhash_open(int buckets)
{
 STRHASH *sh = (STRHASH *)check_calloc(sizeof(STRHASH), 1);
 int i;
 sh->htab = (struct sh_head *)check_calloc(sizeof(struct sh_head), buckets);
 for (i = 0; i < buckets; i++)
  { (&sh->htab[i])->slh_first = ((void *)0); };
 sh->buckets = buckets;
 sh->pool = pool_open();
 sh->entries = 0;
 return sh;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 5
7 2
8 3
9 5
10 5
11 3
12 5
13 6
14 5
15 6
16 7
17 7
18 7
19 7
20 8
21 9
22 10
23 9
24 12
25 12
26 12
27 12
28 12
29 12
<<<sep_out_sample>>>
push   %r12
mov    $0x245,%edx
mov    %rdi,%r12
mov    $0x20,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
callq  17de <array_create_element+0x1e>
mov    %rax,%rbx
mov    %r12,(%rax)
xor    %eax,%eax
test   %rbp,%rbp
je     1811 <array_create_element+0x51>
mov    %rbp,%rdi
callq  17f3 <array_create_element+0x33>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x247,%edx
callq  1806 <array_create_element+0x46>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1811 <array_create_element+0x51>
mov    %rax,0x8(%rbx)
movq   $0x0,0x18(%rbx)
mov    %rbx,%rax
movq   $0x0,0x10(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
array_create_element(indx, value)
arrayind_t indx;
char *value;
{
 ARRAY_ELEMENT *r;
 r = (ARRAY_ELEMENT *)sh_xmalloc((sizeof(ARRAY_ELEMENT)), "array.c", 581);
 r->ind = indx;
 r->value = value ? (char *)strcpy (sh_xmalloc((1 + strlen (value)), "array.c", 583), (value)) : (char *)((void *)0);
 r->next = r->prev = (ARRAY_ELEMENT *) ((void *)0);
 return(r);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 4
7 6
8 4
9 6
10 6
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 11
27 9
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
cmp    $0xffffffff,%ecx
mov    (%rdi),%rax
je     190 <AlibSetClipRect+0x30>
mov    %si,0x1840(%rax)
mov    %dx,0x1842(%rax)
mov    %cx,0x1844(%rax)
mov    %r8w,0x1846(%rax)
retq   
nopw   %cs:0x0(%rax,%rax,1)
cmp    $0xffffffff,%r8d
jne    168 <AlibSetClipRect+0x8>
movzwl 0x1834(%rax),%esi
movzwl 0x1836(%rax),%edi
xor    %edx,%edx
mov    %dx,0x1840(%rax)
xor    %ecx,%ecx
mov    %cx,0x1842(%rax)
lea    -0x1(%rsi),%edx
mov    %dx,0x1844(%rax)
lea    -0x1(%rdi),%edx
mov    %dx,0x1846(%rax)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
AlibSetClipRect(Viewport *v, int x1, int y1,
  int x2, int y2)
{
  if (x2 == -1 && y2 == -1) {
    v->w->clip.x1 = 0;
    v->w->clip.y1 = 0;
    v->w->clip.x2 = v->w->width - 1;
    v->w->clip.y2 = v->w->height - 1;
  }
  else {
    v->w->clip.x1 = x1;
    v->w->clip.y1 = y1;
    v->w->clip.x2 = x2;
    v->w->clip.y2 = y2;
  }
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 11
5 12
6 13
7 14
8 14
9 14
10 4
11 4
12 7
13 8
14 5
15 5
16 6
17 6
18 7
19 7
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
movslq 0x868(%rdi),%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
mov    0x0(%rax),%rax
test   %rax,%rax
je     468 <ceaseFireWeapon+0x28>
jmpq   *%rax
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ceaseFireWeapon(craft * c)
{
 if (wtbl[c->curWeapon].fireRelease != ((void *)0))
  return (*wtbl[c->curWeapon].fireRelease) (c);
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 867 <terminal_ring_bell+0x7>
test   %rdx,%rdx
je     870 <terminal_ring_bell+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%edx        # 876 <terminal_ring_bell+0x16>
test   %edx,%edx
je     884 <terminal_ring_bell+0x24>
mov    0x0(%rip),%eax        # 880 <terminal_ring_bell+0x20>
test   %eax,%eax
jne    8a0 <terminal_ring_bell+0x40>
mov    0x0(%rip),%rdi        # 88b <terminal_ring_bell+0x2b>
test   %rdi,%rdi
je     8ac <terminal_ring_bell+0x4c>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   89f <terminal_ring_bell+0x3f>
nop
mov    0x0(%rip),%rdi        # 8a7 <terminal_ring_bell+0x47>
test   %rdi,%rdi
jne    890 <terminal_ring_bell+0x30>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
terminal_ring_bell (void)
{
  if (terminal_ring_bell_hook)
    (*terminal_ring_bell_hook) ();
  else
    {
      if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)
        do { if (visible_bell) tputs (visible_bell, 1, output_character_function); } while (0);
      else
        do { if (audible_bell) tputs (audible_bell, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
jmpq   0 <find_user_command_in_path>
<<<sep_in_sample>>>
find_in_path (name, path_list, flags)
     const char *name;
     char *path_list;
     int flags;
{
  return (find_user_command_in_path (name, path_list, flags));
}
<<<sep_in_sample>>>
1 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    0x0(%rip),%eax        # 351b <write_long_link+0xb>
lea    -0x1(%rax),%ecx
cmp    $0x5,%ecx
ja     35b3 <write_long_link+0xa3>
mov    $0x1,%eax
shl    %cl,%rax
test   $0x15,%al
jne    3550 <write_long_link+0x40>
test   $0x22,%al
jne    35a0 <write_long_link+0x90>
test   $0x8,%al
je     35b3 <write_long_link+0xa3>
add    $0x10,%rsp
mov    %rdi,%rsi
xor    %edx,%edx
pop    %rbx
mov    $0x0,%edi
jmpq   354f <write_long_link+0x3f>
nop
mov    0x0(%rip),%rax        # 3557 <write_long_link+0x47>
test   %rax,%rax
je     3568 <write_long_link+0x58>
mov    %rdi,0x8(%rsp)
callq  *%rax
mov    0x8(%rsp),%rdi
mov    0x18(%rdi),%rdi
callq  3571 <write_long_link+0x61>
mov    $0x0,%edi
mov    %rax,%rbx
callq  357e <write_long_link+0x6e>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  358f <write_long_link+0x7f>
movl   $0x2,0x0(%rip)        # 3599 <write_long_link+0x89>
add    $0x10,%rsp
pop    %rbx
retq   
nop
mov    0x18(%rdi),%rsi
add    $0x10,%rsp
mov    $0x4b,%edx
pop    %rbx
jmpq   2040 <write_gnu_long_link>
callq  35b8 <write_long_link+0xa8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_long_link (struct tar_stat_info *st)
{
  switch (archive_format)
    {
    case POSIX_FORMAT:
      xheader_store ("linkpath", st, ((void *)0));
      break;
    case V7_FORMAT:
    case USTAR_FORMAT:
    case STAR_FORMAT:
      do { if (error_hook) error_hook (); error (0, 0, gettext ("%s: link name is too long; not dumped"), quotearg_colon (st->link_name)); exit_status = 2; } while (0)
                                       ;
      break;
    case OLDGNU_FORMAT:
    case GNU_FORMAT:
      write_gnu_long_link (st, st->link_name, 'K');
      break;
    default:
      abort();
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 21
16 6
17 6
18 21
19 6
20 6
21 6
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 21
41 21
42 21
43 21
44 16
45 21
46 16
47 21
48 16
49 19
50 19
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1963 <gsl_matrix_uint_isneg+0x53>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     1957 <gsl_matrix_uint_isneg+0x47>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
mov    (%rsi,%rax,4),%ecx
cvtsi2sd %rcx,%xmm0
ucomisd %xmm1,%xmm0
jae    1969 <gsl_matrix_uint_isneg+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1940 <gsl_matrix_uint_isneg+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    1932 <gsl_matrix_uint_isneg+0x22>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_uint_isneg (const gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 13
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <emalloc+0x9>
test   %rax,%rax
je     43 <emalloc+0x13>
add    $0x8,%rsp
retq   
callq  48 <emalloc+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
emalloc (size_t size)
{
  void *p = malloc (size);
  if (!p)
    ealloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <gsl_permutation_get+0x6>
test   %eax,%eax
je     f <gsl_permutation_get+0xf>
cmp    %rsi,(%rdi)
jbe    20 <gsl_permutation_get+0x20>
mov    0x8(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d <gsl_permutation_get+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permutation_get (const gsl_permutation * p, const size_t i)
{
  if ((gsl_check_range && (i >= p->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_permutation.h", 90, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return p->data[i];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 8
18 8
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     50b <terror+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  544 <terror+0x94>
add    $0xd8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
terror (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vlerror (&yylloc, fmt, ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 5
19 2
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 7
28 7
29 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_data (const gsl_combination * c)
{
  return c->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1097 <yy_grecsget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecsget_out (void)
{
        return yy_grecsout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    29a <string_to_rlimtype+0x1a>
jmp    2e8 <string_to_rlimtype+0x68>
nopw   0x0(%rax,%rax,1)
cmp    $0x9,%al
jne    2f0 <string_to_rlimtype+0x70>
add    $0x1,%rdi
je     2e8 <string_to_rlimtype+0x68>
movzbl (%rdi),%eax
test   %al,%al
jne    290 <string_to_rlimtype+0x10>
xor    %esi,%esi
movsbl (%rdi),%edx
lea    -0x30(%rdx),%eax
cmp    $0x9,%al
mov    $0x0,%eax
jbe    2c3 <string_to_rlimtype+0x43>
jmp    2d7 <string_to_rlimtype+0x57>
nopl   0x0(%rax)
movsbl (%rdi),%edx
lea    -0x30(%rdx),%ecx
cmp    $0x9,%cl
ja     2d7 <string_to_rlimtype+0x57>
sub    $0x30,%edx
lea    (%rax,%rax,4),%rax
add    $0x1,%rdi
movslq %edx,%rdx
lea    (%rdx,%rax,2),%rax
jne    2b8 <string_to_rlimtype+0x38>
mov    %rax,%rdx
neg    %rdx
test   %esi,%esi
cmovne %rdx,%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x20,%al
je     294 <string_to_rlimtype+0x14>
cmp    $0x2d,%al
sete   %sil
cmp    $0x2b,%al
jne    30c <string_to_rlimtype+0x8c>
add    $0x1,%rdi
movzbl %sil,%esi
jne    2a3 <string_to_rlimtype+0x23>
xor    %eax,%eax
jmp    2d7 <string_to_rlimtype+0x57>
test   %sil,%sil
jne    2fe <string_to_rlimtype+0x7e>
jmp    2a1 <string_to_rlimtype+0x21>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_rlimtype (s)
     char *s;
{
  rlim_t ret;
  int neg;
  ret = 0;
  neg = 0;
  while (s && *s && (((*s) == ' ') || ((*s) == '\t')))
    s++;
  if (s && (*s == '-' || *s == '+'))
    {
      neg = *s == '-';
      s++;
    }
  for ( ; s && *s && ((*s) >= '0' && (*s) <= '9'); s++)
    ret = (ret * 10) + ((*s) - '0');
  return (neg ? -ret : ret);
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 3
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 16
25 16
26 15
27 16
28 16
29 15
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 8
40 8
41 10
42 10
43 10
44 10
45 15
46 12
47 15
48 15
49 15
50 10
51 10
52 10
53 10
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   21b <stcmp+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stcmp(char **s1, char **s2)
{
  return strcmp(*s1, *s2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
test   $0x1,%dil
mov    $0xcc,%edx
jne    50 <nettle_sha3_512_init+0x50>
test   $0x2,%dil
jne    60 <nettle_sha3_512_init+0x60>
test   $0x4,%dil
jne    78 <nettle_sha3_512_init+0x78>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     30 <nettle_sha3_512_init+0x30>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     3f <nettle_sha3_512_init+0x3f>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     47 <nettle_sha3_512_init+0x47>
movb   $0x0,(%rdi)
repz retq 
nopl   0x0(%rax)
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0xcb,%dl
test   $0x2,%dil
je     11 <nettle_sha3_512_init+0x11>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     17 <nettle_sha3_512_init+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    17 <nettle_sha3_512_init+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_sha3_512_init (struct sha3_512_ctx *ctx)
{
  memset (ctx, 0, __builtin_offsetof (struct sha3_512_ctx, block));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     e50 <gsl_permute_vector_float+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e45 <gsl_permute_vector_float+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  e61 <gsl_permute_vector_float+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_float (const gsl_permutation * p, gsl_vector_float * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_float (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 13aa <gsl_matrix_ushort_ptr+0xa>
test   %eax,%eax
je     13b9 <gsl_matrix_ushort_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    13d0 <gsl_matrix_ushort_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    13f0 <gsl_matrix_ushort_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,2),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  13e9 <gsl_matrix_ushort_ptr+0x49>
xor    %eax,%eax
jmp    13c9 <gsl_matrix_ushort_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1409 <gsl_matrix_ushort_ptr+0x69>
xor    %eax,%eax
jmp    13c9 <gsl_matrix_ushort_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_ushort_ptr(gsl_matrix_ushort * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_ushort.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_ushort.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (unsigned short *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_char_location (rec_field_t field)
{
  return field->char_location;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
test   %r9,%r9
movzbl (%rdi),%ecx
je     2a42 <gsl_vector_uchar_min_index+0x42>
xor    %edx,%edx
xor    %eax,%eax
jmp    2a23 <gsl_vector_uchar_min_index+0x23>
nopl   0x0(%rax)
mov    %r8d,%ecx
movzbl (%rdi),%esi
mov    %ecx,%r8d
cmp    %cl,%sil
cmovbe %esi,%r8d
cmovb  %rdx,%rax
add    $0x1,%rdx
add    %r10,%rdi
cmp    %r9,%rdx
jne    2a20 <gsl_vector_uchar_min_index+0x20>
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_min_index (const gsl_vector_uchar * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned char min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 5
6 8
7 8
8 6
9 6
10 6
11 8
12 10
13 10
14 10
15 10
16 10
17 8
18 8
19 8
20 8
21 18
22 6
23 18
24 18
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1,%eax
cmove  %rax,%rsi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
minstd_set (void *vstate, unsigned long int s)
{
  minstd_state_t *state = (minstd_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s;
  return;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_header_set_value (osip_header_t * header, char *value)
{
  header->hvalue = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_uri (osip_authorization_t * authorization, char *uri)
{
  authorization->uri = (char *) uri;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 87 <gsl_set_error_handler_off+0x7>
movq   $0x0,0x0(%rip)        # 92 <gsl_set_error_handler_off+0x12>
retq   
<<<sep_in_sample>>>
gsl_set_error_handler_off (void)
{
  gsl_error_handler_t * previous_handler = gsl_error_handler;
  gsl_error_handler = no_error_handler;
  return previous_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
push   %r15
mov    %ecx,%r15d
push   %r14
mov    %edx,%r14d
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
movzwl %r9w,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
cmp    0x2288(%rdi),%rbp
mov    0x168(%rdi),%r12
je     95 <VdbeDrawLine+0x55>
mov    0x170(%rdi),%rsi
mov    0x148(%rdi),%rdi
mov    %rbp,%rdx
mov    %r8d,0xc(%rsp)
callq  89 <VdbeDrawLine+0x49>
mov    0xc(%rsp),%r8d
mov    %rbp,0x2288(%rbx)
mov    0x170(%rbx),%rdx
mov    0x148(%rbx),%rdi
mov    %r15d,%r9d
mov    %r8d,(%rsp)
mov    %r13d,%ecx
mov    %r14d,%r8d
mov    %r12,%rsi
callq  b8 <VdbeDrawLine+0x78>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
VdbeDrawLine(Viewport *v, int x1, int y1, int x2, int y2,
      Color color)
{
  Drawable d;
  d = (Drawable) v->dbeDrawable;
  if (color != v->lastPixel) {
    XSetForeground (v->dpy, v->gc, color);
    v->lastPixel = color;
  }
  XDrawLine (v->dpy, d, v->gc, x1, y1, x2, y2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 3
11 3
12 3
13 6
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
mov    0x48(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x38,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
jmpq   2b05 <java_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     da0 <include_symbol+0xa0>
mov    0x18(%rdi),%edx
cmp    $0x2,%edx
je     d20 <include_symbol+0x20>
cmp    $0x1,%edx
mov    $0x1,%eax
je     d60 <include_symbol+0x60>
repz retq 
nopl   (%rax)
mov    0x20(%rdi),%rax
mov    0x0(%rip),%esi        # d2a <include_symbol+0x2a>
cmpb   $0x5f,(%rax)
je     d80 <include_symbol+0x80>
mov    0x70(%rdi),%ecx
mov    0x74(%rdi),%edx
cmp    $0x2,%ecx
je     da3 <include_symbol+0xa3>
xor    %r8d,%r8d
cmp    $0xffffffff,%edx
mov    $0x1,%eax
je     d90 <include_symbol+0x90>
test   %edx,%edx
cmovs  %r8d,%eax
cmpq   $0x0,0x48(%rdi)
je     db8 <include_symbol+0xb8>
and    %eax,%esi
cmp    %esi,%eax
sete   %al
movzbl %al,%eax
retq   
nop
xor    %al,%al
cmpl   $0x10e,0x40(%rdi)
jne    d1b <include_symbol+0x1b>
cmpq   $0x0,0x48(%rdi)
je     d1b <include_symbol+0x1b>
xor    %eax,%eax
testb  $0x10,0x0(%rip)        # d7b <include_symbol+0x7b>
setne  %al
retq   
nop
mov    %esi,%eax
and    $0x8,%eax
jne    d2f <include_symbol+0x2f>
jmp    d1b <include_symbol+0x1b>
nopl   0x0(%rax)
xor    %eax,%eax
cmp    $0x3,%ecx
setne  %al
add    %eax,%eax
jmp    d4d <include_symbol+0x4d>
nopl   0x0(%rax)
xor    %eax,%eax
retq   
cmp    $0xffffffff,%edx
je     dbd <include_symbol+0xbd>
mov    $0x5,%eax
mov    $0x4,%r8d
jmp    d47 <include_symbol+0x47>
nopl   (%rax)
or     $0x20,%eax
jmp    d54 <include_symbol+0x54>
mov    $0x6,%eax
jmp    d4d <include_symbol+0x4d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
include_symbol(Symbol *sym)
{
     int type = 0;
     if (!sym)
   return 0;
     if (sym->type == SymIdentifier) {
   if (sym->name[0] == '_' && !(symbol_map & 0x0008))
        return 0;
   if (sym->storage == StaticStorage)
        type |= 0x0004;
   if (sym->arity == -1 && sym->storage != AutoStorage)
        type |= 0x0002;
   else if (sym->arity >= 0)
        type |= 0x0001;
   if (!sym->source)
        type |= 0x0020;
     } else if (sym->type == SymToken) {
   if (sym->token_type == 270 && sym->source)
        type |= 0x0010;
   else
        return 0;
     }
     return (symbol_map & type) == type;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 17
7 17
8 17
9 24
10 24
11 7
12 7
13 7
14 7
15 9
16 11
17 9
18 9
19 3
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 5
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 7
54 5
55 5
56 11
57 11
58 11
59 10
60 10
61 10
62 16
63 16
64 11
65 12
66 12
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 827 <terminal_end_all_modes+0x7>
test   %rdx,%rdx
je     830 <terminal_end_all_modes+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%rdi        # 837 <terminal_end_all_modes+0x17>
test   %rdi,%rdi
je     850 <terminal_end_all_modes+0x30>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   84b <terminal_end_all_modes+0x2b>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
terminal_end_all_modes (void)
{
  if (terminal_end_all_modes_hook)
    (*terminal_end_all_modes_hook) ();
  else
    {
      do { if (term_me) tputs (term_me, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
test   %rax,%rax
je     1138 <grecs_node_unlink+0x28>
mov    0x38(%rdi),%rdx
mov    %rdx,0x38(%rax)
mov    0x38(%rdi),%rdx
test   %rdx,%rdx
je     1150 <grecs_node_unlink+0x40>
mov    %rax,0x40(%rdx)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    0x28(%rdi),%rcx
test   %rcx,%rcx
je     1158 <grecs_node_unlink+0x48>
mov    0x38(%rdi),%rdx
mov    %rdx,0x30(%rcx)
jmp    1125 <grecs_node_unlink+0x15>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_node_unlink(struct grecs_node *node)
{
 if (node->prev)
  node->prev->next = node->next;
 else if (node->up)
  node->up->down = node->next;
 else
  return 1;
 if (node->next)
  node->next->prev = node->prev;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 9
8 9
9 10
10 11
11 11
12 11
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 11
21 12
22 12
23 8
24 8
25 8
<<<sep_out_sample>>>
xor    %edi,%edi
sub    $0x8,%rsp
callq  b <init_noninteractive+0xb>
mov    0x0(%rip),%eax        # 11 <init_noninteractive+0x11>
movl   $0x0,0x0(%rip)        # 1b <init_noninteractive+0x1b>
mov    $0x1,%edi
movl   $0x0,0x0(%rip)        # 2a <init_noninteractive+0x2a>
movl   $0x0,0x0(%rip)        # 34 <init_noninteractive+0x34>
movl   $0x1,0x0(%rip)        # 3e <init_noninteractive+0x3e>
mov    %eax,0x0(%rip)        # 44 <init_noninteractive+0x44>
mov    0x0(%rip),%eax        # 4a <init_noninteractive+0x4a>
test   %eax,%eax
jne    5b <init_noninteractive+0x5b>
xor    %edi,%edi
cmpl   $0x0,0x0(%rip)        # 57 <init_noninteractive+0x57>
setne  %dil
add    $0x8,%rsp
jmpq   64 <init_noninteractive+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_noninteractive ()
{
  bash_history_reinit (0);
  interactive_shell = startup_state = interactive = 0;
  expand_aliases = posixly_correct;
  no_line_editing = 1;
  set_job_control (forced_interactive||jobs_m_flag);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 5
5 4
6 7
7 4
8 4
9 6
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 7
19 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 317b <dosynch+0xb>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xff,(%rax)
callq  318d <dosynch+0x1d>
callq  3192 <dosynch+0x22>
mov    0x0(%rip),%rax        # 3199 <dosynch+0x29>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xf2,(%rax)
callq  31ab <dosynch+0x3b>
mov    $0xf2,%edx
mov    $0xff,%esi
mov    $0x0,%edi
callq  31bf <dosynch+0x4f>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
dosynch (void)
{
  netclear ();
  { *netoring.supply = 255; ring_supplied(&netoring, 1); };
  setneturg ();
  { *netoring.supply = 242; ring_supplied(&netoring, 1); };
  printoption ("SENT", 255, 242);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
mov    0x18(%rsi),%rcx
mov    %rdi,%rax
mov    (%rsi),%rdi
test   %rcx,%rcx
jne    14b <gl_tree_iterator+0x1b>
jmp    153 <gl_tree_iterator+0x23>
nopl   0x0(%rax)
mov    %rdx,%rcx
mov    (%rcx),%rdx
test   %rdx,%rdx
jne    148 <gl_tree_iterator+0x18>
mov    %rdi,(%rax)
mov    %rsi,0x8(%rax)
movq   $0x0,0x10(%rax)
mov    %rcx,0x18(%rax)
movq   $0x0,0x20(%rax)
movq   $0x0,0x28(%rax)
movq   $0x0,0x30(%rax)
retq   
nop
<<<sep_in_sample>>>
gl_tree_iterator (gl_oset_t set)
{
  gl_oset_iterator_t result;
  gl_oset_node_t node;
  result.vtable = set->base.vtable;
  result.set = set;
  node = set->root;
  if (node != ((void *)0))
    while (node->left != ((void *)0))
      node = node->left;
  result.p = node;
  result.q = ((void *)0);
  return result;
}
<<<sep_in_sample>>>
1 7
2 2
3 5
4 8
5 8
6 8
7 8
8 10
9 9
10 9
11 9
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 14
20 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
movl   $0x0,0x0(%rip)        # 2b1e <make_command_string+0xe>
movl   $0x0,0x0(%rip)        # 2b28 <make_command_string+0x18>
movq   $0x0,0x0(%rip)        # 2b33 <make_command_string+0x23>
callq  15d0 <make_command_string_internal>
mov    0x0(%rip),%rax        # 2b3f <make_command_string+0x2f>
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_command_string (command)
     COMMAND *command;
{
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 6
6 8
7 8
8 8
9 8
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     1dd6 <gsl_vector_ushort_scale+0x36>
mov    0x10(%rdi),%rax
add    %r8,%r8
xor    %edx,%edx
nopl   (%rax)
movzwl (%rax),%ecx
add    $0x1,%rdx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    1db8 <gsl_vector_ushort_scale+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_scale (gsl_vector_ushort * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 6
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2157 <yyget_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_in (void)
{
        return yyin;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    $0x0,%esi
callq  7e1 <assign_seconds+0x11>
test   %eax,%eax
jne    7f0 <assign_seconds+0x20>
movq   $0x0,0x0(%rip)        # 7f0 <assign_seconds+0x20>
xor    %edi,%edi
callq  7f7 <assign_seconds+0x27>
mov    %rax,0x0(%rip)        # 7fe <assign_seconds+0x2e>
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assign_seconds (self, value, unused, key)
     SHELL_VAR *self;
     char *value;
     arrayind_t unused;
     char *key;
{
  if (legal_number (value, &seconds_value_assigned) == 0)
    seconds_value_assigned = 0;
  shell_start_time = ((time_t) time ((time_t *) 0));
  return (self);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 7
7 7
8 8
9 9
10 9
11 9
12 11
13 11
14 11
15 11
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # f78 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # f7f <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    faa <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  fa5 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    f98 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     fd3 <quotearg_free+0x63>
callq  fbd <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # fc8 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # fd3 <quotearg_free+0x63>
cmp    $0x0,%r12
je     fef <quotearg_free+0x7f>
mov    %r12,%rdi
callq  fe4 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # fef <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # ffb <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    2250 <gsl_matrix_long_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,8),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  2272 <gsl_matrix_long_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_subdiagonal (gsl_matrix_long * m,
                                    const size_t k)
{
  _gsl_vector_long_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    0x20(%rdi),%rsi
movswl 0x2(%rdi),%edi
jmpq   10 <VCopyPolygon+0x10>
<<<sep_in_sample>>>
VCopyPolygon(VPolygon * poly)
{
 return VCreatePolygonFromTemplate(poly->numVtces, poly->vertex, poly);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
cmpb   $0x2e,(%rdi)
mov    %rdi,%rax
je     1d0 <trimpath+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
cmpb   $0x2f,0x1(%rdi)
lea    0x2(%rdi),%rdx
cmove  %rdx,%rax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
trimpath(const char *path)
{
 if (*path == '.' && *(path + 1) == '/')
  path += 2;
 return path;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 4
7 4
8 4
9 6
10 6
<<<sep_out_sample>>>
mov    $0x100,%ecx
jmpq   1a <lchmodat+0xa>
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
movslq %esi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  18f <argcpy+0xf>
lea    0x1(%rax,%r12,1),%rdi
mov    %rax,%rbp
callq  19c <argcpy+0x1c>
test   %rax,%rax
je     1b5 <argcpy+0x35>
lea    0x1(%rbp),%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1b0 <argcpy+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x0,%edi
callq  1bf <argcpy+0x3f>
mov    $0x1,%edi
callq  1c9 <argcpy+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argcpy(char arg[], int extra)
{
  char *cpy;
  if (!(cpy = malloc(strlen(arg) + extra + 1)))
    {
      perror("dap");
      exit(1);
    }
  strcpy(cpy, arg);
  return cpy;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 6
21 6
22 7
23 7
24 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d9 <mu_attribute_set_modified+0x9>
orl    $0x40,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_attribute_set_modified (mu_attribute_t attr)
{
  if (attr)
    attr->flags |= 0x40;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
imul   $0x41c64e6d,%rax,%rax
add    $0x3039,%rax
and    $0x7fffffff,%eax
mov    %rax,(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rand_get (void *vstate)
{
  rand_state_t *state = (rand_state_t *) vstate;
  state->x = (1103515245 * state->x + 12345) & 0x7fffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 21b6 <yyset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_debug (int bdebug )
{
        yy_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     991 <gsl_matrix_long_double_fread+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    94e <gsl_matrix_long_double_fread+0x4e>
jmp    980 <gsl_matrix_long_double_fread+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     980 <gsl_matrix_long_double_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  965 <gsl_matrix_long_double_fread+0x65>
test   %eax,%eax
je     940 <gsl_matrix_long_double_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   9b4 <gsl_matrix_long_double_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_fread (FILE * stream, gsl_matrix_long_double * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_double_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_double_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
posix_refcnt (RC_REGEX *regex)
{
  return regex->v.re.re_nsub;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%ecx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%rax
mov    0x8(%rsi),%rsi
lea    0x1(%rax),%rdx
callq  21 <gsl_histogram_fread+0x21>
test   %eax,%eax
je     30 <gsl_histogram_fread+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x10(%rbx),%rsi
mov    (%rbx),%rdx
add    $0x8,%rsp
pop    %rbx
mov    %rbp,%rdi
mov    $0x1,%ecx
pop    %rbp
jmpq   4a <gsl_histogram_fread+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_fread (FILE * stream, gsl_histogram * h)
{
  int status = gsl_block_raw_fread (stream, h->range, h->n + 1, 1);
  if (status)
    return status;
  status = gsl_block_raw_fread (stream, h->bin, h->n, 1);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 4
12 4
13 8
14 8
15 8
16 8
17 8
18 6
19 6
20 8
21 8
22 6
23 6
24 8
25 6
26 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   198 <medium_name_fputs+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
medium_name_fputs (struct medium * medium, FILE * stream)
{
  fputs (medium->name, stream);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    $0x1005,%eax
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     ef <mu_authority_create+0x3f>
mov    %rsi,%rbp
mov    $0x1,%edi
mov    $0x18,%esi
mov    %rdx,%r12
callq  d6 <mu_authority_create+0x26>
mov    %rax,%rcx
mov    $0xc,%eax
test   %rcx,%rcx
je     ef <mu_authority_create+0x3f>
mov    %rbp,0x8(%rcx)
mov    %r12,(%rcx)
xor    %al,%al
mov    %rcx,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_authority_create (mu_authority_t *pauthority, mu_ticket_t ticket, void *owner)
{
  mu_authority_t authority;
  if (pauthority == ((void *)0))
    return (0x1000 +5);
  authority = calloc (1, sizeof (*authority));
  if (authority == ((void *)0))
    return 12;
  authority->ticket = ticket;
  authority->owner = owner;
  *pauthority = authority;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 8
15 7
16 7
17 9
18 10
19 12
20 11
21 13
22 13
23 13
24 13
25 13
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
jmpq   310 <gsl_blas_dnrm2>
<<<sep_in_sample>>>
gsl_blas_snrm2 (const gsl_vector_float * X)
{
  return cblas_snrm2 (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    0x0(%rip),%rdi        # 1b <start_msgs+0xb>
callq  20 <start_msgs+0x10>
mov    $0x0,%esi
mov    $0xe,%edi
callq  2f <start_msgs+0x1f>
mov    %rsp,%rsi
xor    %edx,%edx
xor    %edi,%edi
movq   $0x4,(%rsp)
movq   $0x4,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,0x18(%rsp)
callq  5e <start_msgs+0x4e>
xor    %eax,%eax
add    $0x28,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_msgs (void)
{
  struct itimerval itimer;
  message (current_state);
  signal (14, disp_msg);
  itimer.it_value.tv_sec = itimer.it_interval.tv_sec = 4;
  itimer.it_value.tv_usec = itimer.it_interval.tv_usec = 0;
  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 8
8 8
9 8
10 6
11 6
12 7
13 7
14 8
15 10
16 10
17 10
18 10
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x8,%esi
mov    %rbx,%rdx
callq  20f8 <gsl_block_ulong_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     211a <gsl_block_ulong_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2115 <gsl_block_ulong_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_ulong_fread (FILE * stream, gsl_block_ulong * b)
{
  size_t n = b->size ;
  unsigned long * data = b->data ;
  size_t items = fread (data, 1 * sizeof (unsigned long), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
jmpq   55 <crlf+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
jmpq   65 <rec_rset_record_disp_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_record_disp_fn (void *data)
{
  rec_record_t record = (rec_record_t) data;
  rec_record_destroy (record);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x16,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     123a <mu_message_set_header+0x1a>
cmp    %rdx,(%rdi)
mov    $0xd,%al
je     1248 <mu_message_set_header+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
cmpq   $0x0,0x10(%rdi)
mov    %rsi,%rbp
je     125e <mu_message_set_header+0x3e>
lea    0x10(%rdi),%rdi
mov    %rbx,%rsi
callq  125e <mu_message_set_header+0x3e>
mov    %rbp,0x10(%rbx)
orl    $0x10000,0x20(%rbx)
xor    %eax,%eax
jmp    123a <mu_message_set_header+0x1a>
nopl   (%rax)
<<<sep_in_sample>>>
mu_message_set_header (mu_message_t msg, mu_header_t hdr, void *owner)
{
  if (msg == ((void *)0) )
    return 22;
  if (msg->owner != owner)
     return 13;
  if (msg->header)
    mu_header_destroy (&(msg->header), msg);
  msg->header = hdr;
  msg->flags |= 0x10000;;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 3
8 5
9 6
10 5
11 12
12 12
13 12
14 12
15 12
16 7
17 7
18 7
19 8
20 8
21 8
22 9
23 10
24 11
25 11
26 11
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rcx
test   %rsi,%rsi
je     63a <gsl_vector_complex_isneg+0x6a>
mov    0x10(%rdi),%rax
xorpd  %xmm1,%xmm1
movsd  (%rax),%xmm0
ucomisd %xmm1,%xmm0
jae    640 <gsl_vector_complex_isneg+0x70>
movsd  0x8(%rax),%xmm0
ucomisd %xmm1,%xmm0
jae    640 <gsl_vector_complex_isneg+0x70>
mov    %rcx,%rdi
neg    %rcx
xor    %edx,%edx
shl    $0x4,%rdi
shl    $0x4,%rcx
lea    0x8(%rax,%rdi,1),%rax
movapd %xmm1,%xmm2
jmp    631 <gsl_vector_complex_isneg+0x61>
nopl   0x0(%rax)
movsd  -0x8(%rax),%xmm0
ucomisd %xmm1,%xmm0
jae    640 <gsl_vector_complex_isneg+0x70>
add    %rdi,%rax
movsd  (%rax,%rcx,1),%xmm0
ucomisd %xmm2,%xmm0
jae    640 <gsl_vector_complex_isneg+0x70>
add    $0x1,%rdx
cmp    %rsi,%rdx
jne    618 <gsl_vector_complex_isneg+0x48>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_isneg (const gsl_vector_complex * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 6
16 6
17 6
18 6
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 6
30 6
31 6
32 17
33 17
34 13
35 18
36 18
<<<sep_out_sample>>>
test   %rdi,%rdi
je     58 <cdio_read+0x28>
mov    0x120(%rdi),%rax
test   %rax,%rax
je     50 <cdio_read+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffffffffffe,%rax
retq   
mov    $0xfffffffffffffffd,%rax
retq   
<<<sep_in_sample>>>
cdio_read (const CdIo_t *p_cdio, void *p_buf, size_t i_size)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.read)
    return (p_cdio->op.read) (p_cdio->env, p_buf, i_size);
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 7
11 3
12 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  a55 <assign_string_n+0x15>
test   %r12,%r12
je     a80 <assign_string_n+0x40>
lea    0x1(%rbp),%rdi
callq  a63 <assign_string_n+0x23>
mov    %rbp,%rdx
mov    %rax,(%rbx)
mov    %r12,%rsi
mov    %rax,%rdi
callq  a74 <assign_string_n+0x34>
mov    (%rbx),%rax
movb   $0x0,(%rax,%rbp,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
movq   $0x0,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
assign_string_n (char **pstr, const char *s, size_t length)
{
  free (*pstr);
  if (s)
    {
      *pstr = xmalloc (length + 1);
      memcpy (*pstr, s, length);
      (*pstr)[length] = 0;
    }
  else
    *pstr = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 6
12 6
13 7
14 6
15 7
16 7
17 7
18 8
19 8
20 12
21 12
22 12
23 12
24 11
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
test   %rsi,%rsi
jne    10 <strmatch+0x10>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
test   %rdi,%rdi
je     5 <strmatch+0x5>
jmpq   1a <strmatch+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strmatch (pattern, string, flags)
     char *pattern;
     char *string;
     int flags;
{
  if (string == 0 || pattern == 0)
    return 1;
  return (xstrmatch (pattern, string, flags));
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 6
7 6
8 8
9 8
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
xor    %esi,%esi
jmpq   677 <VReadDXFObject+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
VReadDXFObject(FILE *f)
{
 return VReadDepthCueuedObject(f, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     a1 <printer_free+0x11>
callq  a1 <printer_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     af <printer_free+0x1f>
callq  af <printer_free+0x1f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     c0 <printer_free+0x30>
pop    %rbx
jmpq   be <printer_free+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_free (struct printer * printer)
{
  do { if (printer->key) free (printer->key); } while (0);
  do { if (printer->ppdkey) free (printer->ppdkey); } while (0);
  do { if (printer->command) free (printer->command); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 5
16 5
17 6
18 6
19 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm3        # 70 <gsl_odeiv2_driver_set_hmax+0x10>
movsd  0x20(%rdi),%xmm1
andpd  %xmm3,%xmm2
andpd  %xmm3,%xmm1
ucomisd %xmm2,%xmm1
ja     a8 <gsl_odeiv2_driver_set_hmax+0x48>
movsd  0x28(%rdi),%xmm1
ucomisd %xmm2,%xmm1
ja     a8 <gsl_odeiv2_driver_set_hmax+0x48>
ucomisd 0x0(%rip),%xmm0        # 96 <gsl_odeiv2_driver_set_hmax+0x36>
je     d0 <gsl_odeiv2_driver_set_hmax+0x70>
movsd  %xmm2,0x30(%rdi)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x81,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c1 <gsl_odeiv2_driver_set_hmax+0x61>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x8a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e9 <gsl_odeiv2_driver_set_hmax+0x89>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_driver_set_hmax (gsl_odeiv2_driver * d, const double hmax)
{
  if ((fabs (hmax) < fabs (d->h)) || (fabs (hmax) < d->hmin))
    {
      do { gsl_error ("hmin <= fabs(h) <= hmax required", "driver.c", 129, GSL_EINVAL) ; return 0 ; } while (0);
    }
  if (hmax > 0.0 || hmax < 0.0)
    {
      d->hmax = fabs (hmax);
    }
  else
    {
      do { gsl_error ("invalid hmax", "driver.c", 138, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 7
13 7
14 9
15 16
16 16
17 16
18 16
19 5
20 5
21 5
22 5
23 5
24 16
25 16
26 16
27 16
28 13
29 13
30 13
31 13
32 13
33 16
34 16
35 16
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
eval_scheme_string_function (command)
     char *command;
{
  }
<<<sep_in_sample>>>
1 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0xfb,%esi
mov    $0x22,%edi
jmpq   11 <doclientstat+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doclientstat (void)
{
  clientstat (34, 251, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_nextnonce (osip_authentication_info_t * authentication_info, char *nextnonce)
{
  authentication_info->nextnonce = (char *) nextnonce;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 64b <do_statusbar_home+0xb>
jmpq   650 <do_statusbar_end>
<<<sep_in_sample>>>
do_statusbar_home(void)
{
    statusbar_x = 0;
    update_the_statusbar();
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
lea    -0x1(%rsi),%rdx
xor    %eax,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
move_mbleft(const char *buf, size_t pos)
{
    size_t before, char_len = 0;
    ((void) (0));
    if (mb_cur_max() > pos)
 before = 0;
    else
 before = pos - mb_cur_max();
    while (before < pos) {
 char_len = parse_mbchar(buf + before, ((void *)0), ((void *)0));
 before += char_len;
    }
    return before - char_len;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 14
6 14
<<<sep_out_sample>>>
test   %edi,%edi
jne    350 <jobserver_pre_child+0x40>
mov    0x0(%rip),%edi        # 31a <jobserver_pre_child+0xa>
test   %edi,%edi
js     350 <jobserver_pre_child+0x40>
sub    $0x8,%rsp
mov    $0x1,%edx
mov    $0x2,%esi
xor    %eax,%eax
callq  333 <jobserver_pre_child+0x23>
mov    0x0(%rip),%edi        # 339 <jobserver_pre_child+0x29>
mov    $0x1,%edx
mov    $0x2,%esi
xor    %eax,%eax
add    $0x8,%rsp
jmpq   34e <jobserver_pre_child+0x3e>
xchg   %ax,%ax
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
jobserver_pre_child (int recursive)
{
  if (!recursive && job_fds[0] >= 0)
    {
      (void) fcntl ((job_fds[0]), 2, 1);
      (void) fcntl ((job_fds[1]), 2, 1);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x2,%esi
mov    %rbx,%rdx
callq  34d8 <gsl_block_ushort_fwrite+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     34fa <gsl_block_ushort_fwrite+0x3a>
mov    $0x30,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  34f5 <gsl_block_ushort_fwrite+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_ushort_fwrite (FILE * stream, const gsl_block_ushort * b)
{
  size_t n = b->size ;
  unsigned short * data = b->data ;
  size_t items = fwrite (data, 1 * sizeof (unsigned short), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "fwrite_source.c", 48, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 8c6 <sv_globignore+0x6>
test   %eax,%eax
je     8d0 <sv_globignore+0x10>
repz retq 
nopl   0x0(%rax)
jmpq   8d5 <sv_globignore+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_globignore (name)
     char *name;
{
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   273 <gsl_vector_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_fscanf (FILE * stream, gsl_vector * v)
{
  int status = gsl_block_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ecx
xor    %edx,%edx
mov    %esi,%ebx
sub    $0x20,%rsp
test   %ecx,%ecx
mov    %esi,(%rsp)
js     56 <mu_nntp_carrier_is_ready+0x56>
mov    %ecx,%eax
mov    $0x51eb851f,%edx
mov    %ecx,%esi
imul   %edx
sar    $0x1f,%esi
mov    %ecx,%eax
sar    $0x5,%edx
sub    %esi,%edx
movslq %edx,%rdx
mov    %rdx,0x10(%rsp)
mov    $0x10624dd3,%edx
imul   %edx
sar    $0x6,%edx
sub    %esi,%edx
imul   $0x3e8,%edx,%edx
sub    %edx,%ecx
lea    0x10(%rsp),%rdx
imul   $0x3e8,%ecx,%ecx
movslq %ecx,%rcx
mov    %rcx,0x18(%rsp)
mov    %rsp,%rsi
callq  5e <mu_nntp_carrier_is_ready+0x5e>
xor    %edx,%edx
test   %eax,%eax
jne    69 <mu_nntp_carrier_is_ready+0x69>
and    (%rsp),%ebx
mov    %ebx,%edx
add    $0x20,%rsp
mov    %edx,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_nntp_carrier_is_ready (mu_stream_t carrier, int flag, int timeout)
{
  struct timeval tv, *tvp = ((void *)0);
  int wflags = flag;
  int status;
  if (timeout >= 0)
    {
      tv.tv_sec = timeout / 100;
      tv.tv_usec = (timeout % 1000) * 1000;
      tvp = &tv;
    }
  status = mu_stream_wait (carrier, &wflags, tvp);
  if (status)
    return 0;
  return wflags & flag;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 6
7 4
8 6
9 8
10 8
11 8
12 8
13 8
14 9
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 9
27 9
28 9
29 12
30 12
31 14
32 13
33 13
34 15
35 15
36 16
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2116 <afmget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmget_lineno (void)
{
    return afmlineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     128 <mu_observer_action+0x18>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     130 <mu_observer_action+0x20>
mov    0x18(%rdi),%rcx
jmpq   *%rax
nopl   0x0(%rax)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_observer_action (mu_observer_t observer, size_t type, void *data)
{
  if (observer == ((void *)0))
    return 22;
  if (observer->_action)
    return observer->_action (observer, type, data, observer->_action_data);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
9 4
10 4
11 4
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  81b <_prog_readline+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   83a <_prog_readline+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_prog_readline (mu_stream_t stream, char *optr, size_t osize,
  mu_off_t offset, size_t *pnbytes)
{
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  return mu_stream_readline (fs->in, optr, osize, offset, pnbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    41a8 <gsl_matrix_complex_long_double_const_column+0x38>
shl    $0x5,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  41ca <gsl_matrix_complex_long_double_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_const_column (const gsl_matrix_complex_long_double * m, const size_t j)
{
  _gsl_vector_complex_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 2;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  11 <open_input_file+0x11>
test   %rax,%rax
mov    %rax,%r12
je     51 <open_input_file+0x51>
mov    $0x1,%esi
mov    $0x1410,%edi
callq  28 <open_input_file+0x28>
lea    0x410(%rax),%rdi
mov    %rax,%rbx
mov    %r12,0x8(%rax)
mov    %rbp,%rsi
mov    $0x1000,%edx
callq  43 <open_input_file+0x43>
movl   $0x1,(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbp,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  60 <open_output_file>
<<<sep_in_sample>>>
open_input_file(const char *path)
{
 FILE *fp = fopen(path, "r");
 FILEOP *fileop;
 if (fp == ((void *)0))
  die("cannot open file '%s'.", path);
 fileop = check_calloc(sizeof(FILEOP), 1);
 fileop->fp = fp;
 strlimcpy(fileop->path, path, sizeof(fileop->path));
 fileop->type = 1;
 return fileop;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 5
8 3
9 5
10 7
11 7
12 7
13 9
14 7
15 8
16 9
17 9
18 9
19 10
20 12
21 12
22 12
23 12
24 12
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 7 <nettle_hmac_sha384_set_key+0x7>
mov    %rsi,%r8
mov    %rdx,%r9
lea    0xd8(%rdi),%rsi
lea    0x1b0(%rdi),%rdx
jmpq   20 <nettle_hmac_sha384_digest>
<<<sep_in_sample>>>
nettle_hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
      size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_sha384), (key_length), (key) );
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
movq   $0x0,0x10(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sexp_input_init(struct sexp_input *input, FILE *f)
{
  input->f = f;
  input->coding = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     bc0 <gsl_vector_long_double_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bb5 <gsl_vector_long_double_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     bf7 <gsl_vector_long_double_sub+0x67>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x4,%r10
shl    $0x4,%r9
xor    %edx,%edx
nop
fldt   (%rax)
add    $0x1,%rdx
fldt   (%rcx)
add    %r9,%rcx
fsubrp %st,%st(1)
fstpt  (%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    be0 <gsl_vector_long_double_sub+0x50>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_sub (gsl_vector_long_double * a, const gsl_vector_long_double * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
jmpq   25 <gss_seal+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_seal (OM_uint32 * minor_status,
   gss_ctx_id_t context_handle,
   int conf_req_flag,
   int qop_req,
   gss_buffer_t input_message_buffer,
   int *conf_state, gss_buffer_t output_message_buffer)
{
  return gss_wrap (minor_status, context_handle, conf_req_flag,
     (gss_qop_t) qop_req,
     input_message_buffer, conf_state, output_message_buffer);
}
<<<sep_in_sample>>>
1 8
2 8
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rcx
je     89f <gsl_vector_float_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  895 <gsl_vector_float_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
je     8d7 <gsl_vector_float_swap+0x77>
lea    0x0(,%rcx,4),%rsi
shl    $0x2,%rdi
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
movss  (%rdx),%xmm0
add    $0x1,%rcx
movss  (%rax),%xmm1
movss  %xmm1,(%rdx)
add    %rdi,%rdx
movss  %xmm0,(%rax)
add    %rsi,%rax
cmp    %r8,%rcx
jne    8b8 <gsl_vector_float_swap+0x58>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_swap (gsl_vector_float * v, gsl_vector_float * w)
{
  float * d1 = v->data ;
  float * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          float tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 13
18 13
19 13
20 13
21 13
22 13
23 17
24 13
25 18
26 18
27 18
28 19
29 19
30 13
31 13
32 22
33 23
34 23
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1507 <available_space_after+0x7>
sub    %rdi,%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
available_space_after (union block *pointer)
{
  return record_end->buffer - pointer->buffer;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     32b <cdio_debug+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  210 <cdio_logv>
add    $0xd8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_debug (const char format[], ...) { va_list args; __builtin_va_start(args,format); cdio_logv (CDIO_LOG_DEBUG, format, args); __builtin_va_end(args); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    59e0 <gsl_matrix_float_const_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,4),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  5a02 <gsl_matrix_float_const_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_const_subdiagonal (const gsl_matrix_float * m,
                                    const size_t k)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1010,%edi
callq  e <rl_make_bare_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
jne    10 <rl_make_bare_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_make_bare_keymap ()
{
  register int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc (257 * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < 257; i++)
    {
      keymap[i].type = 0;
      keymap[i].function = (rl_command_func_t *)((void *)0);
    }
  return (keymap);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <mu_alloc_die+0xb>
test   %rax,%rax
je     12 <mu_alloc_die+0x12>
callq  *%rax
mov    $0x0,%esi
mov    $0x0,%edi
callq  21 <mu_alloc_die+0x21>
mov    %rax,%rdi
xor    %eax,%eax
callq  2b <mu_alloc_die+0x2b>
callq  30 <mu_alloc>
<<<sep_in_sample>>>
mu_alloc_die ()
{
  if (mu_alloc_die_hook)
    mu_alloc_die_hook ();
  mu_error (dgettext ("mailutils", "Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    0x8(%rsi),%rbp
xor    %ebx,%ebx
mov    0x10(%rsi),%r14
test   %rbp,%rbp
jne    a9 <gsl_combination_fprintf+0x29>
jmp    e8 <gsl_combination_fprintf+0x68>
nop
add    $0x1,%rbx
cmp    %rbp,%rbx
je     e8 <gsl_combination_fprintf+0x68>
mov    (%r14,%rbx,8),%rdx
xor    %eax,%eax
mov    %r12,%rsi
mov    %r13,%rdi
callq  ba <gsl_combination_fprintf+0x3a>
test   %eax,%eax
jns    a0 <gsl_combination_fprintf+0x20>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d7 <gsl_combination_fprintf+0x57>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x5,%eax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_fprintf (FILE * stream, const gsl_combination * c, const char *format)
{
  size_t k = c->k ;
  size_t * data = c->data ;
  size_t i;
  for (i = 0; i < k; i++)
    {
      int status = fprintf (stream, format, data[i]);
      if (status < 0)
        {
          do { gsl_error ("fprintf failed", "file.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 15
31 15
32 15
33 15
34 11
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 14
43 15
44 15
45 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xeb8(%rdi),%rdi
callq  520 <CloseMCFiles+0x10>
mov    0xeb0(%rbx),%rsi
mov    $0x0,%edi
xor    %eax,%eax
pop    %rbx
jmpq   534 <CloseMCFiles+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CloseMCFiles (PANALYSIS panal)
{
  fclose (panal->mc.pfileMCOut);
  printf ("\nWrote results to \"%s\"\n", panal->mc.szMCOutfilename);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3a0 <socket_error+0x30>
mov    $0x0,%edi
callq  383 <socket_error+0x13>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
pop    %rbx
mov    $0x1,%edi
xor    %eax,%eax
jmpq   398 <socket_error+0x28>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  3aa <socket_error+0x3a>
mov    %rax,%rbx
callq  3b2 <socket_error+0x42>
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
pop    %rbx
xor    %eax,%eax
jmpq   3c4 <socket_error+0x54>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
socket_error (const char *msg)
{
  if (msg)
    anubis_error (1, 0, gettext("Could not write to socket: %s"), msg);
  else
    anubis_error (1, (*__errno_location ()), gettext("Could not write to socket"));
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 7
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 6
24 6
25 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  55e <upperdir+0xe>
mov    %rbx,%rdx
mov    $0x0,%edi
mov    $0x0,%esi
xor    %eax,%eax
callq  572 <upperdir+0x22>
pop    %rbx
mov    $0x0,%edi
jmpq   57d <upperdir+0x2d>
nopl   (%rax)
<<<sep_in_sample>>>
upperdir(const char *dir)
{
 static STRBUF sb[1];
 strbuf_clear(sb);
 strbuf_sprintf(sb, "../%s", dir);
 return strbuf_value(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 7
11 6
12 6
13 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     770 <gsl_stats_short_quantile_from_sorted_data+0x70>
sub    $0x1,%rdx
js     778 <gsl_stats_short_quantile_from_sorted_data+0x78>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     79f <gsl_stats_short_quantile_from_sorted_data+0x9f>
test   %rax,%rax
js     7b0 <gsl_stats_short_quantile_from_sorted_data+0xb0>
cvtsi2sd %rax,%xmm1
add    %rsi,%rsi
movapd %xmm0,%xmm2
imul   %rsi,%rax
movsd  0x0(%rip),%xmm0        # 744 <gsl_stats_short_quantile_from_sorted_data+0x44>
subsd  %xmm1,%xmm2
add    %rdi,%rsi
movswl (%rdi,%rax,1),%edx
movswl (%rsi,%rax,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    723 <gsl_stats_short_quantile_from_sorted_data+0x23>
add    %rsi,%rsi
imul   %rdx,%rsi
movswl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nop
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   731 <gsl_stats_short_quantile_from_sorted_data+0x31>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_short_quantile_from_sorted_data (const short sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 18
18 8
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 18
30 11
31 21
32 21
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 7
42 7
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
51 8
52 8
53 8
54 8
55 8
56 8
57 8
58 8
59 8
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     148b <gsl_matrix_ulong_ispos+0x8b>
xorpd  %xmm1,%xmm1
push   %rbx
lea    0x0(,%rax,8),%rbx
xor    %r8d,%r8d
xor    %r11d,%r11d
test   %rdx,%rdx
je     1455 <gsl_matrix_ulong_ispos+0x55>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
mov    (%rsi,%rax,8),%rcx
test   %rcx,%rcx
js     1470 <gsl_matrix_ulong_ispos+0x70>
cvtsi2sd %rcx,%xmm0
ucomisd %xmm0,%xmm1
jae    1487 <gsl_matrix_ulong_ispos+0x87>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1438 <gsl_matrix_ulong_ispos+0x38>
add    $0x1,%r11
add    %rbx,%r8
cmp    %r9,%r11
jne    1423 <gsl_matrix_ulong_ispos+0x23>
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    %rcx,%r10
and    $0x1,%ecx
shr    %r10
or     %rcx,%r10
cvtsi2sd %r10,%xmm0
addsd  %xmm0,%xmm0
jmp    1446 <gsl_matrix_ulong_ispos+0x46>
xor    %eax,%eax
pop    %rbx
retq   
mov    $0x1,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_ispos (const gsl_matrix_ulong * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 2
8 2
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 13
18 13
19 13
20 13
21 13
22 13
23 9
24 9
25 9
26 7
27 7
28 7
29 7
30 20
31 21
32 21
33 21
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 15
42 21
43 21
44 20
45 21
46 21
<<<sep_out_sample>>>
test   %rdi,%rdi
je     18 <gss_oid_equal+0x18>
test   %rsi,%rsi
je     18 <gss_oid_equal+0x18>
mov    (%rdi),%edx
xor    %eax,%eax
cmp    (%rsi),%edx
je     20 <gss_oid_equal+0x20>
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    0x8(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  31 <gss_oid_equal+0x31>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
gss_oid_equal (gss_const_OID first_oid, gss_const_OID second_oid)
{
  return first_oid && second_oid &&
    first_oid->length == second_oid->length &&
    memcmp (first_oid->elements, second_oid->elements,
     second_oid->length) == 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 3
8 3
9 7
10 7
11 4
12 4
13 4
14 2
15 5
16 5
17 5
18 4
19 4
20 7
21 4
22 7
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <pair_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <pair_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
pair_hash_2 (struct pair *pair)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((pair->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
cmp    $0x5,%edi
je     4c0 <dbname+0x20>
cmp    $0x3,%edi
ja     4d1 <dbname+0x31>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x2,%edi
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rax
retq   
push   %rax
callq  200 <dbname.part.4>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dbname(int db)
{
 if (db == 2 + 3)
  db = 2;
 ((db >= 0 && db < 4) ? (void) (0) : __assert_fail ("db >= 0 && db < 4", "gtagsop.c", 357, __PRETTY_FUNCTION__));
 return tagslist[db];
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 6
7 7
8 7
9 4
10 6
11 6
12 7
13 2
14 2
15 2
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smapwrap (void)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x8(%rsi),%r10
jne    1870 <gsl_vector_uchar_equal+0x40>
test   %r8,%r8
je     1867 <gsl_vector_uchar_equal+0x37>
mov    0x10(%rdi),%rcx
mov    0x10(%rsi),%rdx
xor    %eax,%eax
nop
movzbl (%rdx),%esi
cmp    %sil,(%rcx)
jne    1894 <gsl_vector_uchar_equal+0x64>
add    $0x1,%rax
add    %r9,%rcx
add    %r10,%rdx
cmp    %r8,%rax
jne    1850 <gsl_vector_uchar_equal+0x20>
mov    $0x1,%eax
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  188d <gsl_vector_uchar_equal+0x5d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_equal (const gsl_vector_uchar * u, const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (u->data[1 * stride_u * j + k] != v->data[1 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 7
3 4
4 5
5 7
6 11
7 11
8 11
9 11
10 11
11 11
12 16
13 16
14 16
15 11
16 11
17 11
18 11
19 11
20 22
21 22
22 22
23 2
24 9
25 9
26 9
27 9
28 9
29 9
30 23
31 23
32 18
33 18
34 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x90,%edi
callq  16ae <info_create_tag+0xe>
test   $0x1,%al
mov    %rax,%rdx
mov    %rax,%rdi
mov    $0x90,%esi
jne    1730 <info_create_tag+0x90>
test   $0x2,%dil
jne    1740 <info_create_tag+0xa0>
test   $0x4,%dil
jne    1760 <info_create_tag+0xc0>
mov    %esi,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%sil
rep stos %rax,%es:(%rdi)
je     16e7 <info_create_tag+0x47>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     16f7 <info_create_tag+0x57>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%esi
je     16ff <info_create_tag+0x5f>
movb   $0x0,(%rdi)
movq   $0x0,(%rdx)
movq   $0x0,0x8(%rdx)
mov    %rdx,%rax
movq   $0xffffffffffffffff,0x10(%rdx)
movq   $0xffffffffffffffff,0x18(%rdx)
movq   $0xffffffffffffffff,0x48(%rdx)
add    $0x8,%rsp
retq   
xchg   %ax,%ax
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
mov    $0x8f,%sil
test   $0x2,%dil
je     16c3 <info_create_tag+0x23>
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%esi
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     16cd <info_create_tag+0x2d>
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%esi
add    $0x4,%rdi
jmpq   16cd <info_create_tag+0x2d>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_create_tag (void)
{
  TAG *t = xmalloc (sizeof (TAG));
  memset (t, 0, sizeof (TAG));
  t->filename = 0;
  t->nodename = 0;
  t->nodestart = -1;
  t->nodestart_adjusted = -1;
  t->cache.nodelen = -1;
  return t;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 5
30 6
31 11
32 7
33 8
34 9
35 11
36 11
37 11
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmpw   $0x0,0x0(%rip)        # 7ea <page_changed+0xa>
je     801 <page_changed+0x21>
mov    0x0(%rip),%edx        # 7f2 <page_changed+0x12>
cmp    %rdi,%rdx
jl     801 <page_changed+0x21>
mov    0x0(%rip),%rax        # 7fe <page_changed+0x1e>
mov    (%rax,%rdi,4),%eax
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
page_changed(long page)
{
  if (pass == 0) return FALSE;
  if (page > page_list_size) return FALSE;
  return pages[page].changed;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  13c <hash_free_wx_entry+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   145 <hash_free_wx_entry+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_free_wx_entry (struct wx_entry * wx_entry)
{
  free (wx_entry->glyph);
  free (wx_entry);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    38 <__ham_set_h_nelem+0x38>
mov    %esi,%ebp
mov    $0x2,%esi
callq  1e <__ham_set_h_nelem+0x1e>
test   %eax,%eax
jne    2c <__ham_set_h_nelem+0x2c>
mov    0xd0(%rbx),%rdx
mov    %ebp,0x8(%rdx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   51 <__ham_set_h_nelem+0x51>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__ham_set_h_nelem(dbp, h_nelem)
 DB *dbp;
 u_int32_t h_nelem;
{
 HASH *hashp;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_h_nelem", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x02)) != 0) return (__ret); };
 hashp = dbp->h_internal;
 hashp->h_nelem = h_nelem;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 6
20 11
21 6
22 11
23 11
24 6
25 6
26 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     4066 <text_buffer_printf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  4097 <text_buffer_printf+0x87>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
text_buffer_printf (struct text_buffer *buf, const char *format, ...)
{
  va_list ap;
  size_t n;
  __builtin_va_start(ap,format);
  n = text_buffer_vprintf (buf, format, ap);
  __builtin_va_end(ap);
  return n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 6
18 5
19 5
20 5
21 5
22 5
23 6
24 9
25 9
26 9
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x50(%rdi),%rcx
mov    0x48(%rdi),%rdx
mov    %rax,%rdi
jmpq   470 <xheader_print_n>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattr_acls_d_coder (struct tar_stat_info const *st , char const *keyword,
                    struct xheader *xhdr, void const *data)
{
  xheader_print_n (xhdr, keyword, st->acls_d_ptr, st->acls_d_len);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ping_set_count (PING * ping, size_t count)
{
  ping->ping_count = count;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     96 <report+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  c7 <report+0x87>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
report (FILE *stream, const char *psz_format, ...)
{
  va_list args;
  __builtin_va_start(args,psz_format);
  vfprintf (stream, psz_format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 7
25 7
26 7
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
xor    %eax,%eax
mov    $0x0,%esi
push   %rbp
mov    %r12,%rbp
push   %rbx
mov    (%rdi),%edx
xor    %ebx,%ebx
mov    0x0(%rip),%rdi        # 15c <split_dump+0x1c>
callq  161 <split_dump+0x21>
mov    (%r12),%eax
test   %eax,%eax
jle    1ae <split_dump+0x6e>
nopl   0x0(%rax)
mov    0x8(%rbp),%rcx
mov    0x0(%rip),%rdi        # 17b <split_dump+0x3b>
mov    %ebx,%edx
mov    $0x0,%esi
xor    %eax,%eax
add    $0x18,%rbp
callq  18d <split_dump+0x4d>
mov    0x0(%rbp),%ecx
mov    0x0(%rip),%rdi        # 197 <split_dump+0x57>
mov    %ebx,%edx
xor    %eax,%eax
mov    $0x0,%esi
add    $0x1,%ebx
callq  1a8 <split_dump+0x68>
cmp    %ebx,(%r12)
jg     170 <split_dump+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
split_dump(SPLIT *list)
{
 int i;
 struct part *part;
 fprintf(stderr, "npart: %d\n", list->npart);
 for (i = 0; i < list->npart; i++) {
  part = &list->part[i];
  fprintf(stderr, "string[%d]: |%s|\n", i, part->start);
  fprintf(stderr, "savec[%d] : |%c|\n", i, part->savec);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 2
6 2
7 2
8 5
9 6
10 5
11 5
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 6
29 9
30 6
31 6
32 11
33 11
34 11
35 11
36 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     2aa8 <gsl_block_long_raw_fscanf+0x88>
mov    %rdi,%r13
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
xor    %ebp,%ebp
jmp    2a5c <gsl_block_long_raw_fscanf+0x3c>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     2aa8 <gsl_block_long_raw_fscanf+0x88>
mov    %rsp,%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  2a6e <gsl_block_long_raw_fscanf+0x4e>
mov    (%rsp),%rdx
cmp    $0x1,%eax
mov    %rdx,(%rbx)
je     2a50 <gsl_block_long_raw_fscanf+0x30>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2a93 <gsl_block_long_raw_fscanf+0x73>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   (%rax)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_long_raw_fscanf (FILE * stream,
                                  long * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          long tmp;
          int status = fscanf (stream, "%ld", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 13
21 13
22 13
23 13
24 13
25 14
26 15
27 14
28 15
29 17
30 17
31 17
32 17
33 17
34 22
35 17
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 21
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm0        # bc <gsl_hypot3+0xc>
andpd  %xmm0,%xmm1
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm3
ucomisd %xmm2,%xmm1
movapd %xmm3,%xmm4
jbe    f0 <gsl_hypot3+0x40>
ucomisd %xmm1,%xmm3
jbe    100 <gsl_hypot3+0x50>
nopl   0x0(%rax,%rax,1)
xorpd  %xmm0,%xmm0
ucomisd %xmm0,%xmm4
jp     110 <gsl_hypot3+0x60>
jne    110 <gsl_hypot3+0x60>
repz retq 
xchg   %ax,%ax
ucomisd %xmm2,%xmm3
ja     e0 <gsl_hypot3+0x30>
ucomisd %xmm2,%xmm1
movapd %xmm2,%xmm4
jbe    e0 <gsl_hypot3+0x30>
xorpd  %xmm0,%xmm0
movapd %xmm1,%xmm4
ucomisd %xmm0,%xmm4
jnp    ea <gsl_hypot3+0x3a>
xchg   %ax,%ax
divsd  %xmm4,%xmm3
divsd  %xmm4,%xmm1
divsd  %xmm4,%xmm2
mulsd  %xmm3,%xmm3
mulsd  %xmm1,%xmm1
mulsd  %xmm2,%xmm2
addsd  %xmm1,%xmm3
addsd  %xmm2,%xmm3
sqrtsd %xmm3,%xmm0
ucomisd %xmm0,%xmm0
jp     13f <gsl_hypot3+0x8f>
mulsd  %xmm4,%xmm0
retq   
movapd %xmm3,%xmm0
sub    $0x18,%rsp
movsd  %xmm4,0x8(%rsp)
callq  152 <gsl_hypot3+0xa2>
movsd  0x8(%rsp),%xmm4
add    $0x18,%rsp
mulsd  %xmm4,%xmm0
retq   
<<<sep_in_sample>>>
gsl_hypot3(const double x, const double y, const double z)
{
  double xabs = fabs(x);
  double yabs = fabs(y);
  double zabs = fabs(z);
  double w = ((xabs) > (((yabs) > (zabs) ? (yabs) : (zabs))) ? (xabs) : (((yabs) > (zabs) ? (yabs) : (zabs))));
  if (w == 0.0)
    {
      return (0.0);
    }
  else
    {
      double r = w * sqrt((xabs / w) * (xabs / w) +
                          (yabs / w) * (yabs / w) +
                          (zabs / w) * (zabs / w));
      return r;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 18
17 18
18 6
19 6
20 6
21 6
22 6
23 7
24 6
25 7
26 7
27 7
28 13
29 14
30 15
31 13
32 14
33 15
34 13
35 13
36 13
37 13
38 13
39 13
40 18
41 13
42 2
43 2
44 13
45 13
46 18
47 13
48 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0x8(%rdi),%rdx
mov    %rdi,%rbx
cmp    $0x1,%rdx
jbe    81 <gmp_snprintf_memory+0x31>
sub    $0x1,%rdx
mov    (%rdi),%rdi
cmp    %rdx,%rbp
cmovbe %rbp,%rdx
mov    %rdx,%r12
callq  7a <gmp_snprintf_memory+0x2a>
add    %r12,(%rbx)
sub    %r12,0x8(%rbx)
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gmp_snprintf_memory (struct gmp_snprintf_t *d, const char *str, size_t len)
{
  size_t n;
  do {} while (0);
  if (d->size > 1)
    {
      n = ((d->size-1) < (len) ? (d->size-1) : (len));
      memcpy (d->buf, str, n);
      d->buf += n;
      d->size -= n;
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 5
8 5
9 7
10 8
11 7
12 7
13 7
14 8
15 9
16 10
17 13
18 13
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0xe8(%rdi),%rbx
mov    0x48(%rbx),%rsi
test   %rsi,%rsi
je     11a <CDB___ham_release_meta+0x2a>
mov    0x70(%rbx),%edx
mov    (%rdi),%rdi
shr    $0x2,%edx
and    $0x1,%edx
callq  11a <CDB___ham_release_meta+0x2a>
testb  $0x4,0x150(%rbp)
movq   $0x0,0x48(%rbx)
jne    132 <CDB___ham_release_meta+0x42>
cmpq   $0x0,0x8(%rbp)
je     150 <CDB___ham_release_meta+0x60>
movq   $0x0,0x38(%rbx)
andl   $0xfffffffb,0x70(%rbx)
add    $0x8,%rsp
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x38(%rbx)
je     132 <CDB___ham_release_meta+0x42>
mov    0x0(%rbp),%rax
lea    0x38(%rbx),%rsi
mov    0x28(%rax),%rdi
callq  168 <CDB___ham_release_meta+0x78>
jmp    132 <CDB___ham_release_meta+0x42>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___ham_release_meta(dbc)
 DBC *dbc;
{
 HASH_CURSOR *hcp;
 hcp = (HASH_CURSOR *)dbc->internal;
 if (hcp->hdr)
  (void)CDB___ham_put_page(dbc->dbp, (PAGE *)hcp->hdr,
      ((hcp)->flags & (0x0004)) ? 1 : 0);
 hcp->hdr = ((void *)0);
 if (!((dbc)->flags & (0x004)) &&
     dbc->txn == ((void *)0) && hcp->hlock.off != 0)
  (void)CDB_lock_put(dbc->dbp->dbenv, &hcp->hlock);
 hcp->hlock.off = 0;
 (hcp)->flags &= ~(0x0004);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 10
15 9
16 10
17 10
18 10
19 13
20 14
21 16
22 16
23 16
24 16
25 16
26 16
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
test   %rdx,%rdx
fldt   (%rdi)
fstpt  0x10(%rsp)
je     2a4 <gsl_stats_long_double_min_index+0x64>
shl    $0x4,%rsi
xor    %ebx,%ebx
xor    %r14d,%r14d
mov    %rsi,%r13
lea    (%rdi,%rsi,1),%rbp
fldt   0x10(%rsp)
jmp    298 <gsl_stats_long_double_min_index+0x58>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     2b8 <gsl_stats_long_double_min_index+0x78>
fldt   0x0(%rbp)
fldt   0x10(%rsp)
fucomip %st(1),%st
jbe    295 <gsl_stats_long_double_min_index+0x55>
fld    %st(0)
fstpt  0x10(%rsp)
mov    %rbx,%r14
add    %r13,%rbp
fstpt  (%rsp)
callq  2a0 <gsl_stats_long_double_min_index+0x60>
test   %eax,%eax
je     278 <gsl_stats_long_double_min_index+0x38>
add    $0x20,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
add    $0x20,%rsp
mov    %r14,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_min_index (const long double data[], const size_t stride,
                                const size_t n)
{
  long double min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      long double xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          return i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 3
9 6
10 4
11 4
12 6
13 8
14 6
15 5
16 8
17 8
18 8
19 8
20 8
21 6
22 6
23 6
24 8
25 9
26 9
27 9
28 8
29 8
30 8
31 8
32 14
33 14
34 14
35 14
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 20
53 20
54 20
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 2177 <afmset_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmset_in (FILE * in_str )
{
        afmin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exact_refcnt (RC_REGEX *regex)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  a25 <system_fh_tx_packets+0x15>
test   %rax,%rax
je     a40 <system_fh_tx_packets+0x30>
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    0x18(%rax),%rcx
jmpq   a3f <system_fh_tx_packets+0x2f>
nop
mov    %rbx,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   a51 <system_fh_tx_packets+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_fh_tx_packets (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "tx_packets" " unknown)"); else put_ulong (form, argc, argv, stats->tx_packets); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    (%rdi),%rbx
mov    0x10(%rdi),%rsi
mov    %rbp,%rdi
callq  *0x30(%r12)
shl    $0x4,%rax
add    %rax,%rbx
cmp    0x8(%r12),%rbx
jae    3fb <hash_lookup+0x6b>
mov    (%rbx),%rax
test   %rax,%rax
je     3e5 <hash_lookup+0x55>
mov    %rax,%rsi
jmp    3cb <hash_lookup+0x3b>
nopl   0x0(%rax)
mov    (%rbx),%rsi
cmp    %rsi,%rbp
je     3f3 <hash_lookup+0x63>
mov    %rbp,%rdi
callq  *0x38(%r12)
test   %al,%al
jne    3f0 <hash_lookup+0x60>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    3c8 <hash_lookup+0x38>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax)
mov    (%rbx),%rsi
pop    %rbx
pop    %rbp
mov    %rsi,%rax
pop    %r12
retq   
callq  400 <hash_get_first>
<<<sep_in_sample>>>
hash_lookup (const Hash_table *table, const void *entry)
{
  struct hash_entry const *bucket
    = table->bucket + table->hasher (entry, table->n_buckets);
  struct hash_entry const *cursor;
  if (! (bucket < table->bucket_limit))
    abort ();
  if (bucket->data == ((void *)0))
    return ((void *)0);
  for (cursor = bucket; cursor; cursor = cursor->next)
    if (entry == cursor->data || table->comparator (entry, cursor->data))
      return cursor->data;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 3
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 11
24 11
25 11
26 11
27 10
28 10
29 10
30 14
31 14
32 9
33 14
34 14
35 14
36 14
37 14
38 14
39 12
40 14
41 14
42 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%r9
mov    (%rdi),%r10
mov    0x10(%rdi),%r8
test   %r9,%r9
je     3cc <gsl_combination_prev+0x1ec>
mov    %r9,%rdx
sub    $0x1,%rdx
je     249 <gsl_combination_prev+0x69>
lea    0x0(,%rdx,8),%rcx
lea    (%r8,%rcx,1),%rax
mov    -0x8(%r8,%rcx,1),%rcx
mov    (%rax),%rdi
add    $0x1,%rcx
cmp    %rcx,%rdi
jne    3d2 <gsl_combination_prev+0x1f2>
lea    -0x10(%r8,%r9,8),%rcx
jmp    243 <gsl_combination_prev+0x63>
nopl   (%rax)
mov    %rcx,%rax
mov    (%rcx),%rsi
lea    -0x8(%rcx),%rcx
mov    -0x8(%rax),%rdi
add    $0x1,%rdi
cmp    %rdi,%rsi
jne    3c0 <gsl_combination_prev+0x1e0>
sub    $0x1,%rdx
jne    228 <gsl_combination_prev+0x48>
mov    (%r8),%rcx
test   %rcx,%rcx
je     3cc <gsl_combination_prev+0x1ec>
mov    %r8,%rax
mov    $0x1,%edx
sub    $0x1,%rcx
cmp    %rdx,%r9
mov    %rcx,(%rax)
jbe    3af <gsl_combination_prev+0x1cf>
lea    (%r8,%rdx,8),%rcx
mov    %r10,%rsi
sub    %r9,%rsi
sub    %rdx,%r9
mov    %rcx,%rax
shl    $0x3c,%rax
shr    $0x3f,%rax
cmp    %r9,%rax
cmova  %r9,%rax
cmp    $0x7,%r9
cmovbe %r9,%rax
test   %rax,%rax
je     331 <gsl_combination_prev+0x151>
lea    (%rdx,%rsi,1),%rdi
cmp    $0x1,%rax
mov    %rdi,(%rcx)
lea    0x1(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rdi,%rsi,1),%r10
cmp    $0x2,%rax
mov    %r10,(%r8,%rdi,8)
lea    0x2(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rsi,%rdi,1),%r10
cmp    $0x3,%rax
mov    %r10,(%r8,%rdi,8)
lea    0x3(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rsi,%rdi,1),%r10
cmp    $0x4,%rax
mov    %r10,(%r8,%rdi,8)
lea    0x4(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rsi,%rdi,1),%r10
cmp    $0x5,%rax
mov    %r10,(%r8,%rdi,8)
lea    0x5(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rsi,%rdi,1),%r10
cmp    $0x6,%rax
mov    %r10,(%r8,%rdi,8)
lea    0x6(%rdx),%rdi
jbe    3b8 <gsl_combination_prev+0x1d8>
lea    (%rsi,%rdi,1),%r10
add    $0x7,%rdx
mov    %r10,(%r8,%rdi,8)
cmp    %r9,%rax
je     3af <gsl_combination_prev+0x1cf>
sub    %rax,%r9
mov    %r9,%rdi
shr    %rdi
mov    %rdi,%r10
add    %r10,%r10
je     3a8 <gsl_combination_prev+0x1c8>
mov    %rsi,-0x10(%rsp)
lea    0x1(%rdx),%r11
lea    (%rcx,%rax,8),%rcx
movq   -0x10(%rsp),%xmm2
mov    %rdx,-0x10(%rsp)
mov    %r11,-0x18(%rsp)
movq   -0x10(%rsp),%xmm0
punpcklqdq %xmm2,%xmm2
movhps -0x18(%rsp),%xmm0
movdqa 0x0(%rip),%xmm3        # 376 <gsl_combination_prev+0x196>
xor    %eax,%eax
movdqa %xmm0,%xmm1
add    $0x1,%rax
paddq  %xmm2,%xmm0
add    $0x10,%rcx
movdqa %xmm0,-0x10(%rcx)
paddq  %xmm3,%xmm1
cmp    %rax,%rdi
jbe    3a0 <gsl_combination_prev+0x1c0>
movdqa %xmm1,%xmm0
jmp    378 <gsl_combination_prev+0x198>
nopl   0x0(%rax)
add    %r10,%rdx
cmp    %r10,%r9
je     3af <gsl_combination_prev+0x1cf>
add    %rdx,%rsi
mov    %rsi,(%r8,%rdx,8)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rdx
jmpq   32c <gsl_combination_prev+0x14c>
mov    %rsi,%rcx
add    $0x1,%rdx
jmpq   25d <gsl_combination_prev+0x7d>
mov    $0xffffffff,%eax
retq   
mov    %rdi,%rcx
jmp    3c3 <gsl_combination_prev+0x1e3>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_prev (gsl_combination * c)
{
  const size_t n = c->n;
  const size_t k = c->k;
  size_t *data = c->data;
  size_t i;
  if(k == 0)
    {
      return GSL_FAILURE;
    }
  i = k - 1;
  while(i > 0 && data[i] == data[i-1] + 1)
    {
      i--;
    }
  if(i == 0 && data[i] == 0)
    {
      return GSL_FAILURE;
    }
  data[i++]--;
  for(; i < k; i++)
    {
      data[i] = n - k + i;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 7
5 7
6 12
7 12
8 12
9 12
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 20
34 21
35 20
36 21
37 21
38 21
39 21
40 21
41 21
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 21
50 23
51 23
52 23
53 21
54 21
55 23
56 23
57 23
58 21
59 21
60 23
61 23
62 23
63 21
64 21
65 23
66 23
67 23
68 21
69 21
70 23
71 23
72 23
73 21
74 21
75 23
76 23
77 23
78 21
79 21
80 23
81 21
82 23
83 23
84 23
85 23
86 23
87 23
88 23
89 23
90 23
91 23
92 23
93 23
94 23
95 21
96 21
97 21
98 21
99 21
100 21
101 21
102 21
103 21
104 23
105 23
106 23
107 23
108 23
109 23
110 23
111 23
112 23
113 23
114 23
115 23
116 23
117 23
118 25
119 25
120 25
121 21
122 21
123 12
124 2
125 2
126 9
127 9
128 12
129 12
130 12
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  1f2 <f_ulong+0x12>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_ulong (FILE *fp, void *ptr, int size) { fprintf (fp, "%lu", *(unsigned long*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
cmp    $0x9,%dil
sete   %al
cmp    $0x20,%dil
sete   %dl
or     %edx,%eax
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_space (unsigned char c)
{
  return (c == 0x20) || (c == 0x09);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 17 <do_last_file+0x7>
sub    $0x1,%rax
mov    %rax,0x0(%rip)        # 22 <do_last_file+0x12>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_last_file(void)
{
    selected = filelist_len - 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     56 <__gmp_fscanf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  92 <__gmp_fscanf+0x92>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_fscanf (FILE *fp, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doscan (&__gmp_fscanf_funs, fp, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 6
18 2
19 6
20 6
21 5
22 5
23 5
24 5
25 5
26 6
27 9
28 9
<<<sep_out_sample>>>
movslq %edi,%rdi
shl    $0x3,%rdi
jmpq   3c <strvec_mcreate+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
strvec_mcreate (n)
     int n;
{
  return ((char **)malloc ((n) * sizeof (char *)));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_tree_iterator_free (gl_oset_iterator_t *iterator)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     de1 <gsl_vector_float_ispos+0x31>
mov    0x10(%rdi),%rdx
xorps  %xmm0,%xmm0
shl    $0x2,%rsi
xor    %eax,%eax
nopl   0x0(%rax)
ucomiss (%rdx),%xmm0
jae    de7 <gsl_vector_float_ispos+0x37>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    dd0 <gsl_vector_float_ispos+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_ispos (const gsl_vector_float * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 6
13 6
14 6
15 6
16 17
17 18
18 13
19 13
20 13
<<<sep_out_sample>>>
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_generic_unimplemented_set_blocksize (void *p_user_data,
                                          uint16_t i_blocksize) {
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    0x20(%rdi),%rax
mov    %rdi,%rbx
mov    0x18(%rax),%rdx
movzbl (%rdx),%eax
test   %al,%al
je     f9d <execute_file_commands+0x3d>
nopl   0x0(%rax,%rax,1)
movzbl %al,%ecx
testb  $0x6,0x0(%rcx,%rcx,1)
jne    f92 <execute_file_commands+0x32>
cmp    $0x2d,%al
je     f92 <execute_file_commands+0x32>
cmp    $0x40,%al
je     f92 <execute_file_commands+0x32>
cmp    $0x2b,%al
nop
jne    fc0 <execute_file_commands+0x60>
add    $0x1,%rdx
movzbl (%rdx),%eax
test   %al,%al
jne    f78 <execute_file_commands+0x18>
mov    %rbx,%rdi
mov    $0x2,%esi
callq  faa <execute_file_commands+0x4a>
andb   $0xfc,0x84(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   fba <execute_file_commands+0x5a>
nopw   0x0(%rax,%rax,1)
xor    %esi,%esi
mov    %rbx,%rdi
callq  fca <execute_file_commands+0x6a>
mov    %rbx,%rdi
callq  fd2 <execute_file_commands+0x72>
testb  $0x40,0x84(%rbx)
je     fe3 <execute_file_commands+0x83>
mov    (%rbx),%rdi
callq  fe3 <execute_file_commands+0x83>
mov    %rbx,%rdi
pop    %rbx
jmpq   fec <execute_file_commands+0x8c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
execute_file_commands (struct file *file)
{
  const char *p;
  for (p = file->cmds->commands; *p != '\0'; ++p)
    if (!(((stopchar_map[(unsigned char)((*p))])&(((0x0002|0x0004)))) != 0) && *p != '-' && *p != '@' && *p != '+')
      break;
  if (*p == '\0')
    {
      set_command_state (file, cs_running);
      file->update_status = us_success;
      notice_finished_file (file);
      return;
    }
  initialize_file_variables (file, 0);
  set_file_variables (file);
  if (file->loaded)
    unload_file (file->name);
  new_job (file);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 4
20 4
21 4
22 4
23 9
24 9
25 9
26 10
27 11
28 19
29 11
30 11
31 14
32 14
33 14
34 15
35 15
36 16
37 16
38 17
39 17
40 18
41 19
42 18
43 18
<<<sep_out_sample>>>
cmp    %esi,%ecx
jl     21e0 <select_arg+0x10>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
movslq %ecx,%rcx
mov    (%rdx,%rcx,8),%rax
mov    %rax,0x18(%rdi)
jmpq   1a70 <print_interfaceX.constprop.26>
<<<sep_in_sample>>>
select_arg (format_data_t form, int argc, char *argv[], int nr)
{
  if (nr < argc)
    {
      form->format = argv[nr];
      print_interfaceX (form, 0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f9 <safe_write+0x9>
test   %rax,%rax
js     103 <safe_write+0x13>
add    $0x8,%rsp
retq   
callq  108 <safe_write+0x18>
mov    (%rax),%esi
mov    $0x0,%edx
mov    $0x1,%edi
pop    %rcx
xor    %eax,%eax
jmpq   11c <safe_write+0x2c>
<<<sep_in_sample>>>
safe_write (int socket, const char *str, size_t len)
{
  if (write (socket, str, len) < 0)
    error (1, (*__errno_location ()), "error sending data");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 4
8 4
9 4
10 4
11 5
12 4
13 4
<<<sep_out_sample>>>
test   $0xf,%sil
jne    113 <nettle_aes256_encrypt+0x23>
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 100 <nettle_aes256_encrypt+0x10>
mov    %rcx,%r9
mov    %rsi,%rcx
mov    %rdi,%rsi
mov    $0xe,%edi
jmpq   113 <nettle_aes256_encrypt+0x23>
lea    0x0(%rip),%rcx        # 11a <nettle_aes256_encrypt+0x2a>
push   %rax
lea    0x0(%rip),%rsi        # 122 <nettle_aes256_encrypt+0x32>
lea    0x0(%rip),%rdi        # 129 <nettle_aes256_encrypt+0x39>
mov    $0x50,%edx
callq  133 <nettle_aes256_encrypt+0x43>
<<<sep_in_sample>>>
nettle_aes256_encrypt(const struct aes256_ctx *ctx,
        size_t length, uint8_t *dst,
        const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "aes-encrypt.c", 80, __PRETTY_FUNCTION__));
  _nettle_aes_encrypt(14, ctx->keys, &_nettle_aes_encrypt_table,
        length, dst, src);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 5
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2f0 <gsl_multimin_fdfminimizer_free+0x40>
mov    (%rdi),%rax
mov    0x30(%rdi),%rdi
callq  *0x30(%rax)
mov    0x30(%rbx),%rdi
callq  2cc <gsl_multimin_fdfminimizer_free+0x1c>
mov    0x28(%rbx),%rdi
callq  2d5 <gsl_multimin_fdfminimizer_free+0x25>
mov    0x20(%rbx),%rdi
callq  2de <gsl_multimin_fdfminimizer_free+0x2e>
mov    0x18(%rbx),%rdi
callq  2e7 <gsl_multimin_fdfminimizer_free+0x37>
mov    %rbx,%rdi
pop    %rbx
jmpq   2f0 <gsl_multimin_fdfminimizer_free+0x40>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_free (gsl_multimin_fdfminimizer * s)
{
  if (!s) { return ; };
  (s->type->free) (s->state);
  free (s->state);
  gsl_vector_free (s->dx);
  gsl_vector_free (s->gradient);
  gsl_vector_free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 10
18 9
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     88 <VPrintPolygon+0x88>
movswl 0x2(%rsi),%edx
test   %dx,%dx
je     88 <VPrintPolygon+0x88>
xor    %eax,%eax
mov    $0x0,%esi
xor    %ebp,%ebp
callq  2c <VPrintPolygon+0x2c>
xor    %ebx,%ebx
cmpw   $0x0,0x2(%r12)
jle    79 <VPrintPolygon+0x79>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rax
add    0x20(%r12),%rax
mov    $0x0,%esi
mov    %r13,%rdi
add    $0x1,%ebx
add    $0x18,%rbp
movsd  0x10(%rax),%xmm2
movsd  0x8(%rax),%xmm1
movsd  (%rax),%xmm0
mov    $0x3,%eax
callq  6f <VPrintPolygon+0x6f>
movswl 0x2(%r12),%eax
cmp    %ebx,%eax
jg     40 <VPrintPolygon+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %r13,%rcx
mov    $0x15,%edx
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   a9 <VPrintPolygon+0xa9>
<<<sep_in_sample>>>
VPrintPolygon(FILE * file, VPolygon * p)
{
 int i;
 char *nullPoly = "*** Null Polygon ***\n";
 if (p == (VPolygon *) ((void *)0))
  fprintf(file, nullPoly);
 else {
  if (p->numVtces == 0) {
   fprintf(file, nullPoly);
   return;
  }
  fprintf(file, "%d vertices:\n", p->numVtces);
  for (i = 0; i < p->numVtces; ++i)
   fprintf(file, "%9.6g %9.6g %9.6g\n", p->vertex[i].x,
     p->vertex[i].y, p->vertex[i].z);
 }
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 8
11 8
12 8
13 12
14 12
15 13
16 12
17 13
18 13
19 13
20 13
21 15
22 15
23 14
24 14
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 13
33 13
34 13
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 6
44 6
45 18
46 18
47 18
48 18
49 6
50 6
51 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1d8 <__osip_nist_free+0x38>
xor    %ecx,%ecx
mov    $0x0,%edi
xor    %eax,%eax
mov    $0x0,%r8d
mov    $0x5,%edx
mov    $0x49,%esi
callq  1c7 <__osip_nist_free+0x27>
mov    0x0(%rip),%rax        # 1ce <__osip_nist_free+0x2e>
mov    %rbx,%rdi
test   %rax,%rax
je     1e0 <__osip_nist_free+0x40>
callq  *%rax
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  1e5 <__osip_nist_free+0x45>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
__osip_nist_free (osip_nist_t * nist)
{
  if (nist == ((void *)0))
    return 0;
  osip_trace ("nist.c", 73, TRACE_LEVEL5, ((void *)0), "free nist resource\n");
  { if (nist!=((void *)0)) { if (osip_free_func) osip_free_func(nist); else free(nist);} };
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 6
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    %rsi,(%rdi)
jbe    2f08 <gsl_vector_short_alloc_row_from_matrix+0x58>
mov    $0x28,%edi
callq  2ecb <gsl_vector_short_alloc_row_from_matrix+0x1b>
test   %rax,%rax
je     2f2a <gsl_vector_short_alloc_row_from_matrix+0x7a>
mov    0x10(%rbx),%rcx
lea    (%rcx,%rcx,1),%rdx
imul   %rbp,%rdx
add    0x18(%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x8(%rbx),%rdx
movq   $0x1,0x8(%rax)
movq   $0x0,0x18(%rax)
mov    %rdx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xb5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f21 <gsl_vector_short_alloc_row_from_matrix+0x71>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x8,%ecx
mov    $0xbd,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f43 <gsl_vector_short_alloc_row_from_matrix+0x93>
xor    %eax,%eax
jmp    2efb <gsl_vector_short_alloc_row_from_matrix+0x4b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_alloc_row_from_matrix (gsl_matrix_short * m,
                                              const size_t i)
{
  gsl_vector_short * v;
  const size_t M = m->size1;
  if (i >= M)
    {
      do { gsl_error ("row index is out of range", "getset_source.c", 181, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_short *) malloc (sizeof (gsl_vector_short));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 189
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * i * m->tda ;
  v->size = m->size2;
  v->stride = 1;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 10
9 10
10 11
11 11
12 20
13 20
14 20
15 20
16 20
17 21
18 22
19 23
20 21
21 25
22 25
23 25
24 25
25 25
26 8
27 8
28 8
29 8
30 8
31 25
32 8
33 25
34 25
35 25
36 13
37 13
38 13
39 13
40 13
41 17
42 17
43 17
<<<sep_out_sample>>>
mov    %edi,%eax
xor    %edi,%edi
movb   $0x0,0x0(%rip)        # 585b <ntoa+0xb>
test   %eax,%eax
js     5898 <ntoa+0x48>
mov    $0x0,%ecx
nopl   0x0(%rax)
xor    %edx,%edx
sub    $0x1,%rcx
div    %esi
mov    %edx,%edx
test   %eax,%eax
movzbl 0x0(%rdx),%edx
mov    %dl,(%rcx)
jne    5868 <ntoa+0x18>
test   %dil,%dil
mov    %rcx,%rax
je     588f <ntoa+0x3f>
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
nopl   0x0(%rax,%rax,1)
neg    %eax
mov    $0x1,%edi
jmp    585f <ntoa+0xf>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ntoa (int32_t value, int radix)
{
  _Bool negative;
  uint32_t uvalue;
  static char str[256];
  char *s = &str[sizeof str];
  *--s = '\0';
  if (value < 0)
    {
      negative = 1;
      uvalue = -(uint32_t) value;
    }
  else
    {
      negative = 0;
      uvalue = (uint32_t) value;
    }
  do
    {
      *--s = digits[uvalue % radix];
      uvalue /= radix;
    }
  while (uvalue > 0);
  if (negative)
    *--s = '-';
  return s;
}
<<<sep_in_sample>>>
1 16
2 15
3 7
4 8
5 8
6 15
7 15
8 20
9 20
10 20
11 20
12 23
13 20
14 20
15 23
16 24
17 20
18 24
19 25
20 25
21 27
22 27
23 27
24 11
25 10
26 10
27 10
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
mov    %r9,%r15
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%ebp
lea    0x1(%rbp),%eax
mov    %eax,(%rdi)
movslq %ebp,%rax
lea    (%rdi,%rax,8),%rbx
mov    %rsi,%rdi
movq   $0x0,0xa8(%rbx)
callq  68b <rec_mset_register_type+0x3b>
mov    %r12,0x28(%rbx)
mov    %rax,0x8(%rbx)
mov    %ebp,%eax
mov    %r13,0x48(%rbx)
mov    %r14,0x68(%rbx)
mov    %r15,0x88(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_mset_register_type (rec_mset_t mset,
                        char *name,
                        rec_mset_disp_fn_t disp_fn,
                        rec_mset_equal_fn_t equal_fn,
                        rec_mset_dup_fn_t dup_fn,
                        rec_mset_compare_fn_t compare_fn)
{
  rec_mset_type_t new_type;
  new_type = mset->ntypes++;
  mset->count[new_type] = 0;
  mset->name[new_type] = strdup (name);
  mset->disp_fn[new_type] = disp_fn;
  mset->equal_fn[new_type] = equal_fn;
  mset->dup_fn[new_type] = dup_fn;
  mset->compare_fn[new_type] = compare_fn;
  return new_type;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 11
18 10
19 11
20 12
21 11
22 17
23 13
24 14
25 15
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_state (const gsl_rng * r)
{
  return r->state;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     67a <mu_mailcap_destroy+0x9a>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%r13
test   %r13,%r13
je     670 <mu_mailcap_destroy+0x90>
cmpq   $0x0,0x8(%r13)
je     670 <mu_mailcap_destroy+0x90>
mov    $0x1,%r12d
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
mov    0x0(%r13),%rax
mov    $0x1,%ebx
mov    (%rax,%rdx,8),%rbp
mov    0x0(%rbp),%rdi
callq  626 <mu_mailcap_destroy+0x46>
mov    0x8(%rbp),%rdi
callq  62f <mu_mailcap_destroy+0x4f>
xor    %eax,%eax
cmpq   $0x0,0x18(%rbp)
jne    646 <mu_mailcap_destroy+0x66>
jmp    65d <mu_mailcap_destroy+0x7d>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rdx,%rbx
mov    0x10(%rbp),%rdx
mov    (%rdx,%rax,8),%rdi
callq  653 <mu_mailcap_destroy+0x73>
cmp    %rbx,0x18(%rbp)
lea    0x1(%rbx),%rdx
ja     640 <mu_mailcap_destroy+0x60>
cmp    %r12,0x8(%r13)
lea    0x1(%r12),%rax
jbe    670 <mu_mailcap_destroy+0x90>
mov    %r12,%rdx
mov    %rax,%r12
jmp    610 <mu_mailcap_destroy+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_mailcap_destroy (mu_mailcap_t * pmailcap)
{
  if (pmailcap != ((void *)0) && *pmailcap != ((void *)0))
    {
      int i;
      mu_mailcap_t mailcap = *pmailcap;
      for (i = 0; i < mailcap->entries_count; i++)
 {
   int j;
   mu_mailcap_entry_t entry = mailcap->entries[i];
   free (entry->typefield);
   free (entry->viewcommand);
   for (j = 0; j < entry->fields_count; j++)
     {
       free (entry->fields[j]);
     }
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 7
12 7
13 7
14 7
15 7
16 10
17 13
18 10
19 11
20 11
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 15
33 13
34 13
35 13
36 7
37 7
38 7
39 7
40 7
41 7
42 19
43 19
44 19
45 19
46 19
47 19
48 19
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    (%rax),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
jmpq   1c9b <gsl_sort_vector2_int+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector2_int (gsl_vector_int * v1, gsl_vector_int * v2)
{
  gsl_sort2_int (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x30,(%rdi)
mov    %rdi,%rbx
je     4c0 <sh_invalidnum+0x30>
mov    $0x0,%edi
callq  4a3 <sh_invalidnum+0x13>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
xor    %eax,%eax
pop    %rbx
jmpq   4b6 <sh_invalidnum+0x26>
nopw   %cs:0x0(%rax,%rax,1)
callq  4c5 <sh_invalidnum+0x35>
movzbl 0x1(%rbx),%edx
mov    (%rax),%rax
movzbl %dl,%ecx
testb  $0x8,0x1(%rax,%rcx,2)
jne    4f0 <sh_invalidnum+0x60>
cmp    $0x78,%dl
jne    499 <sh_invalidnum+0x9>
mov    $0x0,%edi
callq  4e5 <sh_invalidnum+0x55>
mov    %rax,%rdx
jmp    4a6 <sh_invalidnum+0x16>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  4fa <sh_invalidnum+0x6a>
mov    %rax,%rdx
jmp    4a6 <sh_invalidnum+0x16>
nop
<<<sep_in_sample>>>
sh_invalidnum (s)
     char *s;
{
  char *msg;
  if (*s == '0' && ((*__ctype_b_loc ())[(int) (((unsigned char)s[1]))] & (unsigned short int) _ISdigit))
    msg = gettext("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = gettext("invalid hex number");
  else
    msg = gettext("invalid number");
  builtin_error ("%s: %s", s, msg);
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 10
6 10
7 10
8 11
9 11
10 11
11 12
12 11
13 11
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 6
28 6
29 6
30 6
31 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
closeScene()
{
 int i;
 for (i=0; i<128; ++i) {
  if (stbl[i].type != 0) {
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r12
lea    0x58(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  9c <osip_message_get_alert_info+0x1c>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    b5 <osip_message_get_alert_info+0x35>
mov    %ebx,%esi
mov    %r12,%rdi
callq  af <osip_message_get_alert_info+0x2f>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_alert_info (const osip_message_t * sip, int pos, osip_alert_info_t ** dest)
{
  osip_alert_info_t *alert_info;
  *dest = ((void *)0);
  if (osip_list_size (&sip->alert_infos) <= pos)
    return -1;
  alert_info = (osip_alert_info_t *) osip_list_get (&sip->alert_infos, pos);
  *dest = alert_info;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 9
17 8
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
mov    %rsi,0x38(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_algorithm (osip_authorization_t * authorization, char *algorithm)
{
  authorization->algorithm = (char *) algorithm;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    0x10(%rdi),%edx
xor    %eax,%eax
mov    %rdi,%rbx
test   %edx,%edx
jne    2b4 <mu_iterator_next+0x14>
mov    0x8(%rdi),%rdi
callq  *0x30(%rbx)
movl   $0x0,0x10(%rbx)
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
mu_iterator_next (mu_iterator_t iterator)
{
  int status = 0;
  if (!iterator->is_advanced)
    status = iterator->next (iterator->owner);
  iterator->is_advanced = 0;
  return status;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 2
5 4
6 4
7 5
8 5
9 6
10 8
11 8
12 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     610 <_cdio_list_node_next+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_cdio_list_node_next (CdioListNode_t *p_node)
{
  if (p_node)
    return p_node->next;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 6
8 6
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    (%rcx),%rax
cmp    0x8(%rcx),%rax
je     1410 <gsl_blas_dtrsv+0x30>
mov    $0x14,%ecx
mov    $0x393,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1406 <gsl_blas_dtrsv+0x26>
mov    $0x14,%eax
add    $0x28,%rsp
retq   
cmp    (%r8),%rax
je     1440 <gsl_blas_dtrsv+0x60>
mov    $0x13,%ecx
mov    $0x397,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  142e <gsl_blas_dtrsv+0x4e>
mov    $0x13,%eax
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%r8),%r10
mov    0x18(%rcx),%r9
mov    %r10d,0x10(%rsp)
mov    0x10(%r8),%r8
mov    %r8,0x8(%rsp)
mov    0x10(%rcx),%rcx
mov    %eax,%r8d
mov    %ecx,(%rsp)
mov    %edx,%ecx
mov    %esi,%edx
mov    %edi,%esi
mov    $0x65,%edi
callq  1470 <gsl_blas_dtrsv+0x90>
xor    %eax,%eax
jmp    140b <gsl_blas_dtrsv+0x2b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 915, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (N != X->size)
    {
      do { gsl_error ("invalid length", "blas.c", 919, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_dtrsv (CblasRowMajor, Uplo, TransA, Diag, ((int)(N)), A->data,
               ((int)(A->tda)), X->data, ((int)(X->stride)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 17
12 17
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 17
22 17
23 17
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 16
38 16
39 16
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x1009,%eax
je     10fa <mu_locker_get_expire_time+0x1a>
test   %rsi,%rsi
mov    $0x16,%ax
je     10fa <mu_locker_get_expire_time+0x1a>
mov    0x14(%rdi),%eax
mov    %eax,(%rsi)
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_locker_get_expire_time (mu_locker_t locker, int *ptime)
{
  if (!locker)
    return (0x1000 +9);
  if (!ptime)
    return 22;
  *ptime = locker->expire_time;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 7
8 7
9 8
10 9
11 9
<<<sep_out_sample>>>
movq   $0x0,(%rcx)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
        JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  12b <_body_read+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   14a <_body_read+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_body_read (mu_stream_t stream, char *buffer, size_t n, mu_off_t off, size_t *pn)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_read (body->fstream, buffer, n, off, pn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 4
11 4
12 5
13 4
14 4
15 4
16 5
17 5
18 5
19 4
20 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
cmp    0x8(%rdi),%r11
je     278a <gsl_matrix_ulong_transpose+0x2a>
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2783 <gsl_matrix_ulong_transpose+0x23>
mov    $0x14,%eax
pop    %rbx
retq   
test   %r11,%r11
je     27ee <gsl_matrix_ulong_transpose+0x8e>
xor    %esi,%esi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
je     27ee <gsl_matrix_ulong_transpose+0x8e>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rdi),%r8
mov    %rbx,%rax
nopw   0x0(%rax,%rax,1)
mov    0x10(%rdi),%rdx
mov    %rsi,%rcx
imul   %rdx,%rcx
imul   %rax,%rdx
add    %rax,%rcx
add    $0x1,%rax
add    %rsi,%rdx
lea    (%r8,%rcx,8),%rcx
cmp    %r11,%rax
lea    (%r8,%rdx,8),%rdx
mov    (%rcx),%r9
mov    (%rdx),%r10
mov    %r10,(%rcx)
mov    %r9,(%rdx)
jne    27b0 <gsl_matrix_ulong_transpose+0x50>
mov    %rbx,%rsi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
jne    27a0 <gsl_matrix_ulong_transpose+0x40>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_transpose (gsl_matrix_ulong * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned long tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 16
24 16
25 16
26 17
27 16
28 12
29 17
30 19
31 12
32 20
33 19
34 20
35 20
36 21
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
45 27
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3ba0 <rc_set_debug_level+0x50>
cmpb   $0x0,0x1(%rdi)
jne    3b80 <rc_set_debug_level+0x30>
callq  3b64 <rc_set_debug_level+0x14>
movsbl (%rbx),%edx
mov    (%rax),%rax
movsbq %dl,%rcx
testb  $0x8,0x1(%rax,%rcx,2)
je     3b80 <rc_set_debug_level+0x30>
sub    $0x30,%edx
mov    %edx,0x0(%rip)        # 3b7e <rc_set_debug_level+0x2e>
pop    %rbx
retq   
mov    $0x0,%edi
callq  3b8a <rc_set_debug_level+0x3a>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   3b98 <rc_set_debug_level+0x48>
nopl   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 3baa <rc_set_debug_level+0x5a>
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rc_set_debug_level (char *arg)
{
  if (!arg)
    debug_level = 0;
  else if (arg[1] != 0 || !((*__ctype_b_loc ())[(int) ((arg[0]))] & (unsigned short int) _ISdigit))
    {
      mprintf (gettext("Not a valid debugging level: %s"), arg);
      return;
    }
  else
    debug_level = arg[0] - '0';
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 11
14 11
15 12
16 12
17 7
18 7
19 7
20 7
21 7
22 12
23 7
24 7
25 4
26 12
27 12
28 12
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     40 <dep_hash_1+0x40>
sub    $0x1,%rax
movzbl 0x1(%rax),%edx
lea    0x1(%rax),%rdi
xor    %eax,%eax
test   %dl,%dl
je     4d <dep_hash_1+0x4d>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    20 <dep_hash_1+0x20>
repz retq 
xchg   %ax,%ax
mov    0x10(%rdi),%rax
mov    (%rax),%rax
sub    $0x1,%rax
jmp    d <dep_hash_1+0xd>
repz retq 
nop
<<<sep_in_sample>>>
dep_hash_1 (const void *key)
{
  const struct dep *d = key;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((d)->name ? (d)->name : (d)->file->name))) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 4
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  b8f <_prog_get_transport2+0xf>
mov    0x18(%rax),%rdi
mov    %rbp,%rsi
mov    %rax,%rbx
callq  b9e <_prog_get_transport2+0x1e>
test   %eax,%eax
je     bb0 <_prog_get_transport2+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x20(%rbx),%rdi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   bc0 <_file_size>
<<<sep_in_sample>>>
_prog_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  int rc;
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  if ((rc = mu_stream_get_transport (fs->in, pin)) != 0)
    return rc;
  return mu_stream_get_transport (fs->out, pout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 4
10 5
11 5
12 5
13 8
14 8
15 8
16 8
17 8
18 7
19 7
20 8
21 8
22 8
23 7
<<<sep_out_sample>>>
mov    0xe0(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_cseq (const osip_message_t * sip)
{
  return sip->cseq;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_subname (rec_sex_ast_node_t node)
{
  return node->val.name[1];
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%rdi
mov    %rdx,%rsi
shr    %rsi
lea    (%rdi,%rdi,1),%rcx
je     543 <gsl_vector_complex_float_reverse+0x73>
lea    -0x4(,%rdx,4),%rdx
mov    %rcx,%r8
shl    $0x3,%rdi
neg    %r8
imul   %rcx,%rdx
shl    $0x2,%r8
xor    %ecx,%ecx
add    %rax,%rdx
nopw   %cs:0x0(%rax,%rax,1)
movss  (%rdx),%xmm0
add    $0x1,%rcx
movss  (%rax),%xmm1
movss  %xmm1,(%rdx)
movss  %xmm0,(%rax)
movss  0x4(%rax),%xmm1
movss  0x4(%rdx),%xmm0
movss  %xmm1,0x4(%rdx)
add    %r8,%rdx
movss  %xmm0,0x4(%rax)
add    %rdi,%rax
cmp    %rsi,%rcx
jne    510 <gsl_vector_complex_float_reverse+0x40>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_reverse (gsl_vector_complex_float * v)
{
  float * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 2 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 2; k++)
        {
          float tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 6
4 8
5 8
6 6
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 14
18 8
19 15
20 15
21 16
22 15
23 14
24 15
25 15
26 16
27 16
28 8
29 8
30 20
31 20
32 20
<<<sep_out_sample>>>
jmpq   22a5 <yyalloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2aa7 <name_from_list+0x7>
test   %rax,%rax
je     2b00 <name_from_list+0x60>
nopl   0x0(%rax)
cmpq   $0x0,0x30(%rax)
jne    2ac0 <name_from_list+0x20>
mov    0x10(%rax),%rdx
cmpb   $0x0,(%rdx)
jne    2ad8 <name_from_list+0x38>
mov    (%rax),%rax
test   %rax,%rax
mov    %rax,0x0(%rip)        # 2acd <name_from_list+0x2d>
jne    2ab0 <name_from_list+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    0x28(%rax),%edi
movq   $0x1,0x30(%rax)
callq  2aec <name_from_list+0x4c>
mov    0x0(%rip),%rax        # 2af3 <name_from_list+0x53>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 2b07 <name_from_list+0x67>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 2b11 <name_from_list+0x71>
jne    2ab0 <name_from_list+0x10>
jmp    2acf <name_from_list+0x2f>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
name_from_list (void)
{
  if (!gnu_list_name)
    gnu_list_name = namelist;
  while (gnu_list_name
  && (gnu_list_name->found_count || gnu_list_name->name[0] == 0))
    gnu_list_name = gnu_list_name->next;
  if (gnu_list_name)
    {
      gnu_list_name->found_count++;
      chdir_do (gnu_list_name->change_dir);
      return gnu_list_name;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 7
11 5
12 7
13 5
14 14
15 15
16 15
17 2
18 11
19 10
20 11
21 12
22 15
23 15
24 15
25 4
26 5
27 4
28 5
29 5
30 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     db0 <via_get_port+0x10>
mov    0x18(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_get_port (osip_via_t * via)
{
  if (via == ((void *)0))
    return ((void *)0);
  return via->port;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  2f6 <mkfilename+0x16>
test   %rax,%rax
mov    %rax,%rbp
je     325 <mkfilename+0x45>
cmpb   $0x2f,-0x1(%rbx,%rax,1)
lea    -0x1(%rax),%rcx
je     31e <mkfilename+0x3e>
jmp    325 <mkfilename+0x45>
nopl   0x0(%rax,%rax,1)
cmpb   $0x2f,-0x1(%rbx,%rcx,1)
lea    -0x1(%rcx),%rax
jne    379 <mkfilename+0x99>
mov    %rax,%rcx
test   %rcx,%rcx
jne    310 <mkfilename+0x30>
xor    %ebp,%ebp
mov    %r13,%rdi
callq  32d <mkfilename+0x4d>
mov    %r12,%rdi
mov    %rax,%r14
callq  338 <mkfilename+0x58>
lea    0x2(%r14,%rax,1),%rdi
add    %rbp,%rdi
callq  345 <mkfilename+0x65>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    %rax,%rbp
callq  353 <mkfilename+0x73>
lea    0x1(%rax),%rdi
mov    %r13,%rsi
movb   $0x2f,(%rax)
callq  362 <mkfilename+0x82>
mov    %r12,%rsi
mov    %rax,%rdi
callq  36d <mkfilename+0x8d>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
mov    %rcx,%rbp
jmp    325 <mkfilename+0x45>
xchg   %ax,%ax
<<<sep_in_sample>>>
mkfilename (const char *dir, const char *name, const char *suf)
{
  size_t dirlen = strlen (dir);
  char *s;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  s = xmalloc (dirlen + 1 + strlen (name) + strlen (suf) + 1);
  strcpy (s, dir);
  strcat (s, "/");
  strcat (s, name);
  strcat (s, suf);
  return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 5
11 3
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 7
36 8
37 10
38 10
39 9
40 10
41 11
42 11
43 11
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 13
53 13
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0xffffffffffffffff,%rdx
xor    %edi,%edi
jmpq   dc1 <variable_expand+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
variable_expand (const char *line)
{
  return variable_expand_string (((void *)0), line, (long)-1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r14
mov    %esi,%r14d
mov    $0x100,%esi
push   %r13
mov    %rdi,%r13
mov    $0x1,%edi
push   %r12
mov    %rcx,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x30,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
test   %rdx,%rdx
movq   $0x0,(%rsp)
cmove  %rsp,%rbx
callq  616 <mu_nntp_parse_article+0x46>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     663 <mu_nntp_parse_article+0x93>
lea    0x10(%rsp),%rdi
mov    $0xfa,%ecx
mov    %r14d,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  63c <mu_nntp_parse_article+0x6c>
mov    0x20(%r13),%rdi
lea    0x10(%rsp),%rsi
xor    %eax,%eax
mov    %rbp,%rcx
mov    %rbx,%rdx
callq  652 <mu_nntp_parse_article+0x82>
cmpb   $0x0,0x0(%rbp)
je     680 <mu_nntp_parse_article+0xb0>
test   %r12,%r12
je     68c <mu_nntp_parse_article+0xbc>
mov    %rbp,(%r12)
xor    %eax,%eax
mov    0x28(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    698 <mu_nntp_parse_article+0xc8>
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
test   %r12,%r12
movl   $0x3e303c,0x0(%rbp)
jne    65d <mu_nntp_parse_article+0x8d>
mov    %rbp,%rdi
callq  694 <mu_nntp_parse_article+0xc4>
xor    %eax,%eax
jmp    663 <mu_nntp_parse_article+0x93>
callq  69d <mu_nntp_parse_article+0xcd>
<<<sep_in_sample>>>
mu_nntp_parse_article(mu_nntp_t nntp, int code, unsigned long *pnum, char **mid)
{
  unsigned long dummy = 0;
  char *buf;
  char format[24];
  if (pnum == ((void *)0))
    pnum = &dummy;
  buf = calloc(1, 256);
  if (buf == ((void *)0))
    {
      return 12;
    }
  sprintf (format, "%d %%ld %%%ds", code, 250);
  sscanf (nntp->ack.buf, format, pnum, buf);
  if (*buf == '\0')
    {
      strcpy (buf, "<0>");
    }
  if (mid)
    {
      *mid = buf;
    }
  else
    {
      free (buf);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 8
4 2
5 2
6 8
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 7
17 3
18 7
19 8
20 8
21 11
22 9
23 9
24 13
25 13
26 13
27 13
28 13
29 13
30 14
31 14
32 14
33 14
34 14
35 14
36 15
37 15
38 19
39 19
40 21
41 27
42 28
43 28
44 28
45 28
46 28
47 28
48 28
49 28
50 28
51 28
52 19
53 17
54 19
55 25
56 25
57 27
58 27
59 28
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     19d0 <gsl_vector_int_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19c5 <gsl_vector_int_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1a03 <gsl_vector_int_add+0x63>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%esi
add    %r9,%rcx
add    %esi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    19f0 <gsl_vector_int_add+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_add (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    1790 <gsl_matrix_float_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,4),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  17b2 <gsl_matrix_float_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_row (gsl_matrix_float * m, const size_t i)
{
  _gsl_vector_float_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
test   %edi,%edi
je     25 <_nettle_umac_l2_init+0x25>
lea    -0x1(%rdi),%eax
lea    0x4(%rsi,%rax,4),%rdx
nopl   0x0(%rax)
mov    (%rsi),%eax
add    $0x4,%rsi
bswap  %eax
and    $0x1ffffff,%eax
mov    %eax,-0x4(%rsi)
cmp    %rdx,%rsi
jne    10 <_nettle_umac_l2_init+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_nettle_umac_l2_init (unsigned size, uint32_t *k)
{
  unsigned i;
  for (i = 0; i < size; i++)
    {
      uint32_t w = k[i];
      w = (((((w)<<(8)) | ((w)>>((-(8)&31)))) & 0x00FF00FFUL) | ((((w)<<(24)) | ((w)>>((-(24)&31)))) & 0xFF00FF00UL));
      k[i] = w & 0x01ffffffUL;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 8
10 8
11 4
12 4
13 4
14 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     288 <osip_list_size+0x8>
mov    (%rdi),%eax
retq   
mov    $0xfffffffe,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
osip_list_size (const osip_list_t * li)
{
  if (li == ((void *)0))
    return -2;
  return li->nb_elt;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
7 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
cmpl   $0x1,0x118(%rdi)
jne    bb <a2ps_print_buffer+0x4b>
cmp    %rcx,%rdx
mov    %rsi,%r13
mov    %rdx,%rbx
mov    %rcx,%rbp
mov    %r8d,%r14d
jae    b2 <a2ps_print_buffer+0x42>
nopl   (%rax)
movzbl 0x0(%r13,%rbx,1),%esi
mov    %r14d,%edx
mov    %r12,%rdi
add    $0x1,%rbx
callq  ad <a2ps_print_buffer+0x3d>
cmp    %rbx,%rbp
ja     98 <a2ps_print_buffer+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
callq  c0 <a2ps_open_output_session>
<<<sep_in_sample>>>
a2ps_print_buffer (a2ps_job * job,
     const unsigned char * buffer,
     size_t start, size_t end,
     enum face_e new_face)
{
  size_t i;
  switch (job->output_format)
    {
    case ps:
      for (i = start ; i < end ; i++)
 ps_print_char (job, buffer [i], new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 11
18 11
19 10
20 11
21 10
22 10
23 16
24 16
25 16
26 16
27 16
28 16
29 14
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%rdi        # 2cc <gsl_odeiv_control_standard_new+0xc>
movsd  %xmm0,0x18(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  2e8 <gsl_odeiv_control_standard_new+0x28>
movsd  (%rsp),%xmm3
mov    %rax,%rdi
movsd  0x8(%rsp),%xmm2
mov    %rax,%rbx
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm0
callq  30a <gsl_odeiv_control_standard_new+0x4a>
test   %eax,%eax
mov    %rbx,%rdi
jne    320 <gsl_odeiv_control_standard_new+0x60>
add    $0x20,%rsp
mov    %rdi,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,(%rsp)
callq  328 <gsl_odeiv_control_standard_new+0x68>
mov    (%rsp),%eax
mov    $0x0,%edi
mov    $0xa7,%edx
mov    $0x0,%esi
mov    %eax,%ecx
callq  341 <gsl_odeiv_control_standard_new+0x81>
xor    %edi,%edi
jmp    311 <gsl_odeiv_control_standard_new+0x51>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_control_standard_new(double eps_abs, double eps_rel,
                               double a_y, double a_dydt)
{
  gsl_odeiv_control * c =
    gsl_odeiv_control_alloc (gsl_odeiv_control_standard);
  int status = gsl_odeiv_control_init (c, eps_abs, eps_rel, a_y, a_dydt);
  if (status != GSL_SUCCESS)
    {
      gsl_odeiv_control_free (c);
      do { gsl_error ("error trying to initialize control", "cstd.c", 167, status) ; return 0 ; } while (0);
    }
  return c;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 3
7 3
8 4
9 6
10 6
11 6
12 4
13 6
14 6
15 6
16 7
17 12
18 7
19 13
20 13
21 13
22 13
23 13
24 13
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
jmpq   2af5 <java_realloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_realloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rax),%rax
mov    0x30(%rax),%rdi
mov    0x38(%rax),%rsi
callq  b1d <hash_handler+0x1d>
mov    $0x0,%esi
mov    $0x0,%edi
mov    %eax,%ebp
callq  b2e <hash_handler+0x2e>
mov    0x10(%rbx),%rdi
add    $0x8,%rsp
mov    %ebp,%edx
pop    %rbx
pop    %rbp
mov    %rax,%rsi
xor    %eax,%eax
jmpq   b44 <hash_handler+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_handler (struct handler_param *param)
{
  fprintf (param->fp, dgettext ("gdbm", "hash value = %x. \n"),
    _gdbm_hash (param->argv[0]->v.dat));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 5
16 3
17 5
18 5
19 3
20 3
21 3
22 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x64,%edx
je     230 <sv_compquery+0x30>
cmpb   $0x0,(%rdi)
je     230 <sv_compquery+0x30>
sub    $0x8,%rsp
callq  218 <sv_compquery+0x18>
xor    %edx,%edx
test   %eax,%eax
cmovns %eax,%edx
xor    %eax,%eax
mov    %edx,0x0(%rip)        # 227 <sv_compquery+0x27>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    %edx,0x0(%rip)        # 236 <sv_compquery+0x36>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sv_compquery (value)
     const char *value;
{
  int nval = 100;
  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
 nval = 0;
    }
  rl_completion_query_items = nval;
  return 0;
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 5
5 5
6 3
7 7
8 7
9 7
10 7
11 13
12 11
13 13
14 13
15 13
16 11
17 13
18 13
19 13
<<<sep_out_sample>>>
jmpq   595 <mbstrpbrk+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbstrpbrk(const char *s, const char *accept)
{
    ((void) (0));
 return (char *) strpbrk(s, accept);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <get_home_dir+0x9>
mov    %eax,%edi
callq  20 <get_home_dir+0x10>
test   %rax,%rax
je     30 <get_home_dir+0x20>
mov    0x20(%rax),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
xor    %eax,%eax
jmp    29 <get_home_dir+0x19>
<<<sep_in_sample>>>
get_home_dir ()
{
  char *home_dir;
  struct passwd *entry;
  home_dir = (char *)((void *)0);
  entry = getpwuid (getuid ());
  if (entry)
    home_dir = entry->pw_dir;
  return (home_dir);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 7
6 7
7 8
8 10
9 10
10 10
11 5
12 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%eax
mov    %edx,%ebx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm0        # 165 <display+0x25>
movsd  0x0(%rip),%xmm2        # 16d <display+0x2d>
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  17a <display+0x3a>
movsd  0x0(%rip),%xmm0        # 182 <display+0x42>
ucomisd 0x0(%rip),%xmm0        # 18a <display+0x4a>
jbe    1ad <display+0x6d>
mulsd  0x8(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x1,%eax
divsd  0x0(%rip),%xmm0        # 1a4 <display+0x64>
callq  1a9 <display+0x69>
test   %ebx,%ebx
jne    1c0 <display+0x80>
add    $0x10,%rsp
mov    $0xa,%edi
pop    %rbx
jmpq   1bc <display+0x7c>
nopl   0x0(%rax)
cvtsi2sd %rbx,%xmm1
mov    $0x0,%edi
movsd  0x8(%rsp),%xmm0
mov    $0x1,%eax
mulsd  0x0(%rip),%xmm0        # 1dd <display+0x9d>
mulsd  %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 1e9 <display+0xa9>
callq  1ee <display+0xae>
add    $0x10,%rsp
mov    $0xa,%edi
pop    %rbx
jmpq   1fd <display+0xbd>
nopl   (%rax)
<<<sep_in_sample>>>
display(const char *name, const char *mode, unsigned block_size,
 double time)
{
  printf("%18s %11s %7.2f",
  name, mode,
  10240 / (time * 1048576.0));
  if (frequency > 0.0)
    {
      printf(" %11.2f", time * frequency / 10240);
      if (block_size > 0)
 printf(" %12.2f", time * frequency * block_size / 10240);
    }
  printf("\n");
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 4
6 4
7 3
8 3
9 6
10 4
11 4
12 4
13 4
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 14
25 13
26 14
27 13
28 13
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 14
38 13
39 14
40 13
41 13
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
movq   $0x0,0x30(%rdi)
movsd  %xmm0,(%rdi)
movsd  %xmm0,0x8(%rdi)
movsd  %xmm0,0x10(%rdi)
movsd  %xmm0,0x18(%rdi)
movsd  %xmm0,0x20(%rdi)
movsd  %xmm0,0x28(%rdi)
mov    0x38(%rdi),%rdi
jmpq   6a2 <gsl_rstat_reset+0x32>
<<<sep_in_sample>>>
gsl_rstat_reset(gsl_rstat_workspace *w)
{
  int status;
  w->min = 0.0;
  w->max = 0.0;
  w->mean = 0.0;
  w->M2 = 0.0;
  w->M3 = 0.0;
  w->M4 = 0.0;
  w->n = 0;
  status = gsl_rstat_quantile_reset(w->median_workspace_p);
  return status;
}
<<<sep_in_sample>>>
1 4
2 10
3 4
4 5
5 6
6 7
7 8
8 9
9 11
10 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
xorpd  %xmm0,%xmm0
ucomisd %xmm2,%xmm0
ja     cb <gsl_ran_chisq_pdf+0x9b>
sub    $0x28,%rsp
ucomisd 0x0(%rip),%xmm1        # 4e <gsl_ran_chisq_pdf+0x1e>
jnp    d0 <gsl_ran_chisq_pdf+0xa0>
mulsd  0x0(%rip),%xmm1        # 5c <gsl_ran_chisq_pdf+0x2c>
movsd  %xmm2,0x10(%rsp)
movapd %xmm1,%xmm0
movsd  %xmm1,0x18(%rsp)
callq  71 <gsl_ran_chisq_pdf+0x41>
movsd  0x10(%rsp),%xmm2
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm2        # 85 <gsl_ran_chisq_pdf+0x55>
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
callq  94 <gsl_ran_chisq_pdf+0x64>
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm2
subsd  0x0(%rip),%xmm1        # a8 <gsl_ran_chisq_pdf+0x78>
mulsd  %xmm0,%xmm1
subsd  %xmm2,%xmm1
subsd  0x8(%rsp),%xmm1
movapd %xmm1,%xmm0
callq  bf <gsl_ran_chisq_pdf+0x8f>
mulsd  0x0(%rip),%xmm0        # c7 <gsl_ran_chisq_pdf+0x97>
add    $0x28,%rsp
repz retq 
nopl   (%rax)
jne    54 <gsl_ran_chisq_pdf+0x24>
movsd  0x0(%rip),%xmm0        # de <gsl_ran_chisq_pdf+0xae>
xorpd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # ea <gsl_ran_chisq_pdf+0xba>
callq  ef <gsl_ran_chisq_pdf+0xbf>
mulsd  0x0(%rip),%xmm0        # f7 <gsl_ran_chisq_pdf+0xc7>
jmp    c7 <gsl_ran_chisq_pdf+0x97>
<<<sep_in_sample>>>
gsl_ran_chisq_pdf (const double x, const double nu)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      if(nu == 2.0)
        {
          return exp(-x/2.0) / 2.0;
        }
      else
        {
          double p;
          double lngamma = gsl_sf_lngamma (nu / 2);
          p = exp ((nu / 2 - 1) * log (x/2) - x/2 - lngamma) / 2;
          return p;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 2
6 9
7 9
8 16
9 16
10 16
11 16
12 16
13 17
14 16
15 17
16 17
17 17
18 17
19 17
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 21
29 21
30 21
31 9
32 11
33 11
34 11
35 11
36 11
37 11
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_header (MESSAGE msg)
{
  return msg->header;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_long_data (const gsl_block_long * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x18(%rsi),%rdi
movsd  (%rdx),%xmm1
movsd  %xmm1,0x8(%rsp)
movapd %xmm1,%xmm0
callq  *(%rsi)
movsd  0x8(%rsp),%xmm1
movsd  %xmm0,0x0(%rbp)
mov    0x18(%rbx),%rdi
movapd %xmm1,%xmm0
callq  *0x8(%rbx)
movsd  %xmm0,0x8(%rbp)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
newton_init (void * vstate, gsl_function_fdf * fdf, double * root)
{
  newton_state_t * state = (newton_state_t *) vstate;
  const double x = *root ;
  state->f = (*((fdf)->f))(x,(fdf)->params);
  state->df = (*((fdf)->df))(x,(fdf)->params) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 4
8 5
9 5
10 5
11 6
12 5
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 8
22 8
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %edx,%ebp
push   %rbx
sub    $0x28,%rsp
callq  c7b <iso9660_name_translate_ext+0x1b>
mov    %rax,%rcx
xor    %eax,%eax
cmp    $0x0,%ecx
je     d4d <iso9660_name_translate_ext+0xed>
jle    e00 <iso9660_name_translate_ext+0x1a0>
movzbl (%r15),%ebx
test   %bl,%bl
je     e00 <iso9660_name_translate_ext+0x1a0>
test   %bpl,%bpl
mov    %ecx,%r14d
jne    d60 <iso9660_name_translate_ext+0x100>
lea    -0x1(%rcx),%r9d
xor    %ebp,%ebp
xor    %r12d,%r12d
mov    %r9,0x8(%rsp)
callq  cba <iso9660_name_translate_ext+0x5a>
mov    %rax,%r8
lea    -0x2(%r14),%eax
mov    0x8(%rsp),%r9
sub    $0x3,%r14d
mov    %eax,0x1c(%rsp)
jmp    cf7 <iso9660_name_translate_ext+0x97>
cmp    $0x3b,%bl
je     dd0 <iso9660_name_translate_ext+0x170>
cmp    %r9,%rbp
mov    %bl,0x0(%r13,%r12,1)
lea    0x1(%rbp),%edx
je     d42 <iso9660_name_translate_ext+0xe2>
movzbl 0x1(%r15,%rbp,1),%ebx
lea    0x1(%rbp),%r12
test   %bl,%bl
je     d45 <iso9660_name_translate_ext+0xe5>
mov    %r12,%rbp
mov    (%r8),%rdx
movzbl %bl,%ecx
testb  $0x1,0x1(%rdx,%rcx,2)
je     d22 <iso9660_name_translate_ext+0xc2>
movzbl %bl,%edi
mov    %r9,0x10(%rsp)
mov    %r8,0x8(%rsp)
callq  d16 <iso9660_name_translate_ext+0xb6>
mov    0x10(%rsp),%r9
mov    0x8(%rsp),%r8
mov    %eax,%ebx
cmp    $0x2e,%bl
jne    cd0 <iso9660_name_translate_ext+0x70>
cmp    %ebp,%r14d
je     e20 <iso9660_name_translate_ext+0x1c0>
mov    $0x2e,%ebx
cmp    %r9,%rbp
lea    0x1(%rbp),%edx
mov    %bl,0x0(%r13,%r12,1)
jne    ce6 <iso9660_name_translate_ext+0x86>
movslq %edx,%r12
movb   $0x0,0x0(%r13,%r12,1)
mov    %edx,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
xor    %ecx,%ecx
xor    %edx,%edx
lea    -0x3(%r14),%r9d
lea    -0x2(%r14),%r8d
jmp    d9d <iso9660_name_translate_ext+0x13d>
nopl   0x0(%rax,%rax,1)
cmp    $0x3b,%bl
je     dc0 <iso9660_name_translate_ext+0x160>
add    $0x1,%edx
mov    %bl,0x0(%r13,%rcx,1)
cmp    %edx,%r14d
jle    d42 <iso9660_name_translate_ext+0xe2>
movzbl (%r15,%rax,1),%ebx
lea    0x1(%rax),%rdi
test   %bl,%bl
je     df0 <iso9660_name_translate_ext+0x190>
mov    %rax,%rcx
mov    %rdi,%rax
cmp    $0x2e,%bl
jne    d78 <iso9660_name_translate_ext+0x118>
cmp    %edx,%r9d
mov    $0x2e,%ebx
jne    d7d <iso9660_name_translate_ext+0x11d>
cmpb   $0x3b,0x1(%r15,%rcx,1)
jne    d7d <iso9660_name_translate_ext+0x11d>
cmpb   $0x31,0x2(%r15,%rcx,1)
jne    d7d <iso9660_name_translate_ext+0x11d>
jmp    d42 <iso9660_name_translate_ext+0xe2>
xchg   %ax,%ax
cmp    %edx,%r8d
je     e0a <iso9660_name_translate_ext+0x1aa>
mov    $0x2e,%ebx
jmp    d7d <iso9660_name_translate_ext+0x11d>
nopl   0x0(%rax)
cmp    %ebp,0x1c(%rsp)
jne    d30 <iso9660_name_translate_ext+0xd0>
cmpb   $0x31,0x1(%r15,%r12,1)
jne    d30 <iso9660_name_translate_ext+0xd0>
mov    0x1c(%rsp),%edx
jmpq   d42 <iso9660_name_translate_ext+0xe2>
nop
mov    %rax,%r12
mov    %edx,%eax
movb   $0x0,0x0(%r13,%r12,1)
jmpq   d4d <iso9660_name_translate_ext+0xed>
xor    %r12d,%r12d
xor    %edx,%edx
jmpq   d45 <iso9660_name_translate_ext+0xe5>
cmpb   $0x31,0x1(%r15,%rcx,1)
jne    dc5 <iso9660_name_translate_ext+0x165>
jmpq   d42 <iso9660_name_translate_ext+0xe2>
nopw   0x0(%rax,%rax,1)
cmpb   $0x3b,0x1(%r15,%r12,1)
jne    cd9 <iso9660_name_translate_ext+0x79>
cmpb   $0x31,0x2(%r15,%r12,1)
jne    cd9 <iso9660_name_translate_ext+0x79>
mov    %r14d,%edx
jmpq   d42 <iso9660_name_translate_ext+0xe2>
<<<sep_in_sample>>>
iso9660_name_translate_ext(const char *psz_oldname, char *psz_newname,
                           uint8_t u_joliet_level)
{
  int len = strlen(psz_oldname);
  int i;
  if (0 == len) return 0;
  for (i = 0; i < len; i++) {
    unsigned char c = psz_oldname[i];
    if (!c)
      break;
    if (!u_joliet_level && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISupper)) c = tolower(c);
    if (c == '.' && i == len - 3
        && psz_oldname[i + 1] == ';' && psz_oldname[i + 2] == '1')
      break;
    if (c == ';' && i == len - 2 && psz_oldname[i + 1] == '1')
      break;
    if (c == ';')
      c = '.';
    psz_newname[i] = c;
  }
  psz_newname[i] = '\0';
  return i;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 7
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 11
25 8
26 8
27 11
28 11
29 15
30 15
31 12
32 15
33 15
34 15
35 15
36 7
37 19
38 19
39 7
40 8
41 8
42 9
43 9
44 9
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 11
55 11
56 12
57 12
58 12
59 12
60 12
61 7
62 7
63 19
64 7
65 7
66 21
67 22
68 23
69 23
70 23
71 23
72 23
73 23
74 23
75 23
76 23
77 9
78 8
79 9
80 12
81 15
82 15
83 15
84 15
85 15
86 7
87 19
88 7
89 7
90 8
91 8
92 9
93 9
94 8
95 8
96 12
97 12
98 12
99 13
100 12
101 13
102 13
103 13
104 13
105 13
106 13
107 15
108 15
109 15
110 15
111 15
112 15
113 15
114 15
115 15
116 15
117 15
118 15
119 8
120 22
121 21
122 21
123 9
124 9
125 9
126 15
127 15
128 15
129 15
130 13
131 13
132 13
133 13
134 13
135 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    %rdi,0x18(%rsi)
mov    %rax,0x10(%rsi)
mov    0x10(%rdi),%rax
test   %rax,%rax
je     299 <splice_node+0x19>
mov    %rsi,0x18(%rax)
mov    0x0(%rip),%rax        # 2a0 <splice_node+0x20>
mov    %rsi,0x10(%rdi)
test   %rax,%rax
je     2af <splice_node+0x2f>
cmp    %rdi,0x10(%rax)
je     2b8 <splice_node+0x38>
repz retq 
nopl   0x0(%rax)
mov    %rsi,0x10(%rax)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
splice_node(filestruct *afterthis, filestruct *newnode)
{
    ((void) (0));
    newnode->next = afterthis->next;
    newnode->prev = afterthis;
    if (afterthis->next != ((void *)0))
 afterthis->next->prev = newnode;
    afterthis->next = newnode;
    if (openfile && openfile->filebot == afterthis)
 openfile->filebot = newnode;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 6
5 6
6 6
7 7
8 9
9 8
10 9
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 10
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edi
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  c9 <osip_gettimeofday+0x19>
test   %eax,%eax
js     108 <osip_gettimeofday+0x58>
mov    (%rsp),%rax
mov    0x8(%rsp),%rcx
movabs $0x20c49ba5e353f7cf,%rdx
mov    %rax,(%rbx)
mov    %rcx,%rax
sar    $0x3f,%rcx
imul   %rdx
sar    $0x7,%rdx
sub    %rcx,%rdx
mov    %rdx,0x8(%rbx)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  113 <osip_gettimeofday+0x63>
jmp    f8 <osip_gettimeofday+0x48>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_gettimeofday (struct timeval *tp, void *tz)
{
  struct timespec ts;
  if (clock_gettime (1, &ts) < 0) {
    gettimeofday (tp, tz);
    return 0;
  }
  tp->tv_sec = ts.tv_sec + offset.tv_sec;
  tp->tv_usec = ts.tv_nsec / 1000;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 8
12 9
13 9
14 8
15 9
16 9
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 5
28 5
29 5
30 6
31 6
<<<sep_out_sample>>>
movzbl 0x84(%rdi),%eax
mov    0x30(%rdi),%rdx
and    $0x3,%esi
shl    $0x2,%esi
and    $0xfffffff3,%eax
or     %esi,%eax
test   %rdx,%rdx
mov    %al,0x84(%rdi)
je     1666 <set_command_state+0x46>
nopl   0x0(%rax)
mov    0x10(%rdx),%rcx
mov    (%rdx),%rdx
movzbl 0x84(%rcx),%eax
and    $0xfffffff3,%eax
or     %esi,%eax
test   %rdx,%rdx
mov    %al,0x84(%rcx)
jne    1648 <set_command_state+0x28>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_command_state (struct file *file, enum cmd_state state)
{
  struct dep *d;
  file->command_state = state;
  for (d = file->also_make; d != 0; d = d->next)
    d->file->command_state = state;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 5
8 4
9 5
10 5
11 6
12 5
13 6
14 6
15 6
16 5
17 6
18 5
19 5
20 5
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    6f2 <sh_contains_quotes+0x22>
jmp    6f9 <sh_contains_quotes+0x29>
nopw   0x0(%rax,%rax,1)
cmp    $0x27,%al
je     700 <sh_contains_quotes+0x30>
cmp    $0x22,%al
je     700 <sh_contains_quotes+0x30>
cmp    $0x5c,%al
je     700 <sh_contains_quotes+0x30>
add    $0x1,%rdi
je     6f9 <sh_contains_quotes+0x29>
movzbl (%rdi),%eax
test   %al,%al
jne    6e0 <sh_contains_quotes+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
sh_contains_quotes (string)
     const char *string;
{
  const char *s;
  for (s = string; s && *s; s++)
    {
      if (*s == '\'' || *s == '"' || *s == '\\')
 return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 5
12 5
13 5
14 5
15 5
16 10
17 11
18 11
19 8
20 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     a3e <parseopts+0x16e>
mov    %rsi,%rbx
callq  8ea <parseopts+0x1a>
movslq 0x0(%rip),%rdx        # 8f1 <parseopts+0x21>
cmp    %rdx,%rax
jbe    a32 <parseopts+0x162>
mov    0x0(%rip),%rdi        # 901 <parseopts+0x31>
test   %rdi,%rdi
je     913 <parseopts+0x43>
callq  90b <parseopts+0x3b>
mov    %rbp,%rdi
callq  913 <parseopts+0x43>
mov    %eax,0x0(%rip)        # 919 <parseopts+0x49>
add    $0x1,%eax
movslq %eax,%rdi
callq  924 <parseopts+0x54>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 92e <parseopts+0x5e>
je     a52 <parseopts+0x182>
mov    %rax,%r10
mov    %r10,%rdi
mov    %rbp,%rsi
callq  942 <parseopts+0x72>
movzbl (%rax),%ecx
mov    %rax,%r10
cmp    $0x20,%cl
jne    a47 <parseopts+0x177>
lea    0x1(%rax),%rdx
xor    %r8d,%r8d
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r9
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
add    $0x1,%r8d
cmp    $0x20,%cl
je     960 <parseopts+0x90>
test   %cl,%cl
je     a3e <parseopts+0x16e>
xor    %eax,%eax
test   %rbx,%rbx
mov    %rbx,%rdi
je     a18 <parseopts+0x148>
nopw   0x0(%rax,%rax,1)
movslq %r8d,%rdx
mov    %r9,(%rdi)
lea    (%r10,%rdx,1),%r9
movzbl (%r9),%ecx
test   $0xdf,%cl
je     9c3 <parseopts+0xf3>
lea    0x1(%r10,%rdx,1),%rdx
nopl   0x0(%rax,%rax,1)
movzbl (%rdx),%ecx
add    $0x1,%r8d
mov    %rdx,%r9
add    $0x1,%rdx
test   $0xdf,%cl
jne    9b0 <parseopts+0xe0>
test   %cl,%cl
je     a28 <parseopts+0x158>
test   %rbx,%rbx
je     9d0 <parseopts+0x100>
movb   $0x0,(%r9)
add    $0x1,%r8d
movslq %r8d,%rdx
lea    (%r10,%rdx,1),%r9
movzbl (%r9),%ecx
cmp    $0x20,%cl
jne    a04 <parseopts+0x134>
lea    0x1(%r10,%rdx,1),%rdx
nopl   0x0(%rax)
mov    %rdx,%r9
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
add    $0x1,%r8d
cmp    $0x20,%cl
je     9f0 <parseopts+0x120>
add    $0x1,%eax
add    $0x8,%rdi
test   %cl,%cl
je     a2b <parseopts+0x15b>
test   %rbx,%rbx
jne    990 <parseopts+0xc0>
movslq %r8d,%rdx
lea    (%r10,%rdx,1),%r9
jmpq   99e <parseopts+0xce>
nopl   0x0(%rax)
add    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%r10        # a39 <parseopts+0x169>
jmpq   937 <parseopts+0x67>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    %rax,%r9
xor    %r8d,%r8d
jmpq   974 <parseopts+0xa4>
mov    $0x0,%edi
callq  a5c <parseopts+0x18c>
mov    $0x1,%edi
callq  a66 <parseopts+0x196>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parseopts(char *opts, char **arg)
{
  static char *optcpy = ((void *)0);
  static int optlen = 0;
  int i;
  int a;
  if (!opts)
    return 0;
  if (strlen(opts) > optlen)
    {
      if (optcpy)
 free(optcpy);
      optlen = strlen(opts);
      if (!(optcpy = malloc(optlen + 1)))
 {
   perror("dap");
   exit(1);
 }
    }
  strcpy(optcpy, opts);
  for (i = 0; optcpy[i] == ' '; i++)
    ;
  for (a = 0; optcpy[i]; a++)
    {
      if (arg)
 arg[a] = optcpy + i;
      while (optcpy[i] && optcpy[i] != ' ')
 i++;
      if (optcpy[i])
 {
   if (arg)
     optcpy[i] = '\0';
   for (i++; optcpy[i] == ' '; i++)
     ;
 }
    }
  return a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 9
9 9
10 9
11 9
12 11
13 11
14 11
15 12
16 12
17 12
18 13
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 20
27 20
28 20
29 21
30 20
31 21
32 21
33 21
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 23
43 23
44 23
45 25
46 25
47 25
48 25
49 25
50 26
51 26
52 26
53 27
54 27
55 27
56 27
57 27
58 28
59 27
60 27
61 27
62 27
63 29
64 29
65 31
66 31
67 32
68 33
69 33
70 33
71 33
72 33
73 33
74 33
75 33
76 33
77 33
78 33
79 33
80 33
81 33
82 23
83 23
84 23
85 23
86 25
87 25
88 25
89 25
90 25
91 25
92 23
93 38
94 38
95 38
96 38
97 38
98 38
99 38
100 8
101 38
102 38
103 38
104 21
105 21
106 21
107 16
108 16
109 17
110 17
111 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  16 <setup_utmp+0x16>
add    $0x8,%rsp
lea    0x5(%rbx),%rdi
mov    %rbp,%rcx
pop    %rbx
pop    %rbp
mov    %rax,%rdx
mov    $0x0,%esi
jmpq   30 <start_login>
<<<sep_in_sample>>>
setup_utmp (char *line, char *host)
{
  char *ut_id = utmp_ptsid (line, "tn");
  utmp_init (line + sizeof ("/dev/") - 1, ".telnet", ut_id, host);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 5
9 4
10 4
11 5
12 5
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %r12
cmpl   $0xffffffff,0x0(%rip)        # 59 <cdio_init+0x9>
push   %rbp
push   %rbx
jne    120 <cdio_init+0xd0>
mov    $0x0,%r12d
mov    $0x0,%ebx
mov    $0x1,%eax
nopl   0x0(%rax)
lea    (%rax,%rax,4),%rbp
shl    $0x4,%rbp
callq  *0x0(%rbp)
test   %al,%al
je     103 <cdio_init+0xb3>
mov    0x0(%rbp),%rdx
mov    0x0(%rbp),%rax
add    $0x50,%rbx
addl   $0x1,0x0(%rip)        # a3 <cdio_init+0x53>
mov    %rdx,-0x50(%rbx)
mov    0x0(%rbp),%rdx
mov    %rax,-0x8(%rbx)
mov    %rdx,-0x48(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x40(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x38(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x30(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x28(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x20(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x18(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,-0x10(%rbx)
add    $0x4,%r12
mov    (%r12),%eax
test   %eax,%eax
jne    78 <cdio_init+0x28>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopl   (%rax)
xor    %eax,%eax
mov    $0x0,%edi
callq  12c <cdio_init+0xdc>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_init(void)
{
  CdIo_driver_t *all_dp;
  CdIo_driver_t *dp = CdIo_driver;
  const driver_id_t *p_driver_id;
  if (CdIo_last_driver != -1) {
    cdio_warn ("Init routine called more than once.");
    return 0;
  }
  for (p_driver_id=cdio_drivers; *p_driver_id!=DRIVER_UNKNOWN; p_driver_id++) {
    all_dp = &CdIo_all_drivers[*p_driver_id];
    if ((*CdIo_all_drivers[*p_driver_id].have_driver)()) {
      *dp++ = *all_dp;
      CdIo_last_driver++;
    }
  }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 6
6 6
7 6
8 10
9 10
10 12
11 12
12 12
13 12
14 12
15 13
16 13
17 13
18 14
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 10
38 10
39 10
40 10
41 18
42 18
43 10
44 18
45 18
46 18
47 7
48 7
49 7
50 18
51 18
52 8
53 18
54 18
55 18
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 317 <dirwatcher_lookup_wd+0x7>
test   %rax,%rax
je     360 <dirwatcher_lookup_wd+0x50>
sub    $0x58,%rsp
lea    0x10(%rsp),%rdx
mov    %edi,0x14(%rsp)
mov    %rsp,%rsi
mov    %rax,%rdi
mov    %rdx,0x8(%rsp)
xor    %edx,%edx
callq  33b <dirwatcher_lookup_wd+0x2b>
test   %rax,%rax
je     350 <dirwatcher_lookup_wd+0x40>
mov    0x8(%rax),%rax
add    $0x58,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
add    $0x58,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dirwatcher_lookup_wd(int wd)
{
 struct dirwatcher dwkey;
 struct dwref dwref, *ent;
 if (!dwtab)
  return ((void *)0);
 dwkey.wd = wd;
 dwref.dw = &dwkey;
 ent = hashtab_lookup_or_install(dwtab, &dwref, ((void *)0));
 return ent ? ent->dw : ((void *)0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 2
5 8
6 7
7 9
8 9
9 8
10 9
11 9
12 10
13 10
14 10
15 11
16 11
17 11
18 6
19 11
20 11
21 11
22 6
23 11
24 11
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_uri (const osip_message_t * sip)
{
  return sip->req_uri;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%rsi        # 10b <diff_init+0xb>
mov    %rsp,%rdi
callq  113 <diff_init+0x13>
cmpq   $0x0,0x0(%rip)        # 11b <diff_init+0x1b>
mov    %rax,0x0(%rip)        # 122 <diff_init+0x22>
je     129 <diff_init+0x29>
callq  129 <diff_init+0x29>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
diff_init (void)
{
  void *ptr;
  diff_buffer = page_aligned_alloc (&ptr, record_size);
  if (listed_incremental_option)
    read_directory_file ();
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 4
7 5
8 6
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_name (const gsl_rng * r)
{
  return r->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsbq (%rdi),%rbp
movsbl %bpl,%edi
test   %edi,%edi
mov    %edi,0xc(%rsp)
je     52 <upcase+0x52>
callq  20 <upcase+0x20>
mov    0xc(%rsp),%edi
mov    %rax,%r12
nopw   0x0(%rax,%rax,1)
mov    (%r12),%rdx
testb  $0x2,0x1(%rdx,%rbp,2)
je     42 <upcase+0x42>
callq  40 <upcase+0x40>
mov    %al,(%rbx)
add    $0x1,%rbx
movsbq (%rbx),%rbp
movsbl %bpl,%edi
test   %edi,%edi
jne    30 <upcase+0x30>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
upcase (register char *argument)
{
  register int c;
  while ((c = *argument) != 0)
    {
      if (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISlower))
 {
   *argument = toupper (c);
 }
      argument++;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 8
19 8
20 10
21 4
22 4
23 4
24 4
25 12
26 12
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    0x18(%rdi),%rdi
mov    %rbx,%rdx
callq  5f <gear1_reset+0x1f>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  6d <gear1_reset+0x2d>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  7b <gear1_reset+0x3b>
mov    0x0(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  89 <gear1_reset+0x49>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gear1_reset (void *vstate, size_t dim)
{
  gear1_state_t *state = (gear1_state_t *) vstate;
  memset((state->y_onestep),0,(dim)*sizeof(double));
  memset((state->y0_orig),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->k),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
jmp    248a <ReadSpecies+0x1a>
nopl   (%rax)
mov    %ebp,%esi
mov    %rbx,%rdi
callq  248a <ReadSpecies+0x1a>
mov    $0x6,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  249c <ReadSpecies+0x2c>
test   %eax,%eax
jne    2480 <ReadSpecies+0x10>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ReadSpecies (PINPUTBUF pibIn, int iSBML_level, BOOL bProcessPK_ODEs)
{
  while (GetSBMLLex (pibIn, 4, 6))
    Read1Species (pibIn, bProcessPK_ODEs);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 3
12 3
13 3
14 3
15 3
16 3
17 5
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     13eb <gsl_matrix_ulong_isnull+0x8b>
xorpd  %xmm1,%xmm1
push   %rbx
lea    0x0(,%rax,8),%rbx
xor    %r8d,%r8d
xor    %r11d,%r11d
test   %rdx,%rdx
je     13b7 <gsl_matrix_ulong_isnull+0x57>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
mov    (%rsi,%rax,8),%rcx
test   %rcx,%rcx
js     13d0 <gsl_matrix_ulong_isnull+0x70>
cvtsi2sd %rcx,%xmm0
ucomisd %xmm1,%xmm0
jp     13e7 <gsl_matrix_ulong_isnull+0x87>
jne    13e7 <gsl_matrix_ulong_isnull+0x87>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1398 <gsl_matrix_ulong_isnull+0x38>
add    $0x1,%r11
add    %rbx,%r8
cmp    %r9,%r11
jne    1383 <gsl_matrix_ulong_isnull+0x23>
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %rcx,%r10
and    $0x1,%ecx
shr    %r10
or     %rcx,%r10
cvtsi2sd %r10,%xmm0
addsd  %xmm0,%xmm0
jmp    13a6 <gsl_matrix_ulong_isnull+0x46>
xor    %eax,%eax
pop    %rbx
retq   
mov    $0x1,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_isnull (const gsl_matrix_ulong * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 2
8 2
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 9
25 9
26 9
27 7
28 7
29 7
30 7
31 20
32 21
33 21
34 21
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 15
43 21
44 21
45 20
46 21
47 21
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
mov    0x8(%rdi),%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tterm_width (struct tterm * tterm)
{
  struct tterm *t = tterm ? tterm : &tterm_default;
  return t->width;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 7 <version_etc_hook+0x7>
mov    0x0(%rip),%rsi        # e <version_etc_hook+0xe>
mov    $0x0,%ecx
mov    $0x0,%edx
jmpq   1d <version_etc_hook+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU inetutils", "1.9.4",
                  program_authors);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%ecx        # 1c2a <show_error_node+0xa>
test   %ecx,%ecx
jne    1c68 <show_error_node+0x48>
mov    0x0(%rip),%edx        # 1c34 <show_error_node+0x14>
test   %edx,%edx
je     1c81 <show_error_node+0x61>
mov    0x0(%rip),%eax        # 1c3e <show_error_node+0x1e>
test   %eax,%eax
je     1c50 <show_error_node+0x30>
add    $0x18,%rsp
jmpq   1c4b <show_error_node+0x2b>
nopl   0x0(%rax,%rax,1)
mov    %rdi,%rsi
xor    %eax,%eax
mov    $0x0,%edi
add    $0x18,%rsp
jmpq   1c63 <show_error_node+0x43>
nopl   0x0(%rax,%rax,1)
mov    %rdi,0x8(%rsp)
callq  1c72 <show_error_node+0x52>
mov    0x0(%rip),%edx        # 1c78 <show_error_node+0x58>
mov    0x8(%rsp),%rdi
test   %edx,%edx
jne    1c38 <show_error_node+0x18>
mov    %rdi,%rsi
xor    %eax,%eax
mov    $0x0,%edi
add    $0x18,%rsp
jmpq   9b0 <info_error.constprop.26>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
show_error_node (char *error)
{
  if (info_error_rings_bell_p)
    terminal_ring_bell ();
  if (!info_windows_initialized_p)
    {
      info_error ("%s", error);
    }
  else if (!echo_area_is_active)
    {
      window_message_in_echo_area ("%s", error);
    }
  else
    inform_in_echo_area (error);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 9
9 9
10 9
11 15
12 14
13 14
14 11
15 11
16 11
17 15
18 11
19 11
20 11
21 4
22 5
23 4
24 5
25 5
26 7
27 7
28 7
29 15
30 7
31 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%r8
mov    0x40(%rdi),%rax
mov    0x50(%rdi),%rsi
mov    %rdx,%r9
mov    0x48(%rdi),%rdx
mov    %rcx,(%rsp)
mov    %rsi,%rcx
mov    %rax,%rsi
callq  395 <gsl_spline2d_eval_deriv_xx_e+0x25>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline2d_eval_deriv_xx_e(const gsl_spline2d * interp, const double x,
                             const double y, gsl_interp_accel * xa, gsl_interp_accel * ya,
                             double * z)
{
  return gsl_interp2d_eval_deriv_xx_e(&(interp->interp_object), interp->xarr, interp->yarr,
                                      interp->zarr, x, y, xa, ya, z);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 4
6 5
7 5
8 5
9 5
10 5
11 7
12 7
13 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
cmp    $0x1,%eax
jbe    528 <fro_move+0x38>
cmp    $0x2,%eax
jne    520 <fro_move+0x30>
sub    $0x8,%rsp
mov    0x38(%rdi),%rdi
mov    %rsi,%rdx
shr    $0x3f,%rdx
callq  511 <fro_move+0x21>
test   %eax,%eax
js     546 <fro_move+0x56>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
test   %rsi,%rsi
js     540 <fro_move+0x50>
mov    0x28(%rdi),%rax
add    %rax,%rsi
mov    %rsi,0x18(%rdi)
retq   
nopl   0x0(%rax)
mov    0x18(%rdi),%rax
jmp    531 <fro_move+0x41>
callq  54b <fro_move+0x5b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fro_move (struct fro *f, off_t change)
{
  switch (f->rm)
    {
    case RM_MMAP:
    case RM_MEM:
      f->ptr = change + (0 > change
                         ? f->ptr
                         : f->base);
      break;
    case RM_STDIO:
      if ((0 > (fseeko (f->stream, change, 0 > change ? 1 : 0))))
        Ierror ();
      break;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 12
8 12
9 12
10 12
11 12
12 12
13 16
14 16
15 16
16 16
17 16
18 9
19 9
20 9
21 7
22 7
23 10
24 10
25 9
26 9
27 13
28 13
<<<sep_out_sample>>>
mov    $0x100,%ecx
jmpq   1a <lchmodat+0xa>
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     f8 <_auth_lb_grow+0x78>
mov    0x8(%rbx),%rdx
mov    0x10(%rbx),%rax
mov    %rdx,%rcx
sub    %rax,%rcx
cmp    %rcx,%rbp
ja     d0 <_auth_lb_grow+0x50>
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rax,%rdi
callq  bc <_auth_lb_grow+0x3c>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x0(%rbp,%rdx,1),%r13
mov    %r13,%rsi
callq  dd <_auth_lb_grow+0x5d>
test   %rax,%rax
mov    %rax,(%rbx)
je     114 <_auth_lb_grow+0x94>
mov    %r13,0x8(%rbx)
mov    %rax,%rdi
mov    0x10(%rbx),%rax
jmp    ae <_auth_lb_grow+0x2e>
nopw   0x0(%rax,%rax,1)
mov    %rdx,%rdi
callq  100 <_auth_lb_grow+0x80>
test   %rax,%rax
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jne    e9 <_auth_lb_grow+0x69>
add    $0x8,%rsp
mov    $0xc,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 9
13 9
14 9
15 9
16 9
17 9
18 18
19 18
20 18
21 18
22 19
23 21
24 20
25 21
26 21
27 21
28 21
29 21
30 21
31 11
32 12
33 12
34 13
35 12
36 13
37 14
38 14
39 14
40 14
41 14
42 5
43 5
44 16
45 5
46 6
47 7
48 16
49 21
50 17
51 21
52 21
53 21
54 21
55 21
56 21
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x14(%rsi),%ebp
cmp    %ebp,(%rdi)
movslq %ebp,%rdx
jl     31 <__gmpq_get_den+0x31>
mov    0x8(%rdi),%rdi
mov    %ebp,0x4(%rbx)
mov    0x18(%r12),%rsi
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
jmpq   31 <__gmpq_get_den+0x31>
mov    %rdx,%rsi
mov    %rdx,0x8(%rsp)
callq  3e <__gmpq_get_den+0x3e>
mov    0x8(%rsp),%rdx
mov    %rax,%rdi
jmp    1c <__gmpq_get_den+0x1c>
<<<sep_in_sample>>>
__gmpq_get_den (mpz_ptr den, mpq_srcptr src)
{
  mp_size_t size = (((&((src)->_mp_den)))->_mp_size);
  mp_ptr dp;
  dp = (__builtin_expect (((size) > ((den)->_mp_alloc)) != 0, 0) ? (mp_ptr) __gmpz_realloc(den,size) : ((den)->_mp_d));
  ((den)->_mp_size) = size;
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (dp, (((&((src)->_mp_den)))->_mp_d), size); } while (0); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 5
9 5
10 5
11 5
12 6
13 7
14 8
15 8
16 8
17 8
18 7
19 5
20 5
21 5
22 5
23 5
24 5
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   1db <rule_cmp+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rule_cmp (struct rule * k1, struct rule * k2)
{
  return (strcmp((const char *)(k1->word), (const char *)(k2->word)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   1c5 <anubis_name_cmp+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
anubis_name_cmp (void *item, void *data)
{
  return strcmp (item, data);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1849 <initialize_info_session+0x9>
test   %eax,%eax
je     18c3 <initialize_info_session+0x83>
callq  1852 <initialize_info_session+0x12>
mov    0x0(%rip),%esi        # 1858 <initialize_info_session+0x18>
mov    0x0(%rip),%edi        # 185e <initialize_info_session+0x1e>
callq  1863 <initialize_info_session+0x23>
callq  1868 <initialize_info_session+0x28>
mov    0x0(%rip),%esi        # 186e <initialize_info_session+0x2e>
mov    0x0(%rip),%edi        # 1874 <initialize_info_session+0x34>
callq  1879 <initialize_info_session+0x39>
cmpq   $0x0,0x0(%rip)        # 1881 <initialize_info_session+0x41>
je     1898 <initialize_info_session+0x58>
movl   $0x1,0x0(%rip)        # 188d <initialize_info_session+0x4d>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 189f <initialize_info_session+0x5f>
xor    %esi,%esi
callq  18a6 <initialize_info_session+0x66>
mov    0x0(%rip),%rax        # 18ad <initialize_info_session+0x6d>
movl   $0x1,0x0(%rip)        # 18b7 <initialize_info_session+0x77>
mov    %rax,0x0(%rip)        # 18be <initialize_info_session+0x7e>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  18cd <initialize_info_session+0x8d>
mov    0x0(%rip),%rdi        # 18d4 <initialize_info_session+0x94>
mov    %rax,%rsi
xor    %eax,%eax
callq  18de <initialize_info_session+0x9e>
mov    $0x1,%edi
callq  18e8 <initialize_info_session+0xa8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initialize_info_session (void)
{
  if (!terminal_prep_terminal ())
    {
      char *term_name = getenv ("TERM");
      info_error (msg_term_too_dumb, term_name);
      exit (1);
    }
  terminal_clear_screen ();
  window_initialize_windows (screenwidth, screenheight);
  initialize_info_signal_handler ();
  display_initialize_display (screenwidth, screenheight);
  if (!info_input_stream)
    {
      setbuf (stdin, ((void *)0));
      info_input_stream = stdin;
    }
  info_windows_initialized_p = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 9
6 10
7 10
8 10
9 11
10 12
11 12
12 12
13 13
14 13
15 18
16 19
17 19
18 19
19 15
20 15
21 15
22 16
23 18
24 16
25 19
26 19
27 5
28 5
29 6
30 6
31 6
32 6
33 7
34 7
35 7
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0x8(%rdi),%xmm0
movsd  %xmm0,0x8(%rsi)
movsd  0x10(%rdi),%xmm0
movsd  %xmm0,0x10(%rsi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
DIStoACMWorld(dis_world_coordinates * in, VPoint * out)
{
 out->x = (in->x);
 out->y = (in->y);
 out->z = (in->z);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
jmp    c4c <get_totsize+0x2c>
xchg   %ax,%ax
cmp    %r12,%rbx
je     c51 <get_totsize+0x31>
mov    (%rbx),%rdi
callq  c3d <get_totsize+0x1d>
mov    0x10(%rbx),%rbx
add    %rax,%rbp
cmp    $0x1,%rbx
sbb    $0xffffffffffffffff,%rbp
test   %rbx,%rbx
jne    c30 <get_totsize+0x10>
test   %rbx,%rbx
je     c6a <get_totsize+0x4a>
mov    (%rbx),%rdi
callq  c5e <get_totsize+0x3e>
add    %rax,%rbp
cmpq   $0x1,0x10(%rbx)
sbb    $0xffffffffffffffff,%rbp
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_totsize(const filestruct *begin, const filestruct *end)
{
    size_t totsize = 0;
    const filestruct *f;
    for (f = begin; f != end && f != ((void *)0); f = f->next) {
 totsize += mbstrlen(f->data);
 if (f->next != ((void *)0))
     totsize++;
    }
    if (f != ((void *)0)) {
 totsize += mbstrlen(f->data);
 if (f->next != ((void *)0))
     totsize++;
    }
    return totsize;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 7
14 6
15 8
16 8
17 5
18 5
19 10
20 10
21 11
22 11
23 11
24 13
25 13
26 16
27 16
28 16
29 16
30 16
31 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 2ca <dolinemode+0xa>
test   %eax,%eax
je     2dd <dolinemode+0x1d>
mov    $0x1,%esi
mov    $0x3,%edi
callq  2dd <dolinemode+0x1d>
mov    $0x1,%esi
mov    $0x22,%edi
callq  2ec <dolinemode+0x2c>
mov    $0x1,%esi
mov    $0x1,%edi
callq  2fb <dolinemode+0x3b>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dolinemode (void)
{
  if (kludgelinemode)
    send_dont (3, 1);
  send_will (34, 1);
  send_dont (1, 1);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
push   %r12
test   %edi,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
js     2c1a <xtrace_set+0x7a>
callq  2bb2 <xtrace_set+0x12>
test   %eax,%eax
je     2c00 <xtrace_set+0x60>
test   %rbp,%rbp
je     2c1f <xtrace_set+0x7f>
mov    %rbp,%rdi
callq  2bc3 <xtrace_set+0x23>
cmp    %ebx,%eax
je     2beb <xtrace_set+0x4b>
mov    %rbp,%rdi
callq  2bcf <xtrace_set+0x2f>
mov    $0x0,%edi
mov    %eax,%r12d
callq  2bdc <xtrace_set+0x3c>
mov    %r12d,%edx
mov    %rax,%rdi
mov    %ebx,%esi
xor    %eax,%eax
callq  2beb <xtrace_set+0x4b>
mov    %ebx,0x0(%rip)        # 2bf1 <xtrace_set+0x51>
mov    %rbp,0x0(%rip)        # 2bf8 <xtrace_set+0x58>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    $0x0,%edi
callq  2c0a <xtrace_set+0x6a>
mov    %ebx,%esi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
jmpq   2c1a <xtrace_set+0x7a>
test   %rsi,%rsi
jne    2beb <xtrace_set+0x4b>
mov    $0x0,%edi
callq  2c29 <xtrace_set+0x89>
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdi
xor    %eax,%eax
jmpq   2c37 <xtrace_set+0x97>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xtrace_set (fd, fp)
     int fd;
     FILE *fp;
{
  if (fd >= 0 && sh_validfd (fd) == 0)
    {
      internal_error (gettext("xtrace_set: %d: invalid file descriptor"), fd);
      return;
    }
  if (fp == 0)
    {
      internal_error (gettext("xtrace_set: NULL file pointer"));
      return;
    }
  if (fd >= 0 && fileno (fp) != fd)
    internal_warning (gettext("xtrace fd (%d) != fileno xtrace fp (%d)"), fd, fileno (fp));
  xtrace_fd = fd;
  xtrace_fp = fp;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 10
12 10
13 15
14 15
15 15
16 15
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 17
28 18
29 19
30 19
31 19
32 19
33 19
34 7
35 7
36 7
37 7
38 7
39 19
40 19
41 19
42 7
43 10
44 10
45 12
46 12
47 19
48 19
49 19
50 12
51 12
52 12
53 12
<<<sep_out_sample>>>
push   %rbx
mov    $0x204,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  e65 <make_bare_simple_command+0x15>
mov    $0x205,%edx
mov    $0x0,%esi
mov    $0x18,%edi
mov    %rax,%rbx
callq  e7c <make_bare_simple_command+0x2c>
mov    0x0(%rip),%edx        # e82 <make_bare_simple_command+0x32>
mov    %rax,0x18(%rbx)
movl   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
mov    %edx,0x4(%rax)
mov    %rbx,%rax
movl   $0x4,(%rbx)
movq   $0x0,0x10(%rbx)
movl   $0x0,0x4(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
make_bare_simple_command ()
{
  COMMAND *command;
  SIMPLE_COM *temp;
  command = (COMMAND *)sh_xmalloc((sizeof (COMMAND)), "make_cmd.c", 516);
  command->value.Simple = temp = (SIMPLE_COM *)sh_xmalloc((sizeof (SIMPLE_COM)), "make_cmd.c", 517);
  temp->flags = 0;
  temp->line = line_number;
  temp->words = (WORD_LIST *)((void *)0);
  temp->redirects = (REDIRECT *)((void *)0);
  command->type = cm_simple;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  return (command);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 6
9 5
10 6
11 8
12 6
13 7
14 9
15 10
16 8
17 15
18 11
19 12
20 13
21 15
22 15
23 15
<<<sep_out_sample>>>
push   %r15
mov    %r8,%r15
push   %r14
mov    %ecx,%r14d
push   %r13
mov    %rdx,%r13
xor    %edx,%edx
push   %r12
mov    %rsi,%r12
mov    $0x0,%esi
push   %rbp
mov    $0xc,%ebp
push   %rbx
sub    $0x8,%rsp
callq  17fb <mu_parse_config+0x2b>
test   %rax,%rax
mov    %rax,%rbx
je     181f <mu_parse_config+0x4f>
mov    $0x4,%esi
mov    %rax,%rdi
mov    $0x2,%bpl
callq  1813 <mu_parse_config+0x43>
test   %eax,%eax
je     1830 <mu_parse_config+0x60>
mov    %rbx,%rdi
callq  181f <mu_parse_config+0x4f>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %r15,%r8
mov    %r14d,%ecx
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1844 <mu_parse_config+0x74>
mov    %eax,%ebp
jmp    1817 <mu_parse_config+0x47>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_parse_config (const char *file, const char *progname,
   struct mu_cfg_param *progparam, int flags,
   void *target_ptr)
{
  int rc;
  char *full_name = mu_tilde_expansion (file, "/", ((void *)0));
  if (full_name)
    {
      if (access (full_name, 4) == 0)
 {
   rc = mu_get_config (full_name, progname, progparam, flags,
         target_ptr);
 }
      else
 rc = 2;
      free (full_name);
    }
  else
    rc = 12;
  return rc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 4
9 4
10 6
11 4
12 19
13 4
14 4
15 6
16 7
17 6
18 7
19 9
20 9
21 15
22 9
23 9
24 9
25 16
26 16
27 21
28 21
29 21
30 21
31 21
32 21
33 21
34 21
35 21
36 11
37 11
38 11
39 11
40 11
41 11
42 11
43 11
44 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     5868 <gsl_matrix_uchar_free+0x38>
mov    0x28(%rdi),%eax
test   %eax,%eax
jne    5850 <gsl_matrix_uchar_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   5849 <gsl_matrix_uchar_free+0x19>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdi
callq  5859 <gsl_matrix_uchar_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   5862 <gsl_matrix_uchar_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_free (gsl_matrix_uchar * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_uchar_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     c2b <osip_transaction_set_out_socket+0xb>
mov    %esi,0x74(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_out_socket (osip_transaction_t * transaction, int sock)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->out_socket = sock;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    (%rdi),%rcx
xorpd  %xmm1,%xmm1
test   %rcx,%rcx
jle    cb <vnorm_+0x2b>
xor    %eax,%eax
xchg   %ax,%ax
movsd  (%rsi,%rax,8),%xmm0
mulsd  (%rdx,%rax,8),%xmm0
add    $0x1,%rax
cmp    %rcx,%rax
mulsd  %xmm0,%xmm0
addsd  %xmm0,%xmm1
jne    b0 <vnorm_+0x10>
cvtsi2sd %rcx,%xmm0
divsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     e0 <vnorm_+0x40>
repz retq 
movapd %xmm1,%xmm0
sub    $0x8,%rsp
callq  ed <vnorm_+0x4d>
add    $0x8,%rsp
jmp    de <vnorm_+0x3e>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vnorm_(long *n, double *v, double *w)
{
  register double d__1;
  register long i;
  register double sum;
  sum = 0.0;
  for (i = 0; i < *n; ++i) {
    d__1 = v[i] * w[i];
    sum += d__1 * d__1;
  }
  return sqrt(sum / (double) (*n));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 8
8 8
9 7
10 7
11 9
12 9
13 7
14 11
15 11
16 11
17 11
18 11
19 12
20 11
21 2
22 11
23 12
24 12
25 12
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm2
jbe    50 <gsl_cdf_pareto_Q+0x10>
movsd  0x0(%rip),%xmm0        # 4e <gsl_cdf_pareto_Q+0xe>
retq   
nop
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
jmpq   5d <gsl_cdf_pareto_Q+0x1d>
<<<sep_in_sample>>>
gsl_cdf_pareto_Q (const double x, const double a, const double b)
{
  double Q;
  if (x < b)
    {
      Q = 1;
    }
  else
    {
      Q = pow(b/x, a);
    }
  return Q;
}
<<<sep_in_sample>>>
1 4
2 4
3 13
4 13
5 13
6 10
7 10
8 10
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x0,0x4(%rdi)
movl   $0x0,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_set_to_null (version_t version)
{
  size_t n;
  for (n = 0 ; n < 3 ; n++)
    version[n] = 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 18f7 <throwaway_nextchar+0x7>
test   %rax,%rax
je     1930 <throwaway_nextchar+0x40>
cmpb   $0x0,(%rax)
je     1910 <throwaway_nextchar+0x20>
add    $0x1,%rax
mov    %rax,0x0(%rip)        # 190c <throwaway_nextchar+0x1c>
retq   
nopl   (%rax)
mov    %rax,0x0(%rip)        # 1917 <throwaway_nextchar+0x27>
movq   $0x0,0x0(%rip)        # 1922 <throwaway_nextchar+0x32>
movl   $0x0,0x0(%rip)        # 192c <throwaway_nextchar+0x3c>
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 193b <throwaway_nextchar+0x4b>
mov    0x0(%rip),%rdi        # 1942 <throwaway_nextchar+0x52>
mov    $0x2,%edx
callq  194c <throwaway_nextchar+0x5c>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 1956 <throwaway_nextchar+0x66>
mov    %rax,0x0(%rip)        # 195d <throwaway_nextchar+0x6d>
je     1987 <throwaway_nextchar+0x97>
addl   $0x1,0x0(%rip)        # 1966 <throwaway_nextchar+0x76>
cmpb   $0x0,(%rax)
jne    1990 <throwaway_nextchar+0xa0>
mov    %rax,0x0(%rip)        # 1972 <throwaway_nextchar+0x82>
movq   $0x0,0x0(%rip)        # 197d <throwaway_nextchar+0x8d>
movl   $0x0,0x0(%rip)        # 1987 <throwaway_nextchar+0x97>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
add    $0x1,%rax
mov    %rax,0x0(%rip)        # 199b <throwaway_nextchar+0xab>
jmp    1987 <throwaway_nextchar+0x97>
nopl   (%rax)
<<<sep_in_sample>>>
throwaway_nextchar(void)
{
 (cp == ((void *)0) ? ((sp = cp = strbuf_fgets(ib, ip, 2)) == ((void *)0) ? (-1) : (lineno++, *cp == 0 ? (lp = cp, cp = ((void *)0), continued_line = 0, '\n') : (unsigned char)*cp++)) : (*cp == 0 ? (lp = cp, cp = ((void *)0), continued_line = 0, '\n') : (unsigned char)*cp++));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 2
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 4
31 4
32 4
33 3
34 3
35 3
36 3
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 9a6 <_rl_fix_point+0x6>
mov    0x0(%rip),%eax        # 9ac <_rl_fix_point+0xc>
cmp    %eax,%edx
jle    9d0 <_rl_fix_point+0x30>
mov    %eax,0x0(%rip)        # 9b6 <_rl_fix_point+0x16>
test   %edi,%edi
je     9c8 <_rl_fix_point+0x28>
mov    0x0(%rip),%edx        # 9c0 <_rl_fix_point+0x20>
cmp    %edx,%eax
jl     9e0 <_rl_fix_point+0x40>
test   %edx,%edx
js     9f0 <_rl_fix_point+0x50>
repz retq 
nopw   0x0(%rax,%rax,1)
test   %edx,%edx
jns    9b6 <_rl_fix_point+0x16>
movl   $0x0,0x0(%rip)        # 9de <_rl_fix_point+0x3e>
jmp    9b6 <_rl_fix_point+0x16>
mov    %eax,0x0(%rip)        # 9e6 <_rl_fix_point+0x46>
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 9fa <_rl_fix_point+0x5a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  do { if (rl_point > rl_end) rl_point = rl_end; else if (rl_point < 0) rl_point = 0; } while (0);
  if (fix_mark_too)
    do { if (rl_mark > rl_end) rl_mark = rl_end; else if (rl_mark < 0) rl_mark = 0; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     7e8 <gsl_combination_free+0x38>
cmpq   $0x0,0x8(%rdi)
jne    7d0 <gsl_combination_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   7c9 <gsl_combination_free+0x19>
nopl   0x0(%rax)
mov    0x10(%rdi),%rdi
callq  7d9 <gsl_combination_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   7e2 <gsl_combination_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_combination_free (gsl_combination * c)
{
  if (!c) { return ; };
  if (c->k > 0) free (c->data);
  free (c);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 4
12 4
13 5
14 6
15 5
16 5
17 6
18 6
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
callq  807 <buffer_sample_get+0x17>
mov    $0x200,%edi
mov    %rax,%r12
callq  814 <buffer_sample_get+0x24>
mov    %rax,%r13
jmp    83c <buffer_sample_get+0x4c>
nopl   0x0(%rax)
mov    %al,0x0(%r13,%rbx,1)
mov    %r12,%rsi
mov    %eax,%edi
add    $0x1,%rbx
callq  833 <buffer_sample_get+0x43>
cmp    $0x200,%rbx
je     84a <buffer_sample_get+0x5a>
mov    0x18(%rbp),%rdi
callq  845 <buffer_sample_get+0x55>
cmp    $0xffffffff,%eax
jne    820 <buffer_sample_get+0x30>
mov    %r13,0x0(%rbp)
mov    %rbx,0x8(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
pop    %r13
jmpq   864 <buffer_sample_get+0x74>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_sample_get (buffer_t * buffer, const char *filename)
{
  FILE *out = xwfopen (filename);
  size_t cur = 0;
  int c;
  char *sample_buffer = ((char *) xmalloc (sizeof (char) * (512)));
  for (; (cur < 512) && ((c = (_IO_getc ((buffer)->stream))) != (-1)); cur++)
    {
      sample_buffer[cur] = c;
      _IO_putc (c, out);
    }
  buffer->buf = sample_buffer;
  buffer->bufsize = cur;
  fclose (out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 4
8 2
9 3
10 6
11 3
12 6
13 6
14 6
15 6
16 9
17 10
18 10
19 7
20 10
21 7
22 7
23 7
24 7
25 7
26 7
27 12
28 13
29 15
30 15
31 15
32 14
33 15
34 15
35 14
36 14
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     104c <gsl_matrix_isnonneg+0x4c>
xorpd  %xmm0,%xmm0
lea    0x0(,%rax,8),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1040 <gsl_matrix_isnonneg+0x40>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
ucomisd (%rcx,%rax,8),%xmm0
ja     1052 <gsl_matrix_isnonneg+0x52>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1030 <gsl_matrix_isnonneg+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    1021 <gsl_matrix_isnonneg+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_isnonneg (const gsl_matrix * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 9
19 9
20 9
21 7
22 7
23 7
24 7
25 20
26 21
27 15
28 15
29 15
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    $0x1,%eax
mov    0x0(,%rdi,4),%edx
test   $0x42,%dl
jne    1002 <trap_to_sighandler+0x22>
xor    %al,%al
and    $0x1,%edx
mov    $0x0,%edx
cmovne %rdx,%rax
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trap_to_sighandler (sig)
     int sig;
{
  if (sigmodes[sig] & (0x40|0x2))
    return (((__sighandler_t) 1));
  else if (sigmodes[sig] & 0x1)
    return (trap_handler);
  else
    return (((__sighandler_t) 0));
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 7
7 7
8 7
9 7
10 10
11 10
<<<sep_out_sample>>>
sub    $0x68,%rsp
mov    %rdi,%r10
mov    %rcx,%r8
xor    %eax,%eax
mov    %rsp,%rdi
mov    $0xc,%ecx
rep stos %rax,%es:(%rdi)
mov    %rsi,%r11
mov    %edx,%ecx
mov    %rsp,%rsi
mov    %r11,%rdx
mov    %r10,%rdi
mov    %r10,(%rsp)
callq  25c0 <_help>
add    $0x68,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_help (const struct argp *argp, FILE *stream,
                  unsigned flags, char *name)
{
  struct argp_state state;
  memset (&state, 0, sizeof state);
  state.root_argp = argp;
  _help (argp, &state, stream, flags, name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 3
9 7
10 5
11 7
12 7
13 6
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rsi),%rbx
cmp    (%rdi),%rbx
mov    0x8(%rdi),%r15
mov    0x8(%rsi),%rax
jne    790 <gsl_vector_complex_float_equal+0xd0>
test   %rbx,%rbx
je     7c0 <gsl_vector_complex_float_equal+0x100>
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%rbp
movss  (%r12),%xmm0
ucomiss 0x0(%rbp),%xmm0
jp     779 <gsl_vector_complex_float_equal+0xb9>
jne    779 <gsl_vector_complex_float_equal+0xb9>
lea    (%r15,%r15,1),%r13
lea    (%rax,%rax,1),%r14
shl    $0x3,%r15
shl    $0x3,%rax
lea    (%r12,%r15,1),%rcx
xor    %r9d,%r9d
mov    %rax,0x8(%rsp)
lea    0x0(%rbp,%rax,1),%rdx
mov    %r14,%rdi
mov    %r13,%rsi
xor    %r8d,%r8d
xor    %eax,%eax
jmp    76a <gsl_vector_complex_float_equal+0xaa>
nop
jne    779 <gsl_vector_complex_float_equal+0xb9>
add    $0x1,%rax
cmp    %rbx,%rax
je     7c0 <gsl_vector_complex_float_equal+0x100>
movss  (%rcx),%xmm1
add    %r15,%rcx
lea    (%rsi,%r13,1),%r10
movss  (%rdx),%xmm0
add    0x8(%rsp),%rdx
ucomiss %xmm0,%xmm1
lea    (%rdi,%r14,1),%r11
jp     779 <gsl_vector_complex_float_equal+0xb9>
jne    779 <gsl_vector_complex_float_equal+0xb9>
mov    %rsi,%r8
mov    %rdi,%r9
mov    %r10,%rsi
mov    %r11,%rdi
movss  0x4(%r12,%r8,4),%xmm0
ucomiss 0x4(%rbp,%r9,4),%xmm0
jnp    730 <gsl_vector_complex_float_equal+0x70>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7a9 <gsl_vector_complex_float_equal+0xe9>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
add    $0x18,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_equal (const gsl_vector_complex_float * u, const gsl_vector_complex_float * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (u->data[2 * stride_u * j + k] != v->data[2 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 7
10 4
11 5
12 7
13 11
14 11
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 16
35 16
36 11
37 11
38 11
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 16
50 16
51 16
52 16
53 16
54 16
55 23
56 18
57 23
58 23
59 23
60 23
61 23
62 23
63 23
64 23
65 9
66 9
67 9
68 9
69 9
70 23
71 9
72 23
73 23
74 23
75 23
76 23
77 23
78 23
79 23
80 23
81 22
82 23
83 23
84 23
85 23
86 23
87 23
88 23
89 23
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0x10,%esi
jmpq   1bcd <nettle_cast128_set_key+0xd>
<<<sep_in_sample>>>
nettle_cast128_set_key(struct cast128_ctx *ctx, const uint8_t *key)
{
  nettle_cast5_set_key (ctx, 16, key);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
mov    0x48(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_targetname (osip_authentication_info_t *
       authentication_info)
{
  return authentication_info->targetname;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
cmp    %r9,%r10
jbe    652 <hash_get_entries+0x62>
xor    %ecx,%ecx
mov    (%r9),%r8
test   %r8,%r8
je     641 <hash_get_entries+0x51>
cmp    %rcx,%rdx
jbe    64a <hash_get_entries+0x5a>
lea    0x1(%rcx),%rax
mov    %r8,(%rsi,%rcx,8)
mov    0x8(%r9),%rcx
test   %rcx,%rcx
je     63a <hash_get_entries+0x4a>
nopl   0x0(%rax)
cmp    %rdx,%rax
je     650 <hash_get_entries+0x60>
mov    (%rcx),%r8
add    $0x1,%rax
mov    %r8,-0x8(%rsi,%rax,8)
mov    0x8(%rcx),%rcx
test   %rcx,%rcx
jne    620 <hash_get_entries+0x30>
mov    0x8(%rdi),%r10
mov    %rax,%rcx
add    $0x10,%r9
cmp    %r10,%r9
jb     5fe <hash_get_entries+0xe>
mov    %rcx,%rax
retq   
xchg   %ax,%ax
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_entries (const Hash_table *table, void **buffer,
                  size_t buffer_size)
{
  size_t counter = 0;
  struct hash_entry const *bucket;
  struct hash_entry const *cursor;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          for (cursor = bucket; cursor; cursor = cursor->next)
            {
              if (counter >= buffer_size)
                return counter;
              buffer[counter++] = cursor->data;
            }
        }
    }
  return counter;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 4
6 9
7 9
8 9
9 13
10 13
11 15
12 15
13 11
14 11
15 11
16 11
17 13
18 13
19 15
20 15
21 15
22 11
23 11
24 11
25 11
26 15
27 7
28 7
29 7
30 13
31 13
32 13
33 20
34 4
35 4
36 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
sub    $0xa0,%rsp
lea    0x8(%rsp),%rdi
movl   $0x0,0x88(%rsp)
movq   $0x0,(%rsp)
callq  6e7 <setsignal+0x27>
xor    %esi,%esi
mov    %rsp,%rdx
mov    %ebx,%edi
callq  6f3 <setsignal+0x33>
test   %eax,%eax
jne    712 <setsignal+0x52>
cmpq   $0x1,(%rsp)
je     712 <setsignal+0x52>
xor    %edx,%edx
mov    %rsp,%rsi
mov    %ebx,%edi
movq   $0x0,(%rsp)
callq  712 <setsignal+0x52>
add    $0xa0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setsignal (int sig)
{
  int rc;
  struct sigaction sa;
  sa.sa_flags = 0;
  sa.__sigaction_handler.sa_handler = ((void *)0);
  sigemptyset (&sa.sa_mask);
  rc = sigaction (sig, ((void *)0), &sa);
  if (!rc && sa.__sigaction_handler.sa_handler != ((__sighandler_t) 1))
    {
      sa.__sigaction_handler.sa_handler = _exit;
      (void) sigaction (sig, &sa, ((void *)0));
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 7
5 5
6 6
7 7
8 8
9 8
10 8
11 8
12 9
13 9
14 9
15 9
16 12
17 12
18 12
19 11
20 12
21 14
22 14
23 14
24 14
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
movsd  %xmm0,-0x8(%rsp)
test   %r10,%r10
fldl   -0x8(%rsp)
je     2052 <gsl_matrix_long_double_add_constant+0x72>
mov    %r9,%rbx
shl    $0x4,%r11
xor    %ecx,%ecx
shl    $0x4,%rbx
xor    %esi,%esi
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     2042 <gsl_matrix_long_double_add_constant+0x62>
mov    0x18(%rdi),%rdx
lea    (%rcx,%rbx,1),%r8
fld    %st(0)
lea    (%rdx,%rcx,1),%rax
add    %r8,%rdx
nopw   %cs:0x0(%rax,%rax,1)
fldt   (%rax)
add    $0x10,%rax
fadd   %st(1),%st
fstpt  -0x10(%rax)
cmp    %rdx,%rax
jne    2030 <gsl_matrix_long_double_add_constant+0x50>
fstp   %st(0)
add    $0x1,%rsi
add    %r11,%rcx
cmp    %r10,%rsi
jne    2010 <gsl_matrix_long_double_add_constant+0x30>
fstp   %st(0)
jmp    2054 <gsl_matrix_long_double_add_constant+0x74>
fstp   %st(0)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_add_constant (gsl_matrix_long_double * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 2
6 7
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 9
28 9
29 9
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 15
38 15
39 15
40 15
<<<sep_out_sample>>>
push   %rbp
mov    $0xbd,%edx
mov    %edi,%ebp
mov    $0x20,%edi
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
sub    $0x8,%rsp
callq  63f <make_command+0x1f>
mov    %ebp,(%rax)
mov    %rbx,0x18(%rax)
movl   $0x0,0x4(%rax)
movl   $0x0,(%rbx)
movq   $0x0,0x10(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_command (type, pointer)
     enum command_type type;
     SIMPLE_COM *pointer;
{
  COMMAND *temp;
  temp = (COMMAND *)sh_xmalloc((sizeof (COMMAND)), "make_cmd.c", 189);
  temp->type = type;
  temp->value.Simple = pointer;
  temp->value.Simple->flags = temp->flags = 0;
  temp->redirects = (REDIRECT *)((void *)0);
  return (temp);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 4
7 6
8 4
9 6
10 7
11 8
12 9
13 9
14 10
15 12
16 12
17 12
18 12
19 12
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
test   %rsi,%rsi
mov    %rsi,(%rax)
setne  %al
movzbl %al,%edx
movzbl %al,%eax
mov    %edx,0x4(%rdi)
mov    %rax,0x8(%rdi)
retq   
<<<sep_in_sample>>>
__gmpf_set_ui (mpf_ptr f, unsigned long val)
{
  mp_size_t size;
  f->_mp_d[0] = val & ((~ ((mp_limb_t) (0))) >> 0);
  size = val != 0;
  f->_mp_exp = f->_mp_size = size;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 6
6 6
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
cmpb   $0x2e,(%rdi)
je     88 <glob_name_is_acceptable+0x88>
cmpl   $0x1,0x0(%rip)        # 13 <glob_name_is_acceptable+0x13>
mov    0x0(%rip),%rbx        # 1a <glob_name_is_acceptable+0x1a>
mov    0x0(%rip),%edx        # 20 <glob_name_is_acceptable+0x20>
mov    (%rbx),%rdi
sbb    %eax,%eax
and    $0xffffffe0,%eax
add    $0x31,%eax
cmpl   $0x1,0x0(%rip)        # 32 <glob_name_is_acceptable+0x32>
sbb    %ebp,%ebp
and    $0xffffffe0,%ebp
add    $0x21,%ebp
test   %edx,%edx
cmovne %eax,%ebp
test   %rdi,%rdi
jne    5c <glob_name_is_acceptable+0x5c>
jmp    78 <glob_name_is_acceptable+0x78>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x10,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     78 <glob_name_is_acceptable+0x78>
mov    %ebp,%edx
mov    %r12,%rsi
callq  66 <glob_name_is_acceptable+0x66>
cmp    $0x1,%eax
je     50 <glob_name_is_acceptable+0x50>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
movzbl 0x1(%rdi),%eax
test   %al,%al
je     6b <glob_name_is_acceptable+0x6b>
cmp    $0x2e,%al
jne    c <glob_name_is_acceptable+0xc>
cmpb   $0x0,0x2(%rdi)
jne    c <glob_name_is_acceptable+0xc>
jmp    6b <glob_name_is_acceptable+0x6b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
glob_name_is_acceptable (name)
     const char *name;
{
  struct ign *p;
  int flags;
  if (name[0] == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
    return (0);
  flags = (1 << 0) | (extended_glob ? (1 << 5) : 0) | (glob_ignore_case ? (1 << 4) : 0);
  for (p = globignore.ignores; p->val; p++)
    {
      if (strmatch (p->val, (char *)name, flags) != 1)
 return (0);
    }
  return (1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 8
8 9
9 8
10 9
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 15
34 15
35 7
36 15
37 15
38 15
39 15
40 15
41 14
42 15
43 15
44 15
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    4c98 <gsl_matrix_complex_float_const_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,8),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  4cba <gsl_matrix_complex_float_const_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_const_superdiagonal (const gsl_matrix_complex_float * m,
                                      const size_t k)
{
  _gsl_vector_complex_float_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_float v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 2;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b8 <cdio_stream_getpos+0x18>
mov    0x38(%rdi),%eax
test   %eax,%eax
je     b8 <cdio_stream_getpos+0x18>
mov    0x40(%rdi),%rax
mov    %rax,(%rsi)
retq   
nopl   0x0(%rax)
mov    $0xfffffffffffffffd,%rax
retq   
<<<sep_in_sample>>>
cdio_stream_getpos(CdioDataSource_t* p_obj, off_t *i_offset)
{
  if (!p_obj || !p_obj->is_open) return DRIVER_OP_UNINIT;
  return *i_offset = p_obj->position;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 3
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     100 <mu_attribute_get_flags+0x20>
test   %rsi,%rsi
je     110 <mu_attribute_get_flags+0x30>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     f8 <mu_attribute_get_flags+0x18>
jmpq   *%rax
nopl   (%rax)
mov    0x8(%rdi),%eax
mov    %eax,(%rsi)
xor    %eax,%eax
retq   
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1005,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_get_flags (mu_attribute_t attr, int *pflags)
{
  if (attr == ((void *)0))
    return 22;
  if (pflags == ((void *)0))
    return (0x1000 +5);
  if (attr->_get_flags)
    return attr->_get_flags (attr, pflags);
  *pflags = attr->flags;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 7
6 7
7 7
8 8
9 8
10 9
11 9
12 10
13 10
14 4
15 4
16 4
17 6
18 11
19 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # b1 <history_total_bytes+0x11>
test   %rbp,%rbp
je     105 <history_total_bytes+0x65>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     105 <history_total_bytes+0x65>
add    $0x8,%rbp
xor    %r12d,%r12d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rdi
add    $0x8,%rbp
callq  dc <history_total_bytes+0x3c>
mov    0x8(%rbx),%rdi
mov    %rax,%r13
callq  e8 <history_total_bytes+0x48>
mov    -0x8(%rbp),%rbx
add    %eax,%r13d
add    %r13d,%r12d
test   %rbx,%rbx
jne    d0 <history_total_bytes+0x30>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    f7 <history_total_bytes+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 5
23 5
24 4
25 4
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 4
34 4
35 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <userdata_free+0x11>
callq  11 <userdata_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     1f <userdata_free+0x1f>
callq  1f <userdata_free+0x1f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2d <userdata_free+0x2d>
callq  2d <userdata_free+0x2d>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     40 <userdata_free+0x40>
pop    %rbx
jmpq   3c <userdata_free+0x3c>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
userdata_free (struct userdata *udata)
{
  do { if (udata->login) free (udata->login); } while (0);
  do { if (udata->name) free (udata->name); } while (0);
  do { if (udata->comments) free (udata->comments); } while (0);
  do { if (udata->home) free (udata->home); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 6
20 6
21 7
22 7
23 7
<<<sep_out_sample>>>
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
jmpq   4a0 <expand_prompt>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_strip_prompt (pmt)
     char *pmt;
{
  char *ret;
  ret = expand_prompt (pmt, 0, (int *)((void *)0), (int *)((void *)0), (int *)((void *)0), (int *)((void *)0));
  return ret;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 3196 <sshget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sshget_leng (void)
{
        return sshleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     d0 <gsl_rng_memcpy+0x30>
mov    $0x4,%ecx
mov    $0x3d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c5 <gsl_rng_memcpy+0x25>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rsi
mov    0x18(%rax),%rdx
callq  e1 <gsl_rng_memcpy+0x41>
xor    %eax,%eax
jmp    ca <gsl_rng_memcpy+0x2a>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_memcpy (gsl_rng * dest, const gsl_rng * src)
{
  if (dest->type != src->type)
    {
      do { gsl_error ("generators must be of the same type", "rng.c", 61, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  memcpy (dest->state, src->state, src->type->size);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 8
20 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # a <toolong+0xa>
xor    %eax,%eax
mov    $0x0,%esi
mov    $0x1a5,%edi
callq  1b <toolong+0x1b>
mov    0x0(%rip),%eax        # 21 <toolong+0x21>
test   %eax,%eax
je     4f <toolong+0x4f>
mov    0x0(%rip),%rax        # 2c <toolong+0x2c>
mov    0x0(%rip),%ecx        # 32 <toolong+0x32>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x6,%edi
test   %rax,%rax
cmovne %rax,%rdx
xor    %eax,%eax
callq  4f <toolong+0x4f>
mov    $0x1,%edi
add    $0x8,%rsp
jmpq   5d <toolong+0x5d>
nopl   (%rax)
<<<sep_in_sample>>>
toolong (int signo)
{
  (void) signo;
  reply (421, "Timeout (%d seconds): closing control connection.",
  timeout);
  if (logging)
    syslog (6, "User %s timed out after %d seconds",
     (cred.name ? cred.name : "unknown"), timeout);
  dologout (1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 8
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 9
20 10
21 9
22 9
<<<sep_out_sample>>>
cmpq   $0x0,0x28(%rdi)
mov    $0x16,%eax
je     403 <_url_smtp_init+0x13>
cmpq   $0x0,0x38(%rdi)
je     408 <_url_smtp_init+0x18>
repz retq 
nopl   (%rax)
mov    0x58(%rdi),%eax
test   %eax,%eax
je     418 <_url_smtp_init+0x28>
mov    $0x16,%eax
retq   
nopl   (%rax)
cmpq   $0x0,0x30(%rdi)
jne    403 <_url_smtp_init+0x13>
movq   $0x19,0x30(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_url_smtp_init (mu_url_t url)
{
  if (!url->host)
    return 22;
  if (url->path || url->qargc)
    return 22;
  if (url->port == 0)
    url->port = 25;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 10
7 10
8 5
9 5
10 5
11 4
12 10
13 10
14 7
15 7
16 8
17 8
18 8
<<<sep_out_sample>>>
test   %rsi,%rsi
je     50 <cdio_open_am_osx+0x20>
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%edi
callq  45 <cdio_open_am_osx+0x15>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_open_am_osx (const char *psz_source_name, const char *psz_access_mode)
{
  if (psz_access_mode != ((void *)0))
    cdio_warn ("there is only one access mode for OS X. Arg %s ignored",
               psz_access_mode);
  return cdio_open_osx(psz_source_name);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     15f9 <gsl_vector_ushort_ispos+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
add    %rsi,%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movzwl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm0,%xmm1
jae    15ff <gsl_vector_ushort_ispos+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    15e0 <gsl_vector_ushort_ispos+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_ispos (const gsl_vector_ushort * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
mov    (%rdi),%eax
imul   $0x6c078965,%eax,%eax
mov    %rax,(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
ran_get (void *vstate)
{
  ran_state_t *state = (ran_state_t *) vstate;
  state->x = (1812433253UL * state->x) & 0xffffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # a <u32reset+0xa>
test   %eax,%eax
je     2b <u32reset+0x2b>
mov    0x0(%rip),%rdi        # 15 <u32reset+0x15>
cmp    $0xffffffffffffffff,%rdi
je     2b <u32reset+0x2b>
callq  20 <u32reset+0x20>
movq   $0xffffffffffffffff,0x0(%rip)        # 2b <u32reset+0x2b>
movl   $0x0,0x0(%rip)        # 35 <u32reset+0x35>
movl   $0x0,0x0(%rip)        # 3f <u32reset+0x3f>
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
u32reset ()
{
  if (u32init && localconv != (iconv_t)-1)
    {
      iconv_close (localconv);
      localconv = (iconv_t)-1;
    }
  u32init = 0;
  utf8locale = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 6
10 8
11 9
12 10
13 10
14 10
<<<sep_out_sample>>>
mov    $0x100,%ecx
jmpq   a <lutimensat+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lutimensat (int dir, char const *file, struct timespec const times[2])
{
  return rpl_utimensat (dir, file, times, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  b5c <compute_duration+0xc>
mov    (%rsp),%rax
sub    0x0(%rip),%rax        # b67 <compute_duration+0x17>
mov    $0x0,%edi
cvtsi2sd %rax,%xmm0
mov    0x8(%rsp),%rax
sub    0x0(%rip),%rax        # b7d <compute_duration+0x2d>
cvtsi2sd %rax,%xmm1
divsd  0x0(%rip),%xmm1        # b8a <compute_duration+0x3a>
addsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # b96 <compute_duration+0x46>
movsd  %xmm0,0x0(%rip)        # b9e <compute_duration+0x4e>
callq  ba3 <compute_duration+0x53>
movsd  0x0(%rip),%xmm0        # bab <compute_duration+0x5b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
compute_duration (void)
{
  struct timespec now;
  gettime (&now);
  duration += ((now.tv_sec - last_stat_time.tv_sec)
               + (now.tv_nsec - last_stat_time.tv_nsec) / 1e9);
  gettime (&last_stat_time);
  return duration;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 6
8 6
9 6
10 6
11 6
12 6
13 5
14 5
15 7
16 9
17 9
18 9
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
jmpq   829 <__db_remove_callback+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__db_remove_callback(dbp, cookie)
 DB *dbp;
 void *cookie;
{
 return (CDB___os_unlink(dbp->dbenv, cookie));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     11d7 <gsl_vector_long_isnonneg+0x37>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdq (%rdx),%xmm0
ucomisd %xmm0,%xmm1
ja     11dd <gsl_vector_long_isnonneg+0x3d>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    11c0 <gsl_vector_long_isnonneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_long_isnonneg (const gsl_vector_long * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
<<<sep_out_sample>>>
mov    0x28(%rdi),%edx
xor    %eax,%eax
test   %edx,%edx
sete   %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exclude_cross_references (REFERENCE *r)
{
  return r->type == 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     d9c <syserr+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    $0x0,%esi
xor    %eax,%eax
mov    0x0(%rip),%rdx        # dad <syserr+0x6d>
mov    0x0(%rip),%rdi        # db4 <syserr+0x74>
callq  db9 <syserr+0x79>
lea    0xe0(%rsp),%rax
mov    0x0(%rip),%rdi        # dc8 <syserr+0x88>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  df4 <syserr+0xb4>
mov    0x0(%rip),%rsi        # dfb <syserr+0xbb>
mov    $0xa,%edi
callq  e05 <syserr+0xc5>
callq  e0a <syserr+0xca>
mov    (%rax),%eax
test   %eax,%eax
jne    e1a <syserr+0xda>
mov    $0x46,%edi
callq  e1a <syserr+0xda>
xor    %edi,%edi
callq  e21 <syserr+0xe1>
mov    $0x47,%edi
callq  e2b <syserr+0xeb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
syserr (const char *fmt,...)
{
  extern int (*__errno_location ());
  va_list ap;
  fprintf (stderr, "\n%s SYSERR: ", program_name);
  __builtin_va_start(ap,fmt);
  vfprintf (stderr, fmt, ap);
  __builtin_va_end(ap);
  fprintf (stderr, "\n");
  if ((*__errno_location ()) == 0)
    {
      exit (70);
    }
  else
    {
      perror (((void *)0));
      exit (71);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 5
21 5
22 5
23 5
24 6
25 7
26 7
27 7
28 6
29 6
30 6
31 6
32 6
33 7
34 9
35 9
36 9
37 10
38 10
39 10
40 10
41 12
42 12
43 16
44 16
45 17
46 17
47 17
<<<sep_out_sample>>>
mov    %edi,%esi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  90 <recurse_1>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
lea    0x0(,%rax,8),%rsi
xor    %eax,%eax
test   %rcx,%rcx
je     2803 <gsl_vector_long_set_zero+0x33>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movq   $0x0,(%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    27f0 <gsl_vector_long_set_zero+0x20>
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_set_zero (gsl_vector_long * v)
{
  long * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const long zero = 0L ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 8
6 8
7 8
8 8
9 8
10 10
11 10
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%esi
push   %rbx
sub    $0x18,%rsp
callq  900 <recutl_read_file+0x10>
test   %rax,%rax
mov    %rax,%rbx
je     930 <recutl_read_file+0x40>
lea    0x8(%rsp),%rsi
mov    %rax,%rdi
callq  915 <recutl_read_file+0x25>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  920 <recutl_read_file+0x30>
add    $0x18,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
xor    %ebp,%ebp
jmp    920 <recutl_read_file+0x30>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
recutl_read_file (char *file_name)
{
  char *result;
  FILE *in;
  result = ((void *)0);
  in = fopen (file_name, "r");
  if (in)
    {
      size_t file_size;
      result = fread_file (in, &file_size);
      fclose (in);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 6
6 7
7 6
8 7
9 10
10 10
11 10
12 11
13 10
14 11
15 14
16 14
17 14
18 14
19 14
20 14
21 5
22 5
23 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x90,%rsp
mov    %rsp,%rsi
callq  1f3 <cdio_is_device_generic+0x13>
test   %eax,%eax
jne    218 <cdio_is_device_generic+0x38>
mov    0x18(%rsp),%eax
and    $0xb000,%eax
cmp    $0x2000,%eax
sete   %al
add    $0x90,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
callq  21d <cdio_is_device_generic+0x3d>
mov    (%rax),%edi
callq  224 <cdio_is_device_generic+0x44>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  236 <cdio_is_device_generic+0x56>
add    $0x90,%rsp
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_is_device_generic(const char *source_name)
{
  struct stat buf;
  if (0 != stat(source_name, &buf)) {
    cdio_warn ("Can't get file status for %s:\n%s", source_name,
                strerror((*__errno_location ())));
    return 0;
  }
  return (((((buf.st_mode)) & 0170000) == (0060000)) || ((((buf.st_mode)) & 0170000) == (0020000)));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 6
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 10
25 7
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  161 <_body_get_transport2+0x11>
mov    0x18(%rax),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
mov    %rbp,%rdx
pop    %rbp
jmpq   176 <_body_get_transport2+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_body_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_get_transport2 (body->fstream, pin, pout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 4
10 5
11 4
12 5
13 4
14 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_min (const gsl_rng * r)
{
  return r->type->min;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %edi,%edi
mov    0x0(%rip),%eax        # 98 <tty_setecho+0x8>
jne    a8 <tty_setecho+0x18>
and    $0xfffffff7,%eax
mov    %eax,0x0(%rip)        # a3 <tty_setecho+0x13>
retq   
nopl   0x0(%rax)
or     $0x8,%eax
mov    %eax,0x0(%rip)        # b1 <tty_setecho+0x21>
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_setecho (int on)
{
  if (on)
    termbuf.c_lflag |= 0000010;
  else
    termbuf.c_lflag &= ~0000010;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
ucomiss 0x0(%rip),%xmm0        # 7 <cblas_saxpy+0x7>
jnp    130 <cblas_saxpy+0x130>
cmp    $0x1,%edx
je     70 <cblas_saxpy+0x70>
xor    %r9d,%r9d
test   %edx,%edx
jle    158 <cblas_saxpy+0x158>
xor    %eax,%eax
test   %r8d,%r8d
jle    148 <cblas_saxpy+0x148>
test   %edi,%edi
jle    6d <cblas_saxpy+0x6d>
movslq %r9d,%r9
movslq %r8d,%r8
cltq   
movslq %edx,%rdx
lea    (%rsi,%r9,4),%rsi
lea    (%rcx,%rax,4),%rax
shl    $0x2,%r8
shl    $0x2,%rdx
xor    %ecx,%ecx
nopl   0x0(%rax)
movss  (%rsi),%xmm1
add    $0x1,%ecx
mulss  %xmm0,%xmm1
add    %rdx,%rsi
addss  (%rax),%xmm1
movss  %xmm1,(%rax)
add    %r8,%rax
cmp    %edi,%ecx
jne    50 <cblas_saxpy+0x50>
repz retq 
nop
cmp    $0x1,%r8d
jne    12 <cblas_saxpy+0x12>
mov    %edi,%eax
sar    $0x1f,%eax
shr    $0x1e,%eax
lea    (%rdi,%rax,1),%r9d
and    $0x3,%r9d
sub    %eax,%r9d
xor    %eax,%eax
test   %r9d,%r9d
jle    ac <cblas_saxpy+0xac>
movss  (%rsi,%rax,4),%xmm1
mulss  %xmm0,%xmm1
addss  (%rcx,%rax,4),%xmm1
movss  %xmm1,(%rcx,%rax,4)
add    $0x1,%rax
cmp    %eax,%r9d
jg     90 <cblas_saxpy+0x90>
lea    0x3(%r9),%eax
cmp    %eax,%edi
jle    1fb <cblas_saxpy+0x1fb>
movslq %r9d,%r10
lea    0x0(,%r10,4),%rax
lea    (%rsi,%rax,1),%r8
lea    (%rcx,%rax,1),%rdx
lea    0x10(%r8),%r11
cmp    %r11,%rdx
jb     170 <cblas_saxpy+0x170>
movaps %xmm0,%xmm3
sub    $0x4,%edi
xor    %eax,%eax
sub    %r9d,%edi
xorps  %xmm2,%xmm2
shr    $0x2,%edi
shufps $0x0,%xmm3,%xmm3
add    $0x1,%rdi
shl    $0x4,%rdi
nopl   (%rax)
movaps %xmm2,%xmm1
movaps %xmm2,%xmm0
movlps (%r8,%rax,1),%xmm1
movlps (%rdx,%rax,1),%xmm0
movhps 0x8(%r8,%rax,1),%xmm1
movhps 0x8(%rdx,%rax,1),%xmm0
mulps  %xmm3,%xmm1
addps  %xmm1,%xmm0
movlps %xmm0,(%rdx,%rax,1)
movhps %xmm0,0x8(%rdx,%rax,1)
add    $0x10,%rax
cmp    %rdi,%rax
jne    f8 <cblas_saxpy+0xf8>
repz retq 
nopl   0x0(%rax)
jne    d <cblas_saxpy+0xd>
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   28 <cblas_saxpy+0x28>
nopl   (%rax)
mov    $0x1,%r9b
sub    %edi,%r9d
imul   %edx,%r9d
jmpq   1d <cblas_saxpy+0x1d>
nopw   0x0(%rax,%rax,1)
lea    0x10(%rdx),%r11
cmp    %r11,%r8
jae    d8 <cblas_saxpy+0xd8>
sub    $0x4,%edi
lea    0x4(%rax),%rdx
sub    %r9,%rdi
and    $0xfffffffc,%edi
lea    (%rcx,%rdx,1),%rax
add    %rdx,%rsi
add    %r10,%rdi
lea    0x14(%rcx,%rdi,4),%rdx
nopl   0x0(%rax)
movss  -0x4(%rsi),%xmm1
add    $0x10,%rax
add    $0x10,%rsi
mulss  %xmm0,%xmm1
addss  -0x14(%rax),%xmm1
movss  %xmm1,-0x14(%rax)
movss  -0x10(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0x10(%rax),%xmm1
movss  %xmm1,-0x10(%rax)
movss  -0xc(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0xc(%rax),%xmm1
movss  %xmm1,-0xc(%rax)
movss  -0x8(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0x8(%rax),%xmm1
movss  %xmm1,-0x8(%rax)
cmp    %rdx,%rax
jne    1a0 <cblas_saxpy+0x1a0>
repz retq 
repz retq 
<<<sep_in_sample>>>
cblas_saxpy (const int N, const float alpha, const float *X, const int incX,
             float *Y, const int incY)
{
{
  int i;
  if (alpha == 0.0) {
    return;
  }
  if (incX == 1 && incY == 1) {
    const int m = N % 4;
    for (i = 0; i < m; i++) {
      Y[i] += alpha * X[i];
    }
    for (i = m; i + 3 < N; i += 4) {
      Y[i] += alpha * X[i];
      Y[i + 1] += alpha * X[i + 1];
      Y[i + 2] += alpha * X[i + 2];
      Y[i + 3] += alpha * X[i + 3];
    }
  } else {
    int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
    int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
    for (i = 0; i < N; i++) {
      Y[iy] += alpha * X[ix];
      ix += incX;
      iy += incY;
    }
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 21
6 21
7 21
8 22
9 22
10 22
11 23
12 23
13 23
14 23
15 23
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 24
24 23
25 24
26 24
27 24
28 24
29 24
30 23
31 23
32 23
33 23
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 10
42 11
43 11
44 11
45 12
46 12
47 12
48 12
49 12
50 11
51 11
52 14
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 14
61 14
62 14
63 14
64 14
65 14
66 15
67 15
68 15
69 15
70 15
71 15
72 15
73 15
74 15
75 15
76 15
77 15
78 15
79 15
80 15
81 15
82 15
83 15
84 15
85 15
86 15
87 6
88 6
89 6
90 6
91 22
92 22
93 22
94 22
95 22
96 21
97 21
98 21
99 21
100 21
101 21
102 21
103 21
104 21
105 21
106 21
107 21
108 21
109 21
110 21
111 21
112 21
113 15
114 15
115 15
116 15
117 15
118 15
119 16
120 16
121 16
122 16
123 17
124 17
125 17
126 17
127 18
128 18
129 18
130 18
131 14
132 14
133 14
134 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # aed7 <wipe_seen_flags+0x7>
test   %rsi,%rsi
je     af34 <wipe_seen_flags+0x64>
mov    0x0(%rip),%rdi        # aee3 <wipe_seen_flags+0x13>
add    $0x1,%rsi
mov    $0x1,%ecx
xor    %edx,%edx
xchg   %ax,%ax
mov    (%rdi,%rdx,8),%rax
mov    0xb8(%rax),%rdx
test   %rdx,%rdx
je     af23 <wipe_seen_flags+0x53>
mov    (%rdx),%rax
test   %rax,%rax
je     af23 <wipe_seen_flags+0x53>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rdx
andl   $0xffff7fff,0x20(%rax)
mov    (%rdx),%rax
test   %rax,%rax
jne    af10 <wipe_seen_flags+0x40>
lea    0x1(%rcx),%rax
cmp    %rsi,%rax
je     af40 <wipe_seen_flags+0x70>
mov    %rcx,%rdx
mov    %rax,%rcx
jmp    aef0 <wipe_seen_flags+0x20>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wipe_seen_flags (void)
{
  int fb_index;
  TAG **t;
  for (fb_index = 0; fb_index < info_loaded_files_index; fb_index++)
    {
      t = info_loaded_files[fb_index]->tags;
      if (!t)
        continue;
      for (; *t; t++)
        {
          (*t)->flags &= ~0x8000;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 12
19 10
20 10
21 10
22 10
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%edx
xor    %eax,%eax
mov    $0x0,%esi
callq  231 <f_uint+0x11>
mov    %ebx,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_uint (FILE *fp, void *ptr, int size) { fprintf (fp, "%u", *(unsigned*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     320 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 327 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     348 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     386 <argp_version_parser+0x76>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 34f <argp_version_parser+0x3f>
test   %rdx,%rdx
je     370 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  364 <argp_version_parser+0x54>
jmp    339 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  384 <argp_version_parser+0x74>
jmp    339 <argp_version_parser+0x29>
xor    %edi,%edi
callq  38d <argp_version_parser+0x7d>
nopl   (%rax)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      ((void) (state->root_argp->argp_domain), ((const char *) ("(PROGRAM ERROR) No version known!?")))
                                                                     );
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 18
4 21
5 21
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 14
15 14
16 14
17 21
18 21
19 21
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 15
36 15
37 15
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # f78 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # f7f <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    faa <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  fa5 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    f98 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     fd3 <quotearg_free+0x63>
callq  fbd <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # fc8 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # fd3 <quotearg_free+0x63>
cmp    $0x0,%r12
je     fef <quotearg_free+0x7f>
mov    %r12,%rdi
callq  fe4 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # fef <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # ffb <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
jmpq   29 <user_option_add+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
user_option_add (a2ps_job * job, const char * key, const char * value)
{
  pair_add (job->user_options, key, value);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rdi        # 42 <mu_global_debug_set_level+0x12>
test   %rdi,%rdi
je     70 <mu_global_debug_set_level+0x40>
mov    %rsp,%rdx
mov    %rbx,%rsi
callq  52 <mu_global_debug_set_level+0x22>
cmp    $0x1029,%eax
mov    %eax,%edx
je     5f <mu_global_debug_set_level+0x2f>
test   %edx,%edx
jne    67 <mu_global_debug_set_level+0x37>
mov    (%rsp),%rax
mov    %ebp,(%rax)
mov    %edx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
xor    %edx,%edx
mov    $0x4,%esi
mov    $0x0,%edi
callq  81 <mu_global_debug_set_level+0x51>
test   %eax,%eax
jne    67 <mu_global_debug_set_level+0x37>
mov    0x0(%rip),%rdi        # 8c <mu_global_debug_set_level+0x5c>
jmp    47 <mu_global_debug_set_level+0x17>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_global_debug_set_level (const char *object_name, mu_log_level_t level)
{
  int rc;
  struct debug_level *dbg;
  if (!debug_table)
    {
      rc = mu_assoc_create (&debug_table, sizeof(struct debug_level), 0);
      if (rc)
 return rc;
    }
  rc = mu_assoc_ref_install (debug_table, object_name, (void**) &dbg);
  if (rc == 0 || rc == (0x1000 +41))
    dbg->level = level;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 11
10 11
11 11
12 12
13 11
14 12
15 12
16 12
17 13
18 13
19 11
20 15
21 15
22 15
23 15
24 15
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     4138 <gsl_matrix_int_free+0x38>
mov    0x28(%rdi),%eax
test   %eax,%eax
jne    4120 <gsl_matrix_int_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   4119 <gsl_matrix_int_free+0x19>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdi
callq  4129 <gsl_matrix_int_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   4132 <gsl_matrix_int_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_free (gsl_matrix_int * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_int_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
movq   $0x0,(%rdi)
cmpq   $0x0,0xe0(%rdx)
je     ea0 <osip_dialog_init_as_uas+0x80>
mov    0x158(%rdx),%rcx
mov    0xf8(%rdx),%r8
mov    %rsi,%r9
callq  820 <__osip_dialog_init>
test   %eax,%eax
je     e70 <osip_dialog_init_as_uas+0x50>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0xe0(%rbx),%rax
mov    0x0(%rbp),%rbp
mov    0x8(%rax),%rdi
movl   $0x1,0x54(%rbp)
callq  e8b <osip_dialog_init_as_uas+0x6b>
mov    %eax,0x34(%rbp)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffb,%eax
jmp    e5f <osip_dialog_init_as_uas+0x3f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_dialog_init_as_uas (osip_dialog_t ** dialog, osip_message_t * invite, osip_message_t * response)
{
  int i;
  *dialog = ((void *)0);
  if (response->cseq == ((void *)0))
    return -5;
  i = __osip_dialog_init (dialog, invite, response, response->to, response->from, invite);
  if (i != 0) {
    *dialog = ((void *)0);
    return i;
  }
  (*dialog)->type = CALLEE;
  (*dialog)->remote_cseq = osip_atoi (response->cseq->number);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 9
16 15
17 15
18 15
19 15
20 15
21 13
22 12
23 13
24 12
25 13
26 13
27 15
28 14
29 15
30 15
31 15
32 15
33 6
34 6
35 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x18(%rdi),%rax
cmp    $0x40,%rsi
mov    $0x40,%edx
movq   $0x0,(%rsp)
cmovbe %rsi,%rdx
mov    %rsp,%rsi
callq  *0x8(%rax)
mov    (%rsp),%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_urandomb_ui (gmp_randstate_ptr rstate, unsigned long bits)
{
  mp_limb_t a[1];
  a[0] = 0;
  do { gmp_randstate_ptr __rstate = (rstate); (*((gmp_randfnptr_t *) ((__rstate)->_mp_algdata._mp_lc))->randget_fn) (__rstate, a, ((bits) < ((8 * 8)) ? (bits) : ((8 * 8)))); } while (0);
  return a[0];
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 4
6 5
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_scheme_string_variable (name, number, value)
     DStr_string_descriptor *name;
     int number;
     DStr_string_descriptor *value;
{
  char *command;
  char *var_name;
  return 0;
  }
<<<sep_in_sample>>>
1 9
2 9
3 9
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
lea    0x44(%rdi),%rbp
push   %rbx
mov    %rbp,%rdi
sub    $0x90,%rsp
callq  331 <announce+0x21>
lea    0x8(%rax),%edi
movslq %edi,%rdi
callq  33c <announce+0x2c>
test   %rax,%rax
mov    %rax,%rbx
je     3a8 <announce+0x98>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    %rax,%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  35b <announce+0x4b>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  366 <announce+0x56>
mov    %rbx,%rdi
mov    %eax,%r14d
callq  371 <announce+0x61>
test   %r14d,%r14d
mov    $0x4,%eax
js     382 <announce+0x72>
testb  $0x10,0x18(%rsp)
jne    398 <announce+0x88>
add    $0x90,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  e0 <print_mesg>
jmp    382 <announce+0x72>
mov    $0x3,%edi
mov    $0x0,%esi
xor    %eax,%eax
callq  3b9 <announce+0xa9>
mov    $0x1,%edi
callq  3c3 <announce+0xb3>
<<<sep_in_sample>>>
announce (CTL_MSG * request, char *remote_machine)
{
  char *ttypath;
  int len;
  struct stat st;
  int rc;
  len = sizeof ("/dev/") + strlen (request->r_tty) + 2;
  ttypath = malloc (len);
  if (!ttypath)
    {
      syslog (3, "Out of memory");
      exit (1);
    }
  sprintf (ttypath, "%s/%s", "/dev/", request->r_tty);
  rc = stat (ttypath, &st);
  free (ttypath);
  if (rc < 0 || (st.st_mode & (0200 >> 3)) == 0)
    return 4;
  return print_mesg (request->r_tty, request, remote_machine);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 2
9 7
10 2
11 7
12 7
13 8
14 8
15 9
16 8
17 9
18 14
19 14
20 14
21 14
22 14
23 14
24 15
25 15
26 15
27 16
28 15
29 16
30 17
31 18
32 17
33 17
34 17
35 20
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 19
44 19
45 19
46 19
47 19
48 11
49 11
50 11
51 11
52 12
53 12
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     5b <__gmp_printf+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rdi,%rdx
mov    $0x0,%edi
mov    0x0(%rip),%rsi        # 77 <__gmp_printf+0x77>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  9b <__gmp_printf+0x9b>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_printf (const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 6
19 2
20 6
21 6
22 5
23 5
24 5
25 5
26 5
27 6
28 9
29 9
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    %rsi,%rdi
setne  %al
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_mu_list_ptr_comparator (const void *item, const void *value)
{
  return item != value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
test   %rbx,%rbx
je     da <find_token_in_alist+0x2a>
cmp    %edi,0x8(%rsi)
mov    %rsi,%rax
jne    d1 <find_token_in_alist+0x21>
jmp    e0 <find_token_in_alist+0x30>
nopl   0x0(%rax,%rax,1)
add    $0x10,%rax
cmp    %edi,0x8(%rax)
je     e0 <find_token_in_alist+0x30>
mov    0x10(%rax),%rbx
test   %rbx,%rbx
jne    c8 <find_token_in_alist+0x18>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  e8 <find_token_in_alist+0x38>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x58,%edx
callq  fb <find_token_in_alist+0x4b>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   107 <find_token_in_alist+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_token_in_alist (token, alist, flags)
     int token;
     STRING_INT_ALIST *alist;
     int flags;
{
  register int i;
  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return ((char *)strcpy (sh_xmalloc((1 + strlen (alist[i].word)), "stringlib.c", 88), (alist[i].word)));
    }
  return ((char *)((void *)0));
}
<<<sep_in_sample>>>
1 5
2 7
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 7
14 7
15 7
16 13
17 13
18 13
19 13
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 13
29 10
30 10
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
mov    %rsi,(%rdi)
mov    %rsi,%rdi
callq  7b7 <osip_uri_param_set+0x17>
test   %rbx,%rbx
mov    %rbx,0x8(%rbp)
je     7c8 <osip_uri_param_set+0x28>
mov    %rbx,%rdi
callq  7c8 <osip_uri_param_set+0x28>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_uri_param_set (osip_uri_param_t * url_param, char *pname, char *pvalue)
{
  url_param->gname = pname;
  osip_clrspace (url_param->gname);
  url_param->gvalue = pvalue;
  if (url_param->gvalue != ((void *)0))
    osip_clrspace (url_param->gvalue);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 6
10 5
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     3f0 <gsl_blas_sswap+0x30>
mov    $0x13,%ecx
mov    $0x10f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3e5 <gsl_blas_sswap+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  40a <gsl_blas_sswap+0x4a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y)
{
  if (X->size == Y->size)
    {
      cblas_sswap (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                   ((int)(Y->stride)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 271, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 11
6 11
7 11
8 11
9 11
10 11
11 13
12 13
13 13
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 13
23 13
24 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  b9c <clone_quoting_options+0xc>
mov    (%rax),%r12d
test   %rbp,%rbp
mov    $0x0,%edi
mov    %rax,%rbx
cmovne %rbp,%rdi
mov    $0x38,%esi
callq  bb8 <clone_quoting_options+0x28>
mov    %r12d,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
clone_quoting_options (struct quoting_options *o)
{
  int e = (*__errno_location ());
  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,
           sizeof *o);
  (*__errno_location ()) = e;
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 3
10 4
11 4
12 4
13 6
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    0x8(%rdi),%rax
js     20 <__gmpz_set_si+0x20>
mov    %rsi,(%rax)
setne  %al
movzbl %al,%eax
mov    %eax,0x4(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
neg    %rsi
mov    %rsi,(%rax)
mov    $0xffffffff,%eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_set_si (mpz_ptr dest, signed long int val)
{
  mp_size_t size;
  mp_limb_t vl;
  vl = (mp_limb_t) ((val) >= 0 ? ((unsigned long int) (val)) : (- (((unsigned long int) ((val) + 1)) - 1)));
  ((dest)->_mp_d)[0] = vl & ((~ ((mp_limb_t) (0))) >> 0);
  size = vl != 0;
  ((dest)->_mp_size) = val >= 0 ? size : -size;
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 6
5 7
6 7
7 8
8 8
9 8
10 5
11 5
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     1e48 <dap_ftell+0x18>
mov    %rax,%rdi
jmpq   1e41 <dap_ftell+0x11>
nopl   0x0(%rax)
mov    0x10(%rdi),%rdx
mov    0x8(%rdx),%rax
sub    (%rdx),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dap_ftell(DFILE *fp)
{
  if (fp->dfile_disk)
    return ftell(fp->dfile_disk);
  return fp->dfile_ram->rfile_pos - fp->dfile_ram->rfile_str;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d0 <osip_sem_trywait+0x10>
jmpq   1ca <osip_sem_trywait+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
osip_sem_trywait (struct osip_sem *_sem)
{
  osip_sem_t *sem = (osip_sem_t *) _sem;
  if (sem == ((void *)0))
    return -2;
  return sem_trywait (sem);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    (%rsi),%r13
cmp    (%rdi),%r13
mov    0x8(%rdi),%rax
jne    4c3 <gsl_matrix_complex_equal+0x23>
mov    0x8(%rsi),%r12
cmp    %rax,%r12
je     4f0 <gsl_matrix_complex_equal+0x50>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4dc <gsl_matrix_complex_equal+0x3c>
xor    %eax,%eax
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
test   %r13,%r13
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
je     5ff <gsl_matrix_complex_equal+0x15f>
lea    (%rdx,%rdx,1),%rbx
shl    $0x4,%rdx
mov    %r13,0x38(%rsp)
mov    %rdx,0x30(%rsp)
movq   $0x0,0x8(%rsp)
xor    %r15d,%r15d
mov    %rbx,0x20(%rsp)
lea    (%rax,%rax,1),%rbx
shl    $0x4,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
xor    %r14d,%r14d
mov    %rbx,0x18(%rsp)
movq   $0x0,0x10(%rsp)
mov    %rax,%r13
test   %r12,%r12
je     5d0 <gsl_matrix_complex_equal+0x130>
mov    0x18(%rdi),%r9
mov    0x18(%rsi),%r8
mov    0x8(%rsp),%rax
movsd  (%r9,%r15,1),%xmm0
ucomisd (%r8,%rax,1),%xmm0
jp     5bf <gsl_matrix_complex_equal+0x11f>
jne    5bf <gsl_matrix_complex_equal+0x11f>
lea    0x2(%r13),%rdx
lea    0x2(%r14),%rax
mov    %r14,%r11
mov    %r13,%r10
xor    %ecx,%ecx
jmp    5af <gsl_matrix_complex_equal+0x10f>
nop
jne    5bf <gsl_matrix_complex_equal+0x11f>
add    $0x1,%rcx
cmp    %r12,%rcx
je     5d0 <gsl_matrix_complex_equal+0x130>
movsd  (%r9,%rdx,8),%xmm0
lea    0x2(%rdx),%rbx
lea    0x2(%rax),%rbp
ucomisd (%r8,%rax,8),%xmm0
jp     5bf <gsl_matrix_complex_equal+0x11f>
jne    5bf <gsl_matrix_complex_equal+0x11f>
mov    %rdx,%r10
mov    %rax,%r11
mov    %rbx,%rdx
mov    %rbp,%rax
movsd  0x8(%r9,%r10,8),%xmm0
ucomisd 0x8(%r8,%r11,8),%xmm0
jnp    580 <gsl_matrix_complex_equal+0xe0>
add    $0x48,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
addq   $0x1,0x10(%rsp)
mov    0x28(%rsp),%rax
add    0x20(%rsp),%r13
add    %rax,0x8(%rsp)
add    0x18(%rsp),%r14
add    0x30(%rsp),%r15
mov    0x38(%rsp),%rax
cmp    %rax,0x10(%rsp)
jne    547 <gsl_matrix_complex_equal+0xa7>
mov    $0x1,%eax
jmpq   4de <gsl_matrix_complex_equal+0x3e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_complex_equal (const gsl_matrix_complex * a, const gsl_matrix_complex * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 2; k++)
                {
                  if (a->data[(i * tda_a + j) * 2 + k]
                      != b->data[(i * tda_b + j) * 2 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 4
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 7
21 30
22 30
23 30
24 30
25 30
26 30
27 30
28 30
29 30
30 14
31 11
32 12
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 16
50 16
51 20
52 21
53 20
54 20
55 20
56 20
57 20
58 20
59 20
60 21
61 20
62 20
63 20
64 20
65 20
66 16
67 16
68 16
69 20
70 20
71 20
72 20
73 20
74 20
75 20
76 21
77 21
78 21
79 20
80 20
81 20
82 30
83 23
84 30
85 30
86 30
87 30
88 30
89 30
90 30
91 14
92 14
93 14
94 14
95 14
96 14
97 14
98 14
99 14
100 29
101 29
102 29
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    $0x0,%esi
callq  a1 <page_range_free+0x11>
mov    %rbx,%rdi
pop    %rbx
jmpq   aa <page_range_free+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
page_range_free (struct page_range * page_range)
{
  da_free (page_range->intervals, (da_map_func_t) free);
  free (page_range);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 4
9 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2987 <java_get_leng+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_get_leng (void)
{
        return java_leng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     12c <stream_set_read+0x1c>
test   %rsi,%rsi
mov    $0x0,%eax
cmovne %rsi,%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
stream_set_read (struct net_stream *str, stream_read_t read)
{
  if (!str)
    return 22;
  str->read = read ? read : _def_read;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 5
7 5
8 6
9 7
10 7
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 23b6 <yyset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_debug (int bdebug )
{
        yy_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
test   %rdx,%rdx
mov    %rdx,0x20(%rsp)
mov    %rcx,0x28(%rsp)
mov    0x78(%rsp),%r12
jle    ee2 <Do_Importance_Ratios+0x1a2>
movslq 0x70(%rsp),%r15
xorpd  %xmm1,%xmm1
lea    0x0(,%rcx,8),%r14
mov    %rsi,%r13
xor    %ebx,%ebx
lea    (%r9,%r15,4),%rbp
cmpq   $0x0,0x28(%rsp)
movq   $0x0,(%r12,%rbx,8)
xorpd  %xmm0,%xmm0
jle    de0 <Do_Importance_Ratios+0xa0>
xor    %eax,%eax
xorpd  %xmm0,%xmm0
xor    %r8d,%r8d
jmp    dc5 <Do_Importance_Ratios+0x85>
nop
mov    (%r9,%r8,4),%r10d
test   %r10d,%r10d
je     db8 <Do_Importance_Ratios+0x78>
mov    (%rdi,%rbx,8),%rdx
addsd  (%rdx,%rax,1),%xmm0
movsd  %xmm0,(%r12,%rbx,8)
add    $0x1,%r8
add    $0x8,%rax
cmp    %r14,%rax
je     de0 <Do_Importance_Ratios+0xa0>
cmpq   $0x0,0x0(%r13,%rax,1)
je     dbc <Do_Importance_Ratios+0x7c>
cmp    %r8,%r15
jne    da0 <Do_Importance_Ratios+0x60>
mov    0x0(%rbp),%edx
xor    %r10d,%r10d
test   %edx,%edx
sete   %r10b
jmp    da4 <Do_Importance_Ratios+0x64>
mov    %r9,0x18(%rsp)
mov    %rdi,0x10(%rsp)
movsd  %xmm1,0x8(%rsp)
callq  df5 <Do_Importance_Ratios+0xb5>
movsd  %xmm0,(%r12,%rbx,8)
add    $0x1,%rbx
cmp    0x20(%rsp),%rbx
movsd  0x8(%rsp),%xmm1
mov    0x10(%rsp),%rdi
mov    0x18(%rsp),%r9
addsd  %xmm0,%xmm1
jne    d80 <Do_Importance_Ratios+0x40>
mov    %r12,%rax
mov    %rbx,%rdx
shl    $0x3c,%rax
shr    $0x3f,%rax
cmp    %rbx,%rax
cmova  %rbx,%rax
cmp    $0x3,%rbx
ja     ef1 <Do_Importance_Ratios+0x1b1>
movsd  (%r12),%xmm0
cmp    $0x1,%rdx
mov    $0x1,%r8d
divsd  %xmm1,%xmm0
movsd  %xmm0,(%r12)
jbe    e89 <Do_Importance_Ratios+0x149>
movsd  0x8(%r12),%xmm0
cmp    $0x2,%rdx
mov    $0x2,%r8b
divsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%r12)
jbe    e89 <Do_Importance_Ratios+0x149>
movsd  0x10(%r12),%xmm0
mov    $0x3,%r8b
divsd  %xmm1,%xmm0
movsd  %xmm0,0x10(%r12)
cmp    %rdx,%rbx
je     ee2 <Do_Importance_Ratios+0x1a2>
sub    %rdx,%rbx
mov    %rbx,%rdi
shr    %rdi
mov    %rdi,%r9
add    %r9,%r9
je     ed2 <Do_Importance_Ratios+0x192>
movapd %xmm1,%xmm2
lea    (%r12,%rdx,8),%rsi
xor    %eax,%eax
xor    %edx,%edx
unpcklpd %xmm2,%xmm2
movapd (%rsi,%rax,1),%xmm0
add    $0x1,%rdx
divpd  %xmm2,%xmm0
movapd %xmm0,(%rsi,%rax,1)
add    $0x10,%rax
cmp    %rdx,%rdi
ja     eaf <Do_Importance_Ratios+0x16f>
add    %r9,%r8
cmp    %r9,%rbx
je     ee2 <Do_Importance_Ratios+0x1a2>
lea    (%r12,%r8,8),%rax
movsd  (%rax),%xmm0
divsd  %xmm1,%xmm0
movsd  %xmm0,(%rax)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
test   %rax,%rax
jne    efd <Do_Importance_Ratios+0x1bd>
xor    %edx,%edx
xor    %r8d,%r8d
jmp    e8e <Do_Importance_Ratios+0x14e>
mov    %rax,%rdx
jmpq   e3d <Do_Importance_Ratios+0xfd>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Do_Importance_Ratios (double **pdY, PMCVAR *pLikes, long nSims,
                           long nPreds, long nDesignPts, int *piDesign_mask,
                           int nDesignPt_tried, double *pdIR)
{
  long i, j, k;
  double dSumL = 0;
  BOOL bOn;
  for (k = 0; k < nSims; k++) {
    pdIR[k] = 0;
    j = 0;
    for (i = 0; i < nPreds; i++) {
      if (pLikes[i] != ((void *)0)) {
        if (j == nDesignPt_tried)
          bOn = ! piDesign_mask[j];
        else
          bOn = piDesign_mask[j];
        if (bOn)
          pdIR[k] = pdIR[k] + pdY[k][i];
        j++;
      }
    }
    pdIR[k] = exp(pdIR[k]);
    dSumL = dSumL + pdIR[k];
  }
  for (k = 0; k < nSims; k++)
    pdIR[k] = pdIR[k] / dSumL;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 8
9 4
10 4
11 4
12 8
13 14
14 6
15 6
16 6
17 8
18 14
19 11
20 9
21 11
22 11
23 11
24 11
25 10
26 10
27 10
28 16
29 17
30 17
31 18
32 18
33 18
34 19
35 19
36 11
37 11
38 12
39 12
40 13
41 13
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 22
51 22
52 8
53 8
54 23
55 8
56 8
57 23
58 8
59 8
60 8
61 8
62 8
63 8
64 8
65 8
66 8
67 26
68 26
69 25
70 26
71 26
72 26
73 26
74 26
75 25
76 26
77 26
78 26
79 26
80 25
81 26
82 26
83 26
84 26
85 26
86 26
87 26
88 26
89 26
90 26
91 26
92 26
93 8
94 8
95 8
96 26
97 26
98 26
99 26
100 26
101 26
102 26
103 26
104 26
105 26
106 26
107 26
108 26
109 26
110 27
111 27
112 27
113 27
114 27
115 27
116 27
117 27
118 27
119 27
120 8
121 8
122 8
123 8
124 8
125 8
<<<sep_out_sample>>>
cmp    $0x1,%esi
je     de0 <mu_locker_set_default_flags+0x40>
jb     dd0 <mu_locker_set_default_flags+0x30>
cmp    $0x2,%esi
jne    dc0 <mu_locker_set_default_flags+0x20>
not    %edi
xor    %eax,%eax
and    %edi,0x0(%rip)        # db6 <mu_locker_set_default_flags+0x16>
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %edi,0x0(%rip)        # dd6 <mu_locker_set_default_flags+0x36>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
or     %edi,0x0(%rip)        # de6 <mu_locker_set_default_flags+0x46>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_locker_set_default_flags (int flags, enum mu_locker_set_mode mode)
{
  switch (mode)
    {
    case mu_locker_assign:
      mu_locker_default_flags = flags;
      break;
    case mu_locker_set_bit:
      mu_locker_default_flags |= flags;
      break;
    case mu_locker_clear_bit:
      mu_locker_default_flags &= ~flags;
      break;
    default:
      return 22;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 12
7 17
8 12
9 13
10 13
11 15
12 18
13 18
14 6
15 17
16 7
17 7
18 9
19 17
20 10
21 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edx,%edx
mov    $0x1,%esi
xor    %eax,%eax
callq  a82 <sh_validfd+0x12>
not    %eax
add    $0x8,%rsp
shr    $0x1f,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_validfd (fd)
     int fd;
{
  return (fcntl (fd, 1, 0) >= 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 4
9 5
10 5
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    %rsi,%rcx
mov    $0x16,%eax
je     bab <mu_m_server_get_default_address+0x1b>
mov    0xd0(%rdi),%esi
cmp    (%rdx),%esi
mov    $0x102a,%ax
jle    bb0 <mu_m_server_get_default_address+0x20>
repz retq 
nopl   (%rax)
movslq %esi,%rdx
lea    0x60(%rdi),%rsi
sub    $0x8,%rsp
mov    %rcx,%rdi
callq  bc3 <mu_m_server_get_default_address+0x33>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_get_default_address (mu_m_server_t srv, struct sockaddr *sa,
     int *salen)
{
  int len;
  if (!sa)
    return 22;
  len = srv->defaddr.len;
  if (sa)
    {
      if (*salen < len)
 return (0x1000 +42);
      memcpy (sa, &srv->defaddr.s.s_sa, len);
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 3
3 6
4 5
5 7
6 10
7 11
8 10
9 15
10 15
11 12
12 12
13 3
14 12
15 12
16 14
17 15
18 15
19 15
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_cnonce (osip_authentication_info_t * authentication_info)
{
  return authentication_info->cnonce;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_version (osip_authorization_t * authorization)
{
  return authorization->version;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %edi,%ecx
shr    $0x5,%al
and    $0x1f,%ecx
and    $0x7,%eax
mov    0x0(,%rax,4),%eax
shr    %cl,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
libunistring_is_basic (char c)
{
  return (libunistring_is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))
         & 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x8(%rbp),%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     f0a <mu_argv_free+0x2a>
nopl   (%rax)
add    $0x8,%rbx
callq  f01 <mu_argv_free+0x21>
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    ef8 <mu_argv_free+0x18>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   f18 <mu_argv_free+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_argv_free (char **argv)
{
  int i;
  for (i = 0; argv[i]; i++)
    free (argv[i]);
  free (argv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 4
15 7
16 6
17 7
18 7
19 6
20 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x10,%rsp
mov    (%rdi),%r12
mov    0x10(%rdi),%rbp
mov    0x8(%rdi),%r13
movss  0x0(%rbp),%xmm2
test   %r12,%r12
movss  %xmm2,0xc(%rsp)
je     ade <gsl_vector_float_min_index+0x6e>
shl    $0x2,%r13
movaps %xmm2,%xmm0
add    %r13,%rbp
xor    %ebx,%ebx
xor    %r14d,%r14d
jmp    ad5 <gsl_vector_float_min_index+0x65>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     af0 <gsl_vector_float_min_index+0x80>
movss  0x0(%rbp),%xmm0
movss  0xc(%rsp),%xmm1
ucomiss %xmm0,%xmm1
jbe    ad2 <gsl_vector_float_min_index+0x62>
movss  %xmm0,0xc(%rsp)
mov    %rbx,%r14
add    %r13,%rbp
callq  ada <gsl_vector_float_min_index+0x6a>
test   %eax,%eax
je     ab0 <gsl_vector_float_min_index+0x40>
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x10,%rsp
mov    %r14,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_min_index (const gsl_vector_float * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  float min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      float x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
        {
          return i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 3
9 5
10 4
11 5
12 8
13 5
14 8
15 10
16 10
17 10
18 8
19 6
20 6
21 6
22 8
23 8
24 8
25 10
26 11
27 11
28 11
29 10
30 10
31 10
32 16
33 16
34 16
35 22
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 22
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 22
53 22
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
cmp    %r9,%r10
jbe    652 <hash_get_entries+0x62>
xor    %ecx,%ecx
mov    (%r9),%r8
test   %r8,%r8
je     641 <hash_get_entries+0x51>
cmp    %rcx,%rdx
jbe    64a <hash_get_entries+0x5a>
lea    0x1(%rcx),%rax
mov    %r8,(%rsi,%rcx,8)
mov    0x8(%r9),%rcx
test   %rcx,%rcx
je     63a <hash_get_entries+0x4a>
nopl   0x0(%rax)
cmp    %rdx,%rax
je     650 <hash_get_entries+0x60>
mov    (%rcx),%r8
add    $0x1,%rax
mov    %r8,-0x8(%rsi,%rax,8)
mov    0x8(%rcx),%rcx
test   %rcx,%rcx
jne    620 <hash_get_entries+0x30>
mov    0x8(%rdi),%r10
mov    %rax,%rcx
add    $0x10,%r9
cmp    %r10,%r9
jb     5fe <hash_get_entries+0xe>
mov    %rcx,%rax
retq   
xchg   %ax,%ax
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_entries (const Hash_table *table, void **buffer,
                  size_t buffer_size)
{
  size_t counter = 0;
  struct hash_entry const *bucket;
  struct hash_entry const *cursor;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          for (cursor = bucket; cursor; cursor = cursor->next)
            {
              if (counter >= buffer_size)
                return counter;
              buffer[counter++] = cursor->data;
            }
        }
    }
  return counter;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 4
6 9
7 9
8 9
9 13
10 13
11 15
12 15
13 11
14 11
15 11
16 11
17 13
18 13
19 15
20 15
21 15
22 11
23 11
24 11
25 11
26 15
27 7
28 7
29 7
30 13
31 13
32 13
33 20
34 4
35 4
36 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
pxor   %xmm0,%xmm0
sub    $0x28,%rsp
mov    %rsp,%rsi
xor    %edx,%edx
xor    %edi,%edi
movdqa %xmm0,(%rsp)
movdqa %xmm0,0x10(%rsp)
callq  8f <end_msgs+0x1f>
xor    %esi,%esi
mov    $0xe,%edi
callq  9b <end_msgs+0x2b>
xor    %eax,%eax
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
end_msgs (void)
{
  struct itimerval itimer;
  ((&itimer.it_value)->tv_sec = (&itimer.it_value)->tv_usec = 0);
  ((&itimer.it_interval)->tv_sec = (&itimer.it_interval)->tv_usec = 0);
  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);
  signal (14, ((__sighandler_t) 0));
  return 0;
}
<<<sep_in_sample>>>
1 5
2 2
3 6
4 6
5 6
6 5
7 5
8 6
9 7
10 7
11 7
12 9
13 9
14 9
<<<sep_out_sample>>>
mov    %esi,%edx
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_open_netbsd(const char *source_name)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 2d7 <filepath+0x7>
mov    %rdi,%rax
test   %rcx,%rcx
je     30a <filepath+0x3a>
cmpb   $0x2f,(%rdi)
je     30a <filepath+0x3a>
sub    $0x8,%rsp
mov    %rdi,%r8
mov    $0x0,%edx
mov    $0xfb,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  301 <filepath+0x31>
add    $0x8,%rsp
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
filepath(char *file)
{
 static char path[250 + 1];
 if (prependpath != ((void *)0) && *file != '/') {
  (void) snprintf(path, sizeof(path), "%s/%s", prependpath, file);
  file = path;
 }
 return(file);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 2
8 5
9 5
10 5
11 5
12 5
13 5
14 9
15 6
16 9
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl (%rdi),%eax
test   %al,%al
jne    83 <mu_str_skip_cset_comp+0x23>
jmp    93 <mu_str_skip_cset_comp+0x33>
nopl   (%rax)
add    $0x1,%rbx
movzbl (%rbx),%eax
test   %al,%al
je     93 <mu_str_skip_cset_comp+0x33>
movsbl %al,%esi
mov    %rbp,%rdi
callq  8e <mu_str_skip_cset_comp+0x2e>
test   %rax,%rax
je     78 <mu_str_skip_cset_comp+0x18>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_str_skip_cset_comp (const char *str, const char *cset)
{
  for (; *str && strchr (cset, *str) == ((void *)0); str++)
    ;
  return (char*) str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  d <gnewton_free+0xd>
mov    0x8(%rbx),%rdi
callq  16 <gnewton_free+0x16>
mov    0x18(%rbx),%rdi
callq  1f <gnewton_free+0x1f>
mov    0x20(%rbx),%rdi
pop    %rbx
jmpq   29 <gnewton_free+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gnewton_free (void * vstate)
{
  gnewton_state_t * state = (gnewton_state_t *) vstate;
  gsl_vector_free(state->d);
  gsl_vector_free(state->x_trial);
  gsl_matrix_free(state->lu);
  gsl_permutation_free(state->permutation);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
je     1e90 <rec_parser_tell+0x10>
mov    %rax,%rdi
jmpq   1e90 <rec_parser_tell+0x10>
mov    0x8(%rdi),%rdx
test   %rdx,%rdx
je     1ea1 <rec_parser_tell+0x21>
mov    0x18(%rdi),%rax
sub    %rdx,%rax
retq   
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1eac <rec_parser_tell+0x2c>
mov    $0x0,%esi
xor    %eax,%eax
callq  1eb8 <rec_parser_tell+0x38>
mov    $0xffffffffffffffff,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_parser_tell (rec_parser_t parser)
{
  if (parser->in_file)
    {
      return ftell (parser->in_file);
    }
  else if (parser->in_buffer)
    {
      return parser->p - parser->in_buffer;
    }
  else
    {
      rpl_fprintf (stderr, "rec_parser_seek: no backend in parser. This is a bug.  Please report it.");
      return -1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 7
7 7
8 7
9 9
10 9
11 16
12 2
13 13
14 13
15 13
16 13
17 14
18 16
19 16
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  c4e <rec_aggregate_std_p+0xe>
test   %eax,%eax
je     ca0 <rec_aggregate_std_p+0x60>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  c5f <rec_aggregate_std_p+0x1f>
test   %eax,%eax
je     ca0 <rec_aggregate_std_p+0x60>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  c70 <rec_aggregate_std_p+0x30>
test   %eax,%eax
je     ca0 <rec_aggregate_std_p+0x60>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  c81 <rec_aggregate_std_p+0x41>
test   %eax,%eax
je     ca0 <rec_aggregate_std_p+0x60>
mov    %rbx,%rdi
mov    $0x0,%esi
callq  c92 <rec_aggregate_std_p+0x52>
test   %eax,%eax
sete   %al
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
rec_aggregate_std_p (const char *name)
{
  _Bool found = 0;
  size_t i = 0;
  for (i = 0; i < 5; i++)
    {
      if (strcasecmp (name, std_aggregates[i].name) == 0)
        {
          found = 1;
          break;
        }
    }
  return found;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 14
28 14
29 14
30 9
31 14
32 14
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,(%rdi)
mov    %rdi,%rbx
je     1230 <rec_rset_url+0x40>
mov    $0x5,%edi
callq  1204 <rec_rset_url+0x14>
mov    (%rbx),%rdi
xor    %edx,%edx
mov    %rax,%rsi
callq  1211 <rec_rset_url+0x21>
test   %rax,%rax
je     1230 <rec_rset_url+0x40>
mov    %rax,%rdi
callq  121e <rec_rset_url+0x2e>
pop    %rbx
mov    %rax,%rdi
jmpq   1227 <rec_rset_url+0x37>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_url (rec_rset_t rset)
{
  char *res;
  rec_field_t field;
  res = ((void *)0);
  if (rset->descriptor)
    {
      field = rec_record_get_field_by_name (rset->descriptor,
                                            rec_std_field_name ((REC_FIELD_REC)),
                                            0);
      if (field)
        {
          res = rec_extract_url (rec_field_value (field));
        }
    }
  return res;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 11
12 11
13 13
14 13
15 17
16 13
17 13
18 13
19 17
20 17
21 17
22 17
<<<sep_out_sample>>>
jmpq   65 <alphabetic+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alphabetic (c)
     int c;
{
  return rl_alphabetic (c);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %edi,0x7c(%rsi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_debug (int bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yy_flex_debug_r = bdebug ;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3a0 <find_directory>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_name (const char *dir)
{
  return find_directory (dir)->name;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 166 <CDB_db_env_set_region_init+0x6>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
CDB_db_env_set_region_init(onoff)
 int onoff;
{
 CDB___db_global_values.db_region_init = onoff;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
push   %r14
mov    0x0(%rip),%edx        # 498 <sig_number+0x8>
push   %r13
mov    %rdi,%r13
test   %edx,%edx
push   %r12
push   %rbp
push   %rbx
je     520 <sig_number+0x90>
cmpb   $0x53,0x0(%r13)
je     536 <sig_number+0xa6>
test   %edx,%edx
mov    $0xffffffff,%eax
jle    506 <sig_number+0x76>
lea    -0x1(%rdx),%r12d
movzbl 0x0(%r13),%ebp
xor    %ebx,%ebx
add    $0x1,%r12
jmp    4d9 <sig_number+0x49>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     510 <sig_number+0x80>
mov    %rbx,%rax
movslq %ebx,%r14
shl    $0x4,%rax
mov    0x0(%rax),%rsi
cmp    %bpl,(%rsi)
jne    4d0 <sig_number+0x40>
mov    %r13,%rdi
callq  4f7 <sig_number+0x67>
test   %eax,%eax
jne    4d0 <sig_number+0x40>
shl    $0x4,%r14
mov    0x0(%r14),%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffff,%eax
pop    %r14
retq   
xchg   %ax,%ax
callq  525 <sig_number+0x95>
cmpb   $0x53,0x0(%r13)
mov    0x0(%rip),%edx        # 530 <sig_number+0xa0>
jne    4b0 <sig_number+0x20>
cmpb   $0x49,0x1(%r13)
jne    4b0 <sig_number+0x20>
cmpb   $0x47,0x2(%r13)
lea    0x3(%r13),%rax
cmove  %rax,%r13
jmpq   4b0 <sig_number+0x20>
<<<sep_in_sample>>>
sig_number (abbrev)
     const char *abbrev;
{
  int i;
  if (sig_table_nelts == 0)
    signame_init ();
  if (abbrev[0] == 'S' && abbrev[1] == 'I' && abbrev[2] == 'G')
    abbrev += 3;
  for (i = 0; i < sig_table_nelts; i++)
    if (abbrev[0] == sig_table[i].abbrev[0]
 && strcmp (abbrev, sig_table[i].abbrev) == 0)
      return sig_table[i].number;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 3
8 3
9 5
10 7
11 7
12 9
13 13
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 12
35 12
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 13
48 14
49 14
50 14
51 6
52 7
53 7
54 7
55 7
56 7
57 8
58 8
59 8
60 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d40 <mu_mailbox_get_stream+0x20>
test   %rsi,%rsi
je     d60 <mu_mailbox_get_stream+0x40>
mov    0x20(%rdi),%rax
test   %rax,%rax
je     d50 <mu_mailbox_get_stream+0x30>
mov    %rax,(%rsi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1006,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x38(%rdi),%rdi
test   %rdi,%rdi
je     d33 <mu_mailbox_get_stream+0x13>
jmpq   d5e <mu_mailbox_get_stream+0x3e>
xchg   %ax,%ax
mov    $0x1005,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_get_stream (mu_mailbox_t mbox, mu_stream_t *pstream)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (pstream == ((void *)0))
    return (0x1000 +5);
  if (mbox->stream == ((void *)0))
    {
      if (mbox->folder)
 return mu_folder_get_stream (mbox->folder, pstream);
    }
  *pstream = mbox->stream;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 7
6 7
7 7
8 12
9 13
10 13
11 13
12 4
13 4
14 4
15 9
16 9
17 9
18 10
19 10
20 6
21 14
22 14
<<<sep_out_sample>>>
testb  $0x8,0x0(%rip)        # 2777 <systemic+0x7>
push   %rbx
mov    %rdi,%rbx
je     278c <systemic+0x1c>
mov    %rdi,%rsi
xor    %eax,%eax
mov    $0x0,%edi
callq  278c <systemic+0x1c>
mov    0x0(%rip),%rdi        # 2793 <systemic+0x23>
callq  2798 <systemic+0x28>
mov    %rbx,%rdi
pop    %rbx
jmpq   27a1 <systemic+0x31>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
systemic (char const *command)
{
  if (debug & 8)
    say ("+ %s\n", command);
  fflush (stdout);
  return system (command);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 7
13 6
14 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rsi
mov    %rdi,%rbx
mov    $0x1000,%edx
mov    $0x0,%edi
callq  476 <save_current_path+0x16>
mov    $0x1000,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  488 <save_current_path+0x28>
mov    $0x0,%edx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     48d <save_current_path+0x2d>
mov    %eax,%ecx
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmovne %rdx,%rcx
add    %al,%al
sbb    $0x3,%rcx
cmp    $0x0,%rcx
jbe    4ee <save_current_path+0x8e>
cmpb   $0x2f,-0x1(%rcx)
lea    -0x1(%rcx),%rsi
jne    4e5 <save_current_path+0x85>
jmp    501 <save_current_path+0xa1>
nopl   0x0(%rax)
cmpb   $0x2f,-0x1(%rsi)
lea    -0x1(%rsi),%rdx
je     510 <save_current_path+0xb0>
mov    %rdx,%rsi
cmp    $0x0,%rsi
jne    4d8 <save_current_path+0x78>
mov    %rbx,%rsi
mov    $0x1000,%edx
mov    $0x0,%edi
pop    %rbx
jmpq   501 <save_current_path+0xa1>
mov    %rsi,%rdx
mov    %rcx,%rsi
nopw   0x0(%rax,%rax,1)
movb   $0x0,(%rdx)
mov    $0x0,%edi
mov    $0x1000,%edx
pop    %rbx
jmpq   523 <save_current_path+0xc3>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
save_current_path(const char *path)
{
 char *startp, *p;
 strlimcpy(current_path, path, sizeof(current_path));
 strlimcpy(current_dir, path, sizeof(current_path));
 startp = current_dir;
 p = startp + strlen(current_dir);
 while (p > startp) {
  if (*--p == '/') {
   *p = '\0';
   strlimcpy(current_file, p + 1, sizeof(current_file));
   return;
  }
 }
 strlimcpy(current_file, path, sizeof(current_file));
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 8
28 8
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 8
39 8
40 15
41 15
42 15
43 16
44 15
45 9
46 9
47 9
48 10
49 11
50 11
51 16
52 11
53 11
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  753 <CDB___log_init_print+0x13>
test   %eax,%eax
je     760 <CDB___log_init_print+0x20>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
mov    $0x2,%edx
mov    $0x0,%esi
pop    %rbx
jmpq   773 <CDB___log_init_print+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___log_init_print(dbenv)
 DB_ENV *dbenv;
{
 int ret;
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register1_print, 1)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register_print, 2)) != 0)
  return (ret);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 5
6 5
7 5
8 12
9 12
10 12
11 8
12 8
13 8
14 12
15 8
16 8
<<<sep_out_sample>>>
sub    $0x58,%rsp
xor    %edi,%edi
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
callq  41ee <disable_signals+0x1e>
xor    %esi,%esi
xor    %edi,%edi
mov    %rsp,%rdx
andl   $0xfffffffe,0xc(%rsp)
callq  41ff <disable_signals+0x2f>
mov    0x48(%rsp),%rax
xor    %fs:0x28,%rax
jne    4214 <disable_signals+0x44>
add    $0x58,%rsp
retq   
callq  4219 <disable_signals+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
disable_signals(void)
{
    struct termios term;
    tcgetattr(0, &term);
    term.c_lflag &= ~0000001;
    tcsetattr(0, 0, &term);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 2
7 4
8 6
9 6
10 6
11 5
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x8,%edi
callq  63 <resetflt+0x13>
cmp    $0x1,%rax
je     80 <resetflt+0x30>
xor    %esi,%esi
mov    $0x8,%edi
add    $0x8,%rsp
jmpq   79 <resetflt+0x29>
nopl   0x0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
resetflt (void)
{
  if (signal (8, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (8, ((__sighandler_t) 0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
mov    0x78(%rsi),%rdx
mov    %rdi,%rax
mov    %rdx,(%rdi)
mov    0x80(%rsi),%rdx
mov    %rdx,0x8(%rdi)
mov    0x88(%rsi),%rdx
mov    %rdx,0x10(%rdi)
mov    0x90(%rsi),%rdx
mov    %rdx,0x18(%rdi)
mov    0x98(%rsi),%rdx
mov    %rdx,0x20(%rdi)
mov    0xa0(%rsi),%rdx
mov    %rdx,0x28(%rdi)
mov    0xa8(%rsi),%rdx
mov    %rdx,0x30(%rdi)
mov    0xb0(%rsi),%rdx
mov    %rdx,0x38(%rdi)
mov    0xb8(%rsi),%rdx
mov    %rdx,0x40(%rdi)
mov    0xc0(%rsi),%rdx
mov    %rdx,0x48(%rdi)
mov    0xc8(%rsi),%rdx
mov    %rdx,0x50(%rdi)
mov    0xd0(%rsi),%rdx
mov    %rdx,0x58(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_robust_statistics(const gsl_multifit_robust_workspace *w)
{
  return w->stats;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 4
27 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <printer_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <printer_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
printer_hash_1 (struct printer *printer)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((printer->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
cmp    %r9,%r10
jbe    652 <hash_get_entries+0x62>
xor    %ecx,%ecx
mov    (%r9),%r8
test   %r8,%r8
je     641 <hash_get_entries+0x51>
cmp    %rcx,%rdx
jbe    64a <hash_get_entries+0x5a>
lea    0x1(%rcx),%rax
mov    %r8,(%rsi,%rcx,8)
mov    0x8(%r9),%rcx
test   %rcx,%rcx
je     63a <hash_get_entries+0x4a>
nopl   0x0(%rax)
cmp    %rdx,%rax
je     650 <hash_get_entries+0x60>
mov    (%rcx),%r8
add    $0x1,%rax
mov    %r8,-0x8(%rsi,%rax,8)
mov    0x8(%rcx),%rcx
test   %rcx,%rcx
jne    620 <hash_get_entries+0x30>
mov    0x8(%rdi),%r10
mov    %rax,%rcx
add    $0x10,%r9
cmp    %r10,%r9
jb     5fe <hash_get_entries+0xe>
mov    %rcx,%rax
retq   
xchg   %ax,%ax
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_entries (const Hash_table *table, void **buffer,
                  size_t buffer_size)
{
  size_t counter = 0;
  struct hash_entry const *bucket;
  struct hash_entry const *cursor;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          for (cursor = bucket; cursor; cursor = cursor->next)
            {
              if (counter >= buffer_size)
                return counter;
              buffer[counter++] = cursor->data;
            }
        }
    }
  return counter;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 4
6 9
7 9
8 9
9 13
10 13
11 15
12 15
13 11
14 11
15 11
16 11
17 13
18 13
19 15
20 15
21 15
22 11
23 11
24 11
25 11
26 15
27 7
28 7
29 7
30 13
31 13
32 13
33 20
34 4
35 4
36 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rsi,%rcx
mov    0xe8(%rdi),%rbx
mov    %edx,%esi
mov    %rcx,%rdi
mov    0xd0(%rax),%rax
callq  *0x10(%rax)
mov    0x48(%rbx),%rdx
and    0x4c(%rdx),%eax
cmp    0x48(%rdx),%eax
jbe    24fc <CDB___ham_call_hash+0x2c>
and    0x50(%rdx),%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
CDB___ham_call_hash(dbc, k, len)
 DBC *dbc;
 u_int8_t *k;
 int32_t len;
{
 u_int32_t n, bucket;
 HASH_CURSOR *hcp;
 HASH *hashp;
 hcp = (HASH_CURSOR *)dbc->internal;
 hashp = dbc->dbp->h_internal;
 n = (u_int32_t)(hashp->h_hash(k, len));
 bucket = n & hcp->hdr->high_mask;
 if (bucket > hcp->hdr->max_bucket)
  bucket = bucket & hcp->hdr->low_mask;
 return (bucket);
}
<<<sep_in_sample>>>
1 5
2 10
3 5
4 9
5 11
6 11
7 11
8 11
9 12
10 12
11 13
12 13
13 14
14 16
15 16
16 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x0(%rip),%ecx        # 11cf <convert_put_path+0xf>
test   %ecx,%ecx
je     11dd <convert_put_path+0x1d>
mov    0x0(%rip),%eax        # 11d9 <convert_put_path+0x19>
test   %eax,%eax
je     1210 <convert_put_path+0x50>
cmpl   $0x5,0xc(%rbx)
jne    1229 <convert_put_path+0x69>
mov    (%rbx),%rbp
mov    %rdx,%rsi
mov    %rbx,%rdi
callq  30 <convert_pathname>
mov    %rax,%rdi
mov    %rbp,%rsi
callq  11fc <convert_put_path+0x3c>
mov    (%rbx),%rsi
mov    0x0(%rip),%edi        # 1205 <convert_put_path+0x45>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
jmpq   1210 <convert_put_path+0x50>
test   %rsi,%rsi
je     11dd <convert_put_path+0x1d>
mov    %rsi,%rdi
mov    %rdx,0x8(%rsp)
callq  400 <set_color_tag>
mov    0x8(%rsp),%rdx
jmp    11dd <convert_put_path+0x1d>
mov    $0x0,%edi
xor    %eax,%eax
callq  1235 <convert_put_path+0x75>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
convert_put_path(CONVERT *cv, const char *pattern, const char *path)
{
 if (use_color && !locked && pattern)
  set_color_tag(pattern);
 if (cv->format != 5)
  die("convert_put_path: internal error.");
 fputs(convert_pathname(cv, path), cv->op);
 (void)fputc(newline, cv->op);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 9
23 9
24 9
25 8
26 3
27 3
28 4
29 4
30 4
31 4
32 4
33 6
34 6
35 6
36 6
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm0
jmpq   d <gsl_nan+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_nan (void)
{
  return gsl_fdiv (0.0, 0.0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
xor    %eax,%eax
test   %dil,%dil
js     50 <mu_parse822_is_ctl+0x20>
movsbl %dil,%edx
mov    $0x1,%al
testb  $0x8,0x0(,%rdx,4)
jne    50 <mu_parse822_is_ctl+0x20>
xor    %eax,%eax
cmp    $0x7f,%dil
sete   %al
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_parse822_is_ctl (char c)
{
  return (((unsigned)((unsigned) c)) < 128 && mu_c_tab[(unsigned)((unsigned) c)] & (0x008)) || c == 127 ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
xorpd  %xmm0,%xmm0
mov    %rdi,0x8(%rsp)
movapd %xmm1,%xmm3
mov    %rsp,%rdi
movsd  0x0(%rip),%xmm1        # 14a0 <gsl_integration_qagi+0x20>
mov    $0x0,%r9d
movq   $0x0,(%rsp)
callq  f0 <qags>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_integration_qagi (gsl_function * f,
                      double epsabs, double epsrel, size_t limit,
                      gsl_integration_workspace * workspace,
                      double *result, double *abserr)
{
  int status;
  gsl_function f_transform;
  f_transform.function = &i_transform;
  f_transform.params = f;
  status = qags (&f_transform, 0.0, 1.0,
                 epsabs, epsrel, limit,
                 workspace,
                 result, abserr,
                 &gsl_integration_qk15);
  return status;
}
<<<sep_in_sample>>>
1 5
2 5
3 10
4 9
5 10
6 10
7 10
8 10
9 8
10 10
11 16
12 16
13 16
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %r8,%r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     4b69 <rc_child_lookup+0x89>
test   %r13d,0x8(%r12)
je     4b60 <rc_child_lookup+0x80>
mov    0x10(%r12),%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    4b2c <rc_child_lookup+0x4c>
jmp    4b60 <rc_child_lookup+0x80>
nopl   0x0(%rax,%rax,1)
add    $0x10,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     4b60 <rc_child_lookup+0x80>
mov    %rbp,%rsi
callq  4b34 <rc_child_lookup+0x54>
test   %eax,%eax
jne    4b20 <rc_child_lookup+0x40>
mov    0x8(%rbx),%eax
test   %r14,%r14
mov    %eax,(%r15)
je     4b7a <rc_child_lookup+0x9a>
mov    0xc(%rbx),%eax
mov    %eax,(%r14)
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
mov    (%r12),%r12
test   %r12,%r12
jne    4b02 <rc_child_lookup+0x22>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %r12,%rax
jmp    4b4c <rc_child_lookup+0x6c>
nop
<<<sep_in_sample>>>
rc_child_lookup (struct rc_secdef_child *child, char *str,
   int method, int *key, int *flags)
{
  for (; child; child = child->next)
    {
      if (child->method & method)
 {
   struct rc_kwdef *kw;
   for (kw = child->kwdef; kw->name; kw++)
     if (!strcmp (kw->name, str))
       {
  *key = kw->tok;
  if (flags)
    *flags = kw->flags;
  return child;
       }
 }
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 6
16 6
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 12
32 13
33 12
34 13
35 14
36 14
37 14
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 20
47 4
48 4
49 4
50 20
51 19
52 20
53 20
54 20
55 20
56 20
57 20
58 20
59 20
60 20
61 20
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%rsi
test   %rcx,%rcx
movsd  (%rsi),%xmm1
je     10e <gsl_histogram_min_bin+0x3e>
xor    %edx,%edx
xor    %eax,%eax
nopl   0x0(%rax)
add    $0x1,%rdx
cmp    %rcx,%rdx
je     10c <gsl_histogram_min_bin+0x3c>
movsd  (%rsi,%rdx,8),%xmm0
ucomisd %xmm0,%xmm1
jbe    e8 <gsl_histogram_min_bin+0x18>
mov    %rdx,%rax
add    $0x1,%rdx
cmp    %rcx,%rdx
movapd %xmm0,%xmm1
jne    f1 <gsl_histogram_min_bin+0x21>
repz retq 
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_histogram_min_bin (const gsl_histogram * h)
{
  size_t i;
  size_t imin = 0;
  double min = h->bin[0];
  for (i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 6
2 5
3 6
4 5
5 6
6 6
7 4
8 4
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 6
17 6
18 8
19 6
20 6
21 4
22 15
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x8(%rsi),%rax
jne    16c0 <gsl_vector_short_equal+0x50>
test   %r8,%r8
je     16b7 <gsl_vector_short_equal+0x47>
mov    0x10(%rsi),%rdx
mov    0x10(%rdi),%rcx
add    %r9,%r9
lea    (%rax,%rax,1),%rdi
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movzwl (%rdx),%esi
cmp    %si,(%rcx)
jne    16e4 <gsl_vector_short_equal+0x74>
add    $0x1,%rax
add    %r9,%rcx
add    %rdi,%rdx
cmp    %r8,%rax
jne    16a0 <gsl_vector_short_equal+0x30>
mov    $0x1,%eax
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16dd <gsl_vector_short_equal+0x6d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_equal (const gsl_vector_short * u, const gsl_vector_short * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (u->data[1 * stride_u * j + k] != v->data[1 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 7
3 4
4 5
5 7
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 16
15 16
16 16
17 11
18 11
19 11
20 11
21 11
22 22
23 22
24 22
25 2
26 9
27 9
28 9
29 9
30 9
31 9
32 23
33 23
34 18
35 18
36 18
<<<sep_out_sample>>>
xor    %eax,%eax
testb  $0x10,0x29(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
visible_var (var)
     SHELL_VAR *var;
{
  return (((((var)->attributes) & (0x0001000))) == 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    %edi,%eax
mov    $0x431bde83,%edx
sub    $0x18,%rsp
imul   %edx
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x12,%edx
sub    %eax,%edx
test   %edx,%edx
jle    200 <osip_usleep+0x40>
movslq %edx,%rdx
xor    %edi,%edi
mov    %rdi,0x8(%rsp)
mov    %rdx,(%rsp)
mov    %rsp,%r8
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
xor    %edi,%edi
callq  1f9 <osip_usleep+0x39>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
movslq %edi,%rdi
xor    %edx,%edx
jmp    1e0 <osip_usleep+0x20>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_usleep (int useconds)
{
  struct timeval delay;
  int sec;
  sec = (int) useconds / 1000000;
  if (sec > 0) {
    delay.tv_sec = sec;
    delay.tv_usec = 0;
  }
  else {
    delay.tv_sec = 0;
    delay.tv_usec = useconds;
  }
  select (0, 0, 0, 0, &delay);
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 7
12 8
13 8
14 8
15 14
16 14
17 14
18 14
19 14
20 14
21 15
22 15
23 15
24 12
25 11
26 11
27 11
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <mkstemp_safer+0x9>
add    $0x8,%rsp
mov    %eax,%edi
jmpq   14 <mkstemp_safer+0x14>
<<<sep_in_sample>>>
mkstemp_safer (char *templ)
{
  return fd_safer (mkstemp (templ));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 3
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
term_change_eof (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
display_mk82(craft *c, craftType *ct, viewer *u, int *x, int *y)
{
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
jmpq   11e5 <yy_grecsrealloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecsrealloc (void * ptr, yy_grecs_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1f03 <gsl_matrix_short_ispos+0x53>
xorpd  %xmm1,%xmm1
lea    (%rax,%rax,1),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     1ef7 <gsl_matrix_short_ispos+0x47>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movswl (%rsi,%rax,2),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm0,%xmm1
jae    1f09 <gsl_matrix_short_ispos+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1ee0 <gsl_matrix_short_ispos+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    1ece <gsl_matrix_short_ispos+0x1e>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_short_ispos (const gsl_matrix_short * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
cmp    $0x3,%esi
jg     2608 <osip_set_transport_error_callback+0x18>
movslq %esi,%rsi
xor    %eax,%eax
mov    %rdx,0x290(%rdi,%rsi,8)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    %esi,%r9d
mov    $0x0,%r8d
xor    %ecx,%ecx
mov    $0x2,%edx
mov    $0x669,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  262d <osip_set_transport_error_callback+0x3d>
mov    $0xfffffffe,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_set_transport_error_callback (osip_t * config, int type, osip_transport_error_cb_t cb)
{
  if (type >= OSIP_TRANSPORT_ERROR_CALLBACK_COUNT) {
    osip_trace ("osip.c", 1641, TRACE_LEVEL2, ((void *)0), "invalid callback type %d\n", type);
    return -2;
  }
  config->tp_error_callbacks[type] = cb;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 8
5 7
6 8
7 8
8 2
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 9
19 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b50 <osip_transaction_get_reserved2+0x10>
mov    0x2c48(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_get_reserved2 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved2;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  11de <dbop_getversion+0xe>
test   %rax,%rax
je     11f0 <dbop_getversion+0x20>
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   11ef <dbop_getversion+0x1f>
nop
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dbop_getversion(DBOP *dbop)
{
 int format_version = 1;
 const char *p;
 if ((p = dbop_getoption(dbop, " __.VERSION")) != ((void *)0))
  format_version = atoi(p);
 return format_version;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 8
8 6
9 6
10 8
11 8
12 8
13 8
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_name (const gsl_multifit_nlinear_workspace * w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 38 <do_last_line+0x8>
mov    0x10(%rbx),%rax
mov    (%rax),%rdi
mov    %rax,0x20(%rbx)
callq  48 <do_last_line+0x18>
mov    %rax,0x30(%rbx)
callq  51 <do_last_line+0x21>
mov    %rax,0x38(%rbx)
mov    0x0(%rip),%eax        # 5b <do_last_line+0x2b>
movb   $0x1,0x0(%rip)        # 62 <do_last_line+0x32>
movb   $0x0,0x0(%rip)        # 69 <do_last_line+0x39>
lea    -0x1(%rax),%edx
mov    0x0(%rip),%rax        # 73 <do_last_line+0x43>
movslq %edx,%rdx
mov    %rdx,0x40(%rax)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
do_last_line(void)
{
    openfile->current = openfile->filebot;
    openfile->current_x = strlen(openfile->filebot->data);
    openfile->placewewant = xplustabs();
    openfile->current_y = editwinrows - 1;
    refresh_needed = 1;
    focusing = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 5
9 5
10 6
11 7
12 8
13 6
14 6
15 6
16 6
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_response (osip_authorization_t * authorization)
{
  return authorization->response;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x2,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_hard_ignored (sig)
     int sig;
{
  return (sigmodes[sig] & 0x2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     2d0 <gsl_blas_zdotc+0x30>
mov    $0x13,%ecx
mov    $0xaf,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c5 <gsl_blas_zdotc+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  2f0 <gsl_blas_zdotc+0x50>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotc)
{
  if (X->size == Y->size)
    {
      cblas_zdotc_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotc)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 175, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 12
6 12
7 12
8 12
9 12
10 12
11 14
12 14
13 14
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 14
25 14
26 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%r10
mov    0x8(%rdi),%rbx
mov    0x10(%rdi),%r12
test   %rbp,%rbp
mov    (%r10),%rdi
je     1563 <gsl_matrix_long_minmax+0x73>
lea    0x0(,%rbx,8),%r13
shl    $0x3,%r12
mov    %rdi,%r8
xor    %r11d,%r11d
nop
test   %rbx,%rbx
je     154a <gsl_matrix_long_minmax+0x5a>
lea    (%r10,%r13,1),%r9
mov    %r10,%rcx
nopl   0x0(%rax)
mov    (%rcx),%rax
cmp    %rax,%rdi
cmovg  %rax,%rdi
cmp    %rax,%r8
cmovl  %rax,%r8
add    $0x8,%rcx
cmp    %rcx,%r9
jne    1530 <gsl_matrix_long_minmax+0x40>
add    $0x1,%r11
add    %r12,%r10
cmp    %rbp,%r11
jne    1520 <gsl_matrix_long_minmax+0x30>
pop    %rbx
pop    %rbp
pop    %r12
mov    %rdi,(%rsi)
mov    %r8,(%rdx)
pop    %r13
retq   
pop    %rbx
pop    %rbp
mov    %rdi,%r8
mov    %rdi,(%rsi)
pop    %r12
mov    %r8,(%rdx)
pop    %r13
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_minmax (const gsl_matrix_long * m,
                               long * min_out,
                               long * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long max = m->data[0 * tda + 0];
  long min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 8
7 6
8 7
9 11
10 8
11 11
12 11
13 11
14 8
15 11
16 11
17 13
18 13
19 13
20 13
21 13
22 15
23 15
24 15
25 15
26 15
27 15
28 13
29 13
30 11
31 11
32 11
33 11
34 28
35 28
36 28
37 26
38 27
39 28
40 28
41 28
42 28
43 8
44 26
45 28
46 27
47 28
48 28
49 28
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x98,%rsp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
callq  5da <rec_record_get_num_fields_by_name+0x1a>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
jmp    652 <rec_record_get_num_fields_by_name+0x92>
nopl   0x0(%rax)
mov    0x40(%rsp),%rdi
callq  642 <rec_record_get_num_fields_by_name+0x82>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  64d <rec_record_get_num_fields_by_name+0x8d>
cmp    $0x1,%al
sbb    $0xffffffff,%ebx
lea    0x40(%rsp),%rdx
lea    0x50(%rsp),%rdi
xor    %ecx,%ecx
mov    $0x1,%esi
callq  668 <rec_record_get_num_fields_by_name+0xa8>
test   %al,%al
jne    638 <rec_record_get_num_fields_by_name+0x78>
lea    0x50(%rsp),%rdi
callq  676 <rec_record_get_num_fields_by_name+0xb6>
add    $0x98,%rsp
movslq %ebx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_get_num_fields_by_name (rec_record_t record,
                                   const char *field_name)
{
  rec_mset_iterator_t iter;
  rec_field_t field;
  int num_fields = 0;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &field, ((void *)0)))
    {
      if (rec_field_name_equal_p (rec_field_name (field), field_name))
        {
          num_fields++;
        }
    }
  rec_mset_iterator_free (&iter);
  return num_fields;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 10
28 10
29 10
30 10
31 10
32 12
33 12
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 15
42 15
43 17
44 16
45 17
46 17
47 17
48 17
<<<sep_out_sample>>>
mov    %rsi,%rax
nopl   0x0(%rax,%rax,1)
lea    0x1(%rax),%rsi
cmp    %rsi,%rdx
jbe    2b <gsl_interp_bsearch+0x2b>
lea    (%rdx,%rax,1),%rcx
shr    %rcx
movsd  (%rdi,%rcx,8),%xmm1
ucomisd %xmm0,%xmm1
jbe    30 <gsl_interp_bsearch+0x30>
mov    %rcx,%rdx
cmp    %rsi,%rdx
ja     11 <gsl_interp_bsearch+0x11>
repz retq 
nopl   (%rax)
mov    %rcx,%rax
jmp    8 <gsl_interp_bsearch+0x8>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_bsearch(const double x_array[], double x,
                   size_t index_lo, size_t index_hi)
{
  size_t ilo = index_lo;
  size_t ihi = index_hi;
  while(ihi > ilo + 1) {
    size_t i = (ihi + ilo)/2;
    if(x_array[i] > x)
      ihi = i;
    else
      ilo = i;
  }
  return ilo;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 7
7 7
8 8
9 8
10 8
11 7
12 6
13 6
14 14
15 14
16 7
17 7
18 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
sub    $0x10,%rsp
callq  4f <mygetch+0xf>
test   %eax,%eax
mov    $0x101,%ebx
je     70 <mygetch+0x30>
mov    0x8(%rsp),%rsi
mov    $0x2,%edi
callq  67 <mygetch+0x27>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
nop
mov    $0x0,%esi
mov    $0x2,%edi
callq  7f <mygetch+0x3f>
mov    0x0(%rip),%rdi        # 86 <mygetch+0x46>
mov    %rax,0x8(%rsp)
callq  90 <mygetch+0x50>
callq  95 <mygetch+0x55>
mov    0x0(%rip),%ebx        # 9b <mygetch+0x5b>
test   %ebx,%ebx
jne    c8 <mygetch+0x88>
nop
mov    0x0(%rip),%rdi        # a7 <mygetch+0x67>
callq  ac <mygetch+0x6c>
cmp    $0xffffffff,%eax
mov    %eax,%ebx
jne    58 <mygetch+0x18>
callq  b8 <mygetch+0x78>
cmpl   $0x4,(%rax)
je     a0 <mygetch+0x60>
nopl   (%rax)
jmp    58 <mygetch+0x18>
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # d2 <mygetch+0x92>
jmp    58 <mygetch+0x18>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mygetch(void)
{
    sighandler_t savesig;
    int c;
    if (_setjmp (env) == 0) {
 savesig = signal(2, catchint);
 wrefresh(stdscr);
 mousereinit();
 if(prevchar) {
     c = prevchar;
     prevchar = 0;
 } else {
     c = -1;
     while (c == -1) {
  c = wgetch(stdscr);
  if ((c == -1) && ((*__errno_location ()) != 4))
      break;
     }
 }
    } else {
 c = 0401;
    }
    signal(2, savesig);
    return(c);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 5
6 21
7 5
8 23
9 23
10 23
11 25
12 25
13 25
14 25
15 25
16 6
17 6
18 6
19 7
20 6
21 7
22 8
23 9
24 9
25 9
26 9
27 15
28 15
29 16
30 15
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 11
39 11
40 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  259 <filter_open+0x9>
mov    (%rax),%rdi
add    $0x8,%rsp
jmpq   265 <filter_open+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filter_open (mu_stream_t stream)
{
  mu_filter_t filter = mu_stream_get_owner (stream);
  return mu_stream_open (filter->stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <file_fmt+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
file_fmt(const char *str, void *data)
{
 fputs(str, (FILE*)data);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x28(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x28,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
movslq %esi,%rsi
mov    0xa8(%rdi,%rsi,8),%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_mset_count (rec_mset_t mset,
                rec_mset_type_t type)
{
  return mset->count[type];
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 46 <__db_join_del+0x6>
mov    $0x16,%eax
test   %edx,%edx
jne    58 <__db_join_del+0x18>
repz retq 
nopl   0x0(%rax)
mov    (%rdi),%rdx
mov    0x28(%rdx),%rdx
mov    0xe0(%rdx),%rdx
test   %rdx,%rdx
je     4f <__db_join_del+0xf>
mov    0x20(%rdx),%rax
cmpl   $0x1,0x74(%rax)
sbb    %eax,%eax
and    $0x7923,%eax
sub    $0x790d,%eax
retq   
<<<sep_in_sample>>>
__db_join_del(dbc, flags)
 DBC *dbc;
 u_int32_t flags;
{
 if(flags){}
 if (CDB___db_global_values.db_panic && (dbc->dbp->dbenv)->reginfo != ((void *)0) && ((REGENV *) ((REGINFO *)(dbc->dbp->dbenv)->reginfo)->primary)->panic != 0) return ((-30989));;
 (flags) = (0);
 return (22);
}
<<<sep_in_sample>>>
1 6
2 8
3 6
4 6
5 9
6 9
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 9
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
control_set_driver_null (void *vstate, const gsl_odeiv2_driver * d)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x98,%rsp
callq  bd1 <_file_size+0x11>
mov    (%rax),%rdi
mov    %rax,%rbx
test   %rdi,%rdi
je     c18 <_file_size+0x58>
callq  be1 <_file_size+0x21>
mov    (%rbx),%rdi
callq  be9 <_file_size+0x29>
mov    %rsp,%rsi
mov    %eax,%edi
callq  bf3 <_file_size+0x33>
cmp    $0xffffffff,%eax
je     c38 <_file_size+0x78>
test   %rbp,%rbp
je     c06 <_file_size+0x46>
mov    0x30(%rsp),%rax
mov    %rax,0x0(%rbp)
add    $0x98,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
test   %rbp,%rbp
je     c06 <_file_size+0x46>
movq   $0x0,0x0(%rbp)
add    $0x98,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
callq  c3d <_file_size+0x7d>
mov    (%rax),%eax
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_file_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  struct stat stbuf;
  if (!fs->file)
    {
      if (psize)
 *psize = 0;
      return 0;
    }
  fflush (fs->file);
  if (fstat(fileno(fs->file), &stbuf) == -1)
    return (*__errno_location ());
  if (psize)
    *psize = stbuf.st_size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 3
8 5
9 5
10 11
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 14
19 14
20 15
21 15
22 17
23 16
24 17
25 17
26 17
27 17
28 7
29 7
30 8
31 17
32 9
33 17
34 17
35 17
36 17
37 13
38 13
39 17
40 17
41 17
42 17
43 17
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 326 <__db_pthread_mutex_unlock+0x6>
test   %eax,%eax
je     368 <__db_pthread_mutex_unlock+0x48>
push   %rbx
movzbl 0x68(%rdi),%eax
mov    %rdi,%rbx
test   $0x1,%al
jne    360 <__db_pthread_mutex_unlock+0x40>
test   $0x2,%al
je     370 <__db_pthread_mutex_unlock+0x50>
callq  33f <__db_pthread_mutex_unlock+0x1f>
test   %eax,%eax
jne    356 <__db_pthread_mutex_unlock+0x36>
movl   $0x0,0x5c(%rbx)
mov    %rbx,%rdi
callq  352 <__db_pthread_mutex_unlock+0x32>
test   %eax,%eax
je     380 <__db_pthread_mutex_unlock+0x60>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x0,0x5c(%rdi)
pop    %rbx
jmpq   37d <__db_pthread_mutex_unlock+0x5d>
nopl   (%rax)
lea    0x28(%rbx),%rdi
pop    %rbx
jmpq   38a <__db_pthread_mutex_unlock+0x6a>
<<<sep_in_sample>>>
__db_pthread_mutex_unlock(mutexp)
 MUTEX *mutexp;
{
 int ret;
 if (!CDB___db_global_values.db_mutexlocks || ((mutexp)->flags & (0x001)))
  return (0);
 if (((mutexp)->flags & (0x002))) {
  if ((ret = pthread_mutex_lock(&mutexp->mutex)) != 0)
   return (ret);
  mutexp->locked = 0;
  if ((ret = pthread_mutex_unlock(&mutexp->mutex)) != 0)
   return (ret);
  if ((ret = pthread_cond_signal(&mutexp->cond)) != 0)
   return (ret);
 } else {
  mutexp->locked = 0;
  if ((ret = pthread_mutex_unlock(&mutexp->mutex)) != 0)
   return (ret);
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 3
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 10
15 11
16 11
17 11
18 11
19 21
20 21
21 21
22 6
23 21
24 21
25 21
26 6
27 21
28 21
29 16
30 21
31 17
32 17
33 13
34 21
35 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  89 <is_alpha_mbchar+0x9>
movzbl (%rbx),%edx
mov    (%rax),%rax
pop    %rbx
movzwl (%rax,%rdx,2),%eax
shr    $0xa,%ax
and    $0x1,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
is_alpha_mbchar(const char *c)
{
    ((void) (0));
 return ((*__ctype_b_loc ())[(int) (((unsigned char)*c))] & (unsigned short int) _ISalpha);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     5e3 <mu_debug_get_function+0x13>
mov    0x28(%rdi),%rax
mov    %rax,(%rsi)
xor    %eax,%eax
repz retq 
<<<sep_in_sample>>>
mu_debug_get_function (mu_debug_t debug, const char **pfunction)
{
  if (!debug)
    return 22;
  *pfunction = debug->function;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 6
7 7
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk1imp_order (void *vstate)
{
  rk1imp_state_t *state = (rk1imp_state_t *) vstate;
  state = 0;
  return 1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x10(%rdi),%rdi
callq  60d <message_free+0xd>
lea    0x18(%rbx),%rdi
callq  616 <message_free+0x16>
lea    0x20(%rbx),%rdi
callq  61f <message_free+0x1f>
mov    0x28(%rbx),%rdi
callq  628 <message_free+0x28>
mov    0x30(%rbx),%rdi
callq  631 <message_free+0x31>
mov    %rbx,%rdi
pop    %rbx
jmpq   63a <message_free+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_free (MESSAGE msg)
{
  destroy_assoc_list (&msg->commands);
  destroy_assoc_list (&msg->header);
  destroy_string_list (&msg->mime_hdr);
  free (msg->body);
  free (msg->boundary);
  free (msg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 9
15 8
16 8
<<<sep_out_sample>>>
mov    %rsi,0x28(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_nonce_count (osip_authentication_info_t * authentication_info, char *nonce_count)
{
  authentication_info->nonce_count = (char *) nonce_count;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
lea    0x2(%rdi),%rdx
lea    0x3(%rdi),%rax
imul   %rdx,%rax
lea    0x1(%rdi),%rdx
imul   %rdi,%rdx
shr    %rax
shr    %rdx
imul   %rdx,%rax
retq   
nop
<<<sep_in_sample>>>
mul4 (mp_limb_t m)
{
  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;
  mp_limb_t m23 = (m + 2) * (m + 3) >> 1;
  return m01 * m23;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 3
6 4
7 3
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
mov    %r9,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
mov    (%r9),%edx
mov    0x260(%rdi),%rax
lea    (%r8,%rdx,8),%rcx
mov    (%rbx),%edx
callq  *0x18(%rax)
addl   $0x1,0x0(%rbp)
addl   $0x1,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
merged_1v_upsample (j_decompress_ptr cinfo,
      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
      JDIMENSION in_row_groups_avail,
      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
      JDIMENSION out_rows_avail)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
    output_buf + *out_row_ctr);
  (*out_row_ctr)++;
  (*in_row_group_ctr)++;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 10
12 11
13 12
14 12
15 12
16 12
17 12
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
test   %rax,%rax
je     150 <jpeg_stdio_dest+0x40>
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,0x20(%rax)
mov    %rbp,0x28(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rax
mov    $0x38,%edx
xor    %esi,%esi
callq  *(%rax)
mov    %rax,0x28(%rbx)
jmp    125 <jpeg_stdio_dest+0x15>
<<<sep_in_sample>>>
jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
{
  my_dest_ptr dest;
  if (cinfo->dest == ((void *)0)) {
    cinfo->dest = (struct jpeg_destination_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 0,
      ((size_t) sizeof(my_destination_mgr)));
  }
  dest = (my_dest_ptr) cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->outfile = outfile;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 10
10 11
11 12
12 13
13 14
14 14
15 14
16 14
17 14
18 6
19 6
20 6
21 6
22 5
23 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 79f6 <copy_fifo_list+0x6>
test   %eax,%eax
je     7a04 <copy_fifo_list+0x14>
mov    0x0(%rip),%eax        # 7a00 <copy_fifo_list+0x10>
test   %eax,%eax
jne    7a18 <copy_fifo_list+0x28>
test   %rdi,%rdi
je     7a0f <copy_fifo_list+0x1f>
movl   $0x0,(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
test   %rdi,%rdi
je     7a23 <copy_fifo_list+0x33>
mov    %eax,(%rdi)
movslq %eax,%rdi
mov    $0x1582,%edx
mov    $0x0,%esi
callq  7a35 <copy_fifo_list+0x45>
movslq 0x0(%rip),%rdx        # 7a3c <copy_fifo_list+0x4c>
mov    0x0(%rip),%rsi        # 7a43 <copy_fifo_list+0x53>
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   7a4f <copy_fifo_list+0x5f>
nop
<<<sep_in_sample>>>
copy_fifo_list (sizep)
     int *sizep;
{
  char *ret;
  if (nfds == 0 || totfds == 0)
    {
      if (sizep)
 *sizep = 0;
      return (char *)((void *)0);
    }
  if (sizep)
    *sizep = totfds;
  ret = (char *)sh_xmalloc((totfds), "subst.c", 5506);
  return (memcpy (ret, dev_fd_list, totfds));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 8
10 15
11 15
12 15
13 3
14 11
15 11
16 12
17 13
18 13
19 13
20 13
21 14
22 14
23 14
24 15
25 14
26 14
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
push   %rbx
sub    $0x8,%rsp
mov    0x38(%rdi),%rbp
mov    0x0(%rbp),%rdi
callq  745 <__bt_dnpage+0x15>
test   %rax,%rax
mov    %rax,%rbx
je     770 <__bt_dnpage+0x40>
mov    %rax,%rdi
callq  755 <__bt_dnpage+0x25>
mov    0x0(%rbp),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
pop    %rbp
xor    %edx,%edx
jmpq   769 <__bt_dnpage+0x39>
nopl   0x0(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__bt_dnpage(dbp, pgno)
 DB *dbp;
 u_int32_t pgno;
{
 BTREE *t;
 PAGE *h;
 t = dbp->internal;
 if ((h = mpool_get(t->bt_mp, pgno, 0)) != ((void *)0)) {
  __bt_dpage(h);
  (void)mpool_put(t->bt_mp, h, 0);
 }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 7
6 8
7 8
8 8
9 8
10 8
11 9
12 9
13 10
14 12
15 10
16 12
17 12
18 10
19 10
20 10
21 12
22 12
23 12
24 12
25 12
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 777 <progcomp_walk+0x7>
test   %rax,%rax
je     788 <progcomp_walk+0x18>
test   %rdi,%rdi
je     788 <progcomp_walk+0x18>
mov    0xc(%rax),%edx
test   %edx,%edx
jne    790 <progcomp_walk+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rsi
mov    %rax,%rdi
jmpq   79b <progcomp_walk+0x2b>
<<<sep_in_sample>>>
progcomp_walk (pfunc)
     hash_wfunc *pfunc;
{
  if (prog_completes == 0 || pfunc == 0 || ((prog_completes) ? (prog_completes)->nentries : 0) == 0)
    return;
  hash_walk (prog_completes, pfunc);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1067 <prompt_failed_backupwrite+0x7>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
je     1079 <prompt_failed_backupwrite+0x19>
callq  1075 <prompt_failed_backupwrite+0x15>
test   %eax,%eax
je     10a9 <prompt_failed_backupwrite+0x49>
mov    $0x0,%edi
callq  1083 <prompt_failed_backupwrite+0x23>
xor    %edi,%edi
mov    %rax,%rsi
callq  108d <prompt_failed_backupwrite+0x2d>
mov    0x0(%rip),%rdi        # 1094 <prompt_failed_backupwrite+0x34>
mov    %rbx,%rsi
mov    %eax,0x0(%rip)        # 109d <prompt_failed_backupwrite+0x3d>
callq  10a2 <prompt_failed_backupwrite+0x42>
mov    %rax,0x0(%rip)        # 10a9 <prompt_failed_backupwrite+0x49>
mov    0x0(%rip),%eax        # 10af <prompt_failed_backupwrite+0x4f>
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
prompt_failed_backupwrite(const char *filename)
{
    static int response;
    static char *prevfile = ((void *)0);
    if (prevfile == ((void *)0) || strcmp(filename, prevfile)) {
 response = do_yesno_prompt(0, gettext("Failed to write backup file; " "continue saving? (Say N if unsure.) ")
                                          );
 prevfile = mallocstrcpy(prevfile, filename);
    }
    return response;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 6
17 8
18 8
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
je     299 <set_current_flags+0x29>
nopw   0x0(%rax,%rax,1)
movsbl (%rdi),%esi
mov    (%rax),%rcx
mov    %rax,%rdx
add    $0x1,%rdi
add    $0x10,%rax
mov    %esi,(%rcx)
cmpb   $0x0,0x8(%rdx)
jne    280 <set_current_flags+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_current_flags (bitmap)
     const char *bitmap;
{
  int i;
  if (bitmap == 0)
    return;
  for (i = 0; shell_flags[i].name; i++)
    *(shell_flags[i].value) = bitmap[i];
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
movq   $0x1,0x0(%rip)        # 4a4b <dfasyntax+0xb>
mov    %rdi,0x0(%rip)        # 4a52 <dfasyntax+0x12>
mov    %esi,0x0(%rip)        # 4a58 <dfasyntax+0x18>
mov    %dl,0x0(%rip)        # 4a5e <dfasyntax+0x1e>
retq   
nop
<<<sep_in_sample>>>
dfasyntax (reg_syntax_t bits, int fold, unsigned char eol)
{
  syntax_bits_set = 1;
  syntax_bits = bits;
  case_fold = fold;
  eolbyte = eol;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 6
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     99c <mu_folder_get_url+0x1c>
test   %rsi,%rsi
mov    $0x1005,%ax
je     99c <mu_folder_get_url+0x1c>
mov    0x28(%rdi),%rax
mov    %rax,(%rsi)
xor    %eax,%eax
repz retq 
<<<sep_in_sample>>>
mu_folder_get_url (mu_folder_t folder, mu_url_t *purl)
{
  if (folder == ((void *)0))
    return 22;
  if (purl == ((void *)0))
    return (0x1000 +5);
  *purl = folder->url;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 7
8 7
9 8
10 9
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    2858 <gsl_vector_long_set_basis+0x48>
shl    $0x3,%rdi
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     2843 <gsl_vector_long_set_basis+0x33>
xchg   %ax,%ax
add    $0x1,%rax
movq   $0x0,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    2830 <gsl_vector_long_set_basis+0x20>
imul   %rsi,%rdi
xor    %eax,%eax
movq   $0x1,(%r8,%rdi,1)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2875 <gsl_vector_long_set_basis+0x65>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_long_set_basis (gsl_vector_long * v, size_t i)
{
  long * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const long zero = 0L ;
  const long one = 1L;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(long *) (data + 1 * k * stride) = zero;
    }
  *(long *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 13
16 13
17 17
18 18
19 17
20 18
21 18
22 2
23 11
24 11
25 11
26 11
27 11
28 11
29 19
30 19
31 19
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     4e <directory_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    30 <directory_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
directory_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((const struct directory *) key)->name)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x10,%rsp
cmpq   $0x0,0x0(%rip)        # 903 <get_groupset+0x13>
je     918 <get_groupset+0x28>
add    $0x10,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
lea    0xc(%rsp),%rdi
callq  922 <get_groupset+0x32>
mov    0xc(%rsp),%edx
mov    %rax,0x0(%rip)        # 92d <get_groupset+0x3d>
mov    0x8(%rbp),%r12
test   %edx,%edx
jle    905 <get_groupset+0x15>
xor    %ebx,%ebx
jmp    947 <get_groupset+0x57>
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 947 <get_groupset+0x57>
mov    (%rax,%rbx,8),%rdx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  956 <get_groupset+0x66>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %eax,0xc(%rsp)
jg     940 <get_groupset+0x50>
jmp    905 <get_groupset+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_groupset (self)
     SHELL_VAR *self;
{
  register int i;
  int ng;
  ARRAY *a;
  static char **group_set = (char **)((void *)0);
  if (group_set == 0)
    {
      group_set = get_group_list (&ng);
      a = (ARRAY *)((self)->value);
      for (i = 0; i < ng; i++)
 array_insert (a, i, group_set[i]);
    }
  return (self);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 8
7 8
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 10
16 10
17 12
18 10
19 11
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 13
30 13
31 13
32 12
33 12
34 12
35 12
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 7a7 <usage+0x7>
mov    0x0(%rip),%rsi        # 7ae <usage+0xe>
mov    $0x4,%edx
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  7c0 <usage+0x20>
callq  7c5 <usage+0x25>
mov    %ebx,%edi
callq  7cc <usage+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
usage (int status)
{
  argp_help (&argp, stderr, 0x04, (char*) program_name);
  close_stdout ();
  exit (status);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_fdiv (const double x, const double y)
{
  return x / y;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
xorpd  %xmm4,%xmm4
sub    $0x28,%rsp
movapd %xmm0,%xmm3
ucomisd %xmm0,%xmm4
ja     956 <gsl_ran_gamma_pdf+0xc6>
ucomisd %xmm4,%xmm0
jnp    940 <gsl_ran_gamma_pdf+0xb0>
ucomisd 0x0(%rip),%xmm1        # 8b8 <gsl_ran_gamma_pdf+0x28>
jnp    960 <gsl_ran_gamma_pdf+0xd0>
movapd %xmm1,%xmm0
movsd  %xmm1,0x18(%rsp)
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  8d9 <gsl_ran_gamma_pdf+0x49>
movsd  0x10(%rsp),%xmm2
movsd  0x8(%rsp),%xmm3
movsd  %xmm0,(%rsp)
divsd  %xmm2,%xmm3
movapd %xmm3,%xmm0
movsd  %xmm3,0x8(%rsp)
callq  8fd <gsl_ran_gamma_pdf+0x6d>
movsd  0x18(%rsp),%xmm1
movsd  0x8(%rsp),%xmm3
subsd  0x0(%rip),%xmm1        # 911 <gsl_ran_gamma_pdf+0x81>
mulsd  %xmm0,%xmm1
subsd  %xmm3,%xmm1
subsd  (%rsp),%xmm1
movapd %xmm1,%xmm0
callq  927 <gsl_ran_gamma_pdf+0x97>
movsd  0x10(%rsp),%xmm2
divsd  %xmm2,%xmm0
add    $0x28,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
jne    8b0 <gsl_ran_gamma_pdf+0x20>
movsd  0x0(%rip),%xmm0        # 94e <gsl_ran_gamma_pdf+0xbe>
ucomisd %xmm0,%xmm1
jp     956 <gsl_ran_gamma_pdf+0xc6>
je     92d <gsl_ran_gamma_pdf+0x9d>
movapd %xmm4,%xmm0
add    $0x28,%rsp
retq   
nop
jne    8be <gsl_ran_gamma_pdf+0x2e>
movsd  0x0(%rip),%xmm0        # 96e <gsl_ran_gamma_pdf+0xde>
movsd  %xmm2,(%rsp)
xorpd  %xmm3,%xmm0
divsd  %xmm2,%xmm0
callq  980 <gsl_ran_gamma_pdf+0xf0>
movsd  (%rsp),%xmm2
add    $0x28,%rsp
divsd  %xmm2,%xmm0
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_ran_gamma_pdf (const double x, const double a, const double b)
{
  if (x < 0)
    {
      return 0 ;
    }
  else if (x == 0)
    {
      if (a == 1)
        return 1/b ;
      else
        return 0 ;
    }
  else if (a == 1)
    {
      return exp(-x/b)/b ;
    }
  else
    {
      double p;
      double lngamma = gsl_sf_lngamma (a);
      p = exp ((a - 1) * log (x/b) - x/b - lngamma)/b;
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 7
7 7
8 14
9 14
10 21
11 21
12 21
13 21
14 21
15 22
16 22
17 21
18 22
19 22
20 22
21 22
22 22
23 22
24 22
25 22
26 22
27 22
28 22
29 22
30 22
31 22
32 25
33 25
34 25
35 7
36 9
37 9
38 9
39 9
40 5
41 25
42 25
43 25
44 14
45 16
46 16
47 16
48 16
49 16
50 16
51 25
52 16
53 25
54 25
<<<sep_out_sample>>>
mov    %rsi,0x40(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_realm (osip_authentication_info_t *
       authentication_info, char *realm)
{
  authentication_info->realm = (char *) realm;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   473 <gsl_vector_uint_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_fscanf (FILE * stream, gsl_vector_uint * v)
{
  int status = gsl_block_uint_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x40(%rdi)
mov    %rdi,%rbx
je     17e8 <undo_cut+0x48>
cmpl   $0x4,0x30(%rdi)
je     17f0 <undo_cut+0x50>
mov    0x58(%rdi),%rsi
mov    0x50(%rdi),%rdi
callq  17be <undo_cut+0x1e>
mov    0x40(%rbx),%rdi
callq  17c7 <undo_cut+0x27>
cmpl   $0x10,0x30(%rbx)
je     17e8 <undo_cut+0x48>
cmpl   $0xc,0x8(%rbx)
je     17e8 <undo_cut+0x48>
mov    0x58(%rbx),%rsi
mov    0x50(%rbx),%rdi
pop    %rbx
jmpq   17e1 <undo_cut+0x41>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x50(%rdi),%rdi
xor    %esi,%esi
callq  17fb <undo_cut+0x5b>
jmp    17be <undo_cut+0x1e>
nopl   (%rax)
<<<sep_in_sample>>>
undo_cut(undo *u)
{
    if (!u->cutbuffer)
 return;
    if (u->xflags == (1<<2))
 goto_line_posx(u->mark_begin_lineno, 0);
    else
 goto_line_posx(u->mark_begin_lineno, u->mark_begin_x);
    copy_from_filestruct(u->cutbuffer);
    if (u->xflags != (1<<4) && u->type != PASTE)
 goto_line_posx(u->mark_begin_lineno, u->mark_begin_x);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 5
6 5
7 8
8 8
9 8
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 12
19 11
20 11
21 12
22 12
23 12
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
mov    $0x0,%esi
sub    $0x8,%rsp
callq  e <jumpback+0xe>
mov    $0x1,%esi
mov    $0x0,%edi
callq  1d <jumpback+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
jumpback(int sig)
{
 signal(sig, jumpback);
 siglongjmp(env, 1);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    (%rdi),%r8d
je     11aa <gsl_stats_uint_min_index+0x3a>
shl    $0x2,%rsi
xor    %eax,%eax
xor    %ecx,%ecx
jmp    118b <gsl_stats_uint_min_index+0x1b>
nopw   0x0(%rax,%rax,1)
mov    %r10d,%r8d
mov    (%rdi),%r9d
mov    %r8d,%r10d
cmp    %r8d,%r9d
cmovbe %r9d,%r10d
cmovb  %rcx,%rax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    1188 <gsl_stats_uint_min_index+0x18>
repz retq 
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_uint_min_index (const unsigned int data[], const size_t stride,
                                const size_t n)
{
  unsigned int min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned int xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
5 5
6 6
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 6
16 6
17 6
18 6
19 16
20 5
21 16
22 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # 7b <option_string_to_eol+0xb>
xor    %r9d,%r9d
mov    $0x4,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rax,(%rsp)
callq  97 <option_string_to_eol+0x27>
cltq   
mov    0x0(,%rax,4),%eax
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
option_string_to_eol (const char *option,
        const char *arg)
{
  (((sizeof (((eol_args))) / sizeof (*((eol_args)))) == (sizeof (((eol_types))) / sizeof (*((eol_types)))) + 1) ? (void) (0) : __assert_fail ("(sizeof (((eol_args))) / sizeof (*((eol_args)))) == (sizeof (((eol_types))) / sizeof (*((eol_types)))) + 1", "buffer.c", 103, __PRETTY_FUNCTION__));
  return (eol_types [__xargmatch_internal ((option), (arg), (eol_args), (const char *) (eol_types), sizeof (*(eol_types)), 0, argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
push   %r14
test   %edi,%edi
mov    %r8d,%r14d
push   %r13
mov    %esi,%r13d
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
js     5f <fdutimensat+0x5f>
mov    %rcx,%rsi
callq  20 <fdutimensat+0x20>
test   %rbp,%rbp
mov    %eax,%ebx
je     2c <fdutimensat+0x2c>
cmp    $0xffffffff,%eax
je     40 <fdutimensat+0x40>
cmp    $0x1,%ebx
je     64 <fdutimensat+0x64>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
callq  45 <fdutimensat+0x45>
cmpl   $0x26,(%rax)
jne    31 <fdutimensat+0x31>
mov    %r14d,%ecx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %r13d,%edi
callq  5b <fdutimensat+0x5b>
mov    %eax,%ebx
jmp    2c <fdutimensat+0x2c>
test   %rdx,%rdx
jne    4a <fdutimensat+0x4a>
callq  69 <fdutimensat+0x69>
mov    $0xffffffff,%ebx
movl   $0x9,(%rax)
jmp    31 <fdutimensat+0x31>
<<<sep_in_sample>>>
fdutimensat (int fd, int dir, char const *file, struct timespec const ts[2],
             int atflag)
{
  int result = 1;
  if (0 <= fd)
    result = rpl_futimens (fd, ts);
  if (file && (fd < 0 || (result == -1 && (*__errno_location ()) == 38)))
    result = rpl_utimensat (dir, file, ts, atflag);
  if (result == 1)
    {
      (*__errno_location ()) = 9;
      result = -1;
    }
  return result;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 6
13 6
14 7
15 6
16 7
17 7
18 7
19 9
20 9
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 15
29 7
30 7
31 7
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 7
40 7
41 11
42 12
43 11
44 11
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    22f8 <gsl_matrix_long_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,8),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  231a <gsl_matrix_long_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_superdiagonal (gsl_matrix_long * m,
                                      const size_t k)
{
  _gsl_vector_long_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
cmpq   $0x2,0x8(%rsp)
mov    $0xffffffff,%eax
jne    79 <haar_centered_init+0x39>
movq   $0x0,(%rdi)
xor    %eax,%eax
movq   $0x0,(%rsi)
movq   $0x0,(%rdx)
movq   $0x0,(%rcx)
movq   $0x2,(%r8)
movq   $0x1,(%r9)
repz retq 
<<<sep_in_sample>>>
haar_centered_init (const double **h1, const double **g1, const double **h2,
                    const double **g2, size_t * nc, size_t * offset,
                    const size_t member)
{
  if (member != 2)
    {
      return GSL_FAILURE;
    }
  *h1 = ch_2;
  *g1 = cg_2;
  *h2 = ch_2;
  *g2 = cg_2;
  *nc = 2;
  *offset = 1;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 9
5 15
6 10
7 11
8 12
9 13
10 14
11 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1947 <get_group_array+0x7>
push   %rbx
mov    %rdi,%rbx
test   %rax,%rax
je     1960 <get_group_array+0x20>
test   %rdi,%rdi
je     195d <get_group_array+0x1d>
mov    0x0(%rip),%edx        # 195b <get_group_array+0x1b>
mov    %edx,(%rdi)
pop    %rbx
retq   
nop
movslq 0x0(%rip),%rdi        # 1967 <get_group_array+0x27>
test   %edi,%edi
je     1a70 <get_group_array+0x130>
test   %edi,%edi
jle    1a40 <get_group_array+0x100>
shl    $0x2,%rdi
mov    $0x501,%edx
mov    $0x0,%esi
callq  198a <get_group_array+0x4a>
mov    0x0(%rip),%ecx        # 1990 <get_group_array+0x50>
mov    %rax,0x0(%rip)        # 1997 <get_group_array+0x57>
test   %ecx,%ecx
jle    1a29 <get_group_array+0xe9>
mov    0x0(%rip),%rsi        # 19a6 <get_group_array+0x66>
lea    0x10(%rax),%rdx
cmp    %rdx,%rsi
lea    0x10(%rsi),%rdx
setae  %dil
cmp    %rdx,%rax
setae  %dl
or     %dl,%dil
je     1a50 <get_group_array+0x110>
cmp    $0x7,%ecx
jbe    1a50 <get_group_array+0x110>
mov    %ecx,%r8d
xor    %edx,%edx
xor    %edi,%edi
shr    $0x2,%r8d
lea    0x0(,%r8,4),%r9d
movdqu (%rsi,%rdx,1),%xmm0
add    $0x1,%edi
movdqu %xmm0,(%rax,%rdx,1)
add    $0x10,%rdx
cmp    %r8d,%edi
jb     19e0 <get_group_array+0xa0>
cmp    %r9d,%ecx
je     1a29 <get_group_array+0xe9>
movslq %r9d,%rdx
mov    (%rsi,%rdx,4),%edi
mov    %edi,(%rax,%rdx,4)
lea    0x1(%r9),%edx
cmp    %edx,%ecx
jle    1a29 <get_group_array+0xe9>
movslq %edx,%rdx
add    $0x2,%r9d
mov    (%rsi,%rdx,4),%edi
cmp    %r9d,%ecx
mov    %edi,(%rax,%rdx,4)
jle    1a29 <get_group_array+0xe9>
movslq %r9d,%r9
mov    (%rsi,%r9,4),%edx
mov    %edx,(%rax,%r9,4)
test   %rbx,%rbx
je     195d <get_group_array+0x1d>
mov    %ecx,(%rbx)
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
test   %rbx,%rbx
je     1a88 <get_group_array+0x148>
movl   $0x0,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nop
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
mov    (%rsi,%rdx,4),%edi
mov    %edi,(%rax,%rdx,4)
add    $0x1,%rdx
cmp    %edx,%ecx
jg     1a58 <get_group_array+0x118>
jmp    1a29 <get_group_array+0xe9>
nopl   0x0(%rax,%rax,1)
callq  a0 <initialize_group_array>
movslq 0x0(%rip),%rdi        # 1a7c <get_group_array+0x13c>
jmpq   196f <get_group_array+0x2f>
nopl   0x0(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_group_array (ngp)
     int *ngp;
{
  int i;
  static int *group_iarray = (int *)((void *)0);
  if (group_iarray)
    {
      if (ngp)
 *ngp = ngroups;
      return (group_iarray);
    }
  if (ngroups == 0)
    initialize_group_array ();
  if (ngroups <= 0)
    {
      if (ngp)
 *ngp = 0;
      return (int *)((void *)0);
    }
  group_iarray = (int *)sh_xmalloc((ngroups * sizeof (int)), "general.c", 1281);
  for (i = 0; i < ngroups; i++)
    group_iarray[i] = (int)group_array[i];
  if (ngp)
    *ngp = ngroups;
  return group_iarray;
}
<<<sep_in_sample>>>
1 6
2 3
3 3
4 6
5 6
6 8
7 8
8 9
9 9
10 26
11 26
12 26
13 12
14 12
15 12
16 14
17 14
18 20
19 20
20 20
21 20
22 21
23 20
24 21
25 21
26 21
27 21
28 21
29 21
30 21
31 21
32 21
33 21
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 22
43 22
44 22
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 22
53 21
54 21
55 21
56 22
57 21
58 22
59 21
60 22
61 21
62 22
63 22
64 22
65 23
66 23
67 24
68 26
69 26
70 26
71 16
72 16
73 17
74 18
75 26
76 26
77 26
78 21
79 21
80 22
81 22
82 22
83 21
84 21
85 21
86 21
87 13
88 13
89 13
90 13
91 18
92 26
93 26
94 26
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rsi
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x90,%rsp
callq  a8 <acm_find_file+0x18>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  b3 <acm_find_file+0x23>
test   %eax,%eax
jne    c8 <acm_find_file+0x38>
add    $0x90,%rsp
mov    $0x0,%eax
pop    %rbx
retq   
nopl   (%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  d7 <acm_find_file+0x47>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  e2 <acm_find_file+0x52>
mov    %rsp,%rsi
mov    $0x0,%edi
callq  ef <acm_find_file+0x5f>
test   %eax,%eax
je     b7 <acm_find_file+0x27>
mov    0x0(%rip),%rdi        # fa <acm_find_file+0x6a>
mov    $0x0,%ecx
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  10e <acm_find_file+0x7e>
mov    $0x1,%edi
callq  118 <acm_find_file+0x88>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
acm_find_file(char *name)
{
 static char pname[1024];
 struct stat statbuf;
 strcpy(pname, name);
 if (stat(name, &statbuf) != 0) {
  strcpy(pname, _acm_fopen_library_dir);
  strcat(pname, name);
  if (stat(pname, &statbuf) != 0) {
            fprintf(stderr, errmsg, name, _acm_fopen_library_dir);
            exit(1);
        }
 }
 return pname;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 5
7 6
8 6
9 6
10 6
11 6
12 15
13 15
14 15
15 15
16 15
17 7
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 11
35 11
36 11
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
jne    339 <CDB___db_txnlist_close+0x19>
jmp    350 <CDB___db_txnlist_close+0x30>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rax),%rax
test   %rax,%rax
je     350 <CDB___db_txnlist_close+0x30>
mov    (%rax),%ecx
test   %ecx,%ecx
jne    330 <CDB___db_txnlist_close+0x10>
cmp    %esi,0x1c(%rax)
jne    330 <CDB___db_txnlist_close+0x10>
testb  $0x2,0x18(%rax)
jne    330 <CDB___db_txnlist_close+0x10>
add    %edx,0x20(%rax)
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_txnlist_close(listp, lid, count)
 void *listp;
 int32_t lid;
 u_int32_t count;
{
 DB_TXNHEAD *hp;
 DB_TXNLIST *p;
 hp = (DB_TXNHEAD *)listp;
 for (p = ((&hp->head)->lh_first); p != ((void *)0); p = ((p)->links.le_next)) {
  if (p->type == TXNLIST_DELETE)
   if (lid == p->u.d.fileid &&
       !((&p->u.d)->flags & (0x2))) {
    p->u.d.count += count;
    return (0);
   }
 }
 return (0);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 10
10 10
11 10
12 11
13 11
14 11
15 11
16 13
17 13
18 18
19 18
20 18
<<<sep_out_sample>>>
cvtsi2sd %edx,%xmm0
lea    0x1(%rdx),%eax
mov    %ecx,0x104(%rsi)
add    $0x1,%ecx
mov    %edx,0x100(%rsi)
mov    %eax,%edi
shr    $0x1f,%edi
add    %edi,%eax
sar    %eax
mov    %eax,0x108(%rsi)
mov    %ecx,%eax
shr    $0x1f,%eax
add    %eax,%ecx
sar    %ecx
mov    %ecx,0x10c(%rsi)
divsd  0x0(%rip),%xmm0        # 5ac <resizeChaserWindow+0x3c>
movsd  %xmm0,0x290(%rsi)
retq   
<<<sep_in_sample>>>
resizeChaserWindow(craft * c, viewer * u, int width, int height, int initial_flag)
{
 u->width = width;
 u->height = height;
 u->xCenter = (u->width + 1) / 2;
 u->yCenter = (u->height + 1) / 2;
 u->scaleFactor = (double) width / (double) 1200;;
}
<<<sep_in_sample>>>
1 7
2 5
3 4
4 6
5 3
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # c <gsl_cdf_negative_binomial_P+0xc>
ucomisd %xmm2,%xmm0
ja     40 <gsl_cdf_negative_binomial_P+0x40>
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
ja     40 <gsl_cdf_negative_binomial_P+0x40>
ucomisd %xmm1,%xmm3
ja     70 <gsl_cdf_negative_binomial_P+0x70>
mov    %edi,%edi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm3
addsd  %xmm3,%xmm2
jmpq   36 <gsl_cdf_negative_binomial_P+0x36>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x2a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  59 <gsl_cdf_negative_binomial_P+0x59>
movsd  0x0(%rip),%xmm0        # 61 <gsl_cdf_negative_binomial_P+0x61>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x2f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  89 <gsl_cdf_negative_binomial_P+0x89>
movsd  0x0(%rip),%xmm0        # 91 <gsl_cdf_negative_binomial_P+0x91>
jmp    61 <gsl_cdf_negative_binomial_P+0x61>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_negative_binomial_P (const unsigned int k, const double p, const double n)
{
  double P;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "nbinomial.c", 42, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (n < 0)
    {
      do { gsl_error ("n < 0", "nbinomial.c", 47, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) n;
  b = (double) k + 1.0;
  P = gsl_cdf_beta_P (p, a, b);
  return P;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 10
9 10
10 15
11 18
12 15
13 16
14 16
15 16
16 8
17 8
18 8
19 8
20 8
21 8
22 18
23 18
24 18
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_message_qop (osip_authorization_t * authorization, char *message_qop)
{
  authorization->message_qop = (char *) message_qop;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 457 <nettle_sha384_init+0x7>
movq   $0x0,0x48(%rdi)
movq   $0x0,0x40(%rdi)
movl   $0x0,0xd0(%rdi)
mov    %rax,(%rdi)
mov    0x0(%rip),%rax        # 47b <nettle_sha384_init+0x2b>
mov    %rax,0x8(%rdi)
mov    0x0(%rip),%rax        # 486 <nettle_sha384_init+0x36>
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 491 <nettle_sha384_init+0x41>
mov    %rax,0x18(%rdi)
mov    0x0(%rip),%rax        # 49c <nettle_sha384_init+0x4c>
mov    %rax,0x20(%rdi)
mov    0x0(%rip),%rax        # 4a7 <nettle_sha384_init+0x57>
mov    %rax,0x28(%rdi)
mov    0x0(%rip),%rax        # 4b2 <nettle_sha384_init+0x62>
mov    %rax,0x30(%rdi)
mov    0x0(%rip),%rax        # 4bd <nettle_sha384_init+0x6d>
mov    %rax,0x38(%rdi)
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_sha384_init(struct sha512_ctx *ctx)
{
  static const uint64_t H0[8] =
  {
    0xCBBB9D5DC1059ED8ULL, 0x629A292A367CD507ULL,
    0x9159015A3070DD17ULL, 0x152FECD8F70E5939ULL,
    0x67332667FFC00B31ULL, 0x8EB44A8768581511ULL,
    0xDB0C2E0D64F98FA7ULL, 0x47B5481DBEFA4FA4ULL,
  };
  memcpy(ctx->state, H0, sizeof(H0));
  ctx->count_low = ctx->count_high = 0;
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 10
2 11
3 11
4 12
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 12
21 12
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 110a <lex_clear_state+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lex_clear_state (void)
{
  (yy_start) = 1 + 2 * (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c0 <load_history+0x10>
mov    $0x0,%edi
callq  2ca <load_history+0x1a>
mov    $0x0,%edi
callq  2d4 <load_history+0x24>
mov    $0x0,%edi
mov    %rax,%rsi
callq  2e1 <load_history+0x31>
mov    $0x0,%edi
callq  2eb <load_history+0x3b>
mov    $0x0,%edi
callq  2f5 <load_history+0x45>
test   %rax,%rax
mov    %rax,%rbx
je     302 <load_history+0x52>
cmpb   $0x0,(%rax)
jne    308 <load_history+0x58>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rax,%rdi
callq  310 <load_history+0x60>
test   %eax,%eax
je     302 <load_history+0x52>
mov    %rbx,%rdi
callq  31c <load_history+0x6c>
pop    %rbx
mov    0x0(%rip),%eax        # 323 <load_history+0x73>
mov    %eax,0x0(%rip)        # 329 <load_history+0x79>
jmpq   32e <load_history+0x7e>
xchg   %ax,%ax
<<<sep_in_sample>>>
load_history ()
{
  char *hf;
  set_if_not ("HISTSIZE", "500");
  sv_histsize ("HISTSIZE");
  set_if_not ("HISTFILESIZE", get_string_value ("HISTSIZE"));
  sv_histsize ("HISTFILESIZE");
  hf = get_string_value ("HISTFILE");
  if (hf && *hf && file_exists (hf))
    {
      read_history (hf);
      history_lines_in_file = history_lines_read_from_file;
      using_history ();
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 8
18 9
19 9
20 9
21 15
22 15
23 15
24 9
25 9
26 9
27 9
28 11
29 11
30 15
31 12
32 12
33 13
34 13
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
callq  11b3 <rec_record_reset_marks+0x13>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
jmp    121c <rec_record_reset_marks+0x7c>
nopw   0x0(%rax,%rax,1)
mov    0x40(%rsp),%rdi
xor    %esi,%esi
callq  121c <rec_record_reset_marks+0x7c>
lea    0x40(%rsp),%rdx
lea    0x50(%rsp),%rdi
xor    %ecx,%ecx
mov    $0x1,%esi
callq  1232 <rec_record_reset_marks+0x92>
test   %al,%al
jne    1210 <rec_record_reset_marks+0x70>
lea    0x50(%rsp),%rdi
callq  1240 <rec_record_reset_marks+0xa0>
add    $0x98,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_reset_marks (rec_record_t record)
{
  rec_mset_iterator_t iter;
  rec_field_t field;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &field, ((void *)0)))
    {
      rec_field_set_mark (field, 0);
    }
  rec_mset_iterator_free (&iter);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 8
24 8
25 8
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 10
34 10
35 11
36 11
37 11
<<<sep_out_sample>>>
add    $0x10,%rdi
mov    $0x1,%esi
jmpq   b20 <it_init_joblist.isra.1>
xchg   %ax,%ax
<<<sep_in_sample>>>
it_init_stopped (itp)
     ITEMLIST *itp;
{
  return (it_init_joblist (itp, 1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x4,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_special (sig)
     int sig;
{
  return (sigmodes[sig] & 0x4);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
priv_set_remove_linkdir (void)
{
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_size (const gsl_block_short * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <str_eq+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
str_eq (const void *elt1, const void *elt2)
{
  return strcmp (elt1, elt2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 2ef7 <xheader_xhdr_name+0x7>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
je     2f10 <xheader_xhdr_name+0x20>
mov    %rbx,%rdi
xor    %edx,%edx
pop    %rbx
jmpq   2f0b <xheader_xhdr_name+0x1b>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f1f <xheader_xhdr_name+0x2f>
mov    %rbx,%rdi
mov    0x0(%rip),%rsi        # 2f29 <xheader_xhdr_name+0x39>
xor    %edx,%edx
pop    %rbx
jmpq   2f31 <xheader_xhdr_name+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xheader_xhdr_name (struct tar_stat_info *st)
{
  if (!exthdr_name)
    assign_string (&exthdr_name, "%d/PaxHeaders.%p/%f");
  return xheader_format_name (st, exthdr_name, 0);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 5
7 5
8 6
9 5
10 5
11 4
12 4
13 4
14 5
15 5
16 5
17 6
18 5
19 5
<<<sep_out_sample>>>
mov    0x38(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexget_leng (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyg->yyleng_r;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  10b <_s_readline+0x1b>
mov    0x8(%rsp),%r8
mov    (%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   129 <_s_readline+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_s_readline (mu_stream_t stream, char *optr, size_t osize,
      mu_off_t offset, size_t *nbytes)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_readline (s->fstream, optr, osize, offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
mov    0x24(%rdi),%eax
mov    %eax,%edx
and    $0xfffffffb,%edx
cmp    $0x8,%edx
je     6b32 <MaxMCVar+0x12>
cmp    $0x1,%eax
jbe    6b40 <MaxMCVar+0x20>
mov    0x80(%rdi),%rax
movsd  (%rax),%xmm0
retq   
xchg   %ax,%ax
mov    0x70(%rdi),%rax
movsd  (%rax),%xmm0
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
MaxMCVar (PMCVAR pMCVar) {
  if (pMCVar->iType == 8 || pMCVar->iType == 12 ) {
   return( *(pMCVar->pdParm[3]));
  }
  else {
    if (pMCVar->iType == 0 || pMCVar->iType == 1 ) {
      return( *(pMCVar->pdParm[1]));
    }
    else {
      return( *(pMCVar->pdParm[3]));
    }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 10
9 10
10 13
11 13
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rdi),%r14
mov    0x18(%rdi),%rbp
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%r15
movss  0x0(%rbp),%xmm3
test   %r14,%r14
movss  %xmm3,0x8(%rsp)
je     be4 <gsl_matrix_float_max+0xa4>
shl    $0x2,%r15
xor    %r13d,%r13d
test   %r12,%r12
je     bd0 <gsl_matrix_float_max+0x90>
xor    %ebx,%ebx
jmp    b89 <gsl_matrix_float_max+0x49>
nopl   (%rax)
add    $0x1,%rbx
cmp    %r12,%rbx
je     bd0 <gsl_matrix_float_max+0x90>
movss  0x0(%rbp,%rbx,4),%xmm1
movaps %xmm1,%xmm2
movaps %xmm1,%xmm0
movss  %xmm1,0xc(%rsp)
maxss  0x8(%rsp),%xmm2
movss  %xmm2,0x8(%rsp)
callq  bac <gsl_matrix_float_max+0x6c>
test   %eax,%eax
movss  0xc(%rsp),%xmm1
je     b80 <gsl_matrix_float_max+0x40>
add    $0x18,%rsp
movaps %xmm1,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x1,%r13
add    %r15,%rbp
cmp    %r14,%r13
jne    b74 <gsl_matrix_float_max+0x34>
movss  0x8(%rsp),%xmm1
jmp    bb6 <gsl_matrix_float_max+0x76>
movaps %xmm3,%xmm1
jmp    bb6 <gsl_matrix_float_max+0x76>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_float_max (const gsl_matrix_float * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  float max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          float x = m->data[i * tda + j];
          if (x > max)
            max = x;
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            return x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 4
11 5
12 6
13 8
14 6
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 12
27 12
28 15
29 15
30 12
31 12
32 15
33 15
34 15
35 15
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 8
47 8
48 8
49 8
50 8
51 8
52 8
53 8
54 8
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
sub    $0x8,%rsp
callq  bd <gsl_ntuple_open+0x1d>
test   %rax,%rax
mov    %rax,%rbx
je     f0 <gsl_ntuple_open+0x50>
mov    %r13,0x8(%rax)
mov    %r12,0x10(%rax)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  da <gsl_ntuple_open+0x3a>
test   %rax,%rax
mov    %rax,(%rbx)
je     10d <gsl_ntuple_open+0x6d>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x8,%ecx
mov    $0x46,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  109 <gsl_ntuple_open+0x69>
xor    %eax,%eax
jmp    e5 <gsl_ntuple_open+0x45>
mov    %rbx,%rdi
callq  115 <gsl_ntuple_open+0x75>
mov    $0x5,%ecx
mov    $0x52,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12e <gsl_ntuple_open+0x8e>
xor    %eax,%eax
jmp    e5 <gsl_ntuple_open+0x45>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ntuple_open (char *filename, void *ntuple_data, size_t size)
{
  gsl_ntuple *ntuple = (gsl_ntuple *)malloc (sizeof (gsl_ntuple));
  if (ntuple == 0)
    {
      do { gsl_error ("failed to allocate space for ntuple struct",
 "ntuple.c"
      ,
 70
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                   ;
    }
  ntuple->ntuple_data = ntuple_data;
  ntuple->size = size;
  ntuple->file = fopen (filename, "rb");
  if (ntuple->file == 0)
    {
      free (ntuple);
      do { gsl_error ("unable to open ntuple file for reading",
 "ntuple.c"
      ,
 82
      , GSL_EFAILED) ; return 0 ; } while (0)
                                    ;
    }
  return ntuple;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 2
9 2
10 3
11 4
12 3
13 4
14 13
15 14
16 15
17 15
18 15
19 16
20 15
21 16
22 16
23 27
24 27
25 27
26 27
27 27
28 27
29 6
30 6
31 6
32 6
33 6
34 10
35 10
36 18
37 18
38 19
39 19
40 19
41 19
42 19
43 23
44 23
45 23
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm3        # 10 <gsl_cdf_logistic_Pinv+0x10>
ucomisd %xmm3,%xmm0
jnp    60 <gsl_cdf_logistic_Pinv+0x60>
ucomisd 0x0(%rip),%xmm2        # 1e <gsl_cdf_logistic_Pinv+0x1e>
jp     30 <gsl_cdf_logistic_Pinv+0x30>
movsd  0x0(%rip),%xmm0        # 28 <gsl_cdf_logistic_Pinv+0x28>
jne    30 <gsl_cdf_logistic_Pinv+0x30>
add    $0x18,%rsp
retq   
nop
subsd  %xmm2,%xmm3
movsd  %xmm1,0x8(%rsp)
divsd  %xmm3,%xmm2
movapd %xmm2,%xmm0
callq  47 <gsl_cdf_logistic_Pinv+0x47>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
mulsd  %xmm1,%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm0        # 68 <gsl_cdf_logistic_Pinv+0x68>
jne    16 <gsl_cdf_logistic_Pinv+0x16>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_cdf_logistic_Pinv (const double P, const double a)
{
  double x;
  if (P == 1.0)
    {
      return (__builtin_inff());
    }
  else if (P == 0.0)
    {
      return (-(__builtin_inff()));
    }
  x = a * log(P/(1-P));
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 8
7 8
8 10
9 8
10 14
11 14
12 14
13 12
14 12
15 12
16 12
17 12
18 12
19 14
20 12
21 14
22 14
23 6
24 4
25 14
26 14
27 14
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     10 <pop_is_updated+0x10>
mov    0x78(%rax),%eax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pop_is_updated (mu_mailbox_t mbox)
{
  pop_data_t mpd = mbox->data;
  if (mpd == ((void *)0))
    return 0;
  return mpd->is_updated;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 6
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
callq  845 <__osip_add_nist+0x15>
lea    0x70(%rbx),%rdi
mov    %rbp,%rsi
mov    $0xffffffff,%edx
callq  856 <__osip_add_nist+0x26>
mov    0x20(%rbx),%rdi
callq  85f <__osip_add_nist+0x2f>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_add_nist (osip_t * osip, osip_transaction_t * nist)
{
  osip_mutex_lock (osip->nist_fastmutex);
  osip_list_add (&osip->osip_nist_transactions, nist, -1);
  osip_mutex_unlock (osip->nist_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
testb  $0x4,0x0(%rip)        # 5a7 <flowstat+0x7>
jne    5b0 <flowstat+0x10>
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
callq  5b9 <flowstat+0x19>
cmp    0x0(%rip),%eax        # 5bf <flowstat+0x1f>
je     5fe <flowstat+0x5e>
callq  5c6 <flowstat+0x26>
test   %eax,%eax
mov    %eax,0x0(%rip)        # 5ce <flowstat+0x2e>
movl   $0xf0,(%rsp)
setne  %r8b
mov    $0xff,%r9d
mov    $0x21,%ecx
movzbl %r8b,%r8d
mov    $0xfa,%edx
mov    $0xff,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  5fe <flowstat+0x5e>
callq  603 <flowstat+0x63>
cmp    0x0(%rip),%eax        # 609 <flowstat+0x69>
je     649 <flowstat+0xa9>
callq  610 <flowstat+0x70>
cmp    $0x1,%eax
mov    %eax,0x0(%rip)        # 619 <flowstat+0x79>
movl   $0xf0,(%rsp)
sbb    %eax,%eax
mov    $0xff,%r9d
mov    $0x21,%ecx
not    %eax
mov    $0xfa,%edx
mov    $0xff,%esi
lea    0x3(%rax),%r8d
mov    $0x0,%edi
xor    %eax,%eax
callq  649 <flowstat+0xa9>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
flowstat (void)
{
  if ((options[33]&0x04))
    {
      if (tty_flowmode () != flowmode)
 {
   flowmode = tty_flowmode ();
   net_output_data ("%c%c%c%c%c%c",
      255, 250, 33,
      flowmode ? 1 : 0, 255, 240);
 }
      if (tty_restartany () != restartany)
 {
   restartany = tty_restartany ();
   net_output_data ("%c%c%c%c%c%c",
      255, 250, 33,
      restartany ? 2
      : 3, 255, 240);
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 21
4 21
5 2
6 5
7 5
8 5
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 12
23 12
24 12
25 14
26 15
27 14
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 21
40 21
41 21
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_ptr (Buffer *buffer)
{
  return buffer->data;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1721 <gsl_matrix_long_isneg+0x51>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,8),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1715 <gsl_matrix_long_isneg+0x45>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdq (%rcx,%rax,8),%xmm0
ucomisd %xmm1,%xmm0
jae    1727 <gsl_matrix_long_isneg+0x57>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1700 <gsl_matrix_long_isneg+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    16f1 <gsl_matrix_long_isneg+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_isneg (const gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 816 <sort_function_names+0x6>
test   %eax,%eax
jne    820 <sort_function_names+0x10>
repz retq 
nopl   0x0(%rax)
lea    0x0(,%rax,8),%rdx
shl    $0x7,%rax
sub    $0x8,%rsp
mov    %rax,%rdi
sub    %rdx,%rdi
callq  83b <sort_function_names+0x2b>
movzwl 0x0(%rip),%esi        # 842 <sort_function_names+0x32>
mov    %rax,0x0(%rip)        # 849 <sort_function_names+0x39>
test   %si,%si
je     921 <sort_function_names+0x111>
lea    -0x1(%rsi),%r8d
mov    0x0(%rip),%rcx        # 85d <sort_function_names+0x4d>
movzwl %r8w,%r8d
add    $0x1,%r8
lea    0x0(,%r8,8),%rdx
shl    $0x7,%r8
sub    %rdx,%r8
xor    %edx,%edx
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rcx,%rdx,1),%rdi
mov    %rdi,(%rax,%rdx,1)
mov    0x8(%rcx,%rdx,1),%rdi
mov    %rdi,0x8(%rax,%rdx,1)
mov    0x10(%rcx,%rdx,1),%rdi
mov    %rdi,0x10(%rax,%rdx,1)
mov    0x18(%rcx,%rdx,1),%rdi
mov    %rdi,0x18(%rax,%rdx,1)
mov    0x20(%rcx,%rdx,1),%rdi
mov    %rdi,0x20(%rax,%rdx,1)
mov    0x28(%rcx,%rdx,1),%rdi
mov    %rdi,0x28(%rax,%rdx,1)
mov    0x30(%rcx,%rdx,1),%rdi
mov    %rdi,0x30(%rax,%rdx,1)
mov    0x38(%rcx,%rdx,1),%rdi
mov    %rdi,0x38(%rax,%rdx,1)
mov    0x40(%rcx,%rdx,1),%rdi
mov    %rdi,0x40(%rax,%rdx,1)
mov    0x48(%rcx,%rdx,1),%rdi
mov    %rdi,0x48(%rax,%rdx,1)
mov    0x50(%rcx,%rdx,1),%rdi
mov    %rdi,0x50(%rax,%rdx,1)
mov    0x58(%rcx,%rdx,1),%rdi
mov    %rdi,0x58(%rax,%rdx,1)
mov    0x60(%rcx,%rdx,1),%rdi
mov    %rdi,0x60(%rax,%rdx,1)
mov    0x68(%rcx,%rdx,1),%rdi
mov    %rdi,0x68(%rax,%rdx,1)
mov    0x70(%rcx,%rdx,1),%rdi
mov    %rdi,0x70(%rax,%rdx,1)
add    $0x78,%rdx
cmp    %r8,%rdx
jne    880 <sort_function_names+0x70>
mov    $0x0,%ecx
mov    $0x78,%edx
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   937 <sort_function_names+0x127>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sort_function_names(void)
{
  unsigned short every_function;
  size_t size_needed = function_list_size * sizeof(function_entry);
  if (function_list_size == 0) return;
  sorted_functions = xmalloc(size_needed);
  for (every_function=0;every_function<no_of_functions;every_function++)
    sorted_functions[every_function] = functions[every_function];
  qsort((char *)sorted_functions,(int)no_of_functions,sizeof(function_entry),compare);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 4
7 4
8 2
9 4
10 4
11 6
12 7
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 8
50 8
51 8
52 8
53 8
54 8
55 8
56 7
57 7
58 9
59 9
60 9
61 10
62 9
63 9
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
movslq 0x4(%rdi),%rdx
test   %rcx,%rcx
jle    40 <__gmpf_integer_p+0x40>
mov    %rdx,%rax
sar    $0x3f,%rax
xor    %rax,%rdx
sub    %rax,%rdx
mov    0x10(%rdi),%rax
cmpq   $0x0,(%rax)
jne    36 <__gmpf_integer_p+0x36>
nopl   0x0(%rax)
add    $0x8,%rax
sub    $0x1,%rdx
cmpq   $0x0,(%rax)
je     28 <__gmpf_integer_p+0x28>
xor    %eax,%eax
cmp    %rcx,%rdx
setle  %al
retq   
nop
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
retq   
<<<sep_in_sample>>>
__gmpf_integer_p (mpf_srcptr f)
{
  mp_srcptr fp;
  mp_exp_t exp;
  mp_size_t size;
  size = ((f)->_mp_size);
  exp = ((f)->_mp_exp);
  if (exp <= 0)
    return (size == 0);
  size = ((size) >= 0 ? (size) : -(size));
  for (fp = ((f)->_mp_d); *fp == 0; ++fp)
    --size;
  return size <= exp;
}
<<<sep_in_sample>>>
1 7
2 6
3 8
4 8
5 10
6 10
7 10
8 10
9 11
10 11
11 11
12 11
13 11
14 12
15 11
16 11
17 13
18 13
19 13
20 14
21 14
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
cmpq   $0x1,0xb8(%rdi)
sbb    %edx,%edx
xor    %eax,%eax
add    $0x1,%edx
cmpq   $0x0,0xc0(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xc8(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xd0(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xd8(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xe0(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xe8(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xf0(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0xf8(%rdi)
cmove  %eax,%edx
cmpq   $0x0,0x100(%rdi)
cmovne %edx,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
face_eo_font_is_set (struct a2ps_job * job)
{
  enum face_e f;
  int res = 1;
  for (f = First_face ; f <= Last_face ; f++)
    if (!job->face_eo_font [f])
      res = 0;
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 2
23 9
24 9
<<<sep_out_sample>>>
movsd  0x10(%rsi),%xmm1
ucomisd 0x0(%rip),%xmm1        # d <VEyeToScreen+0xd>
jbe    60 <VEyeToScreen+0x60>
movsd  0x130(%rdi),%xmm0
movswl 0x128(%rdi),%r8d
mulsd  (%rsi),%xmm0
divsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
movsd  0x138(%rdi),%xmm0
mulsd  0x8(%rsi),%xmm0
divsd  %xmm1,%xmm0
add    %r8d,%eax
sar    $0x2,%eax
mov    %eax,(%rdx)
movswl 0x12a(%rdi),%eax
cvttsd2si %xmm0,%edx
sub    %edx,%eax
sar    $0x2,%eax
mov    %eax,(%rcx)
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
VEyeToScreen(Viewport * v, VPoint * p, int *x, int *y)
{
 register int valid;
 if (p->z > 0.0) {
  *x = (v->Middl.x + (int) (v->Scale.x * p->x / p->z)) >> 2;
  *y = (v->Middl.y - (int) (v->Scale.y * p->y / p->z)) >> 2;
  valid = 1;
 }
 else
  valid = 0;
 return valid;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 10
24 12
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    %rsi,(%rdi)
jb     250 <list_item+0x30>
test   %rsi,%rsi
mov    0x8(%rdi),%rax
je     249 <list_item+0x29>
test   %rax,%rax
jne    23d <list_item+0x1d>
jmp    249 <list_item+0x29>
nopl   (%rax)
test   %rsi,%rsi
je     249 <list_item+0x29>
mov    (%rax),%rax
sub    $0x1,%rsi
test   %rax,%rax
jne    238 <list_item+0x18>
mov    0x8(%rax),%rax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
list_item (struct list *list, size_t n)
{
  struct list_entry *p;
  if (n > list->count)
    return ((void *)0);
  for (p = list->head; n > 0 && p; p = p->next, n--)
    ;
  return p->data;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 5
20 9
21 9
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    0x670(%rdi),%rdx
xor    %ebx,%ebx
test   %rdx,%rdx
jg     b6e9 <SetModelVars+0x29>
jmp    b71d <SetModelVars+0x5d>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %rdx,%rbx
jge    b71d <SetModelVars+0x5d>
mov    0x678(%r12),%rax
mov    (%rax,%rbx,8),%rbp
mov    0xd4(%rbp),%eax
test   %eax,%eax
jne    b6e0 <SetModelVars+0x20>
mov    0x8(%rbp),%rdi
callq  b708 <SetModelVars+0x48>
test   %eax,%eax
jne    b728 <SetModelVars+0x68>
mov    0x670(%r12),%rdx
add    $0x1,%rbx
cmp    %rdx,%rbx
jl     b6e9 <SetModelVars+0x29>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdi
movsd  0x10(%rbp),%xmm0
callq  b736 <SetModelVars+0x76>
jmp    b70c <SetModelVars+0x4c>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
SetModelVars(PLEVEL plevel)
{
  long n;
  PMCVAR pMCVar;
  for (n = 0; n < plevel->nMCVars; n++) {
    pMCVar = plevel->rgpMCVars[n];
    if (!(pMCVar->bIsFixed) && (IsParm (pMCVar->hvar)))
      SetVar (pMCVar->hvar, pMCVar->dVal);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 5
25 5
26 5
27 10
28 10
29 10
30 10
31 10
32 8
33 8
34 8
35 8
36 8
<<<sep_out_sample>>>
addsd  %xmm0,%xmm0
movsd  0x10(%rdi),%xmm1
movsd  0x18(%rdi),%xmm2
mov    0x8(%rdi),%rax
subsd  %xmm1,%xmm0
cmp    %rax,%rsi
cmova  %rax,%rsi
mov    (%rdi),%rax
test   %rsi,%rsi
subsd  %xmm2,%xmm0
subsd  %xmm1,%xmm2
divsd  %xmm2,%xmm0
xorpd  %xmm2,%xmm2
movapd %xmm0,%xmm4
movapd %xmm2,%xmm1
addsd  %xmm0,%xmm4
je     ef <gsl_cheb_eval_n+0x6f>
xorpd  %xmm3,%xmm3
movapd %xmm3,%xmm2
jmp    d8 <gsl_cheb_eval_n+0x58>
nopl   0x0(%rax,%rax,1)
movapd %xmm2,%xmm3
movapd %xmm1,%xmm2
movapd %xmm4,%xmm1
mulsd  %xmm2,%xmm1
subsd  %xmm3,%xmm1
addsd  (%rax,%rsi,8),%xmm1
sub    $0x1,%rsi
jne    d0 <gsl_cheb_eval_n+0x50>
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # fb <gsl_cheb_eval_n+0x7b>
mulsd  (%rax),%xmm1
subsd  %xmm2,%xmm0
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cheb_eval_n (const gsl_cheb_series * cs, const size_t n, const double x)
{
  size_t i;
  double d1 = 0.0;
  double d2 = 0.0;
  size_t eval_order = ((n) < (cs->order) ? (n) : (cs->order));
  double y = (2.0 * x - cs->a - cs->b) / (cs->b - cs->a);
  double y2 = 2.0 * y;
  for (i = eval_order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }
  return y * d1 - d2 + 0.5 * cs->c[0];
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 6
5 7
6 6
7 6
8 6
9 9
10 7
11 7
12 7
13 5
14 8
15 4
16 8
17 9
18 5
19 4
20 4
21 4
22 12
23 12
24 12
25 12
26 12
27 12
28 9
29 9
30 15
31 15
32 15
33 15
34 15
35 16
36 16
<<<sep_out_sample>>>
xor    %eax,%eax
movb   $0x0,0xa(%rdi)
mov    %ax,0x8(%rdi)
lea    0x0(%rip),%rax        # 201 <nettle_base64_encode_init+0x11>
mov    %rax,(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_base64_encode_init(struct base64_encode_ctx *ctx)
{
  ctx->word = ctx->bits = 0;
  ctx->alphabet = base64_encode_table;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x1000,%edx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    %rbx,%rdi
sub    $0x1018,%rsp
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x1008(%rsp)
xor    %eax,%eax
callq  1a2 <histfile_restore+0x32>
test   %rax,%rax
jle    1d8 <histfile_restore+0x68>
mov    %rsp,%rsi
mov    %rbp,%rdi
movb   $0x0,(%rsp,%rax,1)
callq  1b6 <histfile_restore+0x46>
mov    0x1008(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1e5 <histfile_restore+0x75>
add    $0x1018,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1e3 <histfile_restore+0x73>
jmp    1b6 <histfile_restore+0x46>
callq  1ea <histfile_restore+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
histfile_restore (backup, orig)
     const char *backup;
     const char *orig;
{
  char linkbuf[4096 +1];
  ssize_t n;
  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)
    {
      linkbuf[n] = '\0';
      return (rename (backup, linkbuf));
    }
  return (rename (backup, orig));
}
<<<sep_in_sample>>>
1 4
2 7
3 4
4 4
5 4
6 7
7 4
8 7
9 4
10 4
11 4
12 7
13 7
14 7
15 10
16 10
17 9
18 10
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 13
32 13
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_diagonal (gsl_matrix_uint * m)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_uint v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_process_context_token (OM_uint32 * minor_status,
      const gss_ctx_id_t context_handle,
      const gss_buffer_t token_buffer)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %rbx
mov    0x98(%rdi),%rax
mov    %rdi,%rbx
mov    $0xe,%esi
movl   $0xffffffff,0x30(%rax)
movq   $0xffffffffffffffff,0x38(%rax)
callq  74 <osip_nict_timeout_k_event+0x24>
mov    %rbx,%rsi
mov    $0x2,%edi
pop    %rbx
jmpq   82 <osip_nict_timeout_k_event+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_nict_timeout_k_event (osip_transaction_t * nict, osip_event_t * evt)
{
  nict->nict_context->timer_k_length = -1;
  nict->nict_context->timer_k_start.tv_sec = -1;
  __osip_transaction_set_state (nict, NICT_TERMINATED);
  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 3
6 4
7 5
8 6
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm0        # 80 <gsl_cdf_logistic_Qinv+0x10>
jnp    d0 <gsl_cdf_logistic_Qinv+0x60>
movsd  0x0(%rip),%xmm3        # 8a <gsl_cdf_logistic_Qinv+0x1a>
ucomisd %xmm3,%xmm2
jp     a0 <gsl_cdf_logistic_Qinv+0x30>
movsd  0x0(%rip),%xmm0        # 98 <gsl_cdf_logistic_Qinv+0x28>
jne    a0 <gsl_cdf_logistic_Qinv+0x30>
add    $0x18,%rsp
retq   
nop
movapd %xmm3,%xmm0
movsd  %xmm1,0x8(%rsp)
subsd  %xmm2,%xmm0
divsd  %xmm2,%xmm0
callq  b7 <gsl_cdf_logistic_Qinv+0x47>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
mulsd  %xmm1,%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm0        # d8 <gsl_cdf_logistic_Qinv+0x68>
jne    82 <gsl_cdf_logistic_Qinv+0x12>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_logistic_Qinv (const double Q, const double a)
{
  double x;
  if (Q == 0.0)
    {
      return (__builtin_inff());
    }
  else if (Q == 1.0)
    {
      return (-(__builtin_inff()));
    }
  x = a * log((1-Q)/Q);
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 8
6 8
7 8
8 10
9 8
10 14
11 14
12 14
13 12
14 12
15 12
16 12
17 12
18 12
19 14
20 12
21 14
22 14
23 6
24 4
25 14
26 14
<<<sep_out_sample>>>
push   %r15
mov    %rdx,%r15
push   %r14
mov    %rsi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
cmpb   $0x0,(%rsi)
je     497 <revstrcasestr+0x77>
mov    %rdi,%r13
mov    %rsi,%rdi
callq  444 <revstrcasestr+0x24>
mov    %r13,%rdi
mov    %rax,%r12
callq  44f <revstrcasestr+0x2f>
cmp    %rax,%r12
ja     494 <revstrcasestr+0x74>
mov    %r15,%rdi
mov    %r15,%rbx
callq  45f <revstrcasestr+0x3f>
cmp    %r13,%r15
mov    %rax,%rbp
jb     494 <revstrcasestr+0x74>
nopw   0x0(%rax,%rax,1)
cmp    %rbp,%r12
ja     487 <revstrcasestr+0x67>
mov    %r12,%rdx
mov    %r14,%rsi
mov    %rbx,%rdi
callq  483 <revstrcasestr+0x63>
test   %eax,%eax
je     4b0 <revstrcasestr+0x90>
sub    $0x1,%rbx
add    $0x1,%rbp
cmp    %rbx,%r13
jbe    470 <revstrcasestr+0x50>
xor    %r15d,%r15d
add    $0x8,%rsp
mov    %r15,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    %rbx,%r15
jmp    497 <revstrcasestr+0x77>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
revstrcasestr(const char *haystack, const char *needle, const char
 *rev_start)
{
    size_t rev_start_len, needle_len;
    ((void) (0));
    if (*needle == '\0')
 return (char *)rev_start;
    needle_len = strlen(needle);
    if (strlen(haystack) < needle_len)
 return ((void *)0);
    rev_start_len = strlen(rev_start);
    for (; rev_start >= haystack; rev_start--, rev_start_len++) {
 if (rev_start_len >= needle_len && strncasecmp(rev_start,
  needle, needle_len) == 0)
     return (char *)rev_start;
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 6
13 8
14 8
15 9
16 8
17 9
18 9
19 9
20 11
21 11
22 11
23 12
24 11
25 12
26 12
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 12
36 12
37 12
38 12
39 10
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 18
51 18
52 18
<<<sep_out_sample>>>
mov    0x1d0(%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
jpeg_write_m_byte (j_compress_ptr cinfo, int val)
{
  (*cinfo->marker->write_marker_byte) (cinfo, val);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm1        # c <Tfun+0xc>
ucomisd 0x0(%rip),%xmm1        # 14 <Tfun+0x14>
jp     28 <Tfun+0x28>
jne    28 <Tfun+0x28>
movsd  0x0(%rip),%xmm0        # 20 <Tfun+0x20>
add    $0x18,%rsp
retq   
nopl   (%rax)
movsd  %xmm1,0x8(%rsp)
callq  33 <Tfun+0x33>
movsd  0x8(%rsp),%xmm1
subsd  0x0(%rip),%xmm1        # 41 <Tfun+0x41>
add    $0x18,%rsp
jmpq   4a <Tfun+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Tfun(double x)
{
  if (dddi == 0.0)
    return 1.0;
  return pow(cos(x), dddi - 1.0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 6
7 6
8 6
9 6
10 6
11 5
12 5
13 5
14 6
15 5
16 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rdx,%rdi
sar    $0x3f,%rdi
mov    %rdi,%rcx
xor    %rdx,%rcx
sub    %rdi,%rcx
jne    26 <__gmpz_roinit_n+0x26>
jmp    2e <__gmpz_roinit_n+0x2e>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rcx
je     2e <__gmpz_roinit_n+0x2e>
cmpq   $0x0,-0x8(%rsi,%rcx,8)
je     20 <__gmpz_roinit_n+0x20>
mov    %ecx,%edi
movl   $0x0,(%rax)
mov    %rsi,0x8(%rax)
neg    %edi
test   %rdx,%rdx
cmovs  %edi,%ecx
mov    %ecx,0x4(%rax)
retq   
<<<sep_in_sample>>>
__gmpz_roinit_n (mpz_ptr x, mp_srcptr xp, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((xp)[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_alloc) = 0;
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
  ((x)->_mp_d) = (mp_ptr) xp;
  return x;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 5
16 7
17 6
18 6
19 6
20 6
21 9
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     152b <gsl_matrix_ulong_isneg+0x8b>
xorpd  %xmm1,%xmm1
push   %rbx
lea    0x0(,%rax,8),%rbx
xor    %r8d,%r8d
xor    %r11d,%r11d
test   %rdx,%rdx
je     14f5 <gsl_matrix_ulong_isneg+0x55>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
mov    (%rsi,%rax,8),%rcx
test   %rcx,%rcx
js     1510 <gsl_matrix_ulong_isneg+0x70>
cvtsi2sd %rcx,%xmm0
ucomisd %xmm1,%xmm0
jae    1527 <gsl_matrix_ulong_isneg+0x87>
add    $0x1,%rax
cmp    %rdx,%rax
jne    14d8 <gsl_matrix_ulong_isneg+0x38>
add    $0x1,%r11
add    %rbx,%r8
cmp    %r9,%r11
jne    14c3 <gsl_matrix_ulong_isneg+0x23>
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    %rcx,%r10
and    $0x1,%ecx
shr    %r10
or     %rcx,%r10
cvtsi2sd %r10,%xmm0
addsd  %xmm0,%xmm0
jmp    14e6 <gsl_matrix_ulong_isneg+0x46>
xor    %eax,%eax
pop    %rbx
retq   
mov    $0x1,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_isneg (const gsl_matrix_ulong * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 2
8 2
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 13
18 13
19 13
20 13
21 13
22 13
23 9
24 9
25 9
26 7
27 7
28 7
29 7
30 20
31 21
32 21
33 21
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 15
42 21
43 21
44 20
45 21
46 21
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    2608 <gsl_matrix_uint_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  262a <gsl_matrix_uint_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_column (gsl_matrix_uint * m, const size_t j)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  23c1 <str_to_cf+0x11>
cmp    $0x2,%rax
ja     23f0 <str_to_cf+0x40>
mov    %rsp,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  23d7 <str_to_cf+0x27>
test   %eax,%eax
jne    2430 <str_to_cf+0x80>
mov    (%rsp),%edx
or     %edx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  2402 <str_to_cf+0x52>
test   %eax,%eax
jne    23c7 <str_to_cf+0x17>
lea    0x2(%rbx),%rsi
mov    %rsp,%rdx
mov    $0x0,%edi
callq  2417 <str_to_cf+0x67>
test   %eax,%eax
jne    2430 <str_to_cf+0x80>
mov    (%rsp),%edx
not    %edx
and    %edx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
jmp    2423 <str_to_cf+0x73>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
str_to_cf (const char *string, int *flags)
{
  size_t len = strlen (string);
  int neg = 0;
  int mask;
  static struct tokendef cf_tab[] = {
    { "disable", 0x01 },
    { "precious", 0x02 },
    { "wait", 0x04 },
    { "tcpmux", 0x08 },
    { "tcpmuxplus", 0x10 },
    { "internal", 0x20 },
    { "sockenv", 0x40 },
    { "resolve", 0x80 },
    { ((void *)0) }
  };
  if (len > 2 && memcmp (string, "no", 2) == 0)
    {
      neg++;
      string += 2;
    }
  if (strtotok (cf_tab, string, &mask))
    return 1;
  if (neg)
    *flags &= ~mask;
  else
    *flags |= mask;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 17
8 17
9 22
10 22
11 22
12 22
13 22
14 22
15 27
16 27
17 29
18 29
19 29
20 29
21 29
22 17
23 17
24 17
25 17
26 17
27 17
28 20
29 22
30 22
31 22
32 22
33 22
34 25
35 25
36 25
37 29
38 29
39 29
40 29
41 29
42 23
43 23
44 23
<<<sep_out_sample>>>
sub    $0xe8,%rsp
test   %al,%al
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
je     54 <__gmp_snprintf+0x54>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
lea    0xf0(%rsp),%rax
lea    0x18(%rsp),%rcx
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
mov    %rdi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    $0x0,%edi
mov    %rsp,%rsi
movl   $0x18,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
mov    %rax,0x28(%rsp)
callq  96 <__gmp_snprintf+0x96>
add    $0xe8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_snprintf (char *buf, size_t size, const char *fmt, ...)
{
  struct gmp_snprintf_t d;
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  d.buf = buf;
  d.size = size;
  do {} while (0);
  ret = __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 6
16 10
17 6
18 6
19 7
20 8
21 10
22 10
23 6
24 6
25 6
26 10
27 13
28 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # f4b <get_locale_var+0xb>
test   %rax,%rax
je     f55 <get_locale_var+0x15>
cmpb   $0x0,(%rax)
jne    f7c <get_locale_var+0x3c>
callq  f5a <get_locale_var+0x1a>
test   %rax,%rax
je     f64 <get_locale_var+0x24>
cmpb   $0x0,(%rax)
jne    f7c <get_locale_var+0x3c>
mov    0x0(%rip),%rax        # f6b <get_locale_var+0x2b>
test   %rax,%rax
je     f88 <get_locale_var+0x48>
cmpb   $0x0,(%rax)
mov    $0x0,%edx
cmove  %rdx,%rax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_locale_var (var)
     char *var;
{
  char *locale;
  locale = lc_all;
  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
    locale = "";
  return (locale);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 7
8 8
9 8
10 8
11 8
12 9
13 10
14 10
15 11
16 11
17 11
18 13
19 13
20 13
21 11
22 13
23 13
24 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
xor    %esi,%esi
callq  95e <rl_replace_from_history+0xe>
mov    0x10(%rbx),%rax
mov    0x0(%rip),%edx        # 968 <rl_replace_from_history+0x18>
movl   $0x0,0x0(%rip)        # 972 <rl_replace_from_history+0x22>
mov    %rax,0x0(%rip)        # 979 <rl_replace_from_history+0x29>
mov    0x0(%rip),%eax        # 97f <rl_replace_from_history+0x2f>
test   %edx,%edx
mov    %eax,0x0(%rip)        # 987 <rl_replace_from_history+0x37>
jne    999 <rl_replace_from_history+0x49>
movl   $0x0,0x0(%rip)        # 993 <rl_replace_from_history+0x43>
mov    %eax,0x0(%rip)        # 999 <rl_replace_from_history+0x49>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_replace_from_history (entry, flags)
     HIST_ENTRY *entry;
     int flags;
{
  rl_replace_line (entry->line, 0);
  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_point = rl_end;
  rl_mark = 0;
  if (rl_editing_mode == 0)
    {
      rl_point = 0;
      rl_mark = rl_end;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 6
7 9
8 8
9 6
10 7
11 9
12 7
13 9
14 11
15 12
16 14
17 14
18 14
<<<sep_out_sample>>>
test   %edx,%edx
jle    3c <cblas_csscal+0x3c>
test   %edi,%edi
jle    3c <cblas_csscal+0x3c>
add    %edx,%edx
xor    %eax,%eax
movslq %edx,%rdx
shl    $0x2,%rdx
nopl   0x0(%rax,%rax,1)
movss  (%rsi),%xmm1
add    $0x1,%eax
mulss  %xmm0,%xmm1
movss  %xmm1,(%rsi)
movss  0x4(%rsi),%xmm1
mulss  %xmm0,%xmm1
movss  %xmm1,0x4(%rsi)
add    %rdx,%rsi
cmp    %edi,%eax
jne    18 <cblas_csscal+0x18>
repz retq 
<<<sep_in_sample>>>
cblas_csscal (const int N, const float alpha, void *X, const int incX)
{
{
  int i;
  int ix = 0;
  if (incX <= 0) {
    return;
  }
  for (i = 0; i < N; i++) {
    (((float *) X)[2*(ix)]) *= alpha;
    (((float *) X)[2*(ix)+1]) *= alpha;
    ix += incX;
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 10
11 9
12 10
13 10
14 11
15 11
16 11
17 11
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
movzbl (%rsi),%eax
cmp    %al,(%rdi)
je     680 <check_selfref+0x70>
xor    %esi,%esi
mov    %rbx,%rdi
callq  62d <check_selfref+0x1d>
test   %eax,%eax
jne    640 <check_selfref+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
xor    %edx,%edx
xor    %esi,%esi
mov    %rbx,%rdi
callq  64c <check_selfref+0x3c>
test   %rax,%rax
mov    %rax,%rbx
je     65c <check_selfref+0x4c>
movzbl (%rax),%eax
cmp    %al,0x0(%rbp)
je     6a0 <check_selfref+0x90>
mov    %rbx,%rdi
mov    $0x112,%edx
mov    $0x0,%esi
callq  66e <check_selfref+0x5e>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  685 <check_selfref+0x75>
mov    %eax,%edx
mov    $0x1,%eax
test   %edx,%edx
jne    623 <check_selfref+0x13>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  6ab <check_selfref+0x9b>
test   %eax,%eax
jne    65c <check_selfref+0x4c>
mov    $0x10f,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  6c1 <check_selfref+0xb1>
mov    $0x1,%eax
jmpq   631 <check_selfref+0x21>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_selfref (name, value, flags)
     const char *name;
     const char *value;
     int flags;
{
  char *t;
  if (((name)[0] == (value)[0] && strcmp(name, value) == 0))
    return 1;
  if (valid_array_reference (value, 0))
    {
      t = array_variable_name (value, (char **)((void *)0), (int *)((void *)0));
      if (t && ((name)[0] == (t)[0] && strcmp(name, t) == 0))
 {
   sh_xfree((t), "general.c", 271);
   return 1;
 }
      sh_xfree((t), "general.c", 274);
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 20
15 20
16 20
17 20
18 20
19 11
20 11
21 11
22 11
23 12
24 11
25 12
26 12
27 12
28 12
29 17
30 17
31 17
32 17
33 20
34 19
35 20
36 20
37 20
38 20
39 7
40 7
41 8
42 7
43 7
44 20
45 20
46 20
47 20
48 20
49 12
50 12
51 12
52 12
53 12
54 14
55 14
56 14
57 14
58 15
59 15
60 15
<<<sep_out_sample>>>
mov    0x878(%rdi),%eax
orl    $0x1,0x880(%rdi)
test   %eax,%eax
jle    30 <press_m61a1+0x30>
sub    $0x8,%rsp
mov    $0x5,%esi
callq  1f <press_m61a1+0x1f>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
press_m61a1(craft * c)
{
 c->station[0].info3 |= 1;
 if (c->station[0].info > 0) {
  playContinuousSound(c, 5);
 }
 return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 2
6 5
7 5
8 8
9 8
10 8
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 27f7 <php_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_set_out (FILE * out_str )
{
        php_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5da7 <pch_end+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pch_end (void)
{
    return p_end;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
xor    %edx,%edx
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x5f8(%rsi),%rax
xor    %esi,%esi
mov    0x58(%rax),%rdi
callq  42b <dump_requirements+0x1b>
cmpq   $0x0,(%rax)
mov    %rax,%r12
je     48b <dump_requirements+0x7b>
mov    $0x10,%edx
mov    %rbp,%rcx
mov    $0x1,%esi
mov    $0x0,%edi
mov    %r12,%rbx
callq  44e <dump_requirements+0x3e>
mov    (%r12),%rdx
test   %rdx,%rdx
je     47e <dump_requirements+0x6e>
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rdx
xor    %eax,%eax
add    $0x8,%rbx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  476 <dump_requirements+0x66>
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    460 <dump_requirements+0x50>
mov    %rbp,%rsi
mov    $0xa,%edi
callq  48b <dump_requirements+0x7b>
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
jmpq   497 <dump_requirements+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dump_requirements (FILE * stream, struct a2ps_job * job)
{
  dict_entry ** entries = ((void *)0);
  dict_entry ** entry;
  entries = (dict_entry **) hash_dump (job->status->pagedevice, ((void *)0), ((void *)0));
  if (*entries)
    {
      fputs ("%%Requirements: ", stream);
      for (entry = entries ; *entry ; entry++)
 fprintf (stream, "%s ", (*entry)->key);
      _IO_putc ('\n', stream);
    }
  free (entries);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 6
11 5
12 6
13 8
14 8
15 8
16 8
17 9
18 8
19 9
20 9
21 9
22 9
23 10
24 10
25 9
26 10
27 10
28 10
29 9
30 9
31 9
32 11
33 11
34 11
35 14
36 14
37 13
38 14
39 13
40 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  cb <_mapfile_close+0xb>
mov    0x8(%rax),%rdi
mov    %rax,%rbx
cmp    $0xffffffffffffffff,%rdi
je     130 <_mapfile_close+0x70>
test   %rdi,%rdi
je     ea <_mapfile_close+0x2a>
mov    0x10(%rax),%rsi
callq  e6 <_mapfile_close+0x26>
test   %eax,%eax
jne    120 <_mapfile_close+0x60>
xor    %ebp,%ebp
mov    (%rbx),%edi
callq  f3 <_mapfile_close+0x33>
test   %eax,%eax
jne    110 <_mapfile_close+0x50>
movq   $0xffffffffffffffff,0x8(%rbx)
movl   $0xffffffff,(%rbx)
add    $0x8,%rsp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
xchg   %ax,%ax
callq  115 <_mapfile_close+0x55>
mov    (%rax),%ebp
jmp    f7 <_mapfile_close+0x37>
nopl   0x0(%rax)
callq  125 <_mapfile_close+0x65>
mov    (%rax),%ebp
jmp    ec <_mapfile_close+0x2c>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %ebp,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_close (mu_stream_t stream)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  int err = 0;
  if (mfs->ptr != ((void *) -1))
    {
      if (mfs->ptr && munmap (mfs->ptr, mfs->size) != 0)
 err = (*__errno_location ());
      if (close (mfs->fd) != 0)
 err = (*__errno_location ());
      mfs->ptr = ((void *) -1);
      mfs->fd = -1;
    }
  return err;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 3
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 4
16 9
17 9
18 9
19 9
20 11
21 12
22 15
23 15
24 15
25 15
26 15
27 15
28 10
29 10
30 10
31 10
32 8
33 8
34 8
35 8
36 15
37 4
38 15
39 15
40 15
41 15
42 15
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0x10(%rdi),%rcx
mov    %rdi,%rbx
mov    0x18(%rdi),%rsi
lea    (%rdx,%rcx,1),%rdx
cmp    %rdx,%rsi
jbe    40 <__gmp_asprintf_memory+0x40>
mov    0x8(%rdi),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rcx,%rdi
callq  30 <__gmp_asprintf_memory+0x30>
add    %rbp,0x10(%rbx)
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
add    %rdx,%rdx
mov    %rdx,0x18(%rdi)
mov    0x8(%rdi),%rdi
callq  *0x0(%rip)        # 51 <__gmp_asprintf_memory+0x51>
mov    0x10(%rbx),%rcx
mov    %rax,0x8(%rbx)
mov    %rax,%rdi
jmp    22 <__gmp_asprintf_memory+0x22>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_asprintf_memory (struct gmp_asprintf_t *d, const char *str, size_t len)
{
  do { size_t alloc, newsize, newalloc; do {} while (0); alloc = (d)->alloc; newsize = (d)->size + (len); if (alloc <= newsize) { newalloc = 2*newsize; (d)->alloc = newalloc; (d)->buf = ((char *) (*__gmp_reallocate_func) ((d)->buf, (alloc) * sizeof (char), (newalloc) * sizeof (char))); } } while (0);
  memcpy (d->buf + d->size, str, len);
  d->size += len;
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 5
18 7
19 7
20 7
21 7
22 7
23 7
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
<<<sep_out_sample>>>
movzwl 0x1c(%rdi),%ecx
mov    0x14(%rdi),%edx
mov    %rsi,%rax
cmpw   $0xfffe,0x18(%rdi)
mov    %edx,(%rsi)
lea    0x1(%rcx),%edx
mov    %dx,0x1c(%rdi)
mov    %dx,0x4(%rsi)
je     20 <DISxIssueEntityID+0x20>
repz retq 
xor    %edx,%edx
mov    %dx,0x18(%rdi)
retq   
<<<sep_in_sample>>>
DISxIssueEntityID(DISxApplicationInfo * info, dis_entity_id * e)
{
 e->sim_id = info->id;
 e->entity_id = ++info->last_entity;
 if (info->last_event == 0xfffe) {
  info->last_event = 0;
 }
 return e;
}
<<<sep_in_sample>>>
1 4
2 3
3 2
4 5
5 3
6 4
7 4
8 4
9 5
10 9
11 6
12 6
13 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <getViewerCount+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getViewerCount(void)
{
 return vl_count;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    %edi,-0xc(%rsp)
mov    %rsi,0x0(%rip)        # 90b <osip_trace_initialize_func+0xb>
movd   -0xc(%rsp),%xmm5
movdqa 0x0(%rip),%xmm2        # 919 <osip_trace_initialize_func+0x19>
pshufd $0x0,%xmm5,%xmm0
movdqa 0x0(%rip),%xmm1        # 926 <osip_trace_initialize_func+0x26>
psubd  %xmm2,%xmm0
movdqa %xmm0,%xmm4
psubd  %xmm2,%xmm1
movdqa 0x0(%rip),%xmm3        # 93a <osip_trace_initialize_func+0x3a>
pcmpgtd %xmm1,%xmm4
movdqa %xmm4,%xmm1
pand   %xmm3,%xmm1
movdqa %xmm1,0x0(%rip)        # 94e <osip_trace_initialize_func+0x4e>
movdqa 0x0(%rip),%xmm1        # 956 <osip_trace_initialize_func+0x56>
psubd  %xmm2,%xmm1
pcmpgtd %xmm1,%xmm0
pand   %xmm3,%xmm0
movdqa %xmm0,0x0(%rip)        # 96a <osip_trace_initialize_func+0x6a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_trace_initialize_func (osip_trace_level_t level, osip_trace_func_t * func)
{
  int i = 0;
  trace_func = func;
  while (i < END_TRACE_LEVEL) {
    if (i < level)
      tracing_table[i] = 1;
    else
      tracing_table[i] = 0;
    i++;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 1a1b <config_help+0xb>
xor    %esi,%esi
mov    $0x0,%edi
callq  1a27 <config_help+0x17>
mov    0x0(%rip),%rcx        # 1a2e <config_help+0x1e>
xor    %edx,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   1a43 <config_help+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
config_help()
{
 static char docstring[] =
  "Configuration file structure for direvent.\n" "For more information, use `info direvent configuration'."
                                                                ;
 grecs_print_docstring(docstring, 0, stdout);
 grecs_print_statement_array(direvent_kw, 1, 0, stdout);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 7
7 7
8 7
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    (%rdi),%r14
mov    0x18(%rdi),%r12
mov    0x8(%rdi),%rbp
mov    0x10(%rdi),%r15
test   %r14,%r14
fldt   (%r12)
je     75 <gsl_matrix_long_double_max+0x75>
shl    $0x4,%r15
xor    %r13d,%r13d
mov    %r15,0x38(%rsp)
test   %rbp,%rbp
je     88 <gsl_matrix_long_double_max+0x88>
mov    %r12,%rbx
xor    %r15d,%r15d
jmp    53 <gsl_matrix_long_double_max+0x53>
nop
fstp   %st(0)
add    $0x1,%r15
add    $0x10,%rbx
cmp    %rbp,%r15
fldt   0x20(%rsp)
je     88 <gsl_matrix_long_double_max+0x88>
fldt   (%rbx)
fucomi %st(1),%st
fxch   %st(1)
fcmovnbe %st(1),%st
fstpt  0x20(%rsp)
fld    %st(0)
fstpt  (%rsp)
fstpt  0x10(%rsp)
callq  6d <gsl_matrix_long_double_max+0x6d>
test   %eax,%eax
fldt   0x10(%rsp)
je     40 <gsl_matrix_long_double_max+0x40>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x1,%r13
add    0x38(%rsp),%r12
cmp    %r14,%r13
jne    32 <gsl_matrix_long_double_max+0x32>
jmp    75 <gsl_matrix_long_double_max+0x75>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_max (const gsl_matrix_long_double * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long double max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long double x = m->data[i * tda + j];
          if (x > max)
            max = x;
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            return x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 4
11 5
12 8
13 6
14 8
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 12
34 12
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 8
52 8
53 8
54 8
55 8
56 8
<<<sep_out_sample>>>
push   %r12
mov    $0x11da,%edx
mov    %esi,%r12d
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
mov    $0x28,%edi
push   %rbx
callq  b1de <new_var_context+0x1e>
mov    %rax,%rbx
xor    %eax,%eax
test   %rbp,%rbp
je     b20e <new_var_context+0x4e>
mov    %rbp,%rdi
callq  b1f0 <new_var_context+0x30>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x11db,%edx
callq  b203 <new_var_context+0x43>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  b20e <new_var_context+0x4e>
mov    %rax,(%rbx)
mov    0x0(%rip),%eax        # b217 <new_var_context+0x57>
mov    %r12d,0xc(%rbx)
movq   $0x0,0x18(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x20(%rbx)
mov    %eax,0x8(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
new_var_context (name, flags)
     char *name;
     int flags;
{
  VAR_CONTEXT *vc;
  vc = (VAR_CONTEXT *)sh_xmalloc((sizeof (VAR_CONTEXT)), "variables.c", 4570);
  vc->name = name ? (char *)strcpy (sh_xmalloc((1 + strlen (name)), "variables.c", 4571), (name)) : (char *)((void *)0);
  vc->scope = variable_context;
  vc->flags = flags;
  vc->up = vc->down = (VAR_CONTEXT *)((void *)0);
  vc->table = (HASH_TABLE *)((void *)0);
  return vc;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 4
7 6
8 4
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 9
26 10
27 10
28 11
29 8
30 13
31 13
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x20(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_nx_add (gl_oset_t set, const void *elt)
{
  return ((const struct gl_oset_impl_base *) set)->vtable->nx_add (set, elt);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
cmp    $0x1c,%edi
ja     20 <gdbm_strerror+0x20>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rsi
mov    $0x0,%edi
jmpq   1a <gdbm_strerror+0x1a>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   2f <gdbm_strerror+0x2f>
<<<sep_in_sample>>>
gdbm_strerror (gdbm_error error)
{
  if (((int)error < 0) || ((int)error > 28))
    {
      return dgettext ("gdbm", "Unknown error");
    }
  else
    {
      return dgettext ("gdbm", gdbm_errlist[(int)error]);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 9
5 9
6 9
7 9
8 5
9 5
10 5
<<<sep_out_sample>>>
mov    0x5f0(%rdi),%rdi
jmpq   b40c <macro_meta_sequence_get+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
macro_meta_sequence_get (struct a2ps_job * job, const char * key)
{
  return pair_get (job->macro_meta_sequences, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
test   %r8,%r8
je     be <gsl_stats_wmean+0x5e>
fldz   
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
shl    $0x3,%rcx
xor    %eax,%eax
fld    %st(0)
nopw   0x0(%rax,%rax,1)
movsd  (%rdi),%xmm0
ucomisd %xmm1,%xmm0
jbe    a2 <gsl_stats_wmean+0x42>
movsd  %xmm0,-0x18(%rsp)
fldl   -0x18(%rsp)
fadd   %st,%st(1)
fld    %st(2)
fsubrl (%rdx)
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    80 <gsl_stats_wmean+0x20>
fstp   %st(0)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wmean (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t size)
{
  long double wmean = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      double wi = w[i * wstride];
      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 4
5 4
6 12
7 6
8 4
9 4
10 8
11 9
12 9
13 11
14 11
15 11
16 12
17 12
18 12
19 12
20 12
21 12
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 16
33 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  69e <sh_notbuiltin+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   6ac <sh_notbuiltin+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_notbuiltin (s)
     char *s;
{
  builtin_error (gettext("%s: not a shell builtin"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
jmpq   55 <crlf+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 10d7 <yy_grecsset_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecsset_in (FILE * in_str )
{
        yy_grecsin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
push   %r13
mov    %rcx,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
mov    %rdx,0x18(%rsp)
callq  35 <argmatch+0x25>
mov    (%r15),%r14
test   %r14,%r14
je     162 <argmatch+0x152>
xor    %ebx,%ebx
test   %rbp,%rbp
mov    %rax,%r12
movb   $0x0,0x17(%rsp)
movq   $0xffffffffffffffff,0x8(%rsp)
jne    97 <argmatch+0x87>
jmpq   11a <argmatch+0x10a>
xchg   %ax,%ax
imul   %r13,%rdi
mov    %r13,%rdx
mov    %rbp,%rsi
add    0x18(%rsp),%rdi
callq  74 <argmatch+0x64>
test   %eax,%eax
movzbl 0x17(%rsp),%eax
mov    $0x1,%ecx
cmovne %ecx,%eax
mov    %al,0x17(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  a6 <argmatch+0x96>
test   %eax,%eax
jne    87 <argmatch+0x77>
mov    %r14,%rdi
callq  b2 <argmatch+0xa2>
cmp    %r12,%rax
je     150 <argmatch+0x140>
mov    0x8(%rsp),%rdi
cmp    $0xffffffffffffffff,%rdi
jne    60 <argmatch+0x50>
mov    %rbx,0x8(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
jne    97 <argmatch+0x87>
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x17(%rsp)
mov    $0xfffffffffffffffe,%rax
jne    f3 <argmatch+0xe3>
mov    0x8(%rsp),%rax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
movb   $0x1,0x17(%rsp)
add    $0x1,%rbx
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  129 <argmatch+0x119>
test   %eax,%eax
jne    10d <argmatch+0xfd>
mov    %r14,%rdi
callq  135 <argmatch+0x125>
cmp    %r12,%rax
je     150 <argmatch+0x140>
cmpq   $0xffffffffffffffff,0x8(%rsp)
jne    108 <argmatch+0xf8>
mov    %rbx,0x8(%rsp)
jmp    10d <argmatch+0xfd>
nopl   0x0(%rax)
add    $0x28,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
movq   $0xffffffffffffffff,0x8(%rsp)
jmp    ee <argmatch+0xde>
nopl   (%rax)
<<<sep_in_sample>>>
argmatch (const char *arg, const char *const *arglist,
          const char *vallist, size_t valsize)
{
  size_t i;
  size_t arglen;
  ptrdiff_t matchind = -1;
  _Bool ambiguous = 0;
  arglen = strlen (arg);
  for (i = 0; arglist[i]; i++)
    {
      if (!strncmp (arglist[i], arg, arglen))
        {
          if (strlen (arglist[i]) == arglen)
            return i;
          else if (matchind == -1)
            matchind = i;
          else
            {
              if (vallist == ((void *)0)
                  || memcmp (vallist + valsize * matchind,
                             vallist + valsize * i, valsize))
                {
                  ambiguous = 1;
                }
            }
        }
    }
  if (ambiguous)
    return -2;
  else
    return matchind;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 7
21 6
22 6
23 6
24 6
25 20
26 20
27 20
28 20
29 20
30 23
31 23
32 23
33 23
34 23
35 9
36 9
37 9
38 9
39 9
40 11
41 11
42 11
43 11
44 11
45 11
46 13
47 13
48 13
49 13
50 15
51 15
52 15
53 16
54 9
55 9
56 9
57 9
58 9
59 9
60 28
61 29
62 28
63 31
64 32
65 32
66 32
67 32
68 32
69 32
70 32
71 32
72 32
73 23
74 9
75 9
76 9
77 9
78 11
79 11
80 11
81 11
82 11
83 11
84 13
85 13
86 13
87 13
88 15
89 15
90 16
91 16
92 16
93 32
94 14
95 32
96 32
97 32
98 32
99 32
100 32
101 32
102 6
103 6
104 6
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_int_data (const gsl_block_int * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
lea    0x28(%rdi),%rsi
mov    %r8,(%rsp)
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 29 <nettle_ccm_aes192_set_nonce+0x19>
mov    %r9,0x8(%rsp)
mov    %rcx,%r9
mov    %rax,%rcx
callq  39 <nettle_ccm_aes192_set_nonce+0x29>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
nettle_ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx, size_t length, const uint8_t *nonce,
       size_t authlen, size_t msglen, size_t taglen)
{
  nettle_ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes192_encrypt,
  length, nonce, authlen, msglen, taglen);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 125a <gsl_matrix_int_const_ptr+0xa>
test   %eax,%eax
je     1269 <gsl_matrix_int_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1280 <gsl_matrix_int_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    12a0 <gsl_matrix_int_const_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,4),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1299 <gsl_matrix_int_const_ptr+0x49>
xor    %eax,%eax
jmp    1279 <gsl_matrix_int_const_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12b9 <gsl_matrix_int_const_ptr+0x69>
xor    %eax,%eax
jmp    1279 <gsl_matrix_int_const_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_int_const_ptr(const gsl_matrix_int * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_int.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_int.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const int *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  26d2 <rec_sex_compile+0x12>
test   %al,%al
mov    %eax,%ebx
je     26e5 <rec_sex_compile+0x25>
mov    0x8(%rbp),%rdi
callq  26e1 <rec_sex_compile+0x21>
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
rec_sex_compile (rec_sex_t sex,
                 const char *expr)
{
  _Bool res;
  res = rec_sex_parser_run (sex->parser, expr);
  if (res)
    {
      sex->ast = rec_sex_parser_ast (sex->parser);
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 6
8 5
9 6
10 8
11 8
12 8
13 11
14 11
15 11
16 11
17 11
18 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,0x18(%rdi)
mov    0x20(%rdi),%rdi
mov    %rsi,%rdx
test   %rdi,%rdi
je     b65 <rec_record_set_location+0x25>
callq  b59 <rec_record_set_location+0x19>
mov    0x18(%rbx),%rdx
movq   $0x0,0x20(%rbx)
lea    0x20(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
pop    %rbx
jmpq   b76 <rec_record_set_location+0x36>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_set_location (rec_record_t record,
                         size_t location)
{
  record->location = location;
  if (record->location_str)
    {
      free (record->location_str);
      record->location_str = ((void *)0);
    }
  rpl_asprintf (&(record->location_str), "%zu", record->location);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 10
12 10
13 10
14 11
15 10
16 10
<<<sep_out_sample>>>
push   %r12
xor    %eax,%eax
cmp    $0x1ff,%rcx
mov    %rdx,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
ja     2d6 <dir_reader+0x26>
jmp    2ea <dir_reader+0x3a>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2e,0x13(%rax)
jne    2f0 <dir_reader+0x40>
mov    %rbx,%rdi
callq  2de <dir_reader+0x2e>
test   %rax,%rax
jne    2d0 <dir_reader+0x20>
mov    $0xffffffffffffffff,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
lea    0x13(%rax),%rcx
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x0,%edx
xor    %eax,%eax
mov    %rcx,%r8
callq  309 <dir_reader+0x59>
pop    %rbx
pop    %rbp
cltq   
pop    %r12
retq   
<<<sep_in_sample>>>
dir_reader (void *cls, uint64_t pos, char *buf, size_t max)
{
  DIR *dir = cls;
  struct dirent *e;
  if (max < 512)
    return 0;
  do
    {
      e = readdir (dir);
      if (e == ((void *)0))
        return (18446744073709551615UL);
  } while (e->d_name[0] == '.');
  return snprintf (buf, max,
     "<a href=\"/%s\">%s</a><br>",
     e->d_name,
     e->d_name);
}
<<<sep_in_sample>>>
1 2
2 6
3 5
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 12
13 12
14 9
15 9
16 10
17 10
18 11
19 17
20 17
21 17
22 17
23 17
24 15
25 13
26 13
27 13
28 13
29 13
30 13
31 17
32 17
33 13
34 17
35 17
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    $0xffffffffffffffff,%rdx
mov    %esi,%ecx
shr    $0x6,%rax
shl    %cl,%rdx
lea    (%rdi,%rax,8),%r8
and    (%r8),%rdx
lea    0x8(%r8),%rax
jne    2d <__gmpn_scan1+0x2d>
add    $0x8,%rax
mov    -0x8(%rax),%rdx
test   %rdx,%rdx
je     20 <__gmpn_scan1+0x20>
bsf    %rdx,%rdx
sub    %rdi,%rax
movslq %edx,%rdx
lea    -0x40(%rdx,%rax,8),%rax
retq   
<<<sep_in_sample>>>
__gmpn_scan1 (mp_srcptr up, mp_bitcnt_t starting_bit)
{
  mp_size_t starting_word;
  mp_limb_t alimb;
  int cnt;
  mp_srcptr p;
  starting_word = starting_bit / (64 - 0);
  p = up + starting_word;
  alimb = *p++;
  alimb &= - (mp_limb_t) 1 << (starting_bit % (64 - 0));
  while (alimb == 0)
    alimb = *p++;
  do { do {} while (0); __asm__ ("bsfq %1,%q0" : "=r" (cnt) : "rm" ((UDItype)(alimb))); } while (0);
  return (p - up - 1) * (64 - 0) + cnt;
}
<<<sep_in_sample>>>
1 7
2 10
3 10
4 7
5 10
6 8
7 11
8 9
9 11
10 12
11 12
12 11
13 11
14 13
15 14
16 14
17 14
18 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  719 <anubis_child_main+0x9>
mov    0x0(%rip),%eax        # 71f <anubis_child_main+0xf>
test   %eax,%eax
je     758 <anubis_child_main+0x48>
cmp    $0x3,%eax
jne    750 <anubis_child_main+0x40>
mov    %rbx,%rdi
callq  730 <anubis_child_main+0x20>
mov    %eax,%ebx
mov    $0x0,%edi
callq  73c <anubis_child_main+0x2c>
mov    $0x0,%edi
callq  746 <anubis_child_main+0x36>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
callq  755 <anubis_child_main+0x45>
nopl   (%rax)
mov    %rbx,%rdi
callq  760 <anubis_child_main+0x50>
mov    %eax,%ebx
jmp    732 <anubis_child_main+0x22>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
anubis_child_main (struct sockaddr_in *addr)
{
  int rc;
  proclist_init ();
  switch (anubis_mode)
    {
    case anubis_transparent:
      rc = anubis_transparent_mode (addr);
      break;
    case anubis_proxy:
      rc = anubis_proxy_mode (addr);
      break;
    default:
      abort();
    }
  proclist_cleanup (subprocess_report_status);
  net_close_stream (&remote_client);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 5
7 5
8 5
9 11
10 11
11 11
12 16
13 16
14 17
15 17
16 19
17 19
18 19
19 19
20 14
21 14
22 8
23 8
24 8
25 9
26 9
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1230 <gsl_vector_ulong_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1225 <gsl_vector_ulong_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1265 <gsl_vector_ulong_add+0x65>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%rsi
add    %r9,%rcx
add    %rsi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1250 <gsl_vector_ulong_add+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_add (gsl_vector_ulong * a, const gsl_vector_ulong * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     c2 <mu_refcount_destroy+0x32>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     c2 <mu_refcount_destroy+0x32>
lea    0x8(%rbx),%rdi
mov    %rbx,%rsi
callq  b2 <mu_refcount_destroy+0x22>
mov    %rbx,%rdi
callq  ba <mu_refcount_destroy+0x2a>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_refcount_destroy (mu_refcount_t *prefcount)
{
  if (prefcount && *prefcount)
    {
      mu_refcount_t refcount = *prefcount;
      mu_monitor_destroy (&refcount->lock, refcount);
      free (refcount);
      *prefcount = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 6
13 7
14 7
15 8
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edx
mov    $0x100,%esi
mov    $0x180,%edi
callq  15 <utmp_init+0x15>
mov    %rax,0x0(%rip)        # 1c <utmp_init+0x1c>
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
utmp_init(int backwards)
{
  utmp_info = file_reader_init(sizeof (struct utmp), 256,
                               backwards);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 5
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm5        # 8 <gsl_expm1+0x8>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm2        # 14 <gsl_expm1+0x14>
andpd  %xmm5,%xmm1
ucomisd %xmm1,%xmm2
jbe    78 <gsl_expm1+0x78>
movsd  0x0(%rip),%xmm7        # 26 <gsl_expm1+0x26>
movapd %xmm0,%xmm1
movapd %xmm0,%xmm3
movapd %xmm7,%xmm4
movsd  0x0(%rip),%xmm8        # 3b <gsl_expm1+0x3b>
nopl   0x0(%rax,%rax,1)
addsd  %xmm7,%xmm4
movapd %xmm0,%xmm2
divsd  %xmm4,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm3
movapd %xmm1,%xmm6
andpd  %xmm5,%xmm6
movapd %xmm3,%xmm2
andpd  %xmm5,%xmm2
mulsd  %xmm8,%xmm2
ucomisd %xmm2,%xmm6
ja     40 <gsl_expm1+0x40>
movapd %xmm3,%xmm0
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
callq  81 <gsl_expm1+0x81>
subsd  0x0(%rip),%xmm0        # 89 <gsl_expm1+0x89>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_expm1 (const double x)
{
  if (fabs(x) < 0.69314718055994530942)
    {
      double i = 1.0;
      double sum = x;
      double term = x / 1.0;
      do
        {
          i++ ;
          term *= x/i;
          sum += term;
        }
      while (fabs(term) > fabs(sum) * 2.2204460492503131e-16) ;
      return sum ;
    }
  else
    {
      return exp(x) - 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 10
14 11
15 11
16 11
17 12
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 12
26 12
27 12
28 2
29 19
30 19
31 21
32 21
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x10(%rdi),%r9
mov    0x8(%rdi),%r11
test   %r10,%r10
mov    (%r9),%rcx
je     ca4 <gsl_vector_ulong_minmax+0x44>
shl    $0x3,%r11
mov    %rcx,%rdi
xor    %r8d,%r8d
nopl   (%rax)
mov    (%r9),%rax
cmp    %rax,%rdi
cmova  %rax,%rdi
cmp    %rax,%rcx
cmovb  %rax,%rcx
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
jne    c80 <gsl_vector_ulong_minmax+0x20>
mov    %rdi,(%rsi)
mov    %rcx,(%rdx)
retq   
mov    %rcx,%rdi
jmp    c9d <gsl_vector_ulong_minmax+0x3d>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ulong_minmax (const gsl_vector_ulong * v,
                             unsigned long * min_out,
                             unsigned long * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned long max = v->data[0 * stride];
  unsigned long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 7
3 6
4 10
5 7
6 10
7 10
8 8
9 10
10 10
11 12
12 12
13 12
14 12
15 12
16 10
17 10
18 10
19 10
20 22
21 23
22 23
23 8
24 8
25 8
<<<sep_out_sample>>>
mov    %edi,%eax
not    %eax
shr    $0x1f,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_normed_time (n_time t)
{
  return (t & (1UL << 31)) ? 0 : 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     16b0 <gsl_vector_ulong_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  16cf <gsl_vector_ulong_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_ulong_const_view_array (const unsigned long * base, size_t n)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = (unsigned long *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    %r8,0x8(%rdi)
cmovbe 0x8(%rdi),%r8
mov    0x10(%rdi),%rax
xor    %edx,%edx
lea    0x1(%rax),%r9
xor    %eax,%eax
test   %r8,%r8
je     8055 <gsl_matrix_uchar_add_diagonal+0x45>
nopl   (%rax)
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
add    $0x1,%rax
add    %r9,%rdx
cmp    %r8,%rax
movzbl (%rcx),%esi
cvtsi2sd %esi,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%esi
mov    %sil,(%rcx)
jne    8030 <gsl_matrix_uchar_add_diagonal+0x20>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_add_diagonal (gsl_matrix_uchar * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 10
13 8
14 8
15 8
16 10
17 10
18 10
19 10
20 10
21 8
22 13
23 13
24 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     3740 <gsl_matrix_ulong_add+0x50>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3723 <gsl_matrix_ulong_add+0x33>
mov    $0x13,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsi),%r9
cmp    %rax,%r9
jne    370a <gsl_matrix_ulong_add+0x1a>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rbx
test   %r10,%r10
mov    %rax,(%rsp)
mov    %rbx,0x8(%rsp)
je     3838 <gsl_matrix_ulong_add+0x148>
shl    $0x3,%rax
xor    %edx,%edx
mov    %r10,0x20(%rsp)
mov    %rax,0x10(%rsp)
lea    0x0(,%rbx,8),%rax
xor    %r13d,%r13d
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rax,0x18(%rsp)
mov    %r9,%rax
mov    %rdx,%r10
shr    %rax
mov    %rdi,0x28(%rsp)
lea    (%rax,%rax,1),%r14
mov    %rax,%r12
nop
test   %r9,%r9
je     3816 <gsl_matrix_ulong_add+0x126>
mov    0x28(%rsp),%rax
mov    0x18(%rsi),%r15
mov    0x18(%rax),%r8
lea    (%r15,%rbp,1),%rdi
lea    0x10(%rdi),%rax
lea    (%r8,%rbx,1),%rdx
cmp    %rax,%rdx
lea    0x10(%rdx),%rax
setae  %cl
cmp    %rax,%rdi
setae  %al
or     %al,%cl
je     3840 <gsl_matrix_ulong_add+0x150>
cmp    $0x13,%r9
jbe    3840 <gsl_matrix_ulong_add+0x150>
test   %r14,%r14
je     3806 <gsl_matrix_ulong_add+0x116>
xor    %eax,%eax
xor    %ecx,%ecx
movdqu (%rdi,%rax,1),%xmm1
add    $0x1,%rcx
movdqu (%rdx,%rax,1),%xmm0
paddq  %xmm1,%xmm0
movdqu %xmm0,(%rdx,%rax,1)
add    $0x10,%rax
cmp    %rcx,%r12
ja     37e1 <gsl_matrix_ulong_add+0xf1>
cmp    %r9,%r14
je     3816 <gsl_matrix_ulong_add+0x126>
lea    (%r14,%r10,1),%rax
lea    (%r14,%r13,1),%rdx
mov    (%r15,%rdx,8),%rdx
add    %rdx,(%r8,%rax,8)
add    $0x1,%r11
add    0x10(%rsp),%rbx
add    0x18(%rsp),%rbp
add    (%rsp),%r10
add    0x8(%rsp),%r13
cmp    0x20(%rsp),%r11
jne    37a0 <gsl_matrix_ulong_add+0xb0>
xor    %eax,%eax
jmpq   3728 <gsl_matrix_ulong_add+0x38>
nop
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%rdi,%rax,8),%rcx
add    %rcx,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r9,%rax
jne    3848 <gsl_matrix_ulong_add+0x158>
jmp    3816 <gsl_matrix_ulong_add+0x126>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_add (gsl_matrix_ulong * a, const gsl_matrix_ulong * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 28, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 4
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 23
19 23
20 23
21 23
22 23
23 23
24 23
25 23
26 23
27 5
28 5
29 5
30 11
31 12
32 14
33 11
34 12
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 16
54 16
55 16
56 16
57 16
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 16
66 16
67 16
68 16
69 16
70 16
71 16
72 16
73 16
74 18
75 18
76 18
77 18
78 18
79 18
80 18
81 18
82 18
83 18
84 18
85 18
86 18
87 18
88 14
89 14
90 14
91 14
92 14
93 14
94 14
95 21
96 21
97 21
98 16
99 16
100 18
101 18
102 16
103 16
104 16
105 16
106 16
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
movslq (%rdi),%rsi
mov    0x0(%rip),%rax        # a <__gmpz_clear+0xa>
mov    0x8(%rdi),%rdi
shl    $0x3,%rsi
jmpq   *%rax
<<<sep_in_sample>>>
__gmpz_clear (mpz_ptr x)
{
  (*__gmp_free_func) (((x)->_mp_d), (((x)->_mp_alloc)) * sizeof (mp_limb_t));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 76 <alloc_word_desc+0x6>
test   %eax,%eax
jle    a0 <alloc_word_desc+0x30>
mov    0x0(%rip),%rdx        # 81 <alloc_word_desc+0x11>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 8a <alloc_word_desc+0x1a>
cltq   
mov    (%rdx,%rax,8),%rax
movl   $0x0,0x8(%rax)
movq   $0x0,(%rax)
retq   
nop
sub    $0x8,%rsp
mov    $0x58,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  b8 <alloc_word_desc+0x48>
movl   $0x0,0x8(%rax)
movq   $0x0,(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alloc_word_desc ()
{
  WORD_DESC *temp;
  do { if ((wdcache).nc > 0) { (temp) = (WORD_DESC *)((WORD_DESC **)((wdcache).data))[--(wdcache).nc]; } else (temp) = (WORD_DESC *)sh_xmalloc((sizeof (WORD_DESC)), "make_cmd.c", 88); } while (0);
  temp->flags = 0;
  temp->word = 0;
  return temp;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 8
12 8
13 2
14 4
15 4
16 4
17 4
18 5
19 6
20 8
21 8
22 8
<<<sep_out_sample>>>
test   %rdx,%rdx
movzwl (%rdi),%eax
je     1e18 <gsl_stats_short_min+0x118>
push   %r15
mov    %rdx,%r11
lea    (%rsi,%rsi,1),%r8
shr    $0x3,%r11
push   %r14
lea    0x0(,%r11,8),%rcx
push   %r13
test   %rcx,%rcx
push   %r12
push   %rbp
push   %rbx
je     1e20 <gsl_stats_short_min+0x120>
cmp    $0x24,%rdx
jbe    1e20 <gsl_stats_short_min+0x120>
movd   %eax,%xmm0
mov    %rsi,%rbx
mov    %r8,%r13
shl    $0x4,%rbx
lea    (%rdi,%r8,1),%r9
lea    (%r8,%rsi,8),%r15
punpcklwd %xmm0,%xmm0
mov    %rbx,-0x10(%rsp)
lea    (%r8,%rsi,4),%rbx
xor    %r10d,%r10d
neg    %r13
pshufd $0x0,%xmm0,%xmm0
lea    (%rbx,%rbx,1),%r14
movzwl (%r9,%r8,2),%esi
movzwl (%r9,%r8,1),%eax
add    $0x1,%r10
movzwl (%r9,%r15,1),%ebp
movzwl (%r9,%r13,1),%r12d
shl    $0x10,%rsi
or     %rax,%rsi
movzwl (%r9),%eax
shl    $0x10,%rsi
or     %rax,%rsi
movzwl (%r9,%r14,1),%eax
shl    $0x10,%rsi
or     %r12,%rsi
mov    %rsi,-0x28(%rsp)
shl    $0x10,%rax
or     %rbp,%rax
movzwl (%r9,%r8,4),%ebp
shl    $0x10,%rax
or     %rbp,%rax
movzwl (%r9,%rbx,1),%ebp
add    -0x10(%rsp),%r9
shl    $0x10,%rax
or     %rbp,%rax
cmp    %r10,%r11
mov    %rax,-0x20(%rsp)
pminsw -0x28(%rsp),%xmm0
ja     1d6e <gsl_stats_short_min+0x6e>
movdqa %xmm0,%xmm2
cmp    %rcx,%rdx
psrldq $0x8,%xmm2
pminsw %xmm2,%xmm0
movdqa %xmm0,%xmm3
psrldq $0x4,%xmm3
pminsw %xmm3,%xmm0
movdqa %xmm0,%xmm4
psrldq $0x2,%xmm4
pminsw %xmm4,%xmm0
pextrw $0x0,%xmm0,%eax
jne    1e22 <gsl_stats_short_min+0x122>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
repz retq 
nopw   0x0(%rax,%rax,1)
xor    %ecx,%ecx
mov    %rcx,%rsi
imul   %r8,%rsi
add    %rsi,%rdi
nopl   0x0(%rax)
movzwl (%rdi),%esi
cmp    %si,%ax
cmovg  %esi,%eax
add    $0x1,%rcx
add    %r8,%rdi
cmp    %rdx,%rcx
jb     1e30 <gsl_stats_short_min+0x130>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmp    1e18 <gsl_stats_short_min+0x118>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_short_min (const short data[], const size_t stride,
                          const size_t n)
{
  short min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      short xi = data[i * stride];
      if (xi < min)
        min = xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 6
28 6
29 6
30 6
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 8
50 8
51 8
52 8
53 8
54 8
55 8
56 8
57 8
58 8
59 8
60 8
61 8
62 8
63 8
64 8
65 8
66 8
67 8
68 8
69 8
70 13
71 13
72 13
73 13
74 13
75 13
76 13
77 13
78 6
79 6
80 6
81 6
82 6
83 8
84 8
85 8
86 6
87 6
88 6
89 6
90 13
91 13
92 13
93 13
94 13
95 13
96 13
97 13
<<<sep_out_sample>>>
test   %rdx,%rdx
je     318 <gsl_stats_ushort_mean+0x58>
add    %rsi,%rsi
xor    %eax,%eax
fldz   
jmp    2dc <gsl_stats_ushort_mean+0x1c>
xchg   %ax,%ax
fdivrp %st,%st(1)
add    %rsi,%rdi
cmp    %rdx,%rax
faddp  %st,%st(1)
je     30d <gsl_stats_ushort_mean+0x4d>
movzwl (%rdi),%ecx
add    $0x1,%rax
mov    %rax,-0x20(%rsp)
test   %rax,%rax
mov    %ecx,-0x14(%rsp)
fildl  -0x14(%rsp)
fsub   %st(1),%st
fildll -0x20(%rsp)
jns    2d0 <gsl_stats_ushort_mean+0x10>
add    %rsi,%rdi
cmp    %rdx,%rax
fadds  0x0(%rip)        # 307 <gsl_stats_ushort_mean+0x47>
fdivrp %st,%st(1)
faddp  %st,%st(1)
jne    2dc <gsl_stats_ushort_mean+0x1c>
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_mean (const unsigned short data[], const size_t stride, const size_t size)
{
  long double mean = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      mean += (data[i * stride] - mean) / (i + 1);
    }
  return mean;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 3
6 3
7 3
8 7
9 7
10 5
11 7
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 5
24 7
25 7
26 7
27 5
28 5
29 5
30 5
31 5
32 10
33 10
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 7 <SetJoystickPort+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
SetJoystickPort (char * name)
{
    joystick_port = name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 326 <gsl_vector_set+0x6>
test   %eax,%eax
je     32f <gsl_vector_set+0xf>
cmp    %rsi,(%rdi)
jbe    348 <gsl_vector_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rdx
shl    $0x3,%rax
imul   %rsi,%rax
movsd  %xmm0,(%rdx,%rax,1)
retq   
nopl   (%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   361 <gsl_vector_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_set (gsl_vector * v, const size_t i, double x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_double.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%esi
mov    $0x0,%esi
sbb    %edi,%edi
xor    %eax,%eax
and    $0xfffffffc,%edi
add    $0x7,%edi
callq  1b <mu_debug_syslog_printer+0x1b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_debug_syslog_printer (void *unused, mu_log_level_t level, const char *str)
{
  syslog ((level == 0) ? 3 : 7, "%s", str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
sub    $0x28,%rsp
xorpd  %xmm0,%xmm0
ucomisd %xmm0,%xmm3
jnp    128 <gsl_cdf_gumbel2_Qinv+0x88>
ucomisd 0x0(%rip),%xmm3        # ba <gsl_cdf_gumbel2_Qinv+0x1a>
jp     c8 <gsl_cdf_gumbel2_Qinv+0x28>
jne    c8 <gsl_cdf_gumbel2_Qinv+0x28>
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm4        # d0 <gsl_cdf_gumbel2_Qinv+0x30>
movsd  %xmm2,0x18(%rsp)
xorpd  %xmm4,%xmm3
movsd  %xmm1,0x10(%rsp)
movapd %xmm4,(%rsp)
movapd %xmm3,%xmm0
callq  ee <gsl_cdf_gumbel2_Qinv+0x4e>
movapd (%rsp),%xmm4
xorpd  %xmm4,%xmm0
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm2
movsd  0x0(%rip),%xmm5        # 10b <gsl_cdf_gumbel2_Qinv+0x6b>
add    $0x28,%rsp
divsd  %xmm0,%xmm2
divsd  %xmm1,%xmm5
movapd %xmm2,%xmm0
movapd %xmm5,%xmm1
jmpq   124 <gsl_cdf_gumbel2_Qinv+0x84>
nopl   0x0(%rax)
jne    b2 <gsl_cdf_gumbel2_Qinv+0x12>
movsd  0x0(%rip),%xmm0        # 132 <gsl_cdf_gumbel2_Qinv+0x92>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel2_Qinv (const double Q, const double a, const double b)
{
  double x;
  if (Q == 0.0)
    {
      return (__builtin_inff());
    }
  else if (Q == 1.0)
    {
      return 0.0;
    }
  x = pow(b / (-log1p(-Q)), 1/a);
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 8
7 8
8 8
9 14
10 14
11 14
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 14
25 12
26 12
27 12
28 12
29 12
30 12
31 4
32 6
33 14
34 14
<<<sep_out_sample>>>
sub    $0xe8,%rsp
test   %al,%al
mov    %rdi,0x8(%rsp)
mov    %rdx,0x40(%rsp)
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
je     5e <__gmp_sprintf+0x5e>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rdx
lea    0x18(%rsp),%rcx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
movl   $0x10,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
mov    %rax,0x28(%rsp)
callq  9c <__gmp_sprintf+0x9c>
add    $0xe8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_sprintf (char *buf, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doprnt (&__gmp_sprintf_funs, &buf, fmt, ap);
  __builtin_va_end(ap);
  do {} while (0);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 2
19 6
20 6
21 6
22 5
23 5
24 5
25 5
26 5
27 6
28 10
29 10
<<<sep_out_sample>>>
mov    %rsi,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rax
xor    %rsi,%rax
sub    %rdx,%rax
je     2e <__gmpz_limbs_finish+0x2e>
mov    0x8(%rdi),%rdx
cmpq   $0x0,-0x8(%rdx,%rax,8)
je     28 <__gmpz_limbs_finish+0x28>
jmp    2e <__gmpz_limbs_finish+0x2e>
cmpq   $0x0,-0x8(%rdx,%rax,8)
jne    2e <__gmpz_limbs_finish+0x2e>
sub    $0x1,%rax
jne    20 <__gmpz_limbs_finish+0x20>
mov    %eax,%edx
neg    %edx
test   %rsi,%rsi
cmovs  %edx,%eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_limbs_finish (mpz_ptr x, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((((x)->_mp_d))[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdi),%rax
mov    %rsi,%r10
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %r10,%rdx
callq  *0x18(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_step_apply(
  gsl_odeiv_step * s,
  double t,
  double h,
  double y[],
  double yerr[],
  const double dydt_in[],
  double dydt_out[],
  const gsl_odeiv_system * dydt)
{
  return s->type->apply(s->state, s->dimension, t, h, y, yerr, dydt_in, dydt_out, dydt);
}
<<<sep_in_sample>>>
1 10
2 11
3 10
4 11
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 12
13 12
14 12
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %esi,%r13d
push   %r12
mov    %edi,%r12d
push   %rbp
push   %rbx
sub    $0x40e0,%rsp
test   %al,%al
mov    %rcx,0x4048(%rsp)
mov    %r8,0x4050(%rsp)
mov    %r9,0x4058(%rsp)
je     b51 <rlogind_error+0x71>
movaps %xmm0,0x4060(%rsp)
movaps %xmm1,0x4070(%rsp)
movaps %xmm2,0x4080(%rsp)
movaps %xmm3,0x4090(%rsp)
movaps %xmm4,0x40a0(%rsp)
movaps %xmm5,0x40b0(%rsp)
movaps %xmm6,0x40c0(%rsp)
movaps %xmm7,0x40d0(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x4028(%rsp)
xor    %eax,%eax
lea    0x4110(%rsp),%rax
lea    0x8(%rsp),%rcx
lea    0x2020(%rsp),%rdi
mov    $0x1fff,%esi
mov    %rax,0x10(%rsp)
lea    0x4030(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  ba5 <rlogind_error+0xc5>
mov    0x0(%rip),%eax        # bab <rlogind_error+0xcb>
test   %eax,%eax
je     c20 <rlogind_error+0x140>
lea    0x20(%rsp),%rbx
test   %r13d,%r13d
mov    $0x2000,%r14d
mov    %rbx,%rbp
jne    c39 <rlogind_error+0x159>
lea    0x2020(%rsp),%rcx
mov    $0x0,%edx
mov    %r14,%rsi
mov    %rbp,%rdi
xor    %eax,%eax
callq  bdc <rlogind_error+0xfc>
mov    %rbp,%rdi
callq  be4 <rlogind_error+0x104>
movslq %eax,%rdx
mov    %rbx,%rsi
mov    %r12d,%edi
add    %rbp,%rdx
sub    %rbx,%rdx
callq  bf8 <rlogind_error+0x118>
mov    0x4028(%rsp),%rax
xor    %fs:0x28,%rax
jne    c67 <rlogind_error+0x187>
add    $0x40e0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
lea    0x20(%rsp),%rbx
test   %r13d,%r13d
movb   $0x1,0x20(%rsp)
mov    $0x1fff,%r14d
lea    0x1(%rbx),%rbp
je     bc2 <rlogind_error+0xe2>
callq  c3e <rlogind_error+0x15e>
mov    (%rax),%edi
callq  c45 <rlogind_error+0x165>
lea    0x2020(%rsp),%rcx
mov    %rax,%r8
mov    $0x0,%edx
mov    %r14,%rsi
mov    %rbp,%rdi
xor    %eax,%eax
callq  c62 <rlogind_error+0x182>
jmpq   bdc <rlogind_error+0xfc>
callq  c6c <rlogind_error+0x18c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rlogind_error (int f, int syserr, const char *msg, ...)
{
  int len;
  char buf[8192], buf2[8192], *bp = buf;
  va_list ap;
  __builtin_va_start(ap,msg);
  vsnprintf (buf2, sizeof (buf2) - 1, msg, ap);
  __builtin_va_end(ap);
  if (!confirmed)
    *bp++ = '\01';
  if (syserr)
    snprintf (bp, sizeof buf - (bp - buf),
       "rlogind: %s: %s.\r\n", buf2, strerror ((*__errno_location ())));
  else
    snprintf (bp, sizeof buf - (bp - buf), "rlogind: %s\r\n", buf2);
  len = strlen (bp);
  write (f, buf, bp + len - buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 2
23 2
24 2
25 6
26 7
27 7
28 7
29 6
30 6
31 6
32 6
33 6
34 7
35 9
36 9
37 9
38 9
39 11
40 9
41 4
42 11
43 15
44 15
45 15
46 15
47 15
48 15
49 16
50 16
51 17
52 17
53 17
54 17
55 17
56 17
57 18
58 18
59 18
60 18
61 18
62 18
63 18
64 18
65 18
66 18
67 18
68 18
69 11
70 10
71 10
72 10
73 11
74 13
75 12
76 12
77 12
78 12
79 12
80 12
81 12
82 12
83 12
84 12
85 18
86 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 3e <mu_cfg_yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  4a <mu_cfg_yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  54 <mu_cfg_yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x6b,%edx
mov    $0x0,%esi
mov    $0x400,%edi
callq  38 <uwp_init+0x18>
movl   $0x80,0x0(%rip)        # 42 <uwp_init+0x22>
mov    %rax,0x0(%rip)        # 49 <uwp_init+0x29>
movl   $0x0,0x0(%rip)        # 53 <uwp_init+0x33>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uwp_init ()
{
  do { (uwcache).data = sh_xmalloc(((128) * sizeof (UNWIND_ELT *)), "unwind_prot.c", 107); (uwcache).cs = (128); (uwcache).nc = 0; } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
<<<sep_out_sample>>>
push   %r12
lea    0x108(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  9f <osip_message_get_proxy_authenticate+0x1f>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    b8 <osip_message_get_proxy_authenticate+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  b2 <osip_message_get_proxy_authenticate+0x32>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_proxy_authenticate (const osip_message_t * sip, int pos, osip_proxy_authenticate_t ** dest)
{
  osip_proxy_authenticate_t *proxy_authenticate;
  *dest = ((void *)0);
  if (osip_list_size (&sip->proxy_authenticates) <= pos)
    return -1;
  proxy_authenticate = (osip_proxy_authenticate_t *)
    osip_list_get (&sip->proxy_authenticates, pos);
  *dest = proxy_authenticate;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 10
17 9
18 11
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
test   $0x1,%dl
jne    14c9 <string_hex_to_bin+0xc9>
mov    %edx,%eax
shr    $0x1f,%eax
add    %eax,%edx
sar    %edx
test   %edx,%edx
jle    14cf <string_hex_to_bin+0xcf>
push   %r15
lea    -0x1(%rdx),%eax
push   %r14
lea    0x1(%rdi,%rax,1),%r15
mov    %rdi,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
jmp    147a <string_hex_to_bin+0x7a>
nopl   0x0(%rax,%rax,1)
movzbl 0x1(%r13,%rbp,1),%esi
mov    $0x11,%edx
mov    $0x0,%edi
callq  1455 <string_hex_to_bin+0x55>
test   %rax,%rax
je     14a1 <string_hex_to_bin+0xa1>
sub    $0x0,%r12
sub    $0x0,%rax
add    $0x1,%rbx
shl    $0x4,%r12d
add    %r12d,%eax
mov    %al,-0x1(%rbx)
cmp    %r15,%rbx
je     14b8 <string_hex_to_bin+0xb8>
mov    %ebx,%ebp
mov    $0x11,%edx
mov    $0x0,%edi
sub    %r14d,%ebp
add    %ebp,%ebp
movslq %ebp,%rbp
movzbl 0x0(%r13,%rbp,1),%esi
callq  1499 <string_hex_to_bin+0x99>
test   %rax,%rax
mov    %rax,%r12
jne    1440 <string_hex_to_bin+0x40>
add    $0x8,%rsp
mov    $0xfffffffe,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    $0xffffffff,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_hex_to_bin (unsigned char *output, unsigned char *input, int inlen)
{
  int i;
  unsigned char *p, *q;
  if (inlen % 2)
    return -1;
  inlen /= 2;
  p = input;
  q = output;
  for (i = 0; i < inlen; i++)
    {
      char *c1, *c2;
      if (!(c1 = memchr (xlet, p[i << 1], sizeof xlet))
   || !(c2 = memchr (xlet, p[(i << 1) + 1], sizeof xlet)))
 return -2;
      q[i] = ((c1 - xlet) << 4) + (c2 - xlet);
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 7
5 7
6 7
7 10
8 10
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 10
20 2
21 2
22 2
23 14
24 14
25 14
26 14
27 14
28 14
29 16
30 16
31 16
32 16
33 16
34 16
35 10
36 10
37 10
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 19
49 15
50 19
51 19
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 18
60 19
61 19
62 19
63 19
64 19
65 19
66 19
67 6
68 6
69 18
70 19
71 19
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     210 <gsl_multimin_fminimizer_free+0x30>
mov    (%rdi),%rax
mov    0x28(%rdi),%rdi
callq  *0x28(%rax)
mov    0x28(%rbx),%rdi
callq  1fc <gsl_multimin_fminimizer_free+0x1c>
mov    0x18(%rbx),%rdi
callq  205 <gsl_multimin_fminimizer_free+0x25>
mov    %rbx,%rdi
pop    %rbx
jmpq   20e <gsl_multimin_fminimizer_free+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fminimizer_free (gsl_multimin_fminimizer * s)
{
  if (!s) { return ; };
  (s->type->free) (s->state);
  free (s->state);
  gsl_vector_free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 8
14 7
15 7
16 8
17 8
18 8
<<<sep_out_sample>>>
sub    $0xb,%esi
xor    %eax,%eax
mov    %edx,%ecx
cmp    $0x1,%esi
lea    0x20(%rdi),%rsi
mov    $0x4,%r8d
setbe  %al
mov    %eax,%edx
jmpq   5de <__osip_nict_need_timer_f_event+0x1e>
xchg   %ax,%ax
<<<sep_in_sample>>>
__osip_nict_need_timer_f_event (osip_nict_t * nict, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (nict, &nict->timer_f_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_F);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x10,%rsp
movsd  %xmm0,(%rsp)
movsd  %xmm1,0x8(%rsp)
callq  123b <xerrwv+0x2b>
cmp    $0x1,%rbp
je     1270 <xerrwv+0x60>
cmp    $0x2,%rbp
je     12a0 <xerrwv+0x90>
cmp    $0x1,%rbx
je     1288 <xerrwv+0x78>
cmp    $0x2,%rbx
je     12b8 <xerrwv+0xa8>
cmp    $0x2,%r12
je     12d7 <xerrwv+0xc7>
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
mov    %r13,%rsi
mov    $0x0,%edi
callq  127f <xerrwv+0x6f>
cmp    $0x1,%rbx
jne    124d <xerrwv+0x3d>
nopl   (%rax)
movsd  (%rsp),%xmm0
mov    $0x0,%edi
mov    $0x1,%eax
callq  129c <xerrwv+0x8c>
jmp    1253 <xerrwv+0x43>
xchg   %ax,%ax
mov    %r14,%rdx
mov    %r13,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  12b2 <xerrwv+0xa2>
jmp    1247 <xerrwv+0x37>
nopl   0x0(%rax)
movsd  0x8(%rsp),%xmm1
mov    $0x0,%edi
movsd  (%rsp),%xmm0
mov    $0x2,%eax
callq  12d2 <xerrwv+0xc2>
jmpq   1253 <xerrwv+0x43>
callq  12dc <xerrwv+0xcc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xerrwv (char *msg, long level, long ni, long i1, long i2, long nr,
            double r1, double r2)
{
  long mesflg = 1;
  if (mesflg == 0) goto L100;
  printf ("%s\n",msg);
  if (ni == 1) printf(" in above message, i1=%10ld\n", i1);
  if (ni == 2)
    printf(" in above message, i1=%10ld, i2=%10ld\n", i1, i2);
  if (nr == 1) printf(" in above message, r1=%21.13f\n", r1);
  if (nr == 2)
    printf(" in above message, r1=%21.13f, r2=%21.13f\n", r1, r2);
L100:
    if (level != 2) return 0;
    abort();
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 6
15 7
16 7
17 8
18 8
19 10
20 10
21 11
22 11
23 14
24 14
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 7
35 7
36 7
37 7
38 10
39 10
40 10
41 10
42 10
43 10
44 10
45 10
46 10
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 12
55 12
56 12
57 12
58 12
59 12
60 15
61 15
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rax
mov    0x8(%rdi),%rdx
mov    (%rdx),%rdx
cmp    $0x0,%rax
jle    20 <__gmpz_get_si+0x20>
movabs $0x7fffffffffffffff,%rax
and    %rdx,%rax
retq   
nop
mov    $0x0,%eax
jne    30 <__gmpz_get_si+0x30>
repz retq 
nopl   0x0(%rax)
lea    -0x1(%rdx),%rax
movabs $0x7fffffffffffffff,%rdx
and    %rdx,%rax
not    %rax
retq   
<<<sep_in_sample>>>
__gmpz_get_si (mpz_srcptr z)
{
  mp_ptr zp = ((z)->_mp_d);
  mp_size_t size = ((z)->_mp_size);
  mp_limb_t zl = zp[0];
  if (size > 0)
    return zl & 9223372036854775807L;
  else if (size < 0)
    return -1 - (long) ((zl - 1) & 9223372036854775807L);
  else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 7
7 7
8 7
9 7
10 11
11 8
12 12
13 12
14 9
15 9
16 9
17 9
18 12
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    $0xef,%edx
mov    $0x0,%esi
jmpq   2ff <sh_getopt_dispose_istate+0xf>
nop
<<<sep_in_sample>>>
sh_getopt_dispose_istate (gs)
     sh_getopt_state_t *gs;
{
  sh_xfree((gs), "getopt.c", 239);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  12ee <encodings_table_free+0xe>
mov    %rbx,%rdi
pop    %rbx
jmpq   12f7 <encodings_table_free+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
encodings_table_free (struct hash_table_s * table)
{
  hash_free (table, (hash_map_func_t) encoding_free);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rax
mov    %rsi,%rbx
mov    0x8(%rsi),%rdx
mov    %rax,(%rdx)
mov    %rdx,0x8(%rax)
mov    0x18(%rdi),%rax
subq   $0x1,0x40(%rdi)
test   %rax,%rax
je     816 <gl_linked_remove_node+0x26>
mov    0x10(%rsi),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  81e <gl_linked_remove_node+0x2e>
mov    $0x1,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_remove_node (gl_list_t list, gl_list_node_t node)
{
  gl_list_node_t prev;
  gl_list_node_t next;
  prev = node->prev;
  next = node->next;
  prev->next = next;
  next->prev = prev;
  list->count--;
  if (list->base.dispose_fn != ((void *)0))
    list->base.dispose_fn (node->value);
  free (node);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 5
5 7
6 8
7 10
8 9
9 10
10 10
11 11
12 11
13 12
14 12
15 14
16 14
17 14
18 14
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 3966 <c_set_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_set_debug (int bdebug )
{
        c__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_comment_equal_fn (void *data1,
                           void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
jmpq   1085 <meta1free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # b1 <history_total_bytes+0x11>
test   %rbp,%rbp
je     105 <history_total_bytes+0x65>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     105 <history_total_bytes+0x65>
add    $0x8,%rbp
xor    %r12d,%r12d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rdi
add    $0x8,%rbp
callq  dc <history_total_bytes+0x3c>
mov    0x8(%rbx),%rdi
mov    %rax,%r13
callq  e8 <history_total_bytes+0x48>
mov    -0x8(%rbp),%rbx
add    %eax,%r13d
add    %r13d,%r12d
test   %rbx,%rbx
jne    d0 <history_total_bytes+0x30>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    f7 <history_total_bytes+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 5
23 5
24 4
25 4
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 4
34 4
35 4
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x1006,%eax
je     f51 <mu_mailbox_set_folder+0x11>
mov    %rsi,0x38(%rdi)
xor    %ax,%ax
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_set_folder (mu_mailbox_t mbox, mu_folder_t folder)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
   mbox->folder = folder;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 7
7 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     239 <csv_set_delim+0x9>
mov    %sil,0x2e(%rdi)
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_set_delim(struct csv_parser *p, unsigned char c)
{
  if (p) p->delim_char = c;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  e87 <blocking_read+0x17>
cmp    $0xffffffffffffffff,%rax
mov    %rax,%rbx
je     ea0 <blocking_read+0x30>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
callq  ea5 <blocking_read+0x35>
cmpl   $0xb,(%rax)
jne    e90 <blocking_read+0x20>
xor    %eax,%eax
mov    $0x3,%esi
mov    %ebp,%edi
callq  eb8 <blocking_read+0x48>
test   %eax,%eax
js     e90 <blocking_read+0x20>
test   $0x8,%ah
je     e90 <blocking_read+0x20>
and    $0xf7,%ah
mov    $0x4,%esi
mov    %ebp,%edi
mov    %eax,%edx
xor    %eax,%eax
callq  ed4 <blocking_read+0x64>
cmp    $0xffffffff,%eax
je     e90 <blocking_read+0x20>
add    $0x8,%rsp
mov    %ebp,%edi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdx
pop    %r13
jmpq   ef0 <blocking_write>
<<<sep_in_sample>>>
blocking_read (int fd, void *buf, size_t count)
{
  size_t bytes = safe_read (fd, buf, count);
  if (bytes == ((size_t) -1) && (*__errno_location ()) == 11)
    {
      int flags = rpl_fcntl (fd, 3);
      if (0 <= flags && flags & 04000
   && rpl_fcntl (fd, 4, flags & ~04000) != -1)
 bytes = safe_read (fd, buf, count);
    }
  return bytes;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 4
22 4
23 4
24 6
25 6
26 6
27 6
28 7
29 7
30 7
31 7
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 12
41 9
42 9
43 12
44 12
45 12
46 9
47 12
48 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0x7,%sil
jne    294 <openssl_bf_encrypt+0x54>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     289 <openssl_bf_encrypt+0x49>
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x1,%ecx
mov    %r13,%rdx
add    $0x8,%rbp
add    $0x8,%r12
callq  283 <openssl_bf_encrypt+0x43>
sub    $0x8,%rbx
jne    268 <openssl_bf_encrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0xc9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ad <openssl_bf_encrypt+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
openssl_bf_encrypt(const void *ctx, size_t length,
     uint8_t *dst, const uint8_t *src)
{
  ((!(length % 8)) ? (void) (0) : __assert_fail ("!(length % 8)", "nettle-openssl.c", 201, __PRETTY_FUNCTION__));
  while (length)
    {
      BF_ecb_encrypt(src, dst, ctx, 1);
      length -= 8;
      dst += 8;
      src += 8;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    0x8(%rdi),%rdi
lea    0x0(,%rax,8),%esi
mov    0x0(%rip),%rax        # 14 <__gmp_randclear_mt+0x14>
movslq %esi,%rsi
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
__gmp_randclear_mt (gmp_randstate_t rstate)
{
  (*__gmp_free_func) ((void *) ((rstate)->_mp_seed->_mp_d),
        ((rstate->_mp_seed)->_mp_alloc) * 8);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 188 <named_function+0x8>
je     1e7 <named_function+0x67>
push   %r12
xor    %eax,%eax
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
jmp    1b7 <named_function+0x37>
nopw   0x0(%rax,%rax,1)
add    $0x1,%ebx
movslq %ebx,%rax
mov    %rax,%rdx
shl    $0x5,%rdx
cmpq   $0x0,0x0(%rdx)
je     1e0 <named_function+0x60>
shl    $0x5,%rax
mov    %r12,%rsi
mov    0x0(%rax),%rdi
mov    %rax,%rbp
callq  1cd <named_function+0x4d>
test   %eax,%eax
jne    1a0 <named_function+0x20>
pop    %rbx
lea    0x0(%rbp),%rax
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
named_function (char *name)
{
  register int i;
  for (i = 0; function_doc_array[i].func; i++)
    if (strcmp (function_doc_array[i].func_name, name) == 0)
      break;
  if (!function_doc_array[i].func)
    return 0;
  else
    return &function_doc_array[i];
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 11
25 10
26 11
27 11
28 11
29 11
30 11
31 11
32 8
33 11
34 11
35 8
36 11
37 11
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x22,%edi
movl   $0x1,0x0(%rip)        # 288 <dokludgemode+0x18>
callq  28d <dokludgemode+0x1d>
mov    $0x1,%esi
mov    $0x3,%edi
callq  29c <dokludgemode+0x2c>
mov    $0x1,%esi
mov    $0x1,%edi
callq  2ab <dokludgemode+0x3b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dokludgemode (void)
{
  kludgelinemode = 1;
  send_wont (34, 1);
  send_dont (3, 1);
  send_dont (1, 1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 3
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
mov    $0x0,%edx
test   %rax,%rax
cmove  %rdx,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_location_str (rec_record_t record)
{
  char *res;
  if (record->location_str)
    {
      res = record->location_str;
    }
  else
    {
      res = "";
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 10
3 10
4 10
5 13
6 13
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     1a <__gmpz_fits_ushort_p+0x1a>
xor    %al,%al
cmp    $0x1,%rdx
je     20 <__gmpz_fits_ushort_p+0x20>
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
cmpq   $0xffff,(%rcx)
setbe  %al
retq   
<<<sep_in_sample>>>
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (32767 * 2 + 1)));;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 3
12 3
13 3
14 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # c6 <tty_israw+0x6>
shr    %eax
xor    $0x1,%eax
and    $0x1,%eax
retq   
nop
<<<sep_in_sample>>>
tty_israw (void)
{
  return !(termbuf.c_lflag & 0000002);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
sub    $0x68,%rsp
mov    %rdi,%r10
mov    %rcx,%r8
xor    %eax,%eax
mov    %rsp,%rdi
mov    $0xc,%ecx
rep stos %rax,%es:(%rdi)
mov    %rsi,%r11
mov    %edx,%ecx
mov    %rsp,%rsi
mov    %r11,%rdx
mov    %r10,%rdi
mov    %r10,(%rsp)
callq  2510 <_help>
add    $0x68,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_help (const struct argp *argp, FILE *stream,
                  unsigned flags, char *name)
{
  struct argp_state state;
  memset (&state, 0, sizeof state);
  state.root_argp = argp;
  _help (argp, &state, stream, flags, name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 3
9 7
10 5
11 7
12 7
13 6
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     a3e <parseopts+0x16e>
mov    %rsi,%rbx
callq  8ea <parseopts+0x1a>
movslq 0x0(%rip),%rdx        # 8f1 <parseopts+0x21>
cmp    %rdx,%rax
jbe    a32 <parseopts+0x162>
mov    0x0(%rip),%rdi        # 901 <parseopts+0x31>
test   %rdi,%rdi
je     913 <parseopts+0x43>
callq  90b <parseopts+0x3b>
mov    %rbp,%rdi
callq  913 <parseopts+0x43>
mov    %eax,0x0(%rip)        # 919 <parseopts+0x49>
add    $0x1,%eax
movslq %eax,%rdi
callq  924 <parseopts+0x54>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 92e <parseopts+0x5e>
je     a52 <parseopts+0x182>
mov    %rax,%r10
mov    %r10,%rdi
mov    %rbp,%rsi
callq  942 <parseopts+0x72>
movzbl (%rax),%ecx
mov    %rax,%r10
cmp    $0x20,%cl
jne    a47 <parseopts+0x177>
lea    0x1(%rax),%rdx
xor    %r8d,%r8d
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r9
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
add    $0x1,%r8d
cmp    $0x20,%cl
je     960 <parseopts+0x90>
test   %cl,%cl
je     a3e <parseopts+0x16e>
xor    %eax,%eax
test   %rbx,%rbx
mov    %rbx,%rdi
je     a18 <parseopts+0x148>
nopw   0x0(%rax,%rax,1)
movslq %r8d,%rdx
mov    %r9,(%rdi)
lea    (%r10,%rdx,1),%r9
movzbl (%r9),%ecx
test   $0xdf,%cl
je     9c3 <parseopts+0xf3>
lea    0x1(%r10,%rdx,1),%rdx
nopl   0x0(%rax,%rax,1)
movzbl (%rdx),%ecx
add    $0x1,%r8d
mov    %rdx,%r9
add    $0x1,%rdx
test   $0xdf,%cl
jne    9b0 <parseopts+0xe0>
test   %cl,%cl
je     a28 <parseopts+0x158>
test   %rbx,%rbx
je     9d0 <parseopts+0x100>
movb   $0x0,(%r9)
add    $0x1,%r8d
movslq %r8d,%rdx
lea    (%r10,%rdx,1),%r9
movzbl (%r9),%ecx
cmp    $0x20,%cl
jne    a04 <parseopts+0x134>
lea    0x1(%r10,%rdx,1),%rdx
nopl   0x0(%rax)
mov    %rdx,%r9
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
add    $0x1,%r8d
cmp    $0x20,%cl
je     9f0 <parseopts+0x120>
add    $0x1,%eax
add    $0x8,%rdi
test   %cl,%cl
je     a2b <parseopts+0x15b>
test   %rbx,%rbx
jne    990 <parseopts+0xc0>
movslq %r8d,%rdx
lea    (%r10,%rdx,1),%r9
jmpq   99e <parseopts+0xce>
nopl   0x0(%rax)
add    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%r10        # a39 <parseopts+0x169>
jmpq   937 <parseopts+0x67>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    %rax,%r9
xor    %r8d,%r8d
jmpq   974 <parseopts+0xa4>
mov    $0x0,%edi
callq  a5c <parseopts+0x18c>
mov    $0x1,%edi
callq  a66 <parseopts+0x196>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parseopts(char *opts, char **arg)
{
  static char *optcpy = ((void *)0);
  static int optlen = 0;
  int i;
  int a;
  if (!opts)
    return 0;
  if (strlen(opts) > optlen)
    {
      if (optcpy)
 free(optcpy);
      optlen = strlen(opts);
      if (!(optcpy = malloc(optlen + 1)))
 {
   perror("dap");
   exit(1);
 }
    }
  strcpy(optcpy, opts);
  for (i = 0; optcpy[i] == ' '; i++)
    ;
  for (a = 0; optcpy[i]; a++)
    {
      if (arg)
 arg[a] = optcpy + i;
      while (optcpy[i] && optcpy[i] != ' ')
 i++;
      if (optcpy[i])
 {
   if (arg)
     optcpy[i] = '\0';
   for (i++; optcpy[i] == ' '; i++)
     ;
 }
    }
  return a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 9
9 9
10 9
11 9
12 11
13 11
14 11
15 12
16 12
17 12
18 13
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 20
27 20
28 20
29 21
30 20
31 21
32 21
33 21
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 23
43 23
44 23
45 25
46 25
47 25
48 25
49 25
50 26
51 26
52 26
53 27
54 27
55 27
56 27
57 27
58 28
59 27
60 27
61 27
62 27
63 29
64 29
65 31
66 31
67 32
68 33
69 33
70 33
71 33
72 33
73 33
74 33
75 33
76 33
77 33
78 33
79 33
80 33
81 33
82 23
83 23
84 23
85 23
86 25
87 25
88 25
89 25
90 25
91 25
92 23
93 38
94 38
95 38
96 38
97 38
98 38
99 38
100 8
101 38
102 38
103 38
104 21
105 21
106 21
107 16
108 16
109 17
110 17
111 17
<<<sep_out_sample>>>
push   %r15
mov    %r8,%r15
push   %r14
mov    %rcx,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %edi,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1cd4 <rcfile_call_section+0x24>
callq  1cd9 <rcfile_call_section+0x29>
test   %rax,%rax
mov    %rax,%rbx
je     1d10 <rcfile_call_section+0x60>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %r12d,%edi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rcx
mov    %r14,%r8
mov    %r15,%r9
pop    %r13
pop    %r14
pop    %r15
mov    $0x0,%edx
jmpq   1d08 <rcfile_call_section+0x58>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  1d1a <rcfile_call_section+0x6a>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x2,%edi
xor    %eax,%eax
callq  1d2c <rcfile_call_section+0x7c>
jmp    1ce1 <rcfile_call_section+0x31>
xchg   %ax,%ax
<<<sep_in_sample>>>
rcfile_call_section (int method, char *name, char *class,
       void *data, MESSAGE msg)
{
  RC_SECTION *sec = rc_section_lookup (parse_tree, name);
  if (!sec)
    info (2, gettext("No such section: %s"), name);
  rc_run_section (method, sec, anubis_rc_sections, class, data, msg);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 5
16 4
17 5
18 8
19 7
20 7
21 8
22 8
23 8
24 7
25 7
26 7
27 8
28 8
29 8
30 7
31 7
32 7
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # b76 <gsl_vector_uint_const_ptr+0x6>
test   %eax,%eax
je     b7f <gsl_vector_uint_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    b90 <gsl_vector_uint_const_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x2,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bad <gsl_vector_uint_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_const_ptr (const gsl_vector_uint * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_uint.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const unsigned int *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 2
12 5
13 5
14 5
15 5
16 5
17 5
18 8
19 8
20 8
<<<sep_out_sample>>>
mov    $0x2,%eax
retq   
<<<sep_in_sample>>>
nettle_version_minor (void)
{
  return 2;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %rdi,%rcx
mov    $0xf,%edx
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   52b7 <Write_R_Includes+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Write_R_Includes (PFILE pfile)
{
  fprintf (pfile, "#include <R.h>\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     90 <mu_progmailer_set_command+0x40>
mov    0x18(%rdi),%rdi
mov    %rsi,%rbp
callq  6a <mu_progmailer_set_command+0x1a>
test   %rbp,%rbp
je     a0 <mu_progmailer_set_command+0x50>
mov    %rbp,%rdi
callq  77 <mu_progmailer_set_command+0x27>
test   %rax,%rax
mov    %rax,0x18(%rbx)
je     90 <mu_progmailer_set_command+0x40>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x16,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
movq   $0x0,0x18(%rbx)
xor    %eax,%eax
jmp    82 <mu_progmailer_set_command+0x32>
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_progmailer_set_command (mu_progmailer_t pm, const char *command)
{
  if (!pm)
    return 22;
  free (pm->command);
  if (command)
    {
      pm->command = strdup (command);
      if (!pm->command)
 return 22;
    }
  else
    pm->command = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 6
11 6
12 8
13 8
14 9
15 8
16 9
17 14
18 15
19 15
20 15
21 15
22 15
23 15
24 4
25 15
26 15
27 15
28 15
29 13
30 14
31 14
32 14
<<<sep_out_sample>>>
movslq %esi,%rsi
cmp    0x40(%rdi),%rsi
jae    ea0 <rec_sex_ast_node_child+0x10>
mov    0x28(%rdi,%rsi,8),%rax
retq   
nop
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_child (rec_sex_ast_node_t node,
                        int n)
{
  rec_sex_ast_node_t res;
  res = ((void *)0);
  if (n < node->num_children)
    {
      res = node->children[n];
    }
  return res;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 8
5 8
6 8
7 5
8 11
9 11
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
cmp    $0xa9,%rdx
jle    800 <__gmpn_invertappr+0x10>
jmpq   7fe <__gmpn_invertappr+0xe>
xchg   %ax,%ax
jmpq   0 <mpn_bc_invertappr>
<<<sep_in_sample>>>
__gmpn_invertappr (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr scratch)
{
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do {} while (0);
  if ((! ((__builtin_constant_p (170) && (170) == 0) || (!(__builtin_constant_p (170) && (170) == 9223372036854775807L) && (n) >= (170)))))
    return mpn_bc_invertappr (ip, dp, n, scratch);
  else
    return __gmpn_ni_invertappr (ip, dp, n, scratch);
}
<<<sep_in_sample>>>
1 8
2 8
3 11
4 11
5 9
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     508 <legal_identifier+0x58>
movzbl (%rdi),%r12d
xor    %ebp,%ebp
test   %r12b,%r12b
je     50a <legal_identifier+0x5a>
callq  4cc <legal_identifier+0x1c>
mov    (%rax),%rsi
movzbl %r12b,%eax
testb  $0x4,0x1(%rsi,%rax,2)
je     518 <legal_identifier+0x68>
movzbl 0x1(%rbx),%eax
lea    0x1(%rbx),%rdx
test   %al,%al
jne    4fb <legal_identifier+0x4b>
jmp    528 <legal_identifier+0x78>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdx
movzbl (%rdx),%eax
test   %al,%al
je     528 <legal_identifier+0x78>
movzbl %al,%ecx
testb  $0x8,(%rsi,%rcx,2)
jne    4f0 <legal_identifier+0x40>
cmp    $0x5f,%al
je     4f0 <legal_identifier+0x40>
xor    %ebp,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
cmp    $0x5f,%r12b
je     4da <legal_identifier+0x2a>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    $0x1,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
legal_identifier (name)
     char *name;
{
  register char *s;
  unsigned char c;
  if (!name || !(c = *name) || (((1 && ((*__ctype_b_loc ())[(int) (((unsigned char)c))] & (unsigned short int) _ISalpha)) || (c == '_')) == 0))
    return (0);
  for (s = name + 1; (c = *s) != 0; s++)
    {
      if (((1 && ((*__ctype_b_loc ())[(int) (((unsigned char)c))] & (unsigned short int) _ISalnum)) || c == '_') == 0)
 return (0);
    }
  return (1);
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 3
5 3
6 6
7 6
8 7
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 7
32 14
33 14
34 14
35 14
36 14
37 14
38 6
39 6
40 14
41 14
42 14
43 14
44 14
45 14
46 13
47 14
48 14
49 14
50 14
51 14
52 14
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 7 <version_etc_hook+0x7>
mov    0x0(%rip),%rsi        # e <version_etc_hook+0xe>
mov    $0x0,%ecx
mov    $0x0,%edx
jmpq   1d <version_etc_hook+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU cflow", "1.5",
                  program_authors);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 3437 <php_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_set_out (FILE * out_str )
{
        php_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     5a3 <add_history_time+0x53>
movslq 0x0(%rip),%rax        # 565 <add_history_time+0x15>
test   %eax,%eax
jle    5a3 <add_history_time+0x53>
mov    0x0(%rip),%rdx        # 570 <add_history_time+0x20>
mov    -0x8(%rdx,%rax,8),%rbp
mov    0x8(%rbp),%rdi
test   %rdi,%rdi
je     583 <add_history_time+0x33>
callq  583 <add_history_time+0x33>
mov    %rbx,%rdi
callq  58b <add_history_time+0x3b>
lea    0x1(%rax),%rdi
callq  594 <add_history_time+0x44>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  59f <add_history_time+0x4f>
mov    %rax,0x8(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_history_time (string)
     const char *string;
{
  HIST_ENTRY *hs;
  if (string == 0 || history_length < 1)
    return;
  hs = the_history[history_length - 1];
  if (hs->timestamp) free (hs->timestamp);
  hs->timestamp = strcpy (xmalloc (1 + strlen (string)), (string));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %r12
test   %rsi,%rsi
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %edx,%ebx
je     16df <assert_grecs_value_type+0x5f>
mov    (%rsi),%edi
test   %edi,%edi
je     16d8 <assert_grecs_value_type+0x58>
xor    %eax,%eax
cmp    %ebx,%edi
je     16d0 <assert_grecs_value_type+0x50>
callq  169f <assert_grecs_value_type+0x1f>
mov    %ebx,%edi
mov    %rax,%r12
callq  16a9 <assert_grecs_value_type+0x29>
mov    $0x0,%edi
mov    %rax,%rbx
callq  16b6 <assert_grecs_value_type+0x36>
mov    %r12,%r8
mov    %rax,%rdx
mov    %rbx,%rcx
xor    %eax,%eax
xor    %esi,%esi
mov    %rbp,%rdi
callq  16cb <assert_grecs_value_type+0x4b>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
cmpq   $0x0,0x28(%rsi)
jne    1694 <assert_grecs_value_type+0x14>
mov    %ebx,%edi
callq  16e6 <assert_grecs_value_type+0x66>
mov    $0x0,%edi
mov    %rax,%rbx
callq  16f3 <assert_grecs_value_type+0x73>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
xor    %eax,%eax
mov    %rbp,%rdi
callq  1705 <assert_grecs_value_type+0x85>
mov    $0x1,%eax
jmp    16d0 <assert_grecs_value_type+0x50>
nopl   0x0(%rax)
<<<sep_in_sample>>>
assert_grecs_value_type(grecs_locus_t *locus,
   const grecs_value_t *value, int type)
{
 if ((!(value) || ((value)->type == 0 && (value)->v.string == ((void *)0)))) {
  grecs_error(locus, 0, gettext("expected %s"),
       grecs_data_type_string(type));
  return 1;
 }
 if (value->type != type) {
  grecs_error(locus, 0, gettext("expected %s, but found %s"),
       grecs_data_type_string(type),
       grecs_data_type_string(value->type));
  return 1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 15
12 9
13 9
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 13
29 16
30 16
31 16
32 16
33 16
34 4
35 4
36 5
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 5
45 5
46 5
47 5
48 5
49 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <xcalloc+0x9>
test   %rax,%rax
je     1e3 <xcalloc+0x13>
add    $0x8,%rsp
retq   
callq  1e8 <xcalloc+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 8
6 8
7 6
8 6
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %esi,%ecx
je     2d8 <_get_track_msf_image+0x58>
cmp    $0xaa,%sil
movzbl 0x1d(%rdi),%r8d
je     2e8 <_get_track_msf_image+0x68>
movzbl %cl,%esi
add    $0x1,%r8d
xor    %eax,%eax
cmp    %r8d,%esi
jg     2e0 <_get_track_msf_image+0x60>
test   %cl,%cl
je     2e0 <_get_track_msf_image+0x60>
movzbl 0x1c(%rdi),%eax
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
lea    0x1620(%rdi,%rax,8),%rax
movzwl 0x1(%rax),%ecx
mov    %cx,(%rdx)
movzbl 0x3(%rax),%eax
mov    %al,0x2(%rdx)
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x1(%r8),%ecx
jmp    292 <_get_track_msf_image+0x12>
xchg   %ax,%ax
<<<sep_in_sample>>>
_get_track_msf_image(void *p_user_data, track_t i_track, msf_t *msf)
{
  const _img_private_t *p_env = p_user_data;
  if (((void *)0) == msf) return 0;
  if (i_track == CDIO_CDROM_LEADOUT_TRACK) i_track = p_env->gen.i_tracks+1;
  if (i_track <= p_env->gen.i_tracks+1 && i_track != 0) {
    *msf = p_env->tocent[i_track-p_env->gen.i_first_track].start_msf;
    return 1;
  } else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 5
5 5
6 5
7 6
8 6
9 4
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 4
28 4
29 11
30 11
31 5
32 5
33 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    $0x0,%edx
mov    %rax,%rcx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  24 <xalloc_die+0x24>
callq  29 <xalloc_die+0x29>
<<<sep_in_sample>>>
xalloc_die ()
{
  anubis_error (1, 0, "%s", gettext("Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm0        # 5d8 <gsl_sf_laguerre_2_e+0x8>
jnp    690 <gsl_sf_laguerre_2_e+0xc0>
movsd  0x0(%rip),%xmm4        # 5e6 <gsl_sf_laguerre_2_e+0x16>
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 5f0 <gsl_sf_laguerre_2_e+0x20>
addsd  %xmm0,%xmm4
movsd  0x0(%rip),%xmm2        # 5fc <gsl_sf_laguerre_2_e+0x2c>
movsd  0x0(%rip),%xmm5        # 604 <gsl_sf_laguerre_2_e+0x34>
movsd  0x0(%rip),%xmm6        # 60c <gsl_sf_laguerre_2_e+0x3c>
divsd  %xmm4,%xmm3
addsd  %xmm6,%xmm0
xorpd  %xmm4,%xmm2
mulsd  %xmm4,%xmm5
movsd  0x0(%rip),%xmm4        # 624 <gsl_sf_laguerre_2_e+0x54>
mulsd  %xmm1,%xmm3
mulsd  %xmm1,%xmm2
mulsd  %xmm0,%xmm5
movapd %xmm3,%xmm1
andpd  %xmm4,%xmm3
addsd  %xmm6,%xmm1
addsd  %xmm3,%xmm3
mulsd  %xmm2,%xmm1
andpd  %xmm4,%xmm2
addsd  %xmm6,%xmm3
addsd  %xmm2,%xmm2
addsd  %xmm5,%xmm1
andpd  %xmm4,%xmm5
mulsd  %xmm3,%xmm2
movapd %xmm5,%xmm0
movsd  %xmm1,(%rdi)
andpd  %xmm4,%xmm1
addsd  %xmm2,%xmm0
movsd  0x0(%rip),%xmm2        # 674 <gsl_sf_laguerre_2_e+0xa4>
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm0
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
jne    5de <gsl_sf_laguerre_2_e+0xe>
movsd  0x0(%rip),%xmm0        # 69e <gsl_sf_laguerre_2_e+0xce>
xor    %eax,%eax
mulsd  %xmm1,%xmm0
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 6b0 <gsl_sf_laguerre_2_e+0xe0>
movsd  %xmm0,(%rdi)
andpd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 6c0 <gsl_sf_laguerre_2_e+0xf0>
movsd  %xmm0,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_laguerre_2_e(const double a, const double x, gsl_sf_result * result)
{
  if(a == -2.0) {
    result->val = 0.5*x*x;
    result->err = 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
  else {
    double c0 = 0.5 * (2.0+a)*(1.0+a);
    double c1 = -(2.0+a);
    double c2 = -0.5/(2.0+a);
    result->val = c0 + c1*x*(1.0 + c2*x);
    result->err = 2.0 * 2.2204460492503131e-16 * (fabs(c0) + 2.0 * fabs(c1*x) * (1.0 + 2.0 * fabs(c2*x)));
    result->err += 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 17
5 11
6 9
7 10
8 9
9 9
10 11
11 9
12 10
13 9
14 13
15 12
16 12
17 9
18 12
19 13
20 12
21 13
22 12
23 13
24 13
25 13
26 12
27 13
28 13
29 13
30 12
31 14
32 13
33 13
34 14
35 13
36 14
37 14
38 17
39 17
40 3
41 4
42 17
43 4
44 4
45 5
46 4
47 5
48 5
49 5
50 17
51 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  8c3 <a2_read_sys_config+0x13>
test   %rax,%rax
mov    %rax,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %rbp,%rdi
xor    %esi,%esi
mov    %rbx,%rdx
callq  8df <a2_read_sys_config+0x2f>
test   %eax,%eax
je     8f0 <a2_read_sys_config+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  8f8 <a2_read_sys_config+0x48>
mov    $0x0,%edi
mov    %rax,%rbp
callq  905 <a2_read_sys_config+0x55>
mov    %rax,%rbx
callq  90d <a2_read_sys_config+0x5d>
mov    (%rax),%esi
add    $0x8,%rsp
mov    %rbx,%rdx
pop    %rbx
mov    %rbp,%rcx
xor    %edi,%edi
xor    %eax,%eax
pop    %rbp
jmpq   924 <a2_read_sys_config+0x74>
<<<sep_in_sample>>>
a2_read_sys_config (a2ps_job * job)
{
  const char *config_file;
  config_file = getenv ("A2PS_CONFIG");
  if (!config_file)
    config_file = "/usr/local/etc/a2ps.cfg";
  if (a2_read_config (job, ((void *)0), config_file))
    return;
  error (0, (*__errno_location ()),
  gettext ("cannot open file `%s'"), quotearg (config_file));
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 6
8 4
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 9
23 9
24 10
25 9
26 10
27 10
28 9
29 9
30 11
31 9
32 11
33 9
34 9
35 9
36 11
37 9
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     180 <gsl_permute_vector_complex_long_double+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  175 <gsl_permute_vector_complex_long_double+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  191 <gsl_permute_vector_complex_long_double+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_complex_long_double (const gsl_permutation * p, gsl_vector_complex_long_double * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex_long_double (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     248 <rewrite_cancel+0x18>
callq  241 <rewrite_cancel+0x11>
movq   $0x0,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rewrite_cancel(REWRITE *rewrite)
{
 if (rewrite->pattern) {
  free(rewrite->pattern);
  rewrite->pattern = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 7
9 7
10 7
<<<sep_out_sample>>>
jmpq   4e95 <info_grow_window+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_grow_window (WINDOW *window, int count)
{
  window_change_window_height (window, count);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_digest (osip_authorization_t * authorization)
{
  return authorization->digest;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     926 <gsl_stats_ushort_absdev_m+0x76>
xorpd  %xmm2,%xmm2
add    %rsi,%rsi
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 8c6 <gsl_stats_ushort_absdev_m+0x16>
nopw   %cs:0x0(%rax,%rax,1)
movzwl (%rdi),%ecx
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
cvtsi2sd %ecx,%xmm1
subsd  %xmm0,%xmm1
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
jne    8d0 <gsl_stats_ushort_absdev_m+0x20>
test   %rax,%rax
js     908 <gsl_stats_ushort_absdev_m+0x58>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    8f4 <gsl_stats_ushort_absdev_m+0x44>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_absdev_m (const unsigned short data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 6
4 6
5 8
6 8
7 8
8 10
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 8
17 13
18 13
19 13
20 13
21 13
22 15
23 15
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 6
34 6
35 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b37 <move_parms+0x7>
test   %rax,%rax
je     b80 <move_parms+0x50>
mov    0x8(%rax),%rax
test   %rax,%rax
jne    b58 <move_parms+0x28>
jmp    b80 <move_parms+0x50>
nopw   0x0(%rax,%rax,1)
mov    (%rax),%rax
test   %rax,%rax
je     b80 <move_parms+0x50>
mov    0x18(%rax),%rdx
cmpl   $0x2,0x18(%rdx)
jne    b50 <move_parms+0x20>
cmpl   $0x3,0x70(%rdx)
jne    b50 <move_parms+0x20>
cmpl   $0x2,0x28(%rdx)
jne    b50 <move_parms+0x20>
mov    (%rax),%rax
mov    %edi,0x60(%rdx)
movl   $0x0,0x28(%rdx)
test   %rax,%rax
jne    b58 <move_parms+0x28>
repz retq 
<<<sep_in_sample>>>
move_parms(int level)
{
     struct linked_list_entry *p;
     for (p = ((auto_symbol_list) ? (auto_symbol_list)->head : ((void *)0)); p; p = p->next) {
   Symbol *s = p->data;
   if (s->type == SymIdentifier && s->storage == AutoStorage
       && s->flag == symbol_parm) {
        s->level = level;
        s->flag = symbol_none;
   }
     }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 6
14 6
15 6
16 6
17 7
18 7
19 4
20 8
21 9
22 4
23 4
24 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x1e0,%rsp
test   %al,%al
mov    %rsi,0x138(%rsp)
mov    %rdx,0x140(%rsp)
mov    %rcx,0x148(%rsp)
mov    %r8,0x150(%rsp)
mov    %r9,0x158(%rsp)
je     74 <outputf+0x74>
movaps %xmm0,0x160(%rsp)
movaps %xmm1,0x170(%rsp)
movaps %xmm2,0x180(%rsp)
movaps %xmm3,0x190(%rsp)
movaps %xmm4,0x1a0(%rsp)
movaps %xmm5,0x1b0(%rsp)
movaps %xmm6,0x1c0(%rsp)
movaps %xmm7,0x1d0(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x128(%rsp)
xor    %eax,%eax
lea    0x1f0(%rsp),%rax
lea    0x20(%rsp),%rbx
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    %rax,0x10(%rsp)
lea    0x130(%rsp),%rax
mov    %rbx,%rdi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  c6 <outputf+0xc6>
mov    %rbx,%rdx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     c9 <outputf+0xc9>
mov    %eax,%ecx
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmove  %rcx,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbx,%rdx
cmp    $0xff,%rdx
ja     14a <outputf+0x14a>
movsbl 0x20(%rsp),%esi
test   %sil,%sil
je     12e <outputf+0x12e>
nopl   0x0(%rax)
add    $0x1,%rbx
mov    $0x1,%edi
callq  126 <outputf+0x126>
movsbl (%rbx),%esi
test   %sil,%sil
jne    118 <outputf+0x118>
mov    0x128(%rsp),%rax
xor    %fs:0x28,%rax
jne    163 <outputf+0x163>
add    $0x1e0,%rsp
pop    %rbx
retq   
mov    $0x0,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  163 <outputf+0x163>
callq  168 <outputf+0x168>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
outputf(char *fmt, ...)
{
      va_list arg;
      char str[255+1], *ptr;
      __builtin_va_start(arg,fmt);
      vsprintf(str, fmt, arg);
      ((strlen(str) <= sizeof(str) - 1) ? (void) (0) : __assert_fail ("strlen(str) <= sizeof(str) - 1", "alglib3.c", 32, __PRETTY_FUNCTION__));
      __builtin_va_end(arg);
      for (ptr = str; *ptr != '\0'; ptr++) outchar(1, *ptr);
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 5
22 6
23 6
24 2
25 5
26 5
27 6
28 5
29 5
30 5
31 6
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 11
62 11
63 11
64 11
65 11
66 11
67 7
68 7
69 7
70 7
71 7
72 11
73 11
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # ee6 <getconfline+0x6>
test   %edx,%edx
je     ef2 <getconfline+0x12>
mov    0x0(%rip),%rax        # ef1 <getconfline+0x11>
retq   
push   %rax
mov    $0x0,%edi
xor    %eax,%eax
callq  eff <getconfline+0x1f>
nop
<<<sep_in_sample>>>
getconfline(void)
{
 if (!opened)
  die("configuration file not opened.");
 return confline;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 2
7 4
8 4
9 4
10 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mov    $0x0,%eax
movsd  0x0(%rip),%xmm0        # 41 <orderf+0x11>
ucomisd %xmm0,%xmm1
setnp  %dl
cmove  %edx,%eax
test   %al,%al
je     58 <orderf+0x28>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm2        # 60 <orderf+0x30>
ucomisd %xmm2,%xmm1
setnp  %dl
cmove  %edx,%eax
test   %al,%al
jne    4f <orderf+0x1f>
movapd %xmm1,%xmm2
movapd %xmm0,%xmm4
sub    $0x28,%rsp
mulsd  %xmm1,%xmm2
subsd  %xmm2,%xmm4
sqrtsd %xmm4,%xmm0
ucomisd %xmm0,%xmm0
jp     16d <orderf+0x13d>
movapd %xmm1,%xmm3
movsd  %xmm4,0x18(%rsp)
movsd  %xmm1,0x10(%rsp)
divsd  %xmm0,%xmm3
movapd %xmm3,%xmm0
movsd  %xmm3,(%rsp)
callq  b2 <orderf+0x82>
callq  b7 <orderf+0x87>
movsd  0x0(%rip),%xmm5        # bf <orderf+0x8f>
movsd  (%rsp),%xmm3
mulsd  %xmm0,%xmm5
movsd  0x0(%rip),%xmm0        # d0 <orderf+0xa0>
xorpd  %xmm3,%xmm0
movsd  %xmm5,0x8(%rsp)
callq  df <orderf+0xaf>
callq  e4 <orderf+0xb4>
movsd  0x0(%rip),%xmm2        # ec <orderf+0xbc>
movsd  (%rsp),%xmm3
mulsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # fd <orderf+0xcd>
movsd  0x8(%rsp),%xmm5
mulsd  %xmm3,%xmm0
addsd  %xmm5,%xmm2
movsd  0x0(%rip),%xmm5        # 113 <orderf+0xe3>
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm4
mulsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 12b <orderf+0xfb>
subsd  %xmm0,%xmm2
xorpd  %xmm0,%xmm0
andpd  %xmm2,%xmm3
ucomisd %xmm3,%xmm5
jb     168 <orderf+0x138>
movapd %xmm2,%xmm0
movsd  %xmm1,0x8(%rsp)
movsd  %xmm4,(%rsp)
callq  151 <orderf+0x121>
movsd  0x8(%rsp),%xmm1
movsd  (%rsp),%xmm4
mulsd  %xmm1,%xmm0
mulsd  %xmm4,%xmm4
divsd  %xmm4,%xmm0
add    $0x28,%rsp
retq   
movapd %xmm4,%xmm0
movsd  %xmm1,0x8(%rsp)
movsd  %xmm4,(%rsp)
callq  181 <orderf+0x151>
movsd  0x8(%rsp),%xmm1
movsd  (%rsp),%xmm4
jmpq   90 <orderf+0x60>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
orderf(double t)
{
  double x;
  double tmp1, tmp2;
  if (t == -1.0 || t == 1.0)
    return 0.0;
  tmp1 = 1.0 - t * t;
  x = t / sqrt(tmp1);
  tmp2 = dkm1 * log(probz(x)) + dnmk * log(probz(-x)) - 0.5 * x * x;
  if (finite(tmp2))
    return exp(tmp2) * t / (tmp1 * tmp1);
  return 0.0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 2
21 7
22 7
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 10
50 10
51 10
52 9
53 10
54 9
55 12
56 10
57 10
58 10
59 11
60 11
61 11
62 11
63 11
64 11
65 11
66 11
67 11
68 13
69 13
70 8
71 8
72 8
73 8
74 8
75 8
76 8
77 8
<<<sep_out_sample>>>
lea    0x1(%rdi),%rax
imul   %rdi,%rax
add    $0x2,%rdi
shr    %rax
imul   %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mul3 (mp_limb_t m)
{
  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;
  mp_limb_t m2 = (m + 2);
  return m01 * m2;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 5
6 6
7 6
<<<sep_out_sample>>>
xor    %eax,%eax
test   %dil,%dil
js     17f <mu_parse822_is_q_text+0xf>
cmp    $0x22,%dil
jne    188 <mu_parse822_is_q_text+0x18>
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
cmp    $0x5c,%dil
je     17d <mu_parse822_is_q_text+0xd>
xor    %eax,%eax
cmp    $0xd,%dil
setne  %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_parse822_is_q_text (char c)
{
  return
    mu_parse822_is_char (c) &&
    c != '"' &&
    c != '\\' &&
    c != '\r';
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 5
6 6
7 8
8 8
9 5
10 5
11 6
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
sub    $0x28,%rsp
movsd  0x0(%rip),%xmm2        # 6c <gsl_ran_logistic_pdf+0xc>
movsd  0x0(%rip),%xmm3        # 74 <gsl_ran_logistic_pdf+0x14>
andpd  %xmm2,%xmm0
movsd  %xmm1,0x8(%rsp)
movapd %xmm2,0x10(%rsp)
xorpd  %xmm3,%xmm0
divsd  %xmm1,%xmm0
callq  91 <gsl_ran_logistic_pdf+0x31>
movsd  0x0(%rip),%xmm3        # 99 <gsl_ran_logistic_pdf+0x39>
movsd  0x8(%rsp),%xmm1
movapd 0x10(%rsp),%xmm2
addsd  %xmm0,%xmm3
add    $0x28,%rsp
andpd  %xmm2,%xmm1
mulsd  %xmm3,%xmm1
mulsd  %xmm3,%xmm1
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_logistic_pdf (const double x, const double a)
{
  double u = exp (-fabs(x)/a);
  double p = u / (fabs(a) * (1 + u) * (1 + u));
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 6
15 4
16 4
17 4
18 4
19 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1303 <pies_acl_install+0x13>
test   %rdi,%rdi
je     1340 <pies_acl_install+0x50>
mov    %rbx,%rsi
callq  1310 <pies_acl_install+0x20>
test   %rax,%rax
je     137f <pies_acl_install+0x8f>
cmp    %rbx,%rax
je     1368 <pies_acl_install+0x78>
test   %rbp,%rbp
je     1378 <pies_acl_install+0x88>
mov    0x10(%rax),%rdx
mov    0x8(%rax),%rax
mov    %rdx,0x8(%rbp)
mov    %rax,0x0(%rbp)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
xor    %r8d,%r8d
xor    %esi,%esi
mov    $0x0,%ecx
mov    $0x0,%edx
callq  1354 <pies_acl_install+0x64>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 135e <pies_acl_install+0x6e>
je     137f <pies_acl_install+0x8f>
mov    %rax,%rdi
jmp    1308 <pies_acl_install+0x18>
nopl   (%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
jmp    1334 <pies_acl_install+0x44>
callq  1384 <pies_acl_install+0x94>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pies_acl_install (pies_acl_t acl, grecs_locus_t * locus)
{
  pies_acl_t ret;
  if (!((acl_table
  || (acl_table = hash_initialize (0, 0,
       acl_hasher,
       acl_compare, 0)))
 && (ret = hash_insert (acl_table, acl))))
    xalloc_die ();
  if (ret != acl)
    {
      if (locus)
 *locus = ret->locus;
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 10
14 10
15 12
16 12
17 13
18 13
19 13
20 13
21 14
22 17
23 17
24 17
25 17
26 17
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 17
39 16
40 17
41 17
42 17
43 17
44 14
45 14
46 9
47 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    3df0 <gsl_matrix_char_subdiagonal+0x50>
mov    0x10(%rsi),%r8
mov    %rdx,%rcx
sub    %rdx,%rdi
mov    0x8(%rsi),%rdx
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
imul   %r8,%rcx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
mov    %r9,0x18(%rax)
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  3e12 <gsl_matrix_char_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_subdiagonal (gsl_matrix_char * m,
                                    const size_t k)
{
  _gsl_vector_char_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 11
7 12
8 12
9 14
10 17
11 11
12 11
13 12
14 17
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
jmpq   1095 <yyrealloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_int_size (const gsl_block_int * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5e57 <pch_c_function+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pch_c_function (void)
{
    return p_c_function;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x21e0,%edi
callq  e <keymap_make_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x21e0,%rdx
jne    10 <keymap_make_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
keymap_make_keymap (void)
{
  int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc ((271 * 2) * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < (271 * 2); i++)
    {
      keymap[i].type = 0;
      keymap[i].value.function = ((void *)0);
    }
  return keymap;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   0 <history_search_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_search (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x2,%eax
je     3af <get_version+0xf>
cmpb   $0x0,(%rsi)
jne    3b0 <get_version+0x10>
retq   
sub    $0x8,%rsp
mov    0x0(%rip),%r9        # 3bb <get_version+0x1b>
mov    $0x4,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
callq  3d0 <get_version+0x30>
mov    0x0(,%rax,4),%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_version (char const *context, char const *version)
{
  if (version == 0 || *version == 0)
    return numbered_existing_backups;
  else
    return ((backup_types) [__xargmatch_internal (context, version, backup_args, (char const *) (backup_types), sizeof *(backup_types), argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 7
7 2
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x2,%eax
je     3af <get_version+0xf>
cmpb   $0x0,(%rsi)
jne    3b0 <get_version+0x10>
retq   
sub    $0x8,%rsp
mov    0x0(%rip),%r9        # 3bb <get_version+0x1b>
mov    $0x4,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
callq  3d0 <get_version+0x30>
mov    0x0(,%rax,4),%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_version (char const *context, char const *version)
{
  if (version == 0 || *version == 0)
    return numbered_existing_backups;
  else
    return ((backup_types) [__xargmatch_internal (context, version, backup_args, (char const *) (backup_types), sizeof *(backup_types), argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 7
7 2
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  d64 <dupmem+0x14>
test   %rax,%rax
je     d83 <dupmem+0x33>
mov    0x0(%rbp),%rsi
mov    %rbx,%rdx
mov    %rax,%rdi
callq  d78 <dupmem+0x28>
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
callq  d88 <dupmem+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dupmem (void **pptr, size_t size)
{
  void *ptr = malloc (size);
  if (!ptr)
    {
      syslog (3, "dupmem: %m");
      exit (-1);
    }
  memcpy (ptr, *pptr, size);
  *pptr = ptr;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 4
10 9
11 9
12 9
13 9
14 10
15 11
16 11
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1fb6 <rl_vi_check+0x6>
test   %eax,%eax
je     1fc2 <rl_vi_check+0x12>
cmp    0x0(%rip),%eax        # 1fc0 <rl_vi_check+0x10>
je     1fc8 <rl_vi_check+0x18>
xor    %eax,%eax
retq   
nopl   (%rax)
sub    $0x8,%rsp
callq  1fd1 <rl_vi_check+0x21>
cmp    $0x1,%rax
jbe    1fe1 <rl_vi_check+0x31>
mov    0x0(%rip),%eax        # 1fdd <rl_vi_check+0x2d>
test   %eax,%eax
je     1ff0 <rl_vi_check+0x40>
subl   $0x1,0x0(%rip)        # 1fe8 <rl_vi_check+0x38>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
mov    0x0(%rip),%esi        # 1ff6 <rl_vi_check+0x46>
mov    0x0(%rip),%rdi        # 1ffd <rl_vi_check+0x4d>
mov    $0x1,%edx
callq  2007 <rl_vi_check+0x57>
mov    %eax,0x0(%rip)        # 200d <rl_vi_check+0x5d>
jmp    1fe8 <rl_vi_check+0x38>
nop
<<<sep_in_sample>>>
rl_vi_check ()
{
  if (rl_point && rl_point == rl_end)
    {
      if ((__ctype_get_mb_cur_max ()) > 1 && rl_byte_oriented == 0)
 rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, 0x01);
      else
 rl_point--;
    }
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 11
7 11
8 11
9 2
10 5
11 5
12 5
13 5
14 5
15 5
16 8
17 11
18 11
19 11
20 11
21 6
22 6
23 6
24 6
25 6
26 6
27 6
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  705 <gsl_stats_uint_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  718 <gsl_stats_uint_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  735 <gsl_stats_uint_ttest+0x55>
test   %rbp,%rbp
js     798 <gsl_stats_uint_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 747 <gsl_stats_uint_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     7b8 <gsl_stats_uint_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     7d2 <gsl_stats_uint_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    73f <gsl_stats_uint_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    759 <gsl_stats_uint_ttest+0x79>
test   %rbp,%rbp
js     80c <gsl_stats_uint_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     823 <gsl_stats_uint_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  803 <gsl_stats_uint_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   777 <gsl_stats_uint_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    7dc <gsl_stats_uint_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    7ee <gsl_stats_uint_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uint_ttest (const unsigned int data1[],
                           const size_t stride1, const size_t n1,
                           const unsigned int data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_uint_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_uint_mean (data2, stride2, n2);
  const double pv = gsl_stats_uint_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2346 <ppdset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdset_lineno (int line_number )
{
    ppdlineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     14 <nntp_itr_getitem+0x14>
mov    0x10(%rdi),%rax
mov    %rax,(%rsi)
movq   $0x0,0x10(%rdi)
test   %rdx,%rdx
je     20 <nntp_itr_getitem+0x20>
movq   $0x0,(%rdx)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_getitem (void *owner, void **item, const void **pkey)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  if (item)
    {
      *((char **)item) = nntp_iterator->item;
      nntp_iterator->item = ((void *)0);
    }
  if (pkey)
    *pkey = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 9
7 9
8 10
9 12
10 12
11 12
<<<sep_out_sample>>>
push   %rbx
xor    %ebx,%ebx
test   %rdi,%rdi
je     145b <read_subchannel+0x2b>
mov    $0x0,%esi
callq  1442 <read_subchannel+0x12>
test   %eax,%eax
sete   %bl
jne    1460 <read_subchannel+0x30>
cmpb   $0x0,0x0(%rip)        # 1450 <read_subchannel+0x20>
je     145b <read_subchannel+0x2b>
cmpb   $0x13,0x0(%rip)        # 1459 <read_subchannel+0x29>
je     1478 <read_subchannel+0x48>
mov    %ebx,%eax
pop    %rbx
retq   
nop
mov    $0x0,%edi
callq  520 <xperror>
movb   $0x0,0x0(%rip)        # 1471 <read_subchannel+0x41>
jmp    1449 <read_subchannel+0x19>
nopl   0x0(%rax,%rax,1)
callq  1280 <cd_eject>
jmp    145b <read_subchannel+0x2b>
nop
<<<sep_in_sample>>>
read_subchannel(CdIo_t *p_cdio)
{
  _Bool b_ok = 1;
  if (!p_cdio) return 0;
  b_ok = DRIVER_OP_SUCCESS == cdio_audio_read_subchannel(p_cdio, &sub);
  if (!b_ok) {
    xperror("read subchannel");
    b_cd = 0;
  }
  if (auto_mode && sub.audio_status == CDIO_MMC_READ_SUB_ST_COMPLETED)
    cd_eject();
  return b_ok;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 6
9 6
10 10
11 10
12 10
13 10
14 13
15 13
16 13
17 13
18 7
19 7
20 8
21 8
22 8
23 11
24 11
25 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  3c <ModifyOneParm+0xc>
test   %eax,%eax
jne    58 <ModifyOneParm+0x28>
mov    (%rbx),%rdi
movsd  0x8(%rbx),%xmm0
callq  4d <ModifyOneParm+0x1d>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x8(%rbx),%rsi
mov    (%rbx),%rdi
callq  64 <ModifyOneParm+0x34>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ModifyOneParm (PVOID pData, PVOID pNullInfo)
{
  PVARMOD pvarmod = (PVARMOD) pData;
  if (IsInput(pvarmod->hvar))
    SetInput (pvarmod->hvar, pvarmod->uvar.pifn);
  else
    SetVar (pvarmod->hvar, pvarmod->uvar.dVal);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 5
15 5
16 5
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  66 <nntp_itr_dup+0x16>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     8f <nntp_itr_dup+0x3f>
mov    (%rbx),%rax
mov    %rax,(%rdx)
mov    0x8(%rbx),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rbx),%rax
mov    %rax,0x10(%rdx)
mov    %rdx,0x0(%rbp)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_dup (void **ptr, void *owner)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  struct nntp_iterator *clone = malloc (sizeof *nntp_iterator);
  if (clone == ((void *)0))
    return 12;
  *clone = *nntp_iterator;
  *ptr = clone;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 9
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     2a3 <mu_body_destroy+0x23>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     2a3 <mu_body_destroy+0x23>
cmp    %rsi,0x0(%rbp)
je     2b0 <mu_body_destroy+0x30>
movq   $0x0,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdi
test   %rdi,%rdi
je     2c7 <mu_body_destroy+0x47>
callq  2be <mu_body_destroy+0x3e>
mov    0x8(%rbp),%rdi
callq  2c7 <mu_body_destroy+0x47>
cmpq   $0x0,0x10(%rbp)
je     2da <mu_body_destroy+0x5a>
lea    0x10(%rbp),%rdi
mov    %rbp,%rsi
callq  2da <mu_body_destroy+0x5a>
mov    0x18(%rbp),%rdi
test   %rdi,%rdi
je     2f3 <mu_body_destroy+0x73>
callq  2e8 <mu_body_destroy+0x68>
lea    0x18(%rbp),%rdi
xor    %esi,%esi
callq  2f3 <mu_body_destroy+0x73>
mov    %rbp,%rdi
callq  2fb <mu_body_destroy+0x7b>
jmp    29c <mu_body_destroy+0x1c>
nopl   (%rax)
<<<sep_in_sample>>>
mu_body_destroy (mu_body_t *pbody, void *owner)
{
  if (pbody && *pbody)
    {
      mu_body_t body = *pbody;
      if (body->owner == owner)
 {
   if (body->filename)
     {
       remove (body->filename);
       free (body->filename);
     }
   if (body->stream)
     mu_stream_destroy (&(body->stream), body);
   if (body->fstream)
     {
       mu_stream_close (body->fstream);
       mu_stream_destroy (&(body->fstream), ((void *)0));
     }
   free (body);
 }
      *pbody = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 22
13 24
14 24
15 24
16 24
17 24
18 8
19 8
20 8
21 10
22 11
23 11
24 13
25 13
26 14
27 14
28 14
29 15
30 15
31 15
32 17
33 18
34 18
35 18
36 20
37 20
38 20
39 20
<<<sep_out_sample>>>
test   %rsi,%rsi
lea    (%rdi,%rsi,1),%rax
je     3d1 <unsunder+0x21>
nopl   0x0(%rax)
cmpb   $0x0,(%rdi)
jne    3c8 <unsunder+0x18>
movb   $0xa,(%rdi)
add    $0x1,%rdi
cmp    %rax,%rdi
jne    3c0 <unsunder+0x10>
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unsunder(char *str, size_t true_len)
{
    ((void) (0));
    for (; true_len > 0; true_len--, str++) {
 if (*str == '\0')
     *str = '\n';
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 6
8 4
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     6c3 <mu_list_get_comparator+0x13>
mov    0x28(%rdi),%rax
mov    %rax,(%rsi)
xor    %eax,%eax
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_get_comparator (mu_list_t list, mu_list_comparator_t *comp)
{
  if (!list)
    return 22;
  *comp = list->comp;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 6
7 7
8 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b7 <read_stdin+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_stdin (void)
{
  FILE * input_file = stdin;
  return input_file;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a2f <osip_transaction_set_your_instance+0xf>
mov    %rsi,0x2c40(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_your_instance (osip_transaction_t * transaction, void *ptr)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->reserved1 = ptr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # ee6 <gsl_vector_short_ptr+0x6>
test   %eax,%eax
je     eef <gsl_vector_short_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    f00 <gsl_vector_short_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f1d <gsl_vector_short_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_ptr (gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    5140 <gsl_matrix_long_double_const_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  5162 <gsl_matrix_long_double_const_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_const_superdiagonal (const gsl_matrix_long_double * m,
                                      const size_t k)
{
  _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
mov    (%rcx),%eax
je     1013 <gsl_vector_uint_min+0x33>
lea    0x0(,%rdx,4),%rdi
xor    %edx,%edx
nopl   0x0(%rax)
mov    (%rcx),%esi
cmp    %esi,%eax
cmova  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    1000 <gsl_vector_uint_min+0x20>
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_min (const gsl_vector_uint * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned int min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    $0x0,%esi
push   %rbx
callq  2d7 <gdbm_import+0x17>
test   %rax,%rax
mov    %rax,%rbx
je     300 <gdbm_import+0x40>
mov    %rbp,%rdi
mov    %r12d,%edx
mov    %rax,%rsi
callq  2ed <gdbm_import+0x2d>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  2f7 <gdbm_import+0x37>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
movl   $0x3,0x0(%rip)        # 30a <gdbm_import+0x4a>
mov    $0xffffffff,%eax
jmp    2f9 <gdbm_import+0x39>
<<<sep_in_sample>>>
gdbm_import (GDBM_FILE dbf, const char *importfile, int flag)
{
  FILE *fp;
  int rc;
  fp = fopen (importfile, "r");
  if (!fp)
    {
      gdbm_errno = 3;
      return -1;
    }
  rc = gdbm_import_from_file (dbf, fp, flag);
  fclose (fp);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 2
8 5
9 6
10 5
11 6
12 11
13 11
14 11
15 11
16 12
17 11
18 12
19 13
20 14
21 14
22 14
23 14
24 14
25 8
26 9
27 9
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   2f3 <gsl_vector_float_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_fscanf (FILE * stream, gsl_vector_float * v)
{
  int status = gsl_block_float_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x1020(%rdi),%rdi
movzbl %sil,%esi
jmpq   7d0 <eject_media_linux>
<<<sep_in_sample>>>
get_track_isrc_linux (const void *p_user_data, track_t i_track) {
  const _img_private_t *p_env = p_user_data;
  return mmc_get_track_isrc( p_env->gen.cdio, i_track );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     90 <mu_attribute_get_owner+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_get_owner (mu_attribute_t attr)
{
  return (attr) ? attr->owner : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %edi,%edi
mov    %edi,%edx
mov    %edi,0xc(%rsp)
js     90 <file_align_to_string+0x30>
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  7f <file_align_to_string+0x1f>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
lea    0xc(%rsp),%rdi
mov    $0x4,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  a9 <file_align_to_string+0x49>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
file_align_to_string (file_align_t file_align)
{
  static char buf[25];
  if (file_align < 0)
    return argmatch_to_argument ((char const *) &(file_align), (file_align_args), (const char *) (file_align_types), sizeof (*(file_align_types)))
                                       ;
  sprintf (buf, "%d", file_align);
  return buf;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 7
7 7
8 7
9 7
10 8
11 9
12 9
13 9
14 5
15 5
16 5
17 5
18 5
19 9
20 9
<<<sep_out_sample>>>
mov    (%rdi),%rsi
cmp    %rsi,0x8(%rdi)
cmovbe 0x8(%rdi),%rsi
mov    0x10(%rdi),%rcx
test   %rsi,%rsi
je     fae <gsl_matrix_complex_add_diagonal+0x4e>
mov    0x18(%rdi),%rax
add    $0x1,%rcx
xor    %edx,%edx
shl    $0x4,%rcx
nopl   0x0(%rax,%rax,1)
movsd  (%rax),%xmm2
add    $0x1,%rdx
addsd  %xmm0,%xmm2
movsd  %xmm2,(%rax)
movsd  0x8(%rax),%xmm2
addsd  %xmm1,%xmm2
movsd  %xmm2,0x8(%rax)
add    %rcx,%rax
cmp    %rsi,%rdx
jne    f88 <gsl_matrix_complex_add_diagonal+0x28>
xor    %eax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_add_diagonal (gsl_matrix_complex * a, const gsl_complex x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = (M < N ? M : N);
  size_t i;
  for (i = 0; i < loop_lim; i++)
    {
      a->data[2 * (i * tda + i)] += ((x).dat[0]);
      a->data[2 * (i * tda + i) + 1] += ((x).dat[1]);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 10
13 8
14 10
15 10
16 11
17 11
18 11
19 11
20 8
21 8
22 14
23 14
24 14
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
callq  16 <sh_single_quote+0x16>
test   %rbx,%rbx
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jne    32 <sh_single_quote+0x32>
jmp    60 <sh_single_quote+0x60>
nopl   0x0(%rax)
add    $0x1,%rdx
add    $0x1,%rbx
je     60 <sh_single_quote+0x60>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     60 <sh_single_quote+0x60>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    28 <sh_single_quote+0x28>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    32 <sh_single_quote+0x32>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_single_quote (string)
     char *string;
{
  register int c;
  char *result, *r, *s;
  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 9
7 8
8 8
9 9
10 9
11 9
12 11
13 9
14 9
15 9
16 9
17 9
18 9
19 12
20 11
21 12
22 14
23 15
24 16
25 16
26 9
27 9
28 9
29 19
30 20
31 22
32 22
33 22
<<<sep_out_sample>>>
mov    (%rdi),%rax
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_oset_nx_create_empty (gl_oset_implementation_t implementation,
                         gl_setelement_compar_fn compar_fn,
                         gl_setelement_dispose_fn dispose_fn)
{
  return implementation->nx_create_empty (implementation, compar_fn,
                                          dispose_fn);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     e1 <pair_free+0x11>
callq  e1 <pair_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     ef <pair_free+0x1f>
callq  ef <pair_free+0x1f>
mov    %rbx,%rdi
pop    %rbx
jmpq   f8 <pair_free+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pair_free (struct pair * pair)
{
  do { if (pair->key) free (pair->key); } while (0);
  do { if (pair->value) free (pair->value); } while (0);
  do { if (pair) free (pair); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 6
13 5
14 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 27a7 <php_get_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_get_out (void)
{
        return php_out;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
movapd %xmm0,%xmm4
mov    %esi,%ebp
movapd %xmm0,%xmm5
push   %rbx
mov    %edi,%ebx
sub    $0x38,%rsp
ucomisd %xmm2,%xmm1
movsd  %xmm2,(%rsp)
jbe    69c0 <dap_srpt+0x1b0>
addsd  %xmm0,%xmm5
movsd  0x0(%rip),%xmm0        # 683d <dap_srpt+0x2d>
xorpd  %xmm2,%xmm2
jmpq   68fe <dap_srpt+0xee>
nopw   %cs:0x0(%rax,%rax,1)
movapd %xmm2,%xmm0
mov    %ebp,%esi
mov    %ebx,%edi
movsd  %xmm1,0x28(%rsp)
movsd  %xmm4,0x20(%rsp)
movsd  %xmm6,0x18(%rsp)
movsd  %xmm5,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
callq  687b <dap_srpt+0x6b>
movsd  0x18(%rsp),%xmm6
movapd %xmm0,%xmm7
movsd  0x28(%rsp),%xmm1
movapd %xmm0,%xmm3
subsd  %xmm6,%xmm7
movsd  0x20(%rsp),%xmm4
subsd  %xmm1,%xmm3
movsd  0x8(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
movapd %xmm7,%xmm6
andpd  0x0(%rip),%xmm3        # 68b5 <dap_srpt+0xa5>
andpd  0x0(%rip),%xmm6        # 68bd <dap_srpt+0xad>
cmpltsd %xmm6,%xmm3
andpd  %xmm3,%xmm1
andpd  %xmm3,%xmm4
movapd %xmm1,%xmm6
movapd %xmm3,%xmm1
andnpd %xmm0,%xmm1
orpd   %xmm6,%xmm1
movapd %xmm4,%xmm6
movapd %xmm3,%xmm4
andnpd %xmm2,%xmm4
orpd   %xmm6,%xmm4
movapd %xmm2,%xmm6
andpd  %xmm3,%xmm6
andnpd %xmm5,%xmm3
movapd %xmm3,%xmm5
orpd   %xmm6,%xmm5
subsd  (%rsp),%xmm0
andpd  0x0(%rip),%xmm0        # 690b <dap_srpt+0xfb>
ucomisd 0x0(%rip),%xmm0        # 6913 <dap_srpt+0x103>
jbe    69b0 <dap_srpt+0x1a0>
movapd %xmm5,%xmm0
mov    %ebp,%esi
mov    %ebx,%edi
movsd  %xmm1,0x18(%rsp)
movsd  %xmm4,0x10(%rsp)
movsd  %xmm5,0x8(%rsp)
callq  6938 <dap_srpt+0x128>
movsd  0x8(%rsp),%xmm5
movapd %xmm0,%xmm6
movsd  0x10(%rsp),%xmm4
movsd  0x18(%rsp),%xmm1
movapd %xmm5,%xmm2
movsd  (%rsp),%xmm0
xorpd  %xmm7,%xmm7
subsd  %xmm1,%xmm0
subsd  %xmm4,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm6,%xmm0
subsd  %xmm1,%xmm0
divsd  %xmm0,%xmm2
addsd  %xmm4,%xmm2
ucomisd %xmm2,%xmm7
jbe    6850 <dap_srpt+0x40>
ucomisd %xmm4,%xmm5
movsd  0x0(%rip),%xmm2        # 698d <dap_srpt+0x17d>
jbe    69a0 <dap_srpt+0x190>
mulsd  %xmm4,%xmm2
jmpq   6850 <dap_srpt+0x40>
nopl   0x0(%rax,%rax,1)
mulsd  %xmm5,%xmm2
jmpq   6850 <dap_srpt+0x40>
nopl   0x0(%rax)
add    $0x38,%rsp
movapd %xmm2,%xmm0
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mulsd  0x0(%rip),%xmm5        # 69c8 <dap_srpt+0x1b8>
jmpq   6835 <dap_srpt+0x25>
nopl   (%rax)
<<<sep_in_sample>>>
dap_srpt(int numdf, int dendf, double pt0, double pr0, double alpha)
{
  double pt1, pr1;
  double pt2, pr2;
  pt2 = 0.0;
  if (alpha < pr0)
    pt1 = 2.0 * pt0;
  else
    pt1 = 0.5 * pt0;
  pr2 = 1.0;
  while (fabs(pr2 - alpha) > dap_prtol)
    {
      pr1 = dap_sr(numdf, dendf, pt1);
      pt2 = pt0 + (pt1 - pt0) * (alpha - pr0) / (pr1 - pr0);
      if (pt2 < 0.0)
 {
   if (pt0 < pt1)
     pt2 = 0.5 * pt0;
   else
     pt2 = 0.5 * pt1;
 }
      pr2 = dap_sr(numdf, dendf, pt2);
      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))
 {
   pr1 = pr2;
   pt1 = pt2;
 }
      else
 {
   pr0 = pr2;
   pt0 = pt2;
 }
    }
  return pt2;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 7
5 2
6 2
7 2
8 6
9 2
10 6
11 7
12 26
13 26
14 26
15 26
16 22
17 22
18 22
19 22
20 22
21 22
22 22
23 22
24 22
25 23
26 23
27 23
28 23
29 23
30 30
31 23
32 30
33 30
34 23
35 23
36 23
37 30
38 30
39 30
40 30
41 30
42 30
43 30
44 30
45 30
46 30
47 30
48 30
49 30
50 30
51 30
52 30
53 11
54 11
55 11
56 11
57 13
58 13
59 13
60 13
61 13
62 13
63 13
64 14
65 13
66 14
67 14
68 14
69 14
70 15
71 14
72 14
73 14
74 14
75 14
76 14
77 14
78 15
79 15
80 17
81 18
82 17
83 18
84 18
85 18
86 20
87 20
88 20
89 35
90 35
91 35
92 35
93 35
94 35
95 9
96 9
97 9
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 3a <add_utmp_file+0xa>
jmpq   3f <add_utmp_file+0xf>
nop
<<<sep_in_sample>>>
add_utmp_file(char *name)
{
  file_reader_add_file(utmp_info, name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
movq   $0x0,0x10(%rsp)
movq   $0x0,0x20(%rsp)
callq  29fa <libunistring_str_cd_iconveh+0x2a>
lea    0x20(%rsp),%rdx
mov    0x10(%rbx),%r8
mov    0x8(%rbx),%rcx
mov    %r12d,%r9d
mov    %rax,%rsi
mov    %rbp,%rdi
mov    %rdx,0x8(%rsp)
lea    0x10(%rsp),%rdx
mov    %rdx,(%rsp)
mov    (%rbx),%rdx
callq  190 <mem_cd_iconveh_internal.constprop.1>
test   %eax,%eax
js     2a50 <libunistring_str_cd_iconveh+0x80>
mov    0x20(%rsp),%rax
mov    0x10(%rsp),%rdx
movb   $0x0,(%rdx,%rax,1)
mov    0x10(%rsp),%rbx
add    $0x38,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    0x10(%rsp),%rbp
xor    %ebx,%ebx
test   %rbp,%rbp
je     2a3d <libunistring_str_cd_iconveh+0x6d>
callq  2a61 <libunistring_str_cd_iconveh+0x91>
mov    (%rax),%r13d
mov    %rax,%r12
mov    %rbp,%rdi
callq  2a6f <libunistring_str_cd_iconveh+0x9f>
mov    %rbx,%rax
mov    %r13d,(%r12)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
libunistring_str_cd_iconveh (const char *src,
                const iconveh_t *cd,
                enum iconv_ilseq_handler handler)
{
  char *result = ((void *)0);
  size_t length = 0;
  int retval = mem_cd_iconveh_internal (src, strlen (src),
                                        cd->cd, cd->cd1, cd->cd2, handler, 1,
                                        ((void *)0), &result, &length);
  if (retval < 0)
    {
      if (result != ((void *)0))
        {
          int saved_errno = (*__errno_location ());
          free (result);
          (*__errno_location ()) = saved_errno;
        }
      return ((void *)0);
    }
  result[length] = '\0';
  return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 10
24 10
25 20
26 20
27 20
28 21
29 22
30 22
31 22
32 22
33 22
34 22
35 22
36 22
37 12
38 18
39 12
40 12
41 14
42 14
43 14
44 15
45 15
46 22
47 16
48 22
49 22
50 22
51 22
52 22
53 22
54 22
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     2270 <mu_true_answer_p+0x70>
movzbl (%rdi),%ebp
mov    $0xffffffff,%eax
test   %bpl,%bpl
je     2267 <mu_true_answer_p+0x67>
callq  2220 <mu_true_answer_p+0x20>
mov    (%rax),%rdx
jmp    2234 <mu_true_answer_p+0x34>
nopl   (%rax)
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     2270 <mu_true_answer_p+0x70>
movsbq %bpl,%rax
testb  $0x20,0x1(%rdx,%rax,2)
jne    2228 <mu_true_answer_p+0x28>
mov    $0x0,%esi
mov    $0x0,%edi
callq  224e <mu_true_answer_p+0x4e>
movsbl %bpl,%esi
mov    %rax,%rdi
callq  225a <mu_true_answer_p+0x5a>
mov    %rax,%rdx
mov    $0x1,%eax
test   %rdx,%rdx
je     227c <mu_true_answer_p+0x7c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
movsbl (%rbx),%ebx
mov    $0x0,%esi
mov    $0x0,%edi
callq  228e <mu_true_answer_p+0x8e>
mov    %rax,%rdi
mov    %ebx,%esi
callq  2298 <mu_true_answer_p+0x98>
test   %rax,%rax
sete   %al
movzbl %al,%eax
neg    %eax
jmp    2267 <mu_true_answer_p+0x67>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_true_answer_p (const char *p)
{
  if (!p)
    return -1;
  while (*p && ((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISspace))
    p++;
  if (*p)
    {
      if (strchr (dgettext ("mailutils", "yY"), *p))
 return 1;
      else if (strchr (dgettext ("mailutils", "nN"), *p))
 return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 5
17 5
18 5
19 5
20 5
21 5
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 10
30 9
31 9
32 15
33 15
34 15
35 15
36 15
37 15
38 4
39 15
40 15
41 15
42 11
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 11
<<<sep_out_sample>>>
mov    %esi,%edx
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2ef7 <cpp_get_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_get_text (void)
{
        return cpp_text;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  19 <nettle_aes128_set_decrypt_key+0x9>
mov    %rbx,%rsi
mov    %rbx,%rdi
pop    %rbx
jmpq   25 <nettle_aes128_set_decrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes128_set_decrypt_key(struct aes128_ctx *ctx, const uint8_t *key)
{
  nettle_aes128_set_encrypt_key (ctx, key);
  nettle_aes128_invert_key (ctx, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
movsd  0x0(%rbp),%xmm0
lea    0x20(%rsp),%rsi
lea    0x28(%rsp),%rdi
callq  c00 <DISWorldCoordinatesToGeocentric+0x20>
movsd  0x28(%rsp),%xmm3
movsd  0x0(%rip),%xmm1        # c0e <DISWorldCoordinatesToGeocentric+0x2e>
movsd  0x0(%rip),%xmm0        # c16 <DISWorldCoordinatesToGeocentric+0x36>
mulsd  %xmm3,%xmm1
movsd  0x20(%rsp),%xmm5
mulsd  %xmm3,%xmm1
subsd  %xmm1,%xmm0
sqrtsd %xmm0,%xmm2
ucomisd %xmm2,%xmm2
jp     cd2 <DISWorldCoordinatesToGeocentric+0xf2>
movsd  0x0(%rip),%xmm1        # c3e <DISWorldCoordinatesToGeocentric+0x5e>
lea    0x20(%rsp),%rsi
lea    0x28(%rsp),%rdi
movsd  0x10(%rbp),%xmm4
divsd  %xmm2,%xmm1
movsd  %xmm3,0x18(%rsp)
movapd %xmm4,%xmm2
movsd  %xmm4,0x10(%rsp)
movsd  0x8(%rbp),%xmm0
addsd  %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
mulsd  %xmm5,%xmm2
movsd  %xmm2,(%rsp)
callq  c7e <DISWorldCoordinatesToGeocentric+0x9e>
movsd  0x8(%rsp),%xmm1
movsd  0x28(%rsp),%xmm0
movsd  (%rsp),%xmm2
mulsd  0x0(%rip),%xmm1        # c97 <DISWorldCoordinatesToGeocentric+0xb7>
mulsd  %xmm2,%xmm0
movsd  0x20(%rsp),%xmm5
movsd  0x10(%rsp),%xmm4
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x8(%rbx)
mulsd  %xmm2,%xmm5
movapd %xmm1,%xmm0
addsd  %xmm4,%xmm0
movsd  %xmm5,(%rbx)
mulsd  %xmm3,%xmm0
movsd  %xmm0,0x10(%rbx)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
movsd  %xmm5,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  ce2 <DISWorldCoordinatesToGeocentric+0x102>
movsd  0x8(%rsp),%xmm5
movapd %xmm0,%xmm2
movsd  (%rsp),%xmm3
jmpq   c36 <DISWorldCoordinatesToGeocentric+0x56>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
DISWorldCoordinatesToGeocentric(WorldCoordinates * w,
        dis_world_coordinates * p)
{
 double N, N1;
 double cos_latitude, sin_latitude;
 sin_latitude = sin(w->latitude);
 cos_latitude = cos(w->latitude);
 N = 6378137.0 / sqrt(1.0 - (0.006694380004260806515 * sin_latitude * sin_latitude));
 N1 = N + w->z;
 p->x = N1 * cos_latitude * cos(w->longitude);
 p->y = N1 * cos_latitude * sin(w->longitude);
 p->z = (((6356752.3142 * 6356752.3142) / (6378137.0 * 6378137.0)) * N + w->z) * sin_latitude;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 9
24 8
25 8
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 12
35 12
36 10
37 12
38 11
39 10
40 12
41 12
42 11
43 10
44 12
45 12
46 10
47 12
48 12
49 13
50 13
51 13
52 13
53 13
54 13
55 8
56 8
57 8
58 8
59 8
60 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  50e <sh_invalidsig+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   51c <sh_invalidsig+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_invalidsig (s)
     char *s;
{
  builtin_error (gettext("%s: invalid signal specification"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbx
xor    %r9d,%r9d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
mov    $0x0,%r8d
sub    $0x20,%rsp
mov    $0x22b8,%esi
mov    $0x8,%edi
movl   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movl   $0x4,(%rsp)
callq  44 <main+0x44>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     60 <main+0x60>
callq  56 <main+0x56>
mov    %rbx,%rdi
callq  5e <main+0x5e>
xor    %eax,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main ()
{
  struct MHD_Daemon *daemon;
  daemon = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY, 8888, ((void *)0), ((void *)0),
                             &answer_to_connection, ((void *)0),
                             MHD_OPTION_NOTIFY_COMPLETED, request_completed,
                             ((void *)0), MHD_OPTION_END);
  if (((void *)0) == daemon)
    return 1;
  (void) getchar ();
  MHD_stop_daemon (daemon);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 9
17 8
18 8
19 10
20 11
21 11
22 12
23 13
24 13
25 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1b60 <sdp_key_free+0x50>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     1b2f <sdp_key_free+0x1f>
mov    0x0(%rip),%rax        # 1b28 <sdp_key_free+0x18>
test   %rax,%rax
je     1b78 <sdp_key_free+0x68>
callq  *%rax
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     1b46 <sdp_key_free+0x36>
mov    0x0(%rip),%rax        # 1b3f <sdp_key_free+0x2f>
test   %rax,%rax
je     1b80 <sdp_key_free+0x70>
callq  *%rax
mov    0x0(%rip),%rax        # 1b4d <sdp_key_free+0x3d>
mov    %rbx,%rdi
test   %rax,%rax
je     1b68 <sdp_key_free+0x58>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   1b75 <sdp_key_free+0x65>
nopl   (%rax)
callq  1b7d <sdp_key_free+0x6d>
jmp    1b2f <sdp_key_free+0x1f>
nop
callq  1b85 <sdp_key_free+0x75>
jmp    1b46 <sdp_key_free+0x36>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_key_free (sdp_key_t * key)
{
  if (key == ((void *)0))
    return;
  { if (key->k_keytype!=((void *)0)) { if (osip_free_func) osip_free_func(key->k_keytype); else free(key->k_keytype);} };
  { if (key->k_keydata!=((void *)0)) { if (osip_free_func) osip_free_func(key->k_keydata); else free(key->k_keydata);} };
  { if (key!=((void *)0)) { if (osip_free_func) osip_free_func(key); else free(key);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 8
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 7
32 7
33 5
34 5
35 5
36 6
37 6
38 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17f9 <get1c+0x9>
mov    0x0(%rip),%edx        # 17ff <get1c+0xf>
test   %edx,%edx
je     1838 <get1c+0x48>
addl   $0x1,0x0(%rip)        # 180a <get1c+0x1a>
xor    %edx,%edx
mov    %edx,0x0(%rip)        # 1812 <get1c+0x22>
xor    %edx,%edx
cmp    $0xa,%eax
sete   %dl
test   %edx,%edx
mov    %edx,0x0(%rip)        # 1822 <get1c+0x32>
je     182e <get1c+0x3e>
movl   $0x0,0x0(%rip)        # 182e <get1c+0x3e>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%ecx        # 183e <get1c+0x4e>
lea    0x1(%rcx),%edx
jmp    180c <get1c+0x1c>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get1c(FILE *fp)
{
  int c;
  c = _IO_getc (fp);
  if (newline)
    {
      lineno++;
      column = 0;
    }
  else
    column++;
  newline = (c == '\n');
  if (newline)
    pound = 0;
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 7
7 8
8 8
9 12
10 12
11 12
12 13
13 12
14 13
15 14
16 16
17 16
18 16
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     930 <gsl_vector_uint_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  94f <gsl_vector_uint_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_uint_view_array ( unsigned int * base, size_t n)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = (unsigned int *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # ad7 <parse_help_input+0x7>
jne    b08 <parse_help_input+0x38>
mov    (%rdi),%edx
cmp    $0x2d,%edx
je     b10 <parse_help_input+0x40>
jle    af8 <parse_help_input+0x28>
cmp    $0x45,%edx
je     aec <parse_help_input+0x1c>
cmp    $0x65,%edx
jne    b08 <parse_help_input+0x38>
mov    $0x0,%eax
retq   
nopw   0x0(%rax,%rax,1)
cmp    $0x20,%edx
mov    $0x0,%eax
jne    b08 <parse_help_input+0x38>
repz retq 
nopl   0x0(%rax)
jmpq   b0d <parse_help_input+0x3d>
nopl   (%rax)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_help_input(int *kbinput)
{
    if (!meta_key) {
 switch (*kbinput) {
     case ' ':
  return do_page_down;
     case '-':
  return do_page_up;
     case 'E':
     case 'e':
  return do_exit;
 }
    }
    return func_from_key(kbinput);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 11
12 11
13 11
14 4
15 6
16 4
17 15
18 15
19 14
20 14
21 8
22 15
23 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1009 <check_superuser+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_superuser (void)
{
  if (getuid () == 0)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 6
6 3
7 6
8 6
<<<sep_out_sample>>>
mov    %rdx,%rdi
mov    %ecx,%esi
mov    %r8d,%edx
jmpq   d <qcopy_acl+0xd>
<<<sep_in_sample>>>
qcopy_acl (const char *src_name, int source_desc, const char *dst_name,
           int dest_desc, mode_t mode)
{
  return qset_acl (dst_name, dest_desc, mode);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 2f17 <cpp_set_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_set_in (FILE * in_str )
{
        cpp_in = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
cmp    $0x4d2,%esi
je     38 <CDB___db_byteorder+0x38>
cmp    $0x10e1,%esi
mov    $0xffff874f,%eax
je     32 <CDB___db_byteorder+0x32>
test   %esi,%esi
je     38 <CDB___db_byteorder+0x38>
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%esi
callq  29 <CDB___db_byteorder+0x29>
add    $0x8,%rsp
mov    $0x16,%eax
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
CDB___db_byteorder(dbenv, lorder)
 DB_ENV *dbenv;
 int lorder;
{
 switch (lorder) {
 case 0:
  break;
 case 1234:
  break;
 case 4321:
  return ((-30897));
 default:
  CDB___db_err(dbenv,
     "unsupported byte order, only big and little-endian supported");
  return (22);
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 11
5 5
6 5
7 5
8 4
9 13
10 13
11 13
12 18
13 15
14 18
15 18
16 17
17 17
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  b2bc <gsl_sf_ellint_RF+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    b2d0 <gsl_sf_ellint_RF+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x285,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b2e6 <gsl_sf_ellint_RF+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_RF(double x, double y, double z, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_RF_e(x, y, z, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_RF_e(x, y, z, mode, &result)", "ellint.c", 645, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
test   %rdi,%rdi
jne    850 <mu_server_add_connection+0x20>
mov    $0x16,%eax
add    $0x20,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %rcx,%rcx
je     83d <mu_server_add_connection+0xd>
mov    $0x30,%edi
mov    %r8,0x18(%rsp)
mov    %rcx,0x10(%rsp)
mov    %rdx,0x8(%rsp)
mov    %esi,0x4(%rsp)
callq  872 <mu_server_add_connection+0x42>
mov    %rax,%rdi
mov    $0xc,%eax
test   %rdi,%rdi
je     842 <mu_server_add_connection+0x12>
mov    0xa8(%rbx),%rax
mov    0x4(%rsp),%esi
mov    0x10(%rsp),%rcx
mov    0x18(%rsp),%r8
mov    0x8(%rsp),%rdx
movq   $0x0,(%rdi)
test   %rax,%rax
mov    %esi,0x10(%rdi)
mov    %rax,0x8(%rdi)
mov    %rcx,0x18(%rdi)
mov    %r8,0x20(%rdi)
mov    %rdx,0x28(%rdi)
je     8d0 <mu_server_add_connection+0xa0>
mov    %rdi,(%rax)
mov    %rdi,0xa8(%rbx)
add    $0x20,%rsp
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %rdi,0xa0(%rbx)
jmp    8bb <mu_server_add_connection+0x8b>
<<<sep_in_sample>>>
mu_server_add_connection (mu_server_t srv,
     int fd, void *data,
     mu_conn_loop_fp loop, mu_conn_free_fp free)
{
  struct _mu_connection *p;
  if (!srv || !loop)
    return 22;
  p = malloc (sizeof (*p));
  if (!p)
    return 12;
  p->fd = fd;
  p->f_loop = loop;
  p->f_free = free;
  p->data = data;
  p->next = ((void *)0);
  p->prev = srv->tail;
  if (srv->tail)
    srv->tail->next = p;
  else
    srv->head = p;
  srv->tail = p;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 7
7 23
8 23
9 23
10 23
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 10
21 9
22 9
23 16
24 11
25 12
26 13
27 14
28 15
29 17
30 11
31 16
32 12
33 13
34 14
35 17
36 18
37 21
38 23
39 22
40 23
41 23
42 23
43 20
44 20
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    (%rdi),%r8
je     c7a <gsl_stats_ulong_max_index+0x3a>
shl    $0x3,%rsi
xor    %eax,%eax
xor    %ecx,%ecx
jmp    c5b <gsl_stats_ulong_max_index+0x1b>
nopw   0x0(%rax,%rax,1)
mov    %r10,%r8
mov    (%rdi),%r9
mov    %r8,%r10
cmp    %r8,%r9
cmovae %r9,%r10
cmova  %rcx,%rax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    c58 <gsl_stats_ulong_max_index+0x18>
repz retq 
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ulong_max_index (const unsigned long data[], const size_t stride,
                                const size_t n)
{
  unsigned long max = data[0 * stride];
  size_t i, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned long xi = data[i * stride];
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  return max_index;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
5 5
6 6
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 6
16 6
17 6
18 6
19 16
20 5
21 16
22 16
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
ucomisd %xmm1,%xmm2
ja     80 <gsl_multimin_test_size+0x20>
xor    %eax,%eax
ucomisd %xmm0,%xmm1
seta   %al
lea    -0x2(%rax,%rax,1),%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0xd,%ecx
mov    $0x31,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9d <gsl_multimin_test_size+0x3d>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multimin_test_size (const double size, double epsabs)
{
  if (epsabs < 0.0)
    {
      do { gsl_error ("absolute tolerance is negative", "convergence.c", 49, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
    }
  if (size < epsabs)
    {
      return GSL_SUCCESS;
    }
  return GSL_CONTINUE;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 11
5 11
6 11
7 11
8 11
9 11
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 12
18 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2356 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_diagonal (gsl_matrix_short * m)
{
  _gsl_vector_short_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_short v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     280 <iso9660_xa_free+0x10>
jmpq   27a <iso9660_xa_free+0xa>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_xa_free (iso9660_xa_t *_xa)
{
  if (_xa != ((void *)0))
    free(_xa);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 7b6 <gsl_vector_complex_float_const_ptr+0x6>
test   %eax,%eax
je     7bf <gsl_vector_complex_float_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    7d0 <gsl_vector_complex_float_const_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xf0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7ed <gsl_vector_complex_float_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_const_ptr (const gsl_vector_complex_float * v,
                                    const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_float.h", 240, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return ((gsl_complex_float*)&((v)->data[2*(i)*(v)->stride]));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 3
12 6
13 6
14 6
15 6
16 6
17 6
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rsi
test   %rsi,%rsi
je     b07 <wordsplit_free_words+0x57>
mov    0x10(%rdi),%rax
xor    %ebx,%ebx
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdx
lea    (%rax,%rbx,1),%rcx
mov    (%rdx,%rcx,8),%rdi
test   %rdi,%rdi
je     afe <wordsplit_free_words+0x4e>
callq  ae6 <wordsplit_free_words+0x36>
mov    0x10(%rbp),%rax
mov    0x8(%rbp),%rdx
mov    0x0(%rbp),%rsi
lea    (%rbx,%rax,1),%rcx
movq   $0x0,(%rdx,%rcx,8)
add    $0x1,%rbx
cmp    %rsi,%rbx
jb     ad0 <wordsplit_free_words+0x20>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_words (struct wordsplit *ws)
{
  size_t i;
  for (i = 0; i < ws->ws_wordc; i++)
    {
      char *p = ws->ws_wordv[ws->ws_offs + i];
      if (p)
 {
   free (p);
   ws->ws_wordv[ws->ws_offs + i] = ((void *)0);
 }
    }
  ws->ws_wordc = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
14 7
15 7
16 9
17 10
18 10
19 10
20 10
21 10
22 4
23 4
24 4
25 13
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
sub    $0x98,%rsp
callq  3c40 <is_dir+0x10>
mov    %rsp,%rsi
mov    %rax,%rdi
mov    %rax,%rbx
callq  3c4e <is_dir+0x1e>
cmp    $0xffffffff,%eax
je     3c65 <is_dir+0x35>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %bpl
mov    %rbx,%rdi
callq  3c6d <is_dir+0x3d>
add    $0x98,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
is_dir(const char *buf)
{
    char *dirptr;
    struct stat fileinfo;
    _Bool retval;
    ((void) (0));
    dirptr = real_dir_from_tilde(buf);
    retval = (stat(dirptr, &fileinfo) != -1 && ((((fileinfo.st_mode)) & 0170000) == (0040000)));
    free(dirptr);
    return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 8
7 8
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 11
<<<sep_out_sample>>>
movl   $0x14,0x90(%rdi)
movq   $0x0,0x228(%rdi)
movq   $0x0,0x230(%rdi)
movq   $0x0,0x238(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
CDB___txn_dbenv_create(dbenv)
 DB_ENV *dbenv;
{
 dbenv->tx_max = 20;
 dbenv->set_tx_max = __txn_set_tx_max;
 dbenv->set_tx_recover = __txn_set_tx_recover;
 dbenv->set_tx_timestamp = __txn_set_tx_timestamp;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 7
6 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     18 <udf_get_filename+0x18>
mov    (%rdi),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
cmovne %rdx,%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
udf_get_filename(const udf_dirent_t *p_udf_dirent)
{
  if (!p_udf_dirent) return ((void *)0);
  if (!p_udf_dirent->psz_name) return "..";
  return p_udf_dirent->psz_name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 3
10 6
11 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  c9 <is_blank_mbchar+0x9>
movzbl (%rbx),%edx
mov    (%rax),%rax
pop    %rbx
movzwl (%rax,%rdx,2),%eax
and    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_blank_mbchar(const char *c)
{
    ((void) (0));
 return ((*__ctype_b_loc ())[(int) (((unsigned char)*c))] & (unsigned short int) _ISblank);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%rsi
cmp    %rsi,0x8(%rdi)
cmovbe 0x8(%rdi),%rsi
mov    0x10(%rdi),%rax
test   %rsi,%rsi
je     44e5 <gsl_matrix_long_add_diagonal+0x45>
lea    0x8(,%rax,8),%r8
mov    0x18(%rdi),%rax
xor    %edx,%edx
nopl   0x0(%rax,%rax,1)
cvtsi2sdq (%rax),%xmm1
addsd  %xmm0,%xmm1
add    $0x1,%rdx
cvttsd2si %xmm1,%rcx
mov    %rcx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    44c8 <gsl_matrix_long_add_diagonal+0x28>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_add_diagonal (gsl_matrix_long * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 10
13 8
14 10
15 10
16 10
17 8
18 8
19 13
20 13
21 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x40,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
testb  $0x1,0x0(%rip)        # 965 <mangled_patch+0x25>
jne    9a0 <mangled_patch+0x60>
callq  96c <mangled_patch+0x2c>
lea    0x20(%rsp),%rdi
lea    (%rax,%rbp,1),%rsi
callq  97a <mangled_patch+0x3a>
mov    %rax,%rbp
callq  982 <mangled_patch+0x42>
lea    (%rax,%rbx,1),%rsi
mov    %rsp,%rdi
callq  98e <mangled_patch+0x4e>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  9a0 <mangled_patch+0x60>
mov    %rsi,%rdi
callq  9a8 <mangled_patch+0x68>
mov    %rbx,%rdi
mov    %eax,%r12d
callq  9b3 <mangled_patch+0x73>
movsbl %r12b,%edx
movsbl %al,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  9c6 <mangled_patch+0x86>
jmp    967 <mangled_patch+0x27>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mangled_patch (lin old, lin new)
{
  char numbuf0[(sizeof (lin) * 8 / 3 + 1) + 1];
  char numbuf1[(sizeof (lin) * 8 / 3 + 1) + 1];
  if (debug & 1)
    say ("oldchar = '%c', newchar = '%c'\n",
        pch_char (old), pch_char (new));
  fatal ("Out-of-sync patch, lines %s,%s -- mangled text or line numbers, "
        "maybe?",
        format_linenum (numbuf0, pch_hunk_beg () + old),
        format_linenum (numbuf1, pch_hunk_beg () + new));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 11
13 8
14 8
15 8
16 8
17 10
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 6
32 6
33 6
34 6
35 6
36 6
37 6
<<<sep_out_sample>>>
testb  $0x20,0x240(%rdi)
jne    d0 <__log_set_lg_bsize+0x40>
mov    0x50(%rdi),%eax
shr    $0x2,%eax
cmp    %esi,%eax
jb     b0 <__log_set_lg_bsize+0x20>
mov    %esi,0x4c(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%esi
callq  c0 <__log_set_lg_bsize+0x30>
mov    $0x16,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%edx
mov    $0x0,%esi
jmpq   df <__log_set_lg_bsize+0x4f>
nop
<<<sep_in_sample>>>
__log_set_lg_bsize(dbenv, lg_bsize)
 DB_ENV *dbenv;
 u_int32_t lg_bsize;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_lg_bsize", 1));;
 if (lg_bsize > dbenv->lg_max / 4) {
  CDB___db_err(dbenv, "log buffer size must be <= log file size / 4");
  return (22);
 }
 dbenv->lg_bsize = lg_bsize;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 10
8 11
9 11
10 11
11 4
12 7
13 7
14 7
15 8
16 12
17 12
18 12
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    (%rdi),%eax
je     1266 <gsl_stats_int_min+0x26>
shl    $0x2,%rsi
xor    %ecx,%ecx
nopl   (%rax)
mov    (%rdi),%r8d
cmp    %r8d,%eax
cmovg  %r8d,%eax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    1250 <gsl_stats_int_min+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_int_min (const int data[], const size_t stride,
                          const size_t n)
{
  int min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      int xi = data[i * stride];
      if (xi < min)
        min = xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
5 6
6 6
7 8
8 8
9 8
10 6
11 6
12 6
13 6
14 13
15 13
<<<sep_out_sample>>>
movzbl 0x0(%rip),%eax        # 1667 <history_has_changed+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_has_changed(void)
{
    return history_changed;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <lmniel_free+0x11>
callq  11 <lmniel_free+0x11>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     1f <lmniel_free+0x1f>
callq  1f <lmniel_free+0x1f>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     2d <lmniel_free+0x2d>
callq  2d <lmniel_free+0x2d>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     3b <lmniel_free+0x3b>
callq  3b <lmniel_free+0x3b>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     49 <lmniel_free+0x49>
callq  49 <lmniel_free+0x49>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     57 <lmniel_free+0x57>
callq  57 <lmniel_free+0x57>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     65 <lmniel_free+0x65>
callq  65 <lmniel_free+0x65>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     78 <lmniel_free+0x78>
pop    %rbx
jmpq   74 <lmniel_free+0x74>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lmniel_free(void *vstate)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  if (state->A)
    gsl_matrix_free(state->A);
  if (state->J)
    gsl_matrix_free(state->J);
  if (state->diag)
    gsl_vector_free(state->diag);
  if (state->rhs)
    gsl_vector_free(state->rhs);
  if (state->work)
    gsl_vector_free(state->work);
  if (state->A_copy)
    gsl_matrix_free(state->A_copy);
  if (state->x_trial)
    gsl_vector_free(state->x_trial);
  if (state->f_trial)
    gsl_vector_free(state->f_trial);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 15
27 16
28 16
29 16
30 17
31 18
32 18
33 18
34 20
35 19
36 19
37 20
38 20
39 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %esi,%ebx
sub    $0x8,%rsp
test   %esi,%esi
jne    3c28 <jcopy_markers_setup+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xffff,%edx
mov    $0xfe,%esi
mov    %rdi,%rbp
callq  3c3a <jcopy_markers_setup+0x2a>
cmp    $0x2,%ebx
jne    3c1c <jcopy_markers_setup+0xc>
mov    $0xe0,%bl
nopl   0x0(%rax)
mov    %ebx,%esi
mov    $0xffff,%edx
mov    %rbp,%rdi
add    $0x1,%ebx
callq  3c5a <jcopy_markers_setup+0x4a>
cmp    $0xf0,%ebx
jne    3c48 <jcopy_markers_setup+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
jcopy_markers_setup (j_decompress_ptr srcinfo, JCOPY_OPTION option)
{
  int m;
  if (option != JCOPYOPT_NONE) {
    jpeg_save_markers(srcinfo, 0xFE, 0xFFFF);
  }
  if (option == JCOPYOPT_ALL) {
    for (m = 0; m < 16; m++)
      jpeg_save_markers(srcinfo, 0xE0 + m, 0xFFFF);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 11
8 11
9 11
10 11
11 11
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 9
21 9
22 9
23 9
24 9
25 8
26 8
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
mov    0x28(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x28,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
jmpq   65 <alphabetic+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alphabetic (c)
     int c;
{
  return rl_alphabetic (c);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     25e <_cdio_strdup_upper+0x3e>
callq  230 <_cdio_strdup_upper+0x10>
movzbl (%rax),%edi
mov    %rax,%rbp
test   %dil,%dil
je     254 <_cdio_strdup_upper+0x34>
mov    %rax,%rbx
xchg   %ax,%ax
callq  245 <_cdio_strdup_upper+0x25>
add    $0x1,%rbx
mov    %al,-0x1(%rbx)
movzbl (%rbx),%edi
test   %dil,%dil
jne    240 <_cdio_strdup_upper+0x20>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
xor    %ebp,%ebp
jmp    254 <_cdio_strdup_upper+0x34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_cdio_strdup_upper (const char str[])
{
  char *new_str = ((void *)0);
  if (str)
    {
      char *p;
      p = new_str = strdup (str);
      while (*p)
        {
          *p = toupper ((unsigned char) *p);
          p++;
        }
    }
  return new_str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 7
7 8
8 7
9 8
10 8
11 8
12 8
13 10
14 11
15 10
16 8
17 8
18 8
19 15
20 15
21 15
22 15
23 15
24 3
25 3
26 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # f56 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movslq 0xc(%rdi),%rdx
mov    0x0(%rip),%rax        # 344 <smtp_client_rcpt+0x14>
mov    0x0(%rip),%rsi        # 34b <smtp_client_rcpt+0x1b>
xor    %edi,%edi
mov    (%rax,%rdx,8),%rbp
mov    $0x0,%edx
callq  35b <smtp_client_rcpt+0x2b>
mov    0x0(%rip),%rsi        # 362 <smtp_client_rcpt+0x32>
xor    %edi,%edi
mov    %rbp,%rdx
callq  36c <smtp_client_rcpt+0x3c>
mov    0x0(%rip),%rsi        # 373 <smtp_client_rcpt+0x43>
xor    %edi,%edi
mov    $0x0,%edx
callq  37f <smtp_client_rcpt+0x4f>
mov    0x18(%rbx),%rdx
mov    0x0(%rip),%rsi        # 38a <smtp_client_rcpt+0x5a>
xor    %edi,%edi
callq  391 <smtp_client_rcpt+0x61>
mov    0x18(%rbx),%rdi
mov    $0x0,%esi
callq  39f <smtp_client_rcpt+0x6f>
test   %eax,%eax
je     3b8 <smtp_client_rcpt+0x88>
movl   $0x4,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   3c6 <smtp_client_rcpt+0x96>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_client_rcpt (struct smtp_client_context *ctx)
{
  char *addr = x_argv[ctx->rcpt];
  swrite (0, remote_server, "RCPT TO:<");
  swrite (0, remote_server, addr);
  swrite (0, remote_server, ">""\r\n");
  smtp_reply_get (0, remote_server, ctx->reply);
  if (!smtp_reply_code_eq (ctx->reply, "250"))
    {
      smtp_client_failure (ctx);
      return;
    }
  ctx->state = smtp_client_state_data;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 3
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 13
30 14
31 14
32 14
33 14
34 14
35 14
36 10
37 14
38 14
39 10
40 10
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # f77 <mu_cfg_yyget_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yyget_text (void)
{
        return mu_cfg_yytext;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     8b98 <internal_wstrmatch+0x58>
test   %rdi,%rdi
mov    %rdi,%rbp
je     8b98 <internal_wstrmatch+0x58>
mov    %rsi,%rdi
mov    %edx,%r12d
callq  8b65 <internal_wstrmatch+0x25>
mov    %rbp,%rdi
lea    (%rbx,%rax,4),%r13
callq  8b71 <internal_wstrmatch+0x31>
add    $0x8,%rsp
mov    %rbx,%rdi
lea    0x0(%rbp,%rax,4),%rcx
pop    %rbx
mov    %rbp,%rdx
mov    %r12d,%r8d
mov    %r13,%rsi
pop    %rbp
pop    %r12
pop    %r13
jmpq   7800 <gmatch_wc.part.2>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
internal_wstrmatch (pattern, string, flags)
     wchar_t *pattern;
     wchar_t *string;
     int flags;
{
  wchar_t *se, *pe;
  if (string == 0 || pattern == 0)
    return 1;
  se = string + wcslen((wchar_t *)string);
  pe = pattern + wcslen((wchar_t *)pattern);
  return (gmatch_wc (string, se, pattern, pe, flags));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 9
17 10
18 12
19 12
20 10
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x80(%rdi)
je     390 <_ping_setbuf+0x50>
cmpq   $0x0,0x78(%rbx)
je     368 <_ping_setbuf+0x28>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
movslq 0x70(%rbx),%rbp
mov    %rbp,%rdi
callq  374 <_ping_setbuf+0x34>
test   %rax,%rax
mov    %rax,0x78(%rbx)
je     3b2 <_ping_setbuf+0x72>
mov    %rbp,%rdx
xor    %esi,%esi
mov    %rax,%rdi
callq  38a <_ping_setbuf+0x4a>
jmp    35a <_ping_setbuf+0x1a>
nopl   0x0(%rax)
mov    0x50(%rdi),%rax
test   %sil,%sil
lea    0x8(%rax),%rdi
jne    3a1 <_ping_setbuf+0x61>
lea    0x50(%rax),%rdi
callq  3a6 <_ping_setbuf+0x66>
test   %rax,%rax
mov    %rax,0x80(%rbx)
jne    353 <_ping_setbuf+0x13>
mov    $0xffffffff,%eax
jmp    35c <_ping_setbuf+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_ping_setbuf (PING * p, _Bool use_ipv6)
{
  if (!p->ping_buffer)
    {
      p->ping_buffer = malloc (((use_ipv6)? ((p)->ping_datalen + sizeof (struct icmp6_hdr)) : (60 + (p)->ping_datalen + (8 + 3 * sizeof (n_time)))));
      if (!p->ping_buffer)
 return -1;
    }
  if (!p->ping_cktab)
    {
      p->ping_cktab = malloc (p->ping_cktab_size);
      if (!p->ping_cktab)
 return -1;
      memset (p->ping_cktab, 0, p->ping_cktab_size);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 9
8 9
9 16
10 17
11 17
12 17
13 17
14 17
15 11
16 11
17 11
18 12
19 11
20 12
21 14
22 14
23 14
24 14
25 14
26 14
27 5
28 5
29 5
30 5
31 5
32 5
33 6
34 5
35 6
36 7
37 7
38 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8 <osip_dialog_set_state+0x8>
mov    %esi,0x58(%rdi)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_dialog_set_state (osip_dialog_t * dialog, state_t state)
{
  if (dialog == ((void *)0))
    return;
  dialog->state = state;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 11eb <handler+0xb>
mov    $0x10,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  11ff <handler+0x1f>
mov    0x0(%rip),%rdi        # 1206 <handler+0x26>
callq  120b <handler+0x2b>
mov    $0xa,%edi
callq  1215 <handler+0x35>
xor    %edi,%edi
callq  121c <handler+0x3c>
<<<sep_in_sample>>>
handler(int sig)
{
  (void)fputs ("\ninterrupted at ", stdout);
  display_date (last_time);
  (void)putchar ('\n');
  exit(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 4da <send_delete+0xa>
movb   $0x2,0x0(%rip)        # 4e1 <send_delete+0x11>
callq  4e6 <send_delete+0x16>
mov    %eax,0x0(%rip)        # 4ec <send_delete+0x1c>
mov    $0x2,%eax
mov    0x0(%rip),%edi        # 4f7 <send_delete+0x27>
mov    %ax,0x0(%rip)        # 4fe <send_delete+0x2e>
mov    0x0(%rip),%eax        # 504 <send_delete+0x34>
xor    %ecx,%ecx
mov    $0x10,%r9d
mov    $0x0,%r8d
mov    $0x54,%edx
mov    $0x0,%esi
mov    %eax,0x0(%rip)        # 522 <send_delete+0x52>
callq  527 <send_delete+0x57>
cmp    $0x54,%rax
je     537 <send_delete+0x67>
mov    $0x0,%edi
callq  537 <send_delete+0x67>
mov    0x0(%rip),%edi        # 53d <send_delete+0x6d>
callq  542 <send_delete+0x72>
mov    0x0(%rip),%edi        # 548 <send_delete+0x78>
mov    %eax,0x0(%rip)        # 54e <send_delete+0x7e>
xor    %ecx,%ecx
mov    0x0(%rip),%eax        # 556 <send_delete+0x86>
mov    $0x10,%r9d
mov    $0x0,%r8d
mov    $0x54,%edx
mov    $0x0,%esi
mov    %eax,0x0(%rip)        # 572 <send_delete+0xa2>
callq  577 <send_delete+0xa7>
cmp    $0x54,%rax
je     587 <send_delete+0xb7>
mov    $0x0,%edi
callq  587 <send_delete+0xb7>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_delete (void)
{
  msg.type = 2;
  msg.id_num = htonl (remote_id);
  daemon_addr.sin_family = 2;
  daemon_addr.sin_addr = his_machine_addr;
  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,
       (struct sockaddr *) &daemon_addr,
       sizeof (daemon_addr)) != sizeof (msg))
    perror ("send_delete (remote)");
  msg.id_num = htonl (local_id);
  daemon_addr.sin_addr = my_machine_addr;
  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,
       (struct sockaddr *) &daemon_addr,
       sizeof (daemon_addr)) != sizeof (msg))
    perror ("send_delete (local)");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 4
5 4
6 5
7 7
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 6
16 7
17 7
18 7
19 10
20 10
21 11
22 11
23 13
24 11
25 13
26 12
27 13
28 13
29 13
30 13
31 12
32 13
33 13
34 13
35 16
36 16
37 18
38 18
39 18
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 1567 <readlink_diag+0x7>
jne    1570 <readlink_diag+0x10>
jmpq   156e <readlink_diag+0xe>
xchg   %ax,%ax
jmpq   1575 <readlink_diag+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
readlink_diag (char const *name)
{
  if (ignore_failed_read_option)
    readlink_warn (name);
  else
    readlink_error (name);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 4
6 4
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 167 <current_history+0x7>
cmp    0x0(%rip),%eax        # 16d <current_history+0xd>
je     180 <current_history+0x20>
mov    0x0(%rip),%rdx        # 176 <current_history+0x16>
test   %rdx,%rdx
je     180 <current_history+0x20>
mov    (%rdx,%rax,8),%rax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
current_history ()
{
  return ((history_offset == history_length) || the_history == 0)
  ? (HIST_ENTRY *)((void *)0)
  : the_history[history_offset];
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 3
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_inquire_context (OM_uint32 * minor_status,
       const gss_ctx_id_t context_handle,
       gss_name_t * src_name,
       gss_name_t * targ_name,
       OM_uint32 * lifetime_rec,
       gss_OID * mech_type,
       OM_uint32 * ctx_flags, int *locally_initiated, int *open)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 10
2 10
3 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     c21 <savebuf+0x41>
mov    %rdi,%rbp
mov    %rsi,%rdi
callq  bf9 <savebuf+0x19>
test   %rax,%rax
je     c18 <savebuf+0x38>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  c0c <savebuf+0x2c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x0(%rip)        # c1f <savebuf+0x3f>
je     c2a <savebuf+0x4a>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
callq  c2f <savebuf+0x4f>
nop
<<<sep_in_sample>>>
savebuf (char const *s, size_t size)
{
  char *rv;
  if (! size)
    return ((void *)0);
  rv = malloc (size);
  if (! rv)
    {
      if (! using_plan_a)
 xalloc_die ();
    }
  else
    memcpy (rv, s, size);
  return rv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 13
13 13
14 13
15 13
16 15
17 15
18 15
19 15
20 15
21 9
22 9
23 15
24 5
25 15
26 15
27 15
28 10
29 10
<<<sep_out_sample>>>
mov    (%rsi),%rdx
mov    (%rdi),%rax
mov    (%rdx),%rsi
mov    (%rax),%rdi
jmpq   a71 <compare_references+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
compare_references (const void *entry1, const void *entry2)
{
  REFERENCE **e1 = (REFERENCE **) entry1;
  REFERENCE **e2 = (REFERENCE **) entry2;
  return mbscasecmp ((*e1)->label, (*e2)->label);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rsi,%rcx
mov    $0xe,%edi
mov    $0x8,%esi
jmpq   15 <nettle_aes256_set_encrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes256_set_encrypt_key(struct aes256_ctx *ctx, const uint8_t *key)
{
  _nettle_aes_set_key (14, 32 / 4, ctx->keys, key);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
movslq (%rdi),%rdx
mov    0x18(%rdi),%rax
subq   $0x1,0xa8(%rax,%rdx,8)
mov    %esi,(%rdi)
movslq %esi,%rsi
addq   $0x1,0xa8(%rax,%rsi,8)
retq   
nop
<<<sep_in_sample>>>
rec_mset_elem_set_type (rec_mset_elem_t elem,
                        rec_mset_type_t type)
{
  elem->mset->count[elem->type]--;
  elem->type = type;
  elem->mset->count[type]++;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
test   %edi,%edi
je     1687 <gid_to_gname+0x17>
cmp    0x0(%rip),%edi        # 1685 <gid_to_gname+0x15>
je     16de <gid_to_gname+0x6e>
mov    0x0(%rip),%rdi        # 168e <gid_to_gname+0x1e>
test   %rdi,%rdi
je     169b <gid_to_gname+0x2b>
cmp    0x0(%rip),%ebx        # 1699 <gid_to_gname+0x29>
je     16c1 <gid_to_gname+0x51>
mov    %ebx,%edi
callq  16a2 <gid_to_gname+0x32>
test   %rax,%rax
je     16d8 <gid_to_gname+0x68>
mov    (%rax),%rsi
mov    $0x0,%edi
mov    %ebx,0x0(%rip)        # 16b5 <gid_to_gname+0x45>
callq  16ba <gid_to_gname+0x4a>
mov    0x0(%rip),%rdi        # 16c1 <gid_to_gname+0x51>
callq  16c6 <gid_to_gname+0x56>
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %ebx,0x0(%rip)        # 16de <gid_to_gname+0x6e>
mov    $0x0,%edi
callq  16e8 <gid_to_gname+0x78>
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gid_to_gname (gid_t gid, char **gname)
{
  struct group *group;
  if (gid != 0 && gid == cached_no_such_gid)
    {
      *gname = xstrdup ("");
      return;
    }
  if (!cached_gname || gid != cached_gid)
    {
      group = getgrgid (gid);
      if (group)
 {
   cached_gid = gid;
   assign_string (&cached_gname, group->gr_name);
 }
      else
 {
   cached_no_such_gid = gid;
   *gname = xstrdup ("");
   return;
 }
    }
  *gname = xstrdup (cached_gname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 9
11 9
12 9
13 9
14 9
15 11
16 11
17 12
18 12
19 15
20 15
21 14
22 15
23 15
24 24
25 24
26 25
27 25
28 25
29 25
30 25
31 19
32 20
33 20
34 20
35 25
36 25
37 25
38 25
39 25
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x3a,%edi
callq  2dd <regex_print_flags+0xd>
test   $0x1,%bl
jne    320 <regex_print_flags+0x50>
test   $0x2,%bl
jne    330 <regex_print_flags+0x60>
test   $0x4,%bl
jne    340 <regex_print_flags+0x70>
test   $0x20,%bl
nop
jne    310 <regex_print_flags+0x40>
and    $0x10,%ebx
jne    300 <regex_print_flags+0x30>
pop    %rbx
retq   
nopl   0x0(%rax)
pop    %rbx
mov    $0x0,%edi
xor    %eax,%eax
jmpq   30d <regex_print_flags+0x3d>
nopl   (%rax)
mov    $0x0,%edi
xor    %eax,%eax
callq  31c <regex_print_flags+0x4c>
jmp    2f2 <regex_print_flags+0x22>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  32c <regex_print_flags+0x5c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  33c <regex_print_flags+0x6c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  34c <regex_print_flags+0x7c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
<<<sep_in_sample>>>
regex_print_flags (int flags)
{
  printf (":");
  if (flags & 0x00000001)
    printf ("exact");
  else if (flags & 0x00000002)
    printf ("posix");
  else if (flags & 0x00000004)
    printf ("perl");
  if (flags & 0x00000020)
    printf (" :scase");
  if (flags & 0x00000010)
    printf (" :basic");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 10
12 10
13 10
14 12
15 12
16 14
17 14
18 14
19 14
20 13
21 13
22 13
23 13
24 11
25 11
26 11
27 11
28 11
29 5
30 5
31 5
32 5
33 5
34 7
35 7
36 7
37 7
38 7
39 9
40 9
41 9
42 9
43 9
<<<sep_out_sample>>>
sub    $0x1,%rsi
cmp    0x68(%rdi),%rsi
jae    2578 <_amd_get_message+0x18>
mov    0x78(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_amd_get_message (struct _amd_data *amd, size_t msgno)
{
  msgno--;
  if (msgno >= amd->msg_count)
    return ((void *)0);
  return amd->msg_array[msgno];
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 6
7 6
8 5
9 7
10 7
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
mov    $0x2,%edx
push   %rbp
mov    %rsi,%rbp
mov    %rdi,%rsi
mov    %rbp,%rdi
push   %rbx
callq  25a <assoc_replace+0x1a>
test   %rax,%rax
mov    %rax,%rbx
je     2c0 <assoc_replace+0x80>
cmp    %rbp,0x8(%rax)
je     27a <assoc_replace+0x3a>
mov    $0x6b,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  27a <assoc_replace+0x3a>
xor    %eax,%eax
test   %r12,%r12
mov    0x10(%rbx),%rbp
je     2ab <assoc_replace+0x6b>
mov    %r12,%rdi
callq  28d <assoc_replace+0x4d>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x6d,%edx
callq  2a0 <assoc_replace+0x60>
mov    %r12,%rsi
mov    %rax,%rdi
callq  2ab <assoc_replace+0x6b>
mov    %rax,0x10(%rbx)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    2b2 <assoc_replace+0x72>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assoc_replace (hash, key, value)
     HASH_TABLE *hash;
     char *key;
     char *value;
{
  BUCKET_CONTENTS *b;
  void * t;
  b = hash_search (key, hash, 0x02);
  if (b == 0)
    return (void *)0;
  if (b->key != key)
    sh_xfree((key), "assoc.c", 107);
  t = b->data;
  b->data = value ? (char *)strcpy (sh_xmalloc((1 + strlen (value)), "assoc.c", 109), (value)) : (char *)0;
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 8
4 5
5 5
6 8
7 8
8 5
9 8
10 9
11 8
12 9
13 11
14 11
15 12
16 12
17 12
18 12
19 14
20 14
21 13
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 15
34 16
35 16
36 16
37 16
38 16
39 10
40 10
41 10
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    720 <gsl_matrix_complex_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  742 <gsl_matrix_complex_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_superdiagonal (gsl_matrix_complex * m,
                                      const size_t k)
{
  _gsl_vector_complex_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 2;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  22d <strhash_close+0xd>
mov    0x8(%rbx),%rdi
callq  236 <strhash_close+0x16>
mov    %rbx,%rdi
pop    %rbx
jmpq   23f <strhash_close+0x1f>
<<<sep_in_sample>>>
strhash_close(STRHASH *sh)
{
 pool_close(sh->pool);
 free(sh->htab);
 free(sh);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 5
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_add_digit_to_numeric_arg (WINDOW *window, int count)
{}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r12
mov    0x18(%rdi),%rbx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rbp
test   %r12,%r12
mov    (%rbx),%eax
je     1998 <gsl_matrix_uint_max+0x238>
lea    0x0(,%rbp,4),%r13
mov    %rbx,%rdx
xor    %edi,%edi
xor    %r9d,%r9d
movdqa 0x0(%rip),%xmm2        # 179a <gsl_matrix_uint_max+0x3a>
jmpq   1956 <gsl_matrix_uint_max+0x1f6>
nop
mov    (%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x1,%rsi
je     19a8 <gsl_matrix_uint_max+0x248>
mov    0x4(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x2,%rsi
je     1a08 <gsl_matrix_uint_max+0x2a8>
mov    0x8(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x3,%rsi
je     19f8 <gsl_matrix_uint_max+0x298>
mov    0xc(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x4,%rsi
je     19e8 <gsl_matrix_uint_max+0x288>
mov    0x10(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x5,%rsi
je     19d8 <gsl_matrix_uint_max+0x278>
mov    0x14(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x6,%rsi
je     19c8 <gsl_matrix_uint_max+0x268>
mov    0x18(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
cmp    $0x8,%rsi
jne    19b8 <gsl_matrix_uint_max+0x258>
mov    0x1c(%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
mov    $0x8,%ecx
cmp    %rsi,%r8
je     1947 <gsl_matrix_uint_max+0x1e7>
mov    %r8,%r14
sub    %rsi,%r14
mov    %r14,%r10
shr    $0x2,%r10
lea    0x0(,%r10,4),%r11
test   %r11,%r11
je     1913 <gsl_matrix_uint_max+0x1b3>
mov    %eax,-0x4(%rsp)
lea    (%rdx,%rsi,4),%rsi
xor    %eax,%eax
movd   -0x4(%rsp),%xmm7
pshufd $0x0,%xmm7,%xmm0
movdqa (%rsi),%xmm3
movdqa %xmm0,%xmm1
add    $0x1,%rax
add    $0x10,%rsi
movdqa %xmm3,%xmm4
psubd  %xmm2,%xmm1
cmp    %rax,%r10
psubd  %xmm2,%xmm4
pcmpgtd %xmm4,%xmm1
pand   %xmm1,%xmm0
movdqa %xmm0,%xmm4
movdqa %xmm1,%xmm0
pandn  %xmm3,%xmm0
por    %xmm4,%xmm0
ja     1866 <gsl_matrix_uint_max+0x106>
movdqa %xmm0,%xmm5
add    %r11,%rcx
movdqa %xmm0,%xmm4
cmp    %r11,%r14
psrldq $0x8,%xmm5
movdqa %xmm5,%xmm1
psubd  %xmm2,%xmm4
movdqa %xmm5,%xmm3
psubd  %xmm2,%xmm1
pcmpgtd %xmm4,%xmm1
pand   %xmm1,%xmm3
pandn  %xmm0,%xmm1
movdqa %xmm1,%xmm0
por    %xmm3,%xmm0
movdqa %xmm0,%xmm6
movdqa %xmm0,%xmm4
psrldq $0x4,%xmm6
movdqa %xmm6,%xmm1
movdqa %xmm6,%xmm3
psubd  %xmm2,%xmm4
psubd  %xmm2,%xmm1
pcmpgtd %xmm4,%xmm1
pand   %xmm1,%xmm3
pandn  %xmm0,%xmm1
por    %xmm3,%xmm1
movdqa %xmm1,%xmm7
movd   %xmm7,-0x4(%rsp)
mov    -0x4(%rsp),%eax
je     1947 <gsl_matrix_uint_max+0x1e7>
lea    (%rdi,%rcx,1),%rsi
mov    (%rbx,%rsi,4),%esi
cmp    %esi,%eax
cmovb  %esi,%eax
lea    0x1(%rcx),%rsi
cmp    %rsi,%r8
jbe    1947 <gsl_matrix_uint_max+0x1e7>
add    %rdi,%rsi
mov    (%rbx,%rsi,4),%esi
cmp    %esi,%eax
cmovb  %esi,%eax
add    $0x2,%rcx
cmp    %rcx,%r8
jbe    1947 <gsl_matrix_uint_max+0x1e7>
add    %rdi,%rcx
mov    (%rbx,%rcx,4),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
add    $0x1,%r9
add    %r13,%rdx
add    %rbp,%rdi
cmp    %r12,%r9
je     1998 <gsl_matrix_uint_max+0x238>
test   %r8,%r8
je     1947 <gsl_matrix_uint_max+0x1e7>
mov    %rdx,%rcx
mov    %r8,%rsi
and    $0xf,%ecx
shr    $0x2,%rcx
neg    %rcx
and    $0x3,%ecx
cmp    %r8,%rcx
cmova  %r8,%rcx
cmp    $0x8,%r8
jbe    17a0 <gsl_matrix_uint_max+0x40>
test   %rcx,%rcx
jne    1a12 <gsl_matrix_uint_max+0x2b2>
xor    %esi,%esi
xor    %ecx,%ecx
jmpq   1833 <gsl_matrix_uint_max+0xd3>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
mov    $0x1,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x7,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x6,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x5,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x3,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
nopw   0x0(%rax,%rax,1)
mov    $0x2,%ecx
jmpq   182a <gsl_matrix_uint_max+0xca>
mov    %rcx,%rsi
jmpq   17a0 <gsl_matrix_uint_max+0x40>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_max (const gsl_matrix_uint * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned int max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned int x = m->data[i * tda + j];
          if (x > max)
            max = x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 6
8 4
9 5
10 8
11 6
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 12
56 12
57 12
58 10
59 10
60 10
61 10
62 10
63 10
64 10
65 10
66 10
67 10
68 2
69 2
70 2
71 2
72 2
73 2
74 2
75 2
76 2
77 2
78 2
79 2
80 2
81 2
82 2
83 2
84 2
85 2
86 2
87 2
88 2
89 2
90 2
91 2
92 2
93 2
94 2
95 2
96 2
97 2
98 2
99 2
100 2
101 2
102 2
103 2
104 2
105 2
106 2
107 2
108 2
109 2
110 2
111 2
112 2
113 2
114 2
115 2
116 2
117 12
118 12
119 12
120 12
121 10
122 10
123 10
124 12
125 12
126 12
127 12
128 10
129 10
130 10
131 12
132 12
133 12
134 12
135 8
136 8
137 8
138 8
139 8
140 10
141 10
142 10
143 10
144 10
145 10
146 10
147 10
148 10
149 10
150 10
151 10
152 10
153 10
154 10
155 10
156 10
157 10
158 18
159 18
160 18
161 18
162 18
163 18
164 18
165 10
166 10
167 10
168 10
169 10
170 10
171 10
172 10
173 10
174 10
175 10
176 10
177 10
178 10
179 10
180 10
181 10
182 10
183 10
184 10
185 10
186 10
187 10
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     2c0 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 2c7 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     2e8 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     330 <argp_version_parser+0x80>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 2ef <argp_version_parser+0x3f>
test   %rdx,%rdx
je     310 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  304 <argp_version_parser+0x54>
jmp    2d9 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rax
mov    $0x0,%esi
mov    0x30(%rax),%rdi
callq  321 <argp_version_parser+0x71>
mov    %rbx,%rdi
mov    %rax,%rsi
xor    %eax,%eax
callq  32e <argp_version_parser+0x7e>
jmp    2d9 <argp_version_parser+0x29>
xor    %edi,%edi
callq  337 <argp_version_parser+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
 (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
 fprintf (state->out_stream, "%s\n", argp_program_version);
      else
 argp_error (state, dgettext (state->root_argp->argp_domain,
           "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
 exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 17
4 20
5 20
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 13
15 13
16 13
17 20
18 20
19 20
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 14
39 14
40 14
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x8,%rsp
callq  6a2 <EvalSum+0x22>
mov    %rax,%rbp
movzbl (%rbx),%eax
cmp    $0x2b,%al
je     6dc <EvalSum+0x5c>
cmp    $0x2d,%al
jne    708 <EvalSum+0x88>
mov    %r13,%rdx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  6be <EvalSum+0x3e>
mov    %r13,%r8
mov    %rbx,%rcx
mov    %r12,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  6d2 <EvalSum+0x52>
sub    %rax,%rbp
movzbl (%rbx),%eax
cmp    $0x2b,%al
jne    6ac <EvalSum+0x2c>
mov    %r13,%rdx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  6ea <EvalSum+0x6a>
mov    %r13,%r8
mov    %rbx,%rcx
mov    %r12,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  6fe <EvalSum+0x7e>
add    %rax,%rbp
jmp    6a5 <EvalSum+0x25>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
EvalSum (PINPUTBUF pibIn, long index, PSTR *szExp, PSTR szToken,
              PINT piType)
{
  register char cOperator;
  long result, dTmp;
  result = EvalProd (pibIn, index, szExp, szToken, piType);
  while (((cOperator = *szToken) == '+') || (cOperator == '-')) {
    GetToken (szExp, szToken, piType);
    dTmp = EvalProd (pibIn, index, szExp, szToken, piType);
    switch (cOperator) {
      case '-':
        result = result - dTmp;
        break;
      case '+':
        result = result + dTmp;
        break;
      default:
        ReportError (pibIn, 0x0011 | 0x8000, *szExp,
                     "(While parsing bracketed expression)");
    }
  }
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 12
31 7
32 7
33 7
34 8
35 8
36 8
37 8
38 9
39 9
40 9
41 9
42 9
43 9
44 15
45 16
46 16
47 23
48 23
49 23
50 23
51 23
52 23
53 23
54 23
55 23
56 23
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x40(%rdi),%rax
mov    0x10(%rax),%rbp
mov    %rax,(%rsp)
test   %rbp,%rbp
je     2d9 <folder_mbox_unsubscribe+0x59>
mov    0x8(%rax),%r12
mov    %rsi,%r14
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    (%r12,%rbx,8),%r15
lea    0x0(,%rbx,8),%r13
test   %r15,%r15
je     2d0 <folder_mbox_unsubscribe+0x50>
mov    %r14,%rsi
mov    %r15,%rdi
callq  2cc <folder_mbox_unsubscribe+0x4c>
test   %eax,%eax
je     2f0 <folder_mbox_unsubscribe+0x70>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    2b0 <folder_mbox_unsubscribe+0x30>
add    $0x18,%rsp
mov    $0x1028,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
mov    %r15,%rdi
mov    %eax,0xc(%rsp)
callq  2fc <folder_mbox_unsubscribe+0x7c>
mov    (%rsp),%rax
mov    0x8(%rax),%rdx
mov    0xc(%rsp),%eax
movq   $0x0,(%rdx,%r13,1)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nop
<<<sep_in_sample>>>
folder_mbox_unsubscribe (mu_folder_t folder, const char *name)
{
  fmbox_t fmbox = folder->data;
  size_t i;
  for (i = 0; i < fmbox->sublen; i++)
    {
      if (fmbox->subscribe[i] && strcmp (fmbox->subscribe[i], name) == 0)
 {
   free (fmbox->subscribe[i]);
   fmbox->subscribe[i] = ((void *)0);
   return 0;
 }
    }
  return (0x1000 +40);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 3
11 5
12 5
13 5
14 5
15 5
16 5
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 5
27 5
28 5
29 15
30 14
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 9
40 9
41 9
42 10
43 10
44 11
45 10
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 15
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %edi,%ebp
mov    $0x48,%edi
push   %rbx
sub    $0x8,%rsp
callq  1c <file_reader_init+0x1c>
test   $0x1,%al
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x48,%r9d
jne    a0 <file_reader_init+0xa0>
test   $0x2,%dil
jne    b0 <file_reader_init+0xb0>
test   $0x4,%dil
jne    d0 <file_reader_init+0xd0>
mov    %r9d,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%r9b
rep stos %rax,%es:(%rdi)
je     57 <file_reader_init+0x57>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r9b
je     67 <file_reader_init+0x67>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%r9d
je     70 <file_reader_init+0x70>
movb   $0x0,(%rdi)
mov    %ebp,0x34(%rbx)
mov    %r13d,0x30(%rbx)
imul   %r13d,%ebp
movslq %ebp,%rdi
callq  83 <file_reader_init+0x83>
mov    %r12d,0x38(%rbx)
mov    %rax,0x28(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
mov    $0x47,%r9b
test   $0x2,%dil
je     32 <file_reader_init+0x32>
xor    %edx,%edx
add    $0x2,%rdi
sub    $0x2,%r9d
mov    %dx,-0x2(%rdi)
test   $0x4,%dil
je     3c <file_reader_init+0x3c>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%r9d
add    $0x4,%rdi
jmpq   3c <file_reader_init+0x3c>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_reader_init (int record_size, int buffered_records, int backwards)
{
  struct file_rd_info *new;
  new = (struct file_rd_info *) xmalloc (sizeof (struct file_rd_info));
  memset (new, 0, sizeof (struct file_rd_info));
  new->record_size = record_size;
  new->buffered_records = buffered_records;
  new->buffer = (char *) xmalloc (record_size * buffered_records);
  new->backwards = backwards;
  return new;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 2
9 2
10 4
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 6
37 7
38 8
39 8
40 8
41 9
42 8
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 5
52 5
53 5
54 5
55 5
56 5
57 5
58 5
59 5
60 5
61 5
62 5
63 5
64 5
65 5
66 5
67 5
<<<sep_out_sample>>>
cmp    $0x1,%rdi
sbb    %eax,%eax
and    $0x16,%eax
test   %rsi,%rsi
je     695 <mu_mailcap_entries_count+0x15>
mov    0x8(%rdi),%rdx
mov    %rdx,(%rsi)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailcap_entries_count (mu_mailcap_t mailcap, size_t *pcount)
{
  int status = 0;
  if (mailcap == ((void *)0))
    status = 22;
  if (pcount != ((void *)0))
    {
      *pcount = mailcap->entries_count;
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 8
7 8
8 11
9 11
<<<sep_out_sample>>>
push   %r12
lea    0x138(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  af <osip_message_get_record_route+0x1f>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    c8 <osip_message_get_record_route+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  c2 <osip_message_get_record_route+0x32>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
osip_message_get_record_route (const osip_message_t * sip, int pos, osip_record_route_t ** dest)
{
  osip_record_route_t *record_route;
  *dest = ((void *)0);
  if (osip_list_size (&sip->record_routes) <= pos)
    return -1;
  record_route = (osip_record_route_t *) osip_list_get (&sip->record_routes, pos);
  *dest = record_route;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 9
17 8
18 10
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_set_application_context (osip_t * osip, void *pointer)
{
  osip->application_context = pointer;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    $0x1,%ecx
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
callq  7bc7 <gsl_fft_complex_radix2_dif_inverse+0x17>
test   %eax,%eax
jne    7c1e <gsl_fft_complex_radix2_dif_inverse+0x6e>
test   %rbx,%rbx
js     7c28 <gsl_fft_complex_radix2_dif_inverse+0x78>
cvtsi2sd %rbx,%xmm1
movsd  0x0(%rip),%xmm0        # 7bdd <gsl_fft_complex_radix2_dif_inverse+0x2d>
test   %rbx,%rbx
divsd  %xmm1,%xmm0
je     7c1e <gsl_fft_complex_radix2_dif_inverse+0x6e>
mov    %r12,%rsi
mov    %rbp,%rdi
xor    %ecx,%ecx
shl    $0x4,%rsi
nopw   0x0(%rax,%rax,1)
add    $0x1,%rcx
movsd  (%rdi),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rdi)
movsd  0x8(%rdi),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rdi)
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    7bf8 <gsl_fft_complex_radix2_dif_inverse+0x48>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbx,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmp    7bd5 <gsl_fft_complex_radix2_dif_inverse+0x25>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_radix2_dif_inverse (gsl_complex_packed_array data,
                                              const size_t stride,
                                              const size_t n)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_radix2_dif_transform (data, stride, n, sign);
  if (status)
    {
      return status;
    }
  {
    const double norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((data)[2*(stride)*(i)]) *= norm;
        ((data)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 4
8 6
9 7
10 7
11 12
12 12
13 12
14 12
15 14
16 12
17 14
18 14
19 14
20 14
21 14
22 14
23 14
24 16
25 16
26 16
27 17
28 17
29 17
30 17
31 14
32 14
33 21
34 21
35 21
36 21
37 21
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 64b <re_patch+0xb>
movq   $0x0,0x0(%rip)        # 656 <re_patch+0x16>
movq   $0x0,0x0(%rip)        # 661 <re_patch+0x21>
movq   $0x0,0x0(%rip)        # 66c <re_patch+0x2c>
movq   $0xffffffffffffffff,0x0(%rip)        # 677 <re_patch+0x37>
movq   $0x0,0x0(%rip)        # 682 <re_patch+0x42>
movq   $0x0,0x0(%rip)        # 68d <re_patch+0x4d>
movb   $0x0,0x0(%rip)        # 694 <re_patch+0x54>
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
re_patch (void)
{
    p_first = 0;
    p_newfirst = 0;
    p_ptrn_lines = 0;
    p_repl_lines = 0;
    p_end = -1;
    p_max = 0;
    p_indent = 0;
    p_strip_trailing_cr = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 7
6 8
7 9
8 10
9 10
10 10
<<<sep_out_sample>>>
jmp    1d <__gmpn_neg+0x1d>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rdx
movq   $0x0,(%rdi)
je     40 <__gmpn_neg+0x40>
add    $0x8,%rsi
add    $0x8,%rdi
mov    (%rsi),%rax
test   %rax,%rax
je     8 <__gmpn_neg+0x8>
neg    %rax
sub    $0x1,%rdx
mov    %rax,(%rdi)
mov    $0x1,%eax
jne    48 <__gmpn_neg+0x48>
repz retq 
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
add    $0x8,%rsi
add    $0x8,%rdi
mov    %rax,0x8(%rsp)
callq  5e <__gmpn_neg+0x5e>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmpn_neg (mp_ptr __gmp_rp, mp_srcptr __gmp_up, mp_size_t __gmp_n)
{
  while (*__gmp_up == 0)
    {
      *__gmp_rp = 0;
      if (!--__gmp_n)
 return 0;
      ++__gmp_up; ++__gmp_rp;
    }
  *__gmp_rp = (- *__gmp_up) & ((~ ((mp_limb_t) (0))) >> 0);
  if (--__gmp_n)
    __gmpn_com (++__gmp_rp, ++__gmp_up, __gmp_n);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 5
5 6
6 8
7 8
8 3
9 3
10 3
11 10
12 11
13 10
14 13
15 11
16 14
17 14
18 7
19 14
20 14
21 2
22 12
23 12
24 12
25 12
26 12
27 14
28 14
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0x0,%esi
jmpq   c13 <mu_mailcap_entry_get_x11bitmap+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailcap_entry_get_x11bitmap (mu_mailcap_entry_t entry,
    char *buffer, size_t buflen, size_t *pn)
{
  return mu_mailcap_entry_get_value (entry, "x11-bitmap", buffer, buflen, pn);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     1e16 <gsl_vector_ushort_add_constant+0x36>
mov    0x10(%rdi),%rax
add    %r8,%r8
xor    %edx,%edx
nopl   (%rax)
movzwl (%rax),%ecx
add    $0x1,%rdx
cvtsi2sd %ecx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    1df8 <gsl_vector_ushort_add_constant+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_add_constant (gsl_vector_ushort * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 6
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
movslq %esi,%rbx
sub    $0x18,%rsp
mov    0x10(%rdi),%rax
add    0x8(%rdi),%rbx
test   %rax,%rax
je     40 <PreventLexSplit+0x40>
cmpb   $0x0,(%rax)
je     40 <PreventLexSplit+0x40>
mov    %rbx,%rsi
nopl   0x0(%rax)
sub    $0x1,%rsi
cmpb   $0xa,(%rsi)
jne    28 <PreventLexSplit+0x28>
movb   $0x0,(%rsi)
sub    %rbx,%rsi
jne    70 <PreventLexSplit+0x70>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     5a <PreventLexSplit+0x5a>
mov    %esi,0xc(%rsp)
callq  52 <PreventLexSplit+0x52>
test   %eax,%eax
mov    0xc(%rsp),%esi
je     1e <PreventLexSplit+0x1e>
cmp    $0x10000,%esi
je     1e <PreventLexSplit+0x1e>
movb   $0x0,(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rbp),%rdi
add    $0x18,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
jmpq   84 <PreventLexSplit+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
PreventLexSplit (PINPUTBUF pibIn, int iOffset)
{
  long lDelta;
  PBUF pbufEOB = pibIn->pbufOrg + iOffset;
  PBUF pbufEOBOld;
  if (!(!(pibIn) || ((!(pibIn)->pbufCur || !*(pibIn)->pbufCur) && (!(pibIn)->pfileIn || feof((pibIn)->pfileIn))))
      || (iOffset == 0x10000)) {
    pbufEOBOld = pbufEOB;
    while (*(--pbufEOB) != ('\n'))
      ;
    *pbufEOB = '\0';
    if ((lDelta = (long) (pbufEOB - pbufEOBOld)))
      fseek (pibIn->pfileIn, lDelta, 1);
  }
  else *pbufEOB = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 6
7 4
8 6
9 6
10 6
11 6
12 4
13 4
14 9
15 9
16 9
17 11
18 12
19 12
20 16
21 16
22 16
23 16
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 15
35 16
36 16
37 16
38 16
39 16
40 13
41 16
42 13
43 16
44 16
45 13
46 13
<<<sep_out_sample>>>
mov    (%rsi),%eax
xor    %edx,%edx
cmp    %eax,(%rdi)
mov    $0xffffffff,%eax
setg   %dl
cmovge %edx,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
intcmp(int *i1, int *i2)
{
  if (*i1 < *i2)
    return -1;
  else if (*i1 > *i2)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 8
8 8
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
xor    %esi,%esi
jmpq   30 <__gmpz_legendre>
<<<sep_in_sample>>>
__gmpn_divmod_1 (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)
{
  return __gmpn_divrem_1 (dst, ((mp_size_t) (0)), src, size, divisor);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   3cd8 <text_buffer_free+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
text_buffer_free (struct text_buffer *buf)
{
  free (buf->base);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x1009,%eax
je     1007 <mu_locker_set_expire_time+0x17>
test   %esi,%esi
mov    $0x16,%ax
jle    1007 <mu_locker_set_expire_time+0x17>
mov    %esi,0x14(%rdi)
xor    %al,%al
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_locker_set_expire_time (mu_locker_t locker, int etime)
{
  if (!locker)
    return (0x1000 +9);
  if (etime <= 0)
    return 22;
  locker->expire_time = etime;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 7
8 8
9 9
10 9
<<<sep_out_sample>>>
push   %rbp
lea    -0x3(%rsi),%rax
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
shr    $0x1e,%rax
sub    $0x28,%rsp
lea    0x10(%rsp),%rdi
mov    %rax,0x10(%rsp)
callq  1693 <file_timestamp_sprintf+0x23>
test   %rax,%rax
je     1730 <file_timestamp_sprintf+0xc0>
mov    0x14(%rax),%esi
mov    0x10(%rax),%ecx
mov    %rbx,%rdi
mov    0x8(%rax),%r9d
mov    0xc(%rax),%r8d
lea    0x76c(%rsi),%edx
mov    (%rax),%esi
add    $0x1,%ecx
mov    %esi,0x8(%rsp)
mov    0x4(%rax),%eax
mov    $0x0,%esi
mov    %eax,(%rsp)
xor    %eax,%eax
callq  16ce <file_timestamp_sprintf+0x5e>
mov    %rbx,%rdi
callq  16d6 <file_timestamp_sprintf+0x66>
lea    -0x3(%rbp),%edx
add    %rax,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
and    $0x3fffffff,%edx
callq  16f1 <file_timestamp_sprintf+0x81>
mov    %rbx,%rdi
callq  16f9 <file_timestamp_sprintf+0x89>
lea    -0x1(%rbx,%rax,1),%rax
movzbl (%rax),%edx
cmp    $0x30,%dl
jne    171c <file_timestamp_sprintf+0xac>
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x1,%rax
movzbl (%rax),%edx
cmp    $0x30,%dl
je     1710 <file_timestamp_sprintf+0xa0>
cmp    $0x2e,%dl
setne  %dl
movzbl %dl,%edx
movb   $0x0,(%rax,%rdx,1)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x10(%rsp),%rdx
test   %rdx,%rdx
js     174e <file_timestamp_sprintf+0xde>
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  1749 <file_timestamp_sprintf+0xd9>
jmpq   16ce <file_timestamp_sprintf+0x5e>
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  175d <file_timestamp_sprintf+0xed>
jmpq   16ce <file_timestamp_sprintf+0x5e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_timestamp_sprintf (char *p, uintmax_t ts)
{
  time_t t = (((ts) - (2 + 1)) >> (1 ? 30 : 0));
  struct tm *tm = localtime (&t);
  if (tm)
    sprintf (p, "%04d-%02d-%02d %02d:%02d:%02d",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, "%ld", (long) t);
  else
    sprintf (p, "%lu", (unsigned long) t);
  p += strlen (p);
  sprintf (p, ".%09d", ((int) (((ts) - (2 + 1)) & ((1 << (1 ? 30 : 0)) - 1))));
  p += strlen (p) - 1;
  while (*p == '0')
    p--;
  p += *p != '.';
  *p = '\0';
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 2
8 4
9 3
10 4
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 13
28 13
29 14
30 13
31 14
32 14
33 14
34 14
35 14
36 15
37 15
38 15
39 16
40 16
41 16
42 16
43 17
44 16
45 16
46 16
47 18
48 18
49 18
50 19
51 20
52 20
53 20
54 20
55 9
56 9
57 9
58 12
59 12
60 12
61 12
62 12
63 10
64 10
65 10
66 10
67 10
68 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,0x0(%rip)        # 25b <sigsegv_install_handler+0xb>
callq  100 <install_for.constprop.0>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigsegv_install_handler (sigsegv_handler_t handler)
{
  user_handler = handler;
  { int sig; sig = 11; { install_for (sig); } }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     298 <osip_content_length_free+0x38>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     27f <osip_content_length_free+0x1f>
mov    0x0(%rip),%rax        # 278 <osip_content_length_free+0x18>
test   %rax,%rax
je     2b0 <osip_content_length_free+0x50>
callq  *%rax
mov    0x0(%rip),%rax        # 286 <osip_content_length_free+0x26>
mov    %rbx,%rdi
test   %rax,%rax
je     2a0 <osip_content_length_free+0x40>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
jmpq   2a6 <osip_content_length_free+0x46>
nopw   %cs:0x0(%rax,%rax,1)
callq  2b5 <osip_content_length_free+0x55>
jmp    27f <osip_content_length_free+0x1f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_content_length_free (osip_content_length_t * content_length)
{
  if (content_length == ((void *)0))
    return;
  { if (content_length->value!=((void *)0)) { if (osip_free_func) osip_free_func(content_length->value); else free(content_length->value);} };
  { if (content_length!=((void *)0)) { if (osip_free_func) osip_free_func(content_length); else free(content_length);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 7
17 6
18 6
19 7
20 7
21 7
22 7
23 6
24 6
25 5
26 5
27 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  1e <_mu_rfc822_size+0xe>
mov    (%rax),%rdi
mov    %rbx,%rsi
mov    %rax,%rbp
callq  2c <_mu_rfc822_size+0x1c>
test   %eax,%eax
jne    3b <_mu_rfc822_size+0x2b>
mov    0x20(%rbp),%rdx
add    0x10(%rbp),%rdx
sub    %rdx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mu_rfc822_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _mu_rfc822_stream *s = mu_stream_get_owner (stream);
  int rc = mu_stream_size (s->stream, psize);
  if (rc == 0)
    *psize -= s->envelope_length + s->mark_length;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%r8d
mov    %rsi,%rbp
mov    $0xa,%edx
xor    %esi,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    %rsp,%rcx
callq  1e1 <context_length_arg+0x21>
test   %eax,%eax
jne    1f8 <context_length_arg+0x38>
mov    (%rsp),%rax
test   %eax,%eax
mov    %eax,0x0(%rbp)
js     1f8 <context_length_arg+0x38>
movslq %eax,%rdx
cmp    %rdx,%rax
je     21b <context_length_arg+0x5b>
mov    $0x0,%edi
callq  202 <context_length_arg+0x42>
mov    %rbx,%rcx
mov    %rax,%r8
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x2,%edi
xor    %eax,%eax
callq  21b <context_length_arg+0x5b>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
context_length_arg (char const *str, int *out)
{
  uintmax_t value;
  if (! (xstrtoumax (str, 0, 10, &value, "") == LONGINT_OK
         && 0 <= (*out = value)
         && *out == value))
    {
      error (EXIT_TROUBLE, 0, "%s: %s", str,
             gettext("invalid context length argument"));
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 6
18 4
19 4
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 11
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%eax        # 4ea <gpath_close+0x1a>
test   %eax,%eax
jle    5a9 <gpath_close+0xd9>
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,0x0(%rip)        # 4fd <gpath_close+0x2d>
je     520 <gpath_close+0x50>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    5c2 <gpath_close+0xf2>
add    $0x38,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 526 <gpath_close+0x56>
cmp    $0x1,%eax
je     558 <gpath_close+0x88>
cmp    $0x2,%eax
je     562 <gpath_close+0x92>
mov    0x0(%rip),%rdi        # 537 <gpath_close+0x67>
callq  53c <gpath_close+0x6c>
cmpl   $0x1,0x0(%rip)        # 543 <gpath_close+0x73>
jne    4ff <gpath_close+0x2f>
movl   $0x1,0x0(%rip)        # 54f <gpath_close+0x7f>
jmp    4ff <gpath_close+0x2f>
nopl   0x0(%rax)
mov    0x0(%rip),%eax        # 55e <gpath_close+0x8e>
test   %eax,%eax
jne    598 <gpath_close+0xc8>
mov    0x0(%rip),%ecx        # 568 <gpath_close+0x98>
mov    %rsp,%rdi
mov    $0x0,%edx
mov    $0x20,%esi
xor    %eax,%eax
callq  57c <gpath_close+0xac>
mov    0x0(%rip),%rdi        # 583 <gpath_close+0xb3>
mov    %rsp,%rdx
mov    $0x0,%esi
callq  590 <gpath_close+0xc0>
jmp    530 <gpath_close+0x60>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 59f <gpath_close+0xcf>
callq  5a4 <gpath_close+0xd4>
jmpq   4ff <gpath_close+0x2f>
mov    $0x0,%ecx
mov    $0x106,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5c2 <gpath_close+0xf2>
callq  5c7 <gpath_close+0xf7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_close(void)
{
 char fid[32];
 ((opened > 0) ? (void) (0) : __assert_fail ("opened > 0", "gpathop.c", 262, __PRETTY_FUNCTION__));
 if (--opened > 0)
  return;
 if (_mode == 1 && created) {
  dbop_close(dbop);
  return;
 }
 if (_mode == 1 || _mode == 2) {
  snprintf(fid, sizeof(fid), "%d", _nextkey);
  dbop_update(dbop, " __.NEXTKEY", fid);
 }
 dbop_close(dbop);
 if (_mode == 1)
  created = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 18
13 18
14 18
15 18
16 18
17 18
18 7
19 7
20 7
21 11
22 11
23 15
24 15
25 16
26 16
27 17
28 17
29 17
30 7
31 7
32 7
33 12
34 12
35 12
36 12
37 12
38 12
39 13
40 13
41 13
42 13
43 13
44 13
45 8
46 8
47 9
48 4
49 4
50 4
51 4
52 4
53 18
54 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 28a <top_level_cleanup+0xa>
test   %edx,%edx
je     29f <top_level_cleanup+0x1f>
xchg   %ax,%ax
callq  295 <top_level_cleanup+0x15>
mov    0x0(%rip),%eax        # 29b <top_level_cleanup+0x1b>
test   %eax,%eax
jne    290 <top_level_cleanup+0x10>
callq  2a4 <top_level_cleanup+0x24>
callq  2a9 <top_level_cleanup+0x29>
movl   $0x0,0x0(%rip)        # 2b3 <top_level_cleanup+0x33>
movl   $0x0,0x0(%rip)        # 2bd <top_level_cleanup+0x3d>
movl   $0x0,0x0(%rip)        # 2c7 <top_level_cleanup+0x47>
movl   $0x0,0x0(%rip)        # 2d1 <top_level_cleanup+0x51>
movl   $0x0,0x0(%rip)        # 2db <top_level_cleanup+0x5b>
movl   $0x0,0x0(%rip)        # 2e5 <top_level_cleanup+0x65>
movl   $0x0,0x0(%rip)        # 2ef <top_level_cleanup+0x6f>
movl   $0x0,0x0(%rip)        # 2f9 <top_level_cleanup+0x79>
add    $0x8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
top_level_cleanup ()
{
  while (parse_and_execute_level)
    parse_and_execute_cleanup ();
  unlink_fifo_list ();
  run_unwind_protects ();
  loop_level = continuing = breaking = funcnest = 0;
  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 3
8 3
9 3
10 5
11 6
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 9
21 9
22 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdi
mov    0x8(%rsi),%rcx
mov    (%rsi),%rsi
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
lea    0x10(%rdi),%rdx
add    %rcx,%rcx
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_const_imag (const gsl_vector_complex_long_double * v)
{
  gsl_vector_long_double s = {0, 0, 0, 0, 0};
  s.data = v->data + 1;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 12
5 12
6 12
7 4
8 6
9 12
10 12
11 12
12 14
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
mov    0x0(%rip),%rsi        # 4c <GetKeywordCode+0xc>
push   %rbp
push   %rbx
cmpb   $0x0,(%rsi)
je     8c <GetKeywordCode+0x4c>
mov    %rdi,%rbp
mov    $0x0,%ebx
jmp    6c <GetKeywordCode+0x2c>
nopl   (%rax)
add    $0x10,%rbx
mov    (%rbx),%rsi
cmpb   $0x0,(%rsi)
je     78 <GetKeywordCode+0x38>
mov    %rbp,%rdi
callq  74 <GetKeywordCode+0x34>
test   %eax,%eax
jne    60 <GetKeywordCode+0x20>
test   %r12,%r12
je     84 <GetKeywordCode+0x44>
mov    0xc(%rbx),%eax
mov    %eax,(%r12)
mov    0x8(%rbx),%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x0,%ebx
jmp    78 <GetKeywordCode+0x38>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetKeywordCode (PSTR szKeyword, PINT pfContext)
{
  PKM pkm = &vrgkmKeywordMap[0];
  while (*pkm->szKeyword && MyStrcmp (szKeyword, pkm->szKeyword))
    pkm++;
  if (pfContext)
    *pfContext = pkm->fContext;
  return (pkm->iKWCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 4
8 4
9 3
10 3
11 3
12 5
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 7
23 7
24 8
25 9
26 9
27 9
28 9
29 3
30 3
31 3
<<<sep_out_sample>>>
test   %esi,%esi
push   %rbx
mov    %edi,%ebx
je     9b8 <send_wont+0x38>
movslq %edi,%rax
movzbl 0x0(%rax),%ecx
movzbl 0x0(%rax),%edx
test   %cl,%cl
jne    9a1 <send_wont+0x21>
test   $0x1,%dl
je     9e0 <send_wont+0x60>
test   $0x2,%dl
je     9e0 <send_wont+0x60>
and    $0xfffffffd,%edx
add    $0x1,%ecx
mov    %dl,0x0(%rax)
mov    %cl,0x0(%rax)
xor    %eax,%eax
mov    %ebx,%esi
mov    $0x0,%edi
callq  9c6 <send_wont+0x46>
mov    0x0(%rip),%eax        # 9cc <send_wont+0x4c>
test   %eax,%eax
jle    9e0 <send_wont+0x60>
mov    %ebx,%esi
mov    $0x0,%edi
pop    %rbx
jmpq   9dd <send_wont+0x5d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
send_wont (int rpl_option, int init)
{
  if (init)
    {
      if ((will_wont_resp[rpl_option] == 0 && (!(options[rpl_option]&0x01))) ||
   (!(options[rpl_option]&0x02)))
 return;
      (options[rpl_option] &= ~0x02);
      will_wont_resp[rpl_option]++;
    }
  net_output_data (wont, rpl_option);
  if (debug_level[debug_options]>=1) printoption ("td: send wont", rpl_option);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 8
15 9
16 8
17 9
18 11
19 11
20 11
21 11
22 12
23 12
24 12
25 12
26 12
27 13
28 12
29 12
30 13
31 13
32 13
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_call_id_set_host (osip_call_id_t * callid, char *host)
{
  callid->host = host;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdi
mov    0x8(%rsi),%rcx
mov    (%rsi),%rsi
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
lea    0x8(%rdi),%rdx
add    %rcx,%rcx
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_const_imag (const gsl_vector_complex * v)
{
  gsl_vector s = {0, 0, 0, 0, 0};
  s.data = v->data + 1;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 12
5 12
6 12
7 4
8 6
9 12
10 12
11 12
12 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x2,0x0(%rip)        # 2e <args_open_filelist+0xe>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    50 <args_open_filelist+0x30>
mov    0x0(%rip),%rax        # 46 <args_open_filelist+0x26>
mov    %rax,0x0(%rip)        # 4d <args_open_filelist+0x2d>
pop    %rbx
retq   
nop
mov    $0x0,%esi
mov    %rbx,%rdi
callq  5d <args_open_filelist+0x3d>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 67 <args_open_filelist+0x47>
jne    4d <args_open_filelist+0x2d>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  76 <args_open_filelist+0x56>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
args_open_filelist(const char *filename)
{
 type = 2;
 if (!strcmp(filename, "-")) {
  ip = stdin;
 } else {
  ip = fopen(filename, "r");
  if (ip == ((void *)0))
   die("cannot open '%s'.", filename);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 11
12 11
13 11
14 7
15 7
16 7
17 8
18 7
19 8
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
xor    %r9d,%r9d
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x2,%edx
mov    $0x2,%esi
mov    $0x0,%edi
jmpq   652 <rhs_new+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rhs_new (void)
{
  struct darray * res;
  res = da_new ("Rhs", 2, da_geometrical, 2,
  (da_print_func_t) faced_string_self_print, ((void *)0));
  return res;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_diagonal (gsl_matrix_ulong * m)
{
  _gsl_vector_ulong_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_ulong v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   18f3 <gsl_sort_vector_uchar_smallest_index+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_uchar_smallest_index (size_t * p, const size_t k,
                                           const gsl_vector_uchar * v)
{
  return gsl_sort_uchar_smallest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %r12
test   %rsi,%rsi
push   %rbp
push   %rbx
mov    %rsi,%rbx
je     217 <osip_content_length_parse+0x77>
mov    %rdi,%r12
mov    %rsi,%rdi
callq  1b7 <osip_content_length_parse+0x17>
lea    0x1(%rax),%rdi
mov    %rax,%rbp
cmp    $0x1,%rdi
jbe    210 <osip_content_length_parse+0x70>
mov    0x0(%rip),%rax        # 1cb <osip_content_length_parse+0x2b>
test   %rax,%rax
je     1f0 <osip_content_length_parse+0x50>
callq  *%rax
test   %rax,%rax
mov    %rax,(%r12)
je     200 <osip_content_length_parse+0x60>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1e9 <osip_content_length_parse+0x49>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  1f5 <osip_content_length_parse+0x55>
jmp    1d2 <osip_content_length_parse+0x32>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffc,%eax
jmp    1eb <osip_content_length_parse+0x4b>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffb,%eax
jmp    1eb <osip_content_length_parse+0x4b>
mov    $0xfffffffe,%eax
jmp    1eb <osip_content_length_parse+0x4b>
xchg   %ax,%ax
<<<sep_in_sample>>>
osip_content_length_parse (osip_content_length_t * content_length, const char *hvalue)
{
  size_t len;
  if (hvalue == ((void *)0))
    return -2;
  len = strlen (hvalue);
  if (len + 1 < 2)
    return -5;
  content_length->value = (char *) (osip_malloc_func?osip_malloc_func(len + 1):malloc(len + 1));
  if (content_length->value == ((void *)0))
    return -4;
  osip_strncpy (content_length->value, hvalue, len);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 7
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 10
19 9
20 10
21 12
22 12
23 12
24 12
25 13
26 14
27 14
28 14
29 14
30 9
31 9
32 9
33 11
34 11
35 11
36 8
37 8
38 5
39 5
40 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
lea    (%rax,%rax,1),%rsi
xor    %eax,%eax
test   %rcx,%rcx
je     36e1 <gsl_vector_ushort_set_zero+0x31>
nopw   %cs:0x0(%rax,%rax,1)
xor    %edi,%edi
add    $0x1,%rax
mov    %di,(%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    36d0 <gsl_vector_ushort_set_zero+0x20>
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_set_zero (gsl_vector_ushort * v)
{
  unsigned short * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const unsigned short zero = 0U ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(unsigned short *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 8
6 8
7 8
8 8
9 10
10 8
11 10
12 10
13 8
14 8
15 8
16 8
<<<sep_out_sample>>>
mov    0x18(%rdi),%edi
mov    $0x5307,%esi
xor    %eax,%eax
jmpq   5f <audio_stop_linux+0xf>
nop
<<<sep_in_sample>>>
audio_stop_linux (void *p_user_data)
{
  const _img_private_t *p_env = p_user_data;
  return ioctl(p_env->gen.fd, 0x5307);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 52d <do_next_block+0xd>
mov    0x20(%rax),%rbp
mov    0x0(%rbp),%rdi
callq  53a <do_next_block+0x1a>
mov    0x0(%rip),%rcx        # 541 <do_next_block+0x21>
mov    %eax,%ebx
mov    0x20(%rcx),%rax
mov    0x10(%rax),%rdx
test   %rdx,%rdx
jne    55d <do_next_block+0x3d>
jmp    57f <do_next_block+0x5f>
nopw   0x0(%rax,%rax,1)
cmp    $0x1,%bl
je     598 <do_next_block+0x78>
mov    (%rdx),%rdi
mov    %rdx,0x20(%rcx)
callq  569 <do_next_block+0x49>
mov    0x0(%rip),%rcx        # 570 <do_next_block+0x50>
or     %eax,%ebx
mov    0x20(%rcx),%rdx
mov    0x10(%rdx),%rdx
test   %rdx,%rdx
jne    558 <do_next_block+0x38>
movq   $0x0,0x30(%rcx)
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   595 <do_next_block+0x75>
nopl   (%rax)
test   %al,%al
jne    55d <do_next_block+0x3d>
jmp    57f <do_next_block+0x5f>
xchg   %ax,%ax
<<<sep_in_sample>>>
do_next_block(void)
{
    filestruct *was_current = openfile->current;
    _Bool is_white = white_string(openfile->current->data);
    _Bool seen_white = is_white;
    while (openfile->current->next != ((void *)0) && (!seen_white || is_white)) {
 openfile->current = openfile->current->next;
 is_white = white_string(openfile->current->data);
 seen_white = seen_white || is_white;
    }
    openfile->current_x = 0;
    edit_redraw(was_current);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 7
20 8
21 6
22 9
23 6
24 6
25 6
26 6
27 11
28 13
29 12
30 13
31 13
32 12
33 12
34 6
35 6
36 6
37 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   0 <do_convert>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_charset_convert(cdio_charset_coverter_t*cnv,
                          char * src, int src_len,
                          char ** dst, int * dst_len)
  {
  return do_convert(cnv->ic, src, src_len, dst, dst_len);
  }
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 6 <__db_join_put+0x6>
mov    $0x16,%eax
test   %edx,%edx
jne    18 <__db_join_put+0x18>
repz retq 
nopl   0x0(%rax)
mov    (%rdi),%rdx
mov    0x28(%rdx),%rdx
mov    0xe0(%rdx),%rdx
test   %rdx,%rdx
je     f <__db_join_put+0xf>
mov    0x20(%rdx),%rax
cmpl   $0x1,0x74(%rax)
sbb    %eax,%eax
and    $0x7923,%eax
sub    $0x790d,%eax
retq   
<<<sep_in_sample>>>
__db_join_put(dbc, key, data, flags)
 DBC *dbc;
 DBT *key;
 DBT *data;
 u_int32_t flags;
{
 if(key||data||flags){}
 if (CDB___db_global_values.db_panic && (dbc->dbp->dbenv)->reginfo != ((void *)0) && ((REGENV *) ((REGINFO *)(dbc->dbp->dbenv)->reginfo)->primary)->panic != 0) return ((-30989));;
 (key) = (((void *)0));
 (data) = (((void *)0));
 (flags) = (0);
 return (22);
}
<<<sep_in_sample>>>
1 8
2 12
3 8
4 8
5 13
6 13
7 8
8 8
9 8
10 8
11 8
12 8
13 12
14 12
15 12
16 12
17 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    (%rdi),%rdi
mov    %rsp,%rsi
callq  b3 <hdr_finished_p+0x13>
test   %eax,%eax
mov    $0x1,%edx
jne    c9 <hdr_finished_p+0x29>
xor    %edx,%edx
mov    (%rsp),%rax
cmp    %rax,0x8(%rbx)
seta   %dl
add    $0x10,%rsp
mov    %edx,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hdr_finished_p (void *owner)
{
  struct header_iterator *itr = owner;
  size_t count;
  if (mu_header_get_field_count (itr->header, &count))
    return 1;
  return itr->index > count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 6
9 5
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     4048 <xheader_destroy+0x38>
xor    %esi,%esi
callq  4023 <xheader_destroy+0x13>
mov    (%rbx),%rdi
callq  402b <xheader_destroy+0x1b>
movq   $0x0,(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x8(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x10(%rbx),%rdi
callq  4051 <xheader_destroy+0x41>
jmp    4032 <xheader_destroy+0x22>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xheader_destroy (struct xheader *xhdr)
{
  if (xhdr->stk)
    {
      __extension__ ({ struct obstack *__o = (xhdr->stk); void *__obj = (void *) (((void *)0)); if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit) __o->next_free = __o->object_base = (char *) __obj; else _obstack_free (__o, __obj); });
      free (xhdr->stk);
      xhdr->stk = ((void *)0);
    }
  else
    free (xhdr->buffer);
  xhdr->buffer = 0;
  xhdr->size = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 7
11 11
12 12
13 13
14 13
15 13
16 10
17 10
18 10
19 10
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x10,%rsp
mov    0x18(%rdi),%rbx
movl   $0x1,(%rsp)
movl   $0x0,0x4(%rsp)
test   %rbx,%rbx
jne    9d8 <deliver_ev_create+0x38>
jmp    a10 <deliver_ev_create+0x70>
nopl   0x0(%rax,%rax,1)
mov    (%rbx),%rbx
test   %rbx,%rbx
je     a10 <deliver_ev_create+0x70>
testb  $0x1,0x8(%rbx)
je     9d0 <deliver_ev_create+0x30>
mov    0x10(%rbx),%rdi
mov    %rbp,%rsi
callq  9ea <deliver_ev_create+0x4a>
test   %eax,%eax
jne    9d0 <deliver_ev_create+0x30>
mov    0x10(%r12),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
mov    %rsp,%rsi
callq  a01 <deliver_ev_create+0x61>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    9d8 <deliver_ev_create+0x38>
nopl   0x0(%rax)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
deliver_ev_create(struct dirwatcher *dp, const char *name)
{
 event_mask m = { 0x01, 0 };
 struct handler *h;
 for (h = dp->handler_list; h; h = h->next) {
  if ((((h)->ev_mask.gen_mask & (0x01)) && filename_pattern_match((h)->fnames, name) == 0))
   run_handler(h, &m, dp->dirname, name);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 5
30 5
31 5
32 5
33 9
34 9
35 9
36 9
37 9
38 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    0x0(%rip),%edi        # d <gsl_matrix_complex_long_double_get+0xd>
test   %edi,%edi
je     1c <gsl_matrix_complex_long_double_get+0x1c>
cmp    %rdx,(%rsi)
jbe    50 <gsl_matrix_complex_long_double_get+0x50>
cmp    %rcx,0x8(%rsi)
jbe    88 <gsl_matrix_complex_long_double_get+0x88>
imul   0x10(%rsi),%rdx
add    %rdx,%rcx
shl    $0x5,%rcx
add    0x18(%rsi),%rcx
mov    (%rcx),%rdx
mov    %rdx,(%rax)
mov    0x8(%rcx),%rdx
mov    %rdx,0x8(%rax)
mov    0x10(%rcx),%rdx
mov    %rdx,0x10(%rax)
mov    0x18(%rcx),%rdx
mov    %rdx,0x18(%rax)
add    $0x18,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x113,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  6e <gsl_matrix_complex_long_double_get+0x6e>
mov    0x8(%rsp),%rax
fldz   
fstpt  (%rax)
fldt   (%rax)
fstpt  0x10(%rax)
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  a6 <gsl_matrix_complex_long_double_get+0xa6>
mov    0x8(%rsp),%rax
fldz   
fstpt  (%rax)
fldt   (%rax)
fstpt  0x10(%rax)
jmp    4a <gsl_matrix_complex_long_double_get+0x4a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_get(const gsl_matrix_complex_long_double * m,
                     const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      gsl_complex_long_double zero = {{0,0}};
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_long_double.h", 275, GSL_EINVAL) ; return zero ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_long_double.h", 279, GSL_EINVAL) ; return zero ; } while (0) ;
        }
    }
  return *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 7
7 7
8 11
9 11
10 16
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 17
23 17
24 17
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 17
37 17
38 17
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
<<<sep_out_sample>>>
push   %rbx
xor    %r9d,%r9d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
mov    $0x0,%r8d
sub    $0x20,%rsp
mov    $0x1f90,%esi
mov    $0x4,%edi
movl   $0x0,0x10(%rsp)
movl   $0x3,0x8(%rsp)
movl   $0x3,(%rsp)
callq  3a <main+0x3a>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     56 <main+0x56>
callq  4c <main+0x4c>
mov    %rbx,%rdi
callq  54 <main+0x54>
xor    %eax,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main()
{
  struct MHD_Daemon *daemon;
  daemon = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION,
                            8080, ((void *)0), ((void *)0),
                            &answer_to_connection, ((void *)0),
                            MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 3,
                            MHD_OPTION_END);
  if (((void *)0) == daemon)
    return 1;
  getchar();
  MHD_stop_daemon(daemon);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 10
16 9
17 9
18 11
19 12
20 12
21 13
22 14
23 14
24 14
<<<sep_out_sample>>>
sub    $0x38,%rsp
movzbl %r9b,%r9d
movzbl %r8b,%r8d
mov    0x40(%rsp),%rax
movzbl %cl,%ecx
mov    %r9d,0x18(%rsp)
mov    %r8d,0x10(%rsp)
mov    %ecx,0x8(%rsp)
xor    %r9d,%r9d
movq   $0x0,(%rsp)
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %rax,0x20(%rsp)
callq  0 <create_pipe>
add    $0x38,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_pipe_bidi (const char *progname,
                  const char *prog_path, char **prog_argv,
                  _Bool null_stderr,
                  _Bool slave_process, _Bool exit_on_error,
                  int fd[2])
{
  pid_t result = create_pipe (progname, prog_path, prog_argv,
                              1, 1, ((void *)0), ((void *)0),
                              null_stderr, slave_process, exit_on_error,
                              fd);
  return result;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 12
16 12
17 12
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     1520 <mu_udp_server_get_rdata+0x10>
cmpl   $0x1,0x18(%rdi)
je     1528 <mu_udp_server_get_rdata+0x18>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    0x50(%rdi),%rax
mov    %rax,(%rsi)
mov    0x60(%rdi),%rax
mov    %rax,(%rdx)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_udp_server_get_rdata (mu_ip_server_t srv, char **pbuf, size_t *pbufsize)
{
  if (!srv || srv->type != 1)
    return 22;
  *pbuf = srv->v.udp_data.buf;
  *pbufsize = srv->v.udp_data.rdsize;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 8
7 8
8 5
9 5
10 6
11 6
12 7
13 8
14 8
<<<sep_out_sample>>>
movzbl 0x30(%rdi),%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_parser_eof (rec_parser_t parser)
{
  return parser->eof;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  ad <sig_exit+0xd>
mov    $0x1,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  bc <sig_exit+0x1c>
mov    %ebx,%edi
callq  c3 <sig_exit+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sig_exit (int code)
{
  info (1, gettext("Signal Caught. Exiting Cleanly..."));
  quit (code);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
mov    0x0(%rip),%rsi        # 1d6b <avail_handler+0xb>
jmpq   1d70 <_gdbm_print_bucket_cache>
<<<sep_in_sample>>>
avail_handler (struct handler_param *param)
{
  _gdbm_print_avail_list (param->fp, gdbm_file);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%rdi
cmpb   $0x0,(%rdi)
jne    1070 <function_documentation+0x10>
xor    %esi,%esi
jmpq   1070 <function_documentation+0x10>
sub    $0x8,%rsp
callq  1079 <function_documentation+0x19>
xor    %esi,%esi
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   1087 <function_documentation+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
function_documentation (InfoCommand *cmd)
{
  char *doc;
  doc = cmd->doc;
  return replace_in_documentation ((strlen (doc) == 0) ? doc : gettext (doc), 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 2
7 5
8 5
9 5
10 6
11 5
12 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r12
cmp    $0x7,%rsi
mov    $0xffffffff,%eax
push   %rbp
mov    %rsi,%rbp
push   %rbx
jbe    4e <icmp_generic_encode+0x4e>
xor    %eax,%eax
mov    %rdi,%rbx
mov    %ecx,%r12d
mov    %dl,(%rdi)
movb   $0x0,0x1(%rdi)
mov    %ax,0x2(%rdi)
movzwl %r8w,%edi
callq  2d <icmp_generic_encode+0x2d>
movzwl %r12w,%edi
mov    %ax,0x6(%rbx)
callq  3a <icmp_generic_encode+0x3a>
mov    %ebp,%esi
mov    %ax,0x4(%rbx)
mov    %rbx,%rdi
callq  48 <icmp_generic_encode+0x48>
mov    %ax,0x2(%rbx)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
icmp_generic_encode (unsigned char * buffer, size_t bufsize, int type, int ident,
       int seqno)
{
  icmphdr_t *icmp;
  if (bufsize < 8)
    return -1;
  icmp = (icmphdr_t *) buffer;
  icmp->icmp_type = type;
  icmp->icmp_code = 0;
  icmp->icmp_cksum = 0;
  icmp->icmp_hun.ih_idseq.icd_seq = htons (seqno);
  icmp->icmp_hun.ih_idseq.icd_id = htons (ident);
  icmp->icmp_cksum = icmp_cksum (buffer, bufsize);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 3
5 3
6 3
7 5
8 10
9 10
10 10
11 8
12 9
13 10
14 11
15 11
16 12
17 11
18 12
19 13
20 12
21 13
22 13
23 13
24 14
25 15
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     b6c <gsl_matrix_complex_set_identity+0x7c>
xorpd  %xmm1,%xmm1
lea    0x8(%rax),%rdi
shl    $0x4,%r9
movsd  0x0(%rip),%xmm2        # b18 <gsl_matrix_complex_set_identity+0x28>
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
test   %rsi,%rsi
je     b60 <gsl_matrix_complex_set_identity+0x70>
mov    %rdi,%rdx
xor    %eax,%eax
jmp    b42 <gsl_matrix_complex_set_identity+0x52>
nopl   0x0(%rax)
add    $0x1,%rax
movsd  %xmm0,-0x8(%rdx)
add    $0x10,%rdx
cmp    %rsi,%rax
je     b60 <gsl_matrix_complex_set_identity+0x70>
cmp    %rax,%rcx
movq   $0x0,(%rdx)
movapd %xmm1,%xmm0
jne    b30 <gsl_matrix_complex_set_identity+0x40>
movapd %xmm2,%xmm0
jmp    b30 <gsl_matrix_complex_set_identity+0x40>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    b20 <gsl_matrix_complex_set_identity+0x30>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_matrix_complex_set_identity (gsl_matrix_complex * m)
{
  size_t i, j;
  double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex zero = {{0.0,0.0}};
  const gsl_complex one = {{1.0,0.0}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex *) (data + 2 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 10
32 10
33 10
34 10
35 10
36 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
xor    %edi,%edi
callq  8c0 <unbind_args+0x10>
add    $0x8,%rsp
jmpq   8c9 <unbind_args+0x19>
nopl   0x0(%rax)
<<<sep_in_sample>>>
unbind_args ()
{
  remember_args ((WORD_LIST *)((void *)0), 1);
  pop_args ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 4
7 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x8(%rdi),%xmm1
ucomisd %xmm0,%xmm1
ja     256 <gsl_interp_eval+0x16>
ucomisd 0x10(%rdi),%xmm0
jbe    280 <gsl_interp_eval+0x40>
mov    $0x1,%ecx
mov    $0x96,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  26f <gsl_interp_eval+0x2f>
movsd  0x0(%rip),%xmm0        # 277 <gsl_interp_eval+0x37>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    0x18(%rdi),%r10
mov    (%rdi),%rax
mov    %rcx,%r8
mov    0x20(%rdi),%rdi
mov    %rsp,%r9
mov    %r10,%rcx
callq  *0x20(%rax)
test   %eax,%eax
movsd  (%rsp),%xmm0
je     277 <gsl_interp_eval+0x37>
mov    %eax,%ecx
mov    $0x9b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b6 <gsl_interp_eval+0x76>
movsd  0x0(%rip),%xmm0        # 2be <gsl_interp_eval+0x7e>
jmp    277 <gsl_interp_eval+0x37>
<<<sep_in_sample>>>
gsl_interp_eval (const gsl_interp * interp,
                 const double xa[], const double ya[], double x,
                 gsl_interp_accel * a)
{
  double y;
  int status;
  if (x < interp->xmin || x > interp->xmax)
    {
      do { gsl_error ("interpolation error", "interp.c", 150, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  status = interp->type->eval (interp->state, xa, ya, interp->size, x, a, &y);
  if ((status) != GSL_SUCCESS) { do { gsl_error ("interpolation error", "interp.c", 155, (status)) ; return (__builtin_nanf ("")) ; } while (0); };
  return y;
}
<<<sep_in_sample>>>
1 4
2 7
3 7
4 7
5 7
6 7
7 9
8 9
9 9
10 9
11 9
12 9
13 14
14 14
15 14
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 13
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    2b90 <gsl_matrix_int_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,4),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  2bb2 <gsl_matrix_int_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_subdiagonal (gsl_matrix_int * m,
                                    const size_t k)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
mov    0x6c(%rdi),%eax
mov    0x68(%rdi),%ecx
cmp    %ecx,%eax
jge    228 <UpdateNDoses+0x78>
mov    0x70(%rdi),%r9
movslq %eax,%r8
lea    0x0(,%r8,8),%r10
movsd  (%r9,%r8,8),%xmm0
xor    %r8d,%r8d
movsd  %xmm0,(%rsi)
movsd  (%rdx),%xmm1
ucomisd %xmm0,%xmm1
setae  %r8b
test   %r8d,%r8d
mov    %r8d,0x4(%rdi)
je     23b <UpdateNDoses+0x8b>
movsd  0x8(%r9,%r10,1),%xmm0
movsd  %xmm0,(%rsi)
ucomisd (%rdx),%xmm0
seta   %dl
movzbl %dl,%edx
test   %edx,%edx
mov    %edx,0x4(%rdi)
jne    248 <UpdateNDoses+0x98>
add    $0x1,%eax
cmp    %eax,%ecx
mov    %eax,0x6c(%rdi)
jle    23b <UpdateNDoses+0x8b>
movsd  0x10(%r9,%r10,1),%xmm0
movsd  %xmm0,(%rsi)
movl   $0x1,0x4(%rdi)
retq   
nopl   0x0(%rax)
mov    0x4(%rdi),%eax
movsd  0x0(%rip),%xmm2        # 233 <UpdateNDoses+0x83>
movsd  %xmm2,(%rsi)
test   %eax,%eax
jne    248 <UpdateNDoses+0x98>
movq   $0x0,0x10(%rdi)
retq   
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
UpdateNDoses (PIFN pifn, PDOUBLE pdTnext, PDOUBLE pdTime)
{
  int j;
  j = pifn->iDoseCur;
  if (j < pifn->nDoses) {
    *pdTnext = pifn->rgT0s[j];
    pifn->bOn = (*pdTime >= *pdTnext);
    if (pifn->bOn) {
      *pdTnext = pifn->rgT0s[j+1];
      pifn->bOn = (*pdTime < *pdTnext);
      if (!pifn->bOn)
        if (++pifn->iDoseCur < pifn->nDoses) {
          *pdTnext = pifn->rgT0s[pifn->iDoseCur + 1];
          pifn->bOn = 1;
        }
    }
  }
  else
    *pdTnext = ((double)1.79769313486231570815e+308L);
  if (!pifn->bOn)
    pifn->dVal = 0.0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
7 6
8 6
9 7
10 6
11 7
12 7
13 7
14 8
15 7
16 8
17 9
18 9
19 10
20 10
21 10
22 11
23 10
24 11
25 12
26 12
27 12
28 12
29 13
30 13
31 14
32 14
33 14
34 20
35 19
36 19
37 20
38 20
39 21
40 21
41 21
42 21
43 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     9c0 <gsl_permute_vector_long_double_inverse+0x30>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9b5 <gsl_permute_vector_long_double_inverse+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  9d1 <gsl_permute_vector_long_double_inverse+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_long_double_inverse (const gsl_permutation * p, gsl_vector_long_double * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_long_double_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 5bb <newline+0xb>
xor    %ecx,%ecx
mov    0x0(%rip),%edx        # 5c3 <newline+0x13>
mov    0x0(%rip),%rsi        # 5ca <newline+0x1a>
mov    $0x3,%edi
lea    (%rax,%rax,2),%rax
shl    $0x3,%rax
mov    0x0(%rax),%r8
callq  *0x0(%rax)
addl   $0x1,0x0(%rip)        # 5eb <newline+0x3b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
newline()
{
     output_driver[driver_index].handler(cflow_output_newline,
      outfile, out_line,
      ((void *)0),
             output_driver[driver_index].handler_data);
     out_line++;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 7
12 8
13 8
<<<sep_out_sample>>>
jmpq   5 <__gmp_randinit_default+0x5>
<<<sep_in_sample>>>
__gmp_randinit_default (gmp_randstate_t rstate)
{
  __gmp_randinit_mt (rstate);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     e24 <mu_normalize_path+0xd4>
callq  d67 <mu_normalize_path+0x17>
test   %eax,%eax
je     e24 <mu_normalize_path+0xd4>
cltq   
lea    -0x1(%rbx,%rax,1),%rax
cmpb   $0x2f,(%rax)
je     e2e <mu_normalize_path+0xde>
mov    $0x2e,%esi
mov    %rbx,%rdi
lea    -0x1(%rbx),%rbp
callq  d90 <mu_normalize_path+0x40>
test   %rax,%rax
jne    db3 <mu_normalize_path+0x63>
jmpq   e18 <mu_normalize_path+0xc8>
nopw   0x0(%rax,%rax,1)
lea    0x1(%rax),%rdi
mov    $0x2e,%esi
callq  dae <mu_normalize_path+0x5e>
test   %rax,%rax
je     e18 <mu_normalize_path+0xc8>
cmp    %rax,%rbx
jae    da0 <mu_normalize_path+0x50>
cmpb   $0x2f,-0x1(%rax)
jne    da0 <mu_normalize_path+0x50>
cmpb   $0x2e,0x1(%rax)
jne    da0 <mu_normalize_path+0x50>
movzbl 0x2(%rax),%edx
cmp    $0x2f,%dl
je     dd1 <mu_normalize_path+0x81>
test   %dl,%dl
jne    da0 <mu_normalize_path+0x50>
cmpb   $0x2f,-0x2(%rax)
lea    -0x2(%rax),%rdi
je     df6 <mu_normalize_path+0xa6>
cmp    %rdi,%rbx
jbe    ded <mu_normalize_path+0x9d>
jmp    e18 <mu_normalize_path+0xc8>
nopw   0x0(%rax,%rax,1)
cmp    %rbp,%rdi
je     e18 <mu_normalize_path+0xc8>
sub    $0x1,%rdi
cmpb   $0x2f,(%rdi)
jne    de8 <mu_normalize_path+0x98>
cmp    %rdi,%rbx
ja     e18 <mu_normalize_path+0xc8>
xor    %edx,%edx
nopl   (%rax)
movzbl 0x2(%rax,%rdx,1),%ecx
mov    %cl,(%rdi,%rdx,1)
add    $0x1,%rdx
test   %cl,%cl
jne    e00 <mu_normalize_path+0xb0>
jmp    da4 <mu_normalize_path+0x54>
nopw   0x0(%rax,%rax,1)
cmpb   $0x0,(%rbx)
jne    e24 <mu_normalize_path+0xd4>
movb   $0x2f,(%rbx)
movb   $0x0,0x1(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
movb   $0x0,(%rax)
jmpq   d7f <mu_normalize_path+0x2f>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_normalize_path (char *path)
{
  int len;
  char *p;
  if (!path)
    return path;
  len = strlen (path);
  if (len == 0)
    return path;
  if (len && path[len-1] == '/')
    path[len-1] = 0;
  for (p = strchr (path, '.'); p; p = strchr (p, '.'))
    {
      if (p > path && p[-1] == '/')
 {
   if (p[1] == '.' && (p[2] == 0 || p[2] == '/'))
     {
       char *q, *s;
       for (q = p-2; *q != '/' && q >= path; q--)
  ;
       if (q < path)
  break;
       s = p + 2;
       p = q;
       while ((*q++ = *s++))
  ;
       continue;
     }
 }
      p++;
    }
  if (path[0] == 0)
    {
      path[0] = '/';
      path[1] = 0;
    }
  return path;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 7
8 8
9 8
10 10
11 10
12 10
13 10
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 30
23 12
24 12
25 12
26 12
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 19
49 19
50 21
51 21
52 25
53 25
54 25
55 25
56 25
57 25
58 25
59 25
60 25
61 32
62 32
63 34
64 35
65 38
66 38
67 38
68 38
69 38
70 11
71 11
72 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d0 <osip_cond_signal+0x10>
jmpq   ca <osip_cond_signal+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_cond_signal (struct osip_cond *_cond)
{
  if (!_cond)
    return -2;
  return pthread_cond_signal (&_cond->cv);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     667 <array_walk+0x47>
mov    0x10(%rdi),%eax
test   %eax,%eax
je     667 <array_walk+0x47>
mov    0x18(%rdi),%rax
mov    %rsi,%r12
mov    %rdx,%r13
mov    0x10(%rax),%rbx
cmp    %rbx,%rax
jne    65a <array_walk+0x3a>
jmp    667 <array_walk+0x47>
xchg   %ax,%ax
mov    0x10(%rbx),%rbx
cmp    %rbx,0x18(%rbp)
je     667 <array_walk+0x47>
mov    %r13,%rsi
mov    %rbx,%rdi
callq  *%r12
test   %eax,%eax
jns    650 <array_walk+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
array_walk(a, func, udata)
ARRAY *a;
sh_ae_map_func_t *func;
void *udata;
{
 register ARRAY_ELEMENT *ae;
 if (a == 0 || ((a)->num_elements == 0))
  return;
 for (ae = ((a->head)->next); ae != a->head; ae = ((ae)->next))
  if ((*func)(ae, udata) < 0)
   return;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     720 <cdio_get_track_msf+0x70>
mov    0x108(%rdi),%rax
test   %rax,%rax
je     6d0 <cdio_get_track_msf+0x20>
movzbl %sil,%esi
mov    0x180(%rdi),%rdi
jmpq   *%rax
xchg   %ax,%ax
mov    0xe0(%rdi),%rax
test   %rax,%rax
je     720 <cdio_get_track_msf+0x70>
sub    $0x18,%rsp
movzbl %sil,%esi
mov    0x180(%rdi),%rdi
mov    %rdx,0x8(%rsp)
callq  *%rax
cmp    $0xffff4f0b,%eax
je     718 <cdio_get_track_msf+0x68>
mov    0x8(%rsp),%rdx
mov    %eax,%edi
mov    %rdx,%rsi
callq  708 <cdio_get_track_msf+0x58>
mov    $0x1,%eax
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x18,%rsp
retq   
nop
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_track_msf(const CdIo_t *p_cdio, track_t u_track, msf_t *msf)
{
  if (!p_cdio) return 0;
  if (p_cdio->op.get_track_msf) {
    return p_cdio->op.get_track_msf (p_cdio->env, u_track, msf);
  } else if (p_cdio->op.get_track_lba) {
    lba_t lba = p_cdio->op.get_track_lba (p_cdio->env, u_track);
    if (lba == -45301) return 0;
    cdio_lba_to_msf(lba, msf);
    return 1;
  } else {
    return 0;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 2
14 7
15 7
16 7
17 7
18 8
19 8
20 9
21 9
22 9
23 9
24 10
25 14
26 14
27 14
28 12
29 14
30 14
31 14
32 12
33 14
34 14
<<<sep_out_sample>>>
push   %rbx
callq  c6 <_file_destroy+0x6>
mov    0x18(%rax),%rdi
mov    %rax,%rbx
test   %rdi,%rdi
je     d7 <_file_destroy+0x17>
callq  d7 <_file_destroy+0x17>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     f1 <_file_destroy+0x31>
callq  e5 <_file_destroy+0x25>
lea    0x28(%rbx),%rdi
mov    %rax,%rsi
callq  f1 <_file_destroy+0x31>
mov    %rbx,%rdi
pop    %rbx
jmpq   fa <_file_destroy+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_file_destroy (mu_stream_t stream)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  if (fs->filename)
    free (fs->filename);
  if (fs->cache)
    mu_stream_destroy (&fs->cache, mu_stream_get_owner (fs->cache));
  free (fs);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 4
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 9
17 8
18 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  419 <pop_uid+0x9>
test   %rbx,%rbx
je     425 <pop_uid+0x15>
mov    0x38(%rax),%rax
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
pop_uid (mu_message_t msg, size_t *puid)
{
  pop_message_t mpm = mu_message_get_owner (msg);
  if (puid)
    *puid = mpm->num;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # c16 <gsl_vector_int_set+0x6>
test   %eax,%eax
je     c1f <gsl_vector_int_set+0xf>
cmp    %rsi,(%rdi)
jbe    c38 <gsl_vector_int_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
shl    $0x2,%rax
imul   %rsi,%rax
mov    %edx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   c51 <gsl_vector_int_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_set (gsl_vector_int * v, const size_t i, int x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_int.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %r14
test   %rsi,%rsi
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
cmove  0x0(%rip),%rbp        # 2fb <__gmpz_inp_str+0x1b>
push   %rbx
xor    %ebx,%ebx
callq  303 <__gmpz_inp_str+0x23>
mov    %rax,%r14
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbp,%rdi
add    $0x1,%rbx
callq  31c <__gmpz_inp_str+0x3c>
mov    (%r14),%r8
movslq %eax,%rdx
testb  $0x20,0x1(%r8,%rdx,2)
jne    310 <__gmpz_inp_str+0x30>
mov    %rbx,%r8
mov    %rbp,%rsi
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13d,%edx
mov    %eax,%ecx
pop    %r13
pop    %r14
jmpq   345 <__gmpz_inp_str+0x65>
<<<sep_in_sample>>>
__gmpz_inp_str (mpz_ptr x, FILE *stream, int base)
{
  int c;
  size_t nread;
  if (stream == 0)
    stream = stdin;
  nread = 0;
  do
    {
      c = _IO_getc (stream);
      nread++;
    }
  while (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace));
  return __gmpz_inp_str_nowhite (x, stream, base, c, nread);
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 2
11 7
12 7
13 7
14 7
15 10
16 11
17 10
18 13
19 13
20 13
21 13
22 14
23 14
24 14
25 15
26 15
27 15
28 14
29 14
30 15
31 15
32 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # e70 <datadef_lookup+0x10>
test   %rdi,%rdi
je     ea8 <datadef_lookup+0x48>
mov    $0x0,%ebx
jmp    e8c <datadef_lookup+0x2c>
nopl   0x0(%rax)
add    $0x20,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     ea8 <datadef_lookup+0x48>
mov    %rbp,%rsi
callq  e94 <datadef_lookup+0x34>
test   %eax,%eax
jne    e80 <datadef_lookup+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
datadef_lookup (const char *name)
{
  struct datadef *p;
  for (p = datatab; p->name; p++)
    if (strcmp (p->name, name) == 0)
      return p;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 8
29 8
30 8
<<<sep_out_sample>>>
mov    $0x0,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
jmpq   12 <areadlinkat+0x12>
<<<sep_in_sample>>>
areadlinkat (int fd, char const *filename)
{
  return careadlinkat (fd, filename, ((void *)0), 0, ((void *)0), readlinkat);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x20(%rdi)
mov    %rdi,%rbx
je     b70 <alloc_multidata_if_needed+0x10>
pop    %rbx
retq   
nopl   (%rax)
mov    0x0(%rip),%rax        # b77 <alloc_multidata_if_needed+0x17>
mov    0x98(%rax),%rax
movslq 0x40(%rax),%rdi
add    %rdi,%rdi
callq  b8a <alloc_multidata_if_needed+0x2a>
mov    0x0(%rip),%rdx        # b91 <alloc_multidata_if_needed+0x31>
mov    %rax,0x20(%rbx)
mov    0x98(%rdx),%rdx
movslq 0x40(%rdx),%rdx
test   %edx,%edx
jle    b6b <alloc_multidata_if_needed+0xb>
pop    %rbx
add    %rdx,%rdx
mov    $0xffffffff,%esi
mov    %rax,%rdi
jmpq   bb5 <alloc_multidata_if_needed+0x55>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alloc_multidata_if_needed(filestruct *fileptr)
{
    int i;
    if (fileptr->multidata == ((void *)0)) {
 fileptr->multidata = (short *)nmalloc(openfile->syntax->nmultis * sizeof(short));
 for (i = 0; i < openfile->syntax->nmultis; i++)
     fileptr->multidata[i] = -1;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 9
6 9
7 9
8 5
9 5
10 5
11 5
12 5
13 6
14 5
15 6
16 6
17 6
18 6
19 9
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
sub    %edx,0x28(%rdi)
mov    0x18(%rdi),%rdi
mov    %rbp,%rdx
callq  ca <xdrumem_getbytes+0x1a>
add    %rbp,0x18(%rbx)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdrumem_getbytes(register XDR * xdrs, caddr_t addr, register u_int len)
{
 if ((xdrs->x_handy -= len) < 0)
  return ((0));
 bcopy(xdrs->x_private, addr, len);
 xdrs->x_private += len;
 return ((1));
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 3
7 5
8 5
9 5
10 6
11 8
12 8
13 8
14 8
15 8
16 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a29 <rl_cleanup_after_signal+0x9>
mov    0x0(%rip),%rax        # a30 <rl_cleanup_after_signal+0x10>
test   %rax,%rax
je     a37 <rl_cleanup_after_signal+0x17>
callq  *%rax
callq  a3c <rl_cleanup_after_signal+0x1c>
add    $0x8,%rsp
jmpq   a45 <rl_cleanup_after_signal+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_cleanup_after_signal ()
{
  _rl_clean_up_for_exit ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
  rl_clear_pending_input ();
  rl_clear_signals ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 6
8 8
9 7
10 7
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
encoding_get_name (struct encoding * enc)
{
  return enc->name;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
mov    %rdi,%rbx
callq  30b <pool_close+0xb>
mov    %rbx,%rdi
pop    %rbx
jmpq   314 <pool_close+0x14>
<<<sep_in_sample>>>
pool_close(POOL *pool)
{
 __extension__ ({ struct obstack *__o = (&pool->obstack); void *__obj = (((void *)0)); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = (char *)__obj; else (obstack_free) (__o, __obj); });
 free(pool);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x848(%rdi),%eax
test   %eax,%eax
je     4b0 <OpenMCFiles+0x40>
mov    0x838(%rdi),%rax
mov    %rax,0xeb0(%rdi)
mov    0xeb8(%rbx),%rdi
xor    %ebp,%ebp
test   %rdi,%rdi
je     4d0 <OpenMCFiles+0x60>
mov    %rbx,%rsi
callq  4a7 <OpenMCFiles+0x37>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
mov    0xeb0(%rdi),%rax
test   %rax,%rax
jne    491 <OpenMCFiles+0x21>
movq   $0x0,0xeb0(%rdi)
mov    $0x0,%eax
jmp    491 <OpenMCFiles+0x21>
xchg   %ax,%ax
mov    %rax,%rdi
mov    $0x0,%esi
callq  4dd <OpenMCFiles+0x6d>
test   %rax,%rax
mov    %rax,0xeb8(%rbx)
mov    %rax,%rdi
jne    49f <OpenMCFiles+0x2f>
mov    0xeb0(%rbx),%rdx
mov    $0x0,%ecx
mov    $0x8003,%esi
mov    $0x1,%bpl
callq  505 <OpenMCFiles+0x95>
mov    0xeb8(%rbx),%rdi
jmp    49f <OpenMCFiles+0x2f>
xchg   %ax,%ax
<<<sep_in_sample>>>
OpenMCFiles (PANALYSIS panal)
{
  int iErr = 0;
  PMONTECARLO pmc = &panal->mc;
  if (panal->bCommandLineSpec)
    pmc->szMCOutfilename = panal->szOutfilename;
  else
    if (!(pmc->szMCOutfilename))
      pmc->szMCOutfilename = vszDefMCOutFilename;
  if (!pmc->pfileMCOut
      && !(pmc->pfileMCOut = fopen (pmc->szMCOutfilename, "w"))) {
    iErr++;
    ReportError (((void *)0), 0x8000 | 0x0003, pmc->szMCOutfilename,
                 "OpenMCFiles()");
  }
  WriteMCHeader (pmc->pfileMCOut, panal);
  return (iErr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 10
11 3
12 10
13 10
14 16
15 16
16 18
17 18
18 18
19 18
20 18
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 13
36 13
37 13
38 12
39 13
40 13
41 13
42 13
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1e91 <gsl_matrix_ushort_fread+0x91>
lea    (%r15,%r15,1),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    1e4e <gsl_matrix_ushort_fread+0x4e>
jmp    1e80 <gsl_matrix_ushort_fread+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1e80 <gsl_matrix_ushort_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1e65 <gsl_matrix_ushort_fread+0x65>
test   %eax,%eax
je     1e40 <gsl_matrix_ushort_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1eb4 <gsl_matrix_ushort_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_fread (FILE * stream, gsl_matrix_ushort * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_ushort_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_ushort_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    %edi,%edx
mov    $0x1,%eax
and    $0xffffffdf,%edx
sub    $0x41,%edx
cmp    $0x19,%edx
jbe    17aa <alpha+0x1a>
xor    %eax,%eax
cmp    $0x5f,%edi
sete   %al
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
alpha(int c)
{
  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '_';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rax
mov    %rsi,%rbx
mov    0x8(%rsi),%rdx
mov    %rax,(%rdx)
mov    %rdx,0x8(%rax)
mov    0x18(%rdi),%rax
subq   $0x1,0x40(%rdi)
test   %rax,%rax
je     816 <gl_linked_remove_node+0x26>
mov    0x10(%rsi),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  81e <gl_linked_remove_node+0x2e>
mov    $0x1,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_remove_node (gl_list_t list, gl_list_node_t node)
{
  gl_list_node_t prev;
  gl_list_node_t next;
  prev = node->prev;
  next = node->next;
  prev->next = next;
  next->prev = prev;
  list->count--;
  if (list->base.dispose_fn != ((void *)0))
    list->base.dispose_fn (node->value);
  free (node);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 5
5 7
6 8
7 10
8 9
9 10
10 10
11 11
12 11
13 12
14 12
15 14
16 14
17 14
18 14
<<<sep_out_sample>>>
mov    0xe8(%rdi),%rax
mov    %rax,(%rsi)
mov    0xf0(%rdi),%rax
mov    %rax,0x8(%rsi)
mov    0xf8(%rdi),%rax
mov    %rax,0x10(%rsi)
mov    0x100(%rdi),%rax
mov    %rax,0x18(%rsi)
mov    0x108(%rdi),%rax
mov    %rax,0x20(%rsi)
mov    0x110(%rdi),%rax
mov    %rax,0x28(%rsi)
mov    0x118(%rdi),%rax
mov    %rax,0x30(%rsi)
mov    0x120(%rdi),%rax
mov    %rax,0x38(%rsi)
mov    0x128(%rdi),%rax
mov    %rax,0x40(%rsi)
mov    0x130(%rdi),%rax
mov    %rax,0x48(%rsi)
mov    0x138(%rdi),%rax
mov    %rax,0x50(%rsi)
mov    0x140(%rdi),%rax
mov    %rax,0x58(%rsi)
mov    0x148(%rdi),%rax
mov    %rax,0x60(%rsi)
mov    0x150(%rdi),%rax
mov    %rax,0x68(%rsi)
mov    0x158(%rdi),%rax
mov    %rax,0x70(%rsi)
mov    0x160(%rdi),%rax
mov    %rax,0x78(%rsi)
retq   
<<<sep_in_sample>>>
mu_m_server_get_sigset (mu_m_server_t srv, sigset_t *sigset)
{
  *sigset = srv->sigmask;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 906 <mark+0x6>
mov    %eax,(%rdi)
cmpl   $0x1,0x0(%rip)        # 90f <mark+0xf>
jle    930 <mark+0x30>
mov    0x0(%rip),%edx        # 917 <mark+0x17>
mov    0x0(%rip),%rdi        # 91e <mark+0x1e>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   92a <mark+0x2a>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mark(Stackpos pos)
{
     pos[0] = curs;
     if (debug > 1)
   fprintf(stderr, "marking stack at %d\n", curs);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
<<<sep_out_sample>>>
and    $0x7,%esi
movq   $0x0,(%rdi)
shl    $0x8,%rsi
mov    %rsi,0x8(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
slatec_set (void *vstate, unsigned long int s)
{
  slatec_state_t *state = (slatec_state_t *) vstate;
  s = s % 8;
  s *= P / 8;
  state->x0 = s % 2048;
  state->x1 = (s - state->x0) / 2048;
}
<<<sep_in_sample>>>
1 4
2 6
3 7
4 7
5 7
6 7
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rsi),%rax
mov    %rsi,%rbx
mov    (%rsi),%rdx
test   %rax,%rax
je     170 <linked_list_unlink+0x40>
mov    %rdx,(%rax)
mov    (%rsi),%rdx
test   %rdx,%rdx
je     180 <linked_list_unlink+0x50>
mov    %rax,0x8(%rdx)
mov    (%rdi),%rax
test   %rax,%rax
je     15d <linked_list_unlink+0x2d>
mov    0x18(%rbx),%rdi
callq  *%rax
mov    %rbx,%rdi
pop    %rbx
jmpq   166 <linked_list_unlink+0x36>
nopw   %cs:0x0(%rax,%rax,1)
test   %rdx,%rdx
mov    %rdx,0x8(%rdi)
jne    14b <linked_list_unlink+0x1b>
nopl   0x0(%rax)
mov    %rax,0x10(%rdi)
jmp    14f <linked_list_unlink+0x1f>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
linked_list_unlink(struct linked_list *list, struct linked_list_entry *ent)
{
     struct linked_list_entry *p;
     if ((p = ent->prev))
   p->next = ent->next;
     else
   list->head = ent->next;
     if ((p = ent->next))
   p->prev = ent->prev;
     else
   list->tail = ent->prev;
     if (list->free_data)
   list->free_data(ent->data);
     free(ent);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 5
5 4
6 4
7 5
8 5
9 8
10 8
11 9
12 12
13 12
14 12
15 13
16 13
17 14
18 15
19 14
20 14
21 8
22 7
23 8
24 8
25 11
26 11
27 11
<<<sep_out_sample>>>
cmp    $0x4a2,%rsi
jle    190 <__gmpn_bdiv_qr_itch+0x10>
jmpq   18e <__gmpn_bdiv_qr_itch+0xe>
xchg   %ax,%ax
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
__gmpn_bdiv_qr_itch (mp_size_t nn, mp_size_t dn)
{
  if ((! ((__builtin_constant_p (1187) && (1187) == 0) || (!(__builtin_constant_p (1187) && (1187) == 9223372036854775807L) && (dn) >= (1187)))))
    return nn;
  else
    return __gmpn_mu_bdiv_qr_itch (nn, dn);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
callq  ec0 <iterate>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lmder_iterate (void *vstate, const gsl_vector * swts,
               gsl_multifit_function_fdf * fdf, gsl_vector * x,
               gsl_vector * f, gsl_vector * dx)
{
  int status = iterate (vstate, swts, fdf, x, f, dx, 0);
  return status;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 7
5 7
6 7
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   1557 <loadfile+0x7>
<<<sep_in_sample>>>
loadfile(const char *file, STRBUF *result)
{
 load_with_replace(file, result, 0);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  de5 <system_fh_rx_over_errors+0x15>
test   %rax,%rax
je     e00 <system_fh_rx_over_errors+0x30>
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    0x78(%rax),%rcx
jmpq   dff <system_fh_rx_over_errors+0x2f>
nop
mov    %rbx,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   e11 <system_fh_rx_over_errors+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_fh_rx_over_errors (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "rx_over_errors" " unknown)"); else put_ulong (form, argc, argv, stats->rx_over_errors); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
<<<sep_out_sample>>>
movsbl 0x0(%rip),%eax        # 12c7 <escape+0x7>
cmp    %edi,%eax
je     1378 <escape+0xb8>
movsbl 0x0(%rip),%eax        # 12d6 <escape+0x16>
cmp    %edi,%eax
je     1360 <escape+0xa0>
mov    $0x0,%edx
cmp    $0x0,%rdx
jbe    1370 <escape+0xb0>
movsbl 0x0(%rip),%eax        # 12f7 <escape+0x37>
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%eax        # 1302 <escape+0x42>
mov    $0x0,%edx
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%eax        # 1312 <escape+0x52>
mov    $0x0,%edx
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%eax        # 1322 <escape+0x62>
mov    $0x0,%edx
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%eax        # 1332 <escape+0x72>
mov    $0x0,%edx
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%eax        # 1342 <escape+0x82>
mov    $0x0,%edx
cmp    %edi,%eax
je     1368 <escape+0xa8>
movsbl 0x0(%rip),%ecx        # 1352 <escape+0x92>
xor    %eax,%eax
mov    $0x0,%edx
cmp    %edi,%ecx
je     1368 <escape+0xa8>
repz retq 
nop
mov    $0x0,%edx
nopl   (%rax)
movsbl -0x1(%rdx),%eax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
jmp    1368 <escape+0xa8>
nop
<<<sep_in_sample>>>
escape (int c)
{
  char *p;
  for (p = transtab + sizeof (transtab) - 2; p > transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 4
15 6
16 6
17 6
18 4
19 6
20 6
21 6
22 4
23 6
24 6
25 6
26 4
27 6
28 6
29 6
30 4
31 6
32 6
33 6
34 9
35 4
36 6
37 6
38 10
39 10
40 6
41 6
42 7
43 7
44 7
45 9
46 10
47 10
48 4
49 4
50 4
<<<sep_out_sample>>>
cmp    $0x3,%edi
je     5d10 <pch_name+0x10>
mov    %edi,%edi
mov    0x0(,%rdi,8),%rax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pch_name (enum nametype type)
{
  return type == NONE ? ((void *)0) : p_name[type];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     240 <osip_uri_get_host+0x10>
mov    0x18(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_uri_get_host (osip_uri_t * url)
{
  if (url == ((void *)0))
    return ((void *)0);
  return url->host;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # bcb <recutl_reset_indexes+0xb>
callq  bd0 <recutl_reset_indexes+0x10>
movq   $0x0,0x0(%rip)        # bdb <recutl_reset_indexes+0x1b>
movq   $0x0,0x0(%rip)        # be6 <recutl_reset_indexes+0x26>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
recutl_reset_indexes (void)
{
  free (recutl_indexes);
  recutl_indexes = ((void *)0);
  recutl_indexes_size = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # b <jinit_read_gif+0xb>
mov    $0x0,%edi
mov    $0x34,%edx
mov    $0x1,%esi
callq  1f <jinit_read_gif+0x1f>
mov    $0x1,%edi
callq  29 <jinit_read_gif+0x29>
<<<sep_in_sample>>>
jinit_read_gif (j_compress_ptr cinfo)
{
  fprintf(stderr, "GIF input is unsupported for legal reasons.  Sorry.\n");
  exit(1);
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3c5c <name_internal_node+0x1c>
orl    $0x10,0x38(%rdi)
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
mov    %rsi,0x10(%rdi)
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
name_internal_node (NODE *node, char *name)
{
  if (!node)
    return;
  node->fullpath = "";
  node->subfile = 0;
  node->nodename = name;
  node->flags |= 0x10;
}
<<<sep_in_sample>>>
1 3
2 3
3 8
4 5
5 6
6 7
7 7
8 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
mov    %rbx,%rdi
js     6f <rpl_fclose+0x6f>
callq  18 <rpl_fclose+0x18>
test   %eax,%eax
jne    50 <rpl_fclose+0x50>
mov    %rbx,%rdi
callq  24 <rpl_fclose+0x24>
test   %eax,%eax
je     6c <rpl_fclose+0x6c>
callq  2d <rpl_fclose+0x2d>
mov    (%rax),%r12d
mov    %rbx,%rdi
mov    %rax,%rbp
callq  3b <rpl_fclose+0x3b>
test   %r12d,%r12d
je     49 <rpl_fclose+0x49>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  58 <rpl_fclose+0x58>
xor    %esi,%esi
mov    $0x1,%edx
mov    %eax,%edi
callq  66 <rpl_fclose+0x66>
cmp    $0xffffffffffffffff,%rax
jne    1c <rpl_fclose+0x1c>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   78 <rpl_fclose+0x78>
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 8
8 7
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 12
19 11
20 12
21 13
22 13
23 15
24 16
25 19
26 19
27 19
28 19
29 19
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 12
39 19
40 19
41 19
42 12
<<<sep_out_sample>>>
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  79b <gsl_stats_short_pvariance+0x1b>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,0x8(%rsp)
callq  7af <gsl_stats_short_pvariance+0x2f>
mov    %rbp,%rax
sub    $0x1,%rax
js     800 <gsl_stats_short_pvariance+0x80>
cvtsi2sd %rax,%xmm1
movsd  0x8(%rsp),%xmm2
mov    %rbx,%rax
sub    $0x1,%rax
mulsd  %xmm1,%xmm2
js     848 <gsl_stats_short_pvariance+0xc8>
cvtsi2sd %rax,%xmm1
mulsd  %xmm1,%xmm0
lea    -0x2(%rbp,%rbx,1),%rax
test   %rax,%rax
addsd  %xmm2,%xmm0
js     820 <gsl_stats_short_pvariance+0xa0>
cvtsi2sd %rax,%xmm1
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmp    7bd <gsl_stats_short_pvariance+0x3d>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
add    $0x18,%rsp
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   7d5 <gsl_stats_short_pvariance+0x55>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_short_pvariance (const short data1[],
                               const size_t stride1, const size_t n1,
                               const short data2[],
                               const size_t stride2, const size_t n2)
{
  const double var1 = gsl_stats_short_variance (data1, stride1, n1);
  const double var2 = gsl_stats_short_variance (data2, stride2, n2);
  const double pooled_variance =
    (((n1 - 1) * var1) + ((n2 - 1) * var2)) / (n1 + n2 - 2);
  return pooled_variance;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 6
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 11
33 11
34 11
35 11
36 11
37 8
38 11
39 11
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 11
51 9
52 9
53 9
54 11
55 11
56 11
57 11
58 9
59 8
60 11
61 11
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x0,%r9d
mov    $0x0,%r8d
movq   $0x0,0x8(%rsp)
movl   $0x0,(%rsp)
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x0,%edi
movl   $0x0,0x0(%rip)        # 668 <setup_language+0x38>
callq  66d <setup_language+0x3d>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setup_language(void)
{
  language = NO_LANGUAGE;
  string_option("t", "language", ((void *)0), ((void *)0), &set_language_opt, &set_language_default,
  OPT_MISC,
  "treat input as language.  Use --help languages for list.");
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 3
11 4
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
movsd  0x0(%rip),%xmm0        # 1f <init_diag_levenberg+0xf>
callq  24 <init_diag_levenberg+0x14>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_diag_levenberg(const gsl_matrix * JTJ, gsl_vector * diag)
{
  (void)JTJ;
  gsl_vector_set_all(diag, 1.0);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
jmpq   4a0 <expand_prompt>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_strip_prompt (pmt)
     char *pmt;
{
  char *ret;
  ret = expand_prompt (pmt, 0, (int *)((void *)0), (int *)((void *)0), (int *)((void *)0), (int *)((void *)0));
  return ret;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %esi,%esi
lea    0x60(%rsp),%rax
mov    %rdx,0x30(%rsp)
movl   $0x10,(%rsp)
mov    %rax,0x8(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x10(%rsp)
xor    %eax,%eax
callq  2d <rpl_ioctl+0x2d>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
rpl_ioctl (int fd, int request, ... )
{
  void *buf;
  va_list args;
  __builtin_va_start(args,request);
  buf = __builtin_va_arg(args,void *);
  __builtin_va_end(args);
  return ioctl (fd, (unsigned int) request, buf);
}
<<<sep_in_sample>>>
1 2
2 8
3 5
4 2
5 5
6 5
7 5
8 5
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  2652 <rec_sex_new+0x12>
test   %rax,%rax
mov    %rax,%rbx
je     2676 <rec_sex_new+0x36>
callq  265f <rec_sex_new+0x1f>
movzbl %bpl,%esi
mov    %rax,%rdi
mov    %rax,0x8(%rbx)
callq  266f <rec_sex_new+0x2f>
movq   $0x0,(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_sex_new (_Bool case_insensitive)
{
  rec_sex_t new;
  new = malloc (sizeof (struct rec_sex_s));
  if (new)
    {
      new->parser = rec_sex_parser_new ();
      rec_sex_parser_set_case_insensitive (new->parser,
                                           case_insensitive);
      new->ast = ((void *)0);
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 5
8 4
9 5
10 7
11 8
12 8
13 7
14 8
15 10
16 13
17 13
18 13
19 13
20 13
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1336 <yyget_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_debug (void)
{
        return yy_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     ab0 <mu_secret_length+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_secret_length (mu_secret_t sec)
{
  if (!sec)
    return 0;
  return sec->length;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     451 <gsl_matrix_complex_fwrite+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    40e <gsl_matrix_complex_fwrite+0x4e>
jmp    440 <gsl_matrix_complex_fwrite+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     440 <gsl_matrix_complex_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  425 <gsl_matrix_complex_fwrite+0x65>
test   %eax,%eax
je     400 <gsl_matrix_complex_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   474 <gsl_matrix_complex_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_fwrite (FILE * stream, const gsl_matrix_complex * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_raw_fwrite (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
movq   $0x0,(%rsi)
callq  2114 <osip_uri_to_str_canonical+0x14>
test   %eax,%eax
jne    2128 <osip_uri_to_str_canonical+0x28>
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  2124 <osip_uri_to_str_canonical+0x24>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_uri_to_str_canonical (const osip_uri_t * url, char **dest)
{
  int result;
  *dest = ((void *)0);
  result = osip_uri_to_str (url, dest);
  if (result == 0) {
    __osip_uri_unescape (*dest);
  }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 10
13 10
14 10
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1351 <gsl_matrix_ulong_fwrite+0x91>
lea    0x0(,%r15,8),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    130e <gsl_matrix_ulong_fwrite+0x4e>
jmp    1340 <gsl_matrix_ulong_fwrite+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1340 <gsl_matrix_ulong_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1325 <gsl_matrix_ulong_fwrite+0x65>
test   %eax,%eax
je     1300 <gsl_matrix_ulong_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1374 <gsl_matrix_ulong_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_fwrite (FILE * stream, const gsl_matrix_ulong * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_ulong_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_ulong_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1cc5 <gsl_matrix_ushort_isnull+0x55>
xorpd  %xmm1,%xmm1
lea    (%rax,%rax,1),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     1cb9 <gsl_matrix_ushort_isnull+0x49>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movzwl (%rsi,%rax,2),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm1,%xmm0
jp     1ccb <gsl_matrix_ushort_isnull+0x5b>
jne    1ccb <gsl_matrix_ushort_isnull+0x5b>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1ca0 <gsl_matrix_ushort_isnull+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    1c8e <gsl_matrix_ushort_isnull+0x1e>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_matrix_ushort_isnull (const gsl_matrix_ushort * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 13
21 9
22 9
23 9
24 7
25 7
26 7
27 7
28 20
29 21
30 15
31 15
32 15
<<<sep_out_sample>>>
cmp    $0x2,%edi
mov    $0x0,%eax
mov    $0x0,%edx
mov    0x8(%rsi),%rsi
cmovl  %rdx,%rax
mov    %rax,%rdi
xor    %eax,%eax
jmpq   82df <rmtstatus+0x1f>
nop
<<<sep_in_sample>>>
rmtstatus (int argc, char **argv)
{
  command (argc > 1 ? "STAT %s" : "STAT", argv[1]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
<<<sep_out_sample>>>
cmp    $0x9,%rdi
push   %rbx
jg     6170 <get_dollar_var_value+0x40>
mov    0x0(,%rdi,8),%rbx
test   %rbx,%rbx
je     61a2 <get_dollar_var_value+0x72>
mov    %rbx,%rdi
callq  614c <get_dollar_var_value+0x1c>
lea    0x1(%rax),%rdi
mov    $0xcac,%edx
mov    $0x0,%esi
callq  615f <get_dollar_var_value+0x2f>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   616b <get_dollar_var_value+0x3b>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 6177 <get_dollar_var_value+0x47>
test   %rax,%rax
je     61a2 <get_dollar_var_value+0x72>
cmp    $0xa,%rdi
lea    -0xb(%rdi),%rdx
jne    619a <get_dollar_var_value+0x6a>
jmp    61b0 <get_dollar_var_value+0x80>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%rdx
cmp    $0xffffffffffffffff,%rdx
je     61b0 <get_dollar_var_value+0x80>
mov    (%rax),%rax
test   %rax,%rax
jne    6190 <get_dollar_var_value+0x60>
xor    %eax,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x8(%rax),%rax
mov    (%rax),%rbx
mov    %rbx,%rdi
callq  61bf <get_dollar_var_value+0x8f>
mov    $0xcb2,%edx
lea    0x1(%rax),%rdi
jmp    6155 <get_dollar_var_value+0x25>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_dollar_var_value (ind)
     intmax_t ind;
{
  char *temp;
  WORD_LIST *p;
  if (ind < 10)
    temp = dollar_vars[ind] ? (char *)strcpy (sh_xmalloc((1 + strlen (dollar_vars[ind])), "subst.c", 3244), (dollar_vars[ind])) : (char *)((void *)0);
  else
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
 ;
      temp = p ? (char *)strcpy (sh_xmalloc((1 + strlen (p->word->word)), "subst.c", 3250), (p->word->word)) : (char *)((void *)0);
    }
  return (temp);
}
<<<sep_in_sample>>>
1 6
2 3
3 6
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 13
12 13
13 13
14 13
15 16
16 13
17 13
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 16
33 16
34 16
35 16
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   0 <history_search_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_search (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1bb0 <gsl_matrix_int_isnonneg+0x50>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1ba4 <gsl_matrix_int_isnonneg+0x44>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm0,%xmm1
ja     1bb6 <gsl_matrix_int_isnonneg+0x56>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1b90 <gsl_matrix_int_isnonneg+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    1b81 <gsl_matrix_int_isnonneg+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_int_isnonneg (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%rdi
mov    %rdx,%rsi
shr    %rsi
lea    (%rdi,%rdi,1),%rcx
je     373 <gsl_vector_complex_reverse+0x73>
lea    -0x8(,%rdx,8),%rdx
mov    %rcx,%r8
shl    $0x4,%rdi
neg    %r8
imul   %rcx,%rdx
shl    $0x3,%r8
xor    %ecx,%ecx
add    %rax,%rdx
nopw   %cs:0x0(%rax,%rax,1)
movsd  (%rdx),%xmm0
add    $0x1,%rcx
movsd  (%rax),%xmm1
movsd  %xmm1,(%rdx)
movsd  %xmm0,(%rax)
movsd  0x8(%rax),%xmm1
movsd  0x8(%rdx),%xmm0
movsd  %xmm1,0x8(%rdx)
add    %r8,%rdx
movsd  %xmm0,0x8(%rax)
add    %rdi,%rax
cmp    %rsi,%rcx
jne    340 <gsl_vector_complex_reverse+0x40>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_reverse (gsl_vector_complex * v)
{
  double * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 2 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 2; k++)
        {
          double tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 6
4 8
5 8
6 6
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 14
18 8
19 15
20 15
21 16
22 15
23 14
24 15
25 15
26 16
27 16
28 8
29 8
30 20
31 20
32 20
<<<sep_out_sample>>>
movslq %edi,%rax
imul   $0x5a0,%rax,%rax
add    $0x0,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lookupCraftByIndex(int craft_index)
{
 return &ctype[craft_index];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     acf <osip_transaction_set_reserved5+0xf>
mov    %rsi,0x2c60(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_reserved5 (osip_transaction_t * transaction, void *ptr)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->reserved5 = ptr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x1,%edi
callq  1ece <get_screen_lines+0xe>
test   %eax,%eax
mov    $0xffffffff,%edx
je     1f08 <get_screen_lines+0x48>
xor    %eax,%eax
xor    %edx,%edx
mov    $0x5413,%esi
mov    %ax,(%rsp)
mov    %dx,0x2(%rsp)
xor    %eax,%eax
mov    %rsp,%rdx
mov    $0x1,%edi
callq  1ef8 <get_screen_lines+0x38>
test   %eax,%eax
js     1f10 <get_screen_lines+0x50>
movzwl (%rsp),%eax
test   %ax,%ax
je     1f10 <get_screen_lines+0x50>
movzwl %ax,%edx
mov    %edx,%eax
add    $0x18,%rsp
retq   
nop
mov    $0x0,%edi
callq  1f1a <get_screen_lines+0x5a>
test   %rax,%rax
je     1f30 <get_screen_lines+0x70>
mov    $0xa,%edx
xor    %esi,%esi
mov    %rax,%rdi
callq  1f2e <get_screen_lines+0x6e>
jmp    1f05 <get_screen_lines+0x45>
movzwl (%rsp),%eax
jmp    1f05 <get_screen_lines+0x45>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_screen_lines ()
{
  if (isatty (1))
    {
      struct winsize ws;
      ws.ws_col = ws.ws_row = 0;
      if ((ioctl(1, 0x5413, (char *) &ws) < 0) || ws.ws_row == 0)
 {
   const char *lines = getenv ("LINES");
   if (lines)
     ws.ws_row = strtol (lines, ((void *)0), 10);
 }
      return ws.ws_row;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 15
6 3
7 6
8 6
9 7
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 13
22 16
23 16
24 16
25 16
26 9
27 9
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rax
mov    %rdi,%rbx
mov    $0x170,%edx
mov    $0x1,%esi
callq  *(%rax)
mov    %rax,0x250(%rbx)
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x60(%rax)
movq   $0x0,0x68(%rax)
movq   $0x0,0x70(%rax)
movq   $0x0,0x78(%rax)
movq   $0x0,0x40(%rax)
movq   $0x0,0x48(%rax)
movq   $0x0,0x50(%rax)
movq   $0x0,0x58(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
jinit_huff_decoder (j_decompress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;
  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 1,
    ((size_t) sizeof(huff_entropy_decoder)));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_huff_decoder;
  entropy->pub.decode_mcu = decode_mcu;
  for (i = 0; i < 4; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = ((void *)0);
  }
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 5
5 5
6 5
7 8
8 9
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 14
19 14
<<<sep_out_sample>>>
cmp    $0x7ffffffe,%rsi
ja     c8 <uni32_set+0x78>
mov    %rsi,%rax
and    $0x1,%eax
xor    $0x1,%rax
sub    %rax,%rsi
mov    %rsi,%rax
movzwl %si,%esi
shr    $0x10,%rax
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
imul   $0x236d,%rsi,%rsi
imul   $0x236d,%rax,%rax
mov    %rsi,%rcx
movzwl %si,%esi
shr    $0x10,%rcx
add    %rcx,%rax
and    $0x7fff,%eax
mov    %rax,%rcx
shl    $0x10,%rcx
add    %rsi,%rcx
mov    %rcx,0x8(%rdi,%rdx,1)
add    $0x8,%rdx
cmp    $0x88,%rdx
jne    78 <uni32_set+0x28>
movl   $0x4,(%rdi)
movl   $0x10,0x4(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x7fff,%eax
mov    $0xffff,%esi
jmp    70 <uni32_set+0x20>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uni32_set (void *vstate, unsigned long int s)
{
  long int seed, k0, k1, j0, j1;
  int i;
  uni32_state_t *state = (uni32_state_t *) vstate;
  seed = (s < m1 ? s : m1);
  seed -= (seed % 2 == 0 ? 1 : 0);
  k0 = 9069 % m2;
  k1 = 9069 / m2;
  j0 = seed % m2;
  j1 = seed / m2;
  for (i = 0; i < 17; i++)
    {
      seed = j0 * k0;
      j1 = (seed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
      j0 = seed % m2;
      state->m[i] = j0 + m2 * j1;
    }
  state->i = 4;
  state->j = 16;
  return;
}
<<<sep_in_sample>>>
1 6
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 14
13 15
14 15
15 16
16 15
17 15
18 15
19 17
20 17
21 17
22 17
23 17
24 12
25 12
26 19
27 20
28 20
29 20
30 20
31 20
32 20
33 20
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     90 <_cdio_strfreev+0x40>
mov    0x0(%rbp),%rdi
lea    0x8(%rbp),%rbx
test   %rdi,%rdi
je     82 <_cdio_strfreev+0x32>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rbx
callq  79 <_cdio_strfreev+0x29>
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    70 <_cdio_strfreev+0x20>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   90 <_cdio_strfreev+0x40>
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x42,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x5,%edi
xor    %eax,%eax
callq  b7 <_cdio_strfreev+0x67>
jmp    5e <_cdio_strfreev+0xe>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_cdio_strfreev(char **strv)
{
  int n;
  { if (__builtin_expect((!(strv != ((void *)0))),0)) cdio_log (CDIO_LOG_ASSERT, "file %s: line %d (%s): assertion failed: (%s)", "util.c", 66, __PRETTY_FUNCTION__, "strv != NULL"); };
  for(n = 0; strv[n]; n++)
    free(strv[n]);
  free(strv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 5
15 5
16 5
17 8
18 7
19 8
20 8
21 7
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     18db <gsl_vector_uchar_isnull+0x3b>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm1,%xmm0
jp     18e1 <gsl_vector_uchar_isnull+0x41>
jne    18e1 <gsl_vector_uchar_isnull+0x41>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    18c0 <gsl_vector_uchar_isnull+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_isnull (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
mov    $0x20,%edi
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # d4 <osip_sem_init+0x14>
test   %rax,%rax
je     120 <osip_sem_init+0x60>
callq  *%rax
mov    %rax,%rbx
test   %rbx,%rbx
je     130 <osip_sem_init+0x70>
xor    %esi,%esi
mov    %rbx,%rdi
mov    %ebp,%edx
callq  ef <osip_sem_init+0x2f>
test   %eax,%eax
mov    %rbx,%rdi
je     106 <osip_sem_init+0x46>
mov    0x0(%rip),%rax        # fd <osip_sem_init+0x3d>
test   %rax,%rax
je     110 <osip_sem_init+0x50>
callq  *%rax
xor    %edi,%edi
add    $0x8,%rsp
mov    %rdi,%rax
pop    %rbx
pop    %rbp
retq   
callq  115 <osip_sem_init+0x55>
xor    %edi,%edi
jmp    106 <osip_sem_init+0x46>
nopl   0x0(%rax)
callq  125 <osip_sem_init+0x65>
mov    %rax,%rbx
jmp    de <osip_sem_init+0x1e>
nopw   0x0(%rax,%rax,1)
xor    %edi,%edi
jmp    106 <osip_sem_init+0x46>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_sem_init (unsigned int value)
{
  osip_sem_t *sem = (osip_sem_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_sem_t)):malloc(sizeof (osip_sem_t)));
  if (sem == ((void *)0))
    return ((void *)0);
  if (sem_init (sem, 0, value) == 0)
    return (struct osip_sem *) sem;
  { if (sem!=((void *)0)) { if (osip_free_func) osip_free_func(sem); else free(sem);} };
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 8
24 9
25 10
26 10
27 10
28 10
29 10
30 8
31 9
32 9
33 9
34 3
35 3
36 3
37 3
38 5
39 5
40 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     9b0 <osip_header_get_name+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_header_get_name (const osip_header_t * header)
{
  if (header == ((void *)0))
    return ((void *)0);
  return header->hname;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # f <close_stdout_status+0xf>
callq  14 <close_stdout_status+0x14>
test   %eax,%eax
jne    60 <close_stdout_status+0x60>
mov    0x0(%rip),%rdi        # 1f <close_stdout_status+0x1f>
callq  24 <close_stdout_status+0x24>
test   %eax,%eax
jne    30 <close_stdout_status+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    $0x0,%edi
callq  3a <close_stdout_status+0x3a>
mov    %rax,%rbp
callq  42 <close_stdout_status+0x42>
mov    (%rax),%esi
add    $0x8,%rsp
mov    %ebx,%edi
pop    %rbx
mov    %rbp,%rdx
xor    %eax,%eax
pop    %rbp
jmpq   56 <close_stdout_status+0x56>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  6a <close_stdout_status+0x6a>
xor    %esi,%esi
mov    %rax,%rdx
mov    %ebx,%edi
xor    %eax,%eax
callq  78 <close_stdout_status+0x78>
jmp    18 <close_stdout_status+0x18>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_stdout_status (int status)
{
  if (ferror (stdout))
    error (status, 0, gettext ("write error"));
  if (fclose (stdout) != 0)
    error (status, (*__errno_location ()), gettext ("write error"));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 6
19 6
20 6
21 6
22 6
23 7
24 6
25 7
26 6
27 6
28 7
29 6
30 6
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  418f <imap_get_num_parts+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     41b7 <imap_get_num_parts+0x37>
cmpq   $0x0,0x20(%rax)
je     41c0 <imap_get_num_parts+0x40>
test   %rbp,%rbp
je     41b7 <imap_get_num_parts+0x37>
mov    0x20(%rbx),%rdx
mov    $0x1,%eax
test   %rdx,%rdx
cmovne %rdx,%rax
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xchg   %ax,%ax
xor    %esi,%esi
mov    %r12,%rdi
callq  3cd0 <imap_is_multipart>
test   %eax,%eax
je     419e <imap_get_num_parts+0x1e>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
imap_get_num_parts (mu_message_t msg, size_t *nparts)
{
  msg_imap_t msg_imap = mu_message_get_owner (msg);
  if (msg_imap)
    {
      if (msg_imap->num_parts == 0)
 {
   int status = imap_is_multipart (msg, ((void *)0));
   if (status != 0)
     return status;
 }
      if (nparts)
 *nparts = (msg_imap->num_parts == 0) ? 1 : msg_imap->num_parts;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 12
13 12
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 15
22 16
23 16
24 16
25 8
26 8
27 8
28 9
29 9
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 91b <_rl_trclose+0xb>
callq  920 <_rl_trclose+0x10>
movq   $0x0,0x0(%rip)        # 92b <_rl_trclose+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_trclose ()
{
  int r;
  r = fclose (_rl_tracefp);
  _rl_tracefp = 0;
  return r;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 7
6 7
<<<sep_out_sample>>>
orb    $0x40,0x85(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_intermediate (const void *item)
{
  struct file *f = (struct file *) item;
  f->intermediate = 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rsi
test   %rsi,%rsi
je     b07 <wordsplit_free_words+0x57>
mov    0x10(%rdi),%rax
xor    %ebx,%ebx
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdx
lea    (%rax,%rbx,1),%rcx
mov    (%rdx,%rcx,8),%rdi
test   %rdi,%rdi
je     afe <wordsplit_free_words+0x4e>
callq  ae6 <wordsplit_free_words+0x36>
mov    0x10(%rbp),%rax
mov    0x8(%rbp),%rdx
mov    0x0(%rbp),%rsi
lea    (%rbx,%rax,1),%rcx
movq   $0x0,(%rdx,%rcx,8)
add    $0x1,%rbx
cmp    %rsi,%rbx
jb     ad0 <wordsplit_free_words+0x20>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_words (struct wordsplit *ws)
{
  size_t i;
  for (i = 0; i < ws->ws_wordc; i++)
    {
      char *p = ws->ws_wordv[ws->ws_offs + i];
      if (p)
 {
   free (p);
   ws->ws_wordv[ws->ws_offs + i] = ((void *)0);
 }
    }
  ws->ws_wordc = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
14 7
15 7
16 9
17 10
18 10
19 10
20 10
21 10
22 4
23 4
24 4
25 13
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  149 <xalloc+0x9>
test   %rax,%rax
je     153 <xalloc+0x13>
add    $0x8,%rsp
retq   
mov    0x0(%rip),%rcx        # 15a <xalloc+0x1a>
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  16e <xalloc+0x2e>
callq  173 <xalloc+0x33>
<<<sep_in_sample>>>
xalloc(size_t size)
{
  void *p = malloc(size);
  if (!p)
    {
      fprintf(stderr, "Virtual memory exhausted.\n");
      abort();
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 10
6 10
7 6
8 6
9 6
10 6
11 6
12 7
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x90,%rsp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
movq   $0x0,0x40(%rsp)
callq  6b8 <rec_record_get_field_by_name+0x28>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
nopl   (%rax)
lea    0x40(%rsp),%rdx
lea    0x50(%rsp),%rdi
xor    %ecx,%ecx
mov    $0x1,%esi
callq  726 <rec_record_get_field_by_name+0x96>
test   %al,%al
je     750 <rec_record_get_field_by_name+0xc0>
mov    0x40(%rsp),%rdi
callq  734 <rec_record_get_field_by_name+0xa4>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  73f <rec_record_get_field_by_name+0xaf>
test   %al,%al
je     710 <rec_record_get_field_by_name+0x80>
cmp    %rbx,%r12
je     770 <rec_record_get_field_by_name+0xe0>
add    $0x1,%rbx
jmp    710 <rec_record_get_field_by_name+0x80>
xchg   %ax,%ax
xor    %ebx,%ebx
lea    0x50(%rsp),%rdi
callq  75c <rec_record_get_field_by_name+0xcc>
add    $0x90,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    0x40(%rsp),%rbx
jmp    752 <rec_record_get_field_by_name+0xc2>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_get_field_by_name (rec_record_t record,
                              const char *field_name,
                              size_t n)
{
  size_t num_fields = 0;
  rec_field_t field = ((void *)0);
  rec_field_t result = ((void *)0);
  rec_mset_iterator_t iter;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &field, ((void *)0)))
    {
      if (rec_field_name_equal_p (rec_field_name (field), field_name))
        {
          if (n == num_fields)
            {
              result = field;
              break;
            }
          num_fields++;
        }
    }
  rec_mset_iterator_free (&iter);
  return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 4
8 9
9 9
10 6
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 14
44 14
45 19
46 19
47 19
48 7
49 22
50 22
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 16
59 17
60 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     508 <parse_opt_set_af+0x68>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  4be <parse_opt_set_af+0x1e>
test   %eax,%eax
jne    4e0 <parse_opt_set_af+0x40>
mov    $0x2,%eax
orl    $0x4,0x8(%rbx)
mov    %ax,0x20(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  4f9 <parse_opt_set_af+0x59>
orl    $0x4,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rsi,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  51e <parse_opt_set_af+0x7e>
jmp    4b1 <parse_opt_set_af+0x11>
<<<sep_in_sample>>>
parse_opt_set_af (struct ifconfig *ifp, char *af)
{
  if (!ifp)
    error (1, 0,
    "no interface specified for address family `%s'", af);
  if (!strcasecmp (af, "inet"))
    ifp->af = 2;
  else
    error (1, 0,
    "unknown address family `%s' for interface `%s': is not a number",
    af, ifp->name);
  ifp->valid |= 0x004;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 6
9 6
10 6
11 6
12 6
13 7
14 12
15 7
16 13
17 13
18 13
19 13
20 13
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 12
29 13
30 13
31 13
32 13
33 13
34 4
35 4
36 4
37 4
38 4
39 4
40 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <get_clk_tck+0x7>
test   %rax,%rax
je     10 <get_clk_tck+0x10>
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x2,%edi
callq  1e <get_clk_tck+0x1e>
mov    %rax,0x0(%rip)        # 25 <get_clk_tck+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_clk_tck ()
{
  static long retval = 0;
  if (retval != 0)
    return (retval);
  retval = sysconf (_SC_CLK_TCK);
  return (retval);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 8
5 8
6 2
7 6
8 6
9 6
10 8
11 8
<<<sep_out_sample>>>
xor    %ecx,%ecx
mov    $0x1,%edx
jmpq   37ac <info_read_completing_in_echo_area+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
info_read_completing_in_echo_area (const char *prompt, REFERENCE **completions)
{
  return info_read_completing_internal (prompt, completions, 1, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_dcolor (j_decompress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_minimum (const gsl_multimin_fdfminimizer * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
mov    %rdi,%r14
mov    %rsi,%rdi
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     3f50 <gsl_block_uchar_raw_fread+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
mov    %rsi,%rbx
jne    3efc <gsl_block_uchar_raw_fread+0x3c>
jmp    3f40 <gsl_block_uchar_raw_fread+0x80>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r13,%rbx
cmp    %r12,%rbp
je     3f40 <gsl_block_uchar_raw_fread+0x80>
mov    %r14,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  3f11 <gsl_block_uchar_raw_fread+0x51>
cmp    $0x1,%rax
je     3ef0 <gsl_block_uchar_raw_fread+0x30>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3f30 <gsl_block_uchar_raw_fread+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r14,%rcx
mov    $0x1,%esi
callq  3f5d <gsl_block_uchar_raw_fread+0x9d>
cmp    %r12,%rax
je     3f40 <gsl_block_uchar_raw_fread+0x80>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3f7b <gsl_block_uchar_raw_fread+0xbb>
mov    $0x5,%eax
jmp    3f35 <gsl_block_uchar_raw_fread+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uchar_raw_fread (FILE * stream, unsigned char * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (unsigned char), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (unsigned char), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 19
28 19
29 21
30 21
31 21
32 21
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 25
47 26
48 26
49 26
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  41e <sh_notfound+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   42c <sh_notfound+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_notfound (s)
     char *s;
{
  builtin_error (gettext("%s: not found"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %edi,%edi
push   %rbx
mov    %edi,%ebx
je     3bf <print_spaces+0x1f>
nopw   0x0(%rax,%rax,1)
mov    $0x20,%edi
callq  3ba <print_spaces+0x1a>
sub    $0x1,%ebx
jne    3b0 <print_spaces+0x10>
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_spaces (unsigned int n)
{
  while (n-- > 0)
    putchar (' ');
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 4
7 4
8 3
9 3
10 5
11 5
12 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rdx,%rdx
mov    (%rax),%rax
mov    %rax,(%rsi)
je     86 <getitem+0x16>
movq   $0x0,(%rdx)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
getitem (void *owner, void **pret, const void **pkey)
{
  struct list_iterator *itr = owner;
  *pret = itr->cur->item;
  if (pkey)
    *pkey = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 5
6 6
7 8
8 8
9 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x68(%rdi),%rdi
test   %rdi,%rdi
je     50 <mu_pop3_send+0x50>
mov    0x8(%rbx),%r12
mov    (%rbx),%rbp
cmp    %rbp,%r12
jbe    53 <mu_pop3_send+0x53>
mov    0x50(%rbx),%edx
movq   $0x0,(%rsp)
test   %edx,%edx
je     68 <mu_pop3_send+0x68>
mov    $0x2,%esi
callq  39 <mu_pop3_send+0x39>
mov    %eax,%edx
mov    $0x6e,%eax
test   %edx,%edx
je     59 <mu_pop3_send+0x59>
mov    (%rbx),%rsi
mov    0x68(%rbx),%rdi
jmp    6b <mu_pop3_send+0x6b>
nopl   (%rax)
mov    (%rbx),%rbp
mov    %rbp,0x8(%rbx)
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rsi
sub    %rbp,%r12
xor    %ecx,%ecx
mov    %rsp,%r8
mov    %r12,%rdx
callq  7b <mu_pop3_send+0x7b>
mov    (%rsp),%rsi
mov    %eax,%ebp
test   %rsi,%rsi
jne    98 <mu_pop3_send+0x98>
mov    %ebp,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    (%rbx),%rdi
mov    %r12,%rdx
sub    %rsi,%rdx
add    %rdi,%rsi
callq  a9 <mu_pop3_send+0xa9>
mov    (%rsp),%rax
sub    %rax,0x8(%rbx)
mov    %ebp,%eax
jmp    88 <mu_pop3_send+0x88>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_pop3_send (mu_pop3_t pop3)
{
  int status = 0;
  if (pop3->carrier && (pop3->io.ptr > pop3->io.buf))
    {
      size_t n = 0;
      size_t len = pop3->io.ptr - pop3->io.buf;
      if (pop3->timeout)
 {
   int ready = mu_pop3_carrier_is_ready (pop3->carrier,
      0x2,
      pop3->timeout);
   if (ready == 0)
     return 110;
 }
      status = mu_stream_write (pop3->carrier, pop3->io.buf, len, 0, &n);
      if (n)
 {
   memmove (pop3->io.buf, pop3->io.buf + n, len - n);
   pop3->io.ptr -= n;
 }
    }
  else
    pop3->io.ptr = pop3->io.buf;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 8
14 6
15 8
16 8
17 10
18 10
19 10
20 14
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 24
29 3
30 26
31 26
32 26
33 26
34 26
35 26
36 26
37 7
38 16
39 16
40 16
41 16
42 17
43 16
44 17
45 17
46 16
47 26
48 26
49 26
50 26
51 26
52 26
53 19
54 19
55 19
56 19
57 19
58 20
59 20
60 16
61 16
62 16
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
jbe    160 <gsl_ran_rayleigh_tail_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
movapd %xmm0,%xmm4
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
divsd  %xmm2,%xmm4
movapd %xmm1,%xmm0
subsd  %xmm4,%xmm1
movsd  %xmm4,(%rsp)
addsd  %xmm4,%xmm0
mulsd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 193 <gsl_ran_rayleigh_tail_pdf+0x43>
callq  198 <gsl_ran_rayleigh_tail_pdf+0x48>
movsd  (%rsp),%xmm4
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
add    $0x18,%rsp
divsd  %xmm2,%xmm4
movapd %xmm4,%xmm0
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_rayleigh_tail_pdf (const double x, const double a, const double sigma)
{
  if (x < a)
    {
      return 0 ;
    }
  else
    {
      double u = x / sigma ;
      double v = a / sigma ;
      double p = (u / sigma) * exp((v + u) * (v - u) / 2.0) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 10
7 9
8 2
9 10
10 9
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 14
22 11
23 11
24 11
25 14
<<<sep_out_sample>>>
jmpq   5 <__gmpn_sec_mul+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_mul (mp_ptr rp,
      mp_srcptr ap, mp_size_t an,
      mp_srcptr bp, mp_size_t bn,
      mp_ptr tp)
{
  __gmpn_mul_basecase (rp, ap, an, bp, bn);
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm0        # 4b30 <gsl_complex_arctanh_real+0x10>
ucomisd 0x0(%rip),%xmm1        # 4b38 <gsl_complex_arctanh_real+0x18>
jbe    4b40 <gsl_complex_arctanh_real+0x20>
ucomisd %xmm1,%xmm0
ja     4b80 <gsl_complex_arctanh_real+0x60>
divsd  %xmm1,%xmm0
movsd  %xmm1,0x8(%rsp)
callq  4b4f <gsl_complex_arctanh_real+0x2f>
movsd  0x8(%rsp),%xmm1
movsd  0x0(%rip),%xmm2        # 4b5d <gsl_complex_arctanh_real+0x3d>
cmpltsd 0x0(%rip),%xmm1        # 4b66 <gsl_complex_arctanh_real+0x46>
movsd  0x0(%rip),%xmm3        # 4b6e <gsl_complex_arctanh_real+0x4e>
andpd  %xmm1,%xmm2
andnpd %xmm3,%xmm1
orpd   %xmm2,%xmm1
add    $0x18,%rsp
retq   
nop
movapd %xmm1,%xmm0
callq  4b89 <gsl_complex_arctanh_real+0x69>
xorpd  %xmm1,%xmm1
jmp    4b7a <gsl_complex_arctanh_real+0x5a>
nop
<<<sep_in_sample>>>
gsl_complex_arctanh_real (double a)
{
  gsl_complex z;
  if (a > -1.0 && a < 1.0)
    {
      do {(&z)->dat[0]=(atanh (a)); (&z)->dat[1]=(0);} while(0);
    }
  else
    {
      do {(&z)->dat[0]=(atanh (1 / a)); (&z)->dat[1]=((a < 0) ? 1.57079632679489661923 : -1.57079632679489661923);} while(0);
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 13
19 13
20 13
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
mov    $0x0,%edx
test   %rax,%rax
cmove  %rdx,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_char_location_str (rec_field_t field)
{
  char *res;
  if (field->char_location_str)
    {
      res = field->char_location_str;
    }
  else
    {
      res = "";
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 10
3 10
4 10
5 13
6 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    $0x0,%edx
mov    $0x14b,%esi
mov    %rdi,%rbx
sub    $0x160,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x158(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
callq  183 <cannotwrite+0x33>
mov    %rsp,%rdi
callq  18b <cannotwrite+0x3b>
mov    %rbx,%rdi
callq  193 <cannotwrite+0x43>
mov    $0x1,%edi
callq  19d <cannotwrite+0x4d>
<<<sep_in_sample>>>
cannotwrite(char *file)
{
    char msg[((250) + 80) + 1];
    snprintf(msg, sizeof(msg), "Removed file %s because write failed", file);
    myperror(msg);
    unlink(file);
    myexit(1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 6
15 6
16 7
17 7
<<<sep_out_sample>>>
mov    (%rsi),%eax
cmp    %eax,(%rdi)
setle  %al
movzbl %al,%eax
neg    %eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
_compare_prio (const void *item, const void *value)
{
  const mu_record_t a = (const mu_record_t) item;
  const mu_record_t b = (const mu_record_t) value;
  if (a->priority > b->priority)
    return 0;
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 8
7 8
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
cmove  0x0(%rip),%rbx        # 1e <__gmpq_out_str+0x1e>
add    $0x10,%rbp
mov    %rbx,%rdi
callq  2a <__gmpq_out_str+0x2a>
mov    $0x1,%esi
mov    %rbp,%rdi
mov    %rax,%r12
callq  3a <__gmpq_out_str+0x3a>
test   %eax,%eax
jne    60 <__gmpq_out_str+0x60>
mov    %rbx,%rdi
callq  46 <__gmpq_out_str+0x46>
xor    %edx,%edx
test   %eax,%eax
cmove  %r12,%rdx
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
mov    %rdx,%rax
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rsi
mov    $0x2f,%edi
callq  6d <__gmpq_out_str+0x6d>
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  7b <__gmpq_out_str+0x7b>
lea    0x1(%r12,%rax,1),%r12
jmp    3e <__gmpq_out_str+0x3e>
<<<sep_in_sample>>>
__gmpq_out_str (FILE *stream, int base, mpq_srcptr q)
{
  size_t written;
  if (stream == ((void *)0))
    stream = stdout;
  written = __gmpz_out_str (stream, base, (&((q)->_mp_num)));
  if ((__builtin_constant_p (1) && (1) == 0 ? (((&((q)->_mp_den)))->_mp_size < 0 ? -1 : ((&((q)->_mp_den)))->_mp_size > 0) : __gmpz_cmp_ui ((&((q)->_mp_den)),1)) != 0)
    {
      _IO_putc ('/', stream);
      written += 1 + __gmpz_out_str (stream, base, (&((q)->_mp_den)));
    }
  return ferror (stream) ? 0 : written;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 7
12 6
13 6
14 7
15 7
16 6
17 7
18 7
19 7
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 9
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     66 <cdio_log+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  210 <cdio_logv>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
cdio_log(cdio_log_level_t level, const char format[], ...)
{
  va_list args;
  __builtin_va_start(args,format);
  cdio_logv (level, format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 7
25 7
26 7
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
jmpq   1203 <gsl_sort_vector_long+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long (gsl_vector_long * v)
{
  gsl_sort_long (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    0x8(%rsi),%rdi
callq  *%rax
xor    %edx,%edx
test   %eax,%eax
jne    2b <try_auth+0x1b>
movl   $0x0,(%rbx)
mov    $0x1,%dl
mov    %edx,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
try_auth (void *item, void *data)
{
  int (*authenticate) (mu_authority_t) = item;
  struct auth_cb *cb = data;
  if (authenticate (cb->authority) == 0)
    {
      cb->status = 0;
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 10
7 5
8 5
9 7
10 8
11 11
12 11
13 11
14 11
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2646 <smapset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smapset_lineno (int line_number )
{
    smaplineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_arg(void *arg1, void *arg2)
{
      struct arg arg;
      arg.arg1 = arg1;
      arg.arg2 = arg2;
      return arg;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbx
mov    0xc8(%rdi),%ecx
mov    %rdx,%r9
lea    0xcc(%rdi),%rdx
mov    %rdi,%rbx
mov    %rsi,%r8
mov    $0x48,%esi
callq  b1 <nettle_sha3_512_update+0x21>
mov    %eax,0xc8(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_sha3_512_update (struct sha3_512_ctx *ctx,
   size_t length,
   const uint8_t *data)
{
  ctx->index = _nettle_sha3_update (&ctx->state, 72, ctx->block,
        ctx->index, length, data);
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 5
8 5
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    $0x16,%eax
mov    %rdi,%rbx
je     bb <mu_ticket_unref+0x4b>
mov    0x8(%rdi),%eax
test   %eax,%eax
jne    c0 <mu_ticket_unref+0x50>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     93 <mu_ticket_unref+0x23>
callq  93 <mu_ticket_unref+0x23>
cmpq   $0x0,0x18(%rbx)
je     a3 <mu_ticket_unref+0x33>
lea    0x18(%rbx),%rdi
callq  a3 <mu_ticket_unref+0x33>
mov    0x20(%rbx),%rax
test   %rax,%rax
je     b1 <mu_ticket_unref+0x41>
mov    %rbx,%rdi
callq  *%rax
mov    %rbx,%rdi
callq  b9 <mu_ticket_unref+0x49>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,0x8(%rdi)
je     85 <mu_ticket_unref+0x15>
mov    $0x1029,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ticket_unref (mu_ticket_t ticket)
{
  if (!ticket)
    return 22;
  if (ticket->refcnt)
    ticket->refcnt--;
  if (ticket->refcnt == 0)
    {
      if (ticket->plain)
 free (ticket->plain);
      if (ticket->secret)
 mu_secret_destroy (&ticket->secret);
      if (ticket->_destroy)
 ticket->_destroy (ticket);
      free (ticket);
      return 0;
    }
  return (0x1000 +41);
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 2
5 3
6 5
7 5
8 5
9 9
10 9
11 9
12 10
13 11
14 11
15 12
16 12
17 13
18 13
19 13
20 14
21 14
22 15
23 15
24 16
25 19
26 19
27 19
28 6
29 7
30 6
31 7
32 18
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1fb6 <rl_vi_check+0x6>
test   %eax,%eax
je     1fc2 <rl_vi_check+0x12>
cmp    0x0(%rip),%eax        # 1fc0 <rl_vi_check+0x10>
je     1fc8 <rl_vi_check+0x18>
xor    %eax,%eax
retq   
nopl   (%rax)
sub    $0x8,%rsp
callq  1fd1 <rl_vi_check+0x21>
cmp    $0x1,%rax
jbe    1fe1 <rl_vi_check+0x31>
mov    0x0(%rip),%eax        # 1fdd <rl_vi_check+0x2d>
test   %eax,%eax
je     1ff0 <rl_vi_check+0x40>
subl   $0x1,0x0(%rip)        # 1fe8 <rl_vi_check+0x38>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
mov    0x0(%rip),%esi        # 1ff6 <rl_vi_check+0x46>
mov    0x0(%rip),%rdi        # 1ffd <rl_vi_check+0x4d>
mov    $0x1,%edx
callq  2007 <rl_vi_check+0x57>
mov    %eax,0x0(%rip)        # 200d <rl_vi_check+0x5d>
jmp    1fe8 <rl_vi_check+0x38>
nop
<<<sep_in_sample>>>
rl_vi_check ()
{
  if (rl_point && rl_point == rl_end)
    {
      if ((__ctype_get_mb_cur_max ()) > 1 && rl_byte_oriented == 0)
 rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, 0x01);
      else
 rl_point--;
    }
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 11
7 11
8 11
9 2
10 5
11 5
12 5
13 5
14 5
15 5
16 8
17 11
18 11
19 11
20 11
21 6
22 6
23 6
24 6
25 6
26 6
27 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
cmp    %rax,0x8(%rdi)
sete   %al
movzbl %al,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
finished_p (void *owner)
{
  struct list_iterator *itr = owner;
  return itr->cur == &itr->list->head;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    $0x2800,%esi
mov    (%rdi),%rdi
mov    %rdx,%rcx
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bench_cipher(void *arg)
{
  struct bench_cipher_info *info = arg;
  info->crypt(info->ctx, 10240, info->data, info->data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x698,%rsp
lea    0x6a0(%rsp),%rax
mov    %rdx,0x670(%rsp)
mov    %rcx,0x678(%rsp)
mov    %r9,0x688(%rsp)
mov    %rsi,0x668(%rsp)
mov    $0x8,%ecx
mov    %rax,0x8(%rsp)
lea    0x660(%rsp),%rax
mov    %r8,0x680(%rsp)
movl   $0x8,(%rsp)
lea    0x6a0(%rsp),%r9
xor    %edx,%edx
mov    %rax,0x10(%rsp)
jmp    212 <xvstrrpl+0x92>
nopl   0x0(%rax)
lea    0x660(%rsp),%r10
mov    %ecx,%eax
add    $0x8,%ecx
add    %r10,%rax
mov    (%rax),%rax
movslq %esi,%rsi
movslq %r8d,%r8
lea    (%rsi,%r8,2),%rsi
test   %rax,%rax
mov    %rax,0x20(%rsp,%rsi,8)
je     230 <xvstrrpl+0xb0>
add    $0x1,%edx
mov    %edx,%r8d
mov    %edx,%esi
sar    %r8d
and    $0x1,%esi
cmp    $0x2f,%ecx
jbe    1e8 <xvstrrpl+0x68>
mov    %r9,%rax
add    $0x8,%r9
jmp    1f8 <xvstrrpl+0x78>
nopl   0x0(%rax,%rax,1)
and    $0x1,%edx
jne    23f <xvstrrpl+0xbf>
lea    0x20(%rsp),%rsi
callq  23f <xvstrrpl+0xbf>
add    $0x698,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xvstrrpl (const char * string, ...)
{
  va_list ap;
  const char * subst[100][2];
  int i = 0;
  __builtin_va_start(ap,string);
  for (i = 0 ; (subst[i / 2][i % 2] = __builtin_va_arg(ap,char *)) ; i++)
    ;
  __builtin_va_end(ap);
  if (i % 2)
    return ((void *)0);
  return xstrrpl (string, subst);
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 2
11 6
12 6
13 7
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 10
40 10
41 12
42 12
43 13
44 13
45 13
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 8746 <freeze_jobs_list+0x6>
movl   $0x1,0x0(%rip)        # 8750 <freeze_jobs_list+0x10>
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
freeze_jobs_list ()
{
  int o;
  o = jobs_list_frozen;
  jobs_list_frozen = 1;
  return o;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exact_free (RC_REGEX *regex)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  69 <xcalloc+0x9>
test   %rax,%rax
je     73 <xcalloc+0x13>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  7d <xcalloc+0x1d>
mov    $0x1,%edi
callq  87 <xcalloc+0x27>
<<<sep_in_sample>>>
xcalloc (size_t nmemb, size_t size)
{
  void * p;
  p = (void *) calloc (nmemb, size);
  if (p == (void *) ((void *)0))
    {
      perror ("out of memory");
      exit (1);
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 11
6 11
7 7
8 7
9 8
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%edi
callq  3e <__gmp_sqrt_of_negative+0xe>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_sqrt_of_negative (void)
{
  __gmp_exception (GMP_ERROR_SQRT_OF_NEGATIVE);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rsi
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     4190 <gsl_matrix_int_set_identity+0x50>
shl    $0x2,%rdi
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
test   %r8,%r8
je     4184 <gsl_matrix_int_set_identity+0x44>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
xor    %edx,%edx
cmp    %rax,%rcx
sete   %dl
mov    %edx,(%rsi,%rax,4)
add    $0x1,%rax
cmp    %r8,%rax
jne    4170 <gsl_matrix_int_set_identity+0x30>
add    $0x1,%rcx
add    %rdi,%rsi
cmp    %r9,%rcx
jne    4160 <gsl_matrix_int_set_identity+0x20>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_set_identity (gsl_matrix_int * m)
{
  size_t i, j;
  int * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const int zero = 0;
  const int one = 1;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(int *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 12
11 12
12 12
13 12
14 14
15 14
16 14
17 14
18 12
19 12
20 12
21 10
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x8(%rdi),%xmm1
ucomisd %xmm0,%xmm1
ja     3f6 <gsl_interp_eval_deriv2+0x16>
ucomisd 0x10(%rdi),%xmm0
jbe    420 <gsl_interp_eval_deriv2+0x40>
mov    $0x1,%ecx
mov    $0xde,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  40f <gsl_interp_eval_deriv2+0x2f>
movsd  0x0(%rip),%xmm0        # 417 <gsl_interp_eval_deriv2+0x37>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    0x18(%rdi),%r10
mov    (%rdi),%rax
mov    %rcx,%r8
mov    0x20(%rdi),%rdi
mov    %rsp,%r9
mov    %r10,%rcx
callq  *0x30(%rax)
test   %eax,%eax
movsd  (%rsp),%xmm0
je     417 <gsl_interp_eval_deriv2+0x37>
mov    %eax,%ecx
mov    $0xe3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  456 <gsl_interp_eval_deriv2+0x76>
movsd  0x0(%rip),%xmm0        # 45e <gsl_interp_eval_deriv2+0x7e>
jmp    417 <gsl_interp_eval_deriv2+0x37>
<<<sep_in_sample>>>
gsl_interp_eval_deriv2 (const gsl_interp * interp,
                        const double xa[], const double ya[], double x,
                        gsl_interp_accel * a)
{
  double d2;
  int status;
  if (x < interp->xmin || x > interp->xmax)
    {
      do { gsl_error ("interpolation error", "interp.c", 222, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  status = interp->type->eval_deriv2 (interp->state, xa, ya, interp->size, x, a, &d2);
  if ((status) != GSL_SUCCESS) { do { gsl_error ("interpolation error", "interp.c", 227, (status)) ; return (__builtin_nanf ("")) ; } while (0); };
  return d2;
}
<<<sep_in_sample>>>
1 4
2 7
3 7
4 7
5 7
6 7
7 9
8 9
9 9
10 9
11 9
12 9
13 14
14 14
15 14
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 13
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%rsi
test   %rsi,%rsi
je     c00 <stat_with_alloc+0x40>
mov    %rbp,%rdi
callq  bdc <stat_with_alloc+0x1c>
test   %eax,%eax
je     bef <stat_with_alloc+0x2f>
mov    (%rbx),%rdi
callq  be8 <stat_with_alloc+0x28>
movq   $0x0,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x90,%edi
callq  c0a <stat_with_alloc+0x4a>
mov    %rax,(%rbx)
mov    %rax,%rsi
jmp    bd4 <stat_with_alloc+0x14>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stat_with_alloc(const char *filename, struct stat **pstat)
{
    if (*pstat == ((void *)0))
 *pstat = (struct stat *)nmalloc(sizeof(struct stat));
    if (stat(filename, *pstat) != 0) {
 free(*pstat);
 *pstat = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 6
14 6
15 7
16 9
17 9
18 9
19 9
20 9
21 4
22 4
23 4
24 4
25 4
26 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 5d <releaseVResources+0xd>
mov    0x8(%rax),%rbx
test   %rbx,%rbx
jne    73 <releaseVResources+0x23>
jmp    93 <releaseVResources+0x43>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rbx
mov    (%rbx),%rdi
callq  7b <releaseVResources+0x2b>
mov    0x10(%rbx),%rbp
mov    %rbx,%rdi
callq  87 <releaseVResources+0x37>
test   %rbp,%rbp
jne    70 <releaseVResources+0x20>
mov    0x0(%rip),%rax        # 93 <releaseVResources+0x43>
mov    0x30(%rax),%rdi
movq   $0x0,0x8(%rax)
test   %rdi,%rdi
je     b8 <releaseVResources+0x68>
callq  a9 <releaseVResources+0x59>
mov    0x0(%rip),%rax        # b0 <releaseVResources+0x60>
movq   $0x0,0x30(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
releaseVResources (void)
{
 VColor *p = _VDefaultWorkContext->VColorList, *next;
 while (p) {
  free (p->color_name);
  next = p->next;
  free (p);
  p = next;
 }
 _VDefaultWorkContext->VColorList = ((void *)0);
 if (_VDefaultWorkContext->visTable) {
  free(_VDefaultWorkContext->visTable);
  _VDefaultWorkContext->visTable = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 8
11 5
12 5
13 6
14 7
15 7
16 4
17 4
18 4
19 11
20 10
21 11
22 11
23 12
24 13
25 13
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
push   %rbp
mov    $0x1000,%edx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    %rbx,%rdi
sub    $0x1018,%rsp
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x1008(%rsp)
xor    %eax,%eax
callq  1a2 <histfile_restore+0x32>
test   %rax,%rax
jle    1d8 <histfile_restore+0x68>
mov    %rsp,%rsi
mov    %rbp,%rdi
movb   $0x0,(%rsp,%rax,1)
callq  1b6 <histfile_restore+0x46>
mov    0x1008(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1e5 <histfile_restore+0x75>
add    $0x1018,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1e3 <histfile_restore+0x73>
jmp    1b6 <histfile_restore+0x46>
callq  1ea <histfile_restore+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
histfile_restore (backup, orig)
     const char *backup;
     const char *orig;
{
  char linkbuf[4096 +1];
  ssize_t n;
  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)
    {
      linkbuf[n] = '\0';
      return (rename (backup, linkbuf));
    }
  return (rename (backup, orig));
}
<<<sep_in_sample>>>
1 4
2 7
3 4
4 4
5 4
6 7
7 4
8 7
9 4
10 4
11 4
12 7
13 7
14 7
15 10
16 10
17 9
18 10
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 13
32 13
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_line_begin ()
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     683 <gsl_matrix_complex_isnull+0x73>
xorpd  %xmm0,%xmm0
shl    $0x4,%rax
xor    %esi,%esi
mov    %rax,%r10
xor    %r8d,%r8d
test   %rcx,%rcx
je     677 <gsl_matrix_complex_isnull+0x67>
mov    0x18(%rdi),%rax
ucomisd (%rax,%rsi,1),%xmm0
jp     690 <gsl_matrix_complex_isnull+0x80>
jne    690 <gsl_matrix_complex_isnull+0x80>
ucomisd 0x8(%rax,%rsi,1),%xmm0
jp     690 <gsl_matrix_complex_isnull+0x80>
jne    690 <gsl_matrix_complex_isnull+0x80>
lea    0x18(%rax,%rsi,1),%rax
xor    %edx,%edx
jmp    66e <gsl_matrix_complex_isnull+0x5e>
nopl   (%rax)
ucomisd -0x8(%rax),%xmm0
jp     690 <gsl_matrix_complex_isnull+0x80>
jne    690 <gsl_matrix_complex_isnull+0x80>
add    $0x10,%rax
ucomisd -0x10(%rax),%xmm0
jp     690 <gsl_matrix_complex_isnull+0x80>
jne    690 <gsl_matrix_complex_isnull+0x80>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    658 <gsl_matrix_complex_isnull+0x48>
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    630 <gsl_matrix_complex_isnull+0x20>
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_isnull (const gsl_matrix_complex * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 13
7 13
8 7
9 7
10 7
11 9
12 9
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 9
32 9
33 9
34 7
35 7
36 7
37 7
38 20
39 20
40 20
41 15
42 21
43 21
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 22f6 <ppdget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdget_lineno (void)
{
    return ppdlineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x4c(%rdi),%esi
mov    0x50(%rdi),%rdi
jmpq   c3c <rec_rset_num_comments+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_rset_num_comments (rec_rset_t rset)
{
  return rec_mset_count (rset->mset, rset->comment_type);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rax
mov    0x8(%rdi),%r8
test   %rax,%rax
je     40 <__gmpz_cmpabs_ui+0x40>
mov    %rax,%rcx
sar    $0x3f,%rcx
xor    %rcx,%rax
mov    %rax,%rdx
mov    $0x1,%eax
sub    %rcx,%rdx
cmp    $0x1,%rdx
je     30 <__gmpz_cmpabs_ui+0x30>
repz retq 
nopw   0x0(%rax,%rax,1)
cmp    (%r8),%rsi
jb     28 <__gmpz_cmpabs_ui+0x28>
seta   %al
movzbl %al,%eax
neg    %eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
test   %rsi,%rsi
setne  %al
neg    %eax
retq   
<<<sep_in_sample>>>
__gmpz_cmpabs_ui (mpz_srcptr u, unsigned long int v_digit)
{
  mp_ptr up;
  mp_size_t un;
  mp_limb_t ul;
  up = ((u)->_mp_d);
  un = ((u)->_mp_size);
  if (un == 0)
    return -(v_digit != 0);
  un = ((un) >= 0 ? (un) : -(un));
  if (un == 1)
    {
      ul = up[0];
      if (ul > v_digit)
 return 1;
      if (ul < v_digit)
 return -1;
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 7
2 6
3 8
4 8
5 10
6 10
7 10
8 10
9 20
10 10
11 11
12 11
13 21
14 21
15 14
16 14
17 16
18 16
19 16
20 21
21 21
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0xd,0x8(%rdi)
jne    1a9c <rec_type_rec+0xc>
mov    0x20(%rdi),%rax
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
rec_type_rec (rec_type_t type)
{
  const char *res = ((void *)0);
  if (type->kind == REC_TYPE_REC)
    {
      res = type->data.recname;
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 9
6 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1010,%edi
callq  e <rl_make_bare_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
jne    10 <rl_make_bare_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_make_bare_keymap ()
{
  register int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc (257 * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < 257; i++)
    {
      keymap[i].type = 0;
      keymap[i].function = (rl_command_func_t *)((void *)0);
    }
  return (keymap);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
mov    0x80(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_cnum (osip_authorization_t * authorization)
{
  return authorization->cnum;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x28,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  928 <read_fatal_details+0x28>
mov    (%rax),%ebp
mov    0x0(%rip),%rax        # 931 <read_fatal_details+0x31>
test   %rax,%rax
je     938 <read_fatal_details+0x38>
callq  *%rax
mov    %rsp,%rsi
mov    %r13,%rdi
callq  943 <read_fatal_details+0x43>
mov    %r12,%rdi
mov    %rax,%r13
callq  94e <read_fatal_details+0x4e>
mov    %rbx,%rdx
mov    %rax,%r12
mov    $0x0,%esi
mov    $0x0,%edi
callq  963 <read_fatal_details+0x63>
mov    %rbx,%r9
mov    %rax,%rdx
mov    %r13,%r8
mov    %r12,%rcx
mov    %ebp,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  97a <read_fatal_details+0x7a>
callq  97f <read_fatal_details+0x7f>
nop
<<<sep_in_sample>>>
read_fatal_details (char const *name, off_t offset, size_t size)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, ngettext ("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes", size), quotearg_colon (name), umaxtostr (offset, buf), (unsigned long) size); fatal_exit (); } while (0)
                        ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     f8 <_auth_lb_grow+0x78>
mov    0x8(%rbx),%rdx
mov    0x10(%rbx),%rax
mov    %rdx,%rcx
sub    %rax,%rcx
cmp    %rcx,%rbp
ja     d0 <_auth_lb_grow+0x50>
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rax,%rdi
callq  bc <_auth_lb_grow+0x3c>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x0(%rbp,%rdx,1),%r13
mov    %r13,%rsi
callq  dd <_auth_lb_grow+0x5d>
test   %rax,%rax
mov    %rax,(%rbx)
je     114 <_auth_lb_grow+0x94>
mov    %r13,0x8(%rbx)
mov    %rax,%rdi
mov    0x10(%rbx),%rax
jmp    ae <_auth_lb_grow+0x2e>
nopw   0x0(%rax,%rax,1)
mov    %rdx,%rdi
callq  100 <_auth_lb_grow+0x80>
test   %rax,%rax
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jne    e9 <_auth_lb_grow+0x69>
add    $0x8,%rsp
mov    $0xc,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 9
13 9
14 9
15 9
16 9
17 9
18 18
19 18
20 18
21 18
22 19
23 21
24 20
25 21
26 21
27 21
28 21
29 21
30 21
31 11
32 12
33 12
34 13
35 12
36 13
37 14
38 14
39 14
40 14
41 14
42 5
43 5
44 16
45 5
46 6
47 7
48 16
49 21
50 17
51 21
52 21
53 21
54 21
55 21
56 21
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
vector_bfgs_restart (void *vstate)
{
  vector_bfgs_state_t *state = (vector_bfgs_state_t *) vstate;
  state->iter = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  21e <ShowHelp+0xe>
mov    $0x0,%edi
callq  228 <ShowHelp+0x18>
mov    $0x0,%edi
callq  232 <ShowHelp+0x22>
mov    $0x0,%edi
callq  23c <ShowHelp+0x2c>
mov    $0x0,%edi
callq  246 <ShowHelp+0x36>
mov    $0x0,%edi
callq  250 <ShowHelp+0x40>
mov    $0x0,%edi
callq  25a <ShowHelp+0x4a>
mov    $0x0,%edi
callq  264 <ShowHelp+0x54>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   272 <ShowHelp+0x62>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ShowHelp ()
{
  printf ("Help:\n");
  printf ("Usage: mod [options] [input-file [output-file]]\n");
  printf ("Options:\n");
  printf ("  -h  Display this information\n");
  printf ("  -H  Display this information\n");
  printf ("  -D  Debug mode\n");
  printf ("  -R  Generate an R deSolve compatible C file\n");
  printf ("Creates file 'output-file' (or 'model.c', by default)\n");
  printf ("according to the input-file specifications.\n\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 11
19 12
20 11
21 11
<<<sep_out_sample>>>
jmpq   375 <mbstrcasestr+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbstrcasestr(const char *haystack, const char *needle)
{
 return (char *) strcasestr(haystack, needle);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
jmpq   22b5 <yyrealloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x8,0x0(%rip)        # 76b <do_statusbar_cut_text+0xb>
mov    0x0(%rip),%rsi        # 772 <do_statusbar_cut_text+0x12>
jne    781 <do_statusbar_cut_text+0x21>
movq   $0x0,0x0(%rip)        # 77f <do_statusbar_cut_text+0x1f>
xor    %esi,%esi
mov    $0x0,%edi
callq  78b <do_statusbar_cut_text+0x2b>
add    $0x8,%rsp
jmpq   794 <do_statusbar_cut_text+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_statusbar_cut_text(void)
{
    if (!((flags[((CUT_TO_END) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((CUT_TO_END) % (sizeof(unsigned) * 8)))) != 0))
 statusbar_x = 0;
    null_at(&answer, statusbar_x);
    update_the_statusbar();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 7
10 6
11 6
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   68 <nettle_gcm_camellia128_update+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_camellia128_update (struct gcm_camellia128_ctx *ctx,
   size_t length, const uint8_t *data)
{
  nettle_gcm_update(&(ctx)->gcm, &(ctx)->key, (length), (data));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_set_protocol (osip_via_t * via, char *protocol)
{
  via->protocol = protocol;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2147 <yyget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_out (void)
{
        return yyout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x30(%rdi)
jne    a8 <_url_imaps_init+0x18>
movq   $0x3e1,0x30(%rdi)
cmpq   $0x0,0x28(%rbx)
movq   $0x0,0x68(%rbx)
mov    $0x16,%ebp
je     c8 <_url_imaps_init+0x38>
mov    0x58(%rbx),%ebp
test   %ebp,%ebp
je     d8 <_url_imaps_init+0x48>
mov    $0x16,%ebp
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
cmpq   $0x0,0x20(%rbx)
jne    c8 <_url_imaps_init+0x38>
mov    $0x2,%edi
callq  e9 <_url_imaps_init+0x59>
test   %rax,%rax
mov    %rax,0x20(%rbx)
je     ff <_url_imaps_init+0x6f>
movb   $0x2a,(%rax)
mov    0x20(%rbx),%rax
movb   $0x0,0x1(%rax)
jmp    c8 <_url_imaps_init+0x38>
mov    $0xc,%ebp
jmp    c8 <_url_imaps_init+0x38>
<<<sep_in_sample>>>
_url_imaps_init (mu_url_t url)
{
  if (url->port == 0)
    url->port = 993;
  url->_destroy = url_imap_destroy;
  if (!url->host || url->qargc)
    return 22;
  if (!url->auth)
    {
      url->auth = malloc (1 + 1);
      if (!url->auth)
 return 12;
      url->auth[0] = '*';
      url->auth[1] = '\0';
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 6
9 5
10 7
11 6
12 6
13 6
14 6
15 7
16 17
17 17
18 17
19 17
20 17
21 17
22 8
23 8
24 10
25 10
26 11
27 10
28 11
29 13
30 14
31 14
32 14
33 12
34 12
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
mov    %rdi,%rax
test   %r8b,%r8b
je     41 <base_name+0x41>
lea    0x1(%rdi),%rcx
mov    %r8d,%edx
mov    $0x1,%esi
xor    %edi,%edi
nopw   0x0(%rax,%rax,1)
cmp    $0x2f,%dl
cmove  %rcx,%rax
cmovne %edi,%esi
add    $0x1,%rcx
movzbl -0x1(%rcx),%edx
test   %dl,%dl
jne    20 <base_name+0x20>
cmpb   $0x0,(%rax)
jne    41 <base_name+0x41>
cmp    $0x2f,%r8b
je     48 <base_name+0x48>
repz retq 
nopl   0x0(%rax,%rax,1)
cmp    $0x1,%esi
adc    $0xffffffffffffffff,%rax
retq   
<<<sep_in_sample>>>
base_name (char const *name)
{
  char const *base = name += 0;
  int all_slashes = 1;
  char const *p;
  for (p = name; *p; p++)
    {
      if (((*p) == '/'))
 base = p + 1;
      else
 all_slashes = 0;
    }
  if (*base == '\0' && ((*name) == '/') && all_slashes)
    --base;
  return (char *) base;
}
<<<sep_in_sample>>>
1 6
2 2
3 6
4 6
5 6
6 6
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 13
18 13
19 13
20 13
21 16
22 16
23 14
24 14
25 16
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_dcpi1_bdiv_qr_n_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
mov    0x40(%rdi),%rdi
jmpq   19 <folder_pop_open+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
folder_pop_open (mu_folder_t folder, int flags)
{
  mu_mailbox_t mbox = folder->data;
  return mu_mailbox_open (mbox, flags);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
push   %r13
mov    %rcx,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
mov    %rdx,0x18(%rsp)
callq  35 <argmatch+0x25>
mov    (%r15),%r14
test   %r14,%r14
je     162 <argmatch+0x152>
xor    %ebx,%ebx
test   %rbp,%rbp
mov    %rax,%r12
movb   $0x0,0x17(%rsp)
movq   $0xffffffffffffffff,0x8(%rsp)
jne    97 <argmatch+0x87>
jmpq   11a <argmatch+0x10a>
xchg   %ax,%ax
imul   %r13,%rdi
mov    %r13,%rdx
mov    %rbp,%rsi
add    0x18(%rsp),%rdi
callq  74 <argmatch+0x64>
test   %eax,%eax
movzbl 0x17(%rsp),%eax
mov    $0x1,%ecx
cmovne %ecx,%eax
mov    %al,0x17(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  a6 <argmatch+0x96>
test   %eax,%eax
jne    87 <argmatch+0x77>
mov    %r14,%rdi
callq  b2 <argmatch+0xa2>
cmp    %r12,%rax
je     150 <argmatch+0x140>
mov    0x8(%rsp),%rdi
cmp    $0xffffffffffffffff,%rdi
jne    60 <argmatch+0x50>
mov    %rbx,0x8(%rsp)
add    $0x1,%rbx
add    %r13,%rbp
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
jne    97 <argmatch+0x87>
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x17(%rsp)
mov    $0xfffffffffffffffe,%rax
jne    f3 <argmatch+0xe3>
mov    0x8(%rsp),%rax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
movb   $0x1,0x17(%rsp)
add    $0x1,%rbx
mov    (%r15,%rbx,8),%r14
test   %r14,%r14
je     e0 <argmatch+0xd0>
mov    (%rsp),%rsi
mov    %r12,%rdx
mov    %r14,%rdi
callq  129 <argmatch+0x119>
test   %eax,%eax
jne    10d <argmatch+0xfd>
mov    %r14,%rdi
callq  135 <argmatch+0x125>
cmp    %r12,%rax
je     150 <argmatch+0x140>
cmpq   $0xffffffffffffffff,0x8(%rsp)
jne    108 <argmatch+0xf8>
mov    %rbx,0x8(%rsp)
jmp    10d <argmatch+0xfd>
nopl   0x0(%rax)
add    $0x28,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
movq   $0xffffffffffffffff,0x8(%rsp)
jmp    ee <argmatch+0xde>
nopl   (%rax)
<<<sep_in_sample>>>
argmatch (const char *arg, const char *const *arglist,
          const char *vallist, size_t valsize)
{
  size_t i;
  size_t arglen;
  ptrdiff_t matchind = -1;
  _Bool ambiguous = 0;
  arglen = strlen (arg);
  for (i = 0; arglist[i]; i++)
    {
      if (!strncmp (arglist[i], arg, arglen))
        {
          if (strlen (arglist[i]) == arglen)
            return i;
          else if (matchind == -1)
            matchind = i;
          else
            {
              if (vallist == ((void *)0)
                  || memcmp (vallist + valsize * matchind,
                             vallist + valsize * i, valsize))
                {
                  ambiguous = 1;
                }
            }
        }
    }
  if (ambiguous)
    return -2;
  else
    return matchind;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 7
21 6
22 6
23 6
24 6
25 20
26 20
27 20
28 20
29 20
30 23
31 23
32 23
33 23
34 23
35 9
36 9
37 9
38 9
39 9
40 11
41 11
42 11
43 11
44 11
45 11
46 13
47 13
48 13
49 13
50 15
51 15
52 15
53 16
54 9
55 9
56 9
57 9
58 9
59 9
60 28
61 29
62 28
63 31
64 32
65 32
66 32
67 32
68 32
69 32
70 32
71 32
72 32
73 23
74 9
75 9
76 9
77 9
78 11
79 11
80 11
81 11
82 11
83 11
84 13
85 13
86 13
87 13
88 15
89 15
90 16
91 16
92 16
93 32
94 14
95 32
96 32
97 32
98 32
99 32
100 32
101 32
102 6
103 6
104 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    1070 <gsl_matrix_long_double_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  1092 <gsl_matrix_long_double_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_superdiagonal (gsl_matrix_long_double * m,
                                      const size_t k)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     25b8 <gsl_block_ulong_raw_fscanf+0x88>
mov    %rdi,%r13
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
xor    %ebp,%ebp
jmp    256c <gsl_block_ulong_raw_fscanf+0x3c>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     25b8 <gsl_block_ulong_raw_fscanf+0x88>
mov    %rsp,%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  257e <gsl_block_ulong_raw_fscanf+0x4e>
mov    (%rsp),%rdx
cmp    $0x1,%eax
mov    %rdx,(%rbx)
je     2560 <gsl_block_ulong_raw_fscanf+0x30>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  25a3 <gsl_block_ulong_raw_fscanf+0x73>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   (%rax)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_ulong_raw_fscanf (FILE * stream,
                                  unsigned long * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          unsigned long tmp;
          int status = fscanf (stream, "%lu", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 13
21 13
22 13
23 13
24 13
25 14
26 15
27 14
28 15
29 17
30 17
31 17
32 17
33 17
34 22
35 17
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 21
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 167 <current_history+0x7>
cmp    0x0(%rip),%eax        # 16d <current_history+0xd>
je     180 <current_history+0x20>
mov    0x0(%rip),%rdx        # 176 <current_history+0x16>
test   %rdx,%rdx
je     180 <current_history+0x20>
mov    (%rdx,%rax,8),%rax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
current_history ()
{
  return ((history_offset == history_length) || the_history == 0)
  ? (HIST_ENTRY *)((void *)0)
  : the_history[history_offset];
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 3
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    0x18(%rdi),%rdi
jmpq   9 <ppd_font_add+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ppd_font_add (struct ppd * ppd, const char * fontname)
{
  string_htable_add (ppd->fonts, fontname);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    5d98 <gsl_matrix_ulong_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,8),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  5dba <gsl_matrix_ulong_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_const_column (const gsl_matrix_ulong * m, const size_t j)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1360 <gsl_permute_vector_long_inverse+0x30>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1355 <gsl_permute_vector_long_inverse+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1371 <gsl_permute_vector_long_inverse+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_long_inverse (const gsl_permutation * p, gsl_vector_long * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_long_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%rdi
mov    $0x10,%edx
sub    $0x8,%rsp
callq  1e <extend+0x1e>
mov    %rbp,(%rax)
movq   $0x0,0x8(%rax)
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extend (struct link *tp, void const *x, struct divvy *to)
{
  struct link *pair = alloc (to, "struct link", sizeof (struct link)); pair->entry = x; pair->next = ((void *)0); tp->next = pair; return pair;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 2
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
xor    %esi,%esi
callq  95e <rl_replace_from_history+0xe>
mov    0x10(%rbx),%rax
mov    0x0(%rip),%edx        # 968 <rl_replace_from_history+0x18>
movl   $0x0,0x0(%rip)        # 972 <rl_replace_from_history+0x22>
mov    %rax,0x0(%rip)        # 979 <rl_replace_from_history+0x29>
mov    0x0(%rip),%eax        # 97f <rl_replace_from_history+0x2f>
test   %edx,%edx
mov    %eax,0x0(%rip)        # 987 <rl_replace_from_history+0x37>
jne    999 <rl_replace_from_history+0x49>
movl   $0x0,0x0(%rip)        # 993 <rl_replace_from_history+0x43>
mov    %eax,0x0(%rip)        # 999 <rl_replace_from_history+0x49>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_replace_from_history (entry, flags)
     HIST_ENTRY *entry;
     int flags;
{
  rl_replace_line (entry->line, 0);
  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_point = rl_end;
  rl_mark = 0;
  if (rl_editing_mode == 0)
    {
      rl_point = 0;
      rl_mark = rl_end;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 6
7 9
8 8
9 6
10 7
11 9
12 7
13 9
14 11
15 12
16 14
17 14
18 14
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
sub    $0x18,%rsp
xorpd  %xmm0,%xmm0
ucomisd %xmm1,%xmm0
ja     38 <gsl_multimin_test_gradient+0x38>
movsd  %xmm1,0x8(%rsp)
callq  1d <gsl_multimin_test_gradient+0x1d>
movsd  0x8(%rsp),%xmm1
xor    %eax,%eax
ucomisd %xmm0,%xmm1
seta   %al
add    $0x18,%rsp
lea    -0x2(%rax,%rax,1),%eax
retq   
nopl   (%rax)
mov    $0xd,%ecx
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  51 <gsl_multimin_test_gradient+0x51>
mov    $0xd,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_test_gradient (const gsl_vector *g, double epsabs)
{
  double norm;
  if (epsabs < 0.0)
    {
      do { gsl_error ("absolute tolerance is negative", "convergence.c", 31, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
    }
  norm = gsl_blas_dnrm2(g);
  if (norm < epsabs)
    {
      return GSL_SUCCESS;
    }
  return GSL_CONTINUE;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 8
8 13
9 13
10 13
11 13
12 14
13 13
14 14
15 14
16 6
17 6
18 6
19 6
20 6
21 6
22 14
23 14
24 14
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x50(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->indexof_from_to (list, start_index, end_index, elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 66 <isbinary+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
isbinary( void ) { return isbinary_; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
callq  16 <sh_single_quote+0x16>
test   %rbx,%rbx
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jne    32 <sh_single_quote+0x32>
jmp    60 <sh_single_quote+0x60>
nopl   0x0(%rax)
add    $0x1,%rdx
add    $0x1,%rbx
je     60 <sh_single_quote+0x60>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     60 <sh_single_quote+0x60>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    28 <sh_single_quote+0x28>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    32 <sh_single_quote+0x32>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_single_quote (string)
     char *string;
{
  register int c;
  char *result, *r, *s;
  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 9
7 8
8 8
9 9
10 9
11 9
12 11
13 9
14 9
15 9
16 9
17 9
18 9
19 12
20 11
21 12
22 14
23 15
24 16
25 16
26 9
27 9
28 9
29 19
30 20
31 22
32 22
33 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl (%rdi),%eax
sub    $0x41,%eax
cmp    $0x28,%al
ja     60 <set_format_type+0x60>
movzbl %al,%eax
jmpq   *0x0(,%rax,8)
nopl   0x0(%rax,%rax,1)
movl   $0x3,(%rsi)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x1,(%rsi)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x2,(%rsi)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rsi)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rdi,%rcx
mov    0x0(%rip),%rdx        # 6a <set_format_type+0x6a>
mov    0x0(%rip),%rdi        # 71 <set_format_type+0x71>
mov    $0x0,%esi
xor    %eax,%eax
callq  7d <set_format_type+0x7d>
mov    $0x1,%edi
callq  87 <set_format_type+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_format_type (char *s, data_type *typep)
{
  switch (s[0])
    {
    case 'a':
    case 'A':
      *typep = T_ASCII;
      break;
    case 'f':
    case 'F':
      *typep = T_SINGLE;
      break;
    case 'd':
    case 'D':
      *typep = T_DOUBLE;
      break;
    case 'i':
    case 'I':
      *typep = T_INTEGER;
      break;
    default:
      {
 fprintf (stderr, "%s: error: the data format type `%s' is invalid\n",
   progname, s);
 exit (1);
      }
      break;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 19
10 29
11 29
12 29
13 11
14 29
15 29
16 29
17 15
18 29
19 29
20 29
21 7
22 29
23 29
24 29
25 23
26 23
27 23
28 23
29 23
30 23
31 25
32 25
33 25
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1cf0 <gsl_vector_ushort_mul+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ce5 <gsl_vector_ushort_mul+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1d29 <gsl_vector_ushort_mul+0x69>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rsi
add    %r10,%r10
add    %r9,%r9
xor    %ecx,%ecx
nopl   (%rax)
movzwl (%rax),%edx
add    $0x1,%rcx
imul   (%rsi),%dx
add    %r9,%rsi
mov    %dx,(%rax)
add    %r10,%rax
cmp    %r8,%rcx
jne    1d10 <gsl_vector_ushort_mul+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_mul (gsl_vector_ushort * a, const gsl_vector_ushort * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 77, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] *= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
movsd  0x8(%rdi),%xmm1
ucomisd %xmm0,%xmm1
ja     3a2 <gsl_interp_eval_deriv2_e+0x12>
ucomisd 0x10(%rdi),%xmm0
jbe    3b8 <gsl_interp_eval_deriv2_e+0x28>
movsd  0x0(%rip),%xmm2        # 3aa <gsl_interp_eval_deriv2_e+0x1a>
mov    $0x1,%eax
movsd  %xmm2,(%r8)
retq   
nopl   (%rax)
mov    (%rdi),%rax
mov    0x18(%rdi),%r10
mov    %r8,%r9
mov    0x20(%rdi),%rdi
mov    %rcx,%r8
mov    0x30(%rax),%rax
mov    %r10,%rcx
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_eval_deriv2_e (const gsl_interp * interp,
                          const double xa[], const double ya[], double x,
                          gsl_interp_accel * a,
                          double * d2)
{
  if (x < interp->xmin || x > interp->xmax)
    {
      *d2 = (__builtin_nanf (""));
      return GSL_EDOM;
    }
  return interp->type->eval_deriv2 (interp->state, xa, ya, interp->size, x, a, d2);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 8
7 12
8 8
9 12
10 12
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # b <give_usage+0xb>
mov    $0x0,%edi
xor    %eax,%eax
callq  17 <give_usage+0x17>
add    $0x8,%rsp
jmpq   20 <desired_entry>
<<<sep_in_sample>>>
give_usage(void)
{
  (void)printf("Usage: %s [-h"
               "p"
               "V] [-f file] [command] ... [user] ... [terminal] ...\n"
               "       [--forwards] [--file <file>] [--strict-match] [--print-controls]\n"
               "       [--user <name>] [--tty <name>] [--command <name>] [--debug]\n"
               "       "
               "[--show-paging] "
               "[--version] [--help]\n", program_name);
  print_acct_file_location ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 12
7 11
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_gradient (const gsl_multimin_fdfminimizer * s)
{
  return s->gradient;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
jmpq   145 <TransformPred+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TransformPred (PANALYSIS panal, PMCPREDOUT pMCPredOut)
{
  OutspecToLinearArray (panal, pMCPredOut);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
jbe    f0 <gsl_ran_gaussian_tail_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
movapd %xmm0,%xmm3
sub    $0x28,%rsp
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
divsd  %xmm2,%xmm3
mulsd  0x0(%rip),%xmm0        # 10e <gsl_ran_gaussian_tail_pdf+0x2e>
movsd  %xmm3,0x18(%rsp)
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  121 <gsl_ran_gaussian_tail_pdf+0x41>
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
movsd  0x0(%rip),%xmm0        # 135 <gsl_ran_gaussian_tail_pdf+0x55>
xorpd  %xmm3,%xmm0
mulsd  %xmm3,%xmm0
mulsd  0x0(%rip),%xmm0        # 145 <gsl_ran_gaussian_tail_pdf+0x65>
callq  14a <gsl_ran_gaussian_tail_pdf+0x6a>
movsd  0x0(%rip),%xmm1        # 152 <gsl_ran_gaussian_tail_pdf+0x72>
movsd  0x10(%rsp),%xmm2
movapd %xmm0,%xmm3
mulsd  0x8(%rsp),%xmm1
movsd  0x0(%rip),%xmm0        # 16a <gsl_ran_gaussian_tail_pdf+0x8a>
mulsd  0x0(%rip),%xmm1        # 172 <gsl_ran_gaussian_tail_pdf+0x92>
add    $0x28,%rsp
mulsd  %xmm2,%xmm1
divsd  %xmm1,%xmm0
mulsd  %xmm3,%xmm0
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ran_gaussian_tail_pdf (const double x, const double a, const double sigma)
{
  if (x < a)
    {
      return 0;
    }
  else
    {
      double N, p;
      double u = x / sigma ;
      double f = gsl_sf_erfc (a / (sqrt (2.0) * sigma));
      N = 0.5 * f;
      p = (1 / (N * sqrt (2 * 3.14159265358979323846) * sigma)) * exp (-u * u / 2);
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 10
7 2
8 11
9 11
10 10
11 11
12 10
13 11
14 11
15 11
16 13
17 11
18 13
19 13
20 13
21 13
22 13
23 12
24 13
25 13
26 12
27 13
28 13
29 16
30 13
31 13
32 13
33 16
34 16
<<<sep_out_sample>>>
push   %rbx
xor    %r8d,%r8d
mov    $0x16,%ecx
mov    $0xa,%esi
sub    $0x20,%rsp
mov    %rsp,%rdx
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  4a <itos+0x2a>
mov    %rax,%rdi
mov    %rax,%rbx
callq  55 <itos+0x35>
lea    0x1(%rax),%rdi
mov    $0x32,%edx
mov    $0x0,%esi
callq  68 <itos+0x48>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  73 <itos+0x53>
mov    0x18(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    89 <itos+0x69>
add    $0x20,%rsp
pop    %rbx
retq   
callq  8e <itos+0x6e>
xchg   %ax,%ax
<<<sep_in_sample>>>
itos (i)
     intmax_t i;
{
  char *p, lbuf[((sizeof (intmax_t) * 8 - (! ((intmax_t) 0 < (intmax_t) -1))) * 302 / 1000 + 1 + (! ((intmax_t) 0 < (intmax_t) -1))) + 1];
  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return ((char *)strcpy (sh_xmalloc((1 + strlen (p)), "itos.c", 50), (p)));
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 3
6 5
7 3
8 3
9 3
10 5
11 6
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
__gmpn_sec_sqr_itch (mp_size_t an)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  de5 <gsl_stats_char_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  df8 <gsl_stats_char_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  e15 <gsl_stats_char_ttest+0x55>
test   %rbp,%rbp
js     e78 <gsl_stats_char_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # e27 <gsl_stats_char_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     e98 <gsl_stats_char_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     eb2 <gsl_stats_char_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    e1f <gsl_stats_char_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    e39 <gsl_stats_char_ttest+0x79>
test   %rbp,%rbp
js     eec <gsl_stats_char_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     f03 <gsl_stats_char_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  ee3 <gsl_stats_char_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   e57 <gsl_stats_char_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    ebc <gsl_stats_char_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    ece <gsl_stats_char_ttest+0x10e>
<<<sep_in_sample>>>
gsl_stats_char_ttest (const char data1[],
                           const size_t stride1, const size_t n1,
                           const char data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_char_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_char_mean (data2, stride2, n2);
  const double pv = gsl_stats_char_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a29 <rl_cleanup_after_signal+0x9>
mov    0x0(%rip),%rax        # a30 <rl_cleanup_after_signal+0x10>
test   %rax,%rax
je     a37 <rl_cleanup_after_signal+0x17>
callq  *%rax
callq  a3c <rl_cleanup_after_signal+0x1c>
add    $0x8,%rsp
jmpq   a45 <rl_cleanup_after_signal+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_cleanup_after_signal ()
{
  _rl_clean_up_for_exit ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
  rl_clear_pending_input ();
  rl_clear_signals ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 6
8 8
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
callq  e <fopen_safer+0xe>
test   %rax,%rax
mov    %rax,%rbx
je     26 <fopen_safer+0x26>
mov    %rax,%rdi
mov    %rbx,%rbp
callq  21 <fopen_safer+0x21>
cmp    $0x2,%eax
jbe    30 <fopen_safer+0x30>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %eax,%edi
callq  37 <fopen_safer+0x37>
test   %eax,%eax
mov    %eax,%ebx
js     63 <fopen_safer+0x63>
mov    %rbp,%rdi
callq  45 <fopen_safer+0x45>
test   %eax,%eax
jne    80 <fopen_safer+0x80>
mov    %r12,%rsi
mov    %ebx,%edi
callq  53 <fopen_safer+0x53>
test   %rax,%rax
je     80 <fopen_safer+0x80>
mov    %rax,%rbp
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
callq  68 <fopen_safer+0x68>
mov    (%rax),%r12d
mov    %rax,%rbx
mov    %rbp,%rdi
callq  76 <fopen_safer+0x76>
xor    %ebp,%ebp
mov    %r12d,(%rbx)
jmp    26 <fopen_safer+0x26>
nopl   (%rax)
callq  85 <fopen_safer+0x85>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    %ebx,%edi
callq  92 <fopen_safer+0x92>
mov    %r12d,0x0(%rbp)
xor    %ebp,%ebp
jmp    26 <fopen_safer+0x26>
<<<sep_in_sample>>>
fopen_safer (char const *file, char const *mode)
{
  FILE *fp = fopen (file, mode);
  if (fp)
    {
      int fd = fileno (fp);
      if (0 <= fd && fd <= 2)
        {
          int f = dup_safer (fd);
          if (f < 0)
            {
              int e = (*__errno_location ());
              rpl_fclose (fp);
              (*__errno_location ()) = e;
              return ((void *)0);
            }
          if (rpl_fclose (fp) != 0
              || ! (fp = fdopen (f, mode)))
            {
              int e = (*__errno_location ());
              close (f);
              (*__errno_location ()) = e;
              return ((void *)0);
            }
        }
    }
  return fp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 28
16 28
17 28
18 28
19 28
20 28
21 9
22 9
23 10
24 9
25 10
26 17
27 17
28 17
29 17
30 18
31 18
32 18
33 18
34 18
35 18
36 28
37 28
38 28
39 28
40 28
41 12
42 12
43 12
44 13
45 13
46 15
47 14
48 15
49 15
50 20
51 20
52 20
53 21
54 21
55 22
56 23
57 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 381b <sendayt+0xb>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xff,(%rax)
callq  382d <sendayt+0x1d>
mov    0x0(%rip),%rax        # 3834 <sendayt+0x24>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xf6,(%rax)
callq  3846 <sendayt+0x36>
mov    $0xf6,%edx
mov    $0xff,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   385e <sendayt+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
sendayt (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 246; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 246);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 5
16 4
17 4
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%edi        # a76 <togdebug+0x6>
test   %edi,%edi
jle    aa8 <togdebug+0x38>
sub    $0x8,%rsp
mov    0x0(%rip),%ecx        # a84 <togdebug+0x14>
mov    $0x1,%edx
mov    $0x1,%esi
callq  a93 <togdebug+0x23>
test   %eax,%eax
js     ab0 <togdebug+0x40>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
mov    $0x0,%edi
callq  aba <togdebug+0x4a>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
togdebug (void)
{
  if (net > 0 && (SetSockOpt (net, 1, 1, debug)) < 0)
    {
      perror ("setsockopt (SO_DEBUG)");
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 5
19 5
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x40(%rdi),%rcx
mov    0x38(%rdi),%rdx
mov    %rax,%rdi
jmpq   470 <xheader_print_n>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattr_acls_a_coder (struct tar_stat_info const *st , char const *keyword,
                    struct xheader *xhdr, void const *data)
{
  xheader_print_n (xhdr, keyword, st->acls_a_ptr, st->acls_a_len);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  1cf <call_arg_warn+0xf>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 1d8 <call_arg_warn+0x18>
test   %rax,%rax
je     1df <call_arg_warn+0x1f>
callq  *%rax
mov    %r12,%rdi
callq  1e7 <call_arg_warn+0x27>
mov    $0x0,%edi
mov    %rax,%r12
callq  1f4 <call_arg_warn+0x34>
mov    %ebx,%esi
mov    %rbp,%r8
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
jmpq   20c <call_arg_warn+0x4c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
call_arg_warn (char const *call, char const *name)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot %s"), quotearg_colon (name), call); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 4
24 4
25 4
26 4
27 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
jne    3b0 <mu_address_concatenate+0x20>
mov    $0x16,%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %rsi,%rsi
je     39d <mu_address_concatenate+0xd>
mov    (%rsi),%rdx
mov    $0x16,%eax
test   %rdx,%rdx
jne    3cb <mu_address_concatenate+0x3b>
jmp    3a2 <mu_address_concatenate+0x12>
nopl   0x0(%rax)
mov    %rax,%rbx
mov    0x38(%rbx),%rax
test   %rax,%rax
jne    3c8 <mu_address_concatenate+0x38>
mov    %rdx,0x38(%rbx)
movq   $0x0,(%rsi)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     3f3 <mu_address_concatenate+0x63>
callq  3ec <mu_address_concatenate+0x5c>
movq   $0x0,(%rbx)
mov    0x38(%rbx),%rbx
xor    %eax,%eax
mov    (%rbx),%rdi
test   %rdi,%rdi
je     3a2 <mu_address_concatenate+0x12>
mov    %eax,0xc(%rsp)
callq  40a <mu_address_concatenate+0x7a>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_address_concatenate (mu_address_t to, mu_address_t *from)
{
  if (!to || !from || !*from)
    return 22;
  while (to->next)
    to = to->next;
  ((to && !to->next) ? (void) (0) : __assert_fail ("to && !to->next", "address.c", 183, __PRETTY_FUNCTION__));
  to->next = *from;
  *from = ((void *)0);
  if (to->addr)
    {
      free (to->addr);
      to->addr = ((void *)0);
    }
  to = to->next;
  if (to->addr)
    {
      free (to->addr);
      to->addr = ((void *)0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 22
8 22
9 22
10 22
11 3
12 3
13 3
14 4
15 3
16 3
17 3
18 3
19 5
20 5
21 5
22 5
23 8
24 9
25 10
26 10
27 10
28 12
29 13
30 15
31 21
32 16
33 16
34 16
35 16
36 18
37 19
38 19
39 22
40 22
41 22
42 22
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0xc,%esi
jmpq   d <gcm_aes256_set_nonce_wrapper+0xd>
<<<sep_in_sample>>>
gcm_aes256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)
{
  nettle_gcm_aes256_set_iv (ctx, (16 - 4), nonce);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%eax        # 3e <osip_build_random_number+0xe>
test   %eax,%eax
je     60 <osip_build_random_number+0x30>
callq  47 <osip_build_random_number+0x17>
mov    %rax,%rdx
test   %edx,%edx
je     d0 <osip_build_random_number+0xa0>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
lea    0x10(%rsp),%rdi
xor    %esi,%esi
callq  6c <osip_build_random_number+0x3c>
xor    %esi,%esi
xor    %eax,%eax
mov    $0x0,%edi
mov    0x10(%rsp),%rbp
add    0x18(%rsp),%ebp
callq  83 <osip_build_random_number+0x53>
test   %eax,%eax
mov    %eax,%r12d
jle    b3 <osip_build_random_number+0x83>
mov    $0x200,%ebx
nop
lea    0xc(%rsp),%rsi
mov    $0x4,%edx
mov    %r12d,%edi
callq  a2 <osip_build_random_number+0x72>
add    0xc(%rsp),%ebp
sub    $0x1,%ebx
jne    90 <osip_build_random_number+0x60>
mov    %r12d,%edi
callq  b3 <osip_build_random_number+0x83>
mov    %ebp,%edi
callq  ba <osip_build_random_number+0x8a>
movl   $0x1,0x0(%rip)        # c4 <osip_build_random_number+0x94>
callq  c9 <osip_build_random_number+0x99>
mov    %rax,%rdx
test   %edx,%edx
jne    52 <osip_build_random_number+0x22>
lea    0x10(%rsp),%rdi
xor    %esi,%esi
callq  dc <osip_build_random_number+0xac>
mov    0x10(%rsp),%rdi
add    0x18(%rsp),%edi
callq  ea <osip_build_random_number+0xba>
callq  ef <osip_build_random_number+0xbf>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_build_random_number ()
{
  if (!random_seed_set) {
    unsigned int ticks;
    struct timeval tv;
    int fd;
    gettimeofday (&tv, ((void *)0));
    ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);
    fd = open ("/dev/urandom", 00);
    if (fd > 0) {
      unsigned int r;
      int i;
      for (i = 0; i < 512; i++) {
        read (fd, &r, sizeof (r));
        ticks += r;
      }
      close (fd);
    }
    srand48 (ticks);
    random_seed_set = 1;
  }
  {
    int val = (int) lrand48 ();
    if (val == 0) {
      unsigned int ticks;
      struct timeval tv;
      gettimeofday (&tv, ((void *)0));
      ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);
      srand48 (ticks);
      return (unsigned int) lrand48 ();
    }
    return val;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 23
9 23
10 24
11 24
12 34
13 34
14 34
15 34
16 34
17 34
18 7
19 7
20 7
21 9
22 9
23 9
24 8
25 8
26 9
27 10
28 9
29 10
30 10
31 10
32 14
33 14
34 14
35 14
36 15
37 13
38 13
39 17
40 17
41 19
42 19
43 20
44 23
45 23
46 24
47 24
48 27
49 27
50 27
51 29
52 29
53 29
54 30
55 34
56 34
57 34
58 34
59 34
60 34
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 23a6 <yyget_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_debug (void)
{
        return yy_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %edi,%edi
jne    200 <tty_setsofttab+0x10>
andl   $0xffffe7ff,0x0(%rip)        # 1fe <tty_setsofttab+0xe>
retq   
nop
orl    $0x1800,0x0(%rip)        # 20a <tty_setsofttab+0x1a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_setsofttab (int on)
{
  if (on)
    {
      termbuf.c_oflag &= ~0014000;
      termbuf.c_oflag |= 0014000;
    }
  else
    {
      termbuf.c_oflag &= ~0014000;
      termbuf.c_oflag |= 0000000;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 10
4 10
5 10
6 6
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x8(%rdi),%rdi
xor    %esi,%esi
callq  58f <close_space+0xf>
movq   $0x0,0x68(%rbx)
movq   $0x0,0x60(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   5a8 <close_space+0x28>
<<<sep_in_sample>>>
close_space (struct divvy *divvy)
{
  __extension__ ({ struct obstack *__o = (&divvy->space); void *__obj = (void *) (((void *)0)); if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit) __o->next_free = __o->object_base = (char *) __obj; else _obstack_free (__o, __obj); });
  divvy->count = 0;
  divvy->first = ((void *)0);
  free (divvy);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 6
9 7
10 6
<<<sep_out_sample>>>
push   %r12
xorpd  %xmm2,%xmm2
movapd %xmm0,%xmm3
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    0x18(%rdi),%rbx
mov    (%rdi),%r12
movsd  (%rbx),%xmm1
ucomisd %xmm2,%xmm1
jp     78 <fn_qaws+0x78>
jne    78 <fn_qaws+0x78>
movsd  0x8(%rbx),%xmm1
movsd  0x0(%rip),%xmm4        # 33 <fn_qaws+0x33>
ucomisd %xmm2,%xmm1
movsd  %xmm4,0x8(%rsp)
jp     b0 <fn_qaws+0xb0>
jne    b0 <fn_qaws+0xb0>
cmpl   $0x1,0x10(%rbx)
je     e0 <fn_qaws+0xe0>
cmpl   $0x1,0x14(%rbx)
nop
je     110 <fn_qaws+0x110>
mov    0x8(%r12),%rdi
movapd %xmm3,%xmm0
callq  *(%r12)
mulsd  0x8(%rsp),%xmm0
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
movapd %xmm3,%xmm0
movsd  %xmm2,0x18(%rsp)
movsd  %xmm3,0x10(%rsp)
subsd  0x8(%rbp),%xmm0
callq  92 <fn_qaws+0x92>
movsd  0x18(%rsp),%xmm2
movsd  0x8(%rbx),%xmm1
movsd  %xmm0,0x8(%rsp)
ucomisd %xmm2,%xmm1
movsd  0x10(%rsp),%xmm3
jnp    3f <fn_qaws+0x3f>
nop
movsd  0x10(%rbp),%xmm0
movsd  %xmm3,0x10(%rsp)
subsd  %xmm3,%xmm0
callq  c4 <fn_qaws+0xc4>
mulsd  0x8(%rsp),%xmm0
cmpl   $0x1,0x10(%rbx)
movsd  0x10(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
jne    4b <fn_qaws+0x4b>
movapd %xmm3,%xmm0
movsd  %xmm3,0x10(%rsp)
subsd  0x8(%rbp),%xmm0
callq  f4 <fn_qaws+0xf4>
mulsd  0x8(%rsp),%xmm0
cmpl   $0x1,0x14(%rbx)
movsd  0x10(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
jne    56 <fn_qaws+0x56>
movsd  0x10(%rbp),%xmm0
movsd  %xmm3,0x10(%rsp)
subsd  %xmm3,%xmm0
callq  124 <fn_qaws+0x124>
mulsd  0x8(%rsp),%xmm0
movsd  0x10(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
jmpq   56 <fn_qaws+0x56>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fn_qaws (double x, void *params)
{
  struct fn_qaws_params *p = (struct fn_qaws_params *) params;
  gsl_function *f = p->function;
  gsl_integration_qaws_table *t = p->table;
  double factor = 1.0;
  if (t->alpha != 0.0)
    factor *= pow(x - p->a, t->alpha);
  if (t->beta != 0.0)
    factor *= pow(p->b - x, t->beta);
  if (t->mu == 1)
    factor *= log(x - p->a);
  if (t->nu == 1)
    factor *= log(p->b - x);
  return factor * (*((f)->function))(x,(f)->params);
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 2
6 2
7 2
8 5
9 4
10 7
11 7
12 7
13 7
14 9
15 6
16 9
17 6
18 9
19 9
20 11
21 11
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 16
30 16
31 16
32 16
33 16
34 16
35 8
36 8
37 8
38 8
39 8
40 8
41 9
42 8
43 9
44 9
45 9
46 9
47 10
48 10
49 10
50 10
51 10
52 11
53 10
54 10
55 11
56 12
57 12
58 12
59 12
60 12
61 13
62 12
63 12
64 13
65 14
66 14
67 14
68 14
69 14
70 14
71 14
72 14
73 14
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdx,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %rdx,%rdx
je     11e0 <gsl_block_complex_float_raw_fscanf+0xa0>
mov    %rdi,%r13
lea    0x0(,%rcx,8),%r15
lea    0x8(%rsi),%rbp
xor    %r12d,%r12d
jmp    1185 <gsl_block_complex_float_raw_fscanf+0x45>
xchg   %ax,%ax
add    $0x4,%rbx
cmp    %rbx,%rbp
jne    1189 <gsl_block_complex_float_raw_fscanf+0x49>
add    $0x1,%r12
add    %r15,%rbp
cmp    %r14,%r12
je     11e0 <gsl_block_complex_float_raw_fscanf+0xa0>
lea    -0x8(%rbp),%rbx
xor    %eax,%eax
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %r13,%rdi
callq  119b <gsl_block_complex_float_raw_fscanf+0x5b>
movss  (%rsp),%xmm0
cmp    $0x1,%eax
movss  %xmm0,(%rbx)
je     1170 <gsl_block_complex_float_raw_fscanf+0x30>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11c2 <gsl_block_complex_float_raw_fscanf+0x82>
add    $0x18,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_float_raw_fscanf (FILE * stream,
                                  float * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 2; k++)
        {
          float tmp;
          int status = fscanf (stream, "%g", &tmp) ;
          data [2 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 10
19 10
20 7
21 7
22 7
23 7
24 5
25 13
26 13
27 13
28 13
29 13
30 14
31 15
32 14
33 15
34 17
35 17
36 17
37 17
38 17
39 22
40 17
41 22
42 22
43 22
44 22
45 22
46 22
47 22
48 22
49 22
50 21
51 22
52 22
53 22
54 22
55 22
56 22
57 22
58 22
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    30d8 <gsl_matrix_ushort_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,2),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  30fa <gsl_matrix_ushort_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_superdiagonal (gsl_matrix_ushort * m,
                                      const size_t k)
{
  _gsl_vector_ushort_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ushort v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     51 <mu_asnprintf+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  82 <mu_asnprintf+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mu_asnprintf (char **pbuf, size_t *psize, const char *fmt, ...)
{
  int rc;
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc = mu_vasnprintf (pbuf, psize, fmt, ap);
  __builtin_va_end(ap);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 6
17 5
18 5
19 5
20 5
21 5
22 6
23 9
24 9
<<<sep_out_sample>>>
jmpq   8b5 <sv_execignore+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_execignore (name)
     char *name;
{
  setup_exec_ignore (name);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  3bf9 <filename_non_directory+0x9>
add    %rbx,%rax
cmp    %rax,%rbx
jb     3c11 <filename_non_directory+0x21>
jmp    3c17 <filename_non_directory+0x27>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%rax
cmp    %rbx,%rax
je     3c17 <filename_non_directory+0x27>
cmpb   $0x2f,-0x1(%rax)
jne    3c08 <filename_non_directory+0x18>
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
filename_non_directory (char *pathname)
{
  register char *filename = pathname + strlen (pathname);
  if ((0))
    pathname += 2;
  while (filename > pathname && !((filename[-1]) == '/'))
    filename--;
  return filename;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 6
6 6
7 6
8 6
9 7
10 6
11 6
12 6
13 6
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
mov    %rbp,%rsi
push   %rbx
mov    (%rdi),%rdi
mov    %rdx,%rbx
callq  67 <des_compat_des3_encrypt+0x17>
mov    0x8(%r12),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  7a <des_compat_des3_encrypt+0x2a>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    0x10(%r12),%rdi
pop    %r12
jmpq   91 <des_compat_des3_encrypt+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
des_compat_des3_encrypt(struct des_compat_des3 *ctx,
   uint32_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_des_encrypt(ctx->keys[0], length, dst, src);
  nettle_des_decrypt(ctx->keys[1], length, dst, dst);
  nettle_des_encrypt(ctx->keys[2], length, dst, dst);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 6
21 7
22 6
23 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  1d <rk4imp_free+0xd>
mov    0x28(%rbx),%rdi
callq  26 <rk4imp_free+0x16>
mov    0x20(%rbx),%rdi
callq  2f <rk4imp_free+0x1f>
mov    (%rbx),%rdi
callq  37 <rk4imp_free+0x27>
mov    0x8(%rbx),%rdi
callq  40 <rk4imp_free+0x30>
mov    0x10(%rbx),%rdi
callq  49 <rk4imp_free+0x39>
mov    0x18(%rbx),%rdi
callq  52 <rk4imp_free+0x42>
mov    %rbx,%rdi
pop    %rbx
jmpq   5b <rk4imp_free+0x4b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4imp_free (void *vstate)
{
  rk4imp_state_t *state = (rk4imp_state_t *) vstate;
  free (state->y_onestep);
  free (state->y0_orig);
  free (state->y0);
  free (state->k1nu);
  free (state->k2nu);
  free (state->ytmp1);
  free (state->ytmp2);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 12
19 11
20 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # d87 <yyget_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_in (void)
{
        return yyin;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 996 <gsl_vector_long_set+0x6>
test   %eax,%eax
je     99f <gsl_vector_long_set+0xf>
cmp    %rsi,(%rdi)
jbe    9b8 <gsl_vector_long_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
shl    $0x3,%rax
imul   %rsi,%rax
mov    %rdx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   9d1 <gsl_vector_long_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_set (gsl_vector_long * v, const size_t i, long x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r13
lea    (%rsi,%rdx,1),%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
push   %rbx
mov    %edi,%ebx
mov    %esi,%edi
sub    $0x18,%rsp
cmp    %ecx,%r13d
cmovbe %r13d,%ecx
cmp    %ecx,%ebx
mov    %ecx,%ebp
ja     190 <gsl_ran_hypergeometric_pdf+0x80>
cmp    %esi,%ebx
ja     190 <gsl_ran_hypergeometric_pdf+0x80>
cmp    %ecx,%edx
jae    142 <gsl_ran_hypergeometric_pdf+0x32>
lea    (%rdx,%rbx,1),%eax
cmp    %ecx,%eax
nop
jb     190 <gsl_ran_hypergeometric_pdf+0x80>
mov    %ebx,%esi
callq  149 <gsl_ran_hypergeometric_pdf+0x39>
mov    %ebp,%esi
mov    %r12d,%edi
movsd  %xmm0,(%rsp)
sub    %ebx,%esi
callq  15a <gsl_ran_hypergeometric_pdf+0x4a>
mov    %ebp,%esi
mov    %r13d,%edi
movsd  %xmm0,0x8(%rsp)
callq  16a <gsl_ran_hypergeometric_pdf+0x5a>
movsd  (%rsp),%xmm1
addsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
jmpq   18c <gsl_ran_hypergeometric_pdf+0x7c>
nopl   0x0(%rax)
add    $0x18,%rsp
xorpd  %xmm0,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_ran_hypergeometric_pdf (const unsigned int k,
                            const unsigned int n1,
                            const unsigned int n2,
                            unsigned int t)
{
  if (t > n1 + n2)
    {
      t = n1 + n2 ;
    }
  if (k > n1 || k > t)
    {
      return 0 ;
    }
  else if (t > n2 && k + n2 < t )
    {
      return 0 ;
    }
  else
    {
      double p;
      double c1 = gsl_sf_lnchoose(n1,k);
      double c2 = gsl_sf_lnchoose(n2,t-k);
      double c3 = gsl_sf_lnchoose(n1+n2,t);
      p = exp(c1 + c2 - c3) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 10
13 10
14 10
15 10
16 10
17 14
18 14
19 14
20 14
21 14
22 14
23 21
24 21
25 22
26 22
27 21
28 22
29 22
30 23
31 23
32 22
33 23
34 24
35 24
36 27
37 27
38 27
39 27
40 27
41 24
42 24
43 24
44 24
45 27
46 12
47 27
48 27
49 27
50 27
51 27
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_legendre_P1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_legendre_P1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_legendre_P1_e(x, &result)", "legendre_poly.c", 751, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # f78 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # f7f <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    faa <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  fa5 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    f98 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     fd3 <quotearg_free+0x63>
callq  fbd <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # fc8 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # fd3 <quotearg_free+0x63>
cmp    $0x0,%r12
je     fef <quotearg_free+0x7f>
mov    %r12,%rdi
callq  fe4 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # fef <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # ffb <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # f <eu+0xf>
movsd  0x0(%rip),%xmm0        # 17 <eu+0x17>
movsd  0x0(%rip),%xmm1        # 1f <eu+0x1f>
nop
xorpd  %xmm4,%xmm4
ucomisd %xmm4,%xmm1
mulsd  0x0(%rip),%xmm1        # 30 <eu+0x30>
jbe    128 <eu+0x128>
movapd %xmm0,%xmm3
subsd  %xmm1,%xmm3
ucomisd 0x0(%rip),%xmm3        # 46 <eu+0x46>
setb   %al
test   %al,%al
je     147 <eu+0x147>
mov    0x0(%rip),%rax        # 58 <eu+0x58>
movsd  %xmm0,0x28(%rax)
movsd  %xmm0,0x20(%rax)
callq  67 <eu+0x67>
mov    0x0(%rip),%rax        # 6e <eu+0x6e>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 78 <eu+0x78>
je     ab <eu+0xab>
nopw   0x0(%rax,%rax,1)
movsd  0x20(%rax),%xmm0
movsd  %xmm0,0x28(%rax)
movsd  0x60(%rax),%xmm0
movsd  %xmm0,0x68(%rax)
mov    0x108(%rax),%rax
test   %rax,%rax
jne    80 <eu+0x80>
movq   $0x0,0x0(%rip)        # ab <eu+0xab>
callq  b0 <eu+0xb0>
mov    0x0(%rip),%rax        # b7 <eu+0xb7>
movsd  0x0(%rip),%xmm1        # bf <eu+0xbf>
test   %rax,%rax
mov    %rax,0x0(%rip)        # c9 <eu+0xc9>
je     fa <eu+0xfa>
nopl   0x0(%rax,%rax,1)
movsd  0x60(%rax),%xmm0
mulsd  %xmm1,%xmm0
addsd  0x28(%rax),%xmm0
movsd  %xmm0,0x20(%rax)
mov    0x108(%rax),%rax
test   %rax,%rax
jne    d0 <eu+0xd0>
movq   $0x0,0x0(%rip)        # fa <eu+0xfa>
mov    0x0(%rip),%rax        # 101 <eu+0x101>
add    $0x1,%rax
cvtsi2sd %rax,%xmm0
mov    %rax,0x0(%rip)        # 111 <eu+0x111>
mulsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # 11d <eu+0x11d>
jmpq   20 <eu+0x20>
nopw   0x0(%rax,%rax,1)
movapd %xmm0,%xmm5
movsd  0x0(%rip),%xmm2        # 134 <eu+0x134>
subsd  %xmm1,%xmm5
ucomisd %xmm5,%xmm2
setb   %al
test   %al,%al
jne    51 <eu+0x51>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
eu (void)
{
  double t;
  for (it = 0, t = tstart; !(tstep>0 ? t-0.0625*tstep>=tstop : t-0.0625*tstep<=tstop ); t = tstart + (++it) * tstep)
    {
      symtab->sy_value = symtab->sy_val[0] = t;
      field();
      for (fsp = dqueue; fsp != ((void *)0); fsp = fsp->sy_link)
 {
   fsp->sy_val[0] = fsp->sy_value;
   fsp->sy_pri[0] = fsp->sy_prime;
 }
      printq();
      for (fsp = dqueue; fsp != ((void *)0); fsp = fsp->sy_link)
 fsp->sy_value = fsp->sy_val[0] + tstep * fsp->sy_prime;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 10
26 10
27 11
28 11
29 8
30 8
31 8
32 8
33 13
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
43 15
44 14
45 14
46 14
47 14
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 4
57 4
58 4
59 4
60 4
61 4
62 4
63 17
64 17
65 17
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1f6 <define_default_variables+0x6>
test   %eax,%eax
jne    25c <define_default_variables+0x6c>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rbx        # 207 <define_default_variables+0x17>
test   %rbx,%rbx
je     256 <define_default_variables+0x66>
mov    $0x0,%ebp
nopl   0x0(%rax)
mov    %rbx,%rdi
add    $0x10,%rbp
callq  224 <define_default_variables+0x34>
mov    0x0(%rip),%rdx        # 22b <define_default_variables+0x3b>
xor    %ecx,%ecx
mov    %rbx,%rdi
mov    $0x1,%r8d
mov    %eax,%esi
mov    0x8(%rdx),%r9
mov    -0x8(%rbp),%rdx
movq   $0x0,(%rsp)
callq  24d <define_default_variables+0x5d>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
jne    218 <define_default_variables+0x28>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
define_default_variables (void)
{
  const char **s;
  if (no_builtin_variables_flag)
    return;
  for (s = default_variables; *s != 0; s += 2)
    define_variable_in_set((s[0]),(strlen (s[0])),(s[1]),(o_default),(1), current_variable_set_list->set,((floc *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 6
25 6
26 6
27 8
28 8
29 8
30 8
31 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     5f <rcfile_error+0x5f>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
testb  $0x1,0x0(%rip)        # 69 <rcfile_error+0x69>
je     80 <rcfile_error+0x80>
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 87 <rcfile_error+0x87>
mov    $0xa,%edi
callq  91 <rcfile_error+0x91>
mov    0x0(%rip),%rbp        # 98 <rcfile_error+0x98>
test   %rbp,%rbp
jne    100 <rcfile_error+0x100>
lea    0xf0(%rsp),%rax
mov    %rbx,%rdi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  cc <rcfile_error+0xcc>
mov    0x0(%rip),%rdi        # d3 <rcfile_error+0xd3>
lea    0x8(%rsp),%rdx
mov    %rax,%rsi
callq  e0 <rcfile_error+0xe0>
mov    0x0(%rip),%rsi        # e7 <rcfile_error+0xe7>
mov    $0xa,%edi
callq  f1 <rcfile_error+0xf1>
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x0(%rip),%r12        # 107 <rcfile_error+0x107>
mov    $0x0,%edi
movb   $0x1,0x0(%rip)        # 113 <rcfile_error+0x113>
callq  118 <rcfile_error+0x118>
mov    0x0(%rip),%rdi        # 11f <rcfile_error+0x11f>
mov    %rax,%rsi
mov    %rbp,%rcx
mov    %r12,%rdx
xor    %eax,%eax
callq  12f <rcfile_error+0x12f>
jmpq   9d <rcfile_error+0x9d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rcfile_error(const char *msg, ...)
{
    va_list ap;
    if (((flags[((QUIET) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((QUIET) % (sizeof(unsigned) * 8)))) != 0))
 return;
    fprintf(stderr, "\n");
    if (lineno > 0) {
 errors = 1;
 fprintf(stderr, gettext("Error in %s on line %lu: "), nanorc, (unsigned long)lineno);
    }
    __builtin_va_start(ap,msg);
    vfprintf(stderr, gettext(msg), ap);
    __builtin_va_end(ap);
    fprintf(stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 4
22 4
23 15
24 15
25 15
26 15
27 15
28 15
29 6
30 6
31 6
32 7
33 7
34 7
35 11
36 12
37 11
38 11
39 11
40 11
41 11
42 12
43 12
44 12
45 12
46 12
47 14
48 14
49 14
50 15
51 15
52 15
53 15
54 15
55 15
56 9
57 9
58 8
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   2b <direntry_cmp_name+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    0x660(%rdi),%rax
mov    0x28(%rax),%rdx
mov    0x30(%rax),%rax
mov    -0x8(%rax,%rdx,8),%rax
mov    0x70(%rdi),%edx
mov    0x6c(%rax),%ecx
test   %ecx,%ecx
je     210 <file_job_synchronize_pages+0x50>
mov    %edx,%esi
sub    %ecx,%esi
mov    %esi,%ecx
add    $0x1,%ecx
mov    0x84(%rax),%esi
test   %esi,%esi
jne    1fb <file_job_synchronize_pages+0x3b>
movl   $0x1,0x84(%rax)
mov    %edx,0x70(%rax)
mov    0x88(%rax),%edx
mov    %ecx,0x74(%rax)
mov    %edx,0x80(%rax)
retq   
xchg   %ax,%ax
mov    %edx,0x6c(%rax)
mov    $0x1,%ecx
jmp    1e7 <file_job_synchronize_pages+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_job_synchronize_pages (struct a2ps_job * job)
{
  fjob_t * file = ((struct file_job *) (job->jobs->content[job->jobs->len - 1]));
  if (!file->first_page)
    file->first_page = job->pages;
  if (!file->top_page)
    file->top_page = 1;
  file->last_page = job->pages;
  file->top_line = ((struct file_job *) (job->jobs->content[job->jobs->len - 1]))->lines;
  file->pages = file->last_page - file->first_page + 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 7
17 8
18 9
19 10
20 9
21 10
22 10
23 5
24 5
25 5
26 5