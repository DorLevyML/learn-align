mov    0x8(%rsi),%rdx
xor    0x8(%rdi),%rdx
mov    (%rsi),%rax
xor    (%rdi),%rax
or     %rax,%rdx
sete   %al
retq   
<<<sep_in_sample>>>
compare_links (void const *entry1, void const *entry2)
{
  struct link const *link1 = entry1;
  struct link const *link2 = entry2;
  return ((link1->dev ^ link2->dev) | (link1->ino ^ link2->ino)) == 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edi
callq  b73 <do_scroll_down+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_scroll_down(void)
{
    do_down(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm0        # 8 <cblas_daxpy+0x8>
jp     10 <cblas_daxpy+0x10>
je     144 <cblas_daxpy+0x144>
cmp    $0x1,%edx
jne    e8 <cblas_daxpy+0xe8>
cmp    $0x1,%r8d
nopl   (%rax)
jne    e8 <cblas_daxpy+0xe8>
mov    %edi,%eax
sar    $0x1f,%eax
shr    $0x1e,%eax
lea    (%rdi,%rax,1),%r8d
and    $0x3,%r8d
sub    %eax,%r8d
mov    %r8d,%edx
test   %r8d,%r8d
jle    61 <cblas_daxpy+0x61>
mov    $0x0,%eax
movapd %xmm0,%xmm1
mulsd  (%rsi,%rax,8),%xmm1
addsd  (%rcx,%rax,8),%xmm1
movsd  %xmm1,(%rcx,%rax,8)
add    $0x1,%rax
cmp    %eax,%edx
jg     46 <cblas_daxpy+0x46>
add    $0x3,%r8d
cmp    %r8d,%edi
jle    144 <cblas_daxpy+0x144>
movslq %edx,%r9
lea    0x0(,%r9,8),%rax
lea    (%rcx,%rax,1),%r8
movapd %xmm0,%xmm1
mulsd  (%rsi,%r9,8),%xmm1
addsd  (%r8),%xmm1
movsd  %xmm1,(%r8)
lea    0x8(%rcx,%rax,1),%r8
movapd %xmm0,%xmm1
mulsd  0x8(%rsi,%rax,1),%xmm1
addsd  (%r8),%xmm1
movsd  %xmm1,(%r8)
lea    0x10(%rcx,%rax,1),%r8
movapd %xmm0,%xmm1
mulsd  0x10(%rsi,%rax,1),%xmm1
addsd  (%r8),%xmm1
movsd  %xmm1,(%r8)
lea    0x18(%rcx,%rax,1),%r8
movapd %xmm0,%xmm1
mulsd  0x18(%rsi,%rax,1),%xmm1
addsd  (%r8),%xmm1
movsd  %xmm1,(%r8)
add    $0x4,%edx
lea    0x3(%rdx),%eax
cmp    %eax,%edi
jg     6e <cblas_daxpy+0x6e>
repz retq 
mov    $0x0,%eax
test   %edx,%edx
jg     f8 <cblas_daxpy+0xf8>
mov    $0x1,%al
sub    %edi,%eax
imul   %edx,%eax
mov    $0x0,%r9d
test   %r8d,%r8d
jg     10d <cblas_daxpy+0x10d>
mov    $0x1,%r9b
sub    %edi,%r9d
imul   %r8d,%r9d
test   %edi,%edi
jle    144 <cblas_daxpy+0x144>
push   %rbx
mov    $0x0,%r10d
movslq %r9d,%r11
lea    (%rcx,%r11,8),%r11
movslq %eax,%rbx
movapd %xmm0,%xmm1
mulsd  (%rsi,%rbx,8),%xmm1
addsd  (%r11),%xmm1
movsd  %xmm1,(%r11)
add    %edx,%eax
add    %r8d,%r9d
add    $0x1,%r10d
cmp    %edi,%r10d
jne    118 <cblas_daxpy+0x118>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
cblas_daxpy (const int N, const double alpha, const double *X, const int incX,
             double *Y, const int incY)
{
{
  int i;
  if (alpha == 0.0) {
    return;
  }
  if (incX == 1 && incY == 1) {
    const int m = N % 4;
    for (i = 0; i < m; i++) {
      Y[i] += alpha * X[i];
    }
    for (i = m; i + 3 < N; i += 4) {
      Y[i] += alpha * X[i];
      Y[i + 1] += alpha * X[i + 1];
      Y[i + 2] += alpha * X[i + 2];
      Y[i + 3] += alpha * X[i + 3];
    }
  } else {
    int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
    int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
    for (i = 0; i < N; i++) {
      Y[iy] += alpha * X[ix];
      ix += incX;
      iy += incY;
    }
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 9
5 9
6 9
7 9
8 9
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 11
18 11
19 12
20 12
21 12
22 12
23 12
24 11
25 11
26 14
27 14
28 14
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 16
37 16
38 16
39 16
40 16
41 17
42 17
43 17
44 17
45 17
46 18
47 18
48 18
49 18
50 18
51 14
52 14
53 14
54 14
55 14
56 21
57 21
58 21
59 21
60 21
61 21
62 22
63 22
64 22
65 22
66 22
67 22
68 23
69 23
70 3
71 23
72 24
73 24
74 24
75 24
76 24
77 24
78 24
79 25
80 26
81 23
82 23
83 23
84 30
85 30
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9f6 <sexfree+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sexfree (void * ptr , yyscan_t yyscanner)
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0xf(%rcx),%rdi
callq  2df <excfile_add+0x24>
mov    %rax,%rbx
movq   $0x0,(%rax)
mov    %r12d,0x8(%rax)
lea    0xc(%rax),%rdi
mov    %rbp,%rsi
callq  2f9 <excfile_add+0x3e>
mov    0x0(%rip),%rax        # 300 <excfile_add+0x45>
test   %rax,%rax
je     30a <excfile_add+0x4f>
mov    %rbx,(%rax)
jmp    311 <excfile_add+0x56>
mov    %rbx,0x0(%rip)        # 311 <excfile_add+0x56>
mov    %rbx,0x0(%rip)        # 318 <excfile_add+0x5d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
excfile_add (const char *name, int flags)
{
  struct excfile *p = xmalloc (sizeof (*p) + strlen (name));
  p->next = ((void *)0);
  p->flags = flags;
  strcpy (p->name, name);
  if (excfile_tail)
    excfile_tail->next = p;
  else
    excfile_head = p;
  excfile_tail = p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 5
15 6
16 6
17 6
18 7
19 7
20 7
21 8
22 8
23 10
24 11
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rdx,%r12
movl   $0x0,(%rdx)
movzbl (%rdi),%ecx
test   %cl,%cl
je     8e3 <wordsplit_c_quoted_length+0x9b>
mov    %esi,%r13d
mov    $0x0,%ebp
movsbl %cl,%esi
mov    $0x0,%edi
callq  87a <wordsplit_c_quoted_length+0x32>
test   %rax,%rax
je     887 <wordsplit_c_quoted_length+0x3f>
movl   $0x1,(%r12)
movzbl (%rbx),%edi
cmp    $0x20,%dil
jne    896 <wordsplit_c_quoted_length+0x4e>
add    $0x1,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
cmp    $0x22,%dil
jne    8a2 <wordsplit_c_quoted_length+0x5a>
add    $0x2,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
cmp    $0x5c,%dil
je     8b4 <wordsplit_c_quoted_length+0x6c>
cmp    $0x1f,%dil
jle    8b4 <wordsplit_c_quoted_length+0x6c>
add    $0x1,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
test   %r13d,%r13d
je     8bf <wordsplit_c_quoted_length+0x77>
add    $0x3,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
movsbl %dil,%edi
callq  8c8 <wordsplit_c_quoted_length+0x80>
lea    0x2(%rbp),%rdx
add    $0x4,%rbp
test   %eax,%eax
cmovne %rdx,%rbp
add    $0x1,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    86d <wordsplit_c_quoted_length+0x25>
jmp    8e8 <wordsplit_c_quoted_length+0xa0>
mov    $0x0,%ebp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
wordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)
{
  size_t len = 0;
  *quote = 0;
  for (; *str; str++)
    {
      if (strchr (" \"", *str))
 *quote = 1;
      if (*str == ' ')
 len++;
      else if (*str == '"')
 len += 2;
      else if (*str != '\t' && *str != '\\' && (' ' <= ((unsigned) (*str)) && ((unsigned) (*str)) <= 127))
 len++;
      else if (quote_hex)
 len += 3;
      else
 {
   if (wordsplit_c_quote_char (*str))
     len += 2;
   else
     len += 4;
 }
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 5
11 5
12 5
13 3
14 7
15 7
16 7
17 7
18 7
19 8
20 9
21 9
22 9
23 10
24 10
25 11
26 11
27 12
28 12
29 13
30 13
31 13
32 13
33 14
34 14
35 15
36 15
37 16
38 16
39 19
40 19
41 20
42 20
43 20
44 20
45 5
46 5
47 5
48 5
49 5
50 3
51 26
52 26
53 26
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    $0x1,%r9d
callq  72b6 <gsl_fft_complex_float_inverse+0x18>
test   %eax,%eax
jne    7323 <gsl_fft_complex_float_inverse+0x85>
test   %rbx,%rbx
js     72c6 <gsl_fft_complex_float_inverse+0x28>
cvtsi2ss %rbx,%xmm1
jmp    72de <gsl_fft_complex_float_inverse+0x40>
mov    %rbx,%rdx
shr    %rdx
mov    %rbx,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2ss %rdx,%xmm1
addss  %xmm1,%xmm1
movss  0x0(%rip),%xmm0        # 72e6 <gsl_fft_complex_float_inverse+0x48>
divss  %xmm1,%xmm0
test   %rbx,%rbx
je     7323 <gsl_fft_complex_float_inverse+0x85>
lea    0x0(,%r12,8),%rsi
mov    %rbp,%rdi
mov    $0x0,%ecx
movaps %xmm0,%xmm1
mulss  (%rdi),%xmm1
movss  %xmm1,(%rdi)
movaps %xmm0,%xmm1
mulss  0x4(%rdi),%xmm1
movss  %xmm1,0x4(%rdi)
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    72ff <gsl_fft_complex_float_inverse+0x61>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_fft_complex_float_inverse (gsl_complex_packed_array_float data,
                                   const size_t stride,
                                   const size_t n,
                                   const gsl_fft_complex_wavetable_float * wavetable,
                                   gsl_fft_complex_workspace_float * work)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_float_transform (data, stride, n,
                                                    wavetable, work, sign);
  if (status)
    {
      return status;
    }
  {
    const float norm = 1.0F / (float)n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((data)[2*(stride)*(i)]) *= norm;
        ((data)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 8
8 8
9 10
10 10
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 17
25 17
26 19
27 19
28 17
29 19
30 19
31 19
32 20
33 20
34 20
35 17
36 17
37 17
38 17
39 24
40 24
41 24
42 24
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x18(%rdi),%rdx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  27ca <print_dep+0x20>
mov    0x38(%rbx),%rdx
lea    0x8(%rsp),%rcx
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 27df <print_dep+0x35>
callq  27e4 <print_dep+0x3a>
cmp    $0xffffffffffffffff,%rax
je     2820 <print_dep+0x76>
mov    %eax,%edi
callq  27f1 <print_dep+0x47>
mov    0x18(%rax),%rdx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  2809 <print_dep+0x5f>
mov    0x8(%rsp),%rsi
mov    0x0(%rip),%rdi        # 2815 <print_dep+0x6b>
callq  281a <print_dep+0x70>
cmp    $0xffffffffffffffff,%rax
jne    27ea <print_dep+0x40>
mov    0x18(%rbx),%rdx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  2838 <print_dep+0x8e>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
print_dep (struct prog *prog)
{
  pies_depmap_pos_t pos;
  size_t n;
  logmsg_printf (5, "%s -> ", prog->tag);
  for (n = depmap_first (depmap, depmap_col, prog->v.p.idx, &pos);
       n != (size_t)-1;
       n = depmap_next (depmap, pos))
    {
      struct prog *dp = prog_lookup_by_idx (n);
      logmsg_printf (5, "%s -> ", dp->tag);
    }
  logmsg_printf (5, "%s\n", prog->tag);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 11
19 11
20 11
21 11
22 11
23 8
24 8
25 8
26 6
27 6
28 13
29 13
30 13
31 13
32 13
33 14
34 14
35 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rdi
callq  3a49 <rec_sex_eval_str+0x14>
mov    %rax,%rdi
callq  3a51 <rec_sex_eval_str+0x1c>
mov    (%rbx),%rdi
callq  3a59 <rec_sex_eval_str+0x24>
lea    0x7(%rsp),%r8
mov    %rax,%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
lea    0x10(%rsp),%rdi
callq  f9 <rec_sex_eval_node>
cmpb   $0x0,0x7(%rsp)
je     3ada <rec_sex_eval_str+0xa5>
movq   $0x0,0x8(%rsp)
mov    0x10(%rsp),%eax
cmp    $0x1,%eax
je     3aa8 <rec_sex_eval_str+0x73>
cmp    $0x2,%eax
je     3ac4 <rec_sex_eval_str+0x8f>
test   %eax,%eax
jne    3ad3 <rec_sex_eval_str+0x9e>
mov    0x14(%rsp),%edx
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
callq  3aa6 <rec_sex_eval_str+0x71>
jmp    3ad3 <rec_sex_eval_str+0x9e>
movsd  0x18(%rsp),%xmm0
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x1,%eax
callq  3ac2 <rec_sex_eval_str+0x8d>
jmp    3ad3 <rec_sex_eval_str+0x9e>
mov    0x20(%rsp),%rdi
callq  3ace <rec_sex_eval_str+0x99>
mov    %rax,0x8(%rsp)
mov    0x8(%rsp),%rax
jmp    3adf <rec_sex_eval_str+0xaa>
mov    $0x0,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_sex_eval_str (rec_sex_t sex,
                  rec_record_t record)
{
  char *res;
  struct rec_sex_val_s val;
  _Bool status;
  rec_sex_ast_node_unfix (rec_sex_ast_top (sex->ast));
  val = rec_sex_eval_node (sex,
                           record,
                           rec_sex_ast_top (sex->ast),
                           &status);
  if (!status)
    {
      return ((void *)0);
    }
  res = ((void *)0);
  switch (val.type)
    {
    case 0:
      {
        rpl_asprintf (&res, "%d", val.int_val);
        break;
      }
    case 1:
      {
        rpl_asprintf (&res, "%f", val.real_val);
        break;
      }
    case 2:
      {
        res = strdup (val.str_val);
        break;
      }
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 12
19 12
20 16
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 21
29 21
30 21
31 21
32 22
33 26
34 26
35 26
36 26
37 26
38 27
39 31
40 31
41 31
42 35
43 35
44 14
45 36
46 36
47 36
48 36
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x1005,%eax
test   %rdi,%rdi
je     61 <mu_refcount_create+0x61>
mov    $0x10,%esi
mov    $0x1,%edi
callq  20 <mu_refcount_create+0x20>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     61 <mu_refcount_create+0x61>
movl   $0x1,(%rbx)
lea    0x8(%rbx),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  44 <mu_refcount_create+0x44>
mov    %eax,%r12d
test   %eax,%eax
jne    56 <mu_refcount_create+0x56>
mov    %rbx,0x0(%rbp)
mov    $0x0,%eax
jmp    61 <mu_refcount_create+0x61>
mov    %rbx,%rdi
callq  5e <mu_refcount_create+0x5e>
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_refcount_create (mu_refcount_t *prefcount)
{
  int status = 0;
  mu_refcount_t refcount;
  if (prefcount == ((void *)0))
    return (0x1000 +5);
  refcount = calloc (1, sizeof *refcount);
  if (refcount != ((void *)0))
    {
      refcount->ref = 1;
      status = mu_monitor_create (&refcount->lock, 0, refcount);
      if (status == 0)
 {
   *prefcount = refcount;
 }
      else
 {
   free (refcount);
 }
    }
  else
    {
      status = 12;
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 5
7 5
8 7
9 7
10 7
11 7
12 23
13 8
14 8
15 10
16 11
17 11
18 11
19 11
20 11
21 12
22 12
23 14
24 11
25 11
26 18
27 18
28 11
29 26
30 26
31 26
32 26
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
test   %rdx,%rdx
je     32c <gsl_stats_uint_absdev_m+0x3f>
shl    $0x2,%rsi
mov    $0x0,%eax
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 30b <gsl_stats_uint_absdev_m+0x1e>
mov    (%rdi),%ecx
cvtsi2sd %rcx,%xmm2
subsd  %xmm0,%xmm2
andpd  %xmm3,%xmm2
addsd  %xmm2,%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
jne    30b <gsl_stats_uint_absdev_m+0x1e>
jmp    32c <gsl_stats_uint_absdev_m+0x3f>
test   %rdx,%rdx
js     338 <gsl_stats_uint_absdev_m+0x4b>
cvtsi2sd %rdx,%xmm0
jmp    34d <gsl_stats_uint_absdev_m+0x60>
mov    %rdx,%rax
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_uint_absdev_m (const unsigned int data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
4 10
5 8
6 6
7 10
8 10
9 10
10 10
11 10
12 11
13 8
14 8
15 8
16 8
17 8
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     9af <gsl_matrix_fread+0x43>
shl    $0x3,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     9f0 <gsl_matrix_fread+0x84>
jmp    9c6 <gsl_matrix_fread+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  9c4 <gsl_matrix_fread+0x58>
jmp    9f0 <gsl_matrix_fread+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  9de <gsl_matrix_fread+0x72>
test   %eax,%eax
jne    9f0 <gsl_matrix_fread+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    9c6 <gsl_matrix_fread+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_fread (FILE * stream, gsl_matrix * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1bd <check_step+0x7>
cmp    %rax,0x0(%rip)        # 1c4 <check_step+0xe>
je     206 <check_step+0x50>
mov    %rax,0x0(%rip)        # 1cd <check_step+0x17>
mov    0x0(%rip),%eax        # 1d3 <check_step+0x1d>
mov    %eax,0x0(%rip)        # 1d9 <check_step+0x23>
mov    0x0(%rip),%rax        # 1e0 <check_step+0x2a>
mov    %rax,0x0(%rip)        # 1e7 <check_step+0x31>
movb   $0x1,0x0(%rip)        # 1ee <check_step+0x38>
mov    0x0(%rip),%eax        # 1f4 <check_step+0x3e>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 1fd <check_step+0x47>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    0x0(%rip),%rax        # 20d <check_step+0x57>
cmp    %rax,0x0(%rip)        # 214 <check_step+0x5e>
je     241 <check_step+0x8b>
mov    %rax,0x0(%rip)        # 21d <check_step+0x67>
mov    0x0(%rip),%eax        # 223 <check_step+0x6d>
mov    %eax,0x0(%rip)        # 229 <check_step+0x73>
mov    0x0(%rip),%eax        # 22f <check_step+0x79>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 238 <check_step+0x82>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    0x0(%rip),%eax        # 247 <check_step+0x91>
cmp    %eax,0x0(%rip)        # 24d <check_step+0x97>
je     26d <check_step+0xb7>
mov    %eax,0x0(%rip)        # 255 <check_step+0x9f>
mov    0x0(%rip),%eax        # 25b <check_step+0xa5>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 264 <check_step+0xae>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
check_step(INSTRUCTION **pi)
{
 if (fcall_count != stop.fcall_count) {
  stop.fcall_count = fcall_count;
  stop.sourceline = sourceline;
  stop.source = source;
  stop.print_frame = 1;
  return (--stop.repeat_count == 0);
 }
 if (source != stop.source) {
  stop.source = source;
  stop.sourceline = sourceline;
  return (--stop.repeat_count == 0);
 }
 if (sourceline != stop.sourceline) {
  stop.sourceline = sourceline;
  return (--stop.repeat_count == 0);
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 10
20 11
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 15
33 16
34 17
35 17
36 17
37 17
38 17
39 17
40 17
41 19
42 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <skip_blanks+0x9>
mov    (%rax),%rcx
jmp    12 <skip_blanks+0x12>
add    $0x1,%rbx
movzbl (%rbx),%eax
movzbl %al,%edx
testb  $0x20,0x1(%rcx,%rdx,2)
je     23 <skip_blanks+0x23>
cmp    $0xa,%al
jne    e <skip_blanks+0xe>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
skip_blanks( const char * p )
  {
  while( ((*__ctype_b_loc ())[(int) (((unsigned char)*p))] & (unsigned short int) _ISspace) && *p != '\n' ) ++p;
  return p;
  }
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  bf <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  c8 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  d1 <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  da <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  e3 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  ec <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  f4 <modnewton1_free+0x42>
mov    %rbx,%rdi
callq  fc <modnewton1_free+0x4a>
pop    %rbx
retq   
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
mov    $0x8,%eax
retq   
<<<sep_in_sample>>>
rk8pd_order (void *vstate)
{
  rk8pd_state_t *state = (rk8pd_state_t *) vstate;
  state = 0;
  return 8;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x773593ff,%edi
ja     27df <uxfio_read+0x48>
callq  27ac <uxfio_read+0x15>
mov    %rax,%rbp
test   %eax,%eax
jns    27da <uxfio_read+0x43>
callq  27b8 <uxfio_read+0x21>
mov    (%rax),%edi
callq  27bf <uxfio_read+0x28>
mov    %rax,%rcx
mov    %ebx,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 27d0 <uxfio_read+0x39>
mov    $0x0,%eax
callq  27da <uxfio_read+0x43>
movslq %ebp,%rax
jmp    2806 <uxfio_read+0x6f>
mov    $0xffffffffffffffff,%rax
cmp    $0x773593ff,%edi
jle    2806 <uxfio_read+0x6f>
mov    $0x0,%r8d
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
callq  2326 <uxfio_common_read>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
uxfio_read(int uxfio_fildes, void *buf, size_t nbyte)
{
 int ret;
 ;
 if (uxfio_fildes < 2000000000 && uxfio_fildes >= 0) {
  ret = uxfio_unix_safe_read(uxfio_fildes, buf, nbyte);
  if (ret < 0)
   fprintf(stderr,
    "uxfio_read fd=%d : %s\n",
     uxfio_fildes, strerror((*__errno_location ())));
  return ret;
 } else if (uxfio_fildes >= 2000000000 ) {
  return uxfio_common_read(((void *)0), uxfio_fildes, buf, nbyte, 0);
 } else {
  return -1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 6
8 6
9 7
10 7
11 10
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 15
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
lea    0x128(%rdi),%r12
mov    %r12,%rdi
callq  9e <osip_message_get_proxy_authorization+0x1f>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    b7 <osip_message_get_proxy_authorization+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  b1 <osip_message_get_proxy_authorization+0x32>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_proxy_authorization (const osip_message_t * sip, int pos, osip_proxy_authorization_t ** dest)
{
  osip_proxy_authorization_t *proxy_authorization;
  *dest = ((void *)0);
  if (osip_list_size (&sip->proxy_authorizations) <= pos)
    return -1;
  proxy_authorization = (osip_proxy_authorization_t *) osip_list_get (&sip->proxy_authorizations, pos);
  *dest = proxy_authorization;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 6
11 5
12 5
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
callq  283 <signal_handler+0xd>
mov    %rax,%rbp
mov    $0x0,%edi
callq  290 <signal_handler+0x1a>
mov    %rbp,%r8
mov    %ebx,%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  2ac <signal_handler+0x36>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
signal_handler (int signum)
{
  error (1, 0,
  gettext ("received signal %d: %s"), signum, strsignal (signum));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
callq  281 <is_cdrom_linux+0xf>
mov    %eax,%ebx
test   %al,%al
je     2ef <is_cdrom_linux+0x7d>
mov    $0x0,%edx
mov    $0x800,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  29e <is_cdrom_linux+0x2c>
mov    %eax,%ebp
test   %eax,%eax
js     2c9 <is_cdrom_linux+0x57>
mov    $0x0,%edx
mov    $0x5331,%esi
mov    %eax,%edi
mov    $0x0,%eax
callq  2ba <is_cdrom_linux+0x48>
cmp    $0xffffffff,%eax
setne  %bl
mov    %ebp,%edi
callq  2c7 <is_cdrom_linux+0x55>
jmp    2ef <is_cdrom_linux+0x7d>
test   %r12,%r12
je     2ea <is_cdrom_linux+0x78>
mov    $0x0,%edi
mov    $0x8,%ecx
mov    %r12,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
sete   %bl
jmp    2ef <is_cdrom_linux+0x7d>
mov    $0x0,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
is_cdrom_linux(const char *drive, char *mnttype)
{
  _Bool is_cd=0;
  int cdfd;
  if ( !cdio_is_device_quiet_generic(drive) ) {
    return(0);
  }
  cdfd = open(drive, (00|04000), 0);
  if ( cdfd >= 0 ) {
    if ( ioctl(cdfd, 0x5331, 0) != -1 ) {
      is_cd = 1;
    }
    close(cdfd);
    }
  else if ( mnttype && (strcmp(mnttype, "iso9660") == 0) ) {
    is_cd = 1;
  }
  return(is_cd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 13
26 13
27 13
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 3
40 19
41 19
42 19
43 19
44 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  fb <osip_fifo_get+0x10>
mov    $0x0,%edx
test   %eax,%eax
jne    188 <osip_fifo_get+0x9d>
mov    (%rbx),%rdi
callq  110 <osip_fifo_get+0x25>
cmpl   $0x1,0x24(%rbx)
je     157 <osip_fifo_get+0x6c>
lea    0x10(%rbx),%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  127 <osip_fifo_get+0x3c>
mov    %rax,%r12
mov    $0x0,%esi
mov    %rbp,%rdi
callq  137 <osip_fifo_get+0x4c>
mov    %rbp,%rdi
callq  13f <osip_fifo_get+0x54>
test   %eax,%eax
setle  %al
movzbl %al,%eax
mov    %eax,0x24(%rbx)
mov    (%rbx),%rdi
callq  152 <osip_fifo_get+0x67>
mov    %r12,%rdx
jmp    188 <osip_fifo_get+0x9d>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x2,%edx
mov    $0x71,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  17b <osip_fifo_get+0x90>
mov    (%rbx),%rdi
callq  183 <osip_fifo_get+0x98>
mov    $0x0,%edx
mov    %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_fifo_get (osip_fifo_t * ff)
{
  void *el = ((void *)0);
  int i = osip_sem_wait (ff->qisempty);
  if (i != 0)
    return ((void *)0);
  osip_mutex_lock (ff->qislocked);
  if (ff->state != osip_empty) {
    el = osip_list_get (&ff->queue, 0);
    osip_list_remove (&ff->queue, 0);
  }
  else {
    osip_trace ("port_fifo.c", 113, TRACE_LEVEL2, ((void *)0), "no element in fifo.\n");
    osip_mutex_unlock (ff->qislocked);
    return 0;
  }
  if (osip_list_size (&ff->queue) <= 0)
    ff->state = osip_empty;
  else
    ff->state = osip_ok;
  osip_mutex_unlock (ff->qislocked);
  return el;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 5
9 5
10 7
11 7
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 17
23 17
24 20
25 20
26 20
27 20
28 21
29 21
30 22
31 22
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 14
40 14
41 15
42 23
43 23
44 23
45 23
46 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  12 <rk2simp_free+0xc>
mov    0x8(%rbx),%rdi
callq  1b <rk2simp_free+0x15>
mov    0x10(%rbx),%rdi
callq  24 <rk2simp_free+0x1e>
mov    0x18(%rbx),%rdi
callq  2d <rk2simp_free+0x27>
mov    0x20(%rbx),%rdi
callq  36 <rk2simp_free+0x30>
mov    0x28(%rbx),%rdi
callq  3f <rk2simp_free+0x39>
mov    0x30(%rbx),%rdi
callq  48 <rk2simp_free+0x42>
mov    0x38(%rbx),%rdi
callq  51 <rk2simp_free+0x4b>
mov    %rbx,%rdi
callq  59 <rk2simp_free+0x53>
pop    %rbx
retq   
<<<sep_in_sample>>>
rk2simp_free (void *vstate)
{
  rk2simp_state_t *state = (rk2simp_state_t *) vstate;
  free (state->Y1);
  free (state->y0);
  free (state->y0_orig);
  free (state->ytmp);
  free (state->dfdy);
  free (state->dfdt);
  free (state->y_onestep);
  gsl_permutation_free (state->p);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
jne    1e <io_error_string+0x1e>
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c <io_error_string+0x1c>
jmp    23 <io_error_string+0x23>
callq  23 <io_error_string+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
io_error_string(void *data, int code)
{
    struct _iostr *p = data;
    if (!p->last_err)
 return dgettext ("dico", "No error");
    return dico_stream_strerror(p->last_err, code);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rdi
callq  3c5d <swc_get_target_script_pid+0x9>
mov    %rax,%rbx
mov    $0x0,%esi
mov    %rax,%rdi
callq  3c6d <swc_get_target_script_pid+0x19>
mov    %rax,%rdx
test   %rax,%rax
je     3cb1 <swc_get_target_script_pid+0x5d>
mov    $0x0,%eax
cmp    %rbx,%rdx
jne    3cbb <swc_get_target_script_pid+0x67>
cmpb   $0x3a,0x19(%rdx)
jne    3cbb <swc_get_target_script_pid+0x67>
cmpb   $0x20,0x1a(%rdx)
jne    3cbb <swc_get_target_script_pid+0x67>
lea    0x1b(%rdx),%rdi
callq  3c94 <swc_get_target_script_pid+0x40>
mov    %rax,%rbx
mov    $0x0,%esi
mov    %rax,%rdi
callq  3ca4 <swc_get_target_script_pid+0x50>
test   %rax,%rax
je     3cb8 <swc_get_target_script_pid+0x64>
movb   $0x0,(%rax)
mov    %rbx,%rax
jmp    3cbb <swc_get_target_script_pid+0x67>
mov    $0x0,%eax
jmp    3cbb <swc_get_target_script_pid+0x67>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
swc_get_target_script_pid(GB * G, STROB * control_message)
{
 char *s;
 char *p;
 char *ed;
 char *ret;
 s = strob_str(control_message);
 p = strstr(s, "125 target script started");
 if (!p)
  return (char*)((void *)0);
 if (p != s)
  return (char*)((void *)0);
 p+=strlen("125 target script started");
 if (*p != ':')
  return (char*)((void *)0);
 p++;
 if (*p != ' ')
  return (char*)((void *)0);
 p++;
 ret = strdup(p);
 if ((ed=strpbrk(ret, "\n\r"))) *ed = '\0';
 return ret;
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 7
5 8
6 8
7 8
8 8
9 9
10 9
11 12
12 11
13 11
14 14
15 14
16 17
17 17
18 20
19 20
20 20
21 21
22 21
23 21
24 21
25 21
26 21
27 22
28 22
29 10
30 10
31 22
32 23
33 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  dd7 <ds_show_strat+0x9>
test   %eax,%eax
jne    dee <ds_show_strat+0x20>
mov    0x0(%rip),%rax        # de2 <ds_show_strat+0x14>
mov    0xb0(%rax),%rdi
callq  dee <ds_show_strat+0x20>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ds_show_strat(int argc, char **argv)
{
    if (ensure_connection())
 return;
    print_result(conn->strat_result);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  1c <switch_eids+0x1c>
mov    %eax,%r15d
callq  24 <switch_eids+0x24>
mov    %eax,%r14d
mov    (%r12),%edi
callq  30 <switch_eids+0x30>
mov    %eax,%r13d
mov    0x0(%rbp),%edi
callq  3b <switch_eids+0x3b>
test   %eax,%eax
je     7c <switch_eids+0x7c>
callq  44 <switch_eids+0x44>
mov    (%rax),%edi
callq  4b <switch_eids+0x4b>
mov    %rax,(%rsp)
mov    0x0(%rbp),%esi
mov    %rsi,0x8(%rsp)
mov    $0x0,%edi
callq  61 <switch_eids+0x61>
mov    (%rsp),%rcx
mov    0x8(%rsp),%rdx
mov    %rax,%rsi
mov    $0x3,%edi
mov    $0x0,%eax
callq  7c <switch_eids+0x7c>
mov    (%rbx),%edi
callq  83 <switch_eids+0x83>
test   %eax,%eax
je     c3 <switch_eids+0xc3>
callq  8c <switch_eids+0x8c>
mov    (%rax),%edi
callq  93 <switch_eids+0x93>
mov    %rax,(%rsp)
mov    (%rbx),%edx
mov    %rdx,0x8(%rsp)
mov    $0x0,%edi
callq  a8 <switch_eids+0xa8>
mov    (%rsp),%rcx
mov    0x8(%rsp),%rdx
mov    %rax,%rsi
mov    $0x3,%edi
mov    $0x0,%eax
callq  c3 <switch_eids+0xc3>
mov    %r15d,(%rbx)
mov    %r14d,0x0(%rbp)
mov    %r13d,(%r12)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
switch_eids (uid_t *puid, gid_t *pgid, mode_t *pumask)
{
  uid_t ouid = geteuid ();
  gid_t ogid = getegid ();
  mode_t omask = umask (*pumask);
  if (setegid (*pgid))
    logmsg (3, gettext("cannot switch to EGID %lu: %s"),
       (unsigned long) *pgid, strerror ((*__errno_location ())));
  if (seteuid (*puid))
    logmsg (3, gettext("cannot switch to EUID %lu: %s"),
       (unsigned long) *puid, strerror ((*__errno_location ())));
  *puid = ouid;
  *pgid = ogid;
  *pumask = omask;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 4
14 4
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 8
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 9
37 9
38 9
39 9
40 11
41 10
42 10
43 10
44 10
45 10
46 10
47 10
48 10
49 10
50 10
51 10
52 10
53 10
54 12
55 13
56 14
57 15
58 15
59 15
60 15
61 15
62 15
63 15
64 15
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    0x8(%rdi),%rax
mov    0x34(%rdi),%ecx
lea    -0x1(%rcx),%edx
sub    0x48(%rsi),%edx
mov    0x40(%rsi),%rsi
mov    $0x0,%r8d
mov    $0x1,%ecx
callq  *0x38(%rax)
mov    %rax,0x20(%rbx)
addl   $0x1,0x48(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
get_memory_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  tga_source_ptr source = (tga_source_ptr) sinfo;
  JDIMENSION source_row;
  source_row = cinfo->image_height - source->current_row - 1;
  source->pub.buffer = (*cinfo->mem->access_virt_sarray)
    ((j_common_ptr) cinfo, source->whole_image,
     source_row, (JDIMENSION) 1, 0);
  source->current_row++;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 6
12 9
13 11
14 11
15 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     bcb <swlib_check_clean_absolute_path+0x23>
movzbl (%rdi),%edx
mov    $0x2,%eax
test   %dl,%dl
je     bd5 <swlib_check_clean_absolute_path+0x2d>
mov    $0x3,%al
cmp    $0x2f,%dl
jne    bd5 <swlib_check_clean_absolute_path+0x2d>
sub    $0x8,%rsp
callq  bc9 <swlib_check_clean_absolute_path+0x21>
jmp    bd1 <swlib_check_clean_absolute_path+0x29>
mov    $0x1,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
swlib_check_clean_absolute_path(char * s)
{
 if (!s) return 1;
 if (!strlen(s)) return 2;
 if (*s != '/') return 3;
 return swlib_check_clean_path(s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 2
11 6
12 6
13 3
14 3
15 7
16 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
mov    $0xf8,%edi
callq  1029 <register_prog0+0x14>
mov    %rax,%rbx
movl   $0x0,0x10(%rax)
mov    0x8(%rbp),%rax
mov    %rax,0x18(%rbx)
movl   $0x0,0x14(%rbx)
mov    0xd0(%rbp),%eax
mov    %eax,0x28(%rbx)
mov    %rbp,0x30(%rbx)
mov    %r12d,%eax
mov    %rax,0x38(%rbx)
movl   $0xffffffff,0x40(%rbx)
testb  $0x1,0x48(%rbp)
je     106c <register_prog0+0x57>
movl   $0x1,0x68(%rbx)
jmp    1079 <register_prog0+0x64>
cmpl   $0x2,0x0(%rbp)
jne    1079 <register_prog0+0x64>
movl   $0x2,0x68(%rbx)
cmpl   $0x0,0x0(%rbp)
je     1089 <register_prog0+0x74>
movl   $0x0,0xd8(%rbp)
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1096 <register_prog0+0x81>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
register_prog0 (struct component *comp, unsigned index)
{
  struct prog *newp;
  newp = xzalloc (sizeof (*newp));
  newp->type = TYPE_COMPONENT;
  newp->tag = comp->tag;
  newp->pid = 0;
  newp->facility = comp->facility;
  newp->v.p.comp = comp;
  newp->v.p.idx = index;
  newp->v.p.socket = -1;
  if (comp->flags & 0x01)
    newp->v.p.status = status_disabled;
  else if (comp->mode == pies_comp_inetd)
    newp->v.p.status = status_listener;
  if (comp->mode != pies_comp_exec)
    comp->redir[0].type = redir_null;
  link_prog (newp, 0);
  return newp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 7
13 8
14 8
15 9
16 10
17 10
18 11
19 12
20 12
21 13
22 13
23 14
24 14
25 15
26 16
27 16
28 17
29 18
30 18
31 18
32 20
33 20
34 20
35 20
36 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <__rargv+0x7>
retq   
<<<sep_in_sample>>>
__rargv (void)
{
  return (__argv);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdi
callq  a97 <system_fh_tx_dropped+0x15>
test   %rax,%rax
jne    aab <system_fh_tx_dropped+0x29>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  aa9 <system_fh_tx_dropped+0x27>
jmp    abc <system_fh_tx_dropped+0x3a>
mov    0x48(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  abc <system_fh_tx_dropped+0x3a>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_tx_dropped (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "tx_dropped" " unknown)"); else put_ulong (form, argc, argv, stats->tx_dropped); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  c6 <fatal+0x9>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x2,%edi
mov    $0x0,%eax
callq  e2 <fatal+0x25>
callq  e7 <perror_with_exit>
<<<sep_in_sample>>>
fatal (char const *msgid)
{
  error (2, 0, "%s", gettext (msgid));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  15ae <swverid_replace_verid+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swverid_replace_verid(SWVERID * swverid, struct VER_ID * verid) {
 i_replace_verid(swverid, verid, 1 );
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 3
5 3
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
retq   
<<<sep_in_sample>>>
strob_length(STROB * strb)
{
 return strob_get_length(strb);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
callq  0 <rec_match_int>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_match_insensitive (const char *str,
                       const char *reg)
{
  return rec_match_int (str, reg, 1 | (1 << 1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # e17 <gsl_vector_short_const_ptr+0x7>
je     e42 <gsl_vector_short_const_ptr+0x32>
cmp    %rsi,(%rdi)
ja     e42 <gsl_vector_short_const_ptr+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e3b <gsl_vector_short_const_ptr+0x2b>
mov    $0x0,%eax
jmp    e55 <gsl_vector_short_const_ptr+0x45>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rax,%rsi
mov    %rsi,%rax
add    0x10(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_short_const_ptr (const gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1071 <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jae    1077 <_argp_input+0x3e>
cmp    %rdi,0x8(%rax)
jne    1062 <_argp_input+0x29>
jmp    105d <_argp_input+0x24>
cmp    %rdi,0x8(%rax)
jne    1062 <_argp_input+0x29>
mov    0x30(%rax),%rax
retq   
add    $0x48,%rax
cmp    %rdx,%rax
jb     1057 <_argp_input+0x1e>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
        if (group->argp == argp)
          return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 7
16 7
17 7
18 11
19 11
20 11
21 11
22 11
23 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  96 <l_tar_sysdata_getuser+0xf>
mov    %rax,%rbx
test   %rax,%rax
jne    e1 <l_tar_sysdata_getuser+0x5a>
test   %rbp,%rbp
je     c3 <l_tar_sysdata_getuser+0x3c>
movq   $0x0,0x0(%rbp)
movq   $0x0,0x8(%rbp)
movq   $0x0,0x10(%rbp)
movq   $0x0,0x18(%rbp)
mov    $0x0,%eax
test   %r12,%r12
je     109 <l_tar_sysdata_getuser+0x82>
mov    $0x0,%esi
mov    %r12,%rdi
callq  da <l_tar_sysdata_getuser+0x53>
mov    $0x0,%eax
jmp    109 <l_tar_sysdata_getuser+0x82>
test   %rbp,%rbp
je     f6 <l_tar_sysdata_getuser+0x6f>
mov    $0x20,%edx
mov    (%rax),%rsi
mov    %rbp,%rdi
callq  f6 <l_tar_sysdata_getuser+0x6f>
test   %r12,%r12
je     106 <l_tar_sysdata_getuser+0x7f>
mov    (%rbx),%rsi
mov    %r12,%rdi
callq  106 <l_tar_sysdata_getuser+0x7f>
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
l_tar_sysdata_getuser(long uid, char *tarbuf, STROB * paxbuf)
{
 struct passwd *pwent;
 pwent = getpwuid(uid);
 if (!pwent) {
  if (tarbuf) memset(tarbuf, '\0', 32);
  if (paxbuf) strob_strcpy(paxbuf, "");
  return (char *) ((void *)0);
 }
 if (tarbuf) swlib_strncpy(tarbuf, pwent->pw_name, 32);
 if (paxbuf) strob_strcpy(paxbuf, pwent->pw_name);
 return pwent->pw_name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 7
18 7
19 7
20 7
21 7
22 8
23 8
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 12
36 13
37 13
38 13
39 13
<<<sep_out_sample>>>
cmp    $0x9,%edi
ja     783 <subcommand_string+0x3e>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
sub    $0x8,%rsp
callq  78c <subcommand_string+0x47>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
subcommand_string (enum subcommand c)
{
  switch (c)
    {
    case UNKNOWN_SUBCOMMAND:
      return "unknown?";
    case APPEND_SUBCOMMAND:
      return "-r";
    case CAT_SUBCOMMAND:
      return "-A";
    case CREATE_SUBCOMMAND:
      return "-c";
    case DELETE_SUBCOMMAND:
      return "-D";
    case DIFF_SUBCOMMAND:
      return "-d";
    case EXTRACT_SUBCOMMAND:
      return "-x";
    case LIST_SUBCOMMAND:
      return "-t";
    case UPDATE_SUBCOMMAND:
      return "-u";
    case TEST_LABEL_SUBCOMMAND:
      return "--test-label";
    }
  abort ();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 10
6 10
7 12
8 12
9 14
10 14
11 16
12 16
13 18
14 18
15 20
16 20
17 22
18 22
19 24
20 24
21 2
22 26
23 6
24 6
25 8
26 27
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  3a <grecs_install_text+0xb>
mov    %rax,%rbp
cmpq   $0x0,0x0(%rip)        # 45 <grecs_install_text+0x16>
jne    72 <grecs_install_text+0x43>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  66 <grecs_install_text+0x37>
mov    %rax,0x0(%rip)        # 6d <grecs_install_text+0x3e>
test   %rax,%rax
je     89 <grecs_install_text+0x5a>
mov    %rbp,%rsi
mov    0x0(%rip),%rdi        # 7c <grecs_install_text+0x4d>
callq  81 <grecs_install_text+0x52>
mov    %rax,%rbx
test   %rax,%rax
jne    8e <grecs_install_text+0x5f>
callq  8e <grecs_install_text+0x5f>
cmp    %rax,%rbp
je     9b <grecs_install_text+0x6c>
mov    %rbp,%rdi
callq  9b <grecs_install_text+0x6c>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_install_text (const char *str)
{
  char *text, *s;
  s = xstrdup (str);
  if (!((text_table
  || (text_table = hash_initialize (0, 0,
        text_hasher,
        text_compare,
        text_free)))
 && (text = hash_insert (text_table, s))))
    xalloc_die ();
  if (s != text)
    free (s);
  return text;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 5
18 5
19 5
20 5
21 5
22 5
23 11
24 12
25 12
26 13
27 13
28 15
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rdi
mov    (%rsi),%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  52 <_expand_aclno+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_expand_aclno (const char *name, void *data, char **p)
{
  struct run_closure *rp = data;
  return mu_asprintf (p, "%u", rp->idx);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
cmp    $0x2,%rax
ja     1b1 <rec_sex_ast_node_link+0x17>
lea    0x1(%rax),%rdx
mov    %rdx,0x40(%rdi)
mov    %rsi,0x28(%rdi,%rax,8)
repz retq 
<<<sep_in_sample>>>
rec_sex_ast_node_link (rec_sex_ast_node_t parent,
                       rec_sex_ast_node_t child)
{
  if (parent->num_children < 3)
    {
      parent->children[parent->num_children++] = child;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
cmpl   $0x0,0x534(%rsi)
jne    2e <abort_script+0x2e>
callq  12 <abort_script+0x12>
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  24 <abort_script+0x24>
movl   $0x1,0x534(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
abort_script(SWICOL * swicol, GB * G, int fd)
{
 if (G->g_target_did_abortM)
  return;
        swicol_set_master_alarm(swicol);
 if (G->in_shls_looperM) {
  ;
 }
 sw_e_msg(G, "Executing abort_script() ... \n");
 G->g_target_did_abortM = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 9
7 9
8 9
9 9
10 10
11 11
12 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%edi        # a <it_init_builtins+0xa>
callq  f <it_init_builtins+0xf>
cmpl   $0x0,0x0(%rip)        # 16 <it_init_builtins+0x16>
jle    58 <it_init_builtins+0x58>
mov    $0x0,%esi
mov    $0x0,%edx
movslq %edx,%rcx
lea    (%rcx,%rcx,2),%rcx
shl    $0x4,%rcx
add    0x0(%rip),%rcx        # 34 <it_init_builtins+0x34>
cmpq   $0x0,0x8(%rcx)
je     4b <it_init_builtins+0x4b>
mov    (%rcx),%r8
movslq %esi,%rdi
mov    (%rax),%rcx
mov    %r8,(%rcx,%rdi,8)
lea    0x1(%rsi),%esi
add    $0x1,%edx
cmp    %edx,0x0(%rip)        # 54 <it_init_builtins+0x54>
jg     22 <it_init_builtins+0x22>
jmp    5d <it_init_builtins+0x5d>
mov    $0x0,%esi
mov    (%rax),%rdx
mov    %esi,0xc(%rax)
movslq %esi,%rsi
movq   $0x0,(%rdx,%rsi,8)
orl    $0x20,(%rbx)
mov    %rax,0x10(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
it_init_builtins (itp)
     ITEMLIST *itp;
{
  STRINGLIST *sl;
  register int i, n;
  sl = strlist_create (num_shell_builtins);
  for (i = n = 0; i < num_shell_builtins; i++)
    if (shell_builtins[i].function)
      sl->list[n++] = shell_builtins[i].name;
  sl->list[sl->list_len = n] = (char *)((void *)0);
  itp->flags |= 0x020;
  itp->slist = sl;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 7
6 7
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 7
21 7
22 7
23 7
24 7
25 10
26 10
27 10
28 10
29 11
30 12
31 14
32 14
33 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,(%rsp)
mov    $0x1,%r9d
callq  722 <gsl_wavelet2d_transform_forward+0x13>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_wavelet2d_transform_forward (const gsl_wavelet * w,
                                 double *data, size_t tda, size_t size1,
                                 size_t size2, gsl_wavelet_workspace * work)
{
  return gsl_wavelet2d_transform (w, data, tda, size1, size2, gsl_wavelet_forward, work);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdx,%rdx
jne    16d6 <gsl_vector_long_const_view_array+0x47>
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  16ae <gsl_vector_long_const_view_array+0x1f>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    16f4 <gsl_vector_long_const_view_array+0x65>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_long_const_view_array (const long * base, size_t n)
{
  _gsl_vector_long_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = (long *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 10
11 10
12 10
13 10
14 10
15 10
16 21
17 21
18 21
19 21
20 21
21 23
22 23
23 23
<<<sep_out_sample>>>
mov    %sil,0x34(%rdi)
retq   
<<<sep_in_sample>>>
buffer_set_lower_case (buffer_t * buffer, _Bool sensitive)
{
  buffer->lower_case = sensitive;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
pred_closeparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) &pathname;
  (void) &stat_buf;
  (void) &pred_ptr;
  return 1;
}
<<<sep_in_sample>>>
1 7
2 7
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     1a4c <gsl_vector_uint_add+0x29>
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a45 <gsl_vector_uint_add+0x22>
mov    $0x13,%eax
jmp    1a9f <gsl_vector_uint_add+0x7c>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     1a93 <gsl_vector_uint_add+0x70>
shl    $0x2,%rbx
shl    $0x2,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
mov    (%r9,%rcx,1),%r9d
add    %r9d,(%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    1a70 <gsl_vector_uint_add+0x4d>
jmp    1a9a <gsl_vector_uint_add+0x77>
mov    $0x0,%eax
jmp    1a9f <gsl_vector_uint_add+0x7c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_uint_add (gsl_vector_uint * a, const gsl_vector_uint * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 13
27 13
28 13
29 13
30 13
31 13
32 17
33 17
34 17
35 19
36 19
<<<sep_out_sample>>>
mov    %rdi,%rax
movzbl (%rdi),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
je     50d <next_token+0x21>
add    $0x1,%rax
movzbl (%rax),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
jne    4fc <next_token+0x10>
repz retq 
<<<sep_in_sample>>>
next_token (const char *s)
{
  while ((((stopchar_map[(unsigned char)((*(s)))])&(((0x0002|0x0004)))) != 0)) ++(s);
  return (char *)s;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edi
callq  373b <info_tile_windows+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_tile_windows (WINDOW *window, int count)
{
  window_tile_windows (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x68(%rdi),%rax
retq   
<<<sep_in_sample>>>
shcmd_get_envp(SHCMD * cmd)
{
 return cmd->envp_;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xffffffff,%edi
callq  584 <utimens+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
utimens (char const *file, struct timespec const timespec[2])
{
  return fdutimens (-1, file, timespec);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1f59 <gsl_matrix_short_isnull+0x5f>
lea    (%rax,%rax,1),%r11
mov    $0x0,%r8d
mov    $0x0,%r10d
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
jmp    1f52 <gsl_matrix_short_isnull+0x58>
mov    $0x0,%eax
mov    %r8,%rsi
add    0x18(%rdi),%rsi
movswl (%rsi,%rax,2),%edx
cvtsi2sd %edx,%xmm0
ucomisd %xmm1,%xmm0
jp     1f61 <gsl_matrix_short_isnull+0x67>
ucomisd %xmm2,%xmm0
je     1f6d <gsl_matrix_short_isnull+0x73>
jmp    1f61 <gsl_matrix_short_isnull+0x67>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
je     1f67 <gsl_matrix_short_isnull+0x6d>
test   %rcx,%rcx
jne    1f24 <gsl_matrix_short_isnull+0x2a>
jmp    1f46 <gsl_matrix_short_isnull+0x4c>
mov    $0x1,%eax
xchg   %ax,%ax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rcx,%rax
jne    1f30 <gsl_matrix_short_isnull+0x36>
jmp    1f46 <gsl_matrix_short_isnull+0x4c>
<<<sep_in_sample>>>
gsl_matrix_short_isnull (const gsl_matrix_short * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 20
30 20
31 20
32 15
33 15
34 20
35 20
36 9
37 9
38 9
39 9
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 7 <token_hash_1+0x7>
lea    -0x1(%rdi,%rax,1),%rax
lea    0x4(%rax),%rdx
movzbl 0x4(%rax),%ecx
test   %cl,%cl
je     3c <token_hash_1+0x3c>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    1d <token_hash_1+0x1d>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
token_hash_1 (void const *key)
{
  do { unsigned long result = 0; { unsigned char const *kk = (unsigned char const *) (((((struct token const *) key)->tok_hits_name + log_8_member_files))) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 4
<<<sep_out_sample>>>
mov    0x4f8(%rdi),%eax
test   %eax,%eax
jne    415d <sw_exitval+0x12>
test   %edx,%edx
je     415d <sw_exitval+0x12>
cmp    %edx,%esi
je     41a4 <sw_exitval+0x59>
test   %edx,%edx
nop
je     416b <sw_exitval+0x20>
mov    $0x2,%eax
test   %esi,%esi
jne    41a4 <sw_exitval+0x59>
mov    $0x1,%eax
test   %edx,%edx
je     41a4 <sw_exitval+0x59>
sub    $0x8,%rsp
mov    0x220(%rdi),%ecx
lea    0x45c(%rdi),%rdx
mov    0xc(%rdi),%esi
mov    0x14(%rdi),%edi
mov    $0x0,%r8d
mov    $0x0,%eax
callq  419b <sw_exitval+0x50>
mov    $0xff,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
sw_exitval(GB * G, int count, int suc)
{
 if (G->g_master_alarm == 0 && suc && count == suc) return 0;
 if (suc && count) return 2;
 if (suc == 0) return 1;
 swutil_doif_writef(G->g_verboseG, G->g_fail_loudly,
   &G->g_logspec, swc_get_stderr_fd(G),
   "abnormal exit\n");
 return 255;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 9
26 10
27 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  23a1 <display_cursor_at_point+0xe>
sub    0x38(%rbx),%eax
add    0x20(%rbx),%eax
mov    %eax,%ebp
mov    %rbx,%rdi
callq  23b1 <display_cursor_at_point+0x1e>
mov    %ebp,%esi
mov    %eax,%edi
callq  23ba <display_cursor_at_point+0x27>
mov    0x0(%rip),%rdi        # 23c1 <display_cursor_at_point+0x2e>
callq  23c6 <display_cursor_at_point+0x33>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
display_cursor_at_point (WINDOW *window)
{
  int vpos, hpos;
  vpos = window_line_of_point (window) - window->pagetop + window->first_row;
  hpos = window_get_cursor_column (window);
  terminal_goto_xy (hpos, vpos);
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    $0x20,%esi
callq  258 <inl_get_name+0x14>
mov    %rax,%rbx
test   %rax,%rax
jne    279 <inl_get_name+0x35>
mov    $0x0,%ecx
mov    $0x18b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  279 <inl_get_name+0x35>
test   %rbp,%rbp
je     289 <inl_get_name+0x45>
mov    %r12,%rdi
callq  1bd <inl_get_name_len>
mov    %eax,0x0(%rbp)
lea    0x1(%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
inl_get_name(char * line, int * plen)
{
 char * s;
 s = strchr(line, ' ');
 if (!s) swlib_fatal("", (char*)"swverify_lib.c", 395, (char*)__FUNCTION__);;
 s++;
 if (plen) *plen = inl_get_name_len(line);
 return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rsi,%r15
mov    %rdx,%rbp
movq   $0x0,(%rdx)
movl   $0x0,(%rsi)
callq  d29 <compileEntityMap+0x26>
mov    %rax,%r14
test   %rax,%rax
je     d3f <compileEntityMap+0x3c>
mov    $0x0,%r12d
mov    $0x0,%r13d
jmp    db4 <compileEntityMap+0xb1>
mov    0x0(%rip),%rcx        # d46 <compileEntityMap+0x43>
mov    $0x1f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  d5a <compileEntityMap+0x57>
mov    $0xffffffff,%eax
jmpq   de7 <compileEntityMap+0xe4>
add    $0x1,%r12d
movslq %r12d,%rbx
shl    $0x5,%rbx
mov    %rbx,%rsi
mov    0x0(%rbp),%rdi
callq  d7b <compileEntityMap+0x78>
mov    %rax,0x0(%rbp)
test   %rbp,%rbp
sete   %r13b
movzbl %r13b,%r13d
neg    %r13d
mov    (%rsp),%rdx
mov    %rdx,-0x20(%rax,%rbx,1)
mov    0x8(%rsp),%rdx
mov    %rdx,-0x18(%rax,%rbx,1)
mov    0x10(%rsp),%rdx
mov    %rdx,-0x10(%rax,%rbx,1)
mov    0x18(%rsp),%rdx
mov    %rdx,-0x8(%rax,%rbx,1)
mov    %rsp,%rsi
mov    %r14,%rdi
callq  dbf <compileEntityMap+0xbc>
test   %eax,%eax
jne    dc8 <compileEntityMap+0xc5>
test   %r13d,%r13d
je     d64 <compileEntityMap+0x61>
mov    %r12d,(%r15)
mov    0x8(%r14),%rdi
callq  dd4 <compileEntityMap+0xd1>
mov    (%r14),%rdi
callq  ddc <compileEntityMap+0xd9>
mov    %r14,%rdi
callq  de4 <compileEntityMap+0xe1>
mov    %r13d,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
compileEntityMap(char *name, int *count, entity_object_map **pmap)
{
 struct lex_record *p;
 int code = 0;
 entity_object_map po;
 int n = 0;
 *pmap = ((void *)0);
 *count = 0;
 if ((p = OpenSourceFile(name)) == ((void *)0)) {
  fprintf(stderr, "unable to open entity map file\n");
  return -1;
 }
 while (ParseEntityMapEntry(p, &po) == 0 && code == 0) {
  *pmap = realloc (*pmap, sizeof(entity_object_map) * (n+1) );
  if (!pmap) {
   code = -1;
  }
  (*pmap)[n] = po;
  n++;
 }
 *count = n;
 fclose(p->f);
 free(p->filename);
 free((char *) p);
 return code;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 7
11 8
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 11
25 11
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 15
34 15
35 15
36 15
37 18
38 18
39 18
40 18
41 18
42 18
43 18
44 18
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 21
53 22
54 22
55 23
56 23
57 24
58 24
59 25
60 26
61 26
62 26
63 26
64 26
65 26
66 26
67 26
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
je     c6 <udf_get_file_entry+0xab>
lea    0x40(%rdi),%rcx
mov    %rsi,%rax
mov    %rcx,%rdx
mov    $0x800,%r8d
test   $0x1,%sil
je     52 <udf_get_file_entry+0x37>
movzbl 0x40(%rdi),%eax
mov    %al,(%rsi)
lea    0x1(%rsi),%rax
lea    0x41(%rdi),%rdx
mov    $0x7ff,%r8w
test   $0x2,%al
je     68 <udf_get_file_entry+0x4d>
movzwl (%rdx),%ecx
mov    %cx,(%rax)
add    $0x2,%rax
add    $0x2,%rdx
sub    $0x2,%r8d
test   $0x4,%al
je     7c <udf_get_file_entry+0x61>
mov    (%rdx),%ecx
mov    %ecx,(%rax)
add    $0x4,%rax
add    $0x4,%rdx
sub    $0x4,%r8d
mov    %r8d,%ecx
shr    $0x3,%ecx
mov    %ecx,%ecx
mov    %rax,%rdi
mov    %rdx,%rsi
rep movsq %ds:(%rsi),%es:(%rdi)
mov    %rsi,%rdx
mov    %rdi,%rax
test   $0x4,%r8b
je     a2 <udf_get_file_entry+0x87>
mov    (%rsi),%ecx
mov    %ecx,(%rdi)
mov    $0x4,%ecx
test   $0x2,%r8b
je     b4 <udf_get_file_entry+0x99>
movzwl (%rdx,%rcx,1),%esi
mov    %si,(%rax,%rcx,1)
add    $0x2,%rcx
test   $0x1,%r8b
je     c1 <udf_get_file_entry+0xa6>
movzbl (%rdx,%rcx,1),%edx
mov    %dl,(%rax,%rcx,1)
mov    $0x1,%eax
repz retq 
<<<sep_in_sample>>>
udf_get_file_entry(const udf_dirent_t *p_udf_dirent,
             udf_file_entry_t *p_udf_fe)
{
  if (!p_udf_dirent) return 0;
  memcpy(p_udf_fe, &p_udf_dirent->fe, sizeof(udf_file_entry_t));
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 5
45 5
46 5
47 5
48 5
49 5
50 5
51 6
52 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rax        # 150 <diffLineNumberTooLarge+0xe>
mov    0xd0(%rax),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  166 <badDiffOutput>
<<<sep_in_sample>>>
diffLineNumberTooLarge (char const *buf)
{
  generic_fatal ((top->repository. filename), "diff line number too large: %s", buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
sub    $0x38,%rsp
movq   %xmm0,0x20(%rsp)
mov    0x8(%rdx),%rcx
mov    (%rdi),%rax
cmp    (%rdx),%rax
jne    1515 <gsl_blas_cgeru+0x62>
mov    (%rsi),%r10
cmp    %rcx,%r10
jne    1515 <gsl_blas_cgeru+0x62>
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r8
mov    0x10(%rdx),%rcx
mov    %ecx,0x18(%rsp)
mov    0x18(%rdx),%rdx
mov    %rdx,0x10(%rsp)
mov    0x8(%rsi),%rdx
mov    %edx,0x8(%rsp)
mov    0x10(%rsi),%rdx
mov    %rdx,(%rsp)
lea    0x20(%rsp),%rcx
mov    %r10d,%edx
mov    %eax,%esi
mov    $0x65,%edi
callq  150e <gsl_blas_cgeru+0x5b>
mov    $0x0,%eax
jmp    1533 <gsl_blas_cgeru+0x80>
mov    $0x13,%ecx
mov    $0x40e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  152e <gsl_blas_cgeru+0x7b>
mov    $0x13,%eax
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_cgeru (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (X->size == M && Y->size == N)
    {
      cblas_cgeru (CblasRowMajor, ((int)(M)), ((int)(N)), ((&alpha)->dat),
                   X->data, ((int)(X->stride)), Y->data, ((int)(Y->stride)),
                   A->data, ((int)(A->tda)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 1038, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 8
5 8
6 8
7 8
8 8
9 8
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 13
26 13
27 17
28 17
29 17
30 17
31 17
32 17
33 19
34 19
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%r8
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
cmp    %al,%cl
jne    1009 <swlib_toggle_trailing_slashdot+0x6e>
mov    %r8,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x1,%rcx
ja     fdf <swlib_toggle_trailing_slashdot+0x44>
movl   $0x0,(%rdx)
retq   
lea    -0x2(%r8,%rcx,1),%rax
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    1036 <swlib_toggle_trailing_slashdot+0x9b>
movb   $0x0,(%rax)
movl   $0x1,(%rdx)
retq   
cmpl   $0x0,(%rdx)
je     1036 <swlib_toggle_trailing_slashdot+0x9b>
mov    %r8,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r8,%rcx,1),%rax
movw   $0x2e2f,(%rax)
movb   $0x0,0x2(%rax)
movl   $0x0,(%rdx)
repz retq 
<<<sep_in_sample>>>
swlib_toggle_trailing_slashdot(char * mode, char * name, int *pflag)
{
 if (strcmp(mode, "drop") == 0) {
  if (strlen(name) < 2) {
   *pflag = 0;
   return;
  }
  if (strcmp(name + strlen(name) - 2, "/.") == 0) {
   *(name + strlen(name) - 2) = '\0';
   *pflag = 1;
  }
 } else {
  if (*pflag) {
   strcat(name, "/.");
   *pflag = 0;
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 6
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 9
31 10
32 10
33 13
34 13
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 15
44 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10010,%rsp
mov    %edi,%r12d
mov    %fs:0x28,%rax
mov    %rax,0x10008(%rsp)
xor    %eax,%eax
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    9a <swlib_cksum+0x5b>
add    %rax,%rbp
add    %rsp,%rax
mov    %rsp,%rdx
mov    %rbx,%rcx
shl    $0x8,%rcx
add    $0x1,%rdx
shr    $0x18,%rbx
xor    -0x1(%rdx),%bl
movzbl %bl,%ebx
xor    0x0(,%rbx,8),%rcx
mov    %rcx,%rbx
cmp    %rax,%rdx
jne    75 <swlib_cksum+0x36>
mov    $0x10000,%edx
mov    %rsp,%rsi
mov    %r12d,%edi
callq  aa <swlib_cksum+0x6b>
test   %rax,%rax
jg     6c <swlib_cksum+0x2d>
test   %rbp,%rbp
jle    d9 <swlib_cksum+0x9a>
mov    %rbx,%rax
shl    $0x8,%rax
shr    $0x18,%rbx
xor    %rbp,%rbx
movzbl %bl,%ebx
xor    0x0(,%rbx,8),%rax
mov    %rax,%rbx
sar    $0x8,%rbp
test   %rbp,%rbp
jg     b4 <swlib_cksum+0x75>
mov    %ebx,%eax
not    %eax
mov    0x10008(%rsp),%rsi
xor    %fs:0x28,%rsi
je     f5 <swlib_cksum+0xb6>
callq  f5 <swlib_cksum+0xb6>
add    $0x10010,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swlib_cksum (int uxfio_fd)
{
  unsigned char buf[(1 << 16)];
  unsigned long crc = 0;
  long file_length = 0;
  long bytes_read;
  while ((bytes_read = uxfio_read (uxfio_fd, buf, (1 << 16))) > 0)
    {
      unsigned char *cp = buf;
      file_length += bytes_read;
      while (bytes_read--)
 crc = (crc << 8) ^ crctab[((crc >> 24) ^ *(cp++)) & 0xFF];
    }
  bytes_read = file_length;
  while (bytes_read > 0)
    {
      crc = (crc << 8) ^ crctab[((crc >> 24) ^ bytes_read) & 0xFF];
      bytes_read >>= 8;
    }
  crc = ~crc & 0xFFFFFFFF;
  return crc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 4
11 7
12 10
13 10
14 9
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 11
24 11
25 7
26 7
27 7
28 7
29 7
30 7
31 15
32 15
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 18
41 15
42 15
43 20
44 20
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 22
53 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  3c63 <bool_term>
mov    %rax,%rbp
jmpq   3de7 <implication+0xb2>
cmpl   $0x0,0x0(%rip)        # 3d4f <implication+0x1a>
je     3d6d <implication+0x38>
cmpl   $0x4,0x4(%rbp)
je     3d6d <implication+0x38>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3fd <error>
movl   $0x4,0x4(%rbp)
callq  1e59 <get_token>
callq  3c63 <bool_term>
mov    %rax,%rbx
cmpl   $0x0,0x0(%rip)        # 3d81 <implication+0x4c>
je     3de7 <implication+0xb2>
cmpl   $0x4,0x4(%rax)
je     3d9f <implication+0x6a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3fd <error>
movl   $0x4,0x4(%rbx)
movl   $0x0,0x0(%rbp)
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2012 <prepend>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2142 <append>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  2a44 <catenate>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2142 <append>
cmpl   $0x7,0x0(%rip)        # 3dee <implication+0xb9>
jne    3dfd <implication+0xc8>
cmpl   $0x10,0x0(%rip)        # 3df7 <implication+0xc2>
je     3d48 <implication+0x13>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
implication(void)
{ CODE *x, *y;
      x = bool_term();
      while (((token[1].code) == 7 && token[1].delim == 16))
      { if (second_pass)
         { if (x->type != 0x0004)
            { error("operand preceding `->' is not of Boolean type");
               x->type = 0x0004;
            }
         }
         get_token( );
         y = bool_term();
         if (second_pass)
         { if (y->type != 0x0004)
            { error("operand following `->' is not of Boolean type");
               y->type = 0x0004;
            }
            x->lval = 0;
            prepend(x, "impl" "(");
            append(x, ", ");
            catenate(x, y);
            append(x, ")");
         }
      }
      return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 8
15 11
16 12
17 12
18 13
19 13
20 14
21 14
22 15
23 15
24 15
25 16
26 18
27 19
28 19
29 19
30 19
31 20
32 20
33 20
34 20
35 21
36 21
37 21
38 22
39 22
40 22
41 22
42 4
43 4
44 4
45 4
46 26
47 26
48 26
49 26
50 26
<<<sep_out_sample>>>
mov    $0x66,%eax
cmp    $0xc1,%esi
je     ab <Barcode_encode_as+0x62>
mov    $0x61,%al
cmp    $0xc2,%esi
je     ab <Barcode_encode_as+0x62>
mov    $0x60,%al
cmp    $0xc3,%esi
je     ab <Barcode_encode_as+0x62>
cmp    $0xc4,%esi
jne    7f <Barcode_encode_as+0x36>
cmp    $0x41,%edi
sete   %al
movzbl %al,%eax
add    $0x64,%eax
retq   
lea    -0x20(%rsi),%eax
cmp    $0x3f,%eax
jbe    ab <Barcode_encode_as+0x62>
mov    $0x40,%eax
cmp    $0x80,%esi
je     ab <Barcode_encode_as+0x62>
cmp    $0x1f,%esi
jg     9d <Barcode_encode_as+0x54>
lea    0x40(%rsi),%eax
retq   
lea    -0x20(%rsi),%edx
cmp    $0x60,%esi
mov    $0xffffffff,%eax
cmovge %edx,%eax
repz retq 
<<<sep_in_sample>>>
Barcode_encode_as(int code, int value)
{
    if (value == 0xC1) return 102;
    if (value == 0xC2) return 97;
    if (value == 0xC3) return 96;
    if (value == 0xC4) {
 if (code == 'A') return 101;
 return 100;
    }
    if (value >= 0x20 && value <= 0x5F)
 return value - 0x20;
    if (value == 0x80) return 64;
    if (value < 0x20) return value+64;
    if (value >= 0x60) return value - 0x20;
    return -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 10
18 10
19 10
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    10cb <swlib_toggle_leading_dotslash+0x93>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
cmp    $0x1,%rdx
ja     108a <swlib_toggle_leading_dotslash+0x52>
movl   $0x0,0x0(%rbp)
jmpq   1138 <swlib_toggle_leading_dotslash+0x100>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
cmp    %al,%cl
jne    10c2 <swlib_toggle_leading_dotslash+0x8a>
cmp    $0x2,%rdx
jbe    10c2 <swlib_toggle_leading_dotslash+0x8a>
sub    $0x1,%rdx
lea    0x2(%rbx),%rsi
mov    %rbx,%rdi
callq  10b9 <swlib_toggle_leading_dotslash+0x81>
movl   $0x1,0x0(%rbp)
jmp    1138 <swlib_toggle_leading_dotslash+0x100>
movl   $0x0,0x0(%rbp)
jmp    1138 <swlib_toggle_leading_dotslash+0x100>
cmpl   $0x0,0x0(%rbp)
je     1138 <swlib_toggle_leading_dotslash+0x100>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    1107 <swlib_toggle_leading_dotslash+0xcf>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbx,%rcx,1)
jmp    1138 <swlib_toggle_leading_dotslash+0x100>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    0x2(%rbx),%rdi
mov    %rbx,%rsi
callq  112a <swlib_toggle_leading_dotslash+0xf2>
movb   $0x2e,(%rbx)
movb   $0x2f,0x1(%rbx)
movl   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swlib_toggle_leading_dotslash(char * mode, char * name, int *pflag)
{
 if (strcmp(mode, "drop") == 0) {
  if (strlen(name) < 2) {
   *pflag = 0;
   return;
  } else if (strncmp(name, "./", 2) == 0 && strlen(name) > 2) {
   memmove(name, name+2, strlen(name)-1);
   *pflag = 1;
  } else {
   *pflag = 0;
   return;
  }
 } else {
  if (*pflag) {
   if (strcmp(name, ".") == 0) {
    strcat(name, "/");
   } else {
    memmove(name+2, name, strlen(name)+1);
    *name = '.';
    *(name +1) = '/';
    *pflag = 0;
   }
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 6
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 8
36 8
37 8
38 8
39 9
40 9
41 11
42 12
43 15
44 15
45 16
46 16
47 16
48 16
49 16
50 16
51 16
52 16
53 17
54 17
55 17
56 17
57 17
58 17
59 17
60 19
61 19
62 19
63 19
64 19
65 19
66 19
67 19
68 19
69 20
70 21
71 22
72 26
73 26
74 26
75 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  148 <external_locker>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unlock_external (mu_locker_t locker)
{
  return external_locker (locker, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    %esi,%ecx
shr    %cl,%rdx
mov    $0xffffffffffffffff,%rax
test   %rdx,%rdx
je     378e <jit_regset_scan1+0x2a>
test   $0x1,%dl
je     3781 <jit_regset_scan1+0x1d>
movslq %esi,%rax
retq   
shr    %rdx
add    $0x1,%esi
test   $0x1,%dl
je     3781 <jit_regset_scan1+0x1d>
jmp    377d <jit_regset_scan1+0x19>
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
jit_regset_scan1(jit_regset_t *set, jit_int32_t offset)
{
    jit_regset_t mask;
    ((void) (0));
    if ((mask = *set >> offset)) {
 for (;;) {
     if (mask & 1)
  return (offset);
     mask >>= 1;
     ++offset;
 }
    }
    return ((9223372036854775807L * 2UL + 1UL));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 13
5 5
6 5
7 7
8 7
9 8
10 8
11 9
12 10
13 7
14 7
15 7
16 7
17 14
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     15d6 <gsl_vector_uchar_isnull+0x36>
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
movzbl (%rax),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm1,%xmm0
jp     15d0 <gsl_vector_uchar_isnull+0x30>
ucomisd %xmm2,%xmm0
je     15e2 <gsl_vector_uchar_isnull+0x42>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    %r8,%rax
cmp    %rsi,%rdx
jne    15bd <gsl_vector_uchar_isnull+0x1d>
jmp    15dc <gsl_vector_uchar_isnull+0x3c>
<<<sep_in_sample>>>
gsl_vector_uchar_isnull (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 13
16 13
17 17
18 17
19 17
20 17
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
rec_record_location (rec_record_t record)
{
  return record->location;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
lea    0x1(%rdi),%rdx
test   %rdi,%rdi
mov    $0x0,%eax
cmovne %rdx,%rax
retq   
<<<sep_in_sample>>>
iso9660_get_pvd_id(const iso9660_pvd_t *pvd)
{
  if (((void *)0) == pvd) return "ERR";
  return(pvd->id);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  121 <recurse_1>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 45c1 <close_buffer+0x7>
cmp    0xa8(%rax),%rax
je     4642 <close_buffer+0x88>
sub    $0x8,%rsp
testb  $0x4,0x0(%rip)        # 45d5 <close_buffer+0x1b>
je     45f7 <close_buffer+0x3d>
callq  45dc <close_buffer+0x22>
mov    0x0(%rip),%rcx        # 45e3 <close_buffer+0x29>
lea    0x1(%rax),%rdx
mov    0x20(%rcx),%rax
mov    0x8(%rax),%rsi
mov    (%rcx),%rdi
callq  45f7 <close_buffer+0x3d>
mov    $0x1,%edi
callq  4601 <close_buffer+0x47>
mov    0x0(%rip),%rax        # 4608 <close_buffer+0x4e>
mov    0xb0(%rax),%rdi
callq  4614 <close_buffer+0x5a>
mov    0x0(%rip),%rdx        # 461b <close_buffer+0x61>
mov    $0x1,%eax
cmp    0xa8(%rdx),%rdx
jne    4648 <close_buffer+0x8e>
mov    0x0(%rip),%rdx        # 4630 <close_buffer+0x76>
mov    0x0(%rip),%rax        # 4637 <close_buffer+0x7d>
mov    %rdx,0x10(%rax)
mov    $0x1,%eax
jmp    4648 <close_buffer+0x8e>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
close_buffer(void)
{
    ((void) (0));
    if (openfile == openfile->next)
 return 0;
    if (((flags[((POS_HISTORY) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((POS_HISTORY) % (sizeof(unsigned) * 8)))) != 0))
 update_poshistory(openfile->filename,
   openfile->current->lineno, xplustabs() + 1);
    switch_to_prevnext_buffer(1);
    unlink_opennode(openfile->prev);
    if (openfile == openfile->next)
 exitfunc->desc = exit_tag;
    return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 8
8 8
9 8
10 7
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 10
19 11
20 13
21 11
22 11
23 12
24 12
25 12
26 13
27 13
28 5
29 5
30 14
31 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  32 <__lookup_file_id>
test   %rax,%rax
je     3db <lookup_file_id+0x13>
mov    0x10(%rax),%eax
jmp    3e0 <lookup_file_id+0x18>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lookup_file_id (struct stat const *st)
{
  file_id *p = __lookup_file_id (st);
  return p ? p->type : UNKNOWN;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
mov    %esi,(%rdi)
retq   
<<<sep_in_sample>>>
defer_set_format(DEFER * def, int format)
{
 def->formatM=format;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->iterator (list);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
sub    0x20(%rdi),%eax
retq   
<<<sep_in_sample>>>
xdrumem_getpos(register XDR * xdrs)
{
 return ((u_int) xdrs->x_private - (u_int) xdrs->x_base);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r9d
test   %rdx,%rdx
je     f50 <gsl_stats_uint_min_index+0x37>
shl    $0x2,%rsi
add    %rsi,%rdi
mov    $0x0,%ecx
mov    $0x0,%eax
jmp    f45 <gsl_stats_uint_min_index+0x2c>
mov    (%rdi),%r8d
cmp    %r8d,%r9d
jbe    f42 <gsl_stats_uint_min_index+0x29>
mov    %rcx,%rax
mov    %r8d,%r9d
add    %rsi,%rdi
add    $0x1,%rcx
cmp    %rdx,%rcx
jne    f34 <gsl_stats_uint_min_index+0x1b>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_stats_uint_min_index (const unsigned int data[], const size_t stride,
                                const size_t n)
{
  unsigned int min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned int xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 5
8 5
9 8
10 9
11 9
12 6
13 8
14 8
15 6
16 6
17 6
18 6
19 5
20 16
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
__dbenv_set_errfile(dbenv, errfile)
 DB_ENV *dbenv;
 FILE *errfile;
{
 dbenv->db_errfile = errfile;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     115a <mu_message_get_uid+0x2c>
mov    0x78(%rdi),%rax
test   %rax,%rax
je     1149 <mu_message_get_uid+0x1b>
sub    $0x8,%rsp
callq  *%rax
jmp    1156 <mu_message_get_uid+0x28>
movq   $0x0,(%rsi)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_message_get_uid (mu_message_t msg, size_t *puid)
{
  if (msg == ((void *)0))
    return 22;
  if (msg->_get_uid)
    return msg->_get_uid (msg, puid);
  *puid = 0;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 5
6 5
7 2
8 6
9 6
10 7
11 8
12 8
13 9
14 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
callq  136 <rec_sex_parser_print_ast+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_sex_parser_print_ast (rec_sex_parser_t parser)
{
  rec_sex_ast_print (parser->ast);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
cmp    (%rsi),%rax
ja     2812 <strip_whitespace+0x58>
movzbl (%rax),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
je     2816 <strip_whitespace+0x5c>
add    $0x1,%rax
mov    %rax,%rdx
mov    %rax,(%rdi)
cmp    %rax,(%rsi)
jb     2812 <strip_whitespace+0x58>
add    $0x1,%rax
movzbl (%rdx),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
jne    27d3 <strip_whitespace+0x19>
jmp    2816 <strip_whitespace+0x5c>
mov    %rdx,%rcx
mov    %rdx,(%rsi)
mov    (%rdi),%rax
cmp    %rdx,%rax
ja     282f <strip_whitespace+0x75>
sub    $0x1,%rdx
movzbl (%rcx),%ecx
testb  $0x6,0x0(%rcx,%rcx,1)
jne    27f1 <strip_whitespace+0x37>
repz retq 
mov    (%rdi),%rax
retq   
mov    (%rsi),%rdx
mov    (%rdi),%rax
movzbl (%rdx),%ecx
testb  $0x6,0x0(%rcx,%rcx,1)
je     282f <strip_whitespace+0x75>
sub    $0x1,%rdx
jmp    27f1 <strip_whitespace+0x37>
repz retq 
<<<sep_in_sample>>>
strip_whitespace (const char **begpp, const char **endpp)
{
  while (*begpp <= *endpp && (((stopchar_map[(unsigned char)((**begpp))])&(((0x0002|0x0004)))) != 0))
    (*begpp) ++;
  while (*endpp >= *begpp && (((stopchar_map[(unsigned char)((**endpp))])&(((0x0002|0x0004)))) != 0))
    (*endpp) --;
  return (char *)*begpp;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 6
18 6
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 8
<<<sep_out_sample>>>
test   %esi,%esi
je     2c <format_level+0x2c>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %esi,%ebx
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  21 <format_level+0x21>
sub    $0x1,%ebx
jne    f <format_level+0xf>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
format_level (mu_stream_t stream, int level)
{
  while (level--)
    mu_stream_sequential_write (stream, "  ", 2);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 3
13 3
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%ebx
mov    $0x6bca1af3,%ebp
mov    %edi,%eax
imul   %ebp
sar    $0x3,%edx
mov    %edi,%r12d
sar    $0x1f,%r12d
sub    %r12d,%edx
lea    (%rdx,%rdx,8),%eax
lea    (%rdx,%rax,2),%eax
mov    %edi,%esi
sub    %eax,%esi
lea    0x3(%rsi,%rsi,2),%ecx
shl    $0x2,%ecx
mov    %ecx,%eax
imul   %ebp
sar    $0x3,%edx
mov    %edx,%ebp
mov    %ecx,%eax
sar    $0x1f,%eax
sub    %eax,%ebp
lea    0x0(%rbp,%rbp,8),%eax
lea    0x0(%rbp,%rax,2),%eax
sub    %eax,%ecx
mov    %ecx,%ebp
mov    %edi,%edx
mov    $0x8,%esi
mov    0x0(%rip),%edi        # e9 <tishri_1+0x5c>
callq  ee <tishri_1+0x61>
mov    %eax,%r13d
cvtsi2sd %ebp,%xmm1
mulsd  0x0(%rip),%xmm1        # fd <tishri_1+0x70>
shr    $0x1e,%r12d
lea    (%rbx,%r12,1),%eax
and    $0x3,%eax
sub    %r12d,%eax
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 117 <tishri_1+0x8a>
addsd  %xmm0,%xmm1
cvtsi2sd %ebx,%xmm0
mulsd  0x0(%rip),%xmm0        # 127 <tishri_1+0x9a>
addsd  0x0(%rip),%xmm0        # 12f <tishri_1+0xa2>
divsd  0x0(%rip),%xmm0        # 137 <tishri_1+0xaa>
subsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
mov    0x0(%rip),%rax        # 148 <tishri_1+0xbb>
cmp    (%rax),%ebx
jl     175 <tishri_1+0xe8>
mov    $0x51eb851f,%edx
mov    %ebx,%eax
imul   %edx
mov    %edx,%eax
sar    $0x5,%eax
sar    $0x7,%edx
sub    %edx,%eax
cvtsi2sd %eax,%xmm0
subsd  0x0(%rip),%xmm0        # 16b <tishri_1+0xde>
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rsp)
cvttsd2si 0x8(%rsp),%r12d
add    %r12d,%r13d
mov    %ebx,%edx
mov    $0x9,%esi
mov    %r12d,%edi
callq  18e <tishri_1+0x101>
cmp    $0x7,%eax
ja     1ee <tishri_1+0x161>
mov    %eax,%eax
jmpq   *0x0(,%rax,8)
add    $0x1,%r13d
jmp    1ee <tishri_1+0x161>
cvtsi2sd %r12d,%xmm0
movsd  0x8(%rsp),%xmm2
subsd  %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm2        # 1b9 <tishri_1+0x12c>
jb     1ee <tishri_1+0x161>
cmp    $0xc,%ebp
setge  %al
movzbl %al,%eax
add    %eax,%r13d
jmp    1ee <tishri_1+0x161>
cvtsi2sd %r12d,%xmm0
movsd  0x8(%rsp),%xmm3
subsd  %xmm0,%xmm3
ucomisd 0x0(%rip),%xmm3        # 1e0 <tishri_1+0x153>
jb     1ee <tishri_1+0x161>
cmp    $0x7,%ebp
setge  %al
movzbl %al,%eax
add    %eax,%r13d
mov    %r13d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
tishri_1 (year)
     const int year;
{
  auto double n;
  register int golden_number = (year % 19) + 1;
  register int g12 = (12 * golden_number) % 19;
  register int doy = day_of_year (dvec[8 - 1], 8, year);
  n = ((765433.0 / 492480.0) * g12)
    + ((year % 4) / 4.0) - (((313.0 * year) + 89081.0) / 98496.0);
  if (year >= greg->year)
    n += ((year / 100) - (year / 400) - 2.0);
  doy += (int) n;
  switch (weekday_of_date ((int) n, 9, year))
    {
    case 3:
    case 5:
    case 7:
      doy++;
      break;
    case 1:
      if ((n - (int) n >= 23269.0 / 25920.0) && (g12 > 11))
 doy++;
      break;
    case 2:
      if ((n - (int) n >= 1367.0 / 2160.0) && (g12 > 6))
 doy++;
      break;
    default:
      ;
    }
  return (doy);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 7
32 7
33 7
34 7
35 7
36 8
37 8
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 8
50 8
51 10
52 10
53 10
54 11
55 11
56 11
57 11
58 11
59 11
60 11
61 11
62 11
63 11
64 11
65 12
66 12
67 13
68 13
69 13
70 13
71 13
72 13
73 13
74 13
75 18
76 19
77 21
78 21
79 21
80 21
81 21
82 22
83 22
84 22
85 22
86 22
87 25
88 25
89 25
90 25
91 25
92 26
93 26
94 26
95 26
96 32
97 32
98 32
99 32
100 32
101 32
102 32
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  169 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  deb <rule_section_init+0xe>
movl   $0x1,0xc(%rax)
movl   $0x2,0x8(%rax)
mov    $0x0,%esi
mov    %rax,%rdi
callq  e06 <rule_section_init+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rule_section_init (void)
{
  struct rc_secdef *sp = anubis_add_section ("RULE");
  sp->allow_prog = 1;
  sp->prio = prio_system;
  rc_secdef_add_child (sp, &rule_sect_child);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 6
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%rbx
mov    %rsi,0x8(%rsp)
mov    %rdi,0x18(%rsp)
mov    0x0(%rip),%edx        # 1128 <tree8_to_bits+0x18>
lea    0x8(%rsp),%rsi
lea    0x18(%rsp),%rdi
callq  1137 <tree8_to_bits+0x27>
mov    %rbx,%rax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
tree8_to_bits (unsigned char *bv_0, unsigned char const *hits_tree8)
{
  unsigned char* bv = bv_0;
  tree8_to_bits_1 (&bv, &hits_tree8, tree8_levels);
  return bv_0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
mov    0x0(%rip),%rax        # 11bd <quotearg_n_custom_mem+0x17>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 11c8 <quotearg_n_custom_mem+0x22>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 11d4 <quotearg_n_custom_mem+0x2e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 11e0 <quotearg_n_custom_mem+0x3a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 11ec <quotearg_n_custom_mem+0x46>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 11f8 <quotearg_n_custom_mem+0x52>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 1204 <quotearg_n_custom_mem+0x5e>
mov    %rax,0x30(%rsp)
mov    %rsp,%rdi
callq  1211 <quotearg_n_custom_mem+0x6b>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b75 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%rdi
mov    %rdx,%rsi
mov    0x0(%rip),%ecx        # 18f0 <parse_iregex+0x13>
or     $0x400000,%ecx
mov    %rax,%rdx
callq  17b7 <insert_regex>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_iregex (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_regex (argv, arg_ptr, entry, ((((((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)|options.regex_options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %edx,%r12d
movsbl %dl,%edx
callq  115b <EGetPunct+0x1b>
test   %eax,%eax
sete   %r13b
movzbl %r13b,%r13d
jne    1180 <EGetPunct+0x40>
mov    %r12b,0x1(%rbx)
mov    $0x0,%ecx
mov    %rbx,%rdx
mov    $0x13,%esi
mov    %rbp,%rdi
callq  1180 <EGetPunct+0x40>
mov    %r13d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
EGetPunct (PINPUTBUF pibIn, PSTR szLex, char chPunct)
{
  int iReturn;
  iReturn = !GetPunct (pibIn, szLex, chPunct);
  if (iReturn) {
    szLex[1] = chPunct;
    ReportError (pibIn, 0x0013, szLex, ((void *)0));
  }
  return (iReturn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 10
22 10
23 10
24 10
25 10
26 10
27 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 33f <reset_locale_vars+0xb>
test   %rax,%rax
je     349 <reset_locale_vars+0x15>
cmpb   $0x0,(%rax)
jne    35f <reset_locale_vars+0x2b>
callq  34e <reset_locale_vars+0x1a>
mov    0x0(%rip),%rax        # 355 <reset_locale_vars+0x21>
mov    $0x0,%esi
test   %rax,%rax
je     362 <reset_locale_vars+0x2e>
mov    %rax,%rsi
mov    $0x6,%edi
callq  36c <reset_locale_vars+0x38>
mov    $0x0,%edx
test   %rax,%rax
je     407 <reset_locale_vars+0xd3>
mov    $0x0,%edi
callq  384 <reset_locale_vars+0x50>
mov    %rax,%rsi
mov    $0x0,%edi
callq  391 <reset_locale_vars+0x5d>
mov    $0x0,%edi
callq  39b <reset_locale_vars+0x67>
mov    %rax,%rsi
mov    $0x3,%edi
callq  3a8 <reset_locale_vars+0x74>
mov    $0x0,%edi
callq  3b2 <reset_locale_vars+0x7e>
mov    %rax,%rsi
mov    $0x5,%edi
callq  3bf <reset_locale_vars+0x8b>
mov    $0x0,%edi
callq  3c9 <reset_locale_vars+0x95>
mov    %rax,%rsi
mov    $0x1,%edi
callq  3d6 <reset_locale_vars+0xa2>
mov    $0x0,%edi
callq  3e0 <reset_locale_vars+0xac>
mov    %rax,%rsi
mov    $0x2,%edi
callq  3ed <reset_locale_vars+0xb9>
callq  0 <locale_setblanks>
callq  3f7 <reset_locale_vars+0xc3>
mov    %eax,0x0(%rip)        # 3fd <reset_locale_vars+0xc9>
callq  402 <reset_locale_vars+0xce>
mov    $0x1,%edx
mov    %edx,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
reset_locale_vars ()
{
  char *t;
  if (lang == 0 || *lang == '\0')
    maybe_make_export_env ();
  if (setlocale (6, lang ? lang : "") == 0)
    return 0;
  t = setlocale (0, get_locale_var ("LC_CTYPE"));
  t = setlocale (3, get_locale_var ("LC_COLLATE"));
  t = setlocale (5, get_locale_var ("LC_MESSAGES"));
  t = setlocale (1, get_locale_var ("LC_NUMERIC"));
  t = setlocale (2, get_locale_var ("LC_TIME"));
  locale_setblanks ();
  locale_mb_cur_max = (__ctype_get_mb_cur_max ());
  u32reset ();
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 6
17 6
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 11
34 11
35 11
36 11
37 11
38 12
39 12
40 12
41 12
42 12
43 13
44 14
45 14
46 15
47 16
48 17
49 17
50 17
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 8 <initialize_variable_output+0x8>
jne    38 <initialize_variable_output+0x38>
sub    $0x8,%rsp
movl   $0xc8,0x0(%rip)        # 18 <initialize_variable_output+0x18>
mov    $0xc8,%edi
callq  22 <initialize_variable_output+0x22>
mov    %rax,0x0(%rip)        # 29 <initialize_variable_output+0x29>
movb   $0x0,(%rax)
mov    0x0(%rip),%rax        # 33 <initialize_variable_output+0x33>
add    $0x8,%rsp
retq   
mov    0x0(%rip),%rax        # 3f <initialize_variable_output+0x3f>
retq   
<<<sep_in_sample>>>
initialize_variable_output (void)
{
  if (variable_buffer == 0)
    {
      variable_buffer_length = 200;
      variable_buffer = xmalloc (variable_buffer_length);
      variable_buffer[0] = '\0';
    }
  return variable_buffer;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 6
6 6
7 6
8 7
9 10
10 10
11 10
12 10
13 10
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     118 <rl_discard_keymap+0x4e>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x101,%ebp
movzbl (%rbx),%eax
cmp    $0x1,%al
je     ea <rl_discard_keymap+0x20>
cmp    $0x2,%al
je     100 <rl_discard_keymap+0x36>
jmp    109 <rl_discard_keymap+0x3f>
mov    0x8(%rbx),%rdi
xchg   %ax,%ax
callq  f5 <rl_discard_keymap+0x2b>
mov    0x8(%rbx),%rdi
callq  fe <rl_discard_keymap+0x34>
jmp    109 <rl_discard_keymap+0x3f>
mov    0x8(%rbx),%rdi
callq  109 <rl_discard_keymap+0x3f>
add    $0x10,%rbx
sub    $0x1,%ebp
jne    dd <rl_discard_keymap+0x13>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
rl_discard_keymap (map)
     Keymap map;
{
  int i;
  if (map == 0)
    return;
  for (i = 0; i < 257; i++)
    {
      switch (map[i].type)
 {
 case 0:
   break;
 case 1:
   rl_discard_keymap ((Keymap)map[i].function);
   xfree ((char *)map[i].function);
   break;
 case 2:
   xfree ((char *)map[i].function);
   break;
 }
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 3
5 3
6 3
7 5
8 9
9 9
10 9
11 9
12 9
13 9
14 14
15 14
16 14
17 15
18 15
19 16
20 18
21 18
22 18
23 7
24 7
25 22
26 22
27 22
28 22
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     1efc <mu_url_is_ticket+0xc9>
mov    %rsi,%rbp
test   %rsi,%rsi
je     1efc <mu_url_is_ticket+0xc9>
mov    0x8(%rdi),%r12
mov    %r12,%rdi
callq  31e <defined>
test   %eax,%eax
je     1e86 <mu_url_is_ticket+0x53>
mov    0x8(%rbp),%rsi
mov    $0x0,%edx
test   %rsi,%rsi
je     1f08 <mu_url_is_ticket+0xd5>
mov    %r12,%rdi
callq  1e79 <mu_url_is_ticket+0x46>
mov    $0x0,%edx
test   %eax,%eax
jne    1f08 <mu_url_is_ticket+0xd5>
mov    0x28(%rbx),%r12
mov    %r12,%rdi
callq  31e <defined>
test   %eax,%eax
je     1eb5 <mu_url_is_ticket+0x82>
mov    0x28(%rbp),%rsi
mov    $0x0,%edx
test   %rsi,%rsi
je     1f08 <mu_url_is_ticket+0xd5>
mov    %r12,%rdi
callq  1eac <mu_url_is_ticket+0x79>
mov    $0x0,%edx
test   %eax,%eax
jne    1f08 <mu_url_is_ticket+0xd5>
mov    0x30(%rbx),%rax
test   %rax,%rax
je     1ec9 <mu_url_is_ticket+0x96>
mov    $0x0,%edx
cmp    0x30(%rbp),%rax
jne    1f08 <mu_url_is_ticket+0xd5>
mov    0x10(%rbp),%rbp
test   %rbp,%rbp
je     1f03 <mu_url_is_ticket+0xd0>
mov    0x10(%rbx),%rbx
mov    %rbx,%rdi
callq  31e <defined>
mov    $0x1,%edx
test   %eax,%eax
je     1f08 <mu_url_is_ticket+0xd5>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1ef2 <mu_url_is_ticket+0xbf>
test   %eax,%eax
sete   %dl
movzbl %dl,%edx
jmp    1f08 <mu_url_is_ticket+0xd5>
mov    $0x0,%edx
jmp    1f08 <mu_url_is_ticket+0xd5>
mov    $0x1,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_url_is_ticket (mu_url_t ticket, mu_url_t url)
{
  if (!ticket || !url)
    return 0;
  if (defined (ticket->scheme))
    {
      if (!url->scheme || mu_c_strcasecmp (ticket->scheme, url->scheme) != 0)
 return 0;
    }
  if (defined (ticket->host))
    {
      if (!url->host || mu_c_strcasecmp (ticket->host, url->host) != 0)
 return 0;
    }
  if (ticket->port && ticket->port != url->port)
    return 0;
  if (url->user)
    {
      if (defined (ticket->user) && strcmp (ticket->user, url->user) != 0)
 return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 7
16 8
17 7
18 7
19 7
20 7
21 8
22 7
23 7
24 10
25 10
26 10
27 10
28 10
29 12
30 13
31 12
32 12
33 12
34 12
35 13
36 12
37 12
38 15
39 15
40 15
41 16
42 15
43 15
44 17
45 17
46 17
47 19
48 19
49 19
50 22
51 19
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 19
60 4
61 4
62 22
63 23
64 23
65 23
66 23
67 23
<<<sep_out_sample>>>
mov    $0x1b8,%edx
test   $0x1,%dil
je     29c7 <tar_stat_init+0x14>
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0xb7,%dl
test   $0x2,%dil
je     29d9 <tar_stat_init+0x26>
movw   $0x0,(%rdi)
add    $0x2,%rdi
sub    $0x2,%edx
test   $0x4,%dil
je     29ec <tar_stat_init+0x39>
movl   $0x0,(%rdi)
add    $0x4,%rdi
sub    $0x4,%edx
mov    %edx,%ecx
shr    $0x3,%ecx
mov    %ecx,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
test   $0x4,%dl
je     2a0a <tar_stat_init+0x57>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     2a18 <tar_stat_init+0x65>
movw   $0x0,(%rdi)
add    $0x2,%rdi
test   $0x1,%dl
je     2a20 <tar_stat_init+0x6d>
movb   $0x0,(%rdi)
repz retq 
<<<sep_in_sample>>>
tar_stat_init (struct tar_stat_info *st)
{
  memset (st, 0, sizeof (*st));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x0,%esi
callq  2036 <cmdline_parser_file_save+0x14>
mov    %rax,%rbx
test   %rax,%rax
jne    2063 <cmdline_parser_file_save+0x41>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2052 <cmdline_parser_file_save+0x30>
mov    $0x0,%eax
callq  205c <cmdline_parser_file_save+0x3a>
mov    $0x1,%eax
jmp    207a <cmdline_parser_file_save+0x58>
mov    %r12,%rsi
mov    %rax,%rdi
callq  206e <cmdline_parser_file_save+0x4c>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  2078 <cmdline_parser_file_save+0x56>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;
  outfile = fopen(filename, "w");
  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", "gengetopt", filename);
      return 1;
    }
  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);
  return i;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 9
18 9
19 11
20 11
21 11
22 11
23 12
24 12
25 13
26 14
27 14
28 14
29 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     19a <mu_stream_destroy+0x55>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     19a <mu_stream_destroy+0x55>
testb  $0x40,0x10(%rbx)
jne    166 <mu_stream_destroy+0x21>
cmp    %rsi,(%rbx)
jne    192 <mu_stream_destroy+0x4d>
mov    %rbx,%rdi
callq  16e <mu_stream_destroy+0x29>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     17c <mu_stream_destroy+0x37>
callq  17c <mu_stream_destroy+0x37>
mov    0x48(%rbx),%rax
test   %rax,%rax
je     18a <mu_stream_destroy+0x45>
mov    %rbx,%rdi
callq  *%rax
mov    %rbx,%rdi
callq  192 <mu_stream_destroy+0x4d>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_stream_destroy (mu_stream_t *pstream, void *owner)
{
   if (pstream && *pstream)
    {
      mu_stream_t stream = *pstream;
      if ((stream->flags & 0x00000040) || stream->owner == owner)
 {
   mu_stream_close (stream);
   if (stream->rbuffer.base)
     free (stream->rbuffer.base);
   if (stream->_destroy)
     stream->_destroy (stream);
   free (stream);
 }
      *pstream = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 6
13 6
14 8
15 8
16 9
17 9
18 9
19 10
20 11
21 11
22 11
23 12
24 12
25 13
26 13
27 15
28 17
29 17
30 17
31 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%edi
callq  13 <fix_attr_value+0x13>
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
je     70 <fix_attr_value+0x70>
cmp    $0x27,%bl
jne    31 <fix_attr_value+0x31>
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f <fix_attr_value+0x2f>
jmp    64 <fix_attr_value+0x64>
mov    0x0(%rip),%rax        # 38 <fix_attr_value+0x38>
cmp    %rax,0x0(%rip)        # 3f <fix_attr_value+0x3f>
jb     50 <fix_attr_value+0x50>
mov    $0x0,%esi
mov    $0x0,%edi
callq  50 <fix_attr_value+0x50>
mov    0x0(%rip),%rax        # 57 <fix_attr_value+0x57>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 62 <fix_attr_value+0x62>
mov    %bl,(%rax)
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    1b <fix_attr_value+0x1b>
mov    $0x0,%edi
callq  7a <fix_attr_value+0x7a>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
fix_attr_value(const char *value)
{
 static STRBUF sb[1];
 char c;
 const char *cptr;
 strbuf_clear(sb);
 cptr = value;
 while((c = *cptr) != '\0') {
  if(c == '\'')
   strbuf_puts(sb, "&#39;");
  else
   do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = c;} while (0);
  ++cptr;
 }
 return strbuf_value(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 8
8 8
9 8
10 9
11 9
12 10
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 8
28 8
29 8
30 15
31 15
32 16
33 16
34 16
35 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <lmniel_free+0x11>
callq  11 <lmniel_free+0x11>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     1f <lmniel_free+0x1f>
callq  1f <lmniel_free+0x1f>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     2d <lmniel_free+0x2d>
callq  2d <lmniel_free+0x2d>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     3b <lmniel_free+0x3b>
callq  3b <lmniel_free+0x3b>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     49 <lmniel_free+0x49>
callq  49 <lmniel_free+0x49>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     57 <lmniel_free+0x57>
callq  57 <lmniel_free+0x57>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     65 <lmniel_free+0x65>
callq  65 <lmniel_free+0x65>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     73 <lmniel_free+0x73>
callq  73 <lmniel_free+0x73>
pop    %rbx
retq   
<<<sep_in_sample>>>
lmniel_free(void *vstate)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  if (state->A)
    gsl_matrix_free(state->A);
  if (state->J)
    gsl_matrix_free(state->J);
  if (state->diag)
    gsl_vector_free(state->diag);
  if (state->rhs)
    gsl_vector_free(state->rhs);
  if (state->work)
    gsl_vector_free(state->work);
  if (state->A_copy)
    gsl_matrix_free(state->A_copy);
  if (state->x_trial)
    gsl_vector_free(state->x_trial);
  if (state->f_trial)
    gsl_vector_free(state->f_trial);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 15
27 16
28 16
29 16
30 17
31 18
32 18
33 18
34 19
35 20
36 20
<<<sep_out_sample>>>
mov    0x138(%rdi),%rax
cmp    $0x0,%rax
je     1a1d <swvarfs_get_stat_syscall+0x40>
cmp    $0x0,%rax
je     1a23 <swvarfs_get_stat_syscall+0x46>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 19ff <swvarfs_get_stat_syscall+0x22>
mov    $0x31,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1a13 <swvarfs_get_stat_syscall+0x36>
mov    $0x1,%edi
callq  1a1d <swvarfs_get_stat_syscall+0x40>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
swvarfs_get_stat_syscall(SWVARFS * swvarfs)
{
 if ( swvarfs->f_statM == (int (*)(char *, struct stat *))lstat) {
  return "lstat";
 } else if ( swvarfs->f_statM == (int (*)(char *, struct stat *))stat) {
  return "stat";
 } else {
  fprintf(stderr, "swvarfs: fatal error in swvarfs_get_stat_syscall\n");
  exit(1);
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 2
7 8
8 8
9 8
10 8
11 8
12 9
13 9
14 4
15 4
16 6
17 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 425 <taruib_get_datalen+0x6>
retq   
<<<sep_in_sample>>>
taruib_get_datalen(void)
{
 return g_taruib_gst_lenM;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rbx
test   %esi,%esi
jns    25 <emit_message+0x25>
cmpq   $0x0,0x80(%rbx)
je     18 <emit_message+0x18>
cmpl   $0x2,0x7c(%rbx)
jle    1b <emit_message+0x1b>
callq  *0x10(%rbx)
addq   $0x1,0x80(%rbx)
jmp    2d <emit_message+0x2d>
cmp    0x7c(%rbx),%esi
jg     2d <emit_message+0x2d>
callq  *0x10(%rbx)
pop    %rbx
xchg   %ax,%ax
retq   
<<<sep_in_sample>>>
emit_message (j_common_ptr cinfo, int msg_level)
{
  struct jpeg_error_mgr * err = cinfo->err;
  if (msg_level < 0) {
    if (err->num_warnings == 0 || err->trace_level >= 3)
      (*err->output_message) (cinfo);
    err->num_warnings++;
  } else {
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
7 5
8 5
9 6
10 7
11 7
12 9
13 9
14 10
15 12
16 12
17 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1339 <gsl_sf_expint_E1_scaled+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     135f <gsl_sf_expint_E1_scaled+0x32>
mov    %eax,%ecx
mov    $0x226,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1358 <gsl_sf_expint_E1_scaled+0x2b>
movsd  (%rsp),%xmm0
jmp    135f <gsl_sf_expint_E1_scaled+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expint_E1_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_expint_E1_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_expint_E1_scaled_e(x, &result)", "expint.c", 550, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     102d <gsl_matrix_ulong_fscanf+0x43>
shl    $0x3,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     106e <gsl_matrix_ulong_fscanf+0x84>
jmp    1044 <gsl_matrix_ulong_fscanf+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  1042 <gsl_matrix_ulong_fscanf+0x58>
jmp    106e <gsl_matrix_ulong_fscanf+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  105c <gsl_matrix_ulong_fscanf+0x72>
test   %eax,%eax
jne    106e <gsl_matrix_ulong_fscanf+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    1044 <gsl_matrix_ulong_fscanf+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_ulong_fscanf (FILE * stream, gsl_matrix_ulong * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_ulong_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_ulong_raw_fscanf (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <restore_tty_state>
mov    0x0(%rip),%rcx        # 3a <sigint_handler+0x10>
mov    $0x1f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  4e <sigint_handler+0x24>
mov    $0x1,%edi
callq  58 <fm_getpassphrase>
<<<sep_in_sample>>>
sigint_handler(int signum)
{
    restore_tty_state();
    fprintf(stderr, ("\nCaught SIGINT... bailing out.\n"));
    exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 1b <gotoswitch+0xb>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2f <gotoswitch+0x1f>
movq   $0x0,0x0(%rip)        # 3a <gotoswitch+0x2a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gotoswitch (void)
{
  fprintf (ccode, "goto __sw;");
  last_line = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  e1 <grecs_strdup+0x1d>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  ec <grecs_strdup+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_strdup(const char *str)
{
 char *newstr = grecs_malloc(strlen(str) + 1);
 return strcpy(newstr, str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     1b0 <decode_string+0x20>
callq  1a9 <decode_string+0x19>
movq   $0x0,(%rbx)
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    $0x0,%edi
callq  1c0 <decode_string+0x30>
test   %al,%al
jne    1cf <decode_string+0x3f>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1cf <decode_string+0x3f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
decode_string (char **string, char const *arg)
{
  if (*string)
    {
      free (*string);
      *string = ((void *)0);
    }
  if (!utf8_convert (0, arg, string))
    {
      assign_string (string, arg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 10
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    f44 <gsl_permute_matrix_ulong+0x29>
mov    $0x0,%ebx
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     f8c <gsl_permute_matrix_ulong+0x71>
jmp    f64 <gsl_permute_matrix_ulong+0x49>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f5d <gsl_permute_matrix_ulong+0x42>
mov    $0x13,%eax
jmp    f8c <gsl_permute_matrix_ulong+0x71>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  f72 <gsl_permute_matrix_ulong+0x57>
mov    %rsp,%rsi
mov    %r12,%rdi
callq  f7d <gsl_permute_matrix_ulong+0x62>
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     f64 <gsl_permute_matrix_ulong+0x49>
mov    $0x0,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_permute_matrix_ulong (const gsl_permutation * p, gsl_matrix_ulong * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_ulong_view r = gsl_matrix_ulong_row (A, i);
          gsl_permute_vector_ulong (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 10
11 15
12 10
13 10
14 10
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 10
30 10
31 10
32 15
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cdio_get_devices_bsdi (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x658,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rsp,%rdi
callq  4764 <rootunit+0x16>
mov    %rbx,%rdi
callq  476c <rootunit+0x1e>
mov    %eax,%edx
test   %edx,%edx
jne    47f1 <rootunit+0xa3>
movsd  0x640(%rbx),%xmm0
mov    $0x6,%eax
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
ja     47f1 <rootunit+0xa3>
cvtsi2sd %ebp,%xmm2
movsd  0x0(%rip),%xmm1        # 4795 <rootunit+0x47>
divsd  %xmm2,%xmm1
callq  479e <rootunit+0x50>
movsd  %xmm0,0x640(%rsp)
mov    %rsp,%rdx
mov    %rbx,%rsi
mov    %ebp,%edi
callq  47b4 <rootunit+0x66>
mov    %eax,%edx
test   %edx,%edx
jne    47f1 <rootunit+0xa3>
lea    0x320(%rsp),%rdx
lea    0x320(%rbx),%rsi
mov    %ebp,%edi
callq  47d0 <rootunit+0x82>
mov    %eax,%edx
test   %edx,%edx
jne    47f1 <rootunit+0xa3>
mov    %rbx,%rdi
callq  47de <rootunit+0x90>
mov    %rbx,%rdi
callq  47e6 <rootunit+0x98>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  47f1 <rootunit+0xa3>
add    $0x658,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rootunit(struct unittype *inunit,int n)
{
   struct unittype outunit;
   int err;
   initializeunit(&outunit);
   if ((err=completereduce(inunit)))
     return err;
   if (inunit->factor < 0)
     return 6;
   outunit.factor = pow(inunit->factor,1.0/(double)n);
   if ((err = subunitroot(n, inunit->numerator, outunit.numerator)))
     return err;
   if ((err = subunitroot(n, inunit->denominator, outunit.denominator)))
     return err;
   freeunit(inunit);
   initializeunit(inunit);
   return multunit(inunit,&outunit);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 8
14 9
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 15
38 15
39 16
40 16
41 17
42 17
43 17
44 18
45 18
46 18
47 18
<<<sep_out_sample>>>
lea    -0x1(%rdx),%r8
test   %rdx,%rdx
je     2a <strlcat+0x2a>
cmpb   $0x0,(%rdi)
je     2f <strlcat+0x2f>
mov    %rdi,%rcx
mov    $0x0,%eax
add    $0x1,%rcx
cmp    %r8,%rax
je     32 <strlcat+0x32>
add    $0x1,%rax
cmpb   $0x0,(%rcx)
jne    16 <strlcat+0x16>
jmp    32 <strlcat+0x32>
mov    %rdi,%rcx
jmp    32 <strlcat+0x32>
mov    %rdi,%rcx
mov    %rcx,%r10
sub    %rdi,%r10
sub    %r10,%rdx
je     4b <strlcat+0x4b>
movzbl (%rsi),%r9d
mov    %rsi,%r8
test   %r9b,%r9b
jne    65 <strlcat+0x65>
jmp    83 <strlcat+0x83>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r10,%rcx,1),%rax
retq   
cmp    $0x1,%rdx
je     76 <strlcat+0x76>
mov    %r9b,(%rcx)
sub    $0x1,%rdx
lea    0x1(%rcx),%rcx
add    $0x1,%r8
movzbl (%r8),%r9d
test   %r9b,%r9b
jne    65 <strlcat+0x65>
movb   $0x0,(%rcx)
sub    %rsi,%r8
lea    (%r8,%r10,1),%rax
retq   
<<<sep_in_sample>>>
strlcat(char *dst, const char *src, size_t siz)
{
 register char *d = dst;
 register const char *s = src;
 register size_t n = siz;
 size_t dlen;
 while (n-- != 0 && *d != '\0')
  d++;
 dlen = d - dst;
 n = siz - dlen;
 if (n == 0)
  return(dlen + strlen(s));
 while (*s != '\0') {
  if (n != 1) {
   *d++ = *s;
   n--;
  }
  s++;
 }
 *d = '\0';
 return(dlen + (s - src));
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 3
7 7
8 8
9 7
10 7
11 7
12 7
13 7
14 7
15 3
16 3
17 3
18 9
19 9
20 11
21 11
22 13
23 13
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 15
37 16
38 15
39 18
40 13
41 13
42 13
43 20
44 21
45 21
46 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     236 <_cdio_strdup_upper+0x37>
callq  20f <_cdio_strdup_upper+0x10>
mov    %rax,%rbp
movzbl (%rax),%edi
test   %dil,%dil
je     23b <_cdio_strdup_upper+0x3c>
mov    %rax,%rbx
movzbl %dil,%edi
callq  226 <_cdio_strdup_upper+0x27>
mov    %al,(%rbx)
add    $0x1,%rbx
movzbl (%rbx),%edi
test   %dil,%dil
jne    21d <_cdio_strdup_upper+0x1e>
jmp    23b <_cdio_strdup_upper+0x3c>
mov    $0x0,%ebp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_cdio_strdup_upper (const char str[])
{
  char *new_str = ((void *)0);
  if (str)
    {
      char *p;
      p = new_str = strdup (str);
      while (*p)
        {
          *p = toupper ((unsigned char) *p);
          p++;
        }
    }
  return new_str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 7
7 7
8 8
9 8
10 8
11 7
12 10
13 10
14 10
15 11
16 8
17 8
18 8
19 8
20 3
21 15
22 15
23 15
24 15
25 15
<<<sep_out_sample>>>
test   %esi,%esi
je     271 <print_capa+0x4a>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rdx,%rbx
mov    (%rdx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
test   %rax,%rax
je     259 <print_capa+0x32>
mov    0x8(%rbx),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  259 <print_capa+0x32>
mov    0x8(%rbx),%rdi
mov    %rbp,%rsi
callq  265 <print_capa+0x3e>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
print_capa(const char *name, int enabled, void *data)
{
    struct capa_print *cp = data;
    if (enabled) {
 if (cp->num++)
     dico_stream_write(cp->stream, ".", 1);
 stream_writez(cp->stream, (char*)name);
    }
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 10
21 10
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    (%rdi),%rdi
callq  11 <_free_index+0x11>
cmpq   $0x0,0x48(%rbp)
je     45 <_free_index+0x45>
mov    $0x0,%ebx
mov    0x50(%rbp),%rax
mov    (%rax,%rbx,8),%rax
mov    0x10(%rax),%rdi
callq  2e <_free_index+0x2e>
mov    0x50(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
callq  3b <_free_index+0x3b>
add    $0x1,%rbx
cmp    %rbx,0x48(%rbp)
ja     1d <_free_index+0x1d>
mov    0x50(%rbp),%rdi
callq  4e <_free_index+0x4e>
mov    %rbp,%rdi
callq  56 <_free_index+0x56>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_free_index(struct gcide_idx_file *file)
{
    size_t i;
    free(file->name);
    for (i = 0; i < file->cache_used; i++) {
 free(file->cache[i]->page);
 free(file->cache[i]);
    }
    free(file->cache);
    free(file);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 5
18 5
19 5
20 9
21 9
22 10
23 10
24 11
25 11
26 11
27 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <init_sh_quoting_options+0xe>
mov    %rax,0x0(%rip)        # 15 <init_sh_quoting_options+0x15>
mov    $0x1,%esi
mov    %rax,%rdi
callq  22 <init_sh_quoting_options+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_sh_quoting_options (void)
{
  sh_quoting_options = clone_quoting_options (((void *)0));
  set_quoting_style (sh_quoting_options, shell_quoting_style);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 40 <auth_encrypt_user+0xb>
callq  45 <auth_encrypt_user+0x10>
mov    $0x0,%eax
test   %rbx,%rbx
je     57 <auth_encrypt_user+0x22>
mov    %rbx,%rdi
callq  57 <auth_encrypt_user+0x22>
mov    %rax,0x0(%rip)        # 5e <auth_encrypt_user+0x29>
pop    %rbx
retq   
<<<sep_in_sample>>>
auth_encrypt_user (char *name)
{
  extern char *strdup (const char *);
  free (UserNameRequested);
  UserNameRequested = name ? strdup (name) : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rcx
test   %rcx,%rcx
jg     17 <__gmpf_integer_p+0x17>
test   %rdx,%rdx
sete   %al
movzbl %al,%eax
retq   
mov    %rdx,%rax
sar    $0x3f,%rax
xor    %rax,%rdx
sub    %rax,%rdx
mov    0x10(%rdi),%rax
cmpq   $0x0,(%rax)
jne    3c <__gmpf_integer_p+0x3c>
sub    $0x1,%rdx
add    $0x8,%rax
cmpq   $0x0,(%rax)
je     2e <__gmpf_integer_p+0x2e>
cmp    %rcx,%rdx
setle  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
__gmpf_integer_p (mpf_srcptr f)
{
  mp_srcptr fp;
  mp_exp_t exp;
  mp_size_t size;
  size = ((f)->_mp_size);
  exp = ((f)->_mp_exp);
  if (exp <= 0)
    return (size == 0);
  size = ((size) >= 0 ? (size) : -(size));
  for (fp = ((f)->_mp_d); *fp == 0; ++fp)
    --size;
  return size <= exp;
}
<<<sep_in_sample>>>
1 6
2 7
3 8
4 8
5 9
6 9
7 9
8 9
9 10
10 10
11 10
12 10
13 11
14 11
15 11
16 12
17 11
18 11
19 11
20 13
21 13
22 13
23 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  e0 <GetModelInfo+0x9>
cltq   
mov    %rax,0x8(%rbx)
callq  eb <GetModelInfo+0x14>
mov    %rax,0x18(%rbx)
callq  f4 <GetModelInfo+0x1d>
movslq %eax,%rdx
mov    %rdx,(%rbx)
test   %rdx,%rdx
je     137 <GetModelInfo+0x60>
lea    0x0(,%rdx,8),%rdi
callq  10c <GetModelInfo+0x35>
mov    %rax,0x10(%rbx)
test   %rax,%rax
jne    12e <GetModelInfo+0x57>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8004,%esi
mov    $0x0,%edi
callq  12e <GetModelInfo+0x57>
mov    0x10(%rbx),%rdi
callq  137 <GetModelInfo+0x60>
pop    %rbx
retq   
<<<sep_in_sample>>>
GetModelInfo (PMODELINFO pmi)
{
  pmi->nModelVars = (long) GetNModelVars ();
  pmi->pdModelVars = GetModelVector ();
  if ((pmi->nStates = (long) GetNStates()) != 0) {
    if (!(pmi->pStateHvar = (HVAR*) malloc (pmi->nStates * sizeof(HVAR))))
      ReportError(((void *)0), 0x0004 | 0x8000, "GetModelInfo", ((void *)0));
    GetStateHandles (pmi->pStateHvar);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 10
26 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  ed6 <encodings_table_new+0xb>
mov    %rax,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x20,%esi
mov    %rax,%rdi
callq  ef6 <encodings_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
encodings_table_new (void)
{
  struct hash_table_s * res;
  res = ((hash_table *) xmalloc (sizeof (hash_table) * (1)));
  hash_init (res, 32,
      (hash_func_t) encoding_hash_1,
      (hash_func_t) encoding_hash_2,
      (hash_cmp_func_t) encoding_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 10
12 10
13 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     9c <mu_envelope_get_owner+0x9>
mov    (%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_envelope_get_owner (mu_envelope_t envelope)
{
  return (envelope) ? envelope->owner : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,(%rsp)
mov    %rcx,0x8(%rsp)
mov    %r8,%r14
mov    %rdi,%rbp
mov    $0x0,%r13d
mov    %r12,%rsi
mov    %rbp,%rdi
callq  95f <parse_query+0x34>
add    %rax,%rbp
mov    0x0(%rbp),%al
test   %al,%al
je     978 <parse_query+0x4d>
cmp    0x1(%r12),%al
je     978 <parse_query+0x4d>
inc    %rbp
inc    %r13
jmp    954 <parse_query+0x29>
test   %r14,%r14
je     980 <parse_query+0x55>
mov    %rbp,(%r14)
cmp    %rbx,%rbp
je     9ff <parse_query+0xd4>
lea    0x1(%r13),%r15
lea    0x2(%r13),%rdi
mov    $0x8,%esi
callq  997 <parse_query+0x6c>
mov    %rax,%r14
mov    $0x0,%ebp
jmp    9dc <parse_query+0xb1>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  9ac <parse_query+0x81>
mov    %rax,%r13
mov    %rax,%rsi
mov    %rbx,%rdi
callq  9ba <parse_query+0x8f>
mov    %rax,(%r14,%rbp,8)
test   %rax,%rax
jne    9d4 <parse_query+0xa9>
mov    %r14,%rsi
mov    %ebp,%edi
callq  9cd <parse_query+0xa2>
mov    $0x1,%eax
jmp    a04 <parse_query+0xd9>
lea    0x1(%rbx,%r13,1),%rbx
inc    %rbp
cmp    %r15,%rbp
jb     9a1 <parse_query+0x76>
movq   $0x0,(%r14,%rbp,8)
mov    (%rsp),%rax
mov    %r15d,(%rax)
mov    0x8(%rsp),%rax
mov    %r14,(%rax)
mov    $0x0,%eax
jmp    a04 <parse_query+0xd9>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
parse_query (const char *query,
      char *delim,
      int *pargc, char ***pargv, const char **pend)
{
  size_t count, i;
  char **v;
  const char *p;
  for (p = query, count = 0; ; count++)
    {
      size_t len = strcspn (p, delim);
      p += len;
      if (!*p || *p == delim[1])
 break;
      p++;
    }
  if (pend)
    *pend = p;
  if (p == query)
    return 0;
  count++;
  v = calloc (count + 1, sizeof (v[0]));
  for (i = 0, p = query; i < count; i++)
    {
      size_t len = strcspn (p, delim);
      v[i] = mu_url_decode_len (p, len);
      if (v[i] == ((void *)0))
 {
   mu_argcv_free (i, v);
   return 1;
 }
      p += len + 1;
    }
  v[i] = ((void *)0);
  *pargc = count;
  *pargv = v;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 8
14 8
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 12
23 12
24 14
25 8
26 15
27 16
28 16
29 17
30 18
31 18
32 20
33 21
34 21
35 21
36 21
37 22
38 22
39 24
40 24
41 24
42 24
43 25
44 25
45 25
46 25
47 26
48 26
49 28
50 28
51 28
52 29
53 29
54 31
55 22
56 22
57 22
58 33
59 34
60 34
61 35
62 35
63 36
64 36
65 19
66 37
67 37
68 37
69 37
70 37
71 37
72 37
73 37
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%edi
jne    14 <_log_handler+0x14>
cmpl   $0x1,0x0(%rip)        # 10 <_log_handler+0x10>
ja     32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x2,%edi
jne    24 <_log_handler+0x24>
cmpl   $0x0,0x0(%rip)        # 20 <_log_handler+0x20>
jne    32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x3,%edi
jne    32 <_log_handler+0x32>
cmpl   $0x0,0x0(%rip)        # 30 <_log_handler+0x30>
jne    38 <_log_handler+0x38>
callq  *0x0(%rip)        # 38 <_log_handler+0x38>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_log_handler (cdio_log_level_t level, const char message[])
{
  if (level == CDIO_LOG_DEBUG && opts.debug_level < 2)
    return;
  if (level == CDIO_LOG_INFO && opts.debug_level < 1)
    return;
  if (level == CDIO_LOG_WARN && opts.silent)
    return;
  gl_default_cdio_log_handler (level, message);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 9
17 10
18 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbp
mov    %edx,%r12d
lea    0x8(%rsp),%rdx
mov    $0xffffffffffffffff,%rsi
callq  a39 <idna_to_unicode_8z4z+0x1f>
mov    %rax,%rbx
mov    $0x9,%eax
test   %rbx,%rbx
je     a60 <idna_to_unicode_8z4z+0x46>
mov    %r12d,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  a54 <idna_to_unicode_8z4z+0x3a>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  a5e <idna_to_unicode_8z4z+0x44>
mov    %ebp,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
idna_to_unicode_8z4z (const char *input, uint32_t ** output, int flags)
{
  uint32_t *ucs4;
  size_t ucs4len;
  int rc;
  ucs4 = stringprep_utf8_to_ucs4 (input, -1, &ucs4len);
  if (!ucs4)
    return IDNA_ICONV_ERROR;
  rc = idna_to_unicode_4z4z (ucs4, output, flags);
  free (ucs4);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 8
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 11
22 12
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  46 <polynomial_free+0xc>
mov    0x8(%rbx),%rdi
callq  4f <polynomial_free+0x15>
mov    0x10(%rbx),%rdi
callq  58 <polynomial_free+0x1e>
mov    %rbx,%rdi
callq  60 <polynomial_free+0x26>
pop    %rbx
retq   
<<<sep_in_sample>>>
polynomial_free (void *vstate)
{
  polynomial_state_t *state = (polynomial_state_t *) vstate;
  free (state->d);
  free (state->coeff);
  free (state->work);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%r13d
cmp    %esi,%edi
jle    3d61 <move_lines_down+0x56>
lea    -0x1(%rdi),%r12d
movslq %r12d,%rbp
mov    0x0(,%rbp,8),%rsi
movslq %edi,%rbx
mov    0x0(,%rbx,8),%rdi
callq  3d3b <move_lines_down+0x30>
mov    0x0(,%rbp,4),%eax
mov    %eax,0x0(,%rbx,4)
mov    0x0(,%rbp,4),%eax
mov    %eax,0x0(,%rbx,4)
cmp    %r12d,%r13d
jge    3d61 <move_lines_down+0x56>
mov    %r12d,%edi
jmp    3d1c <move_lines_down+0x11>
movslq %r13d,%r13
mov    0x0(,%r13,8),%rax
movb   $0x0,(%rax)
movl   $0x0,0x0(,%r13,4)
movl   $0x0,0x0(,%r13,4)
addl   $0x1,0x0(%rip)        # 3d8e <move_lines_down+0x83>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
move_lines_down(int first, int last)
{
  int i;
  for(i = first; i > last; i--)
  {
    strcpy(lines[i], lines[i-1]);
    LINE_IS_LINKED[i] = LINE_IS_LINKED[i-1];
    totalCharsInLine[i] = totalCharsInLine[i-1];
  }
  lines[last][0] = '\0';
  LINE_IS_LINKED[last] = 0;
  totalCharsInLine[last] = 0;
  totalLines++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 4
20 4
21 4
22 4
23 10
24 10
25 10
26 11
27 12
28 13
29 14
30 14
31 14
32 14
33 14
34 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1acb <java_get_in+0x7>
retq   
<<<sep_in_sample>>>
java_get_in (void)
{
        return java_in;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r12d
callq  b4f <open_temp+0x11>
mov    %r12d,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  b61 <open_temp+0x23>
mov    %eax,%ebx
callq  b68 <open_temp+0x2a>
mov    %rax,%rbp
mov    (%rax),%r12d
test   %ebx,%ebx
js     b79 <open_temp+0x3b>
mov    %ebx,%edi
callq  37d <register_fd>
callq  b7e <open_temp+0x40>
mov    %r12d,0x0(%rbp)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
open_temp (const char *file_name, int flags, mode_t mode)
{
  int fd;
  int saved_errno;
  block_fatal_signals ();
    fd = open (file_name, flags, mode);
  saved_errno = (*__errno_location ());
  if (fd >= 0)
    register_fd (fd);
  unblock_fatal_signals ();
  (*__errno_location ()) = saved_errno;
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 9
20 9
21 10
22 11
23 13
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x160,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %rsp,%rdi
callq  433b <sha384_buffer+0x1c>
mov    %rsp,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  4349 <sha384_buffer+0x2a>
mov    %rbx,%rsi
mov    %rsp,%rdi
callq  4354 <sha384_buffer+0x35>
add    $0x160,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
sha384_buffer (const char *buffer, size_t len, void *resblock)
{
  struct sha512_ctx ctx;
  sha384_init_ctx (&ctx);
  sha512_process_bytes (buffer, len, &ctx);
  return sha384_finish_ctx (&ctx, resblock);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  d2 <help_me_cpp+0xe>
mov    %rax,%rdi
mov    $0x0,%eax
callq  df <help_me_cpp+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
help_me_cpp (void)
{
  printf (gettext ("C++ language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n")
  );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     ef7 <mu_mailer_get_url+0x1f>
mov    $0x1005,%ax
test   %rsi,%rsi
je     ef7 <mu_mailer_get_url+0x1f>
mov    0x18(%rdi),%rax
mov    %rax,(%rsi)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_mailer_get_url (mu_mailer_t mailer, mu_url_t * purl)
{
  if (!mailer)
    return 22;
  if (!purl)
    return (0x1000 +5);
  *purl = mailer->url;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 7
9 8
10 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %rdi,%rdi
je     42db <free_fail_stack_return+0x50>
cmpq   $0x0,(%rdi)
je     42d2 <free_fail_stack_return+0x47>
mov    $0x0,%ebx
mov    $0x0,%r12d
mov    0x10(%rbp),%rax
mov    0x28(%rax,%rbx,1),%rdi
callq  42b6 <free_fail_stack_return+0x2b>
mov    0x10(%rbp),%rax
mov    0x10(%rax,%rbx,1),%rdi
callq  42c4 <free_fail_stack_return+0x39>
add    $0x1,%r12
add    $0x30,%rbx
cmp    %r12,0x0(%rbp)
ja     42a8 <free_fail_stack_return+0x1d>
mov    0x10(%rbp),%rdi
callq  42db <free_fail_stack_return+0x50>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
free_fail_stack_return (struct re_fail_stack_t *fs)
{
  if (fs)
    {
      Idx fs_idx;
      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
 {
   free ((&fs->stack[fs_idx].eps_via_nodes)->elems);
   free (fs->stack[fs_idx].regs);
 }
      free (fs->stack);
    }
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 6
8 6
9 6
10 6
11 8
12 8
13 8
14 9
15 9
16 9
17 6
18 6
19 6
20 6
21 11
22 11
23 14
24 14
25 14
26 14
27 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
lea    0x1(%rdx),%rsi
callq  184 <strob_reopen_if>
mov    %rbp,%rdx
mov    %r12,%rsi
mov    (%rbx),%rdi
callq  5c2 <strob_strncpy+0x24>
mov    %rax,%rdx
mov    (%rbx),%rax
movb   $0x0,(%rax,%rbp,1)
mov    (%rbx),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %ecx,0x10(%rbx)
mov    %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
strob_strncpy(STROB * strb, char *str, size_t n)
{
 char * s;
 strob_reopen_if(strb, n + 1);
 s = strncpy((char*)(strb->str_), str, n);
 strb->str_[n] = '\0';
 strb->length_=strlen((char*)(strb->str_));
 return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x16,%edi
jg     12 <acl_errno_valid+0x12>
cmp    $0x10,%edi
jne    22 <acl_errno_valid+0x22>
nop
jmp    1c <acl_errno_valid+0x1c>
cmp    $0x26,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x5f,%edi
jne    22 <acl_errno_valid+0x22>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 9
16 11
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
mov    -0x10(%rsp),%eax
and    $0x7fff,%eax
jne    1b <rpl_isnanl+0x1b>
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
retq   
cmp    $0x7fff,%eax
jne    36 <rpl_isnanl+0x36>
mov    -0x14(%rsp),%eax
add    $0x80000000,%eax
or     -0x18(%rsp),%eax
setne  %al
movzbl %al,%eax
retq   
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
xor    $0x1,%eax
retq   
<<<sep_in_sample>>>
rpl_isnanl (long double x)
{
  memory_double m;
  unsigned int exponent;
  m.value = x;
  exponent = (m.word[2] >> 0) & ((16384 - (-16381)) | 7);
  if (exponent == 0)
    return (m.word[1] >> 31);
  else if (exponent == ((16384 - (-16381)) | 7))
    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;
  else
    return (m.word[1] >> 31) ^ 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 7
5 7
6 8
7 8
8 8
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 12
18 12
19 12
20 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     541e <gsl_matrix_float_const_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  53f6 <gsl_matrix_float_const_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    5450 <gsl_matrix_float_const_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x2,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_float_const_row (const gsl_matrix_float * m, const size_t i)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  33f <free_value_entry+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
free_value_entry(void *ptr)
{
 struct grecs_value *v = ptr;
 grecs_value_free(v);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x8,0x0(%rip)        # 1640 <close_and_go+0xb>
je     165a <close_and_go+0x25>
mov    0x0(%rip),%rax        # 1649 <close_and_go+0x14>
mov    0x90(%rax),%rdi
test   %rdi,%rdi
je     165a <close_and_go+0x25>
callq  165a <close_and_go+0x25>
callq  165f <close_and_go+0x2a>
test   %al,%al
jne    1668 <close_and_go+0x33>
callq  1668 <close_and_go+0x33>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
close_and_go(void)
{
    if (((flags[((LOCKING) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((LOCKING) % (sizeof(unsigned) * 8)))) != 0) && openfile->lock_filename)
 delete_lockfile(openfile->lock_filename);
    if (!close_buffer())
 finish();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 5
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
callq  1248 <fdDup+0xc>
mov    %eax,%ebp
test   %eax,%eax
js     12c0 <fdDup+0x84>
mov    $0x1a9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    0x0(%rip),%rax        # 1264 <fdDup+0x28>
callq  *0x30(%rax)
mov    %rax,%rbx
mov    %ebp,%esi
mov    %rax,%rdi
callq  1274 <fdDup+0x38>
test   %rbx,%rbx
je     127e <fdDup+0x42>
mov    0x4(%rbx),%edx
jmp    1283 <fdDup+0x47>
mov    $0x0,%edx
or     0x0(%rip),%edx        # 1289 <fdDup+0x4d>
mov    %rbx,%rax
test   $0x40000000,%edx
je     12c5 <fdDup+0x89>
mov    %rbx,%rdi
callq  229 <fdbg>
mov    %rax,%r8
mov    %rbx,%rcx
mov    %r12d,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 12b1 <fdDup+0x75>
mov    $0x0,%eax
callq  12bb <fdDup+0x7f>
mov    %rbx,%rax
jmp    12c5 <fdDup+0x89>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fdDup(int fdno) {
    FD_t fd;
    int nfdno;
    if ((nfdno = dup(fdno)) < 0)
 return ((void *)0);
    fd = fdio->_fdnew("open (fdDup)", "rpmio.c", 425);
    fdSetFdno(fd, nfdno);
if ((_rpmio_debug | (((fd)) ? ((FD_t)((fd)))->flags : 0)) & (0x40000000)) fprintf (stderr, "==> fdDup(%d) fd %p %s\n", fdno, fd, fdbg(fd));
    return fd;
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 9
37 9
38 5
39 10
40 10
41 10
42 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rax
mov    %rcx,%rdx
mov    %r8,%rbx
movl   $0x8,(%rsi)
mov    %rax,%rsi
callq  ea <filenamesTag+0x18>
movl   $0x0,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
filenamesTag(Header h, int_32 * type,
           const void ** data, int_32 * count,
           int * freeData)
{
    *type = 8;
    rpmBuildFileList(h, (const char ***) data, count);
    *freeData = 1;
    *freeData = 0;
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 6
8 8
9 10
10 10
11 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
cmpq   $0x0,0x40(%rdi)
je     69e <redo_cut+0xa3>
mov    0x0(%rip),%r13        # 61a <redo_cut+0x1f>
mov    0x0(%rip),%r12        # 621 <redo_cut+0x26>
movq   $0x0,0x0(%rip)        # 62c <redo_cut+0x31>
movq   $0x0,0x0(%rip)        # 637 <redo_cut+0x3c>
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
callq  643 <redo_cut+0x48>
mov    0x0(%rip),%rbp        # 64a <redo_cut+0x4f>
movb   $0x1,0x58(%rbp)
mov    0x50(%rbx),%rdi
callq  657 <redo_cut+0x5c>
mov    %rax,0x60(%rbp)
mov    0x0(%rip),%rdx        # 662 <redo_cut+0x67>
mov    $0x0,%eax
cmpl   $0x4,0x30(%rbx)
je     671 <redo_cut+0x76>
mov    0x58(%rbx),%rax
mov    %rax,0x68(%rdx)
mov    $0x0,%esi
mov    $0x0,%edi
callq  684 <redo_cut+0x89>
mov    0x0(%rip),%rdi        # 68b <redo_cut+0x90>
callq  690 <redo_cut+0x95>
mov    %r13,0x0(%rip)        # 697 <redo_cut+0x9c>
mov    %r12,0x0(%rip)        # 69e <redo_cut+0xa3>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
redo_cut(undo *u)
{
    if (!u->cutbuffer)
 return;
    filestruct *oldcutbuffer = cutbuffer, *oldcutbottom = cutbottom;
    cutbuffer = cutbottom = ((void *)0);
    goto_line_posx(u->lineno, u->begin);
    openfile->mark_set = 1;
    openfile->mark_begin = fsfromline(u->mark_begin_lineno);
    openfile->mark_begin_x = (u->xflags == (1<<2)) ? 0 : u->mark_begin_x;
    do_cut_text(0, 0);
    free_filestruct(cutbuffer);
    cutbuffer = oldcutbuffer;
    cutbottom = oldcutbottom;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 7
14 7
15 7
16 8
17 8
18 9
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 12
31 12
32 13
33 14
34 15
35 15
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
callq  997 <s_long+0x13>
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    $0x0,%edx
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  9b2 <s_long+0x2e>
mov    %rax,(%rsp)
mov    $0x1,%eax
mov    0x8(%rsp),%rdx
cmpb   $0x0,(%rdx)
jne    9df <s_long+0x5b>
cmpl   $0x22,(%rbx)
je     9df <s_long+0x5b>
mov    $0x8,%edx
mov    %rsp,%rsi
mov    %r12,%rdi
callq  9da <s_long+0x56>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
s_long (struct xdatum *xd, char *str) { long n; long t; char *p; (*__errno_location ()) = 0; n = strtoul (str, &p, 0); if (*p) return 1; if ((*__errno_location ()) == 34 || (t = n) != n) return 1; xd_store (xd, &n, sizeof (n)); return 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
<<<sep_out_sample>>>
mov    %esi,%eax
and    $0x1,%eax
mov    %eax,(%rdi)
mov    %esi,%eax
shr    %al
and    $0x1,%eax
mov    %eax,0x4(%rdi)
and    $0x8,%esi
cmp    $0x1,%sil
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
mov    %eax,0x8(%rdi)
retq   
<<<sep_in_sample>>>
set_track_flags(track_flags_t *p_track_flag, uint8_t i_flag)
{
  p_track_flag->preemphasis = ( i_flag & CDIO_TRACK_FLAG_PRE_EMPHASIS )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->copy_permit = ( i_flag & CDIO_TRACK_FLAG_COPY_PERMITTED )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->channels = ( i_flag & CDIO_TRACK_FLAG_FOUR_CHANNEL_AUDIO )
    ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 6
5 6
6 6
7 5
8 8
9 8
10 8
11 8
12 8
13 7
14 7
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
prepend_void(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3db <gsasl_client_callback_anonymous_get+0xa>
mov    0x58(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_anonymous_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_anonymous : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %esi,%esi
je     14 <make_reference_name+0x14>
callq  f <make_reference_name+0xf>
mov    %rax,%rbx
jmp    24 <make_reference_name+0x24>
callq  19 <make_reference_name+0x19>
mov    %rax,%rdi
callq  21 <make_reference_name+0x21>
mov    %rax,%rbx
mov    $0x2e,%esi
mov    %rbx,%rdi
callq  31 <make_reference_name+0x31>
mov    %rax,%rbp
test   %rax,%rax
je     52 <make_reference_name+0x52>
mov    %rax,%rsi
sub    %rbx,%rsi
add    $0x1,%rsi
mov    %rbx,%rdi
callq  4b <make_reference_name+0x4b>
mov    %rax,%rbx
movb   $0x0,0x0(%rbp)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
make_reference_name (const char *filename, const int dirname_flag)
{
  char *str, *str_end;
  if (dirname_flag) str = xstrdup (filename);
  else str = xstrdup (basename (filename));
  str_end = strrchr (str, '.');
  if (str_end != ((void *)0))
    {
      str = realloc (str, str_end - str + 1);
      *str_end = '\0';
    }
  return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 7
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 13
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
movzwl %di,%edi
callq  249 <swlib_filemodestring+0x8>
repz retq 
<<<sep_in_sample>>>
swlib_filemodestring (mode_t mode, char * str)
{
  mode_string ((unsigned short)mode, str);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    0x18(%rdi),%edi
mov    $0x5304,%esi
mov    $0x0,%eax
callq  234 <audio_play_track_index_linux+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
audio_play_track_index_linux (void *p_user_data,
                              cdio_track_index_t *p_track_index)
{
  const _img_private_t *p_env = p_user_data;
  return ioctl(p_env->gen.fd, 0x5304, p_track_index);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     ad0 <trace+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # ada <trace+0x66>
test   %rdi,%rdi
jne    b0d <trace+0x99>
mov    $0x0,%esi
mov    $0x0,%edi
callq  aee <trace+0x7a>
mov    %rax,0x0(%rip)        # af5 <trace+0x81>
test   %rax,%rax
jne    b0a <trace+0x96>
mov    0x0(%rip),%rax        # b01 <trace+0x8d>
mov    %rax,0x0(%rip)        # b08 <trace+0x94>
jmp    b28 <trace+0xb4>
mov    %rax,%rdi
callq  b12 <trace+0x9e>
mov    $0x1,%edx
mov    $0x2,%esi
mov    %eax,%edi
mov    $0x0,%eax
callq  b28 <trace+0xb4>
callq  b2d <trace+0xb9>
movslq %eax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # b3c <trace+0xc8>
mov    $0x0,%eax
callq  b46 <trace+0xd2>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # b7c <trace+0x108>
callq  b81 <trace+0x10d>
mov    0x0(%rip),%rsi        # b88 <trace+0x114>
mov    $0xa,%edi
callq  b92 <trace+0x11e>
mov    0x0(%rip),%rdi        # b99 <trace+0x125>
callq  b9e <trace+0x12a>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
trace (const char *format, ...)
{
  va_list args;
  static FILE *tracefp = (FILE *)((void *)0);
  if (tracefp == ((void *)0))
    tracefp = fopen("/tmp/bash-trace.log", "a+");
  if (tracefp == ((void *)0))
    tracefp = stderr;
  else
    fcntl (fileno (tracefp), 2, 1);
  fprintf(tracefp, "TRACE: pid %ld: ", (long)getpid());
  __builtin_va_start(args,format);
  vfprintf (tracefp, format, args);
  fprintf (tracefp, "\n");
  __builtin_va_end(args);
  fflush(tracefp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 7
27 7
28 8
29 8
30 8
31 7
32 10
33 10
34 10
35 10
36 10
37 10
38 11
39 11
40 11
41 11
42 11
43 11
44 12
45 12
46 12
47 12
48 12
49 12
50 13
51 13
52 13
53 13
54 14
55 14
56 14
57 16
58 16
59 17
60 17
61 17
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jbe    569 <smtp_reply_has_string+0x4a>
mov    %rdx,%r12
mov    %rcx,%rbp
callq  53c <smtp_reply_has_string+0x1d>
lea    0x4(%rax),%rdi
mov    %r12,%rsi
callq  548 <smtp_reply_has_string+0x29>
test   %rax,%rax
je     55d <smtp_reply_has_string+0x3e>
test   %rbp,%rbp
je     564 <smtp_reply_has_string+0x45>
mov    %rbx,0x0(%rbp)
mov    $0x1,%eax
jmp    569 <smtp_reply_has_string+0x4a>
mov    $0x0,%eax
jmp    569 <smtp_reply_has_string+0x4a>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
smtp_reply_has_string (ANUBIS_SMTP_REPLY reply, size_t index,
         const char *key, size_t *pind)
{
  if (index < reply->line_count)
    if (strstr (smtp_reply_line (reply, index) + 4, key) != ((void *)0))
      {
 if (pind)
   *pind = index;
 return 1;
      }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 11
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 8
19 9
20 9
21 11
22 11
23 9
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <def_realloc_fun+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
def_realloc_fun(void *ptr, size_t size)
{
 return realloc(ptr, size);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    %rsp,%rsi
callq  28b5 <panel_unlink+0x13>
test   %eax,%eax
jne    28d1 <panel_unlink+0x2f>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x8000,%eax
jne    28d1 <panel_unlink+0x2f>
mov    %rbx,%rdi
callq  28d1 <panel_unlink+0x2f>
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
panel_unlink(name)
    char *name;
{
    struct stat statbuf;
    if (xstat(name, &statbuf) == 0 && ((((statbuf.st_mode)) & 0170000) == (0100000)))
 unlink(name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %rdx,%rsi
mov    %rbp,%rdi
callq  0 <compute_hashval>
mov    %rax,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  82 <lookup>
lea    (%rax,%rax,4),%rdx
mov    0x18(%rbx),%rax
lea    (%rax,%rdx,8),%rax
cmpq   $0x0,(%rax)
je     34e <hash_find_entry+0x53>
mov    0x18(%rax),%rax
mov    %rax,0x0(%r13)
mov    $0x0,%eax
jmp    353 <hash_find_entry+0x58>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
hash_find_entry (hash_table *htab, const void *key, size_t keylen,
                 void **result)
{
  hash_entry *table = htab->table;
  size_t idx = lookup (htab, key, keylen, compute_hashval (key, keylen));
  if (table[idx].used == 0)
    return -1;
  *result = table[idx].data;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 8
24 8
25 9
26 9
27 7
28 10
29 10
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,0xc(%rsp)
lea    0xc(%rsp),%rsi
callq  44c <buildargv+0x16>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
buildargv (const char * string)
{
  int argc = 0;
  return buildargv_argc (string, &argc);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
movzbl (%rdi),%eax
cmp    $0x5b,%al
je     a29 <rec_sex_lex_extract_name+0x2e>
cmp    $0x2e,%al
je     a29 <rec_sex_lex_extract_name+0x2e>
test   %al,%al
je     a32 <rec_sex_lex_extract_name+0x37>
mov    %rdi,%rdx
add    $0x1,%rdx
movzbl (%rdx),%eax
cmp    $0x2e,%al
je     a35 <rec_sex_lex_extract_name+0x3a>
cmp    $0x5b,%al
je     a35 <rec_sex_lex_extract_name+0x3a>
test   %al,%al
jne    a14 <rec_sex_lex_extract_name+0x19>
jmp    a35 <rec_sex_lex_extract_name+0x3a>
mov    %rbx,%rdx
nopl   0x0(%rax)
jmp    a35 <rec_sex_lex_extract_name+0x3a>
mov    %rdi,%rdx
sub    %rbx,%rdx
mov    %rdx,%r12
lea    0x1(%rdx),%rdi
callq  a44 <rec_sex_lex_extract_name+0x49>
mov    %rax,%rbp
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  a55 <rec_sex_lex_extract_name+0x5a>
movb   $0x0,0x0(%rbp,%r12,1)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rec_sex_lex_extract_name (char *str)
{
  size_t size;
  char *res;
  char *p;
  p = str;
  while ((*p != '[') && (*p != '.') && (*p != 0))
    {
      p++;
    }
  size = p - str;
  res = malloc (size + 1);
  memcpy (res, str, size);
  res[size] = 0;
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 6
13 9
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 6
23 6
24 6
25 6
26 11
27 11
28 12
29 12
30 12
31 13
32 13
33 13
34 13
35 14
36 16
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     345 <osip_call_info_free+0x63>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     327 <osip_call_info_free+0x45>
mov    0x0(%rip),%rax        # 2fa <osip_call_info_free+0x18>
test   %rax,%rax
je     303 <osip_call_info_free+0x21>
callq  *%rax
jmp    327 <osip_call_info_free+0x45>
callq  308 <osip_call_info_free+0x26>
nopl   0x0(%rax,%rax,1)
jmp    327 <osip_call_info_free+0x45>
mov    %rbx,%rdi
callq  *%rax
jmp    345 <osip_call_info_free+0x63>
mov    %rbx,%rdi
nopl   0x0(%rax)
callq  325 <osip_call_info_free+0x43>
jmp    345 <osip_call_info_free+0x63>
lea    0x8(%rbx),%rdi
callq  330 <osip_call_info_free+0x4e>
movq   $0x0,(%rbx)
mov    0x0(%rip),%rax        # 33e <osip_call_info_free+0x5c>
test   %rax,%rax
jne    312 <osip_call_info_free+0x30>
jmp    319 <osip_call_info_free+0x37>
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_call_info_free (osip_call_info_t * call_info)
{
  if (call_info == ((void *)0))
    return;
  { if (call_info->element!=((void *)0)) { if (osip_free_func) osip_free_func(call_info->element); else free(call_info->element);} };
  osip_uri_param_freelist(&call_info->gen_params);
  call_info->element = ((void *)0);
  { if (call_info!=((void *)0)) { if (osip_free_func) osip_free_func(call_info); else free(call_info);} };
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 6
24 6
25 7
26 8
27 8
28 8
29 8
30 9
31 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     190 <a_word_hash_2+0x2f>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    171 <a_word_hash_2+0x10>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
a_word_hash_2 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct a_word const *) key)->str)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  46e <_rl_start_using_history+0x9>
mov    0x0(%rip),%rdi        # 475 <_rl_start_using_history+0x10>
test   %rdi,%rdi
je     47f <_rl_start_using_history+0x1a>
callq  47f <_rl_start_using_history+0x1a>
movq   $0x0,0x0(%rip)        # 48a <_rl_start_using_history+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_start_using_history ()
{
  using_history ();
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rax
mov    $0xc0,%edx
mov    $0x1,%esi
callq  *(%rax)
mov    %rax,0x1f0(%rbx)
movq   $0x0,(%rax)
mov    $0x0,%edx
movq   $0x0,0x60(%rax)
movq   $0x0,0x40(%rax)
movq   $0x0,0xa0(%rax)
movq   $0x0,0x80(%rax)
add    $0x1,%edx
add    $0x8,%rax
cmp    $0x4,%edx
jne    1650 <jinit_huff_encoder+0x27>
pop    %rbx
retq   
<<<sep_in_sample>>>
jinit_huff_encoder (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;
  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 1,
    ((size_t) sizeof(huff_entropy_encoder)));
  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
  entropy->pub.start_pass = start_pass_huff;
  for (i = 0; i < 4; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = ((void *)0);
    entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = ((void *)0);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 5
5 5
6 5
7 8
8 9
9 10
10 11
11 11
12 12
13 12
14 10
15 10
16 10
17 10
18 14
19 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x18(%rsi),%rdi
callq  319 <lm_init+0x15>
mov    0x20(%rbx),%rdi
callq  322 <lm_init+0x1e>
mov    0x50(%rbp),%rax
movq   $0x0,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
lm_init(const void *vtrust_state, void *vstate)
{
  const gsl_multifit_nlinear_trust_state *trust_state =
    (const gsl_multifit_nlinear_trust_state *) vtrust_state;
  lm_state_t *state = (lm_state_t *) vstate;
  gsl_vector_set_zero(state->vel);
  gsl_vector_set_zero(state->acc);
  *(trust_state->avratio) = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 7
9 7
10 8
11 8
12 10
13 10
14 10
15 10
16 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r9
lea    -0x1(%rsi),%rcx
mov    %r8,(%rsp)
mov    %rdx,%r8
mov    $0x0,%edx
callq  3fd <gsl_sum_levin_utrunc_accel+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sum_levin_utrunc_accel (const double *array,
                            const size_t array_size,
                            gsl_sum_levin_utrunc_workspace * w,
                            double *sum_accel, double *abserr_trunc)
{
  return gsl_sum_levin_utrunc_minmax (array, array_size,
                                      0, array_size - 1,
                                      w, sum_accel, abserr_trunc);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 9
9 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r8
mov    %rsi,%r14
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
mov    0x50(%r8),%eax
test   %eax,%eax
jle    617 <pies_url_get_arg+0x73>
mov    0x58(%r8),%rbx
lea    -0x1(%rax),%eax
lea    0x8(%rbx,%rax,8),%r13
mov    (%rbx),%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  5ee <pies_url_get_arg+0x4a>
cmp    %r12,%rax
jne    60c <pies_url_get_arg+0x68>
mov    %r12,%rdx
mov    %r14,%rsi
mov    %rbp,%rdi
callq  601 <pies_url_get_arg+0x5d>
test   %eax,%eax
jne    60c <pies_url_get_arg+0x68>
lea    0x1(%rbp,%r12,1),%rax
jmp    623 <pies_url_get_arg+0x7f>
add    $0x8,%rbx
cmp    %r13,%rbx
jne    5de <pies_url_get_arg+0x3a>
jmp    61e <pies_url_get_arg+0x7a>
mov    $0x0,%eax
jmp    623 <pies_url_get_arg+0x7f>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
pies_url_get_arg (struct pies_url *url, const char *argname)
{
  int i;
  size_t arglen = strlen (argname);
  for (i = 0; i < url->argc; i++)
    {
      size_t len = strcspn (url->argv[i], "=");
      if (len == arglen && memcmp (url->argv[i], argname, arglen) == 0)
 return url->argv[i] + len + 1;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 5
36 5
37 5
38 11
39 11
40 11
41 12
42 12
43 12
44 12
45 12
46 12
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x18,%esi
mov    $0x1,%edi
callq  13 <_gsasl_login_server_start+0x13>
mov    $0x7,%edx
test   %rax,%rax
je     22 <_gsasl_login_server_start+0x22>
mov    %rax,(%rbx)
mov    $0x0,%dl
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_gsasl_login_server_start (Gsasl_session * sctx, void **mech_data)
{
  struct _Gsasl_login_server_state *state;
  state = calloc (1, sizeof (*state));
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 5
8 5
9 7
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    %rsi,0x8(%rsp)
test   %rsi,%rsi
jne    e8b <mu_mailer_create+0x1d>
lea    0x8(%rsp),%rdi
callq  e8b <mu_mailer_create+0x1d>
mov    0x8(%rsp),%rsi
lea    0x18(%rsp),%rdi
callq  e9a <mu_mailer_create+0x2c>
mov    %eax,%edx
test   %edx,%edx
jne    ed1 <mu_mailer_create+0x63>
mov    0x18(%rsp),%rdi
callq  eaa <mu_mailer_create+0x3c>
mov    %eax,%ebx
test   %eax,%eax
jne    ec3 <mu_mailer_create+0x55>
mov    0x18(%rsp),%rsi
mov    %rbp,%rdi
callq  ebd <mu_mailer_create+0x4f>
mov    %eax,%ebx
test   %eax,%eax
je     ed1 <mu_mailer_create+0x63>
lea    0x18(%rsp),%rdi
callq  ecd <mu_mailer_create+0x5f>
mov    %ebx,%eax
jmp    ed1 <mu_mailer_create+0x63>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_mailer_create (mu_mailer_t * pmailer, const char *name)
{
  int status;
  mu_url_t url;
  if (name == ((void *)0))
    mu_mailer_get_url_default (&name);
  status = mu_url_create (&url, name);
  if (status)
    return status;
  status = mu_url_parse (url);
  if (status == 0)
    status = mu_mailer_create_from_url (pmailer, url);
  if (status)
    mu_url_destroy (&url);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 12
22 12
23 12
24 12
25 13
26 13
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     1360 <gsl_vector_float_div+0x29>
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1359 <gsl_vector_float_div+0x22>
mov    $0x13,%eax
jmp    13bc <gsl_vector_float_div+0x85>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     13b0 <gsl_vector_float_div+0x79>
shl    $0x2,%rbx
shl    $0x2,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
movss  (%r8),%xmm0
divss  (%r9,%rcx,1),%xmm0
movss  %xmm0,(%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    1384 <gsl_vector_float_div+0x4d>
jmp    13b7 <gsl_vector_float_div+0x80>
mov    $0x0,%eax
jmp    13bc <gsl_vector_float_div+0x85>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_float_div (gsl_vector_float * a, const gsl_vector_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 13
28 13
29 13
30 13
31 13
32 13
33 17
34 17
35 17
36 19
37 19
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x58,%rsp
mov    %rsi,0x30(%rsp)
mov    %rdx,0x38(%rsp)
mov    (%rdi),%rax
mov    %rax,%rcx
mov    %rax,0x40(%rsp)
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%rdx
mov    0x18(%rdi),%rax
fldt   (%rax)
fstpt  0x10(%rsp)
test   %rcx,%rcx
je     318 <gsl_matrix_long_double_max_index+0xcc>
shl    $0x4,%rdx
mov    %rdx,0x48(%rsp)
mov    %rax,0x28(%rsp)
mov    $0x0,%r13d
mov    $0x0,%r14d
mov    $0x0,%r15d
jmp    307 <gsl_matrix_long_double_max_index+0xbb>
fldt   0x0(%rbp)
fldt   0x10(%rsp)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jbe    2c7 <gsl_matrix_long_double_max_index+0x7b>
mov    %rbx,%r14
mov    %r13,%r15
fld    %st(0)
fstpt  0x10(%rsp)
fstpt  (%rsp)
callq  2cf <gsl_matrix_long_double_max_index+0x83>
test   %eax,%eax
je     2e5 <gsl_matrix_long_double_max_index+0x99>
mov    0x30(%rsp),%rax
mov    %r13,(%rax)
mov    0x38(%rsp),%rax
mov    %rbx,(%rax)
jmp    334 <gsl_matrix_long_double_max_index+0xe8>
add    $0x1,%rbx
add    $0x10,%rbp
cmp    %r12,%rbx
jne    2ac <gsl_matrix_long_double_max_index+0x60>
add    $0x1,%r13
mov    0x48(%rsp),%rax
add    %rax,0x28(%rsp)
cmp    0x40(%rsp),%r13
je     324 <gsl_matrix_long_double_max_index+0xd8>
test   %r12,%r12
je     2f2 <gsl_matrix_long_double_max_index+0xa6>
mov    0x28(%rsp),%rbp
mov    $0x0,%ebx
jmp    2ac <gsl_matrix_long_double_max_index+0x60>
mov    $0x0,%r14d
mov    $0x0,%r15d
mov    0x30(%rsp),%rax
mov    %r15,(%rax)
mov    0x38(%rsp),%rax
mov    %r14,(%rax)
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_max_index (const gsl_matrix_long_double * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long double max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long double x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            {
              *imax_out = i;
              *jmax_out = j;
              return;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 4
14 5
15 6
16 6
17 6
18 9
19 9
20 9
21 9
22 9
23 9
24 7
25 7
26 7
27 13
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 20
38 20
39 20
40 20
41 22
42 22
43 23
44 23
45 24
46 11
47 11
48 11
49 11
50 9
51 9
52 9
53 9
54 9
55 11
56 11
57 11
58 11
59 11
60 7
61 7
62 28
63 28
64 29
65 29
66 30
67 30
68 30
69 30
70 30
71 30
72 30
73 30
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # 6eeb <us_ok_hdy+0xf>
movl   $0x3,0x0(%rip)        # 6ef5 <us_ok_hdy+0x19>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  6f01 <us_ok_hdy+0x25>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
us_ok_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_OK";
  observe_us_hdy = 3;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 10
3 11
4 12
5 12
6 12
7 13
8 13
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
dos_format_void(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x40(%rdi),%rdi
test   %rdi,%rdi
je     730 <dicod_close_database+0x2a>
mov    0x50(%rax),%rax
mov    0x10(%rax),%rax
mov    0x28(%rax),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
je     73a <dicod_close_database+0x34>
sub    $0x8,%rsp
callq  *%rdx
jmp    736 <dicod_close_database+0x30>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dicod_close_database(dicod_database_t *dp)
{
    int rc = 0;
    if (dp->mod_handle) {
 dicod_module_instance_t *inst = dp->instance;
 if (inst->module->dico_close)
     rc = inst->module->dico_close(dp->mod_handle);
    }
    return rc;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 3
9 6
10 6
11 2
12 7
13 7
14 3
15 3
16 10
17 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
test   %rdx,%rdx
je     444 <gsl_stats_ushort_absdev_m+0x3e>
add    %rsi,%rsi
mov    $0x0,%eax
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 423 <gsl_stats_ushort_absdev_m+0x1d>
movzwl (%rdi),%ecx
cvtsi2sd %ecx,%xmm2
subsd  %xmm0,%xmm2
andpd  %xmm3,%xmm2
addsd  %xmm2,%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
jne    423 <gsl_stats_ushort_absdev_m+0x1d>
jmp    444 <gsl_stats_ushort_absdev_m+0x3e>
test   %rdx,%rdx
js     452 <gsl_stats_ushort_absdev_m+0x4c>
cvtsi2sd %rdx,%xmm0
xchg   %ax,%ax
jmp    467 <gsl_stats_ushort_absdev_m+0x61>
mov    %rdx,%rax
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_ushort_absdev_m (const unsigned short data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
4 10
5 8
6 6
7 10
8 10
9 10
10 10
11 10
12 11
13 8
14 8
15 8
16 8
17 8
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %ecx,%r8d
mov    0x1020(%rdi),%rdi
mov    $0x1,%ecx
callq  12e2 <read_audio_sectors_linux+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
read_audio_sectors_linux (void *p_user_data, void *p_buf, lsn_t i_lsn,
                           uint32_t i_blocks)
{
  _img_private_t *p_env = p_user_data;
  return mmc_read_sectors( p_env->gen.cdio, p_buf, i_lsn,
                           CDIO_MMC_READ_TYPE_CDDA, i_blocks);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
jbe    20d <nabs+0x16>
movsd  0x0(%rip),%xmm1        # 209 <nabs+0x12>
xorpd  %xmm1,%xmm0
repz retq 
<<<sep_in_sample>>>
nabs (double a)
{
  return (a < 0) ? -a : a;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     d28 <gsl_matrix_isnull+0x5c>
lea    0x0(,%rax,8),%r10
mov    $0x0,%esi
mov    $0x0,%r9d
xorpd  %xmm0,%xmm0
movapd %xmm0,%xmm1
jmp    d21 <gsl_matrix_isnull+0x55>
mov    $0x0,%eax
mov    %rsi,%rdx
add    0x18(%rdi),%rdx
ucomisd (%rdx,%rax,8),%xmm0
jp     d31 <gsl_matrix_isnull+0x65>
ucomisd (%rdx,%rax,8),%xmm1
je     d3d <gsl_matrix_isnull+0x71>
jmp    d31 <gsl_matrix_isnull+0x65>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     d37 <gsl_matrix_isnull+0x6b>
test   %rcx,%rcx
jne    cf9 <gsl_matrix_isnull+0x2d>
jmp    d15 <gsl_matrix_isnull+0x49>
mov    $0x1,%eax
nopl   (%rax)
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rcx,%rax
jne    d05 <gsl_matrix_isnull+0x39>
jmp    d15 <gsl_matrix_isnull+0x49>
<<<sep_in_sample>>>
gsl_matrix_isnull (const gsl_matrix * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 20
28 20
29 20
30 15
31 15
32 20
33 20
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
mov    (%rdi),%rbx
mov    0x18(%rbx),%rax
cmp    %rax,0x20(%rbx)
jne    2cb <x_obstack_1grow+0x24>
mov    $0x1,%esi
mov    %rbx,%rdi
callq  2cb <x_obstack_1grow+0x24>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
mov    %r12b,(%rax)
addq   $0x1,0x8(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
x_obstack_1grow (struct xheader *xhdr, char c)
{
  __extension__ ({ struct obstack *__o = (xhdr->stk); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < 1) _obstack_newchunk (__o, 1); ((void) (*((__o)->next_free)++ = (c))); });
  xhdr->size++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 4
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  60a <gsl_vector_char_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_char_fwrite (FILE * stream, const gsl_vector_char * v)
{
  int status = gsl_block_char_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%r12d
mov    %rsi,%r13
callq  aaa <findlock+0x15>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # ab4 <findlock+0x1f>
mov    0x170(%rax),%rax
mov    0x38(%rax),%r8
mov    %r8,0x8(%rsp)
mov    $0x0,%eax
test   %r8,%r8
je     b55 <findlock+0xc0>
mov    %rbx,%rdx
mov    $0x1,%esi
mov    %rsp,%rdi
callq  ae2 <findlock+0x4d>
mov    %rax,%rbp
mov    $0x0,%eax
test   %rbp,%rbp
je     b55 <findlock+0xc0>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x1,%esi
callq  b00 <findlock+0x6b>
test   %rax,%rax
je     b2c <findlock+0x97>
mov    0x0(%rip),%rax        # b0c <findlock+0x77>
mov    0xd0(%rax),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  b25 <findlock+0x90>
mov    $0x2,%eax
jmp    b55 <findlock+0xc0>
mov    0x8(%rbp),%rax
mov    (%rax),%rax
mov    0x8(%rax),%rax
mov    %rax,0x0(%r13)
mov    $0x1,%eax
test   %r12b,%r12b
je     b55 <findlock+0xc0>
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  b50 <findlock+0xbb>
mov    $0x1,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
findlock (_Bool delete, struct delta **target)
{
  struct rcslock const *rl;
  struct link box, *found;
  char const *me = getcaller ();
  if (! (box.next = ((top->repository. r)-> locks))
      || ! (found = lock_memq (&box, 1, me)))
    return 0;
  if (lock_memq (found->next, 1, me))
    {
      generic_error ((top->repository. filename), "multiple revisions locked by %s; please specify one", me);
      return 2;
    }
  rl = found->next->entry;
  *target = rl->delta;
  if (delete)
    lock_drop (&box, found);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 6
11 6
12 6
13 6
14 8
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 8
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 11
32 11
33 11
34 11
35 11
36 11
37 12
38 12
39 14
40 15
41 15
42 15
43 18
44 16
45 16
46 17
47 17
48 17
49 18
50 19
51 19
52 19
53 19
54 19
55 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x431bde83,%edx
mov    %edi,%eax
imul   %edx
sar    $0x12,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
test   %edx,%edx
jle    1b9 <osip_usleep+0x2d>
movslq %edx,%rdx
mov    %rdx,(%rsp)
movq   $0x0,0x8(%rsp)
jmp    1c9 <osip_usleep+0x3d>
movq   $0x0,(%rsp)
movslq %edi,%rdi
mov    %rdi,0x8(%rsp)
mov    %rsp,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e5 <osip_usleep+0x59>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
osip_usleep (int useconds)
{
  struct timeval delay;
  int sec;
  sec = (int) useconds / 1000000;
  if (sec > 0) {
    delay.tv_sec = sec;
    delay.tv_usec = 0;
  }
  else {
    delay.tv_sec = 0;
    delay.tv_usec = useconds;
  }
  select (0, 0, 0, 0, &delay);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 11
16 12
17 12
18 14
19 14
20 14
21 14
22 14
23 14
24 15
25 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x40(%rax),%rdi
callq  17c <multivalued_entry_add_couple>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
add_needed_resource (a2ps_job * job, const char * key, const char * value)
{
  multivalued_entry_add_couple (job->status->needed_resources, key, value);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 525 <rl_reset_after_signal+0xb>
test   %rax,%rax
je     532 <rl_reset_after_signal+0x18>
mov    0x0(%rip),%edi        # 530 <rl_reset_after_signal+0x16>
callq  *%rax
callq  537 <rl_reset_after_signal+0x1d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_reset_after_signal ()
{
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
  rl_set_signals ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 6
9 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rbx
mov    $0x90,%edi
callq  16 <_a2ps_file_job_new+0x16>
mov    %r12,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movb   $0x0,0x20(%rax)
mov    (%rbx),%rdx
mov    %rdx,0x28(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,0x30(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x38(%rax)
mov    0x18(%rbx),%rdx
mov    %rdx,0x40(%rax)
mov    0x20(%rbx),%rdx
mov    %rdx,0x48(%rax)
mov    0x28(%rbx),%rdx
mov    %rdx,0x50(%rax)
mov    0x30(%rbx),%rdx
mov    %rdx,0x58(%rax)
movb   $0x1,0x60(%rax)
movb   $0x0,0x61(%rax)
movl   $0x0,0x64(%rax)
movl   $0x0,0x78(%rax)
movl   $0x0,0x68(%rax)
movl   $0x0,0x6c(%rax)
movl   $0x0,0x74(%rax)
movl   $0x0,0x70(%rax)
movl   $0x1,0x80(%rax)
movl   $0x0,0x84(%rax)
movl   $0x1,0x88(%rax)
mov    %ebp,0x7c(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_a2ps_file_job_new (unsigned char *name, int num, struct tm *run_tm)
{
  fjob_t *(res) = ((fjob_t *) xmalloc (sizeof (fjob_t) * (1)));
  res->name = name;
  res->delegation_tmpname = ((void *)0);
  res->stdin_tmpname = ((void *)0);
  res->type = ((void *)0);
  res->is_toc = 0;
  res->mod_tm = *run_tm;
  res->printable = 1;
  res->is_stdin = 0;
  res->first_sheet = 0;
  res->sheets = 0;
  res->last_sheet = 0;
  res->first_page = 0;
  res->pages = 0;
  res->last_page = 0;
  res->top_line = 1;
  res->top_page = 0;
  res->lines = 1;
  res->num = num;
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 5
11 6
12 7
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 10
29 11
30 12
31 13
32 14
33 15
34 16
35 17
36 18
37 19
38 20
39 21
40 23
41 23
42 23
43 23
<<<sep_out_sample>>>
movzbl %dil,%edi
mov    0x0(,%rdi,4),%eax
retq   
<<<sep_in_sample>>>
pch_says_nonexistent (_Bool which)
{
  return p_says_nonexistent[which];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 269 <nextlinecmp+0x7>
movslq (%rsi),%rdx
lea    (%rax,%rdx,8),%rsi
movslq (%rdi),%rdx
lea    (%rax,%rdx,8),%rdi
callq  1fc <linecmp>
repz retq 
<<<sep_in_sample>>>
nextlinecmp(int *s1, int *s2)
{
  return linecmp(nextline + *s1, nextline + *s2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
mov    (%rdi),%r10
cmp    0x8(%rdi),%r10
je     f84 <gsl_matrix_complex_float_transpose+0x9b>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f13 <gsl_matrix_complex_float_transpose+0x2a>
mov    $0x14,%eax
jmpq   f9d <gsl_matrix_complex_float_transpose+0xb4>
mov    %r11,%r9
lea    0x1(%r9),%r11
cmp    %r10,%r11
je     f91 <gsl_matrix_complex_float_transpose+0xa8>
mov    %r11,%rdx
jmp    f7d <gsl_matrix_complex_float_transpose+0x94>
mov    0x10(%rdi),%rcx
mov    0x18(%rdi),%r8
mov    %r9,%rsi
imul   %rcx,%rsi
add    %rdx,%rsi
lea    (%rax,%rsi,2),%rsi
lea    (%r8,%rsi,4),%rsi
movss  (%rsi),%xmm1
imul   %rdx,%rcx
add    %r9,%rcx
lea    (%rax,%rcx,2),%rcx
movss  (%r8,%rcx,4),%xmm0
movss  %xmm0,(%rsi)
mov    0x18(%rdi),%rsi
movss  %xmm1,(%rsi,%rcx,4)
add    $0x1,%rax
cmp    $0x2,%rax
jne    f2e <gsl_matrix_complex_float_transpose+0x45>
add    $0x1,%rdx
cmp    %r10,%rdx
je     f1d <gsl_matrix_complex_float_transpose+0x34>
mov    $0x0,%eax
jmp    f2e <gsl_matrix_complex_float_transpose+0x45>
test   %r10,%r10
je     f97 <gsl_matrix_complex_float_transpose+0xae>
mov    $0x0,%r9d
jmp    f20 <gsl_matrix_complex_float_transpose+0x37>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_transpose (gsl_matrix_complex_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 2; k++)
            {
              size_t e1 = (i * m->tda + j) * 2 + k ;
              size_t e2 = (j * m->tda + i) * 2 + k ;
              {
                float tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 10
13 12
14 12
15 12
16 12
17 12
18 16
19 19
20 16
21 16
22 16
23 16
24 19
25 19
26 17
27 17
28 17
29 20
30 20
31 21
32 21
33 14
34 14
35 14
36 12
37 12
38 12
39 10
40 10
41 10
42 10
43 10
44 10
45 26
46 26
47 26
48 26
49 27
50 27
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    %ecx,%edx
mov    %r8d,%ecx
mov    $0x38,%esi
callq  321 <_alur>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  876 <_jcc>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_jcr(jit_state_t *_jit,
     jit_int32_t code, jit_word_t i0, jit_int32_t r0, jit_int32_t r1)
{
    _alur(_jit, 7 << 3, r0, r1);
    _jcc(_jit, code, i0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  d5e <swicat_make_options_file+0xe>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swicat_make_options_file(STROB * buf)
{
 strob_strcpy(buf, "");
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x8(%rdi),%rdx
lea    (%rax,%rdx,8),%rdx
cmp    %rdx,%rax
jae    351 <hash_delete_items+0x20>
movq   $0x0,(%rax)
add    $0x8,%rax
cmp    %rax,%rdx
ja     341 <hash_delete_items+0x10>
movq   $0x0,0x18(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x28(%rdi)
movl   $0x0,0x30(%rdi)
retq   
<<<sep_in_sample>>>
hash_delete_items (struct hash_table_s* ht)
{
  void **vec = ht->ht_vec;
  void **end = &vec[ht->ht_size];
  for (; vec < end; vec++)
    *vec = 0;
  ht->ht_fill = 0;
  ht->ht_collisions = 0;
  ht->ht_lookups = 0;
  ht->ht_rehashes = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 6
7 5
8 5
9 5
10 7
11 8
12 9
13 10
14 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # b68 <gsl_matrix_ulong_ptr+0xb>
je     bb5 <gsl_matrix_ulong_ptr+0x58>
cmp    %rsi,(%rdi)
ja     b8f <gsl_matrix_ulong_ptr+0x32>
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b88 <gsl_matrix_ulong_ptr+0x2b>
mov    $0x0,%eax
jmp    bc5 <gsl_matrix_ulong_ptr+0x68>
cmp    %rdx,0x8(%rdi)
ja     bb5 <gsl_matrix_ulong_ptr+0x58>
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bae <gsl_matrix_ulong_ptr+0x51>
mov    $0x0,%eax
jmp    bc5 <gsl_matrix_ulong_ptr+0x68>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
mov    0x18(%rdi),%rax
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_ulong_ptr(gsl_matrix_ulong * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_ulong.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_ulong.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (unsigned long *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 9
14 9
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 14
23 14
24 14
25 14
26 15
27 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  7b3 <gsl_sf_bessel_Kn+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     7d9 <gsl_sf_bessel_Kn+0x32>
mov    %eax,%ecx
mov    $0xef,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7d2 <gsl_sf_bessel_Kn+0x2b>
movsd  (%rsp),%xmm0
jmp    7d9 <gsl_sf_bessel_Kn+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Kn(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Kn_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Kn_e(n, x, &result)", "bessel_Kn.c", 239, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  1a3 <gsl_stats_float_absdev+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1b1 <gsl_stats_float_absdev+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_float_absdev (const float data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_float_mean(data, stride, n);
  return gsl_stats_float_absdev_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmalloc+0x9>
test   %rax,%rax
jne    22 <xmalloc+0x22>
mov    $0x0,%edi
callq  18 <xmalloc+0x18>
mov    $0x1,%edi
callq  22 <xmalloc+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xmalloc (size_t length)
{
  void * p;
  p = (void *) malloc (length);
  if (p == (void *) ((void *)0))
    {
      perror ("out of memory");
      exit (1);
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 8
8 8
9 11
10 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%esi        # 34e <put_paragraph+0xf>
mov    $0x0,%edi
callq  2d2 <put_line>
mov    0x0(%rip),%rbx        # 35f <put_paragraph+0x20>
cmp    %rbp,%rbx
je     37b <put_paragraph+0x3c>
mov    0x0(%rip),%esi        # 36a <put_paragraph+0x2b>
mov    %rbx,%rdi
callq  2d2 <put_line>
mov    0x18(%rbx),%rbx
cmp    %rbx,%rbp
jne    364 <put_paragraph+0x25>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
put_paragraph (register WORD *finish)
{
  register WORD *w;
  put_line (words, first_indent);
  for (w = words->next_break; w != finish; w = w->next_break)
    put_line (w, other_indent);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 5
15 5
16 5
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  9e5 <mu_stream_get_transport+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_stream_get_transport (mu_stream_t stream, mu_transport_t *pt)
{
  return mu_stream_get_transport2 (stream, pt, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
jns    1a <rpl_fclose+0x1a>
mov    %rbx,%rdi
callq  18 <rpl_fclose+0x18>
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  22 <rpl_fclose+0x22>
test   %eax,%eax
je     45 <rpl_fclose+0x45>
mov    %rbx,%rdi
callq  2e <rpl_fclose+0x2e>
mov    $0x1,%edx
mov    $0x0,%esi
mov    %eax,%edi
callq  3f <rpl_fclose+0x3f>
cmp    $0xffffffffffffffff,%rax
je     74 <rpl_fclose+0x74>
mov    %rbx,%rdi
callq  4d <rpl_fclose+0x4d>
test   %eax,%eax
je     74 <rpl_fclose+0x74>
callq  56 <rpl_fclose+0x56>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    %rbx,%rdi
callq  64 <rpl_fclose+0x64>
test   %r12d,%r12d
je     7c <rpl_fclose+0x7c>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  7c <rpl_fclose+0x7c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 7
8 8
9 8
10 8
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 15
35 16
36 16
37 12
38 12
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffff,%ecx
callq  3da5 <gsl_fft_complex_radix2_dif_forward+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_complex_radix2_dif_forward (gsl_complex_packed_array data,
                                              const size_t stride,
                                              const size_t n)
{
  gsl_fft_direction sign = gsl_fft_forward;
  int status = gsl_fft_complex_radix2_dif_transform (data, stride, n, sign);
  return status;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
callq  1451 <gsl_matrix_calloc+0xf>
mov    %rax,%rbx
test   %rax,%rax
je     1495 <gsl_matrix_calloc+0x53>
imul   %r12,%rbp
lea    0x0(,%rbp,8),%rdx
mov    0x18(%rax),%rdi
mov    $0x0,%esi
callq  1473 <gsl_matrix_calloc+0x31>
test   %rbp,%rbp
je     149c <gsl_matrix_calloc+0x5a>
mov    $0x0,%edx
xorpd  %xmm0,%xmm0
mov    0x18(%rbx),%rcx
movsd  %xmm0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbp,%rdx
jne    1481 <gsl_matrix_calloc+0x3f>
jmp    14a2 <gsl_matrix_calloc+0x60>
mov    $0x0,%eax
jmp    14a5 <gsl_matrix_calloc+0x63>
mov    %rbx,%rax
nop
jmp    14a5 <gsl_matrix_calloc+0x63>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_matrix_calloc (const size_t n1, const size_t n2)
{
  size_t i;
  gsl_matrix * m = gsl_matrix_alloc (n1, n2);
  if (m == 0)
    return 0;
  memset(m->data, 0, 1 * n1 * n2 * sizeof(double));
  for (i = 0; i < 1 * n1 * n2; i++)
    {
      m->data[i] = 0;
    }
  return m;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 10
19 10
20 10
21 8
22 8
23 8
24 8
25 6
26 6
27 12
28 12
29 12
30 12
31 13
32 13
33 13
34 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     19c <smtp_reply_free+0x22>
mov    (%rdi),%rdi
callq  18b <smtp_reply_free+0x11>
mov    0x28(%rbx),%rdi
callq  194 <smtp_reply_free+0x1a>
mov    %rbx,%rdi
callq  19c <smtp_reply_free+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
smtp_reply_free (ANUBIS_SMTP_REPLY reply)
{
  if (reply)
    {
      free (reply->buffer);
      free (reply->line_vec);
      free (reply);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 7
10 7
11 9
12 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r12
mov    %edx,%r14d
test   %rsi,%rsi
cmove  0x0(%rip),%r12        # 2b4 <__gmpz_inp_str+0x1c>
mov    $0x0,%ebx
mov    %r12,%rdi
callq  2c1 <__gmpz_inp_str+0x29>
mov    %eax,%ebp
add    $0x1,%rbx
callq  2cc <__gmpz_inp_str+0x34>
movslq %ebp,%rdx
mov    (%rax),%rax
testb  $0x20,0x1(%rax,%rdx,2)
jne    2b9 <__gmpz_inp_str+0x21>
mov    %rbx,%r8
mov    %ebp,%ecx
mov    %r14d,%edx
mov    %r12,%rsi
mov    %r13,%rdi
callq  2ec <__gmpz_inp_str+0x54>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
__gmpz_inp_str (mpz_ptr x, FILE *stream, int base)
{
  int c;
  size_t nread;
  if (stream == 0)
    stream = stdin;
  nread = 0;
  do
    {
      c = _IO_getc (stream);
      nread++;
    }
  while (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace));
  return __gmpz_inp_str_nowhite (x, stream, base, c, nread);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 7
12 10
13 10
14 10
15 11
16 13
17 13
18 13
19 13
20 13
21 14
22 14
23 14
24 14
25 14
26 14
27 15
28 15
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx,%rcx,1),%rdi
callq  1f <latin1toutf8+0x1f>
test   %rax,%rax
je     8e <latin1toutf8+0x8e>
movzbl (%rbx),%edx
test   %dl,%dl
je     85 <latin1toutf8+0x85>
lea    0x1(%rbx),%rcx
mov    %rbx,%rdi
mov    $0x0,%esi
test   %dl,%dl
js     44 <latin1toutf8+0x44>
mov    %dl,(%rax,%rsi,1)
lea    0x1(%rsi),%rsi
jmp    74 <latin1toutf8+0x74>
cmp    $0xbf,%dl
ja     5e <latin1toutf8+0x5e>
lea    0x1(%rsi),%rdx
movb   $0xc2,(%rax,%rsi,1)
add    $0x2,%rsi
movzbl (%rdi),%edi
mov    %dil,(%rax,%rdx,1)
jmp    74 <latin1toutf8+0x74>
lea    0x1(%rsi),%rdx
movb   $0xc3,(%rax,%rsi,1)
add    $0x2,%rsi
movzbl (%rdi),%edi
sub    $0x40,%edi
mov    %dil,(%rax,%rdx,1)
mov    %rcx,%rdi
add    $0x1,%rcx
movzbl -0x1(%rcx),%edx
test   %dl,%dl
jne    37 <latin1toutf8+0x37>
jmp    8a <latin1toutf8+0x8a>
mov    $0x0,%esi
movb   $0x0,(%rax,%rsi,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
latin1toutf8 (const char *str)
{
  char *p = malloc (2 * strlen (str) + 1);
  if (p)
    {
      size_t i, j = 0;
      for (i = 0; str[i]; i++)
 {
   if (to_uchar (str[i]) < 0x80)
     p[j++] = str[i];
   else if (to_uchar (str[i]) < 0xC0)
     {
       p[j++] = (unsigned char) 0xC2;
       p[j++] = str[i];
     }
   else
     {
       p[j++] = (unsigned char) 0xC3;
       p[j++] = str[i] - 64;
     }
 }
      p[j] = 0x00;
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 7
12 7
13 7
14 7
15 7
16 7
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 13
25 13
26 14
27 14
28 14
29 14
30 18
31 18
32 19
33 19
34 19
35 19
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 22
44 25
45 25
<<<sep_out_sample>>>
test   %edx,%edx
jne    2fc1 <swlib_apply_mode_umask+0x14>
cmp    $0x64,%dil
mov    $0x1ff,%eax
mov    $0x1b6,%dx
cmove  %eax,%edx
not    %esi
mov    %edx,%eax
and    %esi,%eax
retq   
<<<sep_in_sample>>>
swlib_apply_mode_umask(char type, mode_t umask, mode_t mode) {
 if (mode == 0) {
  if (type == 'd') {
   mode = 0777;
  } else {
   mode = 0666;
  }
 }
 mode &= ~umask;
 return mode;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 9
8 9
9 9
10 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     372 <gsasl_client_callback_authorization_id_get+0xa>
mov    0x30(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_authorization_id_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_authorization_id : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
cmp    $0xffffffff,%edi
je     2e <unget+0xf>
sub    $0x1,%rax
mov    %rax,(%rsi)
repz retq 
<<<sep_in_sample>>>
unget (int c, const char **sp)
{
  const char *s;
  s = *sp;
  if (c == (-1))
    {
      do {} while (0);
      return;
    }
  s--;
  do {} while (0);
  *sp = s;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 10
5 10
6 10
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  5b9 <nntp_message_uid+0x9>
mov    0x8(%rax),%rdx
mov    $0x0,%eax
test   %rbx,%rbx
jne    5d5 <nntp_message_uid+0x25>
mov    0x10(%rdx),%rdi
mov    $0x0,%esi
callq  36 <nntp_mailbox_messages_count>
pop    %rbx
retq   
<<<sep_in_sample>>>
nntp_message_uid (mu_message_t msg, size_t *puid)
{
  msg_nntp_t msg_nntp = mu_message_get_owner (msg);
  m_nntp_t m_nntp = msg_nntp->m_nntp;
  int status;
  if (puid)
    return 0;
  status = nntp_mailbox_messages_count (m_nntp->mailbox, ((void *)0));
  if (status != 0)
    return status;
  if (puid)
    *puid = msg_nntp->msgno;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 7
6 6
7 6
8 8
9 8
10 8
11 14
12 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 14fa <gsl_matrix_uchar_set+0xb>
je     153d <gsl_matrix_uchar_set+0x4e>
cmp    %rsi,(%rdi)
ja     151c <gsl_matrix_uchar_set+0x2d>
mov    $0x4,%ecx
mov    $0x129,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  151a <gsl_matrix_uchar_set+0x2b>
jmp    1549 <gsl_matrix_uchar_set+0x5a>
cmp    %rdx,0x8(%rdi)
ja     153d <gsl_matrix_uchar_set+0x4e>
mov    $0x4,%ecx
mov    $0x12d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  153b <gsl_matrix_uchar_set+0x4c>
jmp    1549 <gsl_matrix_uchar_set+0x5a>
imul   0x10(%rdi),%rsi
add    0x18(%rdi),%rdx
mov    %cl,(%rdx,%rsi,1)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_set(gsl_matrix_uchar * m, const size_t i, const size_t j, const unsigned char x)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_uchar.h", 297, GSL_EINVAL) ; return ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_uchar.h", 301, GSL_EINVAL) ; return ; } while (0) ;
        }
    }
  m->data[i * m->tda + j] = x ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 11
20 14
21 14
22 14
23 15
24 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r8
mov    %edx,%ecx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  ccd <swlib_exception+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swlib_exception(char * reason, char * file,
   int line, char * function)
{
 e_msg("program exception", reason, file, line, function);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  c5d <err_readonly+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  c6d <err_readonly+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
err_readonly (s)
     const char *s;
{
  report_error (gettext("%s: readonly variable"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    0x0(%rip),%rdx        # c2b <write_dummy_declarations+0x11>
test   %rdx,%rdx
je     c54 <write_dummy_declarations+0x3a>
mov    $0x0,%ebx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  c47 <write_dummy_declarations+0x2d>
add    $0x8,%rbx
mov    -0x8(%rbx),%rdx
test   %rdx,%rdx
jne    c35 <write_dummy_declarations+0x1b>
cmpl   $0x0,0x4(%r12)
jle    c8d <write_dummy_declarations+0x73>
mov    $0x0,%ebx
movslq %ebx,%rdx
mov    0x10(%r12),%rax
mov    (%rax,%rdx,8),%rax
mov    0x8(%rax),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  c83 <write_dummy_declarations+0x69>
add    $0x1,%ebx
cmp    %ebx,0x4(%r12)
jg     c61 <write_dummy_declarations+0x47>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
write_dummy_declarations (stream, builtins)
     FILE *stream;
     ARRAY *builtins;
{
  register int i;
  BUILTIN_DESC *builtin;
  for (i = 0; structfile_header[i]; i++)
    fprintf (stream, "%s\n", structfile_header[i]);
  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];
      fprintf (stream, "int %s () { return (0); }\n", builtin->function);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 7
16 7
17 7
18 9
19 9
20 9
21 11
22 11
23 12
24 12
25 12
26 12
27 12
28 12
29 9
30 9
31 9
32 14
33 14
34 14
35 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rbx,%rdi
callq  18d <newton_alloc+0x12>
mov    %rax,%rbp
test   %rax,%rax
jne    1b5 <newton_alloc+0x3a>
mov    $0x8,%ecx
mov    $0x38,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ae <newton_alloc+0x33>
mov    $0x8,%eax
jmp    1f8 <newton_alloc+0x7d>
mov    %rax,(%r12)
mov    %rbx,%rdi
callq  1c1 <newton_alloc+0x46>
test   %rax,%rax
jne    1ee <newton_alloc+0x73>
mov    %rbp,%rdi
callq  1ce <newton_alloc+0x53>
mov    $0x8,%ecx
mov    $0x43,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e7 <newton_alloc+0x6c>
mov    $0x8,%eax
jmp    1f8 <newton_alloc+0x7d>
mov    %rax,0x8(%r12)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
newton_alloc (void * vstate, size_t n)
{
  newton_state_t * state = (newton_state_t *) vstate;
  gsl_permutation * p;
  gsl_matrix * m;
  m = gsl_matrix_calloc (n,n);
  if (m == 0)
    {
      do { gsl_error ("failed to allocate space for lu", "newton.c", 56, GSL_ENOMEM) ; return GSL_ENOMEM ; } while (0);
    }
  state->lu = m ;
  p = gsl_permutation_calloc (n);
  if (p == 0)
    {
      gsl_matrix_free(m);
      do { gsl_error ("failed to allocate space for permutation", "newton.c", 67, GSL_ENOMEM) ; return GSL_ENOMEM ; } while (0);
    }
  state->permutation = p ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 11
19 12
20 12
21 13
22 13
23 15
24 15
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 18
33 19
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x10(%rdi),%rax
test   %rax,%rax
jne    240 <sexp_put_code_end+0x2a>
mov    $0x0,%ecx
mov    $0xbd,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  240 <sexp_put_code_end+0x2a>
lea    0x30(%rdi),%rdi
mov    %rsp,%rsi
callq  *0x30(%rax)
cmp    $0x3,%eax
jbe    268 <sexp_put_code_end+0x52>
mov    $0x0,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  268 <sexp_put_code_end+0x52>
movq   $0x0,0x10(%rbx)
mov    %rsp,%rdx
mov    %eax,%esi
mov    %rbx,%rdi
callq  27d <sexp_put_code_end+0x67>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
sexp_put_code_end(struct sexp_output *output)
{
  uint8_t encoded[3];
  unsigned done;
  ((output->coding) ? (void) (0) : __assert_fail ("output->coding", "output.c", 189, __PRETTY_FUNCTION__));
  done = output->coding->encode_final(&output->base64, encoded);
  ((done <= sizeof(encoded)) ? (void) (0) : __assert_fail ("done <= sizeof(encoded)", "output.c", 193, __PRETTY_FUNCTION__));
  output->coding = ((void *)0);
  sexp_put_data(output, done, encoded);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 9
24 9
25 9
26 9
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rbp,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    0x30(%rsi,%rdx,1),%r13
mov    %r13,%rdi
callq  6f <dico_strategy_create+0x42>
mov    %rax,%rbx
test   %rax,%rax
je     bd <dico_strategy_create+0x90>
mov    %r13,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  87 <dico_strategy_create+0x5a>
lea    0x30(%rbx),%rdi
mov    %rdi,(%rbx)
mov    %r12,%rsi
callq  96 <dico_strategy_create+0x69>
mov    (%rbx),%rdx
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rdx,%rcx,1),%rdi
mov    %rdi,0x8(%rbx)
mov    %rbp,%rsi
callq  bd <dico_strategy_create+0x90>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dico_strategy_create(const char *name, const char *descr)
{
    dico_strategy_t np;
    size_t size = sizeof(*np) + strlen(name) + strlen(descr) + 2;
    np = malloc(size);
    if (np) {
 memset(np, 0, size);
 np->name = (char*)(np + 1);
 strcpy(np->name, name);
 np->descr = np->name + strlen(np->name) + 1;
 strcpy(np->descr, descr);
    }
    return np;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 6
24 6
25 7
26 7
27 7
28 7
29 8
30 8
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 11
42 11
43 14
44 14
45 14
46 14
47 14
48 14
49 14
<<<sep_out_sample>>>
mov    %rdi,%rax
test   %edx,%edx
jne    482 <__gmpn_mu_div_qr_choose_in+0x48>
cmp    %rsi,%rdi
jle    463 <__gmpn_mu_div_qr_choose_in+0x29>
lea    -0x1(%rdi),%rcx
mov    %rcx,%rax
cqto   
idiv   %rsi
lea    0x1(%rax),%rsi
mov    %rcx,%rax
cqto   
idiv   %rsi
add    $0x1,%rax
retq   
lea    (%rdi,%rdi,2),%rdx
cmp    %rdx,%rsi
jge    499 <__gmpn_mu_div_qr_choose_in+0x5f>
sub    $0x1,%rax
mov    %rax,%rdx
shr    $0x3f,%rdx
add    %rdx,%rax
sar    %rax
add    $0x1,%rax
retq   
cmp    %rsi,%rdi
cmovg  %rsi,%rax
sub    $0x1,%rax
movslq %edx,%rcx
cqto   
idiv   %rcx
add    $0x1,%rax
repz retq 
<<<sep_in_sample>>>
__gmpn_mu_div_qr_choose_in (mp_size_t qn, mp_size_t dn, int k)
{
  mp_size_t in;
  if (k == 0)
    {
      mp_size_t b;
      if (qn > dn)
 {
   b = (qn - 1) / dn + 1;
   in = (qn - 1) / b + 1;
 }
      else if (3 * qn > dn)
 {
   in = (qn - 1) / 2 + 1;
 }
      else
 {
   in = (qn - 1) / 1 + 1;
 }
    }
  else
    {
      mp_size_t xn;
      xn = ((dn) < (qn) ? (dn) : (qn));
      in = (xn - 1) / k + 1;
    }
  return in;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 7
5 7
6 9
7 9
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 12
17 12
18 12
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 24
27 24
28 25
29 25
30 25
31 25
32 25
33 28
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4c39 <dispose_saved_dollar_vars+0x7>
test   %rax,%rax
je     4c72 <dispose_saved_dollar_vars+0x40>
mov    0x0(%rip),%edx        # 4c44 <dispose_saved_dollar_vars+0x12>
test   %edx,%edx
je     4c72 <dispose_saved_dollar_vars+0x40>
sub    $0x8,%rsp
movslq %edx,%rdx
mov    (%rax,%rdx,8),%rdi
callq  4c58 <dispose_saved_dollar_vars+0x26>
movslq 0x0(%rip),%rdx        # 4c5f <dispose_saved_dollar_vars+0x2d>
mov    0x0(%rip),%rax        # 4c66 <dispose_saved_dollar_vars+0x34>
movq   $0x0,(%rax,%rdx,8)
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dispose_saved_dollar_vars ()
{
  if (!dollar_arg_stack || dollar_arg_stack_index == 0)
    return;
  dispose_words (dollar_arg_stack[dollar_arg_stack_index]);
  dollar_arg_stack[dollar_arg_stack_index] = (WORD_LIST *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 2
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17e <string_comp+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_comp(const void *item, void *value)
{
    return strcmp(item, value);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x6b,%edx
mov    $0x0,%esi
mov    $0x400,%edi
callq  583 <uwp_init+0x18>
mov    %rax,0x0(%rip)        # 58a <uwp_init+0x1f>
movl   $0x80,0x0(%rip)        # 594 <uwp_init+0x29>
movl   $0x0,0x0(%rip)        # 59e <uwp_init+0x33>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
uwp_init ()
{
  do { (uwcache).data = sh_xmalloc(((128) * sizeof (UNWIND_ELT *)), "unwind_prot.c", 107); (uwcache).cs = (128); (uwcache).nc = 0; } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
test   %rdx,%rdx
je     1a7 <gsl_histogram_sum+0x23>
mov    0x10(%rdi),%rax
lea    (%rax,%rdx,8),%rdx
xorpd  %xmm0,%xmm0
addsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rdx,%rax
jne    198 <gsl_histogram_sum+0x14>
repz retq 
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_histogram_sum(const gsl_histogram * h)
{
  double sum=0;
  size_t i=0;
  size_t n;
  n=h->n;
  while(i < n)
    sum += h->bin[i++];
  return sum;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 3
7 8
8 8
9 7
10 7
11 7
12 3
13 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rsi,%rsi
jne    25 <ahsStaticSetTarname_i+0x25>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     1c <ahsStaticSetTarname_i+0x1c>
callq  1c <ahsStaticSetTarname_i+0x1c>
movq   $0x0,(%rbx)
jmp    82 <ahsStaticSetTarname_i+0x82>
mov    %edx,%r12d
cmpq   $0x0,(%rdi)
jne    3b <ahsStaticSetTarname_i+0x3b>
mov    $0x64,%edi
callq  38 <ahsStaticSetTarname_i+0x38>
mov    %rax,(%rbx)
test   %r12d,%r12d
jns    52 <ahsStaticSetTarname_i+0x52>
mov    (%rbx),%rdi
cmp    %rbp,(%rdi)
je     82 <ahsStaticSetTarname_i+0x82>
mov    %rbp,%rsi
callq  50 <ahsStaticSetTarname_i+0x50>
jmp    82 <ahsStaticSetTarname_i+0x82>
lea    0x1(%r12),%esi
mov    (%rbx),%rdi
callq  5f <ahsStaticSetTarname_i+0x5f>
mov    (%rbx),%rdi
cmp    %rbp,(%rdi)
je     72 <ahsStaticSetTarname_i+0x72>
movslq %r12d,%rdx
mov    %rbp,%rsi
callq  72 <ahsStaticSetTarname_i+0x72>
mov    (%rbx),%rdi
callq  7a <ahsStaticSetTarname_i+0x7a>
movslq %r12d,%r12
movb   $0x0,(%rax,%r12,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
ahsStaticSetTarname_i(STROB ** c_sb, char * name, int len)
{
 ;
 if (name == ((void *)0)) {
  if (*c_sb)
   strob_close(*c_sb);
  *c_sb = (STROB*)((void *)0);
  return;
 }
 if (*c_sb == ((void *)0)) {
  *c_sb = strob_open(100);
 }
 if (len < 0) {
  if (name != (char*)((*c_sb)->str_)) strob_strcpy(*c_sb, name);
 } else {
  strob_set_memlength(*c_sb, len+1);
  if (name != (char*)((*c_sb)->str_)) strob_strncpy(*c_sb, name, len);
  *(strob_str(*c_sb) + len) = '\0';
 }
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 6
12 7
13 8
14 8
15 10
16 10
17 11
18 11
19 11
20 13
21 13
22 14
23 14
24 14
25 14
26 14
27 14
28 16
29 16
30 16
31 17
32 17
33 17
34 17
35 17
36 17
37 18
38 18
39 18
40 18
41 21
42 21
43 21
44 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 2de <__rslutt+0xb>
je     37b <__rslutt+0xa8>
mov    0x0(%rip),%rdi        # 2eb <__rslutt+0x18>
cmpb   $0x0,0x50(%rdi)
je     37b <__rslutt+0xa8>
callq  2fa <__rslutt+0x27>
movsd  0x0(%rip),%xmm0        # 302 <__rslutt+0x2f>
mov    0x0(%rip),%esi        # 308 <__rslutt+0x35>
mov    $0x0,%edi
mov    $0x1,%eax
callq  317 <__rslutt+0x44>
cmpb   $0x0,0x0(%rip)        # 31e <__rslutt+0x4b>
je     371 <__rslutt+0x9e>
mov    $0x0,%edi
mov    $0x0,%eax
callq  32f <__rslutt+0x5c>
mov    0x0(%rip),%rsi        # 336 <__rslutt+0x63>
cmp    $0x3ff,%rsi
jle    362 <__rslutt+0x8f>
lea    0x3ff(%rsi),%rax
test   %rsi,%rsi
cmovs  %rax,%rsi
sar    $0xa,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  360 <__rslutt+0x8d>
jmp    371 <__rslutt+0x9e>
mov    $0x0,%edi
mov    $0x0,%eax
callq  371 <__rslutt+0x9e>
mov    $0xa,%edi
callq  37b <__rslutt+0xa8>
callq  380 <__rslutt+0xad>
mov    %rax,%rdi
callq  388 <__rslutt+0xb5>
callq  38d <__rslutt+0xba>
mov    %rax,%rdi
callq  395 <__rslutt+0xc2>
callq  39a <__rslutt+0xc7>
mov    %rax,%rdi
callq  3a2 <__rslutt+0xcf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rslutt (void)
{
  if (__gc && ((__bs1FILE *) __blokk0FILE.c2)->open)
    {
      __rpoutimage ((__bs6FILE *) __blokk0FILE.c2);
      printf ("%d garbage collection(s) in %.1f seconds.", __gc, __gbctime);
      if (__chpoolsize)
 {
   printf (" Poolsize changed to ");
   if (__poolsize >= 1024)
     printf ("%ldM while running.", __poolsize / 1024);
   else
     printf ("%ldK while running.", __poolsize);
 }
      printf ("\n");
    }
  __riclose ((__bs1FILE *) __rsysin ());
  __roclose ((__bs1FILE *) __rsysout ());
  __roclose ((__bs1FILE *) __rsyserr ());
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 9
18 10
19 10
20 10
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 15
33 15
34 17
35 17
36 17
37 18
38 18
39 18
40 19
41 19
42 19
43 20
44 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  27 <echo_free_result+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
echo_free_result(dico_result_t rp)
{
    free(rp);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x68(%rdi),%rsi
callq  27 <_mh_next_seq+0xd>
test   %rax,%rax
je     36 <_mh_next_seq+0x1c>
mov    0x48(%rax),%rax
add    $0x1,%rax
jmp    3b <_mh_next_seq+0x21>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_mh_next_seq (struct _amd_data *amd)
{
  struct _mh_message *msg = (struct _mh_message *)
                              _amd_get_message (amd, amd->msg_count);
  return (msg ? msg->seq_number : 0) + 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rdx,%rdi
mov    0x0(%rip),%rcx        # c09d <rpl_re_compile_pattern+0x11>
mov    %rcx,%rdx
shr    $0x19,%rdx
and    $0x1,%edx
shl    $0x4,%edx
movzbl 0x38(%rdi),%r8d
and    $0xffffffef,%r8d
or     %r8d,%edx
or     $0xffffff80,%edx
mov    %dl,0x38(%rdi)
mov    %rsi,%rdx
mov    %rax,%rsi
callq  b3ca <re_compile_internal>
test   %eax,%eax
je     c0dd <rpl_re_compile_pattern+0x51>
cltq   
mov    0x0(,%rax,8),%rax
add    $0x0,%rax
jmp    c0e2 <rpl_re_compile_pattern+0x56>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_re_compile_pattern (const char *pattern, size_t length,
      struct re_pattern_buffer *bufp)
{
  reg_errcode_t ret;
  bufp->no_sub = !!(rpl_re_syntax_options & (((((((((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  bufp->newline_anchor = 1;
  ret = re_compile_internal (bufp, pattern, length, rpl_re_syntax_options);
  if (!ret)
    return ((void *)0);
  return (__re_error_msgid + __re_error_msgid_idx[(int) ret]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 10
20 10
21 10
22 10
23 9
24 11
25 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  3cb <gsl_vector_uint_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_uint_fwrite (FILE * stream, const gsl_vector_uint * v)
{
  int status = gsl_block_uint_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%r8
mov    (%rsi),%rcx
test   %rdi,%rdi
jne    ed <mu_2nrealloc+0x2f>
test   %rcx,%rcx
jne    113 <mu_2nrealloc+0x55>
mov    $0x40,%eax
mov    $0x0,%edx
div    %r8
test   %rax,%rax
sete   %cl
movzbl %cl,%ecx
add    %rax,%rcx
jmp    113 <mu_2nrealloc+0x55>
movabs $0xaaaaaaaaaaaaaaaa,%rax
mov    $0x0,%edx
div    %r8
cmp    %rax,%rcx
jb     109 <mu_2nrealloc+0x4b>
callq  109 <mu_2nrealloc+0x4b>
lea    0x1(%rcx),%rax
shr    %rax
add    %rax,%rcx
mov    %rcx,(%rsi)
imul   %r8,%rcx
mov    %rcx,%rsi
callq  122 <mu_2nrealloc+0x64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_2nrealloc (void *p, size_t *pn, size_t s)
{
  size_t n = *pn;
  if (!p)
    {
      if (!n)
 {
   enum { DEFAULT_MXFAST = 64 };
   n = DEFAULT_MXFAST / s;
   n += !n;
 }
    }
  else
    {
      if ((size_t) -1 / 3 * 2 / s <= n)
 mu_alloc_die ();
      n += (n + 1) / 2;
    }
  *pn = n;
  return mu_realloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 6
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 15
17 15
18 15
19 15
20 15
21 16
22 17
23 17
24 17
25 19
26 20
27 20
28 20
29 21
30 21
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
cmpl   $0x0,0x0(%rip)        # 5fd1 <bash_directory_completion_matches+0xe>
je     6026 <bash_directory_completion_matches+0x63>
mov    0x0(%rip),%esi        # 5fd9 <bash_directory_completion_matches+0x16>
cmpl   $0x0,0x0(%rip)        # 5fe0 <bash_directory_completion_matches+0x1d>
jne    6026 <bash_directory_completion_matches+0x63>
callq  43 <bash_dequote_filename>
mov    %rax,%r12
mov    $0x0,%esi
mov    %rax,%rdi
callq  5ff7 <bash_directory_completion_matches+0x34>
mov    %rax,%rbx
cmp    %r12,%rbp
je     6011 <bash_directory_completion_matches+0x4e>
mov    $0x10cb,%edx
mov    $0x0,%esi
mov    %r12,%rdi
callq  6011 <bash_directory_completion_matches+0x4e>
test   %rbx,%rbx
je     6038 <bash_directory_completion_matches+0x75>
cmpq   $0x0,(%rbx)
je     6038 <bash_directory_completion_matches+0x75>
mov    %rbx,%rdi
callq  bf2 <bash_ignore_filenames>
jmp    6038 <bash_directory_completion_matches+0x75>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  6033 <bash_directory_completion_matches+0x70>
mov    %rax,%rbx
jmp    6011 <bash_directory_completion_matches+0x4e>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
bash_directory_completion_matches (text)
     const char *text;
{
  char **m1;
  char *dfn;
  int qc;
  qc = rl_dispatching ? rl_completion_quote_character : 0;
  if (rl_dispatching && rl_completion_found_quote == 0)
    dfn = bash_dequote_filename ((char *)text, qc);
  else
    dfn = (char *)text;
  m1 = rl_completion_matches (dfn, rl_filename_completion_function);
  if (dfn != text)
    sh_xfree((dfn), "bashline.c", 4299);
  if (m1 == 0 || m1[0] == 0)
    return m1;
  (void)bash_ignore_filenames (m1);
  return m1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 7
8 8
9 8
10 9
11 9
12 12
13 12
14 12
15 12
16 13
17 13
18 14
19 14
20 14
21 14
22 15
23 15
24 15
25 15
26 17
27 17
28 18
29 12
30 12
31 12
32 12
33 12
34 19
35 19
36 19
37 19
38 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
movzbl (%rdi),%eax
test   %al,%al
je     160 <xvasprintf+0x20>
cmp    $0x25,%al
jne    18f <xvasprintf+0x4f>
cmpb   $0x73,0x1(%rdi)
jne    18f <xvasprintf+0x4f>
mov    %rdi,%r9
mov    $0x0,%r8d
jmp    17b <xvasprintf+0x3b>
mov    $0x0,%r8d
mov    %r8,%rdi
callq  0 <xstrcat>
jmp    1be <xvasprintf+0x7e>
cmp    $0x25,%cl
jne    18f <xvasprintf+0x4f>
cmpb   $0x73,0x1(%rax)
jne    18f <xvasprintf+0x4f>
lea    0x2(%r9),%rax
mov    %rax,%r9
add    $0x1,%r8
movzbl (%rax),%ecx
test   %cl,%cl
jne    170 <xvasprintf+0x30>
jmp    166 <xvasprintf+0x26>
mov    %rsi,%rdx
mov    %rdi,%rsi
lea    0x8(%rsp),%rdi
callq  19f <xvasprintf+0x5f>
mov    %eax,%edx
mov    0x8(%rsp),%rax
test   %edx,%edx
jns    1be <xvasprintf+0x7e>
callq  1af <xvasprintf+0x6f>
cmpl   $0xc,(%rax)
jne    1b9 <xvasprintf+0x79>
callq  1b9 <xvasprintf+0x79>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
xvasprintf (const char *format, va_list args)
{
  char *result;
  {
    size_t argcount = 0;
    const char *f;
    for (f = format;;)
      {
 if (*f == '\0')
   return xstrcat (argcount, args);
 if (*f != '%')
   break;
 f++;
 if (*f != 's')
   break;
 f++;
 argcount++;
      }
  }
  if (vasprintf (&result, format, args) < 0)
    {
      if ((*__errno_location ()) == 12)
 xalloc_die ();
      return ((void *)0);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 9
3 9
4 9
5 11
6 11
7 14
8 14
9 7
10 5
11 5
12 5
13 10
14 10
15 10
16 11
17 11
18 14
19 14
20 14
21 14
22 17
23 9
24 9
25 9
26 9
27 20
28 20
29 20
30 20
31 20
32 26
33 20
34 20
35 22
36 22
37 22
38 23
39 24
40 27
41 27
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  1624 <swlib_dirname+0xe>
mov    %rbx,%rdi
callq  162c <swlib_dirname+0x16>
mov    $0x2f,%esi
mov    %rax,%rdi
callq  1639 <swlib_dirname+0x23>
mov    %rax,%rbp
test   %rax,%rax
jne    1650 <swlib_dirname+0x3a>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  164e <swlib_dirname+0x38>
jmp    1667 <swlib_dirname+0x51>
mov    %rbx,%rdi
callq  1658 <swlib_dirname+0x42>
cmp    %rbp,%rax
je     1663 <swlib_dirname+0x4d>
movb   $0x0,0x0(%rbp)
jmp    1667 <swlib_dirname+0x51>
movb   $0x0,0x1(%rax)
mov    %rbx,%rdi
callq  166f <swlib_dirname+0x59>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swlib_dirname(STROB * dest, char * source)
{
 char * s;
 strob_strcpy(dest, source);
 s = strrchr(strob_str(dest), '/');
 if (!s) {
  strob_strcpy(dest, ".");
 } else {
  if (s != strob_str(dest))
   *s = '\0';
  else
   *(s+1) = '\0';
 }
 return strob_str(dest);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 9
22 10
23 10
24 12
25 14
26 14
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    0x18(%rdi),%edx
test   %edx,%edx
jne    90 <evt_set_type_incoming_sipmessage+0x4e>
mov    0x10(%rdi),%rdx
mov    $0x0,%edi
mov    $0x7,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
mov    $0xa,%eax
cmp    %cl,%sil
je     ab <evt_set_type_incoming_sipmessage+0x69>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
add    $0xc,%eax
retq   
lea    -0x64(%rdx),%ecx
mov    $0xd,%eax
cmp    $0x63,%ecx
jbe    ab <evt_set_type_incoming_sipmessage+0x69>
sub    $0xc8,%edx
cmp    $0x64,%edx
sbb    %eax,%eax
add    $0xf,%eax
repz retq 
<<<sep_in_sample>>>
evt_set_type_incoming_sipmessage (osip_message_t * sip)
{
  if (((sip)->status_code==0)) {
    if ((((sip)->status_code==0) && 0==strcmp((sip)->sip_method,"INVITE")))
      return RCV_REQINVITE;
    else if ((((sip)->status_code==0) && 0==strcmp((sip)->sip_method,"ACK")))
      return RCV_REQACK;
    return RCV_REQUEST;
  }
  else {
    if (((sip)->status_code >= 100 && (sip)->status_code < 200))
      return RCV_STATUS_1XX;
    else if (((sip)->status_code >= 200 && (sip)->status_code < 300))
      return RCV_STATUS_2XX;
    return RCV_STATUS_3456XX;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 11
27 12
28 11
29 11
30 13
31 14
32 14
33 14
34 17
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,0x8(%rsp)
callq  24 <filterdir+0x24>
mov    %rax,%r13
test   %rax,%rax
jne    65 <filterdir+0x65>
jmp    aa <filterdir+0xaa>
cmpb   $0x2e,0x13(%rbx)
jne    41 <filterdir+0x41>
cmpb   $0x0,0x14(%rbx)
je     65 <filterdir+0x65>
cmpw   $0x2e,0x14(%rbx)
je     65 <filterdir+0x65>
test   %rbp,%rbp
je     56 <filterdir+0x56>
lea    0x13(%rbx),%rsi
mov    %r14,%rdx
mov    %r12,%rdi
callq  *%rbp
test   %al,%al
je     65 <filterdir+0x65>
lea    0x13(%rbx),%rsi
mov    0x8(%rsp),%rdx
mov    %r12,%rdi
callq  *%r15
mov    %r13,%rdi
callq  6d <filterdir+0x6d>
mov    %rax,%rbx
test   %rax,%rax
jne    2e <filterdir+0x2e>
mov    %r13,%rdi
callq  7d <filterdir+0x7d>
test   %eax,%eax
je     aa <filterdir+0xaa>
mov    $0x0,%edi
callq  8b <filterdir+0x8b>
mov    %rax,%rbx
callq  93 <filterdir+0x93>
mov    %r12,%rcx
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  aa <filterdir+0xaa>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
filterdir (const char *dir,
    filterdir_filter_t filter, void *filtarg,
    filterdir_fun_t fun, void *arg)
{
  DIR *dirp;
  struct dirent *dp;
  dirp = opendir (dir);
  if (dirp == ((void *)0))
    return;
  while ((dp = readdir (dirp)) != ((void *)0))
    if ((dp->d_name[0] != '.' || (dp->d_name[1] != '\0' && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
 && (!filter || (*filter) (dir, dp->d_name, filtarg)))
      fun (dir, dp->d_name, arg);
  if (closedir (dirp))
    error (1, (*__errno_location ()), gettext ("cannot close directory `%s'"), dir);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 7
14 7
15 8
16 8
17 8
18 11
19 11
20 11
21 11
22 11
23 11
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 13
33 13
34 13
35 13
36 10
37 10
38 10
39 10
40 10
41 14
42 14
43 14
44 14
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 15
55 16
56 16
57 16
58 16
59 16
60 16
61 16
62 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rsi,%rbx
mov    0x18(%rdi),%edi
mov    %rsp,%rsi
callq  16 <_gdbm_file_size+0x16>
test   %eax,%eax
jne    24 <_gdbm_file_size+0x24>
mov    0x30(%rsp),%rdx
mov    %rdx,(%rbx)
jmp    29 <_gdbm_file_size+0x29>
mov    $0xffffffff,%eax
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_gdbm_file_size (GDBM_FILE dbf, off_t *psize)
{
  struct stat sb;
  if (fstat (dbf->desc, &sb))
    return -1;
  *psize = sb.st_size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 7
12 5
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     567 <gsl_histogram2d_free+0x2c>
mov    0x10(%rdi),%rdi
callq  54d <gsl_histogram2d_free+0x12>
mov    0x18(%rbx),%rdi
callq  556 <gsl_histogram2d_free+0x1b>
mov    0x20(%rbx),%rdi
callq  55f <gsl_histogram2d_free+0x24>
mov    %rbx,%rdi
callq  567 <gsl_histogram2d_free+0x2c>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_histogram2d_free (gsl_histogram2d * h)
{
  if (!h) { return ; };
  free (h->xrange);
  free (h->yrange);
  free (h->bin);
  free (h);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  1c19 <rl_unbind_command_in_map+0x9>
mov    %rax,%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     1c2e <rl_unbind_command_in_map+0x1e>
mov    %rbx,%rsi
callq  1c2e <rl_unbind_command_in_map+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_unbind_command_in_map (command, map)
     const char *command;
     Keymap map;
{
  rl_command_func_t *func;
  func = rl_named_function (command);
  if (func == 0)
    return 0;
  return (rl_unbind_function_in_map (func, map));
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 8
6 7
7 7
8 9
9 9
10 10
11 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  1e5 <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    (%rdi),%rax
mov    0x28(%rdi),%r9
mov    0x18(%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
mov    0x40(%rdi),%rsi
mov    0xb8(%rdi),%rdi
mov    0x20(%rbx),%r10
mov    %r10,0x8(%rsp)
mov    0x30(%rbx),%r10
mov    %r10,(%rsp)
callq  *0x18(%rax)
addq   $0x1,0x58(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multilarge_nlinear_iterate (gsl_multilarge_nlinear_workspace * w)
{
  int status =
    (w->type->iterate) (w->state, w->sqrt_wts, w->fdf,
                        w->x, w->f, w->g, w->JTJ, w->dx);
  w->niter++;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 6
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    0x38(%rsi),%rsi
mov    %rsp,%rdi
callq  e6b <rec_record_append+0x17>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
jmp    ee7 <rec_record_append+0x93>
mov    0x48(%rsp),%rdi
callq  ecc <rec_record_append+0x78>
mov    0x38(%rbx),%rdi
mov    $0x1,%ecx
mov    %rax,%rdx
mov    $0x1,%esi
callq  ee2 <rec_record_append+0x8e>
test   %rax,%rax
je     f0e <rec_record_append+0xba>
mov    $0x0,%ecx
lea    0x48(%rsp),%rdx
mov    $0x1,%esi
lea    0x50(%rsp),%rdi
callq  f00 <rec_record_append+0xac>
test   %al,%al
jne    ec2 <rec_record_append+0x6e>
lea    0x50(%rsp),%rdi
callq  f0e <rec_record_append+0xba>
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
rec_record_append (rec_record_t dest_record,
                   rec_record_t src_record)
{
  rec_mset_iterator_t iter;
  rec_field_t field;
  iter = rec_mset_iterator (src_record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &field, ((void *)0)))
    {
      if (!rec_mset_append (rec_record_mset (dest_record),
                            1,
                            (void *) rec_field_dup (field),
                            1))
        {
          return;
        }
    }
  rec_mset_iterator_free (&iter);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 11
25 11
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 17
41 17
42 18
43 18
44 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
movsd  %xmm0,(%rsp)
mov    %rdx,%r12
mov    %rcx,%r15
mov    0x8(%rsi),%r13
mov    (%rsi),%rbx
mov    $0x3,%r14d
addsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
mov    0x18(%r15),%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
movsd  0x8(%rsp),%xmm0
callq  *(%r15)
test   %eax,%eax
jne    7f <gear1_step+0x7f>
test   %r12,%r12
je     74 <gear1_step+0x74>
mov    $0x0,%eax
movsd  (%rsp),%xmm0
mulsd  (%rbx,%rax,8),%xmm0
addsd  0x0(%r13,%rax,8),%xmm0
movsd  %xmm0,0x0(%rbp,%rax,8)
add    $0x1,%rax
cmp    %r12,%rax
jne    54 <gear1_step+0x54>
sub    $0x1,%r14d
jne    33 <gear1_step+0x33>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gear1_step (double *y, gear1_state_t *state,
     const double h, const double t,
     const size_t dim, const gsl_odeiv_system *sys)
{
  const int iter_steps = 3;
  int nu;
  size_t i;
  double *y0 = state->y0;
  double *k = state->k;
  for (nu = 0; nu < iter_steps; nu++)
    {
      int s = (*((sys)->function))(t + h,y,k,(sys)->params);
      if (s != GSL_SUCCESS)
 {
   return s;
 }
      for (i=0; i<dim; i++)
 {
   y[i] = y0[i] + h * k[i];
 }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 8
13 9
14 9
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 13
23 13
24 17
25 17
26 17
27 19
28 19
29 19
30 19
31 17
32 17
33 17
34 10
35 10
36 22
37 23
38 23
39 23
40 23
41 23
42 23
43 23
44 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  489a <chkexport+0x9>
test   %rax,%rax
je     48bd <chkexport+0x2c>
mov    0x28(%rax),%eax
and    $0x1,%eax
je     48c2 <chkexport+0x31>
movl   $0x1,0x0(%rip)        # 48b1 <chkexport+0x20>
callq  48b6 <chkexport+0x25>
mov    $0x1,%eax
jmp    48c2 <chkexport+0x31>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
chkexport (name)
     char *name;
{
  SHELL_VAR *v;
  v = find_variable (name);
  if (v && ((((v)->attributes) & (0x0000001))))
    {
      array_needs_making = 1;
      maybe_make_export_env ();
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 6
8 8
9 9
10 10
11 10
12 12
13 13
14 13
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbx
mov    %rsi,%r14
mov    %edx,%ebp
mov    %rcx,%r13
mov    %r8d,%r15d
mov    0xf8(%rdi),%r12
mov    $0x0,%ecx
lea    0x18(%rsp),%rsi
callq  a7d <CDB___log_reopen_file+0x32>
test   %eax,%eax
jne    ad4 <CDB___log_reopen_file+0x89>
mov    0x18(%rsp),%rsi
mov    0x30(%rsi),%eax
mov    %eax,0xc(%rsp)
mov    %rbx,%rdi
callq  a95 <CDB___log_reopen_file+0x4a>
mov    %ebp,%edx
mov    0x18(%rsp),%rsi
mov    %r12,%rdi
callq  aa4 <CDB___log_reopen_file+0x59>
mov    0x18(%rsp),%rax
mov    $0x0,%esi
mov    %rax,%rdi
callq  *0xe8(%rax)
mov    %r15d,(%rsp)
mov    %ebp,%r9d
mov    0xc(%rsp),%r8d
mov    %r14,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1e8 <__log_do_open>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
CDB___log_reopen_file(dbenv, name, ndx, fileid, meta_pgno)
 DB_ENV *dbenv;
 char *name;
 int32_t ndx;
 u_int8_t *fileid;
 db_pgno_t meta_pgno;
{
 DB *dbp;
 DB_LOG *logp;
 DBTYPE ftype;
 int ret;
 logp = dbenv->lg_handle;
 if ((ret = CDB___db_fileid_to_db(dbenv, &dbp, ndx, 0)) != 0)
  goto out;
 ftype = dbp->type;
 (void) CDB_log_unregister(dbenv, dbp);
 (void) CDB___log_rem_logid(logp, dbp, ndx);
 (void) dbp->close(dbp, 0);
 ret = __log_do_open(dbenv, logp, fileid, name, ftype, ndx, meta_pgno);
out: return (ret);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 12
14 13
15 13
16 13
17 13
18 13
19 15
20 15
21 15
22 16
23 16
24 17
25 17
26 17
27 17
28 18
29 18
30 18
31 18
32 19
33 19
34 19
35 19
36 19
37 19
38 19
39 19
40 21
41 21
42 21
43 21
44 21
45 21
46 21
47 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x8(%rdi)
je     1127 <print_assignment+0x81>
mov    0x28(%rdi),%eax
test   $0x8,%al
je     10de <print_assignment+0x38>
mov    (%rdi),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  10ca <print_assignment+0x24>
mov    %rbx,%rdi
callq  10d2 <print_assignment+0x2c>
mov    $0xa,%edi
callq  10dc <print_assignment+0x36>
jmp    1127 <print_assignment+0x81>
test   $0x4,%al
je     10ee <print_assignment+0x48>
mov    $0x0,%esi
callq  10ec <print_assignment+0x46>
jmp    1127 <print_assignment+0x81>
test   $0x40,%al
je     10fe <print_assignment+0x58>
mov    $0x0,%esi
callq  10fc <print_assignment+0x56>
jmp    1127 <print_assignment+0x81>
mov    (%rdi),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1110 <print_assignment+0x6a>
mov    $0x1,%esi
mov    %rbx,%rdi
callq  111d <print_assignment+0x77>
mov    $0xa,%edi
callq  1127 <print_assignment+0x81>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_assignment (var)
     SHELL_VAR *var;
{
  if (((var)->value != 0) == 0)
    return;
  if (((((var)->attributes) & (0x0000008))))
    {
      printf ("%s", var->name);
      print_var_function (var);
      printf ("\n");
    }
  else if (((((var)->attributes) & (0x0000004))))
    print_array_assignment (var, 0);
  else if (((((var)->attributes) & (0x0000040))))
    print_assoc_assignment (var, 0);
  else
    {
      printf ("%s=", var->name);
      print_var_value (var, 1);
      printf ("\n");
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 9
13 9
14 10
15 10
16 10
17 12
18 12
19 13
20 13
21 13
22 14
23 14
24 15
25 15
26 15
27 18
28 18
29 18
30 18
31 19
32 19
33 19
34 20
35 20
36 22
37 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,0x0(%rip)        # aaa <_rl_dispatch+0xb>
mov    $0x0,%edx
callq  ab4 <_rl_dispatch+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_dispatch (key, map)
     register int key;
     Keymap map;
{
  _rl_dispatching_keymap = map;
  return _rl_dispatch_subseq (key, map, 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 1e <gsl_sf_legendre_P2_e+0xc>
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 2a <gsl_sf_legendre_P2_e+0x18>
movapd %xmm0,%xmm2
subsd  %xmm1,%xmm2
mulsd  0x0(%rip),%xmm2        # 3a <gsl_sf_legendre_P2_e+0x28>
movsd  %xmm2,(%rdi)
movsd  0x0(%rip),%xmm2        # 46 <gsl_sf_legendre_P2_e+0x34>
andpd  %xmm2,%xmm0
addsd  %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 56 <gsl_sf_legendre_P2_e+0x44>
movsd  %xmm1,0x8(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_P2_e(double x, gsl_sf_result * result)
{
  {
    result->val = 0.5*(3.0*x*x - 1.0);
    result->err = 2.2204460492503131e-16 * (fabs(3.0*x*x) + 1.0);
    return GSL_SUCCESS;
  }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
callq  17e4 <_rl_erase_at_end_of_line+0xd>
test   %ebp,%ebp
jle    1845 <_rl_erase_at_end_of_line+0x6e>
mov    $0x0,%ebx
mov    0x0(%rip),%rsi        # 17f4 <_rl_erase_at_end_of_line+0x1d>
mov    $0x20,%edi
callq  17fe <_rl_erase_at_end_of_line+0x27>
add    $0x1,%ebx
cmp    %ebp,%ebx
jne    17ed <_rl_erase_at_end_of_line+0x16>
jmp    1830 <_rl_erase_at_end_of_line+0x59>
mov    (%rsi),%rcx
mov    0x0(%rip),%edi        # 1810 <_rl_erase_at_end_of_line+0x39>
lea    -0x1(%rdi),%edx
mov    %edx,0x0(%rip)        # 1819 <_rl_erase_at_end_of_line+0x42>
movslq %edx,%rdx
movb   $0x0,(%rcx,%rdx,1)
add    $0x1,%eax
cmp    %ebp,%eax
jne    1807 <_rl_erase_at_end_of_line+0x30>
addl   $0x1,0x0(%rip)        # 182e <_rl_erase_at_end_of_line+0x57>
jmp    184e <_rl_erase_at_end_of_line+0x77>
mov    %ebp,%edi
callq  1837 <_rl_erase_at_end_of_line+0x60>
mov    0x0(%rip),%rsi        # 183e <_rl_erase_at_end_of_line+0x67>
mov    $0x0,%eax
jmp    1807 <_rl_erase_at_end_of_line+0x30>
mov    %ebp,%edi
callq  184c <_rl_erase_at_end_of_line+0x75>
jmp    1827 <_rl_erase_at_end_of_line+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_erase_at_end_of_line (l)
     int l;
{
  register int i;
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    _IO_putc (' ', rl_outstream);
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    (line_state_visible->line)[--_rl_last_c_pos] = '\0';
  rl_display_fixed++;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 10
21 10
22 9
23 9
24 9
25 11
26 11
27 8
28 8
29 10
30 9
31 9
32 8
33 8
34 8
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     35a <free_history_entry+0x3a>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     33b <free_history_entry+0x1b>
callq  33b <free_history_entry+0x1b>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     349 <free_history_entry+0x29>
callq  349 <free_history_entry+0x29>
mov    0x10(%rbx),%rbp
mov    %rbx,%rdi
callq  355 <free_history_entry+0x35>
mov    %rbp,%rax
jmp    35f <free_history_entry+0x3f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
free_history_entry (hist)
     HIST_ENTRY *hist;
{
  histdata_t x;
  if (hist == 0)
    return ((histdata_t) 0);
  if (hist->line) free (hist->line);
  if (hist->timestamp) free (hist->timestamp);
  x = hist->data;
  xfree (hist);
  return (x);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 9
16 10
17 10
18 11
19 11
20 6
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x2,%edi
callq  19ac <catchAllSignals+0x10>
cmp    $0xffffffffffffffff,%rax
setne  %bl
movzbl %bl,%ebx
mov    $0x0,%esi
mov    $0x3,%edi
callq  19c5 <catchAllSignals+0x29>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x6,%edi
callq  19e0 <catchAllSignals+0x44>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0xf,%edi
callq  19fb <catchAllSignals+0x5f>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x14,%edi
callq  1a16 <catchAllSignals+0x7a>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x9,%edi
callq  1a31 <catchAllSignals+0x95>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x13,%edi
callq  1a4c <catchAllSignals+0xb0>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
catchAllSignals()
{
  int res = 1;
    if(signal(2, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(3, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(6, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(15, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(20, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(9, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(19, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 10
42 10
43 10
44 12
45 12
46 12
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
movsd  0x0(%rip),%xmm1        # 2bc9 <negate_num+0xc>
xorpd  %xmm1,%xmm0
movsd  %xmm0,(%rdi)
retq   
<<<sep_in_sample>>>
negate_num(NODE *n)
{
 if (! 0) {
  n->sub.val.fltnum = -n->sub.val.fltnum;
  return;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
sub    $0x48,%rsp
movsd  %xmm0,0x28(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x30(%rsp)
movq   %xmm1,0x38(%rsp)
mov    0x8(%rdx),%rcx
mov    (%rdi),%rax
cmp    (%rdx),%rax
jne    16c4 <gsl_blas_zgerc+0x72>
mov    (%rsi),%r10
cmp    %rcx,%r10
jne    16c4 <gsl_blas_zgerc+0x72>
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r8
mov    0x10(%rdx),%rcx
mov    %ecx,0x18(%rsp)
mov    0x18(%rdx),%rdx
mov    %rdx,0x10(%rsp)
mov    0x8(%rsi),%rdx
mov    %edx,0x8(%rsp)
mov    0x10(%rsi),%rdx
mov    %rdx,(%rsp)
lea    0x30(%rsp),%rcx
mov    %r10d,%edx
mov    %eax,%esi
mov    $0x65,%edi
callq  16bd <gsl_blas_zgerc+0x6b>
mov    $0x0,%eax
jmp    16e2 <gsl_blas_zgerc+0x90>
mov    $0x13,%ecx
mov    $0x450,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16dd <gsl_blas_zgerc+0x8b>
mov    $0x13,%eax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (X->size == M && Y->size == N)
    {
      cblas_zgerc (CblasRowMajor, ((int)(M)), ((int)(N)), ((&alpha)->dat),
                   X->data, ((int)(X->stride)), Y->data, ((int)(Y->stride)),
                   A->data, ((int)(A->tda)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 1104, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 15
31 15
32 15
33 15
34 15
35 15
36 17
37 17
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,0x8(%rsp)
mov    $0xffffffffffffffff,%r14
mov    $0x0,%eax
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rbp
mov    %rsi,%rdi
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r14
mov    $0x0,%r15d
mov    %rbp,%r13
sub    $0x1,%r13
je     1df6 <make_file_name+0x58>
cmpb   $0x2f,-0x1(%r12,%r13,1)
setne  %r15b
movzbl %r15b,%r15d
movslq %r15d,%r15
add    %r13,%r15
lea    (%r15,%r14,1),%rdi
callq  1e05 <make_file_name+0x67>
mov    %rax,%rbx
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  1e16 <make_file_name+0x78>
movb   $0x2f,-0x1(%rbx,%rbp,1)
lea    (%rbx,%r15,1),%rdi
mov    %r14,%rdx
mov    0x8(%rsp),%rsi
callq  1e2c <make_file_name+0x8e>
mov    %rbx,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
make_file_name (const char *directory_name, const char *name)
{
  size_t dirlen = strlen (directory_name);
  size_t namelen = strlen (name) + 1;
  int slash = dirlen && ! ((directory_name[dirlen - 1]) == '/');
  char *buffer = xmalloc (dirlen + slash + namelen);
  memcpy (buffer, directory_name, dirlen);
  buffer[dirlen] = '/';
  memcpy (buffer + dirlen + slash, name, namelen);
  return buffer;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 6
29 6
30 6
31 6
32 6
33 7
34 7
35 7
36 7
37 8
38 9
39 9
40 9
41 9
42 11
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3d50 <gsl_matrix_uchar_add_constant+0x5a>
mov    $0x0,%r8d
mov    $0x0,%r9d
jmp    3d42 <gsl_matrix_uchar_add_constant+0x4c>
mov    %rax,%rdx
add    0x18(%rdi),%rdx
movzbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
add    $0x1,%rax
cmp    %rax,%rsi
jne    3d15 <gsl_matrix_uchar_add_constant+0x1f>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
je     3d50 <gsl_matrix_uchar_add_constant+0x5a>
test   %r10,%r10
je     3d36 <gsl_matrix_uchar_add_constant+0x40>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
jmp    3d15 <gsl_matrix_uchar_add_constant+0x1f>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_add_constant (gsl_matrix_uchar * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 9
28 9
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x8,%esi
callq  1597 <gsl_block_fread+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     15bc <gsl_block_fread+0x3d>
mov    $0x5,%ecx
mov    $0x1f,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  15b7 <gsl_block_fread+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_fread (FILE * stream, gsl_block * b)
{
  size_t n = b->size ;
  double * data = b->data ;
  size_t items = fread (data, 1 * sizeof (double), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  ec9 <read_line+0xe>
cltq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
read_line(int fd, void * buf, size_t len)
{
 return swgp_read_line(fd, (STROB*)buf, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  94 <swsdflt_get_attr_group+0x9>
test   %rax,%rax
je     9f <swsdflt_get_attr_group+0x14>
movzbl 0x2(%rax),%eax
jmp    a4 <swsdflt_get_attr_group+0x19>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swsdflt_get_attr_group (char * object_keyword, char * keyword) {
   struct swsdflt_defaults * list;
   if ((list=swsdflt_return_entry((char*)(object_keyword), keyword)) != ((void *)0)) {
      return (int)(list->group);
   } else {
      return sdf_not_found;
   }
}
<<<sep_in_sample>>>
1 1
2 3
3 3
4 3
5 4
6 4
7 6
8 8
9 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    %esi,0x138(%rdi)
retq   
<<<sep_in_sample>>>
shcmd_set_lowest_close_fd(SHCMD * cmd, int fd)
{
 cmd->close_all_fd_ = fd;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    %rsp,%rdi
callq  124 <stream_write_multiline+0x11>
mov    $0x0,%ebx
jmp    160 <stream_write_multiline+0x4d>
mov    0x10(%rsp),%eax
cmp    $0x1,%eax
jne    153 <stream_write_multiline+0x40>
mov    0x8(%rsp),%rsi
cmpb   $0xa,(%rsi)
jne    153 <stream_write_multiline+0x40>
sub    %rbx,%rsi
mov    %rbx,%rdx
mov    %rbp,%rdi
callq  14c <stream_write_multiline+0x39>
mov    $0x0,%ebx
jmp    158 <stream_write_multiline+0x45>
mov    %eax,%eax
add    %rax,%rbx
mov    %rsp,%rdi
callq  160 <stream_write_multiline+0x4d>
mov    %rsp,%rdi
callq  168 <stream_write_multiline+0x55>
test   %eax,%eax
je     12b <stream_write_multiline+0x18>
test   %rbx,%rbx
je     184 <stream_write_multiline+0x71>
mov    0x8(%rsp),%rsi
sub    %rbx,%rsi
mov    %rbx,%rdx
mov    %rbp,%rdi
callq  184 <stream_write_multiline+0x71>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
stream_write_multiline(dico_stream_t str, const char *text)
{
    struct utf8_iterator itr;
    size_t len = 0;
    for (utf8_iter_first(&itr, (char*)text);
  !utf8_iter_end_p(&itr);
  utf8_iter_next(&itr)) {
 if (((itr).curwidth == 1 && ((((itr).curptr[0]) & ~0x7f) == 0)) && *itr.curptr == '\n') {
     dico_stream_writeln(str, itr.curptr - len, len);
     len = 0;
 } else
     len += itr.curwidth;
    }
    if (len)
 dico_stream_writeln(str, itr.curptr - len, len);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 4
8 5
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 10
20 10
21 12
22 12
23 7
24 7
25 6
26 6
27 5
28 5
29 14
30 14
31 15
32 15
33 15
34 15
35 15
36 16
37 16
38 16
39 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rcx,%r12
mov    0x10(%rdi),%rax
mov    0x18(%rsi),%ebp
or     0x18(%rdi),%ebp
test   %rax,%rax
jne    704 <usage_argful_short_opt+0x28>
mov    0x10(%rsi),%rax
test   %rax,%rax
je     770 <usage_argful_short_opt+0x94>
test   $0x10,%bpl
jne    770 <usage_argful_short_opt+0x94>
mov    %rax,%rsi
mov    %rdx,%rdi
callq  715 <usage_argful_short_opt+0x39>
mov    %rax,%r13
test   $0x1,%bpl
je     738 <usage_argful_short_opt+0x5c>
mov    0x8(%rbx),%edx
mov    %rax,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  736 <usage_argful_short_opt+0x5a>
jmp    770 <usage_argful_short_opt+0x94>
mov    %rax,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x5(%rcx),%rsi
mov    %r12,%rdi
callq  648 <space>
mov    0x8(%rbx),%edx
mov    %r13,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  770 <usage_argful_short_opt+0x94>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
usage_argful_short_opt (const struct argp_option *opt,
                        const struct argp_option *real,
                        const char *domain, void *cookie)
{
  argp_fmtstream_t stream = cookie;
  const char *arg = opt->arg;
  int flags = opt->flags | real->flags;
  if (! arg)
    arg = real->arg;
  if (arg && !(flags & 0x10))
    {
      arg = dgettext (domain, arg);
      if (flags & 0x1)
        argp_fmtstream_printf (stream, " [-%c[%s]]", opt->key, arg);
      else
        {
          space (stream, 6 + strlen (arg));
          argp_fmtstream_printf (stream, "[-%c %s]", opt->key, arg);
        }
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 7
10 7
11 8
12 8
13 9
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 13
23 13
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 18
40 18
41 18
42 18
43 18
44 18
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
reversehalton_state_size (unsigned int dimension)
{
  return sizeof (reversehalton_state_t);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
cmpb   $0x0,(%rax)
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
utf8_iter_end_p(struct utf8_iterator *itr)
{
    return *itr->curptr == 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2018 <send_docmd+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_docmd (char *name)
{
  return (send_tncmd (send_do, "do", name));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     217 <array_dequote_escapes+0x59>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     21e <array_dequote_escapes+0x60>
cmpl   $0x0,0x10(%rdi)
je     225 <array_dequote_escapes+0x67>
mov    0x10(%rax),%rbx
cmp    %rbx,%rax
je     22c <array_dequote_escapes+0x6e>
mov    0x8(%rbx),%rdi
callq  1eb <array_dequote_escapes+0x2d>
mov    %rax,%rbp
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     206 <array_dequote_escapes+0x48>
mov    $0x17c,%edx
mov    $0x0,%esi
callq  206 <array_dequote_escapes+0x48>
mov    %rbp,0x8(%rbx)
mov    0x10(%rbx),%rbx
cmp    %rbx,0x18(%r12)
jne    1e2 <array_dequote_escapes+0x24>
jmp    231 <array_dequote_escapes+0x73>
mov    $0x0,%eax
jmp    234 <array_dequote_escapes+0x76>
mov    $0x0,%eax
jmp    234 <array_dequote_escapes+0x76>
mov    $0x0,%eax
jmp    234 <array_dequote_escapes+0x76>
mov    %rdi,%rax
jmp    234 <array_dequote_escapes+0x76>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
array_dequote_escapes(array)
ARRAY *array;
{
 ARRAY_ELEMENT *a;
 char *t;
 if (array == 0 || ((array)->head) == 0 || ((array)->num_elements == 0))
  return (ARRAY *)((void *)0);
 for (a = ((array->head)->next); a != array->head; a = ((a)->next)) {
  t = dequote_escapes (a->value);
  do { if (a->value) sh_xfree((a->value), "array.c", 380); } while (0);
  a->value = t;
 }
 return array;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 11
25 8
26 8
27 8
28 8
29 7
30 7
31 7
32 7
33 7
34 7
35 13
36 13
37 13
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
callq  b8f <or_term>
mov    %eax,%ecx
test   %eax,%eax
jne    c7f <logical_and_term+0x82>
jmp    c4e <logical_and_term+0x51>
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
test   %eax,%eax
je     c72 <logical_and_term+0x75>
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  b8f <or_term>
test   %eax,%eax
jne    c44 <logical_and_term+0x47>
cmpl   $0x0,(%rbx)
je     c40 <logical_and_term+0x43>
cmpl   $0x0,0xc(%rsp)
setne  %al
movzbl %al,%eax
mov    %eax,(%rbx)
jmp    c4e <logical_and_term+0x51>
cmpl   $0x0,(%rbx)
jne    c79 <logical_and_term+0x7c>
cmp    $0x3,%eax
ja     c7d <logical_and_term+0x80>
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
cmp    $0x12,%eax
je     c12 <logical_and_term+0x15>
mov    $0x6,%ecx
test   %eax,%eax
je     c7f <logical_and_term+0x82>
callq  0 <eval_undo>
mov    $0x0,%ecx
jmp    c7f <logical_and_term+0x82>
mov    $0x6,%ecx
jmp    c7f <logical_and_term+0x82>
mov    %eax,%ecx
jmp    c7f <logical_and_term+0x82>
mov    %eax,%ecx
mov    %ecx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
logical_and_term (eval_token et, int32_t *v1)
{
  int32_t v2;
  eval_error er;
  if ((er = or_term (et, v1)) != NO_ERROR)
    return er;
  while ((et = eval_lex (&v2)) == LAND)
    {
      et = eval_lex (&v2);
      if (et == ERROR)
        return UNKNOWN_INPUT;
      er = or_term (et, &v2);
      if (er == NO_ERROR)
        *v1 = *v1 && v2;
      else if (*v1 == 0 && er < SYNTAX_ERROR)
        ;
      else
        return er;
    }
  if (et == ERROR)
    return UNKNOWN_INPUT;
  eval_undo ();
  return NO_ERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 6
6 5
7 5
8 5
9 9
10 9
11 10
12 10
13 12
14 12
15 12
16 13
17 13
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 15
26 15
27 15
28 15
29 7
30 7
31 7
32 7
33 21
34 20
35 20
36 22
37 23
38 23
39 11
40 11
41 12
42 12
43 12
44 24
45 24
46 24
47 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  51c <rec_record_field_p+0x9>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_record_field_p (rec_record_t record,
                    const char *field_name)
{
  return (rec_record_get_num_fields_by_name (record, field_name) > 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%ecx
mov    $0x0,%edx
callq  2c8 <mu_property_set+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_property_set (mu_property_t prop, const char *key)
{
  return mu_property_set_value (prop, key, "", 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%r8
mov    0x30(%rdi),%rcx
mov    $0x0,%edx
callq  3d <gl_array_sortedlist_indexof_from_to>
add    $0x1,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_array_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar,
                            const void *elt)
{
  size_t index =
    gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 6
7 7
8 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
callq  a <echo_finish+0xa>
mov    0x0(%rip),%rax        # 11 <echo_finish+0x11>
mov    0xb0(%rax),%rdx
test   %rdx,%rdx
je     af <echo_finish+0xaf>
cmpq   $0xf,0x0(%rip)        # 29 <echo_finish+0x29>
jbe    af <echo_finish+0xaf>
mov    0x68(%rax),%rbx
add    0xb8(%rax),%rdx
js     43 <echo_finish+0x43>
cvtsi2sd %rdx,%xmm1
jmp    58 <echo_finish+0x58>
mov    %rdx,%rax
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x10(%rbx),%xmm0
divsd  %xmm1,%xmm0
movapd %xmm0,%xmm5
movsd  0x18(%rbx),%xmm0
divsd  %xmm1,%xmm0
movapd %xmm5,%xmm4
movsd  %xmm5,0x8(%rsp)
mulsd  %xmm5,%xmm4
subsd  %xmm4,%xmm0
movsd  0x0(%rip),%xmm1        # 88 <echo_finish+0x88>
callq  8d <echo_finish+0x8d>
movapd %xmm0,%xmm3
movsd  0x8(%rbx),%xmm2
movsd  0x8(%rsp),%xmm1
movsd  (%rbx),%xmm0
mov    $0x0,%edi
mov    $0x4,%eax
callq  af <echo_finish+0xaf>
mov    0x0(%rip),%rax        # b6 <echo_finish+0xb6>
cmpq   $0x0,0xb0(%rax)
sete   %al
movzbl %al,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
echo_finish (void)
{
  ping_finish ();
  if (ping->ping_num_recv && ((data_length) >= sizeof (struct timeval)))
    {
      struct ping_stat *ping_stat = (struct ping_stat *) ping->ping_closure;
      double total = ping->ping_num_recv + ping->ping_num_rept;
      double avg = ping_stat->tsum / total;
      double vari = ping_stat->tsumsq / total - avg * avg;
      printf ("round-trip min/avg/max/stddev = %.3f/%.3f/%.3f/%.3f ms\n",
       ping_stat->tmin, avg, ping_stat->tmax, nsqrt (vari, 0.0005));
    }
  return (ping->ping_num_recv == 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 13
40 13
41 13
42 13
43 14
44 14
45 14
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  c4 <rmt_error+0x8>
mov    %rax,%rsi
mov    %ebx,%edi
callq  0 <rmt_error_message>
pop    %rbx
retq   
<<<sep_in_sample>>>
rmt_error (int code)
{
  rmt_error_message (code, strerror (code));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x18,%edi
callq  11b <grecs_list_append+0x16>
mov    %rbp,0x10(%rax)
mov    0x8(%rbx),%rsi
mov    $0x0,%ecx
mov    %rax,%rdx
mov    %rbx,%rdi
callq  133 <grecs_list_append+0x2e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_list_append(struct grecs_list *lp, void *val)
{
 struct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));
 ep->data = val;
 grecs_list_insert_entry(lp, lp->tail, ep, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %rdx,%r8
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  629 <gsl_vector_char_fprintf+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_char_fprintf (FILE * stream, const gsl_vector_char * v,
                                const char *format)
{
  int status = gsl_block_char_raw_fprintf (stream,
                                                  v->data,
                                                  v->size,
                                                  v->stride,
                                                  format);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 10
9 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  4de <emit_bug_reporting_address+0xb>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  4f0 <emit_bug_reporting_address+0x1d>
mov    $0x0,%edi
callq  4fa <emit_bug_reporting_address+0x27>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  511 <emit_bug_reporting_address+0x3e>
mov    0x0(%rip),%rbx        # 518 <emit_bug_reporting_address+0x45>
mov    $0x0,%edi
callq  522 <emit_bug_reporting_address+0x4f>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  52d <emit_bug_reporting_address+0x5a>
pop    %rbx
retq   
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  printf (gettext ("\nReport bugs to: %s\n"), "bug-cpio@gnu.org");
  printf (gettext ("%s home page: <%s>\n"), "GNU cpio", "http://www.gnu.org/software/cpio");
  fputs_unlocked (gettext ("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),stdout)
                ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  5c6 <_print_str+0x16>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_print_str (void *item, void *data)
{
  printf (" %s", (char*)item);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %r14
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%rdx
cmp    (%rdi),%rdx
jne    20ed <gsl_matrix_uchar_equal+0x1f>
mov    0x8(%rsi),%rcx
cmp    %rax,%rcx
je     210d <gsl_matrix_uchar_equal+0x3f>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2106 <gsl_matrix_uchar_equal+0x38>
mov    $0x0,%eax
jmp    2183 <gsl_matrix_uchar_equal+0xb5>
mov    0x10(%rdi),%rbp
mov    0x10(%rsi),%r12
test   %rdx,%rdx
je     2163 <gsl_matrix_uchar_equal+0x95>
mov    $0x0,%r11d
mov    $0x0,%r10d
mov    $0x0,%ebx
jmp    215c <gsl_matrix_uchar_equal+0x8e>
mov    $0x0,%eax
mov    %r10,%r9
add    0x18(%rdi),%r9
mov    %r11,%r8
add    0x18(%rsi),%r8
movzbl (%r8,%rax,1),%r14d
cmp    %r14b,(%r9,%rax,1)
je     2178 <gsl_matrix_uchar_equal+0xaa>
jmp    216a <gsl_matrix_uchar_equal+0x9c>
add    $0x1,%rbx
add    %rbp,%r10
add    %r12,%r11
cmp    %rdx,%rbx
je     2171 <gsl_matrix_uchar_equal+0xa3>
test   %rcx,%rcx
jne    212d <gsl_matrix_uchar_equal+0x5f>
jmp    214d <gsl_matrix_uchar_equal+0x7f>
mov    $0x1,%eax
jmp    2183 <gsl_matrix_uchar_equal+0xb5>
mov    $0x0,%eax
jmp    2183 <gsl_matrix_uchar_equal+0xb5>
mov    $0x1,%eax
jmp    2183 <gsl_matrix_uchar_equal+0xb5>
add    $0x1,%rax
cmp    %rcx,%rax
jne    2140 <gsl_matrix_uchar_equal+0x72>
jmp    214d <gsl_matrix_uchar_equal+0x7f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_equal (const gsl_matrix_uchar * a, const gsl_matrix_uchar * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 21
29 21
30 21
31 21
32 21
33 20
34 20
35 20
36 20
37 14
38 14
39 14
40 14
41 14
42 16
43 16
44 16
45 29
46 29
47 23
48 23
49 29
50 29
51 16
52 16
53 16
54 16
55 30
56 30
57 30
58 30
59 30
60 30
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0x670(%rdi),%rdx
add    %rdx,(%rax)
retq   
<<<sep_in_sample>>>
GetNumberOfMCVars (PLEVEL plevel, char **args)
{
  long *pnThetas = (long *) args[0];
  *pnThetas += plevel->nMCVars;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # b <madir_argmatch+0xb>
mov    %rax,(%rsp)
mov    $0x0,%r9d
mov    $0x4,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
callq  2a <madir_argmatch+0x2a>
cltq   
mov    0x0(,%rax,4),%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
madir_argmatch (const char * option, const char * arg)
{
  return (madir_types [__xargmatch_internal ((option), (arg), (madir_args), (const char *) (madir_types), sizeof (*(madir_types)), 0, argmatch_die)]);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
lea    0x0(,%rsi,8),%rbx
mov    (%rdi),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  82 <rkck_reset+0x21>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  93 <rkck_reset+0x32>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  a4 <rkck_reset+0x43>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  b5 <rkck_reset+0x54>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  c6 <rkck_reset+0x65>
mov    0x28(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  d7 <rkck_reset+0x76>
mov    0x38(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  e8 <rkck_reset+0x87>
mov    0x30(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  f9 <rkck_reset+0x98>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rkck_reset (void *vstate, size_t dim)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->k4),0,(dim)*sizeof(double));
  memset((state->k5),0,(dim)*sizeof(double));
  memset((state->k6),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 13
39 13
40 13
41 13
42 13
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  d58 <username+0x9>
mov    %eax,%edi
callq  d5f <username+0x10>
test   %rax,%rax
jne    d7a <username+0x2b>
callq  d69 <username+0x1a>
mov    %eax,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  d7a <username+0x2b>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
username (void)
{
  const struct passwd *pw;
  pw = getpwuid (getuid ());
  if (pw == ((void *)0))
    {
      syserr ("Who are you?\n"
              "You don't seem to have an entry in the user database "
              "(/etc/passwd) (uid=%d)", (int)getuid ());
      exit (71);
    }
  return (pw->pw_name);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 9
8 7
9 7
10 7
11 7
12 12
13 13
14 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
addq   $0x1,0x120(%rdx)
cmpb   $0x0,0x1a(%rdx)
jne    f14 <apply_predicate+0x27>
cmpb   $0x0,0x1b(%rdx)
jne    f14 <apply_predicate+0x27>
cmpb   $0x0,0x1c(%rdx)
je     f2d <apply_predicate+0x40>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  f22 <apply_predicate+0x35>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    f44 <apply_predicate+0x57>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  *(%rbx)
test   %al,%al
je     f44 <apply_predicate+0x57>
addq   $0x1,0x128(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
apply_predicate(const char *pathname, struct stat *stat_buf, struct predicate *p)
{
  ++p->perf.visits;
  if (p->need_stat || p->need_type || p->need_inum)
    {
      if (get_info(pathname, stat_buf, p) != 0)
     return 0;
    }
  if ((p->pred_func)(pathname, stat_buf, p))
    {
      ++(p->perf.successes);
      return 1;
    }
  else
    {
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 7
20 6
21 6
22 9
23 9
24 9
25 9
26 9
27 9
28 11
29 18
30 18
31 18
32 18
<<<sep_out_sample>>>
mov    (%rsi),%rax
cmp    %rax,(%rdi)
sete   %al
retq   
<<<sep_in_sample>>>
LCO_compare (void const *x, void const *y)
{
  struct LCO_ent const *ax = x;
  struct LCO_ent const *ay = y;
  return ax->st_dev == ay->st_dev;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdx,%rbp
xorpd  %xmm1,%xmm1
movsd  %xmm1,(%rsp)
movsd  %xmm1,0x8(%rsp)
movl   $0x0,0x10(%rsp)
mov    %rsp,%rdx
callq  55bd <gsl_sf_hyperg_U_int_e+0x28>
mov    %eax,%ebx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  55ca <gsl_sf_hyperg_U_int_e+0x35>
test   %eax,%eax
cmove  %ebx,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_U_int_e(const int a, const int b, const double x, gsl_sf_result * result)
{
  gsl_sf_result_e10 re = {0, 0, 0};
  int stat_U = gsl_sf_hyperg_U_int_e10_e(a, b, x, &re);
  int stat_c = gsl_sf_result_smash_e(&re, result);
  return ((stat_c) != GSL_SUCCESS ? (stat_c) : ((stat_U) != GSL_SUCCESS ? (stat_U) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x40(%rdi),%rbp
mov    $0x0,%edx
mov    %rbp,%rsi
callq  3c1f <point_forward_char+0x1a>
movslq %eax,%rdx
mov    0x60(%rbx),%rcx
cmp    %rcx,%rdx
jae    3c53 <point_forward_char+0x4e>
mov    0x68(%rbx),%r8
mov    (%r8,%rdx,8),%rsi
cmp    %rbp,%rsi
jne    3c49 <point_forward_char+0x44>
add    $0x1,%eax
movslq %eax,%rdx
cmp    %rcx,%rdx
jae    3c53 <point_forward_char+0x4e>
cmp    %rsi,(%r8,%rdx,8)
je     3c38 <point_forward_char+0x33>
mov    (%r8,%rdx,8),%rax
mov    %rax,0x40(%rbx)
jmp    3c5b <point_forward_char+0x56>
mov    %rbx,%rdi
callq  3b32 <point_next_line>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
point_forward_char (WINDOW *win)
{
  long point = win->point;
  int col;
  col = window_point_to_column (win, point, 0);
  for (; col < win->line_map.used && win->line_map.map[col] == point; col++)
    ;
  if (col < win->line_map.used)
    win->point = win->line_map.map[col];
  else
    point_next_line (win);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 9
24 9
25 9
26 11
27 11
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
lea    (%rdi,%rdi,2),%rax
lea    (%rdi,%rax,4),%rbp
shl    $0x3,%rbp
mov    %rbp,%rdi
callq  dd <cue_TRACK_init+0x1d>
test   %rbx,%rbx
je     139 <cue_TRACK_init+0x79>
mov    %rax,%rdx
lea    (%rax,%rbp,1),%rdi
movl   $0x0,(%rdx)
movq   $0x0,0x8(%rdx)
movb   $0x0,0x10(%rdx)
movq   $0x0,0x20(%rdx)
movq   $0x0,0x28(%rdx)
movq   $0x0,0x30(%rdx)
movl   $0x0,0x38(%rdx)
movq   $0x0,0x48(%rdx)
movl   $0x0,0x50(%rdx)
movl   $0x0,0x54(%rdx)
add    $0x68,%rdx
cmp    %rdi,%rdx
jne    e9 <cue_TRACK_init+0x29>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cue_TRACK_init (size_t entries)
{
  struct cue_TRACK *track;
  size_t entry;
  track = xmalloc (sizeof (*track) * entries);
  for (entry = 0; entry < entries; entry++)
    {
      track[entry].datatype = 0;
      track[entry].FLAGS = ((void *)0);
      track[entry].ISRC[0] = '\0';
      track[entry].PERFORMER = ((void *)0);
      track[entry].SONGWRITER = ((void *)0);
      track[entry].TITLE = ((void *)0);
      track[entry].PREGAP.initialized = 0;
      track[entry].INDEX = ((void *)0);
      track[entry].IndexEntries = 0;
      track[entry].POSTGAP.initialized = 0;
    }
  return track;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 8
15 9
16 10
17 11
18 12
19 13
20 14
21 15
22 16
23 17
24 17
25 6
26 6
27 20
28 20
29 20
30 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  a51 <read_header0+0x9>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  a63 <read_header0+0x1b>
cmp    $0x1,%eax
jne    a7b <read_header0+0x33>
mov    0x0(%rip),%rdi        # a6f <read_header0+0x27>
callq  a74 <read_header0+0x2c>
mov    $0x1,%eax
jmp    ab9 <read_header0+0x71>
mov    0x0(%rip),%rax        # a82 <read_header0+0x3a>
test   %rax,%rax
je     a89 <read_header0+0x41>
callq  *%rax
mov    $0x0,%edi
callq  a93 <read_header0+0x4b>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  aaa <read_header0+0x62>
movl   $0x2,0x0(%rip)        # ab4 <read_header0+0x6c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
read_header0 (struct tar_stat_info *info)
{
  enum read_header rc;
  tar_stat_init (info);
  rc = read_header (&current_header, info, read_header_auto);
  if (rc == HEADER_SUCCESS)
    {
      set_next_block_after (current_header);
      return 1;
    }
  do { if (error_hook) error_hook (); error (0, 0, gettext ("This does not look like a tar archive")); exit_status = 2; } while (0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 5
7 5
8 6
9 6
10 8
11 8
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 12
27 13
28 13
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1a <rpmErrorSetCallback+0x7>
mov    %rdi,0x0(%rip)        # 21 <rpmErrorSetCallback+0xe>
retq   
<<<sep_in_sample>>>
rpmErrorSetCallback(rpmErrorCallBackType cb)
{
    rpmErrorCallBackType ocb;
    ocb = errorCallback;
    errorCallback = cb;
    return ocb;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %ecx,%r12d
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 4de2 <us_fl_hdy+0x27>
movl   $0x0,0x0(%rip)        # 4dec <us_fl_hdy+0x31>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  4df8 <us_fl_hdy+0x3d>
mov    0x0(%rip),%r15        # 4dff <us_fl_hdy+0x44>
mov    0x0(%rip),%rdi        # 4e06 <us_fl_hdy+0x4b>
callq  4e0b <us_fl_hdy+0x50>
mov    0x70(%rsp),%ecx
mov    %ecx,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
movl   $0x2,(%rsp)
mov    $0xc,%r9d
mov    $0x0,%r8d
mov    %r15,%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    (%rbx),%edi
callq  4e44 <us_fl_hdy+0x89>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
us_fl_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_FL";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected,
    gettext(hd_text[221].ht_text), ptr_cc_id, "+",
    12, 2, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 12
16 12
17 12
18 13
19 14
20 14
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 16
<<<sep_out_sample>>>
mov    (%rdi),%rcx
test   %rcx,%rcx
je     71 <gsl_histogram_mean+0x71>
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
fldz   
fld    %st(0)
mov    $0x0,%eax
xorpd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm4        # 25 <gsl_histogram_mean+0x25>
add    $0x1,%rax
movsd  (%rdx,%rax,8),%xmm2
movsd  -0x8(%rdx,%rax,8),%xmm1
movsd  -0x8(%rsi,%rax,8),%xmm0
ucomisd %xmm3,%xmm0
jbe    68 <gsl_histogram_mean+0x68>
movsd  %xmm0,-0x18(%rsp)
fldl   -0x18(%rsp)
fadd   %st,%st(1)
addsd  %xmm2,%xmm1
mulsd  %xmm4,%xmm1
movsd  %xmm1,-0x18(%rsp)
fld    %st(2)
fsubrl -0x18(%rsp)
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
cmp    %rcx,%rax
jne    25 <gsl_histogram_mean+0x25>
fstp   %st(0)
jmp    73 <gsl_histogram_mean+0x73>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_histogram_mean (const gsl_histogram * h)
{
  const size_t n = h->n;
  size_t i;
  long double wmean = 0;
  long double W = 0;
  for (i = 0; i < n; i++)
    {
      double xi = (h->range[i + 1] + h->range[i]) / 2;
      double wi = h->bin[i];
      if (wi > 0)
        {
          W += wi;
          wmean += (xi - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 3
2 7
3 7
4 9
5 10
6 6
7 6
8 7
9 11
10 9
11 9
12 9
13 9
14 10
15 11
16 11
17 13
18 13
19 13
20 9
21 9
22 9
23 14
24 14
25 14
26 14
27 14
28 14
29 7
30 7
31 7
32 7
33 5
34 17
35 17
36 18
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    0x8(%rdi),%edx
mov    $0x0,%eax
cmp    (%rsi),%edx
jne    2d <CDB___lock_cmp+0x2d>
sub    $0x8,%rsp
mov    %edx,%edx
add    %rcx,%rsi
mov    (%rdi),%rdi
callq  21 <CDB___lock_cmp+0x21>
test   %eax,%eax
sete   %al
movzbl %al,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
CDB___lock_cmp(dbt, lock_obj)
 const DBT *dbt;
 DB_LOCKOBJ *lock_obj;
{
 void *obj_data;
 obj_data = ((void *)(((u_int8_t *)(&lock_obj->lockobj)) + (&lock_obj->lockobj)->off));
 return (dbt->size == lock_obj->lockobj.size &&
  memcmp(dbt->data, obj_data, dbt->size) == 0);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 4
7 8
8 6
9 8
10 8
11 7
12 7
13 7
14 9
15 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%r13d
mov    %rdx,%rbp
test   %rdi,%rdi
cmove  0x0(%rip),%rbx        # 1e <__gmpq_out_str+0x1e>
mov    %rbx,%rdi
callq  26 <__gmpq_out_str+0x26>
mov    %rax,%r12
add    $0x10,%rbp
mov    $0x1,%esi
mov    %rbp,%rdi
callq  3a <__gmpq_out_str+0x3a>
test   %eax,%eax
je     5e <__gmpq_out_str+0x5e>
mov    %rbx,%rsi
mov    $0x2f,%edi
callq  4b <__gmpq_out_str+0x4b>
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  59 <__gmpq_out_str+0x59>
lea    0x1(%r12,%rax,1),%r12
mov    %rbx,%rdi
callq  66 <__gmpq_out_str+0x66>
test   %eax,%eax
mov    $0x0,%eax
cmove  %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__gmpq_out_str (FILE *stream, int base, mpq_srcptr q)
{
  size_t written;
  if (stream == ((void *)0))
    stream = stdout;
  written = __gmpz_out_str (stream, base, (&((q)->_mp_num)));
  if ((__builtin_constant_p (1) && (1) == 0 ? (((&((q)->_mp_den)))->_mp_size < 0 ? -1 : ((&((q)->_mp_den)))->_mp_size > 0) : __gmpz_cmp_ui ((&((q)->_mp_den)),1)) != 0)
    {
      _IO_putc ('/', stream);
      written += 1 + __gmpz_out_str (stream, base, (&((q)->_mp_den)));
    }
  return ferror (stream) ? 0 : written;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 12
31 12
32 12
33 13
34 13
35 13
36 13
37 13
38 13
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rdx
cmpl   $0x0,0x0(%rip)        # 1c1 <imap_step_send+0xf>
je     1d9 <imap_step_send+0x27>
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x0,%eax
callq  1d7 <imap_step_send+0x25>
jmp    1ed <imap_step_send+0x3b>
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x0,%eax
callq  1ed <imap_step_send+0x3b>
mov    $0x0,%edx
test   %eax,%eax
js     214 <imap_step_send+0x62>
mov    0x8(%rsp),%rdi
callq  200 <imap_step_send+0x4e>
mov    %eax,%ebx
mov    0x8(%rsp),%rdi
callq  20c <imap_step_send+0x5a>
test   %ebx,%ebx
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
imap_step_send (const char *data)
{
  char *buf;
  int rc;
  int len;
  if (args_info.server_flag)
    len = asprintf (&buf, "+ %s", data);
  else
    len = asprintf (&buf, "%s", data);
  if (len < 0)
    return 0;
  rc = writeln (buf);
  free (buf);
  if (!rc)
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 11
16 10
17 10
18 12
19 12
20 12
21 13
22 13
23 14
24 14
25 14
26 17
27 17
28 17
29 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r12d
mov    %rsi,%r13
mov    %rdx,%rbp
callq  c7b <blocking_write+0x18>
mov    %rax,%rbx
cmp    %rax,%rbp
jbe    cda <blocking_write+0x77>
callq  c88 <blocking_write+0x25>
cmpl   $0xb,(%rax)
jne    cda <blocking_write+0x77>
mov    $0x3,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  c9f <blocking_write+0x3c>
test   %eax,%eax
js     cda <blocking_write+0x77>
test   $0x8,%ah
je     cda <blocking_write+0x77>
and    $0xf7,%ah
mov    %eax,%edx
mov    $0x4,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  cbf <blocking_write+0x5c>
cmp    $0xffffffff,%eax
je     cda <blocking_write+0x77>
mov    %rbp,%rdx
sub    %rbx,%rdx
lea    0x0(%r13,%rbx,1),%rsi
mov    %r12d,%edi
callq  cd7 <blocking_write+0x74>
add    %rax,%rbx
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
blocking_write (int fd, void const *buf, size_t count)
{
  size_t bytes = full_write (fd, buf, count);
  if (bytes < count && (*__errno_location ()) == 11)
    {
      int flags = rpl_fcntl (fd, 3);
      if (0 <= flags && flags & 04000
   && rpl_fcntl (fd, 4, flags & ~04000) != -1)
 {
   char const *buffer = buf;
   bytes += full_write (fd, buffer + bytes, count - bytes);
 }
    }
  return bytes;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 11
33 11
34 11
35 11
36 11
37 11
38 15
39 15
40 15
41 15
42 15
43 15
44 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  b0b <lastpipe_cleanup+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lastpipe_cleanup (s)
     int s;
{
  unfreeze_jobs_list ();
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %edx,%ebx
test   %rsi,%rsi
je     129 <assert_grecs_value_type+0x1b>
mov    (%rsi),%edi
test   %edi,%edi
jne    15c <assert_grecs_value_type+0x4e>
cmpq   $0x0,0x28(%rsi)
jne    15c <assert_grecs_value_type+0x4e>
mov    %ebx,%edi
callq  130 <assert_grecs_value_type+0x22>
mov    %rax,%rbx
mov    $0x0,%edi
callq  13d <assert_grecs_value_type+0x2f>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  155 <assert_grecs_value_type+0x47>
mov    $0x1,%eax
jmp    1a1 <assert_grecs_value_type+0x93>
mov    $0x0,%eax
cmp    %ebx,%edi
je     1a1 <assert_grecs_value_type+0x93>
callq  16a <assert_grecs_value_type+0x5c>
mov    %rax,%r12
mov    %ebx,%edi
callq  174 <assert_grecs_value_type+0x66>
mov    %rax,%rbx
mov    $0x0,%edi
callq  181 <assert_grecs_value_type+0x73>
mov    %r12,%r8
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  19c <assert_grecs_value_type+0x8e>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
assert_grecs_value_type(grecs_locus_t *locus,
   const grecs_value_t *value, int type)
{
 if ((!(value) || ((value)->type == 0 && (value)->v.string == ((void *)0)))) {
  grecs_error(locus, 0, gettext("expected %s"),
       grecs_data_type_string(type));
  return 1;
 }
 if (value->type != type) {
  grecs_error(locus, 0, gettext("expected %s, but found %s"),
       grecs_data_type_string(type),
       grecs_data_type_string(value->type));
  return 1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 7
25 7
26 15
27 9
28 9
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 10
43 13
44 16
45 16
46 16
47 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rsi        # 5f4 <dumpintlstr+0x13>
test   %rsi,%rsi
je     628 <dumpintlstr+0x47>
cmpb   $0x2e,(%rsi)
jne    613 <dumpintlstr+0x32>
cmpb   $0x2f,0x1(%rsi)
jne    613 <dumpintlstr+0x32>
add    $0x2,%rsi
cmpb   $0x2e,(%rsi)
jne    613 <dumpintlstr+0x32>
cmpb   $0x2f,0x1(%rsi)
je     604 <dumpintlstr+0x23>
mov    0x0(%rip),%edx        # 619 <dumpintlstr+0x38>
mov    $0x0,%edi
mov    $0x0,%eax
callq  628 <dumpintlstr+0x47>
mov    $0x0,%edi
mov    $0x0,%eax
callq  637 <dumpintlstr+0x56>
mov    $0x1,%r9d
mov    $0x22,%r8d
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    0x0(%rip),%rsi        # 650 <dumpintlstr+0x6f>
mov    $0x0,%edi
callq  65a <dumpintlstr+0x79>
mov    $0xa,%edi
callq  664 <dumpintlstr+0x83>
mov    $0x0,%edi
callq  66e <dumpintlstr+0x8d>
mov    0x0(%rip),%rdi        # 675 <dumpintlstr+0x94>
callq  67a <dumpintlstr+0x99>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dumpintlstr(const char *str, size_t len)
{
 char *cp;
 if (source != ((void *)0)) {
  for (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)
   continue;
  printf("#: %s:%d\n", cp, sourceline);
 }
 printf("msgid ");
 pp_string_fp(fprintf, stdout, str, len, '"', 1);
 putchar('\n');
 printf("msgstr \"\"\n\n");
 fflush(stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 11
33 11
34 12
35 12
36 13
37 13
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
cmpl   $0x95f616,0x18(%rdi)
je     36 <cycle_check+0x26>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x3c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  36 <cycle_check+0x26>
mov    0x10(%rdi),%rdx
test   %rdx,%rdx
je     87 <cycle_check+0x77>
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    51 <cycle_check+0x41>
mov    0x8(%rdi),%rax
cmp    %rax,(%rsi)
je     81 <cycle_check+0x71>
lea    0x1(%rdx),%rcx
mov    %rcx,0x10(%rdi)
mov    $0x0,%eax
test   %rdx,%rcx
jne    91 <cycle_check+0x81>
mov    $0x1,%eax
test   %rcx,%rcx
je     91 <cycle_check+0x81>
mov    (%rsi),%rax
mov    %rax,0x8(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,(%rdi)
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
movq   $0x1,0x10(%rdi)
jmp    6d <cycle_check+0x5d>
repz retq 
<<<sep_in_sample>>>
cycle_check (struct cycle_check_state *state, struct stat const *sb)
{
  ((state->magic == 9827862) ? (void) (0) : __assert_fail ("state->magic == 9827862", "cycle-check.c", 60, __PRETTY_FUNCTION__));
  if (state->chdir_counter && ((*sb).st_ino == (state->dev_ino).st_ino && (*sb).st_dev == (state->dev_ino).st_dev))
    return 1;
  if (is_zero_or_power_of_two (++(state->chdir_counter)))
    {
      if (state->chdir_counter == 0)
        return 1;
      state->dev_ino.st_dev = sb->st_dev;
      state->dev_ino.st_ino = sb->st_ino;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 6
19 6
20 13
21 6
22 6
23 9
24 8
25 8
26 10
27 10
28 11
29 11
30 13
31 13
32 5
33 5
34 6
35 6
36 14
<<<sep_out_sample>>>
movzbl %dil,%edi
mov    0x0(,%rdi,4),%eax
retq   
<<<sep_in_sample>>>
pch_mode (_Bool which)
{
  return p_mode[which];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 5b5 <dolinemode+0xb>
je     5c6 <dolinemode+0x1c>
mov    $0x1,%esi
mov    $0x3,%edi
callq  5c6 <dolinemode+0x1c>
mov    $0x1,%esi
mov    $0x22,%edi
callq  5d5 <dolinemode+0x2b>
mov    $0x1,%esi
mov    $0x1,%edi
callq  5e4 <dolinemode+0x3a>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dolinemode (void)
{
  if (kludgelinemode)
    send_dont (3, 1);
  send_will (34, 1);
  send_dont (1, 1);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  368 <gsl_stats_uint_absdev+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  376 <gsl_stats_uint_absdev+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_uint_absdev (const unsigned int data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_uint_mean(data, stride, n);
  return gsl_stats_uint_absdev_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18b <xunlink+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xunlink (filename)
     char *filename;
{
  int r = unlink (filename);
  return r;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <history_search_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
history_search_prefix (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 1));
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1b5 <_s_close+0x9>
mov    (%rax),%rdi
callq  1bd <_s_close+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_s_close (mu_stream_t stream)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_close (s->fstream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    0xc(%rdi),%edx
sub    0xc(%rsi),%edx
mov    %edx,%eax
test   %edx,%edx
jne    12 <stemlen_compare+0x12>
mov    0x10(%rdi),%eax
sub    0x10(%rsi),%eax
repz retq 
<<<sep_in_sample>>>
stemlen_compare (const void *v1, const void *v2)
{
  const struct tryrule *r1 = v1;
  const struct tryrule *r2 = v2;
  int r = r1->stemlen - r2->stemlen;
  return r != 0 ? r : (int)(r1->order - r2->order);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 7
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rdi        # 1b5 <is_ok+0x13>
callq  1ba <is_ok+0x18>
mov    $0x0,%edi
callq  1c4 <is_ok+0x22>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 1d4 <is_ok+0x32>
mov    $0x0,%eax
callq  1de <is_ok+0x3c>
test   %eax,%eax
jns    208 <is_ok+0x66>
mov    $0x0,%edi
callq  1ec <is_ok+0x4a>
mov    %rax,%rbx
callq  1f4 <is_ok+0x52>
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  208 <is_ok+0x66>
mov    0x0(%rip),%rdi        # 20f <is_ok+0x6d>
callq  214 <is_ok+0x72>
callq  219 <is_ok+0x77>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
is_ok (const char *program, const char *arg)
{
  rpl_fflush (stdout);
  if (fprintf (stderr, gettext ("< %s ... %s > ? "), program, arg) < 0)
    {
      error (1, (*__errno_location ()), gettext ("Failed to write prompt for -ok"));
    }
  rpl_fflush (stderr);
  return yesno ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 8
28 8
29 9
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2a1a <parse_language_map+0x23>
test   %eax,%eax
jne    2a3f <parse_language_map+0x48>
mov    $0x0,%edi
callq  2a28 <parse_language_map+0x31>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  2a3f <parse_language_map+0x48>
test   %rbx,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  2a58 <parse_language_map+0x61>
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_language_map (char const *file_name)
{
  if (_obstack_begin ((&lang_args_obstack), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free) == 0)
    error (1, 0, gettext ("can't allocate language args obstack: memory exhausted"));
  if (file_name == 0)
    file_name = "/usr/local/share/id-lang.map";
  parse_language_map_file (file_name, &lang_args_list);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 6
20 6
21 7
22 7
23 7
24 8
25 8
<<<sep_out_sample>>>
test   %rcx,%rcx
je     169b <gsl_permute_ushort_inverse+0x71>
lea    (%rdx,%rdx,1),%r11
mov    $0x0,%edx
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    164a <gsl_permute_ushort_inverse+0x20>
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     1641 <gsl_permute_ushort_inverse+0x17>
cmp    %rax,%rdx
ja     167a <gsl_permute_ushort_inverse+0x50>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
jne    1685 <gsl_permute_ushort_inverse+0x5b>
jmp    167a <gsl_permute_ushort_inverse+0x50>
mov    %r9d,%r10d
mov    %r11,%rax
imul   %r8,%rax
add    %rsi,%rax
movzwl (%rax),%r9d
mov    %r10w,(%rax)
mov    (%rdi,%r8,8),%r8
cmp    %rdx,%r8
jne    165a <gsl_permute_ushort_inverse+0x30>
jmp    1690 <gsl_permute_ushort_inverse+0x66>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    1638 <gsl_permute_ushort_inverse+0xe>
jmp    169b <gsl_permute_ushort_inverse+0x71>
imul   %r11,%rax
movzwl (%rsi,%rax,1),%r10d
jmp    165d <gsl_permute_ushort_inverse+0x33>
imul   %r11,%r8
mov    %r9w,(%rsi,%r8,1)
jmp    167a <gsl_permute_ushort_inverse+0x50>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_ushort_inverse (const size_t * p, unsigned short * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned short t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned short r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 18
4 4
5 6
6 7
7 7
8 8
9 7
10 7
11 9
12 9
13 11
14 12
15 12
16 12
17 23
18 23
19 23
20 23
21 23
22 24
23 28
24 19
25 19
26 19
27 4
28 4
29 4
30 4
31 18
32 18
33 18
34 31
35 31
36 31
37 35
38 35
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  d <symevt_free+0xd>
mov    %rbx,%rdi
callq  15 <symevt_free+0x15>
pop    %rbx
retq   
<<<sep_in_sample>>>
symevt_free(void *p)
{
 struct symevt *sym = p;
 free(sym->name);
 free(sym);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     82c <gsl_matrix_complex_float_ispos+0x62>
lea    0x0(,%rax,8),%r10
mov    $0x0,%esi
mov    $0x0,%r8d
xorps  %xmm1,%xmm1
movaps %xmm1,%xmm0
jmp    819 <gsl_matrix_complex_float_ispos+0x4f>
ucomiss 0x4(%rdx,%rax,8),%xmm0
jae    832 <gsl_matrix_complex_float_ispos+0x68>
add    $0x1,%rax
cmp    %rcx,%rax
je     80d <gsl_matrix_complex_float_ispos+0x43>
ucomiss (%rdx,%rax,8),%xmm1
jb     7f5 <gsl_matrix_complex_float_ispos+0x2b>
jmp    838 <gsl_matrix_complex_float_ispos+0x6e>
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
je     83e <gsl_matrix_complex_float_ispos+0x74>
test   %rcx,%rcx
je     80d <gsl_matrix_complex_float_ispos+0x43>
mov    $0x0,%eax
mov    %rsi,%rdx
add    0x18(%rdi),%rdx
jmp    805 <gsl_matrix_complex_float_ispos+0x3b>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_ispos (const gsl_matrix_complex_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 9
15 9
16 9
17 13
18 13
19 13
20 7
21 7
22 7
23 7
24 9
25 9
26 13
27 13
28 13
29 13
30 20
31 20
32 15
33 15
34 15
35 15
36 20
37 21
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1baf <gsl_matrix_int_isnonneg+0x55>
lea    0x0(,%rax,4),%r10
mov    $0x0,%esi
mov    $0x0,%r9d
xorpd  %xmm1,%xmm1
jmp    1ba8 <gsl_matrix_int_isnonneg+0x4e>
mov    $0x0,%eax
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm0,%xmm1
jbe    1bc1 <gsl_matrix_int_isnonneg+0x67>
jmp    1bb5 <gsl_matrix_int_isnonneg+0x5b>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     1bbb <gsl_matrix_int_isnonneg+0x61>
test   %rdx,%rdx
jne    1b83 <gsl_matrix_int_isnonneg+0x29>
jmp    1b9c <gsl_matrix_int_isnonneg+0x42>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rdx,%rax
jne    1b8f <gsl_matrix_int_isnonneg+0x35>
jmp    1b9c <gsl_matrix_int_isnonneg+0x42>
<<<sep_in_sample>>>
gsl_matrix_int_isnonneg (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 20
26 20
27 15
28 15
29 20
30 20
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     da4 <strob_sprintf_at+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rcx
callq  dd5 <strob_sprintf_at+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
strob_sprintf_at(STROB * sb, int at_offset, char * format, ...)
{
 int ret;
 va_list ap;
 __builtin_va_start(ap,format);
 ret = strob_vsprintf_at(sb, at_offset, format, ap);
 __builtin_va_end(ap);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 9
24 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18f <hash_find_item+0x9>
mov    (%rax),%rax
test   %rax,%rax
je     1a9 <hash_find_item+0x23>
cmp    0x0(%rip),%rax        # 19e <hash_find_item+0x18>
mov    $0x0,%edx
cmove  %rdx,%rax
jmp    1ae <hash_find_item+0x28>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
hash_find_item (struct hash_table* ht, void const *key)
{
  void **slot = hash_find_slot (ht, key);
  return ((((*slot) == 0 || (void *) (*slot) == hash_deleted_item)) ? 0 : *slot);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x38(%rdi),%rbx
mov    %rbx,%rdi
callq  4c5 <CLEAR_STATE>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     69e <smtp_destroy+0x23>
callq  69e <smtp_destroy+0x23>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     6ac <smtp_destroy+0x31>
callq  6ac <smtp_destroy+0x31>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     6ba <smtp_destroy+0x3f>
callq  6ba <smtp_destroy+0x3f>
mov    %rbx,%rdi
callq  6c2 <smtp_destroy+0x47>
movq   $0x0,0x38(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
smtp_destroy (mu_mailer_t mailer)
{
  smtp_t smtp = mailer->data;
  CLEAR_STATE (smtp);
  if (smtp->mailhost)
    free (smtp->mailhost);
  if (smtp->localhost)
    free (smtp->localhost);
  if (smtp->buffer)
    free (smtp->buffer);
  free (smtp);
  mailer->data = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 5
9 5
10 5
11 6
12 7
13 7
14 7
15 8
16 9
17 9
18 9
19 10
20 11
21 11
22 12
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 6e6 <do_next_word_void+0xa>
shr    $0x1d,%edi
and    $0x1,%edi
mov    $0x1,%esi
callq  6f6 <do_next_word_void+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_next_word_void(void)
{
    do_next_word(((flags[((WORD_BOUNDS) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((WORD_BOUNDS) % (sizeof(unsigned) * 8)))) != 0), 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 91b <lex_clear_state+0xa>
retq   
<<<sep_in_sample>>>
lex_clear_state (void)
{
  (yy_start) = 1 + 2 * (0);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
retq   
<<<sep_in_sample>>>
initdiffcmd (register struct diffcmd *dc)
{
  dc->adprev = 0;
  dc->dafter = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %rsi,%rbx
mov    0x0(%rip),%rdi        # 12 <rmt_error_message+0x12>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x9,0x0(%rip)        # 1e <rmt_error_message+0x1e>
jle    ac <rmt_error_message+0xac>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  35 <rmt_error_message+0x35>
mov    0x0(%rip),%rdi        # 3c <rmt_error_message+0x3c>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x9,0x0(%rip)        # 48 <rmt_error_message+0x48>
jle    ac <rmt_error_message+0xac>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  5c <rmt_error_message+0x5c>
mov    0x0(%rip),%rdi        # 63 <rmt_error_message+0x63>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x0,0x0(%rip)        # 6f <rmt_error_message+0x6f>
jle    83 <rmt_error_message+0x83>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  83 <rmt_error_message+0x83>
mov    %rbx,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 94 <rmt_error_message+0x94>
mov    $0x0,%eax
callq  9e <rmt_error_message+0x9e>
mov    0x0(%rip),%rdi        # a5 <rmt_error_message+0xa5>
callq  aa <rmt_error_message+0xaa>
jmp    b5 <rmt_error_message+0xb5>
mov    0x0(%rip),%rdi        # b3 <rmt_error_message+0xb3>
jmp    68 <rmt_error_message+0x68>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rmt_error_message (int code, const char *msg)
{
  do { if (dbgout && (10) <= dbglev) fprintf (dbgout, "S: E%d\n", code); } while (0);
  do { if (dbgout && (10) <= dbglev) fprintf (dbgout, "S: %s\n", msg); } while (0);
  do { if (dbgout && (1) <= dbglev) fprintf (dbgout, "error: %s\n", msg); } while (0);
  fprintf (stdout, "E%d\n%s\n", code, msg);
  fflush_unlocked (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 6
34 6
35 6
36 6
37 6
38 6
39 7
40 7
41 7
42 5
43 5
44 8
45 8
46 8
47 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%r8
mov    (%rdi),%rcx
mov    0x8(%rdi),%r9
cmp    %rsi,%rcx
jbe    2483 <gsl_vector_uint_set_basis+0x27>
lea    0x0(,%r9,4),%rdi
mov    %r8,%rdx
mov    $0x0,%eax
test   %rcx,%rcx
jne    24a7 <gsl_vector_uint_set_basis+0x4b>
jmp    24b9 <gsl_vector_uint_set_basis+0x5d>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  24a0 <gsl_vector_uint_set_basis+0x44>
mov    $0x4,%eax
jmp    24cf <gsl_vector_uint_set_basis+0x73>
movl   $0x0,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    24a7 <gsl_vector_uint_set_basis+0x4b>
shl    $0x2,%r9
imul   %r9,%rsi
movl   $0x1,(%r8,%rsi,1)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_uint_set_basis (gsl_vector_uint * v, size_t i)
{
  unsigned int * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const unsigned int zero = 0U ;
  const unsigned int one = 1U;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(unsigned int *) (data + 1 * k * stride) = zero;
    }
  *(unsigned int *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 9
5 9
6 15
7 15
8 15
9 13
10 13
11 13
12 2
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 15
21 13
22 13
23 13
24 13
25 17
26 17
27 17
28 18
29 18
30 19
31 19
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2ac9 <rl_get_keymap_name_from_edit_mode+0x6>
cmp    $0x1,%eax
je     2adf <rl_get_keymap_name_from_edit_mode+0x1c>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_get_keymap_name_from_edit_mode ()
{
  if (rl_editing_mode == 1)
    return "emacs";
  else if (rl_editing_mode == 0)
    return "vi";
  else
    return "none";
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 6
6 6
7 6
8 6
9 4
10 9
<<<sep_out_sample>>>
mov    0x20(%rsi),%eax
cmp    %eax,0x20(%rdi)
sete   %al
retq   
<<<sep_in_sample>>>
sys_compare_gid (struct stat *a, struct stat *b)
{
  return a->st_gid == b->st_gid;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r12d
mov    %edx,%r9d
mov    $0x28,%r8d
mov    %esi,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xbe,(%rax)
mov    $0x0,%r9d
mov    $0x28,%r8d
mov    %r12d,%ecx
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  22b7 <_rx>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_ldr_c(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    _rex(_jit, 0, 1, r0, _NOREG, r1);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = 0xbe;
    _rx(_jit, r0, 0, r1, _NOREG, 0x00);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 7
29 7
30 7
31 7
<<<sep_out_sample>>>
movslq %esi,%rax
movabs $0x7fffffff8,%rdx
and    %rdx,%rax
add    %rdi,%rax
jmp    3ca <null_block+0x20>
add    $0x8,%rdi
cmpq   $0x0,-0x8(%rdi)
jne    3d5 <null_block+0x2b>
cmp    %rax,%rdi
jne    3bf <null_block+0x15>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
null_block (long *block, int size)
{
  register long *p = block;
  register int i = size / sizeof (long);
  while (i--)
    if (*p++)
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 6
8 6
9 5
10 5
11 8
12 8
13 7
14 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  24 <print_item+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_item(void *item)
{
    printf("%s", (char*)item);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x70(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->nx_add_after (list, node, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
rk4imp_order (void *vstate)
{
  rk4imp_state_t *state = (rk4imp_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdi
test   %rcx,%rcx
je     33f3 <gsl_vector_uchar_set_all+0x24>
mov    $0x0,%eax
mov    %sil,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    33e4 <gsl_vector_uchar_set_all+0x15>
repz retq 
<<<sep_in_sample>>>
gsl_vector_uchar_set_all (gsl_vector_uchar * v, unsigned char x)
{
  unsigned char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(unsigned char *) (data + 1 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 9
8 7
9 7
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x8(%rsi),%rax
cmp    %rax,%rdx
jb     14 <direntry_cmp_inode+0x14>
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rcx
mov    (%rcx),%eax
test   %r8,%r8
je     f7f <gsl_vector_uint_min+0x32>
lea    0x0(,%rdx,4),%rdi
mov    $0x0,%edx
mov    (%rcx),%esi
cmp    %esi,%eax
cmova  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    f6c <gsl_vector_uint_min+0x1f>
repz retq 
<<<sep_in_sample>>>
gsl_vector_uint_min (const gsl_vector_uint * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned int min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 9
8 7
9 9
10 9
11 9
12 7
13 7
14 7
15 7
16 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x6,0x8(%rsi)
ja     1e7 <fpe_handler+0x37>
mov    0x8(%rsi),%eax
jmpq   *0x0(,%rax,8)
mov    $0xfffffff6,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xffffffd6,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xffffffd5,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xffffffca,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xffffffd7,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xffffffc9,%edi
jmp    1f3 <fpe_handler+0x43>
mov    $0xfffffff5,%edi
callq  1f8 <signal_throw>
<<<sep_in_sample>>>
fpe_handler(int sig, siginfo_t *info, void *_)
{
  int code;
  switch(info->si_code) {
  case FPE_INTDIV: code=-10; break;
  case FPE_INTOVF: code=-11; break;
  case FPE_FLTDIV: code=-42; break;
  case FPE_FLTOVF: code=-43; break;
  case FPE_FLTUND: code=-54; break;
  case FPE_FLTRES: code=-41; break;
  default: code=-55; break;
  }
  throw(code);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 7
9 7
10 8
11 8
12 9
13 9
14 10
15 10
16 11
17 11
18 6
19 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  1ff <gsl_vector_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_fwrite (FILE * stream, const gsl_vector * v)
{
  int status = gsl_block_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     f <mu_nntp_set_timeout+0xf>
mov    %esi,0x70(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_nntp_set_timeout (mu_nntp_t nntp, int timeout)
{
  if (nntp == ((void *)0))
    return 22;
  nntp->timeout = timeout;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
mov    %esi,%r13d
mov    %rdx,%rbp
mov    %ecx,%r14d
mov    %r9,%rsi
mov    %r8,%rdi
callq  1f <verror_at_line+0x1f>
mov    %rax,%rbx
test   %rax,%rax
je     67 <verror_at_line+0x67>
test   %rbp,%rbp
je     4d <verror_at_line+0x4d>
mov    %rax,%r9
mov    $0x0,%r8d
mov    %r14d,%ecx
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  4b <verror_at_line+0x4b>
jmp    87 <verror_at_line+0x87>
mov    %rax,%rcx
mov    $0x0,%edx
mov    %r13d,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  65 <verror_at_line+0x65>
jmp    87 <verror_at_line+0x87>
callq  6c <verror_at_line+0x6c>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  82 <verror_at_line+0x82>
callq  87 <verror_at_line+0x87>
mov    %rbx,%rdi
callq  8f <verror_at_line+0x8f>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
verror_at_line (int status, int errnum, const char *file,
                unsigned int line_number, const char *format, va_list args)
{
  char *message = xvasprintf (format, args);
  if (message)
    {
      if (file)
        error_at_line (status, errnum, file, line_number, "%s", message);
      else
        error (status, errnum, "%s", message);
    }
  else
    {
      error (0, (*__errno_location ()), "unable to display error message");
      abort ();
    }
  free (message);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 17
42 17
43 18
44 18
45 18
46 18
47 18
48 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x0(%rip),%rdi        # faa <set_comment+0x11>
callq  faf <set_comment+0x16>
mov    0x0(%rip),%rdi        # fb6 <set_comment+0x1d>
callq  fbb <set_comment+0x22>
test   %rbp,%rbp
je     fd9 <set_comment+0x40>
test   %rbx,%rbx
je     fe3 <set_comment+0x4a>
cmpb   $0x0,0x0(%rbp)
je     fe8 <set_comment+0x4f>
cmpb   $0x0,(%rbx)
mov    $0x0,%eax
cmove  %rax,%rbx
jmp    fe8 <set_comment+0x4f>
mov    $0x0,%ebx
mov    %rbx,%rbp
jmp    fe8 <set_comment+0x4f>
mov    $0x0,%ebx
mov    %rbp,%rdi
callq  ff0 <set_comment+0x57>
mov    %rax,0x0(%rip)        # ff7 <set_comment+0x5e>
mov    $0xffffffffffffffff,%r12
mov    %rax,%rdi
mov    $0x0,%ebp
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
add    %r12,%rcx
mov    %rcx,0x0(%rip)        # 101a <set_comment+0x81>
mov    %rbx,%rdi
callq  1022 <set_comment+0x89>
mov    %rax,0x0(%rip)        # 1029 <set_comment+0x90>
mov    %rax,%rdi
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r12
sub    $0x1,%r12
mov    %r12,0x0(%rip)        # 1044 <set_comment+0xab>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
set_comment (const char *bc, const char *ec)
{
  free (bcomm.string);
  free (ecomm.string);
  if (!bc)
    bc = ec = "";
  else if (!ec || (*bc && !*ec))
    ec = "\n";
  bcomm.string = xstrdup (bc);
  bcomm.length = strlen (bcomm.string);
  ecomm.string = xstrdup (ec);
  ecomm.length = strlen (ecomm.string);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 6
21 6
22 6
23 8
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 11
37 11
38 11
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 13
48 13
49 13
50 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
cmpl   $0x0,0x0(%rip)        # 5c5 <tty_key_human2machine+0x14>
je     5d0 <tty_key_human2machine+0x1f>
lea    0x1(%r13),%rbx
mov    %r13,%rbp
jmp    625 <tty_key_human2machine+0x74>
mov    $0x0,%eax
cmpb   $0x5e,(%rdi)
je     5c7 <tty_key_human2machine+0x16>
jmp    649 <tty_key_human2machine+0x98>
cmp    $0x5e,%al
jne    61a <tty_key_human2machine+0x69>
movzbl 0x1(%rbp),%r12d
test   %r12b,%r12b
je     636 <tty_key_human2machine+0x85>
movzbl %r12b,%edi
callq  5f3 <tty_key_human2machine+0x42>
cmp    $0x47,%eax
je     63d <tty_key_human2machine+0x8c>
cmp    $0x5a,%eax
je     644 <tty_key_human2machine+0x93>
add    $0x2,%rbp
and    $0x7f,%r12d
sub    $0x20,%r12d
movslq %r12d,%r12
movzbl 0x0(%r12),%eax
mov    %al,-0x1(%rbx)
jmp    621 <tty_key_human2machine+0x70>
add    $0x1,%rbp
mov    %al,-0x1(%rbx)
add    $0x1,%rbx
movzbl 0x0(%rbp),%eax
test   %al,%al
jne    5dc <tty_key_human2machine+0x2b>
movb   $0x0,-0x1(%rbx)
mov    %r13,%rax
jmp    649 <tty_key_human2machine+0x98>
mov    $0x0,%eax
jmp    649 <tty_key_human2machine+0x98>
mov    $0x0,%eax
jmp    649 <tty_key_human2machine+0x98>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
tty_key_human2machine(key_seq)
    unsigned char *key_seq;
{
    unsigned char *first;
    unsigned char *second;
    first = second = key_seq;
    if (tty_kbdmode == 0 && *key_seq != '^')
 return ((void *)0);
    while (*second)
    {
 if (*second == '^')
 {
     if (*++second)
     {
  if (toupper(*second) == 'G' || toupper(*second) == 'Z')
      return ((void *)0);
  *first++ = key_ctrl_table[(*second++ & 0x7F) - ' '];
     }
     else
  return ((void *)0);
 }
 else
     *first++ = *second++;
    }
    *first = 0;
    return (char *)key_seq;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 7
10 3
11 3
12 8
13 7
14 7
15 7
16 11
17 11
18 13
19 13
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 23
35 23
36 23
37 9
38 9
39 9
40 25
41 26
42 26
43 20
44 20
45 16
46 16
47 16
48 27
49 27
50 27
51 27
52 27
53 27
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%r13
callq  0 <osip_ixt_lock>
mov    $0x0,%ebx
lea    0x80(%r14),%rbp
jmp    4b8 <osip_stop_retransmissions_from_dialog+0x4b>
mov    %ebx,%esi
mov    %rbp,%rdi
callq  498 <osip_stop_retransmissions_from_dialog+0x2b>
mov    %rax,%r12
cmp    %r13,(%rax)
jne    4b5 <osip_stop_retransmissions_from_dialog+0x48>
mov    %ebx,%esi
mov    %rbp,%rdi
callq  4aa <osip_stop_retransmissions_from_dialog+0x3d>
mov    %r12,%rdi
callq  c8 <ixt_free>
sub    $0x1,%ebx
add    $0x1,%ebx
mov    %ebx,%esi
mov    %rbp,%rdi
callq  4c2 <osip_stop_retransmissions_from_dialog+0x55>
test   %eax,%eax
je     48e <osip_stop_retransmissions_from_dialog+0x21>
mov    %r14,%rdi
callq  12 <osip_ixt_unlock>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
osip_stop_retransmissions_from_dialog (osip_t * osip, osip_dialog_t * dialog)
{
  int i;
  ixt_t *ixt;
  osip_ixt_lock (osip);
  for (i = 0; !osip_list_eol (&osip->ixt_retransmissions, i); i++) {
    ixt = (ixt_t *) osip_list_get (&osip->ixt_retransmissions, i);
    if (ixt->dialog == dialog) {
      osip_list_remove (&osip->ixt_retransmissions, i);
      ixt_free (ixt);
      i--;
    }
  }
  osip_ixt_unlock (osip);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 8
17 8
18 9
19 9
20 9
21 10
22 10
23 11
24 6
25 6
26 6
27 6
28 6
29 6
30 14
31 14
32 15
33 15
34 15
35 15
36 15
37 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  3530 <free_state+0xd>
mov    0x48(%rbx),%rdi
callq  3539 <free_state+0x16>
mov    0x50(%rbx),%rax
lea    0x8(%rbx),%rdx
cmp    %rdx,%rax
je     3558 <free_state+0x35>
mov    0x10(%rax),%rdi
callq  354f <free_state+0x2c>
mov    0x50(%rbx),%rdi
callq  3558 <free_state+0x35>
mov    0x18(%rbx),%rdi
callq  3561 <free_state+0x3e>
mov    0x60(%rbx),%rdi
callq  356a <free_state+0x47>
mov    0x58(%rbx),%rdi
callq  3573 <free_state+0x50>
mov    %rbx,%rdi
callq  357b <free_state+0x58>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_state (re_dfastate_t *state)
{
  free ((&state->non_eps_nodes)->elems);
  free ((&state->inveclosure)->elems);
  if (state->entrance_nodes != &state->nodes)
    {
      free ((state->entrance_nodes)->elems);
      free (state->entrance_nodes);
    }
  free ((&state->nodes)->elems);
  free (state->word_trtable);
  free (state->trtable);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 8
14 8
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 13
23 14
24 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  599 <parse_delete+0x9>
movb   $0x1,0x19(%rax)
movb   $0x1,0x18(%rax)
movb   $0x0,0x0(%rip)        # 5a8 <parse_delete+0x18>
movb   $0x0,0x1b(%rax)
movb   $0x0,0x1a(%rax)
movl   $0x3f800000,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_delete (const struct parser_table* entry, char *argv[], int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = insert_primary_noarg (entry);
  our_pred->side_effects = our_pred->no_default_print = 1;
  options.do_dir_first = 0;
  our_pred->need_stat = our_pred->need_type = 0;
  our_pred->est_success_rate = 1.0f;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 7
5 8
6 9
7 9
8 10
9 12
10 12
11 12
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     3419 <gsl_vector_uchar_set_zero+0x24>
mov    $0x0,%eax
movb   $0x0,(%rdx)
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    340a <gsl_vector_uchar_set_zero+0x15>
repz retq 
<<<sep_in_sample>>>
gsl_vector_uchar_set_zero (gsl_vector_uchar * v)
{
  unsigned char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const unsigned char zero = 0U ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(unsigned char *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 8
6 8
7 10
8 8
9 8
10 8
11 8
12 8
<<<sep_out_sample>>>
cmp    $0x7ffffffe,%rsi
mov    $0x7fffffff,%edx
cmovbe %rsi,%rdx
mov    %rdx,%rax
xor    $0x1,%rax
and    $0x1,%eax
sub    %rax,%rdx
movzwl %dx,%ecx
shr    $0x10,%rdx
mov    $0x0,%eax
imul   $0x236d,%rcx,%rcx
mov    %rcx,%rsi
shr    $0x10,%rsi
imul   $0x236d,%rdx,%rdx
add    %rsi,%rdx
and    $0x7fff,%edx
movzwl %cx,%ecx
mov    %rdx,%rsi
shl    $0x10,%rsi
add    %rcx,%rsi
mov    %rsi,0x8(%rdi,%rax,1)
add    $0x8,%rax
cmp    $0x88,%rax
jne    7e <uni32_set+0x29>
movl   $0x4,(%rdi)
movl   $0x10,0x4(%rdi)
retq   
<<<sep_in_sample>>>
uni32_set (void *vstate, unsigned long int s)
{
  long int seed, k0, k1, j0, j1;
  int i;
  uni32_state_t *state = (uni32_state_t *) vstate;
  seed = (s < m1 ? s : m1);
  seed -= (seed % 2 == 0 ? 1 : 0);
  k0 = 9069 % m2;
  k1 = 9069 / m2;
  j0 = seed % m2;
  j1 = seed / m2;
  for (i = 0; i < 17; i++)
    {
      seed = j0 * k0;
      j1 = (seed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
      j0 = seed % m2;
      state->m[i] = j0 + m2 * j1;
    }
  state->i = 4;
  state->j = 16;
  return;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 7
7 7
8 10
9 11
10 11
11 14
12 15
13 15
14 15
15 15
16 15
17 16
18 17
19 17
20 17
21 17
22 17
23 12
24 12
25 19
26 20
27 20
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 2d9a <just_dump+0xa>
callq  2d9f <just_dump+0xf>
callq  2da4 <just_dump+0x14>
mov    0x0(%rip),%rdi        # 2dab <just_dump+0x1b>
callq  2db0 <just_dump+0x20>
mov    0x0(%rip),%rdi        # 2db7 <just_dump+0x27>
callq  2dbc <just_dump+0x2c>
mov    $0x0,%esi
mov    %ebx,%edi
callq  2dc8 <just_dump+0x38>
pop    %rbx
retq   
<<<sep_in_sample>>>
just_dump(int signum)
{
 extern INSTRUCTION *code_block;
 dump_prog(code_block);
 dump_funcs();
 dump_fcall_stack(prof_fp);
 fflush(prof_fp);
 signal(signum, just_dump);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 6
8 7
9 7
10 8
11 8
12 8
13 9
14 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
lea    -0x1(%rdi),%ebp
test   %ebp,%ebp
jle    b7 <main+0x41>
lea    0x8(%rsi),%r12
mov    %r12,%rsi
mov    %ebp,%edi
callq  8f <main+0x19>
lea    0x1(%rax),%rdi
callq  98 <main+0x22>
mov    %rax,%rbx
test   %rax,%rax
je     c3 <main+0x4d>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rax,%rdi
callq  ad <main+0x37>
mov    %rbx,%rdi
callq  b5 <main+0x3f>
jmp    ad <main+0x37>
mov    $0x0,%edi
callq  c1 <main+0x4b>
jmp    b7 <main+0x41>
mov    0x0(%rip),%rcx        # ca <main+0x54>
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  de <main+0x68>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
main(int argc, char *argv[])
{
  char *msg;
  unsigned long l;
  argv++;
  argc--;
  if (argc > 0)
    {
      l = total_len(argc, argv);
      msg = malloc(l + 1u);
      if (((void *)0) == msg)
        {
          fprintf(stderr, "Ran out of memory.\n");
          return 1;
        }
      concat(msg, argc, argv);
      for (;;)
        puts(msg);
    }
  else
    {
      for (;;)
        puts("yes");
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 7
6 7
7 5
8 9
9 9
10 9
11 10
12 10
13 10
14 11
15 11
16 16
17 16
18 16
19 16
20 18
21 18
22 18
23 23
24 23
25 23
26 13
27 13
28 13
29 13
30 13
31 26
32 26
33 26
34 26
35 26
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
<<<sep_in_sample>>>
CDB_txn_id(txnp)
 DB_TXN *txnp;
{
 return (txnp->txnid);
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    0x40(%rdi),%rax
cmp    %rax,0x38(%rdi)
jb     de <argp_fmtstream_putc+0x23>
mov    $0x1,%esi
callq  da <argp_fmtstream_putc+0x1f>
test   %eax,%eax
je     f3 <argp_fmtstream_putc+0x38>
mov    0x38(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x38(%rbx)
mov    %bpl,(%rax)
movsbl %bpl,%eax
jmp    f8 <argp_fmtstream_putc+0x3d>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)
{
  if (__fs->p < __fs->end || _argp_fmtstream_ensure (__fs, 1))
    return *__fs->p++ = __ch;
  else
    return (-1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     48b <mu_debug_check_level+0x11>
mov    $0x1,%eax
mov    %esi,%ecx
shl    %cl,%eax
and    (%rdi),%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_debug_check_level (mu_debug_t debug, mu_log_level_t level)
{
  if (!debug)
    return 0;
  return debug->level & (1 << (level));
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 4
9 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # cb3 <eval_statement_list+0x7>
test   %rdi,%rdi
je     cf3 <eval_statement_list+0x47>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    (%rdi),%rbx
test   %rbx,%rbx
je     cef <eval_statement_list+0x43>
mov    %rax,%rdi
callq  cd2 <eval_statement_list+0x26>
mov    0x8(%rbx),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
callq  ce1 <eval_statement_list+0x35>
cmpl   $0x0,0x0(%rbp)
jne    cef <eval_statement_list+0x43>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    cca <eval_statement_list+0x1e>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
eval_statement_list (lst, env, return_seen)
     List *lst;
     Environment *env;
     int *return_seen;
{
  ListItem *i;
  Stmt *stmt;
  Node *n = nvoid;
  if (lst == ((void *)0))
    return nvoid;
  for (i = lst->head; i; i = i->next)
    {
      node_free (n);
      stmt = (Stmt *) i->data;
      n = eval_statement (stmt, env, return_seen);
      if (*return_seen)
 return n;
    }
  return n;
}
<<<sep_in_sample>>>
1 8
2 9
3 9
4 5
5 5
6 5
7 5
8 5
9 11
10 11
11 11
12 13
13 13
14 15
15 15
16 15
17 15
18 16
19 16
20 11
21 11
22 11
23 20
24 20
25 20
26 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x8(%rdi),%rsi
mov    (%rdi),%edi
callq  539 <_net_reader+0x15>
cltq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_net_reader (void *data, char **sptr, size_t *psize)
{
  struct net_reader_closure *np = data;
  return recvline (np->method, np->stream, sptr, psize);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    0x68(%rdi),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x88(%rcx),%rdi
callq  19d6 <delay_cpio_set_stat+0x2b>
mov    %rax,%rbp
mov    0x0(%rip),%rax        # 19e0 <delay_cpio_set_stat+0x35>
mov    %rax,0x0(%rbp)
mov    (%rbx),%rax
mov    %rax,0x8(%rbp)
mov    0x8(%rbx),%rax
mov    %rax,0x10(%rbp)
mov    0x10(%rbx),%rax
mov    %rax,0x18(%rbp)
mov    0x18(%rbx),%rax
mov    %rax,0x20(%rbp)
mov    0x20(%rbx),%rax
mov    %rax,0x28(%rbp)
mov    0x28(%rbx),%rax
mov    %rax,0x30(%rbp)
mov    0x30(%rbx),%rax
mov    %rax,0x38(%rbp)
mov    0x38(%rbx),%rax
mov    %rax,0x40(%rbp)
mov    0x40(%rbx),%rax
mov    %rax,0x48(%rbp)
mov    0x48(%rbx),%rax
mov    %rax,0x50(%rbp)
mov    0x50(%rbx),%rax
mov    %rax,0x58(%rbp)
mov    0x58(%rbx),%rax
mov    %rax,0x60(%rbp)
mov    0x60(%rbx),%rax
mov    %rax,0x68(%rbp)
mov    0x68(%rbx),%rax
mov    %rax,0x70(%rbp)
mov    0x70(%rbx),%rax
mov    %rax,0x78(%rbp)
lea    0x88(%rbp),%rdi
mov    %rdi,0x70(%rbp)
mov    0x68(%rbx),%rsi
callq  1a6f <delay_cpio_set_stat+0xc4>
mov    %r12d,0x80(%rbp)
mov    %rbp,0x0(%rip)        # 1a7d <delay_cpio_set_stat+0xd2>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
delay_cpio_set_stat (struct cpio_file_stat *file_stat,
       mode_t invert_permissions)
{
  size_t file_name_len = strlen (file_stat->c_name);
  struct delayed_set_stat *data =
    xmalloc (sizeof (struct delayed_set_stat) + file_name_len + 1);
  data->next = delayed_set_stat_head;
  memcpy (&data->stat, file_stat, sizeof data->stat);
  data->stat.c_name = (char*) (data + 1);
  strcpy (data->stat.c_name, file_stat->c_name);
  data->invert_permissions = invert_permissions;
  delayed_set_stat_head = data;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 6
12 5
13 5
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 9
47 9
48 10
49 10
50 11
51 12
52 13
53 13
54 13
55 13
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rdx,%rdx
je     d08 <gsl_stats_long_max+0x27>
shl    $0x3,%rsi
mov    $0x0,%ecx
mov    (%rdi),%r8
cmp    %r8,%rax
cmovl  %r8,%rax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    cf2 <gsl_stats_long_max+0x11>
repz retq 
<<<sep_in_sample>>>
gsl_stats_long_max (const long data[], const size_t stride,
                          const size_t n)
{
  long max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      long xi = data[i * stride];
      if (xi > max)
        max = xi;
    }
  return max;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 6
6 8
7 8
8 8
9 6
10 6
11 6
12 6
13 13
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
rec_rset_comment_compare_fn (void *data1,
                             void *data2,
                             int type2)
{
  return -1;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
mov    %rsi,%r12
cmp    $0x1,%edi
jne    41f <help+0xbc>
mov    $0x0,%edi
callq  385 <help+0x22>
mov    0x0(%rip),%rdx        # 38c <help+0x29>
test   %rdx,%rdx
je     426 <help+0xc3>
mov    $0x0,%ebx
mov    0x8(%rbx),%rcx
test   %rcx,%rcx
je     3b7 <help+0x54>
mov    $0x8,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3b7 <help+0x54>
add    $0x20,%rbx
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    39a <help+0x37>
jmp    426 <help+0xc3>
add    $0x8,%r12
mov    (%r12),%r13
mov    %r13,%rdi
callq  337 <getcmd>
mov    %rax,%rbp
mov    %rax,%rdi
mov    $0x0,%eax
callq  3e5 <help+0x82>
test   %eax,%eax
je     3fd <help+0x9a>
mov    %r13,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3fb <help+0x98>
jmp    41f <help+0xbc>
test   %rbp,%rbp
jne    416 <help+0xb3>
mov    %r13,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  414 <help+0xb1>
jmp    41f <help+0xbc>
mov    0x8(%rbp),%rdi
callq  41f <help+0xbc>
sub    $0x1,%ebx
test   %ebx,%ebx
jg     3c5 <help+0x62>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
help (int argc, char *argv[])
{
  register Command *c;
  if (argc == 1)
    {
      printf ("Commands may be abbreviated.  Commands are:\n\n");
      for (c = cmdtab; c->name; c++)
 if (c->help)
   {
     printf ("%-*s\t%s\n", (int) (sizeof ("connect")), c->name, c->help);
   }
      return 0;
    }
  while (--argc > 0)
    {
      register char *arg;
      arg = *++argv;
      c = getcmd (arg);
      if (Ambiguous (c))
 printf ("?Ambiguous help command %s\n", arg);
      else if (c == (Command *) 0)
 printf ("?Invalid help command %s\n", arg);
      else
 printf ("%s\n", c->help);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 6
11 6
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 10
20 10
21 10
22 10
23 7
24 7
25 7
26 7
27 7
28 17
29 17
30 18
31 18
32 18
33 19
34 19
35 19
36 19
37 19
38 20
39 20
40 20
41 20
42 20
43 21
44 21
45 22
46 22
47 22
48 22
49 22
50 24
51 24
52 14
53 14
54 14
55 27
56 27
57 27
58 27
59 27
60 27
61 27
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gcide_markup_yywrap()
{
    return 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x80,%esi
callq  b8f <find_char_unquote>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_percent (char *pattern)
{
  return find_char_unquote (pattern, 0x0080);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rdx,%r12
movl   $0x0,(%rdx)
movzbl (%rdi),%ecx
test   %cl,%cl
je     8e3 <wordsplit_c_quoted_length+0x9b>
mov    %esi,%r13d
mov    $0x0,%ebp
movsbl %cl,%esi
mov    $0x0,%edi
callq  87a <wordsplit_c_quoted_length+0x32>
test   %rax,%rax
je     887 <wordsplit_c_quoted_length+0x3f>
movl   $0x1,(%r12)
movzbl (%rbx),%edi
cmp    $0x20,%dil
jne    896 <wordsplit_c_quoted_length+0x4e>
add    $0x1,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
cmp    $0x22,%dil
jne    8a2 <wordsplit_c_quoted_length+0x5a>
add    $0x2,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
cmp    $0x5c,%dil
je     8b4 <wordsplit_c_quoted_length+0x6c>
cmp    $0x1f,%dil
jle    8b4 <wordsplit_c_quoted_length+0x6c>
add    $0x1,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
test   %r13d,%r13d
je     8bf <wordsplit_c_quoted_length+0x77>
add    $0x3,%rbp
jmp    8d6 <wordsplit_c_quoted_length+0x8e>
movsbl %dil,%edi
callq  8c8 <wordsplit_c_quoted_length+0x80>
lea    0x2(%rbp),%rdx
add    $0x4,%rbp
test   %eax,%eax
cmovne %rdx,%rbp
add    $0x1,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    86d <wordsplit_c_quoted_length+0x25>
jmp    8e8 <wordsplit_c_quoted_length+0xa0>
mov    $0x0,%ebp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
wordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)
{
  size_t len = 0;
  *quote = 0;
  for (; *str; str++)
    {
      if (strchr (" \"", *str))
 *quote = 1;
      if (*str == ' ')
 len++;
      else if (*str == '"')
 len += 2;
      else if (*str != '\t' && *str != '\\' && (' ' <= ((unsigned) (*str)) && ((unsigned) (*str)) <= 127))
 len++;
      else if (quote_hex)
 len += 3;
      else
 {
   if (wordsplit_c_quote_char (*str))
     len += 2;
   else
     len += 4;
 }
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 5
11 5
12 5
13 3
14 7
15 7
16 7
17 7
18 7
19 8
20 9
21 9
22 9
23 10
24 10
25 11
26 11
27 12
28 12
29 13
30 13
31 13
32 13
33 14
34 14
35 15
36 15
37 16
38 16
39 19
40 19
41 20
42 20
43 20
44 20
45 5
46 5
47 5
48 5
49 5
50 3
51 26
52 26
53 26
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,0x8(%rsp)
mov    %r9,(%rsp)
mov    %edx,%r9d
callq  c5a5 <re_search_stub>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
re_search (struct re_pattern_buffer *bufp, const char *string, int length,
    int start, int range, struct re_registers *regs)
{
  return re_search_stub (bufp, string, length, start, range, length, regs, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lchmodat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
test   %rsi,%rsi
je     d14 <rec_rset_set_type+0x80>
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
jne    cb3 <rec_rset_set_type+0x1f>
callq  cb0 <rec_rset_set_type+0x1c>
mov    %rax,(%rbx)
mov    $0x5,%edi
callq  cbd <rec_rset_set_type+0x29>
mov    $0x0,%edx
mov    %rax,%rsi
mov    (%rbx),%rdi
callq  ccd <rec_rset_set_type+0x39>
test   %rax,%rax
je     cdf <rec_rset_set_type+0x4b>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  cdd <rec_rset_set_type+0x49>
jmp    d14 <rec_rset_set_type+0x80>
mov    $0x5,%edi
callq  ce9 <rec_rset_set_type+0x55>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  cf4 <rec_rset_set_type+0x60>
mov    %rax,%rbp
mov    (%rbx),%rdi
callq  cff <rec_rset_set_type+0x6b>
mov    $0x1,%ecx
mov    %rbp,%rdx
mov    $0x1,%esi
mov    %rax,%rdi
callq  d14 <rec_rset_set_type+0x80>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_rset_set_type (rec_rset_t rset,
                   const char *type)
{
  rec_field_t rec_field;
  if (!type)
    {
      return;
    }
  if (!rset->descriptor)
    {
      rset->descriptor = rec_record_new ();
    }
  rec_field = rec_record_get_field_by_name (rset->descriptor,
                                            rec_std_field_name ((REC_FIELD_REC)),
                                            0);
  if (rec_field)
    {
      rec_field_set_value (rec_field, type);
    }
  else
    {
      rec_field = rec_field_new (rec_std_field_name ((REC_FIELD_REC)), type);
      rec_mset_append (rec_record_mset (rset->descriptor), 1, (void *) rec_field, 1);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 9
9 9
10 11
11 11
12 13
13 13
14 13
15 13
16 13
17 13
18 16
19 16
20 18
21 18
22 18
23 18
24 22
25 22
26 22
27 22
28 22
29 22
30 23
31 23
32 23
33 23
34 23
35 23
36 23
37 25
38 25
39 25
40 25
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
test   %edi,%edi
js     c12 <close_temp+0x33>
callq  bf4 <close_temp+0x15>
mov    %eax,%r12d
callq  bfc <close_temp+0x1d>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  3d9 <unregister_fd>
mov    %r13d,0x0(%rbp)
mov    %r12d,%eax
jmp    c17 <close_temp+0x38>
callq  c17 <close_temp+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
close_temp (int fd)
{
  if (fd >= 0)
    {
      int result = close (fd);
      int saved_errno = (*__errno_location ());
      unregister_fd (fd);
      (*__errno_location ()) = saved_errno;
      return result;
    }
  else
    return close (fd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 9
19 12
20 13
21 13
22 13
23 13
24 13
25 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x50(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x5,%esi
callq  1f7 <gen_attr_object>
mov    %ebx,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2c4 <gen_txt_stack+0x1b>
mov    $0x0,%eax
callq  2ce <gen_txt_stack+0x25>
pop    %rbx
retq   
<<<sep_in_sample>>>
gen_txt_stack (int i)
{
  gen_attr_object (i, 5);
  fprintf (ccode, "__t%d", i);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
mov    $0x891b,%esi
mov    $0x0,%eax
callq  74d <fh_netmask+0x22>
test   %eax,%eax
jns    772 <fh_netmask+0x47>
callq  756 <fh_netmask+0x2b>
mov    0x8(%rbx),%rcx
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  770 <fh_netmask+0x45>
jmp    787 <fh_netmask+0x5c>
mov    0x8(%rbx),%rax
lea    0x10(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  787 <fh_netmask+0x5c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_netmask (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x891b, form->ifr) < 0)
    error (1, (*__errno_location ()),
    "SIOCGIFNETMASK failed for interface `%s'",
    form->ifr->ifr_ifrn.ifrn_name);
  else
    put_addr (form, argc, argv, &form->ifr->ifr_ifru.ifru_netmask);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     727 <GetaString+0xa7>
test   %rsi,%rsi
je     727 <GetaString+0xa7>
mov    0x18(%rdi),%rdx
test   %rdx,%rdx
je     708 <GetaString+0x88>
mov    $0x0,%eax
cmpb   $0x22,(%rdx)
jne    721 <GetaString+0xa1>
mov    %rsi,%rcx
add    $0x1,%eax
mov    0x18(%rdi),%rdx
lea    0x1(%rdx),%r8
mov    %r8,0x18(%rdi)
movzbl 0x1(%rdx),%edx
mov    %dl,(%rcx)
mov    0x18(%rdi),%rdx
movzbl (%rdx),%edx
cmp    $0x22,%dl
je     6de <GetaString+0x5e>
test   %dl,%dl
je     6de <GetaString+0x5e>
add    $0x1,%rcx
cmp    $0x3fe,%eax
jne    6ac <GetaString+0x2c>
jmp    6e5 <GetaString+0x65>
cmp    $0x3fe,%eax
jne    70d <GetaString+0x8d>
mov    $0x0,%edi
mov    $0x0,%eax
callq  6f4 <GetaString+0x74>
mov    $0x0,%edi
callq  6fe <GetaString+0x7e>
mov    $0x0,%edi
callq  708 <GetaString+0x88>
mov    $0x0,%eax
mov    0x18(%rdi),%rdx
cmpb   $0x22,(%rdx)
jne    721 <GetaString+0xa1>
add    $0x1,%rdx
mov    %rdx,0x18(%rdi)
sub    $0x1,%eax
cltq   
movb   $0x0,(%rsi,%rax,1)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
GetaString (PINPUTBUF pibIn, PSTR szLex)
{
  int i = 0;
  if (!pibIn || !szLex)
    return;
  if ((((PSTR) pibIn->pbufCur) ? (*((PSTR) pibIn->pbufCur) == ('\"')) : (0) )) {
    do
      szLex[i++] = *++pibIn->pbufCur;
    while ((*pibIn->pbufCur)
           && (*pibIn->pbufCur != ('\"'))
           && (i < 0x03FF - 1));
  }
  if (i == 0x03FF - 1) {
    printf ("\n***Error: max string length MAX_LEX exceeded in: %s\n",
            szLex);
    printf ("Exiting...\n\n");
    exit (0);
  }
  if (*pibIn->pbufCur == ('\"')) {
    pibIn->pbufCur++;
    i--;
  }
  szLex[i] = '\0';
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 14
32 14
33 14
34 16
35 16
36 17
37 17
38 17
39 19
40 19
41 19
42 20
43 20
44 21
45 23
46 23
47 24
48 24
<<<sep_out_sample>>>
test   %rdi,%rdi
je     c6 <osip_cond_signal+0x10>
sub    $0x8,%rsp
callq  c4 <osip_cond_signal+0xe>
jmp    cc <osip_cond_signal+0x16>
mov    $0xfffffffe,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_cond_signal (struct osip_cond *_cond)
{
  if (!_cond)
    return -2;
  return pthread_cond_signal (&_cond->cv);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
test   %rsi,%rsi
je     2fe <nettle_chacha_poly1305_decrypt+0x6e>
mov    %rdi,%rbx
mov    %rdx,%r13
mov    %rcx,%r12
testb  $0x3f,0x90(%rdi)
je     2d3 <nettle_chacha_poly1305_decrypt+0x43>
lea    0x0(%rip),%rcx        # 2bb <nettle_chacha_poly1305_decrypt+0x2b>
mov    $0x90,%edx
lea    0x0(%rip),%rsi        # 2c7 <nettle_chacha_poly1305_decrypt+0x37>
lea    0x0(%rip),%rdi        # 2ce <nettle_chacha_poly1305_decrypt+0x3e>
callq  2d3 <nettle_chacha_poly1305_decrypt+0x43>
callq  e5 <poly1305_pad>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  0 <poly1305_update>
mov    %r12,%rcx
mov    %r13,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2f7 <nettle_chacha_poly1305_decrypt+0x67>
add    %rbp,0x90(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
nettle_chacha_poly1305_decrypt (struct chacha_poly1305_ctx *ctx,
    size_t length, uint8_t *dst, const uint8_t *src)
{
  if (!length)
    return;
  ((ctx->data_size % 64 == 0) ? (void) (0) : __assert_fail ("ctx->data_size % 64 == 0", "chacha-poly1305.c", 144, __PRETTY_FUNCTION__));
  poly1305_pad (ctx);
  poly1305_update (ctx, length, src);
  nettle_chacha_crypt (&ctx->chacha, length, dst, src);
  ctx->data_size += length;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 10
30 11
31 11
32 11
33 11
34 11
35 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    0xa8(%rdi),%rbx
mov    0x20(%rdi),%r12d
test   $0x800,%r12d
je     3cd <skip_delim+0x8f>
test   $0x1000,%r12d
je     385 <skip_delim+0x47>
mov    0x98(%rdi),%r13
movzbl 0x0(%r13,%rbx,1),%r14d
movsbl %r14b,%esi
mov    0x28(%rdi),%rdi
callq  380 <skip_delim+0x42>
test   %rax,%rax
jne    38e <skip_delim+0x50>
mov    0xa0(%rbp),%r13
jmp    3a7 <skip_delim+0x69>
mov    0xa0(%rbp),%rax
add    $0x1,%rbx
cmp    %rax,%rbx
jae    3c9 <skip_delim+0x8b>
cmp    0x0(%r13,%rbx,1),%r14b
je     395 <skip_delim+0x57>
jmp    3c9 <skip_delim+0x8b>
add    $0x1,%rbx
cmp    %r13,%rbx
jae    3c9 <skip_delim+0x8b>
mov    0x98(%rbp),%rax
movsbl (%rax,%rbx,1),%esi
mov    0x28(%rbp),%rdi
callq  3c4 <skip_delim+0x86>
test   %rax,%rax
jne    3a7 <skip_delim+0x69>
sub    $0x1,%rbx
and    $0x1000,%r12d
cmp    $0x1,%r12d
adc    $0x0,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
skip_delim (struct wordsplit *wsp)
{
  size_t start = wsp->ws_endp;
  if (wsp->ws_flags & 0x00000800)
    {
      if ((wsp->ws_flags & 0x00001000) &&
   (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)))
 {
   int delim = wsp->ws_input[start];
   do
     start++;
   while (start < wsp->ws_len && delim == wsp->ws_input[start]);
 }
      else
 {
   do
     start++;
   while (start < wsp->ws_len && (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)));
 }
      start--;
    }
  if (!(wsp->ws_flags & 0x00001000))
    start++;
  return start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 6
19 6
20 18
21 18
22 12
23 11
24 12
25 12
26 12
27 12
28 12
29 17
30 18
31 18
32 18
33 18
34 18
35 18
36 18
37 18
38 20
39 22
40 23
41 23
42 25
43 25
44 25
45 25
46 25
47 25
48 25
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
<<<sep_in_sample>>>
ping_set_interval (PING * ping, size_t interval)
{
  ping->ping_interval = interval;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    0x50(%rdi),%rbp
mov    $0x0,%esi
callq  2ec <amd_messages_count>
mov    %eax,%edx
test   %edx,%edx
jne    39b <amd_uidvalidity+0x5c>
cmpq   $0x0,0x68(%rbp)
jne    37f <amd_uidvalidity+0x40>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  *0x38(%rbp)
mov    %eax,%edx
test   %edx,%edx
jne    39b <amd_uidvalidity+0x5c>
test   %r12,%r12
je     396 <amd_uidvalidity+0x57>
mov    0x80(%rbp),%rax
mov    %rax,(%r12)
mov    $0x0,%eax
jmp    39b <amd_uidvalidity+0x5c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
amd_uidvalidity (mu_mailbox_t mailbox, unsigned long *puidvalidity)
{
  struct _amd_data *amd = mailbox->data;
  int status = amd_messages_count (mailbox, ((void *)0));
  if (status != 0)
    return status;
  if (amd->msg_count == 0)
    {
      status = amd->scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  if (puidvalidity)
    *puidvalidity = amd->uidvalidity;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 13
23 13
24 14
25 14
26 15
27 15
28 15
29 16
30 16
31 16
32 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  158a <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    (%rax),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     41 <__gmpz_fits_sshort_p+0x41>
cmp    $0x1,%rdx
jne    29 <__gmpz_fits_sshort_p+0x29>
cmp    $0x7fff,%rcx
setbe  %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
cmp    $0xffffffffffffffff,%rdx
jne    41 <__gmpz_fits_sshort_p+0x41>
cmp    $0x8000,%rcx
setbe  %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
__gmpz_fits_sshort_p (mpz_srcptr z)
{
  mp_size_t n = ((z)->_mp_size);
  mp_ptr p = ((z)->_mp_d);
  mp_limb_t limb = p[0];
  if (n == 0)
    return 1;
  if (n == 1)
    return limb <= 32767;
  if (n == -1)
    return limb <= (- (((mp_limb_t) (((-32767 - 1)) + 1)) - 1));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 6
6 6
7 8
8 8
9 9
10 9
11 9
12 9
13 12
14 10
15 10
16 11
17 11
18 11
19 13
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
lea    0x8(%rsp),%rsi
mov    (%rdi),%rdi
callq  a0 <mbx_finished_p+0x15>
mov    $0x1,%edx
test   %eax,%eax
jne    b8 <mbx_finished_p+0x2d>
mov    0x8(%rsp),%rax
cmp    %rax,0x8(%rbx)
seta   %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
mbx_finished_p (void *owner)
{
  struct mailbox_iterator *itr = owner;
  size_t count;
  if (mu_mailbox_messages_count (itr->mbx, &count))
    return 1;
  return itr->idx > count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 6
8 5
9 5
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %esi,%esi
callq  1a94 <ppdrealloc+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ppdrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
libunistring_c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
je     24 <digest_md5_validate_challenge+0x24>
cmpl   $0x0,0x2c(%rdi)
je     1a <digest_md5_validate_challenge+0x1a>
testb  $0x4,0x18(%rdi)
sete   %al
movzbl %al,%eax
neg    %eax
retq   
mov    0x18(%rdi),%eax
shl    $0x1d,%eax
sar    $0x1f,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
digest_md5_validate_challenge (digest_md5_challenge * c)
{
  if (!c->nonce)
    return -1;
  if (c->ciphers && !(c->qops & DIGEST_MD5_QOP_AUTH_CONF))
    return -1;
  if (!c->ciphers && (c->qops & DIGEST_MD5_QOP_AUTH_CONF))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 4
15 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     21d3 <gdbmarg_destroy+0x1c>
mov    (%rdi),%rdi
callq  21c8 <gdbmarg_destroy+0x11>
test   %eax,%eax
je     21d3 <gdbmarg_destroy+0x1c>
movq   $0x0,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
gdbmarg_destroy (struct gdbmarg **parg)
{
  if (parg && gdbmarg_free (*parg))
    *parg = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     79b <osip_header_get_value+0xa>
mov    0x8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_header_get_value (const osip_header_t * header)
{
  if (header == ((void *)0))
    return ((void *)0);
  return header->hvalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  34 <make_full_file_name+0x9>
test   %rax,%rax
jne    3e <make_full_file_name+0x13>
callq  3e <make_full_file_name+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_full_file_name(const char *dir, const char *file)
{
    char *s = dico_full_file_name(dir, file);
    if (!s)
 xalloc_die();
    return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 7
7 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     5de <gsl_integration_qaws_table_free+0x12>
sub    $0x8,%rsp
callq  5da <gsl_integration_qaws_table_free+0xe>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
gsl_integration_qaws_table_free (gsl_integration_qaws_table * t)
{
  if (!t) { return ; };
  free (t);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    0x280(%rdi),%r12
test   %r12,%r12
je     a5e <rec_aggregate_reg_get+0x4c>
mov    %rsi,%r13
mov    %rdi,%rbp
mov    $0x0,%ebx
mov    %r13,%rsi
mov    0x0(%rbp),%rdi
callq  a40 <rec_aggregate_reg_get+0x2e>
test   %eax,%eax
jne    a4f <rec_aggregate_reg_get+0x3d>
shl    $0x4,%rbx
mov    0x8(%r14,%rbx,1),%rax
jmp    a6a <rec_aggregate_reg_get+0x58>
add    $0x1,%rbx
add    $0x10,%rbp
cmp    %r12,%rbx
jne    a34 <rec_aggregate_reg_get+0x22>
jmp    a65 <rec_aggregate_reg_get+0x53>
mov    $0x0,%eax
jmp    a6a <rec_aggregate_reg_get+0x58>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
rec_aggregate_reg_get (rec_aggregate_reg_t func_reg,
                       const char *name)
{
  size_t i = 0;
  rec_aggregate_t res = ((void *)0);
  for (i = 0; i < func_reg->num_functions; i++)
    {
      if (strcasecmp (func_reg->functions[i].name, name) == 0)
        {
          res = func_reg->functions[i].function;
          break;
        }
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 10
19 10
20 11
21 6
22 6
23 6
24 6
25 6
26 5
27 5
28 5
29 15
30 15
31 15
32 15
33 15
34 15
<<<sep_out_sample>>>
test   %rsi,%rsi
js     1e <__gmpf_set_si+0x1e>
mov    0x10(%rdi),%rax
mov    %rsi,(%rax)
test   %rsi,%rsi
setne  %al
movzbl %al,%edx
mov    %rdx,0x8(%rdi)
movzbl %al,%eax
jmp    3a <__gmpf_set_si+0x3a>
neg    %rsi
mov    0x10(%rdi),%rax
mov    %rsi,(%rax)
test   %rsi,%rsi
setne  %al
movzbl %al,%edx
mov    %rdx,0x8(%rdi)
movzbl %al,%eax
neg    %eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpf_set_si (mpf_ptr dest, long val)
{
  mp_size_t size;
  mp_limb_t vl;
  vl = (mp_limb_t) ((val) >= 0 ? ((unsigned long int) (val)) : (- (((unsigned long int) ((val) + 1)) - 1)));
  dest->_mp_d[0] = vl & ((~ ((mp_limb_t) (0))) >> 0);
  size = vl != 0;
  dest->_mp_exp = size;
  dest->_mp_size = val >= 0 ? size : -size;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 7
6 7
7 7
8 7
9 9
10 9
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f <listel_dispose+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
listel_dispose(const void *el)
{
  free((void*)el);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  c37 <rc_destroy_loc+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rc_destroy_loc (RC_LOC *loc)
{
  string_destroy (loc->file);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <name_list_adjust+0x7>
test   %rax,%rax
je     2a <name_list_adjust+0x2a>
mov    0x8(%rax),%rdx
test   %rdx,%rdx
je     2a <name_list_adjust+0x2a>
mov    0x8(%rdx),%rax
test   %rax,%rax
je     23 <name_list_adjust+0x23>
mov    %rax,%rdx
jmp    15 <name_list_adjust+0x15>
mov    %rdx,0x0(%rip)        # 2a <name_list_adjust+0x2a>
repz retq 
<<<sep_in_sample>>>
name_list_adjust (void)
{
  if (name_head)
    while (name_head->prev)
      name_head = name_head->prev;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  3c9 <gsl_stats_long_kurtosis+0x18>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  3e2 <gsl_stats_long_kurtosis+0x31>
movapd %xmm0,%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  3ff <gsl_stats_long_kurtosis+0x4e>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_long_kurtosis (const long data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_mean(data, stride, n);
  const double est_sd = gsl_stats_long_sd_m(data, stride, n, mean);
  return gsl_stats_long_kurtosis_m_sd(data, stride, n, mean, est_sd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %fs:0x28,%rax
mov    %rax,0xc8(%rsp)
xor    %eax,%eax
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
lea    0x10(%rsp),%rdi
callq  195 <chk_sha+0x41>
mov    $0xffffffffffffffff,%r12
mov    %r13,%rdi
mov    $0x0,%ebp
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rcx,%r12,1),%rsi
lea    0x10(%rsp),%rdx
mov    %r13,%rdi
callq  1bf <chk_sha+0x6b>
lea    0xb0(%rsp),%rsi
lea    0x10(%rsp),%rdi
callq  1d1 <chk_sha+0x7d>
mov    %rbx,%rdi
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rsp,%rcx
lea    0x8(%rsp),%rdx
mov    %rbx,%rdi
callq  1f2 <chk_sha+0x9e>
test   %eax,%eax
jne    236 <chk_sha+0xe2>
cmpq   $0x14,(%rsp)
je     20e <chk_sha+0xba>
mov    0x8(%rsp),%rdi
callq  207 <chk_sha+0xb3>
mov    $0xffffffff,%eax
jmp    23b <chk_sha+0xe7>
mov    0x8(%rsp),%rbx
mov    $0x14,%edx
mov    %rbx,%rsi
lea    0xb0(%rsp),%rdi
callq  228 <chk_sha+0xd4>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  232 <chk_sha+0xde>
mov    %ebp,%eax
jmp    23b <chk_sha+0xe7>
mov    $0xffffffff,%eax
mov    0xc8(%rsp),%rbx
xor    %fs:0x28,%rbx
je     253 <chk_sha+0xff>
callq  253 <chk_sha+0xff>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
chk_sha(const char *db_pass, const char *pass)
{
    int rc;
    unsigned char sha1digest[20];
    struct sha1_ctx sha1context;
    size_t size = 0;
    unsigned char *buf = ((void *)0);
    sha1_init_ctx(&sha1context);
    sha1_process_bytes(pass, strlen(pass), &sha1context);
    sha1_finish_ctx(&sha1context, sha1digest);
    if (dico_base64_decode((unsigned char *)db_pass, strlen(db_pass),
      &buf, &size))
 return -1;
    if (size != 20) {
 free(buf);
 return -1;
    }
    rc = memcmp(sha1digest, buf, sizeof sha1digest);
    free(buf);
    return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 6
12 7
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 14
42 14
43 15
44 15
45 16
46 16
47 18
48 18
49 18
50 18
51 18
52 18
53 19
54 19
55 20
56 20
57 13
58 21
59 21
60 21
61 21
62 21
63 21
64 21
65 21
66 21
67 21
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     35a <free_history_entry+0x3a>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     33b <free_history_entry+0x1b>
callq  33b <free_history_entry+0x1b>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     349 <free_history_entry+0x29>
callq  349 <free_history_entry+0x29>
mov    0x10(%rbx),%rbp
mov    %rbx,%rdi
callq  355 <free_history_entry+0x35>
mov    %rbp,%rax
jmp    35f <free_history_entry+0x3f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
free_history_entry (hist)
     HIST_ENTRY *hist;
{
  histdata_t x;
  if (hist == 0)
    return ((histdata_t) 0);
  if (hist->line) free (hist->line);
  if (hist->timestamp) free (hist->timestamp);
  x = hist->data;
  xfree (hist);
  return (x);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 9
16 10
17 10
18 11
19 11
20 6
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
mov    0x0(%rip),%rax        # 11bd <quotearg_n_custom_mem+0x17>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 11c8 <quotearg_n_custom_mem+0x22>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 11d4 <quotearg_n_custom_mem+0x2e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 11e0 <quotearg_n_custom_mem+0x3a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 11ec <quotearg_n_custom_mem+0x46>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 11f8 <quotearg_n_custom_mem+0x52>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 1204 <quotearg_n_custom_mem+0x5e>
mov    %rax,0x30(%rsp)
mov    %rsp,%rdi
callq  1211 <quotearg_n_custom_mem+0x6b>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b75 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
test   %rdi,%rdi
je     217 <gss_release_name+0xf>
movl   $0x0,(%rdi)
mov    $0x1020000,%eax
test   %rbx,%rbx
je     252 <gss_release_name+0x4a>
mov    (%rbx),%rax
test   %rax,%rax
je     24d <gss_release_name+0x45>
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     237 <gss_release_name+0x2f>
callq  237 <gss_release_name+0x2f>
mov    (%rbx),%rdi
callq  23f <gss_release_name+0x37>
movq   $0x0,(%rbx)
mov    $0x0,%eax
jmp    252 <gss_release_name+0x4a>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gss_release_name (OM_uint32 * minor_status, gss_name_t * name)
{
  if (minor_status)
    *minor_status = 0;
  if (!name)
    return (2ul << 16) | (1ul << 24);
  if (*name != ((gss_name_t) 0))
    {
      if ((*name)->value)
 free ((*name)->value);
      free (*name);
      *name = ((gss_name_t) 0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 6
7 5
8 5
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 11
17 11
18 12
19 14
20 14
21 14
22 15
23 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # a <showKeybindings+0xa>
mov    $0x0,%esi
mov    $0x0,%edi
callq  19 <showKeybindings+0x19>
test   %eax,%eax
je     32 <showKeybindings+0x32>
mov    0x0(%rip),%edx        # 23 <showKeybindings+0x23>
mov    $0x0,%esi
mov    $0x0,%edi
callq  32 <showKeybindings+0x32>
mov    0x0(%rip),%eax        # 38 <showKeybindings+0x38>
lea    -0x2(%rax),%edx
mov    $0x2,%esi
mov    $0x2,%edi
callq  4a <showKeybindings+0x4a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
showKeybindings()
{
  int res = show_readme("/usr/share/doc/gnudos/prime/keybindings", " KEYBINDINGS ", GNU_DOS_LEVEL);
  if(res != 0)
  {
    res = show_readme("/usr/local/share/doc/gnudos/prime/keybindings", " KEYBINDINGS ", GNU_DOS_LEVEL);
  }
  drawMenuBar(2, 2, SCREEN_W-2);
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 8
17 10
18 10
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    %rdx,%rsi
callq  3d <__gmp_default_reallocate+0x14>
test   %rax,%rax
jne    5e <__gmp_default_reallocate+0x35>
mov    %rbx,%rcx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 54 <__gmp_default_reallocate+0x2b>
callq  59 <__gmp_default_reallocate+0x30>
callq  5e <__gmp_default_reallocate+0x35>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmp_default_reallocate (void *oldptr, size_t old_size, size_t new_size)
{
  void *ret;
  ret = realloc (oldptr, new_size);
  if (ret == 0)
    {
      fprintf (stderr, "GNU MP: Cannot reallocate memory (old_size=%lu new_size=%lu)\n", (long) old_size, (long) new_size);
      abort ();
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  d6 <mu_diag_get_debug+0x9>
mov    0x0(%rip),%rax        # dd <mu_diag_get_debug+0x10>
mov    %rax,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_diag_get_debug (mu_debug_t *pdebug)
{
  mu_diag_init ();
  *pdebug = mu_diag_debug;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r13d
mov    %ecx,%r12d
mov    %ecx,%r9d
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xb7,(%rax)
mov    $0x0,%r9d
mov    %r13d,%r8d
mov    %r12d,%ecx
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  22b7 <_rx>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_ldxr_us(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r0, r1, r2);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = 0xb7;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 7
32 7
33 7
34 7
35 7
36 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  47 <initialize_mbcs+0x9>
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
sete   0x0(%rip)        # 65 <initialize_mbcs+0x27>
callq  6a <initialize_mbcs+0x2c>
mov    %eax,0x0(%rip)        # 70 <initialize_mbcs+0x32>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
initialize_mbcs ()
{
  const char *codeset_name;
  codeset_name = locale_charset ();
  is_utf8 = (strcmp (codeset_name, "UTF-8") == 0);
  mb_cur_max = (__ctype_get_mb_cur_max ());
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %rbx
callq  c30 <parse_init_scripts+0x6>
mov    $0x0,%esi
mov    %rax,%rdi
callq  c3d <parse_init_scripts+0x13>
mov    %rax,%rbx
mov    %rax,%rdi
callq  c48 <parse_init_scripts+0x1e>
mov    %rbx,%rdi
callq  c50 <parse_init_scripts+0x26>
mov    $0x0,%edi
callq  c5a <parse_init_scripts+0x30>
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_init_scripts()
{
    char *name = dico_full_file_name(get_homedir(), ".dico");
    parse_init_script(name);
    free(name);
    parse_init_script(".dico");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%eax
callq  56e <current_builtin+0xe>
mov    0x28(%rbx),%rax
test   %rax,%rax
je     586 <current_builtin+0x26>
movslq 0x4(%rax),%rdx
mov    0x10(%rax),%rax
mov    -0x8(%rax,%rdx,8),%rax
jmp    58b <current_builtin+0x2b>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
current_builtin (directive, defs)
     char *directive;
     DEF_FILE *defs;
{
  must_be_building (directive, defs);
  if (defs->builtins)
    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);
  else
    return ((BUILTIN_DESC *)((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 9
13 10
14 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 131 <restoreTerminal+0xb>
je     149 <restoreTerminal+0x23>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  147 <restoreTerminal+0x21>
jmp    177 <restoreTerminal+0x51>
mov    $0x0,%edx
mov    $0x2,%esi
mov    $0x0,%edi
callq  15d <restoreTerminal+0x37>
mov    0x0(%rip),%edx        # 163 <restoreTerminal+0x3d>
mov    $0x4b45,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  177 <restoreTerminal+0x51>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
restoreTerminal()
{
    if(X_IS_RUNNING)
    {
     tcsetattr(0, 0, &tty_attr_old);
    }
    else
    {
     tcsetattr(0, 2, &tty_attr_old);
     ioctl(0, 0x4B45, old_keyboard_mode);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 9
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 12
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  169 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
lea    0x8(%rsp),%rdx
callq  727 <looking_at+0x12>
mov    $0x0,%edx
test   %eax,%eax
jne    73f <looking_at+0x2a>
mov    0x8(%rsp),%rax
cmp    %rax,0x8(%rbx)
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
looking_at (char *string, SEARCH_BINDING *binding)
{
  long search_end;
  if (search (string, binding, &search_end) != search_success)
    return 0;
  return search_end == binding->start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 4
8 4
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 155 <tty_islitecho+0x6>
shr    $0x9,%eax
xor    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
tty_islitecho (void)
{
  return !(termbuf.c_lflag & 0001000);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
callq  9a <mc_net_info_free+0xb>
mov    %rbx,%rdi
callq  a2 <mc_net_info_free+0x13>
pop    %rbx
retq   
<<<sep_in_sample>>>
mc_net_info_free (net_info_t *net)
{
 close(net->sock);
 free(net);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
mov    (%rdx),%rbx
test   %rbx,%rbx
je     49 <request_completed+0x49>
cmpl   $0x1,(%rbx)
jne    39 <request_completed+0x39>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     2b <request_completed+0x2b>
callq  24 <request_completed+0x24>
subl   $0x1,0x0(%rip)        # 2b <request_completed+0x2b>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     39 <request_completed+0x39>
callq  39 <request_completed+0x39>
mov    %rbx,%rdi
callq  41 <request_completed+0x41>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
request_completed (void *cls,
                   struct MHD_Connection *connection,
                   void **con_cls,
                   enum MHD_RequestTerminationCode toe)
{
  struct connection_info_struct *con_info = *con_cls;
  if (((void *)0) == con_info)
    return;
  if (con_info->connectiontype == POST)
    {
      if (((void *)0) != con_info->postprocessor)
        {
          MHD_destroy_post_processor (con_info->postprocessor);
          nr_of_uploading_clients--;
        }
      if (con_info->fp)
        fclose (con_info->fp);
    }
  free (con_info);
  *con_cls = ((void *)0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 6
6 7
7 7
8 9
9 9
10 11
11 11
12 11
13 13
14 14
15 16
16 16
17 16
18 17
19 19
20 19
21 20
22 21
23 21
24 21
25 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x1,%edx
callq  2aa <stream_get8+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
stream_get8(dico_stream_t str, unsigned char *p)
{
    return dico_stream_read(str, p, 1, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <strtoimax+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strtoimax (char const *ptr, char **endptr, int base)
{
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: (sizeof (intmax_t) == sizeof ( long int) || sizeof (intmax_t) == sizeof ( long long int)) ? 1 : -1; }))]
                                                      ;
  if (sizeof (intmax_t) != sizeof ( long int))
    return strtoll (ptr, endptr, base);
  return strtol (ptr, endptr, base);
}
<<<sep_in_sample>>>
1 2
2 7
3 8
4 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%r8
mov    (%rsi),%rax
mov    (%rax),%esi
test   %esi,%esi
jne    d2f <CDB___ram_getno+0x2a>
mov    0x28(%r8),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  d28 <CDB___ram_getno+0x23>
mov    $0x16,%eax
jmp    d4b <CDB___ram_getno+0x46>
test   %rdx,%rdx
je     d36 <CDB___ram_getno+0x31>
mov    %esi,(%rdx)
mov    $0x0,%eax
cmpl   $0x3,0xe0(%rdi)
jne    d4b <CDB___ram_getno+0x46>
mov    %ecx,%edx
callq  3be <__ram_update>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___ram_getno(dbc, key, rep, can_create)
 DBC *dbc;
 const DBT *key;
 db_recno_t *rep;
 int can_create;
{
 DB *dbp;
 db_recno_t recno;
 dbp = dbc->dbp;
 if ((recno = *(db_recno_t *)key->data) == 0) {
  CDB___db_err(dbp->dbenv, "illegal record number of 0");
  return (22);
 }
 if (rep != ((void *)0))
  *rep = recno;
 return (dbc->dbtype == DB_RECNO ?
     __ram_update(dbc, recno, can_create) : 0);
}
<<<sep_in_sample>>>
1 6
2 9
3 10
4 10
5 10
6 10
7 11
8 11
9 11
10 11
11 12
12 12
13 14
14 14
15 15
16 17
17 17
18 17
19 17
20 17
21 18
22 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %esi,%r13d
mov    %rdx,%rbp
test   %rdx,%rdx
jle    d3c <tape_buffered_write+0x63>
movslq 0x0(%rip),%rbx        # cf8 <tape_buffered_write+0x1f>
sub    0x0(%rip),%rbx        # cff <tape_buffered_write+0x26>
jne    d0b <tape_buffered_write+0x32>
mov    %r13d,%edi
callq  d09 <tape_buffered_write+0x30>
jmp    d37 <tape_buffered_write+0x5e>
cmp    %rbx,%rbp
cmovle %rbp,%rbx
mov    %ebx,%edx
mov    %r12,%rsi
mov    0x0(%rip),%rdi        # d1e <tape_buffered_write+0x45>
callq  d23 <tape_buffered_write+0x4a>
add    %rbx,0x0(%rip)        # d2a <tape_buffered_write+0x51>
add    %rbx,0x0(%rip)        # d31 <tape_buffered_write+0x58>
add    %rbx,%r12
sub    %rbx,%rbp
test   %rbp,%rbp
jg     cf1 <tape_buffered_write+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
tape_buffered_write (char *in_buf, int out_des, off_t num_bytes)
{
  off_t bytes_left = num_bytes;
  off_t space_left;
  while (bytes_left > 0)
    {
      space_left = io_block_size - output_size;
      if (space_left == 0)
 tape_empty_output_buffer (out_des);
      else
 {
   if (bytes_left < space_left)
     space_left = bytes_left;
   memcpy (out_buff, in_buf, (unsigned) space_left);
   out_buff += space_left;
   output_size += space_left;
   in_buf += space_left;
   bytes_left -= space_left;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 7
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 14
21 14
22 14
23 15
24 16
25 17
26 18
27 5
28 5
29 21
30 21
31 21
32 21
33 21
34 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  41 <ding+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ding ()
{
  return rl_ding ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
callq  ac <ds_erase+0xd>
mov    %rbx,%rdi
callq  b4 <ds_erase+0x15>
pop    %rbx
retq   
<<<sep_in_sample>>>
ds_erase (struct dstring *string)
{
  free (string->content);
  free (string);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%r13d
mov    %ecx,%ebp
mov    %esi,%r9d
mov    %edx,%r8d
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x89,(%rax)
mov    $0x0,%r9d
mov    %r13d,%r8d
mov    %r12d,%ecx
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  22b7 <_rx>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_stxr_l(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r2, r1, r0);
    *_jit->pc.uc++ = 0x89;
    _rx(_jit, r2, 0, r0, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 6
31 6
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movb   $0x0,0x20(%rdi)
retq   
<<<sep_in_sample>>>
digest_md5_free_finish (digest_md5_finish * f)
{
  memset (f, 0, sizeof (*f));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  1d77 <gsl_sf_airy_Ai_deriv+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1d9d <gsl_sf_airy_Ai_deriv+0x32>
mov    %eax,%ecx
mov    $0x36b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d96 <gsl_sf_airy_Ai_deriv+0x2b>
movsd  (%rsp),%xmm0
jmp    1d9d <gsl_sf_airy_Ai_deriv+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_airy_Ai_deriv(const double x, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_airy_Ai_deriv_e(x, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_airy_Ai_deriv_e(x, mode, &result)", "airy_der.c", 875, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
mov    %rdi,%rax
movzbl (%rdi),%ecx
test   %cl,%cl
je     594 <tail_nc+0x2d>
lea    0x1(%rdi),%rdx
cmp    $0x2f,%cl
jne    588 <tail_nc+0x21>
movzbl (%rdx),%ecx
test   %cl,%cl
je     588 <tail_nc+0x21>
cmp    $0x2f,%cl
cmovne %rdx,%rax
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
test   %cl,%cl
jne    575 <tail_nc+0xe>
repz retq 
<<<sep_in_sample>>>
tail_nc (register char *fn)
{
  register char *p;
  for (p = fn; *p != 0; p++)
    if (*p == '/' && p[1] != '\0' && p[1] != '/')
      fn = &p[1];
  return fn;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 4
15 4
16 4
17 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  4bb3 <gsl_sf_conicalP_cyl_reg+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     4bd9 <gsl_sf_conicalP_cyl_reg+0x32>
mov    %eax,%ecx
mov    $0x55d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4bd2 <gsl_sf_conicalP_cyl_reg+0x2b>
movsd  (%rsp),%xmm0
jmp    4bd9 <gsl_sf_conicalP_cyl_reg+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_conicalP_cyl_reg(const int m, const double lambda, const double x)
{
  gsl_sf_result result; int status = gsl_sf_conicalP_cyl_reg_e(m, lambda, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_conicalP_cyl_reg_e(m, lambda, x, &result)", "legendre_con.c", 1373, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
mov    (%rdi),%rbx
mov    0x20(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    47c <hash_map+0x34>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     473 <hash_map+0x2b>
cmp    0x0(%rip),%rdi        # 46e <hash_map+0x26>
je     473 <hash_map+0x2b>
callq  *%r12
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     45f <hash_map+0x17>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
hash_map (struct hash_table *ht, hash_map_func_t map)
{
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  for (slot = ht->ht_vec; slot < end; slot++)
    {
      if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
 (*map) (*slot);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 5
17 5
18 5
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  146 <print_acct_file_location+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_acct_file_location(void)
{
  (void)printf("\nThe system's default process accounting file is %s.\n", "/var/log/account/pacct");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r8d
callq  d85 <internal_realloc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sh_realloc (ptr, size, file, line)
     void * ptr;
     size_t size;
     const char *file;
     int line;
{
  return internal_realloc (ptr, size, file, line, 0x01);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 8
5 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
test   %esi,%esi
je     297 <send_will+0x45>
movslq %edi,%rax
movzbl 0x0(%rax),%eax
test   %al,%al
jne    273 <send_will+0x21>
movslq %edi,%rdx
testb  $0x1,0x0(%rdx)
jne    2f2 <send_will+0xa0>
movslq %ebx,%rdx
movzbl 0x0(%rdx),%edx
test   $0x2,%dl
jne    2f2 <send_will+0xa0>
movslq %ebx,%rcx
or     $0x2,%edx
mov    %dl,0x0(%rcx)
add    $0x1,%eax
mov    %al,0x0(%rcx)
mov    0x0(%rip),%rax        # 29e <send_will+0x4c>
movb   $0xff,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  2b0 <send_will+0x5e>
mov    0x0(%rip),%rax        # 2b7 <send_will+0x65>
movb   $0xfb,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  2c9 <send_will+0x77>
mov    0x0(%rip),%rax        # 2d0 <send_will+0x7e>
mov    %bl,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  2e1 <send_will+0x8f>
mov    %ebx,%edx
mov    $0xfb,%esi
mov    $0x0,%edi
callq  2f2 <send_will+0xa0>
pop    %rbx
retq   
<<<sep_in_sample>>>
send_will (register int c, register int init)
{
  if (init)
    {
      if (((will_wont_resp[c] == 0) && (options[c]&0x01)) ||
   (options[c]&0x02))
 return;
      {options[c] |= 0x02;};
      will_wont_resp[c]++;
    }
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 251; ring_supplied(&netoring, 1); }; };
  { *netoring.supply = c; ring_supplied(&netoring, 1); };
  printoption ("SENT", 251, c);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 5
15 5
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 12
36 13
37 13
38 13
39 13
40 14
41 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  287 <idset_close+0xd>
mov    %rbx,%rdi
callq  28f <idset_close+0x15>
pop    %rbx
retq   
<<<sep_in_sample>>>
idset_close(IDSET *idset)
{
 free(idset->set);
 free(idset);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <def_realloc_fun+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
def_realloc_fun(void *ptr, size_t size)
{
 return realloc(ptr, size);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x1,%edi
callq  35 <catch_fatal_signals+0x13>
mov    $0x0,%esi
mov    $0x2,%edi
callq  44 <catch_fatal_signals+0x22>
mov    $0x0,%esi
mov    $0xf,%edi
callq  53 <catch_fatal_signals+0x31>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
catch_fatal_signals(void)
{
  signal(1, handle_fatal_signal);
  signal(2, handle_fatal_signal);
  signal(15, handle_fatal_signal);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x38(%rdi),%rdi
callq  39e <gsl_multifit_fdfridge_residual+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_fdfridge_residual (const gsl_multifit_fdfridge * w)
{
  return gsl_multifit_fdfsolver_residual(w->s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     13cd <mu_message_get_qid+0x22>
mov    0x80(%rdi),%rdx
mov    $0x26,%al
test   %rdx,%rdx
je     13cd <mu_message_get_qid+0x22>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_message_get_qid (mu_message_t msg, mu_message_qid_t *pqid)
{
  if (msg == ((void *)0))
    return 22;
  if (!msg->_get_qid)
    return 38;
  return msg->_get_qid (msg, pqid);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 5
7 5
8 2
9 7
10 8
11 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpb   $0x30,(%rdi)
jne    411 <sh_invalidnum+0x42>
callq  3dd <sh_invalidnum+0xe>
movzbl 0x1(%rbx),%edx
movzbl %dl,%ecx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rcx,2)
je     3fd <sh_invalidnum+0x2e>
mov    $0x0,%edi
callq  3f8 <sh_invalidnum+0x29>
mov    %rax,%rdx
jmp    41e <sh_invalidnum+0x4f>
cmp    $0x78,%dl
jne    411 <sh_invalidnum+0x42>
mov    $0x0,%edi
callq  40c <sh_invalidnum+0x3d>
mov    %rax,%rdx
jmp    41e <sh_invalidnum+0x4f>
mov    $0x0,%edi
callq  41b <sh_invalidnum+0x4c>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  430 <sh_invalidnum+0x61>
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_invalidnum (s)
     char *s;
{
  char *msg;
  if (*s == '0' && ((*__ctype_b_loc ())[(int) (((unsigned char)s[1]))] & (unsigned short int) _ISdigit))
    msg = gettext("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = gettext("invalid hex number");
  else
    msg = gettext("invalid number");
  builtin_error ("%s: %s", s, msg);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 12
29 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
test   %rsi,%rsi
je     41 <_gsasl_support_p+0x41>
mov    %rdx,%r12
mov    %rdi,%rbp
mov    $0x0,%ebx
test   %r12,%r12
je     32 <_gsasl_support_p+0x32>
mov    0x0(%rbp),%rsi
mov    %r12,%rdi
callq  2e <_gsasl_support_p+0x2e>
test   %eax,%eax
je     48 <_gsasl_support_p+0x48>
add    $0x1,%rbx
add    $0x78,%rbp
cmp    %r13,%rbx
jne    1d <_gsasl_support_p+0x1d>
jmp    4f <_gsasl_support_p+0x4f>
mov    $0x0,%eax
jmp    54 <_gsasl_support_p+0x54>
mov    $0x1,%eax
jmp    54 <_gsasl_support_p+0x54>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_gsasl_support_p (Gsasl_mechanism * mechs, size_t n_mechs, const char *name)
{
  size_t i;
  for (i = 0; i < n_mechs; i++)
    if (name && strcmp (name, mechs[i].name) == 0)
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 4
20 4
21 4
22 4
23 4
24 7
25 7
26 6
27 6
28 7
29 8
30 8
31 8
32 8
33 8
34 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     18f <scram_valid_client_final+0x6c>
mov    $0x0,%ecx
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  143 <scram_valid_client_final+0x20>
mov    $0x0,%ecx
test   %rax,%rax
jne    1a2 <scram_valid_client_final+0x7f>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     196 <scram_valid_client_final+0x73>
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  165 <scram_valid_client_final+0x42>
mov    $0x0,%ecx
test   %rax,%rax
jne    1a2 <scram_valid_client_final+0x7f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     19d <scram_valid_client_final+0x7a>
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  187 <scram_valid_client_final+0x64>
test   %rax,%rax
sete   %cl
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
mov    %ecx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
scram_valid_client_final (struct scram_client_final * cl)
{
  if (cl->cbind == ((void *)0) || *cl->cbind == '\0')
    return 0;
  if (strchr (cl->cbind, ','))
    return 0;
  if (cl->nonce == ((void *)0) || *cl->nonce == '\0')
    return 0;
  if (strchr (cl->nonce, ','))
    return 0;
  if (cl->proof == ((void *)0) || *cl->proof == '\0')
    return 0;
  if (strchr (cl->proof, ','))
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
9 5
10 5
11 6
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 9
20 9
21 10
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 4
35 4
36 8
37 8
38 12
39 16
40 16
41 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  47 <selectSystem+0x9>
mov    $0x100,%eax
movsd  0x0(%rip),%xmm1        # 54 <selectSystem+0x16>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x1,%ax
movsd  0x0(%rip),%xmm1        # 6a <selectSystem+0x2c>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x2,%al
movsd  0x0(%rip),%xmm1        # 7e <selectSystem+0x40>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x10,%al
movsd  0x0(%rip),%xmm1        # 92 <selectSystem+0x54>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x20,%al
movsd  0x0(%rip),%xmm1        # a6 <selectSystem+0x68>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x40,%al
movsd  0x0(%rip),%xmm1        # ba <selectSystem+0x7c>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x80,%al
movsd  0x0(%rip),%xmm1        # ca <selectSystem+0x8c>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x4,%al
movsd  0x0(%rip),%xmm1        # da <selectSystem+0x9c>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x8,%al
movsd  0x0(%rip),%xmm1        # ea <selectSystem+0xac>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x800,%ax
movsd  0x0(%rip),%xmm1        # fc <selectSystem+0xbe>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x400,%ax
movsd  0x0(%rip),%xmm1        # 10e <selectSystem+0xd0>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
mov    $0x2000,%ax
movsd  0x0(%rip),%xmm1        # 120 <selectSystem+0xe2>
ucomisd %xmm0,%xmm1
ja     13f <selectSystem+0x101>
movsd  0x0(%rip),%xmm1        # 12e <selectSystem+0xf0>
ucomisd %xmm0,%xmm1
mov    $0x1000,%ax
mov    $0x4000,%edx
cmova  %rdx,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
selectSystem(void)
{
 double r;
 long i;
 if ((r = frandom()) < 0.25)
  i = 0x0100;
 else if (r < 0.35)
  i = 0x0001;
 else if (r < 0.40)
  i = 0x0002;
 else if (r < 0.45)
  i = 0x0010;
 else if (r < 0.50)
  i = 0x0020;
 else if (r < 0.53)
  i = 0x0040;
 else if (r < 0.56)
  i = 0x0080;
 else if (r < 0.61)
  i = 0x0004;
 else if (r < 0.69)
  i = 0x0008;
 else if (r < 0.78)
  i = 0x0800;
 else if (r < 0.85)
  i = 0x0400;
 else if (r < 0.90)
  i = 0x2000;
 else if (r < 0.95)
  i = 0x4000;
 else
  i = 0x1000;
 return i;
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 5
5 5
6 5
7 8
8 7
9 7
10 7
11 10
12 9
13 9
14 9
15 12
16 11
17 11
18 11
19 14
20 13
21 13
22 13
23 16
24 15
25 15
26 15
27 18
28 17
29 17
30 17
31 20
32 19
33 19
34 19
35 22
36 21
37 21
38 21
39 24
40 23
41 23
42 23
43 26
44 25
45 25
46 25
47 28
48 27
49 27
50 27
51 29
52 29
53 32
54 32
55 32
56 34
57 34
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x90(%rdi),%rax
movl   $0xffffffff,0x30(%rax)
mov    0x90(%rdi),%rax
movq   $0xffffffffffffffff,0x38(%rax)
mov    $0x9,%esi
callq  19d <osip_ist_timeout_i_event+0x2b>
mov    %rbx,%rsi
mov    $0x1,%edi
callq  1aa <osip_ist_timeout_i_event+0x38>
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_ist_timeout_i_event (osip_transaction_t * ist, osip_event_t * evt)
{
  ist->ist_context->timer_i_length = -1;
  ist->ist_context->timer_i_start.tv_sec = -1;
  __osip_transaction_set_state (ist, IST_TERMINATED);
  __osip_kill_transaction_callback (OSIP_IST_KILL_TRANSACTION, ist);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
gl_linked_size (gl_list_t list)
{
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
callq  7e <swheaderline_write_debug+0x17>
mov    %rax,%r13
lea    0xc(%rsp),%rsi
mov    %rbx,%rdi
callq  8e <swheaderline_write_debug+0x27>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  99 <swheaderline_write_debug+0x32>
mov    %eax,%r14d
cmpb   $0x0,0x0(%rbp)
jne    b6 <swheaderline_write_debug+0x4f>
mov    $0x1,%ecx
mov    %eax,%edx
mov    %r13,%rsi
mov    %r12d,%edi
callq  b4 <swheaderline_write_debug+0x4d>
jmp    101 <swheaderline_write_debug+0x9a>
mov    $0xa,%esi
mov    %rbp,%rdi
callq  c3 <swheaderline_write_debug+0x5c>
mov    %rax,%rbx
test   %rax,%rax
jne    e4 <swheaderline_write_debug+0x7d>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbp,%rcx,1),%rbx
movb   $0x0,(%rbx)
mov    $0x1,%r8d
mov    %r14d,%ecx
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r12d,%edi
callq  fe <swheaderline_write_debug+0x97>
movb   $0xa,(%rbx)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
swheaderline_write_debug(char * line, int fd)
{
 int i, ret;
 char * p;
 char * keyw=swheaderline_get_keyword(line);
 char * value=swheaderline_get_value(line, &i);
 int level=swheaderline_get_level(line);
 if (!strlen(value)) {
  ret=swparse_write_attribute_obj(fd, keyw, level, 1);
 } else {
  p=strchr(value, (int)'\n');
  if (!p){
   p=value + strlen(value);
  }
  *p='\0';
  ret=swparse_write_attribute_att(fd, keyw, value, level, 1);
  *p=(char)'\n';
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 11
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 13
35 13
36 13
37 13
38 15
39 16
40 16
41 16
42 16
43 16
44 16
45 17
46 20
47 20
48 20
49 20
50 20
51 20
52 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
test   %rdi,%rdi
je     2a <lm_free+0x12>
callq  2a <lm_free+0x12>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     38 <lm_free+0x20>
callq  38 <lm_free+0x20>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     46 <lm_free+0x2e>
callq  46 <lm_free+0x2e>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     54 <lm_free+0x3c>
callq  54 <lm_free+0x3c>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     62 <lm_free+0x4a>
callq  62 <lm_free+0x4a>
mov    %rbx,%rdi
callq  6a <lm_free+0x52>
pop    %rbx
retq   
<<<sep_in_sample>>>
lm_free(void *vstate)
{
  lm_state_t *state = (lm_state_t *) vstate;
  if (state->workp)
    gsl_vector_free(state->workp);
  if (state->workn)
    gsl_vector_free(state->workn);
  if (state->fvv)
    gsl_vector_free(state->fvv);
  if (state->vel)
    gsl_vector_free(state->vel);
  if (state->acc)
    gsl_vector_free(state->acc);
  free(state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 15
26 15
<<<sep_out_sample>>>
push   %r14
push   %rbx
sub    $0x138,%rsp
mov    %rsi,0x8(%rsp)
mov    %edi,0x10(%rsp)
mov    0x10(%rdx),%rax
mov    %rax,0x18(%rsp)
movl   $0x0,0x30(%rsp)
movq   $0x0,0x38(%rsp)
mov    %r8,0x20(%rsp)
mov    %rcx,0x28(%rsp)
mov    (%rsi),%rax
mov    %rax,0x108(%rsp)
mov    0x8(%rsi),%rax
mov    %rax,0x110(%rsp)
mov    0x10(%rsi),%rax
mov    %rax,0x118(%rsp)
mov    0xc(%rdx),%eax
mov    %eax,0x120(%rsp)
test   %eax,%eax
je     3805 <eval_section+0x8c>
mov    %rsi,%r14
mov    0x20(%rsi),%rbx
mov    $0x0,%edi
callq  37f2 <eval_section+0x79>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    %r14,%rdi
mov    $0x0,%eax
callq  3805 <eval_section+0x8c>
lea    0x40(%rsp),%rdi
callq  380f <eval_section+0x96>
test   %eax,%eax
jne    3826 <eval_section+0xad>
mov    0x8(%rsp),%rax
mov    0x28(%rax),%rsi
lea    0x10(%rsp),%rdi
callq  334e <stmt_list_eval>
mov    0x38(%rsp),%rsi
test   %rsi,%rsi
je     383a <eval_section+0xc1>
mov    $0xffffffff,%edi
callq  383a <eval_section+0xc1>
add    $0x138,%rsp
pop    %rbx
pop    %r14
retq   
<<<sep_in_sample>>>
eval_section (int method, RC_SECTION *sec, struct rc_secdef *secdef,
       void *data, MESSAGE msg)
{
  struct eval_env env;
  env.method = method;
  env.child = secdef->child;
  env.refcnt = 0;
  env.refstr = ((void *)0);
  env.msg = msg;
  env.data = data;
  env.loc = sec->loc;
  env.traceable = secdef->allow_prog;
  if (env.traceable)
    tracefile (&sec->loc, gettext("Section %s"), sec->name);
  if (_setjmp (env.jmp) == 0)
    stmt_list_eval (&env, sec->stmt);
  if (env.refstr)
    argcv_free (-1, env.refstr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 7
9 8
10 9
11 10
12 11
13 11
14 11
15 11
16 11
17 11
18 12
19 12
20 13
21 13
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 15
32 15
33 15
34 15
35 16
36 16
37 16
38 16
39 17
40 17
41 17
42 18
43 18
44 19
45 19
46 19
47 19
<<<sep_out_sample>>>
mov    %rdi,%rax
or     %rsi,%rax
lea    -0x1(%rax),%rdx
xor    %rdx,%rax
test   %rdi,%rax
je     19 <gcd+0x19>
test   %rsi,%rax
jne    2b <gcd+0x2b>
jmp    45 <gcd+0x45>
test   %rsi,%rax
nopl   0x0(%rax)
jne    38 <gcd+0x38>
sub    $0x8,%rsp
callq  2b <gcd+0x2b>
cmp    %rsi,%rdi
je     4f <gcd+0x4f>
cmp    %rsi,%rdi
jbe    42 <gcd+0x42>
sub    %rsi,%rdi
shr    %rdi
test   %rdi,%rax
je     38 <gcd+0x38>
jmp    2b <gcd+0x2b>
sub    %rdi,%rsi
shr    %rsi
test   %rsi,%rax
je     45 <gcd+0x45>
jmp    2b <gcd+0x2b>
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
gcd (unsigned long a, unsigned long b)
{
  unsigned long c = a | b;
  c = c ^ (c - 1);
  if (a & c)
    {
      if (b & c)
        goto odd_odd;
      else
        goto odd_even;
    }
  else
    {
      if (b & c)
        goto even_odd;
      else
        abort ();
    }
  for (;;)
    {
    odd_odd:
      if (a == b)
        break;
      if (a > b)
        {
          a = a - b;
        even_odd:
          do
            a = a >> 1;
          while ((a & c) == 0);
        }
      else
        {
          b = b - a;
        odd_even:
          do
            b = b >> 1;
          while ((b & c) == 0);
        }
    }
  return a;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 7
8 7
9 7
10 14
11 14
12 14
13 2
14 17
15 22
16 22
17 24
18 24
19 26
20 29
21 30
22 30
23 30
24 34
25 37
26 38
27 38
28 38
29 42
30 42
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
mov    $0x2,%edi
callq  e8 <cgt_time_end+0x11>
test   %eax,%eax
jns    10a <cgt_time_end+0x33>
callq  f1 <cgt_time_end+0x1a>
mov    (%rax),%edi
callq  f8 <cgt_time_end+0x21>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  37 <die>
mov    (%rsp),%rax
sub    0x0(%rip),%rax        # 115 <cgt_time_end+0x3e>
cvtsi2sd %rax,%xmm1
mov    0x8(%rsp),%rax
sub    0x0(%rip),%rax        # 126 <cgt_time_end+0x4f>
cvtsi2sd %rax,%xmm0
mulsd  0x0(%rip),%xmm0        # 133 <cgt_time_end+0x5c>
addsd  %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
cgt_time_end(void)
{
  struct timespec end;
  if (clock_gettime(2, &end) < 0)
    die("clock_gettime failed: %s\n", strerror((*__errno_location ())));
  return end.tv_sec - cgt_start.tv_sec
    + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 6
22 8
23 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 218a <set_lint_or_format_shortcuts+0x7>
mov    0x98(%rax),%rax
cmpq   $0x0,0x28(%rax)
je     21b8 <set_lint_or_format_shortcuts+0x35>
mov    $0x0,%esi
mov    $0x0,%edi
callq  21a7 <set_lint_or_format_shortcuts+0x24>
mov    $0x0,%esi
mov    $0x0,%edi
callq  21b6 <set_lint_or_format_shortcuts+0x33>
repz retq 
mov    $0x0,%esi
mov    $0x0,%edi
callq  21c7 <set_lint_or_format_shortcuts+0x44>
mov    $0x0,%esi
mov    $0x0,%edi
callq  21d6 <set_lint_or_format_shortcuts+0x53>
repz retq 
<<<sep_in_sample>>>
set_lint_or_format_shortcuts(void)
{
    if (openfile->syntax->formatter) {
 replace_scs_for(do_spell, do_formatter);
 replace_scs_for(do_linter, do_formatter);
    } else {
 replace_scs_for(do_spell, do_linter);
 replace_scs_for(do_formatter, do_linter);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rax
test   %rax,%rax
je     11c <is_num+0x1e>
mov    (%rax),%al
sub    $0x30,%eax
cmp    $0x9,%al
setbe  %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
is_num (int idx)
{
    if (!columns [idx] || columns [idx][0] < '0' || columns [idx][0] > '9')
 return 0;
    return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1e8 <do_cut_next_word+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_cut_next_word(void)
{
    do_cutword(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  6e <nettle_gcm_camellia128_update+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_camellia128_update (struct gcm_camellia128_ctx *ctx,
   size_t length, const uint8_t *data)
{
  nettle_gcm_update(&(ctx)->gcm, &(ctx)->key, (length), (data));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x50(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     2f <file_hash_1+0x2f>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    10 <file_hash_1+0x10>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
file_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct file const *) key)->hname)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%r13
mov    0x20(%rdi),%rdx
mov    (%rdi),%rax
lea    (%rax,%rdx,8),%rbx
test   %rsi,%rsi
jne    656 <hash_dump+0x36>
mov    0x30(%rdi),%rax
lea    0x8(,%rax,8),%edi
callq  653 <hash_dump+0x33>
mov    %rax,%r12
mov    0x0(%rbp),%r8
cmp    %r8,%rbx
jbe    685 <hash_dump+0x65>
mov    %r12,%rax
mov    (%r8),%r9
test   %r9,%r9
je     67a <hash_dump+0x5a>
cmp    0x0(%rip),%r9        # 671 <hash_dump+0x51>
je     67a <hash_dump+0x5a>
mov    %r9,(%rax)
lea    0x8(%rax),%rax
add    $0x8,%r8
cmp    %r8,%rbx
ja     662 <hash_dump+0x42>
jmp    688 <hash_dump+0x68>
mov    %r12,%rax
movq   $0x0,(%rax)
test   %r13,%r13
je     6a8 <hash_dump+0x88>
mov    0x30(%rbp),%rsi
mov    %r13,%rcx
mov    $0x8,%edx
mov    %r12,%rdi
callq  6a8 <hash_dump+0x88>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
hash_dump (struct hash_table *ht, void **vector_0, qsort_cmp_t compare)
{
  void **vector;
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  if (vector_0 == 0)
    vector_0 = ((void * *) xmalloc (sizeof (void *) * (ht->ht_fill + 1)));
  vector = vector_0;
  for (slot = ht->ht_vec; slot < end; slot++)
    if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
      *vector++ = *slot;
  *vector = 0;
  if (compare)
    qsort (vector_0, ht->ht_fill, sizeof (void *), compare);
  return vector_0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 8
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 9
30 9
31 9
32 9
33 8
34 12
35 13
36 13
37 14
38 14
39 14
40 14
41 14
42 16
43 16
44 16
45 16
46 16
47 16
48 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
movapd %xmm0,%xmm1
mov    %rdi,%rbx
movsd  0x0(%rip),%xmm0        # 14 <i_transform+0x14>
subsd  %xmm1,%xmm0
movsd  %xmm1,0x8(%rsp)
divsd  %xmm1,%xmm0
mov    0x8(%rdi),%rdi
movsd  %xmm0,0x10(%rsp)
callq  *(%rbx)
movsd  %xmm0,0x18(%rsp)
mov    0x8(%rbx),%rdi
movsd  0x0(%rip),%xmm0        # 40 <i_transform+0x40>
movsd  0x10(%rsp),%xmm2
xorpd  %xmm2,%xmm0
callq  *(%rbx)
addsd  0x18(%rsp),%xmm0
movsd  0x8(%rsp),%xmm1
divsd  %xmm1,%xmm0
divsd  %xmm1,%xmm0
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
i_transform (double t, void *params)
{
  gsl_function *f = (gsl_function *) params;
  double x = (1 - t) / t;
  double y = (*((f)->function))(x,(f)->params) + (*((f)->function))(-x,(f)->params);
  return (y / t) / t;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edx,%ebp
mov    %rcx,%rbx
callq  0 <xargs_open_generic>
movl   $0x2,0x24(%rax)
mov    %ebp,0x60(%rax)
mov    %rbx,0x68(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xargs_open_with_argv(const char *command, int max_args, int argc, char *const *argv)
{
 XARGS *xp = xargs_open_generic(command, max_args);
 xp->type = 2;
 xp->argc = argc;
 xp->argv = argv;
 return xp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 6
10 8
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%esi
mov    $0x0,%ebp
mov    %r12,%rdi
callq  2a3 <find_string_var+0x1e>
test   %eax,%eax
je     2b9 <find_string_var+0x34>
add    $0x1,%ebp
add    $0x18,%rbx
mov    -0x18(%rbx),%rsi
test   %rsi,%rsi
jne    29b <find_string_var+0x16>
jmp    2bd <find_string_var+0x38>
mov    %ebp,%eax
jmp    2c2 <find_string_var+0x3d>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
find_string_var (name)
     const char *name;
{
  register int i;
  for (i = 0; string_varlist[i].name; i++)
    if (strcasecmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
11 6
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 8
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    0x8(%rdx),%rdx
mov    $0x1,%esi
mov    $0x4c,%edi
callq  169 <cholesky_covar+0x22>
mov    0x18(%rbx),%rsi
mov    0x8(%rbx),%rdi
mov    $0x0,%edx
callq  17b <cholesky_covar+0x34>
mov    %eax,%ecx
test   %ecx,%ecx
jne    191 <cholesky_covar+0x4a>
mov    0x18(%rbx),%rsi
mov    0x8(%rbx),%rdi
mov    %rbp,%rdx
callq  191 <cholesky_covar+0x4a>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cholesky_covar(const gsl_matrix * JTJ, gsl_matrix * covar, void * vstate)
{
  int status;
  cholesky_state_t *state = (cholesky_state_t *) vstate;
  gsl_matrix_tricpy('L', 1, state->work_JTJ, JTJ);
  status = gsl_linalg_mcholesky_decomp(state->work_JTJ, state->perm, ((void *)0));
  if (status)
    return status;
  status = gsl_linalg_mcholesky_invert(state->work_JTJ, state->perm, covar);
  if (status)
    return status;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 9
19 9
20 9
21 9
22 13
23 13
24 13
25 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x18(%rdi),%rdi
test   %rdi,%rdi
je     442 <hol_free+0x25>
mov    0x28(%rdi),%rbx
callq  438 <hol_free+0x1b>
test   %rbx,%rbx
je     442 <hol_free+0x25>
mov    %rbx,%rdi
jmp    42f <hol_free+0x12>
cmpl   $0x0,0x8(%rbp)
je     45a <hol_free+0x3d>
mov    0x0(%rbp),%rdi
callq  451 <hol_free+0x34>
mov    0x10(%rbp),%rdi
callq  45a <hol_free+0x3d>
mov    %rbp,%rdi
callq  462 <hol_free+0x45>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
hol_free (struct hol *hol)
{
  struct hol_cluster *cl = hol->clusters;
  while (cl)
    {
      struct hol_cluster *next = cl->next;
      free (cl);
      cl = next;
    }
  if (hol->num_entries > 0)
    {
      free (hol->entries);
      free (hol->short_options);
    }
  free (hol);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 6
9 7
10 4
11 4
12 8
13 8
14 10
15 10
16 12
17 12
18 13
19 13
20 15
21 15
22 16
23 16
24 16
25 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  159f <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
movsd  (%rsi),%xmm4
movslq %ecx,%rax
movsd  %xmm2,(%rdi,%rax,8)
test   %edx,%edx
je     ea <backward_recurse_s+0x25>
mov    %ecx,%edx
mov    $0xc7,%eax
movsd  0x0(%rip),%xmm3        # e4 <backward_recurse_s+0x1f>
test   %ecx,%ecx
jg     134 <backward_recurse_s+0x6f>
jmp    166 <backward_recurse_s+0xa1>
test   %ecx,%ecx
jle    166 <backward_recurse_s+0xa1>
mov    %ecx,%eax
mov    $0x64,%r8d
sub    %ecx,%r8d
movsd  0x0(%rip),%xmm3        # 101 <backward_recurse_s+0x3c>
movslq %eax,%rdx
lea    (%r8,%rax,1),%ecx
imul   %ecx,%ecx
shl    $0x2,%ecx
cvtsi2sd %ecx,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
addsd  (%rdi,%rdx,8),%xmm2
movapd %xmm3,%xmm5
divsd  %xmm2,%xmm5
movsd  %xmm5,-0x8(%rdi,%rdx,8)
sub    $0x1,%eax
jne    101 <backward_recurse_s+0x3c>
jmp    166 <backward_recurse_s+0xa1>
movslq %edx,%rcx
mov    %eax,%r8d
imul   %eax,%r8d
cvtsi2sd %r8d,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
addsd  (%rdi,%rcx,8),%xmm2
movapd %xmm3,%xmm6
divsd  %xmm2,%xmm6
movsd  %xmm6,-0x8(%rdi,%rcx,8)
sub    $0x2,%eax
sub    $0x1,%edx
jne    134 <backward_recurse_s+0x6f>
movsd  (%rdi),%xmm0
subsd  %xmm4,%xmm0
movsd  %xmm0,(%rsi)
retq   
<<<sep_in_sample>>>
backward_recurse_s(double aa, double qq, double xx, double *ff,
                               double *gx, int even_odd, int ni)
{
  int ii, nn;
  double g1;
  g1 = *gx;
  ff[ni] = xx;
  if (even_odd == 0)
  {
      for (ii=0; ii<ni; ii++)
      {
          nn = 100 - ii - 1;
          ff[ni-ii-1] = -1.0/((4*(nn + 1)*(nn + 1) - aa)/qq + ff[ni-ii]);
      }
  }
  else
  {
      for (ii=0; ii<ni; ii++)
      {
          nn = 100 - ii - 1;
          ff[ni-ii-1] = -1.0/(((2*nn + 1)*(2*nn + 1) - aa)/qq + ff[ni-ii]);
      }
  }
  *gx = ff[0] - g1;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 8
5 8
6 8
7 18
8 21
9 18
10 18
11 18
12 10
13 10
14 10
15 10
16 10
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 10
30 10
31 10
32 21
33 21
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 21
43 18
44 18
45 24
46 24
47 24
48 24
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  304 <os_isdir+0xf>
mov    $0x0,%edx
test   %eax,%eax
jne    321 <os_isdir+0x2c>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
os_isdir(int fd)
{
 struct stat sbuf;
 return (fstat(fd, &sbuf) == 0 && ((((sbuf.st_mode)) & 0170000) == (0040000)));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rdi
mov    0x28(%rax),%rcx
mov    $0x0,%eax
test   %rcx,%rcx
je     22e <page_range_applies_above+0x37>
mov    $0x0,%edx
mov    (%rdi,%rdx,8),%rax
cmp    %esi,(%rax)
jge    220 <page_range_applies_above+0x29>
mov    0x4(%rax),%eax
test   %eax,%eax
je     22e <page_range_applies_above+0x37>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    211 <page_range_applies_above+0x1a>
mov    $0x1,%eax
repz retq 
<<<sep_in_sample>>>
page_range_applies_above (struct page_range * page_range, int offset)
{
  size_t i;
  struct interval ** intervals =
    (struct interval **) page_range->intervals->content;
  if (page_range->intervals->len == 0)
    return 0;
  for (i = 0 ; i < page_range->intervals->len ; i++)
    if (intervals [i]->min < offset
 && intervals [i]->max == 0)
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 6
6 6
7 6
8 9
9 9
10 9
11 10
12 10
13 10
14 8
15 8
16 8
17 12
18 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  d9b <free_db+0xc>
mov    0x8(%rbx),%rdi
callq  da4 <free_db+0x15>
mov    0x10(%rbx),%rdi
callq  dad <free_db+0x1e>
mov    0x20(%rbx),%rdi
callq  db6 <free_db+0x27>
mov    0x40(%rbx),%rdi
test   %rdi,%rdi
je     dcd <free_db+0x3e>
callq  dc4 <free_db+0x35>
lea    0x40(%rbx),%rdi
callq  dcd <free_db+0x3e>
mov    0x50(%rbx),%rdi
callq  dd6 <free_db+0x47>
mov    %rbx,%rdi
callq  dde <free_db+0x4f>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_db(struct gcide_db *db)
{
    free(db->db_dir);
    free(db->idx_dir);
    free(db->tmpl_name);
    free(db->idxgcide);
    if (db->file_stream) {
 dico_stream_close(db->file_stream);
 dico_stream_destroy(&db->file_stream);
    }
    gcide_idx_file_close(db->idx);
    free(db);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 8
15 9
16 9
17 11
18 11
19 12
20 12
21 13
22 13
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     20 <_new_note+0x20>
lea    (%rax,%rax,4),%rcx
mov    0x28(%rdi),%rax
lea    -0x28(%rax,%rcx,8),%rax
mov    %rsi,%rcx
sub    (%rax),%rcx
mov    %rcx,0x20(%rax)
mov    0x38(%rdi),%rcx
mov    0x128(%rcx),%rax
lea    0x28(%rax),%r8
mov    %r8,0x128(%rcx)
addq   $0x1,0x30(%rdi)
mov    %rsi,(%rax)
mov    %rdx,0x8(%rax)
retq   
<<<sep_in_sample>>>
_new_note(jit_state_t *_jit, jit_uint8_t *code, char *name)
{
    jit_note_t *note;
    jit_note_t *prev;
    if (_jit->note.length) {
 prev = _jit->note.ptr + _jit->note.length - 1;
 ((void) (0));
 prev->size = code - prev->code;
    }
    note = (jit_note_t *)_jit->comp->note.base;
    _jit->comp->note.base += sizeof(jit_note_t);
    ++_jit->note.length;
    note->code = code;
    note->name = name;
    return (note);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 8
8 8
9 8
10 10
11 10
12 11
13 11
14 12
15 13
16 14
17 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b01 <init_backup_hash_table+0x23>
mov    %rax,0x0(%rip)        # b08 <init_backup_hash_table+0x2a>
test   %rax,%rax
jne    b12 <init_backup_hash_table+0x34>
callq  b12 <init_backup_hash_table+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_backup_hash_table (void)
{
  file_id_table = hash_initialize (0, ((void *)0), file_id_hasher,
       file_id_comparator, free);
  if (!file_id_table)
    xalloc_die ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 6
12 7
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%r13
mov    %rcx,%rbp
test   %rsi,%rsi
je     1c4 <assign_locus+0x47>
test   %rcx,%rcx
je     1b9 <assign_locus+0x3c>
mov    (%rdi),%rsi
test   %rsi,%rsi
je     1b1 <assign_locus+0x34>
mov    %r12,%rdi
callq  1ad <assign_locus+0x30>
test   %eax,%eax
je     1b9 <assign_locus+0x3c>
movq   $0x0,0x0(%rbp)
mov    %r12,%rdi
callq  1c1 <assign_locus+0x44>
mov    %rax,(%rbx)
mov    $0xa,%edx
lea    0x8(%rsp),%rsi
mov    %r13,%rdi
callq  1d6 <assign_locus+0x59>
test   %rbp,%rbp
je     1e0 <assign_locus+0x63>
mov    0x0(%rbp),%edx
jmp    1e5 <assign_locus+0x68>
mov    $0x0,%edx
sub    %edx,%eax
mov    %eax,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
setne  %al
movzbl %al,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
assign_locus(struct grecs_locus_point *ploc,
      char *name, char *line, size_t *pxlines)
{
 char *p;
 if (name) {
  if (pxlines && (!ploc->file || strcmp(name, ploc->file)))
   *pxlines = 0;
  ploc->file = grecs_install_text(name);
 }
 ploc->line = strtoul(line, &p, 10) - (pxlines ? *pxlines : 0);
 ploc->col = 0;
 return *p != 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 8
23 8
24 8
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 11
37 12
38 12
39 12
40 12
41 13
42 13
43 13
44 13
45 13
46 13
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
callq  205 <infopath_first+0xb>
repz retq 
<<<sep_in_sample>>>
infopath_first (int *idx)
{
  *idx = 0;
  return infopath_next (idx);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  3bbf <_mailbox_imap_init+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_mailbox_imap_init (mu_mailbox_t mailbox)
{
  return _mailbox_imap_and_imaps_init (mailbox, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4c <incl_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
incl_free(void *data)
{
 grecs_free(data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %edx,%esi
mov    %rcx,%rdx
mov    0x88(%rdi),%r9d
mov    $0x0,%ecx
mov    (%rax),%rdi
callq  41f <grayscale_convert+0x20>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grayscale_convert (j_decompress_ptr cinfo,
     JSAMPIMAGE input_buf, JDIMENSION input_row,
     JSAMPARRAY output_buf, int num_rows)
{
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
      num_rows, cinfo->output_width);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edi,%edi
je     47 <madir_to_string+0xf>
cmp    $0x1,%edi
je     53 <madir_to_string+0x1b>
jmp    62 <madir_to_string+0x2a>
mov    $0x0,%edi
callq  51 <madir_to_string+0x19>
jmp    67 <madir_to_string+0x2f>
mov    $0x0,%edi
callq  5d <madir_to_string+0x25>
nopl   (%rax)
jmp    67 <madir_to_string+0x2f>
callq  67 <madir_to_string+0x2f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
madir_to_string (madir_t madir)
{
  switch (madir)
    {
    case madir_rows:
      return gettext ("rows first");
    case madir_columns:
      return gettext ("columns first");
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 10
15 12
16 12
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x36,%edi
ja     10c <c_isxdigit+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case 'a' + (0): case 'b' + (0): case 'c' + (0): case 'd' + (0): case 'e' + (0): case 'f' + (0): case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 9
9 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  95d <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &default_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     2a7 <archive_format_string+0x23>
mov    $0x0,%edx
jmp    295 <archive_format_string+0x11>
cmp    %edi,0x8(%rdx)
je     2ac <archive_format_string+0x28>
add    $0x10,%rdx
mov    (%rdx),%rax
test   %rax,%rax
jne    290 <archive_format_string+0xc>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
archive_format_string (enum archive_format fmt)
{
  struct fmttab const *p;
  for (p = fmttab; p->name; p++)
    if (p->fmt == fmt)
      return p->name;
  return "unknown?";
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 4
5 5
6 5
7 4
8 4
9 4
10 4
11 7
12 7
13 4
14 8
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
swsdflt_defaults_array(void) {
  return swsdflt_arr;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 37 <getmaxchild+0x7>
mov    %rdx,%rax
test   %rdx,%rdx
jg     58 <getmaxchild+0x28>
sub    $0x8,%rsp
mov    $0x1,%edi
callq  4d <getmaxchild+0x1d>
mov    %rax,0x0(%rip)        # 54 <getmaxchild+0x24>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
getmaxchild ()
{
  static long maxchild = -1L;
  if (maxchild > 0)
    return maxchild;
  maxchild = sysconf (_SC_CHILD_MAX);
  return (maxchild);
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 2
6 6
7 6
8 6
9 8
10 8
<<<sep_out_sample>>>
mov    $0x0,%eax
and    $0x40,%esi
jmp    47 <next_brace_sub+0x47>
test   %esi,%esi
jne    1f <next_brace_sub+0x1f>
cmp    $0x5c,%dl
jne    1f <next_brace_sub+0x1f>
cmpb   $0x0,0x1(%rdi)
je     54 <next_brace_sub+0x54>
add    $0x2,%rdi
jmp    47 <next_brace_sub+0x47>
cmp    $0x7d,%dl
jne    2d <next_brace_sub+0x2d>
lea    -0x1(%rax),%edx
test   %eax,%eax
jne    6e <next_brace_sub+0x6e>
jmp    5e <next_brace_sub+0x5e>
cmp    $0x2c,%dl
jne    38 <next_brace_sub+0x38>
test   %eax,%eax
jne    68 <next_brace_sub+0x68>
jmp    5e <next_brace_sub+0x5e>
add    $0x1,%rdi
cmp    $0x7b,%dl
sete   %dl
movzbl %dl,%edx
add    %edx,%eax
movzbl (%rdi),%edx
test   %dl,%dl
jne    a <next_brace_sub+0xa>
mov    $0x0,%eax
retq   
cmpb   $0x0,0x1(%rdi)
je     62 <next_brace_sub+0x62>
add    $0x1,%rdi
mov    %rdi,%rax
retq   
mov    $0x0,%eax
retq   
add    $0x1,%rdi
jmp    47 <next_brace_sub+0x47>
add    $0x1,%rdi
mov    %edx,%eax
jmp    47 <next_brace_sub+0x47>
<<<sep_in_sample>>>
next_brace_sub (const char *cp, int flags)
{
  unsigned int depth = 0;
  while (*cp != '\0')
    if ((flags & (1 << 6)) == 0 && *cp == '\\')
      {
        if (*++cp == '\0')
          break;
        ++cp;
      }
    else
      {
        if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))
          break;
        if (*cp++ == '{')
          depth++;
      }
  return *cp != '\0' ? cp : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 9
11 9
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 15
24 16
25 16
26 16
27 16
28 4
29 4
30 4
31 18
32 18
33 18
34 18
35 7
36 7
37 7
38 18
39 18
40 15
41 15
42 15
43 13
44 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <AnnounceProgram+0xe>
mov    $0x0,%edi
callq  18 <AnnounceProgram+0x18>
mov    $0x0,%edi
callq  22 <AnnounceProgram+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
AnnounceProgram (void)
{
  printf ("\n________________________________________\n");
  printf ("\nMod " "v5.6.5" " - Model Generator for MCSim\n\n");
  printf ("MCSim and associated software comes with ABSOLUTELY NO WARRANTY;\n"
          "This is free software, and you are welcome to redistribute it\n"
          "under certain conditions; see the GNU General Public License.\n\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 8
9 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
cmp    $0x1,%edi
jle    27ed <account+0x8c>
mov    %rsi,%r12
lea    0x8(%rsi),%rbx
mov    0x8(%rsi),%rsi
mov    $0x31,%edx
mov    %rsp,%rdi
callq  279c <account+0x3b>
movb   $0x0,0x31(%rsp)
lea    -0x1(%rbp),%eax
cmp    $0x1,%eax
jle    2838 <account+0xd7>
lea    -0x3(%rbp),%eax
lea    0x10(%r12,%rax,8),%r14
mov    $0xffffffffffffffff,%r13
mov    $0x0,%r12d
mov    $0x31,%ebp
add    $0x8,%rbx
mov    %rsp,%rdi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
lea    0x2(%rcx,%rbp,1),%rdx
mov    (%rbx),%rsi
mov    %rsp,%rdi
callq  27e6 <account+0x85>
cmp    %r14,%rbx
jne    27c7 <account+0x66>
jmp    2838 <account+0xd7>
mov    $0x0,%edi
callq  27f7 <account+0x96>
mov    %rax,%rbx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  280c <account+0xab>
test   %rbx,%rbx
je     284f <account+0xee>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  2836 <account+0xd5>
jmp    284f <account+0xee>
mov    %rsp,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  284a <account+0xe9>
mov    %rsp,%rbx
jmp    2811 <account+0xb0>
mov    0x38(%rsp),%rax
xor    %fs:0x28,%rax
je     2865 <account+0x104>
nop
callq  2865 <account+0x104>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
account (int argc, char **argv)
{
  char acct[50], *ap;
  if (argc > 1)
    {
      ++argv;
      --argc;
      strncpy (acct, *argv, sizeof (acct) - 1);
      acct[sizeof (acct) - 1] = '\0';
      while (argc > 1)
 {
   --argc;
   ++argv;
   strncat (acct, *argv, (sizeof (acct) - 1) - strlen (acct));
 }
      ap = acct;
    }
  else
    {
      ap = getpass ("Account:");
    }
  command ("ACCT %s", ap);
  if (ap)
    memset (ap, 0, strlen (ap));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 4
13 4
14 6
15 8
16 8
17 8
18 8
19 9
20 7
21 10
22 10
23 10
24 10
25 14
26 14
27 14
28 13
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 10
38 10
39 10
40 20
41 20
42 20
43 22
44 22
45 22
46 22
47 23
48 23
49 24
50 24
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
59 22
60 22
61 22
62 22
63 22
64 22
65 25
66 25
67 25
68 25
69 25
70 25
71 25
72 25
73 25
74 25
75 25
76 25
<<<sep_out_sample>>>
movzbl (%rdi),%eax
sub    $0x21,%eax
cmp    $0x3c,%al
ja     231 <glob_char_p+0x25>
movzbl %al,%eax
jmpq   *0x0(,%rax,8)
mov    $0x1,%eax
retq   
cmpb   $0x28,0x1(%rdi)
sete   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
glob_char_p (s)
     const char *s;
{
  switch (*s)
    {
    case '*':
    case '[':
    case ']':
    case '?':
    case '\\':
      return 1;
    case '+':
    case '@':
    case '!':
      if (s[1] == '(')
 return 1;
      break;
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 11
8 11
9 15
10 15
11 15
12 15
13 19
14 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 4ba <gsl_matrix_complex_float_ptr+0xb>
je     507 <gsl_matrix_complex_float_ptr+0x58>
cmp    %rsi,(%rdi)
ja     4e1 <gsl_matrix_complex_float_ptr+0x32>
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4da <gsl_matrix_complex_float_ptr+0x2b>
mov    $0x0,%eax
jmp    517 <gsl_matrix_complex_float_ptr+0x68>
cmp    %rdx,0x8(%rdi)
ja     507 <gsl_matrix_complex_float_ptr+0x58>
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  500 <gsl_matrix_complex_float_ptr+0x51>
mov    $0x0,%eax
jmp    517 <gsl_matrix_complex_float_ptr+0x68>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
mov    0x18(%rdi),%rax
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_ptr(gsl_matrix_complex_float * m,
                             const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_float.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_float.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 15
23 15
24 15
25 15
26 16
27 16
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  ba4c <_x87_bunlti_f+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  aeed <_x87_movi_f>
mov    0x0(%r12),%r8d
and    $0x7fff,%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    $0x2,%esi
mov    %rbx,%rdi
callq  1b28 <_x87jcc>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  baa4 <_x87_bunlti_f+0x7c>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_bunlti_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x2, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 13a8 <afmset_debug+0x6>
retq   
<<<sep_in_sample>>>
afmset_debug (int bdebug )
{
        afm_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %edx,%r13d
mov    %ecx,%ebp
mov    %r8d,%r12d
mov    (%rdi),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rdi)
mov    %sil,(%rax)
mov    %r8d,%r9d
mov    $0x0,%r8d
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
mov    %r13b,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
and    $0x7,%r12d
or     $0xffffffc0,%r12d
and    $0x7,%ebp
shl    $0x3,%ebp
or     %ebp,%r12d
mov    %r12b,(%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_sselxr(jit_state_t *_jit, jit_int32_t p, jit_int32_t c,
 jit_int32_t r0, jit_int32_t r1)
{
    *_jit->pc.uc++ = p;
    _rex(_jit, 0, 1, r0, 0, r1);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = c;
    *_jit->pc.uc++ = (0x03<<6) | (((r0) & 7)<<3) | ((r1) & 7);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 9
36 9
37 9
38 9
39 9
<<<sep_out_sample>>>
test   %edi,%edi
jle    815 <queue_sigchld_trap+0x1e>
movl   $0x1,0x0(%rip)        # 805 <queue_sigchld_trap+0xe>
add    %edi,0x0(%rip)        # 80b <queue_sigchld_trap+0x14>
movl   $0x11,0x0(%rip)        # 815 <queue_sigchld_trap+0x1e>
repz retq 
<<<sep_in_sample>>>
queue_sigchld_trap (nchild)
     int nchild;
{
  if (nchild > 0)
    {
      catch_flag = 1;
      pending_traps[17] += nchild;
      trapped_signal_received = 17;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 7
5 8
6 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
callq  486 <java__init_buffer+0x15>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    %rbx,%rdi
callq  494 <java__init_buffer+0x23>
mov    %r13,(%rbx)
movl   $0x1,0x3c(%rbx)
mov    0x0(%rip),%rax        # 4a5 <java__init_buffer+0x34>
test   %rax,%rax
je     4b7 <java__init_buffer+0x46>
mov    0x0(%rip),%rdx        # 4b1 <java__init_buffer+0x40>
mov    (%rax,%rdx,8),%rax
jmp    4bc <java__init_buffer+0x4b>
mov    $0x0,%eax
cmp    %rbx,%rax
je     4cf <java__init_buffer+0x5e>
movl   $0x1,0x34(%rbx)
movl   $0x0,0x38(%rbx)
movl   $0x0,0x2c(%rbx)
mov    %r12d,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
java__init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 java__flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 4
12 4
13 5
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 9
26 11
27 12
28 13
29 13
30 13
31 13
32 13
33 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x28(%rsi),%rdx
mov    %edi,%esi
mov    $0x1,%edi
callq  2589 <gsl_eigen_nonsymmv_params+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_eigen_nonsymmv_params (const int balance,
                           gsl_eigen_nonsymmv_workspace *w)
{
  gsl_eigen_nonsymm_params(1, balance, w->nonsymm_workspace_p);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpl   $0x3,0x1c(%rdi)
jne    2fa <rec_write_field_name+0x40>
mov    $0x22,%esi
callq  0 <rec_writer_putc>
test   %al,%al
jne    305 <rec_write_field_name+0x4b>
jmp    314 <rec_write_field_name+0x5a>
mov    $0x22,%esi
mov    %rbx,%rdi
callq  0 <rec_writer_putc>
jmp    314 <rec_write_field_name+0x5a>
mov    $0x3a,%esi
mov    %rbx,%rdi
callq  0 <rec_writer_putc>
jmp    314 <rec_write_field_name+0x5a>
callq  46 <rec_writer_puts>
test   %al,%al
jne    2eb <rec_write_field_name+0x31>
jmp    314 <rec_write_field_name+0x5a>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  46 <rec_writer_puts>
test   %al,%al
jne    2dc <rec_write_field_name+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_write_field_name (rec_writer_t writer,
                      const char *field_name)
{
  enum rec_writer_mode_e mode = writer->mode;
  if (mode == REC_WRITER_SEXP)
    {
      if (!rec_writer_putc (writer, '"'))
        {
          return 0;
        }
    }
  if (!rec_writer_puts (writer, field_name))
    {
      return 0;
    }
  if (mode == REC_WRITER_SEXP)
    {
      if (!rec_writer_putc (writer, '"'))
        {
          return 0;
        }
    }
  else
    {
      if (!rec_writer_putc (writer, ':'))
        {
          return 0;
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 18
14 18
15 18
16 18
17 25
18 25
19 25
20 25
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 31
31 31
32 31
33 31
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    %rcx,%r12
mov    %r8,%r13
callq  2d00 <mbox_body_readline+0x1b>
mov    %rax,%rdi
callq  2d08 <mbox_body_readline+0x23>
mov    %rax,%rdi
callq  2d10 <mbox_body_readline+0x2b>
mov    0x18(%rax),%rdx
mov    %rdx,0x8(%rsp)
mov    0x10(%rax),%rdx
mov    %rdx,(%rsp)
mov    $0x1,%r9d
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  2b6c <mbox_readstream>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mbox_body_readline (mu_stream_t is, char *buffer, size_t buflen,
      mu_off_t off, size_t *pnread)
{
  mu_body_t body = mu_stream_get_owner (is);
  mu_message_t msg = mu_body_get_owner (body);
  mbox_message_t mum = mu_message_get_owner (msg);
  return mbox_readstream (mum, buffer, buflen, off, pnread, 1,
     mum->body, mum->body_end);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 5
12 5
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 9
31 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %sil,0x6c(%rdi)
mov    0x28(%rdi),%esi
callq  5b09 <panel_set_focus+0x10>
cmpb   $0x0,0x6c(%rbx)
je     5b32 <panel_set_focus+0x39>
mov    0x18(%rbx),%rdi
callq  5b18 <panel_set_focus+0x1f>
cmp    $0xffffffff,%eax
jne    5b32 <panel_set_focus+0x39>
mov    %rbx,%rdi
mov    $0x0,%eax
callq  5b2a <panel_set_focus+0x31>
mov    %rbx,%rdi
callq  5b32 <panel_set_focus+0x39>
pop    %rbx
retq   
<<<sep_in_sample>>>
panel_set_focus(this, status)
    panel_t *this;
    int status;
{
    this->focus = status;
    panel_update_entry(this, this->current_entry);
    if (this->focus)
 if (chdir(this->path) == -1)
 {
     panel_recover(this);
     panel_update(this);
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 6
6 7
7 7
8 8
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 11
17 13
18 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     11aa <fdGetRdTimeoutSecs+0x12>
cmpl   $0xbeefdead,0x8(%rdi)
je     11c3 <fdGetRdTimeoutSecs+0x2b>
mov    $0x0,%ecx
mov    $0x189,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11c3 <fdGetRdTimeoutSecs+0x2b>
mov    0xe0(%rdi),%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fdGetRdTimeoutSecs(FD_t fd) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 393, __PRETTY_FUNCTION__));
    return fd->rd_timeoutsecs;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%ebp
mov    0x0(%rip),%rdi        # 59 <variable_buffer_output+0x19>
mov    %rbx,%r12
sub    %rdi,%r12
lea    (%rdx,%r12,1),%edx
mov    0x0(%rip),%eax        # 69 <variable_buffer_output+0x29>
lea    0x5(%rdx),%ecx
cmp    %eax,%ecx
jbe    94 <variable_buffer_output+0x54>
add    $0x64,%edx
add    %eax,%eax
cmp    %eax,%edx
cmovae %edx,%eax
mov    %eax,%esi
mov    %eax,0x0(%rip)        # 82 <variable_buffer_output+0x42>
callq  87 <variable_buffer_output+0x47>
mov    %rax,0x0(%rip)        # 8e <variable_buffer_output+0x4e>
mov    %r12d,%ebx
add    %rax,%rbx
mov    %ebp,%ebp
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  a4 <variable_buffer_output+0x64>
lea    (%rbx,%rbp,1),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
variable_buffer_output (char *ptr, const char *string, unsigned int length)
{
  register unsigned int newlen = length + (ptr - variable_buffer);
  if ((newlen + 5) > variable_buffer_length)
    {
      unsigned int offset = ptr - variable_buffer;
      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
                                ? newlen + 100
                                : 2 * variable_buffer_length);
      variable_buffer = xrealloc (variable_buffer, variable_buffer_length);
      ptr = variable_buffer + offset;
    }
  memcpy (ptr, string, length);
  return ptr + length;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 8
18 9
19 9
20 9
21 9
22 7
23 10
24 10
25 10
26 11
27 13
28 13
29 13
30 13
31 13
32 14
33 15
34 15
35 15
36 15
37 15
38 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    %rsp,%rsi
callq  1ab <cdio_is_device_generic+0x13>
test   %eax,%eax
je     1d7 <cdio_is_device_generic+0x3f>
callq  1b4 <cdio_is_device_generic+0x1c>
mov    (%rax),%edi
callq  1bb <cdio_is_device_generic+0x23>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1d0 <cdio_is_device_generic+0x38>
mov    $0x0,%eax
jmp    1e8 <cdio_is_device_generic+0x50>
mov    0x18(%rsp),%eax
and    $0xb000,%eax
cmp    $0x2000,%eax
sete   %al
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
cdio_is_device_generic(const char *source_name)
{
  struct stat buf;
  if (0 != stat(source_name, &buf)) {
    cdio_warn ("Can't get file status for %s:\n%s", source_name,
                strerror((*__errno_location ())));
    return 0;
  }
  return (((((buf.st_mode)) & 0170000) == (0060000)) || ((((buf.st_mode)) & 0170000) == (0020000)));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 6
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 9
19 9
20 9
21 9
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    b36 <gsl_permute_matrix+0x29>
mov    $0x0,%ebx
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     b7e <gsl_permute_matrix+0x71>
jmp    b56 <gsl_permute_matrix+0x49>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b4f <gsl_permute_matrix+0x42>
mov    $0x13,%eax
jmp    b7e <gsl_permute_matrix+0x71>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  b64 <gsl_permute_matrix+0x57>
mov    %rsp,%rsi
mov    %r12,%rdi
callq  b6f <gsl_permute_matrix+0x62>
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     b56 <gsl_permute_matrix+0x49>
mov    $0x0,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_permute_matrix (const gsl_permutation * p, gsl_matrix * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_view r = gsl_matrix_row (A, i);
          gsl_permute_vector (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 10
11 15
12 10
13 10
14 10
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 10
30 10
31 10
32 15
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x268(%rdi),%rdi
mov    $0x0,%esi
callq  3e4 <write_idhead+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
write_idhead (struct idhead *idhp)
{
  return io_idhead (idhp->idh_FILE, io_write, idhp);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gsl_utils_placeholder (void)
{
  int i = 0;
  i++ ;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    (%rdi),%rax
lea    0x1(%rax),%rsi
mov    %rsi,(%rdi)
movzbl 0x1(%rax),%eax
cmp    $0x30,%al
jne    3c <cp_subst+0x3c>
mov    %r9,%rbx
mov    %r9,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
jmp    5b <cp_subst+0x5b>
movsbl %al,%esi
sub    $0x31,%esi
movslq %esi,%rsi
mov    (%rdx,%rsi,4),%eax
test   %eax,%eax
je     d1 <cp_subst+0xd1>
mov    (%rcx,%rsi,8),%rbx
mov    (%r8,%rsi,8),%r12
sub    %rbx,%r12
cmp    $0x2,%r12
jbe    9f <cp_subst+0x9f>
mov    0x0(%rbp),%r13
mov    0x30(%rsp),%rax
sub    (%rax),%r13
mov    0x38(%rsp),%rax
mov    (%rax),%eax
lea    -0x2(%rax,%r12,1),%esi
mov    0x38(%rsp),%rax
mov    %esi,(%rax)
movslq %esi,%rsi
mov    0x30(%rsp),%rax
mov    (%rax),%rdi
callq  90 <cp_subst+0x90>
mov    0x30(%rsp),%rdi
mov    %rax,(%rdi)
add    %r13,%rax
mov    %rax,0x0(%rbp)
test   %r12,%r12
je     c5 <cp_subst+0xc5>
lea    (%rbx,%r12,1),%rcx
mov    0x0(%rbp),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rbp)
add    $0x1,%rbx
movzbl -0x1(%rbx),%edx
mov    %dl,(%rax)
cmp    %rcx,%rbx
jne    a8 <cp_subst+0xa8>
jmp    cc <cp_subst+0xcc>
mov    $0x1,%eax
jmp    d1 <cp_subst+0xd1>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cp_subst (char **from_p, char **to_p, int *toks, char **tp, char **te, char *tok0, char **buf_p, int *buf_len_p)
{
  int toknum;
  char *src;
  size_t src_len;
  if (*++(*from_p) == '0')
    {
      src = tok0;
      src_len = strlen (tok0);
    }
  else if (toks[toknum = **from_p - '1'])
    {
      src = tp[toknum];
      src_len = te[toknum] - src;
    }
  else
    return 0;
  if (src_len > strlen ("$2"))
    {
      size_t offset = *to_p - *buf_p;
      *buf_len_p += src_len - strlen ("$2");
      *buf_p = realloc (*buf_p, *buf_len_p);
      *to_p = *buf_p + offset;
    }
  while (src_len--)
    *(*to_p)++ = *src++;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 13
28 14
29 14
30 18
31 18
32 20
33 20
34 20
35 21
36 21
37 21
38 21
39 21
40 22
41 22
42 22
43 22
44 22
45 22
46 23
47 23
48 25
49 25
50 25
51 26
52 26
53 26
54 26
55 26
56 26
57 25
58 25
59 25
60 27
61 27
62 27
63 28
64 28
65 28
66 28
67 28
68 28
<<<sep_out_sample>>>
mov    $0x0,%eax
cmpq   $0x0,0x0(%rip)        # 665 <next_decompress_program+0xd>
jne    684 <next_decompress_program+0x2c>
mov    %rdi,%rsi
mov    0x0(%rip),%edi        # 670 <next_decompress_program+0x18>
callq  48 <find_zip_program>
test   %rax,%rax
je     67f <next_decompress_program+0x27>
mov    0x8(%rax),%rax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
next_decompress_program (int *pstate)
{
  struct zip_program const *zp;
  if (use_compress_program_option)
    return ((void *)0);
  zp = find_zip_program (archive_compression_type, pstate);
  return zp ? zp->program : ((void *)0);
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 7
12 8
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0xa,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_rng_state (const gsl_rng * r)
{
  return r->state;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
movl   $0x1,0x4(%rdi)
retq   
<<<sep_in_sample>>>
hllist_disable_add(HLLIST * hllist)
{
 hllist->disable_add_ = 1;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rsp)
mov    %rdi,%rbx
ucomisd 0x68(%rdi),%xmm0
jp     128 <wrap_df+0x1e>
jne    128 <wrap_df+0x1e>
movsd  0x48(%rdi),%xmm0
jmp    17b <wrap_df+0x71>
mov    %rbx,%rdi
movsd  0x8(%rsp),%xmm0
callq  51 <moveto>
movsd  0x8(%rsp),%xmm2
ucomisd 0x78(%rbx),%xmm2
jp     145 <wrap_df+0x3b>
je     163 <wrap_df+0x59>
mov    0x20(%rbx),%rax
mov    0x58(%rbx),%rdx
mov    0x20(%rax),%rsi
mov    0x50(%rbx),%rdi
callq  *0x8(%rax)
movsd  0x8(%rsp),%xmm4
movsd  %xmm4,0x78(%rbx)
mov    %rbx,%rdi
callq  e9 <slope>
movsd  %xmm0,0x48(%rbx)
movsd  0x8(%rsp),%xmm3
movsd  %xmm3,0x68(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
wrap_df (double alpha, void *params)
{
  wrapper_t *w = (wrapper_t *) params;
  if (alpha == w->df_cache_key)
    {
      return w->df_alpha;
    }
  moveto (alpha, w);
  if (alpha != w->g_cache_key)
    {
      (*((w->fdf)->df))(w->x_alpha,(w->fdf)->params,(w->g_alpha));
      w->g_cache_key = alpha;
    }
  w->df_alpha = slope (w);
  w->df_cache_key = alpha;
  return w->df_alpha;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 11
22 12
23 12
24 14
25 14
26 14
27 15
28 15
29 17
30 17
31 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  17 <__gmp_vfprintf+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_vfprintf (FILE *fp, const char *fmt, va_list ap)
{
  return __gmp_doprnt (&__gmp_fprintf_funs, fp, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x8,%edi
callq  1d <gc_cipher_open+0x13>
test   %rax,%rax
je     31 <gc_cipher_open+0x27>
mov    %rax,%rdi
callq  2a <gc_cipher_open+0x20>
mov    $0x4,%eax
jmp    36 <gc_cipher_open+0x2c>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_cipher_open (Gc_cipher alg, Gc_cipher_mode mode,
                gc_cipher_handle * outhandle)
{
  _gc_cipher_ctx *ctx;
  Gc_rc rc = GC_OK;
  ctx = calloc (sizeof (*ctx), 1);
  if (!ctx)
    return GC_MALLOC_ERROR;
  ctx->alg = alg;
  ctx->mode = mode;
  switch (alg)
    {
    default:
      rc = GC_INVALID_CIPHER;
    }
  if (rc == GC_OK)
    *outhandle = ctx;
  else
    free (ctx);
  return rc;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 6
5 7
6 7
7 19
8 19
9 20
10 20
11 8
12 21
13 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
callq  13d5 <quotearg_char+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x40,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
mov    $0x0,%edi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbx
mov    0x0(%rip),%rdi        # 1cc1 <set_prompt+0x31>
callq  1cc6 <set_prompt+0x36>
mov    $0x33,%edx
sub    %ebx,%edx
mov    %rsp,%rsi
mov    %rax,%rdi
callq  1cd8 <set_prompt+0x48>
mov    $0x0,%esi
mov    %rax,%rdi
callq  1ce5 <set_prompt+0x55>
mov    %rax,%rdi
callq  1ced <set_prompt+0x5d>
mov    0x38(%rsp),%rax
xor    %fs:0x28,%rax
je     1d02 <set_prompt+0x72>
callq  1d02 <set_prompt+0x72>
add    $0x40,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
set_prompt()
{
    char temp[50 + 1];
    il_set_static_text(strcat(truncate_string(panel_get_path(src_panel), temp,
           50 -strlen(PS1)+1),
         PS1));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 7
24 7
25 7
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
callq  dba <info_set_input_from_file+0xb>
mov    %rax,%rbx
test   %rax,%rax
je     df6 <info_set_input_from_file+0x47>
mov    0x0(%rip),%rdi        # dc9 <info_set_input_from_file+0x1a>
test   %rdi,%rdi
je     ddc <info_set_input_from_file+0x2d>
cmp    0x0(%rip),%rdi        # dd5 <info_set_input_from_file+0x26>
je     ddc <info_set_input_from_file+0x2d>
callq  ddc <info_set_input_from_file+0x2d>
mov    %rbx,0x0(%rip)        # de3 <info_set_input_from_file+0x34>
cmp    0x0(%rip),%rbx        # dea <info_set_input_from_file+0x3b>
je     df6 <info_set_input_from_file+0x47>
movl   $0x1,0x0(%rip)        # df6 <info_set_input_from_file+0x47>
pop    %rbx
retq   
<<<sep_in_sample>>>
info_set_input_from_file (char *filename)
{
  FILE *stream;
  stream = fopen (filename, "r");
  if (!stream)
    return;
  if ((info_input_stream != ((void *)0)) &&
      (info_input_stream != stdin))
    fclose (info_input_stream);
  info_input_stream = stream;
  if (stream != stdin)
    display_inhibited = 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 10
14 11
15 11
16 12
17 13
18 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r13
test   %rdi,%rdi
jne    332 <localtime_rz+0x25>
mov    %rdx,%rsi
mov    %rbx,%rdi
callq  330 <localtime_rz+0x23>
jmp    382 <localtime_rz+0x75>
callq  1fd <set_tz>
mov    %rax,%r12
test   %rax,%rax
je     37d <localtime_rz+0x70>
mov    %r13,%rsi
mov    %rbx,%rdi
callq  34a <localtime_rz+0x3d>
mov    %rax,%rbx
test   %rax,%rax
je     368 <localtime_rz+0x5b>
mov    %rax,%rsi
mov    %rbp,%rdi
callq  b0 <save_abbr>
test   %al,%al
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %r12,%rdi
callq  2a5 <revert_tz>
test   %al,%al
mov    $0x0,%eax
cmovne %rbx,%rax
jmp    382 <localtime_rz+0x75>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
{
  if (!tz)
    return gmtime_r (t, tm);
  else
    {
      timezone_t old_tz = set_tz (tz);
      if (old_tz)
        {
          tm = localtime_r (t, tm);
          if (tm && !save_abbr (tz, tm))
            tm = ((void *)0);
          if (revert_tz (old_tz))
            return tm;
        }
      return ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 7
16 7
17 8
18 8
19 10
20 10
21 10
22 10
23 11
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 13
32 13
33 13
34 16
35 16
36 16
37 16
38 18
39 18
40 18
41 18
42 18
43 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
cmp    %rdx,%rax
ja     ec4 <gsl_matrix_long_double_subdiagonal+0x4d>
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e9c <gsl_matrix_long_double_subdiagonal+0x25>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    f03 <gsl_matrix_long_double_subdiagonal+0x8c>
mov    0x10(%rsi),%rcx
mov    %rcx,%r8
shl    $0x4,%r8
imul   %rdx,%r8
add    0x18(%rsi),%r8
mov    0x20(%rsi),%rdi
sub    %rdx,%rax
mov    0x8(%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
add    $0x1,%rcx
mov    %rcx,0x8(%rbx)
mov    %r8,0x10(%rbx)
mov    %rdi,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_subdiagonal (gsl_matrix_long_double * m,
                                    const size_t k)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 14
23 12
24 12
25 12
26 12
27 17
28 13
29 13
30 17
31 17
32 17
33 19
34 19
35 19
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # d3c <gsl_vector_short_get+0x7>
je     d67 <gsl_vector_short_get+0x32>
cmp    %rsi,(%rdi)
ja     d67 <gsl_vector_short_get+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xb4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d60 <gsl_vector_short_get+0x2b>
mov    $0x0,%eax
jmp    d7b <gsl_vector_short_get+0x46>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rax,%rsi
mov    0x10(%rdi),%rax
movzwl (%rax,%rsi,1),%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_short_get (const gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 180, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return v->data[i * v->stride];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0x6666666666666667,%rsi
test   %rdi,%rdi
jns    57 <imaxtostr+0x57>
mov    %rsi,%r8
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %rdi,%rax
imul   %r8
sar    $0x2,%rdx
mov    %rdi,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %rdx,%rdi
test   %rdx,%rdx
jne    1f <imaxtostr+0x1f>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    87 <imaxtostr+0x87>
sub    $0x1,%rcx
mov    %rdi,%rax
imul   %rsi
sar    $0x2,%rdx
mov    %rdi,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %rdx,%rdi
test   %rdx,%rdx
jne    57 <imaxtostr+0x57>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
imaxtostr (intmax_t i, char *buf)
{
  char *p = buf + ((sizeof (intmax_t) * 8 - (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1)) + 1);
  *p = 0;
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: ((! ((intmax_t) 0 < (intmax_t) -1)) == 1) ? 1 : -1; }))];
  if (i < 0)
    {
      do
 *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 16
4 6
5 6
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 9
23 11
24 11
25 11
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 17
39 17
40 17
41 20
42 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    $0x14,%edi
callq  b5 <gsasl_sha1+0x17>
mov    %rax,%rdx
mov    %rax,(%rbx)
mov    $0x7,%eax
test   %rdx,%rdx
je     d0 <gsasl_sha1+0x32>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  d0 <gsasl_sha1+0x32>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsasl_sha1 (const char *in, size_t inlen, char *out[20])
{
  *out = malloc (20);
  if (!*out)
    return GSASL_MALLOC_ERROR;
  return gc_sha1 (in, inlen, *out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 4
13 4
14 6
15 6
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2cd <hash_delete+0x9>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  2d8 <hash_delete+0x14>
pop    %rbx
retq   
<<<sep_in_sample>>>
hash_delete (struct hash_table_s* ht, void const *item)
{
  void **slot = hash_find_slot (ht, item);
  return hash_delete_at (ht, slot);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r12d
mov    %rsi,%r13
test   %edi,%edi
jne    30d <dap_putint+0x2a>
mov    $0x30,%edi
callq  301 <dap_putint+0x1e>
mov    $0x1,%ebp
mov    $0x0,%ebx
jmp    33e <dap_putint+0x5b>
mov    $0x1,%ebp
test   %edi,%edi
jns    320 <dap_putint+0x3d>
neg    %r12d
je     334 <dap_putint+0x51>
mov    $0xffffffff,%ebp
mov    %r12d,%eax
mov    $0x0,%ebx
sar    $0x6,%eax
add    $0x1,%ebx
test   %eax,%eax
jne    328 <dap_putint+0x45>
jmp    33e <dap_putint+0x5b>
mov    $0xffffffff,%ebp
mov    $0x0,%ebx
mov    %ebp,%edi
imul   %ebx,%edi
add    $0x30,%edi
mov    %r13,%rsi
callq  34e <dap_putint+0x6b>
test   %ebp,%ebp
jg     359 <dap_putint+0x76>
sub    $0x1,%ebx
jns    389 <dap_putint+0xa6>
jmp    3b0 <dap_putint+0xcd>
sub    $0x1,%ebx
nopl   0x0(%rax)
js     3b0 <dap_putint+0xcd>
lea    (%rbx,%rbx,2),%ebp
add    %ebp,%ebp
mov    %r12d,%edi
mov    %ebp,%ecx
sar    %cl,%edi
and    $0x3f,%edi
add    $0x21,%edi
mov    %r13,%rsi
callq  37c <dap_putint+0x99>
sub    $0x1,%ebx
sub    $0x6,%ebp
cmp    $0xffffffff,%ebx
jne    367 <dap_putint+0x84>
jmp    3b0 <dap_putint+0xcd>
lea    (%rbx,%rbx,2),%ebp
add    %ebp,%ebp
mov    %r12d,%edi
mov    %ebp,%ecx
sar    %cl,%edi
neg    %edi
and    $0x3f,%edi
add    $0x21,%edi
mov    %r13,%rsi
callq  3a5 <dap_putint+0xc2>
sub    $0x1,%ebx
sub    $0x6,%ebp
cmp    $0xffffffff,%ebx
jne    38e <dap_putint+0xab>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dap_putint(int i, DFILE *dfp)
{
int j;
int ndig;
int sign;
if (!i)
 dap_putc('0', dfp);
sign = 1;
if (i < 0)
 {
 sign = -1;
 i = -i;
 }
for (ndig = 0, j = i; j; ndig++)
 j = (j >> 6);
dap_putc('0' + sign * ndig, dfp);
if (sign > 0)
 {
 while (--ndig >= 0)
  dap_putc(((i >> (6 * ndig)) & 0x3f) + '!', dfp);
 }
else
 {
 while (--ndig >= 0)
  dap_putc(((0x40 - (i >> (6 * ndig))) & 0x3f) + '!', dfp);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 7
11 7
12 8
13 14
14 14
15 8
16 9
17 9
18 14
19 14
20 11
21 8
22 14
23 15
24 14
25 14
26 14
27 14
28 11
29 14
30 16
31 16
32 16
33 16
34 16
35 17
36 17
37 24
38 24
39 24
40 19
41 19
42 19
43 19
44 19
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 25
60 25
61 25
62 25
63 25
64 25
65 25
66 25
67 24
68 24
69 24
70 24
71 27
72 27
73 27
74 27
75 27
76 27
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  edb <gsl_stats_long_sd+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  ee9 <gsl_stats_long_sd+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_long_sd (const long data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_mean (data, stride, n);
  return gsl_stats_long_sd_m (data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r14
cmpb   $0x0,0x50(%rdi)
jne    21 <__robreakoutimage+0x21>
mov    $0x0,%edi
callq  21 <__robreakoutimage+0x21>
cmpq   $0x0,0x58(%r14)
jne    32 <__robreakoutimage+0x32>
mov    $0x0,%edi
callq  32 <__robreakoutimage+0x32>
mov    0x58(%r14),%rax
add    $0x18,%rax
mov    %rax,0x8(%rsp)
mov    0x48(%r14),%rbp
movzwl 0x62(%r14),%r13d
sub    $0x1,%r13d
movzwl 0x64(%r14),%r15d
sub    $0x1,%r15d
test   %r13d,%r13d
jle    83 <__robreakoutimage+0x83>
movslq %r13d,%r13
add    $0x1,%r13
mov    $0x1,%ebx
movslq %r15d,%r12
add    %rax,%r12
movsbl -0x1(%r12,%rbx,1),%edi
mov    %rbp,%rsi
callq  7a <__robreakoutimage+0x7a>
add    $0x1,%rbx
cmp    %r13,%rbx
jne    6c <__robreakoutimage+0x6c>
mov    %rbp,%rdi
callq  8b <__robreakoutimage+0x8b>
movzwl 0x60(%r14),%edx
test   %rdx,%rdx
jle    b0 <__robreakoutimage+0xb0>
mov    $0x0,%eax
movslq %r15d,%r15
add    0x8(%rsp),%r15
movb   $0x20,(%r15,%rax,1)
add    $0x1,%rax
cmp    %rax,%rdx
jg     a2 <__robreakoutimage+0xa2>
movw   $0x1,0x62(%r14)
mov    %r14,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
__robreakoutimage (__bs2FILE *p)
{
  char *s;
  register long i,
    j,
    k;
  FILE *f;
  if (!((__bs1FILE *) p)->open)
    __rerror ("Breakoutimage: File not open");
  if (p->IMAGE.obj == 0L)
    __rerror ("Breakoutimage: IMAGE equals notext");
  s = p->IMAGE.obj->string;
  f = ((__bs1FILE *) p)->file;
  j = p->IMAGE.pos - 1;
  k = p->IMAGE.start - 1;
  for (i = 0; i < j; i++)
    (void) _IO_putc (s[k + i], f);
  (void) fflush (f);
  j = p->IMAGE.length;
  for (i = 0; i < j; i++)
    s[k + i] = ' ';
  p->IMAGE.pos = 1;
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 8
10 8
11 9
12 9
13 10
14 10
15 11
16 11
17 12
18 12
19 12
20 13
21 14
22 14
23 15
24 15
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 17
33 17
34 17
35 17
36 16
37 16
38 18
39 18
40 19
41 20
42 20
43 20
44 20
45 20
46 21
47 20
48 20
49 20
50 22
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
59 24
<<<sep_out_sample>>>
movl   $0x0,0xc(%rdi)
retq   
<<<sep_in_sample>>>
varray_reset(VARRAY *vb)
{
 vb->length = 0;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x60(%rdi)
lea    0x0(,%rsi,8),%rdx
mov    0x70(%rdi),%rdi
mov    $0x0,%esi
callq  ee <bsimp_reset+0x22>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
bsimp_reset (void *vstate, size_t dim)
{
  bsimp_state_t *state = (bsimp_state_t *) vstate;
  state->h_next = 0;
  memset((state->yp),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
test   %edx,%edx
jle    3a <cblas_dasum+0x3a>
test   %edi,%edi
jle    3f <cblas_dasum+0x3f>
mov    $0x0,%ecx
mov    $0x0,%eax
xorpd  %xmm0,%xmm0
movsd  0x0(%rip),%xmm2        # 1e <cblas_dasum+0x1e>
movslq %ecx,%r8
movsd  (%rsi,%r8,8),%xmm1
andpd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
add    %edx,%ecx
add    $0x1,%eax
cmp    %edi,%eax
jne    1e <cblas_dasum+0x1e>
repz retq 
xorpd  %xmm0,%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
cblas_dasum (const int N, const double *X, const int incX)
{
{
  double r = 0.0;
  int i;
  int ix = 0;
  if (incX <= 0) {
    return 0;
  }
  for (i = 0; i < N; i++) {
    r += fabs(X[ix]);
    ix += incX;
  }
  return r;
}
}
<<<sep_in_sample>>>
1 7
2 7
3 10
4 10
5 10
6 10
7 10
8 11
9 11
10 11
11 11
12 11
13 12
14 10
15 10
16 10
17 10
18 8
19 8
20 10
21 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rax
test   %rax,%rax
je     d9 <nettle_buffer_clear+0x1b>
mov    0x10(%rdi),%rdi
mov    $0x0,%edx
mov    (%rbx),%rsi
callq  *%rax
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x20(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_buffer_clear(struct nettle_buffer *buffer)
{
  if (buffer->realloc)
    buffer->realloc(buffer->realloc_ctx, buffer->contents, 0);
  buffer->contents = ((void *)0);
  buffer->alloc = 0;
  buffer->size = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 8
14 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # addc <wf_hdy+0xf>
cmpl   $0x0,0x0(%rip)        # ade3 <wf_hdy+0x16>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # adef <wf_hdy+0x22>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  adfb <wf_hdy+0x2e>
cmpl   $0x0,0x0(%rip)        # ae02 <wf_hdy+0x35>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # ae0e <wf_hdy+0x41>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
wf_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "WF";
  use_other_cc = !use_other_cc;
  fr_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 10
3 11
4 11
5 11
6 11
7 12
8 12
9 12
10 13
11 13
12 13
13 13
14 14
15 14
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x50(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    0x0(%rip),%rax        # 5df <group_map_translate+0x13>
test   %rax,%rax
je     60f <group_map_translate+0x43>
mov    %edi,%ecx
mov    %rcx,(%rsp)
mov    %rsp,%rsi
mov    %rax,%rdi
callq  5f5 <group_map_translate+0x29>
test   %rax,%rax
je     60f <group_map_translate+0x43>
mov    0x8(%rax),%rdx
mov    %edx,0x0(%rbp)
mov    0x10(%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%eax
jmp    638 <group_map_translate+0x6c>
mov    0x0(%rip),%edx        # 615 <group_map_translate+0x49>
mov    $0x1,%eax
cmp    $0xffffffff,%edx
je     624 <group_map_translate+0x58>
mov    %edx,0x0(%rbp)
mov    $0x0,%al
mov    0x0(%rip),%rdx        # 62b <group_map_translate+0x5f>
test   %rdx,%rdx
je     638 <group_map_translate+0x6c>
mov    %rdx,(%rbx)
mov    $0x0,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
group_map_translate (gid_t gid, gid_t *new_gid, char const **new_name)
{
  int rc = 1;
  if (group_map)
    {
      struct mapentry ent, *res;
      ent.orig_id = gid;
      res = hash_lookup (group_map, &ent);
      if (res)
 {
   *new_gid = res->new_id;
   *new_name = res->new_name;
   return 0;
 }
    }
  if (group_option != (uid_t) -1)
    {
      *new_gid = group_option;
      rc = 0;
    }
  if (group_name_option)
    {
      *new_name = group_name_option;
      rc = 0;
    }
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 7
10 7
11 8
12 8
13 8
14 9
15 9
16 11
17 11
18 12
19 12
20 13
21 13
22 16
23 3
24 16
25 16
26 18
27 19
28 21
29 21
30 21
31 23
32 24
33 27
34 27
35 27
36 27
<<<sep_out_sample>>>
mov    0x88(%rdi),%rdx
mov    $0x0,%eax
cmp    %rsi,%rdx
jl     485 <window_log_to_phys_line+0x38>
mov    %rsi,%rax
mov    %rdx,%rcx
cmp    %rdx,%rsi
jae    485 <window_log_to_phys_line+0x38>
mov    0x80(%rdi),%rdx
cmp    (%rdx,%rsi,8),%rsi
jle    485 <window_log_to_phys_line+0x38>
add    $0x1,%rax
cmp    %rcx,%rax
jae    485 <window_log_to_phys_line+0x38>
cmp    (%rdx,%rax,8),%rsi
jg     476 <window_log_to_phys_line+0x29>
repz retq 
<<<sep_in_sample>>>
window_log_to_phys_line (WINDOW *window, long ln)
{
  size_t i;
  if (ln > window->line_count)
    return 0;
  for (i = ln; i < window->line_count && window->log_line_no[i] < ln; i++)
    ;
  return i;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffff,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 4df <askforchar+0x15>
callq  4e4 <askforchar+0x1a>
callq  4e9 <askforchar+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
askforchar(void)
{
    waddnstr(stdscr,("Type any character to continue: "),-1);
    mygetch();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 5
8 5
<<<sep_out_sample>>>
cmp    $0x56,%edi
jne    15e <argp_version_parser+0x77>
push   %rbx
mov    %rdx,%rbx
mov    0x0(%rip),%rax        # f7 <argp_version_parser+0x10>
test   %rax,%rax
je     107 <argp_version_parser+0x20>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
jmp    14e <argp_version_parser+0x67>
mov    0x0(%rip),%rdx        # 10e <argp_version_parser+0x27>
test   %rdx,%rdx
je     128 <argp_version_parser+0x41>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  126 <argp_version_parser+0x3f>
jmp    14e <argp_version_parser+0x67>
mov    (%rbx),%rax
mov    0x30(%rax),%rdi
mov    $0x0,%esi
callq  139 <argp_version_parser+0x52>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  14e <argp_version_parser+0x67>
testb  $0x20,0x1c(%rbx)
jne    164 <argp_version_parser+0x7d>
mov    $0x0,%edi
callq  15e <argp_version_parser+0x77>
mov    $0x7,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 14
30 14
31 15
32 15
33 18
34 21
35 20
36 21
37 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     19 <grecs_txtacc_entry_free+0x19>
mov    (%rdi),%rdi
callq  11 <grecs_txtacc_entry_free+0x11>
mov    %rbx,%rdi
callq  19 <grecs_txtacc_entry_free+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_txtacc_entry_free(void *p)
{
 if (p) {
  struct grecs_txtacc_entry *ent = p;
  free(ent->buf);
  free(ent);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 8
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r9d
callq  1653 <hybrid_set_impl>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
hybrid_set (void *vstate, gsl_multiroot_function * func, gsl_vector * x,
            gsl_vector * f, gsl_vector * dx)
{
  int status = hybrid_set_impl (vstate, func, x, f, dx, 0);
  return status;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
cmp    $0x56,%edi
jne    15e <argp_version_parser+0x77>
push   %rbx
mov    %rdx,%rbx
mov    0x0(%rip),%rax        # f7 <argp_version_parser+0x10>
test   %rax,%rax
je     107 <argp_version_parser+0x20>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
jmp    14e <argp_version_parser+0x67>
mov    0x0(%rip),%rdx        # 10e <argp_version_parser+0x27>
test   %rdx,%rdx
je     128 <argp_version_parser+0x41>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  126 <argp_version_parser+0x3f>
jmp    14e <argp_version_parser+0x67>
mov    (%rbx),%rax
mov    0x30(%rax),%rdi
mov    $0x0,%esi
callq  139 <argp_version_parser+0x52>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  14e <argp_version_parser+0x67>
testb  $0x20,0x1c(%rbx)
jne    164 <argp_version_parser+0x7d>
mov    $0x0,%edi
callq  15e <argp_version_parser+0x77>
mov    $0x7,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 14
30 14
31 15
32 15
33 18
34 21
35 20
36 21
37 21
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x10,%edi
callq  2e <list_prepend+0x16>
mov    %rbp,0x8(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,(%rbx)
cmpq   $0x0,0x8(%rbx)
jne    46 <list_prepend+0x2e>
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
list_prepend (list, data)
     List *list;
     void *data;
{
  ListItem *item;
  item = (ListItem *) xmalloc (sizeof (*item));
  item->data = data;
  item->next = list->head;
  list->head = item;
  if (list->tail == ((void *)0))
    list->tail = item;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 7
9 8
10 8
11 9
12 10
13 10
14 11
15 12
16 12
17 12
18 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdx,%rdx
jne    380 <gsl_vector_long_double_view_array+0x47>
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  358 <gsl_vector_long_double_view_array+0x1f>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    39e <gsl_vector_long_double_view_array+0x65>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_long_double_view_array ( long double * base, size_t n)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = (long double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 10
11 10
12 10
13 10
14 10
15 10
16 21
17 21
18 21
19 21
20 21
21 23
22 23
23 23
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer_flag+0x32>
callq  16 <fd_safer_flag+0x16>
mov    %eax,%r12d
callq  1e <fd_safer_flag+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer_flag+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer_flag (int fd, int flag)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer_flag (fd, flag);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
movslq 0x868(%rdi),%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
mov    0x0(%rax),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
je     1f8 <ceaseFireWeapon+0x31>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
ceaseFireWeapon(craft * c)
{
 if (wtbl[c->curWeapon].fireRelease != ((void *)0))
  return (*wtbl[c->curWeapon].fireRelease) (c);
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 3
8 3
9 2
10 4
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rsi        # 26b <togglehelp+0x8>
test   %rsi,%rsi
je     2aa <togglehelp+0x47>
mov    $0x0,%ebx
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     29e <togglehelp+0x3b>
cmpb   $0x0,(%rdx)
je     294 <togglehelp+0x31>
mov    $0x0,%edi
mov    $0x0,%eax
callq  292 <togglehelp+0x2f>
jmp    29e <togglehelp+0x3b>
mov    $0xa,%edi
callq  29e <togglehelp+0x3b>
add    $0x28,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    275 <togglehelp+0x12>
mov    $0xa,%edi
callq  2b4 <togglehelp+0x51>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  2cd <togglehelp+0x6a>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
togglehelp (void)
{
  struct togglelist *c;
  for (c = Togglelist; c->name; c++)
    {
      if (c->help)
 {
   if (*c->help)
     printf ("%-15s toggle %s\n", c->name, c->help);
   else
     printf ("\n");
 }
    }
  printf ("\n");
  printf ("%-15s %s\n", "?", "display help information");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 8
10 8
11 9
12 9
13 9
14 9
15 11
16 11
17 4
18 4
19 4
20 4
21 14
22 14
23 15
24 15
25 15
26 15
27 15
28 17
29 17
30 17
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x28(%rdi)
movq   $0x0,0x30(%rdi)
movq   $0x0,0x38(%rdi)
retq   
<<<sep_in_sample>>>
debpsf_deb_attributes_init(DEB_ATTRIBUTES * da)
{
 da->Package = ((void *)0);
 da->Version = ((void *)0);
 da->Version_epoch = ((void *)0);
 da->Version_revision = ((void *)0);
 da->Version_release = ((void *)0);
 da->Architecture = ((void *)0);
 da->Maintainer = ((void *)0);
 da->Description = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 7
6 8
7 9
8 10
9 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 10c8 <afm_error+0x13>
mov    $0x0,%eax
callq  10d2 <afm_error+0x1d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
afm_error (AFMHandle handle, char *message)
{
  fprintf (stderr, "AFM Error: %s\n", message);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%edi
mov    $0xc,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %cl
sub    %ecx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    ed4 <anubis_set_mode+0x2c>
movl   $0x0,0x0(%rip)        # ed3 <anubis_set_mode+0x2b>
retq   
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %cl
sub    %ecx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    efd <anubis_set_mode+0x55>
movl   $0x3,0x0(%rip)        # efc <anubis_set_mode+0x54>
retq   
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    f26 <anubis_set_mode+0x7e>
movl   $0x2,0x0(%rip)        # f25 <anubis_set_mode+0x7d>
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
anubis_set_mode (char *modename)
{
  if (strcmp (modename, "transparent") == 0)
    anubis_mode = anubis_transparent;
  else if (strcmp (modename, "proxy") == 0)
    anubis_mode = anubis_proxy;
  else if (strcmp (modename, "mda") == 0)
    anubis_mode = anubis_mda;
  else
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 8
37 8
38 10
39 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%r8
mov    %rcx,%r9
mov    $0x0,%ecx
mov    $0x0,%edx
callq  b1 <verror+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
verror (int status, int errnum, const char *format, va_list args)
{
  verror_at_line (status, errnum, ((void *)0), 0, format, args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  b <copy_string_unquote+0xb>
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbp
movzbl (%rbx),%eax
cmp    $0x27,%al
je     31 <copy_string_unquote+0x31>
cmp    $0x22,%al
jne    4c <copy_string_unquote+0x4c>
cmp    -0x1(%rbx,%rbp,1),%al
jne    4c <copy_string_unquote+0x4c>
lea    -0x2(%rbp),%rdx
lea    0x1(%rbx),%rsi
mov    %rbx,%rdi
callq  47 <copy_string_unquote+0x47>
movb   $0x0,-0x2(%rbx,%rbp,1)
mov    %rbx,%rdi
callq  54 <copy_string_unquote+0x54>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
copy_string_unquote (const char *str)
{
  char *output = xstrdup (str);
  size_t len = strlen (output);
  if ((*output == '"' || *output == '\'')
      && output[len-1] == *output)
    {
      memmove (output, output+1, len-2);
      output[len-2] = 0;
    }
  unquote_string (output);
  return output;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 8
20 8
21 8
22 8
23 9
24 11
25 11
26 13
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     770 <gsl_vector_complex_free+0x20>
cmpl   $0x0,0x20(%rdi)
je     768 <gsl_vector_complex_free+0x18>
mov    0x18(%rdi),%rdi
callq  768 <gsl_vector_complex_free+0x18>
mov    %rbx,%rdi
callq  770 <gsl_vector_complex_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_complex_free (gsl_vector_complex * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_complex_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,0xc(%rsp)
lea    0xc(%rsp),%rdx
mov    $0x5421,%esi
mov    $0x0,%eax
callq  8e6 <NetNonblockingIO+0x1c>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
NetNonblockingIO (int fd, int onoff)
{
  rpl_ioctl (fd, 0x5421, (char *) &onoff);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  99 <recurse_1>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rsi,%rsi
je     5cc <mu_cpystr+0x28>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbx
jmp    5d1 <mu_cpystr+0x2d>
mov    $0x0,%ebx
test   %rbp,%rbp
je     5f6 <mu_cpystr+0x52>
test   %rdx,%rdx
je     5f6 <mu_cpystr+0x52>
lea    -0x1(%rdx),%rax
cmp    %rdx,%rbx
cmovae %rax,%rbx
mov    %rbx,%rdx
mov    %rbp,%rdi
callq  5f1 <mu_cpystr+0x4d>
movb   $0x0,0x0(%rbp,%rbx,1)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_cpystr (char *dst, const char *src, size_t size)
{
  size_t len = src ? strlen (src) : 0 ;
  if (dst == ((void *)0) || size == 0)
    return len;
  if (len >= size)
    len = size - 1;
  memcpy (dst, src, len);
  dst[len] = '\0';
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 7
20 7
21 7
22 8
23 8
24 8
25 9
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x50(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x70,%rsi
add    $0x70,%rdi
callq  11 <namecmp+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
namecmp (const FTSENT *a, const FTSENT *b)
{
  return (strcmp (a->fts_name, b->fts_name));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  13fb <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmp    $0xffff4f0b,%edi
je     f <cdio_lba_to_lsn+0xf>
lea    -0x96(%rdi),%eax
retq   
mov    $0xffff4f0b,%eax
retq   
<<<sep_in_sample>>>
cdio_lba_to_lsn (lba_t lba)
{
  if (-45301 == lba) return -45301;
  return lba - 150;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 3
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1b0(%rdi),%rdx
lea    0xd8(%rdi),%rsi
mov    0x0(%rip),%rcx        # 1f <nettle_hmac_sha512_set_key+0x1f>
callq  24 <nettle_hmac_sha512_set_key+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_hmac_sha512_set_key(struct hmac_sha512_ctx *ctx,
      size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_sha512), (key_length), (key) );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_short_data (const gsl_block_short * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x0,%eax
callq  0 <alloc_section_tab>
lea    0x8(%rsp),%rdx
mov    %rbp,%rsi
mov    0x0(%rip),%rdi        # 1d2 <mu_create_canned_param+0x27>
callq  1d7 <mu_create_canned_param+0x2c>
mov    %eax,%ebx
test   %eax,%eax
jne    202 <mu_create_canned_param+0x57>
mov    $0x1,%esi
mov    0x8(%rsp),%rdi
callq  1ec <mu_create_canned_param+0x41>
mov    0x8(%rsp),%rax
mov    (%rax),%rax
lea    0x10(%rax),%rdx
mov    %rdx,(%r12)
mov    %rbp,0x10(%rax)
jmp    219 <mu_create_canned_param+0x6e>
cmp    $0x1029,%eax
jne    219 <mu_create_canned_param+0x6e>
mov    0x8(%rsp),%rax
mov    (%rax),%rax
add    $0x10,%rax
mov    %rax,(%r12)
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_create_canned_param (char *name, struct mu_cfg_param **pparam)
{
  int rc;
  struct mu_cfg_cont **pcont;
  alloc_section_tab ();
  rc = mu_assoc_ref_install (section_tab, name, (void **)&pcont);
  if (rc == 0)
    {
      mu_config_create_container (pcont, mu_cfg_cont_param);
      *pparam = &(*pcont)->v.param;
      (*pparam)->ident = name;
    }
  else if (rc == (0x1000 +41))
    *pparam = &(*pcont)->v.param;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 11
24 11
25 13
26 13
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
35 16
36 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  153f <quotearg_custom+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom (char const *left_quote, char const *right_quote,
                 char const *arg)
{
  return quotearg_n_custom (0, left_quote, right_quote, arg);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %rsi,%rbx
mov    0x0(%rip),%rdi        # 12 <rmt_error_message+0x12>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x9,0x0(%rip)        # 1e <rmt_error_message+0x1e>
jle    ac <rmt_error_message+0xac>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  35 <rmt_error_message+0x35>
mov    0x0(%rip),%rdi        # 3c <rmt_error_message+0x3c>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x9,0x0(%rip)        # 48 <rmt_error_message+0x48>
jle    ac <rmt_error_message+0xac>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  5c <rmt_error_message+0x5c>
mov    0x0(%rip),%rdi        # 63 <rmt_error_message+0x63>
test   %rdi,%rdi
je     83 <rmt_error_message+0x83>
cmpl   $0x0,0x0(%rip)        # 6f <rmt_error_message+0x6f>
jle    83 <rmt_error_message+0x83>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  83 <rmt_error_message+0x83>
mov    %rbx,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 94 <rmt_error_message+0x94>
mov    $0x0,%eax
callq  9e <rmt_error_message+0x9e>
mov    0x0(%rip),%rdi        # a5 <rmt_error_message+0xa5>
callq  aa <rmt_error_message+0xaa>
jmp    b5 <rmt_error_message+0xb5>
mov    0x0(%rip),%rdi        # b3 <rmt_error_message+0xb3>
jmp    68 <rmt_error_message+0x68>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rmt_error_message (int code, const char *msg)
{
  do { if (dbgout && (10) <= dbglev) fprintf (dbgout, "S: E%d\n", code); } while (0);
  do { if (dbgout && (10) <= dbglev) fprintf (dbgout, "S: %s\n", msg); } while (0);
  do { if (dbgout && (1) <= dbglev) fprintf (dbgout, "error: %s\n", msg); } while (0);
  fprintf (stdout, "E%d\n%s\n", code, msg);
  fflush_unlocked (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 6
34 6
35 6
36 6
37 6
38 6
39 7
40 7
41 7
42 5
43 5
44 8
45 8
46 8
47 8
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdx
mov    0x8(%rsi),%rdi
lea    (%rdi,%rdi,1),%rcx
mov    (%rsi),%rsi
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_const_real (const gsl_vector_complex_long_double * v)
{
  gsl_vector_long_double s = {0, 0, 0, 0, 0};
  s.data = v->data;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 14
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
cmp    $0x1ffff,%rax
ja     7a6 <bc_use_sensible_arg_max+0x11>
mov    %rax,0x18(%rdi)
retq   
mov    0x10(%rdi),%rax
cmp    $0x20001,%rax
mov    $0x20000,%edx
cmovb  %rdx,%rax
mov    %rax,0x18(%rdi)
retq   
<<<sep_in_sample>>>
bc_use_sensible_arg_max (struct buildcmd_control *ctl)
{
  enum { arg_size = (128u * 1024u) };
  if (arg_size > ctl->posix_arg_size_max)
    ctl->arg_max = ctl->posix_arg_size_max;
  else if (arg_size < ctl->posix_arg_size_min)
    ctl->arg_max = ctl->posix_arg_size_min;
  else
    ctl->arg_max = arg_size;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 7
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2772 <php_realloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
php_realloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  182 <scram_print_server_first+0x11>
mov    $0xffffffff,%edx
test   %al,%al
je     1c0 <scram_print_server_first+0x4f>
mov    0x8(%rbx),%rcx
mov    0x10(%rbx),%r8
mov    (%rbx),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  1a8 <scram_print_server_first+0x37>
test   %eax,%eax
jle    1bb <scram_print_server_first+0x4a>
cmpq   $0x0,0x0(%rbp)
sete   %dl
movzbl %dl,%edx
neg    %edx
jmp    1c0 <scram_print_server_first+0x4f>
mov    $0xffffffff,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
scram_print_server_first (struct scram_server_first *sf, char **out)
{
  int n;
  if (!scram_valid_server_first (sf))
    return -1;
  n = asprintf (out, "r=%s,s=%s,i=%lu",
  sf->nonce, sf->salt, (unsigned long) sf->iter);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # f <close_stdout_status+0xf>
callq  14 <close_stdout_status+0x14>
test   %eax,%eax
je     36 <close_stdout_status+0x36>
mov    $0x0,%edi
callq  22 <close_stdout_status+0x22>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %ebx,%edi
mov    $0x0,%eax
callq  36 <close_stdout_status+0x36>
mov    0x0(%rip),%rdi        # 3d <close_stdout_status+0x3d>
callq  42 <close_stdout_status+0x42>
test   %eax,%eax
je     69 <close_stdout_status+0x69>
mov    $0x0,%edi
callq  50 <close_stdout_status+0x50>
mov    %rax,%rbp
callq  58 <close_stdout_status+0x58>
mov    %rbp,%rdx
mov    (%rax),%esi
mov    %ebx,%edi
mov    $0x0,%eax
callq  69 <close_stdout_status+0x69>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
close_stdout_status (int status)
{
  if (ferror (stdout))
    error (status, 0, gettext ("write error"));
  if (fclose (stdout) != 0)
    error (status, (*__errno_location ()), gettext ("write error"));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 7
30 7
31 7
32 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    $0x0,%edx
div    %rsi
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
AD_hash (void const *x, size_t table_size)
{
  struct Active_dir const *ax = x;
  return (uintmax_t) ax->ino % table_size;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cdio_get_devices_netbsd (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edi
callq  2a35 <sshalloc+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sshalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  2dc <dicod_string_list_from_grecs+0xc>
mov    %rax,%r12
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  2f1 <dicod_string_list_from_grecs+0x21>
mov    (%rbx),%rbx
test   %rbx,%rbx
je     34d <dicod_string_list_from_grecs+0x7d>
mov    0x10(%rbx),%rbp
cmpl   $0x0,0x0(%rbp)
je     331 <dicod_string_list_from_grecs+0x61>
jmp    30f <dicod_string_list_from_grecs+0x3f>
mov    0x10(%rbx),%rbp
cmpl   $0x0,0x0(%rbp)
je     331 <dicod_string_list_from_grecs+0x61>
mov    $0x0,%edi
callq  319 <dicod_string_list_from_grecs+0x49>
lea    0x8(%rbp),%rdi
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  32f <dicod_string_list_from_grecs+0x5f>
jmp    34d <dicod_string_list_from_grecs+0x7d>
mov    0x28(%rbp),%rdi
callq  33a <dicod_string_list_from_grecs+0x6a>
mov    %rax,%rsi
mov    %r12,%rdi
callq  345 <dicod_string_list_from_grecs+0x75>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    305 <dicod_string_list_from_grecs+0x35>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dicod_string_list_from_grecs(struct grecs_list *inlist)
{
    struct grecs_list_entry *ep;
    dico_list_t list = xdico_list_create();
    dico_list_set_free_item(list, dicod_free_item, ((void *)0));
    for (ep = inlist->head; ep; ep = ep->next) {
 grecs_value_t *vp = ep->data;
 if (vp->type != 0) {
     grecs_error(&vp->locus, 0, gettext("expected string"));
     break;
 }
 xdico_list_append(list, xstrdup(vp->v.string));
    }
    return list;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 8
16 8
17 8
18 7
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 10
29 12
30 12
31 12
32 12
33 12
34 6
35 6
36 6
37 15
38 15
39 15
40 15
41 15
<<<sep_out_sample>>>
mov    %rdi,%rax
test   $0x80,%sil
je     4a <strip_slash+0x4a>
test   %rdi,%rdi
je     4a <strip_slash+0x4a>
cmpb   $0x2e,(%rdi)
jne    45 <strip_slash+0x45>
cmpb   $0x2f,0x1(%rdi)
jne    4a <strip_slash+0x4a>
add    $0x1,%rax
je     4a <strip_slash+0x4a>
cmpb   $0x2e,(%rax)
jne    45 <strip_slash+0x45>
cmpb   $0x2f,0x1(%rax)
je     19 <strip_slash+0x19>
jmp    45 <strip_slash+0x45>
cmpb   $0x0,0x1(%rax)
je     4a <strip_slash+0x4a>
add    $0x1,%rax
je     4a <strip_slash+0x4a>
cmpb   $0x2f,(%rax)
jne    4a <strip_slash+0x4a>
cmpb   $0x0,0x1(%rax)
jne    32 <strip_slash+0x32>
repz retq 
cmpb   $0x2f,(%rax)
je     2c <strip_slash+0x2c>
nopw   0x0(%rax,%rax,1)
repz retq 
<<<sep_in_sample>>>
strip_slash(char * pname, int vflag)
{
 char * name;
 name = pname;
 if (vflag & (1 << 7)) {
  while( name && *name == '.' && *(name+1) == '/' ) name++;
  while( name && *name == '/' && *(name+1) != '\0' ) name++;
 }
 return name;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x2,%ecx
test   %ecx,%ecx
jle    8a <filesys_decompressor_for_file+0x8a>
push   %r12
push   %rbp
push   %rbx
movslq %ecx,%rbp
add    %rdx,%rbp
cmpb   $0x2e,0x0(%rbp)
jne    39 <filesys_decompressor_for_file+0x39>
jmp    45 <filesys_decompressor_for_file+0x45>
movslq %ecx,%rbp
add    %rdx,%rbp
cmpb   $0x2e,0x0(%rbp)
je     45 <filesys_decompressor_for_file+0x45>
sub    $0x1,%ecx
jne    2d <filesys_decompressor_for_file+0x2d>
mov    $0x0,%esi
jmp    98 <filesys_decompressor_for_file+0x98>
test   %rbp,%rbp
je     93 <filesys_decompressor_for_file+0x93>
mov    $0x0,%ebx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  5c <filesys_decompressor_for_file+0x5c>
test   %eax,%eax
jne    71 <filesys_decompressor_for_file+0x71>
movslq %ebx,%r12
shl    $0x4,%r12
mov    0x0(%r12),%rsi
jmp    98 <filesys_decompressor_for_file+0x98>
add    $0x1,%rbx
mov    %rbx,%rax
shl    $0x4,%rax
mov    0x0(%rax),%rsi
test   %rsi,%rsi
jne    54 <filesys_decompressor_for_file+0x54>
jmp    98 <filesys_decompressor_for_file+0x98>
mov    $0x0,%esi
mov    %rsi,%rax
retq   
mov    $0x0,%esi
mov    %rsi,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
filesys_decompressor_for_file (char *filename)
{
  register int i;
  char *extension = ((void *)0);
  for (i = strlen (filename) - 1; i > 0; i--)
    if (filename[i] == '.')
      {
        extension = filename + i;
        break;
      }
  if (!extension)
    return ((void *)0);
  for (i = 0; compress_suffixes[i].suffix; i++)
    if (strcmp (extension, compress_suffixes[i].suffix) == 0)
      return compress_suffixes[i].decompressor;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 2
10 2
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 5
22 5
23 12
24 12
25 11
26 11
27 11
28 13
29 14
30 14
31 14
32 14
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 13
41 13
42 13
43 13
44 12
45 17
46 17
47 12
48 17
49 17
50 17
51 17
52 17
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    0x8(%rsi),%rsi
mov    (%rdi),%rdi
callq  5c <assoc_key_cmp_ci+0x10>
mov    $0x1,%edx
test   %eax,%eax
jne    78 <assoc_key_cmp_ci+0x2c>
mov    (%rbx),%rax
sub    $0x1,%rax
mov    %rax,(%rbx)
test   %rax,%rax
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
assoc_key_cmp_ci(const void *item, void *data)
{
    const struct dico_assoc *aptr = item;
    struct find_closure *clos = data;
    if (strcasecmp(aptr->key, clos->str) == 0 && --clos->count == 0)
 return 0;
    return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 7
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 8
16 8
17 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <text_compare+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
text_compare (void const *data1, void const *data2)
{
  return strcmp (data1, data2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%r9
lea    0xc0(%rdi),%rdx
lea    0x60(%rdi),%rsi
mov    0x0(%rip),%rcx        # 1c <nettle_hmac_md5_set_key+0x1c>
callq  21 <nettle_hmac_md5_set_key+0x21>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_hmac_md5_set_key(struct hmac_md5_ctx *ctx,
   size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_md5), (key_length), (key) );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x1,%esi
callq  7b6 <array_unshift_element+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
array_unshift_element(a)
ARRAY *a;
{
 return (array_shift (a, 1, 0));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # d <exec_name_should_ignore+0xd>
test   %rbx,%rbx
je     49 <exec_name_should_ignore+0x49>
mov    %rdi,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     50 <exec_name_should_ignore+0x50>
cmpl   $0x1,0x0(%rip)        # 24 <exec_name_should_ignore+0x24>
sbb    %edx,%edx
and    $0xffffffe0,%edx
add    $0x30,%edx
mov    %rbp,%rsi
callq  34 <exec_name_should_ignore+0x34>
cmp    $0x1,%eax
jne    57 <exec_name_should_ignore+0x57>
add    $0x10,%rbx
je     5e <exec_name_should_ignore+0x5e>
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    1d <exec_name_should_ignore+0x1d>
jmp    65 <exec_name_should_ignore+0x65>
mov    $0x0,%eax
jmp    6a <exec_name_should_ignore+0x6a>
mov    $0x0,%eax
jmp    6a <exec_name_should_ignore+0x6a>
mov    $0x1,%eax
jmp    6a <exec_name_should_ignore+0x6a>
mov    $0x0,%eax
jmp    6a <exec_name_should_ignore+0x6a>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
exec_name_should_ignore (name)
     const char *name;
{
  struct ign *p;
  for (p = execignore.ignores; p && p->val; p++)
    if (strmatch (p->val, (char *)name, (extended_glob ? (1 << 5) : 0)|(1 << 4)) != 1)
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 5
22 5
23 5
24 5
25 8
26 8
27 8
28 8
29 7
30 7
31 8
32 8
33 8
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
mov    (%rdi),%r8
mov    $0x0,%ebp
mov    $0x0,%ebx
test   %r10,%r10
je     d38 <gsl_vector_ulong_minmax_index+0x46>
jmp    d40 <gsl_vector_ulong_minmax_index+0x4e>
mov    (%rdi),%rcx
cmp    %rcx,%r8
jbe    d21 <gsl_vector_ulong_minmax_index+0x2f>
mov    %rcx,%r8
mov    %rax,%rbx
add    %r11,%rdi
cmp    %r9,%rcx
jbe    d2f <gsl_vector_ulong_minmax_index+0x3d>
mov    %rcx,%r9
mov    %rax,%rbp
add    $0x1,%rax
cmp    %r10,%rax
jne    d13 <gsl_vector_ulong_minmax_index+0x21>
mov    %rbx,(%rsi)
mov    %rbp,(%rdx)
jmp    d5e <gsl_vector_ulong_minmax_index+0x6c>
shl    $0x3,%r11
add    %r11,%rdi
mov    %r8,%r9
mov    %r8,%rcx
mov    $0x0,%eax
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    d24 <gsl_vector_ulong_minmax_index+0x32>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_minmax_index (const gsl_vector_ulong * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  unsigned long max = v->data[0 * stride];
  unsigned long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 8
7 7
8 7
9 11
10 11
11 11
12 13
13 14
14 14
15 13
16 11
17 11
18 19
19 19
20 19
21 19
22 11
23 11
24 11
25 25
26 26
27 26
28 13
29 13
30 8
31 13
32 11
33 7
34 7
35 7
36 27
37 27
38 27
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
callq  269 <multivalued_table_free+0xe>
mov    %rbx,%rdi
callq  271 <multivalued_table_free+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
multivalued_table_free (struct hash_table_s * table)
{
  hash_free (table, (hash_map_func_t) multivalued_entry_free);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
testb  $0x10,0x23d(%rdi)
je     27 <__ram_set_re_pad+0x27>
mov    0x28(%rdi),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  25 <__ram_set_re_pad+0x25>
jmp    59 <__ram_set_re_pad+0x59>
mov    %esi,%ebp
mov    $0xc,%esi
callq  33 <__ram_set_re_pad+0x33>
mov    %eax,%edx
test   %edx,%edx
jne    59 <__ram_set_re_pad+0x59>
mov    0xc0(%rbx),%rax
mov    %ebp,0x28(%rax)
mov    0xd8(%rbx),%rax
mov    %ebp,0x8(%rax)
orl    $0x8000,0x23c(%rbx)
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__ram_set_re_pad(dbp, re_pad)
 DB *dbp;
 int re_pad;
{
 BTREE *t;
 QUEUE *q;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_re_pad", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x04 | 0x08)) != 0) return (__ret); };
 t = dbp->bt_internal;
 t->re_pad = re_pad;
 q = dbp->q_internal;
 q->re_pad = re_pad;
 (dbp)->flags |= (0x08000);
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 8
18 9
19 10
20 11
21 12
22 13
23 14
24 15
25 15
26 15
27 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
mov    (%rdi),%rbx
mov    0x8(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    47c <hash_map+0x34>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     473 <hash_map+0x2b>
cmp    0x0(%rip),%rdi        # 46e <hash_map+0x26>
je     473 <hash_map+0x2b>
callq  *%r12
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     45f <hash_map+0x17>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
hash_map (struct hash_table *ht, hash_map_func_t map)
{
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  for (slot = ht->ht_vec; slot < end; slot++)
    {
      if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
 (*map) (*slot);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 5
17 5
18 5
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <mu_alloc_die+0xb>
test   %rax,%rax
je     12 <mu_alloc_die+0x12>
callq  *%rax
mov    $0x0,%esi
mov    $0x0,%edi
callq  21 <mu_alloc_die+0x21>
mov    %rax,%rdi
mov    $0x0,%eax
callq  2e <mu_alloc_die+0x2e>
callq  33 <mu_alloc>
<<<sep_in_sample>>>
mu_alloc_die ()
{
  if (mu_alloc_die_hook)
    mu_alloc_die_hook ();
  mu_error (dgettext ("mailutils", "Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     196 <cdio_generic_stdio_free+0x24>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     188 <cdio_generic_stdio_free+0x16>
callq  188 <cdio_generic_stdio_free+0x16>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     196 <cdio_generic_stdio_free+0x24>
callq  196 <cdio_generic_stdio_free+0x24>
pop    %rbx
retq   
<<<sep_in_sample>>>
cdio_generic_stdio_free (void *p_user_data)
{
  generic_img_private_t *p_env = p_user_data;
  if (((void *)0) == p_env) return;
  if (((void *)0) != p_env->source_name)
    free (p_env->source_name);
  if (p_env->data_source)
    cdio_stdio_destroy (p_env->data_source);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 6
9 7
10 7
11 7
12 8
13 9
14 9
<<<sep_out_sample>>>
mov    %rsi,0x38(%rdi)
retq   
<<<sep_in_sample>>>
osip_authentication_info_set_srand (osip_authentication_info_t *
       authentication_info, char *srand)
{
  authentication_info->srand = (char *) srand;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%ebx
jmp    c6c <set_archive_format+0x61>
add    $0x10,%rbx
cmpq   $0x0,(%rbx)
jne    c6c <set_archive_format+0x61>
mov    0x0(%rip),%rax        # c2c <set_archive_format+0x21>
test   %rax,%rax
je     c33 <set_archive_format+0x28>
callq  *%rax
mov    %rbp,%rdi
callq  c3b <set_archive_format+0x30>
mov    %rax,%rbx
mov    $0x0,%edi
callq  c48 <set_archive_format+0x3d>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  c62 <set_archive_format+0x57>
mov    $0x2,%edi
callq  c6c <set_archive_format+0x61>
mov    %rbp,%rsi
mov    (%rbx),%rdi
callq  c77 <set_archive_format+0x6c>
test   %eax,%eax
jne    c1b <set_archive_format+0x10>
mov    0x8(%rbx),%eax
mov    %eax,0x0(%rip)        # c84 <set_archive_format+0x79>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_archive_format (char const *name)
{
  struct fmttab const *p;
  for (p = fmttab; strcmp (p->name, name) != 0; )
    if (! (++p)->name)
      do { if (error_hook) error_hook (); error (0, 0, gettext ("%s: Invalid archive format"), quotearg_colon (name)); usage (2); } while (0)
                             ;
  archive_format = p->fmt;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 4
28 4
29 4
30 4
31 4
32 8
33 8
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    0x0(%rip),%rdi        # a41 <access_log+0xd>
test   %rdi,%rdi
je     aa2 <access_log+0x6e>
mov    %rsi,%r12
mov    $0x0,%esi
callq  a53 <access_log+0x1f>
mov    %rax,%rbx
test   %rax,%rax
jne    a8d <access_log+0x59>
mov    0x0(%rip),%rbp        # a62 <access_log+0x2e>
mov    $0x0,%edi
callq  a6c <access_log+0x38>
mov    %rax,%rbx
callq  a74 <access_log+0x40>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  a8b <access_log+0x57>
jmp    aa2 <access_log+0x6e>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rax,%rdi
callq  a9a <access_log+0x66>
mov    %rbx,%rdi
callq  aa2 <access_log+0x6e>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
access_log(int argc, char **argv)
{
    FILE *fp;
    if (!access_log_file)
 return;
    fp = fopen(access_log_file, "a");
    if (!fp) {
 dico_log(4, (*__errno_location ()), gettext("cannot open access log file `%s'"),
   access_log_file);
 return;
    }
    format_access_log(fp, argc, argv);
    fclose(fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 10
26 12
27 12
28 12
29 12
30 13
31 13
32 14
33 14
34 14
35 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x90(%rdi),%rbp
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x9(%rcx),%rdi
callq  1f2 <make_size_file_name+0x2a>
mov    %rax,%rbx
test   %rax,%rax
je     247 <make_size_file_name+0x7f>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  205 <make_size_file_name+0x3d>
mov    $0xffffffffffffffff,%rdx
mov    %rbx,%rdi
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbx,%rcx,1)
mov    %rbx,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    -0x1(%rbx,%rdx,1),%rax
movabs $0x657a69732d756d2e,%rsi
mov    %rsi,(%rax)
movb   $0x0,0x8(%rax)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
make_size_file_name (struct _amd_data *amd)
{
  size_t size = strlen (amd->name) + 1 + sizeof (".mu-size");
  char *name = malloc (size);
  if (name)
    {
      strcpy (name, amd->name);
      strcat (name, "/");
      strcat (name, ".mu-size");
    }
  return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 5
14 5
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 12
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1583 <gcide_init+0xe>
mov    $0x0,%edi
callq  158d <gcide_init+0x18>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gcide_init(int argc, char **argv)
{
    int i;
    for (i = 0; i < (sizeof(strat_tab)/sizeof((strat_tab)[0])); i++)
 dico_strategy_add(&strat_tab[i].strat);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 7
7 7
8 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edx
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 44d4 <rl_clear_visible_line+0x12>
callq  44d9 <rl_clear_visible_line+0x17>
movl   $0x0,0x0(%rip)        # 44e3 <rl_clear_visible_line+0x21>
mov    0x0(%rip),%edi        # 44e9 <rl_clear_visible_line+0x27>
callq  44ee <rl_clear_visible_line+0x2c>
mov    0x0(%rip),%ebx        # 44f4 <rl_clear_visible_line+0x32>
test   %ebx,%ebx
js     4511 <rl_clear_visible_line+0x4f>
mov    %ebx,%edi
callq  44ff <rl_clear_visible_line+0x3d>
mov    $0x0,%edi
callq  4509 <rl_clear_visible_line+0x47>
sub    $0x1,%ebx
cmp    $0xffffffff,%ebx
jne    44f8 <rl_clear_visible_line+0x36>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_clear_visible_line ()
{
  int curr_line;
  tputs (_rl_term_cr, 1, _rl_output_character_function);
  _rl_last_c_pos = 0;
  _rl_move_vert (_rl_vis_botlin);
  for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)
    {
      _rl_move_vert (curr_line);
      _rl_clear_to_eol (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 6
8 6
9 7
10 7
11 7
12 9
13 9
14 10
15 10
16 7
17 7
18 7
19 13
20 13
21 13
<<<sep_out_sample>>>
movl   $0x0,0x4(%rdi)
movl   $0x0,(%rdi)
mov    0x0(%rip),%edx        # 20c <evtsetall+0x13>
test   %edx,%edx
jle    235 <evtsetall+0x3c>
mov    $0x0,%eax
or     %edx,(%rdi)
movslq %eax,%rdx
mov    0x0(,%rdx,8),%edx
or     %edx,0x4(%rdi)
add    $0x1,%eax
movslq %eax,%rdx
mov    0x0(,%rdx,8),%edx
cmp    %eax,%edx
jg     215 <evtsetall+0x1c>
repz retq 
<<<sep_in_sample>>>
evtsetall(event_mask *m)
{
 int i;
 m->sys_mask = 0;
 m->gen_mask = 0;
 for (i = 0; i < genev_xlat[i].gen_mask; i++) {
  m->gen_mask |= genev_xlat[i].gen_mask;
  m->sys_mask |= genev_xlat[i].sys_mask;
 }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
5 6
6 6
7 7
8 8
9 8
10 8
11 6
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
mov    0x28(%rdi),%rbp
callq  *0x18(%rbp)
mov    $0x0,%edx
test   %eax,%eax
je     2e <dump_buffer+0x2e>
mov    0x0(%rbp),%rax
mov    %rax,(%rbx)
mov    0x8(%rbp),%rax
mov    %rax,0x8(%rbx)
mov    $0x1,%dl
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dump_buffer (working_state * state)
{
  struct jpeg_destination_mgr * dest = state->cinfo->dest;
  if (! (*dest->empty_output_buffer) (state->cinfo))
    return 0;
  state->next_output_byte = dest->next_output_byte;
  state->free_in_buffer = dest->free_in_buffer;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 5
9 4
10 4
11 6
12 6
13 7
14 7
15 8
16 9
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 173 <previous_history+0x6>
test   %eax,%eax
je     18e <previous_history+0x21>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 180 <previous_history+0x13>
cltq   
mov    0x0(%rip),%rdx        # 189 <previous_history+0x1c>
mov    (%rdx,%rax,8),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
previous_history ()
{
  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x1,%esi
callq  564 <array_shift_element+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
array_shift_element(a, v)
ARRAY *a;
char *v;
{
 return (array_rshift (a, 1, v));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  19 <rec_field_name_p+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_field_name_p (const char *str)
{
  return rec_match (str, "^" "[a-zA-Z%][a-zA-Z0-9_]*" "$");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    (%rdi),%r12
mov    0x10(%rdi),%rsi
mov    %rbx,%rdi
callq  *0x30(%rbp)
shl    $0x4,%rax
mov    %rax,%rdx
add    %r12,%rdx
mov    0x8(%rbp),%rcx
cmp    %rcx,%rdx
jae    6af <hash_get_next+0x34>
mov    %rdx,%rax
test   %rdx,%rdx
jne    6b5 <hash_get_next+0x3a>
jmp    6db <hash_get_next+0x60>
nop
callq  6b5 <hash_get_next+0x3a>
cmp    %rbx,(%rax)
jne    6c8 <hash_get_next+0x4d>
mov    0x8(%rax),%rax
test   %rax,%rax
je     6db <hash_get_next+0x60>
mov    (%rax),%rax
jmp    6e9 <hash_get_next+0x6e>
mov    0x8(%rax),%rax
test   %rax,%rax
jne    6b5 <hash_get_next+0x3a>
jmp    6db <hash_get_next+0x60>
mov    (%rdx),%rax
test   %rax,%rax
jne    6e9 <hash_get_next+0x6e>
add    $0x10,%rdx
cmp    %rdx,%rcx
ja     6d3 <hash_get_next+0x58>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
hash_get_next (const Hash_table *table, const void *entry)
{
  struct hash_entry const *bucket
    = table->bucket + table->hasher (entry, table->n_buckets);
  struct hash_entry const *cursor;
  if (! (bucket < table->bucket_limit))
    abort ();
  for (cursor = bucket; cursor; cursor = cursor->next)
    if (cursor->data == entry && cursor->next)
      return cursor->next->data;
  while (++bucket < table->bucket_limit)
    if (bucket->data)
      return bucket->data;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 3
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 7
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 8
30 8
31 8
32 8
33 12
34 12
35 12
36 11
37 11
38 11
39 14
40 15
41 15
42 15
43 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x810,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
mov    0x30(%rdi),%rax
movl   $0x2,(%rax)
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x22,(%rax)
jne    f1f <ReadReaction_L1+0x28>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  f3b <ReadReaction_L1+0x44>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x3e,(%rax)
jne    f3b <ReadReaction_L1+0x44>
mov    $0x3c,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  f5e <ReadReaction_L1+0x67>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x22,(%rax)
jne    f5e <ReadReaction_L1+0x67>
mov    %rax,0x18(%rbx)
lea    0x400(%rsp),%rsi
mov    %rbx,%rdi
callq  f83 <ReadReaction_L1+0x8c>
lea    0x400(%rsp),%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  f9d <ReadReaction_L1+0xa6>
mov    $0x0,%ecx
lea    0x400(%rsp),%rdx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  fb5 <ReadReaction_L1+0xbe>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x3e,(%rax)
jne    fb5 <ReadReaction_L1+0xbe>
mov    0x808(%rsp),%rax
xor    %fs:0x28,%rax
je     fde <ReadReaction_L1+0xe7>
callq  fde <ReadReaction_L1+0xe7>
add    $0x810,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
ReadReaction_L1 (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 60);
  while (*pibIn->pbufCur++ != '"');
  pibIn->pbufCur = pibIn->pbufCur - 1;
  GetaString (pibIn, szEqn);
  printf ("reaction %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 0);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 6
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 11
27 11
28 11
29 11
30 11
31 12
32 13
33 13
34 13
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
43 15
44 15
45 16
46 16
47 16
48 16
49 16
50 17
51 17
52 17
53 17
54 17
55 17
56 17
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # fb6 <pch_copy+0x7>
movzbl 0x0(%rip),%edx        # fbd <pch_copy+0xe>
mov    $0x0,%eax
cmovne %edx,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
pch_copy (void)
{
  return p_copy[OLD] && p_copy[NEW];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x2018,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
mov    $0x2000,%edx
mov    %rsp,%rsi
callq  27 <discard_dg+0x27>
mov    0x2008(%rsp),%rax
xor    %fs:0x28,%rax
je     3f <discard_dg+0x3f>
callq  3f <discard_dg+0x3f>
add    $0x2018,%rsp
retq   
<<<sep_in_sample>>>
discard_dg (int fd, struct component const *comp)
{
  char buffer[8192];
  read (fd, buffer, sizeof buffer);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  13fb <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  896 <parse822_word_dot+0x12>
test   %eax,%eax
jne    8ce <parse822_word_dot+0x4a>
mov    (%rbx),%rdx
cmp    %rbp,%rdx
je     8ce <parse822_word_dot+0x4a>
cmpb   $0x2e,(%rdx)
jne    8ce <parse822_word_dot+0x4a>
mov    $0x0,%esi
mov    %r12,%rdi
callq  ec <str_append>
mov    (%rbx),%r8
lea    0x1(%r8),%rcx
mov    %rcx,(%rbx)
test   %eax,%eax
jne    8ce <parse822_word_dot+0x4a>
cmp    %rcx,%rbp
je     8ce <parse822_word_dot+0x4a>
cmpb   $0x2e,0x1(%r8)
je     8a7 <parse822_word_dot+0x23>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parse822_word_dot (const char **p, const char *e, char **word)
{
  int rc = mu_parse822_word (p, e, word);
  for (;rc == 0 && (*p != e) && **p == '.'; ++*p)
    rc = str_append (word, ".");
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 7
28 7
29 7
30 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
movl   $0x1,(%rsi)
mov    $0x1,%edx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  219 <make_mbchar+0x23>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
make_mbchar(long chr, int *chr_mb_len)
{
    char *chr_mb;
    ((void) (0));
    {
 *chr_mb_len = 1;
 chr_mb = mallocstrncpy(((void *)0), (char *)&chr, 1);
    }
    return chr_mb;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 7
5 7
6 7
7 7
8 10
9 10
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
movapd %xmm0,%xmm1
mov    %edi,%ebx
ucomisd 0x0(%rip),%xmm0        # 1d5 <gsl_ldexp+0x13>
jp     1dd <gsl_ldexp+0x1b>
je     288 <gsl_ldexp+0xc6>
lea    0x1c(%rsp),%rdi
movapd %xmm1,%xmm0
callq  1eb <gsl_ldexp+0x29>
movsd  %xmm0,0x8(%rsp)
add    0x1c(%rsp),%ebx
cvtsi2sd %ebx,%xmm1
ucomisd 0x0(%rip),%xmm1        # 201 <gsl_ldexp+0x3f>
jb     236 <gsl_ldexp+0x74>
subsd  0x0(%rip),%xmm1        # 20b <gsl_ldexp+0x49>
addsd  0x0(%rip),%xmm1        # 213 <gsl_ldexp+0x51>
movsd  0x0(%rip),%xmm0        # 21b <gsl_ldexp+0x59>
callq  220 <gsl_ldexp+0x5e>
mulsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x8(%rsp)
movsd  0x0(%rip),%xmm1        # 234 <gsl_ldexp+0x72>
jmp    275 <gsl_ldexp+0xb3>
movsd  0x0(%rip),%xmm0        # 23e <gsl_ldexp+0x7c>
ucomisd %xmm1,%xmm0
jb     275 <gsl_ldexp+0xb3>
addsd  0x0(%rip),%xmm1        # 24c <gsl_ldexp+0x8a>
subsd  0x0(%rip),%xmm1        # 254 <gsl_ldexp+0x92>
movsd  0x0(%rip),%xmm0        # 25c <gsl_ldexp+0x9a>
callq  261 <gsl_ldexp+0x9f>
mulsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x8(%rsp)
movsd  0x0(%rip),%xmm1        # 275 <gsl_ldexp+0xb3>
movsd  0x0(%rip),%xmm0        # 27d <gsl_ldexp+0xbb>
callq  282 <gsl_ldexp+0xc0>
mulsd  0x8(%rsp),%xmm0
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_ldexp (const double x, const int e)
{
  int ex;
  if (x == 0.0)
    {
      return x;
    }
  {
    double y = gsl_frexp (x, &ex);
    double e2 = e + ex, p2;
    if (e2 >= 1024)
      {
 y *= pow (2.0, e2 - 1024 + 1);
 e2 = 1024 - 1;
      }
    else if (e2 <= (-1021))
      {
 y *= pow (2.0, e2 - (-1021) - 1);
 e2 = (-1021) + 1;
      }
    p2 = pow (2.0, e2);
    return y * p2;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 10
13 10
14 11
15 11
16 13
17 13
18 13
19 13
20 13
21 13
22 14
23 14
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 19
34 21
35 21
36 22
37 24
38 24
39 24
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r10
test   %r9,%r9
je     3832 <gsl_matrix_short_set_all+0x48>
add    %r10,%r10
lea    (%r8,%r8,1),%r11
mov    $0x0,%edi
jmp    3824 <gsl_matrix_short_set_all+0x3a>
mov    %si,(%rax)
add    $0x2,%rax
cmp    %rdx,%rax
jne    380c <gsl_matrix_short_set_all+0x22>
add    $0x1,%rdi
add    %r10,%rcx
cmp    %r9,%rdi
je     3832 <gsl_matrix_short_set_all+0x48>
test   %r8,%r8
je     3818 <gsl_matrix_short_set_all+0x2e>
lea    (%rcx,%r11,1),%rdx
mov    %rcx,%rax
jmp    380c <gsl_matrix_short_set_all+0x22>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_short_set_all (gsl_matrix_short * m, short x)
{
  size_t i, j;
  short * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(short *) (data + 1 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 8
6 8
7 8
8 8
9 8
10 8
11 12
12 12
13 10
14 10
15 8
16 8
17 8
18 8
19 10
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 25ec <parse_daystart+0x7>
jne    267f <parse_daystart+0x9a>
sub    $0x8,%rsp
addq   $0x15180,0x0(%rip)        # 2601 <parse_daystart+0x1c>
movq   $0x0,0x0(%rip)        # 260c <parse_daystart+0x27>
mov    $0x0,%edi
callq  2616 <parse_daystart+0x31>
mov    0x0(%rip),%rcx        # 261d <parse_daystart+0x38>
test   %rax,%rax
je     2636 <parse_daystart+0x51>
imul   $0x3c,0x4(%rax),%edx
add    (%rax),%edx
imul   $0xe10,0x8(%rax),%eax
add    %eax,%edx
movslq %edx,%rdx
jmp    2664 <parse_daystart+0x7f>
movabs $0x1845c8a0ce512957,%rdx
mov    %rcx,%rax
imul   %rdx
sar    $0xd,%rdx
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
imul   $0x15180,%rdx,%rdx
mov    %rcx,%rax
sub    %rdx,%rax
mov    %rax,%rdx
sub    %rdx,%rcx
mov    %rcx,0x0(%rip)        # 266e <parse_daystart+0x89>
movb   $0x1,0x0(%rip)        # 2675 <parse_daystart+0x90>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
parse_daystart (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct tm *local;
  (void) entry;
  (void) argv;
  (void) arg_ptr;
  if (options.full_days == 0)
    {
      options.cur_day_start.tv_sec += 86400;
      options.cur_day_start.tv_nsec = 0;
      local = localtime (&options.cur_day_start.tv_sec);
      options.cur_day_start.tv_sec -= (local
           ? (local->tm_sec + local->tm_min * 60
       + local->tm_hour * 3600)
           : options.cur_day_start.tv_sec % 86400);
      options.full_days = 1;
    }
  return 1;
}
<<<sep_in_sample>>>
1 7
2 7
3 2
4 9
5 10
6 11
7 11
8 12
9 15
10 15
11 13
12 13
13 14
14 14
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 12
29 12
30 16
31 19
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
movb   $0x0,0x0(%rip)        # 1f07 <wrap_reset+0x7>
retq   
<<<sep_in_sample>>>
wrap_reset(void)
{
    prepend_wrap = 0;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
cmpl   $0x3,0x8(%rdi)
jne    11d1 <rec_type_min+0xe>
mov    0x20(%rdi),%eax
repz retq 
<<<sep_in_sample>>>
rec_type_min (rec_type_t type)
{
  int res;
  if (type->kind != REC_TYPE_RANGE)
    {
      res = -1;
    }
  else
    {
      res = type->data.range[0];
    }
  return res;
}
<<<sep_in_sample>>>
1 6
2 4
3 4
4 10
5 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     d92 <gsl_matrix_long_double_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d6a <gsl_matrix_long_double_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    dc4 <gsl_matrix_long_double_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x4,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_row (gsl_matrix_long_double * m, const size_t i)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  99 <rpmfd_get_fd_fd+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpmfd_get_fd_fd(RPMFD * rpmfd)
{
 return fdFileno(rpmfd->fd_t_);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
mov    $0x0,%edi
callq  1a <__gmp_vsnprintf+0x1a>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_vsnprintf (char *buf, size_t size, const char *fmt, va_list ap)
{
  struct gmp_snprintf_t d;
  do {} while (0);
  d.buf = buf;
  d.size = size;
  return __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 7
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdi,%rax
shr    $0x20,%rax
test   %eax,%eax
je     102 <fface_self_print+0x76>
mov    %eax,%ebp
mov    $0x28,%edi
callq  ad <fface_self_print+0x21>
mov    %r12,%rsi
mov    %ebx,%edi
callq  b7 <fface_self_print+0x2b>
mov    $0x0,%ebx
mov    $0x1,%eax
test   %ebp,%eax
je     e8 <fface_self_print+0x5c>
mov    %r12,%rcx
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  dc <fface_self_print+0x50>
mov    -0x18(%rbx),%rdi
mov    %r12,%rsi
callq  e8 <fface_self_print+0x5c>
add    $0x10,%rbx
mov    -0x10(%rbx),%eax
test   %eax,%eax
jne    c1 <fface_self_print+0x35>
mov    %r12,%rsi
mov    $0x29,%edi
callq  100 <fface_self_print+0x74>
jmp    107 <fface_self_print+0x7b>
callq  107 <fface_self_print+0x7b>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fface_self_print (struct fface_s fface, FILE * stream)
{
  int i;
  if (fface.flags) {
    _IO_putc ('(', stream);
    face_self_print (fface.face, stream);
    for (i = 0 ; fflag_and_name [i].flag ; i++)
      if (fflag_and_name [i].flag & fface.flags) {
 fputs (" + ", stream);
 fputs (fflag_and_name [i].name, stream);
      }
    _IO_putc (')', stream);
  }
  else
    face_self_print (fface.face, stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 7
30 7
31 7
32 12
33 12
34 12
35 12
36 15
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
movzwl (%rcx),%edi
test   %r8,%r8
je     1532 <gsl_vector_short_min_index+0x40>
add    %r9,%r9
add    %r9,%rcx
mov    $0x0,%edx
mov    $0x0,%eax
jmp    1527 <gsl_vector_short_min_index+0x35>
movzwl (%rcx),%esi
cmp    %si,%di
jle    1524 <gsl_vector_short_min_index+0x32>
mov    %rdx,%rax
mov    %esi,%edi
add    %r9,%rcx
add    $0x1,%rdx
cmp    %r8,%rdx
jne    1517 <gsl_vector_short_min_index+0x25>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_short_min_index (const gsl_vector_short * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  short min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      short x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 8
7 8
8 8
9 8
10 6
11 6
12 10
13 11
14 11
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  1995 <gsl_vector_ulong_calloc+0xe>
mov    %rax,%rbp
test   %rax,%rax
je     19d4 <gsl_vector_ulong_calloc+0x4d>
lea    0x0(,%rbx,8),%rdx
mov    0x10(%rax),%rdi
mov    $0x0,%esi
callq  19b3 <gsl_vector_ulong_calloc+0x2c>
test   %rbx,%rbx
je     19db <gsl_vector_ulong_calloc+0x54>
mov    $0x0,%edx
mov    0x10(%rbp),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    19bd <gsl_vector_ulong_calloc+0x36>
jmp    19e2 <gsl_vector_ulong_calloc+0x5b>
mov    $0x0,%eax
jmp    19e5 <gsl_vector_ulong_calloc+0x5e>
mov    %rbp,%rax
xchg   %ax,%ax
jmp    19e5 <gsl_vector_ulong_calloc+0x5e>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_calloc (const size_t n)
{
  size_t i;
  gsl_vector_ulong * v = gsl_vector_ulong_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 1 * n * sizeof(unsigned long));
  for (i = 0; i < 1 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 6
24 12
25 12
26 12
27 12
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    0x0(%rip),%rsi        # 1625 <next_node_sep+0xe>
test   %rsi,%rsi
je     16c1 <next_node_sep+0xaa>
add    0x0(%rip),%rsi        # 1635 <next_node_sep+0x1e>
mov    %rsi,%r12
mov    $0x0,%esi
mov    %r12,%rdi
callq  1645 <next_node_sep+0x2e>
mov    %rax,%rbx
lea    0x1(%rax),%rdi
callq  1651 <next_node_sep+0x3a>
mov    %rax,0x10(%rbp)
test   %rax,%rax
jne    1673 <next_node_sep+0x5c>
mov    $0x0,%esi
mov    $0x3,%edi
callq  1669 <next_node_sep+0x52>
mov    $0xffffffff,%edi
callq  1673 <next_node_sep+0x5c>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  1681 <next_node_sep+0x6a>
mov    0x10(%rbp),%rax
movb   $0x0,(%rax,%rbx,1)
add    0x0(%rip),%rbx        # 1690 <next_node_sep+0x79>
mov    %rbx,0x0(%rip)        # 1697 <next_node_sep+0x80>
mov    0x0(%rip),%rdi        # 169e <next_node_sep+0x87>
cmpb   $0x0,(%rdi,%rbx,1)
je     16b1 <next_node_sep+0x9a>
add    $0x1,%rbx
mov    %rbx,0x0(%rip)        # 16af <next_node_sep+0x98>
jmp    16c1 <next_node_sep+0xaa>
callq  16b6 <next_node_sep+0x9f>
movq   $0x0,0x0(%rip)        # 16c1 <next_node_sep+0xaa>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
next_node_sep (struct servtab *sep)
{
  if (serv_node)
    {
      size_t i = strcspn (serv_node + serv_node_offset, ",");
      sep->se_node = malloc (i + 1);
      if (!sep->se_node)
 {
   syslog (3, "malloc: %m");
   exit (-1);
 }
      memcpy (sep->se_node, serv_node + serv_node_offset, i);
      sep->se_node[i] = 0;
      serv_node_offset += i;
      if (serv_node[serv_node_offset])
 serv_node_offset++;
      else
 {
   free (serv_node);
   serv_node = ((void *)0);
 }
    }
  return sep;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 9
20 9
21 9
22 10
23 10
24 12
25 12
26 12
27 12
28 13
29 13
30 14
31 14
32 15
33 15
34 15
35 16
36 16
37 16
38 19
39 20
40 24
41 24
42 24
43 24
44 24
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    $0x14,%edi
callq  b5 <gsasl_sha1+0x17>
mov    %rax,%rdx
mov    %rax,(%rbx)
mov    $0x7,%eax
test   %rdx,%rdx
je     d0 <gsasl_sha1+0x32>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  d0 <gsasl_sha1+0x32>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsasl_sha1 (const char *in, size_t inlen, char *out[20])
{
  *out = malloc (20);
  if (!*out)
    return GSASL_MALLOC_ERROR;
  return gc_sha1 (in, inlen, *out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 4
13 4
14 6
15 6
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  3dd <setbit_wc+0x9>
mov    %eax,%edi
mov    $0x0,%eax
cmp    $0xffffffff,%edi
je     3f6 <setbit_wc+0x22>
mov    %rbx,%rsi
callq  0 <setbit>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
setbit_wc (wint_t wc, charclass c)
{
  int b = wctob (wc);
  if (b == (-1))
    return 0;
  setbit (b, c);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 4
7 4
8 6
9 6
10 7
11 8
12 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # 1ceb <_rl_char_search_callback+0xf>
movl   $0x1,0x0(%rip)        # 1cf5 <_rl_char_search_callback+0x19>
mov    0x8(%rdi),%edx
mov    0x4(%rdi),%esi
mov    (%rdi),%edi
callq  1c62 <_rl_char_search>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_char_search_callback (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  return (_rl_char_search (data->count, data->i1, data->i2));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 6
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rsi
cmpb   $0x0,(%rsi)
jne    3a4 <GetVarPtr+0x22>
jmp    3c1 <GetVarPtr+0x3f>
add    $0x18,%rbx
mov    (%rbx),%rsi
cmpb   $0x0,(%rsi)
je     3c1 <GetVarPtr+0x3f>
mov    %rbp,%rdi
callq  3ac <GetVarPtr+0x2a>
test   %eax,%eax
jne    398 <GetVarPtr+0x16>
mov    (%rbx),%rax
cmpb   $0x0,(%rax)
mov    $0x0,%eax
cmovne %rbx,%rax
jmp    3c6 <GetVarPtr+0x44>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
GetVarPtr (PVMMAPSTRCT pvm, PSTR szName)
{
  while (*pvm->szName && MyStrcmp (szName, pvm->szName))
    pvm++;
  return (*pvm->szName ? pvm : ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xffffffff,%edi
callq  584 <utimens+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
utimens (char const *file, struct timespec const timespec[2])
{
  return fdutimens (-1, file, timespec);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     2e <printer_hash_1+0x2e>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    f <printer_hash_1+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
printer_hash_1 (struct printer *printer)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((printer->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdi,%rdx
mov    $0x7ff,%esi
mov    %rbp,%rdi
callq  534 <read_ps_line+0x1a>
mov    %rax,%r12
test   %rax,%rax
je     576 <read_ps_line+0x5c>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x2(%rbp,%rcx,1),%rax
cmpb   $0xa,(%rax)
jne    562 <read_ps_line+0x48>
movb   $0x0,(%rax)
mov    %r12,%rax
jmp    585 <read_ps_line+0x6b>
mov    %rbx,%rdi
callq  56a <read_ps_line+0x50>
cmp    $0xa,%eax
je     57d <read_ps_line+0x63>
cmp    $0xffffffff,%eax
jne    562 <read_ps_line+0x48>
jmp    582 <read_ps_line+0x68>
mov    $0x0,%eax
jmp    585 <read_ps_line+0x6b>
mov    %r12,%rax
jmp    585 <read_ps_line+0x6b>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
read_ps_line(ps_output, line)
    FILE *ps_output;
    char *line;
{
    int c;
    char *ok;
    size_t lastchar;
    ok = fgets(line, 2048 - 1, ps_output);
    if (ok == ((void *)0))
 return ((void *)0);
    if (line[lastchar = strlen(line) - 1] == '\n')
 line[lastchar] = 0;
    else
 while ((c = fgetc(ps_output)) != '\n' && c != (-1))
     ;
    return ok;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 9
12 9
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 12
22 16
23 16
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 10
32 10
33 16
34 16
35 16
36 17
37 17
38 17
39 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
test   %rdi,%rdi
je     72b2 <close_new_fifos+0x1a>
mov    %esi,%ebp
test   %esi,%esi
jg     72b9 <close_new_fifos+0x21>
jmp    72f5 <close_new_fifos+0x5d>
callq  72b7 <close_new_fifos+0x1f>
jmp    730f <close_new_fifos+0x77>
lea    -0x1(%rsi),%r13d
add    $0x1,%r13
mov    $0x0,%ebx
mov    %ebx,%edi
mov    %rbx,%rax
cmpb   $0x0,(%r12,%rbx,1)
jne    72ec <close_new_fifos+0x54>
cmp    %ebx,0x0(%rip)        # 72d8 <close_new_fifos+0x40>
jle    72ec <close_new_fifos+0x54>
mov    0x0(%rip),%rdx        # 72e1 <close_new_fifos+0x49>
cmpb   $0x0,(%rdx,%rax,1)
je     72ec <close_new_fifos+0x54>
callq  72ec <close_new_fifos+0x54>
add    $0x1,%rbx
cmp    %r13,%rbx
jne    72c6 <close_new_fifos+0x2e>
cmp    0x0(%rip),%ebp        # 72fb <close_new_fifos+0x63>
jge    730f <close_new_fifos+0x77>
mov    %ebp,%edi
callq  7304 <close_new_fifos+0x6c>
add    $0x1,%ebp
cmp    %ebp,0x0(%rip)        # 730d <close_new_fifos+0x75>
jg     72fd <close_new_fifos+0x65>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
close_new_fifos (list, lsize)
     char *list;
     int lsize;
{
  int i;
  if (list == 0)
    {
      unlink_fifo_list ();
      return;
    }
  for (i = 0; i < lsize; i++)
    if (list[i] == 0 && i < totfds && dev_fd_list[i])
      unlink_fifo (i);
  for (i = lsize; i < totfds; i++)
    unlink_fifo (i);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 11
11 11
12 11
13 8
14 9
15 9
16 9
17 11
18 11
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 13
28 13
29 11
30 11
31 14
32 14
33 15
34 15
35 14
36 14
37 14
38 16
39 16
40 16
41 16
42 16
43 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rsi),%rbp
mov    0x8(%rsi),%r12
test   %rbp,%rbp
je     1d5b <gsl_block_float_fscanf+0x73>
mov    %rdi,%r13
mov    $0x0,%ebx
jmp    1d31 <gsl_block_float_fscanf+0x49>
mov    $0x5,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d21 <gsl_block_float_fscanf+0x39>
mov    $0x5,%eax
jmp    1d67 <gsl_block_float_fscanf+0x7f>
add    $0x1,%rbx
cmp    %rbp,%rbx
je     1d62 <gsl_block_float_fscanf+0x7a>
lea    0xc(%rsp),%rdx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  1d48 <gsl_block_float_fscanf+0x60>
movss  0xc(%rsp),%xmm0
movss  %xmm0,(%r12,%rbx,4)
cmp    $0x1,%eax
je     1d28 <gsl_block_float_fscanf+0x40>
jmp    1d08 <gsl_block_float_fscanf+0x20>
mov    $0x0,%eax
jmp    1d67 <gsl_block_float_fscanf+0x7f>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_block_float_fscanf (FILE * stream, gsl_block_float * b)
{
  size_t n = b->size ;
  float * data = b->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          float tmp ;
          int status = fscanf (stream, "%g", &tmp) ;
          data [1 * i + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 90, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 6
21 6
22 6
23 12
24 12
25 12
26 12
27 12
28 13
29 13
30 14
31 14
32 14
33 20
34 20
35 20
36 21
37 21
38 21
39 21
40 21
41 21
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     15fc <mu_header_lines+0x55>
mov    %rsi,%rbp
mov    $0x1005,%ax
test   %rsi,%rsi
je     15fc <mu_header_lines+0x55>
callq  46e <mu_header_fill>
mov    %eax,%r12d
test   %r12d,%r12d
jne    15fc <mu_header_lines+0x55>
lea    0x18(%rsp),%rcx
lea    0x10(%rsp),%rdx
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  81 <mu_hdrent_count>
mov    0x18(%rsp),%rax
add    $0x1,%rax
mov    %rax,0x0(%rbp)
mov    %r12d,%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_header_lines (mu_header_t header, size_t *plines)
{
  int status;
  if (header == ((void *)0))
    return 22;
  if (plines == ((void *)0))
    return (0x1000 +5);
  status = mu_header_fill (header);
  if (status == 0)
    {
      size_t count;
      size_t size;
      size_t lines;
      mu_hdrent_count (header, &count, &size, &lines);
      *plines = lines + 1;
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 4
8 4
9 4
10 7
11 6
12 6
13 8
14 8
15 9
16 9
17 14
18 14
19 14
20 14
21 14
22 15
23 15
24 15
25 17
26 18
27 18
28 18
29 18
30 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
je     1b3 <mu_pop3_sendline+0x19>
mov    $0x0,%eax
callq  1ad <mu_pop3_sendline+0x13>
mov    %eax,%edx
test   %edx,%edx
jne    1bb <mu_pop3_sendline+0x21>
mov    %rbx,%rdi
callq  1bb <mu_pop3_sendline+0x21>
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_pop3_sendline (mu_pop3_t pop3, const char *line)
{
  if (line)
    {
      int status = mu_pop3_writeline (pop3, line);
      if (status)
 return status;
    }
  return mu_pop3_send (pop3);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 6
9 6
10 9
11 9
12 10
13 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x228,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
mov    %fs:0x28,%rax
mov    %rax,0x218(%rsp)
xor    %eax,%eax
callq  7d6 <_stdin_file_size+0x2b>
mov    %rax,%r12
cmpl   $0x0,0x20(%rax)
jne    81e <_stdin_file_size+0x73>
mov    0x8(%rax),%rbx
jmp    7e8 <_stdin_file_size+0x3d>
add    %rdx,%rbx
lea    0x8(%rsp),%r8
mov    %rbx,%rcx
mov    $0x200,%edx
lea    0x10(%rsp),%rsi
mov    %rbp,%rdi
callq  802 <_stdin_file_size+0x57>
test   %eax,%eax
jne    810 <_stdin_file_size+0x65>
mov    0x8(%rsp),%rdx
test   %rdx,%rdx
jne    7e5 <_stdin_file_size+0x3a>
mov    %rbx,0x30(%r12)
movl   $0x1,0x20(%r12)
mov    0x30(%r12),%rax
mov    %rax,0x0(%r13)
mov    $0x0,%eax
mov    0x218(%rsp),%rcx
xor    %fs:0x28,%rcx
je     844 <_stdin_file_size+0x99>
callq  844 <_stdin_file_size+0x99>
add    $0x228,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_stdin_file_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  if (!fs->size_computed)
    {
      char buf[512];
      mu_off_t fs_offset = fs->offset;
      size_t n;
      int status;
      while ((status = mu_stream_read (stream, buf, sizeof (buf),
           fs_offset, &n)) == 0
      && n > 0)
 fs_offset += n;
      fs->size = fs_offset;
      fs->size_computed = 1;
    }
  *psize = fs->size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 4
14 4
15 7
16 10
17 13
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 12
27 12
28 12
29 14
30 15
31 17
32 17
33 19
34 19
35 19
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r11
cmp    (%rdi),%r11
jne    1492 <gsl_matrix_long_double_div_elements+0x1f>
mov    0x8(%rsi),%r9
cmp    %rax,%r9
je     14b2 <gsl_matrix_long_double_div_elements+0x3f>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  14ab <gsl_matrix_long_double_div_elements+0x38>
mov    $0x13,%eax
jmp    152e <gsl_matrix_long_double_div_elements+0xbb>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r12
test   %r11,%r11
je     1522 <gsl_matrix_long_double_div_elements+0xaf>
mov    %rax,%r13
shl    $0x4,%r13
sub    %rax,%r12
shl    $0x4,%r12
mov    $0x0,%r10d
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    1513 <gsl_matrix_long_double_div_elements+0xa0>
mov    %rax,%rcx
add    0x18(%rdi),%rcx
mov    %rax,%r8
add    0x18(%rsi),%r8
fldt   (%rcx)
fldt   (%r8,%r10,1)
fdivrp %st,%st(1)
fstpt  (%rcx)
add    $0x1,%rdx
add    $0x10,%rax
cmp    %r9,%rdx
jne    14df <gsl_matrix_long_double_div_elements+0x6c>
add    $0x1,%rbx
add    %r13,%rbp
add    %r12,%r10
cmp    %r11,%rbx
je     1529 <gsl_matrix_long_double_div_elements+0xb6>
test   %r9,%r9
je     1504 <gsl_matrix_long_double_div_elements+0x91>
mov    %rbp,%rax
mov    $0x0,%edx
jmp    14df <gsl_matrix_long_double_div_elements+0x6c>
mov    $0x0,%eax
jmp    152e <gsl_matrix_long_double_div_elements+0xbb>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_div_elements (gsl_matrix_long_double * a, const gsl_matrix_long_double * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 16
41 16
42 16
43 16
44 14
45 14
46 14
47 14
48 14
49 16
50 16
51 16
52 16
53 16
54 21
55 21
56 21
57 23
58 23
59 23
60 23
61 23
62 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xffffffff,%edi
callq  584 <utimens+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
utimens (char const *file, struct timespec const timespec[2])
{
  return fdutimens (-1, file, timespec);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rsi,%r8
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %cl
sub    %ecx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    1f6c <mu_sql_decode_password_type+0x2c>
movl   $0x0,(%r8)
retq   
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %cl
sub    %ecx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    1f92 <mu_sql_decode_password_type+0x52>
movl   $0x2,(%r8)
retq   
mov    $0x0,%edi
mov    $0xa,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    1fb8 <mu_sql_decode_password_type+0x78>
movl   $0x1,(%r8)
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
mu_sql_decode_password_type (const char *arg, enum mu_password_type *t)
{
  if (strcmp (arg, "plain") == 0)
    *t = password_plaintext;
  else if (strcmp (arg, "hash") == 0)
    *t = password_hash;
  else if (strcmp (arg, "scrambled") == 0)
    *t = password_scrambled;
  else
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 8
38 8
39 10
40 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %edi,%edi
js     92 <free_cwd+0xf>
callq  92 <free_cwd+0xf>
mov    0x8(%rbx),%rdi
callq  9b <free_cwd+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_cwd (struct saved_cwd *cwd)
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  free (cwd->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %r8,%r12
mov    (%rdi),%eax
lea    -0x1(%rax),%ebp
mov    %ebp,(%rdi)
movslq %ebp,%rbp
shl    $0x5,%rbp
mov    0x8(%rdi),%rax
mov    (%rax,%rbp,1),%eax
mov    %eax,(%rsi)
movslq %edx,%rdx
shl    $0x3,%rdx
mov    0x8(%rdi),%rax
mov    0x8(%rax,%rbp,1),%rsi
mov    %rcx,%rdi
callq  39a2 <pop_fail_stack+0x39>
mov    0x8(%r12),%rdi
callq  39ac <pop_fail_stack+0x43>
mov    0x8(%rbx),%rax
mov    0x8(%rax,%rbp,1),%rdi
callq  39ba <pop_fail_stack+0x51>
mov    0x8(%rbx),%rax
mov    0x18(%rax,%rbp,1),%rdx
mov    0x10(%rax,%rbp,1),%rax
mov    %rax,(%r12)
mov    %rdx,0x8(%r12)
mov    0x8(%rbx),%rax
mov    0x4(%rax,%rbp,1),%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
pop_fail_stack (struct re_fail_stack_t *fs, int *pidx, int nregs,
  regmatch_t *regs, re_node_set *eps_via_nodes)
{
  int num = --fs->num;
  ((void) (0));
  *pidx = fs->stack[num].idx;
  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);
  free ((eps_via_nodes)->elems);
  free (fs->stack[num].regs);
  *eps_via_nodes = fs->stack[num].eps_via_nodes;
  return fs->stack[num].node;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 12
33 12
34 12
35 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 4a <osip_call_info_init+0xb>
test   %rax,%rax
je     58 <osip_call_info_init+0x19>
mov    $0x18,%edi
callq  *%rax
jmp    62 <osip_call_info_init+0x23>
mov    $0x18,%edi
callq  62 <osip_call_info_init+0x23>
mov    %rax,(%rbx)
test   %rax,%rax
je     84 <osip_call_info_init+0x45>
movq   $0x0,(%rax)
mov    (%rbx),%rdi
add    $0x8,%rdi
callq  7d <osip_call_info_init+0x3e>
mov    $0x0,%eax
jmp    89 <osip_call_info_init+0x4a>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_call_info_init (osip_call_info_t ** call_info)
{
  *call_info = (osip_call_info_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_call_info_t)):malloc(sizeof (osip_call_info_t)));
  if (*call_info == ((void *)0))
    return -4;
  (*call_info)->element = ((void *)0);
  osip_list_init (&(*call_info)->gen_params);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 7
16 7
17 7
18 8
19 8
20 5
21 9
22 9
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
mov    %esi,0xb0(%rdi)
testb  $0x10,0x20(%rdi)
je     c47 <_wsplt_seterr+0x14>
callq  c47 <_wsplt_seterr+0x14>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_wsplt_seterr (struct wordsplit *wsp, int ec)
{
  wsp->ws_errno = ec;
  if (wsp->ws_flags & 0x00000010)
    wordsplit_perror (wsp);
  return ec;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
lea    0x0(,%rsi,8),%rbx
mov    (%rdi),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  5e <rk2_reset+0x21>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  6f <rk2_reset+0x32>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  80 <rk2_reset+0x43>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  91 <rk2_reset+0x54>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rk2_reset (void *vstate, size_t dim)
{
  rk2_state_t *state = (rk2_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
callq  f <chownat+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
chownat (int fd, char const *file, uid_t owner, gid_t group)
{
  return fchownat (fd, file, owner, group, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  de <delegate_free+0xc>
mov    0x8(%rbx),%rdi
callq  e7 <delegate_free+0x15>
mov    0x10(%rbx),%rdi
callq  f0 <delegate_free+0x1e>
mov    %rbx,%rdi
callq  f8 <delegate_free+0x26>
pop    %rbx
retq   
<<<sep_in_sample>>>
delegate_free (struct delegation *delegation)
{
  free (delegation->name);
  free (delegation->contract);
  free (delegation->command);
  free (delegation);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl %dil,%esi
mov    $0x1,%edi
callq  249 <get_symbols>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
function_list(_Bool sort)
{
 return get_symbols(FUNCTION, sort);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
libunistring_c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
mov    $0x1,%r9d
callq  51 <getopt_long_only+0x16>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getopt_long_only (int argc, char *const *argv, const char *options,
    const struct option *long_options, int *opt_index)
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 1, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
mov    %esi,0x8(%rsp)
mov    %rdx,%r15
mov    %ecx,%r14d
mov    %r8d,0xc(%rsp)
mov    $0x1,%edi
callq  4549 <rpmpsf_write_filesets+0x2b>
mov    %rax,%r13
mov    %r15,%rdi
callq  4554 <rpmpsf_write_filesets+0x36>
mov    %rax,%rsi
mov    $0x1,%ebp
mov    $0x0,%r12d
lea    0x18(%rsp),%rdi
jmp    45e8 <rpmpsf_write_filesets+0xca>
test   %r14d,%r14d
jne    458a <rpmpsf_write_filesets+0x6c>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  4588 <rpmpsf_write_filesets+0x6a>
jmp    45a4 <rpmpsf_write_filesets+0x86>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  45a4 <rpmpsf_write_filesets+0x86>
mov    %r13,%rdi
callq  45ac <rpmpsf_write_filesets+0x8e>
mov    0xc(%rsp),%r9d
mov    %r14d,%r8d
mov    %rax,%rcx
mov    %rbx,%rdx
mov    0x8(%rsp),%esi
mov    (%rsp),%rdi
callq  45c7 <rpmpsf_write_filesets+0xa9>
add    %eax,%r12d
mov    %r15,%rdi
callq  45d2 <rpmpsf_write_filesets+0xb4>
mov    %rax,%rsi
test   %ebp,%ebp
jne    45e0 <rpmpsf_write_filesets+0xc2>
lea    0x18(%rsp),%rdi
jmp    45e5 <rpmpsf_write_filesets+0xc7>
mov    $0x0,%edi
add    $0x1,%ebp
mov    $0x0,%edx
callq  45f2 <rpmpsf_write_filesets+0xd4>
mov    %rax,%rbx
test   %rax,%rax
jne    4569 <rpmpsf_write_filesets+0x4b>
mov    0x18(%rsp),%rdi
test   %rdi,%rdi
je     460d <rpmpsf_write_filesets+0xef>
callq  460d <rpmpsf_write_filesets+0xef>
mov    %r13,%rdi
callq  4615 <rpmpsf_write_filesets+0xf7>
mov    %r12d,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
rpmpsf_write_filesets(TOPSF * topsf, int uxfio_ofd, STROB * all_filesets, int filetype, int swdef_filetype)
{
 int ret = 0, i = 0;
 STROB * tmp = strob_open(1);
 char *buf, *p;
 while ((p = rpmpsf_list_iterate((i++ == 0) ? (&buf) : ((void *)0), strob_str(all_filesets), " ")) && p) {
  if (filetype == 0) {
   strob_sprintf(tmp, 0, "%s-RUN", p);
  } else {
   strob_sprintf(tmp, 0, "%s", p);
  }
  ret += rpmpsf_write_fileset(topsf, uxfio_ofd, p, strob_str(tmp), filetype, swdef_filetype);
 }
 if (buf)
  free(buf);
 strob_close(tmp);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 4
14 4
15 4
16 6
17 6
18 6
19 6
20 3
21 6
22 6
23 7
24 7
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 10
33 10
34 10
35 10
36 10
37 10
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 6
49 6
50 6
51 6
52 6
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 6
62 14
63 14
64 14
65 15
66 16
67 16
68 18
69 18
70 18
71 18
72 18
73 18
74 18
75 18
76 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # 1ceb <_rl_char_search_callback+0xf>
movl   $0x1,0x0(%rip)        # 1cf5 <_rl_char_search_callback+0x19>
mov    0x8(%rdi),%edx
mov    0x4(%rdi),%esi
mov    (%rdi),%edi
callq  1c62 <_rl_char_search>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_char_search_callback (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  return (_rl_char_search (data->count, data->i1, data->i2));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 6
7 6
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  ff <args_read+0xe>
cmpl   $0x4,0x0(%rip)        # 106 <args_read+0x15>
ja     187 <args_read+0x96>
mov    0x0(%rip),%eax        # 10e <args_read+0x1d>
jmpq   *0x0(,%rax,8)
mov    0x0(%rip),%rax        # 11c <args_read+0x2b>
lea    0x8(%rax),%rdx
mov    %rdx,0x0(%rip)        # 127 <args_read+0x36>
mov    (%rax),%rax
jmp    19b <args_read+0xaa>
mov    $0x2,%edx
mov    0x0(%rip),%rsi        # 138 <args_read+0x47>
mov    $0x0,%edi
callq  142 <args_read+0x51>
jmp    19b <args_read+0xaa>
mov    0x0(%rip),%rdi        # 14b <args_read+0x5a>
callq  150 <args_read+0x5f>
jmp    19b <args_read+0xaa>
mov    0x0(%rip),%rax        # 159 <args_read+0x68>
cmpq   $0x0,(%rax)
je     16f <args_read+0x7e>
lea    0x8(%rax),%rdx
mov    %rdx,0x0(%rip)        # 16a <args_read+0x79>
mov    (%rax),%rax
jmp    19b <args_read+0xaa>
mov    $0x2,%edx
mov    0x0(%rip),%rsi        # 17b <args_read+0x8a>
mov    $0x0,%edi
callq  185 <args_read+0x94>
jmp    19b <args_read+0xaa>
mov    $0x0,%edi
mov    $0x0,%eax
callq  196 <args_read+0xa5>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
args_read(void)
{
 const char *p;
 static STRBUF sb[1];
 strbuf_clear(sb);
 switch (type) {
 case 0:
  p = ((void *)0);
  break;
 case 1:
  p = *argslist++;
  break;
 case 2:
  p = strbuf_fgets(sb, ip, 2);
  break;
 case 3:
  p = gfind_read(gp);
  break;
 case 4:
  if (*argslist != ((void *)0))
   p = *argslist++;
  else
   p = strbuf_fgets(sb, ip, 2);
  break;
 default:
  die("args_read: invalid type.");
 }
 return p;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 12
13 14
14 14
15 14
16 14
17 15
18 17
19 17
20 18
21 20
22 20
23 20
24 21
25 21
26 21
27 21
28 23
29 23
30 23
31 23
32 23
33 26
34 26
35 26
36 8
37 29
38 29
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  da5 <quotearg_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_mem (char const *arg, size_t argsize)
{
  return quotearg_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r9d
callq  e4 <qags>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_integration_qags (const gsl_function *f,
                      double a, double b,
                      double epsabs, double epsrel, size_t limit,
                      gsl_integration_workspace * workspace,
                      double * result, double * abserr)
{
  int status = qags (f, a, b, epsabs, epsrel, limit,
                     workspace,
                     result, abserr,
                     &gsl_integration_qk21) ;
  return status ;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 12
5 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rbx
mov    $0x2,%ecx
mov    $0x2,%edx
mov    (%rbx),%rdi
callq  0 <bad_argc>
test   %al,%al
jne    3285 <m4_decr+0x58>
mov    $0x0,%esi
cmp    $0x1,%ebp
jle    3265 <m4_decr+0x38>
mov    0x8(%rbx),%rax
mov    0x8(%rax),%rsi
lea    0xc(%rsp),%rdx
mov    (%rbx),%rdi
callq  27d <numeric_arg>
test   %al,%al
je     3285 <m4_decr+0x58>
mov    0xc(%rsp),%eax
lea    -0x1(%rax),%esi
mov    %r12,%rdi
callq  3046 <shipout_int>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
m4_decr (struct obstack *obs, int argc, token_data **argv)
{
  int value;
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  if (!numeric_arg (argv[0], (argc > (1) ? ((argv[1])->u.u_t.text) : ""), &value))
    return;
  shipout_int (obs, value - 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
cmp    %rdx,%rax
ja     7882 <gsl_matrix_char_const_subdiagonal+0x4d>
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  785a <gsl_matrix_char_const_subdiagonal+0x25>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    78bd <gsl_matrix_char_const_subdiagonal+0x88>
mov    0x10(%rsi),%rcx
mov    %rdx,%r8
imul   %rcx,%r8
add    0x18(%rsi),%r8
mov    0x20(%rsi),%rdi
sub    %rdx,%rax
mov    0x8(%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
add    $0x1,%rcx
mov    %rcx,0x8(%rbx)
mov    %r8,0x10(%rbx)
mov    %rdi,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_const_subdiagonal (const gsl_matrix_char * m,
                                    const size_t k)
{
  _gsl_vector_char_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 14
22 12
23 12
24 12
25 12
26 17
27 13
28 13
29 17
30 17
31 17
32 19
33 19
34 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 3621 <info_delete_window+0xb>
cmpq   $0x0,(%rax)
jne    363f <info_delete_window+0x29>
mov    0x0(%rip),%rsi        # 362e <info_delete_window+0x18>
mov    $0x0,%edi
mov    $0x0,%eax
callq  363d <info_delete_window+0x27>
jmp    3698 <info_delete_window+0x82>
testb  $0x2,0x98(%rdi)
je     3666 <info_delete_window+0x50>
mov    $0x0,%edi
callq  3652 <info_delete_window+0x3c>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3664 <info_delete_window+0x4e>
jmp    3698 <info_delete_window+0x82>
callq  366b <info_delete_window+0x55>
cmpl   $0x0,0x0(%rip)        # 3672 <info_delete_window+0x5c>
je     3680 <info_delete_window+0x6a>
mov    0x0(%rip),%rdi        # 367b <info_delete_window+0x65>
callq  3680 <info_delete_window+0x6a>
cmpl   $0x0,0x0(%rip)        # 3687 <info_delete_window+0x71>
je     3693 <info_delete_window+0x7d>
mov    $0x0,%edi
callq  3693 <info_delete_window+0x7d>
callq  7c1 <gc_file_buffers_and_nodes>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_delete_window (WINDOW *window, int count)
{
  if (!windows->next)
    info_error ("%s", msg_cant_kill_last);
  else if (window->flags & 0x02)
    info_error ("%s", gettext ("Cannot delete a permanent window"));
  else
    {
      info_delete_window_internal (window);
      if (auto_footnotes_p)
        info_get_or_remove_footnotes (active_window);
      if (auto_tiling_p)
        window_tile_windows (0);
      gc_file_buffers_and_nodes ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 9
20 10
21 10
22 11
23 11
24 12
25 12
26 13
27 13
28 14
29 16
30 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
movsbl %dil,%ebp
mov    %ebp,%edi
callq  229 <parse822_is_atom_char_ex+0x13>
mov    $0x0,%edx
test   %eax,%eax
jne    246 <parse822_is_atom_char_ex+0x30>
cmp    $0x20,%bl
je     246 <parse822_is_atom_char_ex+0x30>
mov    %ebp,%edi
callq  23e <parse822_is_atom_char_ex+0x28>
test   %eax,%eax
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse822_is_atom_char_ex (char c)
{
  return !mu_parse822_is_special (c)
    && !mu_parse822_is_space (c)
    && !mu_parse822_is_ctl (c);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,0xc(%rsp)
lea    0xc(%rsp),%rdi
callq  5d2 <cdio_get_devices+0x12>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
cdio_get_devices (driver_id_t driver_id)
{
  driver_id_t driver_id_temp = driver_id;
  return cdio_get_devices_ret (&driver_id_temp);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbx
sub    $0xa8,%rsp
mov    %rdi,%r15
mov    %rdx,%r12
mov    %rcx,%r13
mov    %fs:0x28,%rax
mov    %rax,-0x38(%rbp)
xor    %eax,%eax
mov    $0x0,%ebx
cmpb   $0x2f,(%rdx)
je     8d6 <xpw_find_included_file+0x41>
mov    %rsi,%rdi
callq  8d3 <xpw_find_included_file+0x3e>
mov    %rax,%rbx
mov    $0xffffffffffffffff,%rdx
mov    %rbx,%rdi
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %r12,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    -0x2(%rsi,%rdx,1),%rdx
test   %r13,%r13
je     998 <xpw_find_included_file+0x103>
mov    %r13,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
sub    %rcx,%rdx
add    $0x1e,%rdx
and    $0xfffffffffffffff0,%rdx
sub    %rdx,%rsp
lea    0xf(%rsp),%r14
and    $0xfffffffffffffff0,%r14
mov    %r13,%r9
mov    %r12,%r8
mov    $0x2f,%ecx
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %r14,%rdi
mov    $0x0,%eax
callq  94f <xpw_find_included_file+0xba>
test   %rbx,%rbx
je     95c <xpw_find_included_file+0xc7>
mov    %rbx,%rdi
callq  95c <xpw_find_included_file+0xc7>
lea    -0xd0(%rbp),%rsi
mov    %r14,%rdi
callq  96b <xpw_find_included_file+0xd6>
test   %eax,%eax
jne    979 <xpw_find_included_file+0xe4>
mov    %r14,%rdi
callq  977 <xpw_find_included_file+0xe2>
jmp    987 <xpw_find_included_file+0xf2>
mov    %r13,%rdx
mov    %r12,%rsi
mov    %r15,%rdi
callq  987 <xpw_find_included_file+0xf2>
mov    -0x38(%rbp),%rbx
xor    %fs:0x28,%rbx
je     9bc <xpw_find_included_file+0x127>
jmp    9b7 <xpw_find_included_file+0x122>
add    $0x20,%rdx
and    $0xfffffffffffffff0,%rdx
sub    %rdx,%rsp
lea    0xf(%rsp),%r14
and    $0xfffffffffffffff0,%r14
mov    $0x0,%r9d
jmpq   932 <xpw_find_included_file+0x9d>
callq  9bc <xpw_find_included_file+0x127>
lea    -0x28(%rbp),%rsp
pop    %rbx
pop    %r12
pop    %r13
pop    %r14
pop    %r15
pop    %rbp
retq   
<<<sep_in_sample>>>
xpw_find_included_file (char * const *path,
   const char *including_file,
   const char *name, const char *suffix)
{
  char *dir;
  char *res;
  struct stat statbuf;
  if (*name == '/')
    dir = ((void *)0);
  else
    dir = dir_name (including_file);
  res = ((char *) __builtin_alloca (sizeof (char) * ((strlen (dir) + strlen (name) + (suffix ? strlen (suffix) : 0) + 2))))
              ;
  sprintf (res, "%s%c%s%s", dir, '/',
    name, suffix ? suffix : "");
  do { if (dir) free (dir); } while (0);
  if (stat (res, &statbuf) == 0)
    return xstrdup (res);
  return xpw_find_file (path, name, suffix);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 9
16 8
17 8
18 11
19 11
20 11
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 16
54 16
55 16
56 16
57 17
58 17
59 17
60 17
61 17
62 18
63 18
64 18
65 19
66 19
67 19
68 19
69 20
70 20
71 20
72 20
73 12
74 12
75 12
76 12
77 12
78 14
79 14
80 20
81 20
82 20
83 20
84 20
85 20
86 20
87 20
88 20
<<<sep_out_sample>>>
test   %rsi,%rsi
je     a3c <api_register_output_wrapper+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  a38 <api_register_output_wrapper+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
api_register_output_wrapper(awk_ext_id_t id,
  awk_output_wrapper_t *output_wrapper)
{
 (void) id;
 if (output_wrapper == ((void *)0))
  return;
 register_output_wrapper(output_wrapper);
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 7
6 8
7 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x1,%edi
jle    744 <ds_open+0x36>
mov    %rsi,%rbp
mov    0x8(%rsi),%rsi
mov    $0x0,%edi
callq  72c <ds_open+0x1e>
mov    $0x0,%esi
cmp    $0x3,%ebx
jne    73a <ds_open+0x2c>
mov    0x10(%rbp),%rsi
mov    $0x0,%edi
callq  744 <ds_open+0x36>
cmpq   $0x0,0x0(%rip)        # 74c <ds_open+0x3e>
jne    767 <ds_open+0x59>
mov    $0x0,%edi
callq  758 <ds_open+0x4a>
mov    %rax,%rdi
mov    $0x0,%eax
callq  765 <ds_open+0x57>
jmp    775 <ds_open+0x67>
callq  76c <ds_open+0x5e>
nopl   0x0(%rax)
callq  775 <ds_open+0x67>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ds_open(int argc, char **argv)
{
    if (argc > 1) {
 xdico_assign_string(&dico_url.host, argv[1]);
 xdico_assign_string(&dico_url.port,
       argc == 3 ? argv[2] : "2628");
    }
    if (!dico_url.host) {
 script_error(gettext ("Please specify server name or IP address"));
 return;
    }
    ds_silent_close();
    ensure_connection();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 10
25 12
26 12
27 13
28 14
29 14
30 14
31 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%ecx
callq  e47 <do_parse_xmin>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_cmin (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return do_parse_xmin (entry, argv, arg_ptr, XVAL_CTIME);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 260b <c_get_leng+0x7>
retq   
<<<sep_in_sample>>>
c_get_leng (void)
{
        return c_leng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rsi),%r9
cmp    (%rdi),%r9
je     2fc <gsl_vector_float_memcpy+0x2c>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f5 <gsl_vector_float_memcpy+0x25>
mov    $0x13,%eax
jmp    351 <gsl_vector_float_memcpy+0x81>
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r11
test   %r9,%r9
je     345 <gsl_vector_float_memcpy+0x75>
shl    $0x2,%r11
shl    $0x2,%r10
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    0x10(%rsi),%r8
movss  (%r8,%rcx,1),%xmm0
mov    0x10(%rdi),%r8
movss  %xmm0,(%r8,%rdx,1)
add    $0x1,%rax
add    %r11,%rdx
add    %r10,%rcx
cmp    %r9,%rax
jne    320 <gsl_vector_float_memcpy+0x50>
jmp    34b <gsl_vector_float_memcpy+0x7b>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_float_memcpy (gsl_vector_float * dest,
                               const gsl_vector_float * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 11
13 12
14 14
15 14
16 19
17 20
18 20
19 20
20 14
21 20
22 20
23 20
24 20
25 14
26 14
27 14
28 14
29 14
30 14
31 24
32 24
33 24
34 24
35 25
36 25
<<<sep_out_sample>>>
movzbl (%rdi),%eax
test   %al,%al
je     ddb <is_an_empty_command+0x2a>
cmp    $0x3b,%al
je     dca <is_an_empty_command+0x19>
cmp    $0x20,%al
je     dca <is_an_empty_command+0x19>
jmp    de1 <is_an_empty_command+0x30>
cmp    $0x3b,%al
je     dca <is_an_empty_command+0x19>
cmp    $0x20,%al
jne    de7 <is_an_empty_command+0x36>
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
jne    dc2 <is_an_empty_command+0x11>
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
is_an_empty_command(cmd)
    char *cmd;
{
    for (; *cmd; cmd++)
 if (*cmd != ' ' && *cmd != ';')
     return 0;
    return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 4
17 7
18 7
19 7
20 7
21 6
22 6
23 6
24 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
lea    0x28(%rdi),%rsi
mov    %r9,0x8(%rsp)
mov    %r8,(%rsp)
mov    %rcx,%r9
mov    %rdx,%r8
mov    %rax,%rcx
mov    0x0(%rip),%rdx        # 36 <nettle_ccm_aes128_set_nonce+0x24>
callq  3b <nettle_ccm_aes128_set_nonce+0x29>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx,
       size_t length, const uint8_t *nonce,
       size_t authlen, size_t msglen, size_t taglen)
{
  nettle_ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes128_encrypt,
  length, nonce, authlen, msglen, taglen);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
halton_state_size (unsigned int dimension)
{
  return sizeof (halton_state_t);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x14(%rdi),%edx
mov    %edx,(%rsi)
movzwl 0x18(%rdi),%ecx
lea    0x1(%rcx),%edx
mov    %dx,0x18(%rdi)
mov    %dx,0x4(%rsi)
cmpw   $0xffff,0x18(%rdi)
jne    24 <DISxIssueEventID+0x24>
movw   $0x0,0x18(%rdi)
repz retq 
<<<sep_in_sample>>>
DISxIssueEventID(DISxApplicationInfo * info, dis_event_id * event)
{
 event->sim_id = info->id;
 event->event_id = ++info->last_event;
 if (info->last_event == 0xffff) {
  info->last_event = 0;
 }
 return event;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
10 6
11 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  368 <gsl_sort_vector_smallest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_smallest (double * dest, const size_t k,
                                     const gsl_vector * v)
{
  return gsl_sort_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2b <set_parser+0x9>
test   %rax,%rax
je     3e <set_parser+0x1c>
mov    %rax,0x0(%rip)        # 37 <set_parser+0x15>
mov    $0x0,%eax
jmp    43 <set_parser+0x21>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_parser(const char *arg)
{
 grecs_parser_t p = grecs_get_parser_by_type(arg);
 if (p) {
  grecs_parser_fun = p;
  return 0;
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 6
7 6
8 8
9 9
10 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     2cd <gsl_multiroot_fsolver_free+0x3f>
mov    (%rdi),%rax
mov    0x28(%rdi),%rdi
callq  *0x28(%rax)
mov    0x28(%rbx),%rdi
callq  2aa <gsl_multiroot_fsolver_free+0x1c>
mov    0x20(%rbx),%rdi
callq  2b3 <gsl_multiroot_fsolver_free+0x25>
mov    0x10(%rbx),%rdi
callq  2bc <gsl_multiroot_fsolver_free+0x2e>
mov    0x18(%rbx),%rdi
callq  2c5 <gsl_multiroot_fsolver_free+0x37>
mov    %rbx,%rdi
callq  2cd <gsl_multiroot_fsolver_free+0x3f>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multiroot_fsolver_free (gsl_multiroot_fsolver * s)
{
  if (!s) { return ; };
  (s->type->free) (s->state);
  free (s->state);
  gsl_vector_free (s->dx);
  gsl_vector_free (s->x);
  gsl_vector_free (s->f);
  free (s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 9
18 10
19 10
<<<sep_out_sample>>>
mov    $0x0,%edx
jmp    23a <skip_till_newline+0x2d>
cmp    $0x5c,%al
jne    236 <skip_till_newline+0x29>
lea    0x1(%rdi),%rcx
movzbl 0x1(%rdi),%eax
cmp    $0x7d,%al
jne    22c <skip_till_newline+0x1f>
sub    $0x1,%edx
mov    %rcx,%rdi
jmp    236 <skip_till_newline+0x29>
mov    %rcx,%rdi
cmp    $0x7b,%al
jne    236 <skip_till_newline+0x29>
add    $0x1,%edx
add    $0x1,%rdi
movzbl (%rdi),%eax
cmp    $0xa,%al
je     245 <skip_till_newline+0x38>
test   %al,%al
jne    214 <skip_till_newline+0x7>
test   %edx,%edx
jg     214 <skip_till_newline+0x7>
test   %edx,%edx
nopl   0x0(%rax,%rax,1)
jns    26c <skip_till_newline+0x5f>
mov    0x0(%rip),%eax        # 258 <skip_till_newline+0x4b>
test   %eax,%eax
je     26c <skip_till_newline+0x5f>
add    %edx,%eax
mov    $0x0,%edx
cmovs  %edx,%eax
mov    %eax,0x0(%rip)        # 26c <skip_till_newline+0x5f>
lea    0x1(%rdi),%rax
retq   
<<<sep_in_sample>>>
skip_till_newline(char *c)
{
 int lvl = 0;
 while (*c && *c != '\n' || lvl > 0) {
  if (*c == '\\') {
   c++;
   if (*c == '}')
    lvl--;
   else if (*c == '{')
    lvl++;
  }
  c++;
 }
 c++;
 if (lvl < 0 && newline_for_fun) {
  newline_for_fun = newline_for_fun + lvl;
  if (newline_for_fun < 0)
   newline_for_fun = 0;
 }
 return c;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 6
6 7
7 7
8 7
9 8
10 6
11 6
12 6
13 9
14 9
15 10
16 12
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 15
25 15
26 15
27 15
28 15
29 15
30 17
31 16
32 16
33 16
34 20
35 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5b <compute_variance>
sqrtsd %xmm0,%xmm1
ucomisd %xmm1,%xmm1
jnp    687 <gsl_stats_sd_with_fixed_mean+0x1c>
callq  683 <gsl_stats_sd_with_fixed_mean+0x18>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_sd_with_fixed_mean (const double data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_variance (data, stride, n, mean);
  const double sd = sqrt (variance);
  return sd;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
movzbl 0x8(%rdi),%ebp
test   %bpl,%bpl
je     9f <cdio_generic_init+0x28>
mov    $0x0,%edi
mov    $0x0,%eax
callq  98 <cdio_generic_init+0x21>
mov    $0x0,%ebp
jmp    106 <cdio_generic_init+0x8f>
mov    $0x0,%edx
mov    (%rdi),%rdi
mov    $0x0,%eax
callq  b1 <cdio_generic_init+0x3a>
mov    %eax,0x18(%rbx)
test   %eax,%eax
jns    db <cdio_generic_init+0x64>
callq  bd <cdio_generic_init+0x46>
mov    (%rax),%edi
callq  c4 <cdio_generic_init+0x4d>
mov    %rax,%rdx
mov    (%rbx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  d9 <cdio_generic_init+0x62>
jmp    106 <cdio_generic_init+0x8f>
movb   $0x1,0x8(%rbx)
movb   $0x0,0x9(%rbx)
movq   $0x0,0x1028(%rbx)
movq   $0x0,0x15f0(%rbx)
movb   $0x0,0xa(%rbx)
movb   $0x0,0x1e(%rbx)
mov    $0x1,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cdio_generic_init (void *user_data, int open_flags)
{
  generic_img_private_t *p_env = user_data;
  if (p_env->init) {
    cdio_warn ("init called more than once");
    return 0;
  }
  p_env->fd = open (p_env->source_name, open_flags, 0);
  if (p_env->fd < 0)
    {
      cdio_warn ("open (%s): %s", p_env->source_name, strerror ((*__errno_location ())));
      return 0;
    }
  p_env->init = 1;
  p_env->toc_init = 0;
  p_env->cdtext = ((void *)0);
  p_env->scsi_tuple = ((void *)0);
  p_env->b_cdtext_error = 0;
  p_env->u_joliet_level = 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 12
29 14
30 15
31 16
32 17
33 18
34 19
35 20
36 21
37 21
38 21
39 21
40 21
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 7e5 <yyset_out+0x7>
retq   
<<<sep_in_sample>>>
yyset_out (FILE * out_str )
{
        yyout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
length_of_char(const char *c, int *width)
{
    ((void) (0));
 return 1;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
cmp    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
mov    $0x0,%ebx
cmove  %rax,%rbx
mov    %rdi,%rsi
mov    $0x1,%edi
callq  144 <argmatch_invalid+0x26>
mov    %rax,%rbp
mov    %r12,%rdx
mov    $0x6,%esi
mov    $0x0,%edi
callq  159 <argmatch_invalid+0x3b>
mov    %rbp,%r8
mov    %rax,%rcx
mov    %rbx,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  176 <argmatch_invalid+0x58>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
argmatch_invalid (const char *context, const char *value, ptrdiff_t problem)
{
  char const *format = (problem == -1
                        ? ((const char *) ("invalid argument %s for %s"))
                        : ((const char *) ("ambiguous argument %s for %s")));
  error (0, 0, format, quotearg_n_style (0, locale_quoting_style, value),
         quote_n (1, context));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %rbx
callq  61 <xdico_list_iterator+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    78 <xdico_list_iterator+0x1d>
callq  6e <xdico_list_iterator+0x13>
cmpl   $0xc,(%rax)
jne    78 <xdico_list_iterator+0x1d>
callq  78 <xdico_list_iterator+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xdico_list_iterator(dico_list_t list)
{
    dico_iterator_t p = dico_list_iterator(list);
    if (!p && (*__errno_location ()) == 12)
 xalloc_die();
    return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     f0e <internal_info_node_p+0xf>
mov    0x38(%rdi),%eax
shr    $0x4,%eax
and    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
internal_info_node_p (NODE *node)
{
  return (node != ((void *)0)) && (node->flags & 0x10);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
movslq %edi,%rbx
imul   $0x3a8,%rbx,%rbx
mov    %rbx,%rdx
add    0x0(%rip),%rdx        # 2aee <dis_entityExit+0x1c>
mov    $0xffffffff,%eax
cmpl   $0x1,(%rdx)
jne    2b6b <dis_entityExit+0x99>
movl   $0x18,0x2a4(%rdx)
callq  27f5 <sendEntityState>
add    0x0(%rip),%rbx        # 2b0e <dis_entityExit+0x3c>
mov    0x290(%rbx),%rax
test   %rax,%rax
je     2b4f <dis_entityExit+0x7d>
mov    0x38(%rax),%rdi
callq  2b23 <dis_entityExit+0x51>
mov    0x290(%rbx),%rax
mov    0x40(%rax),%rdi
callq  2b33 <dis_entityExit+0x61>
mov    0x290(%rbx),%rax
mov    0x48(%rax),%rdi
callq  2b43 <dis_entityExit+0x71>
mov    0x290(%rbx),%rdi
callq  2b4f <dis_entityExit+0x7d>
movl   $0xffffffff,(%rbx)
mov    $0x0,%eax
cmp    0x0(%rip),%ebp        # 2b60 <dis_entityExit+0x8e>
jne    2b6b <dis_entityExit+0x99>
sub    $0x1,%ebp
mov    %ebp,0x0(%rip)        # 2b6b <dis_entityExit+0x99>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dis_entityExit(int eid)
{
 if (entities[eid].local != 1)
  return -1;
 else {
  entities[eid].appearance = (3 << 3);
  sendEntityState(eid);
  if (entities[eid].em) {
   free(entities[eid].em->s);
   free(entities[eid].em->b);
   free(entities[eid].em->target);
   free(entities[eid].em);
  }
  entities[eid].local = -1;
  if (eid == entity_top) {
   entity_top--;
  }
  return 0;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 4
10 3
11 3
12 6
13 7
14 8
15 8
16 8
17 8
18 9
19 9
20 10
21 10
22 10
23 11
24 11
25 11
26 12
27 12
28 14
29 18
30 15
31 15
32 16
33 16
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  1f1 <_gsasl_cram_md5_server_finish+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_cram_md5_server_finish (Gsasl_session * sctx, void *mech_data)
{
  char *challenge = mech_data;
  free (challenge);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
test   %rsi,%rsi
jne    3dc <swheader_set_current_offset_p+0xe>
lea    0x48(%rdi),%rax
mov    %rax,0x40(%rdi)
retq   
mov    %rsi,0x40(%rdi)
retq   
<<<sep_in_sample>>>
swheader_set_current_offset_p(SWHEADER * swheader, int *n)
{
 if(!n)
  swheader->current_offset_p_=&(swheader->current_offset_);
 else
  swheader->current_offset_p_=n;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 6
7 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
lea    0x10(%rsp),%rdi
movsd  %xmm1,0x8(%rsp)
callq  2af <gsl_sf_bessel_Knu_e+0x19>
mov    %eax,%ebx
movsd  0x0(%rip),%xmm0        # 2b9 <gsl_sf_bessel_Knu_e+0x23>
movsd  0x8(%rsp),%xmm4
xorpd  %xmm0,%xmm4
movapd %xmm4,%xmm0
mov    %rbp,%rdi
movsd  0x18(%rsp),%xmm3
movsd  0x10(%rsp),%xmm2
xorpd  %xmm1,%xmm1
callq  2df <gsl_sf_bessel_Knu_e+0x49>
test   %eax,%eax
cmove  %ebx,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Knu_e(const double nu, const double x, gsl_sf_result * result)
{
  gsl_sf_result b;
  int stat_K = gsl_sf_bessel_Knu_scaled_e(nu, x, &b);
  int stat_e = gsl_sf_exp_mult_err_e(-x, 0.0, b.val, b.err, result);
  return ((stat_e) != GSL_SUCCESS ? (stat_e) : ((stat_K) != GSL_SUCCESS ? (stat_K) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
sub    $0x88,%rsp
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  3a1 <nettle_openssl_des_is_weak_key+0x12>
test   %eax,%eax
sete   %al
movzbl %al,%eax
add    $0x88,%rsp
retq   
<<<sep_in_sample>>>
nettle_openssl_des_is_weak_key(des_cblock *key)
{
  struct des_ctx ctx;
  return !nettle_des_set_key(&ctx, *key);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    $0x16,%edx
test   %rdi,%rdi
je     168 <mu_unre_subject+0x80>
mov    %rsi,%rbp
cmpq   $0x0,0x0(%rip)        # 106 <mu_unre_subject+0x1e>
jne    122 <mu_unre_subject+0x3a>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11c <mu_unre_subject+0x34>
mov    %eax,%edx
test   %eax,%eax
jne    168 <mu_unre_subject+0x80>
mov    $0x0,%r8d
mov    %rsp,%rcx
mov    $0x1,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 13a <mu_unre_subject+0x52>
callq  13f <mu_unre_subject+0x57>
mov    %eax,%edx
test   %eax,%eax
jne    168 <mu_unre_subject+0x80>
mov    0x4(%rsp),%eax
mov    $0x0,%edx
cmp    $0xffffffff,%eax
je     168 <mu_unre_subject+0x80>
test   %rbp,%rbp
je     163 <mu_unre_subject+0x7b>
cltq   
add    %rax,%rbx
mov    %rbx,0x0(%rbp)
jmp    168 <mu_unre_subject+0x80>
mov    $0x0,%edx
mov    %edx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_unre_subject (const char *subject, const char **new_subject)
{
  int rc;
  regmatch_t rm;
  if (!subject)
    return 22;
  if (!re_prefix)
    {
      rc = mu_unre_set_regex (((void *)0), 0, ((void *)0));
      if (rc)
 return rc;
    }
  rc = regexec (re_prefix, subject, 1, &rm, 0);
  if (rc == 0 && rm.rm_eo != -1 && new_subject)
    *new_subject = subject + rm.rm_eo;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 5
7 5
8 5
9 7
10 7
11 9
12 9
13 9
14 9
15 11
16 10
17 10
18 13
19 13
20 13
21 13
22 13
23 13
24 16
25 14
26 14
27 14
28 16
29 14
30 14
31 14
32 14
33 15
34 15
35 15
36 15
37 16
38 17
39 17
40 17
41 17
42 17
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r13
mov    %edx,%ebx
mov    %rcx,%r14
movq   $0x0,(%rcx)
lea    0x180(%rdi),%rbp
mov    %rbp,%rdi
callq  65 <osip_message_header_get_byname+0x26>
cmp    %eax,%ebx
jl     91 <osip_message_header_get_byname+0x52>
jmp    a4 <osip_message_header_get_byname+0x65>
mov    %ebx,%esi
mov    %rbp,%rdi
callq  75 <osip_message_header_get_byname+0x36>
mov    %rax,%r12
mov    %r13,%rsi
mov    (%rax),%rdi
callq  83 <osip_message_header_get_byname+0x44>
test   %eax,%eax
jne    8e <osip_message_header_get_byname+0x4f>
mov    %r12,(%r14)
mov    %ebx,%eax
jmp    a9 <osip_message_header_get_byname+0x6a>
add    $0x1,%ebx
mov    %rbp,%rdi
callq  99 <osip_message_header_get_byname+0x5a>
cmp    %eax,%ebx
jl     6b <osip_message_header_get_byname+0x2c>
mov    $0xffffffff,%eax
jmp    a9 <osip_message_header_get_byname+0x6a>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
osip_message_header_get_byname (const osip_message_t * sip, const char *hname, int pos, osip_header_t ** dest)
{
  int i;
  osip_header_t *tmp;
  *dest = ((void *)0);
  i = pos;
  if (osip_list_size (&sip->headers) <= pos)
    return -1;
  while (osip_list_size (&sip->headers) > i) {
    tmp = (osip_header_t *) osip_list_get (&sip->headers, i);
    if (osip_strcasecmp (tmp->hname, hname) == 0) {
      *dest = tmp;
      return i;
    }
    i++;
  }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 10
19 10
20 11
21 11
22 11
23 11
24 11
25 12
26 13
27 13
28 15
29 9
30 9
31 9
32 9
33 17
34 17
35 8
36 18
37 18
38 18
39 18
40 18
41 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    0x8(%rdi),%r8
cmp    %r8,(%rdi)
jae    1262 <gsl_linalg_QRPT_rcond+0x2f>
mov    $0x13,%ecx
mov    $0x274,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  125b <gsl_linalg_QRPT_rcond+0x28>
mov    $0x13,%eax
jmp    12b7 <gsl_linalg_QRPT_rcond+0x84>
mov    %rsi,%rbp
mov    %rdx,%rbx
lea    (%r8,%r8,2),%rax
cmp    %rax,(%rdx)
je     1291 <gsl_linalg_QRPT_rcond+0x5e>
mov    $0x13,%ecx
mov    $0x278,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  128a <gsl_linalg_QRPT_rcond+0x57>
mov    $0x13,%eax
jmp    12b7 <gsl_linalg_QRPT_rcond+0x84>
mov    %r8,%r9
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  12a9 <gsl_linalg_QRPT_rcond+0x76>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  12b7 <gsl_linalg_QRPT_rcond+0x84>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_linalg_QRPT_rcond(const gsl_matrix * QR, double * rcond, gsl_vector * work)
{
  const size_t M = QR->size1;
  const size_t N = QR->size2;
  if (M < N)
    {
      do { gsl_error ("M must be >= N", "qrpt.c", 628, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else if (work->size != 3 * N)
    {
      do { gsl_error ("work vector must have length 3*N", "qrpt.c", 632, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      gsl_matrix_const_view R = gsl_matrix_const_submatrix (QR, 0, 0, N, N);
      int status;
      status = gsl_linalg_tri_upper_rcond(&R.matrix, rcond, work);
      return status;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 15
27 15
28 15
29 15
30 15
31 15
32 17
33 17
34 17
35 17
36 20
37 20
38 20
39 20
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x0(%rip),%rdx        # 355 <gsl_multilarge_nlinear_default_parameters+0xa>
mov    %rdx,(%rdi)
mov    0x0(%rip),%rdx        # 35f <gsl_multilarge_nlinear_default_parameters+0x14>
mov    %rdx,0x8(%rdi)
mov    0x0(%rip),%rdx        # 36a <gsl_multilarge_nlinear_default_parameters+0x1f>
mov    %rdx,0x10(%rdi)
movl   $0x0,0x18(%rdi)
movsd  0x0(%rip),%xmm0        # 37d <gsl_multilarge_nlinear_default_parameters+0x32>
movsd  %xmm0,0x20(%rdi)
movsd  0x0(%rip),%xmm1        # 38a <gsl_multilarge_nlinear_default_parameters+0x3f>
movsd  %xmm1,0x28(%rdi)
movsd  0x0(%rip),%xmm2        # 397 <gsl_multilarge_nlinear_default_parameters+0x4c>
movsd  %xmm2,0x30(%rdi)
movsd  0x0(%rip),%xmm3        # 3a4 <gsl_multilarge_nlinear_default_parameters+0x59>
movsd  %xmm3,0x38(%rdi)
movsd  0x0(%rip),%xmm4        # 3b1 <gsl_multilarge_nlinear_default_parameters+0x66>
movsd  %xmm4,0x40(%rdi)
movq   $0x0,0x48(%rdi)
movsd  0x0(%rip),%xmm5        # 3c6 <gsl_multilarge_nlinear_default_parameters+0x7b>
movsd  %xmm5,0x50(%rdi)
retq   
<<<sep_in_sample>>>
gsl_multilarge_nlinear_default_parameters(void)
{
  gsl_multilarge_nlinear_parameters params;
  params.trs = gsl_multilarge_nlinear_trs_lm;
  params.scale = gsl_multilarge_nlinear_scale_more;
  params.solver = gsl_multilarge_nlinear_solver_cholesky;
  params.fdtype = GSL_MULTILARGE_NLINEAR_FWDIFF;
  params.factor_up = 3.0;
  params.factor_down = 2.0;
  params.avmax = 0.75;
  params.h_df = 1.4901161193847656e-08;
  params.h_fvv = 0.01;
  params.max_iter = 0;
  params.tol = 1.0e-6;
  return params;
}
<<<sep_in_sample>>>
1 2
2 15
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 16
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r14
mov    %rdx,%r15
mov    %rcx,%r12
mov    %r8d,%r13d
test   %rdi,%rdi
jne    6c7 <emalloc_real+0x46>
mov    $0x71a,%esi
mov    $0x0,%edi
callq  6b2 <emalloc_real+0x31>
mov    %r13d,%edx
mov    %r12,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  6c7 <emalloc_real+0x46>
mov    %rbx,%rdi
callq  6cf <emalloc_real+0x4e>
mov    %rax,%rbp
test   %rax,%rax
jne    726 <emalloc_real+0xa5>
mov    $0x71e,%esi
mov    $0x0,%edi
callq  6e6 <emalloc_real+0x65>
callq  6eb <emalloc_real+0x6a>
mov    (%rax),%edi
callq  6f2 <emalloc_real+0x71>
mov    %rax,0x8(%rsp)
mov    $0x0,%edi
callq  701 <emalloc_real+0x80>
mov    0x8(%rsp),%rcx
mov    %rcx,(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  726 <emalloc_real+0xa5>
mov    %rbp,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
emalloc_real(size_t count, const char *where, const char *var, const char *file, int line)
{
 void *ret;
 if (count == 0)
  (*(set_loc("awk.h", 1818), r_fatal))("%s:%d: emalloc called with zero bytes", file, line);
 ret = (void *) malloc(count);
 if (ret == ((void *)0))
  (*(set_loc("awk.h", 1822), r_fatal))(gettext("%s:%d:%s: %s: can't allocate %ld bytes of memory (%s)"),
   file, line, where, var, (long) count, strerror((*__errno_location ())));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 7
27 7
28 8
29 8
30 8
31 9
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 11
55 11
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    (%rax),%rcx
test   %rdx,%rdx
jle    1e <__gmpz_get_si+0x1e>
movabs $0x7fffffffffffffff,%rax
and    %rcx,%rax
retq   
mov    $0x0,%eax
test   %rdx,%rdx
jns    3c <__gmpz_get_si+0x3c>
sub    $0x1,%rcx
movabs $0x7fffffffffffffff,%rax
and    %rcx,%rax
not    %rax
repz retq 
<<<sep_in_sample>>>
__gmpz_get_si (mpz_srcptr z)
{
  mp_ptr zp = ((z)->_mp_d);
  mp_size_t size = ((z)->_mp_size);
  mp_limb_t zl = zp[0];
  if (size > 0)
    return zl & 9223372036854775807L;
  else if (size < 0)
    return -1 - (long) ((zl - 1) & 9223372036854775807L);
  else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 7
7 7
8 7
9 11
10 8
11 8
12 9
13 9
14 9
15 9
16 12
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x36,%edi
ja     10c <c_isxdigit+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case 'a' + (0): case 'b' + (0): case 'c' + (0): case 'd' + (0): case 'e' + (0): case 'f' + (0): case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 9
9 11
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rbx
movzbl (%rbx),%edi
test   %dil,%dil
je     674 <FlushBuffer+0x22>
add    $0x1,%rbx
movsbl %dil,%edi
callq  66c <FlushBuffer+0x1a>
movzbl (%rbx),%edi
test   %dil,%dil
jne    65f <FlushBuffer+0xd>
mov    $0x10,%edi
callq  67e <FlushBuffer+0x2c>
pop    %rbx
retq   
<<<sep_in_sample>>>
FlushBuffer (PINPUTBUF pibIn)
{
  PBUF pbuf = pibIn->pbufOrg;
  while (*pbuf)
    printf ("%c", *pbuf++);
  printf ("");
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 4
10 4
11 4
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    0x8(%rsi),%rdx
cmp    %rdx,0x8(%rdi)
jne    2e <file_id_comparator+0x1b>
mov    (%rsi),%rax
cmp    %rax,(%rdi)
sete   %al
movzbl %al,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
file_id_comparator (void const *entry1, void const *entry2)
{
  file_id const *e1 = entry1;
  file_id const *e2 = entry2;
  return (e1->ino == e2->ino && e1->dev == e2->dev);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x0,%edi
callq  213 <set_version_width+0x10>
mov    %rax,%rbx
test   %rax,%rax
je     244 <set_version_width+0x41>
movzbl (%rax),%ebp
test   %bpl,%bpl
js     244 <set_version_width+0x41>
callq  228 <set_version_width+0x25>
movsbq %bpl,%rbp
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rbp,2)
je     244 <set_version_width+0x41>
mov    %rbx,%rdi
callq  23e <set_version_width+0x3b>
mov    %eax,0x0(%rip)        # 244 <set_version_width+0x41>
cmpl   $0x10,0x0(%rip)        # 24b <set_version_width+0x48>
jle    257 <set_version_width+0x54>
movl   $0x10,0x0(%rip)        # 257 <set_version_width+0x54>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_version_width (void)
{
    char *v = getenv ("VERSION_WIDTH");
    if (v && ((((*v) & ~0x7f) == 0) && ((*__ctype_b_loc ())[(int) ((*v))] & (unsigned short int) _ISdigit)))
    {
        version_width = atoi (v);
    }
    if (version_width > 16)
    {
        version_width = 16;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 6
18 6
19 6
20 8
21 8
22 10
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rdi
callq  3b3 <xformat_set_uid_by_name+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_set_uid_by_name (XFORMAT * xux, char * username)
{
 ;
 ahs_set_uid_by_name(xux->ahsM, username);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     848 <reset_clixpath+0x25>
mov    $0x1,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  83e <reset_clixpath+0x1b>
mov    %rbx,%rdi
callq  846 <reset_clixpath+0x23>
jmp    852 <reset_clixpath+0x2f>
mov    $0x0,%edi
callq  852 <reset_clixpath+0x2f>
pop    %rbx
retq   
<<<sep_in_sample>>>
reset_clixpath (char *old_classpath)
{
  if (old_classpath != ((void *)0))
    {
      xsetenv ("LD_LIBRARY_PATH", old_classpath, 1);
      free (old_classpath);
    }
  else
    unsetenv ("LD_LIBRARY_PATH");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 9
13 9
14 10
15 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     413 <yy_flush_buffer+0x4f>
movl   $0x0,0x20(%rdi)
mov    0x8(%rdi),%rax
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
mov    %rax,0x10(%rdi)
movl   $0x1,0x2c(%rdi)
movl   $0x0,0x3c(%rdi)
mov    0x0(%rip),%rax        # 3fc <yy_flush_buffer+0x38>
test   %rax,%rax
je     413 <yy_flush_buffer+0x4f>
mov    0x0(%rip),%rdx        # 408 <yy_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
jne    413 <yy_flush_buffer+0x4f>
callq  af <yy_load_buffer_state>
repz retq 
<<<sep_in_sample>>>
yy_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 7
8 8
9 8
10 9
11 10
12 11
13 11
14 11
15 11
16 11
17 11
18 12
19 12
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x8(%rsi),%rax
cmp    %rax,%rdx
jb     14 <direntry_cmp_inode+0x14>
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x60(%rdi),%rdx
lea    0x20(%rdi),%rdi
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # a0 <nettle_eax_aes128_encrypt+0x20>
mov    %rax,%rsi
callq  a8 <nettle_eax_aes128_encrypt+0x28>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nettle_eax_aes128_encrypt(struct eax_aes128_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes128_encrypt) (&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_eax_encrypt (&(ctx)->eax, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x10,%edi
callq  107 <gsl_rng_alloc+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    12f <gsl_rng_alloc+0x3b>
mov    $0x8,%ecx
mov    $0x24,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  128 <gsl_rng_alloc+0x34>
mov    $0x0,%eax
jmp    183 <gsl_rng_alloc+0x8f>
mov    0x18(%rbp),%rsi
mov    $0x1,%edi
callq  13d <gsl_rng_alloc+0x49>
mov    %rax,0x8(%rbx)
test   %rax,%rax
jne    16e <gsl_rng_alloc+0x7a>
mov    %rbx,%rdi
callq  14e <gsl_rng_alloc+0x5a>
mov    $0x8,%ecx
mov    $0x2e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  167 <gsl_rng_alloc+0x73>
mov    $0x0,%eax
jmp    183 <gsl_rng_alloc+0x8f>
mov    %rbp,(%rbx)
mov    0x0(%rip),%rsi        # 178 <gsl_rng_alloc+0x84>
mov    %rbx,%rdi
callq  180 <gsl_rng_alloc+0x8c>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_rng_alloc (const gsl_rng_type * T)
{
  gsl_rng *r = (gsl_rng *) malloc (sizeof (gsl_rng));
  if (r == 0)
    {
      do { gsl_error ("failed to allocate space for rng struct",
 "rng.c"
      ,
 36
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    };
  r->state = calloc (1, T->size);
  if (r->state == 0)
    {
      free (r);
      do { gsl_error ("failed to allocate space for rng state",
 "rng.c"
      ,
 46
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    };
  r->type = T;
  gsl_rng_set (r, gsl_rng_default_seed);
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 10
16 10
17 13
18 13
19 13
20 13
21 14
22 14
23 16
24 16
25 17
26 17
27 17
28 17
29 17
30 21
31 21
32 24
33 25
34 25
35 25
36 26
37 27
38 27
39 27
40 27
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    $0x0,%edx
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  70 <assign_time_option+0x23>
test   %rdx,%rdx
js     7f <assign_time_option+0x32>
mov    0x8(%rsp),%rdx
cmpb   $0x0,(%rdx)
je     ba <assign_time_option+0x6d>
mov    0x0(%rip),%rax        # 86 <assign_time_option+0x39>
test   %rax,%rax
je     8d <assign_time_option+0x40>
callq  *%rax
mov    $0x0,%edi
callq  97 <assign_time_option+0x4a>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  ae <assign_time_option+0x61>
movl   $0x2,0x0(%rip)        # b8 <assign_time_option+0x6b>
jmp    c9 <assign_time_option+0x7c>
mov    %rax,(%r12)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  c9 <assign_time_option+0x7c>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
assign_time_option (char **sval, time_t *tval, const char *input)
{
  char *p;
  struct timespec t = decode_timespec (input, &p, 0);
  if (! valid_timespec (t) || *p)
    do { if (error_hook) error_hook (); error (0, 0, gettext ("Time stamp is out of allowed range")); exit_status = 2; } while (0);
  else
    {
      *tval = t.tv_sec;
      assign_string (sval, input);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 9
31 10
32 10
33 10
34 12
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 131 <yy_fatal_error+0x13>
mov    $0x0,%eax
callq  13b <yy_fatal_error+0x1d>
mov    $0x2,%edi
callq  145 <yy_pop_state>
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%ebp
test   %edx,%edx
jne    125f <swvarfs_open+0x48>
test   %rdi,%rdi
je     125b <swvarfs_open+0x44>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
je     125b <swvarfs_open+0x44>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  1257 <swvarfs_open+0x40>
test   %eax,%eax
jne    1269 <swvarfs_open+0x52>
mov    0x18(%rsp),%ebp
test   %rbx,%rbx
je     12a6 <swvarfs_open+0x8f>
mov    $0x0,%eax
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
je     12a6 <swvarfs_open+0x8f>
test   %eax,%eax
jne    12a6 <swvarfs_open+0x8f>
mov    %ebp,%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     129c <swvarfs_open+0x85>
cmp    $0x4000,%ebp
jne    12a6 <swvarfs_open+0x8f>
mov    %rbx,%rdi
callq  12a4 <swvarfs_open+0x8d>
jmp    12b1 <swvarfs_open+0x9a>
mov    %r12d,%esi
mov    %rbx,%rdi
callq  12b1 <swvarfs_open+0x9a>
add    $0x90,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swvarfs_open(char * name, int oflags, mode_t p_mode)
{
 SWVARFS * rval;
 int statrc = 0;
 mode_t mode = 0;
 struct stat stbuf;
 ;
 if (p_mode == 0) {
  if (name && strcmp(name, "-") != 0)
   statrc = stat(name, &stbuf);
  if (statrc == 0)
   mode = stbuf.st_mode;
 } else {
  mode = p_mode;
 }
 if (name && strcmp(name,"-") && statrc == 0 &&
   (((((mode)) & 0170000) == (0040000)) || mode == 0040000)
 ) {
  rval = swvarfs_open_directory(name);
 } else {
  rval = swvarfs_open_archive_file(name, oflags);
 }
 return rval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 8
9 8
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 11
24 11
25 12
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 17
40 17
41 16
42 16
43 17
44 17
45 19
46 19
47 19
48 21
49 21
50 21
51 24
52 24
53 24
54 24
55 24
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
movq   $0x1,(%rdi)
movq   $0x1,0x8(%rdi)
mov    $0x8,%edi
callq  11e1 <re_node_set_init_1+0x25>
mov    %rax,0x10(%rbx)
test   %rax,%rax
jne    11fd <re_node_set_init_1+0x41>
movq   $0x0,0x8(%rbx)
movq   $0x0,(%rbx)
mov    $0xc,%al
jmp    1205 <re_node_set_init_1+0x49>
mov    %rbp,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
re_node_set_init_1 (re_node_set *set, Idx elem)
{
  set->alloc = 1;
  set->nelem = 1;
  set->elems = ((Idx *) malloc ((1) * sizeof (Idx)));
  if (__builtin_expect (set->elems == ((void *)0), 0))
    {
      set->alloc = set->nelem = 0;
      return _REG_ESPACE;
    }
  set->elems[0] = elem;
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 6
12 6
13 8
14 8
15 9
16 9
17 11
18 12
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    91 <xnrealloc+0x20>
callq  91 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  9a <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  182 <scram_print_server_first+0x11>
mov    $0xffffffff,%edx
test   %al,%al
je     1c0 <scram_print_server_first+0x4f>
mov    0x8(%rbx),%rcx
mov    0x10(%rbx),%r8
mov    (%rbx),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  1a8 <scram_print_server_first+0x37>
test   %eax,%eax
jle    1bb <scram_print_server_first+0x4a>
cmpq   $0x0,0x0(%rbp)
sete   %dl
movzbl %dl,%edx
neg    %edx
jmp    1c0 <scram_print_server_first+0x4f>
mov    $0xffffffff,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
scram_print_server_first (struct scram_server_first *sf, char **out)
{
  int n;
  if (!scram_valid_server_first (sf))
    return -1;
  n = asprintf (out, "r=%s,s=%s,i=%lu",
  sf->nonce, sf->salt, (unsigned long) sf->iter);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <isword+0x8>
movslq %ebx,%rcx
mov    (%rax),%rdx
mov    $0x1,%eax
testb  $0x8,(%rdx,%rcx,2)
jne    22 <isword+0x22>
cmp    $0x5f,%ebx
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
isword(int c) { return ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISalnum) || c == '_'; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xca,%edx
callq  3e3 <ranlxd_set_lux>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ranlxd1_set (void *vstate, unsigned long int s)
{
  ranlxd_set_lux (vstate, s, 202);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm1
movsd  %xmm0,0x8(%rsp)
xorpd  %xmm0,%xmm0
mov    $0x0,%eax
ucomisd %xmm1,%xmm0
jbe    30a <isnegint+0x40>
movapd %xmm1,%xmm0
callq  2f0 <isnegint+0x26>
movsd  0x8(%rsp),%xmm2
ucomisd %xmm0,%xmm2
setnp  %dl
movzbl %dl,%edx
mov    $0x0,%eax
cmove  %edx,%eax
jmp    30a <isnegint+0x40>
cvtsi2sd %eax,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
isnegint (const double x)
{
  return (x < 0) && (x == floor(x));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
19 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     307 <free_name+0x23>
mov    0x10(%rdi),%rdi
callq  2f6 <free_name+0x12>
mov    0x58(%rbx),%rdi
callq  2ff <free_name+0x1b>
mov    %rbx,%rdi
callq  307 <free_name+0x23>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_name (struct name *p)
{
  if (p)
    {
      free (p->name);
      free (p->caname);
      free (p);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 7
10 7
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x0(%rip),%rax        # 7bd <copystring+0x13>
mov    0x1a8(%rax),%rdi
mov    $0x0,%edx
callq  7ce <copystring+0x24>
mov    0x0(%rip),%rax        # 7d5 <copystring+0x2b>
mov    0x1a0(%rax),%rdi
test   %rdi,%rdi
je     7e9 <copystring+0x3f>
mov    %rbx,%rsi
callq  7e9 <copystring+0x3f>
mov    0x10(%rbx),%rax
add    %rax,0x18(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
copystring (struct editstuff *es, struct atat *atat)
{
  atat_display ((top->flow. res), atat, 0);
  if ((top->flow. to))
    atat_put ((top->flow. to), atat);
  es->lcount += atat->line_count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebx
mov    %rdx,%rbp
callq  5e87 <Fcntl+0x10>
mov    %rbp,%rdx
mov    %ebx,%esi
mov    %eax,%edi
mov    $0x0,%eax
callq  5e98 <Fcntl+0x21>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
Fcntl(FD_t fd, int op, void *lip) {
    return fcntl(Fileno(fd), op, lip);
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 2
7 2
8 2
9 2
10 2
11 2
12 3
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x50(%r8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, start_index, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x1,%esi
callq  1f <ttsetattr+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ttsetattr(fd, ttp)
int fd;
struct termios *ttp;
{
  return tcsetattr(fd, 1, ttp);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     25c <gsl_block_complex_free+0x1a>
mov    0x8(%rdi),%rdi
callq  254 <gsl_block_complex_free+0x12>
mov    %rbx,%rdi
callq  25c <gsl_block_complex_free+0x1a>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_complex_free (gsl_block_complex * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%eax        # 120a <drawScrollBar+0xc>
lea    -0x5(%rax),%ebp
mov    0x0(%rip),%esi        # 1213 <drawScrollBar+0x15>
mov    0x0(%rip),%edi        # 1219 <drawScrollBar+0x1b>
callq  121e <drawScrollBar+0x20>
test   %ebp,%ebp
js     1246 <drawScrollBar+0x48>
mov    $0x0,%ebx
lea    0x3(%rbx),%esi
mov    0x0(%rip),%edx        # 1230 <drawScrollBar+0x32>
mov    $0x0,%edi
mov    $0x0,%eax
callq  123f <drawScrollBar+0x41>
add    $0x1,%ebx
cmp    %ebx,%ebp
jge    1227 <drawScrollBar+0x29>
mov    0x0(%rip),%eax        # 124c <drawScrollBar+0x4e>
add    0x0(%rip),%eax        # 1252 <drawScrollBar+0x54>
add    $0x1,%eax
cvtsi2sd %eax,%xmm0
cvtsi2sdl 0x0(%rip),%xmm2        # 1261 <drawScrollBar+0x63>
cvtsi2sd %ebp,%xmm1
divsd  %xmm2,%xmm0
mulsd  %xmm1,%xmm0
movapd %xmm0,%xmm1
cmpnltsd 0x0(%rip),%xmm1        # 127a <drawScrollBar+0x7c>
andpd  %xmm1,%xmm0
mov    0x0(%rip),%eax        # 1284 <drawScrollBar+0x86>
sub    $0x5,%eax
cvtsi2sd %eax,%xmm3
minsd  %xmm0,%xmm3
movsd  %xmm3,0x8(%rsp)
mov    0x0(%rip),%esi        # 129b <drawScrollBar+0x9d>
mov    0x0(%rip),%edi        # 12a1 <drawScrollBar+0xa3>
callq  12a6 <drawScrollBar+0xa8>
cvttsd2si 0x8(%rsp),%esi
add    $0x3,%esi
mov    $0xb1,%ecx
mov    0x0(%rip),%edx        # 12ba <drawScrollBar+0xbc>
mov    $0x0,%edi
mov    $0x0,%eax
callq  12c9 <drawScrollBar+0xcb>
mov    0x0(%rip),%eax        # 12cf <drawScrollBar+0xd1>
mov    0x0(%rip),%edx        # 12d5 <drawScrollBar+0xd7>
lea    0x2(%rdx,%rax,1),%ecx
mov    0x0(%rip),%eax        # 12df <drawScrollBar+0xe1>
lea    0x3(%rax),%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 12ee <drawScrollBar+0xf0>
mov    $0x0,%eax
callq  12f8 <drawScrollBar+0xfa>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
drawScrollBar()
{
  int h = SCREEN_H-5;
  int i;
  setScreenColors(FG_COLOR[0], BG_COLOR[1]);
  for(i = 0; i <= h; i++)
    printf("\e[%d;%dH ", i+3, SCREEN_W);
  double h2;
  h2 = firstVisLine+selectedLine+1;
  h2 /= totalLines;
  h2 *= h;
  if(h2 < 0) h2 = 0;
  if(h2 > (SCREEN_H-5)) h2 = SCREEN_H-5;
  setScreenColors(FG_COLOR[0], BG_COLOR[0]);
  printf("\e[%d;%dH%c", (int)(h2)+3, SCREEN_W, 177);
  fprintf(stdout, "\e[%d;%dH", selectedLine+3, selectedChar+2+selectedCharCarry);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 6
18 6
19 6
20 9
21 9
22 9
23 9
24 10
25 11
26 11
27 12
28 12
29 12
30 12
31 13
32 13
33 13
34 13
35 13
36 14
37 14
38 14
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 16
47 16
48 16
49 16
50 16
51 16
52 16
53 16
54 16
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xc(%rdi),%edi
test   %edi,%edi
js     11bb <coproc_close+0x17>
callq  11b4 <coproc_close+0x10>
movl   $0xffffffff,0xc(%rbx)
mov    0x10(%rbx),%edi
test   %edi,%edi
js     11ce <coproc_close+0x2a>
callq  11c7 <coproc_close+0x23>
movl   $0xffffffff,0x10(%rbx)
movl   $0xffffffff,0x18(%rbx)
movl   $0xffffffff,0x14(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
coproc_close (cp)
     struct coproc *cp;
{
  if (cp->c_rfd >= 0)
    {
      close (cp->c_rfd);
      cp->c_rfd = -1;
    }
  if (cp->c_wfd >= 0)
    {
      close (cp->c_wfd);
      cp->c_wfd = -1;
    }
  cp->c_rsave = cp->c_wsave = -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 6
7 7
8 9
9 9
10 9
11 11
12 12
13 14
14 14
15 15
16 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    0x10(%rdi),%rsi
mov    0x8(%rdi),%rdi
callq  51 <_dico_list_remove_item>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dico_iterator_remove_current(dico_iterator_t ip, void **pptr)
{
    _dico_list_remove_item(ip->list, ip->cur, pptr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     97f <mu_stream_sequential_printf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  9b0 <mu_stream_sequential_printf+0x87>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mu_stream_sequential_printf (mu_stream_t os, const char *fmt, ...)
{
  va_list ap;
  int rc;
  __builtin_va_start(ap,fmt);
  rc = mu_stream_sequential_vprintf (os, fmt, ap);
  __builtin_va_end(ap);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 9
25 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rdx,%rdi
sar    $0x3f,%rdi
mov    %rdi,%rcx
xor    %rdx,%rcx
sub    %rdi,%rcx
test   %rcx,%rcx
jle    30 <__gmpz_roinit_n+0x30>
cmpq   $0x0,-0x8(%rsi,%rcx,8)
je     2a <__gmpz_roinit_n+0x2a>
jmp    30 <__gmpz_roinit_n+0x30>
cmpq   $0x0,-0x8(%rsi,%rcx,8)
jne    30 <__gmpz_roinit_n+0x30>
sub    $0x1,%rcx
jne    22 <__gmpz_roinit_n+0x22>
movl   $0x0,(%rax)
mov    %ecx,%edi
neg    %edi
test   %rdx,%rdx
cmovs  %edi,%ecx
mov    %ecx,0x4(%rax)
mov    %rsi,0x8(%rax)
retq   
<<<sep_in_sample>>>
__gmpz_roinit_n (mpz_ptr x, mp_srcptr xp, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((xp)[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_alloc) = 0;
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
  ((x)->_mp_d) = (mp_ptr) xp;
  return x;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 6
18 6
19 6
20 6
21 6
22 7
23 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
movl   $0x8,(%rdi)
test   %rsi,%rsi
je     d21 <set_custom_quoting+0x20>
test   %rdx,%rdx
jne    d26 <set_custom_quoting+0x25>
callq  d26 <set_custom_quoting+0x25>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 6
6 7
7 7
8 7
9 7
10 8
11 9
12 10
13 11
14 11
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
callq  0 <randomize>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_pseudo_random (char *data, size_t datalen)
{
  return randomize (1, data, datalen);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rsi        # 555e <unbind_nameref+0xb>
callq  5563 <unbind_nameref+0x10>
test   %rax,%rax
je     5583 <unbind_nameref+0x30>
mov    0x28(%rax),%eax
and    $0x800,%eax
je     5588 <unbind_nameref+0x35>
mov    0x0(%rip),%rsi        # 5579 <unbind_nameref+0x26>
mov    %rbx,%rdi
callq  5581 <unbind_nameref+0x2e>
jmp    5588 <unbind_nameref+0x35>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
unbind_nameref (name)
     const char *name;
{
  SHELL_VAR *v;
  v = var_lookup (name, shell_variables);
  if (v && ((((v)->attributes) & (0x0000800))))
    return makunbound (name, shell_variables);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 8
15 9
16 9
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 15 <sig_restart+0xa>
retq   
<<<sep_in_sample>>>
sig_restart(int sig)
{
    restart = 1;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x80,%ecx
mov    $0x10,%esi
callq  56b <nettle_arctwo128_set_key+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_arctwo128_set_key (struct arctwo_ctx *ctx, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, 16, key, 128);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rdx,%r13
movq   $0x0,(%rdx)
test   %rdi,%rdi
je     10e <__osip_find_next_occurence+0x9a>
mov    %rsi,%rbx
mov    %rcx,%r14
test   %rsi,%rsi
je     10e <__osip_find_next_occurence+0x9a>
mov    $0x3e8,%ebp
mov    $0xffffffffffffffff,%r15
mov    %r12,%rsi
mov    %rbx,%rdi
callq  b6 <__osip_find_next_occurence+0x42>
mov    %rax,0x0(%r13)
test   %rax,%rax
jne    115 <__osip_find_next_occurence+0xa1>
mov    %rbx,%rdi
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rbx
mov    %r14,%rax
sub    %rbx,%rax
test   %rax,%rax
jle    11c <__osip_find_next_occurence+0xa8>
add    $0x1,%rbx
sub    $0x1,%ebp
jne    ab <__osip_find_next_occurence+0x37>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x1,%edx
mov    $0x114,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  107 <__osip_find_next_occurence+0x93>
mov    $0xfffffffb,%eax
jmp    121 <__osip_find_next_occurence+0xad>
mov    $0xfffffffe,%eax
jmp    121 <__osip_find_next_occurence+0xad>
mov    $0x0,%eax
jmp    121 <__osip_find_next_occurence+0xad>
mov    $0xfffffffb,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
__osip_find_next_occurence (const char *str, const char *buf, const char **index_of_str, const char *end_of_buf)
{
  int i;
  *index_of_str = ((void *)0);
  if ((((void *)0) == str) || (((void *)0) == buf))
    return -2;
  for (i = 0; i < 1000; i++) {
    *index_of_str = strstr (buf, str);
    if (((void *)0) == (*index_of_str)) {
      const char *ptr = buf + strlen (buf);
      if (end_of_buf - ptr > 0) {
        buf = ptr + 1;
        continue;
      }
      return -5;
    }
    return 0;
  }
  osip_trace ("osip_message_parse.c", 276, TRACE_LEVEL1, ((void *)0), "This was probably an infinite loop?\n");
  return -5;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 10
19 8
20 8
21 8
22 8
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 12
35 7
36 7
37 19
38 19
39 19
40 19
41 19
42 19
43 19
44 20
45 20
46 6
47 6
48 17
49 17
50 15
51 21
52 21
53 21
54 21
55 21
56 21
57 21
58 21
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%r15
lea    0x0(%rip),%r12        # 21b <replace_minus+0x18>
mov    %r12,0x10(%rsp)
lea    0x0(%rip),%rax        # 227 <replace_minus+0x24>
mov    %rax,0x18(%rsp)
lea    0x0(%rip),%rax        # 233 <replace_minus+0x30>
mov    %rax,0x20(%rsp)
movq   $0x0,0x28(%rsp)
lea    0x10(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    $0xffffffffffffffff,%r14
mov    $0x0,%r13d
mov    %r15,%rbp
mov    %r15,%rbx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  269 <replace_minus+0x66>
mov    %rax,%r8
test   %rax,%rax
je     2f5 <replace_minus+0xf2>
cmp    %rax,%rbx
jae    2a0 <replace_minus+0x9d>
mov    %rbp,%rcx
mov    %rbx,%rdx
add    $0x1,%rcx
add    $0x1,%rdx
movzbl -0x1(%rdx),%esi
mov    %sil,-0x1(%rcx)
cmp    %r8,%rdx
jne    280 <replace_minus+0x7d>
mov    %r8,%rax
sub    %rbx,%rax
add    %rbp,%rax
jmp    2a3 <replace_minus+0xa0>
mov    %rbp,%rax
lea    0x1(%rax),%rbp
movb   $0x2d,(%rax)
mov    %r12,%rdi
mov    %r14,%rcx
mov    %r13d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r8,%rcx,1),%rbx
jmp    25e <replace_minus+0x5b>
movzbl (%rbx),%eax
test   %al,%al
je     2d8 <replace_minus+0xd5>
add    $0x1,%rbp
add    $0x1,%rbx
mov    %al,-0x1(%rbp)
movzbl (%rbx),%eax
test   %al,%al
jne    2c6 <replace_minus+0xc3>
movb   $0x0,0x0(%rbp)
addq   $0x8,0x8(%rsp)
mov    0x8(%rsp),%rax
mov    (%rax),%r12
test   %r12,%r12
jne    258 <replace_minus+0x55>
jmp    302 <replace_minus+0xff>
cmp    %r15,%rbx
ja     2bf <replace_minus+0xbc>
nopw   0x0(%rax,%rax,1)
jmp    2dc <replace_minus+0xd9>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
replace_minus(char *input)
{
  char *unicode_minus[] = {
    "\xE2\x80\x92",
    "\xE2\x80\x93",
    "\xE2\x88\x92",
    0
  };
  char *inptr, *outptr, *ptr, **minus;
  for (minus=unicode_minus; *minus; minus++) {
    inptr = outptr = input;
    do {
      ptr = strstr(inptr, *minus);
      if (ptr) {
        while (inptr < ptr)
          *outptr++ = *inptr++;
        *outptr++ = '-';
        inptr = ptr + strlen(*minus);
      }
    } while (ptr);
    if (inptr > input) {
      while (*inptr)
        *outptr++ = *inptr++;
      *outptr = '\0';
    }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 10
17 10
18 18
19 18
20 10
21 10
22 13
23 13
24 13
25 13
26 14
27 14
28 15
29 15
30 15
31 15
32 16
33 16
34 16
35 16
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 17
44 17
45 18
46 18
47 18
48 18
49 18
50 18
51 18
52 22
53 22
54 22
55 23
56 23
57 23
58 22
59 22
60 22
61 24
62 10
63 10
64 10
65 10
66 10
67 10
68 21
69 21
70 21
71 21
72 27
73 27
74 27
75 27
76 27
77 27
78 27
79 27
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  351 <find_directory>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dir_name (const char *dir)
{
  return find_directory (dir)->name;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a9f <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     aaa <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
movl   $0x0,0x0(%rip)        # ab4 <rl_on_new_line+0x1c>
movl   $0x0,0x0(%rip)        # abe <rl_on_new_line+0x26>
movl   $0x0,0x0(%rip)        # ac8 <rl_on_new_line+0x30>
movl   $0x0,0x0(%rip)        # ad2 <rl_on_new_line+0x3a>
mov    0x8(%rax),%rax
test   %rax,%rax
je     ae8 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # af2 <rl_on_new_line+0x5a>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 8
14 8
15 9
16 11
17 11
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edx
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 44d4 <rl_clear_visible_line+0x12>
callq  44d9 <rl_clear_visible_line+0x17>
movl   $0x0,0x0(%rip)        # 44e3 <rl_clear_visible_line+0x21>
mov    0x0(%rip),%edi        # 44e9 <rl_clear_visible_line+0x27>
callq  44ee <rl_clear_visible_line+0x2c>
mov    0x0(%rip),%ebx        # 44f4 <rl_clear_visible_line+0x32>
test   %ebx,%ebx
js     4511 <rl_clear_visible_line+0x4f>
mov    %ebx,%edi
callq  44ff <rl_clear_visible_line+0x3d>
mov    $0x0,%edi
callq  4509 <rl_clear_visible_line+0x47>
sub    $0x1,%ebx
cmp    $0xffffffff,%ebx
jne    44f8 <rl_clear_visible_line+0x36>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_clear_visible_line ()
{
  int curr_line;
  tputs (_rl_term_cr, 1, _rl_output_character_function);
  _rl_last_c_pos = 0;
  _rl_move_vert (_rl_vis_botlin);
  for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)
    {
      _rl_move_vert (curr_line);
      _rl_clear_to_eol (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 6
8 6
9 7
10 7
11 7
12 9
13 9
14 10
15 10
16 7
17 7
18 7
19 13
20 13
21 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1605 <gsl_complex_arcsec+0x9>
callq  160a <gsl_complex_arcsec+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_arcsec (gsl_complex a)
{
  gsl_complex z = gsl_complex_inverse (a);
  return gsl_complex_arccos (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
callq  e <__argmatch_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
argcasematch (const char *arg, const char *const *arglist,
       const char *vallist, size_t valsize)
{
  return __argmatch_internal (arg, arglist, vallist, valsize, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x3,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x4,0x10(%rdi)
movq   $0x1,0x18(%rdi)
movsd  0x0(%rip),%xmm0        # 163 <InitIntegratorSpec+0x2a>
movsd  %xmm0,0x20(%rdi)
movsd  %xmm0,0x28(%rdi)
movq   $0xde,0x30(%rdi)
movq   $0x12c,0x40(%rdi)
movq   $0x1770,0x48(%rdi)
mov    $0x12c,%edi
callq  18f <InitIntegratorSpec+0x56>
mov    %rax,0x50(%rbx)
test   %rax,%rax
je     1aa <InitIntegratorSpec+0x71>
mov    0x48(%rbx),%rdi
callq  1a1 <InitIntegratorSpec+0x68>
mov    %rax,0x58(%rbx)
test   %rax,%rax
jne    1c3 <InitIntegratorSpec+0x8a>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8004,%esi
mov    $0x0,%edi
callq  1c3 <InitIntegratorSpec+0x8a>
movsd  0x0(%rip),%xmm1        # 1cb <InitIntegratorSpec+0x92>
movsd  %xmm1,0x60(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
InitIntegratorSpec (PINTSPEC pis)
{
  pis->iAlgo = 3;
  pis->iopt = (0);
  pis->itask = (4);
  pis->itol = (1);
  pis->dRtol = (1.0e-5);
  pis->dAtol = (1.0e-5);
  pis->iMf = (222);
  pis->liw = 300;
  pis->lrw = 6000;
  if ( !(pis->iwork = InitlVector (pis->liw)) ||
       !(pis->rwork = InitdVector (pis->lrw)))
    ReportError (((void *)0), 0x0004 | 0x8000,
                 "InitIntegratorSpec()", ((void *)0));
  pis->dTStep = (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 6
7 7
8 7
9 8
10 9
11 10
12 11
13 12
14 12
15 12
16 12
17 12
18 13
19 13
20 13
21 12
22 12
23 14
24 14
25 14
26 14
27 14
28 16
29 16
30 17
31 17
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
callq  a12 <equality_term>
mov    %eax,%ecx
test   %eax,%eax
jne    b19 <and_term+0x66>
jmp    aec <and_term+0x39>
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
test   %eax,%eax
je     b10 <and_term+0x5d>
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  a12 <equality_term>
test   %eax,%eax
jne    b17 <and_term+0x64>
mov    0xc(%rsp),%eax
and    %eax,(%rbx)
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
cmp    $0x15,%eax
je     ac8 <and_term+0x15>
mov    $0x6,%ecx
test   %eax,%eax
je     b19 <and_term+0x66>
callq  0 <eval_undo>
mov    $0x0,%ecx
jmp    b19 <and_term+0x66>
mov    $0x6,%ecx
jmp    b19 <and_term+0x66>
mov    %eax,%ecx
mov    %ecx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
and_term (eval_token et, int32_t *v1)
{
  int32_t v2;
  eval_error er;
  if ((er = equality_term (et, v1)) != NO_ERROR)
    return er;
  while ((et = eval_lex (&v2)) == AND)
    {
      et = eval_lex (&v2);
      if (et == ERROR)
        return UNKNOWN_INPUT;
      if ((er = equality_term (et, &v2)) != NO_ERROR)
        return er;
      *v1 &= v2;
    }
  if (et == ERROR)
    return UNKNOWN_INPUT;
  eval_undo ();
  return NO_ERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 6
6 5
7 5
8 5
9 9
10 9
11 10
12 10
13 12
14 12
15 12
16 12
17 12
18 14
19 14
20 7
21 7
22 7
23 7
24 17
25 16
26 16
27 18
28 19
29 19
30 11
31 11
32 12
33 20
34 20
35 20
36 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    49f <gsl_permute_matrix_complex+0x29>
mov    $0x0,%ebx
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     4e7 <gsl_permute_matrix_complex+0x71>
jmp    4bf <gsl_permute_matrix_complex+0x49>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b8 <gsl_permute_matrix_complex+0x42>
mov    $0x13,%eax
jmp    4e7 <gsl_permute_matrix_complex+0x71>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  4cd <gsl_permute_matrix_complex+0x57>
mov    %rsp,%rsi
mov    %r12,%rdi
callq  4d8 <gsl_permute_matrix_complex+0x62>
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     4bf <gsl_permute_matrix_complex+0x49>
mov    $0x0,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_permute_matrix_complex (const gsl_permutation * p, gsl_matrix_complex * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_complex_view r = gsl_matrix_complex_row (A, i);
          gsl_permute_vector_complex (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 10
11 15
12 10
13 10
14 10
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 10
30 10
31 10
32 15
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
push   %rbx
mov    $0x28,%edi
callq  286 <sc_control_alloc+0xb>
mov    %rax,%rbx
test   %rax,%rax
jne    2a7 <sc_control_alloc+0x2c>
mov    $0x8,%ecx
mov    $0x2f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2a7 <sc_control_alloc+0x2c>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
sc_control_alloc (void)
{
  sc_control_state_t * s =
    (sc_control_state_t *) malloc (sizeof(sc_control_state_t));
  if (s == 0)
    {
      do { gsl_error ("failed to allocate space for sc_control_state",
 "cscal.c"
      ,
 47
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                 ;
    }
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 15
13 15
14 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0xffffffffffffffff,%r8
mov    $0x0,%eax
mov    %r8,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
mov    %rsi,%rdi
mov    %r8,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rdx,%rcx,1),%rdi
callq  41d <_url_path_default+0x35>
mov    %rax,%rbx
test   %rax,%rax
jne    432 <_url_path_default+0x4a>
callq  42a <_url_path_default+0x42>
movl   $0xc,(%rax)
jmp    44a <_url_path_default+0x62>
mov    %r12,%rcx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  44a <_url_path_default+0x62>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_url_path_default (const char *spooldir, const char *user, int unused)
{
  char *mbox = malloc (strlen (spooldir) + strlen (user) + 2);
  if (!mbox)
    (*__errno_location ()) = 12;
  else
    sprintf (mbox, "%s/%s", spooldir, user);
  return mbox;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 4
20 4
21 5
22 5
23 5
24 7
25 7
26 7
27 7
28 7
29 7
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     320 <gsl_multifit_fdfsolver_free+0x6f>
mov    0x40(%rdi),%rdi
test   %rdi,%rdi
je     2d2 <gsl_multifit_fdfsolver_free+0x21>
mov    (%rbx),%rax
callq  *0x38(%rax)
mov    0x40(%rbx),%rdi
callq  2d2 <gsl_multifit_fdfsolver_free+0x21>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     2e0 <gsl_multifit_fdfsolver_free+0x2f>
callq  2e0 <gsl_multifit_fdfsolver_free+0x2f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2ee <gsl_multifit_fdfsolver_free+0x3d>
callq  2ee <gsl_multifit_fdfsolver_free+0x3d>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     2fc <gsl_multifit_fdfsolver_free+0x4b>
callq  2fc <gsl_multifit_fdfsolver_free+0x4b>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     30a <gsl_multifit_fdfsolver_free+0x59>
callq  30a <gsl_multifit_fdfsolver_free+0x59>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     318 <gsl_multifit_fdfsolver_free+0x67>
callq  318 <gsl_multifit_fdfsolver_free+0x67>
mov    %rbx,%rdi
callq  320 <gsl_multifit_fdfsolver_free+0x6f>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_free (gsl_multifit_fdfsolver * s)
{
  if (!s) { return ; };
  if (s->state)
    {
      (s->type->free) (s->state);
      free (s->state);
    }
  if (s->dx)
    gsl_vector_free (s->dx);
  if (s->x)
    gsl_vector_free (s->x);
  if (s->f)
    gsl_vector_free (s->f);
  if (s->sqrt_wts)
    gsl_vector_free (s->sqrt_wts);
  if (s->g)
    gsl_vector_free (s->g);
  free (s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 10
16 11
17 11
18 11
19 12
20 13
21 13
22 13
23 14
24 15
25 15
26 15
27 16
28 17
29 17
30 17
31 18
32 19
33 19
34 20
35 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x70(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->nx_add_after (list, node, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%edx
callq  196 <grecs_sockaddr_cmp+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_sockaddr_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(struct grecs_sockaddr)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
test   %rdx,%rdx
je     98f <swverid_set_tag+0x8d>
mov    %rdi,%rbx
mov    $0x0,%edi
mov    $0x8,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    94d <swverid_set_tag+0x4b>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     93f <swverid_set_tag+0x3d>
callq  937 <swverid_set_tag+0x35>
movq   $0x0,0x10(%rbx)
mov    %rbp,%rdi
callq  947 <swverid_set_tag+0x45>
mov    %rax,0x10(%rbx)
jmp    98f <swverid_set_tag+0x8d>
mov    0x20(%rbx),%rdi
mov    $0x0,%esi
callq  95b <swverid_set_tag+0x59>
test   %rax,%rax
je     976 <swverid_set_tag+0x74>
mov    0x20(%rbx),%rdi
mov    $0x0,%esi
callq  96e <swverid_set_tag+0x6c>
mov    %rax,%rdi
callq  976 <swverid_set_tag+0x74>
mov    %rbp,%rdi
callq  97e <swverid_set_tag+0x7c>
mov    0x20(%rbx),%rdi
mov    %rax,%rdx
mov    $0x0,%esi
callq  98f <swverid_set_tag+0x8d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swverid_set_tag(SWVERID * swverid, char * key, char *value)
{
 if (value == ((void *)0)) return;
 if (!strcmp(key, "catalog")) {
  if (swverid->catalogM) {
   free(swverid->catalogM);
   swverid->catalogM = ((void *)0);
  }
  swverid->catalogM=swlib_strdup(value);
 } else {
  if (cplob_val(swverid->taglistM,0)) {
   free(cplob_val(swverid->taglistM,0));
  }
  cplob_additem(swverid->taglistM, 0, swlib_strdup(value));
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 6
19 7
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 14
37 14
38 14
39 14
40 16
41 16
42 16
43 16
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
jit_finish_note(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4ab <cpp_reserved_word+0x9>
test   %rax,%rax
je     4c2 <cpp_reserved_word+0x20>
mov    0x8(%rax),%eax
cmp    $0x7d0,%eax
mov    $0x0,%edx
cmovle %edx,%eax
jmp    4c7 <cpp_reserved_word+0x25>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cpp_reserved_word(const char *str, int len)
{
 struct keyword *keyword;
 keyword = cpp_lookup(str, len);
 return (keyword && ((keyword->token) >= 2001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%edi
callq  6e <fd_close+0xb>
test   %eax,%eax
je     79 <fd_close+0x16>
callq  77 <fd_close+0x14>
mov    (%rax),%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fd_close(void *data)
{
    struct _stream *p = data;
    if (close(p->fd))
 return (*__errno_location ());
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rsi
mov    $0x0,%eax
test   %rsi,%rsi
je     6d <rec_writer_puts+0x27>
mov    %rbp,%rdi
callq  67 <rec_writer_puts+0x21>
cmp    $0xffffffff,%eax
setne  %al
mov    0x8(%rbx),%rsi
test   %rsi,%rsi
je     84 <rec_writer_puts+0x3e>
mov    %rbp,%rdi
callq  7e <rec_writer_puts+0x38>
cmp    $0xffffffff,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_writer_puts (rec_writer_t writer, const char *s)
{
  _Bool ret;
  ret = 0;
  if (writer->file_out)
    {
      ret = (fputs (s, writer->file_out) != (-1));
    }
  if (writer->buf_out)
    {
      ret = (rec_buf_puts (s, writer->buf_out) != (-1));
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 4
8 5
9 5
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 14
22 14
23 14
24 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x38(%rdi),%rbx
test   %rbx,%rbx
je     7e3 <sent_list_trans+0x66>
movslq 0x4(%rbx),%rax
mov    %rax,0x0(%rip)        # 79a <sent_list_trans+0x1d>
movzbl 0x8(%rbx),%eax
mov    %al,0x0(%rip)        # 7a4 <sent_list_trans+0x27>
movzbl 0x9(%rbx),%eax
mov    %al,0x0(%rip)        # 7ae <sent_list_trans+0x31>
movzbl 0xa(%rbx),%eax
mov    %al,0x0(%rip)        # 7b8 <sent_list_trans+0x3b>
mov    %rbx,%rdi
callq  7c0 <sent_list_trans+0x43>
mov    0x10(%rbp),%rax
mov    %rax,0x0(%rip)        # 7cb <sent_list_trans+0x4e>
test   %rax,%rax
je     7da <sent_list_trans+0x5d>
movswl 0x6c(%rax),%eax
mov    %eax,0x0(%rip)        # 7da <sent_list_trans+0x5d>
mov    0x30(%rbx),%rbx
test   %rbx,%rbx
jne    78f <sent_list_trans+0x12>
movslq 0x48(%rbp),%rax
mov    %rax,0x0(%rip)        # 7ee <sent_list_trans+0x71>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
sent_list_trans (sent_t *parent_sent)
{
  sent_t *sent;
  for (sent= parent_sent->first; sent!=((void *)0); sent= sent->next)
    {
      lineno= sent->line;
      nonetest= sent->nonetest;
      indextest= sent->indextest;
      stripsideeffects= sent->stripsideeffects;
      sent_trans (sent);
      cblock= parent_sent->cblock;
      if (cblock) cblev= cblock->blev;
    }
  lineno= parent_sent->last_line;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 11
19 11
20 12
21 12
22 12
23 12
24 4
25 4
26 4
27 14
28 14
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
add    $0x1,%rax
mov    %rax,0x8(%rsi)
cmp    (%rsi),%rax
sbb    %eax,%eax
and    $0xfffffff9,%eax
add    $0x8,%eax
retq   
<<<sep_in_sample>>>
visit_limit (struct process_data *procdata, void *context)
{
  struct locate_limits *p = context;
  (void) procdata;
  if (++p->items_accepted >= p->limit)
    return VISIT_ABORT;
  else
    return VISIT_CONTINUE;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 6
6 6
7 6
8 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    0x8(%rdi),%rax
mov    $0x0,%ebp
test   $0x1,%dl
je     5c0 <assign_array_var_from_word_list+0x26>
mov    0x8(%rax),%rbp
add    $0x1,%rbp
test   %rbx,%rbx
je     5f1 <assign_array_var_from_word_list+0x57>
and    $0xfffffffe,%edx
mov    %edx,%r13d
mov    0x8(%rbx),%rcx
mov    %r13d,%r8d
mov    (%rcx),%rcx
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  289 <bind_array_var_internal>
mov    (%rbx),%rbx
add    $0x1,%rbp
test   %rbx,%rbx
jne    5cb <assign_array_var_from_word_list+0x31>
andl   $0xffffefff,0x28(%r12)
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
assign_array_var_from_word_list (var, list, flags)
     SHELL_VAR *var;
     WORD_LIST *list;
     int flags;
{
  register arrayind_t i;
  register WORD_LIST *l;
  ARRAY *a;
  a = (ARRAY *)((var)->value);
  i = (flags & 0x0001) ? ((a)->max_index) + 1 : 0;
  for (l = list; l; l = l->next, i++)
    bind_array_var_internal (var, i, 0, l->word->word, flags & ~0x0001);
  ((var)->attributes &= ~(0x0001000));
  return var;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 9
9 10
10 10
11 10
12 10
13 10
14 11
15 11
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 11
26 11
27 11
28 11
29 13
30 15
31 15
32 15
33 15
34 15
35 15
36 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  1e5 <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
cmpq   $0x0,0x0(%rip)        # 536 <dicod_acl_install+0x14>
jne    563 <dicod_acl_install+0x41>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  557 <dicod_acl_install+0x35>
mov    %rax,0x0(%rip)        # 55e <dicod_acl_install+0x3c>
test   %rax,%rax
je     577 <dicod_acl_install+0x55>
mov    %rbp,%rsi
mov    0x0(%rip),%rdi        # 56d <dicod_acl_install+0x4b>
callq  572 <dicod_acl_install+0x50>
test   %rax,%rax
jne    57c <dicod_acl_install+0x5a>
callq  57c <dicod_acl_install+0x5a>
cmp    %rbp,%rax
nop
je     5ad <dicod_acl_install+0x8b>
test   %rbx,%rbx
je     5b4 <dicod_acl_install+0x92>
mov    0x8(%rax),%rdx
mov    %rdx,(%rbx)
mov    0x10(%rax),%rdx
mov    %rdx,0x8(%rbx)
mov    0x18(%rax),%rdx
mov    %rdx,0x10(%rbx)
mov    0x20(%rax),%rax
mov    %rax,0x18(%rbx)
mov    $0x1,%eax
jmp    5b9 <dicod_acl_install+0x97>
mov    $0x0,%eax
jmp    5b9 <dicod_acl_install+0x97>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dicod_acl_install(dicod_acl_t acl, grecs_locus_t *locus)
{
    dicod_acl_t ret;
    if (! ((acl_table
     || (acl_table = hash_initialize(0, 0,
         acl_hasher,
         acl_compare, 0)))
    && (ret = hash_insert(acl_table, acl))))
 xalloc_die();
    if (ret != acl) {
 if (locus)
     *locus = ret->locus;
 return 1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 4
18 4
19 4
20 4
21 4
22 9
23 10
24 10
25 10
26 11
27 11
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 13
37 13
38 15
39 15
40 13
41 16
42 16
43 16
44 16
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r13
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%rbx
test   %r8,%r8
mov    $0x0,%eax
cmove  %rax,%rbx
callq  e10 <quotearg_buffer+0x30>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    0x4(%rbx),%r9d
mov    0x30(%rbx),%rax
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    0x18(%rsp),%rdi
callq  e7 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
mov    %rsi,0x48(%rdi)
retq   
<<<sep_in_sample>>>
osip_www_authenticate_set_targetname (osip_www_authenticate_t *
          www_authenticate, char *targetname)
{
  www_authenticate->targetname = (char *) targetname;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 69 <mu_registrar_set_default_record+0x7>
retq   
<<<sep_in_sample>>>
mu_registrar_set_default_record (mu_record_t record)
{
  mu_default_record = record;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
mov    $0x0,%esi
callq  50 <command_print_word_list>
cmpq   $0x0,0x10(%rbx)
je     18e1 <print_simple_command+0x31>
mov    $0x0,%edi
mov    $0x0,%eax
callq  10b <cprintf>
mov    0x10(%rbx),%rdi
callq  c34 <print_redirection_list>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_simple_command (simple_command)
     SIMPLE_COM *simple_command;
{
  command_print_word_list (simple_command->words, " ");
  if (simple_command->redirects)
    {
      cprintf (" ");
      print_redirection_list (simple_command->redirects);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 8
12 8
13 10
14 10
<<<sep_out_sample>>>
cmpl   $0x0,0x8(%rdi)
jne    94 <_linetrimstr_destroy+0x19>
sub    $0x8,%rsp
callq  8a <_linetrimstr_destroy+0xf>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_linetrimstr_destroy(void *data)
{
    struct _linetrimstr *s = data;
    if (!s->noclose)
 dico_stream_destroy(&s->transport);
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 7
6 7
7 7
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %esi,%esi
jns    168b <ea_kill_line+0x27>
mov    0x0(%rip),%esi        # 1672 <ea_kill_line+0xe>
mov    0x0(%rip),%edi        # 1678 <ea_kill_line+0x14>
callq  59a <ea_kill_text>
mov    0x0(%rip),%eax        # 1683 <ea_kill_line+0x1f>
mov    %eax,0x0(%rip)        # 1689 <ea_kill_line+0x25>
jmp    169c <ea_kill_line+0x38>
mov    0x0(%rip),%esi        # 1691 <ea_kill_line+0x2d>
mov    0x0(%rip),%edi        # 1697 <ea_kill_line+0x33>
callq  59a <ea_kill_text>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ea_kill_line (WINDOW *window, int count)
{
  if (count < 0)
    {
      ea_kill_text (input_line_point, input_line_beg);
      input_line_point = input_line_beg;
    }
  else
    ea_kill_text (input_line_point, input_line_end);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 6
8 6
9 6
10 9
11 9
12 9
13 10
14 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 6c3 <terminal_ring_bell+0xb>
test   %rdx,%rdx
je     6d1 <terminal_ring_bell+0x19>
mov    $0x0,%eax
callq  *%rdx
jmp    71b <terminal_ring_bell+0x63>
cmpl   $0x0,0x0(%rip)        # 6d8 <terminal_ring_bell+0x20>
je     700 <terminal_ring_bell+0x48>
cmpl   $0x0,0x0(%rip)        # 6e1 <terminal_ring_bell+0x29>
je     700 <terminal_ring_bell+0x48>
mov    0x0(%rip),%rdi        # 6ea <terminal_ring_bell+0x32>
test   %rdi,%rdi
je     71b <terminal_ring_bell+0x63>
mov    $0x0,%edx
mov    $0x1,%esi
callq  6fe <terminal_ring_bell+0x46>
jmp    71b <terminal_ring_bell+0x63>
mov    0x0(%rip),%rdi        # 707 <terminal_ring_bell+0x4f>
test   %rdi,%rdi
je     71b <terminal_ring_bell+0x63>
mov    $0x0,%edx
mov    $0x1,%esi
callq  71b <terminal_ring_bell+0x63>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_ring_bell (void)
{
  if (terminal_ring_bell_hook)
    (*terminal_ring_bell_hook) ();
  else
    {
      if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)
        do { if (visible_bell) tputs (visible_bell, 1, output_character_function); } while (0);
      else
        do { if (audible_bell) tputs (audible_bell, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 10
22 10
23 10
24 10
25 12
26 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  1f1 <_gsasl_cram_md5_server_finish+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_cram_md5_server_finish (Gsasl_session * sctx, void *mech_data)
{
  char *challenge = mech_data;
  free (challenge);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x60(%rdi),%rdx
lea    0x20(%rdi),%rdi
mov    0x0(%rip),%rcx        # f6 <nettle_eax_aes128_digest+0x1c>
mov    %rax,%rsi
callq  fe <nettle_eax_aes128_digest+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_eax_aes128_digest(struct eax_aes128_ctx *ctx,
    size_t length, uint8_t *digest)
{
  (0 ? (nettle_aes128_encrypt) (&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_eax_digest (&(ctx)->eax, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (digest)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     c34 <osip_message_set_body_mime+0x71>
mov    %rsi,%rbp
mov    %rdx,%r12
lea    0x8(%rsp),%rdi
callq  be3 <osip_message_set_body_mime+0x20>
mov    %eax,%ecx
test   %ecx,%ecx
jne    c39 <osip_message_set_body_mime+0x76>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    0x8(%rsp),%rdi
callq  bf9 <osip_message_set_body_mime+0x36>
mov    %eax,%ebp
test   %eax,%eax
je     c0d <osip_message_set_body_mime+0x4a>
mov    0x8(%rsp),%rdi
callq  c09 <osip_message_set_body_mime+0x46>
mov    %ebp,%eax
jmp    c39 <osip_message_set_body_mime+0x76>
movl   $0x2,0x1a0(%rbx)
lea    0x190(%rbx),%rdi
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
callq  c2d <osip_message_set_body_mime+0x6a>
mov    $0x0,%eax
jmp    c39 <osip_message_set_body_mime+0x76>
mov    $0xfffffffe,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_set_body_mime (osip_message_t * sip, const char *buf, size_t length)
{
  osip_body_t *body;
  int i;
  if (sip == ((void *)0))
    return -2;
  i = osip_body_init (&body);
  if (i != 0)
    return i;
  i = osip_body_parse_mime (body, buf, length);
  if (i != 0) {
    osip_body_free (body);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->bodies, body, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 8
14 8
15 10
16 10
17 10
18 10
19 10
20 11
21 11
22 12
23 12
24 13
25 13
26 15
27 16
28 16
29 16
30 16
31 17
32 17
33 6
34 18
35 18
36 18
37 18
38 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
movzbl (%rdi),%ebx
test   %bl,%bl
je     6a <dico_markup_valid_name_p+0x44>
test   %bl,%bl
js     71 <dico_markup_valid_name_p+0x4b>
callq  3f <dico_markup_valid_name_p+0x19>
mov    (%rax),%rdx
jmp    48 <dico_markup_valid_name_p+0x22>
test   %bl,%bl
js     78 <dico_markup_valid_name_p+0x52>
movsbq %bl,%rax
testb  $0x8,(%rdx,%rax,2)
jne    57 <dico_markup_valid_name_p+0x31>
cmp    $0x5f,%bl
jne    7f <dico_markup_valid_name_p+0x59>
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    44 <dico_markup_valid_name_p+0x1e>
mov    $0x1,%eax
jmp    84 <dico_markup_valid_name_p+0x5e>
mov    $0x1,%eax
jmp    84 <dico_markup_valid_name_p+0x5e>
mov    $0x0,%eax
jmp    84 <dico_markup_valid_name_p+0x5e>
mov    $0x0,%eax
jmp    84 <dico_markup_valid_name_p+0x5e>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dico_markup_valid_name_p(const char *name)
{
    for (; *name; name++)
 if (!((((*name) & ~0x7f) == 0) && (((*__ctype_b_loc ())[(int) ((*name))] & (unsigned short int) _ISalnum) || *name == '_')))
     return 0;
    return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 3
21 3
22 3
23 3
24 6
25 6
26 6
27 6
28 5
29 5
30 5
31 5
32 5
33 7
34 7
35 7
36 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %r8,%rbp
mov    %rcx,%rsi
callq  67 <print_dig+0x15>
mov    0xa0(%r12),%rax
cmpl   $0x0,(%rax)
je     93 <print_dig+0x41>
cmpb   $0x0,0x0(%rbp)
jne    93 <print_dig+0x41>
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  91 <print_dig+0x3f>
jmp    ad <print_dig+0x5b>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  ad <print_dig+0x5b>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_dig(STROB * fp, struct new_cpio_header * file_hdr, int do_dig, char * key, char * val)
{
 strob_strcat(fp, key);
 if (file_hdr->digsM->do_poisonM && strlen(val) == 0 ) {
  strob_sprintf(fp, 1, "<not available>");
 } else {
  strob_sprintf(fp, 1, "%s", val);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  1579 <xdr_dis_acknowledge_pdu+0x11>
mov    $0x0,%edx
test   %eax,%eax
je     15ea <xdr_dis_acknowledge_pdu+0x82>
lea    0xc(%rbp),%rsi
mov    %rbx,%rdi
callq  158e <xdr_dis_acknowledge_pdu+0x26>
mov    $0x0,%edx
test   %eax,%eax
je     15ea <xdr_dis_acknowledge_pdu+0x82>
lea    0x12(%rbp),%rsi
mov    %rbx,%rdi
callq  15a3 <xdr_dis_acknowledge_pdu+0x3b>
mov    $0x0,%edx
test   %eax,%eax
je     15ea <xdr_dis_acknowledge_pdu+0x82>
lea    0x18(%rbp),%rsi
mov    %rbx,%rdi
callq  15b8 <xdr_dis_acknowledge_pdu+0x50>
mov    $0x0,%edx
test   %eax,%eax
je     15ea <xdr_dis_acknowledge_pdu+0x82>
lea    0x1a(%rbp),%rsi
mov    %rbx,%rdi
callq  15cd <xdr_dis_acknowledge_pdu+0x65>
mov    $0x0,%edx
test   %eax,%eax
je     15ea <xdr_dis_acknowledge_pdu+0x82>
lea    0x20(%rbp),%rsi
mov    %rbx,%rdi
callq  15e2 <xdr_dis_acknowledge_pdu+0x7a>
test   %eax,%eax
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xdr_dis_acknowledge_pdu(xdrs, objp)
	XDR *xdrs;
	dis_acknowledge_pdu *objp;
{
	if (!xdr_dis_pdu_header(xdrs, &objp->hdr)) {
		return (FALSE);
	}
	if (!xdr_dis_entity_id(xdrs, &objp->orig_id)) {
		return (FALSE);
	}
	if (!xdr_dis_entity_id(xdrs, &objp->recv_id)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->acknowledge_flag)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->resp_flag)) {
		return (FALSE);
	}
	if (!xdr_dis_request_id(xdrs, &objp->request_id)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 6
8 5
9 5
10 8
11 8
12 8
13 9
14 8
15 8
16 11
17 11
18 11
19 12
20 11
21 11
22 14
23 14
24 14
25 15
26 14
27 14
28 17
29 17
30 17
31 18
32 17
33 17
34 20
35 20
36 20
37 20
38 20
39 20
40 24
41 24
42 24
43 24
44 24
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    $0x0,%edi
callq  8ac1 <macro_meta_sequences_list_long+0x16>
mov    %rax,%rcx
mov    $0x1,%edx
mov    $0x3d,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  8adb <macro_meta_sequences_list_long+0x30>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  8ae8 <macro_meta_sequences_list_long+0x3d>
mov    0x5f0(%rbp),%rdi
mov    %rbx,%rsi
callq  8af7 <macro_meta_sequences_list_long+0x4c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
macro_meta_sequences_list_long (struct a2ps_job * job,
    FILE * stream)
{
  title (stream, '=', 1, gettext ("Known Variables"));
  _IO_putc ('\n', stream);
  pair_table_list_long (job->macro_meta_sequences, stream);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 6
18 6
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
mov    %sil,0x18(%rdi)
retq   
<<<sep_in_sample>>>
rec_sex_parser_set_case_insensitive (rec_sex_parser_t parser,
                                     _Bool case_insensitive)
{
  parser->case_insensitive = case_insensitive;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x78(%rdi),%rcx
lea    0x0(,%rsi,8),%rax
mov    0x68(%rdi),%rdx
sub    %rsi,%rdx
imul   (%rdi),%rdx
lea    (%rcx,%rax,1),%rsi
lea    -0x8(%rcx,%rax,1),%rdi
callq  1978 <amd_array_shrink+0x29>
subq   $0x1,0x68(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
amd_array_shrink (struct _amd_data *amd, size_t index)
{
  memmove (&amd->msg_array[index-1], &amd->msg_array[index],
    (amd->msg_count-index) * amd->msg_size);
  amd->msg_count--;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 3
8 3
9 3
10 3
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     e <__rct+0xe>
callq  e <__rct+0xe>
mov    $0x50,%edi
callq  18 <__rct+0x18>
movq   $0x7,(%rax)
mov    0x0(%rip),%rdx        # 26 <__rct+0x26>
mov    %rdx,0x30(%rax)
mov    0x0(%rip),%rdx        # 31 <__rct+0x31>
mov    %rdx,0x10(%rax)
mov    %rax,0x0(%rip)        # 3c <__rct+0x3c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rct (long as)
{
  __dhp x;
  if (as)
    __rss (as);
  x = __ralloc ((long) sizeof (__thunk));
  x->pp = (__pty) 7;
  x->sl = __sl;
  x->dl = __pb;
  __pb = x;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 6
7 7
8 8
9 8
10 9
11 9
12 10
13 11
14 11
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     6a5d <info_select_reference_this_line+0x2f>
cmpq   $0x0,(%rax)
je     6a5d <info_select_reference_this_line+0x2f>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x1,%edx
mov    $0x1,%esi
callq  65c6 <info_menu_or_ref_item>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
info_select_reference_this_line (WINDOW *window, int count)
{
  REFERENCE **ref = window->node->references;
  if (!ref || !*ref) return;
  info_menu_or_ref_item (window, 1, 1, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 2
8 5
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
mov    0x0(%rip),%r11        # 9a <history_total_bytes+0x7>
test   %r11,%r11
je     ee <history_total_bytes+0x5b>
mov    (%r11),%rdx
test   %rdx,%rdx
je     f6 <history_total_bytes+0x63>
mov    $0x0,%r8d
mov    $0x0,%esi
mov    $0xffffffffffffffff,%r9
mov    $0x0,%eax
mov    (%rdx),%rdi
mov    %r9,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r10
mov    0x8(%rdx),%rdi
mov    %r9,%rcx
repnz scas %es:(%rdi),%al
sub    %ecx,%r8d
lea    -0x3(%r8,%r10,1),%r8d
add    $0x1,%esi
movslq %esi,%rdx
mov    (%r11,%rdx,8),%rdx
test   %rdx,%rdx
jne    be <history_total_bytes+0x2b>
jmp    fc <history_total_bytes+0x69>
mov    $0x0,%r8d
jmp    fc <history_total_bytes+0x69>
mov    $0x0,%r8d
mov    %r8d,%eax
retq   
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 7
31 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%r13
mov    %rdx,%r12
mov    0x28(%rdi),%rbx
lea    0x28(%rdi),%rbp
cmp    %rbp,%rbx
je     6e2 <gl_linked_sortedlist_remove+0x4c>
mov    0x10(%rbx),%rdi
mov    %r12,%rsi
callq  *%r13
test   %eax,%eax
jg     6e9 <gl_linked_sortedlist_remove+0x53>
test   %eax,%eax
jne    6d3 <gl_linked_sortedlist_remove+0x3d>
mov    %rbx,%rsi
mov    %r14,%rdi
callq  661 <gl_linked_remove_node>
jmp    6f5 <gl_linked_sortedlist_remove+0x5f>
mov    (%rbx),%rbx
cmp    %rbp,%rbx
jne    6b4 <gl_linked_sortedlist_remove+0x1e>
nopl   0x0(%rax,%rax,1)
jmp    6f0 <gl_linked_sortedlist_remove+0x5a>
mov    $0x0,%eax
jmp    6f5 <gl_linked_sortedlist_remove+0x5f>
mov    $0x0,%eax
jmp    6f5 <gl_linked_sortedlist_remove+0x5f>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gl_linked_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,
                             const void *elt)
{
  gl_list_node_t node;
  for (node = list->root.next; node != &list->root; node = node->next)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
        break;
      if (cmp == 0)
        return gl_linked_remove_node (list, node);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 10
19 10
20 11
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 5
29 13
30 13
31 13
32 13
33 13
34 14
35 14
36 14
37 14
38 14
39 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  41 <ding+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ding ()
{
  return rl_ding ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 7ca <nexttoken+0xa>
cmp    %eax,0x0(%rip)        # 7d0 <nexttoken+0x10>
jne    7f6 <nexttoken+0x36>
callq  7d7 <nexttoken+0x17>
mov    0x0(%rip),%rdx        # 7de <nexttoken+0x1e>
mov    0x0(%rip),%esi        # 7e4 <nexttoken+0x24>
mov    %eax,%edi
callq  7eb <nexttoken+0x2b>
movq   $0x0,0x0(%rip)        # 7f6 <nexttoken+0x36>
mov    0x0(%rip),%edx        # 7fc <nexttoken+0x3c>
movslq %edx,%rax
lea    (%rax,%rax,2),%rax
shl    $0x3,%rax
add    0x0(%rip),%rax        # 80e <nexttoken+0x4e>
mov    (%rax),%rcx
mov    %rcx,0x0(%rip)        # 818 <nexttoken+0x58>
mov    0x8(%rax),%rcx
mov    %rcx,0x0(%rip)        # 823 <nexttoken+0x63>
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # 82e <nexttoken+0x6e>
add    $0x1,%edx
mov    %edx,0x0(%rip)        # 837 <nexttoken+0x77>
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  25a <debugtoken>
mov    0x0(%rip),%eax        # 851 <nexttoken+0x91>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nexttoken()
{
     int type;
     if (curs == tos) {
   type = get_token();
   tokpush(type, line_num, yylval.str);
   yylval.str = ((void *)0);
     }
     tok = token_stack[curs];
     curs++;
     debugtoken(&tok, "next token");
     return tok.type;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 6
7 6
8 6
9 6
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 11
25 11
26 11
27 11
28 13
29 13
30 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r8
mov    %rdx,%r9
mov    0xc8(%rdi),%ecx
lea    0xcc(%rdi),%rdx
mov    $0x88,%esi
callq  90 <nettle_sha3_256_update+0x21>
mov    %eax,0xc8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_sha3_256_update (struct sha3_256_ctx *ctx,
   size_t length,
   const uint8_t *data)
{
  ctx->index = _nettle_sha3_update (&ctx->state, 136, ctx->block,
        ctx->index, length, data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
test   %rdi,%rdi
je     352 <gss_release_buffer+0xf>
movl   $0x0,(%rdi)
test   %rbx,%rbx
je     36f <gss_release_buffer+0x2c>
mov    0x8(%rbx),%rdi
callq  360 <gss_release_buffer+0x1d>
movq   $0x0,0x8(%rbx)
movq   $0x0,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gss_release_buffer (OM_uint32 * minor_status, gss_buffer_t buffer)
{
  if (minor_status)
    *minor_status = 0;
  if (buffer != ((gss_buffer_t) 0))
    {
      free (buffer->value);
      buffer->value = ((void *)0);
      buffer->length = 0;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 5
8 7
9 7
10 8
11 9
12 12
13 12
14 12
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  18 <CDB___os_set_errno+0x8>
mov    %ebx,(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___os_set_errno(evalue)
 int evalue;
{
 (*__errno_location ()) = evalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
callq  68 <i_is_value_true>
mov    %eax,%ebx
test   %eax,%eax
jne    43c <swextopt_is_value_true+0x47>
mov    %rbp,%rdi
callq  0 <i_is_value_false>
mov    %eax,%r12d
test   %eax,%eax
jne    441 <swextopt_is_value_true+0x4c>
callq  41b <swextopt_is_value_true+0x26>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 42d <swextopt_is_value_true+0x38>
mov    $0x0,%eax
callq  437 <swextopt_is_value_true+0x42>
mov    %r12d,%ebx
jmp    441 <swextopt_is_value_true+0x4c>
mov    $0x1,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swextopt_is_value_true(char * s)
{
 if (i_is_value_true(s)) {
  return 1;
 } else if (i_is_value_false(s)) {
  return 0;
 } else {
  fprintf(stderr,
  "%s: warning: extended option boolean value '%s' is improperly formatted, assuming false\n", swlib_utilname_get(), s);
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 4
24 12
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # c17 <gsl_vector_ushort_get+0x7>
je     c42 <gsl_vector_ushort_get+0x32>
cmp    %rsi,(%rdi)
ja     c42 <gsl_vector_ushort_get+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xb4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c3b <gsl_vector_ushort_get+0x2b>
mov    $0x0,%eax
jmp    c56 <gsl_vector_ushort_get+0x46>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rax,%rsi
mov    0x10(%rdi),%rax
movzwl (%rax,%rsi,1),%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_ushort_get (const gsl_vector_ushort * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_ushort.h", 180, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return v->data[i * v->stride];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <__rexp+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rexp (double r)
{
  return (exp (r));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x120,%rsp
mov    %rsp,%rsi
mov    0x0(%rip),%rdi        # 2f9 <diff_link+0x12>
callq  29c <get_stat_data>
test   %eax,%eax
je     35c <diff_link+0x75>
lea    0x90(%rsp),%rsi
mov    0x0(%rip),%rdi        # 311 <diff_link+0x2a>
callq  29c <get_stat_data>
test   %eax,%eax
je     35c <diff_link+0x75>
lea    0x90(%rsp),%rsi
mov    %rsp,%rdi
callq  32a <diff_link+0x43>
test   %al,%al
jne    35c <diff_link+0x75>
mov    0x0(%rip),%rdi        # 335 <diff_link+0x4e>
callq  33a <diff_link+0x53>
mov    %rax,%rbx
mov    $0x0,%edi
callq  347 <diff_link+0x60>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  35c <diff_link+0x75>
add    $0x120,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
diff_link (void)
{
  struct stat file_data;
  struct stat link_data;
  if (get_stat_data (current_stat_info.file_name, &file_data)
      && get_stat_data (current_stat_info.link_name, &link_data)
      && !sys_compare_links (&file_data, &link_data))
    report_difference (&current_stat_info,
         gettext ("Not linked to %s"),
         quote (current_stat_info.link_name));
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 8
21 9
22 9
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x3,%esi
sete   %al
movzbl %al,%eax
lea    0x38(%rdi),%rsi
mov    $0x2,%r8d
mov    %edx,%ecx
mov    %eax,%edx
callq  52e <__osip_ict_need_timer_d_event+0x20>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__osip_ict_need_timer_d_event (osip_ict_t * ict, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (ict, &ict->timer_d_start, state == ICT_COMPLETED, transactionid, TIMEOUT_D);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  bd <porinode_add_vrecord+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
porinode_add_vrecord(PORINODE *porinode, char * path, dev_t dev,
     ino_t ino, dev_t v_dev, ino_t v_ino)
{
 hllist_add_vrecord(porinode->hllistM, path, dev, ino, v_dev, v_ino);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%r12
mov    %rdx,%rbp
mov    %rcx,%r14
mov    %r8,%r15
mov    %r9,%rbx
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
movsd  %xmm1,0x8(%rsp)
callq  648 <xerrwv+0x33>
cmp    $0x1,%rbp
jne    662 <xerrwv+0x4d>
mov    %r14,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  660 <xerrwv+0x4b>
jmp    67d <xerrwv+0x68>
cmp    $0x2,%rbp
jne    67d <xerrwv+0x68>
mov    %r15,%rdx
mov    %r14,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  67d <xerrwv+0x68>
cmp    $0x1,%rbx
jne    69f <xerrwv+0x8a>
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x1,%eax
callq  69d <xerrwv+0x88>
jmp    6c5 <xerrwv+0xb0>
cmp    $0x2,%rbx
jne    6c5 <xerrwv+0xb0>
movsd  0x8(%rsp),%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x2,%eax
callq  6c5 <xerrwv+0xb0>
cmp    $0x2,%r12
jne    6d0 <xerrwv+0xbb>
callq  6d0 <xerrwv+0xbb>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
xerrwv (char *msg, long level, long ni, long i1, long i2, long nr,
            double r1, double r2)
{
  long mesflg = 1;
  if (mesflg == 0) goto L100;
  printf ("%s\n",msg);
  if (ni == 1) printf(" in above message, i1=%10ld\n", i1);
  if (ni == 2)
    printf(" in above message, i1=%10ld, i2=%10ld\n", i1, i2);
  if (nr == 1) printf(" in above message, r1=%21.13f\n", r1);
  if (nr == 2)
    printf(" in above message, r1=%21.13f, r2=%21.13f\n", r1, r2);
L100:
    if (level != 2) return 0;
    abort();
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 12
42 12
43 12
44 12
45 12
46 12
47 14
48 14
49 15
50 17
51 17
52 17
53 17
54 17
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  158a <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    $0x0,%edx
mov    (%rdi,%rdx,1),%ecx
mov    %ecx,%r9d
shr    $0x18,%r9d
mov    %ecx,%r8d
shl    $0x18,%r8d
or     %r8d,%r9d
mov    %ecx,%r8d
and    $0xff00,%r8d
shl    $0x8,%r8d
or     %r8d,%r9d
shr    $0x8,%ecx
and    $0xff00,%ecx
mov    %ecx,%r8d
mov    %r9d,%ecx
or     %r8d,%ecx
mov    %ecx,(%rax,%rdx,1)
add    $0x4,%rdx
cmp    $0x20,%rdx
jne    a4 <sha256_read_ctx+0x8>
repz retq 
<<<sep_in_sample>>>
sha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)
{
  int i;
  char *r = resbuf;
  for (i = 0; i < 8; i++)
    set_uint32 (r + i * sizeof ctx->state[0], (((ctx->state[i]) << 24) | (((ctx->state[i]) & 0xff00) << 8) | (((ctx->state[i]) >> 8) & 0xff00) | ((ctx->state[i]) >> 24)));
  return resbuf;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <__rcos+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rcos (double r)
{
  return (cos (r));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  53 <fail_due_to_env_size+0xe>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  6a <fail_due_to_env_size+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fail_due_to_env_size (void)
{
  error (1, 0, gettext ("environment is too large for exec"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
num(int c)
{
  return '0' <= c && c <= '9';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <history_search_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
history_search_prefix (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 1));
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  8ec <pred_ls+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pred_ls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  return pred_fls (pathname, stat_buf, pred_ptr);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%r14
mov    %rcx,0x8(%rsp)
test   %rdi,%rdi
je     95 <gss_test_oid_set_member+0x21>
movl   $0x0,(%rdi)
mov    0x8(%rsp),%rax
movl   $0x0,(%rax)
test   %r14,%r14
je     ef <gss_test_oid_set_member+0x7b>
mov    0x8(%rdx),%rbx
mov    (%rdx),%r13
test   %r13,%r13
je     ef <gss_test_oid_set_member+0x7b>
mov    (%r14),%r12d
mov    $0x0,%ebp
mov    %r12d,%r15d
cmp    %r12d,(%rbx)
jne    e2 <gss_test_oid_set_member+0x6e>
mov    0x8(%r14),%rsi
mov    0x8(%rbx),%rdi
mov    %r15,%rdx
callq  d1 <gss_test_oid_set_member+0x5d>
test   %eax,%eax
jne    e2 <gss_test_oid_set_member+0x6e>
mov    0x8(%rsp),%rax
movl   $0x1,(%rax)
jmp    ef <gss_test_oid_set_member+0x7b>
add    $0x1,%rbp
add    $0x10,%rbx
cmp    %r13,%rbp
jne    bc <gss_test_oid_set_member+0x48>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gss_test_oid_set_member (OM_uint32 * minor_status,
    const gss_OID member,
    const gss_OID_set set, int *present)
{
  gss_OID cur;
  size_t i;
  if (minor_status)
    *minor_status = 0;
  *present = 0;
  if (member == ((gss_OID) 0))
    return 0;
  for (i = 0, cur = set->elements; i < set->count; i++, cur++)
    {
      if (cur->length == member->length &&
   memcmp (cur->elements, member->elements, member->length) == 0)
 {
   *present = 1;
   return 0;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 7
11 7
12 8
13 9
14 9
15 10
16 10
17 12
18 12
19 12
20 12
21 14
22 12
23 15
24 14
25 14
26 15
27 15
28 15
29 15
30 14
31 14
32 17
33 17
34 18
35 12
36 12
37 12
38 12
39 22
40 22
41 22
42 22
43 22
44 22
45 22
46 22
47 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  37 <send_eof+0x9>
callq  3c <send_eof+0xe>
mov    0x0(%rip),%rax        # 43 <send_eof+0x15>
test   %rax,%rax
je     4d <send_eof+0x1f>
movzbl (%rax),%edi
jmp    52 <send_eof+0x24>
mov    $0x4,%edi
callq  57 <send_eof+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_eof (void)
{
  init_termbuf ();
  term_send_eof ();
  pty_output_byte (slctab[8].sptr ?
     (unsigned char) *slctab[8].sptr : '\004');
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  35d <sh_notfound+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  36d <sh_notfound+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_notfound (s)
     char *s;
{
  builtin_error (gettext("%s: not found"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x40(%rdi),%rdi
callq  1f <folder_pop_open+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
folder_pop_open (mu_folder_t folder, int flags)
{
  mu_mailbox_t mbox = folder->data;
  return mu_mailbox_open (mbox, flags);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
movl   $0x8,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
test   %rdi,%rdi
je     72 <__gmpq_inits+0x72>
callq  43 <__gmpq_inits+0x43>
mov    0x8(%rsp),%eax
cmp    $0x30,%eax
jae    5c <__gmpq_inits+0x5c>
mov    %eax,%edx
add    0x18(%rsp),%rdx
add    $0x8,%eax
mov    %eax,0x8(%rsp)
jmp    6a <__gmpq_inits+0x6a>
mov    0x10(%rsp),%rdx
lea    0x8(%rdx),%rax
mov    %rax,0x10(%rsp)
mov    (%rdx),%rdi
test   %rdi,%rdi
jne    3e <__gmpq_inits+0x3e>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
__gmpq_inits (mpq_ptr x, ...)
{
  va_list ap;
  __builtin_va_start(ap,x);
  while (x != ((void *)0))
    {
      __gmpq_init (x);
      x = __builtin_va_arg(ap,mpq_ptr);
    }
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 5
28 5
29 11
30 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
mov    %esi,%ebp
mov    $0x77,%esi
callq  e3c <connect>
movslq %ebx,%rbx
mov    0x0(,%rbx,8),%rdi
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  11f1 <outinteger+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
outinteger(int channel, int val)
{
      connect(channel, 'w');
      fprintf(stream[channel], "%d ", val);
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
test   %rbx,%rbx
je     e5 <find_token_in_alist+0x65>
mov    $0x0,%edx
cmp    %edi,0x8(%rsi)
jne    d0 <find_token_in_alist+0x50>
jmp    9a <find_token_in_alist+0x1a>
cmp    %edi,0x8(%rcx)
jne    d0 <find_token_in_alist+0x50>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdi
not    %rdi
mov    $0x58,%edx
mov    $0x0,%esi
callq  c0 <find_token_in_alist+0x40>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  cb <find_token_in_alist+0x4b>
mov    %rax,%rbx
jmp    e5 <find_token_in_alist+0x65>
add    $0x1,%edx
movslq %edx,%rcx
shl    $0x4,%rcx
add    %rsi,%rcx
mov    (%rcx),%rbx
test   %rbx,%rbx
jne    95 <find_token_in_alist+0x15>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
find_token_in_alist (token, alist, flags)
     int token;
     STRING_INT_ALIST *alist;
     int flags;
{
  register int i;
  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return ((char *)strcpy (sh_xmalloc((1 + strlen (alist[i].word)), "stringlib.c", 88), (alist[i].word)));
    }
  return ((char *)((void *)0));
}
<<<sep_in_sample>>>
1 5
2 7
3 7
4 7
5 7
6 9
7 9
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 13
33 13
34 13
<<<sep_out_sample>>>
mov    $0x1006,%eax
test   %rdi,%rdi
je     a7d <mu_mailbox_set_folder+0x12>
mov    %rsi,0x38(%rdi)
mov    $0x0,%ax
repz retq 
<<<sep_in_sample>>>
mu_mailbox_set_folder (mu_mailbox_t mbox, mu_folder_t folder)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
   mbox->folder = folder;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
neg    %esi
callq  4343 <info_scroll_backward+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_scroll_backward (WINDOW *window, int count)
{
  info_scroll_forward (window, -count);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1312 <str_to_socket_type+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
str_to_socket_type (const char *str, int *pres)
{
  return strtotok (socktype_xtab, str, pres);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a9f <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     aaa <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
movl   $0x0,0x0(%rip)        # ab4 <rl_on_new_line+0x1c>
movl   $0x0,0x0(%rip)        # abe <rl_on_new_line+0x26>
movl   $0x0,0x0(%rip)        # ac8 <rl_on_new_line+0x30>
movl   $0x0,0x0(%rip)        # ad2 <rl_on_new_line+0x3a>
mov    0x8(%rax),%rax
test   %rax,%rax
je     ae8 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # af2 <rl_on_new_line+0x5a>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 8
14 8
15 9
16 11
17 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  10ea <rl_unbind_key+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_unbind_key (key)
     int key;
{
  return (rl_bind_key (key, (rl_command_func_t *)((void *)0)));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
cmpl   $0x9,0xb0(%rdi)
jne    658 <_wsplt_seterr_sub+0x21>
mov    0xb8(%rdi),%rdi
callq  658 <_wsplt_seterr_sub+0x21>
mov    0xb0(%rbx),%eax
mov    %eax,0xb0(%rbp)
cmpl   $0x9,0xb0(%rbx)
jne    690 <_wsplt_seterr_sub+0x59>
mov    0xb8(%rbx),%rax
mov    %rax,0xb8(%rbp)
movl   $0x0,0xb0(%rbx)
movq   $0x0,0xb8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_wsplt_seterr_sub (struct wordsplit *wsp, struct wordsplit *wss)
{
  if (wsp->ws_errno == 9)
    free (wsp->ws_usererr);
  wsp->ws_errno = wss->ws_errno;
  if (wss->ws_errno == 9)
    {
      wsp->ws_usererr = wss->ws_usererr;
      wss->ws_errno = 0;
      wss->ws_usererr = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 6
13 6
14 8
15 8
16 9
17 10
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
orq    $0x40,0x0(%rip)        # 217 <rl_vi_domove_getchar+0xc>
callq  21c <rl_vi_domove_getchar+0x11>
andq   $0xffffffffffffffbf,0x0(%rip)        # 224 <rl_vi_domove_getchar+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_vi_domove_getchar (m)
     _rl_vimotion_cxt *m;
{
  int c;
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 9
6 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdi
callq  e60 <system_fh_tx_window_errors+0x15>
test   %rax,%rax
jne    e74 <system_fh_tx_window_errors+0x29>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  e72 <system_fh_tx_window_errors+0x27>
jmp    e88 <system_fh_tx_window_errors+0x3d>
mov    0xc0(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  e88 <system_fh_tx_window_errors+0x3d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_tx_window_errors (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "tx_window_errors" " unknown)"); else put_ulong (form, argc, argv, stats->tx_window_errors); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  c71 <_prog_get_transport2+0xf>
mov    %rax,%rbx
mov    0x18(%rax),%rdi
mov    %rbp,%rsi
callq  c80 <_prog_get_transport2+0x1e>
mov    %eax,%ecx
test   %ecx,%ecx
jne    c92 <_prog_get_transport2+0x30>
mov    0x20(%rbx),%rdi
mov    %r12,%rsi
callq  c92 <_prog_get_transport2+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_prog_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  int rc;
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  if ((rc = mu_stream_get_transport (fs->in, pin)) != 0)
    return rc;
  return mu_stream_get_transport (fs->out, pout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 7
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
test   %rcx,%rcx
je     1c24 <gsl_permute_char+0x7b>
push   %rbx
mov    %rsi,%r11
mov    $0x0,%r8d
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    1bca <gsl_permute_char+0x21>
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     1bc1 <gsl_permute_char+0x18>
cmp    %rax,%r8
ja     1bff <gsl_permute_char+0x56>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
jne    1c0d <gsl_permute_char+0x64>
jmp    1bff <gsl_permute_char+0x56>
mov    %r9,%rax
mov    %r10,%r9
mov    %r9,%r10
imul   %rdx,%r10
movzbl (%rsi,%r10,1),%r10d
imul   %rdx,%rax
mov    %r10b,(%rsi,%rax,1)
mov    (%rdi,%r9,8),%r10
cmp    %r8,%r10
jne    1bda <gsl_permute_char+0x31>
jmp    1c13 <gsl_permute_char+0x6a>
add    $0x1,%r8
add    %rdx,%r11
cmp    %rcx,%r8
jne    1bb8 <gsl_permute_char+0xf>
jmp    1c1d <gsl_permute_char+0x74>
movzbl (%r11),%ebx
jmp    1be0 <gsl_permute_char+0x37>
imul   %rdx,%r9
mov    %bl,(%rsi,%r9,1)
jmp    1bff <gsl_permute_char+0x56>
mov    $0x0,%eax
pop    %rbx
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_char (const size_t * p, char * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        char t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                char r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 4
6 6
7 7
8 7
9 8
10 7
11 7
12 9
13 9
14 11
15 12
16 12
17 12
18 12
19 27
20 23
21 23
22 23
23 24
24 24
25 27
26 19
27 19
28 19
29 4
30 4
31 4
32 4
33 4
34 18
35 18
36 30
37 30
38 30
39 34
40 34
41 34
42 34
43 34
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x88(%rdi),%rdi
test   %rdi,%rdi
je     8e <mu_nntp_send+0x8e>
mov    0x8(%rbx),%r12
mov    (%rbx),%rbp
cmp    %rbp,%r12
jbe    8e <mu_nntp_send+0x8e>
movq   $0x0,0x8(%rsp)
mov    0x70(%rbx),%edx
test   %edx,%edx
je     45 <mu_nntp_send+0x45>
mov    $0x2,%esi
callq  3d <mu_nntp_send+0x3d>
test   %eax,%eax
jne    45 <mu_nntp_send+0x45>
mov    $0x6e,%al
jmp    9a <mu_nntp_send+0x9a>
sub    %rbp,%r12
mov    0x88(%rbx),%rdi
lea    0x8(%rsp),%r8
mov    $0x0,%ecx
mov    %r12,%rdx
mov    (%rbx),%rsi
callq  64 <mu_nntp_send+0x64>
mov    %eax,%ebp
mov    0x8(%rsp),%rsi
test   %rsi,%rsi
je     8a <mu_nntp_send+0x8a>
mov    (%rbx),%rdi
mov    %r12,%rdx
sub    %rsi,%rdx
add    %rdi,%rsi
callq  81 <mu_nntp_send+0x81>
mov    0x8(%rsp),%rax
sub    %rax,0x8(%rbx)
mov    %ebp,%eax
jmp    9a <mu_nntp_send+0x9a>
mov    (%rbx),%rax
mov    %rax,0x8(%rbx)
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_nntp_send (mu_nntp_t nntp)
{
  int status = 0;
  if (nntp->carrier && (nntp->io.ptr > nntp->io.buf))
    {
      size_t n = 0;
      size_t len = nntp->io.ptr - nntp->io.buf;
      if (nntp->timeout)
 {
   int ready = mu_nntp_carrier_is_ready (nntp->carrier,
      0x2,
      nntp->timeout);
   if (ready == 0)
     return 110;
 }
      status = mu_stream_write (nntp->carrier, nntp->io.buf, len, 0, &n);
      if (n)
 {
   memmove (nntp->io.buf, nntp->io.buf + n, len - n);
   nntp->io.ptr -= n;
 }
    }
  else
    nntp->io.ptr = nntp->io.buf;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 8
15 8
16 8
17 10
18 10
19 13
20 13
21 14
22 14
23 7
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 17
32 17
33 17
34 19
35 19
36 19
37 19
38 19
39 20
40 20
41 16
42 5
43 24
44 24
45 3
46 26
47 26
48 26
49 26
50 26
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
testb  $0xf,0x38(%rdi)
je     595 <nettle_gcm_encrypt+0x32>
lea    0x0(%rip),%rcx        # 57d <nettle_gcm_encrypt+0x1a>
mov    $0x1df,%edx
lea    0x0(%rip),%rsi        # 589 <nettle_gcm_encrypt+0x26>
lea    0x0(%rip),%rdi        # 590 <nettle_gcm_encrypt+0x2d>
callq  595 <nettle_gcm_encrypt+0x32>
mov    %rsi,%r13
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %r8,%rbp
mov    %r9,%r12
mov    0x30(%rsp),%r9
mov    %r12,%r8
mov    %rbp,%rcx
callq  e4 <gcm_crypt>
lea    0x20(%rbx),%rsi
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r13,%rdi
callq  5c6 <nettle_gcm_encrypt+0x63>
add    %rbp,0x38(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
nettle_gcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,
      const void *cipher, nettle_cipher_func *f,
      size_t length, uint8_t *dst, const uint8_t *src)
{
  ((ctx->data_size % 16 == 0) ? (void) (0) : __assert_fail ("ctx->data_size % 16 == 0", "gcm.c", 479, __PRETTY_FUNCTION__));
  gcm_crypt(ctx, cipher, f, length, dst, src);
  _nettle_gcm_hash8(key, &ctx->x, length, dst);
  ctx->data_size += length;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 8
29 9
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x16,%edi
jg     12 <acl_errno_valid+0x12>
cmp    $0x10,%edi
jne    22 <acl_errno_valid+0x22>
nop
jmp    1c <acl_errno_valid+0x1c>
cmp    $0x26,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x5f,%edi
jne    22 <acl_errno_valid+0x22>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 9
16 11
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r11
test   %r10,%r10
je     1e57 <gsl_matrix_float_scale+0x68>
shl    $0x2,%r11
mov    $0x0,%r9d
mov    $0x0,%r8d
jmp    1e48 <gsl_matrix_float_scale+0x59>
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
movss  (%rcx),%xmm1
cvtps2pd %xmm1,%xmm1
mulsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,(%rcx)
add    $0x1,%rax
add    $0x4,%rdx
cmp    %rsi,%rax
jne    1e11 <gsl_matrix_float_scale+0x22>
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
je     1e57 <gsl_matrix_float_scale+0x68>
test   %rsi,%rsi
je     1e3c <gsl_matrix_float_scale+0x4d>
mov    %r9,%rdx
mov    $0x0,%eax
jmp    1e11 <gsl_matrix_float_scale+0x22>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_float_scale (gsl_matrix_float * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 9
31 15
32 15
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rdi,%rax
mov    %rdx,(%rsp)
mov    %rcx,0x8(%rsp)
mov    %r8,0x10(%rsp)
cmp    $0x1,%r9d
lea    -0x62(%rip),%rdx        # 42 <des_compat_des3_encrypt>
lea    -0xab(%rip),%r8        # 0 <des_compat_des3_decrypt>
cmove  %rdx,%r8
mov    %rsp,%rdi
mov    %rax,%rcx
mov    %rsi,%rdx
mov    $0x8,%esi
callq  *%r8
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
nettle_openssl_des_ecb3_encrypt(des_cblock *src, des_cblock *dst,
   des_key_schedule k1,
   des_key_schedule k2,
   des_key_schedule k3, int enc)
{
  struct des_compat_des3 keys;
  keys.keys[0] = k1;
  keys.keys[1] = k2;
  keys.keys[2] = k3;
  ((enc == DES_ENCRYPT) ? des_compat_des3_encrypt : des_compat_des3_decrypt)
    (&keys, 8, *dst, *src);
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 8
5 9
6 10
7 10
8 10
9 10
10 11
11 11
12 11
13 11
14 11
15 12
16 12
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
movslq %esi,%rax
lea    0x0(,%rax,8),%r9
mov    0x110(%rdi),%rdx
mov    (%rdx,%rax,8),%rax
mov    0x18(%rax),%ecx
add    $0x1,%ecx
mov    %ecx,0x18(%rax)
mov    %esi,%eax
sub    $0x1,%eax
js     4d <cache_promote+0x4d>
mov    0x110(%rdi),%r8
mov    -0x8(%r8,%r9,1),%rdx
cmp    0x18(%rdx),%ecx
ja     45 <cache_promote+0x45>
jmp    4d <cache_promote+0x4d>
movslq %eax,%rdx
mov    (%r8,%rdx,8),%rdx
cmp    0x18(%rdx),%ecx
jbe    4d <cache_promote+0x4d>
sub    $0x1,%eax
cmp    $0xffffffff,%eax
jne    39 <cache_promote+0x39>
add    $0x1,%eax
cmp    %esi,%eax
je     75 <cache_promote+0x75>
mov    0x110(%rdi),%rdx
add    %rdx,%r9
mov    (%r9),%rcx
cltq   
mov    (%rdx,%rax,8),%rdx
mov    %rdx,(%r9)
mov    0x110(%rdi),%rdx
mov    %rcx,(%rdx,%rax,8)
repz retq 
<<<sep_in_sample>>>
cache_promote(struct _dict_stream *str, int n)
{
    int i;
    unsigned refcount = ++str->cache[n]->refcount;
    for (i = n - 1; i >= 0; i--)
 if (str->cache[i]->refcount >= refcount)
     break;
    i++;
    if (i != n) {
 struct _dict_chunk_cache *tmp = str->cache[n];
 str->cache[n] = str->cache[i];
 str->cache[i] = tmp;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 5
23 8
24 9
25 9
26 10
27 10
28 10
29 11
30 11
31 11
32 12
33 12
34 12
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
cmpl   $0x400,0x0(%rip)        # 4ad <tty_writec+0xd>
jne    4b9 <tty_writec+0x19>
mov    $0x0,%eax
callq  4b9 <tty_writec+0x19>
mov    0x0(%rip),%eax        # 4bf <tty_writec+0x1f>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # 4c8 <tty_writec+0x28>
cltq   
mov    %bl,0x0(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
tty_writec(c)
    int c;
{
    if (tty_index == 1024)
 tty_flush();
    tty_cache[tty_index++] = (char)c;
    return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <_tree_recurse>
test   %eax,%eax
je     491 <grecs_tree_recurse+0x12>
cmp    $0x3,%eax
jne    498 <grecs_tree_recurse+0x19>
mov    $0x0,%eax
jmp    49d <grecs_tree_recurse+0x1e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_tree_recurse(struct grecs_node *node, grecs_tree_recursor_t recfun,
     void *data)
{
 switch (_tree_recurse(node, recfun, data)) {
 case grecs_tree_recurse_ok:
 case grecs_tree_recurse_stop:
  return 0;
 default:
  break;
 }
 return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 7
8 7
9 11
10 12
11 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1e <clock_time_end+0x9>
sub    0x0(%rip),%rax        # 25 <clock_time_end+0x10>
cvtsi2sd %rax,%xmm0
divsd  0x0(%rip),%xmm0        # 32 <clock_time_end+0x1d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
clock_time_end(void)
{
  return (double) (clock() - (clock_start)) / 1000000l;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2be <rl_digit_loop+0x9>
test   %eax,%eax
jne    2fd <rl_digit_loop+0x48>
callq  2c7 <rl_digit_loop+0x12>
test   %eax,%eax
jns    2dc <rl_digit_loop+0x27>
nopl   0x0(%rax,%rax,1)
callq  2d5 <rl_digit_loop+0x20>
mov    $0xffffffff,%eax
jmp    302 <rl_digit_loop+0x4d>
mov    %eax,%esi
mov    0x0(%rip),%edi        # 2e4 <rl_digit_loop+0x2f>
mov    $0x0,%eax
callq  2ee <rl_digit_loop+0x39>
test   %eax,%eax
jle    302 <rl_digit_loop+0x4d>
testb  $0x4,0x0(%rip)        # 2f9 <rl_digit_loop+0x44>
jne    2b9 <rl_digit_loop+0x4>
jmp    302 <rl_digit_loop+0x4d>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_digit_loop ()
{
  int c, r;
  while (1)
    {
      if (_rl_arg_overflow ())
 return 1;
      c = _rl_arg_getchar ();
      if (c < 0)
 {
   _rl_abort_internal ();
   return -1;
 }
      r = _rl_arg_dispatch (_rl_argcxt, c);
      if (r <= 0 || ((rl_readline_state & (0x0000400)) == 0))
        break;
    }
  return r;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 8
6 9
7 9
8 9
9 11
10 12
11 12
12 14
13 14
14 14
15 14
16 15
17 15
18 15
19 15
20 15
21 7
22 19
23 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
cmpb   $0x0,(%rdi)
je     1d1 <grecs_hash_string_ci+0x2c>
mov    $0x0,%eax
lea    (%rax,%rax,1),%ebp
movzbl (%rbx),%edi
callq  1c4 <grecs_hash_string_ci+0x1f>
xor    %ebp,%eax
add    $0x1,%rbx
cmpb   $0x0,(%rbx)
jne    1b9 <grecs_hash_string_ci+0x14>
jmp    1d6 <grecs_hash_string_ci+0x31>
mov    $0x0,%eax
mov    %eax,%eax
mov    $0x0,%edx
div    %r12
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_hash_string_ci(const char *name, unsigned long hashsize)
{
 unsigned i;
 for (i = 0; *name; name++) {
  i <<= 1;
  i ^= tolower (*(unsigned char*) name);
 }
 return i % hashsize;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 6
13 4
14 4
15 4
16 4
17 4
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
movslq %edi,%rbx
mov    0x0(,%rbx,8),%rsi
callq  293 <restore_signal+0x18>
mov    $0x0,%esi
mov    %ebp,%edi
callq  1fc <change_signal>
andl   $0xfffffffe,0x0(,%rbx,4)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
restore_signal (sig)
     int sig;
{
  set_signal_handler (sig, original_signals[sig]);
  change_signal (sig, (char *)((__sighandler_t) 0));
  sigmodes[sig] &= ~0x1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
test   %edi,%edi
jne    34 <mu_tls_module_init+0x34>
test   %rsi,%rsi
je     34 <mu_tls_module_init+0x34>
mov    (%rsi),%rax
mov    %rax,0x0(%rip)        # 13 <mu_tls_module_init+0x13>
mov    0x8(%rsi),%rax
mov    %rax,0x0(%rip)        # 1e <mu_tls_module_init+0x1e>
mov    0x10(%rsi),%rax
mov    %rax,0x0(%rip)        # 29 <mu_tls_module_init+0x29>
mov    0x18(%rsi),%rax
mov    %rax,0x0(%rip)        # 34 <mu_tls_module_init+0x34>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_tls_module_init (enum mu_gocs_op op, void *data)
{
  switch (op)
    {
    case mu_gocs_op_set:
      if (data)
 memcpy (&mu_tls_module_config, data, sizeof mu_tls_module_config);
      break;
    case mu_gocs_op_flush:
      break;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 13
14 13
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
cmplesd %xmm1,%xmm2
andpd  %xmm2,%xmm0
andnpd %xmm1,%xmm2
orpd   %xmm2,%xmm0
retq   
<<<sep_in_sample>>>
minimus(double x,double y)
{
 if(x<=y) return(x);
 else return(y);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
<<<sep_out_sample>>>
mov    %rdx,0x10(%rsi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gl_linked_node_nx_set_value (gl_list_t list, gl_list_node_t node,
                             const void *elt)
{
  node->value = elt;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # c <defined+0xc>
jne    63 <defined+0x63>
mov    $0x0,%edi
callq  18 <defined+0x18>
test   %rax,%rax
mov    $0x0,%edx
cmove  %rdx,%rax
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  36 <defined+0x36>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  4d <defined+0x4d>
mov    %rax,0x0(%rip)        # 54 <defined+0x54>
test   %rax,%rax
jne    63 <defined+0x63>
mov    $0x0,%edi
callq  63 <defined+0x63>
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 6d <defined+0x6d>
callq  72 <defined+0x72>
test   %rax,%rax
setne  %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
defined(const char *name)
{
 if (dbop == ((void *)0)) {
  const char *dbpath;
  if (!(dbpath = getenv("GTAGSDBPATH")))
   dbpath = ".";
  dbop = dbop_open(makepath(dbpath, "GTAGS", ((void *)0)), 0, 0, 0);
  if (dbop == ((void *)0))
   die("'GTAGS' not found.");
 }
 if (dbop_get(dbop, name))
  return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 11
30 14
31 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdx),%r8
cmp    $0x5,%r8
ja     5214 <_jit_getarg_i+0x25>
mov    $0xd,%ecx
sub    %r8,%rcx
movslq %esi,%rdx
mov    $0x51,%esi
callq  5212 <_jit_getarg_i+0x23>
jmp    5226 <_jit_getarg_i+0x37>
movslq %esi,%rdx
mov    $0xf,%ecx
mov    $0x6d,%esi
callq  5226 <_jit_getarg_i+0x37>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_jit_getarg_i(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6)) {
 _jit_new_node_ww(_jit,jit_code_extr_i,u,_RDI - v->u.w);
     }
    else
 _jit_new_node_www(_jit,jit_code_ldxi_i,u,_RBP,v->u.w);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 8
13 8
14 8
15 9
16 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %edi,0xc(%rsp)
movq   $0x0,0x18(%rsp)
lea    0xc(%rsp),%rdx
mov    $0x1,%esi
lea    0x18(%rsp),%rdi
callq  b7c <mu_get_auth_by_uid+0x25>
mov    0x18(%rsp),%rax
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
mu_get_auth_by_uid (uid_t uid)
{
  struct mu_auth_data *auth = ((void *)0);
  mu_get_auth (&auth, mu_auth_key_uid, &uid);
  return auth;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r13
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%rbx
test   %r8,%r8
mov    $0x0,%eax
cmove  %rax,%rbx
callq  e10 <quotearg_buffer+0x30>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    0x4(%rbx),%r9d
mov    0x30(%rbx),%rax
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    0x18(%rsp),%rdi
callq  e7 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
mov    $0x8,%eax
retq   
<<<sep_in_sample>>>
rk8pd_order (void *vstate)
{
  rk8pd_state_t *state = (rk8pd_state_t *) vstate;
  state = 0;
  return 8;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,0x8(%rsp)
ucomisd 0x0(%rip),%xmm0        # 12 <gsl_acosh+0x12>
jbe    26 <gsl_acosh+0x26>
callq  19 <gsl_acosh+0x19>
addsd  0x0(%rip),%xmm0        # 21 <gsl_acosh+0x21>
jmpq   119 <gsl_acosh+0x119>
movsd  0x8(%rsp),%xmm6
ucomisd 0x0(%rip),%xmm6        # 34 <gsl_acosh+0x34>
jbe    95 <gsl_acosh+0x95>
movapd %xmm6,%xmm1
mulsd  %xmm6,%xmm1
subsd  0x0(%rip),%xmm1        # 46 <gsl_acosh+0x46>
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    69 <gsl_acosh+0x69>
movapd %xmm6,%xmm0
mulsd  %xmm6,%xmm0
subsd  0x0(%rip),%xmm0        # 60 <gsl_acosh+0x60>
callq  65 <gsl_acosh+0x65>
movapd %xmm0,%xmm1
movsd  0x8(%rsp),%xmm2
movapd %xmm2,%xmm0
addsd  %xmm2,%xmm0
addsd  %xmm2,%xmm1
movsd  0x0(%rip),%xmm2        # 83 <gsl_acosh+0x83>
divsd  %xmm1,%xmm2
subsd  %xmm2,%xmm0
callq  90 <gsl_acosh+0x90>
jmpq   119 <gsl_acosh+0x119>
movsd  0x8(%rsp),%xmm7
ucomisd 0x0(%rip),%xmm7        # a3 <gsl_acosh+0xa3>
jbe    fb <gsl_acosh+0xfb>
movapd %xmm7,%xmm4
subsd  0x0(%rip),%xmm4        # b1 <gsl_acosh+0xb1>
movsd  %xmm4,0x8(%rsp)
movapd %xmm4,%xmm1
addsd  %xmm4,%xmm1
movapd %xmm4,%xmm0
mulsd  %xmm4,%xmm0
addsd  %xmm1,%xmm0
sqrtsd %xmm0,%xmm0
ucomisd %xmm0,%xmm0
jnp    ee <gsl_acosh+0xee>
movapd %xmm4,%xmm0
mulsd  %xmm4,%xmm0
movapd %xmm4,%xmm1
addsd  %xmm4,%xmm1
addsd  %xmm1,%xmm0
callq  ee <gsl_acosh+0xee>
addsd  0x8(%rsp),%xmm0
callq  f9 <gsl_acosh+0xf9>
jmp    119 <gsl_acosh+0x119>
movsd  0x8(%rsp),%xmm7
ucomisd 0x0(%rip),%xmm7        # 109 <gsl_acosh+0x109>
jp     111 <gsl_acosh+0x111>
xorpd  %xmm0,%xmm0
je     119 <gsl_acosh+0x119>
movsd  0x0(%rip),%xmm0        # 119 <gsl_acosh+0x119>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_acosh (const double x)
{
  if (x > 1.0 / 1.4901161193847656e-08)
    {
      return log (x) + 0.69314718055994530942;
    }
  else if (x > 2)
    {
      return log (2 * x - 1 / (sqrt (x * x - 1) + x));
    }
  else if (x > 1)
    {
      double t = x - 1;
      return log1p (t + sqrt (2 * t + t * t));
    }
  else if (x == 1)
    {
      return 0;
    }
  else
    {
      return (__builtin_nanf (""));
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 11
32 11
33 11
34 13
35 13
36 13
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 14
54 16
55 16
56 16
57 18
58 16
59 22
60 24
61 24
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x20(%rsi),%rax
mov    %rax,(%rsp)
mov    (%rsi),%rax
mov    0x20(%rsi,%rax,8),%rax
add    $0x2,%rax
mov    %rax,0x8(%rsp)
mov    0x18(%rsi),%rsi
mov    %rsp,%rdx
callq  815 <atat_put+0x29>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
atat_put (FILE *to, struct atat const *atat)
{
  struct range range =
    {
      .beg = atat->beg,
      .end = (((atat)->holes[(atat)->count - 1]) + 2)
    };
  fro_spew_partial (to, atat->from, &range);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 6
5 6
6 6
7 3
8 8
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     e0 <osip_uri_set_scheme+0x8>
mov    %rsi,(%rdi)
repz retq 
<<<sep_in_sample>>>
osip_uri_set_scheme (osip_uri_t * url, char *scheme)
{
  if (url == ((void *)0))
    return;
  url->scheme = scheme;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
mov    0x40(%rax),%rdi
test   %rdi,%rdi
je     c1 <select_menu_digit+0x80>
movzbl %sil,%esi
sub    $0x30,%esi
je     6b <select_menu_digit+0x2a>
mov    (%rdi),%rax
mov    $0x0,%ecx
mov    $0x0,%edx
test   %rax,%rax
jne    95 <select_menu_digit+0x54>
jmp    b9 <select_menu_digit+0x78>
mov    (%rdi),%rax
test   %rax,%rax
je     cc <select_menu_digit+0x8b>
mov    $0x0,%ecx
mov    $0xffffffff,%edx
cmpl   $0x1,0x28(%rax)
cmove  %ecx,%edx
add    $0x1,%ecx
movslq %ecx,%rax
mov    (%rdi,%rax,8),%rax
test   %rax,%rax
jne    7d <select_menu_digit+0x3c>
jmp    b4 <select_menu_digit+0x73>
cmpl   $0x1,0x28(%rax)
sete   %al
movzbl %al,%eax
add    %eax,%ecx
cmp    %esi,%ecx
je     b4 <select_menu_digit+0x73>
add    $0x1,%edx
movslq %edx,%rax
mov    (%rdi,%rax,8),%rax
test   %rax,%rax
jne    95 <select_menu_digit+0x54>
cmp    $0xffffffff,%edx
je     c7 <select_menu_digit+0x86>
movslq %edx,%rdx
mov    (%rdi,%rdx,8),%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
select_menu_digit (WINDOW *window, unsigned char key)
{
  register int i, item;
  register REFERENCE **menu;
  menu = window->node->references;
  if (!menu)
    return 0;
  item = key - '0';
  if (item == 0)
    {
      int j;
      i = -1;
      for (j = 0; menu[j]; j++)
        if (menu[j]->type == 1)
          i = j;
    }
  else
    {
      int k = 0;
      for (i = 0; menu[i]; i++)
        {
          if (menu[i]->type == 1)
            k++;
          if (k == item)
            break;
        }
    }
  if (i == -1)
    return 0;
  return menu[i];
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 8
6 9
7 9
8 20
9 20
10 20
11 20
12 20
13 20
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 23
28 23
29 23
30 23
31 24
32 24
33 20
34 20
35 20
36 20
37 20
38 28
39 28
40 30
41 30
42 30
43 7
44 7
45 29
46 31
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x98,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
test   %esi,%esi
jne    30c <strbuf_putn+0x62>
mov    0x10(%rdi),%rax
cmp    %rax,0x18(%rdi)
jb     2dc <strbuf_putn+0x32>
callq  2dc <strbuf_putn+0x32>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
movb   $0x30,(%rax)
jmpq   372 <strbuf_putn+0xc8>
add    $0x1,%rcx
cmp    $0x80,%rcx
jne    316 <strbuf_putn+0x6c>
mov    $0x0,%edi
mov    $0x0,%eax
callq  30c <strbuf_putn+0x62>
mov    $0x0,%ecx
mov    $0x66666667,%edi
mov    %ecx,%ebp
mov    %esi,%eax
imul   %edi
sar    $0x2,%edx
mov    %esi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%esi
add    $0x30,%esi
mov    %sil,(%rsp,%rcx,1)
mov    %edx,%esi
test   %edx,%edx
jne    2f0 <strbuf_putn+0x46>
test   %ecx,%ecx
js     372 <strbuf_putn+0xc8>
mov    0x10(%rbx),%rax
cmp    %rax,0x18(%rbx)
jb     355 <strbuf_putn+0xab>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  355 <strbuf_putn+0xab>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
movslq %ebp,%rdx
movzbl (%rsp,%rdx,1),%edx
mov    %dl,(%rax)
sub    $0x1,%ebp
cmp    $0xffffffff,%ebp
jne    33e <strbuf_putn+0x94>
mov    0x88(%rsp),%rax
xor    %fs:0x28,%rax
je     38a <strbuf_putn+0xe0>
callq  38a <strbuf_putn+0xe0>
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
strbuf_putn(STRBUF *sb, int n)
{
 if (n == 0) {
  do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = '0';} while (0);
 } else {
  char num[128];
  int i = 0;
  while (n) {
   if (i >= sizeof(num))
    die("Too big integer value.");
   num[i++] = n % 10 + '0';
   n = n / 10;
  }
  while (--i >= 0)
   do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = num[i];} while (0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 9
21 9
22 10
23 10
24 10
25 3
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 12
40 8
41 8
42 14
43 14
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 15
55 15
56 14
57 14
58 14
59 17
60 17
61 17
62 17
63 17
64 17
65 17
66 17
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm2        # 22c <gsl_complex_conjugate+0x8>
xorpd  %xmm2,%xmm1
retq   
<<<sep_in_sample>>>
gsl_complex_conjugate (gsl_complex a)
{
  gsl_complex z;
  do {(&z)->dat[0]=(((a).dat[0])); (&z)->dat[1]=(-((a).dat[1]));} while(0);
  return z;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    (%rdi),%rdi
callq  225 <gsl_spline_eval+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline_eval (const gsl_spline * spline,
                 double x,
                 gsl_interp_accel * a)
{
  return gsl_interp_eval (spline->interp,
                          spline->x, spline->y,
                          x, a);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     82f <api_lintwarn+0x57>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%rbx
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    $0xdc,%esi
mov    $0x0,%edi
callq  868 <api_lintwarn+0x90>
cmpq   $0x0,0x0(%rip)        # 873 <api_lintwarn+0x9b>
jne    896 <api_lintwarn+0xbe>
mov    $0x0,%edi
callq  87f <api_lintwarn+0xa7>
lea    0x8(%rsp),%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x1,%edi
callq  894 <api_lintwarn+0xbc>
jmp    8b5 <api_lintwarn+0xdd>
mov    $0x0,%edi
callq  8a0 <api_lintwarn+0xc8>
lea    0x8(%rsp),%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
callq  8b5 <api_lintwarn+0xdd>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
api_lintwarn(awk_ext_id_t id, const char *format, ...)
{
 va_list args;
 (void) id;
 __builtin_va_start(args,format);
 if ((*(set_loc("gawkapi.c", 220),lintfunc)) == r_fatal) {
  err(1, gettext("fatal: "), format, args);
 } else {
  err(0, gettext("warning: "), format, args);
 }
 __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 6
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 12
45 12
46 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %edi,%ebx
mov    %rsi,%rbp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     2e0b <eval_error+0x58>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0xf8(%rbp),%rsi
lea    0x8(%rsp),%r8
mov    %rdx,%rcx
mov    $0x0,%edx
mov    0x0(%rip),%rdi        # 2e4d <eval_error+0x9a>
callq  *0x0(%rip)        # 2e53 <eval_error+0xa0>
test   %ebx,%ebx
je     2e62 <eval_error+0xaf>
lea    0x30(%rbp),%rdi
mov    %ebx,%esi
callq  2e62 <eval_error+0xaf>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
eval_error (int retcode, struct eval_env *env, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc_error_printer (rc_error_printer_data, &env->loc, ((void *)0), fmt, ap);
  __builtin_va_end(ap);
  if (retcode)
    longjmp(env->jmp, retcode);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 5
31 7
32 7
33 8
34 8
35 8
36 9
37 9
38 9
39 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     3eb <assoc_to_header+0x5d>
mov    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
mov    0x8(%rbx),%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
sub    %rsi,%rdx
mov    %rdx,%rdi
callq  3cd <assoc_to_header+0x3f>
mov    %rax,%rbp
mov    0x8(%rbx),%rcx
mov    (%rbx),%rdx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  3e9 <assoc_to_header+0x5b>
jmp    3f7 <assoc_to_header+0x69>
mov    0x8(%rbx),%rdi
callq  3f4 <assoc_to_header+0x66>
mov    %rax,%rbp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
assoc_to_header (ASSOC * asc)
{
  char *buf;
  if (asc->key)
    {
      buf = xmalloc (strlen (asc->key) + strlen (asc->value) + 3);
      sprintf (buf, "%s: %s", asc->key, asc->value);
    }
  else
    buf = strdup (asc->value);
  return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 10
30 10
31 10
32 12
33 12
34 12
35 12
36 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %esi,%r9d
mov    $0x28,%r8d
mov    $0x28,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xff,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
and    $0x7,%ebp
or     $0xffffffd0,%ebp
mov    %bpl,(%rax)
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_callr(jit_state_t *_jit, jit_int32_t r0)
{
    _rex(_jit, 0, 0, _NOREG, _NOREG, r0);
    *_jit->pc.uc++ = 0xff;
    *_jit->pc.uc++ = (0x03<<6) | (0x02<<3) | ((r0) & 7);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  2ae <reset_or_restore_signal_handlers>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
reset_signal_handlers ()
{
  reset_or_restore_signal_handlers (reset_signal);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
cmp    %rdx,%rax
ja     5550 <gsl_matrix_float_const_subdiagonal+0x4d>
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5528 <gsl_matrix_float_const_subdiagonal+0x25>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    5590 <gsl_matrix_float_const_subdiagonal+0x8d>
mov    0x10(%rsi),%rcx
lea    0x0(,%rcx,4),%r8
imul   %rdx,%r8
add    0x18(%rsi),%r8
mov    0x20(%rsi),%rdi
sub    %rdx,%rax
mov    0x8(%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
add    $0x1,%rcx
mov    %rcx,0x8(%rbx)
mov    %r8,0x10(%rbx)
mov    %rdi,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_float_const_subdiagonal (const gsl_matrix_float * m,
                                    const size_t k)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 14
22 12
23 12
24 12
25 12
26 17
27 13
28 13
29 17
30 17
31 17
32 19
33 19
34 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%esi
callq  3f8 <readrefs+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    412 <readrefs+0x2d>
mov    %rbp,%rdi
callq  408 <readrefs+0x23>
mov    $0x0,%edx
jmpq   4cc <readrefs+0xe7>
mov    %rax,%rdi
callq  41a <readrefs+0x35>
mov    %eax,%ebp
mov    $0x0,%edx
cmp    $0xffffffff,%eax
je     4cc <readrefs+0xe7>
movl   $0x0,0x0(%rip)        # 434 <readrefs+0x4f>
movl   $0x0,0x0(%rip)        # 43e <readrefs+0x59>
movl   $0x1,0x0(%rip)        # 448 <readrefs+0x63>
callq  44d <readrefs+0x68>
mov    $0x1,%edx
cmp    $0x1,%eax
jne    4cc <readrefs+0xe7>
mov    0x0(%rip),%rsi        # 45e <readrefs+0x79>
mov    %ebp,%edi
callq  465 <readrefs+0x80>
jmp    475 <readrefs+0x90>
mov    0x0(%rip),%rsi        # 46e <readrefs+0x89>
mov    %eax,%edi
callq  475 <readrefs+0x90>
mov    %rbx,%rdi
callq  47d <readrefs+0x98>
cmp    $0xffffffff,%eax
jne    467 <readrefs+0x82>
mov    %rbx,%rdi
callq  48a <readrefs+0xa5>
mov    0x0(%rip),%rdi        # 491 <readrefs+0xac>
callq  496 <readrefs+0xb1>
mov    $0x0,%esi
mov    $0x0,%edi
callq  4a5 <readrefs+0xc0>
mov    %rax,0x0(%rip)        # 4ac <readrefs+0xc7>
test   %rax,%rax
jne    4c2 <readrefs+0xdd>
mov    $0x0,%edi
callq  4bb <readrefs+0xd6>
mov    $0x0,%edx
jmp    4cc <readrefs+0xe7>
callq  4c7 <readrefs+0xe2>
mov    $0x1,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
readrefs(char *filename)
{
 FILE *file;
 int c;
 if ((file = myfopen(filename, "rb")) == ((void *)0)) {
  cannotopen(filename);
  return(NO);
 }
 if ((c = _IO_getc (file)) == (-1)) {
  return(NO);
 }
 totallines = 0;
 disprefs = 0;
 nextline = 1;
 if (writerefsfound() == YES) {
  _IO_putc (c, refsfound);
  while ((c = _IO_getc (file)) != (-1)) {
   _IO_putc (c, refsfound);
  }
  fclose(file);
  fclose(refsfound);
  if ( (refsfound = myfopen(temp1, "rb")) == ((void *)0)) {
   cannotopen(temp1);
   return(NO);
  }
  countrefs();
 }
 return(YES);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 9
15 9
16 9
17 10
18 9
19 9
20 12
21 13
22 14
23 15
24 28
25 15
26 15
27 16
28 16
29 16
30 17
31 18
32 18
33 18
34 17
35 17
36 17
37 17
38 20
39 20
40 21
41 21
42 22
43 22
44 22
45 22
46 22
47 22
48 23
49 23
50 24
51 24
52 26
53 28
54 29
55 29
56 29
57 29
58 29
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 196 <cr+0x7>
test   %rdi,%rdi
je     1bc <cr+0x2d>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x1,%esi
callq  1ae <cr+0x1f>
movl   $0x0,0x0(%rip)        # 1b8 <cr+0x29>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
cr ()
{
  if (_rl_term_cr)
    {
      tputs (_rl_term_cr, 1, _rl_output_character_function);
      _rl_last_c_pos = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 5
8 6
9 8
10 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
movl   $0x0,0x0(%rip)        # ffb <dologout+0xd>
mov    $0x0,%edi
callq  1f4 <end_login>
mov    %ebx,%edi
callq  100c <myoob>
<<<sep_in_sample>>>
dologout (int status)
{
  transflag = 0;
  end_login (&cred);
  _exit (status);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r13
mov    %rsi,%r14
mov    %rdx,%r15
callq  a43 <quotearg_alloc+0x1c>
mov    %rax,%rbp
mov    (%rax),%eax
mov    %eax,0xc(%rsp)
mov    %r15,%r8
mov    %r14,%rcx
mov    %r13,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a64 <quotearg_alloc+0x3d>
lea    0x1(%rax),%r12
mov    %r12,%rdi
callq  a70 <quotearg_alloc+0x49>
mov    %rax,%rbx
mov    %r15,%r8
mov    %r14,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  a87 <quotearg_alloc+0x60>
mov    0xc(%rsp),%eax
mov    %eax,0x0(%rbp)
mov    %rbx,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
  struct quoting_options const *o)
{
  int e = (*__errno_location ());
  size_t bufsize = quotearg_buffer (0, 0, arg, argsize, o) + 1;
  char *buf = xcharalloc (bufsize);
  quotearg_buffer (buf, bufsize, arg, argsize, o);
  (*__errno_location ()) = e;
  return buf;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 7
26 7
27 7
28 7
29 7
30 7
31 8
32 8
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
jns    1a <rpl_fclose+0x1a>
mov    %rbx,%rdi
callq  18 <rpl_fclose+0x18>
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  22 <rpl_fclose+0x22>
test   %eax,%eax
je     45 <rpl_fclose+0x45>
mov    %rbx,%rdi
callq  2e <rpl_fclose+0x2e>
mov    $0x1,%edx
mov    $0x0,%esi
mov    %eax,%edi
callq  3f <rpl_fclose+0x3f>
cmp    $0xffffffffffffffff,%rax
je     74 <rpl_fclose+0x74>
mov    %rbx,%rdi
callq  4d <rpl_fclose+0x4d>
test   %eax,%eax
je     74 <rpl_fclose+0x74>
callq  56 <rpl_fclose+0x56>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    %rbx,%rdi
callq  64 <rpl_fclose+0x64>
test   %r12d,%r12d
je     7c <rpl_fclose+0x7c>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  7c <rpl_fclose+0x7c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 7
8 8
9 8
10 8
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 15
35 16
36 16
37 12
38 12
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  c09 <sv_histignore+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sv_histignore (name)
     char *name;
{
  setup_history_ignore (name);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
callq  8c3 <digest_md5_print_finish+0xd>
mov    $0x0,%edx
test   %eax,%eax
jne    8ee <digest_md5_print_finish+0x38>
mov    %rbx,%rdx
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
callq  8de <digest_md5_print_finish+0x28>
test   %eax,%eax
js     8e9 <digest_md5_print_finish+0x33>
mov    0x8(%rsp),%rdx
jmp    8ee <digest_md5_print_finish+0x38>
mov    $0x0,%edx
mov    %rdx,%rax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
digest_md5_print_finish (digest_md5_finish * finish)
{
  char *out;
  if (digest_md5_validate_finish (finish) != 0)
    return ((void *)0);
  if (asprintf (&out, "rspauth=%s", finish->rspauth) < 0)
    return ((void *)0);
  return out;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 7
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 312 <newCraft+0x8>
je     32a <newCraft+0x20>
mov    $0x0,%eax
mov    $0x1,%edx
cmpq   $0x0,(%rax)
jne    3cf <newCraft+0xc5>
jmp    32f <newCraft+0x25>
mov    $0x0,%edx
movslq %edx,%rax
imul   $0x5a0,%rax,%rax
lea    0x0(%rax),%r8
mov    %r8,%rdi
mov    $0x12c0,%esi
test   $0x1,%r8b
je     35c <newCraft+0x52>
movb   $0x0,0x0(%rax)
lea    0x1(%r8),%rdi
mov    $0xbf,%sil
test   $0x2,%dil
je     36e <newCraft+0x64>
movw   $0x0,(%rdi)
add    $0x2,%rdi
sub    $0x2,%esi
test   $0x4,%dil
je     381 <newCraft+0x77>
movl   $0x0,(%rdi)
add    $0x4,%rdi
sub    $0x4,%esi
mov    %esi,%ecx
shr    $0x3,%ecx
mov    %ecx,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
test   $0x4,%sil
je     3a0 <newCraft+0x96>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     3af <newCraft+0xa5>
movw   $0x0,(%rdi)
add    $0x2,%rdi
test   $0x1,%sil
je     3b8 <newCraft+0xae>
movb   $0x0,(%rdi)
movslq %edx,%rdx
imul   $0x5a0,%rdx,%rdx
movq   $0x0,0x0(%rdx)
jmp    3ea <newCraft+0xe0>
add    $0x1,%edx
add    $0x5a0,%rax
cmp    $0x80,%edx
jne    31e <newCraft+0x14>
mov    $0x0,%r8d
mov    %r8,%rax
retq   
<<<sep_in_sample>>>
newCraft(void)
{
 int i;
 for (i = 0; i < 128; ++i)
  if (ctype[i].name == (char *) ((void *)0)) {
   memset (&ctype[i], 0, sizeof (craft));
   ctype[i].name = "*allocated*";
   return &ctype[i];
  }
 return (craftType *) ((void *)0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 4
5 5
6 5
7 5
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 6
42 6
43 6
44 6
45 7
46 7
47 7
48 8
49 4
50 4
51 4
52 4
53 10
54 11
55 11
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 516 <flush_outbuf+0x6>
test   %edx,%edx
je     549 <flush_outbuf+0x39>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    0x0(%rip),%edi        # 529 <flush_outbuf+0x19>
callq  52e <flush_outbuf+0x1e>
mov    0x0(%rip),%eax        # 534 <flush_outbuf+0x24>
add    %rax,0x0(%rip)        # 53b <flush_outbuf+0x2b>
movl   $0x0,0x0(%rip)        # 545 <flush_outbuf+0x35>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
flush_outbuf()
{
    if (outcnt == 0) return;
    write_buf(ofd, (char *)outbuf, outcnt);
    bytes_out += (off_t)outcnt;
    outcnt = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 5
9 5
10 6
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # ca3 <print_file+0xf>
mov    0x0(%rip),%rdi        # caa <print_file+0x16>
callq  caf <print_file+0x1b>
callq  cb4 <print_file+0x20>
test   %eax,%eax
jne    caf <print_file+0x1b>
cmpl   $0x0,0x0(%rip)        # cbf <print_file+0x2b>
je     cc6 <print_file+0x32>
callq  cc6 <print_file+0x32>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_file(void)
{
  file_page_number = 0;
  set_get_char(current_filename);
  while (print_page());
  if (new_sheet_after_file)
    {
      fill_sheet_with_blank_pages();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
7 5
8 6
9 6
10 8
11 10
12 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x1,%ecx
jne    105e <getescape+0x23>
movsbl (%rbx),%eax
jmp    109e <getescape+0x63>
mov    $0x0,%eax
cmpb   $0x5c,(%rbx)
jne    109e <getescape+0x63>
sub    $0x2,%ecx
cmp    $0x2,%ecx
ja     109e <getescape+0x63>
add    $0x1,%rbx
mov    $0x8,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1086 <getescape+0x4b>
add    $0x1,%rbx
movzbl (%rbx),%edx
test   %dl,%dl
je     109e <getescape+0x63>
sub    $0x30,%edx
cmp    $0x8,%dl
jbe    1086 <getescape+0x4b>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
getescape (register char *p)
{
  long val;
  int len;
  len = strlen (p);
  if (len == 1)
    return ((u_int) * p);
  if (*p == '\\' && len >= 2 && len <= 4)
    {
      val = strtol (++p, ((void *)0), 8);
      for (;;)
 {
   if (!*++p)
     return ((u_int) val);
   if (*p < '0' || *p > '8')
     break;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 19
13 8
14 8
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 13
24 13
25 13
26 13
27 15
28 15
29 15
30 19
31 20
32 20
<<<sep_out_sample>>>
mov    (%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     135 <wx_entry_hash_1+0x2e>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    116 <wx_entry_hash_1+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
wx_entry_hash_1 (struct wx_entry *wx_entry)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((wx_entry->glyph)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
callq  164 <pair_table_free+0xe>
mov    %rbx,%rdi
callq  16c <pair_table_free+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
pair_table_free (struct pair_htable * table)
{
  hash_free (table, (hash_map_func_t) pair_free);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rcx
mov    %rdx,%r8
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    (%rdi),%rdi
callq  209 <gsl_spline_eval_e+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline_eval_e (const gsl_spline * spline,
                   double x,
                   gsl_interp_accel * a, double *y)
{
  return gsl_interp_eval_e (spline->interp,
                            spline->x, spline->y,
                            x, a, y);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 8
9 8
<<<sep_out_sample>>>
push   %rbx
cmp    $0x8,%esi
ja     69 <_linetrimstr_ioctl+0x69>
mov    %rdx,%rbx
mov    %esi,%esi
jmpq   *0x0(,%rsi,8)
mov    (%rdi),%rax
mov    %rax,(%rdx)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
mov    %rdx,(%rdi)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
mov    (%rdi),%rdi
callq  31 <_linetrimstr_ioctl+0x31>
mov    %rax,(%rbx)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
mov    (%rdi),%rdi
callq  43 <_linetrimstr_ioctl+0x43>
mov    %rax,(%rbx)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
mov    (%rdx),%rax
mov    %rax,0x10(%rdi)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
mov    0x10(%rdi),%rax
mov    %rax,(%rdx)
mov    $0x0,%eax
jmp    79 <_linetrimstr_ioctl+0x79>
callq  6e <_linetrimstr_ioctl+0x6e>
movl   $0x16,(%rax)
mov    $0xffffffff,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_linetrimstr_ioctl(void *data, int code, void *call_data)
{
    struct _linetrimstr *s = data;
    switch (code) {
    case 0:
 *(dico_stream_t*)call_data = s->transport;
 break;
    case 1:
 s->transport = call_data;
 break;
    case 5:
 *(off_t*)call_data = dico_stream_bytes_in(s->transport);
 break;
    case 6:
 *(off_t*)call_data = dico_stream_bytes_out(s->transport);
 break;
    case 7:
 s->maxlen = *(size_t*)call_data;
 break;
    case 8:
 *(size_t*)call_data = s->maxlen;
 break;
    default:
 (*__errno_location ()) = 22;
 return -1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 27
10 7
11 9
12 27
13 10
14 12
15 12
16 12
17 27
18 13
19 15
20 15
21 15
22 27
23 16
24 18
25 18
26 27
27 19
28 21
29 21
30 27
31 22
32 24
33 24
34 25
35 28
36 28
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rsi),%rdi
callq  acd <rc_mark_loc+0x14>
mov    %rax,(%rbx)
mov    0x8(%rbp),%rax
mov    %rax,0x8(%rbx)
mov    0x10(%rbp),%rax
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rc_mark_loc (RC_LOC *dst, RC_LOC *src)
{
  dst->file = string_create (src->file);
  dst->line = src->line;
  dst->column = src->column;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 5
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,0x0(%rip)        # 16b2 <dap_sr+0xc>
cvtsi2sd %edi,%xmm1
movsd  %xmm1,0x0(%rip)        # 16be <dap_sr+0x18>
movsd  0x0(%rip),%xmm0        # 16c6 <dap_sr+0x20>
subsd  %xmm0,%xmm1
movsd  %xmm1,0x0(%rip)        # 16d2 <dap_sr+0x2c>
cvtsi2sd %esi,%xmm1
movsd  %xmm1,0x0(%rip)        # 16de <dap_sr+0x38>
sub    $0x1,%esi
cvtsi2sd %esi,%xmm2
movsd  %xmm2,0x0(%rip)        # 16ed <dap_sr+0x47>
mulsd  0x0(%rip),%xmm1        # 16f5 <dap_sr+0x4f>
movapd %xmm1,%xmm4
mulsd  0x0(%rip),%xmm4        # 1701 <dap_sr+0x5b>
movsd  0x0(%rip),%xmm5        # 1709 <dap_sr+0x63>
movsd  %xmm5,0x8(%rsp)
movapd %xmm0,%xmm2
ucomisd %xmm0,%xmm1
jbe    1739 <dap_sr+0x93>
subsd  %xmm2,%xmm1
movapd %xmm4,%xmm3
divsd  %xmm1,%xmm3
mulsd  0x8(%rsp),%xmm3
movsd  %xmm3,0x8(%rsp)
ucomisd %xmm2,%xmm1
ja     1719 <dap_sr+0x73>
jmp    1747 <dap_sr+0xa1>
movsd  0x0(%rip),%xmm6        # 1741 <dap_sr+0x9b>
movsd  %xmm6,0x8(%rsp)
ucomisd 0x0(%rip),%xmm1        # 174f <dap_sr+0xa9>
jp     177c <dap_sr+0xd6>
jne    177c <dap_sr+0xd6>
sqrtsd %xmm4,%xmm0
ucomisd %xmm0,%xmm0
jnp    1766 <dap_sr+0xc0>
movapd %xmm4,%xmm0
callq  1766 <dap_sr+0xc0>
divsd  0x0(%rip),%xmm0        # 176e <dap_sr+0xc8>
mulsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x8(%rsp)
jmp    1788 <dap_sr+0xe2>
mulsd  0x8(%rsp),%xmm4
movsd  %xmm4,0x8(%rsp)
mov    $0x40,%esi
movsd  0x0(%rip),%xmm1        # 1795 <dap_sr+0xef>
xorpd  %xmm0,%xmm0
mov    $0x0,%edi
callq  17a3 <dap_sr+0xfd>
mulsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
dap_sr(int numdf, int dendf, double pt0)
{
  double c;
  double dn, dn1;
  pt = pt0;
  dnumdf = (double) numdf;
  numdfm1 = (double) (dnumdf - 1);
  ddendf = (double) dendf;
  dendfm1 = (double) (dendf - 1);
  for (dn = 0.5 * ddendf, dn1 = dn * 0.36787944117144234115, c = 2.0; dn > 1.0; dn -= 1.0)
    c *= dn1 / (dn - 1.0);
  if (dn == 0.5)
    c *= sqrt(dn1) / 1.772453850905516027297;
  else
    c *= dn1;
  return c * dap_simp(&sturf, 0.0, 1.0, 64);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 6
5 7
6 7
7 7
8 8
9 8
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 11
19 10
20 10
21 11
22 11
23 11
24 11
25 11
26 10
27 10
28 10
29 10
30 10
31 12
32 12
33 12
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 15
44 15
45 16
46 16
47 16
48 16
49 16
50 16
51 17
52 17
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1f13 <cpp_set_in+0x7>
retq   
<<<sep_in_sample>>>
cpp_set_in (FILE * in_str )
{
        cpp_in = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    50c <dico_list_get_comparator+0x1b>
sub    $0x8,%rsp
callq  4ff <dico_list_get_comparator+0xe>
movl   $0x16,(%rax)
mov    $0x0,%eax
jmp    511 <dico_list_get_comparator+0x20>
mov    0x28(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dico_list_get_comparator(struct dico_list *list)
{
    if (!list) {
 (*__errno_location ()) = 22;
 return ((void *)0);
    }
    return list->comp;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 5
7 5
8 7
9 7
10 8
11 8
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     2b8 <hash_delete_at+0x1d>
mov    0x0(%rip),%rdx        # 2aa <hash_delete_at+0xf>
cmp    %rdx,%rax
je     2be <hash_delete_at+0x23>
mov    %rdx,(%rsi)
subq   $0x1,0x18(%rdi)
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
hash_delete_at (struct hash_table_s* ht, void const *slot)
{
  void *item = *(void **) slot;
  if (!((item) == 0 || (void *) (item) == hash_deleted_item))
    {
      *(void const **) slot = hash_deleted_item;
      ht->ht_fill--;
      return item;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 6
8 7
9 8
10 11
11 11
12 11
13 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a94 <mu_parse822_domain_ref+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_parse822_domain_ref (const char **p, const char *e, char **domain_ref)
{
  return mu_parse822_atom (p, e, domain_ref);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    $0x1000000,%eax
test   %rdi,%rdi
je     281 <gss_encapsulate_token+0x5a>
test   %rsi,%rsi
je     281 <gss_encapsulate_token+0x5a>
mov    $0x2000000,%eax
test   %rdx,%rdx
je     281 <gss_encapsulate_token+0x5a>
sub    $0x18,%rsp
mov    0x8(%rsi),%r8
mov    0x8(%rdi),%rax
mov    %rdx,0x8(%rsp)
add    $0x8,%rdx
mov    %rdx,(%rsp)
mov    (%rsi),%r9d
mov    (%rdi),%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  271 <gss_encapsulate_token+0x4a>
cmp    $0x1,%eax
sbb    %eax,%eax
not    %eax
and    $0xd0000,%eax
add    $0x18,%rsp
repz retq 
<<<sep_in_sample>>>
gss_encapsulate_token (gss_const_buffer_t input_token,
         gss_const_OID token_oid,
         gss_buffer_t output_token)
{
  int rc;
  if (!input_token)
    return (1ul << 24);
  if (!token_oid)
    return (1ul << 24);
  if (!output_token)
    return (2ul << 24);
  rc = _gss_encapsulate_token_prefix (((void *)0), 0,
          input_token->value,
          input_token->length,
          token_oid->elements,
          token_oid->length,
          &output_token->value,
          &output_token->length);
  if (rc != 0)
    return (13ul << 16);
  return 0;
}
<<<sep_in_sample>>>
1 7
2 6
3 6
4 8
5 8
6 11
7 10
8 10
9 4
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 20
22 20
23 20
24 20
25 22
26 22
<<<sep_out_sample>>>
push   %rbx
add    $0xffffffffffffff80,%rsp
mov    %edi,%ebx
mov    $0x0,%esi
callq  1ca7 <exit_with_signal+0x11>
mov    %rsp,%rdi
callq  1caf <exit_with_signal+0x19>
mov    %ebx,%esi
mov    %rsp,%rdi
callq  1cb9 <exit_with_signal+0x23>
mov    $0x0,%edx
mov    %rsp,%rsi
mov    $0x1,%edi
callq  1ccb <exit_with_signal+0x35>
mov    %ebx,%edi
callq  1cd2 <exit_with_signal+0x3c>
mov    $0x2,%edi
callq  1cdc <systemic>
<<<sep_in_sample>>>
exit_with_signal (int sig)
{
  sigset_t s;
  signal (sig, ((__sighandler_t) 0));
  sigemptyset (&s);
  sigaddset (&s, sig);
  sigprocmask (1, &s, (sigset_t *) 0);
  raise (sig);
  exit (2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 8
17 9
18 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  3530 <free_state+0xd>
mov    0x48(%rbx),%rdi
callq  3539 <free_state+0x16>
mov    0x50(%rbx),%rax
lea    0x8(%rbx),%rdx
cmp    %rdx,%rax
je     3558 <free_state+0x35>
mov    0x10(%rax),%rdi
callq  354f <free_state+0x2c>
mov    0x50(%rbx),%rdi
callq  3558 <free_state+0x35>
mov    0x18(%rbx),%rdi
callq  3561 <free_state+0x3e>
mov    0x60(%rbx),%rdi
callq  356a <free_state+0x47>
mov    0x58(%rbx),%rdi
callq  3573 <free_state+0x50>
mov    %rbx,%rdi
callq  357b <free_state+0x58>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_state (re_dfastate_t *state)
{
  free ((&state->non_eps_nodes)->elems);
  free ((&state->inveclosure)->elems);
  if (state->entrance_nodes != &state->nodes)
    {
      free ((state->entrance_nodes)->elems);
      free (state->entrance_nodes);
    }
  free ((&state->nodes)->elems);
  free (state->word_trtable);
  free (state->trtable);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 8
14 8
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 13
23 14
24 14
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbx
cmpq   $0x0,0x0(%rip)        # 1af <InitDelays+0x18>
jne    1d3 <InitDelays+0x3c>
mov    $0x3e8,%edi
callq  1bb <InitDelays+0x24>
mov    %rax,0x0(%rip)        # 1c2 <InitDelays+0x2b>
movl   $0xffffffff,0x0(%rip)        # 1cc <InitDelays+0x35>
mov    %rbx,0x0(%rip)        # 1d3 <InitDelays+0x3c>
cmpq   $0x0,0x0(%rip)        # 1db <InitDelays+0x44>
jne    22a <InitDelays+0x93>
callq  1e2 <InitDelays+0x4b>
movslq %eax,%rdi
callq  1ea <InitDelays+0x53>
mov    %rax,0x0(%rip)        # 1f1 <InitDelays+0x5a>
callq  1f6 <InitDelays+0x5f>
movslq %eax,%rdi
callq  1fe <InitDelays+0x67>
mov    %rax,0x0(%rip)        # 205 <InitDelays+0x6e>
mov    $0x0,%ebx
jmp    221 <InitDelays+0x8a>
movslq %ebx,%rdx
mov    0x0(%rip),%rax        # 216 <InitDelays+0x7f>
movq   $0x0,(%rax,%rdx,8)
add    $0x1,%ebx
callq  226 <InitDelays+0x8f>
cmp    %eax,%ebx
jl     20c <InitDelays+0x75>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
InitDelays (double dTime)
{
  int i;
  if (!rgdTime) {
    rgdTime = InitdVector(1000);
    iCurrentTime = -1;
    dInitialTime = dTime;
  }
  if (!rgiVars) {
    rgiVars = InitlVector(GetNModelVars());
    pdVar = InitpdVector(GetNModelVars());
    for (i = 0; i < GetNModelVars(); i++)
      rgiVars[i] = 0;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 6
11 7
12 9
13 9
14 10
15 10
16 10
17 10
18 11
19 11
20 11
21 11
22 12
23 12
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
testb  $0x10,0x23d(%rdi)
je     1ee <__ram_set_re_source+0x27>
mov    0x28(%rdi),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  1ec <__ram_set_re_source+0x25>
jmp    218 <__ram_set_re_source+0x51>
mov    %rsi,%rbp
mov    $0x8,%esi
callq  1fb <__ram_set_re_source+0x34>
mov    %eax,%edx
test   %edx,%edx
jne    218 <__ram_set_re_source+0x51>
mov    0xc0(%rbx),%rax
lea    0x38(%rax),%rdx
mov    0x28(%rbx),%rdi
mov    %rbp,%rsi
callq  218 <__ram_set_re_source+0x51>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__ram_set_re_source(dbp, re_source)
 DB *dbp;
 const char *re_source;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_re_source", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x08)) != 0) return (__ret); };
 t = dbp->bt_internal;
 return (CDB___os_strdup(dbp->dbenv, re_source, &t->re_source));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
test   %rax,%rax
jne    92a <dicod_get_database_info+0x28>
mov    0x50(%rdi),%rdx
mov    0x10(%rdx),%rdx
mov    0x30(%rdx),%rdx
test   %rdx,%rdx
je     92a <dicod_get_database_info+0x28>
sub    $0x8,%rsp
mov    0x40(%rdi),%rdi
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dicod_get_database_info(dicod_database_t *db)
{
    if (db->info)
 return db->info;
    else {
 dicod_module_instance_t *inst = db->instance;
 if (inst->module->dico_db_info)
     return inst->module->dico_db_info(db->mod_handle);
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 7
5 7
6 7
7 7
8 7
9 2
10 8
11 8
12 11
13 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
callq  0 <randomize>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_pseudo_random (char *data, size_t datalen)
{
  return randomize (1, data, datalen);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    %esi,0x48(%rdi)
retq   
<<<sep_in_sample>>>
topsf_set_fd(TOPSF * topsf, int fd)
{
 topsf->fd_=fd;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    0x0(%rip),%rbx        # 191 <getgroup+0xd>
test   %rbx,%rbx
je     1f2 <getgroup+0x6e>
cmp    %edi,(%rbx)
jne    1a2 <getgroup+0x1e>
jmp    206 <getgroup+0x82>
cmp    %ebp,(%rbx)
xchg   %ax,%ax
je     206 <getgroup+0x82>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    19c <getgroup+0x18>
jmp    1f2 <getgroup+0x6e>
mov    (%rax),%r12
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x10(%rcx),%rdi
callq  1cd <getgroup+0x49>
mov    %rax,%rbx
mov    %ebp,(%rax)
lea    0x10(%rax),%rdi
mov    %r12,%rsi
callq  1de <getgroup+0x5a>
mov    0x0(%rip),%rax        # 1e5 <getgroup+0x61>
mov    %rax,0x8(%rbx)
mov    %rbx,0x0(%rip)        # 1f0 <getgroup+0x6c>
jmp    206 <getgroup+0x82>
mov    %ebp,%edi
callq  1f9 <getgroup+0x75>
mov    $0x0,%r12d
test   %rax,%rax
je     1b0 <getgroup+0x2c>
jmp    1ad <getgroup+0x29>
lea    0x10(%rbx),%rdx
cmpb   $0x0,0x10(%rbx)
mov    $0x0,%eax
cmovne %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
getgroup (gid_t gid)
{
  struct userid *tail;
  struct userid *match = ((void *)0);
  for (tail = group_alist; tail; tail = tail->next)
    {
      if (tail->id.g == gid)
        {
          match = tail;
          break;
        }
    }
  if (match == ((void *)0))
    {
      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : "";
      match = xmalloc (__builtin_offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
      match->next = group_alist;
      group_alist = match;
    }
  return match->name[0] ? match->name : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 5
15 5
16 5
17 5
18 16
19 17
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 18
28 19
29 19
30 19
31 20
32 20
33 21
34 21
35 15
36 15
37 16
38 16
39 16
40 16
41 23
42 23
43 23
44 23
45 24
46 24
47 24
48 24
<<<sep_out_sample>>>
cmp    %rcx,%rdx
jae    116 <find_next_argument+0x3c>
mov    $0x0,%r8d
movzbl (%rdx),%eax
cmp    %dil,%al
jne    f3 <find_next_argument+0x19>
add    $0x1,%r8d
jmp    10b <find_next_argument+0x31>
cmp    %sil,%al
jne    102 <find_next_argument+0x28>
sub    $0x1,%r8d
jns    10b <find_next_argument+0x31>
xchg   %ax,%ax
jmp    11c <find_next_argument+0x42>
cmp    $0x2c,%al
jne    10b <find_next_argument+0x31>
test   %r8d,%r8d
je     122 <find_next_argument+0x48>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    e5 <find_next_argument+0xb>
jmp    126 <find_next_argument+0x4c>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    %rdx,%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
find_next_argument (char startparen, char endparen,
                    const char *ptr, const char *end)
{
  int count = 0;
  for (; ptr < end; ++ptr)
    if (*ptr == startparen)
      ++count;
    else if (*ptr == endparen)
      {
        --count;
        if (count < 0)
          return ((void *)0);
      }
    else if (*ptr == ',' && !count)
      return (char *)ptr;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 6
5 6
6 6
7 7
8 7
9 8
10 8
11 11
12 11
13 11
14 11
15 14
16 14
17 14
18 14
19 5
20 5
21 5
22 5
23 16
24 16
25 12
26 12
27 12
28 12
29 16
30 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <osip_record_route_init+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_record_route_init (osip_record_route_t ** record_route)
{
  return osip_from_init ((osip_from_t **) record_route);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
mov    %esi,%r13d
mov    %rdx,%rbp
mov    %ecx,%r14d
mov    %r9,%rsi
mov    %r8,%rdi
callq  1f <verror_at_line+0x1f>
mov    %rax,%rbx
test   %rax,%rax
je     67 <verror_at_line+0x67>
test   %rbp,%rbp
je     4d <verror_at_line+0x4d>
mov    %rax,%r9
mov    $0x0,%r8d
mov    %r14d,%ecx
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  4b <verror_at_line+0x4b>
jmp    87 <verror_at_line+0x87>
mov    %rax,%rcx
mov    $0x0,%edx
mov    %r13d,%esi
mov    %r12d,%edi
mov    $0x0,%eax
callq  65 <verror_at_line+0x65>
jmp    87 <verror_at_line+0x87>
callq  6c <verror_at_line+0x6c>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  82 <verror_at_line+0x82>
callq  87 <verror_at_line+0x87>
mov    %rbx,%rdi
callq  8f <verror_at_line+0x8f>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
verror_at_line (int status, int errnum, const char *file,
                unsigned int line_number, const char *format, va_list args)
{
  char *message = xvasprintf (format, args);
  if (message)
    {
      if (file)
        error_at_line (status, errnum, file, line_number, "%s", message);
      else
        error (status, errnum, "%s", message);
    }
  else
    {
      error (0, (*__errno_location ()), "unable to display error message");
      abort ();
    }
  free (message);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 17
42 17
43 18
44 18
45 18
46 18
47 18
48 18
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    $0x0,%ecx
mov    $0x2,%edx
mov    $0x0,%esi
callq  36e <getkey+0x1c>
cmpl   $0x0,0x0(%rip)        # 375 <getkey+0x23>
jne    385 <getkey+0x33>
cmp    0x0(%rip),%rbx        # 37e <getkey+0x2c>
jne    385 <getkey+0x33>
callq  385 <getkey+0x33>
mov    %rbx,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
lea    0xf(%rsp),%rdi
callq  39c <getkey+0x4a>
test   %rax,%rax
jne    3b9 <getkey+0x67>
callq  3a6 <getkey+0x54>
cmpl   $0x4,(%rax)
sete   %al
movzbl %al,%eax
lea    0x4(,%rax,8),%rax
jmp    3be <getkey+0x6c>
movzbl 0xf(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
getkey(FILE * stream)
{
  Cell result;
  unsigned char c;
  setvbuf(stream, ((void *)0), 2, 0);
  if(!terminal_prepped && stream == stdin)
    prep_terminal();
  result = fread(&c, sizeof(c), 1, stream);
  return result==0 ? ((*__errno_location ()) == 4 ? 12 : 4) : c;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 7
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
<<<sep_out_sample>>>
mov    (%rdi),%r8
test   %r8,%r8
jne    10 <__reqtext+0x10>
cmpq   $0x0,(%rsi)
sete   %al
retq   
mov    (%rsi),%r9
test   %r9,%r9
je     7f <__reqtext+0x7f>
movzwl 0x8(%rdi),%edx
mov    $0x0,%eax
cmp    0x8(%rsi),%dx
jne    96 <__reqtext+0x96>
movzwl 0xc(%rdi),%edi
sub    $0x1,%edi
movslq %edi,%rax
lea    0x18(%r8,%rax,1),%rcx
movzwl 0xc(%rsi),%eax
sub    $0x1,%eax
movslq %eax,%rsi
lea    0x18(%r9,%rsi,1),%rsi
movzwl %dx,%edx
test   %rdx,%rdx
jle    85 <__reqtext+0x85>
movslq %edi,%rdi
cltq   
movzbl 0x18(%r9,%rax,1),%eax
cmp    %al,0x18(%r8,%rdi,1)
jne    8b <__reqtext+0x8b>
mov    $0x0,%eax
jmp    70 <__reqtext+0x70>
movzbl (%rsi,%rax,1),%edi
cmp    %dil,(%rcx,%rax,1)
jne    91 <__reqtext+0x91>
add    $0x1,%rax
cmp    %rdx,%rax
jl     66 <__reqtext+0x66>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
__reqtext (__txtvp t1x, __txtvp t2x)
{
  long i = 0;
  register char *p1x,
   *p2x;
  if (t1x->obj == 0L && t2x->obj == 0L)
    return (1);
  if (t1x->obj == 0L || t2x->obj == 0L)
    return (0);
  if (t1x->length != t2x->length)
    return (0);
  p1x = (char *) &(t1x->obj->string[t1x->start - 1]);
  for (p2x = (char *) &(t2x->obj->string[t2x->start - 1]); i < (long) t2x->length; i++)
    if (!(*p1x++ == *p2x++))
      return (0);
  return (1);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 8
8 8
9 8
10 10
11 11
12 10
13 10
14 12
15 12
16 12
17 12
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 14
26 14
27 14
28 14
29 14
30 3
31 3
32 14
33 14
34 14
35 13
36 13
37 13
38 16
39 16
40 9
41 9
42 16
43 16
44 15
45 15
46 15
47 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  25e8 <c__scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
c__scan_string (const char * yystr )
{
 return c__scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%ebp
cmp    $0xfffd,%edx
jbe    35f <write_marker_header+0x23>
mov    (%rdi),%rax
movl   $0xb,0x28(%rax)
mov    (%rdi),%rax
callq  *(%rax)
mov    %r12d,%esi
mov    %rbx,%rdi
callq  44 <emit_marker>
lea    0x2(%rbp),%esi
mov    %rbx,%rdi
callq  6a <emit_2bytes>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
{
  if (datalen > (unsigned int) 65533)
    ((cinfo)->err->msg_code = (JERR_BAD_LENGTH), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
  emit_marker(cinfo, (JPEG_MARKER) marker);
  emit_2bytes(cinfo, (int) (datalen + 2));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  5d2 <gsl_vector_uchar_fscanf+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_fscanf (FILE * stream, gsl_vector_uchar * v)
{
  int status = gsl_block_uchar_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x160,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x158(%rsp)
xor    %eax,%eax
mov    %rdi,%rcx
mov    $0x0,%edx
mov    $0x14b,%esi
mov    %rsp,%rdi
callq  b3a <cannotwrite+0x33>
mov    %rsp,%rdi
callq  b42 <cannotwrite+0x3b>
mov    %rbx,%rdi
callq  b4a <cannotwrite+0x43>
mov    $0x1,%edi
callq  b54 <cannotwrite+0x4d>
<<<sep_in_sample>>>
cannotwrite(char *file)
{
    char msg[((250) + 80) + 1];
    snprintf(msg, sizeof(msg), "Removed file %s because write failed", file);
    myperror(msg);
    unlink(file);
    myexit(1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 7
17 7
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
mov    %rax,%rdx
shl    $0x4,%rdx
mov    %rdx,(%rdi)
shl    $0x9,%rax
mov    %rax,0x8(%rdi)
movsd  0x0(%rip),%xmm0        # 13f7 <gsl_monte_miser_init+0x1e>
movsd  %xmm0,0x18(%rdi)
movsd  0x0(%rip),%xmm1        # 1404 <gsl_monte_miser_init+0x2b>
movsd  %xmm1,0x20(%rdi)
movq   $0x0,0x10(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_monte_miser_init (gsl_monte_miser_state * s)
{
  s->min_calls = 16 * s->dim;
  s->min_calls_per_bisection = 32 * s->min_calls;
  s->estimate_frac = 0.1;
  s->alpha = 2.0;
  s->dither = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 9
13 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     673 <mu_assoc_destroy+0x37>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     673 <mu_assoc_destroy+0x37>
mov    %rbx,%rdi
callq  65a <mu_assoc_destroy+0x1e>
mov    0x10(%rbx),%rdi
callq  663 <mu_assoc_destroy+0x27>
mov    %rbx,%rdi
callq  66b <mu_assoc_destroy+0x2f>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_assoc_destroy (mu_assoc_t *passoc)
{
  mu_assoc_t assoc;
  if (passoc && (assoc = *passoc) != ((void *)0))
    {
      mu_assoc_clear (assoc);
      free (assoc->tab);
      free (assoc);
      *passoc = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdx),%rdx
cmp    $0x5,%rdx
ja     52cb <_jit_putargr+0x28>
movslq %esi,%rcx
mov    $0xd,%eax
sub    %rdx,%rax
mov    %rax,%rdx
mov    $0x4b,%esi
callq  52c9 <_jit_putargr+0x26>
jmp    52dd <_jit_putargr+0x3a>
movslq %esi,%r8
mov    $0xf,%ecx
mov    $0x81,%esi
callq  52dd <_jit_putargr+0x3a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_jit_putargr(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_movr,_RDI - v->u.w,u);
    else
 _jit_new_node_www(_jit,jit_code_stxi_l,v->u.w,_RBP,u);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x68(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%rcx        # 6d2 <blackBoxKillPlayer+0x1b>
test   %rcx,%rcx
je     6f2 <blackBoxKillPlayer+0x3b>
movb   $0x2,(%rsp)
mov    %di,0x2(%rsp)
mov    $0x1,%edx
mov    $0x4,%esi
mov    %rsp,%rdi
callq  6f2 <blackBoxKillPlayer+0x3b>
mov    0x68(%rsp),%rax
xor    %fs:0x28,%rax
je     707 <blackBoxKillPlayer+0x50>
callq  707 <blackBoxKillPlayer+0x50>
add    $0x78,%rsp
retq   
<<<sep_in_sample>>>
blackBoxKillPlayer(int id)
{
 BBRecord rec;
 if (bbout) {
  rec.rectype = 0x02;
  rec.id = id;
  fwrite((char *) &rec, (sizeof(char) + sizeof(char) + sizeof(short)), 1, bbout);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 6
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     1e5 <nsubstr+0x71>
test   %esi,%esi
js     1ec <nsubstr+0x78>
movslq %esi,%r13
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %rcx,%r13
jae    1f3 <nsubstr+0x7f>
test   %edx,%edx
js     1fa <nsubstr+0x86>
movslq %edx,%r12
mov    $0x0,%eax
cmp    %r12,%rcx
jb     201 <nsubstr+0x8d>
add    $0x1,%edx
movslq %edx,%rdi
callq  1c3 <nsubstr+0x4f>
mov    %rax,%rbp
test   %rax,%rax
je     201 <nsubstr+0x8d>
lea    (%rbx,%r13,1),%rsi
mov    %r12,%rdx
mov    %rax,%rdi
callq  1da <nsubstr+0x66>
movb   $0x0,0x0(%rbp,%r12,1)
mov    %rbp,%rax
jmp    201 <nsubstr+0x8d>
mov    $0x0,%eax
jmp    201 <nsubstr+0x8d>
mov    $0x0,%eax
jmp    201 <nsubstr+0x8d>
mov    $0x0,%eax
jmp    201 <nsubstr+0x8d>
mov    $0x0,%eax
jmp    201 <nsubstr+0x8d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
nsubstr(str string, int start, int length)
{
  if(!string) return ((void *)0);
  if(start < 0 || start >= strlen(string)) return ((void *)0);
  if(length < 0 || length > strlen(string)) return ((void *)0);
  str _s = (str) malloc(length+1);
  if(!_s) return ((void *)0);
  strncpy(_s, string+start, length);
  _s[length] = '\0';
  return _s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
23 5
24 5
25 6
26 6
27 6
28 6
29 7
30 7
31 8
32 8
33 8
34 8
35 9
36 10
37 10
38 3
39 3
40 4
41 4
42 4
43 4
44 5
45 5
46 11
47 11
48 11
49 11
50 11
51 11
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 101 <usage+0x8>
mov    $0x0,%edi
callq  10b <usage+0x12>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 118 <usage+0x1f>
mov    $0x0,%eax
callq  122 <usage+0x29>
mov    $0x1,%edi
callq  12c <ceil_log_8>
<<<sep_in_sample>>>
usage (void)
{
  fprintf (stderr, gettext ("Try `%s --help' for more information.\n"),
    program_name);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r8
mov    %rdx,%r9
mov    0xc8(%rdi),%ecx
lea    0xcc(%rdi),%rdx
mov    $0x48,%esi
callq  90 <nettle_sha3_512_update+0x21>
mov    %eax,0xc8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_sha3_512_update (struct sha3_512_ctx *ctx,
   size_t length,
   const uint8_t *data)
{
  ctx->index = _nettle_sha3_update (&ctx->state, 72, ctx->block,
        ctx->index, length, data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 7
11 7
<<<sep_out_sample>>>
sub    $0x38,%rsp
test   %rdx,%rdx
jne    10 <__gmpf_sub_ui+0x10>
callq  e <__gmpf_sub_ui+0xe>
jmp    3a <__gmpf_sub_ui+0x3a>
mov    %rdx,0x8(%rsp)
movl   $0x1,0x14(%rsp)
lea    0x8(%rsp),%rax
mov    %rax,0x20(%rsp)
movq   $0x1,0x18(%rsp)
lea    0x10(%rsp),%rdx
callq  3a <__gmpf_sub_ui+0x3a>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
__gmpf_sub_ui (mpf_ptr sum, mpf_srcptr u, unsigned long int v)
{
  __mpf_struct vv;
  mp_limb_t vl;
  if (v == 0)
    {
      __gmpf_set (sum, u);
      return;
    }
  vl = v;
  vv._mp_size = 1;
  vv._mp_d = &vl;
  vv._mp_exp = 1;
  __gmpf_sub (sum, u, &vv);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 7
5 7
6 10
7 11
8 12
9 12
10 13
11 14
12 14
13 15
14 15
<<<sep_out_sample>>>
cmpl   $0x0,0x10(%rdi)
je     42 <next+0x14>
mov    0x8(%rdi),%rax
mov    0x10(%rax),%rax
mov    %rax,0x8(%rdi)
jmp    4e <next+0x20>
mov    0x8(%rdi),%rax
mov    0x8(%rax),%rax
mov    %rax,0x8(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
next (void *owner)
{
  struct list_iterator *itr = owner;
  if (itr->backwards)
    itr->cur = itr->cur->prev;
  else
    itr->cur = itr->cur->next;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 9
11 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <rec_rset_record_dup_fn+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_rset_record_dup_fn (void *data)
{
  rec_record_t record = (rec_record_t) data;
  rec_record_t new = rec_record_dup (record);
  return (void *) new;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
cmpl   $0x0,0xc(%rsi)
jne    1a5 <tsqr_rcond+0x20>
mov    %rsi,%rdi
callq  46 <tsqr_svd>
mov    %eax,%edx
test   %edx,%edx
jne    1b8 <tsqr_rcond+0x33>
mov    0x30(%rbx),%rdi
callq  1ae <tsqr_rcond+0x29>
movsd  %xmm0,0x0(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
tsqr_rcond(double * rcond, void * vstate)
{
  tsqr_state_t *state = (tsqr_state_t *) vstate;
  if (state->svd == 0)
    {
      int status = tsqr_svd(state);
      if (status)
        return status;
    }
  *rcond = gsl_multifit_linear_rcond(state->multifit_workspace_p);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 6
11 7
12 7
13 10
14 10
15 10
16 11
17 12
18 12
19 12
20 12
<<<sep_out_sample>>>
mov    0x0(%rip),%esi        # 2dc <reset_mail_files+0x6>
test   %esi,%esi
jle    31f <reset_mail_files+0x49>
mov    0x0(%rip),%rdx        # 2e7 <reset_mail_files+0x11>
mov    $0x0,%eax
mov    (%rdx,%rax,8),%rcx
movq   $0x0,0x18(%rcx)
movq   $0x0,0x10(%rcx)
mov    (%rdx,%rax,8),%rcx
movq   $0x0,0x20(%rcx)
mov    (%rdx,%rax,8),%rcx
movl   $0x0,0x28(%rcx)
add    $0x1,%rax
cmp    %eax,%esi
jg     2ec <reset_mail_files+0x16>
repz retq 
<<<sep_in_sample>>>
reset_mail_files ()
{
  register int i;
  for (i = 0; i < mailfiles_count; i++)
    do { mailfiles[i]->access_time = mailfiles[i]->mod_time = 0; mailfiles[i]->file_size = 0; mailfiles[i]->flags = 0; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 4
15 4
16 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%r13d        # 159c <fh_join+0xf>
cmp    $0x1,%esi
jle    1606 <fh_join+0x79>
mov    %rdi,%rbp
mov    %rdx,%r14
movl   $0x0,0x0(%rip)        # 15b1 <fh_join+0x24>
lea    0x8(%rdx),%rbx
lea    -0x2(%rsi),%eax
lea    (%rbx,%rax,8),%r12
jmp    15e6 <fh_join+0x59>
cmpl   $0x0,0x0(%rip)        # 15c5 <fh_join+0x38>
je     15e2 <fh_join+0x55>
mov    (%r14),%rsi
mov    %rbp,%rdi
callq  15d2 <fh_join+0x45>
movl   $0x0,0x0(%rip)        # 15dc <fh_join+0x4f>
mov    $0x1,%r13d
add    $0x8,%rbx
mov    (%rbx),%rax
mov    %rax,0x18(%rbp)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  15fa <fh_join+0x6d>
cmp    %r12,%rbx
jne    15be <fh_join+0x31>
mov    %r13d,0x0(%rip)        # 1606 <fh_join+0x79>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
fh_join (format_data_t form, int argc, char *argv[])
{
  int had_output_saved = had_output;
  int count = 0;
  if (argc < 2)
    return;
  had_output = 0;
  while (++count < argc)
    {
      if (had_output)
 {
   put_string (form, argv[0]);
   had_output = 0;
   had_output_saved = 1;
 }
      form->format = argv[count];
      print_interfaceX (form, 0);
    }
  had_output = had_output_saved;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 12
19 12
20 12
21 13
22 14
23 14
24 16
25 16
26 17
27 17
28 17
29 8
30 8
31 19
32 20
33 20
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    $0x16,%eax
test   %rsi,%rsi
je     9d0 <mu_m_server_get_default_address+0x37>
mov    0xd0(%rdi),%esi
mov    $0x102a,%ax
cmp    (%rdx),%esi
jg     9d0 <mu_m_server_get_default_address+0x37>
sub    $0x8,%rsp
movslq %esi,%rdx
lea    0x60(%rdi),%rsi
mov    %rcx,%rdi
callq  9c7 <mu_m_server_get_default_address+0x2e>
mov    $0x0,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_m_server_get_default_address (mu_m_server_t srv, struct sockaddr *sa,
     int *salen)
{
  int len;
  if (!sa)
    return 22;
  len = srv->defaddr.len;
  if (sa)
    {
      if (*salen < len)
 return (0x1000 +42);
      memcpy (sa, &srv->defaddr.s.s_sa, len);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 6
3 5
4 5
5 7
6 11
7 10
8 10
9 3
10 12
11 12
12 12
13 12
14 14
15 15
16 15
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %rbx
test   %edi,%edi
jg     188 <linetable_get+0x16>
mov    %edi,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  188 <linetable_get+0x16>
mov    %rsi,%rbx
lea    -0x1(%rdi),%esi
mov    $0x0,%edx
mov    0x0(%rip),%rdi        # 19a <linetable_get+0x28>
callq  19f <linetable_get+0x2d>
mov    (%rax),%eax
test   %rbx,%rbx
je     1a8 <linetable_get+0x36>
mov    %eax,(%rbx)
cltq   
add    0x0(%rip),%rax        # 1b1 <linetable_get+0x3f>
pop    %rbx
retq   
<<<sep_in_sample>>>
linetable_get(int lineno, int *offset)
{
 int addr;
 if (lineno <= 0)
  die("linetable_get: line number must >= 1 (lineno = %d)", lineno);
 addr = *((int *)varray_assign(vb, lineno - 1, 0));
 if (offset)
  *offset = addr;
 return filebuf + addr;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 9
19 10
20 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    %edi,%ebx
mov    %rdx,%rbp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    $0xffffffffffffffff,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b31 <quotearg_n_options>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
quotearg_n_style (int n, enum quoting_style s, char const *arg)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, ((size_t) -1), &o);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r15d
mov    %edx,%r12d
mov    %ecx,%ebp
mov    %r8d,%r14d
mov    %r9d,%r13d
mov    %ebp,%edx
mov    $0x30,%esi
callq  321 <_alur>
test   %r15d,%r15d
je     b8f <_ssecmp+0x46>
mov    %r14d,%r8d
mov    %r13d,%ecx
mov    $0x2e,%edx
mov    $0x66,%esi
mov    %rbx,%rdi
callq  9d0 <_ssexr>
jmp    ba2 <_ssecmp+0x59>
mov    %r14d,%ecx
mov    %r13d,%edx
mov    $0x2e,%esi
mov    %rbx,%rdi
callq  966 <_sser>
mov    %ebp,%edx
mov    %r12d,%esi
mov    %rbx,%rdi
callq  2c2 <_cc>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_ssecmp(jit_state_t *_jit, jit_bool_t d, jit_int32_t code,
 jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_bool_t rc;
    jit_int32_t reg;
    if ((rc = 1))
 reg = r0;
    else {
 reg = 0;
 _movr(_jit, r0, reg);
    }
    _alur(_jit, 6 << 3, reg, reg);
    if (d)
 _ssexr(_jit,0x66,0x2e,r2,r1);
    else
 _sser(_jit,0x2e,r2,r1);
    _cc(_jit, code, reg);
    if (!rc)
 _xchgr(_jit, r0, reg);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 12
14 12
15 12
16 13
17 13
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 16
26 16
27 16
28 16
29 16
30 17
31 17
32 17
33 17
34 20
35 20
36 20
37 20
38 20
39 20
40 20
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
mov    (%rax),%rdx
test   %rdx,%rdx
je     2c <_jit_get_size+0x2a>
mov    $0x2b,%eax
mov    0x8(%rdx),%ecx
movswq 0x0(%rcx,%rcx,1),%rcx
add    %rcx,%rax
mov    (%rdx),%rdx
test   %rdx,%rdx
jne    13 <_jit_get_size+0x11>
jmp    31 <_jit_get_size+0x2f>
mov    $0x2b,%eax
add    $0xfff,%rax
and    $0xfffffffffffff000,%rax
retq   
<<<sep_in_sample>>>
_jit_get_size(jit_state_t *_jit)
{
    jit_word_t size;
    jit_node_t *node;
    for (size = 43, node = _jit->comp->head; node; node = node->next)
 size += _szs[node->code];
    return ((size + 4095) & -4096);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 6
7 6
8 6
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  1c19 <rl_unbind_command_in_map+0x9>
mov    %rax,%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     1c2e <rl_unbind_command_in_map+0x1e>
mov    %rbx,%rsi
callq  1c2e <rl_unbind_command_in_map+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_unbind_command_in_map (command, map)
     const char *command;
     Keymap map;
{
  rl_command_func_t *func;
  func = rl_named_function (command);
  if (func == 0)
    return 0;
  return (rl_unbind_function_in_map (func, map));
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 8
6 7
7 7
8 9
9 9
10 10
11 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 44 <utmp_get_entry+0xb>
callq  49 <utmp_get_entry+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
utmp_get_entry(void)
{
  return (struct utmp *)file_reader_get_entry(utmp_info);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x0,(%rdi)
jle    1b0 <strhash_reset+0x24>
mov    $0x0,%eax
movslq %eax,%rcx
mov    0x8(%rbx),%rdx
movq   $0x0,(%rdx,%rcx,8)
add    $0x1,%eax
cmp    %eax,(%rbx)
jg     19a <strhash_reset+0xe>
mov    0x10(%rbx),%rdi
callq  1b9 <strhash_reset+0x2d>
movq   $0x0,0x18(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
strhash_reset(STRHASH *sh)
{
 int i;
 for (i = 0; i < sh->buckets; i++) {
  { (&sh->htab[i])->slh_first = ((void *)0); };
 }
 pool_reset(sh->pool);
 sh->entries = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 4
10 4
11 4
12 7
13 7
14 8
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # e8e <print_version_only+0xb>
test   %rsi,%rsi
cmove  0x0(%rip),%rsi        # e99 <print_version_only+0x16>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%edi
mov    $0x0,%eax
callq  eb2 <print_version_only+0x2f>
mov    $0x0,%edi
callq  ebc <print_version_only+0x39>
mov    $0x0,%edx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  ed3 <print_version_only+0x50>
mov    $0x0,%edi
callq  edd <print_version_only+0x5a>
mov    $0xa,%edi
callq  ee7 <print_version_only+0x64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_version_only (void)
{
  printf ("%s (%s) %s\n",
    parseopt_program_name ? parseopt_program_name : progname,
    "gdbm",
    "1.12");
  printf (version_etc_copyright, gettext ("(C)"), "2011");
  puts (license_text);
  putchar ('\n');
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 9
20 9
21 10
22 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %esi,%esi
jne    4bd <srcfile_generator+0x44>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rsi,%rcx
sub    $0x1,%rcx
mov    %rcx,0x0(%rip)        # 4ac <srcfile_generator+0x33>
mov    0x0(%rip),%rax        # 4b3 <srcfile_generator+0x3a>
mov    (%rax),%rax
mov    %rax,0x0(%rip)        # 4bd <srcfile_generator+0x44>
mov    0x0(%rip),%rbx        # 4c4 <srcfile_generator+0x4b>
mov    0x0(%rip),%r12        # 4cb <srcfile_generator+0x52>
jmp    524 <srcfile_generator+0xab>
mov    0x10(%rax),%edx
lea    -0x3(%rdx),%ecx
cmp    $0x1,%ecx
jbe    4e4 <srcfile_generator+0x6b>
mov    (%rax),%rax
mov    %rax,0x0(%rip)        # 4e2 <srcfile_generator+0x69>
jmp    524 <srcfile_generator+0xab>
mov    0x18(%rax),%r13
mov    (%rax),%rax
mov    %rax,0x0(%rip)        # 4f2 <srcfile_generator+0x79>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  500 <srcfile_generator+0x87>
test   %eax,%eax
jne    524 <srcfile_generator+0xab>
mov    %r13,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
lea    -0x1(%rsi),%rsi
mov    %r13,%rdi
callq  522 <srcfile_generator+0xa9>
jmp    535 <srcfile_generator+0xbc>
mov    0x0(%rip),%rax        # 52b <srcfile_generator+0xb2>
cmp    %rbx,%rax
jne    4cd <srcfile_generator+0x54>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
srcfile_generator(const char *text, int state)
{
 static size_t textlen;
 static SRCFILE *s;
 char *name;
 extern SRCFILE *srcfiles;
 if (! state) {
  textlen = strlen(text);
  s = srcfiles->next;
 }
 while (s != srcfiles) {
  if (s->stype != SRC_FILE && s->stype != SRC_INC) {
   s = s->next;
   continue;
  }
  name = s->src;
  s = s->next;
  if (strncmp(name, text, textlen) == 0)
   return estrdup(name, strlen(name));
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 11
21 18
22 18
23 12
24 12
25 12
26 12
27 13
28 13
29 14
30 16
31 17
32 17
33 18
34 18
35 18
36 18
37 18
38 18
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 11
49 11
50 11
51 21
52 22
53 22
54 22
55 22
56 22
57 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  b2 <help_me_java+0xe>
mov    %rax,%rdi
mov    $0x0,%eax
callq  bf <help_me_java+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
help_me_java (void)
{
  printf (gettext ("Java language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n")
  );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%rdi
mov    $0x10,%edx
mov    $0x0,%esi
callq  b2 <wprepend+0x1e>
mov    %rbp,(%rax)
mov    %rbx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
wprepend (void *x, struct wlink *ls, struct divvy *to)
{
  struct wlink *pair = alloc (to, "struct wlink", sizeof (struct wlink)); pair->entry = x; pair->next = ls; return pair;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  436 <gsl_sf_Chi+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     45c <gsl_sf_Chi+0x32>
mov    %eax,%ecx
mov    $0x86,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  455 <gsl_sf_Chi+0x2b>
movsd  (%rsp),%xmm0
jmp    45c <gsl_sf_Chi+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_Chi(const double x)
{
  gsl_sf_result result; int status = gsl_sf_Chi_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_Chi_e(x, &result)", "shint.c", 134, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
movzbl 0x0(%rip),%eax        # 2ee <dico_argcv_unquote_char+0x7>
test   %al,%al
je     321 <dico_argcv_unquote_char+0x3a>
movsbl %al,%eax
mov    $0x0,%edx
cmp    %edi,%eax
jne    313 <dico_argcv_unquote_char+0x2c>
jmp    309 <dico_argcv_unquote_char+0x22>
movsbl %cl,%ecx
cmp    %edi,%ecx
jne    313 <dico_argcv_unquote_char+0x2c>
jmp    30e <dico_argcv_unquote_char+0x27>
mov    $0x0,%edx
movsbl 0x1(%rdx),%eax
retq   
add    $0x2,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    300 <dico_argcv_unquote_char+0x19>
mov    %edi,%eax
retq   
mov    %edi,%eax
retq   
<<<sep_in_sample>>>
dico_argcv_unquote_char (int c)
{
  char *p;
  for (p = quote_transtab; *p; p += 2)
    {
      if (*p == c)
 return p[1];
    }
  return c;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 4
14 7
15 7
16 4
17 4
18 4
19 4
20 9
21 9
22 9
23 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
callq  0 <panel_get_centered_fos>
mov    %eax,0x2c(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
panel_center_current_entry(this)
    panel_t *this;
{
    this->first_on_screen = panel_get_centered_fos(this);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  2a7 <mu_property_is_set+0xc>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_property_is_set (mu_property_t prop, const char *key)
{
  struct property_item *item = mu_assoc_ref (prop->assoc, key);
  return (item == ((void *)0)) ? 0 : 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     4cd <mu_message_get_mailbox+0x1f>
mov    $0x1005,%ax
test   %rsi,%rsi
je     4cd <mu_message_get_mailbox+0x1f>
mov    0x50(%rdi),%rax
mov    %rax,(%rsi)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_message_get_mailbox (mu_message_t msg, mu_mailbox_t *pmailbox)
{
  if (msg == ((void *)0))
    return 22;
  if (pmailbox == ((void *)0))
    return (0x1000 +5);
  *pmailbox = msg->mailbox;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 7
9 8
10 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    91 <xnrealloc+0x20>
callq  91 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  9a <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
callq  8c3 <digest_md5_print_finish+0xd>
mov    $0x0,%edx
test   %eax,%eax
jne    8ee <digest_md5_print_finish+0x38>
mov    %rbx,%rdx
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
callq  8de <digest_md5_print_finish+0x28>
test   %eax,%eax
js     8e9 <digest_md5_print_finish+0x33>
mov    0x8(%rsp),%rdx
jmp    8ee <digest_md5_print_finish+0x38>
mov    $0x0,%edx
mov    %rdx,%rax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
digest_md5_print_finish (digest_md5_finish * finish)
{
  char *out;
  if (digest_md5_validate_finish (finish) != 0)
    return ((void *)0);
  if (asprintf (&out, "rspauth=%s", finish->rspauth) < 0)
    return ((void *)0);
  return out;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 7
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x60(%rax),%rdi
callq  1cf <dict_entry_remove>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
delstatusdict (a2ps_job * job, const char * key)
{
  dict_entry_remove (job->status->statusdict, key);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     96 <_mapfile_close+0x26>
mov    0x18(%rbx),%rsi
callq  86 <_mapfile_close+0x16>
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
mov    0x8(%rbx),%edi
callq  9e <_mapfile_close+0x2e>
movl   $0xffffffff,0x8(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_mapfile_close(void *data)
{
    struct _mapfile_stream *mfs = data;
    if (mfs->start) {
 munmap(mfs->start, mfs->size);
 mfs->start = ((void *)0);
 mfs->size = 0;
    }
    close(mfs->fd);
    mfs->fd = -1;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 6
9 7
10 9
11 9
12 10
13 12
14 12
15 12
<<<sep_out_sample>>>
push   %rbx
callq  16a4 <exp5>
mov    %rax,%rbx
cmpl   $0x26,0x0(%rip)        # 171e <expband+0x10>
jne    1740 <expband+0x32>
callq  2d7 <readtok>
callq  16a4 <exp5>
and    %rax,%rbx
movl   $0x6,0x0(%rip)        # 1737 <expband+0x29>
cmpl   $0x26,0x0(%rip)        # 173e <expband+0x30>
je     1720 <expband+0x12>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
expband ()
{
  register intmax_t val1, val2;
  val1 = exp5 ();
  while (curtok == '&')
    {
      readtok ();
      val2 = exp5 ();
      val1 = val1 & val2;
      lasttok = 6;
    }
  return (val1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 8
8 9
9 10
10 5
11 5
12 13
13 13
14 13
<<<sep_out_sample>>>
mov    %esi,0x2c(%rdi)
retq   
<<<sep_in_sample>>>
swverid_set_comparison_code(SWVERID * swverid, Swverid_Cmp_Code code)
{
 swverid->comparison_codeM=code;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
je     24 <digest_md5_validate_challenge+0x24>
cmpl   $0x0,0x2c(%rdi)
je     1a <digest_md5_validate_challenge+0x1a>
testb  $0x4,0x18(%rdi)
sete   %al
movzbl %al,%eax
neg    %eax
retq   
mov    0x18(%rdi),%eax
shl    $0x1d,%eax
sar    $0x1f,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
digest_md5_validate_challenge (digest_md5_challenge * c)
{
  if (!c->nonce)
    return -1;
  if (c->ciphers && !(c->qops & DIGEST_MD5_QOP_AUTH_CONF))
    return -1;
  if (!c->ciphers && (c->qops & DIGEST_MD5_QOP_AUTH_CONF))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 4
15 10
<<<sep_out_sample>>>
mov    0x24(%rdi),%eax
retq   
<<<sep_in_sample>>>
shcmd_get_srcfd(SHCMD * shcmd)
{
 return shcmd->srcfd_;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
mulsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_pow_7(const double x) { double x3 = x*x*x; return x3*x3*x; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x10(%rdi),%rdi
callq  6c1 <__osip_add_ist+0x15>
lea    0x50(%rbx),%rdi
mov    $0xffffffff,%edx
mov    %rbp,%rsi
callq  6d2 <__osip_add_ist+0x26>
mov    0x10(%rbx),%rdi
callq  6db <__osip_add_ist+0x2f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__osip_add_ist (osip_t * osip, osip_transaction_t * ist)
{
  osip_mutex_lock (osip->ist_fastmutex);
  osip_list_add (&osip->osip_ist_transactions, ist, -1);
  osip_mutex_unlock (osip->ist_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
<<<sep_out_sample>>>
lea    -0x61(%rdi),%edx
lea    -0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
libunistring_c_toupper (int c)
{
  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
test   %edx,%edx
jne    794 <dosetenv+0x24>
callq  783 <dosetenv+0x13>
mov    %rax,%rdx
mov    $0x0,%eax
test   %rdx,%rdx
jne    81b <dosetenv+0xab>
mov    $0xffffffffffffffff,%rdx
mov    %rbp,%rdi
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %r12,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
add    %edx,%esi
movslq %esi,%rdi
callq  7c6 <dosetenv+0x56>
mov    %rax,%rbx
test   %rax,%rax
jne    7db <dosetenv+0x6b>
callq  7d3 <dosetenv+0x63>
mov    %rax,%rbx
test   %rax,%rax
je     816 <dosetenv+0xa6>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  7e6 <dosetenv+0x76>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x3d,-0x1(%rbx,%rcx,1)
mov    %r12,%rsi
mov    %rbx,%rdi
callq  80c <dosetenv+0x9c>
mov    %rbx,%rdi
callq  814 <dosetenv+0xa4>
jmp    81b <dosetenv+0xab>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dosetenv(const char *name, const char *value, int overwrite)
{
    int i;
    char * a;
    if (!overwrite && getenv(name)) return 0;
    i = strlen(name) + strlen(value) + 2;
    a = (malloc(i) ? : vmefail());
    if (!a) return 1;
    strcpy(a, name);
    strcat(a, "=");
    strcat(a, value);
    return putenv(a);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 9
36 9
37 9
38 10
39 10
40 10
41 10
42 10
43 10
44 11
45 11
46 11
47 12
48 12
49 12
50 8
51 13
52 13
53 13
54 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %r8,%rbx
mov    (%r8),%r8d
cmp    $0x1,%r8d
je     1d7 <EvalAtom+0x24>
cmp    $0x2,%r8d
je     1ea <EvalAtom+0x37>
jmp    205 <EvalAtom+0x52>
mov    %rsi,%rbp
mov    %rbx,%rdx
mov    %rcx,%rsi
mov    %r12,%rdi
callq  1e8 <EvalAtom+0x35>
jmp    21c <EvalAtom+0x69>
mov    %rcx,%rdi
callq  1f2 <EvalAtom+0x3f>
mov    %rax,%rbp
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  203 <EvalAtom+0x50>
jmp    21c <EvalAtom+0x69>
mov    $0x0,%ecx
mov    (%rdx),%rdx
mov    $0x8011,%esi
callq  217 <EvalAtom+0x64>
mov    $0x0,%ebp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
EvalAtom (PINPUTBUF pibIn, long index, PSTR *szExp, PSTR szToken,
               PINT piType)
{
  long result = 0;
  switch (*piType) {
    case 0x0001:
      result = index;
      GetToken (szExp, szToken, piType);
      break;
    case 0x0002:
      result = atol (szToken);
      GetToken (szExp, szToken, piType);
      break;
    default:
      ReportError (pibIn, 0x0011 | 0x8000, *szExp,
                   "(While parsing bracketed expression)");
  }
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 8
17 8
18 8
19 8
20 9
21 11
22 11
23 11
24 12
25 12
26 12
27 12
28 13
29 15
30 15
31 15
32 15
33 4
34 19
35 19
36 19
37 19
38 19
39 19
40 19
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
test   %rdi,%rdi
jne    f7 <xrealloc+0x13>
mov    %rsi,%rdi
callq  f5 <xrealloc+0x11>
jmp    10c <xrealloc+0x28>
callq  fc <xrealloc+0x18>
mov    %rax,%rdx
test   %rdx,%rdx
jne    10c <xrealloc+0x28>
mov    %rbx,%rdi
callq  30 <fixup_null_alloc>
pop    %rbx
retq   
<<<sep_in_sample>>>
xrealloc (void *p, size_t n)
{
  if (p == ((void *)0))
    return xmalloc (n);
  p = realloc (p, n);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 9
15 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   $0xf,%sil
jne    23 <openssl_aes_decrypt+0x23>
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
test   %rsi,%rsi
jne    3c <openssl_aes_decrypt+0x3c>
jmp    5d <openssl_aes_decrypt+0x5d>
mov    $0x0,%ecx
mov    $0x78,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3c <openssl_aes_decrypt+0x3c>
mov    $0x0,%ecx
mov    %r13,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  4f <openssl_aes_decrypt+0x4f>
add    $0x10,%rbp
add    $0x10,%r12
sub    $0x10,%rbx
jne    3c <openssl_aes_decrypt+0x3c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
openssl_aes_decrypt(const void *ctx, size_t length,
      uint8_t *dst, const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "nettle-openssl.c", 120, __PRETTY_FUNCTION__));
  while (length)
    {
      AES_ecb_encrypt(src, dst, ctx, 0);
      length -= 16;
      dst += 16;
      src += 16;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 4
16 4
17 4
18 4
19 4
20 7
21 7
22 7
23 7
24 7
25 9
26 10
27 5
28 5
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 712 <set_dollar_vars_unchanged+0xa>
retq   
<<<sep_in_sample>>>
set_dollar_vars_unchanged ()
{
  changed_dollar_vars = 0;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  1f <html_styled_ostream__begin_use_class+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
html_styled_ostream__begin_use_class (html_styled_ostream_t stream,
                                      const char *classname)
{
  html_ostream_begin_span (stream->html_destination, classname);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%eax
test   %rdi,%rdi
je     1eb <tld_get_4z+0x36>
mov    %rsi,%rdx
cmpl   $0x0,(%rdi)
je     1d9 <tld_get_4z+0x24>
mov    %rdi,%rax
add    $0x4,%rax
cmpl   $0x0,(%rax)
jne    1ce <tld_get_4z+0x19>
jmp    1dc <tld_get_4z+0x27>
mov    %rdi,%rax
sub    %rdi,%rax
sar    $0x2,%rax
mov    %rax,%rsi
callq  1eb <tld_get_4z+0x36>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
tld_get_4z (const uint32_t * in, char **out)
{
  const uint32_t *ipos = in;
  if (!in)
    return TLD_NODATA;
  while (*ipos)
    ipos++;
  return tld_get_4 (in, ipos - in, out);
}
<<<sep_in_sample>>>
1 2
2 5
3 4
4 4
5 4
6 6
7 6
8 6
9 7
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%r8d
movslq %esi,%rsi
mov    $0x0,%r9d
mov    $0x2,%ecx
mov    $0x1,%edx
mov    $0x0,%edi
callq  24 <mapread+0x24>
cmp    $0xffffffffffffffff,%rax
je     34 <mapread+0x34>
test   %rax,%rax
jne    39 <mapread+0x39>
callq  34 <mapread+0x34>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mapread(int fd, int nbytes)
{
  char *p = (char *)mmap((void *)0, (size_t)nbytes, 0x1,
    0|0x02, fd, (off_t)0);
  if (p == (char *)-1)
    return 0;
  if (p == 0)
    abort();
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 8
14 6
15 10
16 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%r8        # b <version_etc_hook+0xb>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    0x0(%rip),%rsi        # 1c <version_etc_hook+0x1c>
callq  21 <version_etc_hook+0x21>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU cpio", "2.12",
                  program_authors);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    $0x14,%eax
cmp    0x8(%rdi),%r9
jne    85b <gsl_linalg_PTLQ_LQsolve_T+0x83>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    %rcx,%rdx
mov    %r8,%r12
mov    (%rsi),%rcx
cmp    0x8(%rsi),%rcx
jne    857 <gsl_linalg_PTLQ_LQsolve_T+0x7f>
mov    $0x13,%al
cmp    0x0(%rbp),%r9
jne    857 <gsl_linalg_PTLQ_LQsolve_T+0x7f>
cmp    %rcx,%r9
jne    857 <gsl_linalg_PTLQ_LQsolve_T+0x7f>
cmp    (%rdx),%r9
jne    857 <gsl_linalg_PTLQ_LQsolve_T+0x7f>
mov    %r8,%rcx
xorpd  %xmm1,%xmm1
mov    %rdi,%rsi
movsd  0x0(%rip),%xmm0        # 823 <gsl_linalg_PTLQ_LQsolve_T+0x4b>
mov    $0x6f,%edi
callq  82d <gsl_linalg_PTLQ_LQsolve_T+0x55>
mov    %r12,%r8
mov    %rbx,%rcx
mov    $0x83,%edx
mov    $0x70,%esi
mov    $0x7a,%edi
callq  847 <gsl_linalg_PTLQ_LQsolve_T+0x6f>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  852 <gsl_linalg_PTLQ_LQsolve_T+0x7a>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
gsl_linalg_PTLQ_LQsolve_T (const gsl_matrix * Q, const gsl_matrix * L,
                           const gsl_permutation * p,
                           const gsl_vector * b,
                           gsl_vector * x)
{
  if (Q->size1 != Q->size2 || L->size1 != L->size2)
    {
      return GSL_ENOTSQR;
    }
  else if (Q->size1 != p->size || Q->size1 != L->size1
           || Q->size1 != b->size)
    {
      return GSL_EBADLEN;
    }
  else
    {
      gsl_blas_dgemv (CblasNoTrans, 1.0, Q, b, 0.0, x);
      gsl_blas_dtrsv (CblasLower, CblasTrans, CblasNonUnit, L, x);
      gsl_permute_vector_inverse (p, x);
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 6
2 8
3 6
4 6
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 13
16 10
17 10
18 10
19 10
20 11
21 11
22 17
23 17
24 17
25 17
26 17
27 17
28 18
29 18
30 18
31 18
32 18
33 18
34 19
35 19
36 19
37 20
38 22
39 22
40 22
41 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  10ea <rl_unbind_key+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_unbind_key (key)
     int key;
{
  return (rl_bind_key (key, (rl_command_func_t *)((void *)0)));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%eax
cmp    $0x2,%eax
je     17 <decode_xform+0x17>
cmp    $0x4,%eax
je     76 <decode_xform+0x76>
cmp    $0x1,%eax
jne    41 <decode_xform+0x41>
jmp    2d <decode_xform+0x2d>
movzbl 0x0(%rip),%edx        # 1e <decode_xform+0x1e>
mov    $0x1,%esi
callq  28 <decode_xform+0x28>
mov    %rax,%rbx
jmp    41 <decode_xform+0x41>
movzbl 0x0(%rip),%edx        # 34 <decode_xform+0x34>
mov    $0x0,%esi
callq  3e <decode_xform+0x3e>
mov    %rax,%rbx
mov    0x0(%rip),%rsi        # 48 <decode_xform+0x48>
test   %rsi,%rsi
je     76 <decode_xform+0x76>
mov    %rbx,%rdi
callq  55 <decode_xform+0x55>
cmp    $0xffffffffffffffff,%rax
jne    73 <decode_xform+0x73>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
add    %rax,%rbx
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
decode_xform (char *file_name, void *data)
{
  int type = *(int*)data;
  switch (type)
    {
    case 0x04:
      return file_name;
    case 0x02:
      file_name = safer_name_suffix (file_name, 1, absolute_names_option);
      break;
    case 0x01:
      file_name = safer_name_suffix (file_name, 0, absolute_names_option);
      break;
    }
  if (strip_name_components)
    {
      size_t prefix_len = stripped_prefix_len (file_name,
            strip_name_components);
      if (prefix_len == (size_t) -1)
 prefix_len = strlen (file_name);
      file_name += prefix_len;
    }
  return file_name;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 9
12 9
13 9
14 9
15 10
16 12
17 12
18 12
19 12
20 15
21 15
22 15
23 17
24 17
25 19
26 19
27 20
28 20
29 20
30 20
31 20
32 20
33 21
34 24
35 24
36 24
<<<sep_out_sample>>>
testb  $0x2,0x2d0(%rdi)
je     6fb <fuelUsed+0x1a>
mov    0x320(%rdi),%rax
movsd  0x228(%rax),%xmm0
jmp    70a <fuelUsed+0x29>
mov    0x320(%rdi),%rax
movsd  0x220(%rax),%xmm0
mulsd  0x268(%rdi),%xmm0
mulsd  0x0(%rip),%xmm0        # 71a <fuelUsed+0x39>
divsd  0x0(%rip),%xmm0        # 722 <fuelUsed+0x41>
retq   
<<<sep_in_sample>>>
fuelUsed( craft * c )
{
 double spFuelConsump;
 if (c->flags & (1<<1)) {
  spFuelConsump = c->cinfo->spABFuelConsump;
 }
 else {
  spFuelConsump = c->cinfo->spFuelConsump;
 }
 return spFuelConsump * c->curThrust * deltaT / 3600.0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 8
7 8
8 10
9 10
10 10
11 11
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    0x20(%rsp),%rax
mov    %rax,(%rsp)
callq  13 <xmem_cd_iconveh+0x13>
mov    %eax,%ebx
test   %eax,%eax
jns    28 <xmem_cd_iconveh+0x28>
callq  1e <xmem_cd_iconveh+0x1e>
cmpl   $0xc,(%rax)
jne    28 <xmem_cd_iconveh+0x28>
callq  28 <xmem_cd_iconveh+0x28>
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
xmem_cd_iconveh (const char *src, size_t srclen,
                 const iconveh_t *cd,
                 enum iconv_ilseq_handler handler,
                 size_t *offsets,
                 char **resultp, size_t *lengthp)
{
  int retval =
    mem_cd_iconveh (src, srclen, cd, handler, offsets, resultp, lengthp);
  if (retval < 0 && (*__errno_location ()) == 12)
    xalloc_die ();
  return retval;
}
<<<sep_in_sample>>>
1 6
2 6
3 7
4 7
5 7
6 7
7 9
8 9
9 9
10 9
11 9
12 10
13 12
14 12
15 12
16 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    (%rsi),%rax
mov    0x18(%rdi),%rdx
cmp    0x130(%rdx),%rax
jae    e95 <oldgnu_store_sparse_info+0x91>
mov    %rcx,%r12
test   %rcx,%rcx
je     e95 <oldgnu_store_sparse_info+0x91>
shl    $0x4,%rax
add    0x140(%rdx),%rax
mov    $0xc,%edx
mov    %rbx,%rsi
mov    (%rax),%rdi
callq  e4a <oldgnu_store_sparse_info+0x46>
lea    0xc(%rbx),%rsi
mov    0x18(%r13),%rdx
mov    0x0(%rbp),%rax
shl    $0x4,%rax
add    0x140(%rdx),%rax
mov    0x8(%rax),%rdi
mov    $0xc,%edx
callq  e6f <oldgnu_store_sparse_info+0x6b>
sub    $0x1,%r12
add    $0x18,%rbx
mov    0x0(%rbp),%rax
add    $0x1,%rax
mov    %rax,0x0(%rbp)
mov    0x18(%r13),%rdx
cmp    %rax,0x130(%rdx)
jbe    e95 <oldgnu_store_sparse_info+0x91>
test   %r12,%r12
jne    e2f <oldgnu_store_sparse_info+0x2b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
oldgnu_store_sparse_info (struct tar_sparse_file *file, size_t *pindex,
     struct sparse *sp, size_t sparse_size)
{
  for (; *pindex < file->stat_info->sparse_map_avail
  && sparse_size > 0; sparse_size--, sp++, ++*pindex)
    {
      off_to_chars (file->stat_info->sparse_map[*pindex].offset, sp->offset, sizeof (sp->offset))
                 ;
      off_to_chars (file->stat_info->sparse_map[*pindex].numbytes, sp->numbytes, sizeof (sp->numbytes))
                   ;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 5
31 5
32 5
33 5
34 5
35 4
36 4
37 4
38 5
39 5
40 12
41 12
42 12
43 12
44 12
45 12
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
mov    -0x10(%rsp),%eax
and    $0x7fff,%eax
jne    1b <rpl_isnanl+0x1b>
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
retq   
cmp    $0x7fff,%eax
jne    36 <rpl_isnanl+0x36>
mov    -0x14(%rsp),%eax
add    $0x80000000,%eax
or     -0x18(%rsp),%eax
setne  %al
movzbl %al,%eax
retq   
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
xor    $0x1,%eax
retq   
<<<sep_in_sample>>>
rpl_isnanl (long double x)
{
  memory_double m;
  unsigned int exponent;
  m.value = x;
  exponent = (m.word[2] >> 0) & ((16384 - (-16381)) | 7);
  if (exponent == 0)
    return (m.word[1] >> 31);
  else if (exponent == ((16384 - (-16381)) | 7))
    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;
  else
    return (m.word[1] >> 31) ^ 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 7
5 7
6 8
7 8
8 8
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 12
18 12
19 12
20 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # ed5 <readlink_diag+0xb>
je     ede <readlink_diag+0x14>
callq  edc <readlink_diag+0x12>
jmp    ee5 <readlink_diag+0x1b>
xchg   %ax,%ax
callq  ee5 <readlink_diag+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
readlink_diag (char const *name)
{
  if (ignore_failed_read_option)
    readlink_warn (name);
  else
    readlink_error (name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r12d
mov    %ecx,%r13d
mov    %r8,%r14
mov    %r9d,%r15d
movq   $0x0,0x0(%rip)        # 8b2 <de_rp_hdy+0x2a>
cmpl   $0x0,0x0(%rip)        # 8b9 <de_rp_hdy+0x31>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 8c5 <de_rp_hdy+0x3d>
mov    0x50(%rsp),%eax
mov    %eax,(%rsp)
callq  8d1 <de_rp_hdy+0x49>
cmpl   $0x0,0x0(%rip)        # 8d8 <de_rp_hdy+0x50>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 8e4 <de_rp_hdy+0x5c>
mov    0x50(%rsp),%eax
mov    %eax,(%rsp)
mov    %r15d,%r9d
mov    %r14,%r8
mov    %r13d,%ecx
mov    %r12d,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  901 <de_rp_hdy+0x79>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
de_rp_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "DE_RP";
  use_other_cc = !use_other_cc;
  de_nw_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
  de_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 10
15 11
16 11
17 11
18 11
19 12
20 12
21 12
22 13
23 13
24 13
25 13
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x8,%esi
callq  1f29 <gsl_block_ulong_fwrite+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     1f4e <gsl_block_ulong_fwrite+0x3d>
mov    $0x5,%ecx
mov    $0x30,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  1f49 <gsl_block_ulong_fwrite+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_ulong_fwrite (FILE * stream, const gsl_block_ulong * b)
{
  size_t n = b->size ;
  unsigned long * data = b->data ;
  size_t items = fwrite (data, 1 * sizeof (unsigned long), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "fwrite_source.c", 48, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x68(%rdi),%rdi
test   %rdi,%rdi
je     88 <mu_pop3_send+0x88>
mov    0x8(%rbx),%r12
mov    (%rbx),%rbp
cmp    %rbp,%r12
jbe    88 <mu_pop3_send+0x88>
movq   $0x0,0x8(%rsp)
mov    0x50(%rbx),%edx
test   %edx,%edx
je     42 <mu_pop3_send+0x42>
mov    $0x2,%esi
callq  3a <mu_pop3_send+0x3a>
test   %eax,%eax
jne    42 <mu_pop3_send+0x42>
mov    $0x6e,%al
jmp    94 <mu_pop3_send+0x94>
sub    %rbp,%r12
mov    0x68(%rbx),%rdi
lea    0x8(%rsp),%r8
mov    $0x0,%ecx
mov    %r12,%rdx
mov    (%rbx),%rsi
callq  5e <mu_pop3_send+0x5e>
mov    %eax,%ebp
mov    0x8(%rsp),%rsi
test   %rsi,%rsi
je     84 <mu_pop3_send+0x84>
mov    (%rbx),%rdi
mov    %r12,%rdx
sub    %rsi,%rdx
add    %rdi,%rsi
callq  7b <mu_pop3_send+0x7b>
mov    0x8(%rsp),%rax
sub    %rax,0x8(%rbx)
mov    %ebp,%eax
jmp    94 <mu_pop3_send+0x94>
mov    (%rbx),%rax
mov    %rax,0x8(%rbx)
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_pop3_send (mu_pop3_t pop3)
{
  int status = 0;
  if (pop3->carrier && (pop3->io.ptr > pop3->io.buf))
    {
      size_t n = 0;
      size_t len = pop3->io.ptr - pop3->io.buf;
      if (pop3->timeout)
 {
   int ready = mu_pop3_carrier_is_ready (pop3->carrier,
      0x2,
      pop3->timeout);
   if (ready == 0)
     return 110;
 }
      status = mu_stream_write (pop3->carrier, pop3->io.buf, len, 0, &n);
      if (n)
 {
   memmove (pop3->io.buf, pop3->io.buf + n, len - n);
   pop3->io.ptr -= n;
 }
    }
  else
    pop3->io.ptr = pop3->io.buf;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 8
15 8
16 8
17 10
18 10
19 13
20 13
21 14
22 14
23 7
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 17
32 17
33 17
34 19
35 19
36 19
37 19
38 19
39 20
40 20
41 16
42 5
43 24
44 24
45 3
46 26
47 26
48 26
49 26
50 26
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d66 <swlib_is_sh_tainted_string_fatal+0x35>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  d44 <swlib_is_sh_tainted_string_fatal+0x13>
test   %rax,%rax
je     d62 <swlib_is_sh_tainted_string_fatal+0x31>
mov    $0x0,%ecx
mov    $0x389,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d62 <swlib_is_sh_tainted_string_fatal+0x31>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
swlib_is_sh_tainted_string_fatal(char * s) {
 if (!s) return;
 if (strpbrk(s, "'\"|*?;&<>`$[]") ? 1 : 0) {
  swlib_fatal("tainted string", (char*)"swlib.c", 905, (char*)__FUNCTION__);;
 }
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 1
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 7
14 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    $0x30,%edi
callq  369 <dicod_acl_create+0x14>
mov    %rax,%rbx
mov    %r12,%rdi
callq  374 <dicod_acl_create+0x1f>
mov    %rax,(%rbx)
mov    0x0(%rbp),%rdi
mov    %rdi,0x8(%rbx)
mov    0x8(%rbp),%rax
mov    %rax,0x10(%rbx)
mov    0x10(%rbp),%rax
mov    %rax,0x18(%rbx)
mov    0x18(%rbp),%rax
mov    %rax,0x20(%rbx)
callq  39c <dicod_acl_create+0x47>
mov    %rax,0x8(%rbx)
mov    0x18(%rbx),%rdi
callq  3a9 <dicod_acl_create+0x54>
mov    %rax,0x18(%rbx)
callq  3b2 <dicod_acl_create+0x5d>
mov    %rax,0x28(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dicod_acl_create(const char *name, grecs_locus_t *locus)
{
    dicod_acl_t acl = xmalloc(sizeof(acl[0]));
    acl->name = xstrdup(name);
    acl->locus = *locus;
    acl->locus.beg.file = strdup(acl->locus.beg.file);
    acl->locus.end.file = strdup(acl->locus.end.file);
    acl->list = dico_list_create();
    return acl;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 6
21 6
22 7
23 7
24 7
25 8
26 8
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  687 <update_progress_meter+0xb>
mov    %rax,%rbx
mov    (%rax),%ebp
callq  6a <can_output>
test   %eax,%eax
je     69a <update_progress_meter+0x1e>
callq  69a <update_progress_meter+0x1e>
mov    $0x0,%esi
mov    $0xe,%edi
callq  6a9 <update_progress_meter+0x2d>
mov    $0x1,%edi
callq  6b3 <update_progress_meter+0x37>
mov    %ebp,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
update_progress_meter(int ignore)
{
 int save_errno;
 save_errno = (*__errno_location ());
 if (can_output())
  refresh_progress_meter();
 signal(14, update_progress_meter);
 alarm(1);
 (*__errno_location ()) = save_errno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 8
15 8
16 9
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     e9 <mu_stream_open+0x26>
movl   $0x1,0x14(%rdi)
mov    0x50(%rdi),%rdx
mov    $0x0,%al
test   %rdx,%rdx
je     e9 <mu_stream_open+0x26>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_stream_open (mu_stream_t stream)
{
  if (stream == ((void *)0))
    return 22;
  stream->state = 1;
  if (stream->_open)
    return stream->_open (stream);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 8
7 6
8 6
9 2
10 7
11 9
12 9
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
retq   
<<<sep_in_sample>>>
gsl_rng_min (const gsl_rng * r)
{
  return r->type->min;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  fb <xstrdup+0x22>
mov    %rax,%rbx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  109 <xstrdup+0x30>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xstrdup (str)
     char *str;
{
  char *tmp;
  tmp = xmalloc (strlen (str) + 1);
  strcpy (tmp, str);
  return tmp;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x18(%rdi),%rdx
mov    0x8(%rdi),%rcx
test   %rdx,%rdx
js     3f9 <hash_print_stats+0x20>
cvtsi2sd %rdx,%xmm0
jmp    411 <hash_print_stats+0x38>
mov    %rdx,%rax
shr    %rax
mov    %rdx,%rsi
and    $0x1,%esi
or     %rsi,%rax
cvtsi2sd %rax,%xmm0
addsd  %xmm0,%xmm0
mulsd  0x0(%rip),%xmm0        # 419 <hash_print_stats+0x40>
test   %rcx,%rcx
js     425 <hash_print_stats+0x4c>
cvtsi2sd %rcx,%xmm1
jmp    43d <hash_print_stats+0x64>
mov    %rcx,%rax
shr    %rax
mov    %rcx,%rsi
and    $0x1,%esi
or     %rsi,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x1,%eax
callq  453 <hash_print_stats+0x7a>
mov    0x30(%rbx),%edx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  468 <hash_print_stats+0x8f>
mov    0x28(%rbx),%rcx
xorpd  %xmm0,%xmm0
test   %rcx,%rcx
je     4ca <hash_print_stats+0xf1>
mov    0x20(%rbx),%rax
test   %rax,%rax
js     485 <hash_print_stats+0xac>
cvtsi2sd %rax,%xmm0
jmp    49a <hash_print_stats+0xc1>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
mulsd  0x0(%rip),%xmm0        # 4a2 <hash_print_stats+0xc9>
test   %rcx,%rcx
js     4ae <hash_print_stats+0xd5>
cvtsi2sd %rcx,%xmm1
jmp    4c6 <hash_print_stats+0xed>
mov    %rcx,%rax
shr    %rax
mov    %rcx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
mov    0x20(%rbx),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x1,%eax
callq  4e0 <hash_print_stats+0x107>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
hash_print_stats (struct hash_table_s *ht, FILE *out_FILE)
{
  fprintf (out_FILE, "Load=%ld/%ld=%.0f%%, ", ht->ht_fill, ht->ht_size,
    100.0 * (double) ht->ht_fill / (double) ht->ht_size);
  fprintf (out_FILE, "Rehash=%d, ", ht->ht_rehashes);
  fprintf (out_FILE, "Collisions=%ld/%ld=%.0f%%\n",
    ht->ht_collisions, ht->ht_lookups,
    (ht->ht_lookups
     ? (100.0 * (double) ht->ht_collisions / (double) ht->ht_lookups)
     : 0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 3
32 3
33 3
34 3
35 3
36 5
37 5
38 5
39 5
40 5
41 8
42 6
43 6
44 6
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 6
69 6
70 6
71 6
72 6
73 6
74 11
75 11
76 11
77 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  159f <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18e4 <gcide_markup_yyrealloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gcide_markup_yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x8,%edx
callq  23a <long_cmp+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
long_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(long)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
test   %rdi,%rdi
je     17 <crc16+0x17>
mov    %rdi,%rcx
add    %rsi,%rdi
mov    $0x0,%eax
test   %rsi,%rsi
jne    34 <crc16+0x34>
jmp    5e <crc16+0x5e>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x26,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  34 <crc16+0x34>
movzbl (%rcx),%edx
shl    $0x8,%edx
xor    %edx,%eax
mov    $0x8,%edx
test   %ax,%ax
jns    4e <crc16+0x4e>
add    %eax,%eax
xor    $0x1021,%ax
jmp    50 <crc16+0x50>
add    %eax,%eax
sub    $0x1,%edx
jne    41 <crc16+0x41>
add    $0x1,%rcx
cmp    %rdi,%rcx
jne    34 <crc16+0x34>
not    %eax
retq   
<<<sep_in_sample>>>
crc16 (const void *message, size_t length)
{
  ((message != ((void *)0)) ? (void) (0) : __assert_fail ("message != ((void *)0)", "crc.c", 38, __PRETTY_FUNCTION__));
  size_t i;
  int j;
  uint16_t crc = 0;
  uint16_t polynomial = 0x1021;
  for (i = 0; i < length; i++)
    {
      crc ^= (uint16_t) *((uint8_t *) message + i) << 8;
      for (j = 0; j < 8; j++)
 crc = crc & (1 << 15) ? (crc << 1) ^ polynomial : crc << 1;
    }
  return ~crc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 8
6 8
7 8
8 8
9 2
10 3
11 3
12 3
13 3
14 3
15 10
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 12
24 12
25 11
26 11
27 11
28 8
29 8
30 14
31 15
<<<sep_out_sample>>>
push   %rbx
mov    $0x18,%edi
callq  27e9 <headerNew+0xb>
mov    %rax,%rbx
test   %rax,%rax
jne    27f9 <headerNew+0x1b>
callq  27f6 <headerNew+0x18>
mov    %rax,%rbx
movl   $0x8,0xc(%rbx)
mov    $0x20,%esi
mov    $0x8,%edi
callq  280f <headerNew+0x31>
mov    %rax,%rdx
test   %rax,%rax
jne    281f <headerNew+0x41>
callq  281c <headerNew+0x3e>
mov    %rax,%rdx
mov    %rdx,(%rbx)
movl   $0x0,0x8(%rbx)
movl   $0x0,0x10(%rbx)
movl   $0x1,0x14(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
headerNew()
{
    Header h = (malloc(sizeof(struct headerToken)) ? : vmefail());
    h->indexAlloced = 8;
    h->index = (calloc((h->indexAlloced), (sizeof(struct indexEntry))) ? : vmefail());
    h->indexUsed = 0;
    h->sorted = 0;
    h->usageCount = 1;
    return (Header) h;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 7
21 8
22 10
23 10
24 10
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     437 <mu_server_set_idle+0x13>
mov    %rsi,0xb0(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_server_set_idle (mu_server_t srv, mu_server_idle_fp fp)
{
  if (!srv)
    return 22;
  srv->f_idle = fp;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
sub    $0x38,%rsp
cmp    $0x27,%esi
jg     3b <add_one+0x3b>
mov    $0x66666667,%edx
mov    %esi,%eax
imul   %edx
sar    $0x2,%edx
mov    %esi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%esi
movslq %esi,%rsi
mov    0x0(,%rsi,8),%rax
movslq %edx,%rdx
mov    0x0(,%rdx,8),%rsi
jmp    51 <add_one+0x51>
sub    $0x28,%esi
movslq %esi,%rsi
mov    0x0(,%rsi,8),%rax
mov    0x0(,%rsi,8),%rsi
movsbl 0x1(%rsi),%r9d
movsbl 0x1(%rax),%r8d
movsbl (%rsi),%ecx
movsbl (%rax),%edx
movsbl 0x4(%rax),%r10d
mov    %r10d,0x20(%rsp)
movsbl 0x3(%rsi),%r10d
mov    %r10d,0x18(%rsp)
movsbl 0x3(%rax),%r10d
mov    %r10d,0x10(%rsp)
movsbl 0x2(%rsi),%esi
mov    %esi,0x8(%rsp)
movsbl 0x2(%rax),%eax
mov    %eax,(%rsp)
mov    $0x0,%esi
mov    $0x0,%eax
callq  9d <add_one+0x9d>
mov    $0x0,%eax
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
add_one(char *ptr, int code)
{
    char *b, *s;
    if (code < 40) {
        b = bars[code%10];
        s = spaces[code/10];
    } else {
        b = specialbars[code-40];
        s = specialspaces[code-40];
    }
    sprintf(ptr,"1%c%c%c%c%c%c%c%c%c",
            b[0], s[0], b[1], s[1], b[2], s[2],
            b[3], s[3], b[4]);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 6
19 8
20 8
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 15
41 15
42 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x1,%esi
mov    $0x838,%edi
callq  72f <Q_init+0x18>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     79d <Q_init+0x86>
movq   $0x4c,0x8(%rbx)
mov    $0x1,%esi
mov    $0x4c,%edi
callq  753 <Q_init+0x3c>
mov    %rax,0x18(%rbx)
test   %rax,%rax
jne    76b <Q_init+0x54>
mov    %rbx,%rdi
callq  764 <Q_init+0x4d>
mov    $0xc,%eax
jmp    79d <Q_init+0x86>
cmpl   $0x0,0x1c(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
mov    %rax,0x830(%rbx)
movq   $0x0,0x28(%rbp)
movq   $0x0,0x40(%rbp)
mov    %rbx,0x20(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
Q_init (mu_filter_t filter)
{
  struct _trans_stream *ts;
  ts = calloc (sizeof (*ts), 1);
  if (ts == ((void *)0))
    return 12;
  ts->min_size = 76;
  ts->s_buf = calloc (ts->min_size, 1);
  if (ts->s_buf == ((void *)0))
    {
      free (ts);
      return 12;
    }
  ts->transcoder = (filter->type == 0) ? Q_decode : Q_encode;
  filter->_read = trans_read;
  filter->_destroy = trans_destroy;
  filter->data = ts;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 5
11 5
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 11
20 11
21 12
22 12
23 14
24 14
25 14
26 14
27 14
28 15
29 16
30 17
31 18
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rax
mov    $0x0,%r12d
cmpb   $0x0,(%rax)
je     34 <finopen+0x34>
mov    $0x1,%r12b
cmpb   $0x0,0x8(%rdi)
jne    34 <finopen+0x34>
mov    0x0(%rip),%rax        # 26 <finopen+0x26>
mov    0xd8(%rax),%r12d
not    %r12d
shr    $0x1f,%r12d
mov    0x0(%rip),%rbp        # 3b <finopen+0x3b>
mov    %rbx,%rdi
callq  *(%rbx)
mov    %rax,0x190(%rbp)
mov    $0x1,%ebp
mov    0x0(%rip),%rax        # 53 <finopen+0x53>
cmpq   $0x0,0x190(%rax)
jne    70 <finopen+0x70>
callq  62 <finopen+0x62>
cmpl   $0x2,(%rax)
setne  %bpl
jne    70 <finopen+0x70>
test   %r12d,%r12d
jne    8a <finopen+0x8a>
callq  75 <finopen+0x75>
mov    (%rax),%eax
mov    %eax,0x40(%rbx)
mov    0x10(%rbx),%rsi
mov    0x18(%rbx),%rdi
mov    %rsi,0x28(%rbx)
mov    %rdi,0x30(%rbx)
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
finopen (struct maybe *m)
{
  _Bool interesting, preferold;
  preferold = m->bestfit.string[0] && (m->mustread || 0 <= (top->repository. fd_lock));
  (top->flow. from) = (m->open) (m);
  interesting = (top->flow. from) || (*__errno_location ()) != 2;
  if (interesting || !preferold)
    {
      m->eno = (*__errno_location ());
      m->bestfit = m->tentative;
    }
  return interesting;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
mov    0x0(%rip),%rax        # 11bd <quotearg_n_custom_mem+0x17>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 11c8 <quotearg_n_custom_mem+0x22>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 11d4 <quotearg_n_custom_mem+0x2e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 11e0 <quotearg_n_custom_mem+0x3a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 11ec <quotearg_n_custom_mem+0x46>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 11f8 <quotearg_n_custom_mem+0x52>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 1204 <quotearg_n_custom_mem+0x5e>
mov    %rax,0x30(%rsp)
mov    %rsp,%rdi
callq  1211 <quotearg_n_custom_mem+0x6b>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b75 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x2010,%rsp
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rsi
mov    %rcx,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
mov    %rcx,%rdx
mov    %rsp,%rdi
callq  2a00 <doOutput+0x34>
movb   $0x0,(%rsp,%rbx,1)
mov    $0x2000,%edx
mov    %rsp,%rsi
mov    %r12,%rdi
callq  20dd <expandU>
test   %ebp,%ebp
je     2a31 <doOutput+0x65>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    $0xffffff8a,%edi
mov    $0x0,%eax
callq  2a2f <doOutput+0x63>
jmp    2a40 <doOutput+0x74>
mov    0x0(%rip),%rsi        # 2a38 <doOutput+0x6c>
mov    %rsp,%rdi
callq  2a40 <doOutput+0x74>
mov    0x2008(%rsp),%rax
xor    %fs:0x28,%rax
je     2a58 <doOutput+0x8c>
callq  2a58 <doOutput+0x8c>
add    $0x2010,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
doOutput(MacroBuf *mb, int waserror, const char *msg, size_t msglen)
{
 char buf[8192];
 strncpy(buf, msg, msglen);
 buf[msglen] = '\0';
 expandU(mb, buf, sizeof(buf));
 if (waserror)
  rpmError(-118, "%s", buf);
 else
  fprintf(stderr, "%s", buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 4
13 4
14 4
15 5
16 6
17 6
18 6
19 6
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 8
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbp
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%r12
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x18(%rsp)
ucomisd %xmm3,%xmm2
jae    101c <TruncInvGGammaRandom+0x37>
mov    $0x1,%ebx
jmp    1085 <TruncInvGGammaRandom+0xa0>
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x2,%eax
callq  1037 <TruncInvGGammaRandom+0x52>
xorpd  %xmm0,%xmm0
jmp    10b4 <TruncInvGGammaRandom+0xcf>
add    $0x1,%ebx
cmp    $0x19,%ebx
jne    1085 <TruncInvGGammaRandom+0xa0>
mov    $0x0,%edi
mov    $0x0,%eax
callq  1054 <TruncInvGGammaRandom+0x6f>
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm3
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm2
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x4,%eax
callq  1085 <TruncInvGGammaRandom+0xa0>
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  10a0 <TruncInvGGammaRandom+0xbb>
movsd  0x10(%rsp),%xmm4
ucomisd %xmm0,%xmm4
ja     103d <TruncInvGGammaRandom+0x58>
ucomisd 0x18(%rsp),%xmm0
ja     103d <TruncInvGGammaRandom+0x58>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
TruncInvGGammaRandom (double alpha, double beta, double a, double b)
{
  double X = 0.0;
  int iter = 0;
  if (a >= b)
    printf ("TruncLogNormalRandom: min >= max  [%g %g]\n", a, b);
  else do {
    if(++iter == 25) {
      printf("TruncInvGGammaRandom: problem with range: ");
      printf("min %g, max %g, alpha %g, beta %g\n", a, b, alpha, beta);
    }
    X = InvGGammaRandom(alpha, beta);
  }
  while (X < a || X > b);
  return X;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 8
14 8
15 6
16 6
17 6
18 6
19 6
20 3
21 3
22 8
23 8
24 8
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 12
38 12
39 12
40 12
41 12
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  12a8 <quote+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote (char const *name)
{
  return quote_n (0, name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  166a <yy_scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%r8
mov    %rcx,%r9
mov    $0x0,%ecx
mov    $0x0,%edx
callq  b1 <verror+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
verror (int status, int errnum, const char *format, va_list args)
{
  verror_at_line (status, errnum, ((void *)0), 0, format, args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
jne    4ee <osip_list_ofchar_free+0x4d>
jmp    4ff <osip_list_ofchar_free+0x5e>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  4be <osip_list_ofchar_free+0x1d>
mov    %rax,%rbp
mov    $0x0,%esi
mov    %rbx,%rdi
callq  4ce <osip_list_ofchar_free+0x2d>
test   %rbp,%rbp
je     4ee <osip_list_ofchar_free+0x4d>
mov    0x0(%rip),%rax        # 4da <osip_list_ofchar_free+0x39>
test   %rax,%rax
je     4e6 <osip_list_ofchar_free+0x45>
mov    %rbp,%rdi
callq  *%rax
jmp    4ee <osip_list_ofchar_free+0x4d>
mov    %rbp,%rdi
callq  4ee <osip_list_ofchar_free+0x4d>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  4fb <osip_list_ofchar_free+0x5a>
test   %eax,%eax
je     4b1 <osip_list_ofchar_free+0x10>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_list_ofchar_free (osip_list_t * li)
{
  char *chain;
  if (li == ((void *)0))
    return;
  while (!osip_list_eol (li, 0)) {
    chain = (char *) osip_list_get (li, 0);
    osip_list_remove (li, 0);
    { if (chain!=((void *)0)) { if (osip_free_func) osip_free_func(chain); else free(chain);} };
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 6
26 6
27 6
28 6
29 6
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
mov    $0x0,%eax
sub    0x0(%rip),%rax        # 572 <pty_buffer_is_full+0xc>
cmp    $0x1,%rax
setle  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
pty_buffer_is_full (void)
{
  return (&ptyobuf[8192] - pfrontp) < 2;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%r8
test   %r8,%r8
je     f1 <strtotok_len_ci+0x64>
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %rcx,%r14
mov    $0xffffffffffffffff,%r12
mov    %r8,%rdi
mov    $0x0,%eax
mov    %r12,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %rbp,%rcx
jne    e3 <strtotok_len_ci+0x56>
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r8,%rdi
callq  d7 <strtotok_len_ci+0x4a>
test   %eax,%eax
jne    e3 <strtotok_len_ci+0x56>
mov    0x8(%rbx),%edx
mov    %edx,(%r14)
jmp    fd <strtotok_len_ci+0x70>
add    $0x10,%rbx
mov    (%rbx),%r8
test   %r8,%r8
jne    b0 <strtotok_len_ci+0x23>
jmp    f8 <strtotok_len_ci+0x6b>
mov    $0x1,%eax
jmp    fd <strtotok_len_ci+0x70>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
strtotok_len_ci (struct tokendef *tab, const char *str, size_t len, int *pres)
{
  for (; tab->name; tab++)
    {
      size_t kwlen = strlen (tab->name);
      if (kwlen == len && c_strncasecmp (tab->name, str, len) == 0)
 {
   *pres = tab->tok;
   return 0;
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 8
29 8
30 9
31 3
32 3
33 3
34 3
35 3
36 12
37 12
38 12
39 13
40 13
41 13
42 13
43 13
44 13
<<<sep_out_sample>>>
movsd  0x28(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
gsl_min_fminimizer_f_minimum (const gsl_min_fminimizer * s)
{
  return s->f_minimum;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x418,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r8
mov    %fs:0x28,%rax
mov    %rax,0x408(%rsp)
xor    %eax,%eax
test   %rdx,%rdx
je     c2f <dbop_putoption+0x41>
mov    %rsi,%rcx
mov    $0x0,%edx
mov    $0x400,%esi
mov    %rsp,%rdi
callq  c2d <dbop_putoption+0x3f>
jmp    c49 <dbop_putoption+0x5b>
mov    %rsi,%rcx
mov    $0x0,%edx
mov    $0x400,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  c49 <dbop_putoption+0x5b>
mov    %rsp,%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  c57 <dbop_putoption+0x69>
mov    0x408(%rsp),%rax
xor    %fs:0x28,%rax
je     c6f <dbop_putoption+0x81>
callq  c6f <dbop_putoption+0x81>
add    $0x418,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dbop_putoption(DBOP *dbop, const char *key, const char *string)
{
 char buf[1024];
 if (string)
  snprintf(buf, sizeof(buf), "%s %s", key, string);
 else
  snprintf(buf, sizeof(buf), "%s", key);
 dbop_put(dbop, key, buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x218,%rsp
mov    %rdi,%r14
mov    %rsi,%rbx
mov    %edx,%r13d
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
mov    (%rsi),%rbp
cmpb   $0x20,0x0(%rbp)
je     44 <put_standard_format+0x44>
mov    %rbp,%rax
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    39 <put_standard_format+0x39>
jmp    47 <put_standard_format+0x47>
mov    %rbp,%rax
lea    0x1(%rax),%r12
movb   $0x0,(%rax)
cmpb   $0x20,0x1(%rax)
je     63 <put_standard_format+0x63>
mov    %r12,%r15
add    $0x1,%r15
cmpb   $0x20,(%r15)
jne    57 <put_standard_format+0x57>
jmp    66 <put_standard_format+0x66>
mov    %r12,%r15
movb   $0x0,(%r15)
test   $0x8,%r13b
je     8f <put_standard_format+0x8f>
mov    0x10(%rbx),%rsi
mov    %r12,%rdi
callq  7c <put_standard_format+0x7c>
mov    $0x200,%edx
mov    %rax,%rsi
mov    %rsp,%rdi
callq  8c <put_standard_format+0x8c>
mov    %rsp,%r12
mov    $0x0,%r8d
cmpl   $0x0,0x0(%rip)        # 9c <put_standard_format+0x9c>
jne    cb <put_standard_format+0xcb>
lea    0x1(%r15),%rax
cmpb   $0x20,0x1(%r15)
je     b2 <put_standard_format+0xb2>
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    a9 <put_standard_format+0xa9>
lea    0x1(%rax),%r8
test   $0x2,%r13b
je     cb <put_standard_format+0xcb>
mov    0x10(%rbx),%rsi
mov    %r8,%rdi
callq  c8 <put_standard_format+0xc8>
mov    %rax,%r8
mov    0x18(%rbx),%ecx
mov    0x8(%rbx),%rdx
mov    %rbp,%r9
mov    %r12,%rsi
mov    %r14,%rdi
callq  e0 <put_standard_format+0xe0>
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
je     f8 <put_standard_format+0xf8>
callq  f8 <put_standard_format+0xf8>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
put_standard_format(CONVERT *cv, GTP *gtp, int flags)
{
 char *p = (char *)gtp->tagline;
 char namebuf[512];
 const char *fid, *tagname, *image;
 fid = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 tagname = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 if (flags & 8) {
  strlimcpy(namebuf, (char *)uncompress(tagname, gtp->tag), sizeof(namebuf));
  tagname = namebuf;
 }
 if (nosource) {
  image = " ";
 } else {
  while (*p != ' ')
   p++;
  image = p + 1;
  if (flags & 2)
   image = (char *)uncompress(image, gtp->tag);
 }
 convert_put_using(cv, tagname, gtp->path, gtp->lineno, image, fid);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 3
15 7
16 7
17 3
18 8
19 7
20 7
21 7
22 3
23 9
24 9
25 11
26 11
27 9
28 12
29 11
30 11
31 11
32 9
33 13
34 14
35 14
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 16
44 19
45 18
46 18
47 13
48 21
49 21
50 22
51 21
52 21
53 23
54 24
55 24
56 25
57 25
58 25
59 25
60 27
61 27
62 27
63 27
64 27
65 27
66 28
67 28
68 28
69 28
70 28
71 28
72 28
73 28
74 28
75 28
76 28
77 28
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x88888889,%r13d
cmpl   $0x0,(%r12,%rbx,4)
je     14c <do_list_missing_characters+0x6c>
mov    %ebx,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 112 <do_list_missing_characters+0x32>
mov    $0x0,%eax
callq  11c <do_list_missing_characters+0x3c>
add    $0x1,%ebp
mov    %ebp,%eax
imul   %r13d
add    %ebp,%edx
sar    $0x3,%edx
mov    %ebp,%eax
sar    $0x1f,%eax
sub    %eax,%edx
mov    %edx,%eax
shl    $0x4,%eax
sub    %edx,%eax
cmp    %eax,%ebp
jne    14c <do_list_missing_characters+0x6c>
mov    0x0(%rip),%rsi        # 142 <do_list_missing_characters+0x62>
mov    $0xa,%edi
callq  14c <do_list_missing_characters+0x6c>
add    $0x1,%rbx
cmp    $0x100,%rbx
jne    fd <do_list_missing_characters+0x1d>
mov    $0x88888889,%edx
mov    %ebp,%eax
imul   %edx
lea    (%rdx,%rbp,1),%eax
sar    $0x3,%eax
mov    %ebp,%ecx
sar    $0x1f,%ecx
sub    %ecx,%eax
mov    %eax,%edx
shl    $0x4,%edx
sub    %eax,%edx
cmp    %edx,%ebp
je     18b <do_list_missing_characters+0xab>
mov    0x0(%rip),%rsi        # 181 <do_list_missing_characters+0xa1>
mov    $0xa,%edi
callq  18b <do_list_missing_characters+0xab>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
do_list_missing_characters (int *array)
{
  int i;
  int count = 0;
  for (i = 0; i < 256; i++)
    if (array[i])
      {
 fprintf (stderr, "%3d ", i);
 count++;
 if (count % 15 == 0)
   fprintf (stderr, "\n");
      }
  if (count % 15 != 0)
    fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 10
10 6
11 6
12 8
13 8
14 8
15 8
16 8
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 5
35 5
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 14
50 14
51 14
52 15
53 15
54 15
55 15
56 15
57 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%edi
callq  3ef <new_exclude+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
new_exclude (void)
{
  return xzalloc (sizeof *new_exclude ());
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
movslq %edi,%rdi
callq  b <Vmalloc+0xb>
test   %rax,%rax
jne    4d <Vmalloc+0x4d>
mov    0x0(%rip),%rcx        # 17 <Vmalloc+0x17>
mov    $0x23,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2b <Vmalloc+0x2b>
mov    %ebx,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 39 <Vmalloc+0x39>
mov    $0x0,%eax
callq  43 <Vmalloc+0x43>
mov    $0x1,%edi
callq  4d <Vmalloc+0x4d>
pop    %rbx
retq   
<<<sep_in_sample>>>
Vmalloc(int size)
{
 char *p;
 if ((p = malloc(size)) == (char *) ((void *)0)) {
  fprintf(stderr, "V package memory allocation error.\n");
  fprintf(stderr, "An error was encountered allocating %d bytes.\n",
               size);
  exit(1);
 }
 return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 11
20 11
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1b74 <gsl_sf_debye_4+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1b9a <gsl_sf_debye_4+0x32>
mov    %eax,%ecx
mov    $0x22b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b93 <gsl_sf_debye_4+0x2b>
movsd  (%rsp),%xmm0
jmp    1b9a <gsl_sf_debye_4+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_debye_4(const double x)
{
  gsl_sf_result result; int status = gsl_sf_debye_4_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_debye_4_e(x, &result)", "debye.c", 555, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  b36 <xdr_dis_capabilities+0x9>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdr_dis_capabilities(xdrs, objp)
	XDR *xdrs;
	dis_capabilities *objp;
{
	if (!xdr_byte_u_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 9
7 9
<<<sep_out_sample>>>
mov    0x14(%rdi),%eax
retq   
<<<sep_in_sample>>>
headerUsageCount(Header h)
{
    return h->usageCount;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    0x260(%rdi),%rax
mov    0x19c(%rdi),%edx
mov    %edx,0xb8(%rax)
mov    0x8c(%rdi),%edx
mov    %edx,0xbc(%rax)
retq   
<<<sep_in_sample>>>
start_pass_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  upsample->next_row_out = cinfo->max_v_samp_factor;
  upsample->rows_to_go = cinfo->output_height;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xd,%edi
ja     226 <signal_throw+0x2e>
mov    %edi,%eax
jmpq   *0x0(,%rax,8)
mov    $0xffffffe4,%edi
jmp    236 <signal_throw+0x3e>
mov    $0xffffffe9,%edi
jmp    236 <signal_throw+0x3e>
mov    $0xfffffff7,%edi
jmp    236 <signal_throw+0x3e>
mov    $0xfffff7ff,%edi
jmp    236 <signal_throw+0x3e>
mov    $0xffffff00,%eax
sub    %edi,%eax
mov    %eax,%edi
jmp    236 <signal_throw+0x3e>
mov    $0xffffffc9,%edi
callq  23b <sigaction_throw>
<<<sep_in_sample>>>
signal_throw(int sig)
{
  int code;
  switch (sig) {
  case 2: code=-28; break;
  case 8: code=-55; break;
  case 7: code=-23; break;
  case 11: code=-9; break;
  case 13: code=-2049; break;
  default: code=-256-sig; break;
  }
  throw(code);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 7
9 7
10 8
11 8
12 9
13 9
14 10
15 10
16 10
17 10
18 6
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edi
callq  1ecb <do_delete+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_delete(void)
{
    do_deletion(DEL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x818,%rsp
mov    %esi,%ebp
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
mov    $0x0,%esi
callq  28 <display_file+0x28>
mov    %rax,%rbx
test   %rax,%rax
je     8b <display_file+0x8b>
jmp    5b <display_file+0x5b>
mov    $0xa,%esi
mov    %rsp,%rdi
callq  3f <display_file+0x3f>
test   %rax,%rax
je     47 <display_file+0x47>
movb   $0x0,(%rax)
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %ebp,%edi
mov    $0x0,%eax
callq  5b <display_file+0x5b>
mov    %rbx,%rdx
mov    $0x800,%esi
mov    %rsp,%rdi
callq  6b <display_file+0x6b>
test   %rax,%rax
jne    32 <display_file+0x32>
mov    0x0(%rip),%rdi        # 77 <display_file+0x77>
callq  7c <display_file+0x7c>
mov    %rbx,%rdi
callq  84 <display_file+0x84>
mov    $0x0,%eax
jmp    92 <display_file+0x92>
callq  90 <display_file+0x90>
mov    (%rax),%eax
mov    0x808(%rsp),%rcx
xor    %fs:0x28,%rcx
je     aa <display_file+0xaa>
callq  aa <display_file+0xaa>
add    $0x818,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
display_file (const char *name, int code)
{
  char *cp, line[2048];
  FILE *fp = fopen (name, "r");
  if (fp != ((void *)0))
    {
      while (fgets (line, sizeof (line), fp) != ((void *)0))
 {
   cp = strchr (line, '\n');
   if (cp != ((void *)0))
     *cp = '\0';
   lreply (code, "%s", line);
 }
      fflush (stdout);
      fclose (fp);
      return 0;
    }
  return (*__errno_location ());
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 5
14 9
15 9
16 9
17 10
18 10
19 11
20 12
21 12
22 12
23 12
24 12
25 7
26 7
27 7
28 7
29 7
30 7
31 14
32 14
33 15
34 15
35 16
36 16
37 18
38 18
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_authorization_get_digest (osip_authorization_t * authorization)
{
  return authorization->digest;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  11ef <mod_free_db+0xe>
mov    0x18(%rbx),%rdi
callq  11f8 <mod_free_db+0x17>
mov    %rbx,%rdi
callq  1200 <mod_free_db+0x1f>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mod_free_db (dico_handle_t hp)
{
    struct _python_database *db = (struct _python_database *)hp;
    PyThreadState_Swap (((void *)0));
    PyThreadState_Delete (db->py_ths);
    free (db);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 8
10 8
11 8
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
<<<sep_in_sample>>>
rec_mset_elem_set_data (rec_mset_elem_t elem,
                        void *data)
{
  elem->data = data;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    0x50(%rdi),%rbp
mov    0x68(%rbp),%r8
test   %r8,%r8
jne    fa <amd_messages_recent+0x65>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x1,%esi
callq  *0x38(%rbp)
mov    %eax,%edx
test   %edx,%edx
jne    10a <amd_messages_recent+0x75>
mov    0x68(%rbp),%r8
mov    $0x0,%ecx
test   %r8,%r8
je     f0 <amd_messages_recent+0x5b>
jmp    fa <amd_messages_recent+0x65>
mov    (%rsi,%rax,8),%rdx
mov    0x1c(%rdx),%edx
test   %edx,%edx
je     e3 <amd_messages_recent+0x4e>
test   $0x10,%dl
jne    e7 <amd_messages_recent+0x52>
add    $0x1,%rcx
add    $0x1,%rax
cmp    %r8,%rax
jb     d3 <amd_messages_recent+0x3e>
mov    %rcx,(%rbx)
mov    $0x0,%eax
jmp    10a <amd_messages_recent+0x75>
mov    0x78(%rbp),%rsi
mov    $0x0,%eax
mov    $0x0,%ecx
jmp    d3 <amd_messages_recent+0x3e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
amd_messages_recent (mu_mailbox_t mailbox, size_t *pcount)
{
  struct _amd_data *amd = mailbox->data;
  size_t count, i;
  if (amd->msg_count == 0)
    {
      int status = amd->scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  count = 0;
  for (i = 0; i < amd->msg_count; i++)
    {
      if (((amd->msg_array[i]->attr_flags) == 0 || ! ((amd->msg_array[i]->attr_flags) & 0x10)))
 count++;
    }
  *pcount = count;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 12
17 11
18 12
19 12
20 12
21 14
22 14
23 14
24 14
25 14
26 14
27 15
28 12
29 12
30 12
31 17
32 18
33 18
34 14
35 14
36 14
37 14
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
retq   
<<<sep_in_sample>>>
window_lines(window)
    window_t *window;
{
    return window->lines;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2ac9 <rl_get_keymap_name_from_edit_mode+0x6>
cmp    $0x1,%eax
je     2adf <rl_get_keymap_name_from_edit_mode+0x1c>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_get_keymap_name_from_edit_mode ()
{
  if (rl_editing_mode == 1)
    return "emacs";
  else if (rl_editing_mode == 0)
    return "vi";
  else
    return "none";
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 6
6 6
7 6
8 6
9 4
10 9
<<<sep_out_sample>>>
movzwl 0xc(%rdi),%r8d
movzwl %r8w,%ecx
movzwl 0x8(%rdi),%eax
add    %rcx,%rax
lea    -0x1(%rax),%rdx
cmp    %rdx,%rcx
jg     3c <__rtstrip+0x3c>
mov    (%rdi),%rsi
sub    $0x2,%rax
cmpb   $0x20,0x18(%rsi,%rax,1)
je     37 <__rtstrip+0x37>
jmp    64 <__rtstrip+0x64>
lea    -0x1(%rax),%rdx
cmpb   $0x20,0x17(%rsi,%rax,1)
jne    67 <__rtstrip+0x67>
mov    %rdx,%rax
cmp    %rax,%rcx
jle    29 <__rtstrip+0x29>
movq   $0x0,0x0(%rip)        # 47 <__rtstrip+0x47>
movw   $0x0,0x0(%rip)        # 50 <__rtstrip+0x50>
movw   $0x0,0x0(%rip)        # 59 <__rtstrip+0x59>
movw   $0x0,0x0(%rip)        # 62 <__rtstrip+0x62>
jmp    8d <__rtstrip+0x8d>
mov    %rdx,%rax
mov    %rsi,0x0(%rip)        # 6e <__rtstrip+0x6e>
mov    %r8w,0x0(%rip)        # 76 <__rtstrip+0x76>
movw   $0x1,0x0(%rip)        # 7f <__rtstrip+0x7f>
sub    0xc(%rdi),%ax
add    $0x1,%eax
mov    %ax,0x0(%rip)        # 8d <__rtstrip+0x8d>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
__rtstrip (__txtvp t)
{
  long pos;
  for (pos = (long) t->start + (long) t->length - 1;
       (long) t->start <= pos && t->obj->string[pos - 1] == ' '; pos--);
  if (pos < (long) t->start)
    {
      __et.obj = 0L;
      __et.pos = __et.start = __et.length = 0;
    }
  else
    {
      __et.obj = t->obj;
      __et.start = t->start;
      __et.pos = 1;
      __et.length = pos - (long) t->start + 1;
    }
  return (&__et);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 4
18 4
19 8
20 9
21 9
22 9
23 9
24 4
25 13
26 14
27 15
28 16
29 16
30 16
31 19
32 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 12b <gsl_ieee_printf_float+0xe>
callq  130 <gsl_ieee_printf_float+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_ieee_printf_float (const float * x)
{
  gsl_ieee_fprintf_float (stdout,x);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
mov    (%rdi),%rdi
callq  9b2 <words_free+0x11>
mov    0x8(%rbx),%rdi
mov    $0x0,%esi
callq  9c0 <words_free+0x1f>
mov    %rbx,%rdi
callq  9c8 <words_free+0x27>
pop    %rbx
retq   
<<<sep_in_sample>>>
words_free (struct words * words)
{
  da_free (words->strings, (da_map_func_t) free_rule);
  da_free (words->regexps, (da_map_func_t) free_rule);
  free (words);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    %rdi,%r8
mov    %rsi,%rdx
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
cmp    %al,%cl
jne    122 <_get_arg_image+0x20>
mov    (%r8),%rax
retq   
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
cmp    %al,%cl
jne    143 <_get_arg_image+0x41>
mov    0x1608(%r8),%rax
retq   
mov    $0x0,%edi
mov    $0xc,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
mov    $0x0,%eax
cmp    %cl,%sil
je     18d <_get_arg_image+0x8b>
mov    $0x0,%edi
mov    $0xf,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmove  %rdx,%rax
repz retq 
<<<sep_in_sample>>>
_get_arg_image (void *user_data, const char key[])
{
  _img_private_t *p_env = user_data;
  if (!strcmp (key, "source")) {
    return p_env->gen.source_name;
  } else if (!strcmp (key, "cue")) {
    return p_env->psz_cue_name;
  } else if (!strcmp(key, "access-mode")) {
    return "image";
  } else if (!strcmp (key, "mmc-supported?")) {
    return "false";
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 8
30 8
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 11
42 11
43 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 398 <mc_maclist_is_wireless+0x7>
callq  0 <mc_maclist_get_cardname_from_list>
test   %rax,%rax
setne  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
mc_maclist_is_wireless (const mac_t *mac)
{
 return (mc_maclist_get_cardname_from_list (mac, list_wireless) != ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     71b <get_spec_varname+0x27>
mov    $0x0,%edx
jmp    70c <get_spec_varname+0x18>
cmp    %rdi,0x28(%rdx)
je     720 <get_spec_varname+0x2c>
cmp    %rdi,0x20(%rdx)
je     720 <get_spec_varname+0x2c>
add    $0x38,%rdx
mov    0x8(%rdx),%rax
test   %rax,%rax
jne    700 <get_spec_varname+0xc>
repz retq 
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
get_spec_varname(Func_ptr fptr)
{
 const struct varinit *vp;
 if (! fptr)
  return ((void *)0);
 for (vp = varinit; vp->name != ((void *)0); vp++) {
  if (vp->assign == fptr || vp->update == fptr)
   return vp->name;
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 7
8 7
9 6
10 6
11 6
12 6
13 6
14 5
15 11
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %edx,%eax
retq   
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdi        # cc <genline+0x8>
cmp    %rdi,0x0(%rip)        # d3 <genline+0xf>
je     105 <genline+0x41>
callq  da <genline+0x16>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # e4 <genline+0x20>
callq  e9 <genline+0x25>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # fb <genline+0x37>
mov    $0x0,%eax
callq  105 <genline+0x41>
cmpl   $0x0,0x0(%rip)        # 10c <genline+0x48>
jne    134 <genline+0x70>
mov    0x0(%rip),%rdx        # 115 <genline+0x51>
cmp    %rdx,0x0(%rip)        # 11c <genline+0x58>
je     134 <genline+0x70>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 12a <genline+0x66>
mov    $0x0,%eax
callq  134 <genline+0x70>
mov    0x0(%rip),%rax        # 13b <genline+0x77>
mov    %rax,0x0(%rip)        # 142 <genline+0x7e>
mov    %rax,0x0(%rip)        # 149 <genline+0x85>
pop    %rbx
retq   
<<<sep_in_sample>>>
genline (void)
{
  if (true_last_line != lineno)
    {
      fprintf (ccode, "\n# %ld \"%s\"\n",getmapline(lineno), getmapfile(lineno));
    }
  if (!option_line && last_line != lineno)
    fprintf (ccode, "__cline=%ld;", lineno);
  true_last_line= last_line= lineno;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 10
28 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 17f <proclist_count+0xb>
callq  184 <proclist_count+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
proclist_count ()
{
  return list_count (process_list);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  4d <nettle_gcm_aes256_set_iv+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes256_set_iv (struct gcm_aes256_ctx *ctx,
     size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
cmp    $0x40,%rsi
jbe    409 <nettle_sha512_digest+0x26>
lea    0x0(%rip),%rcx        # 3f1 <nettle_sha512_digest+0xe>
mov    $0xca,%edx
lea    0x0(%rip),%rsi        # 3fd <nettle_sha512_digest+0x1a>
lea    0x0(%rip),%rdi        # 404 <nettle_sha512_digest+0x21>
callq  409 <nettle_sha512_digest+0x26>
mov    %rdi,%rbx
callq  0 <sha512_write_digest>
mov    %rbx,%rdi
callq  419 <nettle_sha512_digest+0x36>
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_sha512_digest(struct sha512_ctx *ctx,
       size_t length,
       uint8_t *digest)
{
  ((length <= 64) ? (void) (0) : __assert_fail ("length <= 64", "sha512.c", 202, __PRETTY_FUNCTION__));
  sha512_write_digest(ctx, length, digest);
  nettle_sha512_init(ctx);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x48,%rsp
movapd %xmm0,%xmm6
movsd  %xmm0,0x8(%rsp)
movsd  %xmm1,0x18(%rsp)
movsd  %xmm2,0x30(%rsp)
movsd  %xmm3,0x38(%rsp)
ucomisd %xmm3,%xmm2
jae    645 <BetaRandom+0x38>
xorpd  %xmm0,%xmm0
ucomisd %xmm6,%xmm0
jae    645 <BetaRandom+0x38>
ucomisd %xmm1,%xmm0
jb     659 <BetaRandom+0x4c>
mov    $0x0,%edi
callq  64f <BetaRandom+0x42>
mov    $0x0,%edi
callq  659 <BetaRandom+0x4c>
movsd  0x0(%rip),%xmm0        # 661 <BetaRandom+0x54>
ucomisd 0x8(%rsp),%xmm0
jbe    6ef <BetaRandom+0xe2>
ucomisd 0x18(%rsp),%xmm0
jbe    6ef <BetaRandom+0xe2>
callq  67a <BetaRandom+0x6d>
movsd  %xmm0,0x10(%rsp)
mov    0x10(%rsp),%rbp
callq  68a <BetaRandom+0x7d>
movsd  %xmm0,0x10(%rsp)
mov    0x10(%rsp),%rbx
movsd  0x0(%rip),%xmm1        # 69d <BetaRandom+0x90>
divsd  0x8(%rsp),%xmm1
mov    %rbp,0x10(%rsp)
movsd  0x10(%rsp),%xmm0
callq  6b3 <BetaRandom+0xa6>
movsd  %xmm0,0x20(%rsp)
movsd  %xmm0,0x10(%rsp)
movsd  0x0(%rip),%xmm1        # 6c7 <BetaRandom+0xba>
divsd  0x18(%rsp),%xmm1
mov    %rbx,0x28(%rsp)
movsd  0x28(%rsp),%xmm0
callq  6dd <BetaRandom+0xd0>
addsd  0x20(%rsp),%xmm0
ucomisd 0x0(%rip),%xmm0        # 6eb <BetaRandom+0xde>
ja     675 <BetaRandom+0x68>
jmp    711 <BetaRandom+0x104>
movsd  0x8(%rsp),%xmm0
callq  6fa <BetaRandom+0xed>
movsd  %xmm0,0x10(%rsp)
movsd  0x18(%rsp),%xmm0
callq  70b <BetaRandom+0xfe>
addsd  0x10(%rsp),%xmm0
movsd  0x10(%rsp),%xmm1
divsd  %xmm0,%xmm1
movsd  0x38(%rsp),%xmm0
movsd  0x30(%rsp),%xmm7
subsd  %xmm7,%xmm0
mulsd  %xmm1,%xmm0
addsd  %xmm7,%xmm0
add    $0x48,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
BetaRandom (double alpha, double beta, double a, double b)
{
  double u1, u2, w;
  if (b <= a || alpha <= 0 || beta <= 0) {
    printf ("Error: bad shape or range for a beta variate - Exiting\n\n");
    exit (0);
  }
  if ((alpha < 1) && (beta < 1))
    do {
      u1 = Randoms();
      u2 = Randoms();
      u1 = pow(u1, 1/alpha);
      u2 = pow(u2, 1/beta);
      w = u1 + u2;
    } while (w > 1.0);
  else {
    u1 = GammaRandom(alpha);
    u2 = GammaRandom(beta);
    w = u1 + u2;
  }
  return (a + (u1/w) * (b - a));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 6
19 6
20 8
21 8
22 8
23 8
24 8
25 10
26 10
27 10
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 13
39 13
40 13
41 13
42 13
43 14
44 15
45 15
46 15
47 17
48 17
49 17
50 18
51 18
52 19
53 21
54 21
55 21
56 21
57 21
58 21
59 21
60 22
61 22
62 22
63 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%r9
mov    0x50(%rdi),%rcx
mov    0x48(%rdi),%rdx
mov    0x40(%rdi),%rsi
callq  2dc <gsl_spline2d_eval_deriv_xx+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline2d_eval_deriv_xx(const gsl_spline2d * interp, const double x,
                           const double y, gsl_interp_accel * xa, gsl_interp_accel * ya)
{
  return gsl_interp2d_eval_deriv_xx(&(interp->interp_object), interp->xarr, interp->yarr,
                                    interp->zarr, x, y, xa, ya);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rcx,%rbx
testb  $0x80,0x0(%rip)        # 94b <trace_post+0xe>
je     97e <trace_post+0x41>
mov    %rdi,%rbp
mov    %edx,%r12d
mov    %esi,%edi
callq  48d <trace_header>
cmp    $0x2,%r12d
mov    $0x0,%eax
mov    $0x0,%edx
cmovge %rax,%rdx
mov    %rbp,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
test   %rbx,%rbx
je     99e <trace_post+0x61>
testb  $0x2,0x0(%rip)        # 98a <trace_post+0x4d>
je     99e <trace_post+0x61>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
callq  121 <trace_flush>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
trace_post (const char *name, int id, int argc, const char *expanded)
{
  if (debug_level & 128)
    {
      trace_header (id);
      trace_format ("%s%s", name, (argc > 1) ? "(...)" : "");
    }
  if (expanded && (debug_level & 2))
    trace_format (" -> %l%S%r", expanded);
  trace_flush ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 10
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    $0x0,%ebp
jmp    82c <get_totsize+0x28>
mov    (%rbx),%rdi
callq  81d <get_totsize+0x19>
add    %rax,%rbp
mov    0x10(%rbx),%rbx
cmp    $0x1,%rbx
sbb    $0xffffffffffffffff,%rbp
test   %rbx,%rbx
setne  %al
je     839 <get_totsize+0x35>
cmp    %r12,%rbx
jne    815 <get_totsize+0x11>
test   %al,%al
je     851 <get_totsize+0x4d>
mov    (%rbx),%rdi
callq  845 <get_totsize+0x41>
add    %rax,%rbp
cmpq   $0x1,0x10(%rbx)
sbb    $0xffffffffffffffff,%rbp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
get_totsize(const filestruct *begin, const filestruct *end)
{
    size_t totsize = 0;
    const filestruct *f;
    for (f = begin; f != end && f != ((void *)0); f = f->next) {
 totsize += mbstrlen(f->data);
 if (f->next != ((void *)0))
     totsize++;
    }
    if (f != ((void *)0)) {
 totsize += mbstrlen(f->data);
 if (f->next != ((void *)0))
     totsize++;
    }
    return totsize;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 5
8 6
9 6
10 6
11 7
12 8
13 8
14 5
15 5
16 5
17 5
18 5
19 10
20 10
21 11
22 11
23 11
24 13
25 13
26 16
27 16
28 16
29 16
30 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
mov    $0x0,%edx
cmovne %rsi,%rdx
test   %rdi,%rdi
mov    $0x0,%esi
cmovne %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%al
callq  7d2 <gstrbotch+0x28>
mov    $0x46,%edi
callq  7dc <gstrcpy>
<<<sep_in_sample>>>
gstrbotch (const char *str1, const char *str2)
{
  usrerr ("Filename(s) too long: %s %s",
          (str1 ? str1 : ""),
          (str2 ? str2 : ""));
  exit(70);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 6
12 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
callq  a5b <grecs_print_value+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_value(struct grecs_value *val, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_value(val, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 29c <swlib_set_pax_header_pid+0x6>
retq   
<<<sep_in_sample>>>
swlib_set_pax_header_pid(pid_t n)
{
 g_pax_header_pidG = n;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 124 <gsl_matrix_complex_long_double_ptr+0xb>
je     171 <gsl_matrix_complex_long_double_ptr+0x58>
cmp    %rsi,(%rdi)
ja     14b <gsl_matrix_complex_long_double_ptr+0x32>
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  144 <gsl_matrix_complex_long_double_ptr+0x2b>
mov    $0x0,%eax
jmp    184 <gsl_matrix_complex_long_double_ptr+0x6b>
cmp    %rdx,0x8(%rdi)
ja     171 <gsl_matrix_complex_long_double_ptr+0x58>
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16a <gsl_matrix_complex_long_double_ptr+0x51>
mov    $0x0,%eax
jmp    184 <gsl_matrix_complex_long_double_ptr+0x6b>
mov    %rsi,%rax
imul   0x10(%rdi),%rax
add    %rdx,%rax
shl    $0x5,%rax
add    0x18(%rdi),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_ptr(gsl_matrix_complex_long_double * m,
                             const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_long_double.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_long_double.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 15
23 15
24 15
25 15
26 15
27 16
28 16
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rdx,%r9
mov    %edi,%edi
mov    %r8d,0x10(%rsp)
mov    %ecx,0x8(%rsp)
movq   $0x0,(%rsp)
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x4,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  cc <to_chars>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gid_to_chars (gid_t v, char *p, size_t s, int archive_format, int termch)
{
  to_chars (v < 0, (uintmax_t) v, sizeof v, gid_substitute, p, s, "gid_t", archive_format, termch);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
callq  1669 <sv_funcnest+0x9>
test   %rax,%rax
jne    167a <sv_funcnest+0x1a>
movl   $0x0,0x0(%rip)        # 1678 <sv_funcnest+0x18>
jmp    16a3 <sv_funcnest+0x43>
mov    0x8(%rax),%rdi
lea    0x8(%rsp),%rsi
callq  1688 <sv_funcnest+0x28>
test   %eax,%eax
jne    1698 <sv_funcnest+0x38>
movl   $0x0,0x0(%rip)        # 1696 <sv_funcnest+0x36>
jmp    16a3 <sv_funcnest+0x43>
mov    0x8(%rsp),%rax
mov    %eax,0x0(%rip)        # 16a3 <sv_funcnest+0x43>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
sv_funcnest (name)
     char *name;
{
  SHELL_VAR *v;
  intmax_t num;
  v = find_variable (name);
  if (v == 0)
    funcnest_max = 0;
  else if (legal_number (((v)->value), &num) == 0)
    funcnest_max = 0;
  else
    funcnest_max = num;
}
<<<sep_in_sample>>>
1 3
2 6
3 7
4 7
5 8
6 8
7 9
8 9
9 9
10 9
11 9
12 10
13 10
14 12
15 12
16 13
17 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rbx
test   %rbx,%rbx
je     2820 <info_namelist_add+0x2a>
lea    0x8(%rbx),%rdi
mov    %rbp,%rsi
callq  2814 <info_namelist_add+0x1e>
test   %eax,%eax
je     285e <info_namelist_add+0x68>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    2808 <info_namelist_add+0x12>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0xf(%rcx),%rdi
callq  283d <info_namelist_add+0x47>
mov    %rax,%rbx
lea    0x8(%rax),%rdi
mov    %rbp,%rsi
callq  284c <info_namelist_add+0x56>
mov    (%r12),%rax
mov    %rax,(%rbx)
mov    %rbx,(%r12)
mov    $0x0,%eax
jmp    2863 <info_namelist_add+0x6d>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
info_namelist_add (struct info_namelist_entry **ptop, const char *name)
{
  struct info_namelist_entry *p;
  for (p = *ptop; p; p = p->next)
    if (strcmp(p->name,name) == 0)
      return 1;
  p = xmalloc (sizeof (*p) + strlen (name));
  strcpy (p->name, name);
  p->next = *ptop;
  *ptop = p;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 4
15 4
16 4
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
28 9
29 9
30 10
31 11
32 11
33 6
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
test   %rsi,%rsi
je     142 <_gsasl_saml20_client_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  13e <_gsasl_saml20_client_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_client_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_client_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%esi
mov    $0x0,%ebp
mov    %r12,%rdi
callq  2a3 <find_string_var+0x1e>
test   %eax,%eax
je     2b9 <find_string_var+0x34>
add    $0x1,%ebp
add    $0x18,%rbx
mov    -0x18(%rbx),%rsi
test   %rsi,%rsi
jne    29b <find_string_var+0x16>
jmp    2bd <find_string_var+0x38>
mov    %ebp,%eax
jmp    2c2 <find_string_var+0x3d>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
find_string_var (name)
     const char *name;
{
  register int i;
  for (i = 0; string_varlist[i].name; i++)
    if (strcasecmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
11 6
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 8
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
cmpl   $0x0,0x68(%rdi)
jle    271a <panel_select_all+0x36>
mov    $0x0,%eax
movslq %eax,%rdx
lea    (%rdx,%rdx,4),%rdx
shl    $0x4,%rdx
add    0x38(%rdi),%rdx
cmpb   $0x0,0x49(%rdx)
jne    2712 <panel_select_all+0x2e>
cmpb   $0x0,0x48(%rdx)
je     2712 <panel_select_all+0x2e>
movb   $0x1,0x49(%rdx)
addl   $0x1,0x70(%rdi)
add    $0x1,%eax
cmp    %eax,0x68(%rdi)
jg     26ef <panel_select_all+0xb>
repz retq 
<<<sep_in_sample>>>
panel_select_all(this)
    panel_t *this;
{
    int entry;
    for (entry = 0; entry < this->entries; entry++)
 if (this->dir_entry[entry].selected == 0 &&
     this->dir_entry[entry].type != 0)
 {
     this->dir_entry[entry].selected = 1;
     this->selected_entries++;
 }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 9
13 10
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
callq  48b <gsl_sort_vector+0x13>
repz retq 
<<<sep_in_sample>>>
gsl_sort_vector (gsl_vector * v)
{
  gsl_sort (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%r12d
callq  38e8 <panel_mkdirs+0xc>
mov    %rax,%rbp
movzbl (%rax),%edx
test   %dl,%dl
je     393f <panel_mkdirs+0x63>
mov    %rax,%rbx
cmp    $0x2f,%dl
jne    3934 <panel_mkdirs+0x58>
cmp    %rbp,%rbx
je     3934 <panel_mkdirs+0x58>
movb   $0x0,(%rbx)
mov    %rbp,%rdi
mov    $0x0,%eax
callq  390f <panel_mkdirs+0x33>
test   %eax,%eax
jne    3931 <panel_mkdirs+0x55>
mov    %r12d,%esi
mov    %rbp,%rdi
callq  391e <panel_mkdirs+0x42>
test   %eax,%eax
je     3931 <panel_mkdirs+0x55>
mov    %rbp,%rdi
callq  392a <panel_mkdirs+0x4e>
mov    $0xffffffff,%eax
jmp    394c <panel_mkdirs+0x70>
movb   $0x2f,(%rbx)
add    $0x1,%rbx
movzbl (%rbx),%edx
test   %dl,%dl
jne    38f5 <panel_mkdirs+0x19>
mov    %rbp,%rdi
callq  3947 <panel_mkdirs+0x6b>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
panel_mkdirs(path, mode)
    const char *path;
    int mode;
{
    char *copy = xstrdup(path);
    char *z = copy;
    for (; *z != '\0'; z++)
 if (*z == '/' && z != copy)
 {
     *z = '\0';
     if (!panel_isdir(copy))
  if (mkdir(copy, mode) != 0)
  {
      xfree(copy);
      return -1;
  }
     *z = '/';
 }
    xfree(copy);
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 7
8 7
9 7
10 6
11 8
12 8
13 8
14 8
15 10
16 11
17 11
18 11
19 11
20 11
21 12
22 12
23 12
24 12
25 12
26 14
27 14
28 15
29 15
30 17
31 7
32 7
33 7
34 7
35 19
36 19
37 20
38 21
39 21
40 21
41 21
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x20,%edi
callq  118 <gsl_qrng_clone+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    140 <gsl_qrng_clone+0x3b>
mov    $0x8,%ecx
mov    $0x46,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  139 <gsl_qrng_clone+0x34>
mov    $0x0,%eax
jmp    19e <gsl_qrng_clone+0x99>
mov    0x8(%rbp),%eax
mov    %eax,0x8(%rbx)
mov    0x10(%rbp),%rdi
mov    %rdi,0x10(%rbx)
callq  153 <gsl_qrng_clone+0x4e>
mov    %rax,0x18(%rbx)
test   %rax,%rax
jne    184 <gsl_qrng_clone+0x7f>
mov    %rbx,%rdi
callq  164 <gsl_qrng_clone+0x5f>
mov    $0x8,%ecx
mov    $0x51,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  17d <gsl_qrng_clone+0x78>
mov    $0x0,%eax
jmp    19e <gsl_qrng_clone+0x99>
mov    0x0(%rbp),%rdx
mov    %rdx,(%rbx)
mov    0x18(%rbp),%rsi
mov    0x10(%rbp),%rdx
mov    %rax,%rdi
callq  19b <gsl_qrng_clone+0x96>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_qrng_clone (const gsl_qrng * q)
{
  gsl_qrng * r = (gsl_qrng *) malloc (sizeof (gsl_qrng));
  if (r == 0)
    {
      do { gsl_error ("failed to allocate space for rng struct",
 "qrng.c"
      ,
 70
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    };
  r->dimension = q->dimension;
  r->state_size = q->state_size;
  r->state = malloc (r->state_size);
  if (r->state == 0)
    {
      free (r);
      do { gsl_error ("failed to allocate space for rng state",
 "qrng.c"
      ,
 81
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    };
  r->type = q->type;
  memcpy (r->state, q->state, q->state_size);
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 10
16 10
17 13
18 13
19 14
20 14
21 15
22 15
23 16
24 16
25 18
26 18
27 19
28 19
29 19
30 19
31 19
32 23
33 23
34 26
35 26
36 27
37 27
38 27
39 27
40 28
41 29
42 29
43 29
44 29
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x50(%r8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, start_index, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsi,%rcx
mov    %rdx,%rsi
mov    $0xffffffff,%edx
lea    0x8(%rsp),%rdi
callq  bbb <decode_num>
test   %al,%al
je     e2a <sparse_major_decoder+0x2c>
mov    0x8(%rsp),%rax
mov    %eax,0x124(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
sparse_major_decoder (struct tar_stat_info *st,
        char const *keyword,
        char const *arg,
        size_t size)
{
  uintmax_t u;
  if (decode_num (&u, arg, ((unsigned) (! (! ((unsigned) 0 < (unsigned) -1)) ? (unsigned) -1 : ((((unsigned) 1 << (sizeof (unsigned) * 8 - 2)) - 1) * 2 + 1))), keyword))
    st->sparse_major = u;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 8
12 8
13 9
14 9
15 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     291 <metaph_code_free+0x32>
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     289 <metaph_code_free+0x2a>
mov    0x10(%rdi),%rbx
callq  27f <metaph_code_free+0x20>
test   %rbx,%rbx
je     289 <metaph_code_free+0x2a>
mov    %rbx,%rdi
jmp    276 <metaph_code_free+0x17>
mov    %rbp,%rdi
callq  291 <metaph_code_free+0x32>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
metaph_code_free(struct metaph_code *code)
{
    if (code) {
 struct metaph_segment *s = code->segm_head;
 while (s) {
     struct metaph_segment *next = s->next;
     free(s);
     s = next;
 }
 free(code);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 5
9 5
10 6
11 7
12 5
13 5
14 8
15 8
16 10
17 10
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %esi,%esi
callq  7a5 <yyrealloc+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    $0x7e,%edi
ja     40 <cdtext_lang2str+0x14>
mov    %edi,%edi
mov    0x0(,%rdi,8),%rax
repz retq 
<<<sep_in_sample>>>
cdtext_lang2str(cdtext_lang_t i)
{
  if (i >= 127)
    return "INVALID";
  else
    return cdtext_language[i];
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 6
6 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    11e <argp_fmtstream_set_lmargin+0x1f>
callq  11e <argp_fmtstream_set_lmargin+0x1f>
mov    0x8(%rbx),%rax
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->lmargin;
  __fs->lmargin = __lmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rbp
mov    (%rdi),%rax
mov    0x18(%rax),%rax
test   %rax,%rax
je     1e5 <gsl_rng_print_state+0x37>
mov    %rbp,%rbx
add    %rax,%rbp
movzbl (%rbx),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1dc <gsl_rng_print_state+0x2e>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    1ca <gsl_rng_print_state+0x1c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_rng_print_state (const gsl_rng * r)
{
  size_t i;
  unsigned char *p = (unsigned char *) (r->state);
  const size_t n = r->type->size;
  for (i = 0; i < n; i++)
    {
      printf ("%.2x", *(p + i));
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 10
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzbl 0x50(%rdi),%eax
test   %al,%al
je     85 <__roclose+0x85>
cmpb   $0x1,0x55(%rdi)
jne    39 <__roclose+0x39>
mov    0x48(%rdi),%rdi
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2a <__roclose+0x2a>
cmp    $0xffffffff,%eax
jne    39 <__roclose+0x39>
mov    $0x0,%edi
callq  39 <__roclose+0x39>
cmpw   $0x1,0x62(%rbx)
jbe    48 <__roclose+0x48>
mov    %rbx,%rdi
callq  48 <__roclose+0x48>
mov    0x48(%rbx),%rdi
mov    $0x0,%eax
callq  56 <__roclose+0x56>
cmp    $0xffffffff,%eax
je     80 <__roclose+0x80>
movq   $0x0,0x58(%rbx)
movw   $0x0,0x60(%rbx)
movw   $0x0,0x62(%rbx)
movw   $0x0,0x64(%rbx)
movb   $0x0,0x50(%rbx)
mov    $0x1,%eax
jmp    85 <__roclose+0x85>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
__roclose (__bs1FILE *p)
{
  if (p->open)
    {
      if (((__bs1FILE *) p)->re_wind == 1
   && fseek (((__bs1FILE *) p)->file, 0L, 0) == (-1))
 __rerror ("Close: Not possible to rewind");
      if (((__bs2FILE *) p)->IMAGE.pos > 1)
 __rooutimage ((__bs2FILE *) p);
      if (fclose (((__bs1FILE *) p)->file) == (-1))
 return (0);
      ((__bs2FILE *) p)->IMAGE.obj = 0L;
      ((__bs2FILE *) p)->IMAGE.length = 0;
      ((__bs2FILE *) p)->IMAGE.pos = 0;
      ((__bs2FILE *) p)->IMAGE.start = 0;
      p->open = 0;
      return (1);
    }
  else
    return (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 12
27 13
28 14
29 15
30 16
31 17
32 17
33 11
34 21
35 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     23 <xfree+0x10>
callq  21 <xfree+0xe>
jmp    2d <xfree+0x1a>
mov    $0x0,%edi
callq  2d <xfree+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xfree(pointer)
    void *pointer;
{
    if (pointer)
 free(pointer);
    else
 fatal("xfree: trying to free NULL");
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 7
7 7
8 8
9 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     952 <mu_assoc_count+0x71>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
mov    $0x16,%eax
test   %rsi,%rsi
je     94b <mu_assoc_count+0x6a>
lea    0x8(%rsp),%rsi
callq  903 <mu_assoc_count+0x22>
mov    %eax,%edx
test   %edx,%edx
jne    94b <mu_assoc_count+0x6a>
mov    0x8(%rsp),%rdi
callq  913 <mu_assoc_count+0x32>
mov    $0x0,%ebx
jmp    928 <mu_assoc_count+0x47>
add    $0x1,%rbx
mov    0x8(%rsp),%rdi
callq  928 <mu_assoc_count+0x47>
mov    0x8(%rsp),%rdi
callq  932 <mu_assoc_count+0x51>
test   %eax,%eax
je     91a <mu_assoc_count+0x39>
lea    0x8(%rsp),%rdi
callq  940 <mu_assoc_count+0x5f>
mov    %rbx,0x0(%rbp)
mov    $0x0,%eax
jmp    94b <mu_assoc_count+0x6a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x16,%eax
retq   
<<<sep_in_sample>>>
mu_assoc_count (mu_assoc_t assoc, size_t *pcount)
{
  mu_iterator_t itr;
  int rc;
  size_t count = 0;
  if (!assoc || !pcount)
    return 22;
  rc = mu_assoc_get_iterator (assoc, &itr);
  if (rc)
    return rc;
  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);
       mu_iterator_next (itr))
    count++;
  mu_iterator_destroy (&itr);
  *pcount = count;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 2
4 2
5 2
6 2
7 7
8 6
9 6
10 8
11 8
12 8
13 9
14 9
15 11
16 11
17 5
18 11
19 13
20 12
21 12
22 11
23 11
24 11
25 11
26 14
27 14
28 15
29 16
30 16
31 17
32 17
33 17
34 17
35 7
36 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x58(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
term_ostream_get_weight (term_ostream_t first_arg)
{
  const struct term_ostream_implementation *vtable =
    ((struct term_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  return vtable->get_weight (first_arg);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
lea    (%rdi,%rsi,1),%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     4c2 <skipws+0x33>
callq  4a6 <skipws+0x17>
mov    (%rax),%rax
jmp    4b7 <skipws+0x28>
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     4c2 <skipws+0x33>
movsbq %bpl,%rbp
testb  $0x20,0x1(%rax,%rbp,2)
jne    4ab <skipws+0x1c>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
test   %ecx,%ecx
jle    4ee <skipws+0x5f>
movslq %ecx,%rcx
lea    -0x1(%rbx,%rcx,1),%rax
cmpb   $0xa,(%rax)
jne    4ee <skipws+0x5f>
movb   $0x0,(%rax)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
skipws (char *p, size_t off)
{
  int len;
  for (p += off; *p && ((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISspace); p++)
    ;
  len = strlen (p);
  if (len > 0 && p[len-1] == '\n')
    p[len-1] = 0;
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 7
30 8
31 10
32 10
33 10
34 10
35 10
<<<sep_out_sample>>>
movswl (%rdi),%r8d
movswl (%rsi),%eax
imul   %eax,%r8d
movswl 0x2(%rdi),%ecx
movswl 0x2(%rsi),%eax
imul   %ecx,%eax
movswl 0x4(%rdi),%r9d
movswl 0x4(%rsi),%ecx
imul   %r9d,%ecx
lea    (%r8,%rax,1),%eax
lea    (%rax,%rcx,1),%eax
lea    0xfff(%rax),%ecx
test   %eax,%eax
cmovs  %ecx,%eax
sar    $0xc,%eax
add    0x6(%rsi),%ax
mov    %ax,(%rdx)
movswl (%rdi),%r8d
movswl 0x8(%rsi),%eax
imul   %eax,%r8d
movswl 0x2(%rdi),%ecx
movswl 0xa(%rsi),%eax
imul   %ecx,%eax
movswl 0x4(%rdi),%r9d
movswl 0xc(%rsi),%ecx
imul   %r9d,%ecx
lea    (%r8,%rax,1),%eax
lea    (%rax,%rcx,1),%eax
lea    0xfff(%rax),%ecx
test   %eax,%eax
cmovs  %ecx,%eax
sar    $0xc,%eax
add    0xe(%rsi),%ax
mov    %ax,0x2(%rdx)
movswl (%rdi),%r8d
movswl 0x10(%rsi),%eax
imul   %eax,%r8d
movswl 0x2(%rdi),%ecx
movswl 0x12(%rsi),%eax
imul   %ecx,%eax
movswl 0x4(%rdi),%edi
movswl 0x14(%rsi),%ecx
imul   %edi,%ecx
lea    (%r8,%rax,1),%eax
lea    (%rax,%rcx,1),%eax
lea    0xfff(%rax),%ecx
test   %eax,%eax
cmovs  %ecx,%eax
sar    $0xc,%eax
add    0x16(%rsi),%ax
mov    %ax,0x4(%rdx)
retq   
<<<sep_in_sample>>>
ShortTransform(short_point_t * a, short_matrix_t * m, short_point_t * b)
{
 b->x = (a->x * m->m[0][0] + a->y * m->m[0][1] +
   a->z * m->m[0][2]) / (1 << 12) + m->m[0][3];
 b->y = (a->x * m->m[1][0] + a->y * m->m[1][1] +
   a->z * m->m[1][2]) / (1 << 12) + m->m[1][3];
 b->z = (a->x * m->m[2][0] + a->y * m->m[2][1] +
   a->z * m->m[2][2]) / (1 << 12) + m->m[2][3];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 4
12 4
13 4
14 4
15 4
16 3
17 3
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 5
28 6
29 6
30 6
31 6
32 6
33 5
34 5
35 7
36 7
37 7
38 7
39 7
40 7
41 8
42 8
43 8
44 7
45 8
46 8
47 8
48 8
49 8
50 7
51 7
52 7
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x2(%rdx,%rcx,1),%rax
cmpb   $0x2f,(%rax)
jne    722 <stripTrailingSlashes+0x34>
cmp    %rax,%rdx
ja     722 <stripTrailingSlashes+0x34>
movb   $0x0,(%rax)
sub    $0x1,%rax
cmpb   $0x2f,(%rax)
jne    722 <stripTrailingSlashes+0x34>
cmp    %rax,%rdx
jbe    711 <stripTrailingSlashes+0x23>
repz retq 
<<<sep_in_sample>>>
stripTrailingSlashes(char * str)
{
    char * chptr;
    chptr = str + strlen(str) - 1;
    while (*chptr == '/' && chptr >= str) {
 *chptr = '\0';
 chptr--;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 7
13 5
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  102e <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 167 <pe_space+0xb>
mov    $0x1,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  17b <pe_space+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pe_space (struct prompt_exp *p)
{
  fwrite (" ", 1, 1, stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
mac_format_void(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%esi
callq  40a <mu_attribute_unset_seen+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_attribute_unset_seen (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x10);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 8ef <yyget_debug+0x6>
retq   
<<<sep_in_sample>>>
yyget_debug (void)
{
        return yy_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x1,0x0(%rip)        # fe <postmsg+0xb>
je     109 <postmsg+0x16>
cmpl   $0x0,0x0(%rip)        # 107 <postmsg+0x14>
jne    11f <postmsg+0x2c>
mov    %rbx,%rdi
callq  111 <postmsg+0x1e>
mov    0x0(%rip),%rdi        # 118 <postmsg+0x25>
callq  11d <postmsg+0x2a>
jmp    144 <postmsg+0x51>
callq  124 <postmsg+0x31>
mov    $0xffffffff,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 133 <postmsg+0x40>
callq  138 <postmsg+0x45>
mov    0x0(%rip),%rdi        # 13f <postmsg+0x4c>
callq  144 <postmsg+0x51>
mov    $0x14a,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  156 <postmsg+0x63>
pop    %rbx
retq   
<<<sep_in_sample>>>
postmsg(char *msg)
{
 if (linemode == YES || incurses == NO) {
  (void) printf("%s\n", msg);
  fflush(stdout);
 }
 else {
  clearmsg();
  waddnstr(stdscr,(msg),-1);
  wrefresh(stdscr);
 }
 (void) strncpy(lastmsg, msg, sizeof(lastmsg) - 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 8
13 9
14 9
15 9
16 9
17 10
18 10
19 12
20 12
21 12
22 12
23 13
24 13
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
movss  %xmm0,0xc(%rsp)
mov    0xc(%rsp),%r12d
mov    %rsi,%rbp
mov    0x10(%rsi),%rax
cmp    $0x5,%rax
ja     8162 <_jit_putargi_f+0x3b>
mov    $0x1f,%edx
sub    %rax,%rdx
mov    $0xdd,%esi
callq  8160 <_jit_putargi_f+0x39>
jmp    81b1 <_jit_putargi_f+0x8a>
mov    $0x20000000,%esi
callq  816c <_jit_putargi_f+0x45>
mov    %eax,%r13d
movslq %eax,%r14
mov    %r12d,0xc(%rsp)
movss  0xc(%rsp),%xmm0
mov    %r14,%rdx
mov    $0xdd,%esi
mov    %rbx,%rdi
callq  818d <_jit_putargi_f+0x66>
mov    0x10(%rbp),%rdx
mov    %r14,%r8
mov    $0xf,%ecx
mov    $0xe5,%esi
mov    %rbx,%rdi
callq  81a6 <_jit_putargi_f+0x7f>
mov    %r13d,%esi
mov    %rbx,%rdi
callq  81b1 <_jit_putargi_f+0x8a>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
_jit_putargi_f(jit_state_t *_jit, jit_float32_t u, jit_node_t *v)
{
    jit_int32_t regno;
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_wf(_jit,jit_code_movi_f,_XMM0 - v->u.w,u);
    else
    {
 regno = _jit_get_reg(_jit,0x20000000);
 _jit_new_node_wf(_jit,jit_code_movi_f,regno,u);
 _jit_new_node_www(_jit,jit_code_stxi_f,v->u.w,_RBP,regno);
 _jit_unget_reg(_jit,regno);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 11
35 12
36 12
37 12
38 14
39 14
40 14
41 14
42 14
43 14
44 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %rdx,%r12
mov    %rcx,%rbp
mov    $0x0,%esi
callq  5a6 <gsasl_md5pwd_get_password+0x20>
mov    $0x5,%r8d
test   %rax,%rax
je     620 <gsasl_md5pwd_get_password+0x9a>
mov    %rax,%rdi
callq  5b9 <gsasl_md5pwd_get_password+0x33>
lea    0x8(%rsp),%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  5c9 <gsasl_md5pwd_get_password+0x43>
mov    %eax,%r8d
test   %eax,%eax
jne    620 <gsasl_md5pwd_get_password+0x9a>
mov    0x8(%rsp),%rbx
mov    %rbx,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
cmp    %rcx,0x0(%rbp)
jae    5fe <gsasl_md5pwd_get_password+0x78>
mov    %rbx,%rdi
callq  5f6 <gsasl_md5pwd_get_password+0x70>
mov    $0x4,%r8d
jmp    620 <gsasl_md5pwd_get_password+0x9a>
mov    %rdx,0x0(%rbp)
test   %r12,%r12
je     612 <gsasl_md5pwd_get_password+0x8c>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  612 <gsasl_md5pwd_get_password+0x8c>
mov    %rbx,%rdi
callq  61a <gsasl_md5pwd_get_password+0x94>
mov    $0x0,%r8d
mov    %r8d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsasl_md5pwd_get_password (const char *filename,
      const char *username, char *key, size_t * keylen)
{
  char *tmp;
  size_t tmplen;
  int res;
  FILE *fh;
  fh = fopen (filename, "r");
  if (fh == ((void *)0))
    return GSASL_FOPEN_ERROR;
  fclose (fh);
  res = gsasl_simple_getpass (filename, username, &tmp);
  if (res != GSASL_OK)
    return res;
  tmplen = strlen (tmp);
  if (*keylen < tmplen + 1)
    {
      free (tmp);
      return GSASL_TOO_SMALL_BUFFER;
    }
  *keylen = tmplen;
  if (key)
    memcpy (key, tmp, tmplen);
  free (tmp);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 8
11 8
12 10
13 9
14 9
15 11
16 11
17 12
18 12
19 12
20 12
21 14
22 13
23 13
24 15
25 15
26 15
27 15
28 15
29 15
30 16
31 16
32 18
33 18
34 19
35 19
36 21
37 22
38 22
39 23
40 23
41 23
42 24
43 24
44 25
45 26
46 26
47 26
48 26
49 26
50 26
51 26
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
js     244 <gsl_stats_ulong_lag1_autocorrelation_m+0xf>
cvtsi2sd %rax,%xmm1
jmp    259 <gsl_stats_ulong_lag1_autocorrelation_m+0x24>
mov    %rax,%rcx
shr    %rcx
and    $0x1,%eax
or     %rax,%rcx
cvtsi2sd %rcx,%xmm1
addsd  %xmm1,%xmm1
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm2
mulsd  %xmm1,%xmm2
movsd  %xmm2,-0x20(%rsp)
fldl   -0x20(%rsp)
cmp    $0x1,%rdx
jbe    32d <gsl_stats_ulong_lag1_autocorrelation_m+0xf8>
shl    $0x3,%rsi
mov    %rdi,%r8
add    %rsi,%rdi
fldz   
mov    $0x1,%eax
flds   0x0(%rip)        # 290 <gsl_stats_ulong_lag1_autocorrelation_m+0x5b>
mov    (%rdi),%rcx
test   %rcx,%rcx
js     29f <gsl_stats_ulong_lag1_autocorrelation_m+0x6a>
cvtsi2sd %rcx,%xmm1
jmp    2b4 <gsl_stats_ulong_lag1_autocorrelation_m+0x7f>
mov    %rcx,%r9
shr    %r9
and    $0x1,%ecx
or     %rcx,%r9
cvtsi2sd %r9,%xmm1
addsd  %xmm1,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    2d6 <gsl_stats_ulong_lag1_autocorrelation_m+0xa1>
fadd   %st(2),%st
mov    (%r8),%rcx
test   %rcx,%rcx
js     2e5 <gsl_stats_ulong_lag1_autocorrelation_m+0xb0>
cvtsi2sd %rcx,%xmm1
jmp    2fa <gsl_stats_ulong_lag1_autocorrelation_m+0xc5>
mov    %rcx,%r9
shr    %r9
and    $0x1,%ecx
or     %rcx,%r9
cvtsi2sd %r9,%xmm1
addsd  %xmm1,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fld    %st(1)
fmull  -0x20(%rsp)
fsub   %st(4),%st
fdiv   %st(1),%st
faddp  %st,%st(4)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(4),%st
fdivp  %st,%st(1)
faddp  %st,%st(3)
add    %rsi,%r8
add    %rsi,%rdi
cmp    %rdx,%rax
jne    290 <gsl_stats_ulong_lag1_autocorrelation_m+0x5b>
fstp   %st(0)
jmp    32f <gsl_stats_ulong_lag1_autocorrelation_m+0xfa>
fldz   
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_ulong_lag1_autocorrelation_m (const unsigned long data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 10
20 10
21 10
22 5
23 7
24 11
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 11
42 11
43 11
44 11
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 11
59 11
60 11
61 11
62 11
63 11
64 12
65 12
66 12
67 12
68 12
69 12
70 7
71 7
72 7
73 7
74 5
75 14
76 15
77 15
78 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3db <gsasl_client_callback_anonymous_get+0xa>
mov    0x58(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_anonymous_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_anonymous : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lchmodat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <scram_start>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_scram_sha1_plus_client_start (Gsasl_session * sctx, void **mech_data)
{
  return scram_start (sctx, mech_data, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdx),%r8
cmp    $0x5,%r8
ja     5124 <_jit_getarg_c+0x25>
mov    $0xd,%ecx
sub    %r8,%rcx
movslq %esi,%rdx
mov    $0x4d,%esi
callq  5122 <_jit_getarg_c+0x23>
jmp    5136 <_jit_getarg_c+0x37>
movslq %esi,%rdx
mov    $0xf,%ecx
mov    $0x65,%esi
callq  5136 <_jit_getarg_c+0x37>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_jit_getarg_c(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_extr_c,u,_RDI - v->u.w);
    else
 _jit_new_node_www(_jit,jit_code_ldxi_c,u,_RBP,v->u.w);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 8
16 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x187,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  725 <make_pattern_list+0x1e>
mov    %rax,%rbx
test   %rbp,%rbp
je     746 <make_pattern_list+0x3f>
mov    %rbp,%rax
cmpq   $0x0,0x0(%rbp)
je     749 <make_pattern_list+0x42>
mov    %rbp,%rdi
mov    $0x0,%eax
callq  744 <make_pattern_list+0x3d>
jmp    749 <make_pattern_list+0x42>
mov    %rbp,%rax
mov    %rax,0x8(%rbx)
mov    %r12,0x10(%rbx)
movq   $0x0,(%rbx)
movl   $0x0,0x18(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
make_pattern_list (patterns, action)
     WORD_LIST *patterns;
     COMMAND *action;
{
  PATTERN_LIST *temp;
  temp = (PATTERN_LIST *)sh_xmalloc((sizeof (PATTERN_LIST)), "make_cmd.c", 391);
  temp->patterns = ((patterns && patterns->next) ? (WORD_LIST *)list_reverse ((GENERIC_LIST *)patterns) : (WORD_LIST *)(patterns));
  temp->action = action;
  temp->next = ((void *)0);
  temp->flags = 0;
  return (temp);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 9
24 10
25 12
26 12
27 12
28 12
29 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
movapd %xmm0,%xmm3
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%rbx
movsd  %xmm2,0x8(%rsp)
mov    0x8(%rsp),%rbp
ucomisd 0x0(%rip),%xmm0        # 28 <gsl_cdf_gumbel2_Pinv+0x28>
jp     34 <gsl_cdf_gumbel2_Pinv+0x34>
movsd  0x0(%rip),%xmm0        # 32 <gsl_cdf_gumbel2_Pinv+0x32>
je     88 <gsl_cdf_gumbel2_Pinv+0x88>
ucomisd 0x0(%rip),%xmm3        # 3c <gsl_cdf_gumbel2_Pinv+0x3c>
jp     44 <gsl_cdf_gumbel2_Pinv+0x44>
xorpd  %xmm0,%xmm0
je     88 <gsl_cdf_gumbel2_Pinv+0x88>
movapd %xmm3,%xmm0
callq  4d <gsl_cdf_gumbel2_Pinv+0x4d>
movsd  0x0(%rip),%xmm1        # 55 <gsl_cdf_gumbel2_Pinv+0x55>
xorpd  %xmm1,%xmm0
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm4
divsd  %xmm0,%xmm4
movapd %xmm4,%xmm0
movsd  0x0(%rip),%xmm1        # 74 <gsl_cdf_gumbel2_Pinv+0x74>
mov    %rbx,0x8(%rsp)
movsd  0x8(%rsp),%xmm5
divsd  %xmm5,%xmm1
callq  88 <gsl_cdf_gumbel2_Pinv+0x88>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel2_Pinv (const double P, const double a, const double b)
{
  double x;
  if (P == 1.0)
    {
      return (__builtin_inff());
    }
  else if (P == 0.0)
    {
      return 0.0;
    }
  x = pow(b / (-log(P)), 1/a);
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 6
12 4
13 8
14 8
15 10
16 8
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 14
31 14
32 14
33 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # ac2 <available_space_after+0x7>
sub    %rdi,%rax
retq   
<<<sep_in_sample>>>
available_space_after (union block *pointer)
{
  return record_end->buffer - pointer->buffer;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    %rsi,0x58(%rdi)
retq   
<<<sep_in_sample>>>
osip_authorization_set_nonce_count (osip_authorization_t * authorization, char *nonce_count)
{
  authorization->nonce_count = (char *) nonce_count;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
callq  11e <xstrdup+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    141 <xstrdup+0x29>
callq  12b <xstrdup+0x13>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  0 <error>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstrdup (const char *str)
{
  char *ptr = strdup (str);
  if (!ptr)
    error (1, (*__errno_location ()), "virtual memory exhausted");
  return ptr;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  29 <direntry_cmp_name+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
movb   $0x0,0x0(%rip)        # 111 <start_output+0x7>
movb   $0x0,0x0(%rip)        # 118 <start_output+0xe>
movl   $0x0,0x0(%rip)        # 122 <start_output+0x18>
movl   $0x0,0x0(%rip)        # 12c <start_output+0x22>
movq   $0x0,0x0(%rip)        # 137 <start_output+0x2d>
movq   $0x0,0x0(%rip)        # 142 <start_output+0x38>
retq   
<<<sep_in_sample>>>
start_output(void)
{
 curpath[0] = curtag[0] = '\0';
 cur_lineno = last_lineno = 0;
 fp = ((void *)0);
 src = "";
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
cdio_generic_unimplemented_eject_media (void *p_user_data) {
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%r8        # 1c16 <dicod_log_encode_envar+0xb>
mov    0x0(%rip),%ecx        # 1c1c <dicod_log_encode_envar+0x11>
mov    0x0(%rip),%edx        # 1c22 <dicod_log_encode_envar+0x17>
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x0,%eax
callq  1c36 <dicod_log_encode_envar+0x2b>
mov    $0x1,%edx
mov    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  1c4a <dicod_log_encode_envar+0x3f>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
dicod_log_encode_envar()
{
    char *p;
    asprintf(&p, "%d:%d:%s", log_facility, log_print_severity, log_tag);
    setenv("__DICTD_LOGGING__", p, 1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     37 <mu_pop3_set_carrier+0x37>
mov    %rsi,%rbp
cmpq   $0x0,0x68(%rdi)
je     2e <mu_pop3_set_carrier+0x2e>
callq  22 <mu_pop3_set_carrier+0x22>
lea    0x68(%rbx),%rdi
mov    %rbx,%rsi
callq  2e <mu_pop3_set_carrier+0x2e>
mov    %rbp,0x68(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_pop3_set_carrier (mu_pop3_t pop3, mu_stream_t carrier)
{
  if (pop3 == ((void *)0))
    return 22;
  if (pop3->carrier)
    {
      mu_pop3_disconnect (pop3);
      mu_stream_destroy (&pop3->carrier, pop3);
    }
  pop3->carrier = carrier;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 7
12 8
13 8
14 8
15 10
16 11
17 12
18 12
19 12
20 12
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %edx,%eax
retq   
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x1,%edx
mov    $0x0,%esi
callq  6f <isprotocol+0x18>
mov    %rax,%rdx
mov    $0x1,%eax
test   %rdx,%rdx
jne    d6 <isprotocol+0x7f>
movzbl 0x0(%rbp),%ebx
cmp    $0x3a,%bl
je     cc <isprotocol+0x75>
test   %bl,%bl
je     cc <isprotocol+0x75>
callq  8e <isprotocol+0x37>
mov    (%rax),%rax
movsbq %bl,%rbx
testb  $0x8,(%rax,%rbx,2)
je     c5 <isprotocol+0x6e>
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
cmp    $0x3a,%bl
je     cc <isprotocol+0x75>
test   %bl,%bl
jne    91 <isprotocol+0x3a>
jmp    cc <isprotocol+0x75>
mov    $0x0,%eax
cmpb   $0x2f,0x1(%rbp)
jne    d6 <isprotocol+0x7f>
cmpb   $0x2f,0x2(%rbp)
sete   %al
movzbl %al,%eax
jmp    d6 <isprotocol+0x7f>
mov    $0x0,%eax
jmp    d6 <isprotocol+0x7f>
mov    $0x0,%eax
cmp    $0x3a,%bl
je     ae <isprotocol+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
isprotocol(const char *url)
{
 const char *p;
 if (locatestring(url, "file:", 1))
  return 1;
 for (p = url; *p && *p != ':'; p++)
  if (!((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISalnum))
   return 0;
 if (!*p)
  return 0;
 if (*p++ == ':' && *p++ == '/' && *p == '/')
  return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 13
30 11
31 11
32 11
33 11
34 11
35 11
36 8
37 8
38 10
39 9
40 9
41 14
42 14
43 14
44 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,0xc(%rsp)
lea    0xc(%rsp),%rdx
mov    $0x4,%esi
callq  418 <asm_reserved_sharp+0x17>
mov    0xc(%rsp),%esi
mov    %rax,%rdi
callq  424 <asm_reserved_sharp+0x23>
test   %rax,%rax
je     442 <asm_reserved_sharp+0x41>
mov    0x8(%rax),%eax
lea    -0xbb9(%rax),%edx
cmp    $0x3e8,%edx
mov    $0x0,%edx
cmovae %edx,%eax
jmp    447 <asm_reserved_sharp+0x46>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
asm_reserved_sharp(const char *str, int len)
{
 struct keyword *keyword;
 str = strtrim(str, 4, &len);
 keyword = asm_lookup(str, len);
 return (keyword && ((keyword->token) >= 3001 && (keyword->token) < 4001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
and    $0x7fff,%edx
shl    $0x4,%rdx
mov    0x0(%rdx),%edx
and    $0x7fff,%edx
and    $0x7fff,%esi
shl    $0x4,%rsi
mov    0x0(%rsi),%esi
and    $0x7fff,%esi
callq  8e79 <_ldxi_l>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_emit_ldxi(jit_state_t *_jit, jit_gpr_t r0, jit_gpr_t r1, jit_word_t i0)
{
    _ldxi_l(_jit, (((_rvs[((r0) & 0x00007fff)].spec) & 0x00007fff)), (((_rvs[((r1) & 0x00007fff)].spec) & 0x00007fff)), i0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 892 <yypop_buffer_state+0xb>
test   %rbx,%rbx
je     8e9 <yypop_buffer_state+0x62>
mov    0x0(%rip),%rbp        # 89e <yypop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     8e9 <yypop_buffer_state+0x62>
callq  8b0 <yypop_buffer_state+0x29>
movq   $0x0,(%r12)
test   %rbp,%rbp
je     8db <yypop_buffer_state+0x54>
sub    $0x1,%rbp
mov    %rbp,0x0(%rip)        # 8c8 <yypop_buffer_state+0x41>
jmp    8db <yypop_buffer_state+0x54>
callq  c4 <yy_load_buffer_state>
movl   $0x1,0x0(%rip)        # 8d9 <yypop_buffer_state+0x52>
jmp    8e9 <yypop_buffer_state+0x62>
mov    0x0(%rip),%rax        # 8e2 <yypop_buffer_state+0x5b>
cmpq   $0x0,(%rbx,%rax,8)
jne    8ca <yypop_buffer_state+0x43>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
yypop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 yy_delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  yy_load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 6
14 7
15 7
16 8
17 8
18 8
19 10
20 11
21 11
22 9
23 9
24 9
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    %esi,%ebx
mov    %edx,%ebp
lea    0x8(%rsp),%rdi
callq  c0a <traverse_path>
mov    %eax,%edi
cmp    $0xffffff9c,%eax
je     cac <safe_open+0x29>
mov    %eax,%edx
shr    $0x1f,%edx
test   %dl,%dl
jne    cbf <safe_open+0x3c>
mov    %ebp,%ecx
mov    %ebx,%edx
mov    0x8(%rsp),%rsi
mov    $0x0,%eax
callq  cbf <safe_open+0x3c>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
safe_open (const char *pathname, int flags, mode_t mode)
{
  int dirfd;
  dirfd = traverse_path (&pathname);
  if (dirfd < 0 && dirfd != -100)
    return dirfd;
  return openat (dirfd, pathname, flags, mode);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     4ea <gsl_dht_free+0x2c>
mov    0x30(%rdi),%rdi
callq  4d0 <gsl_dht_free+0x12>
mov    0x28(%rbx),%rdi
callq  4d9 <gsl_dht_free+0x1b>
mov    0x20(%rbx),%rdi
callq  4e2 <gsl_dht_free+0x24>
mov    %rbx,%rdi
callq  4ea <gsl_dht_free+0x2c>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_dht_free(gsl_dht * t)
{
  if (!t) { return ; };
  free(t->J2);
  free(t->Jjj);
  free(t->j);
  free(t);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    %rsp,%rsi
callq  4ac <verifydir+0x13>
test   %eax,%eax
jne    4cb <verifydir+0x32>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     4f6 <verifydir+0x5d>
callq  4c5 <verifydir+0x2c>
movl   $0x14,(%rax)
callq  4d0 <verifydir+0x37>
mov    (%rax),%edi
callq  4d7 <verifydir+0x3e>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  4ec <verifydir+0x53>
mov    $0x1,%edi
callq  4f6 <verifydir+0x5d>
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
verifydir (char *cp)
{
  struct stat stb;
  if (!stat (cp, &stb))
    {
      if (((((stb.st_mode)) & 0170000) == (0040000)))
 return;
      (*__errno_location ()) = 20;
    }
  run_err ("%s: %s", cp, strerror ((*__errno_location ())));
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 12
26 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %edx,%ebp
mov    0x0(%rip),%rax        # 9352 <processwant+0x13>
cmpl   $0x0,(%rax)
je     9375 <processwant+0x36>
mov    $0x3b,%esi
mov    %rbx,%rdi
callq  9364 <processwant+0x25>
test   %rax,%rax
je     9375 <processwant+0x36>
mov    %ebp,%esi
mov    %rbx,%rdi
callq  9373 <processwant+0x34>
jmp    9382 <processwant+0x43>
mov    %ebp,%edx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  9382 <processwant+0x43>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
processwant(struct unittype *theunit, char *unitstr, int promptlen)
{
  if (flags.unitlists && strchr(unitstr, ';'))
    return checkunitlist(unitstr, promptlen);
  else
    return processunit(theunit, unitstr, promptlen);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
mov    $0x8915,%esi
mov    $0x0,%eax
callq  1067 <fh_addr_query+0x22>
test   %eax,%eax
js     107f <fh_addr_query+0x3a>
mov    $0x0,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  107d <fh_addr_query+0x38>
jmp    1091 <fh_addr_query+0x4c>
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  1091 <fh_addr_query+0x4c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_addr_query (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x8915, form->ifr) >= 0)
    select_arg (form, argc, argv, 0);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
cvtsi2ss %edi,%xmm3
unpcklps %xmm3,%xmm3
cvtps2pd %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # ea <ceor+0x12>
mulsd  %xmm2,%xmm3
subsd  %xmm2,%xmm3
cvttsd2si %xmm3,%edx
test   %edx,%edx
jle    144 <ceor+0x6c>
movapd %xmm0,%xmm5
mulsd  %xmm0,%xmm5
movapd %xmm0,%xmm3
mov    $0x0,%eax
movsd  0x0(%rip),%xmm4        # 113 <ceor+0x3b>
cvtsi2sd %eax,%xmm2
addsd  %xmm2,%xmm2
addsd  %xmm4,%xmm2
mulsd  %xmm2,%xmm2
movapd %xmm1,%xmm6
subsd  %xmm2,%xmm6
movapd %xmm6,%xmm2
subsd  %xmm3,%xmm2
movapd %xmm5,%xmm3
divsd  %xmm2,%xmm3
add    $0x1,%eax
cmp    %edx,%eax
jne    113 <ceor+0x3b>
jmp    148 <ceor+0x70>
movapd %xmm0,%xmm3
mov    %edi,%eax
imul   %edi,%eax
cvtsi2sd %eax,%xmm5
addsd  %xmm3,%xmm5
xorpd  %xmm3,%xmm3
test   %esi,%esi
jle    198 <ceor+0xc0>
mulsd  %xmm0,%xmm0
xorpd  %xmm3,%xmm3
cvtsi2sd %edi,%xmm4
cvtsi2sd %esi,%xmm2
addsd  %xmm2,%xmm2
addsd  %xmm4,%xmm2
mulsd  %xmm2,%xmm2
movapd %xmm1,%xmm7
subsd  %xmm2,%xmm7
movapd %xmm7,%xmm2
subsd  %xmm3,%xmm2
movapd %xmm0,%xmm3
divsd  %xmm2,%xmm3
sub    $0x1,%esi
jne    169 <ceor+0x91>
jmp    198 <ceor+0xc0>
addsd  %xmm5,%xmm3
movapd %xmm3,%xmm0
subsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
ceor(int order, double qq, double aa, int nterms)
{
  double term, term1;
  int ii, n1;
  term = qq;
  n1 = (int)((float)order/2.0 - 0.5);
  for (ii=0; ii<n1; ii++)
      term = qq*qq/(aa - (2.0*ii + 1.0)*(2.0*ii + 1.0) - term);
  term += order*order;
  term1 = 0.0;
  for (ii=0; ii<nterms; ii++)
      term1 = qq*qq/
        (aa - (order + 2.0*(nterms - ii))*(order + 2.0*(nterms - ii)) - term1);
  return (term + term1 - aa);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 7
9 7
10 8
11 8
12 5
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 7
26 7
27 7
28 7
29 5
30 9
31 9
32 9
33 9
34 10
35 11
36 11
37 12
38 10
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 12
49 12
50 11
51 11
52 11
53 14
54 14
55 14
56 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzbl 0x50(%rdi),%eax
test   %al,%al
je     54 <__ribclose+0x54>
cmpb   $0x1,0x55(%rdi)
jne    39 <__ribclose+0x39>
mov    0x48(%rdi),%rdi
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2a <__ribclose+0x2a>
cmp    $0xffffffff,%eax
jne    39 <__ribclose+0x39>
mov    $0x0,%edi
callq  39 <__ribclose+0x39>
mov    0x48(%rbx),%rdi
mov    $0x0,%eax
callq  47 <__ribclose+0x47>
movb   $0x0,0x50(%rbx)
movb   $0x1,0x58(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
__ribclose (__bs8FILE *p)
{
  if (((__bs1FILE *) p)->open)
    {
      if (((__bs1FILE *) p)->re_wind == 1
   && fseek (((__bs1FILE *) p)->file, 0L, 0) == (-1))
 __rerror ("Close: Not possible to rewind");
      fclose (((__bs1FILE *) p)->file);
      ((__bs1FILE *) p)->open = 0;
      return (((__bs7FILE *) p)->endfile = 1);
    }
  else
    return (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 8
20 9
21 10
22 10
23 14
24 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%edx
callq  28a <short_eq+0xe>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
short_eq (const void *elt1, const void *elt2) { return memcmp (elt1, elt2, sizeof (short)) == 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     456 <mu_cfg_section_add_container+0x2f>
mov    %rdi,%rbp
cmpq   $0x0,0x28(%rdi)
jne    448 <mu_cfg_section_add_container+0x21>
lea    0x28(%rdi),%rdi
callq  448 <mu_cfg_section_add_container+0x21>
mov    0x28(%rbp),%rdi
mov    %rbx,%rsi
callq  454 <mu_cfg_section_add_container+0x2d>
jmp    45b <mu_cfg_section_add_container+0x34>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_cfg_section_add_container (struct mu_cfg_section *sect,
         struct mu_cfg_cont *cont)
{
  if (!cont)
    return 0;
  if (!sect->children)
    mu_list_create (&sect->children);
  return mu_list_append (sect->children, cont);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 8
13 8
14 8
15 8
16 5
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     161e <gsl_matrix_long_isneg+0x56>
lea    0x0(,%rax,8),%r10
mov    $0x0,%esi
mov    $0x0,%r9d
xorpd  %xmm1,%xmm1
jmp    1617 <gsl_matrix_long_isneg+0x4f>
mov    $0x0,%eax
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdq (%rcx,%rax,8),%xmm0
ucomisd %xmm1,%xmm0
jb     1630 <gsl_matrix_long_isneg+0x68>
jmp    1624 <gsl_matrix_long_isneg+0x5c>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     162a <gsl_matrix_long_isneg+0x62>
test   %rdx,%rdx
jne    15f1 <gsl_matrix_long_isneg+0x29>
jmp    160b <gsl_matrix_long_isneg+0x43>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rdx,%rax
jne    15fd <gsl_matrix_long_isneg+0x35>
jmp    160b <gsl_matrix_long_isneg+0x43>
<<<sep_in_sample>>>
gsl_matrix_long_isneg (const gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 20
26 20
27 15
28 15
29 20
30 20
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x70,%rdi
callq  87 <ahsStaticGetTarname_i>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahsStaticGetTarFilename(struct new_cpio_header * file_hdr)
{
 ;
 return ahsStaticGetTarname_i((STROB**)&(file_hdr->c_name));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     6c <dep_hash_2+0x20>
sub    $0x1,%rax
lea    0x1(%rax),%rdx
movzbl 0x1(%rax),%ecx
mov    $0x0,%eax
test   %cl,%cl
jne    79 <dep_hash_2+0x2d>
repz retq 
mov    0x10(%rdi),%rax
mov    (%rax),%rax
sub    $0x1,%rax
jmp    59 <dep_hash_2+0xd>
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    79 <dep_hash_2+0x2d>
repz retq 
<<<sep_in_sample>>>
dep_hash_2 (const void *key)
{
  const struct dep *d = key;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((d)->name ? (d)->name : (d)->file->name))) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdi
callq  b93 <system_fh_collisions+0x15>
test   %rax,%rax
jne    ba7 <system_fh_collisions+0x29>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  ba5 <system_fh_collisions+0x27>
jmp    bb8 <system_fh_collisions+0x3a>
mov    0x68(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  bb8 <system_fh_collisions+0x3a>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_collisions (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "collisions" " unknown)"); else put_ulong (form, argc, argv, stats->collisions); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  341 <link_error>
<<<sep_in_sample>>>
exec_fatal (char const *name)
{
  call_arg_fatal ("exec", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  4432 <set_ppid+0x1a>
movslq %eax,%rdi
mov    $0xc,%edx
mov    %rsp,%rsi
callq  4442 <set_ppid+0x2a>
mov    %rax,%rbx
mov    $0x0,%edi
callq  444f <set_ppid+0x37>
test   %rax,%rax
je     4458 <set_ppid+0x40>
andl   $0xfffffffc,0x28(%rax)
mov    $0x0,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  446a <set_ppid+0x52>
orl    $0x12,0x28(%rax)
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
je     4483 <set_ppid+0x6b>
callq  4483 <set_ppid+0x6b>
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
set_ppid ()
{
  char namebuf[((sizeof (pid_t) * 8 - (! ((pid_t) 0 < (pid_t) -1))) * 302 / 1000 + 1 + (! ((pid_t) 0 < (pid_t) -1))) + 1], *name;
  SHELL_VAR *temp_var;
  name = inttostr (getppid (), namebuf, sizeof(namebuf));
  temp_var = find_variable ("PPID");
  if (temp_var)
    ((temp_var)->attributes &= ~((0x0000002 | 0x0000001)));
  temp_var = bind_variable ("PPID", name, 0);
  ((temp_var)->attributes |= ((0x0000002 | 0x0000010)));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 8
17 9
18 9
19 9
20 9
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 4d <spush+0xb>
add    $0x8,%rax
cmp    %rax,0x0(%rip)        # 58 <spush+0x16>
jae    69 <spush+0x27>
mov    $0x8,%esi
mov    $0x0,%edi
callq  69 <spush+0x27>
mov    0x0(%rip),%rax        # 70 <spush+0x2e>
mov    %rbx,(%rax)
addq   $0x8,0x0(%rip)        # 7b <spush+0x39>
pop    %rbx
retq   
<<<sep_in_sample>>>
spush(sent_t *re)
{
  __extension__ ({ struct obstack *__o = (&os_stack); int __len = (sizeof (void *)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); bcopy (((char *) (&re)), (__o->next_free), (__len)); __o->next_free += __len; (void) 0; });
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  9e3 <insert_depthspec>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_mindepth (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_depthspec (entry, argv, arg_ptr, &options.mindepth);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    (%rsi),%edx
mov    %edx,(%rdi)
mov    %eax,(%rsi)
mov    0x4(%rdi),%eax
mov    0x4(%rsi),%edx
mov    %edx,0x4(%rdi)
mov    %eax,0x4(%rsi)
mov    0x8(%rsi),%rax
mov    0x8(%rdi),%rdx
mov    %rdx,0x8(%rsi)
mov    %rax,0x8(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_swap (mpz_ptr u, mpz_ptr v)
{
  do { mp_size_t __mp_size_t_swap__tmp = (((u)->_mp_alloc)); (((u)->_mp_alloc)) = (((v)->_mp_alloc)); (((v)->_mp_alloc)) = __mp_size_t_swap__tmp; } while (0);
  do { mp_size_t __mp_size_t_swap__tmp = (((u)->_mp_size)); (((u)->_mp_size)) = (((v)->_mp_size)); (((v)->_mp_size)) = __mp_size_t_swap__tmp; } while (0);
  do { mp_ptr __mp_ptr_swap__tmp = (((v)->_mp_d)); (((v)->_mp_d)) = (((u)->_mp_d)); (((u)->_mp_d)) = __mp_ptr_swap__tmp; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # d <find_footnotes_window+0xd>
test   %rbx,%rbx
je     48 <find_footnotes_window+0x48>
mov    $0xc,%ebp
mov    0x30(%rbx),%rdi
callq  20 <find_footnotes_window+0x20>
test   %eax,%eax
je     40 <find_footnotes_window+0x40>
mov    0x30(%rbx),%rax
mov    0x10(%rax),%rsi
mov    $0x0,%edi
mov    %rbp,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
je     48 <find_footnotes_window+0x48>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    17 <find_footnotes_window+0x17>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
find_footnotes_window (void)
{
  WINDOW *win;
  for (win = windows; win; win = win->next)
    if (internal_info_node_p (win->node) &&
        (strcmp (win->node->nodename, footnote_nodename) == 0))
      break;
  return win;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 6
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 4
22 4
23 4
24 9
25 9
26 9
27 9
28 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%r8d
mov    (%rdx),%rdx
callq  16cd <strategy_deny_length_gt_cb+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strategy_deny_length_gt_cb(enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr,
      grecs_value_t *value,
      void *cb_data)
{
    return strategy_deny_length(cmd, locus, *(dico_list_t*) varptr,
    value, cmp_gt);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 9
6 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  37 <quote_string+0x11>
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     d3 <quote_string+0xad>
callq  48 <quote_string+0x22>
mov    %rax,%r12
movzbl %bpl,%ebp
mov    (%r12),%rax
testb  $0x8,(%rax,%rbp,2)
jne    8d <quote_string+0x67>
mov    0x0(%rip),%rax        # 60 <quote_string+0x3a>
cmp    %rax,0x0(%rip)        # 67 <quote_string+0x41>
jb     78 <quote_string+0x52>
mov    $0x0,%esi
mov    $0x0,%edi
callq  78 <quote_string+0x52>
mov    0x0(%rip),%rax        # 7f <quote_string+0x59>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 8a <quote_string+0x64>
movb   $0x5c,(%rax)
mov    0x0(%rip),%rax        # 94 <quote_string+0x6e>
cmp    %rax,0x0(%rip)        # 9b <quote_string+0x75>
jb     ac <quote_string+0x86>
mov    $0x0,%esi
mov    $0x0,%edi
callq  ac <quote_string+0x86>
mov    0x0(%rip),%rdx        # b3 <quote_string+0x8d>
lea    0x1(%rdx),%rcx
mov    %rcx,0x0(%rip)        # be <quote_string+0x98>
movzbl (%rbx),%ecx
mov    %cl,(%rdx)
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
jne    4b <quote_string+0x25>
mov    $0x0,%edi
callq  dd <quote_string+0xb7>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quote_string(const char *s)
{
 static STRBUF sb[1];
 strbuf_clear(sb);
 for (; *s; s++) {
  if (!((*__ctype_b_loc ())[(int) (((unsigned char)*s))] & (unsigned short int) _ISalnum))
   do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = '\\';} while (0);
  do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = *s;} while (0);
 }
 return strbuf_value(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 5
38 5
39 5
40 5
41 10
42 10
43 11
44 11
45 11
46 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  d3d1 <_x87_buneqi_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c747 <_x87_movi_d>
mov    0x0(%r12),%r8d
and    $0x7fff,%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  1b80 <_x87jcc2>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d429 <_x87_buneqi_d+0x7c>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_buneqi_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc2(_jit, 0x4, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c93 <close_extensions+0x7>
test   %rax,%rax
je     cc7 <close_extensions+0x3b>
push   %rbx
mov    (%rax),%rbx
cmp    %rbx,%rax
je     cc6 <close_extensions+0x3a>
cmpl   $0x5,0x10(%rbx)
jne    cba <close_extensions+0x2e>
mov    0xe8(%rbx),%rdx
test   %rdx,%rdx
je     cba <close_extensions+0x2e>
mov    $0x0,%eax
callq  *%rdx
mov    (%rbx),%rbx
cmp    %rbx,0x0(%rip)        # cc4 <close_extensions+0x38>
jne    ca1 <close_extensions+0x15>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
close_extensions()
{
 SRCFILE *s;
 if (srcfiles == ((void *)0))
  return;
 for (s = srcfiles->next; s != srcfiles; s = s->next)
  if (s->stype == SRC_EXTLIB && s->fini_func)
                        (*s->fini_func)();
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 6
16 6
17 6
18 9
19 9
<<<sep_out_sample>>>
push   %rbx
mov    0x28(%rdx),%rbx
cmp    $0x61,%edi
je     a8 <parse_opt+0xa8>
cmp    $0x61,%edi
jg     3c <parse_opt+0x3c>
cmp    $0x34,%edi
je     96 <parse_opt+0x96>
cmp    $0x34,%edi
jg     2b <parse_opt+0x2b>
test   %edi,%edi
nop
je     b1 <parse_opt+0xb1>
jmpq   bb <parse_opt+0xbb>
cmp    $0x36,%edi
xchg   %ax,%ax
je     9f <parse_opt+0x9f>
cmp    $0x50,%edi
je     6e <parse_opt+0x6e>
jmpq   bb <parse_opt+0xbb>
cmp    $0x6e,%edi
nop
je     8d <parse_opt+0x8d>
cmp    $0x6e,%edi
jg     54 <parse_opt+0x54>
cmp    $0x65,%edi
je     7b <parse_opt+0x7b>
cmp    $0x68,%edi
nop
je     88 <parse_opt+0x88>
jmp    bb <parse_opt+0xbb>
cmp    $0x70,%edi
je     68 <parse_opt+0x68>
cmp    $0x75,%edi
nopl   0x0(%rax)
jne    bb <parse_opt+0xbb>
mov    %rsi,0x8(%rbx)
jmp    bb <parse_opt+0xbb>
mov    %rsi,0x10(%rbx)
jmp    bb <parse_opt+0xbb>
mov    %rsi,%rdi
callq  76 <parse_opt+0x76>
mov    %eax,0x24(%rbx)
jmp    bb <parse_opt+0xbb>
mov    %rsi,%rdi
callq  83 <parse_opt+0x83>
mov    %eax,0x2c(%rbx)
jmp    bb <parse_opt+0xbb>
mov    %rsi,(%rbx)
jmp    bb <parse_opt+0xbb>
movl   $0x0,0x28(%rbx)
jmp    bb <parse_opt+0xbb>
movl   $0x2,0x20(%rbx)
jmp    bb <parse_opt+0xbb>
movl   $0xa,0x20(%rbx)
jmp    bb <parse_opt+0xbb>
movl   $0x0,0x20(%rbx)
jmp    bb <parse_opt+0xbb>
mov    %rsi,0x18(%rbx)
mov    0x8(%rdx),%eax
mov    %eax,0x18(%rdx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_opt (int key, char *arg, struct argp_state *state)
{
  struct arguments *arguments = state->input;
  switch (key)
    {
    case 'u':
      arguments->user = arg;
      break;
    case 'p':
      arguments->password = arg;
      break;
    case 'P':
      arguments->port = atoi (arg);
      break;
    case 'e':
      arguments->err_port = atoi (arg);
      break;
    case 'h':
      arguments->host = arg;
      break;
    case 'n':
      arguments->use_err = 0;
      break;
    case '4':
      arguments->af = 2;
      break;
    case '6':
      arguments->af = 10;
      break;
    case 'a':
      arguments->af = 0;
      break;
    case 0:
      arguments->command = arg;
      state->next = state->argc;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 7
38 8
39 10
40 11
41 13
42 13
43 13
44 14
45 16
46 16
47 16
48 17
49 19
50 20
51 22
52 23
53 25
54 26
55 28
56 29
57 31
58 32
59 34
60 35
61 35
62 38
63 38
64 38
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0xa,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    1553 <gsl_permute_matrix_int+0x29>
mov    $0x0,%ebx
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     159b <gsl_permute_matrix_int+0x71>
jmp    1573 <gsl_permute_matrix_int+0x49>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  156c <gsl_permute_matrix_int+0x42>
mov    $0x13,%eax
jmp    159b <gsl_permute_matrix_int+0x71>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  1581 <gsl_permute_matrix_int+0x57>
mov    %rsp,%rsi
mov    %r12,%rdi
callq  158c <gsl_permute_matrix_int+0x62>
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     1573 <gsl_permute_matrix_int+0x49>
mov    $0x0,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_permute_matrix_int (const gsl_permutation * p, gsl_matrix_int * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_int_view r = gsl_matrix_int_row (A, i);
          gsl_permute_vector_int (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 10
11 15
12 10
13 10
14 10
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 10
30 10
31 10
32 15
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
test   %rsi,%rsi
je     14 <nntp_itr_getitem+0x14>
mov    0x10(%rdi),%rax
mov    %rax,(%rsi)
movq   $0x0,0x10(%rdi)
test   %rdx,%rdx
je     20 <nntp_itr_getitem+0x20>
movq   $0x0,(%rdx)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
nntp_itr_getitem (void *owner, void **item, const void **pkey)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  if (item)
    {
      *((char **)item) = nntp_iterator->item;
      nntp_iterator->item = ((void *)0);
    }
  if (pkey)
    *pkey = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 9
7 9
8 10
9 12
10 12
<<<sep_out_sample>>>
test   %rcx,%rcx
je     1a29 <gsl_permute_uchar+0x7b>
push   %rbx
mov    %rsi,%r11
mov    $0x0,%r8d
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    19cf <gsl_permute_uchar+0x21>
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     19c6 <gsl_permute_uchar+0x18>
cmp    %rax,%r8
ja     1a04 <gsl_permute_uchar+0x56>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
jne    1a12 <gsl_permute_uchar+0x64>
jmp    1a04 <gsl_permute_uchar+0x56>
mov    %r9,%rax
mov    %r10,%r9
mov    %r9,%r10
imul   %rdx,%r10
movzbl (%rsi,%r10,1),%r10d
imul   %rdx,%rax
mov    %r10b,(%rsi,%rax,1)
mov    (%rdi,%r9,8),%r10
cmp    %r8,%r10
jne    19df <gsl_permute_uchar+0x31>
jmp    1a18 <gsl_permute_uchar+0x6a>
add    $0x1,%r8
add    %rdx,%r11
cmp    %rcx,%r8
jne    19bd <gsl_permute_uchar+0xf>
jmp    1a22 <gsl_permute_uchar+0x74>
movzbl (%r11),%ebx
jmp    19e5 <gsl_permute_uchar+0x37>
imul   %rdx,%r9
mov    %bl,(%rsi,%r9,1)
jmp    1a04 <gsl_permute_uchar+0x56>
mov    $0x0,%eax
pop    %rbx
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_uchar (const size_t * p, unsigned char * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned char t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned char r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 4
6 6
7 7
8 7
9 8
10 7
11 7
12 9
13 9
14 11
15 12
16 12
17 12
18 12
19 27
20 23
21 23
22 23
23 24
24 24
25 27
26 19
27 19
28 19
29 4
30 4
31 4
32 4
33 4
34 18
35 18
36 30
37 30
38 30
39 34
40 34
41 34
42 34
43 34
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     272 <mu_ip_server_set_ident+0x37>
mov    %rsi,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     25e <mu_ip_server_set_ident+0x23>
callq  25e <mu_ip_server_set_ident+0x23>
mov    %rbp,%rdi
callq  266 <mu_ip_server_set_ident+0x2b>
mov    %rax,(%rbx)
cmp    $0x1,%rax
sbb    %eax,%eax
and    $0xc,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_ip_server_set_ident (mu_ip_server_t srv, const char *ident)
{
  if (!srv)
    return 22;
  if (srv->ident)
    free (srv->ident);
  srv->ident = strdup (ident);
  if (!srv->ident)
    return 12;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 5
12 6
13 7
14 7
15 7
16 9
17 9
18 9
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx,%rcx,1),%rdi
callq  1f <latin1toutf8+0x1f>
test   %rax,%rax
je     8e <latin1toutf8+0x8e>
movzbl (%rbx),%edx
test   %dl,%dl
je     85 <latin1toutf8+0x85>
lea    0x1(%rbx),%rcx
mov    %rbx,%rdi
mov    $0x0,%esi
test   %dl,%dl
js     44 <latin1toutf8+0x44>
mov    %dl,(%rax,%rsi,1)
lea    0x1(%rsi),%rsi
jmp    74 <latin1toutf8+0x74>
cmp    $0xbf,%dl
ja     5e <latin1toutf8+0x5e>
lea    0x1(%rsi),%rdx
movb   $0xc2,(%rax,%rsi,1)
add    $0x2,%rsi
movzbl (%rdi),%edi
mov    %dil,(%rax,%rdx,1)
jmp    74 <latin1toutf8+0x74>
lea    0x1(%rsi),%rdx
movb   $0xc3,(%rax,%rsi,1)
add    $0x2,%rsi
movzbl (%rdi),%edi
sub    $0x40,%edi
mov    %dil,(%rax,%rdx,1)
mov    %rcx,%rdi
add    $0x1,%rcx
movzbl -0x1(%rcx),%edx
test   %dl,%dl
jne    37 <latin1toutf8+0x37>
jmp    8a <latin1toutf8+0x8a>
mov    $0x0,%esi
movb   $0x0,(%rax,%rsi,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
latin1toutf8 (const char *str)
{
  char *p = malloc (2 * strlen (str) + 1);
  if (p)
    {
      size_t i, j = 0;
      for (i = 0; str[i]; i++)
 {
   if (to_uchar (str[i]) < 0x80)
     p[j++] = str[i];
   else if (to_uchar (str[i]) < 0xC0)
     {
       p[j++] = (unsigned char) 0xC2;
       p[j++] = str[i];
     }
   else
     {
       p[j++] = (unsigned char) 0xC3;
       p[j++] = str[i] - 64;
     }
 }
      p[j] = 0x00;
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 7
12 7
13 7
14 7
15 7
16 7
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 13
25 13
26 14
27 14
28 14
29 14
30 18
31 18
32 19
33 19
34 19
35 19
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 22
44 25
45 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1c1f <gsl_complex_arccoth+0x9>
callq  1c24 <gsl_complex_arccoth+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_arccoth (gsl_complex a)
{
  gsl_complex t = gsl_complex_inverse (a);
  return gsl_complex_arctanh (t);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
movzwl (%rdi),%eax
test   %rdx,%rdx
je     114d <gsl_stats_ushort_max+0x28>
add    %rsi,%rsi
mov    $0x0,%ecx
movzwl (%rdi),%r8d
cmp    %r8w,%ax
cmovb  %r8d,%eax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    1135 <gsl_stats_ushort_max+0x10>
repz retq 
<<<sep_in_sample>>>
gsl_stats_ushort_max (const unsigned short data[], const size_t stride,
                          const size_t n)
{
  unsigned short max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned short xi = data[i * stride];
      if (xi > max)
        max = xi;
    }
  return max;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 6
6 8
7 8
8 8
9 6
10 6
11 6
12 6
13 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    $0x3,%edi
je     513 <op_strcasecmp+0x2c>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  50c <op_strcasecmp+0x25>
mov    $0x1,%eax
jmp    539 <op_strcasecmp+0x52>
mov    0x10(%rsi),%rax
mov    0x8(%rsi),%rdi
mov    %rax,%rsi
callq  523 <op_strcasecmp+0x3c>
mov    %eax,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  534 <op_strcasecmp+0x4d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
op_strcasecmp(int argc, char **argv)
{
    char *opname = *argv++;
    argc--;
    if (argc != 2) {
 dico_log(4, 0, "%s requires two arguments", opname);
 return 1;
    }
    printf("%d\n", utf8_strcasecmp(argv[0], argv[1]));
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 11
22 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x11,%edi
callq  d61 <set_impossible_sigchld_trap+0xe>
mov    $0x0,%esi
mov    $0x11,%edi
callq  1fc <change_signal>
andl   $0xfffffffe,0x0(%rip)        # d77 <set_impossible_sigchld_trap+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_impossible_sigchld_trap ()
{
  restore_default_signal (17);
  change_signal (17, (char *)(SigHandler *)initialize_traps);
  sigmodes[17] &= ~0x1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 6
9 6
<<<sep_out_sample>>>
mov    0x0(%rip),%r11        # 9a <history_total_bytes+0x7>
test   %r11,%r11
je     ee <history_total_bytes+0x5b>
mov    (%r11),%rdx
test   %rdx,%rdx
je     f6 <history_total_bytes+0x63>
mov    $0x0,%r8d
mov    $0x0,%esi
mov    $0xffffffffffffffff,%r9
mov    $0x0,%eax
mov    (%rdx),%rdi
mov    %r9,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r10
mov    0x8(%rdx),%rdi
mov    %r9,%rcx
repnz scas %es:(%rdi),%al
sub    %ecx,%r8d
lea    -0x3(%r8,%r10,1),%r8d
add    $0x1,%esi
movslq %esi,%rdx
mov    (%r11,%rdx,8),%rdx
test   %rdx,%rdx
jne    be <history_total_bytes+0x2b>
jmp    fc <history_total_bytes+0x69>
mov    $0x0,%r8d
jmp    fc <history_total_bytes+0x69>
mov    $0x0,%r8d
mov    %r8d,%eax
retq   
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 7
31 7
<<<sep_out_sample>>>
mov    %rdi,%rax
and    0x4(%rdx),%esi
mov    %esi,0x4(%rdi)
movl   $0x0,(%rdi)
mov    0x0(%rip),%r8d        # 1c2 <event_mask_init+0x16>
test   %r8d,%r8d
jle    1ef <event_mask_init+0x43>
mov    $0x0,%ecx
movslq %ecx,%r9
test   %esi,0x0(,%r9,8)
je     1dc <event_mask_init+0x30>
or     %r8d,(%rax)
add    $0x1,%ecx
movslq %ecx,%r8
mov    0x0(,%r8,8),%r8d
cmp    %ecx,%r8d
jg     1cc <event_mask_init+0x20>
mov    (%rdx),%edx
test   %edx,%edx
je     1f7 <event_mask_init+0x4b>
and    %edx,(%rax)
repz retq 
<<<sep_in_sample>>>
event_mask_init(event_mask *m, int fflags, event_mask const *req)
{
 int i;
 m->sys_mask = fflags & req->sys_mask;
 m->gen_mask = 0;
 for (i = 0; i < genev_xlat[i].gen_mask; i++)
  if (genev_xlat[i].sys_mask & m->sys_mask)
   m->gen_mask |= genev_xlat[i].gen_mask;
 if (req->gen_mask)
  m->gen_mask &= req->gen_mask;
 return m;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 8
13 6
14 6
15 6
16 6
17 6
18 9
19 9
20 9
21 10
22 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  566d <string_list+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_list (list)
     WORD_LIST *list;
{
  return (string_list_internal (list, " "));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1f3 <compute_uint_variance>
sqrtsd %xmm0,%xmm1
ucomisd %xmm1,%xmm1
jnp    fbf <gsl_stats_uint_sd_with_fixed_mean+0x1c>
callq  fbb <gsl_stats_uint_sd_with_fixed_mean+0x18>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_uint_sd_with_fixed_mean (const unsigned int data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_uint_variance (data, stride, n, mean);
  const double sd = sqrt (variance);
  return sd;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 77f <unset_sigwinch_handler+0xb>
mov    $0x1c,%edi
callq  789 <unset_sigwinch_handler+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unset_sigwinch_handler ()
{
  set_signal_handler (28, old_winch);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
callq  1b7 <color_init+0x9>
test   %al,%al
je     224 <color_init+0x76>
callq  1c0 <color_init+0x12>
mov    %eax,%ebp
mov    0x0(%rip),%rax        # 1c9 <color_init+0x1b>
mov    0xa0(%rax),%rbx
test   %rbx,%rbx
je     224 <color_init+0x76>
mov    $0x7,%r12d
movzwl (%rbx),%esi
movzwl 0x2(%rbx),%edx
cmp    $0xffffffff,%ebp
sete   %al
jne    1f7 <color_init+0x49>
cmp    $0xffff,%si
sete   %cl
test   %cl,%cl
cmovne %r12d,%esi
test   %al,%al
je     20c <color_init+0x5e>
cmp    $0xffff,%dx
sete   %al
test   %al,%al
mov    $0x0,%eax
cmovne %eax,%edx
movswl %dx,%edx
movswl %si,%esi
movswl 0x8(%rbx),%edi
callq  21b <color_init+0x6d>
mov    0x38(%rbx),%rbx
test   %rbx,%rbx
jne    1db <color_init+0x2d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
color_init(void)
{
    const colortype *ink;
    _Bool using_defaults = 0;
    short foreground, background;
    ((void) (0));
    if (!has_colors())
 return;
    using_defaults = (use_default_colors() != (-1));
    for (ink = openfile->colorstrings; ink != ((void *)0); ink = ink->next) {
 foreground = ink->fg;
 background = ink->bg;
 if (foreground == -1 && !using_defaults)
     foreground = 7;
 if (background == -1 && !using_defaults)
     background = 0;
 init_pair(ink->pairnum, foreground, background);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 7
5 7
6 7
7 9
8 9
9 10
10 10
11 10
12 10
13 14
14 11
15 12
16 13
17 13
18 13
19 13
20 13
21 14
22 14
23 15
24 15
25 15
26 15
27 16
28 16
29 16
30 17
31 17
32 17
33 17
34 10
35 10
36 10
37 19
38 19
39 19
40 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a40 <osip_transaction_get_reserved4+0xd>
mov    0x2c58(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_transaction_get_reserved4 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved4;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  cb <string_cmp+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_cmp(const void *elt1, const void *elt2)
{
 return strcmp((const char *)elt1,(const char *)elt2);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
movzbl (%rdi),%ebx
test   %bl,%bl
je     510 <has_blank_chars+0x30>
callq  4f5 <has_blank_chars+0x15>
mov    (%rax),%rax
movsbq %bl,%rbx
testb  $0x1,(%rax,%rbx,2)
jne    517 <has_blank_chars+0x37>
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    4f8 <has_blank_chars+0x18>
jmp    51e <has_blank_chars+0x3e>
mov    $0x0,%eax
jmp    523 <has_blank_chars+0x43>
mov    $0x1,%eax
jmp    523 <has_blank_chars+0x43>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
has_blank_chars(const char *s)
{
    ((void) (0));
    for (; *s != '\0'; s++) {
 if (((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISblank))
     return 1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 4
17 4
18 8
19 8
20 6
21 6
22 8
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
callq  17e4 <_rl_erase_at_end_of_line+0xd>
test   %ebp,%ebp
jle    1845 <_rl_erase_at_end_of_line+0x6e>
mov    $0x0,%ebx
mov    0x0(%rip),%rsi        # 17f4 <_rl_erase_at_end_of_line+0x1d>
mov    $0x20,%edi
callq  17fe <_rl_erase_at_end_of_line+0x27>
add    $0x1,%ebx
cmp    %ebp,%ebx
jne    17ed <_rl_erase_at_end_of_line+0x16>
jmp    1830 <_rl_erase_at_end_of_line+0x59>
mov    (%rsi),%rcx
mov    0x0(%rip),%edi        # 1810 <_rl_erase_at_end_of_line+0x39>
lea    -0x1(%rdi),%edx
mov    %edx,0x0(%rip)        # 1819 <_rl_erase_at_end_of_line+0x42>
movslq %edx,%rdx
movb   $0x0,(%rcx,%rdx,1)
add    $0x1,%eax
cmp    %ebp,%eax
jne    1807 <_rl_erase_at_end_of_line+0x30>
addl   $0x1,0x0(%rip)        # 182e <_rl_erase_at_end_of_line+0x57>
jmp    184e <_rl_erase_at_end_of_line+0x77>
mov    %ebp,%edi
callq  1837 <_rl_erase_at_end_of_line+0x60>
mov    0x0(%rip),%rsi        # 183e <_rl_erase_at_end_of_line+0x67>
mov    $0x0,%eax
jmp    1807 <_rl_erase_at_end_of_line+0x30>
mov    %ebp,%edi
callq  184c <_rl_erase_at_end_of_line+0x75>
jmp    1827 <_rl_erase_at_end_of_line+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_erase_at_end_of_line (l)
     int l;
{
  register int i;
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    _IO_putc (' ', rl_outstream);
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    (line_state_visible->line)[--_rl_last_c_pos] = '\0';
  rl_display_fixed++;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 10
21 10
22 9
23 9
24 9
25 11
26 11
27 8
28 8
29 10
30 9
31 9
32 8
33 8
34 8
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    11e <argp_fmtstream_set_lmargin+0x1f>
callq  11e <argp_fmtstream_set_lmargin+0x1f>
mov    0x8(%rbx),%rax
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->lmargin;
  __fs->lmargin = __lmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rbx        # eca <progman_lookup_component+0x10>
test   %rbx,%rbx
je     ef5 <progman_lookup_component+0x3b>
cmpl   $0x0,0x10(%rbx)
jne    eeb <progman_lookup_component+0x31>
mov    0x18(%rbx),%rdi
mov    %rbp,%rsi
callq  ee1 <progman_lookup_component+0x27>
test   %eax,%eax
jne    eeb <progman_lookup_component+0x31>
mov    0x30(%rbx),%rax
jmp    f01 <progman_lookup_component+0x47>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    ecf <progman_lookup_component+0x15>
jmp    efc <progman_lookup_component+0x42>
mov    $0x0,%eax
jmp    f01 <progman_lookup_component+0x47>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
progman_lookup_component (const char *tag)
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (((prog)->type == TYPE_COMPONENT) && strcmp (prog->tag, tag) == 0)
      return prog->v.p.comp;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 4
18 4
19 4
20 4
21 7
22 7
23 7
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
mov    (%rdi),%eax
lea    0x1(%rax),%edx
and    $0x3fff,%edx
mov    %edx,(%rdi)
lea    0x39ce(%rdx),%eax
and    $0x3fff,%eax
lea    0x3e29(%rdx),%ecx
and    $0x3fff,%ecx
mov    0x8(%rdi,%rax,8),%rax
xor    0x8(%rdi,%rcx,8),%rax
lea    0x24b4(%rdx),%ecx
and    $0x3fff,%ecx
xor    0x8(%rdi,%rcx,8),%rax
lea    0x1a27(%rdx),%ecx
and    $0x3fff,%ecx
xor    0x8(%rdi,%rcx,8),%rax
movslq %edx,%rdx
mov    %rax,0x8(%rdi,%rdx,8)
retq   
<<<sep_in_sample>>>
gfsr4_get (void *vstate)
{
  gfsr4_state_t *state = (gfsr4_state_t *) vstate;
  state->nd = ((state->nd)+1)&16383;
  return state->ra[(state->nd)] =
      state->ra[((state->nd)+(16383 +1-471))&16383]^
      state->ra[((state->nd)+(16383 +1-1586))&16383]^
      state->ra[((state->nd)+(16383 +1-6988))&16383]^
      state->ra[((state->nd)+(16383 +1-9689))&16383];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 6
8 6
9 6
10 6
11 8
12 8
13 7
14 9
15 9
16 8
17 5
18 5
19 10
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rdx
test   %rsi,%rsi
je     191f <gsl_matrix_uint_isnonneg+0x31>
mov    $0x0,%ecx
jmp    1913 <gsl_matrix_uint_isnonneg+0x25>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1901 <gsl_matrix_uint_isnonneg+0x13>
add    $0x1,%rcx
cmp    %rsi,%rcx
je     191f <gsl_matrix_uint_isnonneg+0x31>
test   %rdx,%rdx
je     190a <gsl_matrix_uint_isnonneg+0x1c>
mov    $0x0,%eax
jmp    1901 <gsl_matrix_uint_isnonneg+0x13>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_uint_isnonneg (const gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 7
4 7
5 7
6 7
7 9
8 9
9 9
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 21
18 21
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %r8,%r14
callq  189 <gsl_stats_wskew+0x22>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r15
mov    %r14,%r8
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1a8 <gsl_stats_wskew+0x41>
movapd %xmm0,%xmm1
mov    %r15,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r14,%r8
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1cb <gsl_stats_wskew+0x64>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_wskew (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_wmean(w, wstride, data, stride, n);
  const double wsd = gsl_stats_wsd_m(w, wstride, data, stride, n, wmean);
  return gsl_stats_wskew_m_sd(w, wstride, data, stride, n, wmean, wsd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
cmpq   $0x0,0x0(%rip)        # 39 <mu_global_debug_set_level+0x13>
jne    55 <mu_global_debug_set_level+0x2f>
mov    $0x0,%edx
mov    $0x4,%esi
mov    $0x0,%edi
callq  4f <mu_global_debug_set_level+0x29>
mov    %eax,%edx
test   %edx,%edx
jne    7f <mu_global_debug_set_level+0x59>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 64 <mu_global_debug_set_level+0x3e>
callq  69 <mu_global_debug_set_level+0x43>
mov    %eax,%edx
cmp    $0x1029,%eax
je     76 <mu_global_debug_set_level+0x50>
test   %edx,%edx
jne    7f <mu_global_debug_set_level+0x59>
mov    0x8(%rsp),%rax
mov    %ebp,(%rax)
mov    %edx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_global_debug_set_level (const char *object_name, mu_log_level_t level)
{
  int rc;
  struct debug_level *dbg;
  if (!debug_table)
    {
      rc = mu_assoc_create (&debug_table, sizeof(struct debug_level), 0);
      if (rc)
 return rc;
    }
  rc = mu_assoc_ref_install (debug_table, object_name, (void**) &dbg);
  if (rc == 0 || rc == (0x1000 +41))
    dbg->level = level;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 11
16 11
17 11
18 11
19 11
20 12
21 12
22 12
23 12
24 13
25 13
26 14
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
testb  $0x20,0x240(%rdi)
je     5e <__txn_set_tx_max+0x1e>
sub    $0x8,%rsp
mov    $0x1,%edx
mov    $0x0,%esi
callq  5c <__txn_set_tx_max+0x1c>
jmp    6a <__txn_set_tx_max+0x2a>
mov    %esi,0x90(%rdi)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__txn_set_tx_max(dbenv, tx_max)
 DB_ENV *dbenv;
 u_int32_t tx_max;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_tx_max", 1));;
 dbenv->tx_max = tx_max;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 5
5 5
6 5
7 5
8 6
9 7
10 7
11 8
12 8
<<<sep_out_sample>>>
test   %rsi,%rsi
je     7b7 <dicod_free_database_descr+0x1b>
cmp    %rsi,0x10(%rdi)
je     7b7 <dicod_free_database_descr+0x1b>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  7b3 <dicod_free_database_descr+0x17>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dicod_free_database_descr(dicod_database_t *db, char *descr)
{
    if (descr && descr != db->descr)
 free(descr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    (%rsi),%edx
mov    %edx,(%rdi)
mov    %eax,(%rsi)
mov    0x4(%rdi),%eax
mov    0x4(%rsi),%edx
mov    %edx,0x4(%rdi)
mov    %eax,0x4(%rsi)
mov    0x8(%rdi),%rax
mov    0x8(%rsi),%rdx
mov    %rdx,0x8(%rdi)
mov    %rax,0x8(%rsi)
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rdx
mov    %rdx,0x10(%rdi)
mov    %rax,0x10(%rsi)
retq   
<<<sep_in_sample>>>
__gmpf_swap (mpf_ptr u, mpf_ptr v)
{
  mp_ptr tptr;
  mp_size_t tprec;
  mp_size_t tsiz;
  mp_exp_t texp;
  tprec = ((u)->_mp_prec);
  ((u)->_mp_prec) = ((v)->_mp_prec);
  ((v)->_mp_prec) = tprec;
  tsiz = ((u)->_mp_size);
  ((u)->_mp_size) = ((v)->_mp_size);
  ((v)->_mp_size) = tsiz;
  texp = ((u)->_mp_exp);
  ((u)->_mp_exp) = ((v)->_mp_exp);
  ((v)->_mp_exp) = texp;
  tptr = ((u)->_mp_d);
  ((u)->_mp_d) = ((v)->_mp_d);
  ((v)->_mp_d) = tptr;
}
<<<sep_in_sample>>>
1 7
2 8
3 8
4 9
5 10
6 11
7 11
8 12
9 13
10 14
11 14
12 15
13 16
14 17
15 17
16 18
17 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  781 <swicat_sl_add_sc+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swicat_sl_add_sc(SWICAT_SL * swicat_sl, SWICAT_SC * swicat_sc)
{
 vplob_add(swicat_sl->scM, swicat_sc);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a2d <osip_transaction_get_reserved3+0xd>
mov    0x2c50(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_transaction_get_reserved3 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved3;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 1ca <non_monotonic_error+0xb>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1d6 <non_monotonic_error+0x17>
mov    $0x0,%eax
callq  1e0 <non_monotonic_error+0x21>
mov    $0x1,%edi
callq  1ea <output_dataset_separator>
<<<sep_in_sample>>>
non_monotonic_error (void)
{
  fprintf (stderr, "%s: error: the abscissa values are not monotonic\n",
    progname);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
movq   %xmm0,-0x8(%rsp)
mov    -0x8(%rsp),%rax
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    %eax,-0x8(%rsp)
movss  -0x8(%rsp),%xmm2
shr    $0x20,%rax
mov    %eax,-0x8(%rsp)
movss  -0x8(%rsp),%xmm3
test   %r8,%r8
je     bf7 <gsl_vector_complex_float_scale+0x87>
shl    $0x3,%r9
mov    $0x0,%eax
mov    $0x0,%edx
mov    0x10(%rdi),%rsi
lea    (%rsi,%rax,1),%rcx
movss  (%rcx),%xmm1
movss  0x4(%rsi,%rax,1),%xmm0
movaps %xmm1,%xmm4
mulss  %xmm2,%xmm4
movaps %xmm0,%xmm5
mulss  %xmm3,%xmm5
subss  %xmm5,%xmm4
movss  %xmm4,(%rcx)
mov    0x10(%rdi),%rcx
mulss  %xmm3,%xmm1
mulss  %xmm2,%xmm0
addss  %xmm1,%xmm0
movss  %xmm0,0x4(%rcx,%rax,1)
add    $0x1,%rdx
add    %r9,%rax
cmp    %r8,%rdx
jne    bad <gsl_vector_complex_float_scale+0x3d>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_scale (gsl_vector_complex_float * a, const gsl_complex_float x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  float xr = ((x).dat[0]);
  float xi = ((x).dat[1]);
  for (i = 0; i < N; i++)
    {
      float ar = a->data[2 * i * stride];
      float ai = a->data[2 * i * stride + 1];
      a->data[2 * i * stride] = ar * xr - ai * xi;
      a->data[2 * i * stride + 1] = ar * xi + ai * xr;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 6
6 6
7 7
8 7
9 7
10 8
11 8
12 10
13 10
14 8
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 8
31 8
32 8
33 8
34 16
35 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    $0x1,%ecx
callq  3aec <gsl_fft_complex_radix2_inverse+0x17>
test   %eax,%eax
jne    3b5a <gsl_fft_complex_radix2_inverse+0x85>
test   %rbx,%rbx
js     3afc <gsl_fft_complex_radix2_inverse+0x27>
cvtsi2sd %rbx,%xmm1
jmp    3b14 <gsl_fft_complex_radix2_inverse+0x3f>
mov    %rbx,%rdx
shr    %rdx
mov    %rbx,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 3b1c <gsl_fft_complex_radix2_inverse+0x47>
divsd  %xmm1,%xmm0
test   %rbx,%rbx
je     3b5a <gsl_fft_complex_radix2_inverse+0x85>
mov    %r12,%rsi
shl    $0x4,%rsi
mov    %rbp,%rdi
mov    $0x0,%ecx
movapd %xmm0,%xmm1
mulsd  (%rdi),%xmm1
movsd  %xmm1,(%rdi)
movapd %xmm0,%xmm1
mulsd  0x8(%rdi),%xmm1
movsd  %xmm1,0x8(%rdi)
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    3b34 <gsl_fft_complex_radix2_inverse+0x5f>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_fft_complex_radix2_inverse (gsl_complex_packed_array data,
                                          const size_t stride, const size_t n)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_radix2_transform (data, stride, n, sign);
  if (status)
    {
      return status;
    }
  {
    const double norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((data)[2*(stride)*(i)]) *= norm;
        ((data)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 6
10 6
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 15
27 15
28 15
29 13
30 15
31 15
32 15
33 16
34 16
35 16
36 13
37 13
38 13
39 13
40 20
41 20
42 20
43 20
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rdx
mov    %rsi,%rbp
mov    (%rsi),%esi
test   %rdi,%rdi
je     2ff <extract_colon_unit+0x8d>
mov    %esi,%r12d
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %rcx,%r12
jae    306 <extract_colon_unit+0x94>
add    %rdx,%r12
movzbl (%r12),%eax
test   %al,%al
je     30d <extract_colon_unit+0x9b>
cmp    $0x3a,%al
je     2c9 <extract_colon_unit+0x57>
mov    %esi,%ebx
add    $0x1,%ebx
mov    %ebx,%eax
movzbl (%rdx,%rax,1),%eax
test   %al,%al
je     2cb <extract_colon_unit+0x59>
cmp    $0x3a,%al
jne    2b6 <extract_colon_unit+0x44>
jmp    2cb <extract_colon_unit+0x59>
mov    %esi,%ebx
mov    %ebx,%r14d
sub    %esi,%r14d
lea    0x1(%r14),%edi
callq  2da <extract_colon_unit+0x68>
mov    %rax,%r13
mov    %r14d,%r14d
mov    %r14,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  2ee <extract_colon_unit+0x7c>
movb   $0x0,0x0(%r13,%r14,1)
add    $0x1,%ebx
mov    %ebx,0x0(%rbp)
mov    %r13,%rax
jmp    312 <extract_colon_unit+0xa0>
mov    $0x0,%eax
jmp    312 <extract_colon_unit+0xa0>
mov    $0x0,%eax
jmp    312 <extract_colon_unit+0xa0>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
extract_colon_unit (char *string, int *idx)
{
  unsigned int i = (unsigned int) *idx;
  unsigned int start = i;
  if (!string || i >= strlen (string))
    return ((void *)0);
  if (!string[i])
    return ((void *)0);
  while (string[i] && string[i] != ":"[0])
    i++;
  {
    char *value = xmalloc ((i - start) + 1);
    strncpy (value, &string[start], (i - start));
    value[i - start] = 0;
    i++;
    *idx = i;
    return value;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 10
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 12
36 12
37 12
38 12
39 12
40 13
41 13
42 13
43 13
44 13
45 14
46 15
47 15
48 17
49 17
50 6
51 6
52 6
53 6
54 8
55 19
56 19
57 19
58 19
59 19
60 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    0x40(%rdi),%rax
cmp    %rax,0x38(%rdi)
jb     de <argp_fmtstream_putc+0x23>
mov    $0x1,%esi
callq  da <argp_fmtstream_putc+0x1f>
test   %eax,%eax
je     f3 <argp_fmtstream_putc+0x38>
mov    0x38(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x38(%rbx)
mov    %bpl,(%rax)
movsbl %bpl,%eax
jmp    f8 <argp_fmtstream_putc+0x3d>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)
{
  if (__fs->p < __fs->end || _argp_fmtstream_ensure (__fs, 1))
    return *__fs->p++ = __ch;
  else
    return (-1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4b <sdp_message_o_origin_set+0x28>
mov    %rsi,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rcx,0x18(%rdi)
mov    %r8,0x20(%rdi)
mov    %r9,0x28(%rdi)
mov    0x8(%rsp),%rax
mov    %rax,0x30(%rdi)
mov    $0x0,%eax
retq   
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
sdp_message_o_origin_set (sdp_message_t * sdp, char *username, char *sess_id, char *sess_version, char *nettype, char *addrtype, char *addr)
{
  if (sdp == ((void *)0))
    return -2;
  sdp->o_username = username;
  sdp->o_sess_id = sess_id;
  sdp->o_sess_version = sess_version;
  sdp->o_nettype = nettype;
  sdp->o_addrtype = addrtype;
  sdp->o_addr = addr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 7
6 8
7 9
8 10
9 10
10 11
11 11
12 4
13 12
<<<sep_out_sample>>>
cmp    %rsi,0x30(%rdi)
ja     413 <gl_array_nx_set_at+0xf>
sub    $0x8,%rsp
callq  413 <gl_array_nx_set_at+0xf>
mov    0x28(%rdi),%rax
mov    %rdx,(%rax,%rsi,8)
lea    0x1(%rsi),%rax
retq   
<<<sep_in_sample>>>
gl_array_nx_set_at (gl_list_t list, size_t position, const void *elt)
{
  size_t count = list->count;
  if (!(position < count))
    abort ();
  list->elements[position] = elt;
  return (gl_list_node_t)(unsigned long)(size_t)((position) + 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 6
6 6
7 7
8 8
<<<sep_out_sample>>>
mov    %esi,%edx
shr    $0x12,%edx
and    $0x3f,%edx
lea    0x0(%rip),%rax        # 1b8 <nettle_base64_encode_group+0xf>
movzbl (%rax,%rdx,1),%edx
mov    %dl,(%rdi)
mov    %esi,%edx
shr    $0xc,%edx
and    $0x3f,%edx
movzbl (%rax,%rdx,1),%edx
mov    %dl,0x1(%rdi)
mov    %esi,%edx
shr    $0x6,%edx
and    $0x3f,%edx
movzbl (%rax,%rdx,1),%edx
mov    %dl,0x2(%rdi)
and    $0x3f,%esi
movzbl (%rax,%rsi,1),%eax
mov    %al,0x3(%rdi)
retq   
<<<sep_in_sample>>>
nettle_base64_encode_group(uint8_t *dst, uint32_t group)
{
  *dst++ = ((base64_encode_table)[0x3F & ((group >> 18))]);
  *dst++ = ((base64_encode_table)[0x3F & ((group >> 12))]);
  *dst++ = ((base64_encode_table)[0x3F & ((group >> 6))]);
  *dst++ = ((base64_encode_table)[0x3F & (group)]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4c <incl_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
incl_free(void *data)
{
 grecs_free(data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0xc(%rdi),%edi
test   %edi,%edi
jne    21c <cplob_add_nta+0x38>
movl   $0x1,0xc(%rbx)
mov    %rbx,%rsi
mov    $0x9,%dil
callq  209 <cplob_add_nta+0x25>
movslq 0xc(%rbx),%rdx
mov    (%rbx),%rax
mov    %rbp,-0x8(%rax,%rdx,8)
test   %rbp,%rbp
jne    227 <cplob_add_nta+0x43>
jmp    243 <cplob_add_nta+0x5f>
add    $0x8,%edi
mov    %rbx,%rsi
callq  227 <cplob_add_nta+0x43>
movslq 0xc(%rbx),%rdx
mov    (%rbx),%rax
mov    %rbp,-0x8(%rax,%rdx,8)
mov    0xc(%rbx),%esi
mov    $0x0,%edx
mov    %rbx,%rdi
callq  243 <cplob_add_nta+0x5f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cplob_add_nta(CPLOB * lob, char *addr)
{
 if (!lob->nused){
  lob->nused++;
  cplob_reopen(lob->nused + 8, lob);
  *(lob->list + (lob->nused-1)) = addr;
  if (!addr){
   return;
  }
 } else {
  cplob_reopen(lob->nused + 8, lob);
 }
 *(lob->list + (lob->nused-1)) = addr;
 cplob_additem(lob, lob->nused, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 5
11 5
12 5
13 6
14 6
15 6
16 7
17 7
18 7
19 11
20 11
21 11
22 13
23 13
24 13
25 14
26 14
27 14
28 14
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
callq  1092 <internal_memalign>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
memalign (alignment, size)
     size_t alignment;
     size_t size;
{
  return internal_memalign (alignment, size, (char *)((void *)0), 0, 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%r14
mov    %rdx,%r15
mov    (%rdx),%r13d
test   %r13d,%r13d
jle    1c6e <levn+0x53>
mov    (%rsi),%rsi
cmpb   $0x0,(%rsi)
je     1c75 <levn+0x5a>
lea    0x8(%r14),%rbp
mov    $0x0,%ebx
mov    %r12,%rdi
callq  1c53 <levn+0x38>
test   %eax,%eax
je     1cc8 <levn+0xad>
add    $0x1,%ebx
cmp    %r13d,%ebx
je     1c7a <levn+0x5f>
mov    0x0(%rbp),%rsi
add    $0x8,%rbp
cmpb   $0x0,(%rsi)
jne    1c4b <levn+0x30>
jmp    1c7a <levn+0x5f>
mov    $0x0,%ebx
jmp    1c7a <levn+0x5f>
mov    $0x0,%ebx
mov    0x0(%rip),%eax        # 1c80 <levn+0x65>
sub    $0x1,%eax
cmp    %ebx,%eax
jle    1ca5 <levn+0x8a>
movslq %ebx,%rax
mov    (%r14,%rax,8),%rdi
mov    %r12,%rsi
callq  1c96 <levn+0x7b>
mov    (%r15),%eax
cmp    %ebx,%eax
jg     1cca <levn+0xaf>
lea    0x1(%rax),%edx
mov    %edx,(%r15)
jmp    1cca <levn+0xaf>
mov    %r12,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1cb4 <levn+0x99>
mov    $0x0,%eax
callq  1cbe <levn+0xa3>
mov    $0x1,%edi
callq  1cc8 <levn+0xad>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
levn(char *levstr, char **levval, int *nlevels)
{
  int l;
  for (l = 0; l < *nlevels && levval[l][0]; l++)
    {
      if (!strcmp(levstr, levval[l]))
 return l;
    }
  if (l < dap_maxlev - 1)
    {
      strcpy(levval[l], levstr);
      if (l < *nlevels)
 return *nlevels;
      else
 return (*nlevels)++;
    }
  else
    {
      fprintf(dap_err, "(levn) too many levels: %s\n", levstr);
      exit(1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 9
35 9
36 9
37 9
38 11
39 11
40 11
41 11
42 12
43 12
44 12
45 15
46 15
47 15
48 19
49 19
50 19
51 19
52 19
53 20
54 20
55 20
56 22
57 22
58 22
59 22
60 22
61 22
62 22
63 22
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <newlabel+0x6>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # f <newlabel+0xf>
retq   
<<<sep_in_sample>>>
newlabel (void )
{
  return (lediglabel++);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 265 <CDB___os_freestr+0xb>
test   %rax,%rax
je     26e <CDB___os_freestr+0x14>
callq  *%rax
jmp    275 <CDB___os_freestr+0x1b>
xchg   %ax,%ax
callq  275 <CDB___os_freestr+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___os_freestr(ptr)
 void *ptr;
{
 if (CDB___db_jump.j_free != ((void *)0))
  CDB___db_jump.j_free(ptr);
 else
  free(ptr);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
7 5
8 7
9 8
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3749 <info_toggle_wrap+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_toggle_wrap (WINDOW *window, int count)
{
  window_toggle_wrap (window);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm3        # ab <gsl_complex_logabs+0xc>
movapd %xmm0,%xmm2
andpd  %xmm3,%xmm2
andpd  %xmm1,%xmm3
movapd %xmm3,%xmm0
ucomisd %xmm0,%xmm2
jb     d0 <gsl_complex_logabs+0x31>
divsd  %xmm2,%xmm0
movsd  %xmm0,(%rsp)
movapd %xmm2,%xmm0
jmp    d9 <gsl_complex_logabs+0x3a>
divsd  %xmm0,%xmm2
movsd  %xmm2,(%rsp)
callq  de <gsl_complex_logabs+0x3f>
movsd  %xmm0,0x8(%rsp)
movsd  (%rsp),%xmm5
movapd %xmm5,%xmm4
mulsd  %xmm5,%xmm4
movapd %xmm4,%xmm0
callq  fa <gsl_complex_logabs+0x5b>
mulsd  0x0(%rip),%xmm0        # 102 <gsl_complex_logabs+0x63>
addsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_logabs (gsl_complex z)
{
  double xabs = fabs (((z).dat[0]));
  double yabs = fabs (((z).dat[1]));
  double max, u;
  if (xabs >= yabs)
    {
      max = xabs;
      u = yabs / xabs;
    }
  else
    {
      max = yabs;
      u = xabs / yabs;
    }
  return log (max) + 0.5 * log1p (u * u);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 6
9 9
10 9
11 8
12 8
13 14
14 14
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 17
25 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    $0x18,%edi
callq  14 <tag_found_keyword+0x14>
mov    %rax,%rbx
movq   $0x0,(%rax)
mov    $0x0,%esi
mov    %r12,%rdi
callq  2b <tag_found_keyword+0x2b>
mov    (%r12),%rax
cmp    %rax,0x0(%rbp)
je     39 <tag_found_keyword+0x39>
mov    %rax,0x0(%rbp)
mov    0x0(%rbp),%rdi
callq  42 <tag_found_keyword+0x42>
mov    %rax,0x8(%rbx)
mov    0x0(%rbp),%rdx
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rdx,%rcx,1),%rdi
callq  67 <tag_found_keyword+0x67>
mov    %rax,0x10(%rbx)
movq   $0x0,0x10(%r12)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
tag_found_keyword (struct text_buffer *tmpbuf_ptr, char **kw)
{
  struct info_tag *tag = xmalloc (sizeof (*tag));
  tag->next = ((void *)0);
  text_buffer_add_char (tmpbuf_ptr, 0);
  if (*kw != tmpbuf_ptr->base) {
    *kw = tmpbuf_ptr->base;
  }
  tag->kw = xstrdup (*kw);
  tag->val = xstrdup (*kw + strlen(*kw) + 1);
  ((tmpbuf_ptr)->off = 0);
  return tag;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 5
11 5
12 5
13 6
14 6
15 6
16 7
17 9
18 9
19 9
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 11
30 13
31 13
32 13
33 13
34 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
movq   $0x1,(%rdi)
movq   $0x1,0x8(%rdi)
mov    $0x8,%edi
callq  11e1 <re_node_set_init_1+0x25>
mov    %rax,0x10(%rbx)
test   %rax,%rax
jne    11fd <re_node_set_init_1+0x41>
movq   $0x0,0x8(%rbx)
movq   $0x0,(%rbx)
mov    $0xc,%al
jmp    1205 <re_node_set_init_1+0x49>
mov    %rbp,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
re_node_set_init_1 (re_node_set *set, Idx elem)
{
  set->alloc = 1;
  set->nelem = 1;
  set->elems = ((Idx *) malloc ((1) * sizeof (Idx)));
  if (__builtin_expect (set->elems == ((void *)0), 0))
    {
      set->alloc = set->nelem = 0;
      return _REG_ESPACE;
    }
  set->elems[0] = elem;
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 6
12 6
13 8
14 8
15 9
16 9
17 11
18 12
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x18,%esi
mov    $0x1,%edi
callq  13 <_gsasl_login_server_start+0x13>
mov    $0x7,%edx
test   %rax,%rax
je     22 <_gsasl_login_server_start+0x22>
mov    %rax,(%rbx)
mov    $0x0,%dl
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_gsasl_login_server_start (Gsasl_session * sctx, void **mech_data)
{
  struct _Gsasl_login_server_state *state;
  state = calloc (1, sizeof (*state));
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 5
8 5
9 7
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
callq  *0x38(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_oset_iterator (gl_oset_t set)
{
  return ((const struct gl_oset_impl_base *) set)->vtable->iterator (set);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
cvtsi2sdq (%rdi),%xmm1
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm2
mulsd  %xmm1,%xmm2
movsd  %xmm2,-0x20(%rsp)
fldl   -0x20(%rsp)
cmp    $0x1,%rdx
jbe    3f4 <gsl_stats_long_lag1_autocorrelation_m+0x93>
shl    $0x3,%rsi
mov    %rdi,%rcx
add    %rsi,%rdi
fldz   
mov    $0x1,%eax
flds   0x0(%rip)        # 399 <gsl_stats_long_lag1_autocorrelation_m+0x38>
cvtsi2sdq (%rdi),%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    3c0 <gsl_stats_long_lag1_autocorrelation_m+0x5f>
fadd   %st(2),%st
cvtsi2sdq (%rcx),%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fld    %st(1)
fmull  -0x20(%rsp)
fsub   %st(4),%st
fdiv   %st(1),%st
faddp  %st,%st(4)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(4),%st
fdivp  %st,%st(1)
faddp  %st,%st(3)
add    %rsi,%rcx
add    %rsi,%rdi
cmp    %rdx,%rax
jne    399 <gsl_stats_long_lag1_autocorrelation_m+0x38>
fstp   %st(0)
jmp    3f6 <gsl_stats_long_lag1_autocorrelation_m+0x95>
fldz   
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_long_lag1_autocorrelation_m (const long data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 7
8 7
9 10
10 10
11 10
12 5
13 7
14 11
15 10
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 12
40 7
41 7
42 7
43 7
44 5
45 14
46 15
47 15
48 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
push   %rbx
cmp    $0x20,%rsi
jbe    607 <nettle_sha512_256_digest+0x26>
lea    0x0(%rip),%rcx        # 5ef <nettle_sha512_256_digest+0xe>
mov    $0x135,%edx
lea    0x0(%rip),%rsi        # 5fb <nettle_sha512_256_digest+0x1a>
lea    0x0(%rip),%rdi        # 602 <nettle_sha512_256_digest+0x21>
callq  607 <nettle_sha512_256_digest+0x26>
mov    %rdi,%rbx
callq  0 <sha512_write_digest>
mov    %rbx,%rdi
callq  617 <nettle_sha512_256_digest+0x36>
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_sha512_256_digest(struct sha512_ctx *ctx,
       size_t length,
       uint8_t *digest)
{
  ((length <= 32) ? (void) (0) : __assert_fail ("length <= 32", "sha512.c", 309, __PRETTY_FUNCTION__));
  sha512_write_digest(ctx, length, digest);
  nettle_sha512_256_init(ctx);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%ebx
movl   $0x0,0xc(%rsp)
mov    $0x200,%edi
callq  3dc <_rl_insert_typein+0x1a>
mov    %rax,%rbp
mov    %bl,(%rax)
mov    $0x1,%ebx
jmp    3f3 <_rl_insert_typein+0x31>
movslq %ebx,%rax
mov    %dil,0x0(%rbp,%rax,1)
lea    0x1(%rbx),%ebx
lea    0xc(%rsp),%rdi
callq  20 <rl_get_char>
test   %eax,%eax
je     427 <_rl_insert_typein+0x65>
mov    0xc(%rsp),%edi
movslq %edi,%rcx
shl    $0x4,%rcx
add    0x0(%rip),%rcx        # 413 <_rl_insert_typein+0x51>
cmpb   $0x0,(%rcx)
jne    422 <_rl_insert_typein+0x60>
cmpq   $0x0,0x8(%rcx)
je     3e8 <_rl_insert_typein+0x26>
callq  427 <_rl_insert_typein+0x65>
movslq %ebx,%rbx
movb   $0x0,0x0(%rbp,%rbx,1)
mov    %rbp,%rdi
callq  437 <_rl_insert_typein+0x75>
mov    %rbp,%rdi
callq  43f <_rl_insert_typein+0x7d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_insert_typein (c)
     int c;
{
  int key, t, i;
  char *string;
  i = key = 0;
  string = (char *)xmalloc (ibuffer_len + 1);
  string[i++] = (char) c;
  while ((t = rl_get_char (&key)) &&
  _rl_keymap[key].type == 0 &&
  _rl_keymap[key].function == rl_insert)
    string[i++] = key;
  if (t)
    _rl_unget_char (key);
  string[i] = '\0';
  rl_insert_text (string);
  xfree (string);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 7
7 7
8 7
9 8
10 8
11 9
12 12
13 12
14 12
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 9
24 9
25 10
26 10
27 14
28 15
29 15
30 16
31 16
32 17
33 17
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     42bc <gsl_fft_complex_workspace_float_free+0x22>
mov    0x8(%rdi),%rdi
callq  42ac <gsl_fft_complex_workspace_float_free+0x12>
movq   $0x0,0x8(%rbx)
mov    %rbx,%rdi
callq  42bc <gsl_fft_complex_workspace_float_free+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_fft_complex_workspace_float_free (gsl_fft_complex_workspace_float * workspace)
{
  if (!workspace) { return ; };
  free (workspace->scratch);
  workspace->scratch = ((void *)0);
  free (workspace) ;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  e1 <grecs_strdup+0x1d>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  ec <grecs_strdup+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_strdup(const char *str)
{
 char *newstr = grecs_malloc(strlen(str) + 1);
 return strcpy(newstr, str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     17e3 <gsl_matrix_uint_isnull+0x63>
lea    0x0(,%rax,4),%r11
mov    $0x0,%r8d
mov    $0x0,%r10d
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
jmp    17dc <gsl_matrix_uint_isnull+0x5c>
mov    $0x0,%eax
mov    %r8,%rsi
add    0x18(%rdi),%rsi
mov    (%rsi,%rax,4),%edx
cvtsi2sd %rdx,%xmm0
ucomisd %xmm1,%xmm0
jp     17e9 <gsl_matrix_uint_isnull+0x69>
ucomisd %xmm2,%xmm0
je     17f7 <gsl_matrix_uint_isnull+0x77>
jmp    17e9 <gsl_matrix_uint_isnull+0x69>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
je     17f1 <gsl_matrix_uint_isnull+0x71>
test   %rcx,%rcx
jne    17ae <gsl_matrix_uint_isnull+0x2e>
jmp    17d0 <gsl_matrix_uint_isnull+0x50>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
xchg   %ax,%ax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rcx,%rax
jne    17ba <gsl_matrix_uint_isnull+0x3a>
jmp    17d0 <gsl_matrix_uint_isnull+0x50>
<<<sep_in_sample>>>
gsl_matrix_uint_isnull (const gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 20
30 20
31 15
32 15
33 15
34 20
35 20
36 9
37 9
38 9
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r12d
mov    %edx,%r9d
mov    $0x28,%r8d
mov    %esi,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xb7,(%rax)
mov    $0x0,%r9d
mov    $0x28,%r8d
mov    %r12d,%ecx
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  22b7 <_rx>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_ldr_us(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    _rex(_jit, 0, 1, r0, _NOREG, r1);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = 0xb7;
    _rx(_jit, r0, 0, r1, _NOREG, 0x00);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 7
29 7
30 7
31 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %r8,%r14
callq  a6 <gsl_stats_long_double_wkurtosis+0x22>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r15
mov    %r14,%r8
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  c5 <gsl_stats_long_double_wkurtosis+0x41>
movapd %xmm0,%xmm1
mov    %r15,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r14,%r8
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  e8 <gsl_stats_long_double_wkurtosis+0x64>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_wkurtosis (const long double w[], const size_t wstride, const long double data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_long_double_wmean(w, wstride, data, stride, n);
  const double wsd = gsl_stats_long_double_wsd_m(w, wstride, data, stride, n, wmean);
  return gsl_stats_long_double_wkurtosis_m_sd(w, wstride, data, stride, n, wmean, wsd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
callq  b8 <gsl_block_complex_long_double_calloc+0xe>
mov    %rax,%rbx
test   %rax,%rax
je     100 <gsl_block_complex_long_double_calloc+0x56>
mov    %rbp,%rdx
shl    $0x5,%rdx
mov    0x8(%rax),%rdi
mov    $0x0,%esi
callq  d5 <gsl_block_complex_long_double_calloc+0x2b>
mov    %rbp,%rdi
add    %rdi,%rdi
je     107 <gsl_block_complex_long_double_calloc+0x5d>
mov    $0x0,%edx
fldz   
mov    %rdx,%rcx
shl    $0x4,%rcx
add    0x8(%rbx),%rcx
fstpt  (%rcx)
fldt   (%rcx)
add    $0x1,%rdx
cmp    %rdi,%rdx
jne    e4 <gsl_block_complex_long_double_calloc+0x3a>
fstp   %st(0)
jmp    10c <gsl_block_complex_long_double_calloc+0x62>
mov    $0x0,%eax
jmp    10f <gsl_block_complex_long_double_calloc+0x65>
mov    %rbx,%rax
jmp    10f <gsl_block_complex_long_double_calloc+0x65>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_block_complex_long_double_calloc (const size_t n)
{
  size_t i;
  gsl_block_complex_long_double * b = gsl_block_complex_long_double_alloc (n);
  if (b == 0)
    return 0;
  memset(b->data, 0, 2 * n * sizeof(long double));
  for (i = 0; i < 2 * n; i++)
    {
      b->data[i] = 0;
    }
  return b;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 8
25 8
26 8
27 8
28 8
29 6
30 6
31 12
32 12
33 12
34 13
35 13
36 13
37 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebp
mov    %rdx,%rbx
mov    0x30(%rdx),%rsi
callq  180 <gsl_eigen_nonsymm_params+0x14>
mov    %ebp,0x20(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_eigen_nonsymm_params (const int compute_t, const int balance,
                          gsl_eigen_nonsymm_workspace *w)
{
  gsl_eigen_francis_T(compute_t, w->francis_workspace_p);
  w->do_balance = balance;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 6
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsp,%rdi
movsd  (%rbx),%xmm0
callq  14c8 <gsl_sf_angle_restrict_symm_e+0x14>
movsd  (%rsp),%xmm0
movsd  %xmm0,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sf_angle_restrict_symm_e(double * theta)
{
  gsl_sf_result r;
  int stat = gsl_sf_angle_restrict_symm_err_e(*theta, &r);
  *theta = r.val;
  return stat;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  153f <quotearg_custom+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom (char const *left_quote, char const *right_quote,
                 char const *arg)
{
  return quotearg_n_custom (0, left_quote, right_quote, arg);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%eax
mov    0x0(,%rax,8),%rdi
callq  c4 <echo_descr+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
echo_descr(dico_handle_t hp)
{
    struct echo_handle *ep = (struct echo_handle*)hp;
    static char *echo_descr_str[2] = {
 "GNU Dico ECHO database",
 "GNU Dico NULL database"
    };
    return strdup(echo_descr_str[ep->mode]);
}
<<<sep_in_sample>>>
1 2
2 8
3 8
4 8
5 9
6 9
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2677 <php_set_debug+0x6>
retq   
<<<sep_in_sample>>>
php_set_debug (int bdebug )
{
        php__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 22f <echo_area_initialize_node+0xa>
cmp    $0x100,%eax
ja     24a <echo_area_initialize_node+0x25>
movslq %eax,%rdx
movb   $0x20,0x0(%rdx)
add    $0x1,%eax
cmp    $0x100,%eax
jbe    236 <echo_area_initialize_node+0x11>
sub    $0x1,%eax
cltq   
movb   $0xa,0x0(%rax)
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 262 <echo_area_initialize_node+0x3d>
callq  267 <echo_area_initialize_node+0x42>
movslq 0x0(%rip),%rax        # 26e <echo_area_initialize_node+0x49>
movb   $0xa,0x0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
echo_area_initialize_node (void)
{
  register int i;
  for (i = input_line_end; (unsigned int) i < sizeof (input_line); i++)
    input_line[i] = ' ';
  input_line[i - 1] = '\n';
  window_set_node_of_window (the_echo_area, &input_line_node);
  input_line[input_line_end] = '\n';
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 4
8 4
9 4
10 6
11 6
12 6
13 7
14 7
15 7
16 8
17 8
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x2,%edx
mov    0x0(%rip),%rsi        # c28 <pred_writable+0x15>
mov    0x0(%rip),%edi        # c2e <pred_writable+0x1b>
callq  c33 <pred_writable+0x20>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pred_writable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  (void) stat_buf;
  (void) pred_ptr;
  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, 2, 0);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
callq  0 <expint_E1_impl>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expint_E1_scaled_e(const double x, gsl_sf_result * result)
{
  return expint_E1_impl(x, result, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r11
test   %r9,%r9
je     225a <gsl_matrix_uchar_ispos+0x52>
mov    $0x0,%ecx
mov    $0x0,%r10d
xorpd  %xmm1,%xmm1
jmp    2253 <gsl_matrix_uchar_ispos+0x4b>
mov    0x18(%rdi),%rdx
lea    (%rdx,%rcx,1),%rax
add    %rsi,%rdx
lea    (%rdx,%rcx,1),%r8
movzbl (%rax),%edx
cvtsi2sd %edx,%xmm0
ucomisd %xmm0,%xmm1
jb     226d <gsl_matrix_uchar_ispos+0x65>
jmp    2261 <gsl_matrix_uchar_ispos+0x59>
add    $0x1,%r10
add    %r11,%rcx
cmp    %r9,%r10
je     2267 <gsl_matrix_uchar_ispos+0x5f>
test   %rsi,%rsi
jne    2229 <gsl_matrix_uchar_ispos+0x21>
jmp    2247 <gsl_matrix_uchar_ispos+0x3f>
mov    $0x1,%eax
nop
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %r8,%rax
jne    2238 <gsl_matrix_uchar_ispos+0x30>
jmp    2247 <gsl_matrix_uchar_ispos+0x3f>
<<<sep_in_sample>>>
gsl_matrix_uchar_ispos (const gsl_matrix_uchar * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 13
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 20
27 20
28 20
29 15
30 15
31 20
32 20
33 20
34 9
35 9
36 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    $0xfa,%edi
mov    $0x0,%eax
callq  716 <ack+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ack (const char *s)
{
  reply (250, "%s command successful.", s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  141d <findEntry>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
headerIsEntry(Header h, int_32 tag)
{
    return (findEntry(h, tag, 0) ? 1 : 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x58,%rsp
mov    %rsi,%r15
mov    %rdx,(%rsp)
mov    %rcx,0x8(%rsp)
test   %rsi,%rsi
je     af <nettle_chacha_crypt+0xaf>
mov    %rdi,%rbx
mov    %rcx,%r13
mov    %rdx,%r12
mov    %rsi,%rbp
lea    0x10(%rsp),%r14
mov    $0x14,%edx
mov    %rbx,%rsi
mov    %r14,%rdi
callq  44 <nettle_chacha_crypt+0x44>
mov    0x30(%rbx),%eax
add    $0x1,%eax
mov    %eax,0x30(%rbx)
test   %eax,%eax
sete   %al
movzbl %al,%eax
add    0x34(%rbx),%eax
mov    %eax,0x34(%rbx)
cmp    $0x40,%rbp
ja     8e <nettle_chacha_crypt+0x8e>
lea    -0x1(%r15),%rax
shr    $0x6,%rax
mov    %rax,%rdi
shl    $0x6,%rdi
mov    %r15,%rcx
sub    %rdi,%rcx
lea    0x10(%rsp),%rdx
mov    0x8(%rsp),%rsi
add    %rdi,%rsi
add    (%rsp),%rdi
callq  8c <nettle_chacha_crypt+0x8c>
jmp    af <nettle_chacha_crypt+0xaf>
mov    $0x40,%ecx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  a1 <nettle_chacha_crypt+0xa1>
sub    $0x40,%rbp
add    $0x40,%r12
add    $0x40,%r13
jmp    34 <nettle_chacha_crypt+0x34>
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
nettle_chacha_crypt(struct chacha_ctx *ctx,
       size_t length,
       uint8_t *c,
       const uint8_t *m)
{
  if (!length)
    return;
  for (;;)
    {
      uint32_t x[16];
      _nettle_chacha_core (x, ctx->state, 20);
      ctx->state[13] += (++ctx->state[12] == 0);
      if (length <= 64)
 {
   nettle_memxor3 (c, m, x, length);
   return;
 }
      nettle_memxor3 (c, m, x, 64);
      length -= 64;
      c += 64;
      m += 64;
  }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 11
18 11
19 11
20 11
21 11
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 15
39 15
40 15
41 15
42 15
43 15
44 18
45 18
46 18
47 18
48 18
49 19
50 20
51 21
52 22
53 23
54 23
55 23
56 23
57 23
58 23
59 23
60 23
<<<sep_out_sample>>>
mov    0x20(%rdi),%eax
sub    $0x1,%eax
mov    %eax,0x20(%rdi)
test   %eax,%eax
jne    1d6 <mu_secret_password_unref+0x2a>
sub    $0x8,%rsp
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  1d2 <mu_secret_password_unref+0x26>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_secret_password_unref (mu_secret_t sec)
{
  if (--sec->clref == 0)
    memset (sec->clptr, 0, sec->length);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  29 <direntry_cmp_name+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 7 <shell_version_string+0x7>
jne    49 <shell_version_string+0x49>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    $0x1,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x20,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3f <shell_version_string+0x3f>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
shell_version_string ()
{
  static char tt[32] = { '\0' };
  if (tt[0] == '\0')
    {
      if (release_status)
 snprintf (tt, sizeof (tt), "%s.%d(%d)-%s", dist_version, patch_level, build_version, release_status);
      else
 snprintf (tt, sizeof (tt), "%s.%d(%d)", dist_version, patch_level, build_version);
    }
  return tt;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 12
14 12
15 12
16 12
17 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
callq  a1f <grecs_print_locus+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_locus(grecs_locus_t *locus, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_locus(locus, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rax
mov    (%rax),%rdi
callq  29 <_PySelectionKey_str+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_PySelectionKey_str (PyObject *self)
{
    PySelectionKey *py_key = (PySelectionKey *)self;
    return PyString_FromString (py_key->key->word);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # 88f <grecs_grecs_wrap+0xc>
je     8aa <grecs_grecs_wrap+0x27>
mov    0x0(%rip),%edi        # 897 <grecs_grecs_wrap+0x14>
callq  89c <grecs_grecs_wrap+0x19>
mov    0x0(%rip),%rdi        # 8a3 <grecs_grecs_wrap+0x20>
callq  8a8 <grecs_grecs_wrap+0x25>
jmp    8af <grecs_grecs_wrap+0x2c>
callq  8af <grecs_grecs_wrap+0x2c>
movq   $0x0,0x0(%rip)        # 8ba <grecs_grecs_wrap+0x37>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_grecs_wrap()
{
 if (grecs_preprocessor) {
  grecs_preproc_extrn_shutdown(grecs_preproc_pid);
  fclose(grecs_grecs_in);
 } else
  grecs_preproc_done();
 grecs_current_locus_point.file = ((void *)0);
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 7
10 8
11 10
12 10
13 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1944 <osip_message_get__property+0xc>
mov    0x1a0(%rdi),%eax
retq   
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
osip_message_get__property (const osip_message_t * sip)
{
  if (sip == ((void *)0))
    return -2;
  return sip->message_property;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %rdx,%r13
mov    0xe8(%rdi),%rbp
callq  166a <CDB___ham_item_first+0x1d>
mov    %eax,%ecx
test   %ecx,%ecx
jne    16a4 <CDB___ham_item_first+0x57>
orl    $0x100,0x70(%rbp)
movl   $0x0,0x58(%rbp)
mov    0x48(%rbp),%r14
mov    $0x1,%edi
callq  168c <CDB___ham_item_first+0x3f>
mov    %eax,%eax
mov    0x60(%r14,%rax,4),%eax
mov    %eax,0x14(%rbp)
mov    %r13,%rdx
mov    %r12d,%esi
mov    %rbx,%rdi
callq  16a4 <CDB___ham_item_first+0x57>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
CDB___ham_item_first(dbc, mode, pgnop)
 DBC *dbc;
 db_lockmode_t mode;
 db_pgno_t *pgnop;
{
 HASH_CURSOR *hcp;
 int ret;
 hcp = (HASH_CURSOR *)dbc->internal;
 if ((ret = CDB___ham_item_reset(dbc)) != 0)
  return (ret);
 (hcp)->flags |= (0x0100);
 hcp->bucket = 0;
 hcp->pgno = ((hcp->bucket) + (hcp)->hdr->spares[CDB___db_log2((hcp->bucket)+1)]);
 return (CDB___ham_item_next(dbc, mode, pgnop));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 8
10 9
11 9
12 9
13 9
14 11
15 12
16 13
17 13
18 13
19 13
20 13
21 13
22 14
23 14
24 14
25 14
26 15
27 15
28 15
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    0x70(%rdi),%rax
mov    %rsi,%rdx
test   %rsi,%rsi
jg     22 <__rplinesperpage+0x22>
test   %rsi,%rsi
mov    $0x3c,%ecx
movabs $0x7fffffffffffffff,%rdx
cmovns %rcx,%rdx
mov    %rdx,0x70(%rdi)
retq   
<<<sep_in_sample>>>
__rplinesperpage (__bs6FILE *p, long n)
{
  long i;
  i = p->lines_per_page;
  p->lines_per_page = (n > 0) ? n : (n < 0) ? (~(1L<<63)) : 60;
  return (i);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     af <panic+0x5f>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    0x0(%rip),%rdx        # b9 <panic+0x69>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # c5 <panic+0x75>
mov    $0x0,%eax
callq  cf <panic+0x7f>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 105 <panic+0xb5>
callq  10a <panic+0xba>
mov    0x0(%rip),%rsi        # 111 <panic+0xc1>
mov    $0xa,%edi
callq  11b <panic+0xcb>
mov    0x0(%rip),%rax        # 122 <panic+0xd2>
test   %rax,%rax
je     1a0 <panic+0x150>
testb  $0x1,0x18(%rax)
je     189 <panic+0x139>
mov    (%rax),%rdi
callq  135 <panic+0xe5>
callq  13a <panic+0xea>
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    0x0(%rip),%rbp        # 14a <panic+0xfa>
mov    0x8(%rbp),%rdi
callq  153 <panic+0x103>
mov    (%rbx),%edi
test   %edi,%edi
je     189 <panic+0x139>
callq  15e <panic+0x10e>
mov    %rax,%r12
mov    0x8(%rbp),%rbx
mov    $0x0,%edi
callq  16f <panic+0x11f>
mov    %r12,%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 17f <panic+0x12f>
mov    $0x0,%eax
callq  189 <panic+0x139>
mov    0x0(%rip),%rax        # 190 <panic+0x140>
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # 19b <panic+0x14b>
test   %rax,%rax
jne    127 <panic+0xd7>
mov    $0x4,%edi
callq  1aa <ck_fwrite>
<<<sep_in_sample>>>
panic(const char *str, ...)
{
  va_list ap;
  fprintf(stderr, "%s: ", myname);
  __builtin_va_start(ap,str);
  vfprintf(stderr, str, ap);
  __builtin_va_end(ap);
  _IO_putc ('\n', stderr);
  while (open_files)
    {
      if (open_files->temp)
 {
   fclose (open_files->fp);
   (*__errno_location ()) = 0;
   unlink (open_files->name);
          if ((*__errno_location ()) != 0)
            fprintf (stderr, gettext("cannot remove %s: %s"), open_files->name, strerror ((*__errno_location ())));
 }
      open_files = open_files->link;
    }
  exit(4);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 5
31 5
32 6
33 6
34 6
35 6
36 8
37 8
38 8
39 9
40 9
41 9
42 11
43 11
44 13
45 13
46 14
47 14
48 14
49 15
50 15
51 15
52 16
53 16
54 16
55 17
56 17
57 17
58 17
59 17
60 17
61 17
62 17
63 17
64 17
65 17
66 19
67 19
68 19
69 9
70 9
71 21
72 21
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
test   %rax,%rax
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
<<<sep_in_sample>>>
rec_field_location_str (rec_field_t field)
{
  char *res;
  if (field->location_str)
    {
      res = field->location_str;
    }
  else
    {
      res = "";
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 4
3 10
4 10
5 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xd0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->sortedlist_indexof (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%edi        # 540 <optionl_stat+0x12>
cmp    $0xffffff9c,%edi
je     562 <optionl_stat+0x34>
test   %edi,%edi
jns    562 <optionl_stat+0x34>
mov    $0x0,%ecx
mov    $0x277,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  562 <optionl_stat+0x34>
mov    $0x0,%ecx
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  572 <optionl_stat+0x44>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
je     588 <optionl_stat+0x5a>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  17c <fallback_stat>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
optionl_stat(const char *name, struct stat *p)
{
  int rv;
  if (-100 != state.cwd_dir_fd)
    ((state.cwd_dir_fd >= 0) ? (void) (0) : __assert_fail ("state.cwd_dir_fd >= 0", "util.c", 631, __PRETTY_FUNCTION__));
  set_stat_placeholders (p);
  rv = fstatat (state.cwd_dir_fd, name, p, 0);
  if (0 == rv)
    return 0;
  else
    return fallback_stat (name, p, rv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 9
22 8
23 8
24 11
25 11
26 11
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
mov    $0x1009,%eax
test   %rdi,%rdi
je     bc3 <mu_locker_set_retry_sleep+0x17>
mov    $0x16,%ax
test   %esi,%esi
jle    bc3 <mu_locker_set_retry_sleep+0x17>
mov    %esi,0x1c(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_locker_set_retry_sleep (mu_locker_t locker, int retry_sleep)
{
  if (!locker)
    return (0x1000 +9);
  if (retry_sleep <= 0)
    return 22;
  locker->retry_sleep = retry_sleep;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 8
9 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%edx
callq  1ca <grecs_sockaddr_eq+0xe>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_sockaddr_eq (const void *elt1, const void *elt2) { return memcmp (elt1, elt2, sizeof (struct grecs_sockaddr)) == 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    %rsi,%r8
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
cmp    $0x2,%eax
jle    14a <suffix+0x58>
movslq %eax,%rcx
lea    -0x2(%rdx,%rcx,1),%r9
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %r9,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    14a <suffix+0x58>
movb   $0x0,(%r9)
mov    %r8,%rsi
mov    %rdx,%rdi
callq  148 <suffix+0x56>
jmp    1a1 <suffix+0xaf>
cmp    $0x4,%eax
jle    181 <suffix+0x8f>
cltq   
lea    -0x4(%rdx,%rax,1),%rax
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    181 <suffix+0x8f>
movb   $0x0,(%rax)
mov    %r8,%rsi
mov    %rdx,%rdi
callq  17f <suffix+0x8d>
jmp    1a1 <suffix+0xaf>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 18d <suffix+0x9b>
mov    $0x0,%eax
callq  197 <suffix+0xa5>
mov    $0x1,%edi
callq  1a1 <suffix+0xaf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
suffix(char name[], char suff[])
{
  int n;
  n = strlen(name);
  if (n > 2 && !strcmp(name + n - 2, ".c"))
    {
      name[n - 2] = '\0';
      strcat(name, suff);
    }
  else if (n > 4 && !strcmp(name + n - 4, ".sbs"))
    {
      name[n - 4] = '\0';
      strcat(name, suff);
    }
  else
    {
      fprintf(stderr, "dap: name must end in .c or .sbs: %s\n", name);
      exit(1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 12
39 13
40 13
41 13
42 13
43 17
44 17
45 17
46 17
47 18
48 18
49 20
50 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 8ef <current_block_ordinal+0x7>
sub    0x0(%rip),%rax        # 8f6 <current_block_ordinal+0xe>
sar    $0x9,%rax
add    0x0(%rip),%rax        # 901 <current_block_ordinal+0x19>
retq   
<<<sep_in_sample>>>
current_block_ordinal (void)
{
  return record_start_block + (current_block - record_start);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdi,%rsi
mov    %r12,%rdi
callq  1b <link_to_name+0x1b>
mov    %eax,%ebx
test   %eax,%eax
jns    3f <link_to_name+0x3f>
cmpl   $0x0,0x0(%rip)        # 28 <link_to_name+0x28>
je     3f <link_to_name+0x3f>
mov    %rbp,%rdi
callq  32 <link_to_name+0x32>
mov    %rbp,%rsi
mov    %r12,%rdi
callq  3d <link_to_name+0x3d>
mov    %eax,%ebx
test   %ebx,%ebx
jne    75 <link_to_name+0x75>
cmpl   $0x0,0x0(%rip)        # 4a <link_to_name+0x4a>
je     aa <link_to_name+0xaa>
mov    $0x0,%edi
callq  56 <link_to_name+0x56>
mov    %rbp,%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  73 <link_to_name+0x73>
jmp    aa <link_to_name+0xaa>
cmpl   $0x0,0x0(%rip)        # 7c <link_to_name+0x7c>
je     aa <link_to_name+0xaa>
mov    $0x0,%edi
callq  88 <link_to_name+0x88>
mov    %rax,%r13
callq  90 <link_to_name+0x90>
mov    %rbp,%r8
mov    %r12,%rcx
mov    %r13,%rdx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  aa <link_to_name+0xaa>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
link_to_name (char *link_name, char *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
 error (0, 0, gettext ("%s linked to %s"),
        link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, (*__errno_location ()), gettext ("cannot link %s to %s"),
      link_target, link_name);
    }
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 11
25 11
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 15
37 15
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 17
46 17
47 17
48 17
49 21
50 21
51 21
52 21
53 21
54 21
55 21
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    $0x1,%esi
mov    $0x0,%edi
callq  5722 <close_all+0x14>
lea    0xf(%rsp),%rdi
callq  572c <close_all+0x1e>
mov    0x0(%rip),%rax        # 5733 <close_all+0x25>
mov    0xe0(%rax),%edi
cmp    $0xffffffff,%edi
je     5754 <close_all+0x46>
callq  5743 <close_all+0x35>
mov    0x0(%rip),%rax        # 574a <close_all+0x3c>
movl   $0xffffffff,0xe0(%rax)
mov    0x0(%rip),%rbx        # 575b <close_all+0x4d>
jmp    5779 <close_all+0x6b>
mov    0x10(%rbx),%rax
test   %rax,%rax
je     5775 <close_all+0x67>
mov    (%rbx),%edi
cmp    $0xffffffff,%edi
je     5775 <close_all+0x67>
callq  *%rax
movl   $0xffffffff,(%rbx)
mov    0x28(%rbx),%rbx
test   %rbx,%rbx
jne    575d <close_all+0x4f>
callq  5783 <close_all+0x75>
mov    $0x0,%edi
callq  546e <set_gawk_output>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
close_all()
{
 _Bool stdio_problem;
 struct command_source *cs;
 (void) nextfile(& curfile, 1);
 (void) close_io(& stdio_problem);
 if (cur_srcfile->fd != (-1)) {
  close(cur_srcfile->fd);
  cur_srcfile->fd = (-1);
 }
 for (cs = cmd_src; cs != ((void *)0); cs = cs->next) {
  if (cs->close_func && cs->fd != (-1)) {
   cs->close_func(cs->fd);
   cs->fd = (-1);
  }
 }
 close_extensions();
 set_gawk_output(((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 9
14 9
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 13
24 14
25 11
26 11
27 11
28 17
29 18
30 18
31 19
32 19
33 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
movslq %edi,%rbp
imul   $0x3a8,%rbp,%rbp
mov    0x0(%rip),%rax        # 3fd <entityExit+0x19>
mov    0x20(%rax,%rbp,1),%rdi
test   %rdi,%rdi
je     412 <entityExit+0x2e>
cmpl   $0x8,0x4(%rdi)
jne    412 <entityExit+0x2e>
callq  412 <entityExit+0x2e>
mov    0x0(%rip),%rax        # 419 <entityExit+0x35>
movl   $0xffffffff,(%rax,%rbp,1)
cmp    0x0(%rip),%ebx        # 426 <entityExit+0x42>
jne    431 <entityExit+0x4d>
sub    $0x1,%ebx
mov    %ebx,0x0(%rip)        # 431 <entityExit+0x4d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
entityExit(int eid)
{
 craft *c;
 c = entities[eid].c;
 if (c != ((void *)0) && c->type == 8) {
  killPlayer(c);
 }
 entities[eid].local = -1;
 if (eid == entity_top) {
  entity_top--;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 8
15 8
16 9
17 9
18 10
19 10
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x1005,%eax
test   %rdi,%rdi
je     67 <mu_authority_create+0x3f>
mov    %rsi,%r12
mov    %rdx,%rbp
mov    $0x18,%esi
mov    $0x1,%edi
callq  4e <mu_authority_create+0x26>
mov    %rax,%rcx
mov    $0xc,%eax
test   %rcx,%rcx
je     67 <mu_authority_create+0x3f>
mov    %r12,0x8(%rcx)
mov    %rbp,(%rcx)
mov    %rcx,(%rbx)
mov    $0x0,%al
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_authority_create (mu_authority_t *pauthority, mu_ticket_t ticket, void *owner)
{
  mu_authority_t authority;
  if (pauthority == ((void *)0))
    return (0x1000 +5);
  authority = calloc (1, sizeof (*authority));
  if (authority == ((void *)0))
    return 12;
  authority->ticket = ticket;
  authority->owner = owner;
  *pauthority = authority;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 8
15 7
16 7
17 9
18 10
19 11
20 12
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r8
mov    %rdx,%rbp
test   %rdi,%rdi
je     9d <set_if_fd+0x70>
mov    %rsi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
cmp    $0xfffffffffffffffd,%rcx
jne    9d <set_if_fd+0x70>
movb   $0x0,0x1(%r8)
lea    0xc(%rsp),%rsi
mov    %r8,%rdi
callq  67 <set_if_fd+0x3a>
cmpl   $0x0,0xc(%rsp)
jne    72 <set_if_fd+0x45>
mov    %eax,(%rbx)
jmp    c8 <set_if_fd+0x9b>
callq  77 <set_if_fd+0x4a>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 89 <set_if_fd+0x5c>
mov    $0x0,%eax
callq  93 <set_if_fd+0x66>
mov    $0x1,%edi
callq  9d <set_if_fd+0x70>
callq  a2 <set_if_fd+0x75>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # b4 <set_if_fd+0x87>
mov    $0x0,%eax
callq  be <set_if_fd+0x91>
mov    $0x1,%edi
callq  c8 <set_if_fd+0x9b>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_if_fd(char * u_optarg, int * pfd, char * option_name)
{
 int ret;
 int status;
 if (u_optarg && strlen(u_optarg) == 1) {
  *(u_optarg+1) = '\0';
  ret = swlib_atoi(u_optarg, &status);
  if (status == 0) {
   *pfd = ret;
  } else {
   fprintf(stderr, "%s: invalid value for option --%s\n", swlib_utilname_get(), option_name);
   exit(1);
  }
 } else {
  fprintf(stderr, "%s: invalid value for --%s\n", swlib_utilname_get(), option_name);
  exit(1);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 8
19 8
20 9
21 9
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 18
41 18
42 18
43 18
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
strbuf_value(STRBUF *sb)
{
 *sb->curp = 0;
 return sb->sbuf;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b4 <register_auth+0x1d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
register_auth()
{
    static struct dicod_command cmd[] = {
 { "AUTH", 3, 3, "user string", "provide authentication information",
   dicod_auth },
 { ((void *)0) }
    };
    dicod_capa_register("auth", cmd, auth_init, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 8
3 8
4 8
5 8
6 8
7 9
8 9
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    $0xffffffff,%edx
mov    $0xffffd22a,%esi
mov    (%rdi),%edi
callq  1c8 <unfix_offset+0x19>
movslq 0x34(%rbx),%rsi
mov    $0x0,%edx
mov    (%rbx),%edi
callq  1d8 <unfix_offset+0x29>
test   %eax,%eax
jns    21e <unfix_offset+0x6f>
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
mov    $0x82,%r9d
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  217 <unfix_offset+0x68>
mov    $0xffffffff,%eax
jmp    223 <unfix_offset+0x74>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
unfix_offset(SWICAT_E * e)
{
 int ret;
 uxfio_fcntl(e->entry_fdM, -11734, -1);
 ret = uxfio_lseek(e->entry_fdM, (off_t)(e->restore_offsetM), 0);
 if (ret < 0) {
  swutil_cpp_doif_writef(1,1, (void*)((void *)0), 2, (char*)"swicat_e.c", 130, (char*)__FUNCTION__, "ERROR: " "setting veof" "\n");
  return -1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 10
27 11
28 11
29 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    0x10(%rdi),%rdx
mov    %rdx,%rcx
mov    $0x2800,%esi
mov    (%rdi),%rdi
callq  *0x8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
bench_cipher(void *arg)
{
  struct bench_cipher_info *info = arg;
  info->crypt(info->ctx, 10240, info->data, info->data);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
get_version(void)
{
 return "6.5";
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edi
callq  e <__argmatch_die+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__argmatch_die (void)
{
  usage (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  0 <_url_remote_init>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_url_remote_prog_init (mu_url_t url)
{
  return _url_remote_init (url, "prog");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
unac_version(void)
{
  return "1.5.0";
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # c39 <set_prompt+0xb>
callq  c3e <set_prompt+0x10>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rbx,%rdi
callq  c5e <set_prompt+0x30>
mov    %rax,0x0(%rip)        # c65 <set_prompt+0x37>
mov    %rax,0x0(%rip)        # c6c <set_prompt+0x3e>
pop    %rbx
retq   
<<<sep_in_sample>>>
set_prompt(const char *value)
{
 free(dgawk_prompt);
 dgawk_prompt = estrdup(value, strlen(value));
 dbg_prompt = dgawk_prompt;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 6
16 6
<<<sep_out_sample>>>
test   %ecx,0x0(%rip)        # 6 <gsl_message+0x6>
je     1d <gsl_message+0x1d>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    $0x0,%edi
callq  19 <gsl_message+0x19>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
gsl_message (const char * reason, const char * file, int line,
             unsigned int mask)
{
  if (mask & gsl_message_mask)
    {
      gsl_stream_printf ("MESSAGE", file, line, reason);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 6
5 6
6 6
7 8
8 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  159f <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
subspace2D_init(const void *vtrust_state, void *vstate)
{
  (void)vtrust_state;
  (void)vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     56 <__gmp_fprintf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%rdx
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rcx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  92 <__gmp_fprintf+0x92>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_fprintf (FILE *fp, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doprnt (&__gmp_fprintf_funs, fp, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 9
28 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0xffffffffffffffff,%rsi
callq  172 <pr29_8z+0x17>
mov    %rax,%rbx
mov    $0x2,%eax
test   %rbx,%rbx
je     193 <pr29_8z+0x38>
mov    %rbx,%rdi
callq  187 <pr29_8z+0x2c>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  191 <pr29_8z+0x36>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pr29_8z (const char *in)
{
  uint32_t *p;
  int rc;
  p = stringprep_utf8_to_ucs4 (in, -1, ((void *)0));
  if (!p)
    return PR29_STRINGPREP_ERROR;
  rc = pr29_4z (p);
  free (p);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 7
9 6
10 6
11 8
12 8
13 8
14 9
15 9
16 10
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
test   %edx,%edx
jns    385 <swheader_set_image_object+0x32>
cmpq   $0x0,0x10(%rdi)
je     380 <swheader_set_image_object+0x2d>
mov    %rdi,%rax
mov    $0x0,%edx
add    $0x1,%edx
add    $0x8,%rax
cmpq   $0x0,0x10(%rax)
jne    366 <swheader_set_image_object+0x13>
mov    $0xffffffff,%eax
cmp    $0x4,%edx
jle    385 <swheader_set_image_object+0x32>
repz retq 
mov    $0x0,%edx
movslq %edx,%rax
mov    %rsi,0x10(%rdi,%rax,8)
mov    %edx,%eax
retq   
<<<sep_in_sample>>>
swheader_set_image_object(SWHEADER * swheader, void * image, int index)
{
 int i=0;
 ;
 if (index < 0){
  while (swheader->image_object_stack_[i]) i++;
  if (i >= 5)
   return -1;
 } else {
  i=index;
 }
 swheader->image_object_stack_[i]=image;
 return i;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 8
12 7
13 7
14 7
15 6
16 12
17 12
18 13
19 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     54 <mu_debug_get_owner+0xa>
mov    0x10(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_debug_get_owner (mu_debug_t debug)
{
  return (debug) ? debug->owner : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x88,%rdi
callq  87 <ahsStaticGetTarname_i>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahsStaticGetTarGroupname(struct new_cpio_header * file_hdr)
{
 ;
 return ahsStaticGetTarname_i((STROB**)&(file_hdr->c_groupname));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    $0x0,%r8d
jmp    31 <matchchar+0x31>
cmp    $0x5c,%cl
jne    13 <matchchar+0x13>
lea    0x2(%rdi),%rax
jmp    2e <matchchar+0x2e>
cmp    %dl,%cl
jne    22 <matchchar+0x22>
sub    $0x1,%r8d
test   %r8d,%r8d
jg     2e <matchchar+0x2e>
jmp    42 <matchchar+0x42>
cmp    %sil,%cl
sete   %cl
movzbl %cl,%ecx
add    %ecx,%r8d
mov    %rax,%rdi
lea    0x1(%rdi),%rax
movzbl (%rdi),%ecx
test   %cl,%cl
jne    8 <matchchar+0x8>
mov    $0x0,%eax
retq   
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
matchchar(const char *p, char pl, char pr)
{
 int lvl = 0;
 char c;
 while ((c = *p++) != '\0') {
  if (c == '\\') {
   p++;
   continue;
  }
  if (c == pr) {
   if (--lvl <= 0) return --p;
  } else if (c == pl)
   lvl++;
 }
 return (const char *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 7
6 8
7 10
8 10
9 11
10 11
11 11
12 11
13 13
14 13
15 13
16 13
17 2
18 5
19 5
20 5
21 5
22 15
23 15
24 15
25 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # 6982 <nu_hdy+0xf>
cmpl   $0x0,0x0(%rip)        # 6989 <nu_hdy+0x16>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 6995 <nu_hdy+0x22>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  69a1 <nu_hdy+0x2e>
cmpl   $0x0,0x0(%rip)        # 69a8 <nu_hdy+0x35>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 69b4 <nu_hdy+0x41>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nu_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "NU";
  use_other_cc = !use_other_cc;
  nz_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 10
3 11
4 11
5 11
6 11
7 12
8 12
9 12
10 13
11 13
12 13
13 13
14 14
15 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rax
mov    %rsi,0x18(%rax)
callq  10f <finisheditline+0x11>
test   %eax,%eax
jns    140 <finisheditline+0x42>
mov    0x18(%rbx),%rax
mov    0x30(%rbx),%rcx
mov    0x0(%rip),%rdx        # 122 <finisheditline+0x24>
mov    0xd0(%rdx),%rdx
mov    (%rax),%r8
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  140 <finisheditline+0x42>
pop    %rbx
retq   
<<<sep_in_sample>>>
finisheditline (struct finctx *finctx, char *l)
{
  struct expctx *ctx = &finctx->ctx;
  ctx->from->ptr = l;
  if (expandline (ctx) < 0)
    generic_fatal (((void *)0), "%s:%zu: error expanding keywords while applying delta %s", (top->repository. filename), finctx->script_lno, ctx->delta->num)
                                                                 ;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 8
18 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
lea    0x0(,%rsi,8),%rbp
mov    $0x0,%ebx
mov    (%r12,%rbx,1),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  74 <rk8pd_reset+0x25>
add    $0x8,%rbx
cmp    $0x68,%rbx
jne    63 <rk8pd_reset+0x14>
mov    0x70(%r12),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  90 <rk8pd_reset+0x41>
mov    0x68(%r12),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  a2 <rk8pd_reset+0x53>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rk8pd_reset (void *vstate, size_t dim)
{
  rk8pd_state_t *state = (rk8pd_state_t *) vstate;
  int i;
  for (i = 0; i < 13; i++)
    {
      memset((state->k[i]),0,(dim)*sizeof(double));
    }
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 5
13 5
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 12
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x1,%esi
mov    %rbp,%rdi
callq  c5c <parse_verbatim_kbinput+0x17>
mov    %rax,%rbx
test   %rax,%rax
je     c4f <parse_verbatim_kbinput+0xa>
cmpl   $0xfffffffe,(%rax)
jne    c80 <parse_verbatim_kbinput+0x3b>
mov    %rax,%rdi
callq  c71 <parse_verbatim_kbinput+0x2c>
movq   $0x0,(%r12)
mov    $0x0,%eax
jmp    cd5 <parse_verbatim_kbinput+0x90>
mov    $0x1,%esi
mov    %rax,%rdi
callq  c8d <parse_verbatim_kbinput+0x48>
mov    %rbx,%rdi
callq  c95 <parse_verbatim_kbinput+0x50>
movq   $0x1,(%r12)
cmpq   $0x3,0x0(%rip)        # ca5 <parse_verbatim_kbinput+0x60>
jbe    cc7 <parse_verbatim_kbinput+0x82>
mov    0x0(%rip),%rax        # cae <parse_verbatim_kbinput+0x69>
cmpl   $0x1b,(%rax)
jne    cc7 <parse_verbatim_kbinput+0x82>
cmpl   $0x1b,0x4(%rax)
jne    cc7 <parse_verbatim_kbinput+0x82>
cmpl   $0x5b,0x8(%rax)
jne    cc7 <parse_verbatim_kbinput+0x82>
movq   $0x2,(%r12)
mov    (%r12),%rsi
mov    $0x0,%edi
callq  cd5 <parse_verbatim_kbinput+0x90>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parse_verbatim_kbinput(WINDOW *win, size_t *count)
{
    int *kbinput;
    while ((kbinput = get_input(win, 1)) == ((void *)0))
 ;
    if (*kbinput == -2) {
 free(kbinput);
 *count = 0;
 return ((void *)0);
    }
 unget_input(kbinput, 1);
    free(kbinput);
    *count = 1;
    if (key_buffer_len > 3 && *key_buffer == 0x1B &&
  key_buffer[1] == 0x1B && key_buffer[2] == '[')
 *count = 2;
    return get_input(((void *)0), *count);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 7
15 7
16 8
17 9
18 9
19 11
20 11
21 11
22 12
23 12
24 13
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 15
33 15
34 16
35 17
36 17
37 17
38 18
39 18
40 18
41 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbp
cmp    %rsi,%rbp
cmova  %rsi,%rbp
lea    0x1(%rbp),%rdi
callq  56 <xstrndup+0x2c>
mov    %rax,%rbx
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  67 <xstrndup+0x3d>
movb   $0x0,(%rbx,%rbp,1)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  size_t len = strlen (string);
  char *res;
  if (n < len)
    len = n;
  res = xmalloc (len + 1);
  strncpy (res, string, len);
  res[len] = '\0';
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 9
20 11
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0xe8(%rdi),%rdi
mov    $0x40,%esi
callq  15 <__qam_c_destroy+0x15>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__qam_c_destroy(dbc)
 DBC *dbc;
{
 CDB___os_free(dbc->internal, sizeof(QUEUE_CURSOR));
 return (0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
set_dest_default(char *value)
{
  set_dest(((void *)0),((void *)0),value);
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 523 <record_open+0x6>
cmp    $0x3,%eax
jg     53c <record_open+0x1f>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # 531 <record_open+0x14>
cltq   
mov    %rdi,0x0(,%rax,8)
retq   
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 547 <record_open+0x2a>
mov    $0x10,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  55b <record_open+0x3e>
mov    $0x0,%eax
callq  565 <expected1>
<<<sep_in_sample>>>
record_open(file)
 char *file;
{
 if (nfiles < 4) {
  outfiles[nfiles++] = file;
 } else {
  (void) fprintf(stderr, "too many files!\n");
  crash();
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 3
10 7
11 7
12 7
13 7
14 7
15 8
16 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rdi
mov    %rdx,%r12
cmp    $0x1,%rcx
je     1638 <gsl_block_raw_fread+0x37>
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %rdx,%rdx
je     16be <gsl_block_raw_fread+0xbd>
jmp    1672 <gsl_block_raw_fread+0x71>
mov    %r13,%rcx
mov    $0x8,%esi
callq  1645 <gsl_block_raw_fread+0x44>
mov    %rax,%rdx
mov    $0x0,%eax
cmp    %r12,%rdx
je     16be <gsl_block_raw_fread+0xbd>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  166b <gsl_block_raw_fread+0x6a>
mov    $0x5,%eax
jmp    16be <gsl_block_raw_fread+0xbd>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  1687 <gsl_block_raw_fread+0x86>
cmp    $0x1,%rax
je     16ad <gsl_block_raw_fread+0xac>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16a6 <gsl_block_raw_fread+0xa5>
mov    $0x5,%eax
jmp    16be <gsl_block_raw_fread+0xbd>
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
jne    1672 <gsl_block_raw_fread+0x71>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_block_raw_fread (FILE * stream, double * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (double), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (double), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 17
12 17
13 17
14 25
15 15
16 15
17 15
18 6
19 6
20 6
21 6
22 25
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 17
33 17
34 17
35 17
36 17
37 19
38 19
39 21
40 21
41 21
42 21
43 21
44 21
45 21
46 15
47 15
48 15
49 15
50 25
51 26
52 26
53 26
54 26
55 26
56 26
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r13
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%rbx
test   %r8,%r8
mov    $0x0,%eax
cmove  %rax,%rbx
callq  e10 <quotearg_buffer+0x30>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    0x4(%rbx),%r9d
mov    0x30(%rbx),%rax
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    0x18(%rsp),%rdi
callq  e7 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 130 <mout_id+0xb>
add    $0x8,%rax
cmp    %rax,0x0(%rip)        # 13b <mout_id+0x16>
jae    14c <mout_id+0x27>
mov    $0x8,%esi
mov    $0x0,%edi
callq  14c <mout_id+0x27>
mov    0x0(%rip),%rax        # 153 <mout_id+0x2e>
mov    %rbx,(%rax)
addq   $0x8,0x0(%rip)        # 15e <mout_id+0x39>
pop    %rbx
retq   
<<<sep_in_sample>>>
mout_id(char *x)
{
  __extension__ ({ struct obstack *__o = (&os_mell); int __len = (sizeof (char *)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); bcopy (((char *) (&x)), (__o->next_free), (__len)); __o->next_free += __len; (void) 0; });
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %edx,%r15d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 9f69 <ca_sa_hdy+0x2a>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  9f75 <ca_sa_hdy+0x36>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
mov    %r14d,%r9d
mov    %r13,%r8
mov    %ebx,%ecx
mov    %r15d,%edx
mov    %r12d,%esi
mov    %rbp,%rdi
callq  0 <ca_base_hdy>
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %ebx,%edx
mov    $0x8,%esi
mov    $0x1,%edi
callq  9fae <ca_sa_hdy+0x6f>
mov    %eax,%r15d
mov    0x0(%rip),%rax        # 9fb8 <ca_sa_hdy+0x79>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 9fc4 <ca_sa_hdy+0x85>
callq  9fc9 <ca_sa_hdy+0x8a>
mov    0x70(%rsp),%edx
mov    %edx,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0x8,(%rsp)
mov    %r15d,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  a002 <ca_sa_hdy+0xc3>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ca_sa_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "CA_SA";
  ca_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  ca_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (1, 8, year, 1, (0==0));
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "+", day, 8, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 11
15 12
16 12
17 12
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 17
52 17
53 17
54 17
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <_rl_callback_newline+0x9>
cmpl   $0x0,0x0(%rip)        # 10 <_rl_callback_newline+0x10>
jne    3e <_rl_callback_newline+0x3e>
movl   $0x1,0x0(%rip)        # 1c <_rl_callback_newline+0x1c>
mov    0x0(%rip),%rax        # 23 <_rl_callback_newline+0x23>
test   %rax,%rax
je     30 <_rl_callback_newline+0x30>
mov    0x0(%rip),%edi        # 2e <_rl_callback_newline+0x2e>
callq  *%rax
cmpl   $0x0,0x0(%rip)        # 37 <_rl_callback_newline+0x37>
je     3e <_rl_callback_newline+0x3e>
callq  3e <_rl_callback_newline+0x3e>
callq  43 <_rl_callback_newline+0x43>
mov    0x0(%rip),%eax        # 49 <_rl_callback_newline+0x49>
test   %eax,%eax
je     58 <_rl_callback_newline+0x58>
mov    0x0(%rip),%edi        # 53 <_rl_callback_newline+0x53>
callq  58 <_rl_callback_newline+0x58>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_callback_newline ()
{
  rl_initialize ();
  if (in_handler == 0)
    {
      in_handler = 1;
      if (rl_prep_term_function)
 (*rl_prep_term_function) (_rl_meta_flag);
      if (rl_persistent_signal_handlers)
 rl_set_signals ();
    }
  readline_internal_setup ();
  do { if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 7
7 7
8 7
9 8
10 8
11 9
12 9
13 10
14 12
15 13
16 13
17 13
18 13
19 13
20 14
21 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <maybe_replace_line+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
maybe_replace_line ()
{
  return rl_maybe_replace_line ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
movslq %edi,%rdi
callq  52b <mymalloc+0xc>
test   %rax,%rax
jne    562 <mymalloc+0x43>
mov    %rbx,%rcx
mov    0x0(%rip),%rax        # 53a <mymalloc+0x1b>
mov    (%rax),%rdx
lea    0x0(%rip),%rsi        # 544 <mymalloc+0x25>
mov    0x0(%rip),%rax        # 54b <mymalloc+0x2c>
mov    (%rax),%rdi
mov    $0x0,%eax
callq  558 <mymalloc+0x39>
mov    $0x1,%edi
callq  562 <mymalloc+0x43>
pop    %rbx
retq   
<<<sep_in_sample>>>
mymalloc(int bytes,char *mesg)
{
   void *pointer;
   pointer = malloc(bytes);
   if (!pointer){
     fprintf(stderr, "%s: memory allocation error %s\n", progname,mesg);
     exit(1);
   }
   return pointer;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 10
18 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  e4 <lookup_request>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_request (CTL_MSG * request)
{
  return lookup_request (request, exact_comp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  158a <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  10e7 <namebuf_free+0xc>
mov    %rbx,%rdi
callq  10ef <namebuf_free+0x14>
pop    %rbx
retq   
<<<sep_in_sample>>>
namebuf_free (namebuf_t buf)
{
  free (buf->buffer);
  free (buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  30c <fd_ostream__free+0x9>
mov    0x10(%rbx),%rdi
callq  315 <fd_ostream__free+0x12>
mov    %rbx,%rdi
callq  31d <fd_ostream__free+0x1a>
pop    %rbx
retq   
<<<sep_in_sample>>>
fd_ostream__free (fd_ostream_t stream)
{
  fd_ostream_flush (stream);
  free (stream->filename);
  free (stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
test   %rsi,%rsi
je     142 <_gsasl_saml20_client_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  13e <_gsasl_saml20_client_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_client_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_client_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1cb <ForAllList3+0x45>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %r8,%r14
test   %rsi,%rsi
je     1c3 <ForAllList3+0x3d>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     1c3 <ForAllList3+0x3d>
mov    %r14,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
mov    (%rbx),%rdi
callq  *%rbp
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    1ac <ForAllList3+0x26>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
repz retq 
<<<sep_in_sample>>>
ForAllList3(PLIST plist, PFI_FORLISTCALLBACK3 pfiCallback,
                 PVOID pUserInfo1, PVOID pUserInfo2, PVOID pUserInfo3)
{
  PLISTELEM ple;
  if (!plist || !pfiCallback)
    return;
  ple = plist->pleHead;
  while (ple) {
    (*pfiCallback) (ple->pData, pUserInfo1, pUserInfo2, pUserInfo3);
    ple = ple->pleNext;
  }
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 7
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 10
23 8
24 8
25 12
26 12
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
movzbl 0x23(%rax),%ecx
test   %cl,%cl
je     4a0 <fh_dma+0x1a>
movzbl %cl,%ecx
callq  49e <fh_dma+0x18>
jmp    4aa <fh_dma+0x24>
mov    $0x0,%esi
callq  4aa <fh_dma+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fh_dma (format_data_t form, int argc, char *argv[])
{
  if (form->ifr->ifr_ifru.ifru_map.dma)
    put_int (form, argc, argv, form->ifr->ifr_ifru.ifru_map.dma);
  else
    put_string (form, "(not available)");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
cmp    (%rdi),%rax
jae    1c <push_stack+0x1c>
mov    0x8(%rdi),%rdx
mov    %rsi,(%rdx,%rax,8)
addq   $0x1,0x10(%rdi)
mov    $0x0,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
push_stack(gsl_stack_t *s, size_t v)
{
    if ((s->i) >= (s->N)) {
      return -1;
    }
    (s->v)[s->i] = v;
    s->i += 1;
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 7
7 8
8 8
9 4
10 9
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 8 <gettwo+0x8>
andpd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 14 <gettwo+0x14>
movsd  0x0(%rip),%xmm2        # 1c <gettwo+0x1c>
ucomisd %xmm1,%xmm0
jbe    2e <gettwo+0x2e>
mulsd  %xmm2,%xmm0
ucomisd %xmm1,%xmm0
ja     22 <gettwo+0x22>
jmp    36 <gettwo+0x36>
movsd  0x0(%rip),%xmm0        # 36 <gettwo+0x36>
ucomisd %xmm0,%xmm1
jbe    46 <gettwo+0x46>
addsd  %xmm0,%xmm0
ucomisd %xmm0,%xmm1
ja     3c <gettwo+0x3c>
repz retq 
<<<sep_in_sample>>>
gettwo(double x)
{
  double t;
  for (t = 1.0, x = fabs(x); t > x; t /= 2.0)
    ;
  while (t < x)
    t *= 2.0;
  return t;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 7
15 6
16 6
17 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     fd3 <gsl_vector_long_double_free+0x20>
cmpl   $0x0,0x20(%rdi)
je     fcb <gsl_vector_long_double_free+0x18>
mov    0x18(%rdi),%rdi
callq  fcb <gsl_vector_long_double_free+0x18>
mov    %rbx,%rdi
callq  fd3 <gsl_vector_long_double_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_long_double_free (gsl_vector_long_double * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_long_double_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # ea6 <gsl_vector_uchar_set+0x7>
je     ecc <gsl_vector_uchar_set+0x2d>
cmp    %rsi,(%rdi)
ja     ecc <gsl_vector_uchar_set+0x2d>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  eca <gsl_vector_uchar_set+0x2b>
jmp    ed9 <gsl_vector_uchar_set+0x3a>
imul   0x8(%rdi),%rsi
mov    0x10(%rdi),%rax
mov    %dl,(%rax,%rsi,1)
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_set (gsl_vector_uchar * v, const size_t i, unsigned char x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_uchar.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %edx,%eax
retq   
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
cmpb   $0x0,0x22(%rax)
je     13e9 <fh_irq_query+0x1a>
mov    $0x0,%ecx
callq  13e7 <fh_irq_query+0x18>
jmp    13f3 <fh_irq_query+0x24>
mov    $0x1,%ecx
callq  13f3 <fh_irq_query+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fh_irq_query (format_data_t form, int argc, char *argv[])
{
  if (form->ifr->ifr_ifru.ifru_map.irq)
    select_arg (form, argc, argv, 0);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x16,%edi
jg     12 <acl_errno_valid+0x12>
cmp    $0x10,%edi
jne    22 <acl_errno_valid+0x22>
nop
jmp    1c <acl_errno_valid+0x1c>
cmp    $0x26,%edi
je     1c <acl_errno_valid+0x1c>
cmp    $0x5f,%edi
jne    22 <acl_errno_valid+0x22>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 9
16 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x0,%edi
callq  18e <vgetcwd+0x16>
test   %rax,%rax
je     1b4 <vgetcwd+0x3c>
mov    $0x0,%edi
callq  19d <vgetcwd+0x25>
test   %rax,%rax
je     1b4 <vgetcwd+0x3c>
mov    %ebp,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  1af <vgetcwd+0x37>
mov    %rbx,%rax
jmp    1c6 <vgetcwd+0x4e>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1bf <vgetcwd+0x47>
test   %rax,%rax
cmovne %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
vgetcwd(char *buf, size_t size) {
 char *p;
 if (getenv("GTAGSLOGICALPATH")) {
  if ((p = getenv("PWD")) != ((void *)0)) {
   strlimcpy(buf, p, size);
   return buf;
  }
 }
 if (getcwd(buf, size) != ((void *)0))
  return buf;
 return ((void *)0);
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 6
19 6
20 9
21 9
22 9
23 9
24 10
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xd8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
           elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 6
5 6
<<<sep_out_sample>>>
mov    %edi,%eax
retq   
<<<sep_in_sample>>>
CDB___lock_locker_hash(locker)
 u_int32_t locker;
{
 return (locker);
}
<<<sep_in_sample>>>
1 3
2 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     1268 <CDB___txn_activekids+0x22>
testb  $0x1,0x50(%rax)
jne    125d <CDB___txn_activekids+0x17>
jmp    126e <CDB___txn_activekids+0x28>
testb  $0x1,0x50(%rax)
je     1274 <CDB___txn_activekids+0x2e>
mov    0x40(%rax),%rax
test   %rax,%rax
jne    1257 <CDB___txn_activekids+0x11>
repz retq 
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
CDB___txn_activekids(txnp)
 DB_TXN *txnp;
{
 DB_TXN *kids;
 for (kids = ((&txnp->kids)->tqh_first);
     kids != ((void *)0);
     kids = ((kids)->klinks.tqe_next))
  if (!((kids)->flags & (0x01)))
   return (1);
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 8
5 8
6 8
7 8
8 8
9 7
10 5
11 5
12 5
13 10
14 10
15 9
16 9
17 9
18 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%edi
jne    14 <_log_handler+0x14>
cmpl   $0x1,0x0(%rip)        # 10 <_log_handler+0x10>
ja     32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x2,%edi
jne    24 <_log_handler+0x24>
cmpl   $0x0,0x0(%rip)        # 20 <_log_handler+0x20>
jne    32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x3,%edi
jne    32 <_log_handler+0x32>
cmpl   $0x0,0x0(%rip)        # 30 <_log_handler+0x30>
jne    38 <_log_handler+0x38>
callq  *0x0(%rip)        # 38 <_log_handler+0x38>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_log_handler (cdio_log_level_t level, const char message[])
{
  if (level == CDIO_LOG_DEBUG && opts.debug_level < 2)
    return;
  if (level == CDIO_LOG_INFO && opts.debug_level < 1)
    return;
  if (level == CDIO_LOG_WARN && opts.silent)
    return;
  gl_default_cdio_log_handler (level, message);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 9
17 10
18 10
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_multilarge_nlinear_residual (const gsl_multilarge_nlinear_workspace * w)
{
  return w->f;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 186 <install_default_implicit_rules+0x7>
jne    1d6 <install_default_implicit_rules+0x57>
push   %rbx
cmpq   $0x0,0x0(%rip)        # 191 <install_default_implicit_rules+0x12>
je     1af <install_default_implicit_rules+0x30>
mov    $0x0,%ebx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1a5 <install_default_implicit_rules+0x26>
add    $0x18,%rbx
cmpq   $0x0,(%rbx)
jne    198 <install_default_implicit_rules+0x19>
cmpq   $0x0,0x0(%rip)        # 1b7 <install_default_implicit_rules+0x38>
je     1d5 <install_default_implicit_rules+0x56>
mov    $0x0,%ebx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  1cb <install_default_implicit_rules+0x4c>
add    $0x18,%rbx
cmpq   $0x0,(%rbx)
jne    1be <install_default_implicit_rules+0x3f>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
install_default_implicit_rules (void)
{
  struct pspec *p;
  if (no_builtin_rules_flag)
    return;
  for (p = default_pattern_rules; p->target != 0; ++p)
    install_pattern_rule (p, 0);
  for (p = default_terminal_rules; p->target != 0; ++p)
    install_pattern_rule (p, 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 6
7 7
8 7
9 7
10 6
11 6
12 6
13 8
14 8
15 8
16 9
17 9
18 9
19 8
20 8
21 8
22 10
23 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  585 <gsl_stats_long_double_variance+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  593 <gsl_stats_long_double_variance+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_variance (const long double data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_double_mean (data, stride, n);
  return gsl_stats_long_double_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  66 <mt_lseek+0x9>
sar    $0x3f,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mt_lseek(int fd, mt_off_t where, int whence)
{
 if(lseek64(fd, where, whence) >= 0)
  return 0;
 else
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 7
5 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
movsbl 0x0(%rip),%eax        # 1d4 <wordsplit_quote_char+0x7>
cmp    %edi,%eax
jne    1ed <wordsplit_quote_char+0x20>
jmp    1e3 <wordsplit_quote_char+0x16>
movsbl (%rax),%edx
cmp    %edi,%edx
jne    1f2 <wordsplit_quote_char+0x25>
jmp    1e8 <wordsplit_quote_char+0x1b>
mov    $0x0,%eax
movsbl -0x1(%rax),%eax
retq   
mov    $0x0,%eax
sub    $0x2,%rax
cmp    $0x0,%rax
ja     1da <wordsplit_quote_char+0xd>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
wordsplit_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof(quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 4
10 8
11 8
12 4
13 5
14 4
15 4
16 10
17 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <rec_mset_elem_equal_fn>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_mset_elem_equal_p (rec_mset_elem_t elem1,
                       rec_mset_elem_t elem2)
{
  return rec_mset_elem_equal_fn ((void *) elem1,
                                 (void *) elem2);
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
movabs $0x41a705af1fe3fb79,%rdx
mov    %rcx,%rax
mul    %rdx
shr    $0xf,%rdx
imul   $0xfffffffffffe0ce3,%rdx,%rax
add    %rax,%rcx
imul   $0x41a7,%rcx,%rcx
imul   $0xfffffffffffff4ec,%rdx,%rdx
add    %rcx,%rdx
jns    40 <ran0_get+0x40>
add    $0x7fffffff,%rdx
mov    %rdx,(%rdi)
jmp    43 <ran0_get+0x43>
mov    %rdx,(%rdi)
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
ran0_get (void *vstate)
{
  ran0_state_t *state = (ran0_state_t *) vstate;
  const unsigned long int x = state->x;
  const long int h = x / q;
  const long int t = a * (x - h * q) - h * r;
  if (t < 0)
    {
      state->x = t + m;
    }
  else
    {
      state->x = t;
    }
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 6
7 6
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 13
16 15
17 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
cmpw   $0xff,0x20(%rax)
jbe    1414 <fh_baseaddr_query+0x1c>
mov    $0x0,%ecx
callq  1412 <fh_baseaddr_query+0x1a>
jmp    141e <fh_baseaddr_query+0x26>
mov    $0x1,%ecx
callq  141e <fh_baseaddr_query+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fh_baseaddr_query (format_data_t form, int argc, char *argv[])
{
  if (form->ifr->ifr_ifru.ifru_map.base_addr >= 0x100)
    select_arg (form, argc, argv, 0);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
mov    (%rsi),%rdx
xorpd  %xmm0,%xmm0
cmp    %rdi,%rdx
jb     639 <gsl_ran_discrete_pdf+0xda>
test   %rdx,%rdx
je     610 <gsl_ran_discrete_pdf+0xb1>
mov    0x10(%rsi),%r9
mov    $0x0,%eax
mov    %rdx,%r11
shr    %r11
mov    %rdx,%rcx
and    $0x1,%ecx
or     %rcx,%r11
movsd  0x0(%rip),%xmm3        # 598 <gsl_ran_discrete_pdf+0x39>
lea    0x0(,%rax,8),%rcx
test   %rdx,%rdx
js     5ac <gsl_ran_discrete_pdf+0x4d>
cvtsi2sd %rdx,%xmm1
jmp    5b5 <gsl_ran_discrete_pdf+0x56>
cvtsi2sd %r11,%xmm1
addsd  %xmm1,%xmm1
mulsd  (%r9,%rax,8),%xmm1
test   %rax,%rax
js     5c7 <gsl_ran_discrete_pdf+0x68>
cvtsi2sd %rax,%xmm2
jmp    5e0 <gsl_ran_discrete_pdf+0x81>
mov    %rax,%r8
shr    %r8
mov    %rax,%r10
and    $0x1,%r10d
or     %r10,%r8
cvtsi2sd %r8,%xmm2
addsd  %xmm2,%xmm2
subsd  %xmm2,%xmm1
cmp    %rdi,%rax
jne    5ef <gsl_ran_discrete_pdf+0x90>
addsd  %xmm1,%xmm0
jmp    605 <gsl_ran_discrete_pdf+0xa6>
mov    0x8(%rsi),%r8
cmp    %rdi,(%r8,%rcx,1)
jne    605 <gsl_ran_discrete_pdf+0xa6>
movapd %xmm3,%xmm4
subsd  %xmm1,%xmm4
addsd  %xmm4,%xmm0
add    $0x1,%rax
cmp    %rdx,%rax
jne    598 <gsl_ran_discrete_pdf+0x39>
jmp    614 <gsl_ran_discrete_pdf+0xb5>
xorpd  %xmm0,%xmm0
test   %rdx,%rdx
js     620 <gsl_ran_discrete_pdf+0xc1>
cvtsi2sd %rdx,%xmm1
jmp    635 <gsl_ran_discrete_pdf+0xd6>
mov    %rdx,%rax
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
repz retq 
<<<sep_in_sample>>>
gsl_ran_discrete_pdf(size_t k, const gsl_ran_discrete_t *g)
{
    size_t i,K;
    double f,p=0;
    K= g->K;
    if (k>K) return 0;
    for (i=0; i<K; ++i) {
        f = (g->F)[i];
        f = K*f-i;
        if (i==k) {
            p += f;
        } else if (k == (g->A)[i]) {
            p += 1.0 - f;
        }
    }
    return p/K;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 7
6 7
7 8
8 8
9 9
10 9
11 9
12 9
13 9
14 13
15 13
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 10
36 10
37 11
38 11
39 12
40 12
41 12
42 13
43 13
44 13
45 7
46 7
47 7
48 7
49 7
50 16
51 16
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
60 16
61 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rdx,%rbp
callq  796 <fnmatch_sanitycheck>
lea    0x8(%rsp),%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  b0 <collect_arg>
mov    %eax,%ebx
test   %al,%al
je     c82 <parse_lname+0x6a>
mov    0x8(%rsp),%rsi
mov    %r12,%rdi
callq  c51 <parse_lname+0x39>
mov    %rax,%rbp
mov    0x8(%rsp),%rdi
mov    %rdi,0x38(%rax)
mov    $0x0,%esi
callq  830 <estimate_pattern_match_rate>
unpcklps %xmm0,%xmm0
cvtps2pd %xmm0,%xmm0
mulsd  0x0(%rip),%xmm0        # c75 <parse_lname+0x5d>
unpcklpd %xmm0,%xmm0
cvtpd2ps %xmm0,%xmm1
movss  %xmm1,0x24(%rbp)
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parse_lname (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  const char *name;
  fnmatch_sanitycheck ();
  if (collect_arg (argv, arg_ptr, &name))
    {
      struct predicate *our_pred = insert_primary (entry, name);
      our_pred->args.str = name;
      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate (name, 0);
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 8
21 8
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 13
31 13
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
test   %rcx,%rcx
je     1a9b <gsl_permute_uchar_inverse+0x6c>
mov    $0x0,%r8d
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    1a4c <gsl_permute_uchar_inverse+0x1d>
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     1a43 <gsl_permute_uchar_inverse+0x14>
cmp    %rax,%r8
ja     1a7b <gsl_permute_uchar_inverse+0x4c>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
jne    1a86 <gsl_permute_uchar_inverse+0x57>
jmp    1a7b <gsl_permute_uchar_inverse+0x4c>
mov    %r10d,%r11d
mov    %r9,%rax
imul   %rdx,%rax
add    %rsi,%rax
movzbl (%rax),%r10d
mov    %r11b,(%rax)
mov    (%rdi,%r9,8),%r9
cmp    %r8,%r9
jne    1a5c <gsl_permute_uchar_inverse+0x2d>
jmp    1a91 <gsl_permute_uchar_inverse+0x62>
add    $0x1,%r8
cmp    %rcx,%r8
jne    1a3a <gsl_permute_uchar_inverse+0xb>
jmp    1a9b <gsl_permute_uchar_inverse+0x6c>
imul   %rdx,%rax
movzbl (%rsi,%rax,1),%r11d
jmp    1a5f <gsl_permute_uchar_inverse+0x30>
imul   %rdx,%r9
mov    %r10b,(%rsi,%r9,1)
jmp    1a7b <gsl_permute_uchar_inverse+0x4c>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_uchar_inverse (const size_t * p, unsigned char * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned char t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned char r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 7
6 7
7 8
8 7
9 7
10 9
11 9
12 11
13 12
14 12
15 12
16 23
17 23
18 23
19 23
20 23
21 24
22 28
23 19
24 19
25 19
26 4
27 4
28 4
29 4
30 18
31 18
32 18
33 31
34 31
35 31
36 35
37 35
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x48(%rdi),%rdi
test   %rdi,%rdi
je     2f31 <prog_stop_redirectors+0x17>
mov    $0xf,%esi
callq  0 <prog_stop>
mov    0x50(%rbx),%rdi
test   %rdi,%rdi
je     2f44 <prog_stop_redirectors+0x2a>
mov    $0xf,%esi
callq  0 <prog_stop>
pop    %rbx
retq   
<<<sep_in_sample>>>
prog_stop_redirectors (struct prog *prog)
{
  if (prog->v.p.redir[0])
    prog_stop (prog->v.p.redir[0], 15);
  if (prog->v.p.redir[1])
    prog_stop (prog->v.p.redir[1], 15);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %esi,%esi
jne    310 <_command_generator+0x4b>
movl   $0x0,0x0(%rip)        # 2e0 <_command_generator+0x1b>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %ecx,0x0(%rip)        # 2fb <_command_generator+0x36>
mov    0x0(%rip),%r13d        # 302 <_command_generator+0x3d>
test   %r13d,%r13d
je     31f <_command_generator+0x5a>
sub    $0x1,%ecx
mov    %ecx,0x0(%rip)        # 310 <_command_generator+0x4b>
mov    0x0(%rip),%r13d        # 317 <_command_generator+0x52>
cmp    $0x1,%r13d
sbb    $0xffffffffffffffff,%rbp
movslq 0x0(%rip),%r12        # 326 <_command_generator+0x61>
jmp    39f <_command_generator+0xda>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # 331 <_command_generator+0x6c>
cltq   
lea    (%rax,%rax,2),%rax
shl    $0x4,%rax
cmpq   $0x0,0x0(%rax)
je     39f <_command_generator+0xda>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  353 <_command_generator+0x8e>
test   %eax,%eax
jne    39f <_command_generator+0xda>
test   %r13d,%r13d
jne    366 <_command_generator+0xa1>
mov    %rbx,%rdi
callq  364 <_command_generator+0x9f>
jmp    3c5 <_command_generator+0x100>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdi
neg    %rdi
callq  382 <_command_generator+0xbd>
mov    %rax,%rbp
mov    0x0(%rip),%eax        # 38b <_command_generator+0xc6>
mov    %al,0x0(%rbp)
lea    0x1(%rbp),%rdi
mov    %rbx,%rsi
callq  39a <_command_generator+0xd5>
mov    %rbp,%rax
jmp    3c5 <_command_generator+0x100>
mov    0x0(%rip),%eax        # 3a5 <_command_generator+0xe0>
movslq %eax,%rcx
lea    (%rcx,%rcx,2),%rdx
shl    $0x4,%rdx
mov    0x0(%rdx),%rbx
test   %rbx,%rbx
jne    328 <_command_generator+0x63>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_command_generator(const char *text, int state)
{
    static int i, len;
    const char *name;
    if (!state) {
 i = 0;
 len = strlen (text);
 if (cmdprefix)
     len--;
    }
    if (cmdprefix)
 text++;
    while ((name = funtab[i].name)) {
 i++;
 if (funtab[i-1].docstring
     && strncmp(name, text, len) == 0) {
     if (!cmdprefix)
  return strdup (name);
     else {
  char *p = xmalloc(strlen(name) + 2);
  *p = cmdprefix;
  strcpy(p+1, name);
  return p;
     }
 }
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 12
23 12
24 16
25 16
26 14
27 14
28 15
29 15
30 15
31 15
32 15
33 16
34 16
35 16
36 16
37 16
38 16
39 17
40 17
41 18
42 18
43 18
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 21
53 21
54 22
55 22
56 22
57 23
58 23
59 13
60 13
61 13
62 13
63 13
64 13
65 13
66 27
67 28
68 28
69 28
70 28
71 28
72 28
<<<sep_out_sample>>>
test   %rdi,%rdi
je     339 <sdp_message_connection_get+0x31>
push   %rbx
mov    %edx,%ebx
cmp    $0xffffffff,%esi
jne    31b <sdp_message_connection_get+0x13>
mov    0x70(%rdi),%rax
jmp    344 <sdp_message_connection_get+0x3c>
add    $0xb8,%rdi
callq  327 <sdp_message_connection_get+0x1f>
test   %rax,%rax
je     33f <sdp_message_connection_get+0x37>
lea    0x38(%rax),%rdi
mov    %ebx,%esi
callq  337 <sdp_message_connection_get+0x2f>
jmp    344 <sdp_message_connection_get+0x3c>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sdp_message_connection_get (sdp_message_t * sdp, int pos_media, int pos)
{
  sdp_media_t *med;
  if (sdp == ((void *)0))
    return ((void *)0);
  if (pos_media == -1)
    return sdp->c_connection;
  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return ((void *)0);
  return (sdp_connection_t *) osip_list_get (&med->c_connections, pos);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 6
6 6
7 7
8 7
9 8
10 8
11 9
12 9
13 11
14 11
15 11
16 11
17 5
18 12
19 10
20 12
21 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0xffffffffffffffff,%rbp
mov    $0xfffffffffffffffe,%r14
jmp    2da3 <fetch_number+0x29>
mov    %r14,%rbp
jmp    2da3 <fetch_number+0x29>
mov    %r14,%rbp
mov    %r12,%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  2d58 <fetch_token>
movzbl (%rbx),%eax
movzbl 0x8(%rbx),%ecx
cmp    $0x2,%cl
je     2e04 <fetch_number+0x8a>
cmp    $0x18,%cl
je     2e0d <fetch_number+0x93>
cmp    $0x2c,%al
je     2e12 <fetch_number+0x98>
cmp    $0x1,%cl
jne    2d9b <fetch_number+0x21>
lea    -0x30(%rax),%edx
cmp    $0x9,%dl
ja     2da0 <fetch_number+0x26>
cmp    $0xfffffffffffffffe,%rbp
je     2da3 <fetch_number+0x29>
cmp    $0xffffffffffffffff,%rbp
jne    2dea <fetch_number+0x70>
movzbl %al,%ebp
sub    $0x30,%ebp
movslq %ebp,%rbp
jmp    2df7 <fetch_number+0x7d>
lea    0x0(%rbp,%rbp,4),%rdx
movzbl %al,%eax
lea    -0x30(%rax,%rdx,2),%rbp
cmp    $0x8000,%rbp
cmovae %r14,%rbp
jmp    2da3 <fetch_number+0x29>
mov    $0xfffffffffffffffe,%rax
jmp    2e15 <fetch_number+0x9b>
mov    %rbp,%rax
jmp    2e15 <fetch_number+0x9b>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
fetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)
{
  Idx num = ((Idx) -1);
  unsigned char c;
  while (1)
    {
      fetch_token (token, input, syntax);
      c = token->opr.c;
      if (__builtin_expect (token->type == END_OF_RE, 0))
 return ((Idx) -2);
      if (token->type == OP_CLOSE_DUP_NUM || c == ',')
 break;
      num = ((token->type != CHARACTER || c < '0' || '9' < c
       || num == ((Idx) -2))
      ? ((Idx) -2)
      : ((num == ((Idx) -1)) ? c - '0' : num * 10 + c - '0'));
      num = (num > (0x7fff)) ? ((Idx) -2) : num;
    }
  return num;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 17
11 17
12 17
13 17
14 17
15 7
16 7
17 7
18 7
19 8
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 16
28 16
29 13
30 13
31 13
32 14
33 14
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 17
44 17
45 17
46 10
47 10
48 10
49 10
50 10
51 20
52 20
53 20
54 20
55 20
56 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %edi,%edi
js     92 <free_cwd+0xf>
callq  92 <free_cwd+0xf>
mov    0x8(%rbx),%rdi
callq  9b <free_cwd+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_cwd (struct saved_cwd *cwd)
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  free (cwd->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%r12
mov    %rdx,%r13
mov    %rcx,%rbp
mov    $0x0,%edx
mov    %rcx,%rsi
mov    %r12,%rdi
callq  1257 <cb_syslog_facility+0x23>
mov    %eax,%ebx
test   %eax,%eax
jne    12e8 <cb_syslog_facility+0xb4>
mov    0x8(%rbp),%rbp
movsbl 0x0(%rbp),%edi
callq  126e <cb_syslog_facility+0x3a>
test   %al,%al
je     12b5 <cb_syslog_facility+0x81>
mov    $0xa,%edx
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  1284 <cb_syslog_facility+0x50>
mov    0x8(%rsp),%rdx
cmpb   $0x0,(%rdx)
je     12af <cb_syslog_facility+0x7b>
mov    $0x0,%edi
callq  1298 <cb_syslog_facility+0x64>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  12ad <cb_syslog_facility+0x79>
jmp    12f1 <cb_syslog_facility+0xbd>
mov    %eax,0x0(%r13)
jmp    12f1 <cb_syslog_facility+0xbd>
mov    %r13,%rsi
mov    %rbp,%rdi
callq  12c0 <cb_syslog_facility+0x8c>
test   %eax,%eax
je     12ef <cb_syslog_facility+0xbb>
mov    $0x0,%edi
callq  12ce <cb_syslog_facility+0x9a>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  12e6 <cb_syslog_facility+0xb2>
jmp    12f1 <cb_syslog_facility+0xbd>
mov    $0x1,%ebx
jmp    12f1 <cb_syslog_facility+0xbd>
mov    %eax,%ebx
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cb_syslog_facility (enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr, grecs_value_t *value, void *cb_data)
{
  const char *str;
  if (assert_grecs_value_type (locus, value, 0))
    return 1;
  str = value->v.string;
  if (c_isdigit (str[0]))
    {
      char *p;
      int n = strtoul (str, &p, 10);
      if (*p)
 grecs_error (locus, 0,
       gettext("expected facility number or symbolic name"));
      else
 *(int *) varptr = n;
    }
  else if (string_to_syslog_facility (str, varptr))
    grecs_error (locus, 0, gettext("unknown syslog facility `%s'"), str);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 9
18 9
19 9
20 9
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 15
29 15
30 14
31 14
32 14
33 14
34 14
35 14
36 12
37 12
38 19
39 19
40 19
41 19
42 19
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 7
53 7
54 21
55 22
56 22
57 22
58 22
59 22
60 22
61 22
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rbp        # ba <_location_dump_table+0x11>
shl    $0x4,%rbp
add    $0x0,%rbp
cmp    $0x0,%rbp
jbe    108 <_location_dump_table+0x5f>
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%r13d
mov    0x8(%rbx),%ecx
mov    (%rbx),%rdx
test   %rdx,%rdx
cmove  %r13,%rdx
mov    0xc(%rbx),%r8d
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  ff <_location_dump_table+0x56>
add    $0x10,%rbx
cmp    %rbx,%rbp
ja     dc <_location_dump_table+0x33>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_location_dump_table (fp)
     FILE *fp;
{
  register ma_table_t *tp, *endp;
  endp = mlocation_table + location_table_count;
  for (tp = mlocation_table; tp < endp; tp++)
    fprintf (fp, "%s:%d\t%d\n", tp->file ? tp->file : "unknown",
    tp->line ? tp->line : 0,
    tp->nalloc);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 6
24 6
25 6
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
add    $0x1,%rbx
movzbl -0x1(%rbx),%eax
cmp    $0xa,%al
je     51 <escape_string+0x51>
cmp    $0xa,%al
jg     2a <escape_string+0x2a>
test   %al,%al
je     be <escape_string+0xbe>
cmp    $0x9,%al
je     42 <escape_string+0x42>
jmp    9d <escape_string+0x9d>
cmp    $0x24,%al
nopl   0x0(%rax)
je     6f <escape_string+0x6f>
cmp    $0x5c,%al
je     7e <escape_string+0x7e>
cmp    $0x20,%al
jne    9d <escape_string+0x9d>
nopw   0x0(%rax,%rax,1)
jmp    60 <escape_string+0x60>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  4f <escape_string+0x4f>
jmp    c <escape_string+0xc>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  5e <escape_string+0x5e>
jmp    c <escape_string+0xc>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  6d <escape_string+0x6d>
jmp    c <escape_string+0xc>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  7c <escape_string+0x7c>
jmp    c <escape_string+0xc>
mov    0x0(%rip),%rdx        # 85 <escape_string+0x85>
cmpl   $0x0,0x18(%rdx)
js     9d <escape_string+0x9d>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  98 <escape_string+0x98>
jmpq   c <escape_string+0xc>
movsbl %al,%edi
mov    %rbp,%rsi
callq  a8 <escape_string+0xa8>
cmp    $0xffffffff,%eax
jne    c <escape_string+0xc>
mov    %rbp,%rdi
callq  b9 <escape_string+0xb9>
jmpq   c <escape_string+0xc>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
escape_string (register FILE *out, register char const *s)
{
  register char c;
  for (;;)
    switch ((c = *s++))
      {
      case 0:
        return;
      case '\t':
        aputs ("\\t", out);
        break;
      case '\n':
        aputs ("\\n", out);
        break;
      case ' ':
        aputs ("\\040", out);
        break;
      case '$':
        aputs ("\\044", out);
        break;
      case '\\':
        if (((5) - 5) <= (top->behavior. version))
          {
            aputs ("\\\\", out);
            break;
          }
      default:
        do if (_IO_putc (c, out) == (-1)) testOerror (out); while (0);
        break;
      }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 10
27 10
28 10
29 11
30 13
31 13
32 13
33 14
34 16
35 16
36 16
37 17
38 19
39 19
40 19
41 20
42 22
43 22
44 22
45 24
46 24
47 24
48 25
49 28
50 28
51 28
52 28
53 28
54 28
55 28
56 28
57 31
58 31
59 31
60 31
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rdx,%rbp
mov    (%rdi),%rdi
callq  14 <gcd_hook+0x14>
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gcd_hook (void *p, mp_srcptr gp, mp_size_t gn,
   mp_srcptr qp, mp_size_t qn, int d)
{
  struct gcd_ctx *ctx = (struct gcd_ctx *) p;
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (ctx->gp, gp, gn); } while (0); } while (0);
  ctx->gn = gn;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 7
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebx
mov    %esi,%r12d
mov    $0x77,%esi
callq  e3c <connect>
movslq %ebx,%rbp
mov    0x0(,%rbp,8),%rsi
mov    %r12d,%edi
callq  111b <outchar+0x26>
mov    0x0(,%rbp,8),%rdi
callq  1128 <outchar+0x33>
test   %eax,%eax
je     114c <outchar+0x57>
callq  1131 <outchar+0x3c>
mov    (%rax),%edi
callq  1138 <outchar+0x43>
mov    %rax,%rdx
mov    %ebx,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  114c <outchar+0x57>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
outchar(int channel, int c)
{
      connect(channel, 'w');
      fputc(c, stream[channel]);
      if (ferror(stream[channel]))
         fault("unable to output to channel %d - %s", channel,
            strerror((*__errno_location ())));
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 7
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  c4 <rmt_error+0x8>
mov    %rax,%rsi
mov    %ebx,%edi
callq  0 <rmt_error_message>
pop    %rbx
retq   
<<<sep_in_sample>>>
rmt_error (int code)
{
  rmt_error_message (code, strerror (code));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %esi,%esi
jne    1e2 <fh_docstr+0x10>
mov    (%rdi),%r12
jmp    1e5 <fh_docstr+0x13>
mov    (%rdx),%r12
mov    %r12,%rdi
callq  1ed <fh_docstr+0x1b>
mov    %rax,%rbx
test   %rax,%rax
jne    213 <fh_docstr+0x41>
callq  1fa <fh_docstr+0x28>
mov    %r12,%rcx
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  213 <fh_docstr+0x41>
mov    0x8(%rbx),%rsi
mov    %rbp,%rdi
callq  21f <fh_docstr+0x4d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_docstr (format_data_t form, int argc, char *argv[])
{
  const char *name;
  struct format *frm;
  name = (argc == 0) ? form->name : argv[0];
  frm = format_find (name);
  if (!frm)
    error (1, (*__errno_location ()), "unknown format: `%s'", name);
  put_string (form, frm->docstr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
mov    0x64(%rdi),%eax
retq   
<<<sep_in_sample>>>
swicol_get_master_alarm_status(SWICOL * swicol)
{
 return swicol->master_alarmM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
callq  3ccc <make_local_assoc_variable+0x6>
mov    %rax,%rbx
test   %rax,%rax
je     3cf4 <make_local_assoc_variable+0x2e>
testb  $0x40,0x28(%rax)
jne    3cf4 <make_local_assoc_variable+0x2e>
mov    %rax,%rdi
callq  987 <dispose_variable_value>
mov    $0x0,%edi
callq  3cec <make_local_assoc_variable+0x26>
mov    %rax,0x8(%rbx)
orl    $0x40,0x28(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
make_local_assoc_variable (name)
     char *name;
{
  SHELL_VAR *var;
  HASH_TABLE *hash;
  var = make_local_variable (name);
  if (var == 0 || ((((var)->attributes) & (0x0000040))))
    return var;
  dispose_variable_value (var);
  hash = (hash_create((0)));
  ((var)->value = (char *)(hash));
  ((var)->attributes |= (0x0000040));
  return var;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 7
5 7
6 7
7 7
8 9
9 9
10 10
11 10
12 11
13 12
14 14
15 14
16 14
<<<sep_out_sample>>>
push   %rbx
add    $0xffffffffffffff80,%rsp
mov    0x0(%rip),%rax        # dc2 <pies_pause+0xc>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # dcd <pies_pause+0x17>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # dd9 <pies_pause+0x23>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # de5 <pies_pause+0x2f>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # df1 <pies_pause+0x3b>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # dfd <pies_pause+0x47>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # e09 <pies_pause+0x53>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%rax        # e15 <pies_pause+0x5f>
mov    %rax,0x38(%rsp)
mov    0x0(%rip),%rax        # e21 <pies_pause+0x6b>
mov    %rax,0x40(%rsp)
mov    0x0(%rip),%rax        # e2d <pies_pause+0x77>
mov    %rax,0x48(%rsp)
mov    0x0(%rip),%rax        # e39 <pies_pause+0x83>
mov    %rax,0x50(%rsp)
mov    0x0(%rip),%rax        # e45 <pies_pause+0x8f>
mov    %rax,0x58(%rsp)
mov    0x0(%rip),%rax        # e51 <pies_pause+0x9b>
mov    %rax,0x60(%rsp)
mov    0x0(%rip),%rax        # e5d <pies_pause+0xa7>
mov    %rax,0x68(%rsp)
mov    0x0(%rip),%rax        # e69 <pies_pause+0xb3>
mov    %rax,0x70(%rsp)
mov    0x0(%rip),%rax        # e75 <pies_pause+0xbf>
mov    %rax,0x78(%rsp)
mov    0x0(%rip),%eax        # e80 <pies_pause+0xca>
lea    0x1(%rax),%edi
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rsp,%rsi
callq  e9b <pies_pause+0xe5>
test   %eax,%eax
jle    eeb <pies_pause+0x135>
cmpl   $0x0,0x0(%rip)        # ea6 <pies_pause+0xf0>
js     f1b <pies_pause+0x165>
mov    $0x0,%ebx
lea    0x3f(%rbx),%edx
test   %ebx,%ebx
cmovns %ebx,%edx
sar    $0x6,%edx
movslq %edx,%rdx
mov    %ebx,%eax
sar    $0x1f,%eax
shr    $0x1a,%eax
lea    (%rbx,%rax,1),%ecx
and    $0x3f,%ecx
sub    %eax,%ecx
mov    %ecx,%eax
mov    (%rsp,%rdx,8),%rdx
bt     %rax,%rdx
jae    ede <pies_pause+0x128>
mov    %ebx,%edi
callq  ede <pies_pause+0x128>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # ee7 <pies_pause+0x131>
jge    ead <pies_pause+0xf7>
jmp    f1b <pies_pause+0x165>
test   %eax,%eax
jns    dbb <pies_pause+0x5>
callq  ef8 <pies_pause+0x142>
mov    (%rax),%edi
cmp    $0x4,%edi
je     f1b <pies_pause+0x165>
callq  f04 <pies_pause+0x14e>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x3,%edi
mov    $0x0,%eax
callq  f1b <pies_pause+0x165>
sub    $0xffffffffffffff80,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
pies_pause ()
{
  while (1)
    {
      fd_set rdset = listenset;
      int rc = select (fd_max + 1, &rdset, ((void *)0), ((void *)0), ((void *)0));
      if (rc > 0)
 {
   int i;
   for (i = 0; i <= fd_max; i++)
     {
       if (((((&rdset)->fds_bits)[((i) / (8 * (int) sizeof (__fd_mask)))] & ((__fd_mask) 1 << ((i) % (8 * (int) sizeof (__fd_mask))))) != 0))
  progman_accept (i);
     }
   break;
 }
      else if (rc < 0)
 {
   if ((*__errno_location ()) != 4)
     logmsg (3, "select: %s", strerror ((*__errno_location ())));
   break;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 6
36 6
37 6
38 6
39 6
40 6
41 6
42 7
43 7
44 10
45 10
46 10
47 12
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 12
56 12
57 12
58 12
59 12
60 12
61 12
62 13
63 13
64 10
65 10
66 10
67 10
68 17
69 17
70 19
71 19
72 19
73 19
74 20
75 20
76 20
77 20
78 20
79 20
80 24
81 24
82 24
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0xa,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r11
cmp    (%rdi),%r11
jne    3227 <gsl_matrix_ushort_sub+0x1f>
mov    0x8(%rsi),%r9
cmp    %rax,%r9
je     3247 <gsl_matrix_ushort_sub+0x3f>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3240 <gsl_matrix_ushort_sub+0x38>
mov    $0x13,%eax
jmp    32be <gsl_matrix_ushort_sub+0xb6>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r12
test   %r11,%r11
je     32b2 <gsl_matrix_ushort_sub+0xaa>
lea    (%rax,%rax,1),%r13
sub    %rax,%r12
add    %r12,%r12
mov    $0x0,%r10d
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    32a3 <gsl_matrix_ushort_sub+0x9b>
mov    %rax,%rcx
add    0x18(%rdi),%rcx
mov    %rax,%r8
add    0x18(%rsi),%r8
movzwl (%r8,%r10,1),%r8d
sub    %r8w,(%rcx)
add    $0x1,%rdx
add    $0x2,%rax
cmp    %r9,%rdx
jne    3270 <gsl_matrix_ushort_sub+0x68>
add    $0x1,%rbx
add    %r13,%rbp
add    %r12,%r10
cmp    %r11,%rbx
je     32b9 <gsl_matrix_ushort_sub+0xb1>
test   %r9,%r9
je     3294 <gsl_matrix_ushort_sub+0x8c>
mov    %rbp,%rax
mov    $0x0,%edx
jmp    3270 <gsl_matrix_ushort_sub+0x68>
mov    $0x0,%eax
jmp    32be <gsl_matrix_ushort_sub+0xb6>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_sub (gsl_matrix_ushort * a, const gsl_matrix_ushort * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
37 16
38 16
39 16
40 16
41 14
42 14
43 14
44 14
45 14
46 16
47 16
48 16
49 16
50 16
51 21
52 21
53 21
54 23
55 23
56 23
57 23
58 23
59 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 1b32 <debug_script+0xb>
callq  1b37 <debug_script+0x10>
test   %rbx,%rbx
je     1b6a <debug_script+0x43>
mov    0x20(%rbx),%rcx
mov    0x18(%rbx),%rdx
mov    0x8(%rbx),%r9
mov    0x10(%rbx),%r8
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1b58 <debug_script+0x31>
mov    $0x0,%eax
callq  1b62 <debug_script+0x3b>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    1b3c <debug_script+0x15>
mov    0x0(%rip),%rdi        # 1b71 <debug_script+0x4a>
callq  1b76 <debug_script+0x4f>
pop    %rbx
retq   
<<<sep_in_sample>>>
debug_script (struct change *sp)
{
  fflush_unlocked (stdout);
  for (; sp; sp = sp->link)
    {
      long int line0 = sp->line0;
      long int line1 = sp->line1;
      long int deleted = sp->deleted;
      long int inserted = sp->inserted;
      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
        line0, line1, deleted, inserted);
    }
  fflush_unlocked (stderr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 4
16 4
17 4
18 13
19 13
20 14
21 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
mov    (%rax),%rbx
lea    0x4(%rbx),%rax
cmpb   $0x2d,0x1(%rbx)
cmovne %rax,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1a1 <cmpidx_long+0x26>
mov    %rax,%r12
mov    0x0(%rbp),%rax
mov    (%rax),%rbp
lea    0x4(%rbp),%rax
cmpb   $0x2d,0x1(%rbp)
cmovne %rax,%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  1c4 <cmpidx_long+0x49>
cmp    %r12,%rax
mov    %r12,%rdx
cmovbe %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1d9 <cmpidx_long+0x5e>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cmpidx_long(const void *a, const void *b)
{
 struct grecs_opthelp const **ap = (struct grecs_opthelp const **)a;
 struct grecs_opthelp const **bp = (struct grecs_opthelp const **)b;
 char const *opta, *optb;
 size_t lena, lenb;
 if ((*ap)->opt[1] == '-')
  opta = (*ap)->opt;
 else
  opta = (*ap)->opt + 4;
 lena = strcspn(opta, ",");
 if ((*bp)->opt[1] == '-')
  optb = (*bp)->opt;
 else
  optb = (*bp)->opt + 4;
 lenb = strcspn(optb, ",");
 return strncmp(opta, optb, lena > lenb ? lenb : lena);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 10
8 10
9 10
10 11
11 11
12 11
13 11
14 12
15 12
16 15
17 15
18 15
19 16
20 16
21 16
22 17
23 17
24 17
25 17
26 17
27 17
28 18
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdx,%r12
fldt   (%rdi)
fld    %st(0)
fstpt  0x20(%rsp)
test   %rdx,%rdx
jne    e7 <gsl_stats_long_double_min+0x5d>
fstpt  0x10(%rsp)
jmp    103 <gsl_stats_long_double_min+0x79>
fldt   0x0(%rbp)
fld    %st(0)
fstpt  0x10(%rsp)
fldt   0x20(%rsp)
fucomi %st(1),%st
fcmovnbe %st(1),%st
fstp   %st(1)
fstpt  0x20(%rsp)
add    %r13,%rbp
fldt   0x10(%rsp)
fstpt  (%rsp)
callq  d0 <gsl_stats_long_double_min+0x46>
test   %eax,%eax
jne    103 <gsl_stats_long_double_min+0x79>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    aa <gsl_stats_long_double_min+0x20>
fldt   0x20(%rsp)
fstpt  0x10(%rsp)
jmp    103 <gsl_stats_long_double_min+0x79>
fstp   %st(0)
shl    $0x4,%rsi
mov    %rsi,%r13
lea    (%rdi,%rsi,1),%rbp
fldt   0x20(%rsp)
fstpt  0x10(%rsp)
mov    $0x0,%ebx
jmp    c4 <gsl_stats_long_double_min+0x3a>
fldt   0x10(%rsp)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_min (const long double data[], const size_t stride,
                          const size_t n)
{
  long double min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      long double xi = data[i * stride];
      if (xi < min)
        min = xi;
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        return xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 6
11 6
12 4
13 4
14 8
15 8
16 8
17 9
18 9
19 8
20 8
21 8
22 8
23 11
24 11
25 11
26 11
27 11
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 8
39 8
40 6
41 6
42 15
43 15
44 15
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
movl   $0x0,(%rsi)
movzbl (%rdi),%ebx
test   %bl,%bl
je     3ef <mu_argcv_quoted_length+0x94>
mov    $0x0,%r12d
cmp    $0x20,%bl
jne    391 <mu_argcv_quoted_length+0x36>
add    $0x1,%r12
movl   $0x1,0x0(%r13)
jmp    3e1 <mu_argcv_quoted_length+0x86>
cmp    $0x22,%bl
jne    3a4 <mu_argcv_quoted_length+0x49>
add    $0x2,%r12
movl   $0x1,0x0(%r13)
jmp    3e1 <mu_argcv_quoted_length+0x86>
cmp    $0x5c,%bl
je     3c9 <mu_argcv_quoted_length+0x6e>
cmp    $0x9,%bl
je     3c9 <mu_argcv_quoted_length+0x6e>
xchg   %ax,%ax
callq  3b5 <mu_argcv_quoted_length+0x5a>
movsbq %bl,%rdx
mov    (%rax),%rax
testb  $0x40,0x1(%rax,%rdx,2)
je     3c9 <mu_argcv_quoted_length+0x6e>
add    $0x1,%r12
jmp    3e1 <mu_argcv_quoted_length+0x86>
movsbl %bl,%edi
callq  3d1 <mu_argcv_quoted_length+0x76>
lea    0x2(%r12),%rdx
add    $0x4,%r12
cmp    $0xffffffff,%eax
cmovne %rdx,%r12
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    37e <mu_argcv_quoted_length+0x23>
jmp    3f5 <mu_argcv_quoted_length+0x9a>
mov    $0x0,%r12d
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_argcv_quoted_length (const char *str, int *quote)
{
  size_t len = 0;
  *quote = 0;
  for (; *str; str++)
    {
      if (*str == ' ')
 {
   len++;
   *quote = 1;
 }
      else if (*str == '"')
 {
   len += 2;
   *quote = 1;
 }
      else if (*str != '\t' && *str != '\\' && ((*__ctype_b_loc ())[(int) ((*str))] & (unsigned short int) _ISprint))
 len++;
      else if (mu_argcv_quote_char (*str) != -1)
 len += 2;
      else
 len += 4;
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 5
11 5
12 3
13 7
14 7
15 9
16 10
17 10
18 12
19 12
20 14
21 15
22 15
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 18
34 18
35 19
36 19
37 20
38 20
39 20
40 20
41 5
42 5
43 5
44 5
45 5
46 3
47 25
48 25
49 25
50 25
51 25
52 25
53 25
<<<sep_out_sample>>>
cmp    $0x1,%esi
jle    158b <fh_rep+0x8f>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rdx,%r12
mov    $0xa,%edx
lea    0x8(%rsp),%rsi
mov    (%r12),%rdi
callq  1528 <fh_rep+0x2c>
mov    %rax,%rbx
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
je     154e <fh_rep+0x52>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  154e <fh_rep+0x52>
lea    -0x1(%rbx),%r13d
test   %ebx,%ebx
je     1581 <fh_rep+0x85>
mov    %r13d,%r13d
add    $0x1,%r13
mov    $0x0,%ebx
mov    0x8(%r12),%rax
mov    %rax,0x18(%rbp)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  1578 <fh_rep+0x7c>
add    $0x1,%rbx
cmp    %r13,%rbx
jne    1562 <fh_rep+0x66>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
fh_rep (format_data_t form, int argc, char *argv[])
{
  unsigned int count;
  char *p;
  if (argc < 2)
    return;
  count = strtoul (argv[0], &p, 10);
  if (*p)
    error (1, 0, "invalid repeat count");
  while (count--)
    {
      form->format = argv[1];
      print_interfaceX (form, 0);
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 10
29 12
30 12
31 13
32 13
33 13
34 13
35 10
36 10
37 15
38 15
39 15
40 15
41 15
42 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %esi,%ebx
callq  48 <_s_shutdown+0xc>
mov    (%rax),%rdi
mov    $0x16,%eax
test   %rdi,%rdi
je     88 <_s_shutdown+0x4c>
lea    0x8(%rsp),%rsi
callq  5f <_s_shutdown+0x23>
mov    $0x0,%esi
cmp    $0x1,%ebx
je     74 <_s_shutdown+0x38>
cmp    $0x2,%ebx
sete   %sil
movzbl %sil,%esi
mov    0x8(%rsp),%edi
callq  7d <_s_shutdown+0x41>
test   %eax,%eax
je     88 <_s_shutdown+0x4c>
callq  86 <_s_shutdown+0x4a>
mov    (%rax),%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_s_shutdown (mu_stream_t stream, int how)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  int flag;
  mu_transport_t trans;
  if (s->fstream == ((void *)0))
    return 22;
  mu_stream_get_transport(s->fstream, &trans);
  switch (how)
    {
    case 0x00000001:
      flag = SHUT_RD;
      break;
    case 0x00000002:
      flag = SHUT_WR;
    }
  if (shutdown ((int) trans, flag))
    return (*__errno_location ());
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 6
6 7
7 6
8 6
9 8
10 8
11 12
12 9
13 9
14 15
15 15
16 15
17 17
18 17
19 17
20 17
21 18
22 18
23 20
24 20
25 20
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    $0x0,%edx
movw   $0x0,(%rax)
add    $0x4,%rax
cmp    %rdx,%rax
jne    a <init_block+0xa>
mov    $0x0,%eax
mov    $0x0,%edx
movw   $0x0,(%rax)
add    $0x4,%rax
cmp    %rdx,%rax
jne    22 <init_block+0x22>
mov    $0x0,%eax
mov    $0x0,%edx
movw   $0x0,(%rax)
add    $0x4,%rax
cmp    %rdx,%rax
jne    3a <init_block+0x3a>
movw   $0x1,0x0(%rip)        # 51 <init_block+0x51>
movq   $0x0,0x0(%rip)        # 5c <init_block+0x5c>
movq   $0x0,0x0(%rip)        # 67 <init_block+0x67>
movl   $0x0,0x0(%rip)        # 71 <init_block+0x71>
movl   $0x0,0x0(%rip)        # 7b <init_block+0x7b>
movl   $0x0,0x0(%rip)        # 85 <init_block+0x85>
movb   $0x0,0x0(%rip)        # 8c <init_block+0x8c>
movb   $0x1,0x0(%rip)        # 93 <init_block+0x93>
retq   
<<<sep_in_sample>>>
init_block()
{
    int n;
    for (n = 0; n < (256 +1+29); n++) dyn_ltree[n].fc.freq = 0;
    for (n = 0; n < 30; n++) dyn_dtree[n].fc.freq = 0;
    for (n = 0; n < 19; n++) bl_tree[n].fc.freq = 0;
    dyn_ltree[256].fc.freq = 1;
    opt_len = static_len = 0L;
    last_lit = last_dist = last_flags = 0;
    flags = 0; flag_bit = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 7
20 8
21 8
22 9
23 9
24 9
25 10
26 10
27 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  47c <mbstrpbrk+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mbstrpbrk(const char *s, const char *accept)
{
    ((void) (0));
 return (char *) strpbrk(s, accept);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     5b <sdp_message_o_username_get+0xa>
mov    0x8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
sdp_message_o_username_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->o_username;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     404 <_rl_errmsg+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rcx        # 435 <_rl_errmsg+0x8d>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  449 <_rl_errmsg+0xa1>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 458 <_rl_errmsg+0xb0>
callq  45d <_rl_errmsg+0xb5>
mov    0x0(%rip),%rsi        # 464 <_rl_errmsg+0xbc>
mov    $0xa,%edi
callq  46e <_rl_errmsg+0xc6>
mov    0x0(%rip),%rdi        # 475 <_rl_errmsg+0xcd>
callq  47a <_rl_errmsg+0xd2>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_errmsg (const char *format, ...)
{
  va_list args;
  __builtin_va_start(args,format);
  fprintf (stderr, "readline: ");
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  fflush (stderr);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 6
34 7
35 7
36 7
37 8
38 8
39 10
40 10
41 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 65b3 <us_mt_hdy+0x27>
movl   $0x0,0x0(%rip)        # 65bd <us_mt_hdy+0x31>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  65c9 <us_mt_hdy+0x3d>
cmp    $0x734,%ebx
jle    6642 <us_mt_hdy+0xb6>
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %ebx,%edx
mov    $0xb,%esi
mov    $0x1,%edi
callq  65ed <us_mt_hdy+0x61>
mov    %eax,%r15d
mov    0x0(%rip),%rax        # 65f7 <us_mt_hdy+0x6b>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 6603 <us_mt_hdy+0x77>
callq  6608 <us_mt_hdy+0x7c>
mov    0x70(%rsp),%esi
mov    %esi,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0xb,(%rsp)
lea    0x1(%r15),%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  6642 <us_mt_hdy+0xb6>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
us_mt_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_MT";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  if (year > 1844)
    {
      register int day;
      day = eval_holiday (1, 11, year, 1, (0==0)) + 1;
      holiday (*init_data, detected, gettext(hd_text[100].ht_text),
        ptr_cc_id, "+", day, 11, year, hd_elems, fday, count);
    }
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 12
16 12
17 12
18 13
19 13
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
lea    0x2a(%rdx,%rdx,1),%rsi
mov    $0x1,%edi
callq  a5 <mu_secret_create+0x22>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     e3 <mu_secret_create+0x60>
lea    0x28(%rbx),%rsi
mov    %rsi,0x10(%rbx)
lea    0x1(%rsi,%rbp,1),%rdx
mov    %rdx,0x18(%rbx)
mov    %rbp,%rdx
mov    %r13,%rdi
callq  0 <obfuscate>
mov    %rbp,0x8(%rbx)
mov    %rbx,(%r12)
mov    %rbx,%rdi
callq  de <mu_secret_create+0x5b>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_secret_create (mu_secret_t *psec, const char *value, size_t len)
{
  mu_secret_t sec;
  sec = calloc (1, sizeof (sec[0]) + 2 * (len + 1));
  if (!sec)
    return 12;
  sec->obptr = (unsigned char*)(sec + 1);
  sec->clptr = sec->obptr + len + 1;
  obfuscate ((unsigned char *) value, sec->obptr, len);
  sec->length = len;
  *psec = sec;
  mu_secret_ref (sec);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 6
14 5
15 5
16 7
17 7
18 8
19 8
20 9
21 9
22 9
23 10
24 11
25 12
26 12
27 13
28 14
29 14
30 14
31 14
32 14
33 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 142 <mu_set_mailbox_pattern+0xb>
test   %rdi,%rdi
je     14c <mu_set_mailbox_pattern+0x15>
callq  14c <mu_set_mailbox_pattern+0x15>
test   %rbx,%rbx
jne    163 <mu_set_mailbox_pattern+0x2c>
movq   $0x0,0x0(%rip)        # 15c <mu_set_mailbox_pattern+0x25>
mov    $0x0,%eax
jmp    17b <mu_set_mailbox_pattern+0x44>
mov    %rbx,%rdi
callq  16b <mu_set_mailbox_pattern+0x34>
mov    %rax,0x0(%rip)        # 172 <mu_set_mailbox_pattern+0x3b>
cmp    $0x1,%rax
sbb    %eax,%eax
and    $0xc,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_set_mailbox_pattern (const char *pat)
{
  if (_mu_mailbox_pattern)
    free (_mu_mailbox_pattern);
  if (!pat)
    {
      _mu_mailbox_pattern = ((void *)0);
      return 0;
    }
  _mu_mailbox_pattern = strdup (pat);
  return _mu_mailbox_pattern ? 0 : 12;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 7
10 8
11 8
12 10
13 10
14 10
15 11
16 11
17 11
18 12
19 12
<<<sep_out_sample>>>
mov    %sil,0x19(%rdi)
retq   
<<<sep_in_sample>>>
rec_writer_set_skip_comments (rec_writer_t writer,
                              _Bool value)
{
  writer->skip_comments_p = value;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x50(%r8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, start_index, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1af4 <gsl_sf_lncosh+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1b1a <gsl_sf_lncosh+0x32>
mov    %eax,%ecx
mov    $0x2ea,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b13 <gsl_sf_lncosh+0x2b>
movsd  (%rsp),%xmm0
jmp    1b1a <gsl_sf_lncosh+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_lncosh(const double x)
{
  gsl_sf_result result; int status = gsl_sf_lncosh_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_lncosh_e(x, &result)", "trig.c", 746, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 2af <output_init+0xb>
lea    (%rax,%rax,1),%rdx
lea    (%rdx,%rax,1),%r9
mov    0x0(,%r9,8),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  *0x0(,%r9,8)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
output_init()
{
     output_driver[driver_index].handler(cflow_output_init,
      ((void *)0), 0,
      ((void *)0),
             output_driver[driver_index].handler_data);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 7
12 7
<<<sep_out_sample>>>
mov    %edi,%eax
and    $0x100,%ax
cmp    $0x1,%ax
sbb    %eax,%eax
and    $0xffffffbb,%eax
add    $0x72,%eax
mov    %al,(%rsi)
mov    %edi,%eax
and    $0x80,%ax
cmp    $0x1,%ax
sbb    %eax,%eax
and    $0xffffffb6,%eax
add    $0x77,%eax
mov    %al,0x1(%rsi)
and    $0x40,%di
cmp    $0x1,%di
sbb    %eax,%eax
and    $0xffffffb5,%eax
add    $0x78,%eax
mov    %al,0x2(%rsi)
retq   
<<<sep_in_sample>>>
rwx (unsigned short bits, char *chars)
{
  chars[0] = (bits & 0400) ? 'r' : '-';
  chars[1] = (bits & 0200) ? 'w' : '-';
  chars[2] = (bits & 0100) ? 'x' : '-';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  386c <buffer_uninit+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
buffer_uninit (Buffer *buffer)
{
  xfree (buffer->data);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
callq  ac8 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  131 <pair_table_new+0xb>
mov    %rax,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
mov    %rax,%rdi
callq  151 <pair_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
pair_table_new (void)
{
  struct pair_htable * res;
  res = ((struct pair_htable *) xmalloc (sizeof (struct pair_htable) * (1)));
  hash_init (res, 8,
      (hash_func_t) pair_hash_1,
      (hash_func_t) pair_hash_2,
      (hash_cmp_func_t) pair_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 10
12 10
13 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rdx,%rbp
lea    0x8(%rsp),%rdi
callq  2e6 <osip_uri_param_add+0x1b>
mov    %eax,%ecx
test   %ecx,%ecx
jne    327 <osip_uri_param_add+0x5c>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  2fc <osip_uri_param_add+0x31>
mov    %eax,%ebx
test   %eax,%eax
je     310 <osip_uri_param_add+0x45>
mov    0x8(%rsp),%rdi
callq  30c <osip_uri_param_add+0x41>
mov    %ebx,%eax
jmp    327 <osip_uri_param_add+0x5c>
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
mov    %r12,%rdi
callq  322 <osip_uri_param_add+0x57>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_uri_param_add (osip_list_t * url_params, char *pname, char *pvalue)
{
  int i;
  osip_uri_param_t *url_param;
  i = osip_uri_param_init (&url_param);
  if (i != 0)
    return i;
  i = osip_uri_param_set (url_param, pname, pvalue);
  if (i != 0) {
    osip_uri_param_free (url_param);
    return i;
  }
  osip_list_add (url_params, url_param, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 10
21 10
22 11
23 11
24 13
25 13
26 13
27 13
28 14
29 15
30 15
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     45a <rtrim+0x88>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdi
not    %rdi
callq  3f9 <rtrim+0x27>
mov    %rax,%rbx
test   %rax,%rax
je     461 <rtrim+0x8f>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  40c <rtrim+0x3a>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %ecx,%edx
sub    $0x1,%edx
js     444 <rtrim+0x72>
movslq %edx,%rax
movzbl (%rbx,%rax,1),%eax
lea    -0x9(%rax),%esi
cmp    $0x1,%sil
jbe    43f <rtrim+0x6d>
cmp    $0x20,%al
jne    444 <rtrim+0x72>
sub    $0x1,%edx
jns    42b <rtrim+0x59>
movslq %edx,%rdx
sub    $0x1,%rcx
cmp    %rcx,%rdx
je     468 <rtrim+0x96>
movb   $0x0,0x1(%rbx,%rdx,1)
mov    %rbx,%rax
jmp    46b <rtrim+0x99>
mov    $0x0,%eax
jmp    46b <rtrim+0x99>
mov    $0x0,%eax
jmp    46b <rtrim+0x99>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rtrim(str string)
{
  if(!string) return ((void *)0);
  str _s = (str) malloc(strlen(string)+1);
  if(!_s) return ((void *)0);
  strcpy(_s, string);
  int i;
  for(i = strlen(_s)-1; i >= 0; i--)
    if(_s[i] == ' ' || _s[i] == '\t' || _s[i] == '\n') continue;
    else break;
  if(i == strlen(_s)-1) return _s;
  else { _s[i+1] = '\0'; return _s; }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 6
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 8
36 8
37 11
38 11
39 11
40 11
41 12
42 12
43 12
44 3
45 3
46 5
47 5
48 11
49 13
50 13
51 13
52 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2933 <sshget_out+0x7>
retq   
<<<sep_in_sample>>>
sshget_out (void)
{
        return sshout;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %edx,%eax
retq   
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%r9
movzbl (%rdi),%edx
mov    $0x0,%eax
test   %dl,%dl
je     77 <mu_ltrim_class+0x77>
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rax
sub    $0x1,%rax
je     77 <mu_ltrim_class+0x77>
test   %dl,%dl
js     77 <mu_ltrim_class+0x77>
movsbl %dl,%edx
test   %esi,0x0(,%rdx,4)
je     77 <mu_ltrim_class+0x77>
mov    $0x0,%r8d
add    $0x1,%r8
cmp    %rax,%r8
je     5e <mu_ltrim_class+0x5e>
movzbl (%r9,%r8,1),%edx
test   %dl,%dl
js     59 <mu_ltrim_class+0x59>
movsbl %dl,%edx
test   %esi,0x0(,%rdx,4)
jne    3b <mu_ltrim_class+0x3b>
test   %r8,%r8
je     77 <mu_ltrim_class+0x77>
sub    %r8,%rax
mov    %rax,%rbx
lea    0x1(%rax),%rdx
lea    (%r9,%r8,1),%rsi
mov    %r9,%rdi
callq  74 <mu_ltrim_class+0x74>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_ltrim_class (char *str, int class)
{
  size_t i, len;
  if (!*str)
    return 0;
  len = strlen (str);
  for (i = 0; i < len && (((unsigned)(str[i])) < 128 && mu_c_tab[(unsigned)(str[i])] & (class)); i++)
    ;
  if (i)
    {
      len -= i;
      memmove (str, str + i, len + 1);
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 11
31 11
32 12
33 12
34 12
35 12
36 11
37 15
38 15
<<<sep_out_sample>>>
mov    (%rdi),%r10
cmp    0x8(%rdi),%r10
je     45cf <gsl_matrix_uchar_transpose+0x76>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  457f <gsl_matrix_uchar_transpose+0x26>
mov    $0x14,%eax
jmp    45e8 <gsl_matrix_uchar_transpose+0x8f>
mov    %r11,%r8
lea    0x1(%r8),%r11
cmp    %r10,%r11
je     45dc <gsl_matrix_uchar_transpose+0x83>
mov    %r11,%rax
mov    0x10(%rdi),%rcx
mov    %rax,%rdx
imul   %rcx,%rdx
add    %r8,%rdx
mov    0x18(%rdi),%rsi
imul   %r8,%rcx
add    %rax,%rcx
add    %rsi,%rcx
movzbl (%rcx),%r9d
movzbl (%rsi,%rdx,1),%esi
mov    %sil,(%rcx)
mov    0x18(%rdi),%rcx
mov    %r9b,(%rcx,%rdx,1)
add    $0x1,%rax
cmp    %r10,%rax
jne    4595 <gsl_matrix_uchar_transpose+0x3c>
jmp    4586 <gsl_matrix_uchar_transpose+0x2d>
test   %r10,%r10
je     45e2 <gsl_matrix_uchar_transpose+0x89>
mov    $0x0,%r8d
jmp    4589 <gsl_matrix_uchar_transpose+0x30>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_transpose (gsl_matrix_uchar * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned char tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 10
13 12
14 12
15 12
16 12
17 16
18 17
19 17
20 17
21 19
22 16
23 16
24 19
25 19
26 20
27 20
28 21
29 21
30 12
31 12
32 12
33 12
34 10
35 10
36 10
37 10
38 26
39 26
40 26
41 26
42 27
43 27
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # da <close_logfile+0x7>
mov    (%rax),%rsi
test   %rsi,%rsi
je     103 <close_logfile+0x30>
sub    $0x8,%rsp
mov    $0xa,%edi
callq  f0 <close_logfile+0x1d>
mov    0x0(%rip),%rax        # f7 <close_logfile+0x24>
mov    (%rax),%rdi
callq  ff <close_logfile+0x2c>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
close_logfile(void)
{
  if (logfile){
    fputc('\n',logfile);
    fclose(logfile);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 4
7 4
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     e65 <gsl_matrix_ulong_fread+0x43>
shl    $0x3,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     ea6 <gsl_matrix_ulong_fread+0x84>
jmp    e7c <gsl_matrix_ulong_fread+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  e7a <gsl_matrix_ulong_fread+0x58>
jmp    ea6 <gsl_matrix_ulong_fread+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  e94 <gsl_matrix_ulong_fread+0x72>
test   %eax,%eax
jne    ea6 <gsl_matrix_ulong_fread+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    e7c <gsl_matrix_ulong_fread+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_ulong_fread (FILE * stream, gsl_matrix_ulong * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_ulong_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_ulong_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
mov    0x8(%rdi),%rsi
movslq 0x4(%rdi),%rcx
mov    0x10(%rdi),%rdi
test   %rsi,%rsi
jle    5a <__gmpf_get_si+0x5a>
mov    %rcx,%rax
sar    $0x3f,%rax
mov    %rax,%rdx
xor    %rcx,%rdx
sub    %rax,%rdx
mov    $0x0,%eax
cmp    %rdx,%rsi
jg     32 <__gmpf_get_si+0x32>
sub    %rsi,%rdx
mov    (%rdi,%rdx,8),%rax
test   %rcx,%rcx
jle    45 <__gmpf_get_si+0x45>
movabs $0x7fffffffffffffff,%rdx
and    %rdx,%rax
retq   
sub    $0x1,%rax
movabs $0x7fffffffffffffff,%rdx
and    %rdx,%rax
not    %rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
__gmpf_get_si (mpf_srcptr f)
{
  mp_exp_t exp;
  mp_size_t size, abs_size;
  mp_srcptr fp;
  mp_limb_t fl;
  exp = ((f)->_mp_exp);
  size = ((f)->_mp_size);
  fp = ((f)->_mp_d);
  if (exp <= 0)
    return 0L;
  fl = 0;
  abs_size = ((size) >= 0 ? (size) : -(size));
  if (abs_size >= exp)
    fl = fp[abs_size-exp];
  if (size > 0)
    return fl & 9223372036854775807L;
  else
    return -1 - (long) ((fl - 1) & 9223372036854775807L);
}
<<<sep_in_sample>>>
1 7
2 8
3 9
4 10
5 10
6 13
7 13
8 13
9 13
10 13
11 12
12 14
13 14
14 15
15 15
16 16
17 16
18 17
19 17
20 17
21 19
22 19
23 19
24 19
25 19
26 11
27 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
orq    $0x40,0x0(%rip)        # 42a <_rl_vi_callback_getchar+0x12>
callq  42f <_rl_vi_callback_getchar+0x17>
mov    %eax,%ebx
andq   $0xffffffffffffffbf,0x0(%rip)        # 439 <_rl_vi_callback_getchar+0x21>
test   %eax,%eax
js     464 <_rl_vi_callback_getchar+0x4c>
callq  442 <_rl_vi_callback_getchar+0x2a>
mov    %ebx,%ecx
cmp    $0x1,%rax
jbe    469 <_rl_vi_callback_getchar+0x51>
cmpl   $0x0,0x0(%rip)        # 451 <_rl_vi_callback_getchar+0x39>
jne    469 <_rl_vi_callback_getchar+0x51>
mov    %r12d,%edx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  460 <_rl_vi_callback_getchar+0x48>
mov    %eax,%ecx
jmp    469 <_rl_vi_callback_getchar+0x51>
mov    $0xffffffff,%ecx
mov    %ecx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_rl_vi_callback_getchar (mb, mlen)
     char *mb;
     int mlen;
{
  int c;
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  if (c < 0)
    return -1;
  if ((__ctype_get_mb_cur_max ()) > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mlen);
  return c;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 8
10 9
11 9
12 11
13 7
14 11
15 11
16 11
17 11
18 12
19 12
20 12
21 12
22 12
23 12
24 10
25 14
26 14
27 14
28 14
29 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x21,%esi
callq  1fd <strob_trunc+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strob_trunc(STROB * strb)
{
 return strob_reopen(strb, 32 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  16 <final_exit+0x8>
callq  1b <final_exit+0xd>
mov    %ebx,%edi
callq  22 <gawk_exit>
<<<sep_in_sample>>>
final_exit(int status)
{
 run_ext_exit_handlers(status);
 close_extensions();
 exit(status);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
movsd  %xmm0,0x38(%rdi)
movl   $0x0,0x4(%rdi)
movsd  %xmm0,0x8(%rdi)
movsd  %xmm0,0x10(%rdi)
movsd  %xmm0,0x18(%rdi)
movsd  %xmm0,0x20(%rdi)
movsd  %xmm0,0x28(%rdi)
movsd  %xmm0,0x30(%rdi)
movl   $0x0,0x68(%rdi)
movq   $0x0,0x40(%rdi)
movq   $0x0,0x48(%rdi)
movq   $0x0,0x50(%rdi)
movq   $0x0,0x58(%rdi)
movq   $0x0,0x60(%rdi)
movl   $0x0,0x6c(%rdi)
movq   $0x0,0x80(%rdi)
movq   $0x0,0x78(%rdi)
movq   $0x0,0x70(%rdi)
retq   
<<<sep_in_sample>>>
InitIFN (PIFN pifn)
{
    pifn->dTStartPeriod = 0.0;
    pifn->bOn = 0;
    pifn->dMag = 0.0;
    pifn->dTper = 0.0;
    pifn->dT0 = 0.0;
    pifn->dTexp = 0.0;
    pifn->dDecay = 0.0;
    pifn->dVal = 0.0;
    pifn->nDoses = 0;
    pifn->hMag = 0;
    pifn->hTper = 0;
    pifn->hT0 = 0;
    pifn->hTexp = 0;
    pifn->hDecay = 0;
    pifn->nDoses = pifn->iDoseCur = 0;
    pifn->rgT0s = pifn->rgTexps = pifn->rgMags = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 14
14 15
15 16
16 17
17 18
18 18
19 18
20 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmp    %rsi,0x10(%rdi)
jae    54c <xd_expand+0x39>
mov    (%rdi),%rdi
callq  52d <xd_expand+0x1a>
mov    %rax,(%rbx)
mov    0x10(%rbx),%rcx
mov    %rbp,%rdx
sub    %rcx,%rdx
lea    (%rax,%rcx,1),%rdi
mov    $0x0,%esi
callq  548 <xd_expand+0x35>
mov    %rbp,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xd_expand (struct xdatum *xd, size_t size)
{
  if (xd->dmax < size)
    {
      xd->dptr = erealloc (xd->dptr, size);
      memset (xd->dptr + xd->dmax, 0, size - xd->dmax);
      xd->dmax = size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  cb <string_cmp+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_cmp(const void *elt1, const void *elt2)
{
 return strcmp((const char *)elt1,(const char *)elt2);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    0x0(%rip),%rbx        # 191 <getgroup+0xd>
test   %rbx,%rbx
je     1f2 <getgroup+0x6e>
cmp    %edi,(%rbx)
jne    1a2 <getgroup+0x1e>
jmp    206 <getgroup+0x82>
cmp    %ebp,(%rbx)
xchg   %ax,%ax
je     206 <getgroup+0x82>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    19c <getgroup+0x18>
jmp    1f2 <getgroup+0x6e>
mov    (%rax),%r12
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x10(%rcx),%rdi
callq  1cd <getgroup+0x49>
mov    %rax,%rbx
mov    %ebp,(%rax)
lea    0x10(%rax),%rdi
mov    %r12,%rsi
callq  1de <getgroup+0x5a>
mov    0x0(%rip),%rax        # 1e5 <getgroup+0x61>
mov    %rax,0x8(%rbx)
mov    %rbx,0x0(%rip)        # 1f0 <getgroup+0x6c>
jmp    206 <getgroup+0x82>
mov    %ebp,%edi
callq  1f9 <getgroup+0x75>
mov    $0x0,%r12d
test   %rax,%rax
je     1b0 <getgroup+0x2c>
jmp    1ad <getgroup+0x29>
lea    0x10(%rbx),%rdx
cmpb   $0x0,0x10(%rbx)
mov    $0x0,%eax
cmovne %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
getgroup (gid_t gid)
{
  struct userid *tail;
  struct userid *match = ((void *)0);
  for (tail = group_alist; tail; tail = tail->next)
    {
      if (tail->id.g == gid)
        {
          match = tail;
          break;
        }
    }
  if (match == ((void *)0))
    {
      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : "";
      match = xmalloc (__builtin_offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
      match->next = group_alist;
      group_alist = match;
    }
  return match->name[0] ? match->name : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 5
15 5
16 5
17 5
18 16
19 17
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 18
28 19
29 19
30 19
31 20
32 20
33 21
34 21
35 15
36 15
37 16
38 16
39 16
40 16
41 23
42 23
43 23
44 23
45 24
46 24
47 24
48 24
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # de <php__load_buffer_state+0x7>
mov    0x0(%rip),%rdx        # e5 <php__load_buffer_state+0xe>
lea    (%rax,%rdx,8),%rdx
mov    (%rdx),%rax
mov    0x20(%rax),%rcx
mov    %rcx,0x0(%rip)        # f7 <php__load_buffer_state+0x20>
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # 102 <php__load_buffer_state+0x2b>
mov    %rax,0x0(%rip)        # 109 <php__load_buffer_state+0x32>
mov    (%rdx),%rdx
mov    (%rdx),%rdx
mov    %rdx,0x0(%rip)        # 116 <php__load_buffer_state+0x3f>
movzbl (%rax),%eax
mov    %al,0x0(%rip)        # 11f <php__load_buffer_state+0x48>
retq   
<<<sep_in_sample>>>
php__load_buffer_state (void)
{
     (yy_n_chars) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_n_chars;
 (php_text) = (yy_c_buf_p) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_buf_pos;
 php_in = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_input_file;
 (yy_hold_char) = *(yy_c_buf_p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rdi
callq  a1 <gear1_free+0xd>
mov    0x10(%rbx),%rdi
callq  aa <gear1_free+0x16>
mov    0x8(%rbx),%rdi
callq  b3 <gear1_free+0x1f>
mov    (%rbx),%rdi
callq  bb <gear1_free+0x27>
mov    %rbx,%rdi
callq  c3 <gear1_free+0x2f>
pop    %rbx
retq   
<<<sep_in_sample>>>
gear1_free (void *vstate)
{
  gear1_state_t *state = (gear1_state_t *) vstate;
  free (state->y_onestep);
  free (state->y0_orig);
  free (state->y0);
  free (state->k);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 17d0 <gcide_markup_yyget_lineno+0x6>
retq   
<<<sep_in_sample>>>
gcide_markup_yyget_lineno (void)
{
    return gcide_markup_yylineno;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  58d <DoOneMCExp+0x11>
mov    0x738(%rbx),%rdi
callq  599 <DoOneMCExp+0x1d>
mov    0xee0(%rbx),%rdx
mov    0xee8(%rbx),%rsi
mov    0xed8(%rbx),%rdi
callq  5b3 <DoOneMCExp+0x37>
mov    0x30(%rbp),%rdi
callq  5bc <DoOneMCExp+0x40>
mov    %rbp,%rdi
callq  5c4 <DoOneMCExp+0x48>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
DoOneMCExp (PANALYSIS panal, PEXPERIMENT pexp)
{
  register MONTECARLO *pmc = &panal->mc;
  InitModel ();
  ModifyParms (panal->expGlobal.plistParmMods);
  SetParms (pmc->nParms, pmc->rghvar, pmc->rgdParms);
  ModifyParms (pexp->plistParmMods);
  if (!DoOneExperiment (pexp)) {
    return 0;
  }
  return (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rdx,%rdi
mov    0x0(%rip),%rcx        # c466 <re_compile_pattern+0x11>
mov    %rcx,%rdx
shr    $0x19,%rdx
and    $0x1,%edx
shl    $0x4,%edx
movzbl 0x38(%rdi),%r8d
and    $0xffffffef,%r8d
or     %r8d,%edx
or     $0xffffff80,%edx
mov    %dl,0x38(%rdi)
mov    %rsi,%rdx
mov    %rax,%rsi
callq  b75d <re_compile_internal>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
je     c4b2 <re_compile_pattern+0x5d>
movslq %edx,%rdx
mov    0x0(,%rdx,8),%rdi
add    $0x0,%rdi
callq  c4b2 <re_compile_pattern+0x5d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
re_compile_pattern (const char *pattern, size_t length,
      struct re_pattern_buffer *bufp)
{
  reg_errcode_t ret;
  bufp->no_sub = !!(re_syntax_options & (((((((((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  bufp->newline_anchor = 1;
  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);
  if (!ret)
    return ((void *)0);
  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 9
19 8
20 8
21 10
22 10
23 10
24 10
25 11
26 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
callq  11 <_mapfile_get_transport2+0x11>
test   %rbp,%rbp
je     1e <_mapfile_get_transport2+0x1e>
movq   $0x0,0x0(%rbp)
test   %rbx,%rbx
je     29 <_mapfile_get_transport2+0x29>
movslq (%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_mapfile_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  if (pout)
    *pout = ((void *)0);
  if (pin)
    *pin = (mu_transport_t) mfs->fd;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 5
10 6
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  fd <strob_reopen+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strob_reopen(STROB * strb, size_t new_length)
{
 return strob_reopen_fill_with(strb, new_length, (int)'\0');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    (%rdi),%rbx
mov    $0x16,%eax
test   %rbx,%rbx
je     18e <mu_vartab_destroy+0xa0>
mov    %rsp,%rsi
mov    (%rbx),%rdi
callq  113 <mu_vartab_destroy+0x25>
mov    %eax,%edx
test   %edx,%edx
jne    18e <mu_vartab_destroy+0xa0>
mov    (%rsp),%rdi
callq  122 <mu_vartab_destroy+0x34>
jmp    145 <mu_vartab_destroy+0x57>
lea    0x8(%rsp),%rsi
mov    (%rsp),%rdi
callq  132 <mu_vartab_destroy+0x44>
mov    0x8(%rsp),%rdi
callq  0 <vardefn_free>
mov    (%rsp),%rdi
callq  145 <mu_vartab_destroy+0x57>
mov    (%rsp),%rdi
callq  14e <mu_vartab_destroy+0x60>
test   %eax,%eax
je     124 <mu_vartab_destroy+0x36>
mov    %rsp,%rdi
callq  15a <mu_vartab_destroy+0x6c>
mov    %rbx,%rdi
callq  162 <mu_vartab_destroy+0x74>
lea    0x8(%rbx),%rdi
mov    $0x0,%esi
callq  170 <mu_vartab_destroy+0x82>
mov    0x10(%rbx),%rdi
callq  179 <mu_vartab_destroy+0x8b>
mov    %rbx,%rdi
callq  181 <mu_vartab_destroy+0x93>
movq   $0x0,0x0(%rbp)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_vartab_destroy (mu_vartab_t *pvar)
{
  int rc;
  mu_vartab_t var = *pvar;
  mu_iterator_t itr;
  if (!var)
    return 22;
  rc = mu_assoc_get_iterator (var->assoc, &itr);
  if (rc)
    return rc;
  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);
       mu_iterator_next (itr))
    {
      struct vardefn *vd;
      mu_iterator_current (itr, (void**)&vd);
      vardefn_free (vd);
    }
  mu_iterator_destroy (&itr);
  mu_assoc_destroy (&var->assoc);
  mu_stream_destroy (&var->stream, ((void *)0));
  free (var->buf);
  free (var);
  *pvar = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 7
7 6
8 6
9 8
10 8
11 8
12 8
13 9
14 9
15 11
16 11
17 11
18 15
19 15
20 15
21 16
22 16
23 12
24 12
25 11
26 11
27 11
28 11
29 18
30 18
31 19
32 19
33 20
34 20
35 20
36 21
37 21
38 22
39 22
40 23
41 24
42 25
43 25
44 25
45 25
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%edi
callq  795 <list_encodes+0x11>
mov    %rax,%rsi
mov    %r12,%rdi
mov    $0x0,%eax
callq  7a5 <list_encodes+0x21>
cmpq   $0x0,0x0(%rip)        # 7ad <list_encodes+0x29>
je     814 <list_encodes+0x90>
mov    $0x0,%ebx
mov    $0xffffffff,%eax
mov    %rbx,%rbp
cmp    %eax,(%rbx)
je     7d9 <list_encodes+0x55>
mov    %r12,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  7d7 <list_encodes+0x53>
jmp    7f0 <list_encodes+0x6c>
mov    %r12,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  7f0 <list_encodes+0x6c>
mov    -0x8(%rbp),%rdx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  806 <list_encodes+0x82>
mov    0x0(%rbp),%eax
add    $0x10,%rbx
cmpq   $0x0,-0x8(%rbx)
jne    7b9 <list_encodes+0x35>
mov    %r12,%rsi
mov    $0xa,%edi
callq  821 <list_encodes+0x9d>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
list_encodes(FILE *f)
{
    int prev = -1;
    int i;
    fprintf(f, gettext ("Known encodings are (synonyms appear on the same line):"));
    for (i = 0; encode_tab[i].name; i++) {
 if (encode_tab[i].type != prev)
     fprintf(f, "\n\t");
 else
     fprintf(f, ", ");
 fprintf(f, "\"%s\"", encode_tab[i].name);
 prev = encode_tab[i].type;
    }
    fprintf(f, "\n");
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 3
15 3
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 10
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 6
37 6
38 14
39 14
40 14
41 16
42 16
43 16
44 16
45 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  91 <gsl_stats_long_double_lag1_autocorrelation+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  9f <gsl_stats_long_double_lag1_autocorrelation+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_lag1_autocorrelation (const long double data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_double_mean (data, stride, n);
  return gsl_stats_long_double_lag1_autocorrelation_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gl_array_iterator_free (gl_list_iterator_t *iterator)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
mov    %rdx,%r12
callq  4a4 <list_intersect+0x15>
mov    %rax,0x8(%rsp)
test   %rax,%rax
je     507 <list_intersect+0x78>
callq  4b3 <list_intersect+0x24>
mov    %rax,%r13
mov    0x8(%rsp),%rdi
callq  4c0 <list_intersect+0x31>
mov    %rax,%rbx
test   %rax,%rax
je     4f8 <list_intersect+0x69>
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  4d6 <list_intersect+0x47>
test   %rax,%rax
je     4e6 <list_intersect+0x57>
mov    %rbx,%rsi
mov    %r13,%rdi
callq  4e6 <list_intersect+0x57>
mov    0x8(%rsp),%rdi
callq  4f0 <list_intersect+0x61>
mov    %rax,%rbx
test   %rax,%rax
jne    4c8 <list_intersect+0x39>
lea    0x8(%rsp),%rdi
callq  502 <list_intersect+0x73>
mov    %r13,%rax
jmp    50c <list_intersect+0x7d>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
list_intersect (ANUBIS_LIST a, ANUBIS_LIST b, list_comp_t cmp)
{
  ANUBIS_LIST res;
  ITERATOR itr = iterator_create (a);
  void *p;
  if (!itr)
    return ((void *)0);
  res = list_create ();
  for (p = iterator_first (itr); p; p = iterator_next (itr))
    {
      if (list_locate (b, p, cmp))
 list_append (res, p);
    }
  iterator_destroy (&itr);
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 6
11 6
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 9
29 9
30 9
31 9
32 9
33 14
34 14
35 15
36 15
37 7
38 16
39 16
40 16
41 16
42 16
43 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
jns    1a <rpl_fclose+0x1a>
mov    %rbx,%rdi
callq  18 <rpl_fclose+0x18>
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  22 <rpl_fclose+0x22>
test   %eax,%eax
je     45 <rpl_fclose+0x45>
mov    %rbx,%rdi
callq  2e <rpl_fclose+0x2e>
mov    $0x1,%edx
mov    $0x0,%esi
mov    %eax,%edi
callq  3f <rpl_fclose+0x3f>
cmp    $0xffffffffffffffff,%rax
je     74 <rpl_fclose+0x74>
mov    %rbx,%rdi
callq  4d <rpl_fclose+0x4d>
test   %eax,%eax
je     74 <rpl_fclose+0x74>
callq  56 <rpl_fclose+0x56>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    %rbx,%rdi
callq  64 <rpl_fclose+0x64>
test   %r12d,%r12d
je     7c <rpl_fclose+0x7c>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
jmp    7c <rpl_fclose+0x7c>
mov    %rbx,%rdi
callq  7c <rpl_fclose+0x7c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 7
8 8
9 8
10 8
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 15
35 16
36 16
37 12
38 12
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x10,%edi
callq  28c2 <headerInitIterator+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    28d2 <headerInitIterator+0x23>
callq  28cf <headerInitIterator+0x20>
mov    %rax,%rbx
mov    %rbp,%rdi
callq  28da <headerInitIterator+0x2b>
mov    %rbp,%rdi
callq  28e2 <headerInitIterator+0x33>
mov    %rax,(%rbx)
movl   $0x0,0x8(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
headerInitIterator(Header h)
{
    HeaderIterator hi = (malloc(sizeof(struct headerIteratorS)) ? : vmefail());
    headerSort(h);
    hi->h = headerLink(h);
    hi->next_index = 0;
    return hi;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 5
15 5
16 5
17 6
18 8
19 8
20 8
21 8
22 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 4f9 <terminal_end_inverse+0xb>
test   %rdx,%rdx
je     507 <terminal_end_inverse+0x19>
mov    $0x0,%eax
callq  *%rdx
jmp    522 <terminal_end_inverse+0x34>
mov    0x0(%rip),%rdi        # 50e <terminal_end_inverse+0x20>
test   %rdi,%rdi
je     522 <terminal_end_inverse+0x34>
mov    $0x0,%edx
mov    $0x1,%esi
callq  522 <terminal_end_inverse+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_end_inverse (void)
{
  if (terminal_end_inverse_hook)
    (*terminal_end_inverse_hook) ();
  else
    {
      do { if (term_invend) tputs (term_invend, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     ca6 <err_quit+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # cdc <err_quit+0x91>
callq  ce1 <err_quit+0x96>
mov    0x0(%rip),%rsi        # ce8 <err_quit+0x9d>
mov    $0xa,%edi
callq  cf2 <err_quit+0xa7>
mov    $0x1,%edi
callq  cfc <openconn>
<<<sep_in_sample>>>
err_quit (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vfprintf (stderr, fmt, ap);
  fputs ("\n", stderr);
  __builtin_va_end(ap);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 6
28 6
29 6
30 8
31 8
<<<sep_out_sample>>>
test   %rdx,%rdx
je     43d <gsl_stats_uint_skew_m_sd+0x5b>
shl    $0x2,%rsi
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 3f8 <gsl_stats_uint_skew_m_sd+0x16>
mov    (%rdi),%ecx
cvtsi2sd %rcx,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fld    %st(0)
fmul   %st(1),%st
fmulp  %st,%st(1)
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    42d <gsl_stats_uint_skew_m_sd+0x4b>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    3f8 <gsl_stats_uint_skew_m_sd+0x16>
fstp   %st(0)
jmp    43f <gsl_stats_uint_skew_m_sd+0x5d>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_uint_skew_m_sd (const unsigned int data[],
                               const size_t stride, const size_t n,
                               const double mean, const double sd)
{
  long double skew = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      skew += (x * x * x - skew) / (i + 1);
    }
  return skew;
}
<<<sep_in_sample>>>
1 7
2 7
3 9
4 7
5 5
6 10
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 7
27 7
28 7
29 7
30 5
31 12
32 12
33 13
<<<sep_out_sample>>>
movslq %esi,%rsi
add    %rsi,%rdi
movq   $0x0,(%rdi)
movl   $0x0,0x8(%rdi)
movl   $0x5,0xc(%rdi)
retq   
<<<sep_in_sample>>>
init_infoitem(INFOLINE * inl, int offset)
{
 INFOITEM * it;
 it = (INFOITEM*)((char*)inl + offset);
 it->addrM = ((void *)0);
 it->lenM = 0;
 it->statusM = 5;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 7
6 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     80 <mu_attribute_is_modified+0xc>
mov    0x8(%rdi),%eax
and    $0x40,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_attribute_is_modified (mu_attribute_t attr)
{
  return (attr) ? attr->flags & 0x40 : 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
mov    0x0(%rip),%rax        # 11bd <quotearg_n_custom_mem+0x17>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 11c8 <quotearg_n_custom_mem+0x22>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 11d4 <quotearg_n_custom_mem+0x2e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 11e0 <quotearg_n_custom_mem+0x3a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 11ec <quotearg_n_custom_mem+0x46>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 11f8 <quotearg_n_custom_mem+0x52>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 1204 <quotearg_n_custom_mem+0x5e>
mov    %rax,0x30(%rsp)
mov    %rsp,%rdi
callq  1211 <quotearg_n_custom_mem+0x6b>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b75 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x50(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  0 <unlink_symbol>
cmpq   $0x0,0x58(%rbx)
jne    1b1 <delete_symbol+0x4c>
cmpl   $0x0,0x0(%rip)        # 17c <delete_symbol+0x17>
je     188 <delete_symbol+0x23>
cmpq   $0x0,0x90(%rbx)
jne    1b1 <delete_symbol+0x4c>
lea    0x58(%rbx),%rdi
callq  191 <delete_symbol+0x2c>
lea    0x88(%rbx),%rdi
callq  19d <delete_symbol+0x38>
lea    0x90(%rbx),%rdi
callq  1a9 <delete_symbol+0x44>
mov    %rbx,%rdi
callq  1b1 <delete_symbol+0x4c>
pop    %rbx
retq   
<<<sep_in_sample>>>
delete_symbol(Symbol *sym)
{
     unlink_symbol(sym);
     if (sym->ref_line == ((void *)0) && !(reverse_tree && sym->callee)) {
   linked_list_destroy(&sym->ref_line);
   linked_list_destroy(&sym->caller);
   linked_list_destroy(&sym->callee);
   free(sym);
     }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 7
15 7
16 8
17 8
18 10
19 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  5d <_osip_message_to_str>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_message_to_str (osip_message_t * sip, char **dest, size_t * message_length)
{
  return _osip_message_to_str (sip, dest, message_length, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  2fc <getParent+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
getParent(direntry_t *entry)
{
 return getDirentry(entry->Dir);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
movsd  (%rdi),%xmm1
movsd  (%rsi),%xmm0
ucomisd %xmm1,%xmm0
ja     19 <dblcmp+0x19>
ucomisd %xmm0,%xmm1
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
dblcmp(double *x, double *y)
{
  if (*x < *y)
    return -1;
  if (*x > *y)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 4
10 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1c7a <asm_get_debug+0x6>
retq   
<<<sep_in_sample>>>
asm_get_debug (void)
{
        return asm__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
movsbl 0x0(%rip),%eax        # 274 <argcv_quote_char+0x7>
cmp    %edi,%eax
jne    28d <argcv_quote_char+0x20>
jmp    283 <argcv_quote_char+0x16>
movsbl (%rax),%edx
cmp    %edi,%edx
jne    292 <argcv_quote_char+0x25>
jmp    288 <argcv_quote_char+0x1b>
mov    $0x0,%eax
movsbl -0x1(%rax),%eax
retq   
mov    $0x0,%eax
sub    $0x2,%rax
cmp    $0x0,%rax
ja     27a <argcv_quote_char+0xd>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
argcv_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof(quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 4
10 8
11 8
12 4
13 5
14 4
15 4
16 10
17 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    %rsi,%rdi
mov    $0xc0,%esi
callq  fd <openssl_aes192_set_decrypt_key+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
openssl_aes192_set_decrypt_key(void *ctx, const uint8_t *key)
{
  AES_set_decrypt_key(key, 192, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     118 <rl_discard_keymap+0x4e>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x101,%ebp
movzbl (%rbx),%eax
cmp    $0x1,%al
je     ea <rl_discard_keymap+0x20>
cmp    $0x2,%al
je     100 <rl_discard_keymap+0x36>
jmp    109 <rl_discard_keymap+0x3f>
mov    0x8(%rbx),%rdi
xchg   %ax,%ax
callq  f5 <rl_discard_keymap+0x2b>
mov    0x8(%rbx),%rdi
callq  fe <rl_discard_keymap+0x34>
jmp    109 <rl_discard_keymap+0x3f>
mov    0x8(%rbx),%rdi
callq  109 <rl_discard_keymap+0x3f>
add    $0x10,%rbx
sub    $0x1,%ebp
jne    dd <rl_discard_keymap+0x13>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
rl_discard_keymap (map)
     Keymap map;
{
  int i;
  if (map == 0)
    return;
  for (i = 0; i < 257; i++)
    {
      switch (map[i].type)
 {
 case 0:
   break;
 case 1:
   rl_discard_keymap ((Keymap)map[i].function);
   xfree ((char *)map[i].function);
   break;
 case 2:
   xfree ((char *)map[i].function);
   break;
 }
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 3
5 3
6 3
7 5
8 9
9 9
10 9
11 9
12 9
13 9
14 14
15 14
16 14
17 15
18 15
19 16
20 18
21 18
22 18
23 7
24 7
25 22
26 22
27 22
28 22
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%rbp
cmpl   $0x0,0x0(%rip)        # 10ac <convert_put_path+0x11>
je     10c4 <convert_put_path+0x29>
cmpl   $0x0,0x0(%rip)        # 10b5 <convert_put_path+0x1a>
jne    10c4 <convert_put_path+0x29>
test   %rsi,%rsi
je     10c4 <convert_put_path+0x29>
mov    %rsi,%rdi
callq  3a3 <set_color_tag>
cmpl   $0x5,0xc(%rbx)
je     10d9 <convert_put_path+0x3e>
mov    $0x0,%edi
mov    $0x0,%eax
callq  10d9 <convert_put_path+0x3e>
mov    (%rbx),%r12
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  25 <convert_pathname>
mov    %r12,%rsi
mov    %rax,%rdi
callq  10f2 <convert_put_path+0x57>
mov    (%rbx),%rsi
mov    0x0(%rip),%edi        # 10fb <convert_put_path+0x60>
callq  1100 <convert_put_path+0x65>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
convert_put_path(CONVERT *cv, const char *pattern, const char *path)
{
 if (use_color && !locked && pattern)
  set_color_tag(pattern);
 if (cv->format != 5)
  die("convert_put_path: internal error.");
 fputs(convert_pathname(cv, path), cv->op);
 (void)fputc(newline, cv->op);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  123 <rl_free_keymap+0x9>
mov    %rbx,%rdi
callq  12b <rl_free_keymap+0x11>
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_free_keymap (map)
     Keymap map;
{
  rl_discard_keymap (map);
  xfree ((char *)map);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %rdx,%rbp
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    %rbp,%rdi
callq  36b <__gmpn_hgcd_matrix_mul_1+0x23>
mov    0x18(%rbx),%rcx
mov    0x10(%rbx),%rsi
mov    0x8(%rbx),%r8
mov    %rbp,%rdx
mov    %r13,%rdi
callq  382 <__gmpn_hgcd_matrix_mul_1+0x3a>
mov    %rax,%r12
mov    0x8(%rbx),%rdx
mov    0x20(%rbx),%rsi
mov    %rbp,%rdi
callq  395 <__gmpn_hgcd_matrix_mul_1+0x4d>
mov    0x28(%rbx),%rcx
mov    0x20(%rbx),%rsi
mov    0x8(%rbx),%r8
mov    %rbp,%rdx
mov    %r13,%rdi
callq  3ac <__gmpn_hgcd_matrix_mul_1+0x64>
cmp    %r12,%rax
cmovge %rax,%r12
mov    %r12,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__gmpn_hgcd_matrix_mul_1 (struct hgcd_matrix *M, const struct hgcd_matrix1 *M1,
         mp_ptr tp)
{
  mp_size_t n0, n1;
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (tp, M->p[0][0], M->n); } while (0); } while (0);
  n0 = __gmpn_hgcd_mul_matrix1_vector (M1, M->p[0][0], tp, M->p[0][1], M->n);
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (tp, M->p[1][0], M->n); } while (0); } while (0);
  n1 = __gmpn_hgcd_mul_matrix1_vector (M1, M->p[1][0], tp, M->p[1][1], M->n);
  M->n = ((n0) > (n1) ? (n0) : (n1));
  do {} while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 8
30 9
31 9
32 9
33 11
34 11
35 11
36 11
37 11
38 11
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  ae <file_open_location+0x10>
mov    %rax,%rbx
test   %rax,%rax
je     17a <file_open_location+0xdc>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # c4 <file_open_location+0x26>
callq  c9 <file_open_location+0x2b>
mov    $0x7e,%esi
mov    0x0(%rip),%rdi        # d5 <file_open_location+0x37>
callq  da <file_open_location+0x3c>
test   %rax,%rax
je     15b <file_open_location+0xbd>
mov    $0x7e,%esi
mov    %rbx,%rdi
callq  ec <file_open_location+0x4e>
lea    0x1(%rax),%rsi
mov    0x0(%rip),%rdi        # f7 <file_open_location+0x59>
callq  fc <file_open_location+0x5e>
callq  101 <file_open_location+0x63>
mov    %eax,%edi
callq  108 <file_open_location+0x6a>
mov    $0x0,%edx
test   %rax,%rax
jne    17f <file_open_location+0xe1>
mov    0x20,%rsi
mov    0x0(%rip),%rdi        # 121 <file_open_location+0x83>
callq  126 <file_open_location+0x88>
mov    0x0(%rip),%rdx        # 12d <file_open_location+0x8f>
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rdx,%rcx,1)
mov    0x0(%rip),%rsi        # 14f <file_open_location+0xb1>
mov    0x0(%rip),%rdi        # 156 <file_open_location+0xb8>
callq  15b <file_open_location+0xbd>
mov    0x0(%rip),%rdi        # 162 <file_open_location+0xc4>
callq  167 <file_open_location+0xc9>
mov    $0x0,%eax
callq  171 <file_open_location+0xd3>
mov    0x0(%rip),%rdx        # 178 <file_open_location+0xda>
jmp    17f <file_open_location+0xe1>
mov    $0x0,%edx
mov    %rdx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
file_open_location()
{
  char *res = inputBox("Enter directory path to open:", "Open Location");
  if(res != ((void *)0))
  {
    strcpy(tmp, res);
    if(strchr(tmp, '~'))
    {
      strcpy(tmp2, res+((strchr(res, '~')+1)-res));
      struct passwd *pass;
      if((pass = getpwuid(geteuid())))
 return ((void *)0);
      strcpy(tmp, pass->pw_dir);
      strcat(tmp, "/");
      strcat(tmp, tmp2);
      strcat(tmp, "\0");
    }
    scanDir(tmp);
    refreshWindows();
    return tmp;
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 11
23 11
24 11
25 12
26 11
27 11
28 13
29 13
30 13
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 15
39 15
40 15
41 18
42 18
43 19
44 19
45 20
46 20
47 22
48 23
49 23
50 23
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x0,%ebx
mov    0x0(,%rbx,8),%rdi
mov    %rbp,%rsi
callq  287 <cdtext_is_field+0x1c>
test   %eax,%eax
je     297 <cdtext_is_field+0x2c>
add    $0x1,%rbx
cmp    $0xa,%rbx
jne    277 <cdtext_is_field+0xc>
jmp    29b <cdtext_is_field+0x30>
mov    %ebx,%eax
jmp    2a0 <cdtext_is_field+0x35>
mov    $0xa,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cdtext_is_field (const char *key)
{
  unsigned int i;
  for (i = 0; i < 10 ; i++)
    if (0 == strcmp(cdtext_field[i], key)) {
      return i;
    }
  return CDTEXT_FIELD_INVALID;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 4
13 4
14 4
15 4
16 4
17 8
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x1,%eax
cmp    %rsi,0x18(%rdi)
jbe    422 <smtp_reply_get_line+0x72>
mov    %rdx,%r13
mov    %rcx,%r12
shl    $0x4,%rsi
mov    %rsi,%r15
mov    0x28(%rdi),%rax
mov    0x8(%rax,%rsi,1),%rbp
lea    0x1(%rbp),%rdi
callq  3eb <smtp_reply_get_line+0x3b>
mov    %rax,%r14
mov    0x28(%rbx),%rax
mov    (%rbx),%rsi
add    (%rax,%r15,1),%rsi
mov    %rbp,%rdx
mov    %r14,%rdi
callq  404 <smtp_reply_get_line+0x54>
movb   $0x0,(%r14,%rbp,1)
mov    %r14,0x0(%r13)
test   %r12,%r12
je     41d <smtp_reply_get_line+0x6d>
mov    %rbp,(%r12)
mov    $0x0,%eax
jmp    422 <smtp_reply_get_line+0x72>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
smtp_reply_get_line (ANUBIS_SMTP_REPLY reply, size_t index,
       char **pstr, size_t *psize)
{
  if (index < reply->line_count)
    {
      size_t len = reply->line_vec[index].len;
      char *p = xmalloc (len + 1);
      memcpy (p, ((reply)->buffer + (reply)->line_vec[index].off), len);
      p[len] = 0;
      *pstr = p;
      if (psize)
 *psize = len;
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 15
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 10
29 11
30 11
31 12
32 13
33 13
34 13
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rsi),%rax
cmp    %rdx,%rax
ja     2109 <gsl_matrix_long_superdiagonal+0x4e>
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  20e1 <gsl_matrix_long_superdiagonal+0x26>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    2140 <gsl_matrix_long_superdiagonal+0x85>
mov    0x18(%rsi),%rcx
lea    (%rcx,%rdx,8),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
sub    %rdx,%rax
mov    (%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
mov    %r8,0x8(%rbx)
mov    %rdi,0x10(%rbx)
mov    %rcx,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_long_superdiagonal (gsl_matrix_long * m,
                                      const size_t k)
{
  _gsl_vector_long_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 13
20 13
21 14
22 12
23 12
24 12
25 12
26 17
27 17
28 17
29 17
30 17
31 19
32 19
33 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  320 <do_rmdir+0x14>
mov    $0x0,%edx
test   %eax,%eax
jns    35c <do_rmdir+0x50>
cmpb   $0x0,0x8(%rbp)
je     35c <do_rmdir+0x50>
callq  334 <do_rmdir+0x28>
mov    (%rax),%esi
mov    $0x0,%edx
cmp    $0x2,%esi
je     35c <do_rmdir+0x50>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x0,%edi
mov    $0x0,%eax
callq  357 <do_rmdir+0x4b>
mov    $0xffffffff,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
do_rmdir (struct temp_dir *dir, const char *absolute_dir_name)
{
  if (rmdir (absolute_dir_name) < 0 && dir->cleanup_verbose
      && (*__errno_location ()) != 2)
    {
      error (0, (*__errno_location ()),
             ((const char *) ("cannot remove temporary directory %s")), absolute_dir_name);
      return -1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 10
9 3
10 3
11 3
12 3
13 4
14 4
15 10
16 4
17 4
18 6
19 6
20 6
21 6
22 6
23 8
24 11
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  2627 <php__scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
php__scan_string (const char * yystr )
{
 return php__scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
movzwl (%rcx),%edi
test   %r8,%r8
je     14ec <gsl_vector_short_max_index+0x40>
add    %r9,%r9
add    %r9,%rcx
mov    $0x0,%edx
mov    $0x0,%eax
jmp    14e1 <gsl_vector_short_max_index+0x35>
movzwl (%rcx),%esi
cmp    %si,%di
jge    14de <gsl_vector_short_max_index+0x32>
mov    %rdx,%rax
mov    %esi,%edi
add    %r9,%rcx
add    $0x1,%rdx
cmp    %r8,%rdx
jne    14d1 <gsl_vector_short_max_index+0x25>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_short_max_index (const gsl_vector_short * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  short max = v->data[0 * stride];
  size_t imax = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      short x = v->data[i*stride];
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  return imax;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 8
7 8
8 8
9 8
10 6
11 6
12 10
13 11
14 11
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,%r12
mov    %rdx,%r15
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     3c8 <gsl_matrix_complex_fprintf+0x47>
shl    $0x4,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     414 <gsl_matrix_complex_fprintf+0x93>
jmp    3e6 <gsl_matrix_complex_fprintf+0x65>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    %r15,%r8
mov    $0x1,%ecx
mov    (%rsp),%rdi
callq  3e4 <gsl_matrix_complex_fprintf+0x63>
jmp    414 <gsl_matrix_complex_fprintf+0x93>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    %r15,%r8
mov    $0x1,%ecx
mov    %r13,%rdx
mov    (%rsp),%rdi
callq  402 <gsl_matrix_complex_fprintf+0x81>
test   %eax,%eax
jne    414 <gsl_matrix_complex_fprintf+0x93>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    3e6 <gsl_matrix_complex_fprintf+0x65>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_fprintf (FILE * stream, const gsl_matrix_complex * m,
                                const char *format)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_raw_fprintf (stream,
                                                  m->data,
                                                  size1 * size2, 1,
                                                  format);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_raw_fprintf (stream,
                                                      m->data + i * 2 * tda,
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 6
13 7
14 8
15 8
16 21
17 21
18 21
19 21
20 18
21 18
22 18
23 18
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 24
40 24
41 18
42 18
43 18
44 18
45 29
46 29
47 29
48 29
49 29
50 29
51 29
52 29
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
movl   $0x0,0x0(%rip)        # 2e5 <put_line+0x13>
mov    %esi,%edi
callq  266 <put_space>
mov    0x18(%rbx),%rax
lea    -0x20(%rax),%rbp
cmp    %rbp,%rbx
je     313 <put_line+0x41>
mov    %rbx,%rdi
callq  28c <put_word>
movswl 0xa(%rbx),%edi
callq  266 <put_space>
add    $0x20,%rbx
cmp    %rbx,%rbp
jne    2f9 <put_line+0x27>
mov    %rbx,%rdi
callq  28c <put_word>
mov    0x0(%rip),%eax        # 321 <put_line+0x4f>
mov    %eax,0x0(%rip)        # 327 <put_line+0x55>
mov    0x0(%rip),%rsi        # 32e <put_line+0x5c>
mov    $0xa,%edi
callq  338 <put_line+0x66>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
put_line (register WORD *w, int indent)
{
  register WORD *endline;
  out_column = 0;
  put_space (indent);
  endline = w->next_break - 1;
  for (; w != endline; w++)
    {
      put_word (w);
      put_space (w->space);
    }
  put_word (w);
  last_line_length = out_column;
  putc_unlocked ('\n',outfile);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 9
13 9
14 10
15 10
16 7
17 7
18 7
19 12
20 12
21 13
22 13
23 14
24 14
25 14
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
mov    0xc8(%rdi),%ecx
mov    %rsi,%rax
shl    %cl,%rax
retq   
<<<sep_in_sample>>>
sectorsToBytes(Stream_t *Stream, off_t off)
{
 Fs_t *This = (Fs_t *) Stream;
 return (mt_off_t) off << This->sectorShift;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x20,%edi
callq  5b <add_segment+0xe>
movq   $0x0,(%rax)
mov    0x60(%rbx),%rdx
test   %rdx,%rdx
je     70 <add_segment+0x23>
mov    %rax,(%rdx)
jmp    74 <add_segment+0x27>
mov    %rax,0x58(%rbx)
mov    %rax,0x60(%rbx)
addq   $0x1,0x68(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
add_segment (struct transform *tf)
{
  struct replace_segm *segm = xmalloc (sizeof *segm);
  segm->next = ((void *)0);
  if (tf->repl_tail)
    tf->repl_tail->next = segm;
  else
    tf->repl_head = segm;
  tf->repl_tail = segm;
  tf->segm_count++;
  return segm;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 5
8 5
9 6
10 6
11 8
12 9
13 10
14 12
15 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %edi,%ebp
callq  8bb <with_input_from_buffered_stream+0x10>
test   %rax,%rax
mov    $0x0,%eax
mov    $0x0,%edi
cmove  %rax,%rdi
mov    %rbp,%r8
mov    %rbx,%rcx
mov    $0x4,%edx
mov    $0x0,%esi
callq  8e1 <with_input_from_buffered_stream+0x36>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
with_input_from_buffered_stream (bfd, name)
     int bfd;
     char *name;
{
  INPUT_STREAM location;
  BUFFERED_STREAM *bp;
  location.buffered_fd = bfd;
  bp = fd_to_buffered_stream (bfd);
  init_yy_io (bp == 0 ? return_EOF : buffered_getchar,
       buffered_ungetchar, st_bstream, name, location);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 8
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rsi),%rbp
mov    0x10(%rsi),%r12
test   %rbp,%rbp
je     e7 <gsl_multiset_fprintf+0x63>
mov    %rdi,%r13
mov    %rdx,%r14
mov    $0x0,%ebx
mov    (%r12,%rbx,8),%rdx
mov    %r14,%rsi
mov    %r13,%rdi
mov    $0x0,%eax
callq  b8 <gsl_multiset_fprintf+0x34>
test   %eax,%eax
jns    dc <gsl_multiset_fprintf+0x58>
mov    $0x5,%ecx
mov    $0x4f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d5 <gsl_multiset_fprintf+0x51>
mov    $0x5,%eax
jmp    f3 <gsl_multiset_fprintf+0x6f>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    a4 <gsl_multiset_fprintf+0x20>
jmp    ee <gsl_multiset_fprintf+0x6a>
mov    $0x0,%eax
jmp    f3 <gsl_multiset_fprintf+0x6f>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_multiset_fprintf (FILE * stream, const gsl_multiset * c, const char *format)
{
  size_t k = c->k ;
  size_t * data = c->data ;
  size_t i;
  for (i = 0; i < k; i++)
    {
      int status = fprintf (stream, format, data[i]);
      if (status < 0)
        {
          do { gsl_error ("fprintf failed", "file.c", 79, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 6
28 6
29 6
30 6
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
mov    %rdi,%rax
addl   $0x1,0x14(%rdi)
retq   
<<<sep_in_sample>>>
headerLink(Header h)
{
    if (probe_headers) headerProbe((h), ("headerLink"));
    h->usageCount++;
    return h;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
callq  61b <it_init_joblist>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
it_init_stopped (itp)
     ITEMLIST *itp;
{
  return (it_init_joblist (itp, 1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
movb   $0x0,(%rsi)
cmpl   $0xffffffff,0x8(%rdi)
je     377 <os_isreadable+0x4c>
mov    0x48(%rdi),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     36e <os_isreadable+0x43>
cmp    $0x4000,%eax
ja     35a <os_isreadable+0x2f>
cmp    $0x1000,%eax
je     368 <os_isreadable+0x3d>
cmp    $0x2000,%eax
jne    37d <os_isreadable+0x52>
jmp    368 <os_isreadable+0x3d>
cmp    $0x8000,%eax
je     368 <os_isreadable+0x3d>
cmp    $0xc000,%eax
jne    37d <os_isreadable+0x52>
mov    $0x1,%eax
retq   
movb   $0x1,(%rsi)
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
os_isreadable(const awk_input_buf_t *iobuf, _Bool *isdir)
{
 *isdir = 0;
 if (iobuf->fd == (-1))
  return 0;
 switch (iobuf->sbuf.st_mode & 0170000) {
 case 0100000:
 case 0020000:
 case 0140000:
 case 0010000:
  return 1;
 case 0040000:
  *isdir = 1;
 default:
  return 0;
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 11
20 11
21 13
22 15
23 15
24 5
25 5
26 15
27 17
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
gl_linked_size (gl_list_t list)
{
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
sub    $0xffffffffffffff80,%rdi
callq  87 <ahsStaticGetTarname_i>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahsStaticGetTarUsername(struct new_cpio_header * file_hdr)
{
 ;
 return ahsStaticGetTarname_i((STROB**)&(file_hdr->c_username));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x20b,%esi
mov    $0x0,%edi
callq  5fc <init_hash_global_variable_set+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_hash_global_variable_set (void)
{
  hash_init (&global_variable_set.table, 523,
             variable_hash_1, variable_hash_2, variable_hash_cmp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  24 <update_diag_marquardt>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_diag_marquardt(const gsl_matrix * JTJ, gsl_vector * diag)
{
  return update_diag_marquardt(JTJ, diag);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  508 <flags2str+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
flags2str(int flagval)
{
 static const struct flagtab values[] = {
  { 0x0001, "MALLOC" },
  { 0x0002, "STRING" },
  { 0x0004, "STRCUR" },
  { 0x0008, "NUMCUR" },
  { 0x0010, "NUMBER" },
  { 0x0020, "MAYBE_NUM" },
  { 0x0040, "FIELD" },
  { 0x0080, "INTLSTR" },
  { 0x0100, "NUMINT" },
  { 0x0200, "INTIND" },
  { 0x0400, "WSTRCUR" },
  { 0x0800, "MPFN" },
  { 0x1000, "MPZN" },
  { 0x4000, "NULL_FIELD" },
  { 0x8000, "ARRAYMAXED" },
  { 0x10000, "HALFHAT" },
  { 0x20000, "XARRAY" },
  { 0, ((void *)0) },
 };
 return genflags2str(flagval, values);
}
<<<sep_in_sample>>>
1 2
2 23
3 23
4 24
5 24
<<<sep_out_sample>>>
test   %rdi,%rdi
je     969 <osip_transaction_set_reserved1+0x12>
mov    %rsi,0x2c40(%rdi)
mov    $0x0,%eax
retq   
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
osip_transaction_set_reserved1 (osip_transaction_t * transaction, void *ptr)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->reserved1 = ptr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
mov    %edx,0x8(%rdi)
movq   $0x0,0x10(%rdi)
mov    %ecx,0x1c(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x28(%rdi)
movl   $0x0,0x40(%rdi)
movl   $0x0,0x44(%rdi)
retq   
<<<sep_in_sample>>>
sexp_output_init(struct sexp_output *output, FILE *f,
   unsigned width, int prefer_hex)
{
  output->f = f;
  output->line_width = width;
  output->coding = ((void *)0);
  output->prefer_hex = prefer_hex;
  output->hash = ((void *)0);
  output->ctx = ((void *)0);
  output->pos = 0;
  output->soft_newline = 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 8
6 9
7 10
8 11
9 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r8d
callq  1092 <internal_memalign>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sh_memalign (alignment, size, file, line)
     size_t alignment;
     size_t size;
     const char *file;
     int line;
{
  return internal_memalign (alignment, size, file, line, 0x01);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 8
5 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1c8 <gsl_ran_multinomial_pdf+0x9>
callq  1cd <gsl_ran_multinomial_pdf+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_multinomial_pdf (const size_t K,
                         const double p[], const unsigned int n[])
{
  return exp (gsl_ran_multinomial_lnpdf (K, p, n));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
movsd  0xe8(%rdi),%xmm0
mov    $0x0,%eax
ucomisd 0x0(%rip),%xmm0        # 15 <inCloud+0x15>
ja     28 <inCloud+0x28>
ucomisd 0x0(%rip),%xmm0        # 1f <inCloud+0x1f>
setbe  %al
movzbl %al,%eax
add    $0x1,%eax
repz retq 
<<<sep_in_sample>>>
inCloud(craft * c)
{
 int state;
 if (c->w.z > ctop) {
  state = 0;
 }
 else if (c->w.z > cbase) {
  state = 1;
 }
 else {
  state = 2;
 }
 return state;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 11
6 11
7 11
8 11
9 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3ca <compute_char_variance>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_char_variance_with_fixed_mean (const char data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_char_variance (data, stride, n, mean);
  return variance;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x38(%rdi),%rdi
callq  6e2 <prog_close+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
prog_close (mu_mailer_t mailer)
{
  return mu_progmailer_close (mailer->data);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1675 <yyget_lineno+0x6>
retq   
<<<sep_in_sample>>>
yyget_lineno (void)
{
    return yylineno;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 257 <lookup+0x7>
test   %rax,%rax
je     2a2 <lookup+0x52>
sub    $0xb8,%rsp
mov    %rdi,0x30(%rsp)
lea    0x10(%rsp),%rdx
mov    %rdx,(%rsp)
mov    %rsp,%rsi
mov    %rax,%rdi
callq  27c <lookup+0x2c>
test   %rax,%rax
je     2a8 <lookup+0x58>
mov    (%rax),%rax
cmpl   $0x1,0x18(%rax)
jne    2ad <lookup+0x5d>
cmpl   $0x3,0x28(%rax)
jne    2ad <lookup+0x5d>
mov    0x30(%rax),%rax
cmpl   $0x1,0x18(%rax)
jne    2ad <lookup+0x5d>
cmpl   $0x3,0x28(%rax)
je     290 <lookup+0x40>
jmp    2ad <lookup+0x5d>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
add    $0xb8,%rsp
retq   
<<<sep_in_sample>>>
lookup(const char *name)
{
     Symbol s, *sym;
     struct table_entry t, *tp;
     if (!symbol_table)
   return ((void *)0);
     s.name = (char*) name;
     t.sym = &s;
     tp = hash_lookup(symbol_table, &t);
     if (tp) {
   sym = tp->sym;
   while (sym->type == SymToken && sym->flag == symbol_alias)
        sym = sym->alias;
     } else
   sym = ((void *)0);
     return sym;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 2
5 7
6 8
7 8
8 9
9 9
10 9
11 10
12 10
13 11
14 12
15 12
16 12
17 12
18 13
19 12
20 12
21 12
22 12
23 12
24 6
25 17
26 15
27 17
28 17
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%esi        # 4af9 <push_dollar_vars+0x7>
mov    0x0(%rip),%eax        # 4aff <push_dollar_vars+0xd>
add    $0x2,%eax
cmp    %esi,%eax
jle    4b33 <push_dollar_vars+0x41>
add    $0xa,%esi
mov    %esi,0x0(%rip)        # 4b0f <push_dollar_vars+0x1d>
movslq %esi,%rsi
shl    $0x3,%rsi
mov    $0x12e9,%ecx
mov    $0x0,%edx
mov    0x0(%rip),%rdi        # 4b27 <push_dollar_vars+0x35>
callq  4b2c <push_dollar_vars+0x3a>
mov    %rax,0x0(%rip)        # 4b33 <push_dollar_vars+0x41>
mov    0x0(%rip),%eax        # 4b39 <push_dollar_vars+0x47>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # 4b42 <push_dollar_vars+0x50>
cltq   
mov    0x0(%rip),%rdx        # 4b4b <push_dollar_vars+0x59>
lea    (%rdx,%rax,8),%rbx
callq  4b54 <push_dollar_vars+0x62>
mov    %rax,(%rbx)
movslq 0x0(%rip),%rdx        # 4b5e <push_dollar_vars+0x6c>
mov    0x0(%rip),%rax        # 4b65 <push_dollar_vars+0x73>
movq   $0x0,(%rax,%rdx,8)
pop    %rbx
retq   
<<<sep_in_sample>>>
push_dollar_vars ()
{
  if (dollar_arg_stack_index + 2 > dollar_arg_stack_slots)
    {
      dollar_arg_stack = (WORD_LIST **)
 sh_xrealloc((dollar_arg_stack), ((dollar_arg_stack_slots += 10) * sizeof (WORD_LIST *)),
 "variables.c"
 ,
 4841
 )
                           ;
    }
  dollar_arg_stack[dollar_arg_stack_index++] = list_rest_of_args ();
  dollar_arg_stack[dollar_arg_stack_index] = (WORD_LIST *)((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 5
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 14
25 14
26 14
27 15
28 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
test   %rdx,%rdx
je     49 <_gdbm_full_read+0x49>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  20 <_gdbm_full_read+0x20>
cmp    $0xffffffffffffffff,%rax
jne    37 <_gdbm_full_read+0x37>
callq  2b <_gdbm_full_read+0x2b>
cmpl   $0x4,(%rax)
je     42 <_gdbm_full_read+0x42>
mov    $0x6,%eax
jmp    5c <_gdbm_full_read+0x5c>
test   %rax,%rax
je     50 <_gdbm_full_read+0x50>
add    %rax,%rbp
sub    %rax,%rbx
test   %rbx,%rbx
jne    12 <_gdbm_full_read+0x12>
jmp    57 <_gdbm_full_read+0x57>
mov    $0x0,%eax
jmp    5c <_gdbm_full_read+0x5c>
mov    $0x19,%eax
jmp    5c <_gdbm_full_read+0x5c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_gdbm_full_read (GDBM_FILE dbf, void *buffer, size_t size)
{
  char *ptr = buffer;
  while (size)
    {
      ssize_t rdbytes = _gdbm_mapped_read(dbf, ptr, size);
      if (rdbytes == -1)
 {
   if ((*__errno_location ()) == 4)
     continue;
   return 6;
 }
      if (rdbytes == 0)
 return 25;
      ptr += rdbytes;
      size -= rdbytes;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 13
21 13
22 15
23 16
24 4
25 4
26 4
27 18
28 18
29 14
30 14
31 18
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1efc <cpp_get_leng+0x7>
retq   
<<<sep_in_sample>>>
cpp_get_leng (void)
{
        return cpp_leng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     2a0 <osip_cseq_free+0x6d>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     259 <osip_cseq_free+0x26>
mov    0x0(%rip),%rax        # 24b <osip_cseq_free+0x18>
test   %rax,%rax
je     254 <osip_cseq_free+0x21>
callq  *%rax
jmp    259 <osip_cseq_free+0x26>
callq  259 <osip_cseq_free+0x26>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     292 <osip_cseq_free+0x5f>
mov    0x0(%rip),%rax        # 269 <osip_cseq_free+0x36>
test   %rax,%rax
je     272 <osip_cseq_free+0x3f>
callq  *%rax
jmp    292 <osip_cseq_free+0x5f>
callq  277 <osip_cseq_free+0x44>
jmp    292 <osip_cseq_free+0x5f>
mov    %rbx,%rdi
nopl   0x0(%rax)
callq  *%rax
jmp    2a0 <osip_cseq_free+0x6d>
mov    %rbx,%rdi
callq  28c <osip_cseq_free+0x59>
nopl   0x0(%rax)
jmp    2a0 <osip_cseq_free+0x6d>
mov    0x0(%rip),%rax        # 299 <osip_cseq_free+0x66>
test   %rax,%rax
jne    279 <osip_cseq_free+0x46>
jmp    284 <osip_cseq_free+0x51>
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_cseq_free (osip_cseq_t * cseq)
{
  if (cseq == ((void *)0))
    return;
  { if (cseq->method!=((void *)0)) { if (osip_free_func) osip_free_func(cseq->method); else free(cseq->method);} };
  { if (cseq->number!=((void *)0)) { if (osip_free_func) osip_free_func(cseq->number); else free(cseq->number);} };
  { if (cseq!=((void *)0)) { if (osip_free_func) osip_free_func(cseq); else free(cseq);} };
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 8
37 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,0x8(%rsp)
mov    %rsi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
shr    %rcx
lea    0x10(,%rcx,8),%rdi
callq  5ff <vectorize_string+0x35>
mov    %rax,%r12
lea    0x8(%rax),%rbx
mov    %rbp,%rsi
lea    0x8(%rsp),%rdi
callq  613 <vectorize_string+0x49>
mov    %rax,(%r12)
test   %rax,%rax
je     63c <vectorize_string+0x72>
cmpb   $0x0,(%rax)
cmove  %r12,%rbx
mov    %rbp,%rsi
lea    0x8(%rsp),%rdi
callq  630 <vectorize_string+0x66>
mov    %rax,(%rbx)
add    $0x8,%rbx
test   %rax,%rax
jne    623 <vectorize_string+0x59>
mov    %rbx,%rsi
sub    %r12,%rsi
mov    %r12,%rdi
callq  64a <vectorize_string+0x80>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
vectorize_string (char *string, char const *delimiter_class)
{
  char **vector_0 = xmalloc (sizeof(char *) * (2 + strlen (string) / 2));
  char **vector = vector_0;
  *vector++ = strsep (&string, delimiter_class);
  if (vector[-1])
    {
      if (vector[-1][0] == '\0')
 vector--;
      do
 *vector = strsep (&string, delimiter_class);
      while (*vector++);
    }
  return xrealloc (vector_0, sizeof(char *) * (vector - vector_0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 9
24 9
25 11
26 11
27 11
28 11
29 12
30 12
31 12
32 14
33 14
34 14
35 14
36 15
37 15
38 15
39 15
40 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
test   %rdx,%rdx
je     114 <_idx_full_read+0xb7>
mov    0x8(%r12),%edi
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  89 <_idx_full_read+0x2c>
cmp    $0xffffffffffffffff,%rax
jne    ca <_idx_full_read+0x6d>
callq  94 <_idx_full_read+0x37>
mov    %rax,%r13
cmpl   $0xb,(%rax)
je     109 <_idx_full_read+0xac>
mov    (%r12),%rbx
mov    $0x0,%edi
callq  aa <_idx_full_read+0x4d>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    0x0(%r13),%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  c3 <_idx_full_read+0x66>
mov    $0xffffffff,%eax
jmp    120 <_idx_full_read+0xc3>
test   %rax,%rax
jne    103 <_idx_full_read+0xa6>
mov    (%r12),%rbp
mov    $0x0,%edi
callq  dd <_idx_full_read+0x80>
mov    %rax,%rbx
callq  e5 <_idx_full_read+0x88>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  fc <_idx_full_read+0x9f>
mov    $0xffffffff,%eax
jmp    120 <_idx_full_read+0xc3>
add    %rax,%rbp
sub    %rax,%rbx
test   %rbx,%rbx
jne    79 <_idx_full_read+0x1c>
jmp    11b <_idx_full_read+0xbe>
mov    $0x0,%eax
jmp    120 <_idx_full_read+0xc3>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_idx_full_read(struct gcide_idx_file *file, void *buf, size_t size)
{
    char *p = buf;
    while (size) {
 ssize_t rc = read(file->fd, p, size);
 if (rc == -1) {
     if ((*__errno_location ()) == 11)
  continue;
     dico_log(4, (*__errno_location ()), gettext ("error reading from `%s'"), file->name);
     return -1;
 } else if (rc == 0) {
     dico_log(4, (*__errno_location ()), gettext ("short read while reading from `%s'"),
       file->name);
     return -1;
 }
 p += rc;
 size -= rc;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 7
18 7
19 7
20 7
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 14
46 14
47 16
48 17
49 4
50 4
51 4
52 19
53 19
54 19
55 20
56 20
57 20
58 20
59 20
60 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 8c <current_column+0x7>
mov    0x0(%rip),%rdi        # 93 <current_column+0xe>
cmp    %rdi,%rcx
ja     ad <current_column+0x28>
movslq 0x0(%rip),%rax        # 9f <current_column+0x1a>
add    %rcx,%rax
mov    0x0(%rip),%esi        # a8 <current_column+0x23>
cmp    %rax,%rdi
jbe    b9 <current_column+0x34>
mov    0x0(%rip),%rcx        # b4 <current_column+0x2f>
mov    $0x1,%esi
cmp    %rcx,%rdi
jbe    111 <current_column+0x8c>
mov    0x0(%rip),%r8d        # c5 <current_column+0x40>
movzbl (%rcx),%edx
cmp    $0x9,%dl
je     e9 <current_column+0x64>
cmp    $0x9,%dl
jg     d9 <current_column+0x54>
cmp    $0x8,%dl
je     f9 <current_column+0x74>
jmp    fe <current_column+0x79>
cmp    $0xa,%dl
nopl   0x0(%rax)
je     103 <current_column+0x7e>
cmp    $0xc,%dl
je     103 <current_column+0x7e>
jmp    fe <current_column+0x79>
lea    -0x1(%rsi),%eax
cltd   
idiv   %r8d
mov    %r8d,%eax
sub    %edx,%eax
add    %eax,%esi
jmp    108 <current_column+0x83>
sub    $0x1,%esi
jmp    108 <current_column+0x83>
add    $0x1,%esi
jmp    108 <current_column+0x83>
mov    $0x1,%esi
add    $0x1,%rcx
cmp    %rdi,%rcx
jne    c5 <current_column+0x40>
mov    %esi,%eax
retq   
<<<sep_in_sample>>>
current_column (void)
{
    char *p;
    int column;
    if ((buf_ptr >= save_com.ptr) && (buf_ptr <= save_com.ptr + save_com.len))
    {
        p = save_com.ptr;
        column = save_com.start_column;
    }
    else
    {
        p = cur_line;
        column = 1;
    }
    while (p < buf_ptr)
    {
        switch (*p)
        {
            case '\n':
            case 014:
                column = 1;
                break;
            case '\t':
                column += settings.tabsize - (column - 1) % settings.tabsize;
                break;
            case '\b':
                column--;
                break;
            default:
                column++;
                break;
        }
        p++;
    }
    return column;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 8
8 5
9 5
10 12
11 13
12 15
13 15
14 24
15 17
16 17
17 17
18 17
19 17
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 24
30 24
31 24
32 24
33 24
34 24
35 25
36 27
37 28
38 30
39 31
40 21
41 33
42 15
43 15
44 36
45 36
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x8(%rax),%eax
retq   
<<<sep_in_sample>>>
gsl_interp_min_size(const gsl_interp * interp)
{
  return interp->type->min_size;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    (%rsi),%rcx
test   %rcx,%rcx
je     3f <unlink_symbol+0x3f>
mov    0x8(%rcx),%rax
cmp    %rcx,%rdi
jne    3a <unlink_symbol+0x3a>
jmp    35 <unlink_symbol+0x35>
mov    0x8(%rax),%rdx
cmp    %rax,%rdi
je     27 <unlink_symbol+0x27>
mov    %rax,%rcx
mov    %rdx,%rax
jmp    3a <unlink_symbol+0x3a>
test   %rcx,%rcx
je     32 <unlink_symbol+0x32>
mov    %rdx,0x8(%rcx)
jmp    3f <unlink_symbol+0x3f>
mov    %rdx,%rax
mov    %rax,(%rsi)
jmp    3f <unlink_symbol+0x3f>
test   %rax,%rax
jne    16 <unlink_symbol+0x16>
movq   $0x0,(%rdi)
retq   
<<<sep_in_sample>>>
unlink_symbol(Symbol *sym)
{
     Symbol *s, *prev = ((void *)0);
     struct table_entry *tp = sym->owner;
     for (s = tp->sym; s; ) {
   Symbol *next = s->next;
   if (s == sym) {
        if (prev)
      prev->next = next;
        else
      tp->sym = next;
        break;
   } else
        prev = s;
   s = next;
     }
     sym->owner = ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 7
7 7
8 7
9 6
10 7
11 7
12 7
13 6
14 6
15 8
16 8
17 9
18 9
19 6
20 11
21 11
22 5
23 5
24 17
25 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1b,%edi
jne    20 <_rl_subseq_getchar+0x20>
orq    $0x50,0x0(%rip)        # 11 <_rl_subseq_getchar+0x11>
callq  16 <_rl_subseq_getchar+0x16>
andq   $0xffffffffffffffaf,0x0(%rip)        # 1e <_rl_subseq_getchar+0x1e>
jmp    35 <_rl_subseq_getchar+0x35>
orq    $0x40,0x0(%rip)        # 28 <_rl_subseq_getchar+0x28>
callq  2d <_rl_subseq_getchar+0x2d>
andq   $0xffffffffffffffbf,0x0(%rip)        # 35 <_rl_subseq_getchar+0x35>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_subseq_getchar (key)
     int key;
{
  int k;
  if (key == (('[') & 0x1f))
    (rl_readline_state |= (0x0000010));
  (rl_readline_state |= (0x0000040));
  k = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  if (key == (('[') & 0x1f))
    (rl_readline_state &= ~(0x0000010));
  return k;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 8
6 11
7 11
8 7
9 8
10 9
11 13
12 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edx
mov    $0x2,%edi
callq  b8 <restore_signal_mask+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
restore_signal_mask (set)
     sigset_t *set;
{
  return (sigprocmask (2, set, (sigset_t *)((void *)0)));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     a42 <gsl_matrix_fwrite+0x43>
shl    $0x3,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     a83 <gsl_matrix_fwrite+0x84>
jmp    a59 <gsl_matrix_fwrite+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  a57 <gsl_matrix_fwrite+0x58>
jmp    a83 <gsl_matrix_fwrite+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  a71 <gsl_matrix_fwrite+0x72>
test   %eax,%eax
jne    a83 <gsl_matrix_fwrite+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    a59 <gsl_matrix_fwrite+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_fwrite (FILE * stream, const gsl_matrix * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x48(%r8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_list_search (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
  ->search_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
movsd  0x58(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
trust_avratio(void *vstate)
{
  trust_state_t *state = (trust_state_t *) vstate;
  return state->avratio;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzwl (%rdi),%edx
mov    $0x0,%eax
cmp    $0x1,%dx
je     2a <prepare_sa+0x2a>
mov    $0x1,%al
cmp    $0x2,%dx
jne    2a <prepare_sa+0x2a>
mov    0x4(%rdi),%edi
callq  22 <prepare_sa+0x22>
mov    %eax,0x4(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
prepare_sa (struct sockaddr *sa)
{
  switch (sa->sa_family)
    {
    case 2:
      {
 struct sockaddr_in *s_in = (struct sockaddr_in *)sa;
 s_in->sin_addr.s_addr = ntohl (s_in->sin_addr.s_addr);
 break;
      }
    case 1:
      break;
    default:
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 16
5 3
6 3
7 14
8 3
9 3
10 8
11 8
12 8
13 16
14 17
15 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,0x8(%rsp)
mov    %rsi,(%rsp)
lea    0x8(%rsp),%rdi
callq  c0a <traverse_path>
mov    %eax,%ebx
cmp    $0xffffff9c,%eax
je     cf1 <safe_rename+0x2b>
mov    %eax,%edx
shr    $0x1f,%edx
test   %dl,%dl
jne    d3f <safe_rename+0x79>
mov    %ebx,%esi
mov    %rsp,%rdi
callq  7c4 <traverse_another_path>
mov    %eax,%ebp
cmp    $0xffffff9c,%eax
je     d0b <safe_rename+0x45>
mov    %eax,%edx
shr    $0x1f,%edx
test   %dl,%dl
jne    d3f <safe_rename+0x79>
mov    (%rsp),%rcx
mov    %ebp,%edx
mov    0x8(%rsp),%rsi
mov    %ebx,%edi
callq  d1d <safe_rename+0x57>
mov    %eax,%r12d
test   %r12d,%r12d
jne    d3f <safe_rename+0x79>
mov    0x8(%rsp),%rsi
mov    %ebx,%edi
callq  77a <invalidate_cached_dirfd>
mov    (%rsp),%rsi
mov    %ebp,%edi
callq  77a <invalidate_cached_dirfd>
mov    %r12d,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
safe_rename (const char *oldpath, const char *newpath)
{
  int olddirfd, newdirfd;
  int ret;
  olddirfd = traverse_path (&oldpath);
  if (olddirfd < 0 && olddirfd != -100)
    return olddirfd;
  newdirfd = traverse_another_path (&newpath, olddirfd);
  if (newdirfd < 0 && newdirfd != -100)
    return newdirfd;
  ret = renameat (olddirfd, oldpath, newdirfd, newpath);
  if (! ret)
    {
      invalidate_cached_dirfd (olddirfd, oldpath);
      invalidate_cached_dirfd (newdirfd, newpath);
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 11
27 11
28 11
29 11
30 11
31 11
32 12
33 12
34 14
35 14
36 14
37 15
38 15
39 15
40 17
41 18
42 18
43 18
44 18
45 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  d93d <_x87_bunordi_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c747 <_x87_movi_d>
mov    0x0(%r12),%r8d
and    $0x7fff,%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  1b80 <_x87jcc2>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d995 <_x87_bunordi_d+0x7c>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_bunordi_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc2(_jit, 0xa, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x400,%edi
callq  e <init_inc+0xe>
mov    %rax,0x0(%rip)        # 15 <init_inc+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_inc(void)
{
 head_inc = strhash_open(1024);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  46e <_rl_start_using_history+0x9>
mov    0x0(%rip),%rdi        # 475 <_rl_start_using_history+0x10>
test   %rdi,%rdi
je     47f <_rl_start_using_history+0x1a>
callq  47f <_rl_start_using_history+0x1a>
movq   $0x0,0x0(%rip)        # 48a <_rl_start_using_history+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_start_using_history ()
{
  using_history ();
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rcx,%r12
mov    0x10(%rdi),%rax
mov    0x18(%rsi),%ebp
or     0x18(%rdi),%ebp
test   %rax,%rax
jne    704 <usage_argful_short_opt+0x28>
mov    0x10(%rsi),%rax
test   %rax,%rax
je     770 <usage_argful_short_opt+0x94>
test   $0x10,%bpl
jne    770 <usage_argful_short_opt+0x94>
mov    %rax,%rsi
mov    %rdx,%rdi
callq  715 <usage_argful_short_opt+0x39>
mov    %rax,%r13
test   $0x1,%bpl
je     738 <usage_argful_short_opt+0x5c>
mov    0x8(%rbx),%edx
mov    %rax,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  736 <usage_argful_short_opt+0x5a>
jmp    770 <usage_argful_short_opt+0x94>
mov    %rax,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x5(%rcx),%rsi
mov    %r12,%rdi
callq  648 <space>
mov    0x8(%rbx),%edx
mov    %r13,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  770 <usage_argful_short_opt+0x94>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
usage_argful_short_opt (const struct argp_option *opt,
                        const struct argp_option *real,
                        const char *domain, void *cookie)
{
  argp_fmtstream_t stream = cookie;
  const char *arg = opt->arg;
  int flags = opt->flags | real->flags;
  if (! arg)
    arg = real->arg;
  if (arg && !(flags & 0x10))
    {
      arg = dgettext (domain, arg);
      if (flags & 0x1)
        argp_fmtstream_printf (stream, " [-%c[%s]]", opt->key, arg);
      else
        {
          space (stream, 6 + strlen (arg));
          argp_fmtstream_printf (stream, "[-%c %s]", opt->key, arg);
        }
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 7
10 7
11 8
12 8
13 9
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 13
23 13
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 18
40 18
41 18
42 18
43 18
44 18
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rdi,%rdi
jne    8a <_cdio_list_prepend+0x3b>
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x57,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  8a <_cdio_list_prepend+0x3b>
mov    $0x18,%esi
mov    $0x1,%edi
callq  99 <_cdio_list_prepend+0x4a>
mov    %rbx,(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,0x8(%rax)
mov    %rbp,0x10(%rax)
mov    %rax,0x8(%rbx)
mov    (%rbx),%edx
test   %edx,%edx
jne    b6 <_cdio_list_prepend+0x67>
mov    %rax,0x10(%rbx)
add    $0x1,%edx
mov    %edx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_cdio_list_prepend (CdioList_t *p_list, void *p_data)
{
  CdioListNode_t *p_new_node;
  { if (__builtin_expect((!(p_list != ((void *)0))),0)) cdio_log (CDIO_LOG_ASSERT, "file %s: line %d (%s): assertion failed: (%s)", "ds.c", 87, __PRETTY_FUNCTION__, "p_list != NULL"); };
  p_new_node = calloc (1, sizeof (CdioListNode_t));
  p_new_node->list = p_list;
  p_new_node->next = p_list->begin;
  p_new_node->data = p_data;
  p_list->begin = p_new_node;
  if (p_list->length == 0)
    p_list->end = p_new_node;
  p_list->length++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 6
20 7
21 7
22 8
23 9
24 10
25 10
26 10
27 11
28 12
29 12
30 13
31 13
32 13
33 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
test   %edi,%edi
js     d2f <disable_socket+0x85>
cmpl   $0x1,0x0(%rip)        # cb8 <disable_socket+0xe>
jbe    d00 <disable_socket+0x56>
cmpl   $0x0,0x0(%rip)        # cc1 <disable_socket+0x17>
je     ce7 <disable_socket+0x3d>
mov    $0x0,%r8d
mov    $0x1a1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x7,%edi
mov    $0x0,%eax
callq  ce7 <disable_socket+0x3d>
mov    $0x0,%edi
callq  cf1 <disable_socket+0x47>
mov    %ebx,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  d00 <disable_socket+0x56>
lea    0x3f(%rbx),%eax
test   %ebx,%ebx
cmovns %ebx,%eax
sar    $0x6,%eax
cltq   
mov    %ebx,%edx
sar    $0x1f,%edx
shr    $0x1a,%edx
lea    (%rbx,%rdx,1),%ecx
and    $0x3f,%ecx
sub    %edx,%ecx
mov    $0xfffffffffffffffe,%rdx
rol    %cl,%rdx
and    %rdx,0x0(,%rax,8)
pop    %rbx
retq   
<<<sep_in_sample>>>
disable_socket (int fd)
{
  if (fd < 0)
    return;
  do if (debug_level >= 2) { if (source_info_option) logmsg_printf (7, "%s:%lu:%s: ", "socket.c", 417, __FUNCTION__); debug_msg (gettext("disabling fd %d"), fd); } while (0);
  ((void) (((&listenset)->fds_bits)[((fd) / (8 * (int) sizeof (__fd_mask)))] &= ~((__fd_mask) 1 << ((fd) % (8 * (int) sizeof (__fd_mask))))));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 7
37 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
cmpl   $0x0,0x0(%rip)        # 4a6 <trace_header+0x19>
je     4e5 <trace_header+0x58>
testb  $0x20,0x0(%rip)        # 4af <trace_header+0x22>
je     4c7 <trace_header+0x3a>
mov    0x0(%rip),%rsi        # 4b8 <trace_header+0x2b>
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
testb  $0x10,0x0(%rip)        # 4ce <trace_header+0x41>
je     4e5 <trace_header+0x58>
mov    0x0(%rip),%esi        # 4d6 <trace_header+0x49>
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
mov    0x0(%rip),%esi        # 4eb <trace_header+0x5e>
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
testb  $0x2,0x0(%rip)        # 501 <trace_header+0x74>
je     514 <trace_header+0x87>
mov    %ebx,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  211 <trace_format>
pop    %rbx
retq   
<<<sep_in_sample>>>
trace_header (int id)
{
  trace_format ("m4trace:");
  if (current_line)
    {
      if (debug_level & 32)
        trace_format ("%s:", current_file);
      if (debug_level & 16)
        trace_format ("%d:", current_line);
    }
  trace_format (" -%d- ", expansion_level);
  if (debug_level & 512)
    trace_format ("id %d: ", id);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 7
13 7
14 8
15 8
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 12
25 12
26 13
27 13
28 13
29 13
30 14
31 14
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
add    %rdx,%rcx
movzbl 0x1(%rcx),%eax
cmpb   $0x0,(%rcx)
jns    5fd <token_count+0x29>
movzbl 0x2(%rcx),%edx
shl    $0x8,%edx
add    %edx,%eax
repz retq 
<<<sep_in_sample>>>
token_count (char const *buf)
{
  unsigned char const *flags = (unsigned char const *)&buf[strlen (buf) + 1];
  unsigned char const *addr = flags + 1;
  unsigned short count = *addr;
  if (*flags & 0x80)
    count += (*++addr << 8);
  return count;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 6
9 6
10 7
11 7
12 7
13 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_oset_remove (gl_oset_t set, const void *elt)
{
  return ((const struct gl_oset_impl_base *) set)->vtable
         ->remove_elt (set, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2298 <swlib_strdup+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swlib_strdup(char *s)
{
 return strdup(s);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 99b2 <ca_nb_hdy+0x27>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  99be <ca_nb_hdy+0x33>
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %ebx,%edx
mov    $0x8,%esi
mov    $0x1,%edi
callq  99da <ca_nb_hdy+0x4f>
mov    %eax,%r15d
mov    0x0(%rip),%rax        # 99e4 <ca_nb_hdy+0x59>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 99f0 <ca_nb_hdy+0x65>
callq  99f5 <ca_nb_hdy+0x6a>
mov    0x70(%rsp),%esi
mov    %esi,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0x8,(%rsp)
mov    %r15d,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  9a2e <ca_nb_hdy+0xa3>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ca_nb_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "CA_NB";
  ca_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (1, 8, year, 1, (0==0));
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "+", day, 8, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 12
15 12
16 12
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    %esi,%r12d
mov    %rcx,%rbx
shr    $0x20,%rcx
mov    $0xffffffff,%eax
cmp    %rax,%rcx
jne    cf <_nettle_umac_poly64+0x35>
callq  0 <poly64_mul>
lea    -0x1(%rax),%rdx
test   %rax,%rax
mov    $0xffffffffffffffc4,%rax
cmove  %rax,%rdx
sub    $0x3b,%rbx
mov    %r12d,%esi
mov    %ebp,%edi
callq  0 <poly64_mul>
add    %rbx,%rax
lea    0x3b(%rax),%rdx
cmp    %rax,%rbx
cmova  %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_nettle_umac_poly64 (uint32_t kh, uint32_t kl, uint64_t y, uint64_t m)
{
  if ( (m >> 32) == 0xffffffff)
    {
      y = poly64_mul (kh, kl, y);
      if (y == 0)
 y = (- (uint64_t) 59) - 1;
      else
 y--;
      m -= 59;
    }
  y = poly64_mul (kh, kl, y);
  y += m;
  if (y < m)
    y += 59;
  return y;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 9
13 9
14 9
15 9
16 10
17 12
18 12
19 12
20 13
21 15
22 15
23 15
24 17
25 17
26 17
27 17
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  281c <imap_body_size+0x9>
mov    %rax,%rdi
callq  2824 <imap_body_size+0x11>
test   %rax,%rax
je     2870 <imap_body_size+0x5d>
test   %rbx,%rbx
je     2870 <imap_body_size+0x5d>
cmpq   $0x0,0x30(%rax)
je     2842 <imap_body_size+0x2f>
mov    0x58(%rax),%rdx
sub    0x60(%rax),%rdx
mov    %rdx,(%rbx)
jmp    2870 <imap_body_size+0x5d>
mov    0x68(%rax),%rdx
test   %rdx,%rdx
je     2850 <imap_body_size+0x3d>
mov    %rdx,(%rbx)
jmp    2870 <imap_body_size+0x5d>
mov    0x58(%rax),%rdx
test   %rdx,%rdx
je     2869 <imap_body_size+0x56>
sub    0x80(%rax),%rdx
sub    0x78(%rax),%rdx
mov    %rdx,(%rbx)
jmp    2870 <imap_body_size+0x5d>
movq   $0x0,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
imap_body_size (mu_body_t body, size_t *psize)
{
  mu_message_t msg = mu_body_get_owner (body);
  msg_imap_t msg_imap = mu_message_get_owner (msg);
  if (psize && msg_imap)
    {
      if (msg_imap->parent)
 {
   *psize = msg_imap->mu_message_size - msg_imap->mu_message_lines;
 }
      else
 {
   if (msg_imap->body_size)
     *psize = msg_imap->body_size;
   else if (msg_imap->mu_message_size)
     *psize = msg_imap->mu_message_size
       - (msg_imap->header_size + msg_imap->header_lines);
   else
     *psize = 0;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 5
9 5
10 7
11 7
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 14
20 14
21 15
22 15
23 15
24 15
25 17
26 17
27 17
28 19
29 23
30 23
31 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rdi
mov    %rdx,%rbx
mov    %rax,%rdx
mov    %rbx,%rsi
callq  f8c <insert_num>
test   %rax,%rax
je     112e <parse_links+0x54>
mov    0x40(%rax),%rdx
cmp    $0x1,%rdx
jne    110c <parse_links+0x32>
movl   $0x3f7d70a4,0x24(%rax)
mov    $0x1,%eax
jmp    1136 <parse_links+0x5c>
cmp    $0x2,%rdx
jne    1120 <parse_links+0x46>
movl   $0x3c23d70a,0x24(%rax)
mov    $0x1,%eax
jmp    1136 <parse_links+0x5c>
movl   $0x3a83126f,0x24(%rax)
mov    $0x1,%eax
jmp    1136 <parse_links+0x5c>
subl   $0x1,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_links (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *p = insert_num (argv, arg_ptr, entry);
  if (p)
    {
      if (p->args.numinfo.l_val == 1)
 p->est_success_rate = 0.99;
      else if (p->args.numinfo.l_val == 2)
 p->est_success_rate = 0.01;
      else
 p->est_success_rate = 1e-3;
      return 1;
    }
  else
    {
      --*arg_ptr;
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 7
14 12
15 12
16 8
17 8
18 9
19 12
20 12
21 11
22 12
23 12
24 16
25 17
26 19
27 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  153 <gsl_sort_vector_long_double_smallest_index+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_long_double_smallest_index (size_t * p, const size_t k,
                                           const gsl_vector_long_double * v)
{
  return gsl_sort_long_double_smallest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  fd7 <xdr_dis_repair_result+0x9>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdr_dis_repair_result(xdrs, objp)
	XDR *xdrs;
	dis_repair_result *objp;
{
	if (!xdr_byte_u_char(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 9
7 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  124 <dispose_file_to_output+0xc>
mov    0x98(%rbx),%rdi
callq  130 <dispose_file_to_output+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
dispose_file_to_output (const void *elt)
{
  const struct file_to_output *file_to_output = elt;
  free (file_to_output->from);
  free (file_to_output->to);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 96c <_rl_disable_meta_key+0x7>
je     9a4 <_rl_disable_meta_key+0x3f>
mov    0x0(%rip),%rdi        # 975 <_rl_disable_meta_key+0x10>
test   %rdi,%rdi
je     9a4 <_rl_disable_meta_key+0x3f>
cmpl   $0x0,0x0(%rip)        # 981 <_rl_disable_meta_key+0x1c>
je     9a4 <_rl_disable_meta_key+0x3f>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x1,%esi
callq  996 <_rl_disable_meta_key+0x31>
movl   $0x0,0x0(%rip)        # 9a0 <_rl_disable_meta_key+0x3b>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_rl_disable_meta_key ()
{
  if (term_has_meta && _rl_term_mo && enabled_meta)
    {
      tputs (_rl_term_mo, 1, _rl_output_character_function);
      enabled_meta = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 2
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  d <gnewton_free+0xd>
mov    0x8(%rbx),%rdi
callq  16 <gnewton_free+0x16>
mov    0x18(%rbx),%rdi
callq  1f <gnewton_free+0x1f>
mov    0x20(%rbx),%rdi
callq  28 <gnewton_free+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
gnewton_free (void * vstate)
{
  gnewton_state_t * state = (gnewton_state_t *) vstate;
  gsl_vector_free(state->d);
  gsl_vector_free(state->x_trial);
  gsl_matrix_free(state->lu);
  gsl_permutation_free(state->permutation);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x36,%edi
ja     10c <c_isxdigit+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case 'a' + (0): case 'b' + (0): case 'c' + (0): case 'd' + (0): case 'e' + (0): case 'f' + (0): case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 9
9 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # f15 <seek_diag_details+0xb>
je     f1e <seek_diag_details+0x14>
callq  f1c <seek_diag_details+0x12>
jmp    f25 <seek_diag_details+0x1b>
xchg   %ax,%ax
callq  f25 <seek_diag_details+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
seek_diag_details (char const *name, off_t offset)
{
  if (ignore_failed_read_option)
    seek_warn_details (name, offset);
  else
    seek_error_details (name, offset);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  118 <gl_array_sortedlist_indexof>
mov    %rax,%rsi
mov    $0x0,%eax
cmp    $0xffffffffffffffff,%rsi
je     2b0 <gl_array_sortedlist_remove+0x1f>
mov    %rbx,%rdi
callq  223 <gl_array_remove_at>
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_array_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,
                            const void *elt)
{
  size_t index = gl_array_sortedlist_indexof (list, compar, elt);
  if (index == (size_t)(-1))
    return 0;
  else
    return gl_array_remove_at (list, index);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 6
6 5
7 5
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  102e <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
gsl_min_fminimizer_x_minimum (const gsl_min_fminimizer * s)
{
  return s->x_minimum;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm1        # 200e <gsl_sf_legendre_deriv_alt_array+0xc>
callq  2013 <gsl_sf_legendre_deriv_alt_array+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_deriv_alt_array
(const gsl_sf_legendre_t norm, const size_t lmax, const double x,
 double result_array[], double result_deriv_array[])
{
  int s = gsl_sf_legendre_deriv_alt_array_e(norm, lmax, x, 1.0, result_array, result_deriv_array);
  return s;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 7
5 7
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
swicat_r_get_installed_catalog(GB * G, VPLOB * swspecs, char * target_path)
{
        return -1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 731 <define_line+0x7>
test   %rdx,%rdx
cmove  0x0(%rip),%rdx        # 73c <define_line+0x12>
cmpq   $0x0,0x0(%rip)        # 744 <define_line+0x1a>
je     7a0 <define_line+0x76>
mov    (%rdx),%esi
mov    $0x0,%eax
cmp    %edi,%esi
jg     7d5 <define_line+0xab>
mov    0x0(%rip),%rcx        # 75c <define_line+0x32>
cmp    %rcx,%rdx
jae    7a6 <define_line+0x7c>
cmp    %edi,%esi
jge    7ca <define_line+0xa0>
add    $0x38,%rdx
cmp    %rcx,%rdx
jae    7ac <define_line+0x82>
cmp    (%rdx),%edi
jg     765 <define_line+0x3b>
jmp    7ca <define_line+0xa0>
mov    %rdx,0x0(%rip)        # 77b <define_line+0x51>
cmp    (%rdx),%esi
jne    7b2 <define_line+0x88>
cmpb   $0x44,0x4(%rdx)
jne    78d <define_line+0x63>
jmp    7b8 <define_line+0x8e>
cmpb   $0x44,0x4(%rdx)
je     7be <define_line+0x94>
add    $0x38,%rdx
cmp    %rcx,%rdx
jae    7c4 <define_line+0x9a>
cmp    (%rdx),%esi
je     787 <define_line+0x5d>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    (%rdx),%esi
mov    $0x0,%eax
cmp    %edi,%esi
je     774 <define_line+0x4a>
repz retq 
<<<sep_in_sample>>>
define_line(int lineno)
{
 struct anchor *p = curp ? curp : start;
 if (table == ((void *)0))
  return 0;
 if (p->lineno > lineno)
  return 0;
 for (; p < end && p->lineno < lineno; p++)
  ;
 if (p >= end || p->lineno != lineno)
  return 0;
 curp = p;
 for (; p < end && p->lineno == lineno; p++)
  if (p->type == 'D')
   return 1;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 6
7 7
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 12
22 13
23 13
24 14
25 14
26 14
27 14
28 14
29 13
30 13
31 13
32 13
33 13
34 16
35 16
36 5
37 5
38 11
39 11
40 11
41 11
42 16
43 16
44 15
45 15
46 15
47 15
48 16
49 16
50 10
51 11
52 10
53 10
54 17
<<<sep_out_sample>>>
test   %rdi,%rdi
je     f5f <osip_generic_param_get_name+0x9>
mov    (%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_generic_param_get_name (const osip_generic_param_t * fparam)
{
  if (fparam == ((void *)0))
    return ((void *)0);
  return fparam->gname;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%eax
lea    (%rax,%rax,4),%rax
lea    (%rdi,%rax,8),%rbx
mov    0x18(%rbx),%rax
test   %rax,%rax
jne    cd2 <swbisoption_get_opta+0x2f>
mov    0x8(%rbx),%rcx
mov    %esi,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # cc9 <swbisoption_get_opta+0x26>
callq  cce <swbisoption_get_opta+0x2b>
mov    0x10(%rbx),%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
swbisoption_get_opta(struct extendedOptions * opta, enum eOpts nopt)
{
 char * value;
 value = opta[nopt].valueM;
 if (value == ((void *)0)) {
  fprintf(stderr, "internal warning: swbis option %d [%s] is null\n", (int)nopt, opta[nopt].optionNameM);
 }
 if (!value) value = opta[nopt].defaultValueM;
 return value;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 8
14 10
15 10
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
movb   $0xff,(%rsp)
movb   $0xff,0x1(%rsp)
movb   $0x73,0x2(%rsp)
movb   $0x73,0x3(%rsp)
movzwl 0x0(%rip),%edi        # 3f9 <sendwindow+0x2e>
callq  3fe <sendwindow+0x33>
mov    %ax,0x4(%rsp)
movzwl 0x0(%rip),%edi        # 40a <sendwindow+0x3f>
callq  40f <sendwindow+0x44>
mov    %ax,0x6(%rsp)
movzwl 0x0(%rip),%edi        # 41b <sendwindow+0x50>
callq  420 <sendwindow+0x55>
mov    %ax,0x8(%rsp)
movzwl 0x0(%rip),%edi        # 42c <sendwindow+0x61>
callq  431 <sendwindow+0x66>
mov    %ax,0xa(%rsp)
mov    $0xc,%edx
mov    %rsp,%rsi
mov    0x0(%rip),%edi        # 444 <sendwindow+0x79>
callq  449 <sendwindow+0x7e>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
je     45e <sendwindow+0x93>
callq  45e <sendwindow+0x93>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
sendwindow (void)
{
  struct winsize *wp;
  char obuf[4 + sizeof (struct winsize)];
  wp = (struct winsize *) (obuf + 4);
  obuf[0] = 0377;
  obuf[1] = 0377;
  obuf[2] = 's';
  obuf[3] = 's';
  wp->ws_row = htons (winsize.ws_row);
  wp->ws_col = htons (winsize.ws_col);
  wp->ws_xpixel = htons (winsize.ws_xpixel);
  wp->ws_ypixel = htons (winsize.ws_ypixel);
    write (rem, obuf, sizeof obuf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 8
8 9
9 10
10 10
11 10
12 11
13 11
14 11
15 12
16 12
17 12
18 13
19 13
20 13
21 14
22 14
23 14
24 14
25 15
26 15
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x2,%edx
mov    $0x0,%esi
mov    (%rdi),%edi
callq  38 <fd_size+0x15>
test   %rax,%rax
jns    46 <fd_size+0x23>
callq  42 <fd_size+0x1f>
mov    (%rax),%eax
jmp    4e <fd_size+0x2b>
mov    %rax,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
fd_size (void *data, off_t *psize)
{
    struct _stream *p = data;
    off_t size = lseek(p->fd, 0, 2);
    if (size < 0)
 return (*__errno_location ());
    *psize = size;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 8
14 9
15 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x48(%rdi),%rdi
test   %rdi,%rdi
je     fc <ist_snd_1xx+0x1a>
callq  fc <ist_snd_1xx+0x1a>
mov    0x8(%rbp),%rax
mov    %rax,0x48(%rbx)
mov    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  110 <ist_snd_1xx+0x2e>
test   %eax,%eax
je     120 <ist_snd_1xx+0x3e>
mov    %eax,%esi
mov    %rbx,%rdi
callq  0 <ist_handle_transport_error>
jmp    131 <ist_snd_1xx+0x4f>
mov    0x48(%rbx),%rdx
mov    %rbx,%rsi
mov    $0x10,%edi
callq  131 <ist_snd_1xx+0x4f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ist_snd_1xx (osip_transaction_t * ist, osip_event_t * evt)
{
  int i;
  if (ist->last_response != ((void *)0)) {
    osip_message_free (ist->last_response);
  }
  ist->last_response = evt->sip;
  i = __osip_transaction_snd_xxx (ist, evt->sip);
  if (i != 0) {
    ist_handle_transport_error (ist, i);
    return;
  }
  else
    __osip_message_callback (OSIP_IST_STATUS_1XX_SENT, ist, ist->last_response);
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 10
18 10
19 10
20 11
21 14
22 14
23 14
24 14
25 16
26 16
27 16
28 16
<<<sep_out_sample>>>
mov    (%rdi),%edx
mov    (%rsi),%eax
cmp    %eax,%edx
jl     2e <intcmp+0xf>
setg   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
intcmp(int *i1, int *i2)
{
  if (*i1 < *i2)
    return -1;
  else if (*i1 > *i2)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 4
9 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  bf <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  c8 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  d1 <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  da <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  e3 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  ec <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  f4 <modnewton1_free+0x42>
mov    %rbx,%rdi
callq  fc <modnewton1_free+0x4a>
pop    %rbx
retq   
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 247 <CDB___os_free+0xb>
test   %rax,%rax
je     250 <CDB___os_free+0x14>
callq  *%rax
jmp    255 <CDB___os_free+0x19>
callq  255 <CDB___os_free+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___os_free(ptr, size)
 void *ptr;
 size_t size;
{ if(size){}
 (size) = (0);
 if (CDB___db_jump.j_free != ((void *)0))
  CDB___db_jump.j_free(ptr);
 else
  free(ptr);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 7
6 7
7 9
8 10
9 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x6c(%rdi),%eax
cmp    $0x1,%eax
jle    b6 <swi_file_member_delete+0x14>
sub    $0x1,%eax
mov    %eax,0x6c(%rdi)
jmp    da <swi_file_member_delete+0x38>
mov    0x48(%rdi),%rdi
test   %rdi,%rdi
je     c4 <swi_file_member_delete+0x22>
callq  c4 <swi_file_member_delete+0x22>
mov    0x58(%rbx),%rdi
test   %rdi,%rdi
je     d2 <swi_file_member_delete+0x30>
callq  d2 <swi_file_member_delete+0x30>
mov    %rbx,%rdi
callq  da <swi_file_member_delete+0x38>
pop    %rbx
retq   
<<<sep_in_sample>>>
swi_file_member_delete(SWI_FILE_MEMBER * s)
{
 if (s->refcountM > 1) {
  (s->refcountM)--;
  return;
 }
 if (s->pathnameM) free(s->pathnameM);
 if (s->dataM) free(s->dataM);
 free(s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 10
20 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x1005,%eax
test   %rdi,%rdi
je     44 <mu_iterator_create+0x44>
mov    %rsi,%rbp
mov    $0x16,%ax
test   %rsi,%rsi
je     44 <mu_iterator_create+0x44>
mov    $0x58,%esi
mov    $0x1,%edi
callq  2e <mu_iterator_create+0x2e>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     44 <mu_iterator_create+0x44>
mov    %rbp,0x8(%rdx)
mov    %rdx,(%rbx)
mov    $0x0,%al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_iterator_create (mu_iterator_t *piterator, void *owner)
{
  mu_iterator_t iterator;
  if (piterator == ((void *)0))
    return (0x1000 +5);
  if (owner == ((void *)0))
    return 22;
  iterator = calloc (1, sizeof (*iterator));
  if (iterator == ((void *)0))
    return 12;
  iterator->owner = owner;
  *piterator = iterator;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 4
9 7
10 6
11 6
12 8
13 8
14 8
15 8
16 10
17 9
18 9
19 11
20 12
21 13
22 14
23 14
24 14
25 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 480 <_rl_set_the_line+0x7>
mov    %rax,0x0(%rip)        # 487 <_rl_set_the_line+0xe>
retq   
<<<sep_in_sample>>>
_rl_set_the_line ()
{
  the_line = rl_line_buffer;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1e <nntp_body_size+0xc>
movq   $0x0,(%rsi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
nntp_body_size (mu_body_t body, size_t *psize)
{
  if (psize)
    *psize = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
rk4imp_order (void *vstate)
{
  rk4imp_state_t *state = (rk4imp_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rsi        # 10 <print_frame+0x10>
mov    $0x0,%edi
callq  1a <print_frame+0x1a>
test   %rbp,%rbp
je     37 <print_frame+0x37>
mov    $0x0,%ebx
mov    $0x2d,%edi
callq  2e <print_frame+0x2e>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    24 <print_frame+0x24>
mov    0x0(%rip),%rsi        # 3e <print_frame+0x3e>
mov    $0x0,%edi
callq  48 <print_frame+0x48>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
print_frame (const size_t len)
{
  size_t i;
  fputws (L"+-", stdout);
  for (i = 0; i < len; i++)
    putwchar (L'-');
  fputws (L"-+\n", stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 5
14 5
15 5
16 7
17 7
18 7
19 8
20 8
21 8
22 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    $0x0,%edi
callq  130 <describe_command+0x15>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  13b <describe_command+0x20>
mov    %rax,%rbx
test   %rax,%rax
jne    153 <describe_command+0x38>
mov    %ebp,%esi
mov    0x0(%rip),%rdi        # 14c <describe_command+0x31>
callq  151 <describe_command+0x36>
jmp    18f <describe_command+0x74>
cmpb   $0x0,(%rax)
je     187 <describe_command+0x6c>
mov    %rax,%rdi
nopl   0x0(%rax,%rax,1)
callq  165 <describe_command+0x4a>
test   %rax,%rax
je     18f <describe_command+0x74>
mov    %rax,%rdi
callq  172 <describe_command+0x57>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  187 <describe_command+0x6c>
mov    %rbx,%rdi
callq  18f <describe_command+0x74>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
describe_command (WINDOW *window, int count)
{
  char *line;
  line = read_function_name (gettext ("Describe command: "), window);
  if (!line)
    {
      info_abort_key (active_window, count);
      return;
    }
  if (*line)
    {
      InfoCommand *cmd = named_function (line);
      if (!cmd)
        return;
      window_message_in_echo_area ("%s: %s.",
                                   line, function_documentation (cmd));
    }
  free (line);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 8
18 10
19 10
20 12
21 12
22 12
23 13
24 13
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 18
33 18
34 19
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    (%rdi),%rbx
test   %rbx,%rbx
je     235 <grecs_list_clear+0x34>
mov    (%rbx),%rbp
mov    0x20(%r12),%rax
test   %rax,%rax
je     223 <grecs_list_clear+0x22>
mov    0x10(%rbx),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  22b <grecs_list_clear+0x2a>
test   %rbp,%rbp
je     235 <grecs_list_clear+0x34>
mov    %rbp,%rbx
jmp    210 <grecs_list_clear+0xf>
movq   $0x0,0x8(%r12)
movq   $0x0,(%r12)
movq   $0x0,0x10(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_list_clear(struct grecs_list *lp)
{
 struct grecs_list_entry *ep = lp->head;
 while (ep) {
  struct grecs_list_entry *next = ep->next;
  if (lp->free_entry)
   lp->free_entry(ep->data);
  grecs_free(ep);
  ep = next;
 }
 lp->head = lp->tail = ((void *)0);
 lp->count = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 5
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 4
17 4
18 9
19 9
20 11
21 11
22 12
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  33 <dummy_covar+0xc>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dummy_covar(const gsl_matrix * JTJ, gsl_matrix * covar, void * vstate)
{
  (void) vstate;
  (void) JTJ;
  gsl_matrix_set_zero(covar);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 7
5 7
6 7
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 1af <sigint_handler+0x7>
je     1bc <sigint_handler+0x14>
movl   $0x1,0x0(%rip)        # 1bb <sigint_handler+0x13>
retq   
push   %rbx
add    $0xffffffffffffff80,%rsp
mov    %edi,%ebx
movl   $0x0,0x0(%rip)        # 1cd <sigint_handler+0x25>
mov    %rsp,%rdi
callq  1d5 <sigint_handler+0x2d>
mov    %ebx,%esi
mov    %rsp,%rdi
callq  1df <sigint_handler+0x37>
mov    $0x0,%edx
mov    %rsp,%rsi
mov    $0x1,%edi
callq  1f1 <sigint_handler+0x49>
mov    $0xffffffff,%esi
mov    $0x0,%edi
callq  200 <sigwinch_handler>
<<<sep_in_sample>>>
sigint_handler( int signum )
  {
  if( mutex ) sigint_pending = true;
  else
    {
    sigset_t set;
    sigint_pending = false;
    sigemptyset( &set );
    sigaddset( &set, signum );
    sigprocmask( 1, &set, 0 );
    longjmp( jmp_state, -1 );
    }
  }
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 2
7 2
8 7
9 8
10 8
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
movl   $0x0,0xc(%rsp)
mov    0x8(%rsi),%rdx
test   %rdx,%rdx
je     10a7 <lower_subexps+0x3c>
cmpb   $0x11,0x30(%rdx)
jne    10a7 <lower_subexps+0x3c>
mov    %rdi,%rsi
lea    0xc(%rsp),%rdi
callq  ed8 <lower_subexp>
mov    %rax,0x8(%rbx)
test   %rax,%rax
je     10a7 <lower_subexps+0x3c>
mov    %rbx,(%rax)
mov    0x10(%rbx),%rdx
test   %rdx,%rdx
je     10cf <lower_subexps+0x64>
cmpb   $0x11,0x30(%rdx)
jne    10cf <lower_subexps+0x64>
mov    %rbp,%rsi
lea    0xc(%rsp),%rdi
callq  ed8 <lower_subexp>
mov    %rax,0x10(%rbx)
test   %rax,%rax
je     10cf <lower_subexps+0x64>
mov    %rbx,(%rax)
mov    0xc(%rsp),%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
lower_subexps (void *extra, bin_tree_t *node)
{
  regex_t *preg = (regex_t *) extra;
  reg_errcode_t err = REG_NOERROR;
  if (node->left && node->left->token.type == SUBEXP)
    {
      node->left = lower_subexp (&err, preg, node->left);
      if (node->left)
 node->left->parent = node;
    }
  if (node->right && node->right->token.type == SUBEXP)
    {
      node->right = lower_subexp (&err, preg, node->right);
      if (node->right)
 node->right->parent = node;
    }
  return err;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
18 9
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 13
27 13
28 14
29 14
30 15
31 18
32 18
33 18
34 18
35 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 1edb <do_backspace+0xb>
mov    0x8(%rax),%rdx
cmp    %rdx,0x20(%rax)
jne    1eec <do_backspace+0x1c>
cmpq   $0x0,0x30(%rax)
je     1efb <do_backspace+0x2b>
callq  1ef1 <do_backspace+0x21>
mov    $0x2,%edi
callq  1efb <do_backspace+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_backspace(void)
{
    if (openfile->current != openfile->fileage || openfile->current_x > 0) {
 do_left();
 do_deletion(BACK);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 10c <_rl_next_macro_key+0x7>
test   %rdx,%rdx
je     167 <_rl_next_macro_key+0x62>
push   %rbx
mov    0x0(%rip),%ecx        # 118 <_rl_next_macro_key+0x13>
movslq %ecx,%rax
movzbl (%rdx,%rax,1),%eax
test   %al,%al
jne    132 <_rl_next_macro_key+0x2d>
callq  128 <_rl_next_macro_key+0x23>
callq  12d <_rl_next_macro_key+0x28>
nopl   (%rax)
jmp    16d <_rl_next_macro_key+0x68>
add    $0x1,%ecx
mov    %ecx,0x0(%rip)        # 13b <_rl_next_macro_key+0x36>
movsbl %al,%ebx
mov    0x0(%rip),%rsi        # 145 <_rl_next_macro_key+0x40>
mov    %ebx,%eax
test   $0x80000,%esi
je     16d <_rl_next_macro_key+0x68>
test   $0x48,%sil
je     16d <_rl_next_macro_key+0x68>
movslq %ecx,%rcx
cmpb   $0x0,(%rdx,%rcx,1)
jne    16d <_rl_next_macro_key+0x68>
callq  163 <_rl_next_macro_key+0x5e>
mov    %ebx,%eax
jmp    16d <_rl_next_macro_key+0x68>
mov    $0x0,%eax
retq   
pop    %rbx
xchg   %ax,%ax
retq   
<<<sep_in_sample>>>
_rl_next_macro_key ()
{
  int c;
  if (rl_executing_macro == 0)
    return (0);
  if (rl_executing_macro[executing_macro_index] == 0)
    {
      _rl_pop_executing_macro ();
      return (_rl_next_macro_key ());
    }
  c = rl_executing_macro[executing_macro_index++];
  if ((rl_readline_state & (0x0080000)) && (rl_readline_state & (0x0000008|0x0000040)) && rl_executing_macro[executing_macro_index] == 0)
      _rl_pop_executing_macro ();
  return c;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
13 9
14 11
15 11
16 11
17 12
18 14
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 14
28 14
29 5
30 5
31 15
32 15
33 15
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 32 <phash_create+0x8>
jne    4d <phash_create+0x23>
sub    $0x8,%rsp
mov    $0x40,%edi
callq  42 <phash_create+0x18>
mov    %rax,0x0(%rip)        # 49 <phash_create+0x1f>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
phash_create ()
{
  if (hashed_filenames == 0)
    hashed_filenames = hash_create (64);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x0,%esi
callq  10e <ImFromLex+0x13>
mov    %eax,%ebp
callq  115 <ImFromLex+0x1a>
movsbq (%rbx),%rcx
mov    (%rax),%rdx
testb  $0x4,0x1(%rdx,%rcx,2)
jne    134 <ImFromLex+0x39>
mov    %rbx,%rdi
callq  12b <ImFromLex+0x30>
cltq   
test   %rax,%rax
jne    162 <ImFromLex+0x67>
jmp    14b <ImFromLex+0x50>
mov    $0x3,%eax
cmp    $0x258,%ebp
je     162 <ImFromLex+0x67>
mov    $0x2,%al
cmp    $0x259,%ebp
je     162 <ImFromLex+0x67>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  15d <ImFromLex+0x62>
mov    $0x3,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ImFromLex (PSTR szLex)
{
  int ikwcode = GetKeywordCode (szLex, ((void *)0));
  long lReturn;
  lReturn = (!((*__ctype_b_loc ())[(int) ((szLex[0]))] & (unsigned short int) _ISalpha) ? atoi(szLex)
            : ikwcode == 600 ? 3
            : ikwcode == 601 ? 2
            : 0);
  if (!lReturn) {
    printf ("Warning: Unknown integrator specification (%s) -\n"
            "         Switching to Lsodes with default options\n\n", szLex);
    lReturn = 3;
  }
  return (lReturn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 9
17 9
18 9
19 5
20 5
21 5
22 5
23 5
24 5
25 10
26 10
27 10
28 10
29 12
30 15
31 15
32 15
33 15
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    %rdx,%r9
shr    %r9
je     e5b <gsl_vector_int_reverse+0x40>
shl    $0x2,%rsi
sub    $0x1,%rdx
imul   %rsi,%rdx
add    %rax,%rdx
mov    $0x0,%ecx
mov    (%rdx),%edi
mov    (%rax),%r8d
mov    %r8d,(%rdx)
mov    %edi,(%rax)
add    $0x1,%rcx
sub    %rsi,%rdx
add    %rsi,%rax
cmp    %r9,%rcx
jne    e42 <gsl_vector_int_reverse+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_int_reverse (gsl_vector_int * v)
{
  int * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          int tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 8
6 8
7 14
8 14
9 14
10 14
11 8
12 14
13 15
14 15
15 16
16 8
17 8
18 8
19 8
20 8
21 20
22 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1002 <pch_repl_lines+0x7>
retq   
<<<sep_in_sample>>>
pch_repl_lines (void)
{
    return p_repl_lines;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rdx,%rbp
callq  ec <osip_strncpy+0x11>
movb   $0x0,(%rbx,%rbp,1)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_strncpy (char *dest, const char *src, size_t length)
{
  strncpy (dest, src, length);
  dest[length] = '\0';
  return dest;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1b51 <grecs_next_node+0x29>
mov    0x30(%rdi),%rax
test   %rax,%rax
jne    1b56 <grecs_next_node+0x2e>
jmp    1b46 <grecs_next_node+0x1e>
mov    0x28(%rdi),%rdi
test   %rdi,%rdi
je     1b56 <grecs_next_node+0x2e>
cmpl   $0x0,(%rdi)
je     1b56 <grecs_next_node+0x2e>
mov    0x38(%rdi),%rax
test   %rax,%rax
je     1b38 <grecs_next_node+0x10>
repz retq 
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
grecs_next_node(struct grecs_node *node)
{
 if (!node)
  return ((void *)0);
 if (node->down)
  return node->down;
 while (!node->next) {
  node = node->up;
  if (!node || node->type == grecs_node_root)
   return ((void *)0);
 }
 return node->next;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 8
8 9
9 9
10 9
11 9
12 7
13 7
14 7
15 7
16 4
17 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rcx,%r12
mov    0x10(%rdi),%rax
mov    0x18(%rsi),%ebp
or     0x18(%rdi),%ebp
test   %rax,%rax
jne    704 <usage_argful_short_opt+0x28>
mov    0x10(%rsi),%rax
test   %rax,%rax
je     770 <usage_argful_short_opt+0x94>
test   $0x10,%bpl
jne    770 <usage_argful_short_opt+0x94>
mov    %rax,%rsi
mov    %rdx,%rdi
callq  715 <usage_argful_short_opt+0x39>
mov    %rax,%r13
test   $0x1,%bpl
je     738 <usage_argful_short_opt+0x5c>
mov    0x8(%rbx),%edx
mov    %rax,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  736 <usage_argful_short_opt+0x5a>
jmp    770 <usage_argful_short_opt+0x94>
mov    %rax,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x5(%rcx),%rsi
mov    %r12,%rdi
callq  648 <space>
mov    0x8(%rbx),%edx
mov    %r13,%rcx
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x0,%eax
callq  770 <usage_argful_short_opt+0x94>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
usage_argful_short_opt (const struct argp_option *opt,
                        const struct argp_option *real,
                        const char *domain, void *cookie)
{
  argp_fmtstream_t stream = cookie;
  const char *arg = opt->arg;
  int flags = opt->flags | real->flags;
  if (! arg)
    arg = real->arg;
  if (arg && !(flags & 0x10))
    {
      arg = dgettext (domain, arg);
      if (flags & 0x1)
        argp_fmtstream_printf (stream, " [-%c[%s]]", opt->key, arg);
      else
        {
          space (stream, 6 + strlen (arg));
          argp_fmtstream_printf (stream, "[-%c %s]", opt->key, arg);
        }
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 7
10 7
11 8
12 8
13 9
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 13
23 13
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 18
40 18
41 18
42 18
43 18
44 18
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
callq  104d <kwsfree+0xe>
mov    %rbx,%rdi
callq  1055 <kwsfree+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
kwsfree (kwset_t kws)
{
  struct kwset *kwset;
  kwset = (struct kwset *) kws;
  __extension__ ({ struct obstack *__o = (&kwset->obstack); void *__obj = (((void *)0)); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = (char *)__obj; else (obstack_free) (__o, __obj); });
  free(kws);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 6
6 6
7 7
8 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%edi
callq  3ef <new_exclude+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
new_exclude (void)
{
  return xzalloc (sizeof *new_exclude ());
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
cmpb   $0x10,0x30(%rsi)
jne    d42 <calc_first+0x2a>
mov    0x8(%rsi),%rax
mov    0x18(%rax),%rdx
mov    %rdx,0x18(%rsi)
mov    0x38(%rax),%rax
mov    %rax,0x38(%rsi)
mov    $0x0,%edx
jmp    d9a <calc_first+0x82>
mov    %rdi,%rbp
mov    %rsi,0x18(%rbx)
mov    0x28(%rsi),%rsi
mov    0x30(%rbx),%rdx
callq  b3a <re_dfa_add_node>
mov    %rax,0x38(%rbx)
cmp    $0xffffffffffffffff,%rax
je     d95 <calc_first+0x7d>
mov    $0x0,%edx
cmpb   $0xc,0x30(%rbx)
jne    d9a <calc_first+0x82>
shl    $0x4,%rax
add    0x0(%rbp),%rax
movzwl 0x28(%rbx),%edx
and    $0x3ff,%edx
shl    $0x8,%edx
mov    0x8(%rax),%ecx
and    $0xfffc00ff,%ecx
or     %ecx,%edx
mov    %edx,0x8(%rax)
mov    $0x0,%edx
jmp    d9a <calc_first+0x82>
mov    $0xc,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
calc_first (void *extra, bin_tree_t *node)
{
  re_dfa_t *dfa = (re_dfa_t *) extra;
  if (node->token.type == CONCAT)
    {
      node->first = node->left->first;
      node->node_idx = node->left->node_idx;
    }
  else
    {
      node->first = node;
      node->node_idx = re_dfa_add_node (dfa, node->token);
      if (__builtin_expect (node->node_idx == ((Idx) -1), 0))
        return _REG_ESPACE;
      if (node->token.type == ANCHOR)
        dfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;
    }
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 18
13 18
14 18
15 11
16 12
17 12
18 12
19 12
20 13
21 13
22 18
23 15
24 15
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 18
35 18
36 14
37 19
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%r13d
mov    %ecx,%ebp
mov    $0x0,%edi
callq  1b7 <set_classpath+0x1d>
test   %rax,%rax
je     1c9 <set_classpath+0x2f>
mov    %rax,%rdi
callq  1c4 <set_classpath+0x2a>
mov    %rax,%r14
jmp    1cf <set_classpath+0x35>
mov    $0x0,%r14d
movzbl %r13b,%edx
mov    %r12d,%esi
mov    %rbx,%rdi
callq  1de <set_classpath+0x44>
mov    %rax,%rbx
test   %bpl,%bpl
je     1f8 <set_classpath+0x5e>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1f8 <set_classpath+0x5e>
mov    $0x1,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  20a <set_classpath+0x70>
mov    %rbx,%rdi
callq  212 <set_classpath+0x78>
mov    %r14,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
set_classpath (const char * const *classpaths, unsigned int classpaths_count,
               _Bool use_minimal_classpath, _Bool verbose)
{
  const char *old_CLASSPATH = getenv ("CLASSPATH");
  char *result = (old_CLASSPATH != ((void *)0) ? xstrdup (old_CLASSPATH) : ((void *)0));
  char *new_CLASSPATH =
    new_classpath (classpaths, classpaths_count, use_minimal_classpath);
  if (verbose)
    printf ("CLASSPATH" "=%s ", new_CLASSPATH);
  xsetenv ("CLASSPATH", new_CLASSPATH, 1);
  free (new_CLASSPATH);
  return result;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 7
20 6
21 6
22 6
23 6
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 13
37 13
38 13
39 13
40 13
41 13
42 13
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x2,%edi
callq  19ac <catchAllSignals+0x10>
cmp    $0xffffffffffffffff,%rax
setne  %bl
movzbl %bl,%ebx
mov    $0x0,%esi
mov    $0x3,%edi
callq  19c5 <catchAllSignals+0x29>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x6,%edi
callq  19e0 <catchAllSignals+0x44>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0xf,%edi
callq  19fb <catchAllSignals+0x5f>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x14,%edi
callq  1a16 <catchAllSignals+0x7a>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x9,%edi
callq  1a31 <catchAllSignals+0x95>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x13,%edi
callq  1a4c <catchAllSignals+0xb0>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
catchAllSignals()
{
  int res = 1;
    if(signal(2, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(3, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(6, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(15, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(20, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(9, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(19, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 10
42 10
43 10
44 12
45 12
46 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     24f <freeITable+0x1a>
mov    0x8(%rdi),%rdi
callq  247 <freeITable+0x12>
mov    %rbx,%rdi
callq  24f <freeITable+0x1a>
pop    %rbx
retq   
<<<sep_in_sample>>>
freeITable (ITable *oldp)
{
 if ( oldp ) {
  free ( oldp->entry );
  free ( oldp );
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  26c <initialize_backups+0xe>
test   %rax,%rax
je     27d <initialize_backups+0x1f>
cmpb   $0x0,(%rax)
je     27d <initialize_backups+0x1f>
mov    %rax,0x0(%rip)        # 27d <initialize_backups+0x1f>
callq  282 <initialize_backups+0x24>
mov    %eax,0x0(%rip)        # 288 <initialize_backups+0x2a>
test   %eax,%eax
jne    2d2 <initialize_backups+0x74>
mov    $0x0,%edi
callq  296 <initialize_backups+0x38>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 2a0 <initialize_backups+0x42>
mov    $0x0,%eax
callq  2aa <initialize_backups+0x4c>
mov    $0x0,%edi
callq  2b4 <initialize_backups+0x56>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 2be <initialize_backups+0x60>
mov    $0x0,%eax
callq  2c8 <initialize_backups+0x6a>
movl   $0x3,0x0(%rip)        # 2d2 <initialize_backups+0x74>
callq  2d7 <initialize_backups+0x79>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
initialize_backups (void)
{
    char *v = getenv ("SIMPLE_BACKUP_SUFFIX");
    if (v && *v)
    {
        simple_backup_suffix = v;
    }
    version_control = version_control_value ();
    if (version_control == unknown)
    {
        fprintf (stderr, gettext("indent:  Strange version-control value\n"));
        fprintf (stderr, gettext("indent:  Using numbered-existing\n"));
        version_control = numbered_existing;
    }
    set_version_width ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 6
9 8
10 8
11 9
12 9
13 11
14 11
15 11
16 11
17 11
18 11
19 12
20 12
21 12
22 12
23 12
24 12
25 13
26 15
27 16
28 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  2512 <gsl_sf_mathieu_a+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     2538 <gsl_sf_mathieu_a+0x32>
mov    %eax,%ecx
mov    $0x374,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2531 <gsl_sf_mathieu_a+0x2b>
movsd  (%rsp),%xmm0
jmp    2538 <gsl_sf_mathieu_a+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_mathieu_a(int order, double qq)
{
 gsl_sf_result result; int status = gsl_sf_mathieu_a_e(order, qq, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_mathieu_a_e(order, qq, &result)", "mathieu_charv.c", 884, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 325 <bgp_clear+0x7>
test   %rdi,%rdi
je     373 <bgp_clear+0x55>
cmpl   $0x0,0x0(%rip)        # 331 <bgp_clear+0x13>
je     373 <bgp_clear+0x55>
sub    $0x8,%rsp
mov    $0x368,%edx
mov    $0x0,%esi
callq  346 <bgp_clear+0x28>
movq   $0x0,0x0(%rip)        # 351 <bgp_clear+0x33>
movl   $0x0,0x0(%rip)        # 35b <bgp_clear+0x3d>
movl   $0x0,0x0(%rip)        # 365 <bgp_clear+0x47>
movl   $0x0,0x0(%rip)        # 36f <bgp_clear+0x51>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
bgp_clear ()
{
  if (bgpids.storage == 0 || bgpids.nalloc == 0)
    return;
  sh_xfree((bgpids.storage), "jobs.c", 872);
  bgpids.storage = 0;
  bgpids.nalloc = 0;
  bgpids.head = 0;
  bgpids.npid = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 5
8 5
9 5
10 6
11 7
12 8
13 9
14 10
15 10
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x36,%edi
ja     10c <c_isxdigit+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case 'a' + (0): case 'b' + (0): case 'c' + (0): case 'd' + (0): case 'e' + (0): case 'f' + (0): case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 9
9 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
cmp    %rdx,%rax
ja     59bc <gsl_matrix_ulong_const_subdiagonal+0x4d>
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5994 <gsl_matrix_ulong_const_subdiagonal+0x25>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    59fc <gsl_matrix_ulong_const_subdiagonal+0x8d>
mov    0x10(%rsi),%rcx
lea    0x0(,%rcx,8),%r8
imul   %rdx,%r8
add    0x18(%rsi),%r8
mov    0x20(%rsi),%rdi
sub    %rdx,%rax
mov    0x8(%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
add    $0x1,%rcx
mov    %rcx,0x8(%rbx)
mov    %r8,0x10(%rbx)
mov    %rdi,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_ulong_const_subdiagonal (const gsl_matrix_ulong * m,
                                    const size_t k)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 14
22 12
23 12
24 12
25 12
26 17
27 13
28 13
29 17
30 17
31 17
32 19
33 19
34 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 1cd <make_history_line_current+0xa>
mov    $0x0,%esi
mov    (%rdi),%rdi
callq  1da <make_history_line_current+0x17>
mov    $0x1,%edi
callq  1e4 <make_history_line_current+0x21>
cmpl   $0x0,0x0(%rip)        # 1eb <make_history_line_current+0x28>
jne    1f2 <make_history_line_current+0x2f>
callq  1f2 <make_history_line_current+0x2f>
mov    0x0(%rip),%rdi        # 1f9 <make_history_line_current+0x36>
test   %rdi,%rdi
je     203 <make_history_line_current+0x40>
callq  203 <make_history_line_current+0x40>
movq   $0x0,0x0(%rip)        # 20e <make_history_line_current+0x4b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_history_line_current (entry)
     HIST_ENTRY *entry;
{
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
  if (rl_editing_mode == 0)
    rl_free_undo_list ();
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 11
17 11
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x0,0x4(%rdi)
movl   $0x0,0x8(%rdi)
retq   
<<<sep_in_sample>>>
version_set_to_null (version_t version)
{
  size_t n;
  for (n = 0 ; n < 3 ; n++)
    version[n] = 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
callq  a1f <grecs_print_locus+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_locus(grecs_locus_t *locus, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_locus(locus, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     683 <SkipWhitespace+0x8c>
mov    0x10(%rdi),%rax
cmpb   $0x0,(%rax)
jne    619 <SkipWhitespace+0x22>
cmpq   $0x0,(%rdi)
je     619 <SkipWhitespace+0x22>
callq  619 <SkipWhitespace+0x22>
callq  61e <SkipWhitespace+0x27>
mov    %rax,%rbp
mov    $0x0,%eax
jmp    666 <SkipWhitespace+0x6f>
cmp    $0x23,%dl
jne    637 <SkipWhitespace+0x40>
mov    %rbx,%rdi
callq  635 <SkipWhitespace+0x3e>
jmp    661 <SkipWhitespace+0x6a>
cmp    $0xa,%dl
jne    640 <SkipWhitespace+0x49>
addl   $0x1,0x18(%rbx)
lea    0x1(%rcx),%rax
mov    %rax,0x10(%rbx)
cmpb   $0x0,0x1(%rcx)
jne    661 <SkipWhitespace+0x6a>
cmpq   $0x0,(%rbx)
je     661 <SkipWhitespace+0x6a>
mov    %rbx,%rdi
callq  65c <SkipWhitespace+0x65>
cmp    $0xffffffff,%eax
je     68a <SkipWhitespace+0x93>
mov    $0x1,%eax
mov    0x10(%rbx),%rcx
movzbl (%rcx),%edx
movsbq %dl,%rdi
mov    0x0(%rbp),%rsi
testb  $0x20,0x1(%rsi,%rdi,2)
jne    628 <SkipWhitespace+0x31>
cmp    $0x23,%dl
je     62d <SkipWhitespace+0x36>
jmp    68f <SkipWhitespace+0x98>
mov    $0x0,%eax
jmp    68f <SkipWhitespace+0x98>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
SkipWhitespace (PINPUTBUF pibIn)
{
  char c;
  int fSkipped = 0;
  if (!pibIn)
    return 0;
  if (!*pibIn->pbufCur && pibIn->pfileIn)
    FillBuffer (pibIn);
  while (((*__ctype_b_loc ())[(int) ((c = *pibIn->pbufCur))] & (unsigned short int) _ISspace) || c == ('#')) {
    fSkipped = 1;
    if (c == ('#'))
      SkipComment (pibIn);
    else {
      if (c == '\n')
    pibIn->iLineNum++;
      if (!*(++pibIn->pbufCur) && pibIn->pfileIn)
    if (FillBuffer (pibIn) == (-1))
      break;
    }
  }
  return (fSkipped);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 8
13 9
14 9
15 9
16 9
17 11
18 11
19 12
20 12
21 12
22 14
23 14
24 15
25 16
26 16
27 16
28 16
29 16
30 16
31 17
32 17
33 17
34 17
35 17
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 6
46 6
47 10
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1ad1 <gsl_sf_exprel+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1af7 <gsl_sf_exprel+0x32>
mov    %eax,%ecx
mov    $0x25b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1af0 <gsl_sf_exprel+0x2b>
movsd  (%rsp),%xmm0
jmp    1af7 <gsl_sf_exprel+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_exprel(const double x)
{
  gsl_sf_result result; int status = gsl_sf_exprel_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_exprel_e(x, &result)", "exp.c", 603, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     199 <gsl_interp_free+0x23>
mov    (%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     191 <gsl_interp_free+0x1b>
mov    0x20(%rdi),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  199 <gsl_interp_free+0x23>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_interp_free (gsl_interp * interp)
{
  if (!interp) { return ; };
  if (interp->type->free)
    interp->type->free (interp->state);
  free (interp);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     6ea1 <gsl_matrix_short_const_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6e79 <gsl_matrix_short_const_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    6ed2 <gsl_matrix_short_const_row+0x7b>
mov    0x10(%rsi),%rax
add    %rax,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_short_const_row (const gsl_matrix_short * m, const size_t i)
{
  _gsl_vector_short_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_short v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x98,%rsp
mov    %rdi,%rbx
mov    %rsp,%rsi
callq  db <file_status+0x14>
test   %eax,%eax
js     13f <file_status+0x78>
mov    0x18(%rsp),%edx
and    $0xf000,%edx
mov    $0x11,%eax
cmp    $0x4000,%edx
je     144 <file_status+0x7d>
mov    %rbx,%rdi
mov    $0x0,%eax
callq  0 <exec_name_should_ignore>
mov    $0x1,%ebp
test   %eax,%eax
jne    124 <file_status+0x5d>
mov    $0x1,%esi
mov    %rbx,%rdi
callq  119 <file_status+0x52>
cmp    $0x1,%eax
sbb    %ebp,%ebp
and    $0x2,%ebp
add    $0x1,%ebp
mov    $0x4,%esi
mov    %rbx,%rdi
callq  131 <file_status+0x6a>
mov    %eax,%edx
mov    %ebp,%eax
or     $0x40,%eax
test   %edx,%edx
cmovne %ebp,%eax
jmp    144 <file_status+0x7d>
mov    $0x0,%eax
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
file_status (name)
     const char *name;
{
  struct stat finfo;
  int r;
  if (stat (name, &finfo) < 0)
    return (0);
  if (((((finfo.st_mode)) & 0170000) == (0040000)))
    return (0x1|0x10);
  r = 0x1;
  if (exec_name_should_ignore (name) == 0 && eaccess (name, 1) == 0)
    r |= 0x2;
  if (eaccess (name, 4) == 0)
    r |= 0x40;
  return r;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 8
10 8
11 9
12 8
13 8
14 11
15 11
16 11
17 10
18 11
19 11
20 11
21 11
22 11
23 10
24 10
25 10
26 10
27 13
28 13
29 13
30 13
31 13
32 14
33 14
34 14
35 14
36 7
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x0(%rip),%eax        # 280 <make_word_list+0x12>
test   %eax,%eax
jle    29c <make_word_list+0x2e>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 28d <make_word_list+0x1f>
cltq   
mov    0x0(%rip),%rdx        # 296 <make_word_list+0x28>
mov    (%rdx,%rax,8),%rax
jmp    2b0 <make_word_list+0x42>
mov    $0xaf,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  2b0 <make_word_list+0x42>
mov    %rbp,0x8(%rax)
mov    %rbx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
make_word_list (word, wlink)
     WORD_DESC *word;
     WORD_LIST *wlink;
{
  WORD_LIST *temp;
  do { if ((wlcache).nc > 0) { (temp) = (WORD_LIST *)((WORD_LIST **)((wlcache).data))[--(wlcache).nc]; } else (temp) = (WORD_LIST *)sh_xmalloc((sizeof (WORD_LIST)), "make_cmd.c", 175); } while (0);
  temp->word = word;
  temp->next = wlink;
  return (temp);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 8
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x43,%esi
mov    (%rdi),%rdi
callq  4de7 <swc_get_default_sh_dash_s+0x11>
mov    $0x0,%edi
mov    $0x7,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
mov    $0x0,%eax
cmp    %dl,%cl
je     4e0c <swc_get_default_sh_dash_s+0x36>
mov    0x4e0(%rbx),%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
swc_get_default_sh_dash_s(GB * G)
{
 if (strcmp(get_opta(G->optaM, SW_E_swbis_shell_command), "detect") == 0)
  return "exit 1";
 else
  return G->g_sh_dash_s;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 3
14 3
15 6
16 7
17 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rcx
sub    %rcx,%rsi
mov    $0x1007,%eax
cmp    $0x1,%rsi
jle    4cf <mu_parse822_quoted_pair+0x30>
cmpb   $0x5c,(%rcx)
jne    4cf <mu_parse822_quoted_pair+0x30>
movsbl 0x1(%rcx),%esi
mov    %rdx,%rdi
callq  cf <str_append_char>
mov    %eax,%edx
test   %edx,%edx
jne    4cf <mu_parse822_quoted_pair+0x30>
addq   $0x2,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_parse822_quoted_pair (const char **p, const char *e, char **qpair)
{
  int rc;
  if ((e - *p) < 2)
    return (0x1000 +7);
  if (**p != '\\')
    return (0x1000 +7);
  if ((rc = str_append_char (qpair, *(*p + 1))))
    return rc;
  *p += 2;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 4
7 4
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 8
16 10
17 12
18 12
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 41d4 <set_directory_hook+0x7>
je     41ed <set_directory_hook+0x20>
movq   $0x0,0x0(%rip)        # 41e1 <set_directory_hook+0x14>
movq   $0x0,0x0(%rip)        # 41ec <set_directory_hook+0x1f>
retq   
movq   $0x0,0x0(%rip)        # 41f8 <set_directory_hook+0x2b>
movq   $0x0,0x0(%rip)        # 4203 <set_directory_hook+0x36>
retq   
<<<sep_in_sample>>>
set_directory_hook ()
{
  if (dircomplete_expand)
    {
      rl_directory_completion_hook = bash_directory_completion_hook;
      rl_directory_rewrite_hook = (rl_icppfunc_t *)0;
    }
  else
    {
      rl_directory_rewrite_hook = bash_directory_completion_hook;
      rl_directory_completion_hook = (rl_icppfunc_t *)0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 10
7 11
8 11
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
movl   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movl   $0x4,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x22b8,%esi
mov    $0x8,%edi
mov    $0x0,%eax
callq  2c3 <main+0x50>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     2e2 <main+0x6f>
callq  2d5 <main+0x62>
mov    %rbx,%rdi
callq  2dd <main+0x6a>
mov    $0x0,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main ()
{
  struct MHD_Daemon *daemon;
  daemon = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY, 8888, ((void *)0), ((void *)0),
                             &answer_to_connection, ((void *)0),
                             MHD_OPTION_NOTIFY_COMPLETED, request_completed,
                             ((void *)0), MHD_OPTION_END);
  if (((void *)0) == daemon)
    return 1;
  (void) getchar ();
  MHD_stop_daemon (daemon);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 9
17 8
18 8
19 10
20 11
21 11
22 12
23 13
24 13
25 13
<<<sep_out_sample>>>
movsd  (%rdi),%xmm1
movsd  (%rsi),%xmm0
ucomisd %xmm1,%xmm0
ja     19 <dblcmp+0x19>
ucomisd %xmm0,%xmm1
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
dblcmp(double *x, double *y)
{
  if (*x < *y)
    return -1;
  if (*x > *y)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 4
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # e1 <myexit+0xa>
test   %rdi,%rdi
je     eb <myexit+0x14>
callq  eb <myexit+0x14>
cmpb   $0x0,0x0(%rip)        # f2 <myexit+0x1b>
je     112 <myexit+0x3b>
mov    $0x0,%edi
callq  fe <myexit+0x27>
mov    $0x0,%edi
callq  108 <myexit+0x31>
mov    $0x0,%edi
callq  112 <myexit+0x3b>
cmpl   $0x1,0x0(%rip)        # 119 <myexit+0x42>
jne    120 <myexit+0x49>
callq  120 <myexit+0x49>
cmp    $0x3,%ebx
jne    12a <myexit+0x53>
callq  12a <myexit+0x53>
mov    %ebx,%edi
callq  131 <main>
<<<sep_in_sample>>>
myexit(int sig)
{
 if (refsfound != ((void *)0))
  fclose(refsfound);
 if (temp1[0] != '\0') {
  unlink(temp1);
  unlink(temp2);
  rmdir(tempdirpv);
 }
 if (incurses == YES) {
  exitcurses();
 }
 if (sig == 3) {
  abort();
 }
 exit(sig);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 10
16 10
17 11
18 13
19 13
20 14
21 16
22 16
<<<sep_out_sample>>>
movsd  0x8(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
rec_sex_ast_node_real (rec_sex_ast_node_t node)
{
  return node->val.real;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rsi
lea    -0x1(%rsi),%rdx
mov    0x28(%rdi),%edi
mov    $0x0,%eax
test   %edi,%edi
je     5b <variable_hash_1+0x5b>
cmp    $0x1,%edi
je     4c <variable_hash_1+0x4c>
movzbl (%rsi),%ecx
test   %cl,%cl
je     53 <variable_hash_1+0x53>
lea    -0x2(%rdi),%edi
add    %rsi,%rdi
mov    %rsi,%rdx
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
cmp    %rdi,%rdx
je     5b <variable_hash_1+0x5b>
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    28 <variable_hash_1+0x28>
jmp    5b <variable_hash_1+0x5b>
mov    $0x0,%eax
jmp    5b <variable_hash_1+0x5b>
mov    %rsi,%rdx
mov    $0x0,%eax
movzbl 0x1(%rdx),%edx
add    %rdx,%rax
retq   
<<<sep_in_sample>>>
variable_hash_1 (const void *keyv)
{
  struct variable const *key = (struct variable const *) keyv;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((key->name)) - 1; int _n_ = ((key->length)); if (_n_) while (--_n_ && *++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); (_result_) += *++_key_; } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
movslq %esi,%rsi
lea    (%rcx,%rsi,1),%rax
mov    %rax,%rdx
cmp    0x18(%rdi),%rax
jb     ee <ring_supplied+0x1f>
movslq 0x28(%rdi),%rax
sub    %rax,%rsi
lea    (%rcx,%rsi,1),%rdx
mov    %rdx,0x8(%rdi)
mov    0x0(%rip),%rax        # f9 <ring_supplied+0x2a>
add    $0x1,%rax
mov    %rax,0x0(%rip)        # 104 <ring_supplied+0x35>
mov    %rax,0x38(%rdi)
retq   
<<<sep_in_sample>>>
ring_supplied (Ring * ring, int count)
{
  ring->supply = (((ring->supply)+(count) < (ring)->top)? (ring->supply)+(count) : (((ring->supply)+(count))-(ring)->size));
  ring->supplytime = ++ring_clock;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
callq  13d5 <quotearg_char+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_www_authenticate_get_nonce (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->nonce;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  612 <osip_ist_lock+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_ist_lock (osip_t * osip)
{
  return osip_mutex_lock (osip->ist_fastmutex);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
movsd  0x640(%rdi),%xmm0
mulsd  0x640(%rsi),%xmm0
movsd  %xmm0,0x640(%rdi)
callq  404e <multunit+0x29>
test   %eax,%eax
jne    4065 <multunit+0x40>
lea    0x320(%rbp),%rsi
lea    0x320(%rbx),%rdi
callq  4065 <multunit+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
multunit(struct unittype *left, struct unittype *right)
{
  int myerr;
  left->factor *= right->factor;
  myerr = moveproduct(left->numerator, right->numerator);
  if (!myerr)
    myerr = moveproduct(left->denominator, right->denominator);
  return myerr;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 7
13 7
14 7
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
callq  55b <it_init_bindings+0xc>
mov    %rax,%r12
mov    $0x0,%edi
callq  568 <it_init_bindings+0x19>
mov    %rax,%rbx
mov    %r12,(%rax)
movl   $0x0,0x8(%rax)
mov    %r12,%rdi
callq  57d <it_init_bindings+0x2e>
mov    %eax,0xc(%rbx)
orl    $0x20,0x0(%rbp)
mov    %rbx,0x10(%rbp)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
it_init_bindings (itp)
     ITEMLIST *itp;
{
  char **blist;
  STRINGLIST *sl;
  blist = (char **)rl_funmap_names ();
  sl = strlist_create (0);
  sl->list = blist;
  sl->list_size = 0;
  sl->list_len = strvec_len (sl->list);
  itp->flags |= 0x020;
  itp->slist = sl;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 7
8 7
9 7
10 8
11 9
12 10
13 10
14 10
15 11
16 12
17 14
18 14
19 14
20 14
21 14
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_multiroot_fsolver_root (const gsl_multiroot_fsolver * s)
{
  return s->x;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
cmp    $0x3,%rdx
je     7f <get_size+0x2b>
cmp    $0x3,%rdx
jg     6b <get_size+0x17>
cmp    $0x1,%rdx
je     90 <get_size+0x3c>
jmp    97 <get_size+0x43>
cmp    $0x5,%rdx
nop
je     8a <get_size+0x36>
mov    $0x50,%eax
cmp    $0x7,%rdx
je     9c <get_size+0x48>
jmp    97 <get_size+0x43>
movswq 0x12(%rdi),%rax
add    $0x19,%rax
jmp    9c <get_size+0x48>
movslq 0x10(%rdi),%rax
jmp    9c <get_size+0x48>
movswq 0x1c(%rdi),%rax
jmp    9c <get_size+0x48>
movswq 0x4(%rdx),%rax
add    $0x7,%rax
and    $0xfffffffffffffff8,%rax
retq   
<<<sep_in_sample>>>
get_size (__dhp p)
{
  long size;
  switch ((long int) p->pp)
    {
    case 3:
      size = ((__textref) p)->h.size + sizeof (__th) + 1;
      break;
    case 5:
      size = ((__ahp) p)->size;
      break;
    case 1:
      size = ((__shp) p)->size;
      break;
    case 7:
      size = sizeof (__thunk);
      break;
    default:
      size = p->pp->size;
    };
  return (((((long)size)+8 -1)&(~(8 -1))));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 16
13 4
14 4
15 4
16 7
17 7
18 8
19 10
20 11
21 13
22 14
23 19
24 21
25 21
26 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x138(%rdi),%edi
test   %edi,%edi
js     3c6 <shcmd_unix_execvp+0x13>
callq  3c6 <shcmd_unix_execvp+0x13>
mov    0x18(%rbx),%rax
mov    %rax,%rsi
mov    (%rax),%rdi
callq  3d5 <shcmd_unix_execvp+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
shcmd_unix_execvp(void * cmd)
{
 if (((SHCMD*)cmd)->close_all_fd_ >= 0)
  swgp_close_all_fd(((SHCMD*)cmd)->close_all_fd_);
 return execvp(((SHCMD*)cmd)->argv_[0], ((SHCMD*)cmd)->argv_);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  b98 <fopen_temp+0xf>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  ba3 <fopen_temp+0x1a>
mov    %rax,%rbx
callq  bab <fopen_temp+0x22>
mov    %rax,%rbp
mov    (%rax),%r12d
test   %rbx,%rbx
je     bce <fopen_temp+0x45>
mov    %rbx,%rdi
callq  bbe <fopen_temp+0x35>
test   %eax,%eax
jns    bc7 <fopen_temp+0x3e>
callq  bc7 <fopen_temp+0x3e>
mov    %eax,%edi
callq  37d <register_fd>
callq  bd3 <fopen_temp+0x4a>
mov    %r12d,0x0(%rbp)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fopen_temp (const char *file_name, const char *mode)
{
  FILE *fp;
  int saved_errno;
  block_fatal_signals ();
    {
      fp = fopen (file_name, mode);
      saved_errno = (*__errno_location ());
    }
  if (fp != ((void *)0))
    {
      int fd = fileno (fp);
      if (!(fd >= 0))
        abort ();
      register_fd (fd);
    }
  unblock_fatal_signals ();
  (*__errno_location ()) = saved_errno;
  return fp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 10
15 10
16 12
17 12
18 13
19 13
20 14
21 15
22 15
23 17
24 18
25 20
26 20
27 20
28 20
29 20
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
mov    0x0(%rip),%r13        # 15 <VAllocDepthCueuedColor+0x15>
mov    0x8(%r13),%rbx
test   %rbx,%rbx
je     59 <VAllocDepthCueuedColor+0x59>
mov    %rbp,%rsi
mov    (%rbx),%rdi
callq  29 <VAllocDepthCueuedColor+0x29>
test   %eax,%eax
jne    42 <VAllocDepthCueuedColor+0x42>
test   %r12d,%r12d
je     3a <VAllocDepthCueuedColor+0x3a>
testb  $0x1,0x8(%rbx)
je     42 <VAllocDepthCueuedColor+0x42>
jmp    a1 <VAllocDepthCueuedColor+0xa1>
cmpw   $0x0,0x8(%rbx)
nop
je     a6 <VAllocDepthCueuedColor+0xa6>
mov    0x10(%rbx),%rax
test   %rax,%rax
je     50 <VAllocDepthCueuedColor+0x50>
mov    %rax,%rbx
jmp    1e <VAllocDepthCueuedColor+0x1e>
lea    0x10(%rbx),%r14
test   %rbx,%rbx
jne    5d <VAllocDepthCueuedColor+0x5d>
lea    0x8(%r13),%r14
mov    $0x18,%edi
callq  67 <VAllocDepthCueuedColor+0x67>
mov    %rax,%rbx
mov    %rax,(%r14)
mov    %rbp,%rdi
callq  75 <VAllocDepthCueuedColor+0x75>
mov    %rax,(%rbx)
mov    (%r14),%rax
movw   $0x0,0xa(%rax)
mov    (%r14),%rax
test   %r12d,%r12d
setne  %dl
movzbl %dl,%edx
mov    %dx,0x8(%rax)
mov    (%r14),%rax
movq   $0x0,0x10(%rax)
mov    (%r14),%rax
jmp    a9 <VAllocDepthCueuedColor+0xa9>
mov    %rbx,%rax
jmp    a9 <VAllocDepthCueuedColor+0xa9>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
VAllocDepthCueuedColor(char *name, int flag)
{
 VColor *p = _VDefaultWorkContext->VColorList, *prev = 0, **q;
 while (p != (VColor *) 0) {
  if (strcmp(p->color_name, name) == 0) {
   if ((flag && (p->flags & 1)) ||
    (flag == 0 && p->flags == 0)) {
    return p;
   }
  }
  prev = p;
  p = p->next;
 }
 if (prev == (VColor *) 0)
  q = &_VDefaultWorkContext->VColorList;
 else
  q = &(prev->next);
 *q = (VColor *) Vmalloc(sizeof(VColor));
 (*q)->color_name = strdup(name);
 (*q)->cIndex = 0;
 (*q)->flags = flag ? 1 : 0;
 (*q)->next = 0;
 return *q;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 12
26 4
27 4
28 12
29 12
30 17
31 14
32 14
33 15
34 18
35 18
36 18
37 18
38 19
39 19
40 19
41 20
42 20
43 21
44 21
45 21
46 21
47 21
48 22
49 22
50 23
51 23
52 23
53 23
54 23
55 24
56 24
57 24
58 24
59 24
60 24
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     493 <osip_call_id_match+0x63>
mov    %rsi,%rbx
test   %rsi,%rsi
je     493 <osip_call_id_match+0x63>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     49a <osip_call_id_match+0x6a>
mov    (%rsi),%rsi
test   %rsi,%rsi
je     4a1 <osip_call_id_match+0x71>
callq  45b <osip_call_id_match+0x2b>
test   %eax,%eax
jne    4a8 <osip_call_id_match+0x78>
mov    0x8(%rbp),%rdi
test   %rdi,%rdi
jne    477 <osip_call_id_match+0x47>
cmpq   $0x0,0x8(%rbx)
setne  %al
movzbl %al,%eax
neg    %eax
jmp    4b4 <osip_call_id_match+0x84>
cmpq   $0x0,0x8(%rbx)
je     4af <osip_call_id_match+0x7f>
mov    0x8(%rbx),%rsi
callq  487 <osip_call_id_match+0x57>
test   %eax,%eax
setne  %al
movzbl %al,%eax
neg    %eax
jmp    4b4 <osip_call_id_match+0x84>
mov    $0xfffffffe,%eax
jmp    4b4 <osip_call_id_match+0x84>
mov    $0xfffffffe,%eax
jmp    4b4 <osip_call_id_match+0x84>
mov    $0xfffffffe,%eax
jmp    4b4 <osip_call_id_match+0x84>
mov    $0xffffffff,%eax
jmp    4b4 <osip_call_id_match+0x84>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_call_id_match (osip_call_id_t * callid1, osip_call_id_t * callid2)
{
  if (callid1 == ((void *)0) || callid2 == ((void *)0))
    return -2;
  if (callid1->number == ((void *)0) || callid2->number == ((void *)0))
    return -2;
  if (0 != strcmp (callid1->number, callid2->number))
    return -1;
  if ((callid1->host == ((void *)0)) && (callid2->host == ((void *)0)))
    return 0;
  if ((callid1->host == ((void *)0)) && (callid2->host != ((void *)0)))
    return -1;
  if ((callid1->host != ((void *)0)) && (callid2->host == ((void *)0)))
    return -1;
  if (0 != strcmp (callid1->host, callid2->host))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 13
28 13
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 4
37 4
38 6
39 6
40 6
41 6
42 8
43 8
44 14
45 18
46 18
47 18
48 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbx
mov    0x38(%rsp),%rbp
cmpl   $0x0,0x30(%rsp)
jne    480 <set_real+0x2c>
mov    $0x0,%edi
mov    $0x0,%eax
callq  480 <set_real+0x2c>
mov    0x34(%rsp),%eax
cmp    $0x69,%eax
je     494 <set_real+0x40>
cmp    $0x72,%eax
jne    4a9 <set_real+0x55>
mov    %rbx,0x0(%rbp)
jmp    4b8 <set_real+0x64>
mov    %rbx,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  4a4 <set_real+0x50>
mov    %eax,0x0(%rbp)
jmp    4b8 <set_real+0x64>
mov    $0x0,%edi
mov    $0x0,%eax
callq  4b8 <set_real+0x64>
mov    %rbx,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_real(struct desc x, double val)
{
      if (!x.lval)
         fault("assignment to a real formal parameter called by name no"
            "t possible because final actual parameter is not a variabl"
            "e");
      switch (x.type)
      { case 'r':
            *x.u.real_ptr = val;
            break;
         case 'i':
            *x.u.int_ptr = real2int(val);
            break;
         default:
            fault("assignment to a real formal parameter called by name"
               " not possible because final actual parameter is not of "
               "arithmetic type");
      }
      return val;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 7
13 7
14 7
15 7
16 7
17 9
18 10
19 12
20 12
21 12
22 12
23 13
24 15
25 15
26 15
27 20
28 20
29 20
30 20
31 20
32 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
or     %edi,0x0(%rip)        # a <__gmp_exception+0xa>
mov    $0xa,%eax
cltd   
idivl  0x0(%rip)        # 16 <__gmp_exception+0x16>
mov    %eax,0x0(%rip)        # 1c <__gmp_exception+0x1c>
callq  21 <__gmp_sqrt_of_negative>
<<<sep_in_sample>>>
__gmp_exception (int error_bit)
{
  __gmp_errno |= error_bit;
  __gmp_junk = 10 / __gmp_0;
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %rdx,%r12
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdx
sub    $0x1,%rdx
je     7cd <mkfilename+0x59>
lea    -0x1(%rdx),%rax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
je     7c0 <mkfilename+0x4c>
jmp    7cd <mkfilename+0x59>
lea    -0x1(%rax),%rcx
cmpb   $0x2f,-0x1(%rbx,%rax,1)
jne    7ca <mkfilename+0x56>
mov    %rcx,%rax
test   %rax,%rax
jne    7b2 <mkfilename+0x3e>
mov    %rax,%rdx
jmp    7cd <mkfilename+0x59>
mov    %rax,%rdx
mov    $0xffffffffffffffff,%r15
mov    %r13,%rdi
mov    $0x0,%r14d
mov    %r15,%rcx
mov    %r14d,%eax
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %r12,%rdi
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
add    %rcx,%rsi
lea    (%rsi,%rdx,1),%rdi
callq  802 <mkfilename+0x8e>
mov    %rax,%rbp
mov    %rbx,%rsi
mov    %rax,%rdi
callq  810 <mkfilename+0x9c>
mov    %rbp,%rdi
mov    %r15,%rcx
mov    %r14d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbp,%rcx,1)
mov    %r13,%rsi
mov    %rbp,%rdi
callq  830 <mkfilename+0xbc>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  83b <mkfilename+0xc7>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
mkfilename (const char *dir, const char *name, const char *suf)
{
  size_t dirlen = strlen (dir);
  char *s;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  s = xmalloc (dirlen + 1 + strlen (name) + strlen (suf) + 1);
  strcpy (s, dir);
  strcat (s, "/");
  strcat (s, name);
  strcat (s, suf);
  return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 3
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 8
48 8
49 8
50 9
51 9
52 9
53 9
54 9
55 9
56 10
57 10
58 10
59 11
60 11
61 11
62 13
63 13
64 13
65 13
66 13
67 13
68 13
69 13
70 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,0x8(%rdi)
movsd  %xmm0,0x10(%rdi)
mov    (%rdi),%rax
lea    0x10(%rdi),%rdx
mov    0x18(%rdi),%rdi
callq  *0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_root_fdfsolver_set (gsl_root_fdfsolver * s, gsl_function_fdf * f, double root)
{
  s->fdf = f;
  s->root = root;
  return (s->type->set) (s->state, s->fdf, &(s->root));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
test   %rdi,%rdi
je     3f <osip_message_get_via+0x3f>
mov    %esi,%ebx
lea    0x160(%rdi),%r12
mov    %r12,%rdi
callq  24 <osip_message_get_via+0x24>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    44 <osip_message_get_via+0x44>
mov    %ebx,%esi
mov    %r12,%rdi
callq  37 <osip_message_get_via+0x37>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
jmp    44 <osip_message_get_via+0x44>
mov    $0xfffffffe,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_via (const osip_message_t * sip, int pos, osip_via_t ** dest)
{
  *dest = ((void *)0);
  if (sip == ((void *)0))
    return -2;
  if (osip_list_size (&sip->vias) <= pos)
    return -1;
  *dest = (osip_via_t *) osip_list_get (&sip->vias, pos);
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 4
9 6
10 6
11 6
12 7
13 6
14 6
15 8
16 8
17 8
18 8
19 9
20 9
21 5
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 15 <close_stdout+0xd>
callq  1a <close_stdout+0x12>
test   %eax,%eax
je     8b <close_stdout+0x83>
mov    $0x0,%edi
callq  28 <close_stdout+0x20>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # 32 <close_stdout+0x2a>
test   %rdi,%rdi
je     62 <close_stdout+0x5a>
callq  3c <close_stdout+0x34>
mov    %rax,%rbp
callq  44 <close_stdout+0x3c>
mov    %rbx,%r8
mov    %rbp,%rcx
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  60 <close_stdout+0x58>
jmp    80 <close_stdout+0x78>
callq  67 <close_stdout+0x5f>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  80 <close_stdout+0x78>
mov    0x0(%rip),%edi        # 86 <close_stdout+0x7e>
callq  8b <close_stdout+0x83>
mov    0x0(%rip),%rdi        # 92 <close_stdout+0x8a>
callq  97 <close_stdout+0x8f>
test   %eax,%eax
je     a6 <close_stdout+0x9e>
mov    0x0(%rip),%edi        # a1 <close_stdout+0x99>
callq  a6 <close_stdout+0x9e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
close_stdout (void)
{
  if (close_stream (stdout) != 0)
    {
      char const *write_error = gettext ("write error");
      if (file_name)
 error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
        write_error);
      else
 error (0, (*__errno_location ()), "%s", write_error);
      _exit (exit_failure);
    }
   if (close_stream (stderr) != 0)
     _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 11
33 11
34 13
35 13
36 13
37 13
38 14
39 14
40 15
41 15
42 15
43 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
mov    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %r13,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    -0x2(%rsi,%rdx,1),%rdx
test   %rbp,%rbp
je     6ba <maildir_mkfilename+0xa5>
mov    $0xffffffffffffffff,%r15
mov    %rbp,%rdi
mov    $0x0,%r14d
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x2(%rdx,%rcx,1),%rdi
callq  67d <maildir_mkfilename+0x68>
mov    %rax,%rbx
mov    %r13,%rcx
mov    %r12,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  698 <maildir_mkfilename+0x83>
mov    %rbx,%rdi
mov    %r15,%rcx
mov    %r14d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbx,%rcx,1)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  6b8 <maildir_mkfilename+0xa3>
jmp    6de <maildir_mkfilename+0xc9>
lea    0x2(%rdx),%rdi
callq  6c3 <maildir_mkfilename+0xae>
mov    %rax,%rbx
mov    %r13,%rcx
mov    %r12,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  6de <maildir_mkfilename+0xc9>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
maildir_mkfilename (const char *directory, const char *suffix, const char *name)
{
  size_t size = strlen (directory) + 1 + strlen (suffix) + 1;
  char *tmp;
  if (name)
    size += 1 + strlen (name);
  tmp = malloc (size);
  sprintf (tmp, "%s/%s", directory, suffix);
  if (name)
    {
      strcat (tmp, "/");
      strcat (tmp, name);
    }
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 5
24 5
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 8
35 8
36 8
37 8
38 8
39 8
40 11
41 11
42 11
43 11
44 11
45 11
46 12
47 12
48 12
49 12
50 3
51 7
52 7
53 8
54 8
55 8
56 8
57 8
58 8
59 15
60 15
61 15
62 15
63 15
64 15
65 15
66 15
67 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x18,%edi
callq  11b <grecs_list_append+0x16>
mov    %rbp,0x10(%rax)
mov    0x8(%rbx),%rsi
mov    $0x0,%ecx
mov    %rax,%rdx
mov    %rbx,%rdi
callq  133 <grecs_list_append+0x2e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_list_append(struct grecs_list *lp, void *val)
{
 struct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));
 ep->data = val;
 grecs_list_insert_entry(lp, lp->tail, ep, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
orl    $0x1,0x880(%rdi)
cmpl   $0x0,0x878(%rdi)
jle    a6 <press_m61a1+0x28>
sub    $0x8,%rsp
mov    $0x5,%esi
callq  9c <press_m61a1+0x1e>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
press_m61a1(craft * c)
{
 c->station[0].info3 |= 1;
 if (c->station[0].info > 0) {
  playContinuousSound(c, 5);
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 2
5 5
6 5
7 8
8 8
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x4,%esi
callq  2827 <gsl_block_uint_fread+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     284c <gsl_block_uint_fread+0x3d>
mov    $0x5,%ecx
mov    $0x1f,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  2847 <gsl_block_uint_fread+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_uint_fread (FILE * stream, gsl_block_uint * b)
{
  size_t n = b->size ;
  unsigned int * data = b->data ;
  size_t items = fread (data, 1 * sizeof (unsigned int), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
movl   $0x10,0xc(%rsp)
lea    0xc(%rsp),%rdx
lea    0x10(%rsp),%rsi
callq  2b <isnetconn+0x2b>
mov    $0x1,%edx
test   %eax,%eax
jns    5f <isnetconn+0x5f>
callq  39 <isnetconn+0x39>
mov    (%rax),%eax
cmp    $0x58,%eax
je     5a <isnetconn+0x5a>
cmp    $0x6b,%eax
je     5a <isnetconn+0x5a>
mov    $0x0,%edx
cmp    $0x16,%eax
je     5f <isnetconn+0x5f>
cmp    $0x9,%eax
setne  %dl
movzbl %dl,%edx
jmp    5f <isnetconn+0x5f>
mov    $0x0,%edx
mov    %edx,%eax
mov    0x28(%rsp),%rcx
xor    %fs:0x28,%rcx
je     76 <isnetconn+0x76>
callq  76 <isnetconn+0x76>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
isnetconn (fd)
     int fd;
{
  int rv;
  socklen_t l;
  struct sockaddr sa;
  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  return ((rv < 0 && ((*__errno_location ()) == 88 || (*__errno_location ()) == 107 || (*__errno_location ()) == 22 || (*__errno_location ()) == 9)) ? 0 : 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 8
7 8
8 8
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
mov    0x8(%rdi),%rdi
callq  *0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_rng_get (const gsl_rng * r)
{
  return (r->type->get) (r->state);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
movl   $0x0,(%rsi)
movq   $0x0,0x8(%rsi)
mov    %rdi,0x10(%rsi)
mov    %rsi,%rdi
callq  4f8 <hashtab_first+0x1a>
repz retq 
<<<sep_in_sample>>>
hashtab_first(struct hashtab *ht, struct hashtab_order *ho)
{
  ho->which = 0;
  ho->elem = ((void *)0);
  ho->ht = ht;
  return hashtab_next (ho);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 7
<<<sep_out_sample>>>
sub    $0x38,%rsp
divsd  0x0(%rip),%xmm0        # 10b31 <Fi+0xc>
movsd  0x0(%rip),%xmm4        # 10b39 <Fi+0x14>
movsd  %xmm4,0x8(%rsp)
movsd  0x0(%rip),%xmm1        # 10b47 <Fi+0x22>
movsd  %xmm0,(%rsp)
callq  10b51 <Fi+0x2c>
movsd  %xmm0,0x20(%rsp)
movsd  0x0(%rip),%xmm5        # 10b5f <Fi+0x3a>
movsd  %xmm5,0x10(%rsp)
movsd  0x0(%rip),%xmm1        # 10b6d <Fi+0x48>
movsd  (%rsp),%xmm0
callq  10b77 <Fi+0x52>
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm6        # 10b85 <Fi+0x60>
movsd  %xmm6,0x18(%rsp)
movsd  0x0(%rip),%xmm1        # 10b93 <Fi+0x6e>
movsd  (%rsp),%xmm0
callq  10b9d <Fi+0x78>
movsd  0x8(%rsp),%xmm2
mulsd  0x20(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
mulsd  0x28(%rsp),%xmm5
movapd %xmm5,%xmm1
addsd  %xmm2,%xmm1
mulsd  0x18(%rsp),%xmm0
addsd  %xmm1,%xmm0
movsd  (%rsp),%xmm3
movapd %xmm3,%xmm1
mulsd  %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 10bdc <Fi+0xb7>
addsd  %xmm1,%xmm0
movapd %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 10bec <Fi+0xc7>
addsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # 10bf8 <Fi+0xd3>
mulsd  0x0(%rip),%xmm0        # 10c00 <Fi+0xdb>
mulsd  0x0(%rip),%xmm0        # 10c08 <Fi+0xe3>
divsd  0x0(%rip),%xmm0        # 10c10 <Fi+0xeb>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
Fi(double t)
{
 double W=t/Q;
 return(f[1]*pow(W,5.)+f[2]*pow(W,4.)
  +f[3]*pow(W,3.)+f[4]*pow(W,2.)+f[5]*W+f[6])*Q*Q/MSTAR[0][1];
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 4
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 4
40 6
41 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
lea    0x1(%rdx),%rdi
callq  16 <alloc_string_len+0x16>
mov    %rax,%rdi
mov    %rax,0x0(%rbp)
mov    $0x1,%eax
test   %rdi,%rdi
je     3f <alloc_string_len+0x3f>
mov    %rbx,%rdx
mov    %r12,%rsi
callq  32 <alloc_string_len+0x32>
mov    0x0(%rbp),%rax
movb   $0x0,(%rax,%rbx,1)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
alloc_string_len(char **sptr, const char *start, size_t len)
{
    *sptr = malloc(len + 1);
    if (!*sptr)
 return 1;
    memcpy(*sptr, start, len);
    (*sptr)[len] = 0;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 4
13 4
14 6
15 6
16 6
17 7
18 7
19 8
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     aab <gsl_permute_vector+0x2c>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  aa4 <gsl_permute_vector+0x25>
mov    $0x13,%eax
jmp    ac1 <gsl_permute_vector+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  abc <gsl_permute_vector+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector (const gsl_permutation * p, gsl_vector * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %ecx,%r12d
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 957d <pw_hdy+0x27>
movl   $0x0,0x0(%rip)        # 9587 <pw_hdy+0x31>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  9593 <pw_hdy+0x3d>
mov    0x0(%rip),%r15        # 959a <pw_hdy+0x44>
mov    0x0(%rip),%rdi        # 95a1 <pw_hdy+0x4b>
callq  95a6 <pw_hdy+0x50>
mov    0x70(%rsp),%ecx
mov    %ecx,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
movl   $0x7,(%rsp)
mov    $0x9,%r9d
mov    $0x0,%r8d
mov    %r15,%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    (%rbx),%edi
callq  95df <pw_hdy+0x89>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
pw_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "PW";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected,
    gettext(hd_text[75].ht_text), ptr_cc_id, "+", 9,
    7, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 12
16 12
17 12
18 13
19 14
20 14
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
test   %rdi,%rdi
je     468 <mu_message_is_modified+0x39>
mov    0x10(%rdi),%rdi
callq  449 <mu_message_is_modified+0x1a>
mov    %eax,%r12d
mov    0x30(%rbx),%rdi
callq  455 <mu_message_is_modified+0x26>
mov    %eax,%ebp
mov    0x18(%rbx),%rdi
callq  460 <mu_message_is_modified+0x31>
or     %r12d,%ebp
or     0x20(%rbx),%ebp
or     %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_message_is_modified (mu_message_t msg)
{
  int mod = 0;
  if (msg)
    {
      mod |= mu_header_is_modified (msg->header);
      mod |= mu_attribute_is_modified (msg->attribute);
      mod |= mu_body_is_modified (msg->body);
      mod |= msg->flags;
    }
  return mod;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 6
9 6
10 6
11 7
12 7
13 7
14 8
15 8
16 7
17 8
18 9
19 12
20 12
21 12
22 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl %sil,%esi
callq  2a3 <cdio_get_track_pregap_lsn+0xd>
mov    %eax,%edi
callq  2aa <cdio_get_track_pregap_lsn+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cdio_get_track_pregap_lsn(const CdIo_t *p_cdio, track_t u_track)
{
  return cdio_lba_to_lsn(cdio_get_track_pregap_lba(p_cdio, u_track));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  29 <direntry_cmp_name+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     246 <compute_uint_variance+0x53>
shl    $0x2,%rsi
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 209 <compute_uint_variance+0x16>
mov    (%rdi),%ecx
cvtsi2sd %rcx,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fmul   %st(0),%st
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    236 <compute_uint_variance+0x43>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    209 <compute_uint_variance+0x16>
fstp   %st(0)
jmp    248 <compute_uint_variance+0x55>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
compute_uint_variance (const unsigned int data[], const size_t stride, const size_t n, const double mean)
{
  long double variance = 0 ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double delta = (data[i * stride] - mean);
      variance += (delta * delta - variance) / (i + 1);
    }
  return variance ;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 5
5 3
6 8
7 7
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 5
24 5
25 5
26 5
27 3
28 10
29 10
30 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%edi
jne    14 <_log_handler+0x14>
cmpl   $0x1,0x0(%rip)        # 10 <_log_handler+0x10>
ja     32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x2,%edi
jne    24 <_log_handler+0x24>
cmpl   $0x0,0x0(%rip)        # 20 <_log_handler+0x20>
jne    32 <_log_handler+0x32>
jmp    38 <_log_handler+0x38>
cmp    $0x3,%edi
jne    32 <_log_handler+0x32>
cmpl   $0x0,0x0(%rip)        # 30 <_log_handler+0x30>
jne    38 <_log_handler+0x38>
callq  *0x0(%rip)        # 38 <_log_handler+0x38>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_log_handler (cdio_log_level_t level, const char message[])
{
  if (level == CDIO_LOG_DEBUG && opts.debug_level < 2)
    return;
  if (level == CDIO_LOG_INFO && opts.debug_level < 1)
    return;
  if (level == CDIO_LOG_WARN && opts.silent)
    return;
  gl_default_cdio_log_handler (level, message);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 9
17 10
18 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%esi
mov    $0x0,%edi
callq  95d <dicod_inetd+0x10>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     9cc <dicod_inetd+0x7f>
movl   $0x80,0x0(%rip)        # 974 <dicod_inetd+0x27>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  988 <dicod_inetd+0x3b>
cmp    $0xffffffff,%eax
jne    997 <dicod_inetd+0x4a>
movl   $0x0,0x0(%rip)        # 997 <dicod_inetd+0x4a>
movl   $0x10,0x0(%rip)        # 9a1 <dicod_inetd+0x54>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
callq  9b5 <dicod_inetd+0x68>
cmp    $0xffffffff,%eax
jne    9c4 <dicod_inetd+0x77>
movl   $0x0,0x0(%rip)        # 9c4 <dicod_inetd+0x77>
mov    %rbx,%rdi
callq  9cc <dicod_inetd+0x7f>
pop    %rbx
retq   
<<<sep_in_sample>>>
dicod_inetd()
{
    dico_stream_t str = dicod_iostream(0, 1);
    if (!str)
 return 1;
    client_addrlen = sizeof(client_addr);
    if (getsockname (0, (struct sockaddr*)&client_addr, &client_addrlen) == -1)
 client_addrlen = 0;
    server_addrlen = sizeof(server_addr);
    if (getsockname (1, &server_addr, &server_addrlen) == -1)
 server_addrlen = 0;
    return dicod_loop(str);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 5
7 4
8 4
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 11
25 12
26 12
27 13
28 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    %esi,%r12d
mov    %rdx,%rbx
mov    %rdx,%rdi
mov    $0x0,%eax
callq  731 <scan2+0x19>
mov    (%rbx),%eax
cmp    %ebp,%eax
je     74b <scan2+0x33>
cmp    %r12d,%eax
je     74b <scan2+0x33>
mov    %r12d,%esi
mov    %ebp,%edi
mov    $0x0,%eax
callq  74b <scan2+0x33>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
scan2(expect1, expect2, tokp)
 tok_kind expect1;
 tok_kind expect2;
 token *tokp;
{
 get_token(tokp);
 if (tokp->kind != expect1 && tokp->kind != expect2) {
  expected2(expect1, expect2);
 }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
mov    (%rsi),%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
cmp    (%rdi),%r8
jne    291 <gsl_vector_complex_equal+0x2c>
test   %r8,%r8
je     2ea <gsl_vector_complex_equal+0x85>
shl    $0x4,%r10
mov    0x10(%rdi),%rdx
shl    $0x4,%r9
mov    0x10(%rsi),%rax
mov    $0x0,%edi
jmp    2d2 <gsl_vector_complex_equal+0x6d>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ae <gsl_vector_complex_equal+0x49>
mov    $0x0,%eax
jmp    2fd <gsl_vector_complex_equal+0x98>
movsd  0x8(%rcx),%xmm0
ucomisd 0x8(%rsi),%xmm0
jp     2f1 <gsl_vector_complex_equal+0x8c>
jne    2f1 <gsl_vector_complex_equal+0x8c>
add    $0x1,%rdi
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rdi
je     2f7 <gsl_vector_complex_equal+0x92>
mov    %rdx,%rcx
mov    %rax,%rsi
movsd  (%rdx),%xmm0
ucomisd (%rax),%xmm0
jp     2e4 <gsl_vector_complex_equal+0x7f>
je     2b5 <gsl_vector_complex_equal+0x50>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
nop
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_equal (const gsl_vector_complex * u, const gsl_vector_complex * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (u->data[2 * stride_u * j + k] != v->data[2 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 11
7 11
8 11
9 11
10 11
11 11
12 16
13 16
14 2
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 16
23 16
24 16
25 16
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 16
34 16
35 16
36 16
37 18
38 18
39 22
40 22
41 23
42 18
43 18
44 22
45 22
46 23
47 23
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 211 <min_ival+0x7>
mov    (%rdx),%rax
add    $0x8,%rdx
mov    %rdx,0x0(%rip)        # 21f <min_ival+0x15>
retq   
<<<sep_in_sample>>>
min_ival(void)
{
  long x;
  memmove (&x,mpointer,sizeof(long));
  mpointer += sizeof(long);
  return (x);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%r13
mov    (%rsi),%rdi
mov    $0xffffffff,%eax
test   %rdi,%rdi
je     77 <find_string_in_alist+0x77>
mov    %edx,%r14d
mov    %rsi,%rbp
mov    $0x0,%ebx
test   %r14d,%r14d
je     3f <find_string_in_alist+0x3f>
mov    $0x20,%edx
mov    %r12,%rsi
callq  38 <find_string_in_alist+0x38>
cmp    $0x1,%eax
je     5c <find_string_in_alist+0x5c>
jmp    57 <find_string_in_alist+0x57>
movzbl (%rdi),%eax
cmp    %al,(%r12)
jne    5c <find_string_in_alist+0x5c>
mov    %rdi,%rsi
mov    %r12,%rdi
callq  53 <find_string_in_alist+0x53>
test   %eax,%eax
jne    5c <find_string_in_alist+0x5c>
mov    0x8(%rbp),%eax
jmp    77 <find_string_in_alist+0x77>
add    $0x1,%ebx
movslq %ebx,%rbp
shl    $0x4,%rbp
add    %r13,%rbp
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
jne    26 <find_string_in_alist+0x26>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
find_string_in_alist (string, alist, flags)
     char *string;
     STRING_INT_ALIST *alist;
     int flags;
{
  register int i;
  int r;
  for (i = r = 0; alist[i].word; i++)
    {
      if (flags)
 r = strmatch (alist[i].word, string, (1 << 5)) != 1;
      else
 r = ((string)[0] == (alist[i].word)[0] && strcmp(string, alist[i].word) == 0);
      if (r)
 return (alist[i].token);
    }
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 8
9 17
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 11
18 11
19 11
20 14
21 14
22 14
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 15
32 15
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 17
41 18
42 18
43 18
44 18
45 18
46 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    91 <xnrealloc+0x20>
callq  91 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  9a <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
callq  957 <dicod_langlist_copy+0xe>
mov    %rax,%rbx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  96c <dicod_langlist_copy+0x23>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  97c <dicod_langlist_copy+0x33>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dicod_langlist_copy(dico_list_t src)
{
    dico_list_t dst = xdico_list_create();
    dico_list_set_free_item(dst, dicod_free_item, ((void *)0));
    dico_list_iterate(src, _dup_lang_item, dst);
    return dst;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r13d
mov    %ecx,%r12d
mov    %ecx,%r9d
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xb6,(%rax)
mov    $0x0,%r9d
mov    %r13d,%r8d
mov    %r12d,%ecx
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  22b7 <_rx>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_ldxr_uc(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r0, r1, r2);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = 0xb6;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 7
32 7
33 7
34 7
35 7
36 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x8,%edi
jne    31 <catchsig+0x31>
mov    $0x4a6,%esi
mov    $0x0,%edi
callq  18 <catchsig+0x18>
mov    $0x0,%edi
callq  22 <catchsig+0x22>
mov    %rax,%rdi
mov    $0x0,%eax
callq  2f <catchsig+0x2f>
jmp    7f <catchsig+0x7f>
cmp    $0x7,%edi
je     3b <catchsig+0x3b>
cmp    $0xb,%edi
jne    66 <catchsig+0x66>
mov    $0x4ac,%esi
mov    $0x0,%edi
callq  4a <catchsig+0x4a>
mov    $0x0,%edi
callq  54 <catchsig+0x54>
mov    %rax,%rdi
mov    $0x0,%eax
callq  61 <catchsig+0x61>
callq  66 <catchsig+0x66>
mov    $0x0,%edx
mov    $0x4b1,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  7f <catchsig+0x7f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
catchsig(int sig)
{
 if (sig == 8) {
  (*(set_loc("main.c", 1190), r_fatal))(gettext("floating point exception"));
 } else if (sig == 11
         || sig == 7
 ) {
  set_loc("main.c", 1196);
  msg(gettext("fatal error: internal error"));
  abort();
 } else
  r_fatal("internal error line %d, file: %s", 1201, "main.c");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 10
26 12
27 12
28 12
29 12
30 12
31 13
32 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  8ca <unlink_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unlink_error (char const *name)
{
  call_arg_error ("unlink", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rbx
mov    %rdx,%rsi
callq  24c5 <text_buffer_fill+0x14>
mov    (%r12),%rax
add    0x10(%r12),%rax
test   %rbx,%rbx
je     24ec <text_buffer_fill+0x3b>
mov    %rax,%rcx
add    $0x1,%rcx
mov    %bpl,-0x1(%rcx)
mov    %ecx,%r8d
sub    %eax,%r8d
movslq %r8d,%r8
cmp    %r8,%rbx
ja     24d6 <text_buffer_fill+0x25>
add    %rbx,0x10(%r12)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
text_buffer_fill (struct text_buffer *buf, int c, size_t len)
{
  char *p;
  int i;
  text_buffer_alloc (buf, len);
  for (i = 0, p = buf->base + buf->off; i < len; i++)
    *p++ = c;
  buf->off += len;
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 6
19 6
20 6
21 8
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r12
mov    %rdx,%r13
mov    %rcx,%r14
mov    %r8,%rbp
mov    %r9,%r15
mov    $0xa0,%edi
callq  c51 <ls_list+0x2c>
mov    %rax,%rbx
mov    0x70(%rsp),%eax
mov    %eax,0x10(%rsp)
mov    0x68(%rsp),%eax
mov    %eax,0x8(%rsp)
mov    0x60(%rsp),%rax
mov    %rax,(%rsp)
mov    %r15,%r9
mov    %rbx,%r8
mov    %r14,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
mov    0x18(%rsp),%rdi
callq  c86 <ls_list+0x61>
mov    %rbx,%rdi
callq  c8e <ls_list+0x69>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  ca3 <ls_list+0x7e>
mov    %rbp,%rdi
callq  cab <ls_list+0x86>
mov    %rbx,%rdi
callq  cb3 <ls_list+0x8e>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ls_list (char * name, char * ln_name, struct new_cpio_header * sbp,
 time_t now, FILE * fp, char * uname, char * gname, int type, int vflag)
{
 STROB * buf = strob_open(160);
        ls_list_to_string(name, ln_name, sbp, now, buf, uname, gname, type, vflag);
 fprintf(fp, "%s\n", strob_str(buf));
        (void) fflush (fp);
 strob_close(buf);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 7
38 7
39 8
40 8
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
sub    %rsi,%rdx
mov    %rdx,%rbp
mov    0x28(%rdi),%rax
sub    0x20(%rdi),%rax
cmp    %rax,%rdx
jbe    2e2 <accumulate_range+0x29>
lea    0x8(%rdi),%rdi
mov    %rdx,%rsi
callq  2e2 <accumulate_range+0x29>
mov    0x20(%rbx),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
callq  2f1 <accumulate_range+0x38>
add    %rbp,0x20(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
accumulate_range (struct divvy *divvy, char const *beg, char const *end)
{
  __extension__ ({ struct obstack *__o = (&divvy->space); size_t __len = (end - beg); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < __len) _obstack_newchunk (__o, __len); memcpy (__o->next_free, beg, __len); __o->next_free += __len; (void) 0; });
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 4
21 4
22 4
23 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     1ab <__osip_nist_free+0x48>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x5,%edx
mov    $0x49,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  190 <__osip_nist_free+0x2d>
mov    0x0(%rip),%rax        # 197 <__osip_nist_free+0x34>
test   %rax,%rax
je     1a3 <__osip_nist_free+0x40>
mov    %rbx,%rdi
callq  *%rax
jmp    1ab <__osip_nist_free+0x48>
mov    %rbx,%rdi
callq  1ab <__osip_nist_free+0x48>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
__osip_nist_free (osip_nist_t * nist)
{
  if (nist == ((void *)0))
    return 0;
  osip_trace ("nist.c", 73, TRACE_LEVEL5, ((void *)0), "free nist resource\n");
  { if (nist!=((void *)0)) { if (osip_free_func) osip_free_func(nist); else free(nist);} };
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # bee <getconfline+0x7>
jne    c03 <getconfline+0x1c>
sub    $0x8,%rsp
mov    $0x0,%edi
mov    $0x0,%eax
callq  c03 <getconfline+0x1c>
mov    0x0(%rip),%rax        # c0a <getconfline+0x23>
retq   
<<<sep_in_sample>>>
getconfline(void)
{
 if (!opened)
  die("configuration file not opened.");
 return confline;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 4
7 6
8 6
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
ucomisd 0x0(%rip),%xmm0        # c <__rsubepsilon+0xc>
jp     14 <__rsubepsilon+0x14>
je     c4 <__rsubepsilon+0xc4>
movsd  %xmm1,-0x8(%rsp)
mov    -0x8(%rsp),%rax
mov    %rax,%rdx
sar    $0x20,%rdx
mov    %edx,%ecx
and    $0x7ff00000,%ecx
cmp    $0x7ff00000,%ecx
je     c0 <__rsubepsilon+0xc0>
ucomisd 0x0(%rip),%xmm1        # 42 <__rsubepsilon+0x42>
jp     4e <__rsubepsilon+0x4e>
movsd  0x0(%rip),%xmm0        # 4c <__rsubepsilon+0x4c>
je     c4 <__rsubepsilon+0xc4>
ucomisd 0x0(%rip),%xmm1        # 56 <__rsubepsilon+0x56>
jp     5e <__rsubepsilon+0x5e>
xorpd  %xmm0,%xmm0
je     c4 <__rsubepsilon+0xc4>
test   %edx,%edx
jns    8c <__rsubepsilon+0x8c>
lea    0x1(%rax),%ecx
mov    %ecx,%edi
movabs $0xffffffff00000000,%rsi
and    %rax,%rsi
or     %rdi,%rsi
mov    %rsi,%rax
test   %ecx,%ecx
jne    b4 <__rsubepsilon+0xb4>
lea    0x1(%rdx),%eax
shl    $0x20,%rax
mov    %esi,%esi
or     %rsi,%rax
jmp    b4 <__rsubepsilon+0xb4>
mov    %eax,%esi
lea    -0x1(%rax),%edi
movabs $0xffffffff00000000,%rcx
and    %rax,%rcx
or     %rdi,%rcx
mov    %rcx,%rax
test   %esi,%esi
jne    b4 <__rsubepsilon+0xb4>
lea    -0x1(%rdx),%eax
shl    $0x20,%rax
mov    %ecx,%ecx
or     %rcx,%rax
mov    %rax,-0x8(%rsp)
movsd  -0x8(%rsp),%xmm0
retq   
movapd %xmm1,%xmm0
repz retq 
<<<sep_in_sample>>>
__rsubepsilon (double r)
{
  union
    {
      double d;
      struct
 {
   unsigned int i1;
   int i2;
 }
      dasii;
    }
  value;
  if (r == -((double)1.79769313486231570815e+308L))
    return (r);
  value.d = r;
  if ((value.dasii.i2 & (2047L<<20)) == (2047L<<20))
    return (r);
  if (r == 0.0)
    return (-((double)2.22507385850720138309e-308L));
  if (r == ((double)2.22507385850720138309e-308L))
    return (0.0);
  if (value.dasii.i2 & (1L<<31))
    {
      if ((++value.dasii.i1) == 0)
 value.dasii.i2++;
    }
  else if ((value.dasii.i1--) == 0)
    value.dasii.i2--;
  return (value.d);
}
<<<sep_in_sample>>>
1 2
2 14
3 14
4 14
5 16
6 16
7 17
8 17
9 17
10 17
11 17
12 17
13 19
14 19
15 20
16 19
17 21
18 21
19 22
20 21
21 23
22 23
23 25
24 25
25 25
26 25
27 25
28 25
29 25
30 25
31 26
32 26
33 26
34 26
35 26
36 28
37 28
38 28
39 28
40 28
41 28
42 28
43 28
44 29
45 29
46 29
47 29
48 30
49 30
50 30
51 18
52 31
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
sysev_filemask(struct dirwatcher *dp)
{
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    0x8(%rdi),%ebp
mov    $0x0,%ebx
test   %ebp,%ebp
je     55f <guess_level+0x41>
mov    %rsi,%rax
add    0x10(%rdi),%rax
movsbl (%rax),%edx
cmp    %edx,%ebp
jne    55f <guess_level+0x41>
test   %rax,%rax
je     55a <guess_level+0x3c>
add    $0x1,%rbx
lea    0x1(%rax),%rdi
mov    %ebp,%esi
callq  553 <guess_level+0x35>
test   %rax,%rax
jne    544 <guess_level+0x26>
jmp    55f <guess_level+0x41>
mov    $0x0,%ebx
mov    %ebx,0x4(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
guess_level (struct mu_list_response *resp, size_t prefix_len)
{
  size_t lev = 0;
  if (!resp->separator)
    lev = 0;
  else
    {
      char *p = resp->name + prefix_len;
      if (p[0] == resp->separator)
 for ( ; p; p = strchr (p + 1, resp->separator))
   lev++;
    }
  resp->level = lev;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 4
9 8
10 8
11 9
12 9
13 9
14 10
15 10
16 11
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 13
25 14
26 14
27 14
28 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  1192 <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rsi,%rsi
jle    28 <__gmpn_dump+0x28>
cmpq   $0x0,-0x8(%rdi,%rsi,8)
je     20 <__gmpn_dump+0x20>
jmp    28 <__gmpn_dump+0x28>
cmpq   $0x0,-0x8(%rbp,%rsi,8)
jne    39 <__gmpn_dump+0x39>
sub    $0x1,%rsi
jne    18 <__gmpn_dump+0x18>
jmp    2d <__gmpn_dump+0x2d>
test   %rsi,%rsi
jne    39 <__gmpn_dump+0x39>
mov    $0x0,%edi
callq  37 <__gmpn_dump+0x37>
jmp    82 <__gmpn_dump+0x82>
lea    -0x1(%rsi),%rbx
mov    0x0(%rbp,%rbx,8),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  51 <__gmpn_dump+0x51>
test   %rbx,%rbx
je     78 <__gmpn_dump+0x78>
sub    $0x1,%rbx
mov    0x0(%rbp,%rbx,8),%rdx
mov    $0x10,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  73 <__gmpn_dump+0x73>
test   %rbx,%rbx
jne    56 <__gmpn_dump+0x56>
mov    $0xa,%edi
callq  82 <__gmpn_dump+0x82>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmpn_dump (mp_srcptr ptr, mp_size_t n)
{
  do { while ((n) > 0) { if ((ptr)[(n) - 1] != 0) break; (n)--; } } while (0);
  if (n == 0)
    printf ("0\n");
  else
    {
      n--;
 printf ("%lX", (unsigned long) ptr[n]);
      while (n)
 {
   n--;
   printf ("%0*lX", (64 - 0) / 4, (unsigned long) ptr[n]);
 }
      printf ("\n");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 5
18 5
19 5
20 8
21 9
22 9
23 9
24 9
25 10
26 10
27 12
28 13
29 13
30 13
31 13
32 13
33 10
34 10
35 15
36 15
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0x8(%rdi),%xmm0
movsd  %xmm0,0x8(%rsi)
movsd  0x10(%rdi),%xmm0
movsd  %xmm0,0x10(%rsi)
retq   
<<<sep_in_sample>>>
DIStoACMWorld(dis_world_coordinates * in, VPoint * out)
{
 out->x = (in->x);
 out->y = (in->y);
 out->z = (in->z);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  64b <yy_scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     3f <gengetopt_strdup+0x3f>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  27 <gengetopt_strdup+0x27>
mov    %rax,%rbp
test   %rax,%rax
je     46 <gengetopt_strdup+0x46>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3a <gengetopt_strdup+0x3a>
mov    %rbp,%rax
jmp    46 <gengetopt_strdup+0x46>
mov    $0x0,%eax
jmp    46 <gengetopt_strdup+0x46>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gengetopt_strdup (const char *s)
{
  char *result = ((void *)0);
  if (!s)
    return result;
  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 9
17 9
18 9
19 10
20 10
21 5
22 5
23 11
24 11
25 11
26 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x0,%edx
test   %rdi,%rdi
je     d86 <check_username+0xf0>
callq  cb0 <check_username+0x1a>
mov    $0x1,%edx
test   %rax,%rax
jne    d86 <check_username+0xf0>
mov    %rbp,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
mov    %r12d,%ebx
sub    $0x1,%ebx
js     d07 <check_username+0x71>
callq  cde <check_username+0x48>
mov    (%rax),%rcx
mov    $0x0,%edx
movslq %ebx,%rax
movzbl 0x0(%rbp,%rax,1),%eax
movzwl (%rcx,%rax,2),%eax
and    $0x800,%ax
cmp    $0x1,%ax
sbb    $0xffffffff,%edx
sub    $0x1,%ebx
cmp    $0xffffffff,%ebx
jne    ce6 <check_username+0x50>
jmp    d0c <check_username+0x76>
mov    $0x0,%edx
cmp    %r12d,%edx
jne    d62 <check_username+0xcc>
mov    %rbp,%rdi
callq  d19 <check_username+0x83>
mov    %eax,%edi
callq  d20 <check_username+0x8a>
test   %rax,%rax
je     d3c <check_username+0xa6>
mov    $0x40,%edx
mov    (%rax),%rsi
mov    %rbp,%rdi
callq  d35 <check_username+0x9f>
mov    $0x1,%edx
jmp    d86 <check_username+0xf0>
mov    $0x0,%edi
callq  d46 <check_username+0xb0>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x1,%edi
mov    $0x0,%eax
callq  d5b <check_username+0xc5>
mov    $0x0,%edx
jmp    d86 <check_username+0xf0>
mov    $0x0,%edi
callq  d6c <check_username+0xd6>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x1,%edi
mov    $0x0,%eax
callq  d81 <check_username+0xeb>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
check_username (char *user)
{
  struct passwd *pwd;
  if (user == ((void *)0))
    return 0;
  pwd = getpwnam (user);
  if (pwd == 0)
    {
      int i = 0;
      int digits = 0;
      int len = strlen (user);
      for (i = len - 1; i >= 0; i--)
 {
   if (((*__ctype_b_loc ())[(int) (((u_char) user[i]))] & (unsigned short int) _ISdigit))
     digits++;
 }
      if (digits == len)
 {
   int uid = atoi (user);
   pwd = getpwuid (uid);
   if (pwd != 0)
     strncpy (user, (char *) pwd->pw_name, 64);
   else
     {
       info (1, gettext("Invalid user ID: %s"), user);
       return 0;
     }
 }
      else
 {
   info (1, gettext("Invalid user name: %s"), user);
   return 0;
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 6
9 35
10 7
11 7
12 11
13 11
14 11
15 11
16 11
17 12
18 12
19 12
20 14
21 14
22 10
23 14
24 14
25 14
26 14
27 15
28 15
29 12
30 12
31 12
32 12
33 10
34 17
35 17
36 19
37 19
38 20
39 20
40 21
41 21
42 22
43 22
44 22
45 22
46 35
47 35
48 25
49 25
50 25
51 25
52 25
53 25
54 25
55 26
56 26
57 31
58 31
59 31
60 31
61 31
62 31
63 31
64 32
65 36
66 36
67 36
68 36
69 36
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  365 <does_have_sw_selections+0x9>
test   %eax,%eax
setg   %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
does_have_sw_selections(VPLOB * swspecs)
{
 return
 vplob_get_nstore(swspecs) > 0 ? 1 : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%rbp
movsd  %xmm0,(%rdi)
mov    %rsi,%rdi
callq  82f <pict_maketick+0x20>
mov    %rax,0x8(%rbx)
mov    %rbp,0x10(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pict_maketick(tick *t, double num, char *label, double len)
{
  t->tick_num = num;
  t->tick_lab = pict_newstr(label);
  t->tick_len = len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  8ca <unlink_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unlink_error (char const *name)
{
  call_arg_error ("unlink", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
orq    $0x40,0x0(%rip)        # 42a <_rl_vi_callback_getchar+0x12>
callq  42f <_rl_vi_callback_getchar+0x17>
mov    %eax,%ebx
andq   $0xffffffffffffffbf,0x0(%rip)        # 439 <_rl_vi_callback_getchar+0x21>
test   %eax,%eax
js     464 <_rl_vi_callback_getchar+0x4c>
callq  442 <_rl_vi_callback_getchar+0x2a>
mov    %ebx,%ecx
cmp    $0x1,%rax
jbe    469 <_rl_vi_callback_getchar+0x51>
cmpl   $0x0,0x0(%rip)        # 451 <_rl_vi_callback_getchar+0x39>
jne    469 <_rl_vi_callback_getchar+0x51>
mov    %r12d,%edx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  460 <_rl_vi_callback_getchar+0x48>
mov    %eax,%ecx
jmp    469 <_rl_vi_callback_getchar+0x51>
mov    $0xffffffff,%ecx
mov    %ecx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_rl_vi_callback_getchar (mb, mlen)
     char *mb;
     int mlen;
{
  int c;
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  if (c < 0)
    return -1;
  if ((__ctype_get_mb_cur_max ()) > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mlen);
  return c;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 8
10 9
11 9
12 11
13 7
14 11
15 11
16 11
17 11
18 12
19 12
20 12
21 12
22 12
23 12
24 10
25 14
26 14
27 14
28 14
29 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  20f4 <swlib_pipe_pump+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swlib_pipe_pump(int ofd, int ifd)
{
 ;
 return
 swlib_pump_amount(ofd, ifd, -1);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %rcx,%r14
mov    %r8,%r15
mov    %r9,%rbx
callq  2cd <gsl_stats_float_ttest+0x25>
movsd  %xmm0,(%rsp)
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  2e0 <gsl_stats_float_ttest+0x38>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  2fd <gsl_stats_float_ttest+0x55>
test   %rbp,%rbp
js     309 <gsl_stats_float_ttest+0x61>
cvtsi2sd %rbp,%xmm3
jmp    321 <gsl_stats_float_ttest+0x79>
mov    %rbp,%rax
shr    %rax
mov    %rbp,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # 329 <gsl_stats_float_ttest+0x81>
divsd  %xmm3,%xmm2
test   %rbx,%rbx
js     339 <gsl_stats_float_ttest+0x91>
cvtsi2sd %rbx,%xmm3
jmp    351 <gsl_stats_float_ttest+0xa9>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm1        # 359 <gsl_stats_float_ttest+0xb1>
divsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    3de <gsl_stats_float_ttest+0x136>
test   %rbp,%rbp
js     37b <gsl_stats_float_ttest+0xd3>
cvtsi2sd %rbp,%xmm1
jmp    390 <gsl_stats_float_ttest+0xe8>
mov    %rbp,%rax
shr    %rax
and    $0x1,%ebp
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm2        # 398 <gsl_stats_float_ttest+0xf0>
divsd  %xmm1,%xmm2
test   %rbx,%rbx
js     3a8 <gsl_stats_float_ttest+0x100>
cvtsi2sd %rbx,%xmm1
jmp    3bd <gsl_stats_float_ttest+0x115>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 3c5 <gsl_stats_float_ttest+0x11d>
divsd  %xmm1,%xmm3
movapd %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
callq  3da <gsl_stats_float_ttest+0x132>
movapd %xmm0,%xmm1
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
divsd  %xmm1,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_float_ttest (const float data1[],
                           const size_t stride1, const size_t n1,
                           const float data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_float_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_float_mean (data2, stride2, n2);
  const double pv = gsl_stats_float_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 11
92 11
93 11
94 11
95 11
96 11
97 11
98 11
<<<sep_out_sample>>>
mov    (%rdi),%rax
shr    $0x3,%rax
not    %rax
retq   
<<<sep_in_sample>>>
member_file_hash_2 (void const *key)
{
  do { unsigned long result = 0; do { (result) += ~((unsigned long)((((unsigned long)(((struct member_file const *) key)->mf_link)) >> 3))); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
sub    0x8(%rsi),%edx
mov    %edx,%eax
test   %edx,%edx
jne    14c <dirfile_hash_cmp+0x2d>
mov    (%rdi),%rdi
mov    (%rsi),%rsi
cmp    %rsi,%rdi
je     142 <dirfile_hash_cmp+0x23>
sub    $0x8,%rsp
callq  140 <dirfile_hash_cmp+0x21>
jmp    148 <dirfile_hash_cmp+0x29>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dirfile_hash_cmp (const void *xv, const void *yv)
{
  const struct dirfile *x = xv;
  const struct dirfile *y = yv;
  int result = x->length - y->length;
  if (result)
    return result;
  do { return ((x->name)) == ((y->name)) ? 0 : strcmp (((x->name)), ((y->name))); } while (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 6
5 6
6 8
7 8
8 8
9 8
10 2
11 8
12 8
13 8
14 8
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  cee <gsl_sf_bessel_i1_scaled+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     d14 <gsl_sf_bessel_i1_scaled+0x32>
mov    %eax,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d0d <gsl_sf_bessel_i1_scaled+0x2b>
movsd  (%rsp),%xmm0
jmp    d14 <gsl_sf_bessel_i1_scaled+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_i1_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_i1_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_i1_scaled_e(x, &result)", "bessel_i.c", 317, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    (%rsi,%rax,1),%rdx
or     %rdx,(%rdi,%rax,1)
add    $0x8,%rax
cmp    $0x20,%rax
jne    1a <bitset_merge+0x5>
retq   
<<<sep_in_sample>>>
bitset_merge (bitset_t dest, const bitset_t src)
{
  int bitset_i;
  for (bitset_i = 0; bitset_i < (256 / (sizeof (bitset_word_t) * 8)); ++bitset_i)
    dest[bitset_i] |= src[bitset_i];
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 4
6 4
7 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  c76 <fwriteerror_temp+0x12>
mov    %eax,%r13d
mov    %rbx,%rdi
callq  c81 <fwriteerror_temp+0x1d>
mov    %eax,%ebp
callq  c88 <fwriteerror_temp+0x24>
mov    %rax,%rbx
mov    (%rax),%r12d
mov    %r13d,%edi
callq  3d9 <unregister_fd>
mov    %r12d,(%rbx)
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fwriteerror_temp (FILE *fp)
{
  int fd = fileno (fp);
  int result = fwriteerror (fp);
  int saved_errno = (*__errno_location ());
  unregister_fd (fd);
  (*__errno_location ()) = saved_errno;
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 7
18 9
19 9
20 9
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x36,%edi
ja     10c <c_isxdigit+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case 'a' + (0): case 'b' + (0): case 'c' + (0): case 'd' + (0): case 'e' + (0): case 'f' + (0): case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 9
9 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2cc8 <env_getvalue+0x9>
test   %rax,%rax
je     2cd3 <env_getvalue+0x14>
mov    0x18(%rax),%rax
jmp    2cd8 <env_getvalue+0x19>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
env_getvalue (const char *var)
{
  register struct env_lst *ep = env_find (var);
  if (ep)
    return (ep->value);
  return (((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r14
callq  1e1 <equivalent+0x13>
mov    $0x1,%edx
test   %eax,%eax
je     246 <equivalent+0x78>
cmpb   $0x0,0x0(%r13)
je     233 <equivalent+0x65>
mov    %r13,%rdi
jmp    211 <equivalent+0x43>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  201 <equivalent+0x33>
cmpb   $0x2f,0x1(%rbx)
je     1f6 <equivalent+0x28>
lea    0x1(%rbx),%rdi
cmpb   $0x0,0x1(%rbx)
je     233 <equivalent+0x65>
mov    $0x2f,%esi
callq  21b <equivalent+0x4d>
mov    %rax,%rbx
test   %rax,%rax
je     233 <equivalent+0x65>
cmpb   $0x2f,0x1(%rax)
jne    207 <equivalent+0x39>
lea    0x2(%rax),%r12
lea    0x1(%rax),%rbp
jmp    1f6 <equivalent+0x28>
mov    %r14,%rsi
mov    %r13,%rdi
callq  23e <equivalent+0x70>
test   %eax,%eax
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
equivalent(char *lname, const char *rname)
{
    char *s;
    if (!strcmp(lname, rname))
        return 1;
    for (s = lname; *s && (s = strchr(s, '/')); s++) {
        while (s[1] == '/')
            strcpy(s+1, s+2);
    }
    return !strcmp(lname, rname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 4
11 4
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 7
20 7
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 7
30 7
31 8
32 8
33 8
34 10
35 10
36 10
37 10
38 10
39 10
40 11
41 11
42 11
43 11
44 11
45 11
46 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
mov    %rsi,%rbp
mov    %rdx,%rbx
test   %rdx,%rdx
jne    29a <taru_safewrite+0x1e>
jmp    2ba <taru_safewrite+0x3e>
cltq   
add    %rax,%rbp
sub    %rax,%rbx
je     2b2 <taru_safewrite+0x36>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12d,%edi
callq  2a8 <taru_safewrite+0x2c>
mov    %eax,%edx
cmp    %ebx,%eax
jge    2b2 <taru_safewrite+0x36>
test   %eax,%eax
jg     290 <taru_safewrite+0x14>
mov    %ebx,%eax
neg    %eax
test   %edx,%edx
js     2bc <taru_safewrite+0x40>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
taru_safewrite(int fd, void *vbuf, size_t amount)
{
 int rc = 0;
 char *buf = vbuf;
 while (amount &&
  ((rc = uxfio_write(fd, buf, amount)) < (int)amount) &&
       rc > 0) {
  buf += rc;
  amount -= rc;
 }
 if (rc < 0) return -((int)(amount));
 return (int)amount;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 8
11 8
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 6
22 6
23 11
24 11
25 11
26 11
27 12
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     3b1 <gsl_matrix_complex_long_double_free+0x20>
cmpl   $0x0,0x28(%rdi)
je     3a9 <gsl_matrix_complex_long_double_free+0x18>
mov    0x20(%rdi),%rdi
callq  3a9 <gsl_matrix_complex_long_double_free+0x18>
mov    %rbx,%rdi
callq  3b1 <gsl_matrix_complex_long_double_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_free (gsl_matrix_complex_long_double * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_complex_long_double_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0xc0800000,%esi
callq  d574 <_sse_bungei_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c657 <_sse_movi_d>
mov    0x0(%r12),%ecx
and    $0x7fff,%ecx
mov    %r14d,%edx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  12eb <_sse_bunger_d>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d5c6 <_sse_bungei_d+0x76>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_sse_bungei_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bunger_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x6,%edi
callq  11 <mu_set_locale+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_set_locale (const char *locale)
{
  return setlocale (6, locale);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x8(%rsi),%rax
cmp    %rax,%rdx
jb     14 <direntry_cmp_inode+0x14>
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%rbp
mov    0x8(%rsi),%r12
test   %rbp,%rbp
je     e4 <gsl_permutation_fprintf+0x62>
mov    %rdi,%r13
mov    %rdx,%r14
mov    $0x0,%ebx
mov    (%r12,%rbx,8),%rdx
mov    %r14,%rsi
mov    %r13,%rdi
mov    $0x0,%eax
callq  b5 <gsl_permutation_fprintf+0x33>
test   %eax,%eax
jns    d9 <gsl_permutation_fprintf+0x57>
mov    $0x5,%ecx
mov    $0x4c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d2 <gsl_permutation_fprintf+0x50>
mov    $0x5,%eax
jmp    f0 <gsl_permutation_fprintf+0x6e>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    a1 <gsl_permutation_fprintf+0x1f>
jmp    eb <gsl_permutation_fprintf+0x69>
mov    $0x0,%eax
jmp    f0 <gsl_permutation_fprintf+0x6e>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_permutation_fprintf (FILE * stream, const gsl_permutation * p, const char *format)
{
  size_t n = p->size ;
  size_t * data = p->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      int status = fprintf (stream, format, data[i]);
      if (status < 0)
        {
          do { gsl_error ("fprintf failed", "file.c", 76, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 6
28 6
29 6
30 6
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x410,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x408(%rsp)
xor    %eax,%eax
movabs $0x203a78696e756d76,%rax
mov    %rax,(%rsp)
movb   $0x0,0x8(%rsp)
mov    %rsp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rsp,%rcx,1),%r12
movzbl (%rbx),%eax
test   %al,%al
je     1947 <printsys+0x116>
lea    0x400(%rsp),%rbp
mov    $0x7,%ecx
mov    $0x2,%edi
cmp    $0x3c,%al
jne    18e9 <printsys+0xb8>
callq  18a4 <printsys+0x73>
mov    (%rax),%rcx
mov    $0x0,%edi
jmp    18b8 <printsys+0x87>
lea    (%rdi,%rdi,4),%edx
movsbl %al,%eax
lea    -0x30(%rax,%rdx,2),%edi
add    $0x1,%rbx
movzbl (%rbx),%eax
movsbq %al,%rdx
testb  $0x8,0x1(%rcx,%rdx,2)
jne    18ae <printsys+0x7d>
cmp    $0x3e,%al
sete   %al
movzbl %al,%eax
add    %rax,%rbx
mov    %edi,%eax
and    $0xfffffc00,%eax
mov    $0x6,%ecx
mov    $0x2,%eax
cmovne %eax,%edi
movzbl (%rbx),%eax
test   %al,%al
je     191d <printsys+0xec>
add    $0x1,%rbx
cmp    $0xa,%al
je     1922 <printsys+0xf1>
cmp    %rbp,%r12
jae    1927 <printsys+0xf6>
mov    %r12,%rdx
add    $0x1,%rdx
mov    %al,-0x1(%rdx)
movzbl (%rbx),%eax
test   %al,%al
je     192a <printsys+0xf9>
add    $0x1,%rbx
cmp    $0xa,%al
je     192a <printsys+0xf9>
cmp    %rbp,%rdx
jne    1900 <printsys+0xcf>
jmp    192a <printsys+0xf9>
mov    %r12,%rdx
jmp    192a <printsys+0xf9>
mov    %r12,%rdx
jmp    192a <printsys+0xf9>
mov    %r12,%rdx
movb   $0x0,(%rdx)
mov    0x0(%rip),%rdx        # 1934 <printsys+0x103>
mov    %rsp,%rsi
callq  193c <printsys+0x10b>
movzbl (%rbx),%eax
test   %al,%al
jne    1891 <printsys+0x60>
mov    0x408(%rsp),%rax
xor    %fs:0x28,%rax
je     195f <printsys+0x12e>
callq  195f <printsys+0x12e>
add    $0x410,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
printsys (const char *msg)
{
  int c, pri, flags;
  char *lp, *q, line[1024 + 1];
  const char *p;
  strcpy (line, "vmunix: ");
  lp = line + strlen (line);
  for (p = msg; *p != '\0';)
    {
      flags = 0x002 | 0x004;
      pri = ((0<<3)|2);
      if (*p == '<')
 {
   pri = 0;
   while (((*__ctype_b_loc ())[(int) ((*++p))] & (unsigned short int) _ISdigit))
     pri = 10 * pri + (*p - '0');
   if (*p == '>')
     ++p;
 }
      else
 {
   flags |= 0x001;
 }
      if (pri & ~(0x03f8 | 0x07))
 pri = ((0<<3)|2);
      q = lp;
      while (*p != '\0' && (c = *p++) != '\n' && q < &line[1024])
 *q++ = c;
      *q = '\0';
      logmsg (pri, line, LocalHostName, flags);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 8
21 27
22 22
23 11
24 12
25 12
26 15
27 15
28 15
29 15
30 16
31 16
32 16
33 15
34 15
35 15
36 15
37 15
38 18
39 18
40 18
41 18
42 24
43 24
44 24
45 24
46 24
47 27
48 27
49 27
50 27
51 27
52 27
53 27
54 27
55 26
56 28
57 28
58 27
59 27
60 27
61 27
62 27
63 27
64 27
65 27
66 27
67 26
68 26
69 26
70 26
71 26
72 29
73 30
74 30
75 30
76 8
77 8
78 8
79 32
80 32
81 32
82 32
83 32
84 32
85 32
86 32
87 32
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <cmp_markup_name+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cmp_markup_name(const void *item, void *data)
{
    return strcasecmp((char*)item, (char*)data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     200 <osip_list_get+0x29>
test   %esi,%esi
js     206 <osip_list_get+0x2f>
cmp    (%rdi),%esi
jge    20c <osip_list_get+0x35>
mov    0x8(%rdi),%rdx
test   %esi,%esi
jle    1fb <osip_list_get+0x24>
mov    $0x0,%eax
add    $0x1,%eax
mov    (%rdx),%rdx
cmp    %esi,%eax
jne    1f1 <osip_list_get+0x1a>
mov    0x8(%rdx),%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_list_get (const osip_list_t * li, int pos)
{
  __node_t *ntmp;
  int i = 0;
  if (li == ((void *)0))
    return ((void *)0);
  if (pos < 0 || pos >= li->nb_elt)
    return ((void *)0);
  ntmp = li->node;
  while (pos > i) {
    i++;
    ntmp = ntmp->next;
  }
  return ntmp->element;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 7
5 7
6 7
7 9
8 10
9 10
10 4
11 11
12 12
13 10
14 10
15 14
16 14
17 6
18 6
19 8
20 8
21 8
22 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x240(%rdi),%rax
movq   $0x0,(%rax)
movl   $0x0,0x20(%rax)
movl   $0x0,0x24(%rax)
movl   $0x1,0x28(%rax)
mov    (%rdi),%rax
callq  *0x20(%rax)
mov    0x248(%rbx),%rax
mov    %rbx,%rdi
callq  *(%rax)
movq   $0x0,0xc0(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
reset_input_controller (j_decompress_ptr cinfo)
{
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
  inputctl->pub.consume_input = consume_markers;
  inputctl->pub.has_multiple_scans = 0;
  inputctl->pub.eoi_reached = 0;
  inputctl->inheaders = 1;
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->marker->reset_marker_reader) (cinfo);
  cinfo->coef_bits = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 8
10 9
11 9
12 9
13 10
14 11
15 11
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 6576 <info_initialize_numeric_arg+0x7>
jne    6583 <info_initialize_numeric_arg+0x14>
movl   $0x0,0x0(%rip)        # 6582 <info_initialize_numeric_arg+0x13>
retq   
movl   $0x0,0x0(%rip)        # 658d <info_initialize_numeric_arg+0x1e>
retq   
<<<sep_in_sample>>>
info_initialize_numeric_arg (void)
{
  if (!echo_area_is_active)
    {
      info_explicit_arg = 0;
    }
  else
    {
      ea_explicit_arg = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 9
6 9
<<<sep_out_sample>>>
movb   $0xff,0x0(%rip)        # c2b <slc_start_reply+0x7>
movb   $0xfa,0x0(%rip)        # c32 <slc_start_reply+0xe>
movb   $0x22,0x0(%rip)        # c39 <slc_start_reply+0x15>
movq   $0x0,0x0(%rip)        # c44 <slc_start_reply+0x20>
movb   $0x3,0x0(%rip)        # c4b <slc_start_reply+0x27>
retq   
<<<sep_in_sample>>>
slc_start_reply (void)
{
  slc_replyp = slc_reply;
  *slc_replyp++ = 255;
  *slc_replyp++ = 250;
  *slc_replyp++ = 34;
  *slc_replyp++ = 3;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 7
6 7
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
retq   
<<<sep_in_sample>>>
swicol_get_blocksize(SWICOL * swicol)
{
 return swicol->blocksizeM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0x0,%eax
mov    $0x61,%edx
mov    %eax,%esi
mov    %dl,0x0(%rax)
movzbl (%rcx),%edx
add    $0x1,%rax
add    $0x10,%rcx
test   %dl,%dl
jne    36b <initialize_flags+0xf>
lea    0x2(%rsi),%eax
cltq   
movb   $0x6f,0x0(%rax)
lea    0x3(%rsi),%eax
cltq   
movb   $0x3b,0x0(%rax)
add    $0x4,%esi
movslq %esi,%rsi
movb   $0x0,0x0(%rsi)
retq   
<<<sep_in_sample>>>
initialize_flags ()
{
  register int i;
  for (i = 0; shell_flags[i].name; i++)
    optflags[i+1] = shell_flags[i].name;
  optflags[++i] = 'o';
  optflags[++i] = ';';
  optflags[i+1] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
mov    (%rdi),%eax
test   %r10,%r10
je     1a2e <gsl_matrix_int_min+0x56>
push   %rbx
shl    $0x2,%r11
lea    0x0(,%r9,4),%rbx
mov    $0x0,%r8d
jmp    1a1f <gsl_matrix_int_min+0x47>
mov    (%rdx),%ecx
cmp    %ecx,%eax
cmovg  %ecx,%eax
add    $0x4,%rdx
cmp    %rsi,%rdx
jne    1a03 <gsl_matrix_int_min+0x2b>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
je     1a2d <gsl_matrix_int_min+0x55>
test   %r9,%r9
je     1a13 <gsl_matrix_int_min+0x3b>
lea    (%rdi,%rbx,1),%rsi
mov    %rdi,%rdx
jmp    1a03 <gsl_matrix_int_min+0x2b>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
gsl_matrix_int_min (const gsl_matrix_int * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  int min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          int x = m->data[i * tda + j];
          if (x < min)
            min = x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 8
7 8
8 2
9 2
10 2
11 8
12 8
13 12
14 12
15 12
16 12
17 10
18 10
19 8
20 8
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 18
29 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 3b4f <il_hdy+0x27>
cmpl   $0x0,0x0(%rip)        # 3b56 <il_hdy+0x2e>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 3b62 <il_hdy+0x3a>
movq   $0x0,(%rsp)
mov    0x70(%rsp),%r9d
mov    %r14d,%r8d
mov    %r13,%rcx
mov    %ebx,%edx
callq  3b7c <il_hdy+0x54>
cmpl   $0x0,0x0(%rip)        # 3b83 <il_hdy+0x5b>
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 3b8f <il_hdy+0x67>
cmp    $0x7cf,%ebx
jle    3be4 <il_hdy+0xbc>
mov    0x0(%rip),%r15        # 3b9e <il_hdy+0x76>
mov    0x0(%rip),%rdi        # 3ba5 <il_hdy+0x7d>
callq  3baa <il_hdy+0x82>
mov    0x70(%rsp),%edx
mov    %edx,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0x5,(%rsp)
mov    $0x9,%r9d
mov    $0x0,%r8d
mov    %r15,%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  3be4 <il_hdy+0xbc>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
il_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "IL";
  use_other_cc = !use_other_cc;
  hebrew_hdy (init_data, detected, year, hd_elems, fday, count, ptr_cc_id);
  use_other_cc = !use_other_cc;
  if (year > 1999)
    holiday (*init_data, detected, gettext(hd_text[277].ht_text),
      ptr_cc_id, "-", 9, 5, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 11
16 11
17 11
18 12
19 12
20 12
21 12
22 12
23 12
24 13
25 13
26 13
27 13
28 14
29 14
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 17
47 17
48 17
49 17
50 17
51 17
52 17
53 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x88,%rsp
mov    %rdi,%rbx
mov    %esi,0xc(%rsp)
mov    %edx,%ebp
movq   $0x0,0x28(%rsp)
movq   $0x0,0x30(%rsp)
movq   $0x0,0x38(%rsp)
movq   $0x0,0x40(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x60(%rsp)
movq   $0x0,0x68(%rsp)
movq   $0x0,0x70(%rsp)
movl   $0x0,0x1c(%rsp)
lea    0xc(%rsp),%rax
mov    %rax,0x20(%rsp)
movl   $0x4,0x28(%rsp)
lea    0x1c(%rsp),%rax
mov    %rax,0x50(%rsp)
movl   $0x4,0x5c(%rsp)
movl   $0x10,0x68(%rsp)
mov    $0x0,%r8d
lea    0x50(%rsp),%rcx
lea    0x20(%rsp),%rdx
mov    $0x0,%esi
callq  *0x118(%rbx)
mov    %eax,%ecx
test   %eax,%eax
jne    bc <__db_vrfy_pgset_iinc+0xbc>
mov    0x50(%rsp),%rax
mov    (%rax),%eax
mov    %eax,0x1c(%rsp)
jmp    c4 <__db_vrfy_pgset_iinc+0xc4>
cmp    $0xffff86f1,%ecx
jne    ee <__db_vrfy_pgset_iinc+0xee>
movl   $0x4,0x58(%rsp)
add    %ebp,0x1c(%rsp)
mov    $0x0,%r8d
lea    0x50(%rsp),%rcx
lea    0x20(%rsp),%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x148(%rbx)
add    $0x88,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__db_vrfy_pgset_iinc(dbp, pgno, i)
 DB *dbp;
 db_pgno_t pgno;
 int i;
{
 DBT key, data;
 int ret;
 int val;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 val = 0;
 key.data = &pgno;
 key.size = sizeof(db_pgno_t);
 data.data = &val;
 data.ulen = sizeof(int);
 (&data)->flags |= (0x010);
 if ((ret = dbp->get(dbp, ((void *)0), &key, &data, 0)) == 0) {
  ((void)0);
  memcpy(&val, data.data, sizeof(int));
 } else if (ret != (-30991))
  return (ret);
 data.size = sizeof(int);
 val += i;
 return (dbp->put(dbp, ((void *)0), &key, &data, 0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 9
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 11
16 12
17 12
18 13
19 14
20 14
21 15
22 16
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 19
32 19
33 19
34 19
35 20
36 20
37 22
38 23
39 24
40 24
41 24
42 24
43 24
44 24
45 25
46 25
47 25
48 25
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     259 <mu_diag_output+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  28a <mu_diag_output+0x87>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mu_diag_output (mu_log_level_t level, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  mu_diag_voutput (level, fmt, ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 4
18 4
19 4
20 4
21 4
22 5
23 5
24 7
25 7
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
textdomain(char * a) {
}
<<<sep_in_sample>>>
1 1
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%r14
mov    0x60(%rdi),%rax
lea    (%rsi,%rax,1),%rdx
mov    %rdx,0x60(%rdi)
and    $0x1f,%eax
je     135d <nettle_gosthash94_update+0x5a>
mov    $0x20,%ebx
sub    %eax,%ebx
mov    %eax,%eax
lea    0x40(%rdi,%rax,1),%rdi
cmp    %rsi,%rbx
mov    %rsi,%rdx
cmovbe %rbx,%rdx
mov    %r14,%rsi
callq  1345 <nettle_gosthash94_update+0x42>
cmp    %rbx,%r13
jb     13a8 <nettle_gosthash94_update+0xa5>
lea    0x40(%r12),%rsi
mov    %r12,%rdi
callq  121e <gost_compute_sum_and_hash>
add    %rbx,%r14
sub    %rbx,%r13
cmp    $0x1f,%r13
jbe    1393 <nettle_gosthash94_update+0x90>
mov    %r14,%rbp
mov    %r13,%rbx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  121e <gost_compute_sum_and_hash>
add    $0x20,%rbp
sub    $0x20,%rbx
cmp    $0x1f,%rbx
ja     1369 <nettle_gosthash94_update+0x66>
lea    -0x20(%r13),%rax
and    $0xffffffffffffffe0,%rax
lea    0x20(%r14,%rax,1),%r14
and    $0x1f,%r13d
test   %r13,%r13
je     13a8 <nettle_gosthash94_update+0xa5>
lea    0x40(%r12),%rdi
mov    %r13,%rdx
mov    %r14,%rsi
callq  13a8 <nettle_gosthash94_update+0xa5>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
nettle_gosthash94_update (struct gosthash94_ctx *ctx,
     size_t length, const uint8_t *msg)
{
    unsigned index = (unsigned) ctx->length & 31;
    ctx->length += length;
    if (index)
      {
          unsigned left = 32 - index;
          memcpy (ctx->message + index, msg, (length < left ? length : left));
          if (length < left)
              return;
          gost_compute_sum_and_hash (ctx, ctx->message);
          msg += left;
          length -= left;
      }
    while (length >= 32)
      {
          gost_compute_sum_and_hash (ctx, msg);
          msg += 32;
          length -= 32;
      }
    if (length)
      {
          memcpy (ctx->message, msg, length);
      }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 6
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 12
26 12
27 12
28 13
29 14
30 16
31 16
32 16
33 16
34 18
35 18
36 18
37 19
38 20
39 16
40 16
41 16
42 16
43 16
44 16
45 22
46 22
47 24
48 24
49 24
50 24
51 26
52 26
53 26
54 26
55 26
56 26
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
cmp    $0x7f,%rdi
jbe    26 <_gss_asn1_length_der+0x26>
mov    $0x0,%ecx
test   %rdi,%rdi
jne    37 <_gss_asn1_length_der+0x37>
jmp    49 <_gss_asn1_length_der+0x49>
test   %rsi,%rsi
je     2e <_gss_asn1_length_der+0x2e>
mov    %dil,(%rsi)
movq   $0x1,(%rdx)
jmp    80 <_gss_asn1_length_der+0x80>
add    $0x1,%rcx
mov    %dil,-0x1(%rsp,%rcx,1)
shr    $0x8,%rdi
test   %rdi,%rdi
jne    37 <_gss_asn1_length_der+0x37>
lea    0x1(%rcx),%rax
mov    %rax,(%rdx)
test   %rsi,%rsi
je     80 <_gss_asn1_length_der+0x80>
mov    %ecx,%eax
or     $0xffffff80,%eax
mov    %al,(%rsi)
lea    -0x1(%rcx),%rax
test   %rcx,%rcx
je     80 <_gss_asn1_length_der+0x80>
mov    %rax,%rcx
not    %rcx
add    (%rdx),%rcx
movzbl (%rsp,%rax,1),%edi
mov    %dil,(%rsi,%rcx,1)
sub    $0x1,%rax
cmp    $0xffffffffffffffff,%rax
jne    65 <_gss_asn1_length_der+0x65>
mov    0x8(%rsp),%rax
xor    %fs:0x28,%rax
je     95 <_gss_asn1_length_der+0x95>
callq  95 <_gss_asn1_length_der+0x95>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
_gss_asn1_length_der (size_t len, unsigned char *ans, size_t * ans_len)
{
  size_t k;
  unsigned char temp[sizeof (len)];
  if (len < 128)
    {
      if (ans != ((void *)0))
 ans[0] = (unsigned char) len;
      *ans_len = 1;
    }
  else
    {
      k = 0;
      while (len)
 {
   temp[k++] = len & 0xFF;
   len = len >> 8;
 }
      *ans_len = k + 1;
      if (ans != ((void *)0))
 {
   ans[0] = ((unsigned char) k & 0x7F) + 128;
   while (k--)
     ans[*ans_len - 1 - k] = temp[k];
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 14
8 14
9 14
10 14
11 7
12 7
13 8
14 9
15 9
16 16
17 16
18 17
19 14
20 14
21 19
22 19
23 20
24 20
25 22
26 22
27 22
28 23
29 23
30 23
31 24
32 24
33 24
34 24
35 24
36 23
37 23
38 23
39 27
40 27
41 27
42 27
43 27
44 27
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%esi
mov    $0x1,%edi
callq  11f <daemonize+0x10>
mov    $0x0,%esi
mov    $0x0,%edi
callq  12e <daemonize+0x1f>
cmp    $0xffffffff,%eax
jne    159 <daemonize+0x4a>
mov    $0x0,%edi
callq  13d <daemonize+0x2e>
mov    %rax,%rbx
callq  145 <daemonize+0x36>
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  159 <daemonize+0x4a>
mov    0x0(%rip),%rax        # 160 <daemonize+0x51>
and    $0xffffffffffffffdf,%rax
or     $0x40,%rax
mov    %rax,0x0(%rip)        # 16f <daemonize+0x60>
mov    0x0(%rip),%edx        # 175 <daemonize+0x66>
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 181 <daemonize+0x72>
callq  186 <daemonize+0x77>
mov    $0x0,%edi
callq  190 <daemonize+0x81>
mov    $0x0,%edx
mov    %rax,%rsi
mov    $0x1,%edi
mov    $0x0,%eax
callq  1a7 <daemonize+0x98>
callq  1ac <daemonize+0x9d>
pop    %rbx
retq   
<<<sep_in_sample>>>
daemonize (void)
{
  signal (1, ((__sighandler_t) 1));
  if (daemon (0, 0) == -1)
    anubis_error (1, (*__errno_location ()), gettext("daemon() failed"));
  topt &= ~0x00000020;
  topt |= 0x00000040;
  openlog (log_tag, 0x01, log_facility);
  info (1, gettext("%s daemon startup succeeded."), version);
  write_pid_file ();
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 7
22 7
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 10
35 12
36 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    (%rsi),%rsi
test   %rsi,%rsi
jne    7cc <swicat_isf_all_scripts+0x38>
jmp    7de <swicat_isf_all_scripts+0x4a>
mov    %r13d,%edx
mov    %r12,%rdi
callq  7b6 <swicat_isf_all_scripts+0x22>
add    $0x8,%rbx
cmp    $0x48,%rbx
je     7de <swicat_isf_all_scripts+0x4a>
mov    0x8(%rbp,%rbx,1),%rsi
test   %rsi,%rsi
jne    7ab <swicat_isf_all_scripts+0x17>
jmp    7de <swicat_isf_all_scripts+0x4a>
mov    %rdi,%r12
mov    %edx,%r13d
callq  7d7 <swicat_isf_all_scripts+0x43>
mov    $0x0,%ebx
jmp    7c0 <swicat_isf_all_scripts+0x2c>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
swicat_isf_all_scripts(STROB * buf, SWI_SCRIPTS * xx, int do_if_active)
{
 int i = 0;
 while(i < 10 && xx->swi_coM[i]) {
  swicat_isf_control_script(buf, xx->swi_coM[i], do_if_active);
  i++;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 9
27 9
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     24a <list_count+0x9>
mov    (%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
list_count (struct list * list)
{
  if (!list)
    return 0;
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gb_delete(GB * G) {
 return;
}
<<<sep_in_sample>>>
1 1
<<<sep_out_sample>>>
movzbl %dil,%edx
cmp    $0x7f,%edx
je     b6 <control+0x97>
mov    $0x0,%eax
test   %dil,%dil
je     bb <control+0x9c>
cmp    $0x7f,%edx
jbe    7f <control+0x60>
movb   $0x5c,0x0(%rip)        # 46 <control+0x27>
mov    %edi,%eax
shr    $0x6,%al
add    $0x30,%eax
mov    %al,0x0(%rip)        # 54 <control+0x35>
mov    %edi,%eax
shr    $0x3,%al
and    $0x7,%eax
add    $0x30,%eax
mov    %al,0x0(%rip)        # 65 <control+0x46>
and    $0x7,%edi
add    $0x30,%edi
mov    %dil,0x0(%rip)        # 72 <control+0x53>
movb   $0x0,0x0(%rip)        # 79 <control+0x5a>
mov    $0x0,%eax
retq   
cmp    $0x1f,%edx
jbe    98 <control+0x79>
mov    %dil,0x0(%rip)        # 8b <control+0x6c>
movb   $0x0,0x0(%rip)        # 92 <control+0x73>
mov    $0x0,%eax
retq   
movb   $0x5e,0x0(%rip)        # 9f <control+0x80>
add    $0x40,%edi
mov    %dil,0x0(%rip)        # a9 <control+0x8a>
movb   $0x0,0x0(%rip)        # b0 <control+0x91>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
control (register cc_t c)
{
  static char buf[5];
  register unsigned int uic = (unsigned int) c;
  if (uic == 0x7f)
    return ("^?");
  if (c == (cc_t) '\0')
    {
      return "off";
    }
  if (uic >= 0x80)
    {
      buf[0] = '\\';
      buf[1] = ((c >> 6) & 07) + '0';
      buf[2] = ((c >> 3) & 07) + '0';
      buf[3] = (c & 07) + '0';
      buf[4] = 0;
    }
  else if (uic >= 0x20)
    {
      buf[0] = c;
      buf[1] = 0;
    }
  else
    {
      buf[0] = '^';
      buf[1] = '@' + c;
      buf[2] = 0;
    }
  return (buf);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 9
5 7
6 7
7 11
8 11
9 13
10 14
11 14
12 14
13 14
14 15
15 15
16 15
17 15
18 15
19 16
20 16
21 16
22 17
23 30
24 30
25 19
26 19
27 21
28 22
29 30
30 30
31 26
32 27
33 27
34 28
35 30
36 30
37 6
38 31
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     947 <rec_record_set_source+0x22>
callq  93f <rec_record_set_source+0x1a>
movq   $0x0,0x10(%rbx)
mov    %rbp,%rdi
callq  94f <rec_record_set_source+0x2a>
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_record_set_source (rec_record_t record,
                       char *source)
{
  if (record->source)
    {
      free (record->source);
      record->source = ((void *)0);
    }
  record->source = strdup (source);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 7
11 9
12 9
13 9
14 10
15 10
16 10
17 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     1576 <gsl_matrix_int_fread+0x43>
shl    $0x2,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     15b7 <gsl_matrix_int_fread+0x84>
jmp    158d <gsl_matrix_int_fread+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  158b <gsl_matrix_int_fread+0x58>
jmp    15b7 <gsl_matrix_int_fread+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  15a5 <gsl_matrix_int_fread+0x72>
test   %eax,%eax
jne    15b7 <gsl_matrix_int_fread+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    158d <gsl_matrix_int_fread+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_int_fread (FILE * stream, gsl_matrix_int * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_int_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_int_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # c9 <set_current_addr+0x6>
retq   
<<<sep_in_sample>>>
set_current_addr( const int addr ) { current_addr_ = addr; }
<<<sep_in_sample>>>
1 1
2 1
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
conjugate_pr_restart (void *vstate)
{
  conjugate_pr_state_t *state = (conjugate_pr_state_t *) vstate;
  state->iter = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  4de <emit_bug_reporting_address+0xb>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  4f0 <emit_bug_reporting_address+0x1d>
mov    $0x0,%edi
callq  4fa <emit_bug_reporting_address+0x27>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  511 <emit_bug_reporting_address+0x3e>
mov    0x0(%rip),%rbx        # 518 <emit_bug_reporting_address+0x45>
mov    $0x0,%edi
callq  522 <emit_bug_reporting_address+0x4f>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  52d <emit_bug_reporting_address+0x5a>
pop    %rbx
retq   
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  printf (gettext ("\nReport bugs to: %s\n"), "bug-gsasl@gnu.org");
  printf (gettext ("%s home page: <%s>\n"), "GNU SASL", "http://www.gnu.org/software/gsasl/");
  fputs (gettext ("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),
         stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0xa8,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %fs:0x28,%rax
mov    %rax,0x98(%rsp)
xor    %eax,%eax
callq  5d <_body_get_lines0+0x2b>
mov    $0x0,%ebp
test   %eax,%eax
jne    af <_body_get_lines0+0x7d>
movq   $0x0,0x8(%rsp)
mov    $0x0,%ebx
jmp    87 <_body_get_lines0+0x55>
cmpb   $0xa,0xf(%rsp,%rdx,1)
sete   %al
movzbl %al,%eax
add    %rax,%rbp
add    %rdx,%rbx
lea    0x8(%rsp),%r8
mov    %rbx,%rcx
mov    $0x80,%edx
lea    0x10(%rsp),%rsi
mov    %r12,%rdi
callq  a1 <_body_get_lines0+0x6f>
test   %eax,%eax
jne    af <_body_get_lines0+0x7d>
mov    0x8(%rsp),%rdx
test   %rdx,%rdx
jne    76 <_body_get_lines0+0x44>
test   %r13,%r13
je     b8 <_body_get_lines0+0x86>
mov    %rbp,0x0(%r13)
mov    0x98(%rsp),%rcx
xor    %fs:0x28,%rcx
je     d0 <_body_get_lines0+0x9e>
callq  d0 <_body_get_lines0+0x9e>
add    $0xa8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_body_get_lines0 (mu_stream_t stream, size_t *plines)
{
  int status = mu_stream_flush (stream);
  size_t lines = 0;
  if (status == 0)
    {
      char buf[128];
      size_t n = 0;
      mu_off_t off = 0;
      while ((status = mu_stream_readline (stream, buf, sizeof buf,
        off, &n)) == 0 && n > 0)
 {
   if (buf[n - 1] == '\n')
     lines++;
   off += n;
 }
    }
  if (plines)
    *plines = lines;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 5
14 5
15 8
16 9
17 10
18 14
19 14
20 14
21 14
22 15
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 18
35 18
36 19
37 21
38 21
39 21
40 21
41 21
42 21
43 21
44 21
45 21
46 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%esi
callq  430 <mu_attribute_unset_flagged+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_attribute_unset_flagged (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x02);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rsi
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbx
test   %rbp,%rbp
je     65 <_my_stpcpy+0x65>
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     65 <_my_stpcpy+0x65>
mov    (%r12),%rax
cmp    %rax,%rbx
cmova  %rax,%rbx
mov    %rbx,%rdx
callq  46 <_my_stpcpy+0x46>
sub    %rbx,(%r12)
mov    %rbx,%rax
add    0x0(%rbp),%rax
mov    %rax,0x0(%rbp)
cmpq   $0x0,(%r12)
je     61 <_my_stpcpy+0x61>
movb   $0x0,(%rax)
jmp    65 <_my_stpcpy+0x65>
movb   $0x0,-0x1(%rax)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_my_stpcpy (char **pbuf, size_t *psize, const char *src)
{
  size_t slen = strlen (src);
  if (pbuf == ((void *)0) || *pbuf == ((void *)0))
    return slen;
  else
    {
      char *buf = *pbuf;
      size_t size = *psize;
      if (size > slen)
 size = slen;
      memcpy (buf, src, size);
      *psize -= size;
      *pbuf += size;
      if (*psize)
 **pbuf = 0;
      else
 (*pbuf)[-1] = 0;
      return size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 9
19 9
20 9
21 12
22 12
23 13
24 14
25 14
26 14
27 15
28 15
29 16
30 16
31 18
32 21
33 21
34 21
35 21
36 21
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
mov    0x20(%rax),%rax
mov    %rsi,0x98(%rax)
retq   
<<<sep_in_sample>>>
regwhen (block_t *rb, decl_t *rd)
{
  rb->quant.prefqual->descr->when= rd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x20,%esi
mov    $0x1,%edi
callq  19 <_nntp_folder_init+0x13>
mov    %rax,%rdx
mov    %rax,0x40(%rbx)
mov    $0xc,%eax
test   %rdx,%rdx
je     50 <_nntp_folder_init+0x4a>
mov    %rbx,0x8(%rdx)
movq   $0x0,0x48(%rbx)
movq   $0x0,0x50(%rbx)
movq   $0x0,0x58(%rbx)
movq   $0x0,0x60(%rbx)
mov    $0x0,%al
pop    %rbx
retq   
<<<sep_in_sample>>>
_nntp_folder_init (mu_folder_t folder)
{
  f_nntp_t f_nntp;
  f_nntp = folder->data = calloc (1, sizeof (*f_nntp));
  if (f_nntp == ((void *)0))
    return 12;
  f_nntp->folder = folder;
  folder->_destroy = nntp_folder_destroy;
  folder->_open = nntp_folder_open;
  folder->_close = nntp_folder_close;
  folder->_list = nntp_folder_list;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 6
9 5
10 5
11 7
12 8
13 9
14 10
15 11
16 12
17 13
18 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  22 <nettle_camellia256_set_decrypt_key+0x9>
mov    %rbx,%rsi
mov    %rbx,%rdi
callq  2d <nettle_camellia256_set_decrypt_key+0x14>
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_camellia256_set_decrypt_key(struct camellia256_ctx *ctx,
       const uint8_t *key)
{
  nettle_camellia256_set_encrypt_key(ctx, key);
  nettle_camellia256_invert_key(ctx, ctx);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
ucomisd %xmm0,%xmm4
jbe    675 <gsl_cdf_fdist_Q+0x4d>
addsd  %xmm0,%xmm4
movsd  0x0(%rip),%xmm5        # 646 <gsl_cdf_fdist_Q+0x1e>
divsd  %xmm4,%xmm0
movapd %xmm0,%xmm4
movapd %xmm2,%xmm3
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm1
movapd %xmm1,%xmm2
movsd  0x0(%rip),%xmm1        # 666 <gsl_cdf_fdist_Q+0x3e>
movsd  0x0(%rip),%xmm0        # 66e <gsl_cdf_fdist_Q+0x46>
callq  26d <beta_inc_AXPY>
jmp    6a2 <gsl_cdf_fdist_Q+0x7a>
addsd  %xmm4,%xmm0
movsd  0x0(%rip),%xmm5        # 681 <gsl_cdf_fdist_Q+0x59>
divsd  %xmm0,%xmm4
movapd %xmm1,%xmm3
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm2
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 69d <gsl_cdf_fdist_Q+0x75>
callq  26d <beta_inc_AXPY>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_fdist_Q (const double x, const double nu1, const double nu2)
{
  double Q;
  double r = nu2 / nu1;
  if (x < r)
    {
      double u = x / (r + x);
      Q = beta_inc_AXPY (-1.0, 1.0, nu1 / 2.0, nu2 / 2.0, u);
    }
  else
    {
      double u = r / (r + x);
      Q = beta_inc_AXPY (1.0, 0.0, nu2 / 2.0, nu1 / 2.0, u);
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 12
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 16
28 16
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 17fe <gcide_markup_yyset_in+0x7>
retq   
<<<sep_in_sample>>>
gcide_markup_yyset_in (FILE * in_str )
{
        gcide_markup_yyin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x48(%rdi),%edx
mov    $0x0,%ebp
test   $0x4,%dl
jne    68b <restore_initial_cwd+0x3e>
test   $0x2,%dh
je     679 <restore_initial_cwd+0x2c>
mov    $0x1,%edx
mov    $0xffffff9c,%esi
callq  5fc <cwd_advance_fd>
jmp    68b <restore_initial_cwd+0x3e>
mov    0x28(%rdi),%edi
callq  681 <restore_initial_cwd+0x34>
test   %eax,%eax
setne  %bpl
movzbl %bpl,%ebp
lea    0x60(%rbx),%rdi
callq  52b <fd_ring_clear>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
restore_initial_cwd (FTS *sp)
{
  int fail = (!(sp->fts_options & (0x0004)) && ((sp->fts_options & (0x0200)) ? (cwd_advance_fd ((sp), ((sp->fts_options & (0x0200)) ? -100 : sp->fts_rfd), 1), 0) : fchdir ((sp->fts_options & (0x0200)) ? -100 : sp->fts_rfd)));
  fd_ring_clear (&(sp->fts_fd_ring));
  return fail;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 4
21 4
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
<<<sep_in_sample>>>
swheader_get_current_offset_p(SWHEADER * swheader)
{
 return swheader->current_offset_p_;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
callq  5e36 <print_unix_command_map+0x6>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # 5e40 <print_unix_command_map+0x10>
callq  5e45 <print_unix_command_map+0x15>
mov    $0x1,%edi
callq  5e4f <print_unix_command_map+0x1f>
mov    %rbx,%rdi
callq  5e57 <print_unix_command_map+0x27>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
print_unix_command_map ()
{
  Keymap save;
  save = rl_get_keymap ();
  rl_set_keymap (cmd_xmap);
  rl_macro_dumper (1);
  rl_set_keymap (save);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 7
9 7
10 9
11 9
12 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  4b7c <gsl_sf_conicalP_sph_reg+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     4ba2 <gsl_sf_conicalP_sph_reg+0x32>
mov    %eax,%ecx
mov    $0x558,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b9b <gsl_sf_conicalP_sph_reg+0x2b>
movsd  (%rsp),%xmm0
jmp    4ba2 <gsl_sf_conicalP_sph_reg+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_conicalP_sph_reg(const int l, const double lambda, const double x)
{
  gsl_sf_result result; int status = gsl_sf_conicalP_sph_reg_e(l, lambda, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_conicalP_sph_reg_e(l, lambda, x, &result)", "legendre_con.c", 1368, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl 0x0(%rip),%ecx        # 5b2 <get_line+0xb>
movzbl 0x0(%rip),%edx        # 5b9 <get_line+0x12>
mov    0x0(%rip),%esi        # 5bf <get_line+0x18>
mov    0x0(%rip),%rdi        # 5c6 <get_line+0x1f>
callq  385 <pget_line>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_line (void)
{
   return pget_line (p_indent, p_rfc934_nesting, p_strip_trailing_cr,
       p_pass_comments_through);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
mov    (%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     2e <font_entry_hash_1+0x2e>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    f <font_entry_hash_1+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
font_entry_hash_1 (struct font_entry * entry)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((entry->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdx,%rbx
lea    0x8(%rsp),%rdx
callq  1f4 <mu_property_aget_value+0x12>
mov    %eax,%ecx
test   %ecx,%ecx
jne    210 <mu_property_aget_value+0x2e>
mov    0x8(%rsp),%rdi
callq  204 <mu_property_aget_value+0x22>
mov    %rax,(%rbx)
cmp    $0x1,%rax
sbb    %eax,%eax
and    $0xc,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_property_aget_value (mu_property_t prop, const char *key,
   char **buffer)
{
  const char *value;
  int rc = mu_property_sget_value (prop, key, &value);
  if (rc == 0)
    {
      if ((*buffer = strdup (value)) == ((void *)0))
 return 12;
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 6
8 6
9 8
10 8
11 8
12 9
13 9
14 9
15 12
16 12
17 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
test   %esi,%esi
jle    e58 <fh_format_query+0x30>
mov    %rdi,%r12
mov    %rdx,%rbp
mov    (%rdx),%rdi
callq  e40 <fh_format_query+0x18>
cmp    $0x1,%rax
sbb    %ecx,%ecx
not    %ecx
add    $0x2,%ecx
mov    %rbp,%rdx
mov    %ebx,%esi
mov    %r12,%rdi
callq  e58 <fh_format_query+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_format_query (format_data_t form, int argc, char *argv[])
{
  if (argc < 1)
    return;
  select_arg (form, argc, argv, format_find (argv[0]) ? 1 : 2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
testl  $0x102,0x48(%rdi)
je     51d <free_dir+0x1d>
mov    0x58(%rdi),%rdi
test   %rdi,%rdi
je     526 <free_dir+0x26>
callq  51b <free_dir+0x1b>
jmp    526 <free_dir+0x26>
mov    0x58(%rdi),%rdi
callq  526 <free_dir+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
free_dir (FTS *sp)
{
  if (sp->fts_options & (0x0100 | 0x0002))
    {
      if (sp->fts_cycle.ht)
        hash_free (sp->fts_cycle.ht);
    }
  else
    free (sp->fts_cycle.state);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 6
8 6
9 9
10 9
11 10
12 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0xd0(%rdi),%rcx
mov    0x28(%rdi),%rdi
mov    $0x0,%edx
mov    $0x18,%esi
callq  104 <CDB___ham_db_create+0x1e>
test   %eax,%eax
jne    146 <CDB___ham_db_create+0x60>
mov    0xd0(%rbx),%rdx
movl   $0x0,0x8(%rdx)
movl   $0x0,0x4(%rdx)
movq   $0x0,0x10(%rdx)
movq   $0x0,0x200(%rbx)
movq   $0x0,0x208(%rbx)
movq   $0x0,0x210(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___ham_db_create(dbp)
 DB *dbp;
{
 HASH *hashp;
 int ret;
 if ((ret = CDB___os_malloc(dbp->dbenv,
     sizeof(HASH), ((void *)0), &dbp->h_internal)) != 0)
  return (ret);
 hashp = dbp->h_internal;
 hashp->h_nelem = 0;
 hashp->h_ffactor = 0;
 hashp->h_hash = ((void *)0);
 dbp->set_h_ffactor = __ham_set_h_ffactor;
 dbp->set_h_hash = __ham_set_h_hash;
 dbp->set_h_nelem = __ham_set_h_nelem;
 return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 6
5 6
6 6
7 6
8 6
9 6
10 9
11 10
12 11
13 12
14 13
15 14
16 15
17 17
18 17
<<<sep_out_sample>>>
mov    (%rcx),%r11
cmpl   $0x0,0x19c(%rdi)
jle    19f <h2v1_upsample+0x55>
mov    $0x0,%r10d
movslq %r10d,%rax
mov    (%rdx,%rax,8),%rsi
mov    (%r11,%rax,8),%rcx
mov    0x88(%rdi),%r9d
add    %rcx,%r9
cmp    %r9,%rcx
jae    192 <h2v1_upsample+0x48>
add    $0x1,%rsi
movzbl -0x1(%rsi),%r8d
mov    %r8b,(%rcx)
lea    0x2(%rcx),%rax
mov    %rax,%rcx
mov    %r8b,-0x1(%rax)
cmp    %r9,%rax
jb     176 <h2v1_upsample+0x2c>
add    $0x1,%r10d
cmp    %r10d,0x19c(%rdi)
jg     15c <h2v1_upsample+0x12>
repz retq 
<<<sep_in_sample>>>
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
        JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  JSAMPARRAY output_data = *output_data_ptr;
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow;
  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
  }
}
<<<sep_in_sample>>>
1 4
2 9
3 9
4 9
5 10
6 10
7 11
8 12
9 12
10 13
11 13
12 14
13 14
14 15
15 15
16 15
17 16
18 13
19 13
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
rec_record_comment_equal_fn (void *data1,
                             void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 7 <check_code_size+0x7>
cmp    %rsi,0x0(%rip)        # e <check_code_size+0xe>
jb     68 <check_code_size+0x68>
push   %rbx
sub    0x0(%rip),%rsi        # 18 <check_code_size+0x18>
lea    0x190(%rsi),%ebx
mov    %ebx,%esi
mov    0x0(%rip),%rdi        # 27 <check_code_size+0x27>
callq  2c <check_code_size+0x2c>
mov    %rax,0x0(%rip)        # 33 <check_code_size+0x33>
mov    0x0(%rip),%rdx        # 3a <check_code_size+0x3a>
sub    0x0(%rip),%rdx        # 41 <check_code_size+0x41>
lea    0x1(%rax,%rdx,1),%rdx
mov    %rdx,0x0(%rip)        # 4d <check_code_size+0x4d>
movslq %ebx,%rbx
lea    -0x5(%rax,%rbx,1),%rdx
mov    %rdx,0x0(%rip)        # 5c <check_code_size+0x5c>
add    $0x1,%rax
mov    %rax,0x0(%rip)        # 67 <check_code_size+0x67>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
check_code_size(void)
{
    if (e_code >= l_code)
    {
        int nsize = l_code - s_code + 400;
        codebuf = (char *) xrealloc (codebuf, nsize);
        e_code = codebuf + (e_code - s_code) + 1;
        l_code = codebuf + nsize - 5;
        s_code = codebuf + 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 9
19 9
20 11
21 11
<<<sep_out_sample>>>
mov    $0x1,%r9d
callq  358 <_asn1_decode_simple_der>
repz retq 
<<<sep_in_sample>>>
asn1_decode_simple_der (unsigned int etype, const unsigned char *der,
   unsigned int _der_len, const unsigned char **str,
   unsigned int *str_len)
{
  return _asn1_decode_simple_der(etype, der, _der_len, str, str_len, 1);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
mov    (%rcx),%rdi
test   %r8,%r8
je     ea4 <gsl_vector_long_min_index+0x42>
shl    $0x3,%r9
add    %r9,%rcx
mov    $0x0,%edx
mov    $0x0,%eax
jmp    e99 <gsl_vector_long_min_index+0x37>
mov    (%rcx),%rsi
cmp    %rsi,%rdi
jle    e96 <gsl_vector_long_min_index+0x34>
mov    %rdx,%rax
mov    %rsi,%rdi
add    %r9,%rcx
add    $0x1,%rdx
cmp    %r8,%rdx
jne    e88 <gsl_vector_long_min_index+0x26>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_long_min_index (const gsl_vector_long * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  long min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 8
7 8
8 8
9 8
10 6
11 6
12 10
13 11
14 11
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 18
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
movzbl (%rcx),%edi
test   %r8,%r8
je     16c8 <gsl_vector_uchar_min_index+0x3d>
add    %r9,%rcx
mov    $0x0,%edx
mov    $0x0,%eax
jmp    16bd <gsl_vector_uchar_min_index+0x32>
movzbl (%rcx),%esi
cmp    %sil,%dil
jbe    16ba <gsl_vector_uchar_min_index+0x2f>
mov    %rdx,%rax
mov    %esi,%edi
add    %r9,%rcx
add    $0x1,%rdx
cmp    %r8,%rdx
jne    16ad <gsl_vector_uchar_min_index+0x22>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_min_index (const gsl_vector_uchar * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned char min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 8
7 8
8 8
9 6
10 6
11 10
12 11
13 11
14 8
15 10
16 10
17 8
18 8
19 8
20 8
21 6
22 18
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
movsd  0x50(%rdi),%xmm3
movsd  0x18(%rdi),%xmm2
mov    0x4(%rsi),%r9d
movsd  0x48(%rdi),%xmm1
mov    0xc(%rsi),%r8d
movsd  0x40(%rdi),%xmm0
mov    0x8(%rsi),%ecx
movslq 0x58(%rdi),%rdx
lea    0x14(%rsi,%rdx,1),%rdx
lea    0x5c(%rdi),%rsi
mov    0x10(%rax),%eax
mov    %eax,(%rsp)
mov    $0x0,%edi
mov    $0x4,%eax
callq  e8 <print_time_list+0x48>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
print_time_list(const STATISTICS_TIME *t, void *priv)
{
 const struct printing_width *max_width = priv;
 const char *dots = (const char *)&max_width[1];
 message("- %s %s"
  " user %*." "3" "fs"
  " system %*." "3" "fs"
  " elapsed %*." "3" "fs"
  " %*." "1" "f%%",
  t->name, dots + t->name_len,
  max_width->user, t->user,
  max_width->system, t->system,
  max_width->elapsed, t->elapsed,
  max_width->percent, t->percent);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 10
13 5
14 5
15 5
16 5
17 5
18 15
19 15
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
mov    $0x0,%esi
callq  737 <_rl_nsearch_cleanup+0xd>
movq   $0x0,0x0(%rip)        # 742 <_rl_nsearch_cleanup+0x18>
andq   $0xfffffffffffffeff,0x0(%rip)        # 74d <_rl_nsearch_cleanup+0x23>
cmp    $0x1,%ebx
setne  %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_nsearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;
  (rl_readline_state &= ~(0x0000100));
  return (r != 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,0x0(%rip)        # aaa <_rl_dispatch+0xb>
mov    $0x0,%edx
callq  ab4 <_rl_dispatch+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_dispatch (key, map)
     register int key;
     Keymap map;
{
  _rl_dispatching_keymap = map;
  return _rl_dispatch_subseq (key, map, 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %edx,%r12d
callq  216 <git_addfn+0x12>
mov    (%rax),%rsi
jmp    21f <git_addfn+0x1b>
add    $0x1,%rbx
movzbl (%rbx),%eax
movsbq %al,%rcx
testb  $0x20,0x1(%rsi,%rcx,2)
jne    21b <git_addfn+0x17>
cmp    $0x23,%al
je     253 <git_addfn+0x4f>
test   %al,%al
je     253 <git_addfn+0x4f>
cmp    $0x5c,%al
jne    245 <git_addfn+0x41>
lea    0x1(%rbx),%rax
cmpb   $0x23,0x1(%rbx)
cmove  %rax,%rbx
mov    %r12d,%edx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  253 <git_addfn+0x4f>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
git_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  while (((*__ctype_b_loc ())[(int) ((*pattern))] & (unsigned short int) _ISspace))
    ++pattern;
  if (*pattern == 0 || *pattern == '#')
    return;
  if (*pattern == '\\' && pattern[1] == '#')
    ++pattern;
  add_exclude (ex, pattern, options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 4
11 3
12 3
13 3
14 3
15 5
16 5
17 5
18 5
19 7
20 7
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdx
callq  5623 <gsl_sf_hyperg_U_int+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     5649 <gsl_sf_hyperg_U_int+0x32>
mov    %eax,%ecx
mov    $0x6f5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5642 <gsl_sf_hyperg_U_int+0x2b>
movsd  (%rsp),%xmm0
jmp    5649 <gsl_sf_hyperg_U_int+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_U_int(const int a, const int b, const double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_U_int_e(a, b, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_U_int_e(a, b, x, &result)", "hyperg_U.c", 1781, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
ucomisd %xmm0,%xmm4
jbe    5f2 <gsl_cdf_fdist_P+0x49>
addsd  %xmm0,%xmm4
movsd  0x0(%rip),%xmm5        # 5c7 <gsl_cdf_fdist_P+0x1e>
divsd  %xmm4,%xmm0
movapd %xmm0,%xmm4
movapd %xmm2,%xmm3
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm1
movapd %xmm1,%xmm2
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 5eb <gsl_cdf_fdist_P+0x42>
callq  26d <beta_inc_AXPY>
jmp    623 <gsl_cdf_fdist_P+0x7a>
addsd  %xmm4,%xmm0
movsd  0x0(%rip),%xmm5        # 5fe <gsl_cdf_fdist_P+0x55>
divsd  %xmm0,%xmm4
movapd %xmm1,%xmm3
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm2
movsd  0x0(%rip),%xmm1        # 616 <gsl_cdf_fdist_P+0x6d>
movsd  0x0(%rip),%xmm0        # 61e <gsl_cdf_fdist_P+0x75>
callq  26d <beta_inc_AXPY>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_fdist_P (const double x, const double nu1, const double nu2)
{
  double P;
  double r = nu2 / nu1;
  if (x < r)
    {
      double u = x / (r + x);
      P = beta_inc_AXPY (1.0, 0.0, nu1 / 2.0, nu2 / 2.0, u);
    }
  else
    {
      double u = r / (r + x);
      P = beta_inc_AXPY (-1.0, 1.0, nu2 / 2.0, nu1 / 2.0, u);
    }
  return P;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 12
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 16
28 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x0,%edi
callq  199 <optloc_save>
mov    0x0(%rip),%rdi        # baa <set_use_compress_program_option+0x1a>
test   %rdi,%rdi
je     bfd <set_use_compress_program_option+0x6d>
mov    %rax,%rbp
mov    %rbx,%rsi
callq  bba <set_use_compress_program_option+0x2a>
test   %eax,%eax
je     bfd <set_use_compress_program_option+0x6d>
cmpl   $0x1,0x0(%rbp)
jne    bfd <set_use_compress_program_option+0x6d>
mov    0x0(%rip),%rax        # bcb <set_use_compress_program_option+0x3b>
test   %rax,%rax
je     bd2 <set_use_compress_program_option+0x42>
callq  *%rax
mov    $0x0,%edi
callq  bdc <set_use_compress_program_option+0x4c>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  bf3 <set_use_compress_program_option+0x63>
mov    $0x2,%edi
callq  bfd <set_use_compress_program_option+0x6d>
mov    %rbx,0x0(%rip)        # c04 <set_use_compress_program_option+0x74>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_use_compress_program_option (const char *string, struct option_locus *loc)
{
  struct option_locus *p = optloc_save (OC_COMPRESS, loc);
  if (use_compress_program_option
      && strcmp (use_compress_program_option, string) != 0
      && p->source == OPTS_COMMAND_LINE)
    do { if (error_hook) error_hook (); error (0, 0, gettext ("Conflicting compression options")); usage (2); } while (0);
  use_compress_program_option = string;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 8
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    (%rdi),%rax
mov    (%rax),%rbx
lea    0x4(%rbx),%rax
cmpb   $0x2d,0x1(%rbx)
cmovne %rax,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1a1 <cmpidx_long+0x26>
mov    %rax,%r12
mov    0x0(%rbp),%rax
mov    (%rax),%rbp
lea    0x4(%rbp),%rax
cmpb   $0x2d,0x1(%rbp)
cmovne %rax,%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  1c4 <cmpidx_long+0x49>
cmp    %r12,%rax
mov    %r12,%rdx
cmovbe %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1d9 <cmpidx_long+0x5e>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cmpidx_long(const void *a, const void *b)
{
 struct grecs_opthelp const **ap = (struct grecs_opthelp const **)a;
 struct grecs_opthelp const **bp = (struct grecs_opthelp const **)b;
 char const *opta, *optb;
 size_t lena, lenb;
 if ((*ap)->opt[1] == '-')
  opta = (*ap)->opt;
 else
  opta = (*ap)->opt + 4;
 lena = strcspn(opta, ",");
 if ((*bp)->opt[1] == '-')
  optb = (*bp)->opt;
 else
  optb = (*bp)->opt + 4;
 lenb = strcspn(optb, ",");
 return strncmp(opta, optb, lena > lenb ? lenb : lena);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 10
8 10
9 10
10 11
11 11
12 11
13 11
14 12
15 12
16 15
17 15
18 15
19 16
20 16
21 16
22 17
23 17
24 17
25 17
26 17
27 17
28 18
29 18
30 18
31 18
<<<sep_out_sample>>>
test   %rdi,%rdi
je     62c <nntp_get_transport2+0x55>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    0x8(%rdi),%rax
test   %rax,%rax
je     632 <nntp_get_transport2+0x5b>
mov    0x18(%rax),%rcx
test   %rcx,%rcx
je     639 <nntp_get_transport2+0x62>
mov    $0x16,%eax
cmpq   $0x0,0x8(%rcx)
je     63e <nntp_get_transport2+0x67>
mov    0x18(%rcx),%rdi
lea    0x8(%rsp),%rsi
callq  614 <nntp_get_transport2+0x3d>
mov    %eax,%edx
test   %edx,%edx
jne    63e <nntp_get_transport2+0x67>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  62a <nntp_get_transport2+0x53>
jmp    63e <nntp_get_transport2+0x67>
mov    $0x16,%eax
retq   
mov    $0x16,%eax
jmp    63e <nntp_get_transport2+0x67>
mov    $0x16,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nntp_get_transport2 (msg_nntp_t msg_nntp, mu_transport_t *pin, mu_transport_t *pout)
{
  int status = 22;
  if (msg_nntp && msg_nntp->m_nntp
      && msg_nntp->m_nntp->f_nntp && msg_nntp->m_nntp->f_nntp->folder)
    {
      mu_stream_t carrier;
      status = mu_nntp_get_carrier (msg_nntp->m_nntp->f_nntp->nntp, &carrier);
      if (status == 0)
 return mu_stream_get_transport2 (carrier, pin, pout);
    }
  return status;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 5
14 3
15 5
16 5
17 8
18 8
19 8
20 8
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 3
29 13
30 3
31 3
32 3
33 13
34 13
35 13
36 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  61 <gsl_isnan+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_isnan (const double x)
{
  return (sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r13
push   %r12
push   %rbx
sub    $0x18,%rsp
mov    %esi,%ebx
mov    %fs:0x28,%rax
mov    %rax,-0x28(%rbp)
xor    %eax,%eax
mov    %esi,%r12d
cmpb   $0x0,(%rdi,%r12,1)
je     3ed <strcache_add_len+0x5a>
lea    0x1(%rsi),%eax
add    $0x1e,%rax
shr    $0x4,%rax
shl    $0x4,%rax
sub    %rax,%rsp
lea    0xf(%rsp),%r13
and    $0xfffffffffffffff0,%r13
mov    %r12,%rdx
mov    %rdi,%rsi
mov    %r13,%rdi
callq  3e4 <strcache_add_len+0x51>
movb   $0x0,0x0(%r13,%r12,1)
mov    %r13,%rdi
mov    %ebx,%esi
callq  7d <add_hash>
mov    -0x28(%rbp),%rcx
xor    %fs:0x28,%rcx
je     408 <strcache_add_len+0x75>
callq  408 <strcache_add_len+0x75>
lea    -0x18(%rbp),%rsp
pop    %rbx
pop    %r12
pop    %r13
pop    %rbp
retq   
<<<sep_in_sample>>>
strcache_add_len (const char *str, unsigned int len)
{
  if (str[len] != '\0')
    {
      char *key = __builtin_alloca (len + 1);
      memcpy (key, str, len);
      key[len] = '\0';
      str = key;
    }
  return add_hash (str, len);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 6
25 7
26 8
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    %rsp,%rdx
mov    $0x2,%esi
callq  3c1 <getSizeFromId+0x11>
cmp    $0xffffffff,%eax
mov    $0xffffffffffffffff,%rax
cmovne 0x30(%rsp),%rax
add    $0x78,%rsp
retq   
<<<sep_in_sample>>>
getSizeFromId (int id)
{
  struct shmid_ds informations;
  if (shmctl (id, 2, (struct shmid_ds *)&informations) == -1)
  {
    return -1;
  }
  return informations.shm_segsz;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 8
7 8
8 9
9 9
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
je     876 <read_subchannel+0x49>
push   %rbx
mov    $0x0,%esi
callq  842 <read_subchannel+0x15>
test   %eax,%eax
sete   %bl
je     85a <read_subchannel+0x2d>
mov    $0x0,%edi
callq  5e4 <xperror>
movb   $0x0,0x0(%rip)        # 85a <read_subchannel+0x2d>
mov    %ebx,%eax
cmpb   $0x0,0x0(%rip)        # 863 <read_subchannel+0x36>
je     875 <read_subchannel+0x48>
cmpb   $0x13,0x0(%rip)        # 86c <read_subchannel+0x3f>
jne    875 <read_subchannel+0x48>
callq  7cf <cd_eject>
mov    %ebx,%eax
pop    %rbx
repz retq 
<<<sep_in_sample>>>
read_subchannel(CdIo_t *p_cdio)
{
  _Bool b_ok = 1;
  if (!p_cdio) return 0;
  b_ok = DRIVER_OP_SUCCESS == cdio_audio_read_subchannel(p_cdio, &sub);
  if (!b_ok) {
    xperror("read subchannel");
    b_cd = 0;
  }
  if (auto_mode && sub.audio_status == CDIO_MMC_READ_SUB_ST_COMPLETED)
    cd_eject();
  return b_ok;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 8
13 12
14 10
15 10
16 10
17 10
18 11
19 12
20 13
21 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     402e <gsl_matrix_char_free+0x20>
cmpl   $0x0,0x28(%rdi)
je     4026 <gsl_matrix_char_free+0x18>
mov    0x20(%rdi),%rdi
callq  4026 <gsl_matrix_char_free+0x18>
mov    %rbx,%rdi
callq  402e <gsl_matrix_char_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_free (gsl_matrix_char * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_char_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%edi
callq  2727 <pies_reload+0xb>
mov    %eax,%ebx
cmp    $0xffffffff,%eax
jne    2751 <pies_reload+0x35>
mov    $0x0,%edi
callq  2738 <pies_reload+0x1c>
mov    %rax,%rsi
mov    $0x2,%edi
mov    $0x0,%eax
callq  274a <pies_reload+0x2e>
mov    $0x1,%eax
jmp    2786 <pies_reload+0x6a>
mov    $0x0,%edi
callq  275b <pies_reload+0x3f>
movslq %ebx,%rdx
mov    %rax,%rsi
mov    $0x6,%edi
mov    $0x0,%eax
callq  2770 <pies_reload+0x54>
mov    $0x1,%esi
mov    %ebx,%edi
callq  277c <pies_reload+0x60>
test   %eax,%eax
mov    $0x46,%edx
cmovne %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
pies_reload ()
{
  pid_t pid = pidfile_read (1);
  if (pid == -1)
    {
      logmsg (2, gettext("pies is not running"));
      return 1;
    }
  logmsg (6, gettext("reloading pies at PID %lu"), (unsigned long) pid);
  return kill (pid, 1) ? 70 : 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    (%rdi),%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
cmp    (%rsi),%r8
jne    971 <gsl_vector_ulong_swap+0x30>
shl    $0x3,%r10
shl    $0x3,%r9
mov    $0x0,%ecx
test   %r8,%r8
jne    995 <gsl_vector_ulong_swap+0x54>
mov    $0x0,%eax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  98e <gsl_vector_ulong_swap+0x4d>
mov    $0x4,%eax
jmp    9b6 <gsl_vector_ulong_swap+0x75>
mov    (%rdx),%rsi
mov    (%rax),%rdi
mov    %rdi,(%rdx)
mov    %rsi,(%rax)
add    $0x1,%rcx
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    995 <gsl_vector_ulong_swap+0x54>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_swap (gsl_vector_ulong * v, gsl_vector_ulong * w)
{
  unsigned long * d1 = v->data ;
  unsigned long * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          unsigned long tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 7
6 9
7 9
8 17
9 18
10 18
11 13
12 13
13 22
14 23
15 2
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 17
24 18
25 18
26 19
27 13
28 13
29 13
30 13
31 13
32 22
33 22
34 23
35 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  3e90 <gsl_sf_legendre_array_n+0x9>
lea    0x2(%rax,%rbx,2),%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_array_n(const size_t lmax)
{
  size_t nlm = gsl_sf_legendre_nlm(lmax);
  size_t nsqrt = 2 * lmax + 2;
  return (nlm + nsqrt);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 6
6 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    %rsi,%rbx
mov    %rdx,%r15
test   %rsi,%rsi
je     27e3 <ForAllVarwSep+0x8a>
mov    %rcx,%r12
mov    $0x0,%ebp
mov    $0xffffffffffffffff,%r13
mov    $0x0,%r14d
test   %r12,%r12
je     27a4 <ForAllVarwSep+0x4b>
test   %rbx,%rbx
je     27d8 <ForAllVarwSep+0x7f>
mov    0x10(%rbx),%rax
and    $0xf0000,%eax
cmp    %rax,%r12
jne    27d8 <ForAllVarwSep+0x7f>
cmpq   $0x0,0x8(%rbx)
je     27d8 <ForAllVarwSep+0x7f>
test   %r15,%r15
je     27d4 <ForAllVarwSep+0x7b>
test   %ebp,%ebp
mov    $0x0,%eax
cmovg  %rax,%r13
mov    %r13,%rdx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  *%r15
add    %eax,%r14d
add    $0x1,%ebp
jmp    27d8 <ForAllVarwSep+0x7f>
add    $0x1,%r14d
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    278c <ForAllVarwSep+0x33>
jmp    27e9 <ForAllVarwSep+0x90>
mov    $0x0,%r14d
mov    $0x1,%edx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  *%r15
mov    %r14d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ForAllVarwSep (PFILE pfile, PVMMAPSTRCT pvm, PFI_CALLBACK pfiFunc,
                   HANDLE hType, PVOID pinfo)
{
  int iTotal = 0;
  long End = -1;
  int iCount = 0;
  while (pvm) {
    if (hType == (0)
        || (pvm ? (pvm)->hType & 0xF0000 : 0x00000) == hType) {
      if (pvm->szEqn != vszHasInitializer) {
        if (pfiFunc) {
          if (iCount > 0)
            End = 0;
          iTotal += (*pfiFunc) (pfile, pvm, (PVOID) End);
          iCount++;
        }
        else
          iTotal++;
      }
    }
    pvm = pvm->pvmNextVar;
  }
  End = 1;
  (*pfiFunc) (pfile, pvm, (PVOID) End);
  return (iTotal);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 7
12 7
13 7
14 6
15 5
16 4
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 11
28 11
29 12
30 13
31 13
32 14
33 14
34 14
35 14
36 14
37 15
38 15
39 18
40 21
41 7
42 7
43 7
44 4
45 24
46 24
47 24
48 24
49 26
50 26
51 26
52 26
53 26
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
cmpb   $0x10,0x30(%rsi)
jne    d42 <calc_first+0x2a>
mov    0x8(%rsi),%rax
mov    0x18(%rax),%rdx
mov    %rdx,0x18(%rsi)
mov    0x38(%rax),%rax
mov    %rax,0x38(%rsi)
mov    $0x0,%edx
jmp    d9a <calc_first+0x82>
mov    %rdi,%rbp
mov    %rsi,0x18(%rbx)
mov    0x28(%rsi),%rsi
mov    0x30(%rbx),%rdx
callq  b3a <re_dfa_add_node>
mov    %rax,0x38(%rbx)
cmp    $0xffffffffffffffff,%rax
je     d95 <calc_first+0x7d>
mov    $0x0,%edx
cmpb   $0xc,0x30(%rbx)
jne    d9a <calc_first+0x82>
shl    $0x4,%rax
add    0x0(%rbp),%rax
movzwl 0x28(%rbx),%edx
and    $0x3ff,%edx
shl    $0x8,%edx
mov    0x8(%rax),%ecx
and    $0xfffc00ff,%ecx
or     %ecx,%edx
mov    %edx,0x8(%rax)
mov    $0x0,%edx
jmp    d9a <calc_first+0x82>
mov    $0xc,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
calc_first (void *extra, bin_tree_t *node)
{
  re_dfa_t *dfa = (re_dfa_t *) extra;
  if (node->token.type == CONCAT)
    {
      node->first = node->left->first;
      node->node_idx = node->left->node_idx;
    }
  else
    {
      node->first = node;
      node->node_idx = re_dfa_add_node (dfa, node->token);
      if (__builtin_expect (node->node_idx == ((Idx) -1), 0))
        return _REG_ESPACE;
      if (node->token.type == ANCHOR)
        dfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;
    }
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 18
13 18
14 18
15 11
16 12
17 12
18 12
19 12
20 13
21 13
22 18
23 15
24 15
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 18
35 18
36 14
37 19
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rcx,%rbp
callq  125d <mu_header_aget_value_unfold_n+0xe>
mov    %eax,%ebx
test   %eax,%eax
jne    1271 <mu_header_aget_value_unfold_n+0x22>
mov    $0x0,%esi
mov    0x0(%rbp),%rdi
callq  1271 <mu_header_aget_value_unfold_n+0x22>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_header_aget_value_unfold_n (mu_header_t header, const char *name, int n,
          char **pvalue)
{
  int rc = mu_header_aget_value_n (header, name, n, pvalue);
  if (rc == 0)
    mu_string_unfold (*pvalue, ((void *)0));
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  a7b <gsl_sf_synchrotron_1+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     aa1 <gsl_sf_synchrotron_1+0x32>
mov    %eax,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a9a <gsl_sf_synchrotron_1+0x2b>
movsd  (%rsp),%xmm0
jmp    aa1 <gsl_sf_synchrotron_1+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_synchrotron_1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_synchrotron_1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_synchrotron_1_e(x, &result)", "synchrotron.c", 279, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%rbp
mov    %rcx,%r12
mov    $0x0,%edx
callq  191 <file_reader+0x17>
mov    %rbx,%rcx
mov    %r12,%rdx
mov    $0x1,%esi
mov    %rbp,%rdi
callq  1a4 <file_reader+0x2a>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
file_reader (void *cls,
             uint64_t pos,
             char *buf,
             size_t max)
{
  FILE *file = cls;
  (void) fseek (file, pos, 0);
  return fread (buf, 1, max, file);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 9
15 9
16 9
17 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r13
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%rbx
test   %r8,%r8
mov    $0x0,%eax
cmove  %rax,%rbx
callq  e10 <quotearg_buffer+0x30>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    0x4(%rbx),%r9d
mov    0x30(%rbx),%rax
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    0x18(%rsp),%rdi
callq  e7 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
callq  13d5 <quotearg_char+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    0x28(%rdi),%rdx
mov    0x18(%rdi),%rsi
cmp    %rsi,%rdx
jbe    4b3 <smtp_write+0x56>
sub    %rsi,%rdx
mov    %rdx,0x8(%rsp)
mov    (%rdi),%rax
lea    0x8(%rsp),%r8
mov    $0x0,%ecx
mov    (%rax),%rdi
callq  490 <smtp_write+0x33>
mov    %eax,%ebp
test   %eax,%eax
jne    4bc <smtp_write+0x5f>
mov    0x18(%rbx),%rdi
mov    0x8(%rsp),%rdx
lea    (%rdi,%rdx,1),%rsi
callq  4a8 <smtp_write+0x4b>
mov    0x8(%rsp),%rax
sub    %rax,0x28(%rbx)
jmp    4bc <smtp_write+0x5f>
mov    %rsi,0x28(%rdi)
mov    $0x0,%ebp
mov    %ebp,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
smtp_write (smtp_t smtp)
{
  int status = 0;
  size_t len;
  if (smtp->ptr > smtp->buffer)
    {
      len = smtp->ptr - smtp->buffer;
      status = mu_stream_write (smtp->mailer->stream, smtp->buffer, len,
    0, &len);
      if (status == 0)
 {
   memmove (smtp->buffer, smtp->buffer + len, len);
   smtp->ptr -= len;
 }
    }
  else
    {
      smtp->ptr = smtp->buffer;
      len = 0;
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 18
27 3
28 22
29 22
30 22
31 22
32 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  7ac <do_end+0xb>
mov    %rax,%rbp
mov    0x0(%rip),%rbx        # 7b6 <do_end+0x15>
mov    0x20(%rbx),%rax
mov    (%rax),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,0x30(%rbx)
callq  7db <do_end+0x3a>
mov    %rax,0x38(%rbx)
mov    0x0(%rip),%rax        # 7e6 <do_end+0x45>
mov    0x38(%rax),%rsi
mov    %rbp,%rdi
callq  7f2 <do_end+0x51>
test   %al,%al
je     80a <do_end+0x69>
mov    0x0(%rip),%rax        # 7fd <do_end+0x5c>
mov    0x30(%rax),%rsi
mov    0x20(%rax),%rdi
callq  80a <do_end+0x69>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
do_end(void)
{
    size_t was_column = xplustabs();
    openfile->current_x = strlen(openfile->current->data);
    openfile->placewewant = xplustabs();
    if (need_horizontal_scroll(was_column, openfile->placewewant))
 update_line(openfile->current, openfile->current_x);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 8
28 8
29 8
30 8
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     14f9 <gsl_vector_ulong_sub+0x29>
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  14f2 <gsl_vector_ulong_sub+0x22>
mov    $0x13,%eax
jmp    154c <gsl_vector_ulong_sub+0x7c>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     1540 <gsl_vector_ulong_sub+0x70>
shl    $0x3,%rbx
shl    $0x3,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
mov    (%r9,%rcx,1),%r9
sub    %r9,(%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    151d <gsl_vector_ulong_sub+0x4d>
jmp    1547 <gsl_vector_ulong_sub+0x77>
mov    $0x0,%eax
jmp    154c <gsl_vector_ulong_sub+0x7c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_sub (gsl_vector_ulong * a, const gsl_vector_ulong * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 13
27 13
28 13
29 13
30 13
31 13
32 17
33 17
34 17
35 19
36 19
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 6 <init_sig+0x6>
movslq %edx,%rax
shl    $0x4,%rax
mov    %edi,0x0(%rax)
add    $0x1,%edx
mov    %edx,0x0(%rip)        # 1c <init_sig+0x1c>
mov    %rsi,0x0(%rax)
retq   
<<<sep_in_sample>>>
init_sig (number, abbrev, name)
     int number;
     const char *abbrev;
     const char *name;
{
  sig_table[sig_table_nelts].number = number;
  sig_table[sig_table_nelts++].abbrev = abbrev;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 7
6 7
7 7
8 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 78 <usage+0xb>
mov    $0x33,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8c <usage+0x1f>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
usage (void)
{
  fprintf (stderr, "usage: ls [-1ACFLRSTWacdfiklmnopqrstux] [file ...]\n");
  return (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  640 <history_get_history_state+0xe>
mov    0x0(%rip),%rdx        # 647 <history_get_history_state+0x15>
mov    %rdx,(%rax)
mov    0x0(%rip),%edx        # 650 <history_get_history_state+0x1e>
mov    %edx,0x8(%rax)
mov    0x0(%rip),%edx        # 659 <history_get_history_state+0x27>
mov    %edx,0xc(%rax)
mov    0x0(%rip),%edx        # 662 <history_get_history_state+0x30>
mov    %edx,0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
history_get_history_state ()
{
  HISTORY_STATE *state;
  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
  state->entries = the_history;
  state->offset = history_offset;
  state->length = history_length;
  state->size = history_size;
  return (state);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 7
9 7
10 8
11 8
12 10
13 10
<<<sep_out_sample>>>
sub    $0x88,%rsp
test   %rdi,%rdi
je     55e <signal_unblock+0x20>
mov    $0x0,%edx
mov    %rdi,%rsi
mov    $0x2,%edi
callq  55c <signal_unblock+0x1e>
jmp    578 <signal_unblock+0x3a>
mov    %rsp,%rdi
callq  566 <signal_unblock+0x28>
mov    $0x0,%edx
mov    %rsp,%rsi
mov    $0x2,%edi
callq  578 <signal_unblock+0x3a>
add    $0x88,%rsp
retq   
<<<sep_in_sample>>>
signal_unblock (sigset_t * status)
{
  if (status)
    sigprocmask (2, status, 0);
  else
    {
      sigset_t empty;
      sigemptyset (&empty);
      sigprocmask (2, &empty, 0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 8
10 8
11 9
12 9
13 9
14 9
15 11
16 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x98a,%edx
mov    $0x0,%esi
mov    $0x11,%edi
callq  568f <ifs_firstchar+0x1d>
mov    %rax,%rbx
mov    0x0(%rip),%rdx        # 5699 <ifs_firstchar+0x27>
cmp    $0x1,%rdx
jne    56b6 <ifs_firstchar+0x44>
movzbl 0x0(%rip),%eax        # 56a6 <ifs_firstchar+0x34>
mov    %al,(%rbx)
movb   $0x0,0x1(%rbx)
test   %al,%al
setne  %al
movzbl %al,%eax
jmp    56d3 <ifs_firstchar+0x61>
mov    $0x0,%esi
mov    %rax,%rdi
callq  56c3 <ifs_firstchar+0x51>
mov    0x0(%rip),%rdx        # 56ca <ifs_firstchar+0x58>
mov    %edx,%eax
movslq %edx,%rdx
movb   $0x0,(%rbx,%rdx,1)
test   %rbp,%rbp
je     56db <ifs_firstchar+0x69>
mov    %eax,0x0(%rbp)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ifs_firstchar (lenp)
     int *lenp;
{
  char *ret;
  int len;
  ret = sh_xmalloc((16 + 1), "subst.c", 2442);
  if (ifs_firstc_len == 1)
    {
      ret[0] = ifs_firstc[0];
      ret[1] = '\0';
      len = ret[0] ? 1 : 0;
    }
  else
    {
      memcpy (ret, ifs_firstc, ifs_firstc_len);
      ret[len = ifs_firstc_len] = '\0';
    }
  if (lenp)
    *lenp = len;
  return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 7
13 9
14 9
15 10
16 11
17 11
18 11
19 11
20 15
21 15
22 15
23 16
24 16
25 16
26 16
27 18
28 18
29 19
30 21
31 21
32 21
33 21
34 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  23a <gsl_vector_fscanf+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_fscanf (FILE * stream, gsl_vector * v)
{
  int status = gsl_block_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
mov    0x38(%rdi),%rbx
mov    0x20(%rbx),%rsi
test   %rsi,%rsi
je     23 <__bt_fd+0x23>
mov    $0x0,%edx
mov    (%rbx),%rdi
callq  1b <__bt_fd+0x1b>
movq   $0x0,0x20(%rbx)
testb  $0x1,0x27c(%rbx)
je     3e <__bt_fd+0x3e>
callq  31 <__bt_fd+0x31>
movl   $0x2,(%rax)
mov    $0xffffffff,%eax
jmp    44 <__bt_fd+0x44>
mov    0x200(%rbx),%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
__bt_fd(dbp)
        const DB *dbp;
{
 BTREE *t;
 t = dbp->internal;
 if (t->bt_pinned != ((void *)0)) {
  mpool_put(t->bt_mp, t->bt_pinned, 0);
  t->bt_pinned = ((void *)0);
 }
 if (((t)->flags & (0x00001))) {
  (*__errno_location ()) = 2;
  return (-1);
 }
 return (t->bt_fd);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 7
7 7
8 7
9 8
10 10
11 10
12 11
13 11
14 12
15 12
16 14
17 15
18 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x70(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->nx_add_after (list, node, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
mov    $0x1006,%eax
test   %rdi,%rdi
je     8ce <mu_mailbox_get_stream+0x3b>
mov    $0x5,%al
test   %rsi,%rsi
je     8ce <mu_mailbox_get_stream+0x3b>
mov    0x20(%rdi),%rax
test   %rax,%rax
jne    8c1 <mu_mailbox_get_stream+0x2e>
mov    0x38(%rdi),%rdi
test   %rdi,%rdi
je     8c1 <mu_mailbox_get_stream+0x2e>
sub    $0x8,%rsp
callq  8bf <mu_mailbox_get_stream+0x2c>
jmp    8ca <mu_mailbox_get_stream+0x37>
mov    %rax,(%rsi)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailbox_get_stream (mu_mailbox_t mbox, mu_stream_t *pstream)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (pstream == ((void *)0))
    return (0x1000 +5);
  if (mbox->stream == ((void *)0))
    {
      if (mbox->folder)
 return mu_folder_get_stream (mbox->folder, pstream);
    }
  *pstream = mbox->stream;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 7
9 7
10 9
11 9
12 9
13 2
14 10
15 10
16 12
17 13
18 13
19 14
20 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
callq  1c8 <make_size_file_name>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     589 <write_size_file+0x65>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  550 <write_size_file+0x2c>
mov    %rax,%rbp
mov    $0x1,%r12d
test   %rax,%rax
je     57e <write_size_file+0x5a>
mov    %r13,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  573 <write_size_file+0x4f>
mov    %rbp,%rdi
callq  57b <write_size_file+0x57>
mov    $0x0,%r12b
mov    %rbx,%rdi
callq  586 <write_size_file+0x62>
mov    %r12d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
write_size_file (struct _amd_data *amd, mu_off_t size)
{
  FILE *fp;
  int rc;
  char *name = make_size_file_name (amd);
  if (!name)
    return 1;
  fp = fopen (name, "w");
  if (fp)
    {
      fprintf (fp, "%lu", (unsigned long) size);
      fclose (fp);
      rc = 0;
    }
  else
    rc = 1;
  free (name);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 7
10 6
11 6
12 8
13 8
14 8
15 8
16 16
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 12
25 12
26 13
27 17
28 17
29 18
30 19
31 19
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
cmpl   $0x0,0x0(%rip)        # db <yy_grecsdestruct+0x13>
je     129 <yy_grecsdestruct+0x61>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebx
mov    %rdx,%rbp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # f7 <yy_grecsdestruct+0x2f>
mov    $0x0,%eax
callq  101 <yy_grecsdestruct+0x39>
mov    %rbp,%rdx
mov    %ebx,%esi
mov    0x0(%rip),%rdi        # 10d <yy_grecsdestruct+0x45>
callq  14 <yy_grecs_symbol_print>
mov    0x0(%rip),%rsi        # 119 <yy_grecsdestruct+0x51>
mov    $0xa,%edi
callq  123 <yy_grecsdestruct+0x5b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
yy_grecsdestruct (const char *yy_grecsmsg, int yy_grecstype, YYSTYPE *yy_grecsvaluep)
{
  ((void) (yy_grecsvaluep));
  if (!yy_grecsmsg)
    yy_grecsmsg = "Deleting";
  do { if (yy_grecsdebug) { fprintf (stderr, "%s ", yy_grecsmsg); yy_grecs_symbol_print (stderr, yy_grecstype, yy_grecsvaluep); fprintf (stderr, "\n"); } } while ((0));
  switch (yy_grecstype)
    {
      default:
 break;
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 2
7 2
8 2
9 2
10 2
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <__rsinh+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rsinh (double r)
{
  return (sinh (r));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
movzbl (%rsi),%eax
cmp    %al,(%rdi)
jne    549 <check_selfref+0x23>
callq  53e <check_selfref+0x18>
mov    %eax,%edx
mov    $0x1,%eax
test   %edx,%edx
je     5bb <check_selfref+0x95>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  556 <check_selfref+0x30>
test   %eax,%eax
je     5bb <check_selfref+0x95>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  56c <check_selfref+0x46>
mov    %rax,%rbx
test   %rax,%rax
je     5a4 <check_selfref+0x7e>
movzbl (%rax),%eax
cmp    %al,0x0(%rbp)
jne    5a4 <check_selfref+0x7e>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  587 <check_selfref+0x61>
test   %eax,%eax
jne    5a4 <check_selfref+0x7e>
mov    $0x10f,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  59d <check_selfref+0x77>
mov    $0x1,%eax
jmp    5bb <check_selfref+0x95>
mov    $0x112,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  5b6 <check_selfref+0x90>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
check_selfref (name, value, flags)
     const char *name;
     const char *value;
     int flags;
{
  char *t;
  if (((name)[0] == (value)[0] && strcmp(name, value) == 0))
    return 1;
  if (valid_array_reference (value, 0))
    {
      t = array_variable_name (value, (char **)((void *)0), (int *)((void *)0));
      if (t && ((name)[0] == (t)[0] && strcmp(name, t) == 0))
 {
   sh_xfree((t), "general.c", 271);
   return 1;
 }
      sh_xfree((t), "general.c", 274);
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 8
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 14
37 14
38 15
39 15
40 17
41 17
42 17
43 17
44 19
45 20
46 20
47 20
48 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x0,%ecx
mov    $0x8,%edx
callq  a4 <xdr_simx_entity_type_attr+0x1b>
mov    $0x0,%edx
test   %eax,%eax
je     c5 <xdr_simx_entity_type_attr+0x3c>
lea    0x8(%rbp),%rsi
mov    $0x100,%dx
mov    %rbx,%rdi
callq  bd <xdr_simx_entity_type_attr+0x34>
test   %eax,%eax
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xdr_simx_entity_type_attr (XDR *xdrs, simx_entity_type_attr *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->type, sizeof (dis_entity_type), (xdrproc_t) xdr_dis_entity_type))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->attr, 256))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
push   %rbx
callq  f2 <input_new>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 93c <guess+0x10>
mov    0x660(%rax),%rdx
mov    0x28(%rdx),%rcx
mov    0x30(%rdx),%rax
mov    -0x8(%rax,%rcx,8),%rcx
mov    0x18(%rcx),%rdx
mov    (%rcx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  966 <guess+0x3a>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     97d <guess+0x51>
cmp    0x0(%rip),%rdi        # 976 <guess+0x4a>
je     97d <guess+0x51>
callq  97d <guess+0x51>
pop    %rbx
retq   
<<<sep_in_sample>>>
guess (unsigned char * filename)
{
  buffer_t * buffer;
  struct file_job * file_job;
  buffer = input_new (filename);
  file_job = ((struct file_job *) (job->jobs->content[job->jobs->len - 1]));
  printf ("[%s (%s)]\n", file_job->name, file_job->type);
  if (buffer->stream && buffer->stream != stdin)
    fclose (buffer->stream);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 9
20 10
21 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  12f <delegation_table_new+0xb>
mov    %rax,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
mov    %rax,%rdi
callq  14f <delegation_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
delegation_table_new (void)
{
  struct hash_table_s *(res) = ((struct hash_table_s *) xmalloc (sizeof (struct hash_table_s) * (1)));
  hash_init (res, 8,
      delegate_hash_1, delegate_hash_2, delegate_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 7
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
callq  1745 <expbxor>
mov    %rax,%rbx
cmpl   $0x7c,0x0(%rip)        # 178c <expbor+0x10>
jne    17ae <expbor+0x32>
callq  2d7 <readtok>
callq  1745 <expbxor>
or     %rax,%rbx
movl   $0x6,0x0(%rip)        # 17a5 <expbor+0x29>
cmpl   $0x7c,0x0(%rip)        # 17ac <expbor+0x30>
je     178e <expbor+0x12>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
expbor ()
{
  register intmax_t val1, val2;
  val1 = expbxor ();
  while (curtok == '|')
    {
      readtok ();
      val2 = expbxor ();
      val1 = val1 | val2;
      lasttok = 6;
    }
  return (val1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 8
8 9
9 10
10 5
11 5
12 13
13 13
14 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2c7 <get_count+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_count(void *data)
{
    return dico_list_count((dico_list_t)data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  435 <wait_for_proc_all+0x9>
cmp    0x0(%rip),%eax        # 43b <wait_for_proc_all+0xf>
je     456 <wait_for_proc_all+0x2a>
mov    $0x0,%ecx
mov    $0x60c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  456 <wait_for_proc_all+0x2a>
cmpb   $0x0,0x0(%rip)        # 45d <wait_for_proc_all+0x31>
jne    497 <wait_for_proc_all+0x6b>
movb   $0x1,0x0(%rip)        # 466 <wait_for_proc_all+0x3a>
mov    $0x0,%esi
mov    $0x1,%edi
callq  201 <wait_for_proc>
movb   $0x0,0x0(%rip)        # 47c <wait_for_proc_all+0x50>
mov    0x0(%rip),%edx        # 482 <wait_for_proc_all+0x56>
mov    0x0(%rip),%eax        # 488 <wait_for_proc_all+0x5c>
cmp    %eax,%edx
je     497 <wait_for_proc_all+0x6b>
mov    0x0(%rip),%edi        # 492 <wait_for_proc_all+0x66>
callq  497 <wait_for_proc_all+0x6b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
wait_for_proc_all (void)
{
  static _Bool waiting = 0;
  ((getpid () == parent) ? (void) (0) : __assert_fail ("getpid () == parent", "xargs.c", 1548, __PRETTY_FUNCTION__));
  if (waiting)
    return;
  waiting = 1;
  wait_for_proc (1, 0u);
  waiting = 0;
  if (original_exit_value != child_error)
    {
      _exit (child_error);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 7
13 8
14 8
15 8
16 9
17 10
18 10
19 10
20 10
21 12
22 12
23 14
24 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x78(%rdi),%rdi
mov    $0x9,%esi
callq  4d <mu_nntp_debug_cmd+0x12>
test   %eax,%eax
je     96 <mu_nntp_debug_cmd+0x5b>
cmpl   $0x0,0x0(%rip)        # 58 <mu_nntp_debug_cmd+0x1d>
je     7b <mu_nntp_debug_cmd+0x40>
mov    0x78(%rbx),%rdi
mov    $0x2a,%edx
mov    $0x0,%esi
callq  6d <mu_nntp_debug_cmd+0x32>
mov    0x78(%rbx),%rdi
mov    $0x0,%esi
callq  7b <mu_nntp_debug_cmd+0x40>
mov    0x78(%rbx),%rdi
mov    (%rbx),%rcx
mov    $0x0,%edx
mov    $0x9,%esi
mov    $0x0,%eax
callq  96 <mu_nntp_debug_cmd+0x5b>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_nntp_debug_cmd (mu_nntp_t nntp)
{
  do { if (mu_debug_check_level (nntp->debug, 9)) do { if (mu_debug_line_info) { mu_debug_set_locus (nntp->debug, "nntp_debug.c", 42); mu_debug_set_function (nntp->debug, __FUNCTION__); } mu_debug_printf (nntp->debug, 9, "%s", nntp->io.buf); } while (0); } while(0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 5
24 5
25 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%eax        # 526 <help_line_len+0x13>
mov    $0x18,%r12d
cmp    $0x18,%eax
jle    538 <help_line_len+0x25>
lea    -0x1(%rax),%r12d
movslq %r12d,%r12
cmp    %rbp,0x0(%rip)        # 53f <help_line_len+0x2c>
jbe    54d <help_line_len+0x3a>
cmp    $0x4b,%eax
mov    $0x4a,%eax
cmovge %rax,%r12
mov    $0x1,%edx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  55d <help_line_len+0x4a>
mov    %rax,%r13
movzbl 0x0(%rbp),%edx
cmp    $0xa,%dl
je     590 <help_line_len+0x7d>
test   %dl,%dl
je     590 <help_line_len+0x7d>
mov    $0x0,%ebx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  57d <help_line_len+0x6a>
mov    %rax,%rbx
movzbl 0x0(%rbp,%rax,1),%edx
cmp    $0xa,%dl
je     595 <help_line_len+0x82>
test   %dl,%dl
jne    572 <help_line_len+0x5f>
jmp    595 <help_line_len+0x82>
mov    $0x0,%ebx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  5a0 <help_line_len+0x8d>
add    $0x1,%r12
cmp    %r12,%rax
jbe    5b5 <help_line_len+0xa2>
test   %r13,%r13
mov    $0x0,%ebx
cmovg  %r13,%rbx
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
help_line_len(const char *ptr)
{
    size_t wrapping_point = (COLS > 24) ? COLS - 1 : 24;
    ssize_t wrap_location;
    size_t length = 0;
    if (ptr < end_of_intro && COLS > 74)
 wrapping_point = 74;
    wrap_location = break_line(ptr, wrapping_point, 1);
    while (*(ptr + length) != '\0' && *(ptr + length) != '\n')
 length = move_mbright(ptr, length);
    if (strnlenpt(ptr, length) <= wrapping_point + 1)
 return length;
    else if (wrap_location > 0)
 return wrap_location;
    else
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 6
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 5
29 10
30 10
31 10
32 10
33 9
34 9
35 9
36 9
37 9
38 9
39 5
40 11
41 11
42 11
43 11
44 11
45 11
46 14
47 14
48 14
49 17
50 17
51 17
52 17
53 17
54 17
55 17
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 37 <swap_chars+0x6>
mov    0x0(%rip),%edx        # 3d <swap_chars+0xc>
mov    %edx,0x0(%rip)        # 43 <swap_chars+0x12>
mov    %eax,0x0(%rip)        # 49 <swap_chars+0x18>
retq   
<<<sep_in_sample>>>
swap_chars()
{
  int tmp;
  tmp = sel_range_end.nchar;
  sel_range_end.nchar = sel_range_start.nchar;
  sel_range_start.nchar = tmp;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  9c5 <gsl_sf_bessel_y0+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     9eb <gsl_sf_bessel_y0+0x32>
mov    %eax,%ecx
mov    $0x112,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9e4 <gsl_sf_bessel_y0+0x2b>
movsd  (%rsp),%xmm0
jmp    9eb <gsl_sf_bessel_y0+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_y0(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_y0_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_y0_e(x, &result)", "bessel_y.c", 274, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
mov    (%rdi),%r8d
mov    0x4(%rdi),%esi
movslq %esi,%rax
lea    (%rdi,%rax,8),%rcx
movslq %r8d,%rax
mov    0x8(%rdi,%rax,8),%rdx
sub    0x8(%rcx),%rdx
lea    0x7fff(%rdx),%rax
test   %rdx,%rdx
cmovs  %rax,%rdx
mov    %rdx,%rax
mov    %rdx,0x8(%rcx)
test   %r8d,%r8d
jne    3b <uni_get+0x3b>
movl   $0x10,(%rdi)
jmp    42 <uni_get+0x42>
sub    $0x1,%r8d
mov    %r8d,(%rdi)
test   %esi,%esi
jne    4e <uni_get+0x4e>
movl   $0x10,0x4(%rdi)
retq   
sub    $0x1,%esi
mov    %esi,0x4(%rdi)
retq   
<<<sep_in_sample>>>
uni_get (void *vstate)
{
  uni_state_t *state = (uni_state_t *) vstate;
  const int i = state->i;
  const int j = state->j;
  long k = state->m[i] - state->m[j];
  if (k < 0)
    k += m1;
  state->m[j] = k;
  if (i == 0)
    {
      state->i = 16;
    }
  else
    {
      (state->i)--;
    }
  if (j == 0)
    {
      state->j = 16;
    }
  else
    {
      (state->j)--;
    }
  return k;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
7 7
8 8
9 8
10 8
11 9
12 9
13 10
14 10
15 12
16 12
17 16
18 16
19 18
20 18
21 20
22 20
23 24
24 24
25 27
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    $0x0,%ebx
cmp    $0x3,%edi
jne    887c <call_match+0x25>
mov    0x0(%rip),%rax        # 886e <call_match+0x17>
lea    -0x8(%rax),%rdx
mov    %rdx,0x0(%rip)        # 8879 <call_match+0x22>
mov    (%rax),%rbx
mov    0x0(%rip),%rax        # 8883 <call_match+0x2c>
lea    -0x8(%rax),%rdx
mov    %rdx,0x0(%rip)        # 888e <call_match+0x37>
mov    (%rax),%rsi
mov    $0x2,%edi
callq  889b <call_match+0x44>
mov    %rax,%r12
mov    0x0(%rip),%rdx        # 88a5 <call_match+0x4e>
cmp    0x0(%rip),%rdx        # 88ac <call_match+0x55>
jae    88be <call_match+0x67>
add    $0x8,%rdx
mov    %rdx,0x0(%rip)        # 88b9 <call_match+0x62>
mov    %rdx,%rax
jmp    88c3 <call_match+0x6c>
callq  88c3 <call_match+0x6c>
mov    %r12,(%rax)
test   %rbx,%rbx
je     88f0 <call_match+0x99>
mov    0x0(%rip),%rax        # 88d2 <call_match+0x7b>
cmp    0x0(%rip),%rax        # 88d9 <call_match+0x82>
jae    88e8 <call_match+0x91>
add    $0x8,%rax
mov    %rax,0x0(%rip)        # 88e6 <call_match+0x8f>
jmp    88ed <call_match+0x96>
callq  88ed <call_match+0x96>
mov    %rbx,(%rax)
mov    %ebp,%edi
callq  88f7 <call_match+0xa0>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
call_match(int nargs)
{
 NODE *regex, *text, *array;
 NODE *result;
 regex = text = array = ((void *)0);
 if (nargs == 3)
  array = ((stack_ptr--)->rptr);
 regex = ((stack_ptr--)->rptr);
 regex = make_regnode(Node_regex, regex);
 (void) (((stack_ptr < stack_top) ? ++stack_ptr : grow_stack())->rptr = (regex));
 if (array)
  (void) (((stack_ptr < stack_top) ? ++stack_ptr : grow_stack())->rptr = (array));
 result = do_match(nargs);
 return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 13
39 13
40 15
41 15
42 15
43 15
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r14
push   %r13
push   %r12
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,-0x28(%rbp)
xor    %eax,%eax
cmp    %rsi,%rdi
jne    11f <expand_argument+0x35>
mov    $0x0,%edi
callq  11a <expand_argument+0x30>
jmpq   1a3 <expand_argument+0xb9>
test   %rsi,%rsi
je     129 <expand_argument+0x3f>
cmpb   $0x0,(%rsi)
jne    138 <expand_argument+0x4e>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  136 <expand_argument+0x4c>
jmp    1a3 <expand_argument+0xb9>
sub    %rdi,%rsi
mov    %rsi,%r12
lea    0x1(%rsi),%rax
cmp    $0x3e8,%rax
jle    15a <expand_argument+0x70>
lea    0x1(%rsi),%edi
callq  152 <expand_argument+0x68>
mov    %rax,%r13
mov    %rax,%r14
jmp    174 <expand_argument+0x8a>
add    $0x1e,%rax
and    $0xfffffffffffffff0,%rax
sub    %rax,%rsp
lea    0xf(%rsp),%r13
and    $0xfffffffffffffff0,%r13
mov    $0x0,%r14d
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %r13,%rdi
callq  182 <expand_argument+0x98>
movb   $0x0,0x0(%r13,%r12,1)
mov    $0x0,%esi
mov    %r13,%rdi
callq  195 <expand_argument+0xab>
mov    %rax,%rbx
mov    %r14,%rdi
callq  1a0 <expand_argument+0xb6>
mov    %rbx,%rax
mov    -0x28(%rbp),%rcx
xor    %fs:0x28,%rcx
je     1b7 <expand_argument+0xcd>
callq  1b7 <expand_argument+0xcd>
lea    -0x20(%rbp),%rsp
pop    %rbx
pop    %r12
pop    %r13
pop    %r14
pop    %rbp
retq   
<<<sep_in_sample>>>
expand_argument (const char *str, const char *end)
{
  char *tmp, *alloc = ((void *)0);
  char *r;
  if (str == end)
    return xstrdup ("");
  if (!end || *end == '\0')
    return allocated_variable_expand_for_file (str, (struct file *) 0);
  if (end - str + 1 > 1000)
    tmp = alloc = xmalloc (end - str + 1);
  else
    tmp = __builtin_alloca (end - str + 1);
  memcpy (tmp, str, end - str);
  tmp[end - str] = '\0';
  r = allocated_variable_expand_for_file (tmp, (struct file *) 0);
  free (alloc);
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 12
36 12
37 12
38 12
39 12
40 3
41 13
42 13
43 13
44 13
45 14
46 15
47 15
48 15
49 15
50 16
51 16
52 17
53 18
54 18
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 18
63 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  551 <dispose_function_def_contents+0xd>
mov    0x10(%rbx),%rdi
callq  55a <dispose_function_def_contents+0x16>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     572 <dispose_function_def_contents+0x2e>
mov    $0xe9,%edx
mov    $0x0,%esi
callq  572 <dispose_function_def_contents+0x2e>
pop    %rbx
retq   
<<<sep_in_sample>>>
dispose_function_def_contents (c)
     FUNCTION_DEF *c;
{
  dispose_word (c->name);
  dispose_command (c->command);
  do { if (c->source_file) sh_xfree((c->source_file), "dispose_cmd.c", 233); } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 480 <_rl_set_the_line+0x7>
mov    %rax,0x0(%rip)        # 487 <_rl_set_the_line+0xe>
retq   
<<<sep_in_sample>>>
_rl_set_the_line ()
{
  the_line = rl_line_buffer;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
movsbl %dil,%eax
sub    $0x30,%eax
cmp    $0x9,%eax
jbe    31 <__rlowten+0x31>
lea    -0x2b(%rdi),%eax
cmp    $0x3,%al
jbe    31 <__rlowten+0x31>
cmp    $0x7f,%dil
je     31 <__rlowten+0x31>
cmp    $0x1f,%dil
jle    31 <__rlowten+0x31>
movsbl %dil,%edi
callq  2b <__rlowten+0x2b>
cmp    $0x7f,%rax
jle    3b <__rlowten+0x3b>
mov    $0x0,%edi
callq  3b <__rlowten+0x3b>
movzbl 0x0(%rip),%eax        # 42 <__rlowten+0x42>
mov    %bl,0x0(%rip)        # 48 <__rlowten+0x48>
pop    %rbx
retq   
<<<sep_in_sample>>>
__rlowten (char c)
{
  char s;
  if (isdigit (c) || c == '+' || c == '-'
      || c == '.' || c == ',' || c == 127 || c < 32
      || __risorank (c) > 127)
    __rerror ("Lowten: Illegal character");
  s = __currentlowten;
  __currentlowten = c;
  return (s);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 8
21 9
22 11
23 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  bb74 <_x87_bunlei_f+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  aeed <_x87_movi_f>
mov    0x0(%r12),%r8d
and    $0x7fff,%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    $0x6,%esi
mov    %rbx,%rdi
callq  1b28 <_x87jcc>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  bbcc <_x87_bunlei_f+0x7c>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_bunlei_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x6, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%r13
mov    %rcx,%rbp
test   %rsi,%rsi
je     1c4 <assign_locus+0x47>
test   %rcx,%rcx
je     1b9 <assign_locus+0x3c>
mov    (%rdi),%rsi
test   %rsi,%rsi
je     1b1 <assign_locus+0x34>
mov    %r12,%rdi
callq  1ad <assign_locus+0x30>
test   %eax,%eax
je     1b9 <assign_locus+0x3c>
movq   $0x0,0x0(%rbp)
mov    %r12,%rdi
callq  1c1 <assign_locus+0x44>
mov    %rax,(%rbx)
mov    $0xa,%edx
lea    0x8(%rsp),%rsi
mov    %r13,%rdi
callq  1d6 <assign_locus+0x59>
test   %rbp,%rbp
je     1e0 <assign_locus+0x63>
mov    0x0(%rbp),%edx
jmp    1e5 <assign_locus+0x68>
mov    $0x0,%edx
sub    %edx,%eax
mov    %eax,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
setne  %al
movzbl %al,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
assign_locus(struct grecs_locus_point *ploc,
      char *name, char *line, size_t *pxlines)
{
 char *p;
 if (name) {
  if (pxlines && (!ploc->file || strcmp(name, ploc->file)))
   *pxlines = 0;
  ploc->file = grecs_install_text(name);
 }
 ploc->line = strtoul(line, &p, 10) - (pxlines ? *pxlines : 0);
 ploc->col = 0;
 return *p != 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 8
23 8
24 8
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 11
37 12
38 12
39 12
40 12
41 13
42 13
43 13
44 13
45 13
46 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    0x8(%rsi),%rcx
test   %rcx,%rcx
je     d19 <pred_samefile+0x20>
mov    $0x0,%eax
cmp    0x38(%rdx),%rcx
jne    d52 <pred_samefile+0x59>
mov    %rbx,%rdx
mov    0x0(%rip),%rsi        # d23 <pred_samefile+0x2a>
callq  d28 <pred_samefile+0x2f>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    d52 <pred_samefile+0x59>
mov    $0x0,%eax
mov    0x38(%rbp),%rsi
cmp    %rsi,0x8(%rbx)
jne    d4f <pred_samefile+0x56>
mov    0x40(%rbp),%rax
cmp    %rax,(%rbx)
sete   %al
movzbl %al,%eax
and    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pred_samefile (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  if (stat_buf->st_ino)
    {
      if (stat_buf->st_ino != pred_ptr->args.samefileid.ino)
 return 0;
    }
  if (0 == get_statinfo (pathname, state.rel_pathname, stat_buf))
    {
      return stat_buf->st_ino == pred_ptr->args.samefileid.ino
 && stat_buf->st_dev == pred_ptr->args.samefileid.dev;
    }
  else
    {
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 7
10 6
11 6
12 9
13 9
14 9
15 9
16 16
17 9
18 9
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 11
28 18
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rdi,%rbp
test   %rdi,%rdi
je     5b <locale_to_utf8+0x5b>
mov    $0xe,%edi
callq  1b <locale_to_utf8+0x1b>
mov    $0x0,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  2b <locale_to_utf8+0x2b>
mov    %rax,%rbp
test   %rax,%rax
jne    53 <locale_to_utf8+0x53>
mov    0x0(%rip),%rcx        # 3a <locale_to_utf8+0x3a>
mov    $0x2e,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  4e <locale_to_utf8+0x4e>
mov    %rbx,%rbp
jmp    5b <locale_to_utf8+0x5b>
mov    %rbx,%rdi
callq  5b <locale_to_utf8+0x5b>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
locale_to_utf8 (char *str)
{
  if (str)
    {
      char *from = nl_langinfo (CODESET);
      char *q = str_iconv (str, from, "UTF-8");
      if (!q)
 fprintf (stderr, "warning: Could not convert string to UTF-8...\n");
      else
 {
   free (str);
   str = q;
 }
    }
  return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 11
25 11
26 16
27 16
28 16
29 16
30 16
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
mov    $0x0,%esi
callq  737 <_rl_nsearch_cleanup+0xd>
movq   $0x0,0x0(%rip)        # 742 <_rl_nsearch_cleanup+0x18>
andq   $0xfffffffffffffeff,0x0(%rip)        # 74d <_rl_nsearch_cleanup+0x23>
cmp    $0x1,%ebx
setne  %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_nsearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;
  (rl_readline_state &= ~(0x0000100));
  return (r != 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     4f3 <gsl_vector_int_memcpy+0x29>
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4ec <gsl_vector_int_memcpy+0x22>
mov    $0x13,%eax
jmp    544 <gsl_vector_int_memcpy+0x7a>
mov    0x8(%rsi),%r11
mov    0x8(%rdi),%rbx
test   %r10,%r10
je     538 <gsl_vector_int_memcpy+0x6e>
shl    $0x2,%rbx
shl    $0x2,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    0x10(%rsi),%r8
mov    (%r8,%rcx,1),%r9d
mov    0x10(%rdi),%r8
mov    %r9d,(%r8,%rdx,1)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    517 <gsl_vector_int_memcpy+0x4d>
jmp    53f <gsl_vector_int_memcpy+0x75>
mov    $0x0,%eax
jmp    544 <gsl_vector_int_memcpy+0x7a>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_int_memcpy (gsl_vector_int * dest,
                               const gsl_vector_int * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 11
13 12
14 14
15 14
16 19
17 20
18 20
19 20
20 14
21 20
22 20
23 20
24 20
25 14
26 14
27 14
28 14
29 14
30 14
31 24
32 24
33 24
34 25
35 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r8
movzwl (%r8),%edi
test   %rbp,%rbp
je     1e5a <gsl_matrix_ushort_min_index+0x65>
add    %r12,%r12
mov    $0x0,%r10d
mov    $0x0,%r11d
mov    $0x0,%ebx
jmp    1e4e <gsl_matrix_ushort_min_index+0x59>
movzwl (%r8,%rax,2),%ecx
cmp    %di,%cx
jae    1e39 <gsl_matrix_ushort_min_index+0x44>
mov    %rax,%r11
mov    %r10,%rbx
mov    %ecx,%edi
add    $0x1,%rax
cmp    %r9,%rax
jne    1e27 <gsl_matrix_ushort_min_index+0x32>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
je     1e65 <gsl_matrix_ushort_min_index+0x70>
test   %r9,%r9
je     1e42 <gsl_matrix_ushort_min_index+0x4d>
mov    $0x0,%eax
jmp    1e27 <gsl_matrix_ushort_min_index+0x32>
mov    $0x0,%r11d
mov    $0x0,%ebx
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_min_index (const gsl_matrix_ushort * m, size_t * imin_out, size_t *jmin_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned short min = m->data[0 * tda + 0];
  size_t imin = 0, jmin = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned short x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 5
7 6
8 6
9 9
10 9
11 9
12 9
13 7
14 7
15 7
16 13
17 14
18 14
19 14
20 14
21 16
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 7
34 7
35 22
36 23
37 24
38 24
39 24
40 24
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,0x8(%rsp)
mov    %rdx,%r14
mov    %rcx,%r15
mov    $0xffffffffffffffff,%r13
mov    $0x0,%r12d
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rbp
lea    (%rcx,%r13,1),%rax
mov    %rax,(%rsp)
mov    %rbx,%rsi
mov    $0x0,%edi
callq  3d8 <get_args+0x4c>
mov    $0x0,%edi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x20,0x0(%rcx)
mov    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  400 <get_args+0x74>
mov    $0xc7,%esi
sub    (%rsp),%esi
lea    0x0(%rbp),%rdi
mov    0x0(%rip),%rdx        # 416 <get_args+0x8a>
callq  41b <get_args+0x8f>
test   %rax,%rax
je     437 <get_args+0xab>
callq  28a <makeargv>
mov    0x0(%rip),%eax        # 42b <get_args+0x9f>
mov    %eax,(%r14)
movq   $0x0,(%r15)
jmp    444 <get_args+0xb8>
mov    (%r15),%rax
mov    %rbx,(%rax)
movl   $0x1,(%r14)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
get_args (char *arg0, char *prompt, int *argc, char ***argv)
{
  size_t arg0_len = strlen (arg0);
  strcpy (line, arg0);
  strcat (line, " ");
  printf ("%s", prompt);
  if (fgets (line + arg0_len + 1, sizeof line - arg0_len - 1, stdin))
    {
      makeargv ();
      *argc = margc;
      *argv = margv;
    }
  else
    {
      *argv[0] = arg0;
      *argc = 1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 9
41 10
42 10
43 11
44 11
45 15
46 15
47 16
48 18
49 18
50 18
51 18
52 18
53 18
54 18
55 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    (%rdi),%rbx
test   %rbx,%rbx
je     235 <grecs_list_clear+0x34>
mov    (%rbx),%rbp
mov    0x20(%r12),%rax
test   %rax,%rax
je     223 <grecs_list_clear+0x22>
mov    0x10(%rbx),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  22b <grecs_list_clear+0x2a>
test   %rbp,%rbp
je     235 <grecs_list_clear+0x34>
mov    %rbp,%rbx
jmp    210 <grecs_list_clear+0xf>
movq   $0x0,0x8(%r12)
movq   $0x0,(%r12)
movq   $0x0,0x10(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_list_clear(struct grecs_list *lp)
{
 struct grecs_list_entry *ep = lp->head;
 while (ep) {
  struct grecs_list_entry *next = ep->next;
  if (lp->free_entry)
   lp->free_entry(ep->data);
  grecs_free(ep);
  ep = next;
 }
 lp->head = lp->tail = ((void *)0);
 lp->count = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 5
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 4
17 4
18 9
19 9
20 11
21 11
22 12
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    $0x0,%eax
jmp    a62 <swlib_tr+0x15>
movsbl %cl,%ecx
cmp    %edx,%ecx
jne    a62 <swlib_tr+0x15>
mov    %sil,-0x1(%rdi)
add    $0x1,%eax
add    $0x1,%rdi
movzbl -0x1(%rdi),%ecx
test   %cl,%cl
jne    a54 <swlib_tr+0x7>
repz retq 
<<<sep_in_sample>>>
swlib_tr(char * src, int to, int from)
{
 int ret = 0;
 char * p1;
 p1 = src;
 while (*(p1++)) {
  if (*(p1 - 1) == from) {
   *(p1 - 1) = to;
   ret ++;
  }
 }
 return ret;
}
<<<sep_in_sample>>>
1 3
2 6
3 7
4 7
5 7
6 8
7 9
8 6
9 6
10 6
11 6
12 13
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     40df <gsl_matrix_char_scale+0x5a>
mov    $0x0,%r8d
mov    $0x0,%r9d
jmp    40d1 <gsl_matrix_char_scale+0x4c>
mov    %rax,%rdx
add    0x18(%rdi),%rdx
movsbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
add    $0x1,%rax
cmp    %rax,%rsi
jne    40a4 <gsl_matrix_char_scale+0x1f>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
je     40df <gsl_matrix_char_scale+0x5a>
test   %r10,%r10
je     40c5 <gsl_matrix_char_scale+0x40>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
jmp    40a4 <gsl_matrix_char_scale+0x1f>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_scale (gsl_matrix_char * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 9
28 9
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
cmpq   $0x0,(%rdi)
je     ab2 <rec_db_get_rset_by_type+0x61>
mov    %rsi,%r13
mov    $0x0,%esi
mov    $0x0,%ebx
mov    %r12,%rdi
callq  a79 <rec_db_get_rset_by_type+0x28>
mov    %rax,%rbp
mov    %rax,%rdi
callq  a84 <rec_db_get_rset_by_type+0x33>
test   %rax,%rax
jne    a92 <rec_db_get_rset_by_type+0x41>
test   %r13,%r13
jne    aa6 <rec_db_get_rset_by_type+0x55>
xchg   %ax,%ax
jmp    ab7 <rec_db_get_rset_by_type+0x66>
test   %r13,%r13
je     aa6 <rec_db_get_rset_by_type+0x55>
mov    %r13,%rsi
mov    %rax,%rdi
callq  aa2 <rec_db_get_rset_by_type+0x51>
test   %eax,%eax
je     ab7 <rec_db_get_rset_by_type+0x66>
add    $0x1,%ebx
movslq %ebx,%rsi
cmp    (%r12),%rsi
jb     a71 <rec_db_get_rset_by_type+0x20>
mov    $0x0,%ebp
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
rec_db_get_rset_by_type (rec_db_t db,
                         const char *type)
{
  int i;
  rec_rset_t rset;
  _Bool found;
  char *rtype;
  found = 0;
  for (i = 0; i < rec_db_size (db); i++)
    {
      rset = rec_db_get_rset (db, i);
      rtype = rec_rset_type (rset);
      if (rtype == ((void *)0))
        {
          if (type == ((void *)0))
            {
              found = 1;
              break;
            }
        }
      else
        {
          if ((type != ((void *)0))
              && (strcmp (rtype, type) == 0))
            {
              found = 1;
              break;
            }
        }
    }
  if (!found)
    {
      rset = ((void *)0);
    }
  return rset;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 9
8 9
9 9
10 9
11 9
12 11
13 11
14 11
15 12
16 12
17 13
18 13
19 15
20 15
21 15
22 15
23 23
24 23
25 24
26 24
27 24
28 24
29 24
30 9
31 9
32 9
33 9
34 33
35 36
36 36
37 36
38 36
39 36
40 36
41 36
<<<sep_out_sample>>>
mov    0x10(%rdi),%r8
mov    (%rdi),%rcx
mov    0x8(%rdi),%r9
cmp    %rsi,%rcx
jbe    2081 <gsl_vector_long_set_basis+0x27>
lea    0x0(,%r9,8),%rdi
mov    %r8,%rdx
mov    $0x0,%eax
test   %rcx,%rcx
jne    20a5 <gsl_vector_long_set_basis+0x4b>
jmp    20b8 <gsl_vector_long_set_basis+0x5e>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  209e <gsl_vector_long_set_basis+0x44>
mov    $0x4,%eax
jmp    20ce <gsl_vector_long_set_basis+0x74>
movq   $0x0,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    20a5 <gsl_vector_long_set_basis+0x4b>
shl    $0x3,%r9
imul   %r9,%rsi
movq   $0x1,(%r8,%rsi,1)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_long_set_basis (gsl_vector_long * v, size_t i)
{
  long * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const long zero = 0L ;
  const long one = 1L;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(long *) (data + 1 * k * stride) = zero;
    }
  *(long *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 9
5 9
6 15
7 15
8 15
9 13
10 13
11 13
12 2
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 15
21 13
22 13
23 13
24 13
25 17
26 17
27 17
28 18
29 18
30 19
31 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 3c3 <star_fixup_header+0xb>
lea    0x1c4(%rax),%rdi
mov    $0xc,%esi
callq  3d4 <star_fixup_header+0x1c>
mov    0x18(%rbx),%rdx
mov    0x88(%rdx),%rcx
mov    %rcx,0x118(%rdx)
mov    0x18(%rbx),%rdx
test   %rax,%rax
mov    $0x0,%ecx
cmovns %rax,%rcx
mov    %rcx,0x88(%rdx)
not    %rax
shr    $0x3f,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
star_fixup_header (struct tar_sparse_file *file)
{
  off_t realsize = off_from_header (current_header->star_in_header.realsize, sizeof (current_header->star_in_header.realsize));
  file->stat_info->archive_file_size = file->stat_info->stat.st_size;
  file->stat_info->stat.st_size = ((0) < (realsize) ? (realsize) : (0));
  return 0 <= realsize;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 7
18 7
<<<sep_out_sample>>>
mov    0xc(%rdi),%eax
retq   
<<<sep_in_sample>>>
window_columns(window)
    window_t *window;
{
    return window->columns;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1d0 <gsl_permute_vector_complex_long_double+0x2c>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c9 <gsl_permute_vector_complex_long_double+0x25>
mov    $0x13,%eax
jmp    1e6 <gsl_permute_vector_complex_long_double+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  1e1 <gsl_permute_vector_complex_long_double+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_complex_long_double (const gsl_permutation * p, gsl_vector_complex_long_double * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex_long_double (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x50(%r8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, start_index, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
cmp    $0x2,%edi
je     30c <main+0x23>
mov    (%rsi),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  305 <main+0x1c>
mov    $0x1,%eax
jmp    36c <main+0x83>
mov    0x8(%rsi),%rdi
callq  315 <main+0x2c>
movzwl %ax,%esi
movl   $0x0,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x5,%edi
mov    $0x0,%eax
callq  344 <main+0x5b>
mov    %rax,%rbx
test   %rax,%rax
je     367 <main+0x7e>
mov    0x0(%rip),%rdi        # 353 <main+0x6a>
callq  358 <main+0x6f>
mov    %rbx,%rdi
callq  360 <main+0x77>
mov    $0x0,%eax
jmp    36c <main+0x83>
mov    $0x1,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main (int argc, char *const *argv)
{
  struct MHD_Daemon *d;
  if (argc != 2)
    {
      printf ("%s PORT\n", argv[0]);
      return 1;
    }
  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_DEBUG,
                        atoi (argv[1]),
                        ((void *)0), ((void *)0), &ahc_echo, "<html><head><title>File not found</title></head><body>File not found</body></html>", MHD_OPTION_END);
  if (((void *)0) == d)
    return 1;
  (void) _IO_getc (stdin);
  MHD_stop_daemon (d);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 7
11 10
12 10
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 12
24 12
25 14
26 14
27 15
28 15
29 16
30 16
31 13
32 17
33 17
34 17
<<<sep_out_sample>>>
callq  c09 <IsParm+0x5>
cmp    $0x40000,%eax
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
IsParm (HVAR hvar)
{
  return (GetVarType(hvar) == 0x40000);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,0x10(%rsp)
mov    0x8(%rdi),%rax
mov    %rax,%rbx
mov    %rax,0x18(%rsp)
lea    0x1(%rax),%edi
movslq %edi,%rdi
mov    $0x8,%esi
callq  a72 <config_array_to_argv+0x35>
mov    %rax,%r15
test   %ebx,%ebx
jle    ad8 <config_array_to_argv+0x9b>
lea    -0x1(%rbx),%eax
lea    0x3(%rax,%rax,2),%r13
shl    $0x3,%r13
mov    $0x0,%ebx
mov    $0x0,%r14d
mov    %rbx,%rsi
add    0x10(%rbp),%rsi
mov    $0x0,%edx
mov    %r12,%rdi
callq  aa4 <config_array_to_argv+0x67>
test   %eax,%eax
jne    acd <config_array_to_argv+0x90>
lea    0x1(%r14),%eax
mov    %eax,0xc(%rsp)
movslq %r14d,%r14
lea    (%r15,%r14,8),%r14
mov    0x10(%rbp),%rax
mov    0x8(%rax,%rbx,1),%rdi
callq  ac5 <config_array_to_argv+0x88>
mov    %rax,(%r14)
mov    0xc(%rsp),%r14d
add    $0x18,%rbx
cmp    %r13,%rbx
jne    a90 <config_array_to_argv+0x53>
jmp    ade <config_array_to_argv+0xa1>
mov    $0x0,%r14d
movslq %r14d,%r14
movq   $0x0,(%r15,%r14,8)
mov    0x10(%rsp),%rcx
test   %rcx,%rcx
je     afb <config_array_to_argv+0xbe>
movslq 0x18(%rsp),%rax
mov    %rax,(%rcx)
mov    %r15,%rax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
config_array_to_argv (grecs_value_t *val, grecs_locus_t *locus, size_t *pargc)
{
  int i, j;
  int argc;
  char **argv;
  argc = val->v.arg.c;
  argv = xcalloc (argc + 1, sizeof (argv[0]));
  for (i = j = 0; i < argc; i++)
    {
      if (assert_grecs_value_type (locus, &val->v.arg.v[i], 0)
   == 0)
 argv[j++] = xstrdup (val->v.arg.v[i].v.string);
    }
  argv[j] = ((void *)0);
  if (pargc)
    *pargc = argc;
  return argv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 8
44 8
45 8
46 8
47 14
48 14
49 15
50 15
51 15
52 16
53 16
54 18
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 18
<<<sep_out_sample>>>
movabs $0x200000005,%rdx
mov    %rsi,%rax
mul    %rdx
mov    %rsi,%rax
sub    %rdx,%rax
shr    %rax
add    %rax,%rdx
shr    $0x1e,%rdx
mov    %rdx,%rax
shl    $0x1f,%rax
sub    %rdx,%rax
mov    %rsi,%rcx
sub    %rax,%rcx
mov    $0x1,%eax
cmove  %rax,%rsi
and    $0x7fffffff,%esi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if ((s%m) == 0)
    s = 1;
  state->x = s & m;
  return;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
lea    0x0(,%rsi,8),%rbx
mov    (%rdi),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  7c <rkck_reset+0x21>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  8d <rkck_reset+0x32>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  9e <rkck_reset+0x43>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  af <rkck_reset+0x54>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  c0 <rkck_reset+0x65>
mov    0x28(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  d1 <rkck_reset+0x76>
mov    0x38(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  e2 <rkck_reset+0x87>
mov    0x30(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  f3 <rkck_reset+0x98>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rkck_reset (void *vstate, size_t dim)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->k4),0,(dim)*sizeof(double));
  memset((state->k5),0,(dim)*sizeof(double));
  memset((state->k6),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 13
39 13
40 13
41 13
42 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # e10 <check_stdout+0xb>
callq  e15 <check_stdout+0x10>
test   %eax,%eax
je     e23 <check_stdout+0x1e>
mov    $0x0,%edi
callq  e23 <check_stdout+0x1e>
mov    0x0(%rip),%rdi        # e2a <check_stdout+0x25>
callq  e2f <check_stdout+0x2a>
test   %eax,%eax
je     e45 <check_stdout+0x40>
mov    $0x0,%edi
callq  e3d <check_stdout+0x38>
mov    %rax,%rdi
callq  e45 <check_stdout+0x40>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
check_stdout (void)
{
  if (ferror_unlocked (stdout))
    fatal ("write failed");
  else if (fclose (stdout) != 0)
    pfatal_with_name (gettext ("standard output"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 7
17 7
<<<sep_out_sample>>>
push   %rbx
test   %rdi,%rdi
je     7b <try_help+0x28>
mov    %rsi,%rbx
callq  61 <try_help+0xe>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  7b <try_help+0x28>
mov    0x0(%rip),%rbx        # 82 <try_help+0x2f>
mov    $0x0,%edi
callq  8c <try_help+0x39>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x2,%edi
mov    $0x0,%eax
callq  a6 <try_help+0x53>
callq  ab <diraccess>
<<<sep_in_sample>>>
try_help (char const *reason_msgid, char const *operand)
{
  if (reason_msgid)
    error (0, 0, gettext (reason_msgid), operand);
  error (2, 0, gettext ("Try '%s --help' for more information."),
  program_name);
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0x18,%edi
callq  7cc <gl_linked_add_after+0x17>
mov    %r12,0x10(%rax)
mov    %rbx,0x8(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
mov    %rax,(%rbx)
addq   $0x1,0x40(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_linked_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  gl_list_node_t new_node = ((struct gl_list_node_impl *) xmalloc (sizeof (struct gl_list_node_impl)));
  new_node->value = elt;
  new_node->prev = node;
  new_node->next = node->next;
  new_node->next->prev = new_node;
  node->next = new_node;
  list->count++;
  return new_node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 5
11 6
12 6
13 7
14 8
15 9
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     2ec <grecs_warning+0x58>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdx,%rsi
movq   $0x0,(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rsp,%rdi
callq  32b <grecs_warning+0x97>
mov    (%rsp),%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  33e <grecs_warning+0xaa>
mov    (%rsp),%rdi
callq  347 <grecs_warning+0xb3>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_warning(grecs_locus_t *locus, int errcode, const char *fmt, ...)
{
  va_list ap;
  char *buf = ((void *)0);
  __builtin_va_start(ap,fmt);
  vasprintf (&buf, fmt, ap);
  __builtin_va_end(ap);
  grecs_print_diag (locus, 0, errcode, buf);
  free(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 4
21 5
22 5
23 5
24 5
25 5
26 5
27 6
28 6
29 6
30 8
31 8
32 8
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %rdx,%r12
mov    %rcx,%rbp
mov    $0x0,%esi
callq  5a6 <gsasl_md5pwd_get_password+0x20>
mov    $0x5,%r8d
test   %rax,%rax
je     620 <gsasl_md5pwd_get_password+0x9a>
mov    %rax,%rdi
callq  5b9 <gsasl_md5pwd_get_password+0x33>
lea    0x8(%rsp),%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  5c9 <gsasl_md5pwd_get_password+0x43>
mov    %eax,%r8d
test   %eax,%eax
jne    620 <gsasl_md5pwd_get_password+0x9a>
mov    0x8(%rsp),%rbx
mov    %rbx,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
cmp    %rcx,0x0(%rbp)
jae    5fe <gsasl_md5pwd_get_password+0x78>
mov    %rbx,%rdi
callq  5f6 <gsasl_md5pwd_get_password+0x70>
mov    $0x4,%r8d
jmp    620 <gsasl_md5pwd_get_password+0x9a>
mov    %rdx,0x0(%rbp)
test   %r12,%r12
je     612 <gsasl_md5pwd_get_password+0x8c>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  612 <gsasl_md5pwd_get_password+0x8c>
mov    %rbx,%rdi
callq  61a <gsasl_md5pwd_get_password+0x94>
mov    $0x0,%r8d
mov    %r8d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsasl_md5pwd_get_password (const char *filename,
      const char *username, char *key, size_t * keylen)
{
  char *tmp;
  size_t tmplen;
  int res;
  FILE *fh;
  fh = fopen (filename, "r");
  if (fh == ((void *)0))
    return GSASL_FOPEN_ERROR;
  fclose (fh);
  res = gsasl_simple_getpass (filename, username, &tmp);
  if (res != GSASL_OK)
    return res;
  tmplen = strlen (tmp);
  if (*keylen < tmplen + 1)
    {
      free (tmp);
      return GSASL_TOO_SMALL_BUFFER;
    }
  *keylen = tmplen;
  if (key)
    memcpy (key, tmp, tmplen);
  free (tmp);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 8
11 8
12 10
13 9
14 9
15 11
16 11
17 12
18 12
19 12
20 12
21 14
22 13
23 13
24 15
25 15
26 15
27 15
28 15
29 15
30 16
31 16
32 18
33 18
34 19
35 19
36 21
37 22
38 22
39 23
40 23
41 23
42 24
43 24
44 25
45 26
46 26
47 26
48 26
49 26
50 26
51 26
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdx        # cb7 <two_arguments+0x8>
movslq 0x0(%rip),%rax        # cbe <two_arguments+0xf>
lea    0x0(,%rax,8),%rcx
mov    (%rdx,%rax,8),%rbx
movzbl (%rbx),%eax
cmp    $0x21,%al
jne    ce7 <two_arguments+0x38>
cmpb   $0x0,0x1(%rbx)
jne    d19 <two_arguments+0x6a>
mov    0x8(%rdx,%rcx,1),%rax
cmpb   $0x0,(%rax)
sete   %al
movzbl %al,%eax
jmp    d2e <two_arguments+0x7f>
cmp    $0x2d,%al
jne    d19 <two_arguments+0x6a>
cmpb   $0x0,0x2(%rbx)
jne    d19 <two_arguments+0x6a>
mov    %rbx,%rdi
callq  cf9 <two_arguments+0x4a>
test   %eax,%eax
je     d04 <two_arguments+0x55>
callq  be2 <unary_operator>
jmp    d2e <two_arguments+0x7f>
mov    $0x0,%edi
callq  d0e <two_arguments+0x5f>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  0 <test_syntax_error>
mov    $0x0,%edi
callq  d23 <two_arguments+0x74>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  0 <test_syntax_error>
pop    %rbx
retq   
<<<sep_in_sample>>>
two_arguments ()
{
  if (argv[pos][0] == '!' && argv[pos][1] == '\0')
    return (argv[pos + 1][0] == '\0');
  else if (argv[pos][0] == '-' && argv[pos][2] == '\0')
    {
      if (test_unop (argv[pos]))
 return (unary_operator ());
      else
 test_syntax_error (gettext("%s: unary operator expected"), argv[pos]);
    }
  else
    test_syntax_error (gettext("%s: unary operator expected"), argv[pos]);
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 13
32 13
33 13
34 13
35 13
36 15
37 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f7a <varunif+0x9>
cvtsi2sd %rax,%xmm0
divsd  0x0(%rip),%xmm0        # f87 <varunif+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
varunif()
{
  return ((double) random()) / randmax;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
callq  887 <insert_path_check>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_wholename (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_path_check (entry, argv, arg_ptr, "wholename", pred_path);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    $0x80,%esi
mov    $0x1,%edi
callq  9f <node_alloc+0x17>
mov    %rax,%rbx
mov    %ebp,(%rax)
movl   $0x1,0x4(%rax)
mov    0x0(%rip),%eax        # b1 <node_alloc+0x29>
mov    %eax,0x8(%rbx)
mov    0x0(%rip),%rax        # bb <node_alloc+0x33>
mov    %rax,0x10(%rbx)
cmp    $0x2,%ebp
jne    d2 <node_alloc+0x4a>
mov    $0x100,%edi
callq  ce <node_alloc+0x46>
mov    %rax,0x48(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
node_alloc (type)
     NodeType type;
{
  Node *n;
  n = (Node *) xcalloc (1, sizeof (*n));
  n->type = type;
  n->refcount = 1;
  n->linenum = linenum;
  n->filename = yyin_name;
  if (type == nREGEXP)
    n->u.re.compiled.fastmap = xmalloc (256);
  return n;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 6
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 11
20 13
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10 <xgetcwd+0x10>
mov    %rax,%rbx
test   %rax,%rax
jne    27 <xgetcwd+0x27>
callq  1d <xgetcwd+0x1d>
cmpl   $0xc,(%rax)
jne    27 <xgetcwd+0x27>
callq  27 <xgetcwd+0x27>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xgetcwd (void)
{
  char *cwd = getcwd (((void *)0), 0);
  if (! cwd && (*__errno_location ()) == 12)
    xalloc_die ();
  return cwd;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    (%rdi),%r8
test   %r8,%r8
je     70 <strtotok_len+0x70>
mov    %rsi,%r14
mov    %rdx,%rbp
mov    %rcx,%r15
mov    $0xffffffffffffffff,%r13
mov    $0x0,%r12d
mov    %r8,%rdi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %rbp,%rcx
jne    62 <strtotok_len+0x62>
mov    %rbp,%rdx
mov    %r14,%rsi
mov    %r8,%rdi
callq  54 <strtotok_len+0x54>
mov    %eax,%edx
test   %eax,%eax
jne    62 <strtotok_len+0x62>
mov    0x8(%rbx),%eax
mov    %eax,(%r15)
jmp    7c <strtotok_len+0x7c>
add    $0x10,%rbx
mov    (%rbx),%r8
test   %r8,%r8
jne    2f <strtotok_len+0x2f>
jmp    77 <strtotok_len+0x77>
mov    $0x1,%edx
jmp    7c <strtotok_len+0x7c>
mov    $0x1,%edx
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
strtotok_len (struct tokendef *tab, const char *str, size_t len, int *pres)
{
  for (; tab->name; tab++)
    {
      size_t kwlen = strlen (tab->name);
      if (kwlen == len && memcmp (tab->name, str, len) == 0)
 {
   *pres = tab->tok;
   return 0;
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 3
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 8
33 8
34 9
35 3
36 3
37 3
38 3
39 3
40 12
41 12
42 12
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%r8
mov    0x30(%rdi),%rcx
mov    $0x0,%edx
callq  3d <gl_array_sortedlist_indexof_from_to>
add    $0x1,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_array_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar,
                            const void *elt)
{
  size_t index =
    gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 6
7 7
8 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    0xe8(%rdx),%rax
mov    %rdi,%rsi
mov    (%rax),%rdi
callq  1a2 <is_ok>
test   %al,%al
je     afb <pred_ok+0x31>
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  afb <pred_ok+0x31>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
pred_ok (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    return impl_pred_exec (pathname, stat_buf, pred_ptr);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     e2 <printer_set+0x1b>
callq  e2 <printer_set+0x1b>
test   %r12,%r12
je     fd <printer_set+0x36>
mov    $0x0,%eax
cmpb   $0x0,(%r12)
je     102 <printer_set+0x3b>
mov    %r12,%rdi
callq  fb <printer_set+0x34>
jmp    102 <printer_set+0x3b>
mov    $0x0,%eax
mov    %rax,0x8(%rbx)
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     114 <printer_set+0x4d>
callq  114 <printer_set+0x4d>
test   %rbp,%rbp
je     12e <printer_set+0x67>
mov    $0x0,%eax
cmpb   $0x0,0x0(%rbp)
je     133 <printer_set+0x6c>
mov    %rbp,%rdi
callq  12c <printer_set+0x65>
jmp    133 <printer_set+0x6c>
mov    $0x0,%eax
mov    %rax,0x10(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
printer_set (struct printer *p,
      const char * ppdkey, const char * command)
{
  do { const char *my_s2 = (ppdkey); do { if (p->ppdkey) free (p->ppdkey); } while (0); p->ppdkey = !(((const char *) (my_s2) == ((void *)0)) || (*(my_s2) == '\0')) ? xstrdup (my_s2) : ((void *)0); } while (0);
  do { const char *my_s2 = (command); do { if (p->command) free (p->command); } while (0); p->command = !(((const char *) (my_s2) == ((void *)0)) || (*(my_s2) == '\0')) ? xstrdup (my_s2) : ((void *)0); } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 6
36 6
37 6
38 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    (%rdi),%rbx
test   %rbx,%rbx
je     e18 <rc_section_list_destroy+0x26>
mov    0x18(%rbx),%rbx
mov    %rbp,%rdi
callq  da8 <rc_section_destroy>
mov    %rbx,0x0(%rbp)
test   %rbx,%rbx
jne    e03 <rc_section_list_destroy+0x11>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rc_section_list_destroy (RC_SECTION **s)
{
  while (*s)
    {
      RC_SECTION *next = (*s)->next;
      rc_section_destroy (s);
      *s = next;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 6
10 6
11 7
12 3
13 3
14 9
15 9
16 9
17 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    0x0(%rip),%eax        # 3d7b <check_special+0x19>
mov    %eax,%edx
and    $0x8,%edx
cmp    $0x1,%edx
sbb    %r15d,%r15d
not    %r15d
and    $0x400,%r15d
and    $0x10,%eax
mov    %r15d,%edx
or     $0x2,%dh
test   %eax,%eax
cmovne %edx,%r15d
movsbl (%rdi),%r13d
mov    $0x44,%r12d
mov    $0x0,%ebp
lea    0x0(%rbp,%r12,1),%eax
mov    %eax,%ebx
shr    $0x1f,%ebx
add    %eax,%ebx
sar    %ebx
mov    %ebx,%r14d
movslq %ebx,%rax
lea    (%rax,%rax,4),%rax
mov    0x0(,%rax,8),%rsi
movsbl (%rsi),%eax
mov    %r13d,%ecx
sub    %eax,%ecx
mov    %ecx,%eax
jne    3de4 <check_special+0x82>
mov    0x8(%rsp),%rdi
callq  3de4 <check_special+0x82>
test   %eax,%eax
jns    3dee <check_special+0x8c>
lea    -0x1(%rbx),%r12d
jmp    3e11 <check_special+0xaf>
test   %eax,%eax
jle    3df7 <check_special+0x95>
lea    0x1(%rbx),%ebp
jmp    3e11 <check_special+0xaf>
movslq %r14d,%rax
lea    (%rax,%rax,4),%rax
and    0x0(,%rax,8),%r15d
mov    $0xffffffff,%eax
cmove  %r14d,%eax
jmp    3e1b <check_special+0xb9>
cmp    %ebp,%r12d
jge    3dae <check_special+0x4c>
mov    $0xffffffff,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
check_special(const char *name)
{
 int low, high, mid;
 int i;
 int non_standard_flags = 0;
 if ((do_flags & DO_TRADITIONAL))
  non_standard_flags |= 0x0400;
 if ((do_flags & DO_POSIX))
  non_standard_flags |= 0x0200;
 low = 0;
 high = (sizeof(tokentab) / sizeof(tokentab[0])) - 1;
 while (low <= high) {
  mid = (low + high) / 2;
  i = *name - tokentab[mid].operator[0];
  if (i == 0)
   i = strcmp(name, tokentab[mid].operator);
  if (i < 0)
   high = mid - 1;
  else if (i > 0)
   low = mid + 1;
  else {
   if ((tokentab[mid].flags & non_standard_flags) != 0)
    return -1;
   return mid;
  }
 }
 return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 6
12 5
13 5
14 5
15 5
16 8
17 9
18 9
19 9
20 9
21 14
22 11
23 10
24 13
25 13
26 13
27 13
28 13
29 13
30 14
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 16
39 16
40 17
41 17
42 18
43 18
44 19
45 19
46 20
47 20
48 22
49 22
50 22
51 23
52 23
53 23
54 12
55 12
56 27
57 28
58 28
59 28
60 28
61 28
62 28
63 28
64 28
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmp    %rsi,0x8(%rdi)
ja     12d5 <gsl_vector_alloc_col_from_matrix+0x32>
mov    $0x4,%ecx
mov    $0xd2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12ce <gsl_vector_alloc_col_from_matrix+0x2b>
mov    $0x0,%eax
jmp    1326 <gsl_vector_alloc_col_from_matrix+0x83>
mov    $0x28,%edi
callq  12df <gsl_vector_alloc_col_from_matrix+0x3c>
test   %rax,%rax
jne    1304 <gsl_vector_alloc_col_from_matrix+0x61>
mov    $0x8,%ecx
mov    $0xda,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12fd <gsl_vector_alloc_col_from_matrix+0x5a>
mov    $0x0,%eax
jmp    1326 <gsl_vector_alloc_col_from_matrix+0x83>
mov    0x18(%rbx),%rdx
lea    (%rdx,%rbp,8),%rdx
mov    %rdx,0x10(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x8(%rax)
movq   $0x0,0x18(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_alloc_col_from_matrix (gsl_matrix * m,
                                              const size_t j)
{
  gsl_vector * v;
  const size_t N = m->size2;
  if (j >= N)
    {
      do { gsl_error ("column index is out of range", "getset_source.c", 210, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector *) malloc (sizeof (gsl_vector));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 218
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * j ;
  v->size = m->size1;
  v->stride = m->tda;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 11
18 11
19 13
20 13
21 13
22 13
23 13
24 17
25 17
26 20
27 20
28 20
29 21
30 21
31 22
32 22
33 23
34 25
35 25
36 25
37 25
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r14
mov    %edx,%r12d
test   %edx,%edx
jle    83d <findvar+0x42>
mov    %rsi,%rbp
mov    $0x0,%ebx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  823 <findvar+0x28>
test   %eax,%eax
je     833 <findvar+0x38>
add    $0x1,%ebx
sub    $0xffffffffffffff80,%rbp
cmp    %r12d,%ebx
jne    818 <findvar+0x1d>
cmp    $0x1fe,%ebx
jg     854 <findvar+0x59>
jmp    842 <findvar+0x47>
mov    $0x0,%ebx
movslq %ebx,%rdi
shl    $0x7,%rdi
add    %r14,%rdi
mov    %r13,%rsi
callq  854 <findvar+0x59>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
findvar(char *varname, char var[][127 + 1], int nvars)
{
  int v;
  for (v = 0; v < nvars; v++)
    {
      if (!linecmp(varname, var[v]))
 break;
    }
  if (v < 512 - 1)
    strcpy(var[v], varname);
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 4
19 4
20 4
21 4
22 9
23 9
24 9
25 4
26 10
27 10
28 10
29 10
30 10
31 12
32 12
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %edi,%edi
js     92 <free_cwd+0xf>
callq  92 <free_cwd+0xf>
mov    0x8(%rbx),%rdi
callq  9b <free_cwd+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_cwd (struct saved_cwd *cwd)
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  free (cwd->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     78c <_movi+0xc>
callq  609 <_imovi>
repz retq 
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
repz retq 
<<<sep_in_sample>>>
_movi(jit_state_t *_jit, jit_int32_t r0, jit_word_t i0)
{
    if (i0)
 _imovi(_jit, r0, i0);
    else
 _alur(_jit, 6 << 3, r0, r0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 6
6 6
7 6
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  1e5 <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 8 <append_cmdarg+0x8>
jne    13 <append_cmdarg+0x13>
mov    %rdi,0x0(%rip)        # 11 <append_cmdarg+0x11>
jmp    1d <append_cmdarg+0x1d>
mov    0x0(%rip),%rax        # 1a <append_cmdarg+0x1a>
mov    %rdi,(%rax)
mov    %rdi,0x0(%rip)        # 24 <append_cmdarg+0x24>
retq   
<<<sep_in_sample>>>
append_cmdarg(CMDARG *arg)
{
 static CMDARG *savetail;
 if (arg_list == ((void *)0))
  arg_list = arg;
 else
  savetail->next = arg;
 savetail = arg;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     270 <gsl_sum_levin_u_free+0x3e>
mov    0x40(%rdi),%rdi
callq  244 <gsl_sum_levin_u_free+0x12>
mov    0x38(%rbx),%rdi
callq  24d <gsl_sum_levin_u_free+0x1b>
mov    0x30(%rbx),%rdi
callq  256 <gsl_sum_levin_u_free+0x24>
mov    0x28(%rbx),%rdi
callq  25f <gsl_sum_levin_u_free+0x2d>
mov    0x20(%rbx),%rdi
callq  268 <gsl_sum_levin_u_free+0x36>
mov    %rbx,%rdi
callq  270 <gsl_sum_levin_u_free+0x3e>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sum_levin_u_free (gsl_sum_levin_u_workspace * w)
{
  if (!w) { return ; };
  free (w->dsum);
  free (w->dq_den);
  free (w->dq_num);
  free (w->q_den);
  free (w->q_num);
  free (w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 10
18 10
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
<<<sep_in_sample>>>
topsf_get_rpmheader(TOPSF * topsf)
{
 return topsf->h_;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x50(%rsi),%rsi
mov    0x50(%rdi),%rdi
callq  2ba <compare_directory_canonical_names+0x11>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
compare_directory_canonical_names (void const *entry1, void const *entry2)
{
  struct directory const *directory1 = entry1;
  struct directory const *directory2 = entry2;
  return strcmp (directory1->caname, directory2->caname) == 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x20(%rdi),%ebp
test   $0x1,%bpl
je     1bf9 <swlib_synct_delete+0x32>
callq  1bde <swlib_synct_delete+0x17>
mov    %ebp,%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1bef <swlib_synct_delete+0x28>
mov    $0x0,%eax
callq  1bf9 <swlib_synct_delete+0x32>
mov    0x4(%rbx),%edi
test   %edi,%edi
jle    1c05 <swlib_synct_delete+0x3e>
callq  1c05 <swlib_synct_delete+0x3e>
mov    0x28(%rbx),%rdi
callq  1c0e <swlib_synct_delete+0x47>
mov    0x8(%rbx),%rdi
callq  1c17 <swlib_synct_delete+0x50>
mov    %rbx,%rdi
callq  1c1f <swlib_synct_delete+0x58>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swlib_synct_delete(SYNCT * synct)
{
 if (synct->countM % 2) {
  fprintf(stderr, "%s: Warning: swlib_synct_delete() block count error: %d\n",
   swlib_utilname_get(), synct->countM);
 }
 if (synct->debugfdM > 0) close(synct->debugfdM);
 free(synct->mtM);
 free(synct->bufM);
 free(synct);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 7
16 7
17 7
18 7
19 8
20 8
21 9
22 9
23 10
24 10
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x4,0x8(%rsp)
mov    %rdi,(%rsp)
mov    $0x0,%esi
mov    %rsp,%rdi
callq  8444 <do_assignment_internal>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
do_assignment_no_expand (string)
     char *string;
{
  WORD_DESC td;
  td.flags = 0x000004;
  td.word = string;
  return (do_assignment_internal (&td, 0));
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rdi
mov    %rdx,%r12
cmp    $0x1,%rcx
je     24ee <gsl_block_long_raw_fwrite+0x37>
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %rdx,%rdx
je     2574 <gsl_block_long_raw_fwrite+0xbd>
jmp    2528 <gsl_block_long_raw_fwrite+0x71>
mov    %r13,%rcx
mov    $0x8,%esi
callq  24fb <gsl_block_long_raw_fwrite+0x44>
mov    %rax,%rdx
mov    $0x0,%eax
cmp    %r12,%rdx
je     2574 <gsl_block_long_raw_fwrite+0xbd>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2521 <gsl_block_long_raw_fwrite+0x6a>
mov    $0x5,%eax
jmp    2574 <gsl_block_long_raw_fwrite+0xbd>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  253d <gsl_block_long_raw_fwrite+0x86>
cmp    $0x1,%rax
je     2563 <gsl_block_long_raw_fwrite+0xac>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  255c <gsl_block_long_raw_fwrite+0xa5>
mov    $0x5,%eax
jmp    2574 <gsl_block_long_raw_fwrite+0xbd>
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
jne    2528 <gsl_block_long_raw_fwrite+0x71>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_block_long_raw_fwrite (FILE * stream, const long * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 1 * sizeof (long), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 1 * i * stride,
                                1 * sizeof (long),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 17
12 17
13 17
14 26
15 15
16 15
17 15
18 6
19 6
20 6
21 6
22 26
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 17
33 17
34 17
35 17
36 17
37 20
38 20
39 22
40 22
41 22
42 22
43 22
44 22
45 22
46 15
47 15
48 15
49 15
50 26
51 27
52 27
53 27
54 27
55 27
56 27
<<<sep_out_sample>>>
mov    (%rdi),%rdi
mov    (%rsi),%rsi
movzbl (%rdi),%eax
movzbl (%rsi),%edx
cmp    %dl,%al
je     19 <alpha_compare+0x19>
movsbl %al,%eax
movsbl %dl,%edx
sub    %edx,%eax
retq   
sub    $0x8,%rsp
callq  22 <alpha_compare+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
alpha_compare (const void *v1, const void *v2)
{
  const char *s1 = *((char **)v1);
  const char *s2 = *((char **)v2);
  if (*s1 != *s2)
    return *s1 - *s2;
  return strcmp (s1, s2);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 8
11 2
12 7
13 8
14 8
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
cmpl   $0x0,0x0(%rip)        # c7 <pd_yydestruct+0x13>
je     115 <pd_yydestruct+0x61>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebx
mov    %rdx,%rbp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # e3 <pd_yydestruct+0x2f>
mov    $0x0,%eax
callq  ed <pd_yydestruct+0x39>
mov    %rbp,%rdx
mov    %ebx,%esi
mov    0x0(%rip),%rdi        # f9 <pd_yydestruct+0x45>
callq  0 <pd_yy_symbol_print>
mov    0x0(%rip),%rsi        # 105 <pd_yydestruct+0x51>
mov    $0xa,%edi
callq  10f <pd_yydestruct+0x5b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
pd_yydestruct (const char *pd_yymsg, int pd_yytype, YYSTYPE *pd_yyvaluep)
{
  ((void) (pd_yyvaluep));
  if (!pd_yymsg)
    pd_yymsg = "Deleting";
  do { if (pd_yydebug) { fprintf (stderr, "%s ", pd_yymsg); pd_yy_symbol_print (stderr, pd_yytype, pd_yyvaluep); fprintf (stderr, "\n"); } } while ((0));
  switch (pd_yytype)
    {
      default:
 break;
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 2
7 2
8 2
9 2
10 2
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %esi,0xd8(%rdi)
add    $0x10,%rdi
mov    $0x1,%esi
callq  18 <get_token>
<<<sep_in_sample>>>
parse_error (AFMHandle handle, AFMError error)
{
  handle->parse_error = error;
  longjmp (handle->jmpbuf, 1);
  fprintf (stderr, "AFM: fatal internal longjmp() error.\n");
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%ebp
mov    %esi,%r9d
mov    $0x28,%r8d
mov    %edx,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x87,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
and    $0x7,%r12d
or     $0xffffffc0,%r12d
and    $0x7,%ebp
shl    $0x3,%ebp
or     %ebp,%r12d
mov    %r12b,(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_xchgr(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    _rex(_jit, 0, 1, r1, _NOREG, r0);
    *_jit->pc.uc++ = 0x87;
    *_jit->pc.uc++ = (0x03<<6) | (((r1) & 7)<<3) | ((r0) & 7);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,%ecx
movq   $0x0,0x8(%rsp)
lea    0x8(%rsp),%r8
mov    $0x0,%edx
mov    $0x0,%esi
callq  159 <find_lsn_recurse>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
iso9660_find_fs_lsn(CdIo_t *p_cdio, lsn_t i_lsn)
{
  char *psz_full_filename = ((void *)0);
  return find_lsn_recurse (p_cdio, (iso9660_readdir_t *) iso9660_fs_readdir,
      "/", i_lsn, &psz_full_filename);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  c9 <pbm_getc+0x9>
cmp    $0x23,%eax
jne    e0 <pbm_getc+0x20>
mov    %rbx,%rdi
callq  d6 <pbm_getc+0x16>
cmp    $0xffffffff,%eax
je     e0 <pbm_getc+0x20>
cmp    $0xa,%eax
jne    ce <pbm_getc+0xe>
pop    %rbx
retq   
<<<sep_in_sample>>>
pbm_getc (FILE * infile)
{
  register int ch;
  ch = _IO_getc (infile);
  if (ch == '#') {
    do {
      ch = _IO_getc (infile);
    } while (ch != '\n' && ch != (-1));
  }
  return ch;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 7
8 8
9 8
10 8
11 8
12 11
13 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %edi,%edi
js     92 <free_cwd+0xf>
callq  92 <free_cwd+0xf>
mov    0x8(%rbx),%rdi
callq  9b <free_cwd+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_cwd (struct saved_cwd *cwd)
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  free (cwd->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1bbb <killPlayerEx+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
killPlayerEx(craft * c,...)
{
 return killPlayer(c);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  102e <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x38,%rsp
divsd  0x0(%rip),%xmm0        # 10c21 <Gi+0xc>
movsd  0x0(%rip),%xmm4        # 10c29 <Gi+0x14>
movsd  %xmm4,0x8(%rsp)
movsd  0x0(%rip),%xmm1        # 10c37 <Gi+0x22>
movsd  %xmm0,(%rsp)
callq  10c41 <Gi+0x2c>
movsd  %xmm0,0x20(%rsp)
movsd  0x0(%rip),%xmm5        # 10c4f <Gi+0x3a>
movsd  %xmm5,0x10(%rsp)
movsd  0x0(%rip),%xmm1        # 10c5d <Gi+0x48>
movsd  (%rsp),%xmm0
callq  10c67 <Gi+0x52>
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm6        # 10c75 <Gi+0x60>
movsd  %xmm6,0x18(%rsp)
movsd  0x0(%rip),%xmm1        # 10c83 <Gi+0x6e>
movsd  (%rsp),%xmm0
callq  10c8d <Gi+0x78>
movsd  0x8(%rsp),%xmm2
mulsd  0x20(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
mulsd  0x28(%rsp),%xmm5
movapd %xmm5,%xmm1
addsd  %xmm2,%xmm1
mulsd  0x18(%rsp),%xmm0
addsd  %xmm1,%xmm0
movsd  (%rsp),%xmm3
movapd %xmm3,%xmm1
mulsd  %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 10ccc <Gi+0xb7>
addsd  %xmm1,%xmm0
movapd %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 10cdc <Gi+0xc7>
addsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # 10ce8 <Gi+0xd3>
mulsd  0x0(%rip),%xmm0        # 10cf0 <Gi+0xdb>
divsd  0x0(%rip),%xmm0        # 10cf8 <Gi+0xe3>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
Gi(double t)
{
 double W=t/Q;
 return(g[1]*pow(W,5.)+g[2]*pow(W,4.)
  +g[3]*pow(W,3.)+g[4]*pow(W,2.)+g[5]*W+g[6])*Q/MSTAR[0][1];
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 4
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 4
39 6
40 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  204 <gsl_stats_float_skew+0x18>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  21d <gsl_stats_float_skew+0x31>
movapd %xmm0,%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  23a <gsl_stats_float_skew+0x4e>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_float_skew (const float data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_float_mean(data, stride, n);
  const double sd = gsl_stats_float_sd_m(data, stride, n, mean);
  return gsl_stats_float_skew_m_sd(data, stride, n, mean, sd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
test   %rsi,%rsi
je     a25 <api_register_two_way_processor+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  a21 <api_register_two_way_processor+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
api_register_two_way_processor(awk_ext_id_t id,
  awk_two_way_processor_t *two_way_processor)
{
 (void) id;
 if (two_way_processor == ((void *)0))
  return;
 register_two_way_processor(two_way_processor);
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 7
6 8
7 8
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     27 <__gmpz_fits_ushort_p+0x27>
mov    $0x0,%al
cmp    $0x1,%rdx
jne    27 <__gmpz_fits_ushort_p+0x27>
cmpq   $0xffff,(%rcx)
setbe  %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (32767 * 2 + 1)));;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rsi),%rax
cmp    %rdx,%rax
ja     7910 <gsl_matrix_char_const_superdiagonal+0x4e>
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  78e8 <gsl_matrix_char_const_superdiagonal+0x26>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    7946 <gsl_matrix_char_const_superdiagonal+0x84>
mov    %rdx,%rdi
add    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
sub    %rdx,%rax
mov    (%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
mov    %r8,0x8(%rbx)
mov    %rdi,0x10(%rbx)
mov    %rcx,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_const_superdiagonal (const gsl_matrix_char * m,
                                      const size_t k)
{
  _gsl_vector_char_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 13
20 13
21 14
22 12
23 12
24 12
25 12
26 17
27 17
28 17
29 17
30 17
31 19
32 19
33 19
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 3c3 <check_return+0x7>
mov    0x0(%rip),%rdx        # 3ca <check_return+0xe>
cmp    %rdx,%rcx
jne    3dc <check_return+0x20>
movb   $0x1,0x0(%rip)        # 3d6 <check_return+0x1a>
mov    $0x1,%eax
retq   
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
cmp    %rdx,%rcx
jge    40a <check_return+0x4e>
mov    0x0(%rip),%rdi        # 3f1 <check_return+0x35>
callq  0 <find_frame>
mov    0x10(%rax),%rax
mov    0x8(%rax),%rax
mov    0x28(%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
check_return(INSTRUCTION **pi)
{
 ((void) (0));
 if (fcall_count == stop.fcall_count) {
  stop.print_frame = 1;
  return 1;
 }
 if (fcall_count > stop.fcall_count) {
  NODE *func;
  func = find_frame(cur_frame)->sub.nodep.x.extra;
  ((void) (0));
  *pi = (func->sub.nodep.r.iptr + 1)->d.di;
 }
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 15
8 2
9 2
10 14
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 14
20 15
21 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer_flag+0x32>
callq  16 <fd_safer_flag+0x16>
mov    %eax,%r12d
callq  1e <fd_safer_flag+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer_flag+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer_flag (int fd, int flag)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer_flag (fd, flag);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  153f <quotearg_custom+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom (char const *left_quote, char const *right_quote,
                 char const *arg)
{
  return quotearg_n_custom (0, left_quote, right_quote, arg);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x70(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->nx_add_after (list, node, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rsi),%rsi
mov    0x38(%rdi),%rdi
callq  5c2 <swi_com_field_edge_detect_fileset+0x19>
test   %eax,%eax
jne    5dc <swi_com_field_edge_detect_fileset+0x33>
mov    0x28(%rbx),%rdx
cmpb   $0x0,(%rdx)
jne    5dc <swi_com_field_edge_detect_fileset+0x33>
mov    0x28(%rbp),%rax
cmpb   $0x0,(%rax)
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swi_com_field_edge_detect_fileset(SWPATH_EX * current, SWPATH_EX * previous)
{
 int ret;
 ret = swi_com_field_edge_detect(current->fileset_control_dir,
  previous->fileset_control_dir);
 if (ret == 0) {
  if (strlen(current->pfiles) == 0 && strlen(previous->pfiles)) {
   ret = 1;
  }
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
test   %rdi,%rdi
je     10e <DefDepParm+0x64>
callq  c1 <DefDepParm+0x17>
movzbl (%rbx),%ecx
movsbq %cl,%rdx
mov    (%rax),%rax
testb  $0x4,0x1(%rax,%rdx,2)
jne    d7 <DefDepParm+0x2d>
cmp    $0x5f,%cl
jne    10e <DefDepParm+0x64>
mov    %rbx,%rdi
callq  df <DefDepParm+0x35>
mov    %rax,%rdx
mov    %rax,0x0(%rbp)
mov    $0x1,%eax
test   %rdx,%rdx
jne    129 <DefDepParm+0x7f>
mov    $0x0,%ecx
mov    %rbx,%rdx
mov    $0x106,%esi
mov    $0x0,%edi
callq  107 <DefDepParm+0x5d>
mov    $0x0,%eax
jmp    129 <DefDepParm+0x7f>
mov    %rbx,%rdi
callq  116 <DefDepParm+0x6c>
movsd  %xmm0,(%r12)
movq   $0x0,0x0(%rbp)
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
DefDepParm (PSTR szLex, PDOUBLE pdValue, HANDLE *phvar)
{
  BOOL bReturn = 1;
  if (((szLex) ? ((*__ctype_b_loc ())[(int) ((*(szLex)))] & (unsigned short int) _ISalpha) || *(szLex) == '_' : 0)) {
    if (!(*phvar = (HANDLE) (GetVarHandle((szLex))))) {
      bReturn = 0;
      ReportError (((void *)0), 0x0106, szLex, ((void *)0));
    }
  }
  else {
    *pdValue = atof(szLex);
    *phvar = 0;
  }
  return (bReturn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 3
22 5
23 5
24 7
25 7
26 7
27 7
28 7
29 6
30 6
31 11
32 11
33 11
34 12
35 3
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rcx        # 13 <yy_stack_print+0x13>
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  27 <yy_stack_print+0x27>
cmp    %rbp,%rbx
ja     4e <yy_stack_print+0x4e>
movswl (%rbx),%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 3b <yy_stack_print+0x3b>
mov    $0x0,%eax
callq  45 <yy_stack_print+0x45>
add    $0x2,%rbx
cmp    %rbx,%rbp
jae    2c <yy_stack_print+0x2c>
mov    0x0(%rip),%rsi        # 55 <yy_stack_print+0x55>
mov    $0xa,%edi
callq  5f <yy_stack_print+0x5f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
{
  fprintf (stderr, "Stack now");
  for (; bottom <= top; ++bottom)
    fprintf (stderr, " %d", *bottom);
  fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 4
19 4
20 4
21 6
22 6
23 6
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 685 <subshell_exit+0xa>
callq  68a <subshell_exit+0xf>
mov    0x0(%rip),%rdi        # 691 <subshell_exit+0x16>
callq  696 <subshell_exit+0x1b>
mov    $0x0,%edi
callq  6a0 <subshell_exit+0x25>
test   %eax,%eax
je     6ab <subshell_exit+0x30>
callq  6a9 <subshell_exit+0x2e>
mov    %eax,%ebx
mov    %ebx,%edi
callq  6b2 <shell_is_restricted>
<<<sep_in_sample>>>
subshell_exit (s)
     int s;
{
  fflush (stdout);
  fflush (stderr);
  if (signal_is_trapped (0))
    s = run_exit_trap ();
  sh_exit (s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rax        # 65 <CDB___os_yield+0x13>
test   %rax,%rax
je     70 <CDB___os_yield+0x1e>
callq  *%rax
test   %eax,%eax
je     80 <CDB___os_yield+0x2e>
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  80 <CDB___os_yield+0x2e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
CDB___os_yield(dbenv, usecs)
 DB_ENV *dbenv;
 u_long usecs;
{
 if (CDB___db_jump.j_yield != ((void *)0) && CDB___db_jump.j_yield() == 0)
  return;
 CDB___os_sleep(dbenv, 0, usecs);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%ebx
movl   $0x0,0xc(%rsp)
mov    $0x200,%edi
callq  3dc <_rl_insert_typein+0x1a>
mov    %rax,%rbp
mov    %bl,(%rax)
mov    $0x1,%ebx
jmp    3f3 <_rl_insert_typein+0x31>
movslq %ebx,%rax
mov    %dil,0x0(%rbp,%rax,1)
lea    0x1(%rbx),%ebx
lea    0xc(%rsp),%rdi
callq  20 <rl_get_char>
test   %eax,%eax
je     427 <_rl_insert_typein+0x65>
mov    0xc(%rsp),%edi
movslq %edi,%rcx
shl    $0x4,%rcx
add    0x0(%rip),%rcx        # 413 <_rl_insert_typein+0x51>
cmpb   $0x0,(%rcx)
jne    422 <_rl_insert_typein+0x60>
cmpq   $0x0,0x8(%rcx)
je     3e8 <_rl_insert_typein+0x26>
callq  427 <_rl_insert_typein+0x65>
movslq %ebx,%rbx
movb   $0x0,0x0(%rbp,%rbx,1)
mov    %rbp,%rdi
callq  437 <_rl_insert_typein+0x75>
mov    %rbp,%rdi
callq  43f <_rl_insert_typein+0x7d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_insert_typein (c)
     int c;
{
  int key, t, i;
  char *string;
  i = key = 0;
  string = (char *)xmalloc (ibuffer_len + 1);
  string[i++] = (char) c;
  while ((t = rl_get_char (&key)) &&
  _rl_keymap[key].type == 0 &&
  _rl_keymap[key].function == rl_insert)
    string[i++] = key;
  if (t)
    _rl_unget_char (key);
  string[i] = '\0';
  rl_insert_text (string);
  xfree (string);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 7
7 7
8 7
9 8
10 8
11 9
12 12
13 12
14 12
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 9
24 9
25 10
26 10
27 14
28 15
29 15
30 16
31 16
32 17
33 17
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
movzbl (%rdi),%eax
cmp    $0x2e,%al
jne    233 <normalize_filename_x+0x40>
cmpb   $0x2f,0x1(%rdi)
jne    23b <normalize_filename_x+0x48>
mov    %rdi,%rax
mov    %rdi,%rcx
lea    0x2(%rax),%rdx
movzbl 0x2(%rax),%eax
cmp    $0x2f,%al
jne    21d <normalize_filename_x+0x2a>
add    $0x1,%rdx
movzbl (%rdx),%eax
cmp    $0x2f,%al
je     212 <normalize_filename_x+0x1f>
test   %al,%al
sete   %al
movzbl %al,%eax
add    %rax,%rcx
movzbl (%rdx),%eax
mov    %al,(%rcx)
cmp    $0x2e,%al
je     243 <normalize_filename_x+0x50>
jmp    28d <normalize_filename_x+0x9a>
mov    %rdi,%rdx
mov    %rdi,%rcx
jmp    28d <normalize_filename_x+0x9a>
mov    %rdi,%rdx
mov    %rdi,%rcx
jmp    28d <normalize_filename_x+0x9a>
cmpb   $0x2f,0x1(%rdx)
jne    28d <normalize_filename_x+0x9a>
mov    %rdx,%rax
jmp    206 <normalize_filename_x+0x13>
cmp    $0x2f,%sil
jne    287 <normalize_filename_x+0x94>
movzbl 0x1(%rdx),%edx
cmp    $0x2e,%dl
sete   %cl
movzbl %cl,%ecx
cmpb   $0x2f,(%rax,%rcx,1)
jne    287 <normalize_filename_x+0x94>
cmp    $0x2e,%dl
sete   %dl
movzbl %dl,%edx
lea    0x1(%rax,%rdx,1),%rax
movzbl (%rax),%edx
cmp    $0x2e,%dl
sete   %cl
movzbl %cl,%ecx
cmpb   $0x2f,(%rax,%rcx,1)
je     267 <normalize_filename_x+0x74>
mov    %r8,%rcx
mov    %rax,%rdx
lea    0x1(%rcx),%r8
lea    0x1(%rdx),%rax
movzbl (%rdx),%esi
mov    %sil,-0x1(%r8)
test   %sil,%sil
jne    24e <normalize_filename_x+0x5b>
mov    %r8,%rax
sub    %rdi,%rax
cmp    $0x2,%rax
jle    2e4 <normalize_filename_x+0xf1>
cmpb   $0x2e,-0x1(%rcx)
jne    2c9 <normalize_filename_x+0xd6>
cmpb   $0x2f,-0x2(%rcx)
jne    2c9 <normalize_filename_x+0xd6>
lea    -0x1(%r8),%r8
mov    %r8,%rax
sub    %rdi,%rax
cmp    $0x2,%rax
jle    2d5 <normalize_filename_x+0xe2>
mov    $0x1,%eax
cmpb   $0x2f,-0x2(%r8)
je     2da <normalize_filename_x+0xe7>
mov    $0x0,%eax
cltq   
sub    %rax,%r8
movb   $0x0,-0x1(%r8)
repz retq 
<<<sep_in_sample>>>
normalize_filename_x (char *file_name)
{
  char *name = file_name + 0;
  char *p;
  char const *q;
  char c;
  name += (0
    && ((*name) == '/') && ((name[1]) == '/') && ! ((name[2]) == '/'));
  for (q = p = name; (*p = *q) == '.' && ((q[1]) == '/'); p += !*q)
    for (q += 2; ((*q) == '/'); q++)
      continue;
  while ((*p++ = c = *q++) != '\0')
    if (((c) == '/'))
      while (((q[*q == '.']) == '/'))
 q += (*q == '.') + 1;
  if (2 < p - name)
    {
      p -= p[-2] == '.' && ((p[-3]) == '/');
      p -= 2 < p - name && ((p[-2]) == '/');
      p[-1] = '\0';
    }
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 13
36 13
37 14
38 14
39 14
40 14
41 14
42 14
43 15
44 15
45 15
46 15
47 14
48 14
49 14
50 14
51 14
52 14
53 12
54 12
55 12
56 12
57 12
58 12
59 12
60 12
61 16
62 16
63 16
64 16
65 18
66 18
67 18
68 18
69 18
70 19
71 19
72 19
73 19
74 19
75 19
76 19
77 19
78 19
79 19
80 20
81 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebx
mov    %esi,%r12d
cmpl   $0x0,0x0(%rip)        # 153 <print_level+0x10>
je     171 <print_level+0x2e>
mov    0x0(%rip),%edx        # 15b <print_level+0x18>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 167 <print_level+0x24>
mov    $0x0,%eax
callq  171 <print_level+0x2e>
cmpl   $0x0,0x0(%rip)        # 178 <print_level+0x35>
je     192 <print_level+0x4f>
mov    %ebx,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 188 <print_level+0x45>
mov    $0x0,%eax
callq  192 <print_level+0x4f>
mov    0x0(%rip),%rsi        # 199 <print_level+0x56>
mov    0x0(%rip),%rdi        # 1a0 <print_level+0x5d>
callq  1a5 <print_level+0x62>
test   %ebx,%ebx
jle    1dd <print_level+0x9a>
lea    -0x1(%rbx),%ebp
add    $0x1,%rbp
mov    $0x0,%ebx
mov    0x0(%rip),%rax        # 1bc <print_level+0x79>
movzbl (%rax,%rbx,1),%eax
mov    0x0(,%rax,8),%rdi
mov    0x0(%rip),%rsi        # 1cf <print_level+0x8c>
callq  1d4 <print_level+0x91>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    1b5 <print_level+0x72>
movslq %r12d,%r12
mov    0x0(,%r12,8),%rdi
mov    0x0(%rip),%rsi        # 1ef <print_level+0xac>
callq  1f4 <print_level+0xb1>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_level(int lev, int last)
{
     int i;
     if (print_line_numbers)
   fprintf(outfile, "%5d ", out_line);
     if (print_levels)
   fprintf(outfile, "{%4d} ", lev);
     fprintf(outfile, "%s", level_begin);
     for (i = 0; i < lev; i++)
   fprintf(outfile, "%s", level_indent[ level_mark[i] ]);
     fprintf(outfile, "%s", level_end[last]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 9
35 9
36 11
37 11
38 11
39 11
40 12
41 12
42 12
43 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
testb  $0xc0,0x0(%rip)        # 566 <stream_dump+0x13>
je     581 <stream_dump+0x2e>
mov    %rsi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 577 <stream_dump+0x24>
mov    $0x0,%eax
callq  581 <stream_dump+0x2e>
mov    %rbx,%rdi
callq  589 <stream_dump+0x36>
mov    %rax,%rbx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  0 <_streams_copy>
mov    %rbx,%rdi
callq  59f <stream_dump+0x4c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
stream_dump (FILE * stream, const char * filename)
{
  FILE * fp;
  do { if ((((1 << 7) | (1 << 6)) & msg_verbosity)) fprintf (stderr, "Dumping file `%s'\n", filename); } while (0);
  fp = xrfopen (filename);
  _streams_copy (fp, stream);
  fclose (fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 8
22 8
23 8
24 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  39f <do_ck_fclose+0xe>
mov    %rbx,%rdi
callq  3a7 <do_ck_fclose+0x16>
mov    %rbx,%rdi
callq  3af <do_ck_fclose+0x1e>
cmp    $0xffffffff,%eax
jne    3e0 <do_ck_fclose+0x4f>
callq  3b9 <do_ck_fclose+0x28>
mov    (%rax),%edi
callq  3c0 <do_ck_fclose+0x2f>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  0 <utils_fp_name>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3e0 <do_ck_fclose+0x4f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
do_ck_fclose(fp)
  FILE *fp;
{
  ck_fflush(fp);
  clearerr(fp);
  if (fclose(fp) == (-1))
    panic("couldn't close %s: %s", utils_fp_name(fp), strerror((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rcx
mov    0x0(%rip),%rax        # 104a <pch_write_line+0xb>
mov    (%rax,%rdi,8),%r8
mov    0x0(%rip),%rax        # 1055 <pch_write_line+0x16>
mov    (%rax,%rdi,8),%rdx
cmpb   $0xa,-0x1(%r8,%rdx,1)
sete   %bl
mov    $0x1,%esi
mov    %r8,%rdi
callq  106f <pch_write_line+0x30>
test   %rax,%rax
jne    1079 <pch_write_line+0x3a>
callq  1079 <pch_write_line+0x3a>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
pch_write_line (lin line, FILE *file)
{
  _Bool after_newline = p_line[line][p_len[line] - 1] == '\n';
  if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))
    write_fatal ();
  return after_newline;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 5
15 7
16 7
17 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x8(%rdi),%rdi
callq  cd7 <rc_inst_destroy+0xd>
mov    0x10(%rbx),%rdi
callq  ce0 <rc_inst_destroy+0x16>
mov    0x18(%rbx),%rdi
callq  ce9 <rc_inst_destroy+0x1f>
pop    %rbx
retq   
<<<sep_in_sample>>>
rc_inst_destroy (RC_INST *inst)
{
  anubis_regex_free (&inst->key);
  free (inst->key2);
  free (inst->arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     1495 <mu_message_is_multipart+0x5c>
mov    %rsi,%rbp
test   %rsi,%rsi
je     1495 <mu_message_is_multipart+0x5c>
mov    0x98(%rdi),%rax
test   %rax,%rax
je     145f <mu_message_is_multipart+0x26>
callq  *%rax
jmp    149a <mu_message_is_multipart+0x61>
cmpq   $0x0,0x40(%rdi)
jne    1482 <mu_message_is_multipart+0x49>
lea    0x40(%rdi),%rdi
mov    $0x0,%edx
mov    %rbx,%rsi
callq  1477 <mu_message_is_multipart+0x3e>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    149a <mu_message_is_multipart+0x61>
mov    0x40(%rbx),%rdi
callq  148b <mu_message_is_multipart+0x52>
mov    %eax,0x0(%rbp)
mov    $0x0,%eax
jmp    149a <mu_message_is_multipart+0x61>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_message_is_multipart (mu_message_t msg, int *pmulti)
{
  if (msg && pmulti)
    {
      if (msg->_is_multipart)
 return msg->_is_multipart (msg, pmulti);
      if (msg->mime == ((void *)0))
 {
   int status = mu_mime_create (&(msg->mime), msg, 0);
   if (status != 0)
     return 0;
 }
      *pmulti = mu_mime_is_multipart(msg->mime);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 6
14 6
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 11
23 10
24 10
25 13
26 13
27 13
28 15
29 15
30 15
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    12a <process_file+0x39>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 123 <process_file+0x32>
callq  128 <process_file+0x37>
jmp    182 <process_file+0x91>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  137 <process_file+0x46>
test   %rax,%rax
jne    166 <process_file+0x75>
callq  141 <process_file+0x50>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  15a <process_file+0x69>
movl   $0x1,0x0(%rip)        # 164 <process_file+0x73>
jmp    187 <process_file+0x96>
mov    $0x1,%edx
mov    0x8(%rsp),%rsi
mov    %rax,%rdi
callq  178 <process_file+0x87>
mov    0x8(%rsp),%rdi
callq  182 <process_file+0x91>
callq  187 <process_file+0x96>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
process_file (const char *name)
{
  if ((strcmp (name, "-") == 0))
    {
      push_file (stdin, "stdin", 0);
    }
  else
    {
      char *full_name;
      FILE *fp = m4_path_search (name, &full_name);
      if (fp == ((void *)0))
        {
          error (0, (*__errno_location ()), "cannot open `%s'", name);
          retcode = 1;
          return;
        }
      push_file (fp, full_name, 1);
      free (full_name);
    }
  expand_input ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 5
15 5
16 5
17 10
18 10
19 10
20 11
21 11
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 14
30 14
31 17
32 17
33 17
34 17
35 18
36 18
37 20
38 21
39 21
40 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x1,%edx
mov    0x0(%rip),%rsi        # bd4 <pred_executable+0x15>
mov    0x0(%rip),%edi        # bda <pred_executable+0x1b>
callq  bdf <pred_executable+0x20>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pred_executable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  (void) stat_buf;
  (void) pred_ptr;
  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, 1, 0);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    0x18(%rdi),%edx
cmp    $0x38,%edx
sbb    %rax,%rax
and    $0xfffffffffffffff0,%rax
add    $0x20,%rax
mov    %edx,%ecx
add    0x10(%rdi),%ecx
mov    %ecx,0x10(%rdi)
cmp    %ecx,%edx
jbe    1851 <md5_finish_ctx+0x31>
addl   $0x1,0x14(%rdi)
lea    0x0(,%rcx,8),%esi
mov    %esi,0x14(%rbx,%rax,4)
shr    $0x1d,%ecx
mov    0x14(%rbx),%edi
lea    0x0(,%rdi,8),%esi
or     %esi,%ecx
mov    %ecx,0x18(%rbx,%rax,4)
lea    0x0(,%rax,4),%r13
mov    %edx,%edx
lea    0x1c(%rbx),%rbp
lea    0x0(%rbp,%rdx,1),%rdi
mov    %r13,%rax
sub    %rdx,%rax
lea    -0x8(%rax),%rdx
mov    $0x0,%esi
callq  1896 <md5_finish_ctx+0x76>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %rbp,%rdi
callq  18a4 <md5_finish_ctx+0x84>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  18af <md5_finish_ctx+0x8f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)
{
  uint32_t bytes = ctx->buflen;
  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes)
    ++ctx->total[1];
  ctx->buffer[size - 2] = (ctx->total[0] << 3);
  ctx->buffer[size - 1] = ((ctx->total[1] << 3) | (ctx->total[0] >> 29));
  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);
  md5_process_block (ctx->buffer, size * 4, ctx);
  return md5_read_ctx (ctx, resbuf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 7
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 11
36 11
37 11
38 11
39 12
40 12
41 12
42 13
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsi,%r14
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%r12
mov    $0x0,%ebp
mov    %rbx,%rdi
callq  2f2 <gsl_multifit_fsolver_driver+0x35>
test   %eax,%eax
jne    327 <gsl_multifit_fsolver_driver+0x6a>
mov    0x10(%rbx),%rsi
mov    0x20(%rbx),%rdi
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  319 <gsl_multifit_fsolver_driver+0x5c>
cmp    $0xfffffffe,%eax
jne    327 <gsl_multifit_fsolver_driver+0x6a>
add    $0x1,%rbp
cmp    %r14,%rbp
jb     2ea <gsl_multifit_fsolver_driver+0x2d>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_multifit_fsolver_driver (gsl_multifit_fsolver * s,
                             const size_t maxiter,
                             const double epsabs,
                             const double epsrel)
{
  int status;
  size_t iter = 0;
  do
    {
      status = gsl_multifit_fsolver_iterate (s);
      if (status)
        break;
      status = gsl_multifit_test_delta (s->dx, s->x, epsabs, epsrel);
    }
  while (status == GSL_CONTINUE && ++iter < maxiter);
  return status;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 10
15 10
16 11
17 11
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 15
30 17
31 17
32 17
33 17
34 17
35 17
36 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  11 <node_ident_cmp+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
node_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)
{
 return strcmp(a->ident, b->ident);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2670 <php_get_debug+0x6>
retq   
<<<sep_in_sample>>>
php_get_debug (void)
{
        return php__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gc_hash_write (gc_hash_handle handle, size_t len, const char *data)
{
  _gc_hash_ctx *ctx = handle;
  switch (ctx->alg)
    {
    default:
      break;
    }
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0xc0800000,%esi
callq  cbbc <_sse_blti_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c657 <_sse_movi_d>
mov    0x0(%r12),%ecx
and    $0x7fff,%ecx
mov    %r14d,%edx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  10b7 <_sse_bltr_d>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  cc0e <_sse_blti_d+0x76>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_sse_blti_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bltr_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
callq  d <__riinreal+0xd>
test   %al,%al
je     1b <__riinreal+0x1b>
mov    $0x0,%edi
callq  1b <__riinreal+0x1b>
mov    0x58(%rbx),%rax
mov    %rax,(%rsp)
movzwl 0x62(%rbx),%eax
mov    %eax,%edx
add    0x64(%rbx),%dx
sub    $0x1,%edx
mov    %dx,0xc(%rsp)
movzwl 0x60(%rbx),%ecx
lea    0x1(%rcx),%edx
sub    %eax,%edx
mov    %dx,0x8(%rsp)
movw   $0x1,0xa(%rsp)
mov    %rsp,%rdi
callq  52 <__riinreal+0x52>
movzwl 0x62(%rbx),%eax
add    0xa(%rsp),%ax
sub    $0x1,%eax
mov    %ax,0x62(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
__riinreal (__bs2FILE *p)
{
  __txt t;
  double inreal;
  if (__rilastitem (p))
    __rerror ("Inreal: End of file");
  t.obj = p->IMAGE.obj;
  t.start = p->IMAGE.start + p->IMAGE.pos - 1;
  t.length = p->IMAGE.length - p->IMAGE.pos + 1;
  t.pos = 1;
  inreal = __rtgetreal (&t);
  p->IMAGE.pos += t.pos - 1;
  return (inreal);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 10
21 11
22 11
23 12
24 12
25 12
26 12
27 14
28 14
29 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5815 <next_step>
test   %eax,%eax
je     6b4b <do_nexti+0x26>
mov    0x0(%rip),%rdx        # 6b39 <do_nexti+0x14>
mov    %rdx,0x0(%rip)        # 6b40 <do_nexti+0x1b>
movq   $0x0,0x0(%rip)        # 6b4b <do_nexti+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_nexti(CMDARG *arg, int cmd)
{
 int ret;
 ret = next_step(arg, cmd);
 if (ret) {
  stop.fcall_count = fcall_count;
  stop.check_func = check_nexti;
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 6
6 6
7 7
8 10
9 10
<<<sep_out_sample>>>
test   %edi,%edi
je     32 <_nettle_umac_l2_init+0x32>
mov    %rsi,%rax
lea    -0x1(%rdi),%edx
lea    0x4(%rsi,%rdx,4),%rsi
mov    (%rax),%edx
mov    %edx,%ecx
ror    $0x18,%ecx
and    $0xff00ff,%ecx
ror    $0x8,%edx
and    $0x100ff00,%edx
or     %ecx,%edx
mov    %edx,(%rax)
add    $0x4,%rax
cmp    %rsi,%rax
jne    f <_nettle_umac_l2_init+0xf>
repz retq 
<<<sep_in_sample>>>
_nettle_umac_l2_init (unsigned size, uint32_t *k)
{
  unsigned i;
  for (i = 0; i < size; i++)
    {
      uint32_t w = k[i];
      w = (((((w)<<(8)) | ((w)>>((-(8)&31)))) & 0x00FF00FFUL) | ((((w)<<(24)) | ((w)>>((-(24)&31)))) & 0xFF00FF00UL));
      k[i] = w & 0x01ffffffUL;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 4
16 4
17 4
<<<sep_out_sample>>>
test   %edi,%edi
je     ba <gsl_ran_geometric_pdf+0x3f>
movapd %xmm0,%xmm3
cmp    $0x1,%edi
je     c3 <gsl_ran_geometric_pdf+0x48>
sub    $0x18,%rsp
mov    %edi,%edi
cvtsi2sd %rdi,%xmm1
movsd  0x0(%rip),%xmm2        # 9b <gsl_ran_geometric_pdf+0x20>
movapd %xmm2,%xmm0
movsd  %xmm3,0x8(%rsp)
subsd  %xmm3,%xmm0
subsd  %xmm2,%xmm1
callq  b2 <gsl_ran_geometric_pdf+0x37>
mulsd  0x8(%rsp),%xmm0
jmp    bf <gsl_ran_geometric_pdf+0x44>
xorpd  %xmm0,%xmm0
retq   
add    $0x18,%rsp
repz retq 
<<<sep_in_sample>>>
gsl_ran_geometric_pdf (const unsigned int k, const double p)
{
  if (k == 0)
    {
      return 0 ;
    }
  else if (k == 1)
    {
      return p ;
    }
  else
    {
      double P = p * pow (1 - p, k - 1.0);
      return P;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 7
5 7
6 2
7 13
8 13
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 14
17 5
18 5
19 16
20 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%r8
mov    %r12,%rcx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x50(%r8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, start_index, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 10e0 <psname+0x6>
sub    $0x5,%eax
cmp    $0x3,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmova  %rdx,%rax
retq   
<<<sep_in_sample>>>
psname ()
{
  if ((((yy_start) - 1) / 2) == 3 || (((yy_start) - 1) / 2) == 2)
    return "ps2";
  return "ps1";
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rax        # 13 <__gmpf_init_set_ui+0x13>
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 23 <__gmpf_init_set_ui+0x23>
mov    %rax,0x10(%rbx)
mov    %rbp,(%rax)
test   %rbp,%rbp
setne  %al
movzbl %al,%edx
mov    %edx,0x4(%rbx)
movzbl %al,%eax
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmpf_init_set_ui (mpf_ptr r, unsigned long int val)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  mp_size_t size;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
  r->_mp_d[0] = val & ((~ ((mp_limb_t) (0))) >> 0);
  size = (val != 0);
  r->_mp_size = size;
  r->_mp_exp = size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 5
8 6
9 6
10 6
11 7
12 8
13 8
14 9
15 9
16 8
17 8
18 11
19 11
20 11
21 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
orq    $0x40,0x0(%rip)        # 217 <rl_vi_domove_getchar+0xc>
callq  21c <rl_vi_domove_getchar+0x11>
andq   $0xffffffffffffffbf,0x0(%rip)        # 224 <rl_vi_domove_getchar+0x19>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_vi_domove_getchar (m)
     _rl_vimotion_cxt *m;
{
  int c;
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 9
6 9
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
mpfr_unset(NODE *n)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  11 <node_ident_cmp+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
node_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)
{
 return strcmp(a->ident, b->ident);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
ror    %cl,%eax
retq   
<<<sep_in_sample>>>
rotr32 (uint32_t x, int n)
{
  return ((x >> n) | (x << (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  82c <cspline_free+0xc>
mov    0x8(%rbx),%rdi
callq  835 <cspline_free+0x15>
mov    0x10(%rbx),%rdi
callq  83e <cspline_free+0x1e>
mov    0x18(%rbx),%rdi
callq  847 <cspline_free+0x27>
mov    %rbx,%rdi
callq  84f <cspline_free+0x2f>
pop    %rbx
retq   
<<<sep_in_sample>>>
cspline_free (void * vstate)
{
  cspline_state_t *state = (cspline_state_t *) vstate;
  free (state->c);
  free (state->g);
  free (state->diag);
  free (state->offdiag);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 567 <progcomp_walk+0x7>
test   %rax,%rax
je     58a <progcomp_walk+0x2a>
test   %rdi,%rdi
je     58a <progcomp_walk+0x2a>
cmpl   $0x0,0xc(%rax)
je     58a <progcomp_walk+0x2a>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    %rax,%rdi
callq  586 <progcomp_walk+0x26>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
progcomp_walk (pfunc)
     hash_wfunc *pfunc;
{
  if (prog_completes == 0 || pfunc == 0 || ((prog_completes) ? (prog_completes)->nentries : 0) == 0)
    return;
  hash_walk (prog_completes, pfunc);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 3
9 6
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer_flag+0x32>
callq  16 <fd_safer_flag+0x16>
mov    %eax,%r12d
callq  1e <fd_safer_flag+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer_flag+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer_flag (int fd, int flag)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer_flag (fd, flag);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 644 <asm_restart+0x10>
test   %rax,%rax
je     657 <asm_restart+0x23>
mov    0x0(%rip),%rdx        # 650 <asm_restart+0x1c>
cmpq   $0x0,(%rax,%rdx,8)
jne    694 <asm_restart+0x60>
callq  2ce <asm_ensure_buffer_stack>
mov    0x0(%rip),%rax        # 663 <asm_restart+0x2f>
mov    0x0(%rip),%rdx        # 66a <asm_restart+0x36>
lea    (%rax,%rdx,8),%rbp
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 67a <asm_restart+0x46>
callq  67f <asm_restart+0x4b>
mov    %rax,0x0(%rbp)
mov    0x0(%rip),%rax        # 68a <asm_restart+0x56>
mov    $0x0,%edi
test   %rax,%rax
je     69f <asm_restart+0x6b>
mov    0x0(%rip),%rdx        # 69b <asm_restart+0x67>
mov    (%rax,%rdx,8),%rdi
mov    %rbx,%rsi
callq  55d <asm__init_buffer>
callq  c4 <asm__load_buffer_state>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
asm_restart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        asm_ensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            asm__create_buffer(asm_in,16384 );
 }
 asm__init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 asm__load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%esi
mov    $0x0,%edx
callq  e8 <indexof+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
indexof(str string, char chr)
{
 return __do_indexof(string, chr, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
movzbl (%rdi),%eax
mov    %al,0x0(%rip)        # ab8 <tty_restore+0x9>
retq   
<<<sep_in_sample>>>
tty_restore(status)
    tty_status_t *status;
{
    tty_current_attribute = *status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%rdi
mov    %edx,%edx
shl    $0x7,%rdx
mov    %rax,%rsi
callq  83 <jcopy_block_row+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
   JDIMENSION num_blocks)
{
  memcpy((void *)(output_row), (const void *)(input_row), (size_t)(num_blocks * (64 * ((size_t) sizeof(JCOEF)))));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
movzbl (%rdi),%eax
test   %r10,%r10
je     255b <gsl_matrix_char_min+0x4a>
mov    $0x0,%r8d
jmp    254d <gsl_matrix_char_min+0x3c>
movzbl (%rdx),%ecx
cmp    %cl,%al
cmovg  %ecx,%eax
add    $0x1,%rdx
cmp    %rdx,%rsi
jne    2530 <gsl_matrix_char_min+0x1f>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
je     255b <gsl_matrix_char_min+0x4a>
test   %r9,%r9
je     2541 <gsl_matrix_char_min+0x30>
lea    (%rdi,%r9,1),%rsi
mov    %rdi,%rdx
jmp    2530 <gsl_matrix_char_min+0x1f>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_char_min (const gsl_matrix_char * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  char min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          char x = m->data[i * tda + j];
          if (x < min)
            min = x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 8
7 8
8 8
9 8
10 12
11 12
12 12
13 12
14 10
15 10
16 8
17 8
18 8
19 8
20 10
21 10
22 10
23 10
24 10
25 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18a <reset_info_window_sizes+0x9>
mov    0x0(%rip),%esi        # 190 <reset_info_window_sizes+0xf>
mov    0x0(%rip),%edi        # 196 <reset_info_window_sizes+0x15>
callq  19b <reset_info_window_sizes+0x1a>
mov    0x0(%rip),%esi        # 1a1 <reset_info_window_sizes+0x20>
mov    0x0(%rip),%edi        # 1a7 <reset_info_window_sizes+0x26>
callq  1ac <reset_info_window_sizes+0x2b>
callq  1b1 <reset_info_window_sizes+0x30>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
reset_info_window_sizes (void)
{
  terminal_get_screen_size ();
  display_initialize_display (screenwidth, screenheight);
  window_new_screen_size (screenwidth, screenheight);
  redisplay_after_signal ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 7
11 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdi
test   %rcx,%rcx
je     202a <gsl_vector_long_set_all+0x28>
shl    $0x3,%rdi
mov    $0x0,%eax
mov    %rsi,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    201b <gsl_vector_long_set_all+0x19>
repz retq 
<<<sep_in_sample>>>
gsl_vector_long_set_all (gsl_vector_long * v, long x)
{
  long * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long *) (data + 1 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 9
7 7
8 9
9 7
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  31 <_mimepart_body_lines+0x9>
mov    %rax,%rdi
callq  39 <_mimepart_body_lines+0x11>
mov    $0x16,%edx
test   %rax,%rax
je     58 <_mimepart_body_lines+0x30>
test   %rbx,%rbx
je     53 <_mimepart_body_lines+0x2b>
mov    0x20(%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%dl
jmp    58 <_mimepart_body_lines+0x30>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_mimepart_body_lines (mu_body_t body, size_t *plines)
{
  mu_message_t msg = mu_body_get_owner (body);
  struct _mime_part *mime_part = mu_message_get_owner (msg);
  if (mime_part == ((void *)0))
    return 22;
  if (plines)
    *plines = mime_part->lines;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 5
8 5
9 7
10 7
11 8
12 8
13 9
14 9
15 9
16 10
17 10
18 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     18f <scram_valid_client_final+0x6c>
mov    $0x0,%ecx
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  143 <scram_valid_client_final+0x20>
mov    $0x0,%ecx
test   %rax,%rax
jne    1a2 <scram_valid_client_final+0x7f>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     196 <scram_valid_client_final+0x73>
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  165 <scram_valid_client_final+0x42>
mov    $0x0,%ecx
test   %rax,%rax
jne    1a2 <scram_valid_client_final+0x7f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     19d <scram_valid_client_final+0x7a>
cmpb   $0x0,(%rdi)
je     1a2 <scram_valid_client_final+0x7f>
mov    $0x2c,%esi
callq  187 <scram_valid_client_final+0x64>
test   %rax,%rax
sete   %cl
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
jmp    1a2 <scram_valid_client_final+0x7f>
mov    $0x0,%ecx
mov    %ecx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
scram_valid_client_final (struct scram_client_final * cl)
{
  if (cl->cbind == ((void *)0) || *cl->cbind == '\0')
    return 0;
  if (strchr (cl->cbind, ','))
    return 0;
  if (cl->nonce == ((void *)0) || *cl->nonce == '\0')
    return 0;
  if (strchr (cl->nonce, ','))
    return 0;
  if (cl->proof == ((void *)0) || *cl->proof == '\0')
    return 0;
  if (strchr (cl->proof, ','))
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
9 5
10 5
11 6
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 9
20 9
21 10
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 4
35 4
36 8
37 8
38 12
39 16
40 16
41 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edx,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
movzbl %dil,%edi
mov    0x0(,%rdi,8),%rcx
mov    0x0(%rip),%rdx        # 1f <_dico_stderr_log_printer+0x1f>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2b <_dico_stderr_log_printer+0x2b>
mov    $0x0,%eax
callq  35 <_dico_stderr_log_printer+0x35>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    0x0(%rip),%rdi        # 42 <_dico_stderr_log_printer+0x42>
callq  47 <_dico_stderr_log_printer+0x47>
test   %ebx,%ebx
je     6b <_dico_stderr_log_printer+0x6b>
mov    %ebx,%edi
callq  52 <_dico_stderr_log_printer+0x52>
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 61 <_dico_stderr_log_printer+0x61>
mov    $0x0,%eax
callq  6b <_dico_stderr_log_printer+0x6b>
mov    0x0(%rip),%rsi        # 72 <_dico_stderr_log_printer+0x72>
mov    $0xa,%edi
callq  7c <_dico_stderr_log_printer+0x7c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_dico_stderr_log_printer(int lvl, int exitcode, int errcode,
    const char *fmt, va_list ap)
{
    fprintf(stderr, "%s: %s: ", dico_program_name, prefix[lvl & 0xff]);
    vfprintf(stderr, fmt, ap);
    if (errcode)
 fprintf(stderr, ": %s", strerror(errcode));
    fprintf(stderr, "\n");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 8
28 8
29 8
30 9
31 9
32 9
33 9
<<<sep_out_sample>>>
movl   $0x3e8,0x44(%rdi)
movq   $0x0,0x200(%rdi)
movq   $0x0,0x208(%rdi)
movq   $0x0,0x210(%rdi)
retq   
<<<sep_in_sample>>>
CDB___lock_dbenv_create(dbenv)
 DB_ENV *dbenv;
{
 dbenv->lk_max = 1000;
 dbenv->set_lk_conflicts = __lock_set_lk_conflicts;
 dbenv->set_lk_detect = __lock_set_lk_detect;
 dbenv->set_lk_max = __lock_set_lk_max;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  52 <vplob_val+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
vplob_val(VPLOB * vplob, int index)
{
 CPLOB * cplob = (CPLOB*)vplob;
 return (void*) cplob_val(cplob, index);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  102e <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
movq   $0x0,(%rax)
mov    (%rdi),%rax
test   %rax,%rax
je     10b <fix_break_continue+0x42>
mov    0x1c(%rax),%ecx
cmp    $0x34,%ecx
je     eb <fix_break_continue+0x22>
cmp    $0x35,%ecx
je     f8 <fix_break_continue+0x2f>
jmp    103 <fix_break_continue+0x3a>
cmpq   $0x0,0x8(%rax)
jne    103 <fix_break_continue+0x3a>
mov    %rsi,0x8(%rax)
jmp    103 <fix_break_continue+0x3a>
cmpq   $0x0,0x8(%rax)
jne    103 <fix_break_continue+0x3a>
mov    %rdx,0x8(%rax)
mov    (%rax),%rax
test   %rax,%rax
jne    dc <fix_break_continue+0x13>
repz retq 
<<<sep_in_sample>>>
fix_break_continue(INSTRUCTION *list, INSTRUCTION *b_target, INSTRUCTION *c_target)
{
 INSTRUCTION *ip;
 list->d.di->nexti = ((void *)0);
 for (ip = list->nexti; ip != ((void *)0); ip = ip->nexti) {
  switch (ip->opcode) {
  case Op_K_break:
   if (ip->d.di == ((void *)0))
    ip->d.di = b_target;
   break;
  case Op_K_continue:
   if (ip->d.di == ((void *)0))
    ip->d.di = c_target;
   break;
  default:
   break;
  }
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 9
15 9
16 12
17 12
18 13
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0xc(%rdi),%eax
cmp    0x8(%rdi),%eax
jne    9f <dynvec_append+0x2e>
add    %eax,%eax
mov    %eax,0x8(%rdi)
cltq   
lea    0x0(,%rax,8),%rsi
mov    (%rdi),%rdi
callq  9c <dynvec_append+0x2b>
mov    %rax,(%rbx)
mov    (%rbx),%rdx
mov    0xc(%rbx),%eax
lea    0x1(%rax),%ecx
mov    %ecx,0xc(%rbx)
cltq   
mov    %rbp,(%rdx,%rax,8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dynvec_append (struct dynvec *dv, void *element)
{
  if (dv->dv_fill == dv->dv_capacity)
    {
      dv->dv_capacity *= 2;
      dv->dv_vec = xrealloc (dv->dv_vec, sizeof(void *) * dv->dv_capacity);
    }
  dv->dv_vec[dv->dv_fill++] = element;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    %ecx,%edx
mov    %ecx,%esi
callq  1fe <_testr>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  876 <_jcc>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_jci0(jit_state_t *_jit, jit_int32_t code, jit_word_t i0, jit_int32_t r0)
{
    _testr(_jit, r0, r0);
    _jcc(_jit, code, i0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x10,%esi
callq  5b2 <gsl_block_complex_fread+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     5d7 <gsl_block_complex_fread+0x3d>
mov    $0x5,%ecx
mov    $0x1f,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  5d2 <gsl_block_complex_fread+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_complex_fread (FILE * stream, gsl_block_complex * b)
{
  size_t n = b->size ;
  double * data = b->data ;
  size_t items = fread (data, 2 * sizeof (double), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
mov    (%rdi),%rax
test   %r10,%r10
je     1181 <gsl_matrix_ulong_min+0x5a>
push   %rbx
shl    $0x3,%r11
lea    0x0(,%r9,8),%rbx
mov    $0x0,%r8d
jmp    1172 <gsl_matrix_ulong_min+0x4b>
mov    (%rdx),%rcx
cmp    %rcx,%rax
cmova  %rcx,%rax
add    $0x8,%rdx
cmp    %rsi,%rdx
jne    1153 <gsl_matrix_ulong_min+0x2c>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
je     1180 <gsl_matrix_ulong_min+0x59>
test   %r9,%r9
je     1166 <gsl_matrix_ulong_min+0x3f>
lea    (%rdi,%rbx,1),%rsi
mov    %rdi,%rdx
jmp    1153 <gsl_matrix_ulong_min+0x2c>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
gsl_matrix_ulong_min (const gsl_matrix_ulong * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned long min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned long x = m->data[i * tda + j];
          if (x < min)
            min = x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 8
7 8
8 2
9 2
10 2
11 8
12 8
13 12
14 12
15 12
16 12
17 10
18 10
19 8
20 8
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 18
29 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  114 <match_lname>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pred_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  return match_lname (pathname, stat_buf, pred_ptr, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <maybe_replace_line+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
maybe_replace_line ()
{
  return rl_maybe_replace_line ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
mov    -0x10(%rsp),%eax
and    $0x7fff,%eax
jne    1b <rpl_isnanl+0x1b>
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
retq   
cmp    $0x7fff,%eax
jne    36 <rpl_isnanl+0x36>
mov    -0x14(%rsp),%eax
add    $0x80000000,%eax
or     -0x18(%rsp),%eax
setne  %al
movzbl %al,%eax
retq   
mov    -0x14(%rsp),%eax
shr    $0x1f,%eax
xor    $0x1,%eax
retq   
<<<sep_in_sample>>>
rpl_isnanl (long double x)
{
  memory_double m;
  unsigned int exponent;
  m.value = x;
  exponent = (m.word[2] >> 0) & ((16384 - (-16381)) | 7);
  if (exponent == 0)
    return (m.word[1] >> 31);
  else if (exponent == ((16384 - (-16381)) | 7))
    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;
  else
    return (m.word[1] >> 31) ^ 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 7
5 7
6 8
7 8
8 8
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 12
18 12
19 12
20 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     23b <list_tail_item+0xe>
mov    0x8(%rax),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
list_tail_item (struct list *list)
{
  struct list_entry *p = list->tail;
  return p ? p->data : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
mov    $0x0,%eax
cmp    %cl,%sil
je     1c8 <get_failcode_snippet+0x8f>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
mov    $0x0,%eax
cmp    %cl,%sil
je     1c8 <get_failcode_snippet+0x8f>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
mov    $0x0,%eax
cmp    %dl,%cl
je     1c8 <get_failcode_snippet+0x8f>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1a8 <get_failcode_snippet+0x6f>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  1bf <get_failcode_snippet+0x86>
mov    $0x0,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
get_failcode_snippet (const char *source_version)
{
  if (strcmp (source_version, "1.3") == 0)
    return "class conftestfail { static { assert(true); } }\n";
  if (strcmp (source_version, "1.4") == 0)
    return "class conftestfail<T> { T foo() { return null; } }\n";
  if (strcmp (source_version, "1.5") == 0)
    return ((void *)0);
  error (1, 0, gettext ("invalid source_version argument to compile_java_class"));
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 3
10 3
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 5
19 5
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 7
28 7
29 2
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 10
38 11
39 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edi,%edi
je     83c <unset_bash_input+0x13>
cmpl   $0x0,0x0(%rip)        # 838 <unset_bash_input+0xf>
jns    845 <unset_bash_input+0x1c>
jmp    86e <unset_bash_input+0x45>
cmpl   $0x0,0x0(%rip)        # 843 <unset_bash_input+0x1a>
jle    86e <unset_bash_input+0x45>
mov    0x0(%rip),%edi        # 84b <unset_bash_input+0x22>
callq  850 <unset_bash_input+0x27>
movl   $0xffffffff,0x0(%rip)        # 85a <unset_bash_input+0x31>
movl   $0xffffffff,0x0(%rip)        # 864 <unset_bash_input+0x3b>
movl   $0x0,0x0(%rip)        # 86e <unset_bash_input+0x45>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unset_bash_input (check_zero)
     int check_zero;
{
  if ((check_zero && default_buffered_input >= 0) ||
      (check_zero == 0 && default_buffered_input > 0))
    {
      close_buffered_fd (default_buffered_input);
      default_buffered_input = bash_input.location.buffered_fd = -1;
      bash_input.type = st_none;
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 7
10 7
11 8
12 8
13 9
14 11
15 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
mov    0x8(%rdi),%rdi
callq  *0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multilarge_linear_reset(gsl_multilarge_linear_workspace *w)
{
  int status = w->type->reset(w->state);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
lea    0x88(%rdi),%r12
mov    %r12,%rdi
callq  5ff <osip_message_get_authorization+0x1f>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    618 <osip_message_get_authorization+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  612 <osip_message_get_authorization+0x32>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_authorization (const osip_message_t * sip, int pos, osip_authorization_t ** dest)
{
  osip_authorization_t *authorization;
  *dest = ((void *)0);
  if (osip_list_size (&sip->authorizations) <= pos)
    return -1;
  authorization = (osip_authorization_t *) osip_list_get (&sip->authorizations, pos);
  *dest = authorization;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 6
11 5
12 5
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
mov    %esi,0xb0(%rdi)
testb  $0x10,0x20(%rdi)
je     c47 <_wsplt_seterr+0x14>
callq  c47 <_wsplt_seterr+0x14>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_wsplt_seterr (struct wordsplit *wsp, int ec)
{
  wsp->ws_errno = ec;
  if (wsp->ws_flags & 0x00000010)
    wordsplit_perror (wsp);
  return ec;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
movzbl %bh,%edi
mov    0x0(%rip),%rsi        # 31a <write_2_bytes+0xd>
callq  31f <write_2_bytes+0x12>
movzbl %bl,%edi
mov    0x0(%rip),%rsi        # 329 <write_2_bytes+0x1c>
callq  32e <write_2_bytes+0x21>
pop    %rbx
retq   
<<<sep_in_sample>>>
write_2_bytes (unsigned int val)
{
  _IO_putc (((val >> 8) & 0xFF), outfile);
  _IO_putc ((val & 0xFF), outfile);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzbl (%rdi),%eax
test   %al,%al
je     757a <shell_escape+0x2e>
mov    %rdi,%rdx
mov    $0x0,%edi
lea    0x1(%rdi),%rcx
add    $0x4,%rdi
cmp    $0x27,%al
cmovne %rcx,%rdi
add    $0x1,%rdx
movzbl (%rdx),%eax
test   %al,%al
jne    755f <shell_escape+0x13>
jmp    757f <shell_escape+0x33>
mov    $0x0,%edi
add    $0x1,%rdi
callq  7588 <shell_escape+0x3c>
test   %rax,%rax
je     75cc <shell_escape+0x80>
movzbl (%rbx),%ecx
test   %cl,%cl
je     75c4 <shell_escape+0x78>
mov    %rax,%rdx
cmp    $0x27,%cl
jne    75b1 <shell_escape+0x65>
movb   $0x27,(%rdx)
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
movb   $0x27,0x3(%rdx)
lea    0x4(%rdx),%rdx
jmp    75b7 <shell_escape+0x6b>
mov    %cl,(%rdx)
lea    0x1(%rdx),%rdx
add    $0x1,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    7597 <shell_escape+0x4b>
jmp    75c7 <shell_escape+0x7b>
mov    %rax,%rdx
movb   $0x0,(%rdx)
jmp    75d1 <shell_escape+0x85>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
shell_escape(const char *fn)
{
  size_t len = 0;
  const char *inp;
  char *retval, *outp;
  for(inp = fn; *inp; ++inp)
    switch(*inp)
    {
      case '\'': len += 4; break;
      default: len += 1; break;
    }
  outp = retval = malloc(len + 1);
  if(!outp)
    return ((void *)0);
  for(inp = fn; *inp; ++inp)
    switch(*inp)
    {
      case '\'': *outp++ = '\''; *outp++ = '\\'; *outp++ = '\'', *outp++ = '\''; break;
      default: *outp++ = *inp; break;
    }
  *outp = 0;
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 6
7 3
8 10
9 10
10 10
11 10
12 6
13 6
14 6
15 6
16 6
17 3
18 12
19 12
20 13
21 13
22 15
23 15
24 15
25 15
26 16
27 16
28 18
29 18
30 18
31 18
32 18
33 18
34 19
35 19
36 15
37 15
38 15
39 15
40 15
41 15
42 21
43 22
44 14
45 23
46 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <_rl_callback_newline+0x9>
cmpl   $0x0,0x0(%rip)        # 10 <_rl_callback_newline+0x10>
jne    3e <_rl_callback_newline+0x3e>
movl   $0x1,0x0(%rip)        # 1c <_rl_callback_newline+0x1c>
mov    0x0(%rip),%rax        # 23 <_rl_callback_newline+0x23>
test   %rax,%rax
je     30 <_rl_callback_newline+0x30>
mov    0x0(%rip),%edi        # 2e <_rl_callback_newline+0x2e>
callq  *%rax
cmpl   $0x0,0x0(%rip)        # 37 <_rl_callback_newline+0x37>
je     3e <_rl_callback_newline+0x3e>
callq  3e <_rl_callback_newline+0x3e>
callq  43 <_rl_callback_newline+0x43>
mov    0x0(%rip),%eax        # 49 <_rl_callback_newline+0x49>
test   %eax,%eax
je     58 <_rl_callback_newline+0x58>
mov    0x0(%rip),%edi        # 53 <_rl_callback_newline+0x53>
callq  58 <_rl_callback_newline+0x58>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_callback_newline ()
{
  rl_initialize ();
  if (in_handler == 0)
    {
      in_handler = 1;
      if (rl_prep_term_function)
 (*rl_prep_term_function) (_rl_meta_flag);
      if (rl_persistent_signal_handlers)
 rl_set_signals ();
    }
  readline_internal_setup ();
  do { if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 7
7 7
8 7
9 8
10 8
11 9
12 9
13 10
14 12
15 13
16 13
17 13
18 13
19 13
20 14
21 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
callq  a5b <grecs_print_value+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_value(struct grecs_value *val, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_value(val, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%r12d
test   %edi,%edi
mov    $0x0,%eax
cmovns %edi,%eax
mov    %eax,%esi
mov    0x0(%rip),%ebp        # 302 <terminal_insert_lines+0x19>
sub    %eax,%ebp
mov    $0x0,%edi
callq  30e <terminal_insert_lines+0x25>
mov    0x0(%rip),%rdi        # 315 <terminal_insert_lines+0x2c>
test   %rdi,%rdi
jne    324 <terminal_insert_lines+0x3b>
mov    %r12d,%ebx
test   %r12d,%r12d
jne    342 <terminal_insert_lines+0x59>
jmp    35a <terminal_insert_lines+0x71>
mov    %r12d,%edx
mov    $0x0,%esi
callq  331 <terminal_insert_lines+0x48>
mov    $0x0,%edx
mov    %ebp,%esi
mov    %rax,%rdi
callq  340 <terminal_insert_lines+0x57>
jmp    35a <terminal_insert_lines+0x71>
mov    $0x0,%edx
mov    %ebp,%esi
mov    0x0(%rip),%rdi        # 350 <terminal_insert_lines+0x67>
callq  355 <terminal_insert_lines+0x6c>
sub    $0x1,%ebx
jne    342 <terminal_insert_lines+0x59>
mov    0x0(%rip),%rdi        # 361 <terminal_insert_lines+0x78>
callq  366 <terminal_insert_lines+0x7d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
terminal_insert_lines (int start, int count)
{
  int lines;
  if (start < 0)
    start = 0;
  lines = screenheight - start;
  terminal_goto_xy (0, start);
  if (term_AL)
    tputs (tgoto (term_AL, 0, count), lines, output_character_function);
  else
    {
      while (count--)
        tputs (term_al, lines, output_character_function);
    }
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 7
12 7
13 8
14 8
15 8
16 8
17 12
18 12
19 12
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 13
29 13
30 13
31 13
32 12
33 12
34 15
35 15
36 16
37 16
38 16
39 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x80,0x0(%rip)        # 4d80 <do_insertfile_void+0xb>
je     4d89 <do_insertfile_void+0x14>
callq  4d87 <do_insertfile_void+0x12>
jmp    4db9 <do_insertfile_void+0x44>
mov    0x0(%rip),%eax        # 4d8f <do_insertfile_void+0x1a>
and    $0x2080,%eax
cmp    $0x80,%eax
jne    4daf <do_insertfile_void+0x3a>
mov    $0x0,%edi
callq  4da5 <do_insertfile_void+0x30>
mov    %rax,%rdi
callq  4dad <do_insertfile_void+0x38>
jmp    4db9 <do_insertfile_void+0x44>
mov    $0x0,%edi
callq  4db9 <do_insertfile_void+0x44>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_insertfile_void(void)
{
    if (((flags[((RESTRICTED) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((RESTRICTED) % (sizeof(unsigned) * 8)))) != 0)) {
 show_restricted_warning();
 return;
    }
    if (((flags[((VIEW_MODE) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((VIEW_MODE) % (sizeof(unsigned) * 8)))) != 0) && !((flags[((MULTIBUFFER) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((MULTIBUFFER) % (sizeof(unsigned) * 8)))) != 0))
 statusbar(gettext("Key invalid in non-multibuffer mode"));
    else
 do_insertfile(
  0
  );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 7
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 13
18 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  b8 <compute_float_variance>
test   %rbx,%rbx
js     93a <gsl_stats_float_sd_m+0x15>
cvtsi2sd %rbx,%xmm1
jmp    952 <gsl_stats_float_sd_m+0x2d>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     962 <gsl_stats_float_sd_m+0x3d>
cvtsi2sd %rax,%xmm2
jmp    977 <gsl_stats_float_sd_m+0x52>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    9e0 <gsl_stats_float_sd_m+0xbb>
test   %rbx,%rbx
js     995 <gsl_stats_float_sd_m+0x70>
cvtsi2sd %rbx,%xmm2
jmp    9ad <gsl_stats_float_sd_m+0x88>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm2
addsd  %xmm2,%xmm2
sub    $0x1,%rbx
js     9ba <gsl_stats_float_sd_m+0x95>
cvtsi2sd %rbx,%xmm1
jmp    9cf <gsl_stats_float_sd_m+0xaa>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
callq  9dc <gsl_stats_float_sd_m+0xb7>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_stats_float_sd_m (const float data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_float_variance (data, stride, n, mean);
  const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
  return sd;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 6
57 6
58 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  141 <init_filelist+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_filelist (void)
{
  _obstack_begin ((&os_filelist), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %rbx
callq  6 <xvprintf+0x6>
mov    %eax,%ebx
test   %eax,%eax
jns    38 <xvprintf+0x38>
mov    0x0(%rip),%rdi        # 13 <xvprintf+0x13>
callq  18 <xvprintf+0x18>
test   %eax,%eax
jne    38 <xvprintf+0x38>
callq  21 <xvprintf+0x21>
mov    0x0(%rip),%edi        # 27 <xvprintf+0x27>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%eax
callq  38 <xvprintf+0x38>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
xvprintf (char const *__restrict format, va_list args)
{
  int retval = vprintf (format, args);
  if (retval < 0 && ! ferror (stdout))
    error (exit_failure, (*__errno_location ()), ((const char *) ("cannot perform formatted output")));
  return retval;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 1d <rpmIsDebug+0x7>
setle  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
rpmIsDebug(void)
{
    return (minLevel <= 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
callq  ab3 <and_term>
mov    %eax,%ecx
test   %eax,%eax
jne    b87 <xor_term+0x66>
jmp    b5a <xor_term+0x39>
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
test   %eax,%eax
je     b7e <xor_term+0x5d>
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  ab3 <and_term>
test   %eax,%eax
jne    b85 <xor_term+0x64>
mov    0xc(%rsp),%eax
xor    %eax,(%rbx)
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
cmp    $0x17,%eax
je     b36 <xor_term+0x15>
mov    $0x6,%ecx
test   %eax,%eax
je     b87 <xor_term+0x66>
callq  0 <eval_undo>
mov    $0x0,%ecx
jmp    b87 <xor_term+0x66>
mov    $0x6,%ecx
jmp    b87 <xor_term+0x66>
mov    %eax,%ecx
mov    %ecx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
xor_term (eval_token et, int32_t *v1)
{
  int32_t v2;
  eval_error er;
  if ((er = and_term (et, v1)) != NO_ERROR)
    return er;
  while ((et = eval_lex (&v2)) == XOR)
    {
      et = eval_lex (&v2);
      if (et == ERROR)
        return UNKNOWN_INPUT;
      if ((er = and_term (et, &v2)) != NO_ERROR)
        return er;
      *v1 ^= v2;
    }
  if (et == ERROR)
    return UNKNOWN_INPUT;
  eval_undo ();
  return NO_ERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 6
6 5
7 5
8 5
9 9
10 9
11 10
12 10
13 12
14 12
15 12
16 12
17 12
18 14
19 14
20 7
21 7
22 7
23 7
24 17
25 16
26 16
27 18
28 19
29 19
30 11
31 11
32 12
33 20
34 20
35 20
36 20
<<<sep_out_sample>>>
push   %rbx
sub    $0x40,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
cmp    $0x2,%edi
jle    1155 <setescape+0xa2>
mov    %rsi,%rbx
mov    0x8(%rsi),%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10e7 <setescape+0x34>
mov    0x8(%rbx),%rax
jmp    10fe <setescape+0x4b>
movb   $0x0,(%rsp)
mov    $0xa,%edi
callq  10fb <setescape+0x48>
mov    %rsp,%rax
movzbl (%rax),%eax
test   %al,%al
je     110b <setescape+0x58>
mov    %al,0x0(%rip)        # 110b <setescape+0x58>
cmpl   $0x0,0x0(%rip)        # 1112 <setescape+0x5f>
jne    1132 <setescape+0x7f>
movzbl 0x0(%rip),%edi        # 111b <setescape+0x68>
callq  1f <control>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1132 <setescape+0x7f>
mov    0x0(%rip),%rdi        # 1139 <setescape+0x86>
callq  113e <setescape+0x8b>
mov    $0x1,%eax
mov    0x38(%rsp),%rcx
xor    %fs:0x28,%rcx
je     11a5 <setescape+0xf2>
jmp    11a0 <setescape+0xed>
mov    $0x0,%edx
mov    %rdx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  116c <setescape+0xb9>
mov    $0x0,%edi
mov    $0x0,%eax
callq  117b <setescape+0xc8>
mov    0x0(%rip),%rdx        # 1182 <setescape+0xcf>
mov    $0x32,%esi
mov    %rsp,%rdi
callq  118f <setescape+0xdc>
test   %rax,%rax
je     10ed <setescape+0x3a>
mov    %rsp,%rax
jmpq   10fe <setescape+0x4b>
callq  11a5 <setescape+0xf2>
add    $0x40,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
setescape (int argc, char *argv[])
{
  register char *arg;
  char buf[50];
  printf ("Deprecated usage - please use 'set escape%s%s' in the future.\n",
   (argc > 2) ? " " : "", (argc > 2) ? argv[1] : "");
  if (argc > 2)
    arg = argv[1];
  else
    {
      printf ("new escape character: ");
      if (fgets (buf, sizeof (buf), stdin) == ((void *)0))
 {
   buf[0] = '\0';
   printf ("\n");
 }
      arg = buf;
    }
  if (arg[0] != '\0')
    escape = arg[0];
  if (!In3270)
    {
      printf ("Escape character is '%s'.\n", control (escape));
    }
  fflush (stdout);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 8
14 8
15 14
16 15
17 15
18 17
19 19
20 19
21 19
22 20
23 21
24 21
25 23
26 23
27 23
28 23
29 23
30 23
31 25
32 25
33 27
34 27
35 27
36 27
37 27
38 5
39 5
40 5
41 5
42 5
43 11
44 11
45 11
46 12
47 12
48 12
49 12
50 12
51 12
52 17
53 17
54 27
55 27
56 27
57 27
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,0x8(%rsi)
ja     3a24 <gsl_matrix_char_column+0x4b>
mov    $0x4,%ecx
mov    $0x33,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  39fc <gsl_matrix_char_column+0x23>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    3a49 <gsl_matrix_char_column+0x70>
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rcx
mov    0x20(%rsi),%rax
mov    (%rsi),%rsi
mov    %rsi,(%rdi)
mov    %rcx,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_column (gsl_matrix_char * m, const size_t j)
{
  _gsl_vector_char_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 12
18 13
19 16
20 16
21 16
22 16
23 16
24 16
25 18
26 18
27 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  2bec <remove_pidfile+0xe>
test   %eax,%eax
je     2c21 <remove_pidfile+0x43>
callq  2bf5 <remove_pidfile+0x17>
mov    (%rax),%edi
callq  2bfc <remove_pidfile+0x1e>
mov    %rax,%rbp
mov    $0x0,%edi
callq  2c09 <remove_pidfile+0x2b>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x3,%edi
mov    $0x0,%eax
callq  2c21 <remove_pidfile+0x43>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
remove_pidfile (char *name)
{
  if (unlink (name))
    logmsg (3, gettext("cannot unlink pidfile `%s': %s"),
     name, strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4cc <nettle_sha512_224_init+0x7>
mov    %rax,(%rdi)
mov    0x0(%rip),%rax        # 4d6 <nettle_sha512_224_init+0x11>
mov    %rax,0x8(%rdi)
mov    0x0(%rip),%rax        # 4e1 <nettle_sha512_224_init+0x1c>
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 4ec <nettle_sha512_224_init+0x27>
mov    %rax,0x18(%rdi)
mov    0x0(%rip),%rax        # 4f7 <nettle_sha512_224_init+0x32>
mov    %rax,0x20(%rdi)
mov    0x0(%rip),%rax        # 502 <nettle_sha512_224_init+0x3d>
mov    %rax,0x28(%rdi)
mov    0x0(%rip),%rax        # 50d <nettle_sha512_224_init+0x48>
mov    %rax,0x30(%rdi)
mov    0x0(%rip),%rax        # 518 <nettle_sha512_224_init+0x53>
mov    %rax,0x38(%rdi)
movq   $0x0,0x48(%rdi)
movq   $0x0,0x40(%rdi)
movl   $0x0,0xd0(%rdi)
retq   
<<<sep_in_sample>>>
nettle_sha512_224_init(struct sha512_ctx *ctx)
{
  static const uint64_t H0[8] =
  {
    0x8c3d37c819544da2ULL, 0x73e1996689dcd4d6ULL,
    0x1dfab7ae32ff9c82ULL, 0x679dd514582f9fcfULL,
    0x0f6d2b697bd44da8ULL, 0x77e36f7304c48942ULL,
    0x3f9d85a86a1d36c8ULL, 0x1112e6ad91d692a1ULL,
  };
  memcpy(ctx->state, H0, sizeof(H0));
  ctx->count_low = ctx->count_high = 0;
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 10
2 10
3 10
4 10
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
imul   $0x6c078965,(%rdi),%eax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_get (void *vstate)
{
  ran_state_t *state = (ran_state_t *) vstate;
  state->x = (1812433253UL * state->x) & 0xffffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
sub    %rsi,%rdi
callq  8c0 <__gmpn_mu_div_qr_itch+0x12>
mov    %rax,%rbx
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  8d1 <__gmpn_mu_div_qr_itch+0x23>
lea    0x4(%rbx,%rbx,2),%rdx
cmp    %rax,%rdx
cmovge %rdx,%rax
add    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
__gmpn_mu_div_qr_itch (mp_size_t nn, mp_size_t dn, int mua_k)
{
  mp_size_t in = __gmpn_mu_div_qr_choose_in (nn - dn, dn, mua_k);
  mp_size_t itch_preinv = __gmpn_preinv_mu_div_qr_itch (nn, dn, in);
  mp_size_t itch_invapp = (2 * (in + 1)) + in + 2;
  do {} while (0);
  return in + ((itch_invapp) > (itch_preinv) ? (itch_invapp) : (itch_preinv));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 5
14 7
15 7
16 7
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%r15d
mov    %edi,0x4(%rsp)
mov    %rdx,0x8(%rsp)
mov    $0x1,%eax
test   %rdx,%rdx
je     432 <argcv_string+0x10b>
mov    %rsi,%rbp
mov    $0x1,%edi
callq  35c <argcv_string+0x35>
mov    %rax,%rbx
test   %rax,%rax
je     417 <argcv_string+0xf0>
movb   $0x0,(%rax)
test   %r15d,%r15d
jle    425 <argcv_string+0xfe>
mov    $0x0,%r13d
mov    $0x0,%r12d
mov    $0xffffffffffffffff,%r14
mov    %rbp,%r15
mov    0x0(%rbp),%rdi
mov    $0x0,%eax
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
sub    %rcx,%r13
mov    %r13,%rsi
mov    %rbx,%rdi
callq  3a6 <argcv_string+0x7f>
mov    %rax,%rbx
test   %rax,%rax
je     41e <argcv_string+0xf7>
test   %r12d,%r12d
je     3ca <argcv_string+0xa3>
mov    %rax,%rdi
mov    $0x0,%eax
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x20,-0x1(%rbx,%rcx,1)
mov    (%r15),%rsi
mov    %rbx,%rdi
callq  3d5 <argcv_string+0xae>
add    $0x1,%r12d
add    $0x8,%rbp
cmp    0x4(%rsp),%r12d
jne    387 <argcv_string+0x60>
mov    %rbx,%rsi
mov    $0xffffffffffffffff,%r8
mov    $0x0,%eax
cmpb   $0x0,(%rbx)
jne    3fd <argcv_string+0xd6>
jmp    425 <argcv_string+0xfe>
movb   $0x0,(%rdx)
mov    %rsi,%rdi
mov    %r8,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    -0x2(%rsi,%rdx,1),%rdx
cmpb   $0x20,(%rdx)
je     3fa <argcv_string+0xd3>
jmp    425 <argcv_string+0xfe>
mov    $0x1,%eax
jmp    432 <argcv_string+0x10b>
mov    $0x1,%eax
jmp    432 <argcv_string+0x10b>
mov    0x8(%rsp),%rax
mov    %rbx,(%rax)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
argcv_string (int argc, char **argv, char **pstring)
{
  int i;
  size_t len;
  char *buffer;
  if (pstring == ((void *)0))
    return 1;
  buffer = malloc (1);
  if (buffer == ((void *)0))
    return 1;
  *buffer = '\0';
  for (len = i = 0; i < argc; i++)
    {
      len += strlen (argv[i]) + 2;
      buffer = realloc (buffer, len);
      if (buffer == ((void *)0))
 return 1;
      if (i != 0)
 strcat (buffer, " ");
      strcat (buffer, argv[i]);
    }
  if (*buffer != '\0')
    {
      while (buffer[strlen (buffer) - 1] == ' ')
 {
   buffer[strlen (buffer) - 1] = '\0';
 }
    }
  if (pstring)
    *pstring = buffer;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 7
12 6
13 6
14 6
15 8
16 8
17 8
18 9
19 9
20 11
21 12
22 12
23 12
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 15
33 15
34 15
35 15
36 16
37 16
38 18
39 18
40 19
41 19
42 19
43 19
44 19
45 19
46 20
47 20
48 20
49 12
50 12
51 12
52 12
53 15
54 24
55 24
56 22
57 22
58 22
59 26
60 24
61 24
62 24
63 24
64 24
65 24
66 24
67 24
68 24
69 10
70 10
71 17
72 17
73 30
74 30
75 31
76 32
77 32
78 32
79 32
80 32
81 32
82 32
83 32
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %esi,%esi
js     401b <info_backward_char+0x15>
mov    %esi,%ebx
test   %esi,%esi
jne    4027 <info_backward_char+0x21>
jmp    4034 <info_backward_char+0x2e>
neg    %esi
nopl   (%rax)
callq  4025 <info_backward_char+0x1f>
jmp    403c <info_backward_char+0x36>
mov    %rbp,%rdi
callq  3fac <point_backward_char>
sub    $0x1,%ebx
jne    4027 <info_backward_char+0x21>
mov    %rbp,%rdi
callq  3ed <info_show_point>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
info_backward_char (WINDOW *window, int count)
{
  if (count < 0)
    info_forward_char (window, -count);
  else
    {
      while (count--)
        point_backward_char (window);
      info_show_point (window);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 7
9 7
10 7
11 4
12 4
13 4
14 4
15 8
16 8
17 7
18 7
19 9
20 9
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x2,%edi
callq  19ac <catchAllSignals+0x10>
cmp    $0xffffffffffffffff,%rax
setne  %bl
movzbl %bl,%ebx
mov    $0x0,%esi
mov    $0x3,%edi
callq  19c5 <catchAllSignals+0x29>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x6,%edi
callq  19e0 <catchAllSignals+0x44>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0xf,%edi
callq  19fb <catchAllSignals+0x5f>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x14,%edi
callq  1a16 <catchAllSignals+0x7a>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x9,%edi
callq  1a31 <catchAllSignals+0x95>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    $0x0,%esi
mov    $0x13,%edi
callq  1a4c <catchAllSignals+0xb0>
cmp    $0xffffffffffffffff,%rax
mov    $0x0,%eax
cmove  %eax,%ebx
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
catchAllSignals()
{
  int res = 1;
    if(signal(2, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(3, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(6, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(15, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(20, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(9, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    if(signal(19, sighandler) == ((__sighandler_t) -1)) { res = 0; }
    return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 10
42 10
43 10
44 12
45 12
46 12
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     65 <cdio_log+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  1cb <cdio_logv>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
cdio_log(cdio_log_level_t level, const char format[], ...)
{
  va_list args;
  __builtin_va_start(args,format);
  cdio_logv (level, format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 4
18 4
19 4
20 4
21 4
22 5
23 5
24 7
25 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpq   $0x0,0x20(%rdi)
jne    c56 <message_append_mime_header+0x1c>
callq  c52 <message_append_mime_header+0x18>
mov    %rax,0x20(%rbx)
mov    %rbp,%rdi
callq  c5e <message_append_mime_header+0x24>
mov    0x20(%rbx),%rdi
mov    %rax,%rsi
callq  c6a <message_append_mime_header+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
message_append_mime_header (MESSAGE msg, const char *buf)
{
  if (!msg->mime_hdr)
    msg->mime_hdr = list_create ();
  list_append (msg->mime_hdr, xstrdup (buf));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
je     75d <ignore_primitive+0x3a>
sub    $0x8,%rsp
callq  736 <ignore_primitive+0x13>
test   %rax,%rax
je     754 <ignore_primitive+0x31>
mov    0x8(%rax),%rdi
mov    $0x21,%esi
callq  749 <ignore_primitive+0x26>
test   %rax,%rax
setne  %al
movzbl %al,%eax
jmp    759 <ignore_primitive+0x36>
mov    $0x0,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
ignore_primitive(char *name)
{
  struct unitlist *ul;
  if (!name)
    return 0;
  ul = ulookup(name);
  if (ul && strchr(ul->value, '!'))
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 2
5 6
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 10
17 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  144c <gsl_sf_expint_Ei+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1472 <gsl_sf_expint_Ei+0x32>
mov    %eax,%ecx
mov    $0x23f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  146b <gsl_sf_expint_Ei+0x2b>
movsd  (%rsp),%xmm0
jmp    1472 <gsl_sf_expint_Ei+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expint_Ei(const double x)
{
  gsl_sf_result result; int status = gsl_sf_expint_Ei_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_expint_Ei_e(x, &result)", "expint.c", 575, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %esi,%esi
js     4058 <info_forward_char+0x15>
mov    %esi,%ebx
test   %esi,%esi
jne    4062 <info_forward_char+0x1f>
jmp    406f <info_forward_char+0x2c>
neg    %esi
callq  405f <info_forward_char+0x1c>
nop
jmp    4077 <info_forward_char+0x34>
mov    %rbp,%rdi
callq  3c05 <point_forward_char>
sub    $0x1,%ebx
jne    4062 <info_forward_char+0x1f>
mov    %rbp,%rdi
callq  3ed <info_show_point>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
info_forward_char (WINDOW *window, int count)
{
  if (count < 0)
    info_backward_char (window, -count);
  else
    {
      while (count--)
        point_forward_char (window);
      info_show_point (window);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 7
9 7
10 7
11 4
12 4
13 4
14 4
15 8
16 8
17 7
18 7
19 9
20 9
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rsi),%rbp
mov    0x8(%rsi),%r12
test   %rbp,%rbp
je     3471 <gsl_block_ushort_fscanf+0x71>
mov    %rdi,%r13
mov    $0x0,%ebx
jmp    3449 <gsl_block_ushort_fscanf+0x49>
mov    $0x5,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3439 <gsl_block_ushort_fscanf+0x39>
mov    $0x5,%eax
jmp    347d <gsl_block_ushort_fscanf+0x7d>
add    $0x1,%rbx
cmp    %rbp,%rbx
je     3478 <gsl_block_ushort_fscanf+0x78>
lea    0xe(%rsp),%rdx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  3460 <gsl_block_ushort_fscanf+0x60>
movzwl 0xe(%rsp),%edx
mov    %dx,(%r12,%rbx,2)
cmp    $0x1,%eax
je     3440 <gsl_block_ushort_fscanf+0x40>
jmp    3420 <gsl_block_ushort_fscanf+0x20>
mov    $0x0,%eax
jmp    347d <gsl_block_ushort_fscanf+0x7d>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_block_ushort_fscanf (FILE * stream, gsl_block_ushort * b)
{
  size_t n = b->size ;
  unsigned short * data = b->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          unsigned short tmp ;
          int status = fscanf (stream, "%hu", &tmp) ;
          data [1 * i + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 90, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 6
21 6
22 6
23 12
24 12
25 12
26 12
27 12
28 13
29 13
30 14
31 14
32 14
33 20
34 20
35 20
36 21
37 21
38 21
39 21
40 21
41 21
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    8 <tokenize+0x8>
mov    (%rsi),%rdi
movzbl (%rdi),%edx
mov    %rdi,%rcx
mov    $0x0,%r8d
test   %dl,%dl
jne    21 <tokenize+0x21>
mov    %rdi,(%rsi)
mov    $0x0,%eax
retq   
cmp    $0x3b,%dl
jne    2c <tokenize+0x2c>
cmp    $0x5c,%r8d
jne    42 <tokenize+0x42>
movsbl %dl,%r8d
add    $0x1,%rcx
movzbl (%rcx),%edx
test   %dl,%dl
jne    21 <tokenize+0x21>
mov    %rcx,(%rsi)
mov    %rdi,%rax
retq   
movb   $0x0,(%rcx)
add    $0x1,%rcx
mov    %rcx,(%rsi)
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
tokenize (char *s, char **save_ptr)
{
  int c;
  char *token;
  if (s == ((void *)0))
    {
      s = *save_ptr;
    }
  if (*s == '\0')
    {
      *save_ptr = s;
      return ((void *)0);
    }
  for (token = s, c = 0; *s; s++)
    {
      if (*s == ';' && c != '\\')
 {
   break;
 }
      c = *s;
    }
  if (*s == '\0')
    {
      *save_ptr = s;
    }
  else
    {
      *s = '\0';
      *save_ptr = s + 1;
    }
  return token;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 9
5 9
6 9
7 9
8 9
9 11
10 12
11 12
12 16
13 16
14 16
15 16
16 20
17 14
18 14
19 14
20 14
21 24
22 31
23 31
24 28
25 29
26 29
27 31
28 32
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    $0x1006,%eax
test   %rdi,%rdi
je     24bf <amd_close+0xa7>
mov    0x50(%rdi),%rbp
mov    %rbp,%rdi
callq  23c3 <amd_pool_flush>
mov    0x40(%r13),%rdi
callq  2448 <amd_close+0x30>
cmpq   $0x0,0x68(%rbp)
je     2485 <amd_close+0x6d>
mov    $0x0,%ebx
mov    $0x0,%r12d
mov    0x78(%rbp),%rax
mov    (%rax,%rbx,8),%rsi
lea    0x38(%rsi),%rdi
callq  246b <amd_close+0x53>
mov    0x78(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
callq  2478 <amd_close+0x60>
add    $0x1,%r12d
movslq %r12d,%rbx
cmp    0x68(%rbp),%rbx
jb     245a <amd_close+0x42>
mov    0x78(%rbp),%rdi
callq  248e <amd_close+0x76>
movq   $0x0,0x78(%rbp)
movq   $0x0,0x68(%rbp)
movq   $0x0,0x70(%rbp)
movq   $0x0,0x80(%rbp)
mov    0x40(%r13),%rdi
callq  24ba <amd_close+0xa2>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
amd_close (mu_mailbox_t mailbox)
{
  struct _amd_data *amd;
  int i;
  if (!mailbox)
    return (0x1000 +6);
  amd = mailbox->data;
  amd_pool_flush (amd);
  mu_monitor_wrlock (mailbox->monitor);
  for (i = 0; i < amd->msg_count; i++)
    {
      mu_message_destroy (&amd->msg_array[i]->message, amd->msg_array[i]);
      free (amd->msg_array[i]);
    }
  free (amd->msg_array);
  amd->msg_array = ((void *)0);
  amd->msg_count = 0;
  amd->msg_max = 0;
  amd->uidvalidity = 0;
  mu_monitor_unlock (mailbox->monitor);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 5
9 5
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 10
27 10
28 10
29 10
30 15
31 15
32 16
33 17
34 18
35 19
36 20
37 20
38 21
39 22
40 22
41 22
42 22
43 22
44 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     ef2c <gsl_fft_real_wavetable_free+0x28>
mov    0x410(%rdi),%rdi
callq  ef19 <gsl_fft_real_wavetable_free+0x15>
movq   $0x0,0x410(%rbx)
mov    %rbx,%rdi
callq  ef2c <gsl_fft_real_wavetable_free+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_fft_real_wavetable_free (gsl_fft_real_wavetable * wavetable)
{
  if (!wavetable) { return ; };
  free (wavetable->trig);
  wavetable->trig = ((void *)0);
  free (wavetable) ;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %esi,%esi
callq  1486 <afmrealloc+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
afmrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <try_nocreate+0xf>
test   %eax,%eax
jne    1e <try_nocreate+0x1e>
callq  18 <try_nocreate+0x18>
movl   $0x11,(%rax)
callq  23 <try_nocreate+0x23>
cmpl   $0x2,(%rax)
setne  %al
movzbl %al,%eax
neg    %eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
try_nocreate (char *tmpl, void *flags)
{
  struct stat st;
  if (lstat (tmpl, &st) == 0)
    (*__errno_location ()) = (17);
  return (*__errno_location ()) == 2 ? 0 : -1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    $0x13f,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  f30 <new_fd_bitmap+0x1c>
mov    %rax,%rbx
mov    %ebp,(%rax)
test   %ebp,%ebp
je     f64 <new_fd_bitmap+0x50>
movslq %ebp,%rbp
mov    $0x145,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  f4e <new_fd_bitmap+0x3a>
mov    %rax,0x8(%rbx)
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  f62 <new_fd_bitmap+0x4e>
jmp    f6c <new_fd_bitmap+0x58>
movq   $0x0,0x8(%rax)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
new_fd_bitmap (size)
     int size;
{
  struct fd_bitmap *ret;
  ret = (struct fd_bitmap *)sh_xmalloc((sizeof (struct fd_bitmap)), "execute_cmd.c", 319);
  ret->size = size;
  if (size)
    {
      ret->bitmap = (char *)sh_xmalloc((size), "execute_cmd.c", 325);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)((void *)0);
  return (ret);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 13
25 15
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
mov    0x98(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_message_get_call_id (const osip_message_t * sip)
{
  return sip->call_id;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
__m_SIMENVIR(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
cmpb   $0x0,(%rdi)
je     1d1 <grecs_hash_string_ci+0x2c>
mov    $0x0,%eax
lea    (%rax,%rax,1),%ebp
movzbl (%rbx),%edi
callq  1c4 <grecs_hash_string_ci+0x1f>
xor    %ebp,%eax
add    $0x1,%rbx
cmpb   $0x0,(%rbx)
jne    1b9 <grecs_hash_string_ci+0x14>
jmp    1d6 <grecs_hash_string_ci+0x31>
mov    $0x0,%eax
mov    %eax,%eax
mov    $0x0,%edx
div    %r12
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_hash_string_ci(const char *name, unsigned long hashsize)
{
 unsigned i;
 for (i = 0; *name; name++) {
  i <<= 1;
  i ^= tolower (*(unsigned char*) name);
 }
 return i % hashsize;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 6
13 4
14 4
15 4
16 4
17 4
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 3b53 <bash_re_edit+0xb>
test   %rdi,%rdi
je     3b67 <bash_re_edit+0x1f>
mov    $0x29d,%edx
mov    $0x0,%esi
callq  3b67 <bash_re_edit+0x1f>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
mov    $0x29f,%edx
mov    $0x0,%esi
callq  3b8d <bash_re_edit+0x45>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3b98 <bash_re_edit+0x50>
mov    %rax,0x0(%rip)        # 3b9f <bash_re_edit+0x57>
mov    0x0(%rip),%rax        # 3ba6 <bash_re_edit+0x5e>
mov    %rax,0x0(%rip)        # 3bad <bash_re_edit+0x65>
movq   $0x0,0x0(%rip)        # 3bb8 <bash_re_edit+0x70>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
bash_re_edit (line)
     char *line;
{
  do { if (push_to_readline) sh_xfree((push_to_readline), "bashline.c", 669); } while (0);
  push_to_readline = (char *)strcpy (sh_xmalloc((1 + strlen (line)), "bashline.c", 671), (line));
  old_rl_startup_hook = rl_startup_hook;
  rl_startup_hook = bash_push_line;
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 9
26 9
27 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%rbx
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r10
mov    (%r10),%edi
test   %rbp,%rbp
je     17bc <gsl_matrix_uint_minmax+0x65>
shl    $0x2,%r12
lea    0x0(,%rbx,4),%r13
mov    %edi,%r8d
mov    $0x0,%r11d
jmp    17ae <gsl_matrix_uint_minmax+0x57>
mov    (%rcx),%eax
cmp    %eax,%r8d
cmova  %eax,%r8d
cmp    %eax,%edi
cmovb  %eax,%edi
add    $0x4,%rcx
cmp    %r9,%rcx
jne    178b <gsl_matrix_uint_minmax+0x34>
add    $0x1,%r11
add    %r12,%r10
cmp    %rbp,%r11
je     17bf <gsl_matrix_uint_minmax+0x68>
test   %rbx,%rbx
je     17a2 <gsl_matrix_uint_minmax+0x4b>
lea    (%r10,%r13,1),%r9
mov    %r10,%rcx
jmp    178b <gsl_matrix_uint_minmax+0x34>
mov    %edi,%r8d
mov    %r8d,(%rsi)
mov    %edi,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_uint_minmax (const gsl_matrix_uint * m,
                               unsigned int * min_out,
                               unsigned int * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned int max = m->data[0 * tda + 0];
  unsigned int min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned int x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 7
8 8
9 8
10 11
11 11
12 11
13 11
14 9
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 15
23 13
24 13
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 9
35 26
36 27
37 28
38 28
39 28
40 28
41 28
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    $0x48,%esi
mov    $0x1,%edi
callq  f1 <cdio_stream_new+0x1b>
mov    %rbp,(%rax)
mov    (%rbx),%rcx
mov    %rcx,0x8(%rax)
mov    0x8(%rbx),%rcx
mov    %rcx,0x10(%rax)
mov    0x10(%rbx),%rcx
mov    %rcx,0x18(%rax)
mov    0x18(%rbx),%rcx
mov    %rcx,0x20(%rax)
mov    0x20(%rbx),%rcx
mov    %rcx,0x28(%rax)
mov    0x28(%rbx),%rcx
mov    %rcx,0x30(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cdio_stream_new(void *user_data, const cdio_stream_io_functions *funcs)
{
  CdioDataSource_t *new_obj;
  new_obj = calloc (1, sizeof (CdioDataSource_t));
  new_obj->user_data = user_data;
  memcpy(&(new_obj->op), funcs, sizeof(cdio_stream_io_functions));
  return new_obj;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
cmp    $0x2f,%edi
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
isdirpunct(int c)
{
 return (c == '/');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    (%rdx),%eax
mov    %eax,(%rsi)
mov    0x4(%rdx),%eax
mov    %eax,0x4(%rsi)
mov    0x8(%rdx),%edi
callq  30d <rpmbis_ntoh_header+0x1e>
mov    %eax,0x8(%rbx)
mov    0xc(%rbp),%edi
callq  318 <rpmbis_ntoh_header+0x29>
mov    %eax,0xc(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rpmbis_ntoh_header(RPMBIS * rpmbis, RPM_HSHEADER * dst, RPM_PX_HSHEADER * src)
{
 memcpy(&(dst->magic), &(src->px_magic), sizeof(src->px_magic));
 memcpy(&(dst->reserved), &(src->px_reserved), sizeof(src->px_reserved));
 dst->nindex = (int)ntohl(*((uint32_t*)(src->px_nindex)));
 dst->hsize = (int)ntohl(*((uint32_t*)(src->px_hsize)));
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0x18,%edi
callq  7e4 <gl_linked_nx_add_after+0x17>
test   %rax,%rax
je     803 <gl_linked_nx_add_after+0x36>
mov    %r12,0x10(%rax)
mov    %rbx,0x8(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
mov    %rax,(%rbx)
addq   $0x1,0x40(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gl_linked_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  gl_list_node_t new_node =
    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));
  if (new_node == ((void *)0))
    return ((void *)0);
  new_node->value = elt;
  new_node->prev = node;
  new_node->next = node->next;
  new_node->next->prev = new_node;
  node->next = new_node;
  list->count++;
  return new_node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 7
12 8
13 9
14 9
15 10
16 11
17 12
18 14
19 14
20 14
21 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  266b <branch>
cmpq   $0x10d,0x5a0(%rbx)
jne    22a1 <regexp+0x47>
mov    %rbx,%rdi
callq  187d <lex>
mov    %rax,0x5a0(%rbx)
mov    %rbx,%rdi
callq  266b <branch>
mov    $0x10d,%esi
mov    %rbx,%rdi
callq  a95 <addtok>
cmpq   $0x10d,0x5a0(%rbx)
je     2270 <regexp+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
regexp (struct dfa *dfa)
{
  branch (dfa);
  while (dfa->parsestate.tok == OR)
    {
      dfa->parsestate.tok = lex (dfa);
      branch (dfa);
      addtok (dfa, OR);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 4
15 4
16 10
17 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x28(%rdi),%rdi
callq  1e <dico_strat_free+0xd>
mov    %rbx,%rdi
callq  26 <dico_strat_free+0x15>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
dico_strat_free(void *item, void *data)
{
    dico_strategy_t strat = item;
    dico_list_destroy(&strat->stratcl);
    free(strat);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
mov    0x20(%rsi),%eax
cmp    %eax,0x38(%rdx)
sete   %al
retq   
<<<sep_in_sample>>>
pred_group (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  if (pred_ptr->args.gid == stat_buf->st_gid)
    return (1);
  else
    return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
callq  339 <lm_alloc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lm_alloc_accel (const void * params, const size_t n, const size_t p)
{
  return lm_alloc(1, params, n, p);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmpl   $0x0,0x0(%rip)        # 204 <gsl_matrix_complex_get+0xb>
je     257 <gsl_matrix_complex_get+0x5e>
cmp    %rsi,(%rdi)
ja     22e <gsl_matrix_complex_get+0x35>
mov    $0x4,%ecx
mov    $0x113,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  224 <gsl_matrix_complex_get+0x2b>
mov    $0x0,%ecx
mov    %rcx,%rax
jmp    26e <gsl_matrix_complex_get+0x75>
cmp    %rdx,0x8(%rdi)
ja     257 <gsl_matrix_complex_get+0x5e>
mov    $0x4,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  24d <gsl_matrix_complex_get+0x54>
mov    $0x0,%ecx
mov    %rcx,%rax
jmp    26e <gsl_matrix_complex_get+0x75>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
shl    $0x4,%rdx
add    0x18(%rdi),%rdx
mov    (%rdx),%rcx
mov    0x8(%rdx),%rax
mov    %rcx,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %rax,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_get(const gsl_matrix_complex * m,
                     const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      gsl_complex zero = {{0,0}};
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_double.h", 275, GSL_EINVAL) ; return zero ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_double.h", 279, GSL_EINVAL) ; return zero ; } while (0) ;
        }
    }
  return *(gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 7
5 7
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 11
15 11
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 17
35 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rdi),%rsi
add    $0x151,%rsi
mov    $0x0,%r8d
mov    $0x3,%ecx
mov    $0x8,%edx
mov    %eax,%edi
callq  565 <etar_set_devminor+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
etar_set_devminor(ETAR * etar, unsigned long devno)
{
 minor_to_chars (devno, ((struct tar_header *)((etar)->tar_hdrM))->devminor, sizeof (((struct tar_header *)((etar)->tar_hdrM))->devminor), POSIX_FORMAT, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 525 <rl_reset_after_signal+0xb>
test   %rax,%rax
je     532 <rl_reset_after_signal+0x18>
mov    0x0(%rip),%edi        # 530 <rl_reset_after_signal+0x16>
callq  *%rax
callq  537 <rl_reset_after_signal+0x1d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_reset_after_signal ()
{
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
  rl_set_signals ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 6
9 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  2fb1 <gsl_sf_hyperg_2F1_renorm+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     2fd7 <gsl_sf_hyperg_2F1_renorm+0x32>
mov    %eax,%ecx
mov    $0x3be,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2fd0 <gsl_sf_hyperg_2F1_renorm+0x2b>
movsd  (%rsp),%xmm0
jmp    2fd7 <gsl_sf_hyperg_2F1_renorm+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_2F1_renorm(double a, double b, double c, double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_2F1_renorm_e(a, b, c, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_2F1_renorm_e(a, b, c, x, &result)", "hyperg_2F1.c", 958, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  90f <_rl_nsearch_callback+0x9>
mov    %eax,%esi
mov    %rbx,%rdi
callq  32 <_rl_nsearch_dispatch>
mov    $0x1,%edx
test   %eax,%eax
jne    945 <_rl_nsearch_callback+0x3f>
mov    %rbx,%rdi
callq  2cb <_rl_nsearch_dosearch>
test   %eax,%eax
js     93c <_rl_nsearch_callback+0x36>
mov    %eax,%esi
mov    %rbx,%rdi
callq  938 <_rl_nsearch_callback+0x32>
mov    %eax,%edx
jmp    945 <_rl_nsearch_callback+0x3f>
cmp    $0x1,%eax
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_nsearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;
  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;
  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 6
7 8
8 7
9 7
10 9
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  16e <hash_free_medium+0xc>
mov    %rbx,%rdi
callq  176 <hash_free_medium+0x14>
pop    %rbx
retq   
<<<sep_in_sample>>>
hash_free_medium (struct medium * medium)
{
  free (medium->name);
  free (medium);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    0x0(%rip),%rdx        # 2d <error+0xe>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 39 <error+0x1a>
mov    $0x0,%eax
callq  43 <error+0x24>
mov    $0x2,%edi
callq  4d <main>
<<<sep_in_sample>>>
error(const char *s)
{
  fprintf(stderr, "%s: %s\n", program_name, s);
  exit(2);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x70(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->nx_add_after (list, node, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # 5c <gsl_odeiv2_driver_set_hmax+0xc>
movapd %xmm0,%xmm1
andpd  %xmm2,%xmm1
movsd  0x20(%rdi),%xmm3
andpd  %xmm3,%xmm2
ucomisd %xmm1,%xmm2
ja     7e <gsl_odeiv2_driver_set_hmax+0x2e>
movsd  0x28(%rdi),%xmm2
ucomisd %xmm1,%xmm2
jbe    99 <gsl_odeiv2_driver_set_hmax+0x49>
mov    $0x4,%ecx
mov    $0x81,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  97 <gsl_odeiv2_driver_set_hmax+0x47>
jmp    c3 <gsl_odeiv2_driver_set_hmax+0x73>
ucomisd 0x0(%rip),%xmm0        # a1 <gsl_odeiv2_driver_set_hmax+0x51>
je     aa <gsl_odeiv2_driver_set_hmax+0x5a>
movsd  %xmm1,0x30(%rdi)
jmp    c3 <gsl_odeiv2_driver_set_hmax+0x73>
mov    $0x4,%ecx
mov    $0x8a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c3 <gsl_odeiv2_driver_set_hmax+0x73>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_driver_set_hmax (gsl_odeiv2_driver * d, const double hmax)
{
  if ((fabs (hmax) < fabs (d->h)) || (fabs (hmax) < d->hmin))
    {
      do { gsl_error ("hmin <= fabs(h) <= hmax required", "driver.c", 129, GSL_EINVAL) ; return 0 ; } while (0);
    }
  if (hmax > 0.0 || hmax < 0.0)
    {
      d->hmax = fabs (hmax);
    }
  else
    {
      do { gsl_error ("invalid hmax", "driver.c", 138, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 9
21 15
22 13
23 13
24 13
25 13
26 13
27 16
28 16
29 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # c <gsl_stream_printf+0xc>
jne    1c <gsl_stream_printf+0x1c>
mov    0x0(%rip),%rax        # 15 <gsl_stream_printf+0x15>
mov    %rax,0x0(%rip)        # 1c <gsl_stream_printf+0x1c>
mov    0x0(%rip),%rax        # 23 <gsl_stream_printf+0x23>
test   %rax,%rax
je     2c <gsl_stream_printf+0x2c>
callq  *%rax
jmp    4d <gsl_stream_printf+0x4d>
mov    %rcx,%r9
mov    %rdi,%r8
mov    %edx,%ecx
mov    %rsi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 43 <gsl_stream_printf+0x43>
mov    $0x0,%eax
callq  4d <gsl_stream_printf+0x4d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stream_printf (const char *label, const char *file, int line,
                   const char *reason)
{
  if (gsl_stream == ((void *)0))
    {
      gsl_stream = stderr;
    }
  if (gsl_stream_handler)
    {
      (*gsl_stream_handler) (label, file, line, reason);
      return;
    }
  fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 10
10 11
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 14
20 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  4d <nettle_gcm_aes128_set_iv+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes128_set_iv (struct gcm_aes128_ctx *ctx,
        size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x4,0x8(%rsp)
mov    %rdi,(%rsp)
mov    $0x1,%esi
mov    %rsp,%rdi
callq  8444 <do_assignment_internal>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
do_assignment (string)
     char *string;
{
  WORD_DESC td;
  td.flags = 0x000004;
  td.word = string;
  return do_assignment_internal (&td, 1);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r13d
mov    %ecx,%r12d
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
mov    %r13d,%r8d
mov    %r12d,%ecx
mov    $0x2e,%edx
mov    $0x66,%esi
mov    %rbx,%rdi
callq  9d0 <_ssexr>
mov    $0x0,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  850 <_jccs>
mov    (%rbx),%r12
mov    %ebp,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  2c2 <_cc>
mov    (%rbx),%rax
sub    %r12d,%eax
mov    %al,-0x1(%r12)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_sse_eqr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_bool_t rc;
    jit_int32_t reg;
    jit_word_t jp_code;
    if ((rc = 1))
 reg = r0;
    else {
 reg = 0;
 _movr(_jit, r0, 0);
    }
    _alur(_jit, 6 << 3, reg, reg);
    _ssexr(_jit,0x66,0x2e,r2,r1);
    _jccs(_jit, 0xa, 0);
    jp_code = _jit->pc.w;
    _cc(_jit, 0x4, reg);
    *(jit_int8_t *)(jp_code - 1) = _jit->pc.w - jp_code;
    if (!rc)
 _xchgr(_jit, r0, reg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 12
10 12
11 12
12 12
13 13
14 13
15 13
16 13
17 13
18 13
19 14
20 14
21 14
22 14
23 15
24 16
25 16
26 16
27 16
28 17
29 17
30 17
31 20
32 20
33 20
34 20
35 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x0,%esi
callq  11 <set_termsig+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_termsig (int sig, signal_info *old)
{
  sigaction (sig, &info_signal_handler, old);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    91 <xnrealloc+0x20>
callq  91 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  9a <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <get_env_value+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_env_value (varname)
     char *varname;
{
  return ((char *)getenv (varname));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1b,%edi
jne    20 <_rl_subseq_getchar+0x20>
orq    $0x50,0x0(%rip)        # 11 <_rl_subseq_getchar+0x11>
callq  16 <_rl_subseq_getchar+0x16>
andq   $0xffffffffffffffaf,0x0(%rip)        # 1e <_rl_subseq_getchar+0x1e>
jmp    35 <_rl_subseq_getchar+0x35>
orq    $0x40,0x0(%rip)        # 28 <_rl_subseq_getchar+0x28>
callq  2d <_rl_subseq_getchar+0x2d>
andq   $0xffffffffffffffbf,0x0(%rip)        # 35 <_rl_subseq_getchar+0x35>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_subseq_getchar (key)
     int key;
{
  int k;
  if (key == (('[') & 0x1f))
    (rl_readline_state |= (0x0000010));
  (rl_readline_state |= (0x0000040));
  k = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  if (key == (('[') & 0x1f))
    (rl_readline_state &= ~(0x0000010));
  return k;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 8
6 11
7 11
8 7
9 8
10 9
11 13
12 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    0x20(%rsp),%rdi
mov    %rdi,(%rsp)
movzbl %r8b,%r8d
mov    %rax,%rdi
callq  *0x8(%rax)
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gl_list_create (gl_list_implementation_t implementation,
  gl_listelement_equals_fn equals_fn,
  gl_listelement_hashcode_fn hashcode_fn,
  gl_listelement_dispose_fn dispose_fn,
  _Bool allow_duplicates,
  size_t count, const void **contents)
{
  return implementation->create (implementation, equals_fn, hashcode_fn,
     dispose_fn, allow_duplicates, count, contents);
}
<<<sep_in_sample>>>
1 7
2 7
3 8
4 8
5 8
6 8
7 8
8 10
9 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # 88f <grecs_grecs_wrap+0xc>
je     8aa <grecs_grecs_wrap+0x27>
mov    0x0(%rip),%edi        # 897 <grecs_grecs_wrap+0x14>
callq  89c <grecs_grecs_wrap+0x19>
mov    0x0(%rip),%rdi        # 8a3 <grecs_grecs_wrap+0x20>
callq  8a8 <grecs_grecs_wrap+0x25>
jmp    8af <grecs_grecs_wrap+0x2c>
callq  8af <grecs_grecs_wrap+0x2c>
movq   $0x0,0x0(%rip)        # 8ba <grecs_grecs_wrap+0x37>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_grecs_wrap()
{
 if (grecs_preprocessor) {
  grecs_preproc_extrn_shutdown(grecs_preproc_pid);
  fclose(grecs_grecs_in);
 } else
  grecs_preproc_done();
 grecs_current_locus_point.file = ((void *)0);
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 7
10 8
11 10
12 10
13 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 173 <previous_history+0x6>
test   %eax,%eax
je     18e <previous_history+0x21>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 180 <previous_history+0x13>
cltq   
mov    0x0(%rip),%rdx        # 189 <previous_history+0x1c>
mov    (%rdx,%rax,8),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
previous_history ()
{
  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edi
callq  795 <yyalloc+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yyalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     20 <gsl_multilarge_linear_free+0x20>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     18 <gsl_multilarge_linear_free+0x18>
mov    (%rbx),%rax
callq  *0x38(%rax)
mov    %rbx,%rdi
callq  20 <gsl_multilarge_linear_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multilarge_linear_free(gsl_multilarge_linear_workspace *w)
{
  if (!w) { return ; };
  if (w->state)
    w->type->free(w->state);
  free(w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2a0 <mu_attribute_is_userflag+0xb>
mov    %esi,%eax
and    0xc(%rdi),%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_attribute_is_userflag (mu_attribute_t attr, int flag)
{
  if (attr == ((void *)0))
    return 0;
  return attr->user_flags & flag;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  18 <dup_safer+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer (int fd)
{
  return rpl_fcntl (fd, 0, 2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
cmpl   $0x9,0xb0(%rdi)
jne    658 <_wsplt_seterr_sub+0x21>
mov    0xb8(%rdi),%rdi
callq  658 <_wsplt_seterr_sub+0x21>
mov    0xb0(%rbx),%eax
mov    %eax,0xb0(%rbp)
cmpl   $0x9,0xb0(%rbx)
jne    690 <_wsplt_seterr_sub+0x59>
mov    0xb8(%rbx),%rax
mov    %rax,0xb8(%rbp)
movl   $0x0,0xb0(%rbx)
movq   $0x0,0xb8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_wsplt_seterr_sub (struct wordsplit *wsp, struct wordsplit *wss)
{
  if (wsp->ws_errno == 9)
    free (wsp->ws_usererr);
  wsp->ws_errno = wss->ws_errno;
  if (wss->ws_errno == 9)
    {
      wsp->ws_usererr = wss->ws_usererr;
      wss->ws_errno = 0;
      wss->ws_usererr = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 6
13 6
14 8
15 8
16 9
17 10
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r13
mov    %rsi,%r12
mov    %rdx,%rbp
movq   $0x0,0x8(%rsp)
cmp    %rdx,%rsi
jae    b7 <url_parse_arg+0x3d>
cmpb   $0x3d,(%rsi)
je     11b <url_parse_arg+0xa1>
mov    %rsi,%rbx
add    $0x1,%rbx
cmp    %rbp,%rbx
je     13a <url_parse_arg+0xc0>
cmpb   $0x3d,(%rbx)
jne    a3 <url_parse_arg+0x29>
jmp    11e <url_parse_arg+0xa4>
mov    %rsi,%rdx
mov    %rsp,%rdi
callq  44 <alloc_string>
mov    $0x1,%edx
test   %eax,%eax
jne    151 <url_parse_arg+0xd7>
cmp    %rbp,%r12
je     ef <url_parse_arg+0x75>
lea    0x1(%r12),%rsi
mov    %rbp,%rdx
lea    0x8(%rsp),%rdi
callq  44 <alloc_string>
mov    $0x1,%edx
test   %eax,%eax
jne    151 <url_parse_arg+0xd7>
mov    0x38(%r13),%rdi
mov    0x8(%rsp),%rdx
mov    (%rsp),%rsi
callq  101 <url_parse_arg+0x87>
mov    (%rsp),%rdi
callq  10a <url_parse_arg+0x90>
mov    0x8(%rsp),%rdi
callq  114 <url_parse_arg+0x9a>
mov    $0x0,%edx
jmp    151 <url_parse_arg+0xd7>
mov    %rsi,%rbx
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rsp,%rdi
callq  44 <alloc_string>
mov    $0x1,%edx
mov    %rbx,%r12
test   %eax,%eax
je     d4 <url_parse_arg+0x5a>
jmp    151 <url_parse_arg+0xd7>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rsp,%rdi
callq  44 <alloc_string>
mov    $0x1,%edx
test   %eax,%eax
je     ef <url_parse_arg+0x75>
mov    %edx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
url_parse_arg(dico_url_t url, char *p, char *q)
{
    char *s;
    char *key, *value = ((void *)0);
    for (s = p; s < q && *s != '='; s++)
 ;
    if (alloc_string(&key, p, s))
 return 1;
    if (s != q) {
 if (alloc_string(&value, s + 1, q))
     return 1;
    }
    dico_assoc_append(url->args, key, value);
    free(key);
    free(value);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 7
23 7
24 8
25 7
26 7
27 9
28 9
29 10
30 10
31 10
32 10
33 11
34 10
35 10
36 13
37 13
38 13
39 13
40 14
41 14
42 15
43 15
44 16
45 16
46 5
47 7
48 7
49 7
50 7
51 8
52 7
53 7
54 7
55 7
56 7
57 7
58 7
59 7
60 8
61 7
62 7
63 17
64 17
65 17
66 17
67 17
68 17
69 17
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 10c <_rl_next_macro_key+0x7>
test   %rdx,%rdx
je     167 <_rl_next_macro_key+0x62>
push   %rbx
mov    0x0(%rip),%ecx        # 118 <_rl_next_macro_key+0x13>
movslq %ecx,%rax
movzbl (%rdx,%rax,1),%eax
test   %al,%al
jne    132 <_rl_next_macro_key+0x2d>
callq  128 <_rl_next_macro_key+0x23>
callq  12d <_rl_next_macro_key+0x28>
nopl   (%rax)
jmp    16d <_rl_next_macro_key+0x68>
add    $0x1,%ecx
mov    %ecx,0x0(%rip)        # 13b <_rl_next_macro_key+0x36>
movsbl %al,%ebx
mov    0x0(%rip),%rsi        # 145 <_rl_next_macro_key+0x40>
mov    %ebx,%eax
test   $0x80000,%esi
je     16d <_rl_next_macro_key+0x68>
test   $0x48,%sil
je     16d <_rl_next_macro_key+0x68>
movslq %ecx,%rcx
cmpb   $0x0,(%rdx,%rcx,1)
jne    16d <_rl_next_macro_key+0x68>
callq  163 <_rl_next_macro_key+0x5e>
mov    %ebx,%eax
jmp    16d <_rl_next_macro_key+0x68>
mov    $0x0,%eax
retq   
pop    %rbx
xchg   %ax,%ax
retq   
<<<sep_in_sample>>>
_rl_next_macro_key ()
{
  int c;
  if (rl_executing_macro == 0)
    return (0);
  if (rl_executing_macro[executing_macro_index] == 0)
    {
      _rl_pop_executing_macro ();
      return (_rl_next_macro_key ());
    }
  c = rl_executing_macro[executing_macro_index++];
  if ((rl_readline_state & (0x0080000)) && (rl_readline_state & (0x0000008|0x0000040)) && rl_executing_macro[executing_macro_index] == 0)
      _rl_pop_executing_macro ();
  return c;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
13 9
14 11
15 11
16 11
17 12
18 14
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 14
28 14
29 5
30 5
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %rbx
callq  190 <xmalloc+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    1b3 <xmalloc+0x29>
callq  19d <xmalloc+0x13>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  0 <error>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xmalloc (size_t size)
{
  void *ptr = malloc (size);
  if (!ptr)
    error (1, (*__errno_location ()), "virtual memory exhausted");
  return ptr;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
<<<sep_in_sample>>>
gcide_iterator_compare_count(gcide_iterator_t itr)
{
    return itr->compare_count;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%edx
mov    $0x1,%eax
test   $0x42,%dl
jne    8a8 <trap_to_sighandler+0x22>
and    $0x1,%edx
mov    $0x0,%al
mov    $0x0,%edx
cmovne %rdx,%rax
repz retq 
<<<sep_in_sample>>>
trap_to_sighandler (sig)
     int sig;
{
  if (sigmodes[sig] & (0x40|0x2))
    return (((__sighandler_t) 1));
  else if (sigmodes[sig] & 0x1)
    return (trap_handler);
  else
    return (((__sighandler_t) 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 4
6 6
7 7
8 7
9 7
10 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     372 <gsasl_client_callback_authorization_id_get+0xa>
mov    0x30(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_authorization_id_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_authorization_id : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     117 <gsl_permutation_free+0x1a>
mov    0x8(%rdi),%rdi
callq  10f <gsl_permutation_free+0x12>
mov    %rbx,%rdi
callq  117 <gsl_permutation_free+0x1a>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_permutation_free (gsl_permutation * p)
{
  if (!p) { return ; };
  free (p->data);
  free (p);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x40(%rdi),%r12
mov    0x68(%rdi),%rax
mov    (%rax),%rax
mov    %eax,%ebp
test   %eax,%eax
je     3f8a <info_beginning_of_line+0x3f>
lea    -0x1(%rbp),%esi
movslq %esi,%rsi
mov    %rbx,%rdi
callq  4a5 <looking_at_newline>
test   %eax,%eax
jne    3f8a <info_beginning_of_line+0x3f>
mov    %rbx,%rdi
callq  3e0e <point_prev_line>
mov    0x68(%rbx),%rax
mov    (%rax),%rax
mov    %eax,%ebp
test   %eax,%eax
jne    3f63 <info_beginning_of_line+0x18>
cmp    %r12d,%ebp
je     3fa0 <info_beginning_of_line+0x55>
movslq %ebp,%rbp
mov    %rbp,0x40(%rbx)
mov    %rbx,%rdi
callq  3ed <info_show_point>
jmp    3fa7 <info_beginning_of_line+0x5c>
movslq %ebp,%rbp
mov    %rbp,0x40(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
info_beginning_of_line (WINDOW *window, int count)
{
  int old_point = window->point;
  int point;
  while (1)
    {
      point = window->line_map.map[0];
      if (point == 0 || looking_at_newline (window, point-1))
 break;
      point_prev_line (window);
    }
  if (point != old_point)
    {
      window->point = point;
      info_show_point (window);
    }
  else
    window->point = old_point;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 7
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 7
20 7
21 7
22 8
23 8
24 12
25 12
26 14
27 14
28 15
29 15
30 15
31 18
32 18
33 19
34 19
35 19
36 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b9 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 527 <gsl_matrix_complex_float_const_ptr+0xb>
je     574 <gsl_matrix_complex_float_const_ptr+0x58>
cmp    %rsi,(%rdi)
ja     54e <gsl_matrix_complex_float_const_ptr+0x32>
mov    $0x4,%ecx
mov    $0x152,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  547 <gsl_matrix_complex_float_const_ptr+0x2b>
mov    $0x0,%eax
jmp    584 <gsl_matrix_complex_float_const_ptr+0x68>
cmp    %rdx,0x8(%rdi)
ja     574 <gsl_matrix_complex_float_const_ptr+0x58>
mov    $0x4,%ecx
mov    $0x156,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  56d <gsl_matrix_complex_float_const_ptr+0x51>
mov    $0x0,%eax
jmp    584 <gsl_matrix_complex_float_const_ptr+0x68>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
mov    0x18(%rdi),%rax
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_const_ptr(const gsl_matrix_complex_float * m,
                                   const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_float.h", 338, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_float.h", 342, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 15
23 15
24 15
25 15
26 16
27 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    $0x0,%eax
cmpb   $0x0,(%rdi)
je     d0 <mu_rtrim_cset+0x5d>
mov    %rsi,%r13
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,%rbx
jne    ac <mu_rtrim_cset+0x39>
jmp    c8 <mu_rtrim_cset+0x55>
test   %rbp,%rbp
je     c5 <mu_rtrim_cset+0x52>
mov    %rbp,%rbx
lea    -0x1(%rbx),%rbp
movsbl -0x1(%r12,%rbx,1),%esi
mov    %r13,%rdi
callq  be <mu_rtrim_cset+0x4b>
test   %rax,%rax
jne    a4 <mu_rtrim_cset+0x31>
jmp    c8 <mu_rtrim_cset+0x55>
mov    %rbp,%rbx
movb   $0x0,(%r12,%rbx,1)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_rtrim_cset (char *str, const char *cset)
{
  size_t len;
  if (!*str)
    return 0;
  for (len = strlen (str); len > 0 && strchr (cset, str[len-1]) != ((void *)0); len--)
    ;
  str[len] = 0;
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 4
9 4
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 8
30 9
31 10
32 10
33 10
34 10
35 10
36 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 630 <_asn1_delete_list+0x7>
test   %rdi,%rdi
je     659 <_asn1_delete_list+0x30>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    %rax,0x0(%rip)        # 644 <_asn1_delete_list+0x1b>
callq  649 <_asn1_delete_list+0x20>
mov    0x0(%rip),%rdi        # 650 <_asn1_delete_list+0x27>
test   %rdi,%rdi
jne    639 <_asn1_delete_list+0x10>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_asn1_delete_list (void)
{
  list_type *listElement;
  while (firstElement)
    {
      listElement = firstElement;
      firstElement = firstElement->next;
      free (listElement);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 7
6 7
7 8
8 4
9 4
10 4
11 10
12 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 196 <cr+0x7>
test   %rdi,%rdi
je     1bc <cr+0x2d>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x1,%esi
callq  1ae <cr+0x1f>
movl   $0x0,0x0(%rip)        # 1b8 <cr+0x29>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
cr ()
{
  if (_rl_term_cr)
    {
      tputs (_rl_term_cr, 1, _rl_output_character_function);
      _rl_last_c_pos = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 5
8 6
9 8
10 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     55a <sdp_message_t_time_descr_add+0x4e>
mov    %rsi,%r13
mov    %rdx,%r12
lea    0x8(%rsp),%rdi
callq  52e <sdp_message_t_time_descr_add+0x22>
mov    %eax,%ebx
test   %ebx,%ebx
jne    55f <sdp_message_t_time_descr_add+0x53>
mov    0x8(%rsp),%rax
mov    %r13,(%rax)
mov    0x8(%rsp),%rsi
mov    %r12,0x8(%rsi)
lea    0x88(%rbp),%rdi
mov    $0xffffffff,%edx
callq  556 <sdp_message_t_time_descr_add+0x4a>
mov    %ebx,%eax
jmp    55f <sdp_message_t_time_descr_add+0x53>
mov    $0xfffffffe,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
sdp_message_t_time_descr_add (sdp_message_t * sdp, char *start, char *stop)
{
  int i;
  sdp_time_descr_t *td;
  if (sdp == ((void *)0))
    return -2;
  i = sdp_time_descr_init (&td);
  if (i != 0)
    return i;
  td->t_start_time = start;
  td->t_stop_time = stop;
  osip_list_add (&sdp->t_descrs, td, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 11
19 11
20 12
21 12
22 12
23 13
24 13
25 6
26 14
27 14
28 14
29 14
30 14
31 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2be <rl_digit_loop+0x9>
test   %eax,%eax
jne    2fd <rl_digit_loop+0x48>
callq  2c7 <rl_digit_loop+0x12>
test   %eax,%eax
jns    2dc <rl_digit_loop+0x27>
nopl   0x0(%rax,%rax,1)
callq  2d5 <rl_digit_loop+0x20>
mov    $0xffffffff,%eax
jmp    302 <rl_digit_loop+0x4d>
mov    %eax,%esi
mov    0x0(%rip),%edi        # 2e4 <rl_digit_loop+0x2f>
mov    $0x0,%eax
callq  2ee <rl_digit_loop+0x39>
test   %eax,%eax
jle    302 <rl_digit_loop+0x4d>
testb  $0x4,0x0(%rip)        # 2f9 <rl_digit_loop+0x44>
jne    2b9 <rl_digit_loop+0x4>
jmp    302 <rl_digit_loop+0x4d>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_digit_loop ()
{
  int c, r;
  while (1)
    {
      if (_rl_arg_overflow ())
 return 1;
      c = _rl_arg_getchar ();
      if (c < 0)
 {
   _rl_abort_internal ();
   return -1;
 }
      r = _rl_arg_dispatch (_rl_argcxt, c);
      if (r <= 0 || ((rl_readline_state & (0x0000400)) == 0))
        break;
    }
  return r;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 8
6 9
7 9
8 9
9 11
10 12
11 12
12 14
13 14
14 14
15 14
16 15
17 15
18 15
19 15
20 15
21 7
22 19
23 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  79 <check_strdup+0x22>
mov    %rax,%rbx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  87 <check_strdup+0x30>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
check_strdup(const char *string)
{
 char *p = check_malloc(strlen(string) + 1);
 strcpy(p, string);
 return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 6
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e7d <gen_form_begin+0xe>
mov    0x0(%rip),%rdi        # e84 <gen_form_begin+0x15>
callq  0 <fix_attr_value>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  ea0 <gen_form_begin+0x31>
cmpl   $0x0,0x0(%rip)        # ea7 <gen_form_begin+0x38>
je     ecd <gen_form_begin+0x5e>
test   %rbx,%rbx
je     ecd <gen_form_begin+0x5e>
mov    %rbx,%rdi
callq  0 <fix_attr_value>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  ecd <gen_form_begin+0x5e>
mov    $0x0,%esi
mov    $0x0,%edi
callq  edc <gen_form_begin+0x6d>
mov    $0x0,%edi
callq  ee6 <gen_form_begin+0x77>
pop    %rbx
retq   
<<<sep_in_sample>>>
gen_form_begin(const char *target)
{
 static STRBUF sb[1];
 strbuf_clear(sb);
 strbuf_sprintf(sb, "<form method='get' action='%s'", fix_attr_value(action));
 if (Fflag && target)
  strbuf_sprintf(sb, " target='%s'", fix_attr_value(target));
 strbuf_puts(sb, ">");
 return strbuf_value(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 9
27 9
28 10
29 10
<<<sep_out_sample>>>
lea    0x200(%rdi),%rsi
lea    0x94(%rdi),%rcx
cmp    %rcx,%rdi
jae    1183 <taru_tar_checksum+0x53>
mov    $0x0,%eax
add    $0x1,%rdi
movzbl -0x1(%rdi),%edx
add    %rdx,%rax
cmp    %rcx,%rdi
jne    1148 <taru_tar_checksum+0x18>
mov    %rcx,%rdi
jmp    1188 <taru_tar_checksum+0x58>
sub    $0x1,%ecx
jne    115d <taru_tar_checksum+0x2d>
add    $0x100,%rax
lea    0x8(%rdi),%rdx
cmp    %rsi,%rdx
jae    118f <taru_tar_checksum+0x5f>
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
add    %rcx,%rax
cmp    %rdx,%rsi
jne    1171 <taru_tar_checksum+0x41>
repz retq 
mov    $0x0,%eax
mov    $0x8,%ecx
jmp    115d <taru_tar_checksum+0x2d>
repz retq 
<<<sep_in_sample>>>
taru_tar_checksum (void * hdr)
{
  struct tar_header *tar_hdr = (struct tar_header*)(hdr);
  unsigned long sum = 0;
  char *p = (char *) tar_hdr;
  char *q = p + 512;
  int i;
  while (p < tar_hdr->chksum)
    sum += *p++ & 0xff;
  for (i = 0; i < 8; ++i)
    {
      sum += ' ';
      ++p;
    }
  while (p < q)
    sum += *p++ & 0xff;
  return sum;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
4 8
5 4
6 9
7 9
8 9
9 8
10 8
11 8
12 8
13 10
14 10
15 10
16 10
17 15
18 15
19 16
20 16
21 16
22 15
23 15
24 15
25 4
26 4
27 4
28 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  169 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    11e <argp_fmtstream_set_lmargin+0x1f>
callq  11e <argp_fmtstream_set_lmargin+0x1f>
mov    0x8(%rbx),%rax
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->lmargin;
  __fs->lmargin = __lmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    %rax,(%rsi)
retq   
<<<sep_in_sample>>>
mu_mime_io_buffer_get_size (mu_mime_io_buffer_t info, size_t *psize)
{
  *psize = info->bufsize;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <jit_default_realloc_func+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
jit_default_realloc_func(void *ptr, size_t size)
{
    return (realloc(ptr, size));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movl   $0x1,0x0(%rip)        # 573 <dokludgemode+0xe>
mov    $0x1,%esi
mov    $0x22,%edi
callq  582 <dokludgemode+0x1d>
mov    $0x1,%esi
mov    $0x3,%edi
callq  591 <dokludgemode+0x2c>
mov    $0x1,%esi
mov    $0x1,%edi
callq  5a0 <dokludgemode+0x3b>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dokludgemode (void)
{
  kludgelinemode = 1;
  send_wont (34, 1);
  send_dont (3, 1);
  send_dont (1, 1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
cmp    %rsi,(%rdi)
ja     154 <gsl_histogram2d_get+0x2c>
mov    $0x1,%ecx
mov    $0x23,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  14e <gsl_histogram2d_get+0x26>
xorpd  %xmm0,%xmm0
jmp    188 <gsl_histogram2d_get+0x60>
cmp    %rdx,%rax
ja     178 <gsl_histogram2d_get+0x50>
mov    $0x1,%ecx
mov    $0x29,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  172 <gsl_histogram2d_get+0x4a>
xorpd  %xmm0,%xmm0
jmp    188 <gsl_histogram2d_get+0x60>
imul   %rax,%rsi
add    %rsi,%rdx
mov    0x20(%rdi),%rcx
movsd  (%rcx,%rdx,8),%xmm0
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_histogram2d_get (const gsl_histogram2d * h, const size_t i, const size_t j)
{
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  if (i >= nx)
    {
      do { gsl_error ("index i lies outside valid range of 0 .. nx - 1",
 "get2d.c"
      ,
 35
      , GSL_EDOM) ; return 0 ; } while (0)
                                    ;
    }
  if (j >= ny)
    {
      do { gsl_error ("index j lies outside valid range of 0 .. ny - 1",
 "get2d.c"
      ,
 41
      , GSL_EDOM) ; return 0 ; } while (0)
                                    ;
    }
  return h->bin[i * ny + j];
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 14
13 14
14 16
15 16
16 16
17 16
18 16
19 20
20 20
21 23
22 23
23 23
24 23
25 24
26 24
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,0x18(%rsp)
mov    %rsi,%r13
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%rbx
test   %r8,%r8
mov    $0x0,%eax
cmove  %rax,%rbx
callq  d63 <quotearg_buffer+0x30>
mov    %rax,%rbp
mov    (%rax),%r12d
mov    0x4(%rbx),%r9d
mov    0x30(%rbx),%rax
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    0x18(%rsp),%rdi
callq  0 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
   char const *arg, size_t argsize,
   struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
           p->style, p->flags, p->quote_these_too,
           p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    %rcx,%r12
mov    %r8,%r13
callq  12d <_s_readline+0x1b>
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    (%rax),%rdi
callq  141 <_s_readline+0x2f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_s_readline (mu_stream_t stream, char *optr, size_t osize,
      mu_off_t offset, size_t *nbytes)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_readline (s->fstream, optr, osize, offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  2ad <_is_nl_or_punct+0x10>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_is_nl_or_punct(int c)
{
    return !!strchr("\r\n!,-./:;?", c);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  47 <__rtrace_trap+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rtrace_trap (int ignore)
{
  __rerror ("System error: Trace trap");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
movl   $0x2a,0x678(%rdi)
retq   
<<<sep_in_sample>>>
crasher (unsigned long p)
{
  *(volatile int *) (p + 0x678) = 42;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movsd  0x8(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
timer_get_real(xdico_timer_t t)
{
    return t->real;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  154 <gsl_vector_complex_float_fscanf+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_fscanf (FILE * stream, gsl_vector_complex_float * v)
{
  int status = gsl_block_complex_float_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     19 <grecs_txtacc_entry_free+0x19>
mov    (%rdi),%rdi
callq  11 <grecs_txtacc_entry_free+0x11>
mov    %rbx,%rdi
callq  19 <grecs_txtacc_entry_free+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_txtacc_entry_free(void *p)
{
 if (p) {
  struct grecs_txtacc_entry *ent = p;
  free(ent->buf);
  free(ent);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 8
10 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x8(%rdi),%rdi
callq  686 <__osip_add_ict+0x15>
lea    0x40(%rbx),%rdi
mov    $0xffffffff,%edx
mov    %rbp,%rsi
callq  697 <__osip_add_ict+0x26>
mov    0x8(%rbx),%rdi
callq  6a0 <__osip_add_ict+0x2f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__osip_add_ict (osip_t * osip, osip_transaction_t * ict)
{
  osip_mutex_lock (osip->ict_fastmutex);
  osip_list_add (&osip->osip_ict_transactions, ict, -1);
  osip_mutex_unlock (osip->ict_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     f <mu_pop3_set_timeout+0xf>
mov    %esi,0x50(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_pop3_set_timeout (mu_pop3_t pop3, int timeout)
{
  if (pop3 == ((void *)0))
    return 22;
  pop3->timeout = timeout;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 3b1 <il_backward_char+0x7>
mov    0x18(%rax),%rdx
cmp    0x40(%rax),%rdx
jbe    3ca <il_backward_char+0x20>
sub    $0x1,%rdx
mov    %rdx,0x18(%rax)
movl   $0x1,0x10(%rax)
repz retq 
<<<sep_in_sample>>>
il_backward_char()
{
    if (il->point > il->static_length)
    {
 il->point--;
 il->last_operation = 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     7de <xprintf+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # 814 <xprintf+0x91>
callq  819 <xprintf+0x96>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
xprintf (const char *format, ...)
{
  va_list args;
  __builtin_va_start(args,format);
  vfprintf (stdout, format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 7
28 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
mov    0x4(%rsi),%r12d
movslq %r12d,%rbx
mov    %rbx,%rax
sar    $0x3f,%rax
xor    %rax,%rbx
sub    %rax,%rbx
test   %rbx,%rbx
mov    $0x1,%edi
cmovg  %rbx,%rdi
mov    %edi,0x0(%rbp)
movslq %edi,%rdi
shl    $0x3,%rdi
callq  *0x0(%rip)        # 40 <__gmpz_init_set+0x40>
mov    %rax,0x8(%rbp)
mov    0x8(%r13),%rsi
mov    %rbx,%rdx
mov    %rax,%rdi
callq  53 <__gmpz_init_set+0x53>
mov    %r12d,0x4(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__gmpz_init_set (mpz_ptr w, mpz_srcptr u)
{
  mp_ptr wp, up;
  mp_size_t usize, size;
  usize = ((u)->_mp_size);
  size = ((usize) >= 0 ? (usize) : -(usize));
  ((w)->_mp_alloc) = ((size) > (1) ? (size) : (1));
  ((w)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((((w)->_mp_alloc)) * sizeof (mp_limb_t)));
  wp = ((w)->_mp_d);
  up = ((u)->_mp_d);
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (wp, up, size); } while (0); } while (0);
  ((w)->_mp_size) = usize;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 11
23 11
24 11
25 11
26 12
27 13
28 13
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     2050 <slist_free+0x2c>
mov    (%rbx),%rbp
mov    0x8(%rbx),%rdi
callq  203e <slist_free+0x1a>
mov    %rbx,%rdi
callq  2046 <slist_free+0x22>
test   %rbp,%rbp
je     2050 <slist_free+0x2c>
mov    %rbp,%rbx
jmp    2032 <slist_free+0xe>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
slist_free (struct slist *lp)
{
  while (lp)
    {
      struct slist *next = lp->next;
      free (lp->str);
      free (lp);
      lp = next;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 6
9 6
10 7
11 7
12 3
13 3
14 8
15 8
16 10
17 10
18 10
19 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # a08 <sdp_bandwidth_init+0xb>
test   %rax,%rax
je     a16 <sdp_bandwidth_init+0x19>
mov    $0x10,%edi
callq  *%rax
jmp    a20 <sdp_bandwidth_init+0x23>
mov    $0x10,%edi
callq  a20 <sdp_bandwidth_init+0x23>
mov    %rax,(%rbx)
test   %rax,%rax
je     a41 <sdp_bandwidth_init+0x44>
movq   $0x0,(%rax)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    $0x0,%eax
jmp    a46 <sdp_bandwidth_init+0x49>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sdp_bandwidth_init (sdp_bandwidth_t ** b)
{
  *b = (sdp_bandwidth_t *) (osip_malloc_func?osip_malloc_func(sizeof (sdp_bandwidth_t)):malloc(sizeof (sdp_bandwidth_t)));
  if (*b == ((void *)0))
    return -4;
  (*b)->b_bwtype = ((void *)0);
  (*b)->b_bandwidth = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 7
16 7
17 8
18 8
19 5
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x58(%rax),%rdi
callq  f5 <dict_entry_table_dump>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
list_pagedevice (a2ps_job * job, FILE * stream)
{
  dict_entry_table_dump (job->status->pagedevice, stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 1da <jobserver_clear+0xa>
test   %edi,%edi
js     1e3 <jobserver_clear+0x13>
callq  1e3 <jobserver_clear+0x13>
mov    0x0(%rip),%edi        # 1e9 <jobserver_clear+0x19>
test   %edi,%edi
js     1f2 <jobserver_clear+0x22>
callq  1f2 <jobserver_clear+0x22>
mov    0x0(%rip),%edi        # 1f8 <jobserver_clear+0x28>
test   %edi,%edi
js     201 <jobserver_clear+0x31>
callq  201 <jobserver_clear+0x31>
movl   $0xffffffff,0x0(%rip)        # 20b <jobserver_clear+0x3b>
movl   $0xffffffff,0x0(%rip)        # 215 <jobserver_clear+0x45>
movl   $0xffffffff,0x0(%rip)        # 21f <jobserver_clear+0x4f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
jobserver_clear (void)
{
  if (job_fds[0] >= 0)
    close (job_fds[0]);
  if (job_fds[1] >= 0)
    close (job_fds[1]);
  if (job_rfd >= 0)
    close (job_rfd);
  job_fds[0] = job_fds[1] = job_rfd = -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 6
10 7
11 7
12 7
13 8
14 9
15 9
16 9
17 10
18 10
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
fldt   -0x18(%rsp)
retq   
<<<sep_in_sample>>>
gsl_coerce_long_double (const long double x)
{
  volatile long double y;
  y = x;
  return y;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
retq   
<<<sep_in_sample>>>
csv_error(struct csv_parser *p)
{
  return p->status;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %ecx,%ebp
test   %ecx,%ecx
je     1e39 <_x87_bner_d+0x18>
test   %edx,%edx
jne    1e48 <_x87_bner_d+0x27>
mov    %ecx,%edx
mov    $0x1d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
jmp    1e62 <_x87_bner_d+0x41>
mov    $0x8,%esi
callq  13ec <_x87ri>
lea    0x1(%rbp),%edx
mov    $0x3d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
mov    $0x0,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  850 <_jccs>
mov    (%rbx),%r12
mov    $0x0,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  850 <_jccs>
mov    (%rbx),%rbp
mov    %ebp,%eax
sub    %r12d,%eax
mov    %al,-0x1(%r12)
mov    %r13,%rsi
mov    %rbx,%rdi
callq  942 <_jmpi>
movzbl (%rbx),%eax
sub    %ebp,%eax
mov    %al,-0x1(%rbp)
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_x87_bner_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_int32_t r1)
{
    jit_int32_t f0, f1;
    jit_word_t jp_code;
    jit_word_t jz_code;
    if (r1 == 0) f0 = r1, f1 = r0;
    else f0 = r0, f1 = r1;
    if (f0 == 0)
 _x87ri(_jit,035,f1);
    else {
 _x87ri(_jit,010,f0);
 _x87ri(_jit,075,f1 + 1);
    }
    _jccs(_jit, 0xa, 0);
    jp_code = _jit->pc.w;
    _jccs(_jit, 0x4, 0);
    jz_code = _jit->pc.w;
    *(jit_int8_t *)(jp_code - 1) = _jit->pc.w - jp_code;
    _jmpi(_jit, i0);
    *(jit_int8_t *)(jz_code - 1) = _jit->pc.w - jz_code;
    return (_jit->pc.w);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 8
11 8
12 7
13 9
14 9
15 9
16 9
17 11
18 11
19 12
20 12
21 12
22 12
23 14
24 14
25 14
26 14
27 15
28 16
29 16
30 16
31 16
32 17
33 18
34 18
35 18
36 19
37 19
38 19
39 20
40 20
41 20
42 21
43 22
44 22
45 22
46 22
47 22
<<<sep_out_sample>>>
imul   $0x5d588b65,(%rdi),%eax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_get (void *vstate)
{
  ran_state_t *state = (ran_state_t *) vstate;
  state->x = (1566083941UL * state->x) & 0xffffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
<<<sep_out_sample>>>
movslq 0x0(%rip),%rdx        # 7 <MCVarListToArray+0x7>
mov    0x0(%rip),%rax        # e <MCVarListToArray+0xe>
mov    %rdi,(%rax,%rdx,8)
addl   $0x1,0x0(%rip)        # 19 <MCVarListToArray+0x19>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
MCVarListToArray (PVOID pv_pMCVar, PVOID pv_Null)
{
  vrgpMCVar[viMCVar] = (MCVAR *) pv_pMCVar;
  viMCVar++;
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
mov    0x0(%rip),%esi        # d66 <write_history+0xf>
mov    $0x0,%eax
callq  400 <history_do_write>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
write_history (filename)
     char *filename;
{
  return (history_do_write (filename, history_length, 1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  13fb <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
ucomisd %xmm1,%xmm2
jbe    1c2 <gsl_root_test_residual+0x2e>
sub    $0x8,%rsp
mov    $0xd,%ecx
mov    $0x50,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1bb <gsl_root_test_residual+0x27>
mov    $0xd,%eax
jmp    1dd <gsl_root_test_residual+0x49>
movsd  0x0(%rip),%xmm2        # 1ca <gsl_root_test_residual+0x36>
andpd  %xmm2,%xmm0
ucomisd %xmm0,%xmm1
seta   %al
movzbl %al,%eax
lea    -0x2(%rax,%rax,1),%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_root_test_residual (double f, double epsabs)
{
  if (epsabs < 0.0)
    do { gsl_error ("absolute tolerance is negative", "convergence.c", 80, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
  if (fabs(f) < epsabs)
    return GSL_SUCCESS;
  return GSL_CONTINUE ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movb   $0x0,0x20(%rdi)
retq   
<<<sep_in_sample>>>
digest_md5_free_finish (digest_md5_finish * f)
{
  memset (f, 0, sizeof (*f));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %edx,%eax
retq   
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # a <xalloc_die+0xa>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  23 <xalloc_die+0x23>
callq  28 <xalloc_die+0x28>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", ((const char *) ("memory exhausted")));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
mov    0x108(%rdi),%ecx
test   $0x2,%cl
je     2293 <inrec+0x28>
mov    $0x0,%eax
mov    0xd0(%rdi),%rdx
cmp    %rdx,0xc8(%rdi)
jae    22db <inrec+0x70>
mov    $0x0,%eax
test   $0x4,%cl
jne    22db <inrec+0x70>
mov    %rbx,%rdx
mov    %rdi,%rsi
lea    0x8(%rsp),%rdi
callq  193c <get_a_record>
mov    %eax,%esi
cmp    $0xffffffff,%eax
je     22d6 <inrec+0x6b>
addq   $0x1,0x0(%rip)        # 22bc <inrec+0x51>
addq   $0x1,0x0(%rip)        # 22c4 <inrec+0x59>
mov    0x8(%rsp),%rdi
callq  22ce <inrec+0x63>
cmpl   $0x0,(%rbx)
setle  %al
jmp    22db <inrec+0x70>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
inrec(IOBUF *iop, int *errcode)
{
 char *begin;
 int cnt;
 _Bool retval = 1;
 if ((((iop)->flag & 2) != 0) && ((iop)->off >= (iop)->dataend))
  cnt = (-1);
 else if ((iop->flag & 4) != 0)
  cnt = (-1);
 else
  cnt = get_a_record(& begin, iop, errcode);
 if (cnt == (-1)) {
  retval = 0;
 } else {
  NR++;
  FNR++;
  set_record(begin, cnt);
  if (*errcode > 0)
   retval = 0;
 }
 return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 6
7 13
8 6
9 6
10 6
11 13
12 8
13 8
14 11
15 11
16 11
17 11
18 11
19 12
20 12
21 15
22 16
23 17
24 17
25 18
26 18
27 18
28 13
29 22
30 22
31 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   $0x100,%esi
je     5dd <print_date+0x30>
mov    %rcx,%rdi
callq  539 <tartime>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  5db <print_date+0x2e>
jmp    60c <print_date+0x5f>
test   $0x200,%esi
je     60c <print_date+0x5f>
cmp    $0x30,%edx
jne    60c <print_date+0x5f>
mov    %rcx,%rdi
callq  539 <tartime>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  60c <print_date+0x5f>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_date(STROB * fp, int vflag, int type, time_t mtime)
{
 if (vflag & (1 << 8)) {
  strob_sprintf(fp, 1, "%s", tartime(mtime));
 } else if (vflag & (1 << 9)) {
  if (type == '0') {
   strob_sprintf(fp, 1, "%s", tartime(mtime));
  } else {
  }
 } else {
  ;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 13
27 13
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r12
test   %r12,%r12
je     302 <argmatch_to_argument+0x3f>
mov    %rdi,%r14
mov    %rcx,%r13
mov    %rdx,%rbx
lea    0x8(%rsi),%rbp
mov    %r13,%rdx
mov    %rbx,%rsi
mov    %r14,%rdi
callq  2ee <argmatch_to_argument+0x2b>
test   %eax,%eax
je     302 <argmatch_to_argument+0x3f>
mov    0x0(%rbp),%r12
add    %r13,%rbx
add    $0x8,%rbp
test   %r12,%r12
jne    2e0 <argmatch_to_argument+0x1d>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
argmatch_to_argument (const char *value,
                      const char *const *arglist,
                      const char *vallist, size_t valsize)
{
  size_t i;
  for (i = 0; arglist[i]; i++)
    if (!memcmp (value, vallist + valsize * i, valsize))
      return arglist[i];
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 6
20 6
21 6
22 6
23 6
24 10
25 10
26 10
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x0,%esi
callq  488 <read_first_line+0x13>
mov    %rax,%rbx
test   %rax,%rax
je     4b8 <read_first_line+0x43>
mov    $0x2,%edx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  4a0 <read_first_line+0x2b>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  4ab <read_first_line+0x36>
test   %rbp,%rbp
sete   %al
movzbl %al,%eax
neg    %eax
jmp    4bd <read_first_line+0x48>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
read_first_line(const char *com, STRBUF *sb)
{
 FILE *ip = popen(com, "r");
 char *p;
 if (ip == ((void *)0))
  return -1;
 p = strbuf_fgets(sb, ip, 2);
 pclose(ip);
 return (p == ((void *)0)) ? -1 : 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 6
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
cmpl   $0x0,0x8(%rdi)
jne    8a <_crlfstr_destroy+0x19>
sub    $0x8,%rsp
callq  80 <_crlfstr_destroy+0xf>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_crlfstr_destroy(void *data)
{
    struct _crlfstr *s = data;
    if (!s->noclose)
 dico_stream_destroy(&s->transport);
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 7
6 7
7 7
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffff,%esi
callq  61b <it_init_joblist>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
it_init_jobs (itp)
     ITEMLIST *itp;
{
  return (it_init_joblist (itp, -1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rax
cmp    %rdx,%rax
ja     3ad0 <gsl_matrix_char_subdiagonal+0x4d>
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3aa8 <gsl_matrix_char_subdiagonal+0x25>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    3b0b <gsl_matrix_char_subdiagonal+0x88>
mov    0x10(%rsi),%rcx
mov    %rdx,%r8
imul   %rcx,%r8
add    0x18(%rsi),%r8
mov    0x20(%rsi),%rdi
sub    %rdx,%rax
mov    0x8(%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
add    $0x1,%rcx
mov    %rcx,0x8(%rbx)
mov    %r8,0x10(%rbx)
mov    %rdi,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_char_subdiagonal (gsl_matrix_char * m,
                                    const size_t k)
{
  _gsl_vector_char_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 14
22 12
23 12
24 12
25 12
26 17
27 13
28 13
29 17
30 17
31 17
32 19
33 19
34 19
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_qrng_state (const gsl_qrng * q)
{
  return q->state;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    0x0(%rip),%rdx        # 244 <evalerror+0x12>
mov    0x0(%rip),%rbx        # 24b <evalerror+0x19>
movzbl (%rbx),%eax
cmp    $0x9,%al
je     256 <evalerror+0x24>
cmp    $0x20,%al
jne    265 <evalerror+0x33>
add    $0x1,%rbx
movzbl (%rbx),%eax
cmp    $0x9,%al
je     256 <evalerror+0x24>
cmp    $0x20,%al
je     256 <evalerror+0x24>
mov    0x0(%rip),%rax        # 26c <evalerror+0x3a>
test   %rax,%rax
je     280 <evalerror+0x4e>
cmpb   $0x0,(%rax)
mov    $0x0,%r14d
cmovne %rax,%r14
jmp    286 <evalerror+0x54>
mov    $0x0,%r14d
test   %rdx,%rdx
mov    $0x0,%r12d
cmovne %rdx,%r12
mov    $0x0,%eax
mov    $0x0,%r13d
cmovne %rax,%r13
mov    $0x0,%edi
callq  2ac <evalerror+0x7a>
mov    %r14,%r9
mov    %rbp,%r8
mov    %rbx,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  2c8 <evalerror+0x96>
mov    $0x1,%esi
mov    $0x0,%edi
callq  2d7 <readtok>
<<<sep_in_sample>>>
evalerror (msg)
     const char *msg;
{
  char *name, *t;
  name = this_command_name;
  for (t = expression; (((*t) == ' ') || ((*t) == '\t')); t++)
    ;
  internal_error (gettext("%s%s%s: %s (error token is \"%s\")"),
     name ? name : "", name ? ": " : "", t,
     msg, (lasttp && *lasttp) ? lasttp : "");
  siglongjmp((evalbuf), (1));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 10
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 11
45 11
46 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x50(%rdi),%rdi
callq  10b <rk1imp_free+0xd>
mov    0x48(%rbx),%rdi
callq  b2 <modnewton1_free>
mov    0x38(%rbx),%rdi
callq  11d <rk1imp_free+0x1f>
mov    0x40(%rbx),%rdi
callq  126 <rk1imp_free+0x28>
mov    0x30(%rbx),%rdi
callq  12f <rk1imp_free+0x31>
mov    0x28(%rbx),%rdi
callq  138 <rk1imp_free+0x3a>
mov    0x20(%rbx),%rdi
callq  141 <rk1imp_free+0x43>
mov    0x18(%rbx),%rdi
callq  14a <rk1imp_free+0x4c>
mov    0x10(%rbx),%rdi
callq  153 <rk1imp_free+0x55>
mov    0x8(%rbx),%rdi
callq  15c <rk1imp_free+0x5e>
mov    (%rbx),%rdi
callq  164 <rk1imp_free+0x66>
mov    %rbx,%rdi
callq  16c <rk1imp_free+0x6e>
pop    %rbx
retq   
<<<sep_in_sample>>>
rk1imp_free (void *vstate)
{
  rk1imp_state_t *state = (rk1imp_state_t *) vstate;
  free (state->errlev);
  modnewton1_free (state->esol);
  gsl_matrix_free (state->dfdy);
  free (state->dfdt);
  free (state->fYZ);
  free (state->YZ);
  free (state->y_save);
  free (state->ytmp);
  free (state->y_twostep);
  free (state->y_onestep);
  gsl_matrix_free (state->A);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 13
23 14
24 14
25 15
26 15
27 16
28 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rbx        # 73 <lookup+0x10>
test   %rbx,%rbx
je     98 <lookup+0x35>
mov    $0x20,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  88 <lookup+0x25>
test   %eax,%eax
je     b5 <lookup+0x52>
mov    0x108(%rbx),%rbx
test   %rbx,%rbx
jne    78 <lookup+0x15>
callq  9d <lookup+0x3a>
mov    %rax,%rbx
mov    $0x20,%edx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  b0 <lookup+0x4d>
mov    %rbx,%rax
jmp    b8 <lookup+0x55>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
lookup (const char *nam)
{
  struct sym *sp;
  for (sp = symtab; sp != ((void *)0); sp = sp->sy_link)
    if (strncmp (sp->sy_name, nam, 32) == 0)
      return sp;
  sp = salloc();
  strncpy (sp->sy_name, nam, 32);
  return sp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 4
15 4
16 4
17 7
18 7
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r11
cmp    (%rdi),%r11
jne    2489 <gsl_matrix_long_add+0x1f>
mov    0x8(%rsi),%r9
cmp    %rax,%r9
je     24a9 <gsl_matrix_long_add+0x3f>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  24a2 <gsl_matrix_long_add+0x38>
mov    $0x13,%eax
jmp    2523 <gsl_matrix_long_add+0xb9>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r12
test   %r11,%r11
je     2517 <gsl_matrix_long_add+0xad>
lea    0x0(,%rax,8),%r13
sub    %rax,%r12
shl    $0x3,%r12
mov    $0x0,%r10d
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    2508 <gsl_matrix_long_add+0x9e>
mov    %rax,%rcx
add    0x18(%rdi),%rcx
mov    %rax,%r8
add    0x18(%rsi),%r8
mov    (%r8,%r10,1),%r8
add    %r8,(%rcx)
add    $0x1,%rdx
add    $0x8,%rax
cmp    %r9,%rdx
jne    24d7 <gsl_matrix_long_add+0x6d>
add    $0x1,%rbx
add    %r13,%rbp
add    %r12,%r10
cmp    %r11,%rbx
je     251e <gsl_matrix_long_add+0xb4>
test   %r9,%r9
je     24f9 <gsl_matrix_long_add+0x8f>
mov    %rbp,%rax
mov    $0x0,%edx
jmp    24d7 <gsl_matrix_long_add+0x6d>
mov    $0x0,%eax
jmp    2523 <gsl_matrix_long_add+0xb9>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_long_add (gsl_matrix_long * a, const gsl_matrix_long * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 28, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
37 16
38 16
39 16
40 16
41 14
42 14
43 14
44 14
45 14
46 16
47 16
48 16
49 16
50 16
51 21
52 21
53 21
54 23
55 23
56 23
57 23
58 23
59 23
<<<sep_out_sample>>>
mov    0x68(%rdi),%rax
retq   
<<<sep_in_sample>>>
__rpline (__bs6FILE *p)
{
  return (p->line);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  3e17 <point_prev_line+0x9>
test   %eax,%eax
jle    3e4a <point_prev_line+0x3c>
cltq   
mov    0x78(%rbx),%rdx
mov    -0x8(%rdx,%rax,8),%rax
mov    %rax,0x40(%rbx)
mov    %rbx,%rdi
callq  3e32 <point_prev_line+0x24>
mov    0x60(%rbx),%rdx
mov    0x68(%rbx),%rax
mov    -0x8(%rax,%rdx,8),%rax
mov    %rax,0x40(%rbx)
mov    $0x1,%eax
jmp    3eab <point_prev_line+0x9d>
cmpl   $0x0,0x0(%rip)        # 3e51 <point_prev_line+0x43>
je     3e9e <point_prev_line+0x90>
mov    0x0(%rip),%esi        # 3e59 <point_prev_line+0x4b>
mov    %rbx,%rdi
callq  3c62 <backward_move_node_structure>
test   %eax,%eax
jne    3e9e <point_prev_line+0x90>
mov    0x30(%rbx),%rax
mov    0x20(%rax),%rax
sub    $0x1,%rax
mov    %rax,0x40(%rbx)
mov    0x88(%rbx),%rsi
mov    0x18(%rbx),%rax
cmp    %rax,%rsi
jle    3e8f <point_prev_line+0x81>
sub    %eax,%esi
mov    %rbx,%rdi
callq  3e8f <point_prev_line+0x81>
mov    %rbx,%rdi
callq  3e97 <point_prev_line+0x89>
mov    $0x1,%eax
jmp    3eab <point_prev_line+0x9d>
movq   $0x0,0x40(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
point_prev_line (WINDOW *win)
{
  int line = window_line_of_point (win);
  if (line > 0)
    {
      win->point = win->line_starts[line - 1];
      window_compute_line_map (win);
      win->point = win->line_map.map[win->line_map.used - 1];
      return 1;
    }
  if (cursor_movement_scrolls_p
      && backward_move_node_structure (win, info_scroll_behaviour) == 0)
    {
      win->point = win->node->nodelen - 1;
      if (win->line_count > win->height)
        set_window_pagetop (win, win->line_count - win->height);
      window_compute_line_map (win);
      return 1;
    }
  win->point = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 6
8 6
9 6
10 7
11 7
12 8
13 8
14 8
15 8
16 9
17 9
18 11
19 11
20 12
21 12
22 12
23 12
24 12
25 14
26 14
27 14
28 14
29 15
30 15
31 15
32 15
33 16
34 16
35 16
36 17
37 17
38 18
39 18
40 20
41 21
42 22
43 22
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3cef <gsl_matrix_uchar_scale+0x5a>
mov    $0x0,%r8d
mov    $0x0,%r9d
jmp    3ce1 <gsl_matrix_uchar_scale+0x4c>
mov    %rax,%rdx
add    0x18(%rdi),%rdx
movzbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
add    $0x1,%rax
cmp    %rax,%rsi
jne    3cb4 <gsl_matrix_uchar_scale+0x1f>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
je     3cef <gsl_matrix_uchar_scale+0x5a>
test   %r10,%r10
je     3cd5 <gsl_matrix_uchar_scale+0x40>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
jmp    3cb4 <gsl_matrix_uchar_scale+0x1f>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_scale (gsl_matrix_uchar * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 9
28 9
29 15
30 15
31 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  1036 <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
mov    (%rdi),%r8d
mov    $0x0,%ebp
mov    $0x0,%ebx
test   %r10,%r10
je     108f <gsl_vector_uint_minmax_index+0x45>
jmp    1097 <gsl_vector_uint_minmax_index+0x4d>
mov    (%rdi),%ecx
cmp    %ecx,%r8d
jbe    1078 <gsl_vector_uint_minmax_index+0x2e>
mov    %ecx,%r8d
mov    %rax,%rbx
add    %r11,%rdi
cmp    %r9d,%ecx
jbe    1086 <gsl_vector_uint_minmax_index+0x3c>
mov    %ecx,%r9d
mov    %rax,%rbp
add    $0x1,%rax
cmp    %r10,%rax
jne    106b <gsl_vector_uint_minmax_index+0x21>
mov    %rbx,(%rsi)
mov    %rbp,(%rdx)
jmp    10b5 <gsl_vector_uint_minmax_index+0x6b>
shl    $0x2,%r11
add    %r11,%rdi
mov    %r8d,%r9d
mov    %r8d,%ecx
mov    $0x0,%eax
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    107b <gsl_vector_uint_minmax_index+0x31>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_uint_minmax_index (const gsl_vector_uint * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  unsigned int max = v->data[0 * stride];
  unsigned int min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 8
7 7
8 7
9 11
10 11
11 11
12 13
13 14
14 14
15 13
16 11
17 11
18 19
19 19
20 19
21 19
22 11
23 11
24 11
25 25
26 26
27 26
28 13
29 13
30 8
31 13
32 11
33 7
34 7
35 7
36 27
37 27
38 27
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x406,%esi
mov    $0x0,%eax
callq  78 <dup_cloexec+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     10d <udf_get_fileid_descriptor+0x45>
mov    0x38(%rdi),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
je     112 <udf_get_fileid_descriptor+0x4a>
mov    (%rdx),%rax
mov    %rax,(%rsi)
mov    0x8(%rdx),%rax
mov    %rax,0x8(%rsi)
mov    0x10(%rdx),%rax
mov    %rax,0x10(%rsi)
mov    0x18(%rdx),%rax
mov    %rax,0x18(%rsi)
mov    0x20(%rdx),%eax
mov    %eax,0x20(%rsi)
movzwl 0x24(%rdx),%eax
mov    %ax,0x24(%rsi)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
udf_get_fileid_descriptor(const udf_dirent_t *p_udf_dirent,
                  udf_fileid_desc_t *p_udf_fid)
{
  if (!p_udf_dirent) return 0;
  if (!p_udf_dirent->fid) {
    return 0;
  }
  memcpy(p_udf_fid, p_udf_dirent->fid, sizeof(udf_fileid_desc_t));
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 5
6 5
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 4
22 10
<<<sep_out_sample>>>
lea    -0x1(%rsi),%eax
cmp    $0xb,%eax
ja     158b <valid_date+0x46>
push   %rbx
mov    %edi,%ebx
mov    %edi,%eax
shr    $0x1f,%eax
test   %al,%al
jne    1584 <valid_date+0x3f>
cmp    $0x2,%esi
je     1573 <valid_date+0x2e>
sub    $0x1,%esi
movslq %esi,%rsi
cmp    0x0(,%rsi,4),%edi
setle  %al
movzbl %al,%eax
jmp    1589 <valid_date+0x44>
mov    %edx,%edi
callq  157a <valid_date+0x35>
cmp    %eax,%ebx
setle  %al
movzbl %al,%eax
jmp    1589 <valid_date+0x44>
mov    $0x0,%eax
pop    %rbx
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
valid_date (day, month, year)
     const int day;
     const int month;
     const int year;
{
  if (day < 0
      || month < 1
      || month > 12
      || ((month != 2)
   && (day > dvec[month - 1]))
      || ((month == 2) && (day > days_of_february (year))))
    return ((!(0==0)));
  return ((0==0));
}
<<<sep_in_sample>>>
1 7
2 6
3 6
4 5
5 5
6 6
7 6
8 6
9 6
10 9
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 11
19 11
20 11
21 11
22 11
23 11
24 12
25 14
26 14
27 12
28 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r13d
mov    %rsi,%r12
mov    %rdx,%rbx
jmp    1a <safe_read+0x1a>
mov    $0x7fffe000,%ebx
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  28 <safe_read+0x28>
mov    %rax,%rbp
test   %rax,%rax
js     32 <safe_read+0x32>
jmp    4f <safe_read+0x4f>
callq  37 <safe_read+0x37>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     1a <safe_read+0x1a>
cmp    $0x16,%ecx
jne    4c <safe_read+0x4c>
cmp    $0x7fffe000,%rbx
ja     15 <safe_read+0x15>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_read (int fd, void *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = read (fd, buf, count);
      if (0 <= result)
 return result;
      else if ((((*__errno_location ())) == 4))
 continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
 count = BUGGY_READ_MAXIMUM;
      else
 return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 12
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 8
19 9
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 14
28 16
29 16
30 16
31 16
32 16
33 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  19bb <gsl_sf_gamma_inc+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     19e1 <gsl_sf_gamma_inc+0x32>
mov    %eax,%ecx
mov    $0x2d0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19da <gsl_sf_gamma_inc+0x2b>
movsd  (%rsp),%xmm0
jmp    19e1 <gsl_sf_gamma_inc+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_gamma_inc(const double a, const double x)
{
   gsl_sf_result result; int status = gsl_sf_gamma_inc_e(a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_gamma_inc_e(a, x, &result)", "gamma_inc.c", 720, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpb   $0x0,0x9(%rdi)
jne    5c6 <get_num_tracks_generic+0x1d>
mov    0x1020(%rdi),%rax
callq  *0x158(%rax)
cmpb   $0x0,0x9(%rbx)
je     5cc <get_num_tracks_generic+0x23>
movzbl 0x1d(%rbx),%eax
jmp    5d1 <get_num_tracks_generic+0x28>
mov    $0xffffffff,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
get_num_tracks_generic(void *p_user_data)
{
  generic_img_private_t *p_env = p_user_data;
  if (!p_env->toc_init)
    p_env->cdio->op.read_toc (p_user_data);
  return p_env->toc_init ? p_env->i_tracks : CDIO_INVALID_TRACK;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
mov    0x94(%rdi),%r11d
mov    %r11d,%edx
mov    $0x0,%eax
jmp    638 <search_cur_bkref_entry+0x43>
lea    (%rax,%rcx,1),%edx
mov    %edx,%r8d
shr    $0x1f,%r8d
add    %r8d,%edx
sar    %edx
mov    %edx,%r10d
movslq %edx,%r8
lea    (%r8,%r8,4),%r8
cmp    %esi,0x4(%r9,%r8,4)
jl     632 <search_cur_bkref_entry+0x3d>
mov    %edx,%ecx
cmp    %ecx,%eax
jl     606 <search_cur_bkref_entry+0x11>
mov    %eax,%edx
jmp    668 <search_cur_bkref_entry+0x73>
mov    %edx,%ecx
lea    0x1(%r10),%eax
mov    %ecx,%edx
cmp    %eax,%edx
jle    666 <search_cur_bkref_entry+0x71>
lea    (%rdx,%rax,1),%ecx
mov    %ecx,%r10d
shr    $0x1f,%r10d
add    %ecx,%r10d
sar    %r10d
mov    %r10d,%ecx
mov    0xa0(%rdi),%r9
movslq %r10d,%r8
lea    (%r8,%r8,4),%r8
cmp    0x4(%r9,%r8,4),%esi
jle    628 <search_cur_bkref_entry+0x33>
jmp    630 <search_cur_bkref_entry+0x3b>
mov    %eax,%edx
cmp    %r11d,%edx
jge    68b <search_cur_bkref_entry+0x96>
movslq %edx,%rdx
lea    (%rdx,%rdx,4),%rdx
shl    $0x2,%rdx
add    0xa0(%rdi),%rdx
cmp    %esi,0x4(%rdx)
mov    $0xffffffff,%edx
cmovne %edx,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
search_cur_bkref_entry (const re_match_context_t *mctx, int str_idx)
{
  int left, right, mid, last;
  last = right = mctx->nbkref_ents;
  for (left = 0; left < right;)
    {
      mid = (left + right) / 2;
      if (mctx->bkref_ents[mid].str_idx < str_idx)
 left = mid + 1;
      else
 right = mid;
    }
  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)
    return left;
  else
    return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 7
16 5
17 5
18 5
19 5
20 8
21 9
22 9
23 5
24 5
25 7
26 7
27 7
28 7
29 7
30 7
31 8
32 8
33 8
34 8
35 8
36 8
37 5
38 13
39 13
40 13
41 13
42 13
43 13
44 16
45 16
46 16
47 16
48 16
49 17
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm1        # 9a <zero_g+0xc>
movsd  %xmm0,0x8(%rsp)
callq  a5 <zero_g+0x17>
movsd  0x8(%rsp),%xmm5
movapd %xmm5,%xmm1
mulsd  %xmm5,%xmm1
movsd  0x0(%rip),%xmm3        # bb <zero_g+0x2d>
movapd %xmm3,%xmm2
divsd  %xmm1,%xmm2
movapd %xmm2,%xmm1
mulsd  %xmm2,%xmm1
movapd %xmm2,%xmm4
mulsd  0x0(%rip),%xmm4        # d7 <zero_g+0x49>
addsd  %xmm4,%xmm3
movapd %xmm1,%xmm4
mulsd  0x0(%rip),%xmm4        # e7 <zero_g+0x59>
addsd  %xmm4,%xmm3
movapd %xmm1,%xmm4
mulsd  0x0(%rip),%xmm4        # f7 <zero_g+0x69>
mulsd  %xmm4,%xmm2
addsd  %xmm3,%xmm2
movapd %xmm1,%xmm3
mulsd  0x0(%rip),%xmm3        # 10b <zero_g+0x7d>
mulsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
zero_g(double z)
{
  const double pre = pow(z, 2.0/3.0);
  const double zi2 = 1.0/(z*z);
  const double zi4 = zi2 * zi2;
  const double t1 = -7.0/48.0 * zi2;
  const double t2 = 35.0/288.0 * zi4;
  const double t3 = -181223.0/207360.0 * zi4 * zi2;
  const double t4 = 18683371.0/1244160.0 * zi4 * zi4;
  return pre * (1.0 + t1 + t2 + t3 + t4);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 6
14 6
15 10
16 7
17 7
18 10
19 8
20 8
21 8
22 10
23 9
24 9
25 9
26 10
27 10
28 11
29 11
<<<sep_out_sample>>>
mov    $0x1003,%eax
test   %rdi,%rdi
je     547 <mu_mailbox_sync+0x28>
mov    0xa0(%rdi),%rdx
test   %rdx,%rdx
je     547 <mu_mailbox_sync+0x28>
mov    0x30(%rdi),%eax
and    $0xe,%eax
je     547 <mu_mailbox_sync+0x28>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailbox_sync (mu_mailbox_t mbox)
{
  if (mbox == ((void *)0) || mbox->_sync == ((void *)0))
    return (0x1000 +3);
  if (!(mbox->flags & (0x00000004|0x00000002|0x00000008)))
    return 0;
  return mbox->_sync (mbox);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 2
11 7
12 8
13 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%r13
mov    %rdx,%r12
mov    %rcx,%rbp
mov    %r8,%rbx
cmpl   $0x3e7,0x0(%rip)        # c0 <GetJoystickPosition+0x21>
jne    e4 <GetJoystickPosition+0x45>
xorpd  %xmm0,%xmm0
movsd  %xmm0,(%rdi)
movsd  %xmm0,(%rsi)
movsd  %xmm0,(%rdx)
movsd  %xmm0,(%rcx)
mov    0x0(%rip),%eax        # dc <GetJoystickPosition+0x3d>
mov    %eax,(%r8)
jmpq   1ce <GetJoystickPosition+0x12f>
mov    $0x0,%edi
callq  ee <GetJoystickPosition+0x4f>
movsd  0x0(%rip),%xmm1        # f6 <GetJoystickPosition+0x57>
movapd %xmm0,%xmm3
cmpnltsd %xmm1,%xmm3
movapd %xmm3,%xmm1
andpd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm2        # 10f <GetJoystickPosition+0x70>
andnpd %xmm2,%xmm1
orpd   %xmm1,%xmm0
movsd  %xmm0,(%r14)
mov    $0x1,%edi
callq  126 <GetJoystickPosition+0x87>
movsd  0x0(%rip),%xmm1        # 12e <GetJoystickPosition+0x8f>
movapd %xmm0,%xmm4
cmpnltsd %xmm1,%xmm4
movapd %xmm4,%xmm1
andpd  %xmm4,%xmm0
movsd  0x0(%rip),%xmm2        # 147 <GetJoystickPosition+0xa8>
andnpd %xmm2,%xmm1
orpd   %xmm1,%xmm0
movsd  %xmm0,0x0(%r13)
mov    $0x2,%edi
callq  15f <GetJoystickPosition+0xc0>
movsd  0x0(%rip),%xmm1        # 167 <GetJoystickPosition+0xc8>
movapd %xmm0,%xmm5
cmpnltsd %xmm1,%xmm5
movapd %xmm5,%xmm1
andpd  %xmm5,%xmm0
movsd  0x0(%rip),%xmm2        # 180 <GetJoystickPosition+0xe1>
andnpd %xmm2,%xmm1
orpd   %xmm1,%xmm0
movsd  %xmm0,(%r12)
mov    $0x3,%edi
callq  198 <GetJoystickPosition+0xf9>
movsd  0x0(%rip),%xmm1        # 1a0 <GetJoystickPosition+0x101>
movapd %xmm0,%xmm6
cmpnltsd %xmm1,%xmm6
movapd %xmm6,%xmm1
andpd  %xmm6,%xmm0
movsd  0x0(%rip),%xmm2        # 1b9 <GetJoystickPosition+0x11a>
andnpd %xmm2,%xmm1
orpd   %xmm1,%xmm0
movsd  %xmm0,0x0(%rbp)
mov    0x0(%rip),%eax        # 1cc <GetJoystickPosition+0x12d>
mov    %eax,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
GetJoystickPosition(double *x1, double *y1,
      double *x2, double *y2, int *switches)
{
  if (min[0] == 999)
  {
    *x1 = 0.0; *y1 = 0.0; *x2 = 0.0; *y2 = 0.0; *switches = value[4];
    return;
  }
  *x1 = fixJoy(0);
  if (*x1 < -1.0) *x1 = -1.0;
  *y1 = fixJoy(1);
  if (*y1 < -1.0) *y1 = -1.0;
  *x2 = fixJoy(2);
  if (*x2 < -1.0) *x2 = -1.0;
  *y2 = fixJoy(3);
  if (*y2 < -1.0) *y2 = -1.0;
  *switches = value[4];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 13
44 13
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 14
54 15
55 15
56 16
57 16
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 17
66 17
67 18
68 18
69 18
70 18
71 18
72 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
callq  adf <cmdline_parser_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cmdline_parser_ext (int argc, char * const *argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, ((void *)0));
  return result;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
testl  $0x102,0x48(%rdi)
je     431 <setup_dir+0x38>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1f,%edi
callq  425 <setup_dir+0x2c>
mov    %rax,0x58(%rbx)
test   %rax,%rax
setne  %al
jmp    456 <setup_dir+0x5d>
mov    $0x20,%edi
callq  43b <setup_dir+0x42>
mov    %rax,%rdi
mov    %rax,0x58(%rbx)
mov    $0x0,%eax
test   %rdi,%rdi
je     456 <setup_dir+0x5d>
callq  451 <setup_dir+0x58>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
setup_dir (FTS *fts)
{
  if (fts->fts_options & (0x0100 | 0x0002))
    {
      enum { HT_INITIAL_SIZE = 31 };
      fts->fts_cycle.ht = hash_initialize (HT_INITIAL_SIZE, ((void *)0), AD_hash,
                                           AD_compare, free);
      if (! fts->fts_cycle.ht)
        return 0;
    }
  else
    {
      fts->fts_cycle.state = malloc (sizeof *fts->fts_cycle.state);
      if (! fts->fts_cycle.state)
        return 0;
      cycle_check_init (fts->fts_cycle.state);
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 13
16 13
17 13
18 13
19 15
20 14
21 14
22 16
23 18
24 19
25 19
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
sigsegv_reset_onstack_flag (void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3b <remove_output_file>
mov    $0x1,%edi
callq  12cd <do_exit>
<<<sep_in_sample>>>
abort_gzip ()
{
   remove_output_file ();
   do_exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  1af <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1bd <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
movl   $0x3fffffff,0x14(%rdi)
retq   
<<<sep_in_sample>>>
panel_no_optimizations(this)
    panel_t *this;
{
    this->on_screen = 2147483647 / 2;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4ec <net_output_byte+0x7>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 4f7 <net_output_byte+0x12>
mov    %dil,(%rax)
retq   
<<<sep_in_sample>>>
net_output_byte (int c)
{
  *nfrontp++ = c;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
cmp    %rsi,0x30(%rdi)
ja     413 <gl_array_nx_set_at+0xf>
sub    $0x8,%rsp
callq  413 <gl_array_nx_set_at+0xf>
mov    0x28(%rdi),%rax
mov    %rdx,(%rax,%rsi,8)
lea    0x1(%rsi),%rax
retq   
<<<sep_in_sample>>>
gl_array_nx_set_at (gl_list_t list, size_t position, const void *elt)
{
  size_t count = list->count;
  if (!(position < count))
    abort ();
  list->elements[position] = elt;
  return (gl_list_node_t)(unsigned long)(size_t)((position) + 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 6
6 6
7 7
8 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  254 <load_history+0x10>
mov    $0x0,%edi
callq  25e <load_history+0x1a>
mov    $0x0,%edi
callq  268 <load_history+0x24>
mov    %rax,%rsi
mov    $0x0,%edi
callq  275 <load_history+0x31>
mov    $0x0,%edi
callq  27f <load_history+0x3b>
mov    $0x0,%edi
callq  289 <load_history+0x45>
mov    %rax,%rbx
test   %rax,%rax
je     2bb <load_history+0x77>
cmpb   $0x0,(%rax)
je     2bb <load_history+0x77>
mov    %rax,%rdi
callq  29e <load_history+0x5a>
test   %eax,%eax
je     2bb <load_history+0x77>
mov    %rbx,%rdi
callq  2aa <load_history+0x66>
mov    0x0(%rip),%eax        # 2b0 <load_history+0x6c>
mov    %eax,0x0(%rip)        # 2b6 <load_history+0x72>
callq  2bb <load_history+0x77>
pop    %rbx
retq   
<<<sep_in_sample>>>
load_history ()
{
  char *hf;
  set_if_not ("HISTSIZE", "500");
  sv_histsize ("HISTSIZE");
  set_if_not ("HISTFILESIZE", get_string_value ("HISTSIZE"));
  sv_histsize ("HISTFILESIZE");
  hf = get_string_value ("HISTFILE");
  if (hf && *hf && file_exists (hf))
    {
      read_history (hf);
      history_lines_in_file = history_lines_read_from_file;
      using_history ();
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 11
26 11
27 12
28 12
29 13
30 15
31 15
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(%rip),%rax        # 64 <processes_in_job+0xa>
mov    (%rax,%rdi,8),%rax
mov    0x8(%rax),%rcx
mov    %rcx,%rdx
mov    $0x0,%eax
mov    (%rdx),%rdx
add    $0x1,%eax
cmp    %rdx,%rcx
jne    74 <processes_in_job+0x1a>
repz retq 
<<<sep_in_sample>>>
processes_in_job (job)
     int job;
{
  int nproc;
  register PROCESS *p;
  nproc = 0;
  p = jobs[job]->pipe;
  do
    {
      p = p->next;
      nproc++;
    }
  while (p != jobs[job]->pipe);
  return nproc;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 6
7 10
8 11
9 13
10 13
11 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
movzbl (%rsi),%eax
mov    %al,0xf(%rsp)
mov    $0x1,%edx
lea    0xf(%rsp),%rsi
callq  1dc <xdr_byte_u_char+0x1e>
mov    $0x0,%edx
test   %eax,%eax
je     1ee <xdr_byte_u_char+0x30>
movzbl 0xf(%rsp),%eax
mov    %al,(%rbx)
mov    $0x1,%dl
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
xdr_byte_u_char(XDR * xdrs, void * vcp)
{
 u_char u, *cp = (u_char *) vcp;
 u = (*cp);
 if (!xdr_byte_opaque(xdrs, &u, 1)) {
  return ((0));
 }
 *cp = u;
 return ((1));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 5
9 6
10 5
11 5
12 8
13 8
14 9
15 10
16 10
17 10
18 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2b <set_parser+0x9>
test   %rax,%rax
je     3e <set_parser+0x1c>
mov    %rax,0x0(%rip)        # 37 <set_parser+0x15>
mov    $0x0,%eax
jmp    43 <set_parser+0x21>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_parser(const char *arg)
{
 grecs_parser_t p = grecs_get_parser_by_type(arg);
 if (p) {
  grecs_parser_fun = p;
  return 0;
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 6
7 6
8 8
9 9
10 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  4d <nettle_gcm_aes192_set_iv+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes192_set_iv (struct gcm_aes192_ctx *ctx,
        size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <cholesky_free+0x11>
callq  11 <cholesky_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     1f <cholesky_free+0x1f>
callq  1f <cholesky_free+0x1f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2d <cholesky_free+0x2d>
callq  2d <cholesky_free+0x2d>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     3b <cholesky_free+0x3b>
callq  3b <cholesky_free+0x3b>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     49 <cholesky_free+0x49>
callq  49 <cholesky_free+0x49>
mov    %rbx,%rdi
callq  51 <cholesky_free+0x51>
pop    %rbx
retq   
<<<sep_in_sample>>>
cholesky_free(void *vstate)
{
  cholesky_state_t *state = (cholesky_state_t *) vstate;
  if (state->JTJ)
    gsl_matrix_free(state->JTJ);
  if (state->work_JTJ)
    gsl_matrix_free(state->work_JTJ);
  if (state->rhs)
    gsl_vector_free(state->rhs);
  if (state->perm)
    gsl_permutation_free(state->perm);
  if (state->work3p)
    gsl_vector_free(state->work3p);
  free(state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 15
26 15
<<<sep_out_sample>>>
cmp    %rsi,(%rdi)
ja     28 <gsl_histogram_get+0x28>
sub    $0x8,%rsp
mov    $0x1,%ecx
mov    $0x22,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  22 <gsl_histogram_get+0x22>
xorpd  %xmm0,%xmm0
jmp    32 <gsl_histogram_get+0x32>
mov    0x10(%rdi),%rax
movsd  (%rax,%rsi,8),%xmm0
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_histogram_get (const gsl_histogram * h, size_t i)
{
  const size_t n = h->n;
  if (i >= n)
    {
      do { gsl_error ("index lies outside valid range of 0 .. n - 1",
 "get.c"
      ,
 34
      , GSL_EDOM) ; return 0 ; } while (0)
                                    ;
    }
  return h->bin[i];
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 6
7 6
8 6
9 10
10 10
11 13
12 13
13 13
14 14
15 14
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     21a <mu_vartab_define+0x85>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdx,%rbp
mov    %ecx,%ebx
lea    0x8(%rsp),%rdx
mov    (%rdi),%rdi
callq  1b7 <mu_vartab_define+0x22>
mov    %eax,%esi
cmp    $0x1029,%eax
jne    1cc <mu_vartab_define+0x37>
mov    0x8(%rsp),%rdi
callq  0 <vardefn_free>
jmp    1d0 <mu_vartab_define+0x3b>
test   %esi,%esi
jne    214 <mu_vartab_define+0x7f>
test   %ebx,%ebx
je     1ef <mu_vartab_define+0x5a>
mov    0x8(%rsp),%rax
movl   $0x1,(%rax)
mov    0x8(%rsp),%rax
mov    %rbp,0x8(%rax)
mov    $0x0,%eax
jmp    214 <mu_vartab_define+0x7f>
mov    0x8(%rsp),%rax
movl   $0x0,(%rax)
mov    0x8(%rsp),%rbx
mov    %rbp,%rdi
callq  207 <mu_vartab_define+0x72>
mov    %rax,0x8(%rbx)
cmp    $0x1,%rax
sbb    %eax,%eax
and    $0xc,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
mu_vartab_define (mu_vartab_t var, const char *name, const char *value,
    int isstatic)
{
  int rc;
  struct vardefn *vd;
  if (!var)
    return 22;
  rc = mu_assoc_ref_install (var->assoc, name, (void **) &vd);
  if (rc == (0x1000 +41))
    vardefn_free (vd);
  else if (rc != 0)
    return rc;
  if (isstatic)
    {
      vd->flags = 0x1;
      vd->value = (char*) value;
    }
  else
    {
      vd->flags = 0;
      vd->value = strdup (value);
      if (!vd->value)
 return 12;
    }
  return 0;
}
<<<sep_in_sample>>>
1 7
2 6
3 6
4 3
5 3
6 3
7 3
8 3
9 8
10 8
11 8
12 8
13 9
14 9
15 10
16 10
17 10
18 11
19 11
20 13
21 13
22 15
23 15
24 16
25 16
26 25
27 25
28 20
29 20
30 21
31 21
32 21
33 21
34 23
35 23
36 23
37 26
38 26
39 26
40 26
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     404 <_rl_errmsg+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rcx        # 435 <_rl_errmsg+0x8d>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  449 <_rl_errmsg+0xa1>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 458 <_rl_errmsg+0xb0>
callq  45d <_rl_errmsg+0xb5>
mov    0x0(%rip),%rsi        # 464 <_rl_errmsg+0xbc>
mov    $0xa,%edi
callq  46e <_rl_errmsg+0xc6>
mov    0x0(%rip),%rdi        # 475 <_rl_errmsg+0xcd>
callq  47a <_rl_errmsg+0xd2>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_errmsg (const char *format, ...)
{
  va_list args;
  __builtin_va_start(args,format);
  fprintf (stderr, "readline: ");
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  fflush (stderr);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 6
34 7
35 7
36 7
37 8
38 8
39 10
40 10
41 10
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rsi,(%rsp)
mov    %rdx,0x8(%rsp)
mov    %rcx,0x10(%rsp)
mov    %r8,0x18(%rsp)
mov    %rsp,%rsi
callq  355 <grecs_node_create_points+0x1f>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
grecs_node_create_points(enum grecs_node_type type,
    struct grecs_locus_point beg,
    struct grecs_locus_point end)
{
 grecs_locus_t loc;
 loc.beg = beg;
 loc.end = end;
 return grecs_node_create(type, &loc);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 7
5 7
6 8
7 8
8 9
9 9
<<<sep_out_sample>>>
mov    0x48(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_authentication_info_get_targetname (osip_authentication_info_t *
       authentication_info)
{
  return authentication_info->targetname;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer+0x32>
callq  16 <fd_safer+0x16>
mov    %eax,%r12d
callq  1e <fd_safer+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer (int fd)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer (fd);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
callq  8444 <do_assignment_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_word_assignment (word, flags)
     WORD_DESC *word;
     int flags;
{
  return do_assignment_internal (word, 1);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  90f <_rl_nsearch_callback+0x9>
mov    %eax,%esi
mov    %rbx,%rdi
callq  32 <_rl_nsearch_dispatch>
mov    $0x1,%edx
test   %eax,%eax
jne    945 <_rl_nsearch_callback+0x3f>
mov    %rbx,%rdi
callq  2cb <_rl_nsearch_dosearch>
test   %eax,%eax
js     93c <_rl_nsearch_callback+0x36>
mov    %eax,%esi
mov    %rbx,%rdi
callq  938 <_rl_nsearch_callback+0x32>
mov    %eax,%edx
jmp    945 <_rl_nsearch_callback+0x3f>
cmp    $0x1,%eax
setne  %dl
movzbl %dl,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_nsearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;
  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;
  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 6
7 8
8 7
9 7
10 9
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  3181 <gsl_vector_uchar_calloc+0xe>
mov    %rax,%rbp
test   %rax,%rax
je     31b7 <gsl_vector_uchar_calloc+0x44>
mov    0x10(%rax),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  319a <gsl_vector_uchar_calloc+0x27>
test   %rbx,%rbx
je     31be <gsl_vector_uchar_calloc+0x4b>
mov    $0x0,%ecx
mov    0x10(%rbp),%rsi
movb   $0x0,(%rsi,%rcx,1)
add    $0x1,%rcx
cmp    %rbx,%rcx
jne    31a4 <gsl_vector_uchar_calloc+0x31>
jmp    31c3 <gsl_vector_uchar_calloc+0x50>
mov    $0x0,%eax
jmp    31c6 <gsl_vector_uchar_calloc+0x53>
mov    %rbp,%rax
jmp    31c6 <gsl_vector_uchar_calloc+0x53>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_calloc (const size_t n)
{
  size_t i;
  gsl_vector_uchar * v = gsl_vector_uchar_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 1 * n * sizeof(unsigned char));
  for (i = 0; i < 1 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 6
24 12
25 12
26 12
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %edi,%edi
js     92 <free_cwd+0xf>
callq  92 <free_cwd+0xf>
mov    0x8(%rbx),%rdi
callq  9b <free_cwd+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_cwd (struct saved_cwd *cwd)
{
  if (cwd->desc >= 0)
    close (cwd->desc);
  free (cwd->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%r8
cmp    %r8,%rcx
jae    4a3 <hash_table_ok+0x45>
mov    $0x0,%edx
mov    $0x0,%esi
cmpq   $0x0,(%rcx)
je     498 <hash_table_ok+0x3a>
add    $0x1,%rsi
add    $0x1,%rdx
mov    0x8(%rcx),%rax
test   %rax,%rax
je     498 <hash_table_ok+0x3a>
add    $0x1,%rdx
mov    0x8(%rax),%rax
test   %rax,%rax
jne    48b <hash_table_ok+0x2d>
add    $0x10,%rcx
cmp    %r8,%rcx
jb     474 <hash_table_ok+0x16>
jmp    4ad <hash_table_ok+0x4f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
cmp    %rsi,0x18(%rdi)
jne    4bf <hash_table_ok+0x61>
cmp    %rdx,0x20(%rdi)
sete   %al
repz retq 
<<<sep_in_sample>>>
hash_table_ok (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t n_buckets_used = 0;
  size_t n_entries = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
        {
          struct hash_entry const *cursor = bucket;
          n_buckets_used++;
          n_entries++;
          while (cursor = cursor->next, cursor)
            n_entries++;
        }
    }
  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 5
6 4
7 8
8 8
9 11
10 12
11 13
12 13
13 13
14 14
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 5
23 4
24 19
25 17
26 17
27 17
28 17
29 20
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
test   %rsi,%rsi
je     41 <_gsasl_support_p+0x41>
mov    %rdx,%r12
mov    %rdi,%rbp
mov    $0x0,%ebx
test   %r12,%r12
je     32 <_gsasl_support_p+0x32>
mov    0x0(%rbp),%rsi
mov    %r12,%rdi
callq  2e <_gsasl_support_p+0x2e>
test   %eax,%eax
je     48 <_gsasl_support_p+0x48>
add    $0x1,%rbx
add    $0x78,%rbp
cmp    %r13,%rbx
jne    1d <_gsasl_support_p+0x1d>
jmp    4f <_gsasl_support_p+0x4f>
mov    $0x0,%eax
jmp    54 <_gsasl_support_p+0x54>
mov    $0x1,%eax
jmp    54 <_gsasl_support_p+0x54>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_gsasl_support_p (Gsasl_mechanism * mechs, size_t n_mechs, const char *name)
{
  size_t i;
  for (i = 0; i < n_mechs; i++)
    if (name && strcmp (name, mechs[i].name) == 0)
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 4
20 4
21 4
22 4
23 4
24 7
25 7
26 6
27 6
28 7
29 8
30 8
31 8
32 8
33 8
34 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%rbp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
callq  2c9 <dgetc>
cmp    $0xd,%al
je     50f <getblock+0x48>
lea    0x1(%rsp),%rbx
lea    0x20(%rsp),%r12
mov    %rbp,%rdi
callq  2c9 <dgetc>
mov    %al,(%rbx)
add    $0x1,%rbx
cmp    %r12,%rbx
jne    4f5 <getblock+0x2e>
movzbl 0x10(%rsp),%eax
jmp    514 <getblock+0x4d>
mov    $0x0,%eax
mov    0x28(%rsp),%rdx
xor    %fs:0x28,%rdx
je     529 <getblock+0x62>
callq  529 <getblock+0x62>
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
getblock(DFILE *fp)
{
  char block[32];
  int b;
  if ((block[0] = dgetc(fp)) == '\r')
    return 0;
  for (b = 1; b < 32; b++)
    block[b] = dgetc(fp);
  return (block[16] & 0xff);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 8
15 8
16 8
17 8
18 7
19 7
20 9
21 9
22 6
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %esi,%ebx
test   %esi,%esi
jns    13c7 <ea_rubout+0x16>
neg    %esi
callq  13c5 <ea_rubout+0x14>
jmp    1415 <ea_rubout+0x64>
mov    0x0(%rip),%ebp        # 13cd <ea_rubout+0x1c>
cmp    0x0(%rip),%ebp        # 13d3 <ea_rubout+0x22>
jne    13e9 <ea_rubout+0x38>
cmp    0x0(%rip),%ebp        # 13db <ea_rubout+0x2a>
jne    1415 <ea_rubout+0x64>
movl   $0x1,0x0(%rip)        # 13e7 <ea_rubout+0x36>
jmp    1415 <ea_rubout+0x64>
callq  13ee <ea_rubout+0x3d>
cmpl   $0x0,0x0(%rip)        # 13f5 <ea_rubout+0x44>
jne    13fc <ea_rubout+0x4b>
cmp    $0x1,%ebx
jle    140b <ea_rubout+0x5a>
mov    0x0(%rip),%esi        # 1402 <ea_rubout+0x51>
mov    %ebp,%edi
callq  59a <ea_kill_text>
jmp    1415 <ea_rubout+0x64>
mov    %ebx,%esi
mov    %r12,%rdi
callq  1415 <ea_rubout+0x64>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
ea_rubout (WINDOW *window, int count)
{
  if (count < 0)
    ea_delete (window, -count);
  else
    {
      int start;
      if (input_line_point == input_line_beg)
        {
          if (input_line_beg == input_line_end)
            info_aborted_echo_area = 1;
          return;
        }
      start = input_line_point;
      ea_backward (window, count);
      if (ea_explicit_arg || count > 1)
        ea_kill_text (start, input_line_point);
      else
        ea_delete (window, count);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 8
12 8
13 8
14 10
15 10
16 11
17 11
18 15
19 16
20 16
21 16
22 16
23 17
24 17
25 17
26 17
27 19
28 19
29 19
30 21
31 21
32 21
33 21
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
movzbl (%rcx),%edi
test   %r8,%r8
je     1685 <gsl_vector_uchar_max_index+0x3d>
add    %r9,%rcx
mov    $0x0,%edx
mov    $0x0,%eax
jmp    167a <gsl_vector_uchar_max_index+0x32>
movzbl (%rcx),%esi
cmp    %sil,%dil
jae    1677 <gsl_vector_uchar_max_index+0x2f>
mov    %rdx,%rax
mov    %esi,%edi
add    %r9,%rcx
add    $0x1,%rdx
cmp    %r8,%rdx
jne    166a <gsl_vector_uchar_max_index+0x22>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_max_index (const gsl_vector_uchar * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned char max = v->data[0 * stride];
  size_t imax = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned char x = v->data[i*stride];
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  return imax;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 8
7 8
8 8
9 6
10 6
11 10
12 11
13 11
14 8
15 10
16 10
17 8
18 8
19 8
20 8
21 6
22 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
and    $0x1,%esi
shl    $0x2,%esi
movzbl 0xaa(%rdi),%eax
and    $0xfffffffb,%eax
or     %eax,%esi
mov    %sil,0xaa(%rdi)
mov    0xa8(%rdi),%esi
callq  28d <simplify_attributes>
mov    %eax,0xac(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
term_ostream__set_weight (term_ostream_t stream, term_weight_t weight)
{
  stream->curr_attr.weight = weight;
  stream->simp_attr = simplify_attributes (stream, stream->curr_attr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x18,%esi
callq  659 <nettle_twofish192_set_key+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_twofish192_set_key(struct twofish_ctx *context, const uint8_t *key)
{
  nettle_twofish_set_key (context, 24, key);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
<<<sep_in_sample>>>
rec_sex_parser_scanner (rec_sex_parser_t parser)
{
  return parser->scanner;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gl_array_iterator_free (gl_list_iterator_t *iterator)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  118 <gl_array_sortedlist_indexof>
mov    %rax,%rsi
mov    $0x0,%eax
cmp    $0xffffffffffffffff,%rsi
je     2b0 <gl_array_sortedlist_remove+0x1f>
mov    %rbx,%rdi
callq  223 <gl_array_remove_at>
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_array_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,
                            const void *elt)
{
  size_t index = gl_array_sortedlist_indexof (list, compar, elt);
  if (index == (size_t)(-1))
    return 0;
  else
    return gl_array_remove_at (list, index);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 6
6 5
7 5
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
cmp    %edx,%esi
jne    1982 <_x87_negr_d+0x4f>
test   %esi,%esi
jne    1953 <_x87_negr_d+0x20>
mov    $0x0,%edx
mov    $0xc,%esi
callq  13ec <_x87ri>
jmp    19ae <_x87_negr_d+0x7b>
mov    %esi,%edx
mov    $0x9,%esi
callq  13ec <_x87ri>
mov    $0x0,%edx
mov    $0xc,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
mov    %ebp,%edx
mov    $0x9,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
jmp    19ae <_x87_negr_d+0x7b>
mov    $0x8,%esi
callq  13ec <_x87ri>
mov    $0x0,%edx
mov    $0xc,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
lea    0x1(%rbp),%edx
mov    $0x2b,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_x87_negr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    if (r0 == r1) {
 if (r1 == 0)
     _x87ri(_jit,014,0);
 else {
     _x87ri(_jit,011,r0);
     _x87ri(_jit,014,0);
     _x87ri(_jit,011,r0);
 }
    }
    else {
 _x87ri(_jit,010,r1);
 _x87ri(_jit,014,0);
 _x87ri(_jit,053,r0 + 1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 13
26 13
27 14
28 14
29 14
30 14
31 15
32 15
33 15
34 15
35 17
36 17
37 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     5f6 <make_lowercase+0x2f>
movzbl (%rdi),%edx
test   %dl,%dl
je     5fd <make_lowercase+0x36>
mov    %rdi,%rbx
movzbl %dl,%edi
callq  5e7 <make_lowercase+0x20>
mov    %al,(%rbx)
add    $0x1,%rbx
movzbl (%rbx),%edx
test   %dl,%dl
jne    5df <make_lowercase+0x18>
jmp    602 <make_lowercase+0x3b>
mov    $0x0,%eax
jmp    605 <make_lowercase+0x3e>
mov    %rdi,%rax
jmp    605 <make_lowercase+0x3e>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
make_lowercase (char *s)
{
  unsigned char *p;
  if (!s)
    return ((void *)0);
  for (p = (unsigned char*) s; *p; p++)
    *p = tolower (*p);
  return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 8
22 8
23 8
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b4 <csv_set_opts+0xf>
mov    %sil,0x2c(%rdi)
mov    $0x0,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
csv_set_opts(struct csv_parser *p, unsigned char options)
{
  if (p == ((void *)0))
    return -1;
  p->options = options;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
__gmpz_limbs_read (mpz_srcptr x)
{
  return ((x)->_mp_d);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x70,%esi
mov    %rdx,%rdi
callq  47 <CDB___db_mutex_free+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___db_mutex_free(dbenv, infop, mutexp)
 DB_ENV *dbenv;
 REGINFO *infop;
 MUTEX *mutexp;
{ if(infop||dbenv){}
 (dbenv) = (((void *)0));
 (infop) = (((void *)0));
 CDB___os_free(mutexp, sizeof(*mutexp));
}
<<<sep_in_sample>>>
1 5
2 8
3 8
4 8
5 9
6 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl 0x38(%rdx),%eax
and    $0xffffffe9,%eax
or     $0xffffff80,%eax
mov    %al,0x38(%rdx)
mov    %rdx,%rcx
mov    0x0(%rip),%rdx        # 5c12 <re_compile_pattern+0x1b>
callq  28f8 <regex_compile>
test   %eax,%eax
je     5c27 <re_compile_pattern+0x30>
cltq   
mov    0x0(,%rax,8),%rax
jmp    5c2c <re_compile_pattern+0x35>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
re_compile_pattern (pattern, length, bufp)
     const char *pattern;
     size_t length;
     struct re_pattern_buffer *bufp;
{
  reg_errcode_t ret;
  bufp->regs_allocated = 0;
  bufp->no_sub = 0;
  bufp->newline_anchor = 1;
  ret = regex_compile (pattern, length, re_syntax_options, bufp);
  if (!ret)
    return ((void *)0);
  return (re_error_msgid[(int) ret]);
}
<<<sep_in_sample>>>
1 5
2 8
3 8
4 9
5 9
6 10
7 10
8 10
9 11
10 11
11 13
12 13
13 13
14 12
15 14
16 14
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rcx
movzwl (%rcx),%eax
test   %r8,%r8
je     1288 <gsl_vector_ushort_max+0x31>
lea    (%rdx,%rdx,1),%rdi
mov    $0x0,%edx
movzwl (%rcx),%esi
cmp    %si,%ax
cmovb  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    1273 <gsl_vector_ushort_max+0x1c>
repz retq 
<<<sep_in_sample>>>
gsl_vector_ushort_max (const gsl_vector_ushort * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned short max = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned short x = v->data[i*stride];
      if (x > max)
        max = x;
    }
  return max;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 9
8 7
9 9
10 9
11 9
12 7
13 7
14 7
15 7
16 14
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 96c <_rl_disable_meta_key+0x7>
je     9a4 <_rl_disable_meta_key+0x3f>
mov    0x0(%rip),%rdi        # 975 <_rl_disable_meta_key+0x10>
test   %rdi,%rdi
je     9a4 <_rl_disable_meta_key+0x3f>
cmpl   $0x0,0x0(%rip)        # 981 <_rl_disable_meta_key+0x1c>
je     9a4 <_rl_disable_meta_key+0x3f>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x1,%esi
callq  996 <_rl_disable_meta_key+0x31>
movl   $0x0,0x0(%rip)        # 9a0 <_rl_disable_meta_key+0x3b>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_rl_disable_meta_key ()
{
  if (term_has_meta && _rl_term_mo && enabled_meta)
    {
      tputs (_rl_term_mo, 1, _rl_output_character_function);
      enabled_meta = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 2
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x5d,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  327 <array_create+0x15>
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    $0xffffffffffffffff,%rdi
mov    %rdi,0x8(%rax)
movl   $0x0,0x10(%rax)
mov    $0x0,%esi
callq  34c <array_create+0x3a>
mov    %rax,0x10(%rax)
mov    %rax,0x18(%rax)
mov    %rax,0x18(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
array_create()
{
 ARRAY *r;
 ARRAY_ELEMENT *head;
 r =(ARRAY *)sh_xmalloc((sizeof(ARRAY)), "array.c", 93);
 r->type = array_indexed;
 r->max_index = -1;
 r->num_elements = 0;
 head = array_create_element(-1, (char *)((void *)0));
 head->prev = head->next = head;
 r->head = head;
 return(r);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 6
8 7
9 7
10 8
11 9
12 9
13 10
14 10
15 11
16 13
17 13
18 13
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2f <color_cap_ne_fct+0xb>
movq   $0x0,0x0(%rip)        # 3a <color_cap_ne_fct+0x16>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
color_cap_ne_fct(void)
{
  sgr_start = "\33[%sm";
  sgr_end = "\33[m";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r11
cmp    (%rdi),%r11
je     1ded <gsl_vector_int_mul+0x2e>
mov    $0x13,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1de6 <gsl_vector_int_mul+0x27>
mov    $0x13,%eax
jmp    1e44 <gsl_vector_int_mul+0x85>
mov    0x8(%rdi),%rbp
mov    0x8(%rsi),%rbx
test   %r11,%r11
je     1e38 <gsl_vector_int_mul+0x79>
shl    $0x2,%rbp
shl    $0x2,%rbx
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r10
mov    (%r8),%r9d
imul   (%r10,%rcx,1),%r9d
mov    %r9d,(%r8)
add    $0x1,%rax
add    %rbp,%rdx
add    %rbx,%rcx
cmp    %r11,%rax
jne    1e11 <gsl_vector_int_mul+0x52>
jmp    1e3f <gsl_vector_int_mul+0x80>
mov    $0x0,%eax
jmp    1e44 <gsl_vector_int_mul+0x85>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_int_mul (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 77, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] *= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 10
15 11
16 13
17 13
18 15
19 15
20 15
21 15
22 13
23 15
24 15
25 15
26 15
27 15
28 15
29 13
30 13
31 13
32 13
33 13
34 13
35 17
36 17
37 17
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
lea    0x1(%rdi),%rax
lea    0x2(%rdi),%rdx
cmpb   $0x62,0x1(%rdi)
cmovne %rax,%rdx
movzbl (%rdi),%eax
cmp    $0x72,%al
je     335 <str2mode+0x21>
cmp    $0x77,%al
je     348 <str2mode+0x34>
cmp    $0x61,%al
jne    368 <str2mode+0x54>
jmp    359 <str2mode+0x45>
movzbl (%rdx),%eax
cmp    $0x77,%al
je     38c <str2mode+0x78>
cmp    $0x2b,%al
xchg   %ax,%ax
je     38c <str2mode+0x78>
mov    $0x0,%eax
retq   
movzbl (%rdx),%eax
cmp    $0x72,%al
je     392 <str2mode+0x7e>
cmp    $0x2b,%al
je     392 <str2mode+0x7e>
mov    $0x241,%eax
retq   
cmpb   $0x2b,(%rdx)
sete   %al
movzbl %al,%eax
add    $0x441,%eax
retq   
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x598,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  385 <str2mode+0x71>
mov    $0x0,%eax
jmp    398 <str2mode+0x84>
mov    $0x2,%eax
retq   
mov    $0x242,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
str2mode(const char *mode)
{
 int ret;
 const char *second = & mode[1];
 if (*second == 'b')
  second++;
 switch(mode[0]) {
 case 'r':
  ret = 00;
  if (*second == '+' || *second == 'w')
   ret = 02;
  break;
 case 'w':
  ret = 01|0100|01000;
  if (*second == '+' || *second == 'r')
   ret = 02|0100|01000;
  break;
 case 'a':
  ret = 01|02000|0100;
  if (*second == '+')
   ret = 02|02000|0100;
  break;
 default:
  ret = 0;
  r_fatal("internal error line %d, file: %s", 1432, "io.c");
 }
 if (strchr(mode, 'b') != ((void *)0))
  ret |= 0;
 return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 10
14 10
15 10
16 10
17 10
18 10
19 9
20 9
21 15
22 15
23 15
24 15
25 15
26 14
27 14
28 19
29 19
30 19
31 19
32 30
33 2
34 25
35 25
36 25
37 25
38 25
39 24
40 24
41 11
42 11
43 16
44 16
45 30
46 30
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <__rprintfilline+0xb>
test   %rax,%rax
je     41 <__rprintfilline+0x41>
mov    0x0(%rip),%rcx        # 17 <__rprintfilline+0x17>
add    $0x18,%rax
cmp    %rcx,0x10(%rax)
jle    17 <__rprintfilline+0x17>
add    -0x10(%rax),%rcx
mov    -0x18(%rax),%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 35 <__rprintfilline+0x35>
mov    $0x0,%eax
callq  3f <__rprintfilline+0x3f>
jmp    5c <__rprintfilline+0x5c>
mov    0x0(%rip),%rcx        # 48 <__rprintfilline+0x48>
mov    $0xc,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  5c <__rprintfilline+0x5c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rprintfilline (void)
{
  __map *mapindeks = __curent_map;
  if (__curent_map)
    {
      while ((++mapindeks)->fromline <= __cline);
      mapindeks--;
      fprintf (stderr, "\n\"%s\", line %ld: "
        ,mapindeks->fil, __cline + mapindeks->line);
    }
  else
    fprintf (stderr, "\n\"\", line : ");
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 6
7 6
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 13
22 13
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rdi
mov    %rdx,%r12
cmp    $0x1,%rcx
je     652 <gsl_block_complex_raw_fread+0x36>
shl    $0x4,%rcx
mov    %rcx,%r14
mov    %rsi,%rbx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %rdx,%rdx
je     6d8 <gsl_block_complex_raw_fread+0xbc>
jmp    68c <gsl_block_complex_raw_fread+0x70>
mov    %r13,%rcx
mov    $0x10,%esi
callq  65f <gsl_block_complex_raw_fread+0x43>
mov    %rax,%rdx
mov    $0x0,%eax
cmp    %r12,%rdx
je     6d8 <gsl_block_complex_raw_fread+0xbc>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  685 <gsl_block_complex_raw_fread+0x69>
mov    $0x5,%eax
jmp    6d8 <gsl_block_complex_raw_fread+0xbc>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x10,%esi
mov    %rbx,%rdi
callq  6a1 <gsl_block_complex_raw_fread+0x85>
cmp    $0x1,%rax
je     6c7 <gsl_block_complex_raw_fread+0xab>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6c0 <gsl_block_complex_raw_fread+0xa4>
mov    $0x5,%eax
jmp    6d8 <gsl_block_complex_raw_fread+0xbc>
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
jne    68c <gsl_block_complex_raw_fread+0x70>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_block_complex_raw_fread (FILE * stream, double * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 2 * sizeof (double), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 2 * i * stride,
                               2 * sizeof (double), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 17
12 17
13 17
14 17
15 25
16 15
17 15
18 15
19 6
20 6
21 6
22 6
23 25
24 7
25 7
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 17
34 17
35 17
36 17
37 17
38 19
39 19
40 21
41 21
42 21
43 21
44 21
45 21
46 21
47 15
48 15
49 15
50 15
51 25
52 26
53 26
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 8 <usage+0x8>
mov    $0x0,%edi
callq  12 <usage+0x12>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 1f <usage+0x1f>
mov    $0x0,%eax
callq  29 <usage+0x29>
mov    $0x1,%edi
callq  33 <get_file_index>
<<<sep_in_sample>>>
usage (void)
{
  fprintf (stderr, gettext ("Try `%s --help' for more information.\n"),
    program_name);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
testb  $0x2,0x2d1(%rdi)
jne    9ae <update_mk82+0x94>
mov    (%rdi),%eax
movslq %eax,%rdx
cmpl   $0x0,0x0(,%rdx,4)
je     9ae <update_mk82+0x94>
cmpl   $0x0,0x0(,%rdx,4)
jle    9ae <update_mk82+0x94>
mov    $0x0,%esi
callq  94e <update_mk82+0x34>
test   %eax,%eax
jns    96f <update_mk82+0x55>
mov    0x0(%rip),%rcx        # 959 <update_mk82+0x3f>
mov    $0x17,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  96d <update_mk82+0x53>
jmp    9a0 <update_mk82+0x86>
cmpl   $0x0,0x0(%rip)        # 976 <update_mk82+0x5c>
jne    996 <update_mk82+0x7c>
movslq %eax,%rdx
shl    $0x5,%rdx
movq   $0x0,0x870(%rbx,%rdx,1)
movslq (%rbx),%rdx
subl   $0x1,0x0(,%rdx,4)
mov    %eax,%esi
mov    %rbx,%rdi
callq  9a0 <update_mk82+0x86>
movslq (%rbx),%rax
movl   $0x0,0x0(,%rax,4)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
update_mk82(craft * c)
{
 int i;
 if ((c->flags & (1<<9)) == 0) {
  if (hasFired[c->pIndex] && count[c->pIndex] > 0) {
   i = readyStation(c, "mk82");
   if (i < 0) {
    fprintf(stderr, "Oops. Can't find Mk-82\n");
   }
   else {
    if (arcadeMode == 0) {
     c->station[i].type = "";
     count[c->pIndex]--;
    }
    dropOrdinance (c, i);
   }
   hasFired[c->pIndex] = 0;
  }
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 12
24 12
25 12
26 13
27 13
28 15
29 15
30 15
31 17
32 17
33 21
34 21
35 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     402 <meta_free+0x32>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     3f8 <meta_free+0x28>
callq  3e8 <meta_free+0x18>
movq   $0x0,0x18(%rbx)
movq   $0x0,0x8(%rbx)
add    $0x28,%rbx
cmpq   $0x0,(%rbx)
jne    3da <meta_free+0xa>
pop    %rbx
retq   
<<<sep_in_sample>>>
meta_free (struct metadef *def)
{
  for (; def->kw; def++)
    {
      if (def->storage)
 {
   free (def->storage);
   def->value = def->storage = ((void *)0);
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 7
9 8
10 8
11 3
12 3
13 3
14 11
15 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     425 <freelist+0x1d>
add    $0x8,%rbx
callq  41d <freelist+0x15>
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    414 <freelist+0xc>
pop    %rbx
retq   
<<<sep_in_sample>>>
freelist (char **cpp)
{
  while (*cpp)
    free (*cpp++);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 3
9 3
10 3
11 5
12 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %esi,%r14d
movswq 0x14(%rdi),%rax
lea    0x18(,%rax,8),%rax
lea    (%rdi,%rax,1),%r12
movslq 0x10(%rdi),%rbx
sub    %rax,%rbx
mov    %ebx,%edi
callq  2a <__rcopytextarrtoc+0x2a>
mov    %rax,%rbp
shr    $0x3,%rbx
mov    %rbx,%r13
test   %r14b,%r14b
jne    45 <__rcopytextarrtoc+0x45>
mov    $0x0,%edx
test   %rbx,%rbx
jg     68 <__rcopytextarrtoc+0x68>
jmp    8b <__rcopytextarrtoc+0x8b>
test   %rbx,%rbx
jle    8b <__rcopytextarrtoc+0x8b>
mov    $0x0,%ebx
mov    (%r12,%rbx,8),%rdi
callq  58 <__rcopytextarrtoc+0x58>
mov    %rax,0x0(%rbp,%rbx,8)
add    $0x1,%rbx
cmp    %rbx,%r13
jne    4f <__rcopytextarrtoc+0x4f>
jmp    8b <__rcopytextarrtoc+0x8b>
mov    (%r12,%rdx,8),%rcx
movzwl 0xc(%rcx),%eax
sub    $0x1,%eax
cltq   
mov    (%rcx),%rcx
lea    0x18(%rcx,%rax,1),%rax
mov    %rax,0x0(%rbp,%rdx,8)
add    $0x1,%rdx
cmp    %rdx,%r13
jne    68 <__rcopytextarrtoc+0x68>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
__rcopytextarrtoc (__arrp p, char byvalue)
{
  long sizeofhode,
    size,
    i;
  __txtvp *p1x;
  char **p2x;
  sizeofhode = sizeof (__ah) + sizeof (__arrlimit) * p->h.dim;
  p1x = (__txtvp *) ((long) p + sizeofhode);
  p2x = (char **) xmalloc ((unsigned) (size = p->h.size - sizeofhode));
  size /= sizeof (__txtvp);
  if (byvalue)
    for (i = 0; i < size; i++)
      p2x[i] = __rcopytexttoc (p1x[i]);
  else
    for (i = 0; i < size; i++)
      p2x[i] = &p1x[i]->obj->string[p1x[i]->start - 1];
  return (p2x);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 8
8 8
9 9
10 10
11 10
12 10
13 10
14 10
15 11
16 11
17 12
18 12
19 16
20 16
21 16
22 16
23 13
24 13
25 13
26 14
27 14
28 14
29 13
30 13
31 13
32 13
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 16
41 16
42 16
43 19
44 19
45 19
46 19
47 19
48 19
49 19
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    %rsi,%r14
mov    %rdx,%r15
mov    (%rdi),%r12
mov    0x8(%rdi),%r13
mov    0x10(%rdi),%rbp
fldt   0x0(%rbp)
fld    %st(0)
fstpt  0x20(%rsp)
test   %r12,%r12
jne    1b4 <gsl_vector_long_double_minmax+0x98>
fstpt  0x10(%rsp)
jmp    1a4 <gsl_vector_long_double_minmax+0x88>
fldt   0x0(%rbp)
fld    %st(0)
fstpt  0x10(%rsp)
fldt   0x20(%rsp)
fucomi %st(1),%st
fcmovnbe %st(1),%st
fstp   %st(1)
fstpt  0x20(%rsp)
add    %r13,%rbp
fldt   0x10(%rsp)
fldt   0x30(%rsp)
fxch   %st(1)
fucomi %st(1),%st
fxch   %st(1)
fcmovnbe %st(1),%st
fstpt  0x30(%rsp)
fstpt  (%rsp)
callq  185 <gsl_vector_long_double_minmax+0x69>
test   %eax,%eax
jne    19c <gsl_vector_long_double_minmax+0x80>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    14f <gsl_vector_long_double_minmax+0x33>
fldt   0x30(%rsp)
fstpt  0x10(%rsp)
jmp    1a4 <gsl_vector_long_double_minmax+0x88>
fldt   0x10(%rsp)
fstpt  0x20(%rsp)
fldt   0x20(%rsp)
fstpt  (%r14)
fldt   0x10(%rsp)
fstpt  (%r15)
jmp    1d2 <gsl_vector_long_double_minmax+0xb6>
fstp   %st(0)
shl    $0x4,%r13
add    %r13,%rbp
fldt   0x20(%rsp)
fld    %st(0)
fstpt  0x30(%rsp)
fstpt  0x10(%rsp)
mov    $0x0,%ebx
jmp    169 <gsl_vector_long_double_minmax+0x4d>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_vector_long_double_minmax (const gsl_vector_long_double * v,
                             long double * min_out,
                             long double * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  long double max = v->data[0 * stride];
  long double min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      long double x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
      if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
        {
          min = x;
          max = x;
          break;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 7
14 7
15 7
16 10
17 10
18 7
19 7
20 12
21 12
22 12
23 13
24 13
25 12
26 12
27 12
28 12
29 17
30 17
31 17
32 17
33 17
34 17
35 17
36 21
37 21
38 21
39 21
40 10
41 10
42 10
43 10
44 10
45 10
46 10
47 10
48 28
49 28
50 29
51 29
52 29
53 29
54 29
55 29
56 7
57 7
58 7
59 12
60 10
61 10
62 30
63 30
64 30
65 30
66 30
67 30
68 30
69 30
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x3a0,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x398(%rsp)
xor    %eax,%eax
cmp    $0x1,%edi
setg   %r12b
movzbl %r12b,%r12d
mov    $0xffffffffffffffff,%rbp
mov    $0x0,%ebx
jmp    b3 <main+0xb3>
mov    $0x0,%esi
lea    0x10(%rsp),%rdi
callq  46 <main+0x46>
test   %rax,%rax
je     4e <main+0x4e>
movb   $0x0,(%rax)
lea    0x10(%rsp),%rdi
mov    %rbp,%rcx
mov    %ebx,%eax
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x381,%rcx
jbe    82 <main+0x82>
lea    0x10(%rsp),%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 7b <main+0x7b>
callq  80 <main+0x80>
jmp    b3 <main+0xb3>
mov    %r12d,%ecx
lea    0xc(%rsp),%rdx
mov    $0x4,%esi
lea    0x10(%rsp),%rdi
callq  99 <main+0x99>
lea    0x10(%rsp),%rcx
mov    %eax,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # ac <main+0xac>
mov    %ebx,%eax
callq  b3 <main+0xb3>
mov    0x0(%rip),%rdx        # ba <main+0xba>
mov    $0x383,%esi
lea    0x10(%rsp),%rdi
callq  c9 <main+0xc9>
test   %rax,%rax
jne    37 <main+0x37>
mov    $0x0,%edi
callq  dc <swlex_errorcode+0xbc>
<<<sep_in_sample>>>
main (int argc, char ** argv)
{
  int ret;
  int do_long_link;
  int is_dir = 0;
  char line[900];
  char * nl;
  if (argc > 1) is_dir = 1;
  while (fgets (line, 900 - 1, stdin) != (char *) (((void *)0)))
    {
      nl = strpbrk(line, "\n\r");
      if (nl) *nl = '\0';
      if (strlen (line) >= 900 - 2)
 {
   fprintf (stderr, "filesize: line too long : %s\n", line);
 }
      else
 {
  ret = taru_is_tar_filename_too_long(line, (1 << 2) , &do_long_link, is_dir);
    fprintf(stdout, "%d %s\n", ret, line);
 }
    }
  exit (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 8
9 8
10 8
11 13
12 13
13 13
14 11
15 11
16 11
17 12
18 12
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 15
29 15
30 15
31 15
32 15
33 19
34 19
35 19
36 19
37 19
38 20
39 20
40 20
41 20
42 20
43 20
44 9
45 9
46 9
47 9
48 9
49 9
50 23
51 23
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r13d
mov    %rsi,%rbp
mov    %edx,%r12d
mov    %rcx,%rbx
test   %rcx,%rcx
je     2b1 <i_set_opta+0x64>
mov    $0x0,%esi
mov    %rcx,%rdi
callq  275 <i_set_opta+0x28>
test   %rax,%rax
je     2ca <i_set_opta+0x7d>
mov    %r12d,%eax
imul   $0x28,%rax,%rax
mov    0x8(%rbp,%rax,1),%rbx
callq  28b <i_set_opta+0x3e>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 29d <i_set_opta+0x50>
mov    $0x0,%eax
callq  2a7 <i_set_opta+0x5a>
mov    $0x1,%edi
callq  2b1 <i_set_opta+0x64>
mov    %edx,%r12d
lea    (%r12,%r12,4),%rax
lea    (%rsi,%rax,8),%rax
mov    %dil,0x2(%rax)
movq   $0x0,0x18(%rax)
jmp    2e6 <i_set_opta+0x99>
mov    %r12d,%edx
lea    (%rdx,%rdx,4),%rax
lea    0x0(%rbp,%rax,8),%rbp
mov    %r13b,0x2(%rbp)
mov    %rbx,%rdi
callq  2e2 <i_set_opta+0x95>
mov    %rax,0x18(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
i_set_opta(int optsetflag, struct extendedOptions * opta,
   enum eOpts nopt, char * value)
{
 if (value && strpbrk(value, "'\"|*?;&<>`$[]")) {
  fprintf(stderr,
  "%s: error: shell meta-characters detected for %s option\n",
  swlib_utilname_get(), opta[nopt].optionNameM);
  exit(1);
 }
 opta[nopt].option_setM = (char)optsetflag;
 if (value) {
  opta[nopt].valueM = strdup(value);
 } else {
  opta[nopt].valueM = value;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 7
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 8
28 8
29 10
30 10
31 10
32 10
33 14
34 14
35 10
36 10
37 10
38 10
39 12
40 12
41 12
42 16
43 16
44 16
45 16
46 16
47 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%edi
callq  91c <gen_href_begin_simple+0x27>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gen_href_begin_simple(const char *file)
{
 return gen_href_begin_with_title_target(((void *)0), file, ((void *)0), ((void *)0), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 1cd <make_history_line_current+0xa>
mov    $0x0,%esi
mov    (%rdi),%rdi
callq  1da <make_history_line_current+0x17>
mov    $0x1,%edi
callq  1e4 <make_history_line_current+0x21>
cmpl   $0x0,0x0(%rip)        # 1eb <make_history_line_current+0x28>
jne    1f2 <make_history_line_current+0x2f>
callq  1f2 <make_history_line_current+0x2f>
mov    0x0(%rip),%rdi        # 1f9 <make_history_line_current+0x36>
test   %rdi,%rdi
je     203 <make_history_line_current+0x40>
callq  203 <make_history_line_current+0x40>
movq   $0x0,0x0(%rip)        # 20e <make_history_line_current+0x4b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_history_line_current (entry)
     HIST_ENTRY *entry;
{
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
  if (rl_editing_mode == 0)
    rl_free_undo_list ();
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 11
17 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  123 <rl_free_keymap+0x9>
mov    %rbx,%rdi
callq  12b <rl_free_keymap+0x11>
pop    %rbx
retq   
<<<sep_in_sample>>>
rl_free_keymap (map)
     Keymap map;
{
  rl_discard_keymap (map);
  xfree ((char *)map);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdx,%rdx
jne    128a <gsl_vector_long_double_const_view_array+0x47>
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  1262 <gsl_vector_long_double_const_view_array+0x1f>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    12a8 <gsl_vector_long_double_const_view_array+0x65>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_long_double_const_view_array (const long double * base, size_t n)
{
  _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = (long double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 10
11 10
12 10
13 10
14 10
15 10
16 21
17 21
18 21
19 21
20 21
21 23
22 23
23 23
<<<sep_out_sample>>>
mov    $0x4,%eax
movsd  (%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0x20(%rdi),%xmm0
movsd  %xmm0,0x8(%rsi)
movsd  0x40(%rdi),%xmm0
movsd  %xmm0,0x10(%rsi)
movsd  0x60(%rdi),%xmm0
movsd  %xmm0,0x18(%rsi)
add    $0x8,%rdi
add    $0x20,%rsi
sub    $0x1,%eax
jne    5 <transpose+0x5>
repz retq 
<<<sep_in_sample>>>
transpose(VMatrix * m, VMatrix * r)
{
 int i, j;
 for (i = 0; i < 4; ++i)
  for (j = 0; j < 4; ++j)
   r->m[i][j] = m->m[j][i];
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 4
13 4
14 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edx,%ebx
cmpb   $0x0,0x0(%rip)        # ff6 <prompt_yes_no+0xd>
je     1038 <prompt_yes_no+0x4f>
mov    %esi,%ebp
mov    %rcx,%r12
callq  1002 <prompt_yes_no+0x19>
mov    %r12,%rsi
mov    %rax,%rdi
callq  100d <prompt_yes_no+0x24>
mov    $0x0,%edi
callq  *0x0(%rip)        # 1018 <prompt_yes_no+0x2f>
test   %rax,%rax
jne    1027 <prompt_yes_no+0x3e>
mov    $0x1,%edi
callq  1027 <prompt_yes_no+0x3e>
cmp    %bpl,(%rax)
sete   %bl
movzbl %bl,%ebx
mov    %rax,%rdi
callq  1038 <prompt_yes_no+0x4f>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
prompt_yes_no(const char *mesg, char res_true, int res_default, FILE *fp)
{
 char *in_str;
 int ret = res_default;
 if (input_from_tty) {
  fprintf(fp, "%s", gettext(mesg));
  in_str = read_a_line(((void *)0));
  if (in_str == ((void *)0))
   exit(1);
  ret = (*in_str == res_true);
  free(in_str);
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 14
25 14
26 14
27 14
28 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     2ba <swicat_sq_delete+0x11>
callq  2ba <swicat_sq_delete+0x11>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2c8 <swicat_sq_delete+0x1f>
callq  2c8 <swicat_sq_delete+0x1f>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     2d6 <swicat_sq_delete+0x2d>
callq  2d6 <swicat_sq_delete+0x2d>
mov    %rbx,%rdi
callq  2de <swicat_sq_delete+0x35>
pop    %rbx
nop
retq   
<<<sep_in_sample>>>
swicat_sq_delete(SWICAT_SQ * sq)
{
 if (sq->lineM != ((void *)0))
  free(sq->lineM);
 if (sq->swspec_stringM != ((void *)0))
  free(sq->swspec_stringM);
 if (sq->swspecM != ((void *)0))
  swverid_close(sq->swspecM);
 free(sq);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 8
15 9
16 9
17 10
18 10
19 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1f3 <compute_uint_variance>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_uint_variance_with_fixed_mean (const unsigned int data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_uint_variance (data, stride, n, mean);
  return variance;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x0,0x0(%rip)        # 90 <dfawarn+0xb>
jne    ad <dfawarn+0x28>
mov    $0x0,%edi
callq  9c <dfawarn+0x17>
cmp    $0x1,%rax
sbb    %eax,%eax
not    %eax
add    $0x2,%eax
mov    %eax,0x0(%rip)        # ad <dfawarn+0x28>
cmpl   $0x2,0x0(%rip)        # b4 <dfawarn+0x2f>
jne    be <dfawarn+0x39>
mov    %rbx,%rdi
callq  be <dfawarn+0x39>
pop    %rbx
retq   
<<<sep_in_sample>>>
dfawarn (char const *mesg)
{
  static enum { DW_NONE = 0, DW_POSIX, DW_GNU } mode;
  if (mode == DW_NONE)
    mode = (getenv ("POSIXLY_CORRECT") ? DW_POSIX : DW_GNU);
  if (mode == DW_GNU)
    dfaerror (mesg);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1d11 <info_handle_pointer>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_prev_node (WINDOW *window, int count)
{
  info_handle_pointer ("Prev", window);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x28(%rdi),%rbx
cmpq   $0x0,0x8(%rbx)
jne    2f <jpeg_getc+0x2f>
callq  *0x18(%rbx)
test   %eax,%eax
jne    2f <jpeg_getc+0x2f>
mov    0x0(%rbp),%rax
movl   $0x18,0x28(%rax)
mov    0x0(%rbp),%rax
mov    %rbp,%rdi
callq  *(%rax)
subq   $0x1,0x8(%rbx)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movzbl (%rax),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
jpeg_getc (j_decompress_ptr cinfo)
{
  struct jpeg_source_mgr * datasrc = cinfo->src;
  if (datasrc->bytes_in_buffer == 0) {
    if (! (*datasrc->fill_input_buffer) (cinfo))
      ((cinfo)->err->msg_code = (JERR_CANT_SUSPEND), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
  }
  datasrc->bytes_in_buffer--;
  return (*datasrc->next_input_byte++);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 8
17 9
18 9
19 9
20 9
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2f <decrement_proc_max+0x6>
cmp    $0x1,%eax
jle    43 <decrement_proc_max+0x1a>
mov    0x0(%rip),%eax        # 3a <decrement_proc_max+0x11>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 43 <decrement_proc_max+0x1a>
repz retq 
<<<sep_in_sample>>>
decrement_proc_max (int ignore)
{
        (void) ignore;
 if (proc_max > 1)
  proc_max--;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    (%rdi),%edx
mov    $0x0,%eax
cmp    (%rsi),%edx
jne    267 <optloc_eq+0x35>
cmp    $0x1,%edx
je     25d <optloc_eq+0x2b>
sub    $0x8,%rsp
mov    0x8(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  253 <optloc_eq+0x21>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    263 <optloc_eq+0x31>
mov    $0x1,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
optloc_eq (struct option_locus *a, struct option_locus *b)
{
  if (a->source != b->source)
    return 0;
  if (a->source == OPTS_COMMAND_LINE)
    return 1;
  return strcmp (a->name, b->name) == 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 5
6 5
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 6
16 6
17 8
18 8
<<<sep_out_sample>>>
test   %rdx,%rdx
je     ab <compute_variance+0x50>
shl    $0x3,%rsi
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 71 <compute_variance+0x16>
movsd  (%rdi),%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fmul   %st(0),%st
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    9b <compute_variance+0x40>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    71 <compute_variance+0x16>
fstp   %st(0)
jmp    ad <compute_variance+0x52>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
compute_variance (const double data[], const size_t stride, const size_t n, const double mean)
{
  long double variance = 0 ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double delta = (data[i * stride] - mean);
      variance += (delta * delta - variance) / (i + 1);
    }
  return variance ;
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 5
5 3
6 8
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 5
23 5
24 5
25 5
26 3
27 10
28 10
29 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
jmp    38 <main+0x38>
mov    0x18(%rax),%r9
mov    0x14(%rax),%r8d
mov    0x10(%rax),%ecx
mov    0x8(%rax),%rdx
mov    0x28(%rax),%rsi
mov    %rsi,0x8(%rsp)
mov    0x20(%rax),%rsi
mov    %rsi,(%rsp)
mov    (%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  38 <main+0x38>
callq  3d <main+0x3d>
test   %rax,%rax
jne    6 <main+0x6>
callq  47 <main+0x47>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
main(int argc, char **argv)
{
    struct passwd *p;
    while ((p = getpwent()) != ((void *)0))
        printf("%s:%s:%ld:%ld:%s:%s:%s\n",
            p->pw_name, p->pw_passwd, (long) p->pw_uid,
            (long) p->pw_gid, p->pw_gecos, p->pw_dir, p->pw_shell);
    endpwent();
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 4
16 4
17 4
18 8
19 10
20 10
21 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     28 <osip_list_size+0x8>
mov    (%rdi),%eax
retq   
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
osip_list_size (const osip_list_t * li)
{
  if (li == ((void *)0))
    return -2;
  return li->nb_elt;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  277 <_body_stream_size+0x9>
mov    %rax,%rdi
callq  27f <_body_stream_size+0x11>
mov    %rax,%rdi
callq  287 <_body_stream_size+0x19>
test   %rbx,%rbx
je     297 <_body_stream_size+0x29>
mov    0x18(%rax),%rdx
sub    0x10(%rax),%rdx
mov    %rdx,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_body_stream_size (mu_stream_t stream, mu_off_t *psize)
{
  mu_body_t body = mu_stream_get_owner (stream);
  mu_message_t msg = mu_body_get_owner (body);
  struct _mu_rfc822_message *mp = mu_message_get_owner (msg);
  if (psize)
    *psize = mp->body_end - mp->body_start;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 9
14 9
15 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    0x8(%rsi),%rdx
cmp    %rdx,(%rsi)
cmovbe (%rsi),%rdx
mov    %rdx,(%rax)
mov    %r8,0x8(%rax)
mov    %rdi,0x10(%rax)
mov    %rcx,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_diagonal (gsl_matrix_complex_float * m)
{
  _gsl_vector_complex_float_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_complex_float v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    0x40(%rdi),%rax
cmp    %rax,0x38(%rdi)
jb     de <argp_fmtstream_putc+0x23>
mov    $0x1,%esi
callq  da <argp_fmtstream_putc+0x1f>
test   %eax,%eax
je     f3 <argp_fmtstream_putc+0x38>
mov    0x38(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x38(%rbx)
mov    %bpl,(%rax)
movsbl %bpl,%eax
jmp    f8 <argp_fmtstream_putc+0x3d>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)
{
  if (__fs->p < __fs->end || _argp_fmtstream_ensure (__fs, 1))
    return *__fs->p++ = __ch;
  else
    return (-1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
callq  b3e <urlPath+0x15>
mov    %eax,%ebp
cmp    $0x4,%eax
ja     bcd <urlPath+0xa4>
mov    %eax,%eax
jmpq   *0x0(,%rax,8)
lea    0x6(%rbx),%r13
mov    $0x2f,%esi
mov    %r13,%rdi
callq  b63 <urlPath+0x3a>
mov    %rax,%rbx
test   %rax,%rax
jne    bcd <urlPath+0xa4>
mov    %r13,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r13,%rcx,1),%rbx
jmp    bcd <urlPath+0xa4>
lea    0x7(%rbx),%r13
mov    $0x2f,%esi
mov    %r13,%rdi
callq  b97 <urlPath+0x6e>
mov    %rax,%rbx
test   %rax,%rax
jne    bcd <urlPath+0xa4>
mov    %r13,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r13,%rcx,1),%rbx
jmp    bcd <urlPath+0xa4>
test   %rbx,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
jmp    bcd <urlPath+0xa4>
mov    $0x0,%ebx
test   %r12,%r12
je     bd6 <urlPath+0xad>
mov    %rbx,(%r12)
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
urlPath(const char * url, const char ** pathp)
{
    const char *path;
    int urltype;
    path = url;
    urltype = urlIsURL(url);
    switch (urltype) {
    case URL_IS_FTP:
 url += sizeof("ftp://") - 1;
 path = strchr(url, '/');
 if (path == ((void *)0)) path = url + strlen(url);
 break;
    case URL_IS_HTTP:
    case URL_IS_PATH:
 url += sizeof("file://") - 1;
 path = strchr(url, '/');
 if (path == ((void *)0)) path = url + strlen(url);
 break;
    case URL_IS_UNKNOWN:
 if (path == ((void *)0)) path = "";
 break;
    case URL_IS_DASH:
 path = "";
 break;
    }
    if (pathp)
 *pathp = path;
    return urltype;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 7
11 7
12 7
13 7
14 9
15 10
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 15
29 16
30 16
31 16
32 16
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
41 17
42 20
43 20
44 20
45 20
46 23
47 26
48 26
49 27
50 29
51 29
52 29
53 29
54 29
55 29
56 29
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x0(%rip),%rdi        # 87c <TerminalWindowSize+0x13>
callq  881 <TerminalWindowSize+0x18>
mov    %rsp,%rdx
mov    $0x5413,%esi
mov    %eax,%edi
mov    $0x0,%eax
callq  895 <TerminalWindowSize+0x2c>
test   %eax,%eax
js     8b0 <TerminalWindowSize+0x47>
movzwl (%rsp),%eax
mov    %rax,0x0(%rbp)
movzwl 0x2(%rsp),%eax
mov    %rax,(%rbx)
mov    $0x1,%eax
jmp    8b5 <TerminalWindowSize+0x4c>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
TerminalWindowSize (long *rows, long *cols)
{
  struct winsize ws;
  if (rpl_ioctl (fileno (stdin), 0x5413, (char *) &ws) >= 0)
    {
      *rows = ws.ws_row;
      *cols = ws.ws_col;
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 7
18 7
19 8
20 8
21 10
22 11
23 11
24 11
25 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # fe4 <dispose_exec_redirects+0x7>
test   %rdi,%rdi
je     1001 <dispose_exec_redirects+0x24>
sub    $0x8,%rsp
callq  ff2 <dispose_exec_redirects+0x15>
movq   $0x0,0x0(%rip)        # ffd <dispose_exec_redirects+0x20>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dispose_exec_redirects ()
{
  if (exec_redirection_undo_list)
    {
      dispose_redirects (exec_redirection_undo_list);
      exec_redirection_undo_list = (REDIRECT *)((void *)0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 6
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
test   %rdi,%rdi
jne    f7 <xrealloc+0x13>
mov    %rsi,%rdi
callq  f5 <xrealloc+0x11>
jmp    10c <xrealloc+0x28>
callq  fc <xrealloc+0x18>
mov    %rax,%rdx
test   %rdx,%rdx
jne    10c <xrealloc+0x28>
mov    %rbx,%rdi
callq  30 <fixup_null_alloc>
pop    %rbx
retq   
<<<sep_in_sample>>>
xrealloc (void *p, size_t n)
{
  if (p == ((void *)0))
    return xmalloc (n);
  p = realloc (p, n);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 9
15 9
<<<sep_out_sample>>>
movq   $0x0,(%rsi)
movl   $0x0,(%rdx)
test   %rdi,%rdi
je     8ef <osip_transaction_get_destination+0x5c>
mov    0x88(%rdi),%rax
test   %rax,%rax
je     8ca <osip_transaction_get_destination+0x37>
mov    0x48(%rax),%rax
mov    %rax,(%rsi)
mov    0x88(%rdi),%rax
mov    0x50(%rax),%eax
mov    %eax,(%rdx)
mov    $0x0,%eax
retq   
mov    0x98(%rdi),%rax
test   %rax,%rax
je     8f5 <osip_transaction_get_destination+0x62>
mov    0x48(%rax),%rax
mov    %rax,(%rsi)
mov    0x98(%rdi),%rax
mov    0x50(%rax),%eax
mov    %eax,(%rdx)
mov    $0x0,%eax
retq   
mov    $0xfffffffe,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
osip_transaction_get_destination (osip_transaction_t * transaction, char **ip, int *port)
{
  *ip = ((void *)0);
  *port = 0;
  if (transaction == ((void *)0))
    return -2;
  if (transaction->ict_context != ((void *)0)) {
    *ip = transaction->ict_context->destination;
    *port = transaction->ict_context->port;
    return 0;
  }
  else if (transaction->nict_context != ((void *)0)) {
    *ip = transaction->nict_context->destination;
    *port = transaction->nict_context->port;
    return 0;
  }
  return -1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 7
8 8
9 8
10 9
11 9
12 9
13 10
14 10
15 12
16 12
17 12
18 13
19 13
20 14
21 14
22 14
23 15
24 15
25 6
26 6
27 17
28 18
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdx
mov    0x8(%rsi),%rdi
lea    (%rdi,%rdi,1),%rcx
mov    (%rsi),%rsi
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_const_real (const gsl_vector_complex_float * v)
{
  gsl_vector_float s = {0, 0, 0, 0, 0};
  s.data = v->data;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     6162 <gsl_matrix_uint_const_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  613a <gsl_matrix_uint_const_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    6194 <gsl_matrix_uint_const_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x2,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_uint_const_row (const gsl_matrix_uint * m, const size_t i)
{
  _gsl_vector_uint_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%r12
mov    %rcx,%rbp
mov    %edi,%esi
mov    %rbx,%rdi
callq  1334 <_cb_socket_type+0x1d>
mov    $0x1,%r8d
test   %eax,%eax
jne    1390 <_cb_socket_type+0x79>
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  134e <_cb_socket_type+0x37>
mov    %eax,%r13d
mov    $0x1,%r8d
test   %eax,%eax
jne    1390 <_cb_socket_type+0x79>
mov    0x8(%rbp),%rdi
mov    %r12,%rsi
callq  1367 <_cb_socket_type+0x50>
mov    %eax,%r8d
test   %eax,%eax
je     1390 <_cb_socket_type+0x79>
mov    $0x0,%edi
callq  1378 <_cb_socket_type+0x61>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  138d <_cb_socket_type+0x76>
mov    %r13d,%r8d
mov    %r8d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_cb_socket_type (enum grecs_callback_command cmd,
   grecs_locus_t *locus,
   void *varptr, grecs_value_t *value, void *cb_data)
{
  if (assert_scalar_stmt (locus, cmd)
      || assert_grecs_value_type (locus, value, 0))
    return 1;
  if (str_to_socket_type (value->v.string, varptr))
    grecs_error (locus, 0, gettext("bad socket type"));
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 7
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 7
21 6
22 6
23 8
24 8
25 8
26 8
27 8
28 8
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 10
37 11
38 11
39 11
40 11
41 11
42 11
43 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 15b4 <yyget_leng+0x6>
retq   
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%r12
mov    %rcx,%r13
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rbp
test   %rax,%rax
jne    9c2 <tag_of_reference+0x24>
mov    0x30(%rsi),%rax
mov    (%rax),%rax
test   %rbp,%rbp
je     9d6 <tag_of_reference+0x38>
cmpb   $0x0,0x0(%rbp)
mov    $0x0,%edx
cmove  %rdx,%rbp
jmp    9db <tag_of_reference+0x3d>
mov    $0x0,%ebp
mov    %rax,%rdi
callq  9e3 <tag_of_reference+0x45>
mov    %rax,(%r12)
test   %rax,%rax
je     a37 <tag_of_reference+0x99>
mov    0xb8(%rax),%rax
mov    %rax,0x0(%r13)
mov    (%rax),%rax
test   %rax,%rax
je     a3e <tag_of_reference+0xa0>
mov    $0x0,%ebx
mov    0x8(%rax),%rsi
mov    %rbp,%rdi
callq  a10 <tag_of_reference+0x72>
test   %eax,%eax
je     a45 <tag_of_reference+0xa7>
add    $0x1,%ebx
mov    (%r12),%rax
movslq %ebx,%rdx
mov    0xb8(%rax),%rax
lea    (%rax,%rdx,8),%rax
mov    %rax,0x0(%r13)
mov    (%rax),%rax
test   %rax,%rax
jne    a04 <tag_of_reference+0x66>
jmp    a4c <tag_of_reference+0xae>
mov    $0x0,%eax
jmp    a51 <tag_of_reference+0xb3>
mov    $0x0,%eax
jmp    a51 <tag_of_reference+0xb3>
mov    $0x1,%eax
jmp    a51 <tag_of_reference+0xb3>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
tag_of_reference (REFERENCE *r, WINDOW *window, FILE_BUFFER **fb, TAG ***t)
{
  char *filename, *nodename;
  int i;
  filename = r->filename;
  nodename = r->nodename;
  if (!filename)
    filename = window->node->fullpath;
  if (!nodename || !*nodename)
    nodename = "Top";
  *fb = info_find_file (filename);
  if (!*fb)
    return 0;
  for (i = 0; *(*t = &(*fb)->tags[i]); i++)
    if (!strcmp (nodename, (**t)->nodename))
      goto found_tag;
  return 0;
found_tag: ;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 6
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 10
19 10
20 10
21 11
22 11
23 11
24 12
25 12
26 14
27 14
28 14
29 14
30 14
31 14
32 15
33 15
34 15
35 15
36 15
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 13
48 13
49 17
50 17
51 19
52 19
53 17
54 20
55 20
56 20
57 20
58 20
59 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    91a <gsl_blas_drotm+0x33>
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  913 <gsl_blas_drotm+0x2c>
mov    $0x0,%eax
jmp    938 <gsl_blas_drotm+0x51>
mov    $0x13,%ecx
mov    $0x220,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  933 <gsl_blas_drotm+0x4c>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_drotm (gsl_vector * X, gsl_vector * Y, const double P[])
{
  if (X->size == Y->size)
    {
      cblas_drotm (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                   ((int)(Y->stride)), P);
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 544, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 11
17 11
18 11
19 11
20 11
21 11
22 13
23 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  1967 <ppd_scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ppd_scan_string (const char * yystr )
{
 return ppd_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x40(%rdi),%rbx
mov    0x20(%rdi),%rdi
callq  68 <nntp_folder_close+0x16>
mov    (%rbx),%eax
sub    $0x1,%eax
mov    %eax,(%rbx)
test   %eax,%eax
je     83 <nntp_folder_close+0x31>
mov    0x20(%rbp),%rdi
callq  7c <nntp_folder_close+0x2a>
mov    $0x0,%eax
jmp    9d <nntp_folder_close+0x4b>
mov    0x20(%rbp),%rdi
callq  8c <nntp_folder_close+0x3a>
mov    0x18(%rbx),%rdi
callq  95 <nntp_folder_close+0x43>
movq   $0x0,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nntp_folder_close (mu_folder_t folder)
{
  f_nntp_t f_nntp = folder->data;
  int status = 0;
  mu_monitor_wrlock (folder->monitor);
  f_nntp->isopen--;
  if (f_nntp->isopen)
    {
      mu_monitor_unlock (folder->monitor);
      return 0;
    }
  mu_monitor_unlock (folder->monitor);
  status = mu_nntp_quit (f_nntp->nntp);
  f_nntp->selected = ((void *)0);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 9
14 9
15 10
16 10
17 12
18 12
19 13
20 13
21 14
22 16
23 16
24 16
25 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  bf <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  c8 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  d1 <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  da <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  e3 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  ec <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  f4 <modnewton1_free+0x42>
mov    %rbx,%rdi
callq  fc <modnewton1_free+0x4a>
pop    %rbx
retq   
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
callq  f <chownat+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
chownat (int fd, char const *file, uid_t owner, gid_t group)
{
  return fchownat (fd, file, owner, group, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b9 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  2966 <gsl_sf_lndoublefact+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     298a <gsl_sf_lndoublefact+0x30>
mov    %eax,%ecx
mov    $0x671,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2985 <gsl_sf_lndoublefact+0x2b>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_lndoublefact(const unsigned int n)
{
  gsl_sf_result result; int status = gsl_sf_lndoublefact_e(n, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_lndoublefact_e(n, &result)", "gamma.c", 1649, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # b36b <ch_gr_hdy+0xf>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  1e5 <ch_base_hdy>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
ch_gr_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_GR";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 10
3 11
4 11
5 11
6 12
7 12
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     2e7 <mu_property_unset+0x1a>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  2e3 <mu_property_unset+0x16>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_property_unset (mu_property_t prop, const char *key)
{
  if (!prop)
    return 22;
  return mu_assoc_remove (prop->assoc, key);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 2
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     31b <run_err+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
addl   $0x1,0x0(%rip)        # 34c <run_err+0x8d>
cmpq   $0x0,0x0(%rip)        # 354 <run_err+0x95>
jne    376 <run_err+0xb7>
mov    $0x0,%esi
mov    0x0(%rip),%edi        # 361 <run_err+0xa2>
callq  366 <run_err+0xa7>
mov    %rax,0x0(%rip)        # 36d <run_err+0xae>
test   %rax,%rax
je     445 <run_err+0x186>
mov    0x0(%rip),%rsi        # 37d <run_err+0xbe>
mov    $0x1,%edi
callq  387 <run_err+0xc8>
mov    0x0(%rip),%rcx        # 38e <run_err+0xcf>
mov    $0x5,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3a2 <run_err+0xe3>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 3b1 <run_err+0xf2>
callq  3b6 <run_err+0xf7>
mov    0x0(%rip),%rsi        # 3bd <run_err+0xfe>
mov    $0xa,%edi
callq  3c7 <run_err+0x108>
mov    0x0(%rip),%rdi        # 3ce <run_err+0x10f>
callq  3d3 <run_err+0x114>
cmpl   $0x0,0x0(%rip)        # 3da <run_err+0x11b>
jne    445 <run_err+0x186>
mov    0x0(%rip),%rdx        # 3e3 <run_err+0x124>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 3ef <run_err+0x130>
mov    $0x0,%eax
callq  3f9 <run_err+0x13a>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 42f <run_err+0x170>
callq  434 <run_err+0x175>
mov    0x0(%rip),%rsi        # 43b <run_err+0x17c>
mov    $0xa,%edi
callq  445 <run_err+0x186>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
run_err (const char *fmt, ...)
{
  static FILE *fp;
  va_list ap;
  __builtin_va_start(ap,fmt);
  ++errs;
  if (fp == ((void *)0) && !(fp = fdopen (rem, "w")))
    return;
  fprintf (fp, "%c", 0x01);
  fprintf (fp, "rcp: ");
  vfprintf (fp, fmt, ap);
  __builtin_va_end(ap);
  fprintf (fp, "\n");
  fflush (fp);
  if (!iamremote)
    {
      fprintf (stderr, "%s: ", program_invocation_name);
      __builtin_va_start(ap,fmt);
      vfprintf (stderr, fmt, ap);
      __builtin_va_end(ap);
      fprintf (stderr, "\n");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 5
21 5
22 5
23 5
24 5
25 6
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 9
35 9
36 9
37 10
38 10
39 10
40 10
41 10
42 11
43 11
44 11
45 11
46 13
47 13
48 13
49 14
50 14
51 15
52 15
53 17
54 17
55 17
56 17
57 17
58 18
59 18
60 18
61 18
62 18
63 18
64 19
65 19
66 19
67 19
68 21
69 21
70 21
71 23
72 23
73 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x18(%rdi),%edi
mov    $0x5301,%esi
mov    $0x0,%eax
callq  24f <audio_pause_linux+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
audio_pause_linux (void *p_user_data)
{
  const _img_private_t *p_env = p_user_data;
  return ioctl(p_env->gen.fd, 0x5301);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    (%rsi),%rcx
cmp    $0x3,%edi
je     366 <op_wc_strcasecmp+0x31>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  35f <op_wc_strcasecmp+0x2a>
mov    $0x1,%eax
jmp    39c <op_wc_strcasecmp+0x67>
mov    0x8(%rsi),%rdi
callq  1d <strtowc>
mov    %rax,%rbp
mov    0x10(%rbx),%rdi
callq  1d <strtowc>
mov    %rax,%rsi
mov    %rbp,%rdi
callq  386 <op_wc_strcasecmp+0x51>
mov    %eax,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  397 <op_wc_strcasecmp+0x62>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
op_wc_strcasecmp(int argc, char **argv)
{
    unsigned *wa, *wb;
    char *opname = *argv++;
    argc--;
    if (argc != 2) {
 dico_log(4, 0, "%s requires two arguments", opname);
 return 1;
    }
    wa = strtowc(argv[0]);
    wb = strtowc(argv[1]);
    printf("%d\n", utf8_wc_strcasecmp(wa, wb));
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 10
16 10
17 10
18 11
19 11
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 13
28 14
29 14
30 14
31 14
<<<sep_out_sample>>>
push   %rbx
add    $0xffffffffffffff80,%rsp
mov    %rdi,%rbx
mov    %rsp,%rdi
callq  501 <signal_block+0x10>
mov    $0x11,%esi
mov    %rsp,%rdi
callq  50e <signal_block+0x1d>
mov    $0x1,%esi
mov    %rsp,%rdi
callq  51b <signal_block+0x2a>
mov    $0xe,%esi
mov    %rsp,%rdi
callq  528 <signal_block+0x37>
mov    %rbx,%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
callq  538 <signal_block+0x47>
sub    $0xffffffffffffff80,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
signal_block (sigset_t * old_status)
{
  sigset_t sigs;
  sigemptyset (&sigs);
  sigaddset (&sigs, 17);
  sigaddset (&sigs, 1);
  sigaddset (&sigs, 14);
  sigprocmask (0, &sigs, old_status);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%r9
movzbl (%r9),%ecx
test   %r10,%r10
je     17d1 <gsl_vector_char_minmax+0x39>
mov    %ecx,%edi
mov    $0x0,%r8d
movzbl (%r9),%eax
cmp    %al,%dil
cmovg  %eax,%edi
cmp    %al,%cl
cmovl  %eax,%ecx
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
jne    17b4 <gsl_vector_char_minmax+0x1c>
jmp    17d3 <gsl_vector_char_minmax+0x3b>
mov    %ecx,%edi
mov    %dil,(%rsi)
mov    %cl,(%rdx)
retq   
<<<sep_in_sample>>>
gsl_vector_char_minmax (const gsl_vector_char * v,
                             char * min_out,
                             char * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  char max = v->data[0 * stride];
  char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 10
6 10
7 8
8 10
9 12
10 12
11 12
12 12
13 12
14 10
15 10
16 10
17 10
18 10
19 8
20 22
21 23
22 23
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 71e <seekline+0xa>
test   %rdi,%rdi
je     759 <seekline+0x45>
callq  728 <seekline+0x14>
movl   $0x1,0x0(%rip)        # 732 <seekline+0x1e>
jmp    740 <seekline+0x2c>
cmp    $0xa,%eax
jne    740 <seekline+0x2c>
addl   $0x1,0x0(%rip)        # 740 <seekline+0x2c>
cmp    %ebx,0x0(%rip)        # 746 <seekline+0x32>
jae    759 <seekline+0x45>
mov    0x0(%rip),%rdi        # 74f <seekline+0x3b>
callq  754 <seekline+0x40>
cmp    $0xffffffff,%eax
jne    734 <seekline+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
seekline(unsigned int line)
{
 int c;
 if (refsfound == ((void *)0)) {
  return;
 }
 rewind(refsfound);
 nextline = 1;
 while (nextline < line && (c = _IO_getc (refsfound)) != (-1)) {
  if (c == '\n') {
   nextline++;
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 7
7 8
8 9
9 10
10 10
11 11
12 9
13 9
14 9
15 9
16 9
17 9
18 14
19 14
<<<sep_out_sample>>>
cmpl   $0xffffffff,0x4(%rdi)
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
idset_empty(IDSET *idset)
{
 return ((idset)->min == ((unsigned int)(-1)) ? 1 : 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    0x0(%rip),%rdi        # a4 <markup_flush_capa+0x13>
callq  a9 <markup_flush_capa+0x18>
mov    %rax,0x8(%rsp)
mov    %rax,%rdi
callq  b6 <markup_flush_capa+0x25>
mov    %rax,%rbp
test   %rax,%rax
je     12e <markup_flush_capa+0x9d>
mov    $0xffffffffffffffff,%r14
mov    $0x0,%r13d
movabs $0x2d70756b72616d,%r12
mov    %rbp,%rdi
mov    %r14,%rcx
mov    %r13d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x7(%rcx),%rdi
callq  ec <markup_flush_capa+0x5b>
mov    %rax,%rbx
mov    %r12,(%rax)
mov    %rbp,%rsi
mov    %rax,%rdi
callq  fd <markup_flush_capa+0x6c>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  114 <markup_flush_capa+0x83>
mov    %rbx,%rdi
callq  11c <markup_flush_capa+0x8b>
mov    0x8(%rsp),%rdi
callq  126 <markup_flush_capa+0x95>
mov    %rax,%rbp
test   %rax,%rax
jne    d5 <markup_flush_capa+0x44>
lea    0x8(%rsp),%rdi
callq  138 <markup_flush_capa+0xa7>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
markup_flush_capa()
{
    dico_iterator_t itr;
    const char *p;
    itr = xdico_list_iterator(dico_markup_list);
    for (p = dico_iterator_first(itr); p; p = dico_iterator_next(itr)) {
 size_t len = sizeof("markup-") + strlen(p);
 char *str = xmalloc(len);
 strcat(strcpy(str, "markup-"), p);
 dicod_capa_register(str, ((void *)0), ((void *)0), ((void *)0));
 dicod_capa_add(str);
    }
    dico_iterator_destroy(&itr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 9
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 11
36 11
37 6
38 6
39 6
40 6
41 6
42 13
43 13
44 14
45 14
46 14
47 14
48 14
49 14
50 14
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
null_array_assign (self, value, ind, key)
     SHELL_VAR *self;
     char *value;
     arrayind_t ind;
     char *key;
{
  return (self);
}
<<<sep_in_sample>>>
1 6
2 8
<<<sep_out_sample>>>
movzwl 0x404(%rdi),%eax
test   %ax,%ax
jle    16 <unholdFireAlarm+0x16>
sub    $0x1,%eax
mov    %ax,0x404(%rdi)
repz retq 
<<<sep_in_sample>>>
unholdFireAlarm(char *arg1, char *arg2)
{
 craft *c = (craft *) arg1;
 if (c->holdCount > 0) {
  c->holdCount--;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
lea    0xa(%rsi),%rcx
movb   $0x0,0xa(%rsi)
mov    $0xcccccccd,%esi
sub    $0x1,%rcx
mov    %edi,%eax
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    d <uinttostr+0xd>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
uinttostr (unsigned int i, char *buf)
{
  char *p = buf + ((((sizeof (unsigned int) * 8 - (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (unsigned int)) 0 < (__typeof__ (unsigned int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 16
15 16
16 19
17 19
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 56f <gsl_vector_float_set+0x7>
je     595 <gsl_vector_float_set+0x2d>
cmp    %rsi,(%rdi)
ja     595 <gsl_vector_float_set+0x2d>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  593 <gsl_vector_float_set+0x2b>
jmp    5ab <gsl_vector_float_set+0x43>
mov    0x8(%rdi),%rax
shl    $0x2,%rax
imul   %rax,%rsi
mov    0x10(%rdi),%rax
movss  %xmm0,(%rax,%rsi,1)
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_float_set (gsl_vector_float * v, const size_t i, float x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_float.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0xc(%rdi),%esi
mov    $0x1,%edx
callq  11e <varray_append+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
varray_append(VARRAY *vb)
{
 return varray_assign(vb, vb->length, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     332 <hash_load+0x39>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rcx,%r13
mov    %rdx,%rbp
mov    %rbx,%rsi
mov    %r12,%rdi
callq  31f <hash_load+0x26>
add    %r13,%rbx
sub    $0x1,%rbp
jne    314 <hash_load+0x1b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
hash_load (struct hash_table* ht, void *item_table, unsigned long cardinality, unsigned long size)
{
  char *items = (char *) item_table;
  while (cardinality--)
    {
      hash_insert (ht, items);
      items += size;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 6
13 6
14 6
15 7
16 4
17 4
18 9
19 9
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rdi
callq  9 <main+0x9>
callq  e <main+0xe>
mov    %rax,0x0(%rip)        # 15 <main+0x15>
mov    %rax,%rdi
callq  1d <main+0x1d>
mov    0x0(%rip),%rdi        # 24 <main+0x24>
callq  29 <main+0x29>
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 38 <main+0x38>
callq  3d <main+0x3d>
mov    $0x1,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0xb,%esi
mov    0x0(%rip),%rdi        # 59 <main+0x59>
callq  5e <main+0x5e>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 6a <main+0x6a>
callq  6f <main+0x6f>
mov    0x0(%rip),%rdi        # 76 <main+0x76>
callq  7b <main+0x7b>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # 85 <main+0x85>
callq  8a <main+0x8a>
mov    $0x5,%edi
callq  *%rbx
mov    %eax,%edx
mov    $0x5,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  a7 <main+0xa7>
mov    0x0(%rip),%rdi        # ae <main+0xae>
callq  b3 <main+0xb3>
callq  b8 <main+0xb8>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
main(int argc, char *argv[])
{
  jit_node_t *in;
  pifi incr;
  init_jit(argv[0]);
  _jit = jit_new_state();
  _jit_prolog(_jit);
  in = _jit_arg(_jit);
  _jit_getarg_l(_jit,_RAX,in);
  _jit_new_node_www(_jit,jit_code_addi,_RAX,_RAX,1);
  _jit_retr(_jit,_RAX);
  incr = _jit_emit(_jit);
  _jit_clear_state(_jit);
  printf("%d + 1 = %d\n", 5, incr(5));
  _jit_destroy_state(_jit);
  finish_jit();
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
6 7
7 7
8 8
9 8
10 9
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 10
19 10
20 11
21 11
22 11
23 12
24 12
25 12
26 13
27 13
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 15
36 15
37 16
38 18
39 18
40 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
movswq 0x14(%rdi),%rax
lea    0x18(,%rax,8),%rax
lea    (%rdi,%rax,1),%rbp
movslq 0x10(%rdi),%rbx
sub    %rax,%rbx
mov    %ebx,%edi
callq  25 <__rcopyarrtoc+0x25>
test   %rbx,%rbx
jle    47 <__rcopyarrtoc+0x47>
lea    0x0(%rbp,%rbx,1),%rdi
mov    %rbp,%rdx
mov    %rax,%rsi
sub    %rbp,%rsi
movzbl (%rdx),%ecx
mov    %cl,(%rsi,%rdx,1)
add    $0x1,%rdx
cmp    %rdi,%rdx
jne    38 <__rcopyarrtoc+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__rcopyarrtoc (__arrp p)
{
  long sizeofhode,
    size,
    i;
  char *p1x,
   *p2x;
  sizeofhode = sizeof (__ah) + sizeof (__arrlimit) * p->h.dim;
  p1x = (char *) ((long) p + sizeofhode);
  p2x = (char *) xmalloc ((unsigned) (size = p->h.size - sizeofhode));
  for (i = 0; i < size; i++)
    p2x[i] = p1x[i];
  return (p2x);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 8
5 8
6 9
7 10
8 10
9 10
10 10
11 11
12 11
13 11
14 11
15 11
16 11
17 12
18 12
19 12
20 11
21 11
22 14
23 14
24 14
25 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  d7 <osip_route_parse+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_route_parse (osip_route_t * route, const char *hvalue)
{
  return osip_from_parse ((osip_from_t *) route, hvalue);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x38(%rdi),%rdi
callq  95a <swpath_get_pkgpathname+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swpath_get_pkgpathname(SWPATH * swpath)
{
 return strob_str(swpath->swpackage_pathname_);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <mb_width_aux+0x8>
mov    %eax,%edx
test   %edx,%edx
jns    1d <mb_width_aux+0x1d>
mov    %ebx,%edi
callq  15 <mb_width_aux+0x15>
test   %eax,%eax
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mb_width_aux (wint_t wc)
{
  int w = wcwidth (wc);
  return (w >= 0 ? w : iswcntrl (wc) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rsi),%rax
cmp    %rdx,%rax
ja     5a4f <gsl_matrix_ulong_const_superdiagonal+0x4e>
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5a27 <gsl_matrix_ulong_const_superdiagonal+0x26>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    5a86 <gsl_matrix_ulong_const_superdiagonal+0x85>
mov    0x18(%rsi),%rcx
lea    (%rcx,%rdx,8),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
sub    %rdx,%rax
mov    (%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
mov    %r8,0x8(%rbx)
mov    %rdi,0x10(%rbx)
mov    %rcx,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_ulong_const_superdiagonal (const gsl_matrix_ulong * m,
                                      const size_t k)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 13
20 13
21 14
22 12
23 12
24 12
25 12
26 17
27 17
28 17
29 17
30 17
31 19
32 19
33 19
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gen_frameset_end(void)
{
 return "</frameset>";
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
lea    0x1(%rsi),%rax
retq   
<<<sep_in_sample>>>
move_mbright(const char *buf, size_t pos)
{
    return pos + parse_mbchar(buf + pos, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
test   %rdx,%rdx
jne    1b6c <WriteScale+0x1c>
mov    $0x0,%edi
callq  1b6c <WriteScale+0x1c>
mov    %rbx,%rcx
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1b83 <WriteScale+0x33>
mov    %rbx,%rcx
mov    $0x21,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1b9a <WriteScale+0x4a>
mov    %rbx,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1bb1 <WriteScale+0x61>
mov    $0x0,%r8d
mov    $0x60000,%ecx
mov    $0x0,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1bcc <WriteScale+0x7c>
mov    $0x5,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1be7 <WriteScale+0x97>
mov    %rbx,%rcx
mov    $0x16,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1bfe <WriteScale+0xae>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
WriteScale (PFILE pfile, PVMMAPSTRCT pvmGlo, PVMMAPSTRCT pvmScale)
{
  if (!pvmScale)
    printf ("No Scale{} equations. Null function defined.\n\n");
  fprintf (pfile, "/*----- Model scaling */\n\n");
  fprintf (pfile, "void ScaleModel (PDOUBLE pdTime)\n");
  fprintf (pfile, "{\n");
  ForAllVar (pfile, pvmGlo, &WriteOneDecl, 0x60000, ((void *)0));
  ForAllVar (pfile, pvmScale, &WriteOneEquation, (0), (PVOID) 5);
  fprintf (pfile, "\n} /* ScaleModel */\n\n\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 10
42 10
43 11
44 11
45 11
46 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # f35 <stat_diag+0xb>
je     f3e <stat_diag+0x14>
callq  f3c <stat_diag+0x12>
jmp    f45 <stat_diag+0x1b>
xchg   %ax,%ax
callq  f45 <stat_diag+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
stat_diag (char const *name)
{
  if (ignore_failed_read_option)
    stat_warn (name);
  else
    stat_error (name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1f8 <signal_throw>
<<<sep_in_sample>>>
sigaction_throw(int sig, siginfo_t *info, void *_)
{
  signal_throw(sig);
}
<<<sep_in_sample>>>
1 2
2 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,0xc(%rsp)
mov    %rsi,(%rsp)
cmp    $0x1,%edi
jg     1810 <removedir+0x49>
mov    $0x0,%edx
mov    %rsp,%rsi
lea    0xc(%rsp),%rdi
callq  17ea <removedir+0x23>
test   %eax,%eax
jne    1810 <removedir+0x49>
mov    (%rsp),%rax
mov    (%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1804 <removedir+0x3d>
movl   $0xffffffff,0x0(%rip)        # 180e <removedir+0x47>
jmp    1862 <removedir+0x9b>
mov    (%rsp),%rax
mov    0x8(%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1827 <removedir+0x60>
cmp    $0x5,%eax
jne    1862 <removedir+0x9b>
cmpl   $0x1f4,0x0(%rip)        # 1836 <removedir+0x6f>
jne    1862 <removedir+0x9b>
cmpl   $0x0,0x0(%rip)        # 183f <removedir+0x78>
je     184b <removedir+0x84>
mov    $0x0,%edi
callq  184b <removedir+0x84>
mov    (%rsp),%rax
mov    0x8(%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1862 <removedir+0x9b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
removedir (int argc, char **argv)
{
  if (argc < 2 && !another (&argc, &argv, "directory-name"))
    {
      printf ("usage: %s directory-name\n", argv[0]);
      code = -1;
      return;
    }
  if (command ("RMD %s", argv[1]) == 5 && code == 500)
    {
      if (verbose)
 printf ("RMD command not recognized, trying XRMD\n");
      command ("XRMD %s", argv[1]);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 5
15 5
16 5
17 6
18 7
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 11
29 11
30 12
31 12
32 13
33 13
34 13
35 13
36 13
37 15
38 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  e31 <free_db>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mod_free_db(dico_handle_t hp)
{
    struct dictdb *db = (struct dictdb *) hp;
    free_db(db);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  1787 <gsl_sort_vector_char_largest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_char_largest (char * dest, const size_t k,
                                    const gsl_vector_char * v)
{
  return gsl_sort_char_largest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rbx        # 1624 <xheader_keyword_deleted_p+0x10>
test   %rbx,%rbx
je     1648 <xheader_keyword_deleted_p+0x34>
mov    0x8(%rbx),%rdi
mov    $0x0,%edx
mov    %rbp,%rsi
callq  163a <xheader_keyword_deleted_p+0x26>
test   %eax,%eax
je     164f <xheader_keyword_deleted_p+0x3b>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    1629 <xheader_keyword_deleted_p+0x15>
jmp    1656 <xheader_keyword_deleted_p+0x42>
mov    $0x0,%eax
jmp    165b <xheader_keyword_deleted_p+0x47>
mov    $0x1,%eax
jmp    165b <xheader_keyword_deleted_p+0x47>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xheader_keyword_deleted_p (const char *kw)
{
  struct keyword_list *kp;
  for (kp = keyword_pattern_list; kp; kp = kp->next)
    if (fnmatch (kp->pattern, kw, 0) == 0)
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 4
15 4
16 4
17 4
18 7
19 7
20 6
21 6
22 7
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  341 <link_error>
<<<sep_in_sample>>>
exec_fatal (char const *name)
{
  call_arg_fatal ("exec", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     49a <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
callq  4cb <version_etc+0x7d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  43e <gsl_sf_hydrogenicR_1+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     464 <gsl_sf_hydrogenicR_1+0x32>
mov    %eax,%ecx
mov    $0x71,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  45d <gsl_sf_hydrogenicR_1+0x2b>
movsd  (%rsp),%xmm0
jmp    464 <gsl_sf_hydrogenicR_1+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hydrogenicR_1(const double Z, const double r)
{
  gsl_sf_result result; int status = gsl_sf_hydrogenicR_1_e(Z, r, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hydrogenicR_1_e(Z, r, &result)", "coulomb_bound.c", 113, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  3f38 <is_identchar+0x8>
mov    $0x1,%edx
test   %al,%al
jne    3f4a <is_identchar+0x1a>
cmp    $0x5f,%ebx
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
and    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
is_identchar(int c)
{
 return (is_alnum(c) || c == '_');
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
lea    0x0(,%rsi,8),%rbp
mov    (%rdi),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  7d <rk2simp_reset+0x22>
mov    0x8(%rbx),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  8e <rk2simp_reset+0x33>
mov    0x10(%rbx),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  9f <rk2simp_reset+0x44>
mov    0x18(%rbx),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  b0 <rk2simp_reset+0x55>
imul   %r12,%r12
lea    0x0(,%r12,8),%rdx
mov    0x28(%rbx),%rdi
mov    $0x0,%esi
callq  ca <rk2simp_reset+0x6f>
mov    0x28(%rbx),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  db <rk2simp_reset+0x80>
mov    0x30(%rbx),%rdi
mov    %rbp,%rdx
mov    $0x0,%esi
callq  ec <rk2simp_reset+0x91>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rk2simp_reset (void *vstate, size_t dim)
{
  rk2simp_state_t *state = (rk2simp_state_t *) vstate;
  memset((state->Y1),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->y0_orig),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->dfdt),0,(dim * dim)*sizeof(double));
  memset((state->dfdt),0,(dim)*sizeof(double));
  memset((state->y_onestep),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 10
33 10
34 10
35 10
36 12
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 20da <sendabort+0xb>
movb   $0xff,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  20ec <sendabort+0x1d>
mov    0x0(%rip),%rax        # 20f3 <sendabort+0x24>
movb   $0xee,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  2105 <sendabort+0x36>
mov    $0xee,%edx
mov    $0xff,%esi
mov    $0x0,%edi
callq  2119 <sendabort+0x4a>
movl   $0x1,0x0(%rip)        # 2123 <sendabort+0x54>
cmpl   $0x0,0x0(%rip)        # 212a <sendabort+0x5b>
je     2131 <sendabort+0x62>
callq  0 <doflush>
cmpl   $0x0,0x0(%rip)        # 2138 <sendabort+0x69>
je     213f <sendabort+0x70>
callq  213f <sendabort+0x70>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sendabort (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 238; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 238);
  flushline = 1;
  if (autoflush)
    {
      doflush ();
    }
  if (autosynch)
    {
      dosynch ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 6
18 6
19 8
20 10
21 10
22 12
23 14
24 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0xe0(%rdi),%rdx
mov    0x78(%rsi),%rax
cmp    $0xffffffffffffffff,%rax
je     333 <__db_des_destroy+0x3a>
mov    0x80(%rsi),%rcx
sub    %rax,%rcx
mov    %rcx,0x80(%rsi,%rax,1)
mov    %rsi,%rax
add    0x80(%rsi),%rax
mov    0x78(%rsi),%rcx
add    %rcx,(%rax)
jmp    342 <__db_des_destroy+0x49>
mov    0x80(%rsi),%rax
movq   $0xffffffffffffffff,(%rsi,%rax,1)
mov    0x18(%rdx),%rdi
callq  34b <__db_des_destroy+0x52>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__db_des_destroy(dbenv, rp)
 DB_ENV *dbenv;
 REGION *rp;
{
 REGINFO *infop;
 infop = dbenv->reginfo;
 do { if ((rp)->q.sle_next != -1) { ((struct __db_region *)(((u_int8_t *)(rp)) + (rp)->q.sle_next))->q.sle_prev = (rp)->q.sle_prev - (rp)->q.sle_next; *((ssize_t *)(((u_int8_t *)(rp)) + (rp)->q.sle_prev)) += (rp)->q.sle_next; } else *((ssize_t *)(((u_int8_t *)(rp)) + (rp)->q.sle_prev)) = -1; } while (0);
 CDB___db_shalloc_free(infop->addr, rp);
 return (0);
}
<<<sep_in_sample>>>
1 4
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 10
19 10
20 10
<<<sep_out_sample>>>
test   %r8,%r8
je     a1 <gsl_stats_wmean+0x4f>
shl    $0x3,%rsi
shl    $0x3,%rcx
mov    $0x0,%eax
fldz   
fld    %st(0)
xorpd  %xmm1,%xmm1
movsd  (%rdi),%xmm0
ucomisd %xmm1,%xmm0
jbe    8e <gsl_stats_wmean+0x3c>
movsd  %xmm0,-0x18(%rsp)
fldl   -0x18(%rsp)
fadd   %st,%st(1)
fld    %st(2)
fsubrl (%rdx)
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    6c <gsl_stats_wmean+0x1a>
fstp   %st(0)
jmp    a3 <gsl_stats_wmean+0x51>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_wmean (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t size)
{
  long double wmean = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      double wi = w[i * wstride];
      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 6
2 6
3 8
4 12
5 6
6 4
7 4
8 9
9 8
10 9
11 9
12 11
13 11
14 11
15 12
16 12
17 12
18 12
19 12
20 12
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 3
29 15
30 15
31 16
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     ea <dbg_printf+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
cmpl   $0x0,0x0(%rip)        # f1 <dbg_printf+0x62>
je     143 <dbg_printf+0xb4>
cmpl   $0x0,0x0(%rip)        # fa <dbg_printf+0x6b>
je     143 <dbg_printf+0xb4>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 132 <dbg_printf+0xa3>
callq  137 <dbg_printf+0xa8>
mov    0x0(%rip),%rdi        # 13e <dbg_printf+0xaf>
callq  143 <dbg_printf+0xb4>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
dbg_printf (const char *fmt, ...)
{
  va_list ap;
  if (!(NoDetach && dbg_output))
    return;
  __builtin_va_start(ap,fmt);
  vfprintf (stdout, fmt, ap);
  __builtin_va_end(ap);
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 4
19 4
20 4
21 6
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 9
32 9
33 10
34 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  18c <xcalloc+0x9>
test   %rax,%rax
jne    196 <xcalloc+0x13>
callq  196 <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
mov    (%rdi),%r9d
test   %rdx,%rdx
je     10bb <gsl_stats_int_min_index+0x37>
shl    $0x2,%rsi
add    %rsi,%rdi
mov    $0x0,%ecx
mov    $0x0,%eax
jmp    10b0 <gsl_stats_int_min_index+0x2c>
mov    (%rdi),%r8d
cmp    %r8d,%r9d
jle    10ad <gsl_stats_int_min_index+0x29>
mov    %rcx,%rax
mov    %r8d,%r9d
add    %rsi,%rdi
add    $0x1,%rcx
cmp    %rdx,%rcx
jne    109f <gsl_stats_int_min_index+0x1b>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_stats_int_min_index (const int data[], const size_t stride,
                                const size_t n)
{
  int min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      int xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 5
8 5
9 8
10 9
11 9
12 6
13 8
14 8
15 6
16 6
17 6
18 6
19 5
20 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    0x0(%rip),%edi        # 14 <xalloc_die+0x14>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  2b <xalloc_die+0x2b>
callq  30 <xalloc_die+0x30>
<<<sep_in_sample>>>
xalloc_die (void)
{
  error (exit_failure, 0, "%s", gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%esi        # 7 <drawToolBox+0x7>
mov    0x0(%rip),%edi        # d <drawToolBox+0xd>
callq  12 <drawToolBox+0x12>
mov    0x0(%rip),%ecx        # 18 <drawToolBox+0x18>
mov    0x0(%rip),%eax        # 1e <drawToolBox+0x1e>
lea    -0x1(%rax),%edx
lea    -0xf(%rcx),%esi
mov    $0x2,%r9d
mov    $0x0,%r8d
mov    $0x3,%edi
callq  3a <drawToolBox+0x3a>
mov    $0x0,%ebx
mov    0x0(%rip),%eax        # 45 <drawToolBox+0x45>
lea    -0xe(%rax),%edx
lea    0x4(%rbx),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  5a <drawToolBox+0x5a>
mov    0x0(,%rbx,8),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  71 <drawToolBox+0x71>
add    $0x1,%rbx
cmp    $0x5,%rbx
jne    3f <drawToolBox+0x3f>
cmpl   $0x1,0x0(%rip)        # 82 <drawToolBox+0x82>
jne    d4 <drawToolBox+0xd4>
mov    0x0(%rip),%esi        # 8a <drawToolBox+0x8a>
mov    0x0(%rip),%edi        # 90 <drawToolBox+0x90>
callq  95 <drawToolBox+0x95>
mov    0x0(%rip),%eax        # 9b <drawToolBox+0x9b>
lea    -0xe(%rax),%edx
mov    0x0(%rip),%eax        # a4 <drawToolBox+0xa4>
lea    0x4(%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  b6 <drawToolBox+0xb6>
movslq 0x0(%rip),%rax        # bd <drawToolBox+0xbd>
mov    0x0(,%rax,8),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  d4 <drawToolBox+0xd4>
mov    0x0(%rip),%rdi        # db <drawToolBox+0xdb>
callq  e0 <drawToolBox+0xe0>
pop    %rbx
retq   
<<<sep_in_sample>>>
drawToolBox()
{
 setScreenColors(FG_COLOR[0], BG_COLOR[0]);
 drawBox(3, SCREEN_W-15, SCREEN_H-1, SCREEN_W, " Toolbox ", 2);
 int i;
 for(i = 0; i < 5; i++)
 {
   printf("\e[%d;%dH", i+4, SCREEN_W-14);
   printf("%s", tool[i]);
 }
 if(activeWindow == 1)
 {
   setScreenColors(FG_COLOR[1],
     BG_COLOR[1]);
   printf("\e[%d;%dH", selected_tool+4, SCREEN_W-14);
   printf("%s", tool[selected_tool]);
 }
 fflush(stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 8
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 6
26 6
27 11
28 11
29 13
30 13
31 13
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 19
47 19
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r14
mov    %rdx,%r15
movq   $0x0,(%rdx)
movq   $0x0,(%rsi)
mov    %rdi,%rsi
mov    $0x0,%edi
callq  78a <ogsnames+0x2f>
cmpb   $0x2f,0x0(%rip)        # 791 <ogsnames+0x36>
mov    $0x0,%eax
mov    $0x0,%ebx
cmovne %rax,%rbx
mov    $0xffffffffffffffff,%r12
mov    $0x0,%ebp
mov    $0x3,%r13d
jmp    809 <ogsnames+0xae>
movb   $0x0,(%rdx)
mov    %rbx,%rdi
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x2,%ecx
jle    805 <ogsnames+0xaa>
lea    -0x3(%rdx),%rsi
mov    $0x0,%edi
mov    %r13,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
cmp    %al,%cl
jne    805 <ogsnames+0xaa>
mov    %rbx,(%r14)
lea    0x1(%rdx),%rbx
mov    $0x2f,%esi
mov    %rbx,%rdi
callq  7f8 <ogsnames+0x9d>
test   %rax,%rax
je     81e <ogsnames+0xc3>
mov    %rbx,(%r15)
movb   $0x0,(%rax)
jmp    81e <ogsnames+0xc3>
lea    0x1(%rdx),%rbx
mov    $0x2f,%esi
mov    %rbx,%rdi
callq  816 <ogsnames+0xbb>
mov    %rax,%rdx
test   %rax,%rax
jne    7b3 <ogsnames+0x58>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ogsnames(char *file, char **subsystem, char **book)
{
 static char buf[250 + 1];
 char *s, *slash;
 *subsystem = *book = "";
 (void) strcpy(buf,file);
 s = buf;
 if (*s == '/') {
  ++s;
 }
 while ((slash = strchr(s, '/')) != ((void *)0)) {
  *slash = '\0';
  if ((int)strlen(s) >= 3 && strncmp(slash - 3, ".ss", 3) == 0) {
   *subsystem = s;
   s = slash + 1;
   if ((slash = strchr(s, '/')) != ((void *)0)) {
    *book = s;
    *slash = '\0';
   }
   break;
  }
  s = slash + 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 13
20 13
21 13
22 13
23 12
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 14
41 15
42 16
43 16
44 16
45 16
46 16
47 17
48 18
49 18
50 22
51 11
52 11
53 11
54 11
55 11
56 11
57 24
58 24
59 24
60 24
61 24
62 24
63 24
64 24
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdx,%r12
movss  (%rdi),%xmm1
movss  %xmm1,0xc(%rsp)
mov    $0x0,%ebx
test   %rdx,%rdx
je     a10 <gsl_stats_float_max_index+0x73>
jmp    9f1 <gsl_stats_float_max_index+0x54>
movss  0x0(%rbp),%xmm0
ucomiss 0xc(%rsp),%xmm0
jbe    9d7 <gsl_stats_float_max_index+0x3a>
mov    %rbx,%r14
movss  %xmm0,0xc(%rsp)
add    %r13,%rbp
callq  9df <gsl_stats_float_max_index+0x42>
test   %eax,%eax
jne    a10 <gsl_stats_float_max_index+0x73>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    9c2 <gsl_stats_float_max_index+0x25>
mov    %r14,%rbx
jmp    a10 <gsl_stats_float_max_index+0x73>
lea    0x0(,%rsi,4),%r13
lea    (%rdi,%r13,1),%rbp
movss  0xc(%rsp),%xmm0
mov    $0x0,%ebx
mov    $0x0,%r14d
jmp    9da <gsl_stats_float_max_index+0x3d>
mov    %rbx,%rax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_stats_float_max_index (const float data[], const size_t stride,
                                const size_t n)
{
  float max = data[0 * stride];
  size_t i, max_index = 0;
  for (i = 0; i < n; i++)
    {
      float xi = data[i * stride];
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          return i;
        }
    }
  return max_index;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 6
12 6
13 6
14 8
15 9
16 9
17 6
18 8
19 8
20 14
21 14
22 14
23 6
24 6
25 6
26 6
27 6
28 8
29 8
30 8
31 6
32 5
33 5
34 20
35 20
36 20
37 20
38 20
39 20
40 20
41 20
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    0xa8(%rdi),%rbx
mov    0x20(%rdi),%r12d
test   $0x800,%r12d
je     3cd <skip_delim+0x8f>
test   $0x1000,%r12d
je     385 <skip_delim+0x47>
mov    0x98(%rdi),%r13
movzbl 0x0(%r13,%rbx,1),%r14d
movsbl %r14b,%esi
mov    0x28(%rdi),%rdi
callq  380 <skip_delim+0x42>
test   %rax,%rax
jne    38e <skip_delim+0x50>
mov    0xa0(%rbp),%r13
jmp    3a7 <skip_delim+0x69>
mov    0xa0(%rbp),%rax
add    $0x1,%rbx
cmp    %rax,%rbx
jae    3c9 <skip_delim+0x8b>
cmp    0x0(%r13,%rbx,1),%r14b
je     395 <skip_delim+0x57>
jmp    3c9 <skip_delim+0x8b>
add    $0x1,%rbx
cmp    %r13,%rbx
jae    3c9 <skip_delim+0x8b>
mov    0x98(%rbp),%rax
movsbl (%rax,%rbx,1),%esi
mov    0x28(%rbp),%rdi
callq  3c4 <skip_delim+0x86>
test   %rax,%rax
jne    3a7 <skip_delim+0x69>
sub    $0x1,%rbx
and    $0x1000,%r12d
cmp    $0x1,%r12d
adc    $0x0,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
skip_delim (struct wordsplit *wsp)
{
  size_t start = wsp->ws_endp;
  if (wsp->ws_flags & 0x00000800)
    {
      if ((wsp->ws_flags & 0x00001000) &&
   (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)))
 {
   int delim = wsp->ws_input[start];
   do
     start++;
   while (start < wsp->ws_len && delim == wsp->ws_input[start]);
 }
      else
 {
   do
     start++;
   while (start < wsp->ws_len && (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)));
 }
      start--;
    }
  if (!(wsp->ws_flags & 0x00001000))
    start++;
  return start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 6
19 6
20 18
21 18
22 12
23 11
24 12
25 12
26 12
27 12
28 12
29 17
30 18
31 18
32 18
33 18
34 18
35 18
36 18
37 18
38 20
39 22
40 23
41 23
42 25
43 25
44 25
45 25
46 25
47 25
48 25
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
callq  59d <net_create_stream+0x10>
movslq %ebp,%rsi
movq   $0x0,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    (%rbx),%rdi
callq  5c6 <net_create_stream+0x39>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
net_create_stream (NET_STREAM * str, int fd)
{
  stream_create (str);
  stream_set_io (*str, (void *) fd, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
lea    -0x1(%rdi),%eax
cmp    $0x6,%eax
jbe    b15 <short3_day_name+0x18>
mov    $0x0,%edi
callq  b13 <short3_day_name+0x16>
jmp    b25 <short3_day_name+0x28>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rdi
callq  b25 <short3_day_name+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
short3_day_name (day)
     const int day;
{
  static const char *name[] = {
    ("invalid day"),
    ("Mon"),
    ("Tue"),
    ("Wed"),
    ("Thu"),
    ("Fri"),
    ("Sat"),
    ("Sun")
  };
  return (((day < 1) || (day > 7)) ? gettext(name[0]) : gettext(name[day]));
}
<<<sep_in_sample>>>
1 3
2 14
3 14
4 14
5 14
6 14
7 14
8 14
9 14
10 14
11 15
12 15
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    0x8(%rsi),%rdx
cmp    %rdx,(%rsi)
cmovbe (%rsi),%rdx
mov    %rdx,(%rax)
mov    %r8,0x8(%rax)
mov    %rdi,0x10(%rax)
mov    %rcx,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_matrix_const_diagonal (const gsl_matrix * m)
{
  _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
  gsl_vector v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r9d
callq  377a <gsl_fft_complex_backward+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_complex_backward (gsl_complex_packed_array data,
                                    const size_t stride,
                                    const size_t n,
                                    const gsl_fft_complex_wavetable * wavetable,
                                    gsl_fft_complex_workspace * work)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_transform (data, stride, n,
                                                    wavetable, work, sign);
  return status;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
4 11
5 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%rbx
cmp    (%rdi),%rbx
jne    2f76 <gsl_matrix_int_div_elements+0x23>
mov    0x8(%rsi),%r11
cmp    %rax,%r11
je     2f99 <gsl_matrix_int_div_elements+0x46>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f8f <gsl_matrix_int_div_elements+0x3c>
mov    $0x13,%eax
jmpq   301c <gsl_matrix_int_div_elements+0xc9>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r13
test   %rbx,%rbx
je     3010 <gsl_matrix_int_div_elements+0xbd>
lea    0x0(,%rax,4),%r14
sub    %rax,%r13
shl    $0x2,%r13
mov    $0x0,%r10d
mov    $0x0,%r12d
mov    $0x0,%ebp
jmp    3000 <gsl_matrix_int_div_elements+0xad>
mov    %rcx,%r9
add    0x18(%rdi),%r9
mov    %rcx,%rdx
add    0x18(%rsi),%rdx
mov    %rdx,%r15
mov    (%r9),%eax
cltd   
idivl  (%r15,%r10,1)
mov    %eax,(%r9)
add    $0x1,%r8
add    $0x4,%rcx
cmp    %r11,%r8
jne    2fc8 <gsl_matrix_int_div_elements+0x75>
add    $0x1,%rbp
add    %r14,%r12
add    %r13,%r10
cmp    %rbx,%rbp
je     3017 <gsl_matrix_int_div_elements+0xc4>
test   %r11,%r11
je     2ff1 <gsl_matrix_int_div_elements+0x9e>
mov    %r12,%rcx
mov    $0x0,%r8d
jmp    2fc8 <gsl_matrix_int_div_elements+0x75>
mov    $0x0,%eax
jmp    301c <gsl_matrix_int_div_elements+0xc9>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_int_div_elements (gsl_matrix_int * a, const gsl_matrix_int * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 11
23 12
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 16
43 16
44 16
45 16
46 14
47 14
48 14
49 14
50 14
51 16
52 16
53 16
54 16
55 16
56 21
57 21
58 21
59 23
60 23
61 23
62 23
63 23
64 23
65 23
66 23
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%r9
mov    (%r9),%rcx
test   %r10,%r10
je     c58 <gsl_vector_ulong_minmax+0x3f>
shl    $0x3,%r11
mov    %rcx,%rdi
mov    $0x0,%r8d
mov    (%r9),%rax
cmp    %rax,%rdi
cmova  %rax,%rdi
cmp    %rax,%rcx
cmovb  %rax,%rcx
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
jne    c39 <gsl_vector_ulong_minmax+0x20>
jmp    c5b <gsl_vector_ulong_minmax+0x42>
mov    %rcx,%rdi
mov    %rdi,(%rsi)
mov    %rcx,(%rdx)
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_minmax (const gsl_vector_ulong * v,
                             unsigned long * min_out,
                             unsigned long * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned long max = v->data[0 * stride];
  unsigned long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 10
6 10
7 12
8 8
9 10
10 12
11 12
12 12
13 12
14 12
15 10
16 10
17 10
18 10
19 10
20 8
21 22
22 23
23 23
<<<sep_out_sample>>>
sub    $0x58,%rsp
movapd %xmm0,%xmm7
movsd  %xmm2,(%rsp)
xorpd  %xmm0,%xmm0
movsd  %xmm7,0x8(%rsp)
ucomisd %xmm7,%xmm0
ja     1c7 <gsl_ran_fdist_pdf+0x14a>
movsd  0x0(%rip),%xmm5        # a6 <gsl_ran_fdist_pdf+0x29>
mulsd  %xmm1,%xmm5
movsd  %xmm5,0x10(%rsp)
movsd  %xmm1,0x20(%rsp)
movapd %xmm1,%xmm0
callq  bf <gsl_ran_fdist_pdf+0x42>
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm1        # cd <gsl_ran_fdist_pdf+0x50>
movsd  (%rsp),%xmm6
mulsd  %xmm6,%xmm1
movsd  %xmm1,0x18(%rsp)
movapd %xmm6,%xmm0
callq  e5 <gsl_ran_fdist_pdf+0x68>
movsd  0x28(%rsp),%xmm2
mulsd  0x10(%rsp),%xmm2
movapd %xmm2,%xmm1
mulsd  0x18(%rsp),%xmm0
addsd  %xmm0,%xmm1
movsd  %xmm1,0x28(%rsp)
movsd  0x20(%rsp),%xmm4
addsd  (%rsp),%xmm4
movapd %xmm4,%xmm1
mulsd  0x0(%rip),%xmm1        # 11c <gsl_ran_fdist_pdf+0x9f>
movsd  %xmm1,0x30(%rsp)
movapd %xmm1,%xmm0
callq  12b <gsl_ran_fdist_pdf+0xae>
movsd  %xmm0,0x38(%rsp)
movsd  0x10(%rsp),%xmm0
callq  13c <gsl_ran_fdist_pdf+0xbf>
movsd  %xmm0,0x40(%rsp)
movsd  0x18(%rsp),%xmm0
callq  14d <gsl_ran_fdist_pdf+0xd0>
movsd  %xmm0,0x18(%rsp)
movsd  0x8(%rsp),%xmm0
callq  15e <gsl_ran_fdist_pdf+0xe1>
movsd  %xmm0,0x48(%rsp)
movsd  0x20(%rsp),%xmm4
mulsd  0x8(%rsp),%xmm4
movapd %xmm4,%xmm0
addsd  (%rsp),%xmm0
callq  17e <gsl_ran_fdist_pdf+0x101>
movsd  0x28(%rsp),%xmm2
addsd  0x38(%rsp),%xmm2
subsd  0x40(%rsp),%xmm2
subsd  0x18(%rsp),%xmm2
movsd  0x10(%rsp),%xmm3
subsd  0x0(%rip),%xmm3        # 1a4 <gsl_ran_fdist_pdf+0x127>
mulsd  0x48(%rsp),%xmm3
addsd  %xmm3,%xmm2
movsd  0x30(%rsp),%xmm1
mulsd  %xmm0,%xmm1
subsd  %xmm1,%xmm2
movapd %xmm2,%xmm0
callq  1c5 <gsl_ran_fdist_pdf+0x148>
jmp    1cb <gsl_ran_fdist_pdf+0x14e>
xorpd  %xmm0,%xmm0
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_fdist_pdf (const double x, const double nu1, const double nu2)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      double p;
      double lglg = (nu1 / 2) * log (nu1) + (nu2 / 2) * log (nu2) ;
      double lg12 = gsl_sf_lngamma ((nu1 + nu2) / 2);
      double lg1 = gsl_sf_lngamma (nu1 / 2);
      double lg2 = gsl_sf_lngamma (nu2 / 2);
      p =
 exp (lglg + lg12 - lg1 - lg2 + (nu1 / 2 - 1) * log (x) -
      ((nu1 + nu2) / 2) * log (nu2 + nu1 * x));
      return p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 12
36 12
37 12
38 13
39 13
40 13
41 15
42 15
43 15
44 16
45 16
46 16
47 16
48 16
49 15
50 15
51 15
52 15
53 15
54 15
55 15
56 15
57 16
58 16
59 15
60 15
61 14
62 17
63 5
64 19
65 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     cbb <toprintable+0x39>
mov    %rdi,%rbp
callq  c98 <toprintable+0x16>
mov    %rbp,%rdx
lea    0x0(%rbp,%rbx,1),%rsi
movsbq (%rdx),%r8
mov    (%rax),%rcx
testb  $0x40,0x1(%rcx,%r8,2)
jne    cb2 <toprintable+0x30>
movb   $0x3f,(%rdx)
add    $0x1,%rdx
cmp    %rsi,%rdx
jne    ca0 <toprintable+0x1e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
toprintable(string, length)
    char *string;
    size_t length;
{
    size_t i;
    for (i = 0; i < length; i++)
 if (!((*__ctype_b_loc ())[(int) (((int)string[i]))] & (unsigned short int) _ISprint))
     string[i] = '?';
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 6
18 6
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x20,%esi
mov    $0x1,%edi
callq  ad <mu_vartab_create+0x16>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     e9 <mu_vartab_create+0x52>
mov    $0x0,%edx
mov    $0x28,%esi
mov    %rbx,%rdi
callq  cc <mu_vartab_create+0x35>
mov    %eax,%r12d
test   %eax,%eax
je     e0 <mu_vartab_create+0x49>
mov    %rbx,%rdi
callq  db <mu_vartab_create+0x44>
mov    %r12d,%eax
jmp    e9 <mu_vartab_create+0x52>
mov    %rbx,0x0(%rbp)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_vartab_create (mu_vartab_t *pvar)
{
  int rc;
  struct _mu_vartab *p = calloc (1, sizeof *p);
  if (!p)
    return 12;
  rc = mu_assoc_create (&p->assoc, sizeof (struct vardefn), 0);
  if (rc)
    {
      free (p);
      return rc;
    }
  *pvar = p;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 10
20 10
21 11
22 11
23 13
24 14
25 15
26 15
27 15
28 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
callq  10ca <quotearg_style_mem+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)
{
  return quotearg_n_style_mem (0, s, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
cmp    $0x56,%edi
jne    15e <argp_version_parser+0x77>
push   %rbx
mov    %rdx,%rbx
mov    0x0(%rip),%rax        # f7 <argp_version_parser+0x10>
test   %rax,%rax
je     107 <argp_version_parser+0x20>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
jmp    14e <argp_version_parser+0x67>
mov    0x0(%rip),%rdx        # 10e <argp_version_parser+0x27>
test   %rdx,%rdx
je     128 <argp_version_parser+0x41>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  126 <argp_version_parser+0x3f>
jmp    14e <argp_version_parser+0x67>
mov    (%rbx),%rax
mov    0x30(%rax),%rdi
mov    $0x0,%esi
callq  139 <argp_version_parser+0x52>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  14e <argp_version_parser+0x67>
testb  $0x20,0x1c(%rbx)
jne    164 <argp_version_parser+0x7d>
mov    $0x0,%edi
callq  15e <argp_version_parser+0x77>
mov    $0x7,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 14
30 14
31 15
32 15
33 18
34 21
35 20
36 21
37 21
<<<sep_out_sample>>>
push   %rbx
mov    0x20(%rdi),%rax
mov    0xa0(%rax),%rbx
mov    %rbx,%rdi
callq  14 <swi_get_last_swpath_ex+0x14>
lea    -0x2(%rax),%esi
mov    %rbx,%rdi
callq  1f <swi_get_last_swpath_ex+0x1f>
pop    %rbx
retq   
<<<sep_in_sample>>>
swi_get_last_swpath_ex(SWI * swi)
{
 SWPATH_EX * ret;
 CPLOB * list = swi->swi_pkgM->exlistM;
 int index;
 index = cplob_get_nused(list) - 2;
 ret = (SWPATH_EX *)cplob_val(list, index);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 7
8 7
9 9
10 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     39a <get_value+0xb3>
mov    %rsi,%r12
mov    %edx,%r13d
callq  308 <get_value+0x21>
mov    %rax,%rbp
test   %rax,%rax
je     3a1 <get_value+0xba>
mov    %rbx,%rdi
callq  31c <get_value+0x35>
cmp    $0x4f,%al
jne    348 <get_value+0x61>
test   %r12,%r12
je     32d <get_value+0x46>
movl   $0x0,(%r12)
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbp,%rcx,1),%rax
jmp    3a6 <get_value+0xbf>
mov    %rbx,%rdi
callq  350 <get_value+0x69>
mov    %eax,%edx
test   %r12,%r12
je     35b <get_value+0x74>
mov    %eax,(%r12)
test   %r13d,%r13d
je     37f <get_value+0x98>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
movslq %edx,%rdx
mov    %rbp,%rax
sub    %rcx,%rax
movb   $0x0,-0x1(%rdx,%rax,1)
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x0(%rbp,%rcx,1),%rax
jmp    3a6 <get_value+0xbf>
mov    $0x0,%eax
jmp    3a6 <get_value+0xbf>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
get_value(char *output_line, int *value_len, int do_terminate)
{
 char *ret;
 int len;
 if (!output_line) return (char*)(((void *)0));
 if (!(ret = swheaderline_get_keyword(output_line)))
  return ((void *)0);
 if (swheaderline_get_type(output_line) == 'O') {
  if (value_len) *value_len = 0;
  return ret + strlen(ret);
 }
 len=swheaderline_get_value_length(output_line);
 if (value_len) *value_len=len;
 if (do_terminate)
  *(ret + strlen(ret) + 1 +len) = '\0';
 return ret + strlen(ret) + 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 12
30 12
31 12
32 13
33 13
34 13
35 14
36 14
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 16
46 16
47 16
48 16
49 16
50 16
51 16
52 5
53 5
54 7
55 17
56 17
57 17
58 17
59 17
60 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1a6 <exitcondlabel+0x12>
mov    $0x0,%eax
callq  1b0 <exitcondlabel+0x1c>
movb   $0x0,0x0(%rip)        # 1b7 <exitcondlabel+0x23>
movq   $0x0,0x0(%rip)        # 1c2 <exitcondlabel+0x2e>
callq  1c7 <exitcondlabel+0x33>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
exitcondlabel (int l)
{
  fprintf (ccode, "goto __sw;__l%d:", l);
  not_reached = 0;
  last_line = 0;
  genline ();
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 5
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0x2,%edi
ja     32 <fd_safer_flag+0x32>
callq  16 <fd_safer_flag+0x16>
mov    %eax,%r12d
callq  1e <fd_safer_flag+0x1e>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    %ebx,%edi
callq  2b <fd_safer_flag+0x2b>
mov    %r13d,0x0(%rbp)
mov    %r12d,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
fd_safer_flag (int fd, int flag)
{
  if (0 <= fd && fd <= 2)
    {
      int f = dup_safer_flag (fd, flag);
      int e = (*__errno_location ());
      close (fd);
      (*__errno_location ()) = e;
      fd = f;
    }
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %rsi,%r12
mov    %edx,%r13d
mov    $0xa,%edi
callq  acc <swextopt_writeExtendedOptions+0x1c>
mov    %rax,%rbx
mov    $0x0,%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rax,%rdi
callq  ae2 <swextopt_writeExtendedOptions+0x32>
mov    %rbx,%rdi
callq  aea <swextopt_writeExtendedOptions+0x3a>
mov    %rax,%r12
mov    %rbx,%rdi
callq  af5 <swextopt_writeExtendedOptions+0x45>
mov    %r12,%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    $0x0,%edi
callq  b07 <swextopt_writeExtendedOptions+0x57>
mov    %rax,%r12
mov    %rbx,%rdi
callq  b12 <swextopt_writeExtendedOptions+0x62>
mov    $0xffffffff,%ebp
cmp    %r12d,%eax
jne    b28 <swextopt_writeExtendedOptions+0x78>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  b26 <swextopt_writeExtendedOptions+0x76>
jmp    b28 <swextopt_writeExtendedOptions+0x78>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
swextopt_writeExtendedOptions(int ofd, struct extendedOptions * eop, int SWC_FLAG)
{
 int ret;
 STROB * tmp = strob_open(10);
 swextopt_writeExtendedOptions_strob(tmp, eop, SWC_FLAG, 0);
 ret = atomicio((ssize_t (*)(int, void *, size_t))write, ofd, strob_str(tmp), strob_strlen(tmp));
 if (ret != (int)strob_strlen(tmp)) return -1;
 strob_close(tmp);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 7
29 7
30 7
31 7
32 7
33 7
34 8
35 8
36 9
37 10
38 10
39 10
40 10
41 10
42 10
43 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
callq  269 <setbit_case_fold_c+0xc>
mov    %eax,%ebp
mov    $0x0,%ebx
mov    %ebx,%edi
callq  277 <setbit_case_fold_c+0x1a>
cmp    %ebp,%eax
jne    285 <setbit_case_fold_c+0x28>
mov    %r12,%rsi
mov    %ebx,%edi
callq  26 <setbit>
add    $0x1,%ebx
cmp    $0x100,%ebx
jne    270 <setbit_case_fold_c+0x13>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
setbit_case_fold_c (int b, charclass c)
{
  int ub = toupper (b);
  int i;
  for (i = 0; i < NOTCHAR; i++)
    if (toupper (i) == ub)
      setbit (i, c);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 5
16 5
17 5
18 8
19 8
20 8
21 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  4da <gsl_sf_bessel_Jn+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     500 <gsl_sf_bessel_Jn+0x32>
mov    %eax,%ecx
mov    $0xc6,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4f9 <gsl_sf_bessel_Jn+0x2b>
movsd  (%rsp),%xmm0
jmp    500 <gsl_sf_bessel_Jn+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Jn(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Jn_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Jn_e(n, x, &result)", "bessel_Jn.c", 198, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
and    $0x3,%esi
lea    0x0(,%rsi,4),%eax
movzbl 0x84(%rdi),%edx
and    $0xfffffff3,%edx
or     %edx,%eax
mov    %al,0x84(%rdi)
mov    0x30(%rdi),%rax
test   %rax,%rax
je     11e7 <set_command_state+0x46>
shl    $0x2,%esi
mov    0x10(%rax),%rdx
movzbl 0x84(%rdx),%ecx
and    $0xfffffff3,%ecx
or     %esi,%ecx
mov    %cl,0x84(%rdx)
mov    (%rax),%rax
test   %rax,%rax
jne    11c9 <set_command_state+0x28>
repz retq 
<<<sep_in_sample>>>
set_command_state (struct file *file, enum cmd_state state)
{
  struct dep *d;
  file->command_state = state;
  for (d = file->also_make; d != 0; d = d->next)
    d->file->command_state = state;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 5
17 5
18 5
19 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  eb <xextendbuf+0x9>
test   %rax,%rax
jne    fd <xextendbuf+0x1b>
mov    %rbx,%rdi
callq  f8 <xextendbuf+0x16>
callq  fd <xextendbuf+0x1b>
pop    %rbx
retq   
<<<sep_in_sample>>>
xextendbuf (void* existing, size_t wanted, size_t *allocated)
{
  void *p = extendbuf (existing, wanted, allocated);
  if (((void *)0) == p)
    {
      free (existing);
      xalloc_die ();
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 6
8 7
9 10
10 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  2c8 <push_source>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_preproc_init (const char *name)
{
  return push_source (name, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x1,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
callq  dca <rpl_getopt+0x21>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
rpl_getopt (int argc, char *const *argv, const char *optstring)
{
  return rpl_getopt_internal (argc, (char **) argv, optstring, ((void *)0), ((void *)0), 0,
      POSIXLY_CORRECT);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     32f <warning+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
cmpl   $0x0,0x0(%rip)        # 339 <warning+0x66>
jne    3a2 <warning+0xcf>
mov    0x0(%rip),%rcx        # 342 <warning+0x6f>
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  356 <warning+0x83>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 38c <warning+0xb9>
callq  391 <warning+0xbe>
mov    0x0(%rip),%rsi        # 398 <warning+0xc5>
mov    $0xa,%edi
callq  3a2 <warning+0xcf>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
warning(const char *s, ...)
{
 va_list ap;
 if (!quiet) {
  fputs("Warning: ", stderr);
  __builtin_va_start(ap,s);
  (void)vfprintf(stderr, s, ap);
  __builtin_va_end(ap);
  fputs("\n", stderr);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 7
35 7
36 9
37 9
38 9
39 11
40 11
41 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  f2 <help_me_c+0xe>
mov    %rax,%rdi
mov    $0x0,%eax
callq  ff <help_me_c+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
help_me_c (void)
{
  printf (gettext ("C language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n")
  );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
lea    0x0(,%rsi,8),%rbx
mov    (%rdi),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  82 <rkf45_reset+0x21>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  93 <rkf45_reset+0x32>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  a4 <rkf45_reset+0x43>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  b5 <rkf45_reset+0x54>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  c6 <rkf45_reset+0x65>
mov    0x28(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  d7 <rkf45_reset+0x76>
mov    0x38(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  e8 <rkf45_reset+0x87>
mov    0x30(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  f9 <rkf45_reset+0x98>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rkf45_reset (void *vstate, size_t dim)
{
  rkf45_state_t *state = (rkf45_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->k4),0,(dim)*sizeof(double));
  memset((state->k5),0,(dim)*sizeof(double));
  memset((state->k6),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 13
39 13
40 13
41 13
42 13
<<<sep_out_sample>>>
cvtsi2sd %rdi,%xmm1
cvtsi2sd %rsi,%xmm0
divsd  0x0(%rip),%xmm0        # 52 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x78(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_add_at (gl_list_t list, size_t position, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->add_at (list, position, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
dummy_free(void *vstate)
{
  (void) vstate;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edi,%r13d
mov    %esi,%ebp
mov    %edx,%r12d
mov    $0x4,%edi
callq  e4 <dico_fd_stream_create+0x1c>
mov    %rax,%rbx
test   %rax,%rax
je     17b <dico_fd_stream_create+0xb3>
mov    %rax,%rdx
mov    %ebp,%esi
lea    0x8(%rsp),%rdi
callq  ff <dico_fd_stream_create+0x37>
test   %eax,%eax
je     112 <dico_fd_stream_create+0x4a>
mov    %rbx,%rdi
callq  10b <dico_fd_stream_create+0x43>
mov    $0x0,%eax
jmp    180 <dico_fd_stream_create+0xb8>
mov    %r13d,(%rbx)
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  124 <dico_fd_stream_create+0x5c>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  133 <dico_fd_stream_create+0x6b>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  142 <dico_fd_stream_create+0x7a>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  151 <dico_fd_stream_create+0x89>
test   %r12d,%r12d
jne    165 <dico_fd_stream_create+0x9d>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  165 <dico_fd_stream_create+0x9d>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  174 <dico_fd_stream_create+0xac>
mov    0x8(%rsp),%rax
jmp    180 <dico_fd_stream_create+0xb8>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dico_fd_stream_create(int fd, int flags, int noclose)
{
    int rc;
    dico_stream_t str;
    struct _stream *s = malloc(sizeof(*s));
    if (!s)
 return ((void *)0);
    rc = dico_stream_create(&str, flags, s);
    if (rc) {
 free(s);
 return ((void *)0);
    }
    s->fd = fd;
    dico_stream_set_seek(str, fd_seek);
    dico_stream_set_size(str, fd_size);
    dico_stream_set_write(str, fd_write);
    dico_stream_set_read(str, fd_read);
    if (!noclose)
 dico_stream_set_close(str, fd_close);
    dico_stream_set_destroy(str, fd_destroy);
    return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 6
13 6
14 8
15 8
16 8
17 8
18 9
19 9
20 10
21 10
22 11
23 11
24 13
25 14
26 14
27 14
28 15
29 15
30 15
31 16
32 16
33 16
34 17
35 17
36 17
37 18
38 18
39 19
40 19
41 19
42 20
43 20
44 20
45 21
46 21
47 7
48 22
49 22
50 22
51 22
52 22
53 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3a0 <find_user_command_in_path>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_in_path (name, path_list, flags)
     const char *name;
     char *path_list;
     int flags;
{
  return (find_user_command_in_path (name, path_list, flags));
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <scram_start>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_scram_sha1_plus_client_start (Gsasl_session * sctx, void **mech_data)
{
  return scram_start (sctx, mech_data, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30f <cdio_get_track_msf+0x60>
push   %rbx
mov    %rdx,%rbx
mov    0x108(%rdi),%rax
test   %rax,%rax
je     2d3 <cdio_get_track_msf+0x24>
movzbl %sil,%esi
mov    0x180(%rdi),%rdi
callq  *%rax
jmp    315 <cdio_get_track_msf+0x66>
mov    0xe0(%rdi),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
je     315 <cdio_get_track_msf+0x66>
movzbl %sil,%esi
mov    0x180(%rdi),%rdi
callq  *%rdx
mov    %eax,%edi
mov    $0x0,%eax
cmp    $0xffff4f0b,%edi
je     315 <cdio_get_track_msf+0x66>
mov    %rbx,%rsi
callq  308 <cdio_get_track_msf+0x59>
mov    $0x1,%eax
jmp    315 <cdio_get_track_msf+0x66>
mov    $0x0,%eax
retq   
pop    %rbx
retq   
<<<sep_in_sample>>>
cdio_get_track_msf(const CdIo_t *p_cdio, track_t u_track, msf_t *msf)
{
  if (!p_cdio) return 0;
  if (p_cdio->op.get_track_msf) {
    return p_cdio->op.get_track_msf (p_cdio->env, u_track, msf);
  } else if (p_cdio->op.get_track_lba) {
    lba_t lba = p_cdio->op.get_track_lba (p_cdio->env, u_track);
    if (lba == -45301) return 0;
    cdio_lba_to_msf(lba, msf);
    return 1;
  } else {
    return 0;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 6
13 12
14 6
15 6
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 10
26 10
27 3
28 3
29 14
30 14
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
<<<sep_in_sample>>>
osip_authentication_info_set_cnonce (osip_authentication_info_t * authentication_info, char *cnonce)
{
  authentication_info->cnonce = (char *) cnonce;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
test   %rdi,%rdi
je     628 <hash_walk+0x5c>
mov    %rsi,%rbp
cmpl   $0x0,0xc(%rdi)
je     628 <hash_walk+0x5c>
mov    0x8(%rdi),%eax
test   %eax,%eax
jle    628 <hash_walk+0x5c>
mov    $0x0,%r13d
cmp    %eax,%r13d
jge    61a <hash_walk+0x4e>
movslq %r13d,%rdx
mov    (%r12),%rax
mov    (%rax,%rdx,8),%rbx
test   %rbx,%rbx
je     61a <hash_walk+0x4e>
mov    %rbx,%rdi
callq  *%rbp
test   %eax,%eax
js     628 <hash_walk+0x5c>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    609 <hash_walk+0x3d>
add    $0x1,%r13d
mov    0x8(%r12),%eax
cmp    %r13d,%eax
jg     5f4 <hash_walk+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
hash_walk (table, func)
     HASH_TABLE *table;
     hash_wfunc *func;
{
  register int i;
  BUCKET_CONTENTS *item;
  if (table == 0 || ((table) ? (table)->nentries : 0) == 0)
    return;
  for (i = 0; i < table->nbuckets; i++)
    {
      for (item = ((table && (i < table->nbuckets)) ? table->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); item; item = item->next)
 if ((*func) (item) < 0)
   return;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 12
25 12
26 12
27 11
28 11
29 11
30 9
31 9
32 9
33 9
34 15
35 15
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # d4 <shell_quote+0xc>
jne    e0 <shell_quote+0x18>
mov    $0x0,%eax
callq  0 <init_sh_quoting_options>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    0x0(%rip),%rdx        # ff <shell_quote+0x37>
mov    %rbx,%rdi
callq  107 <shell_quote+0x3f>
pop    %rbx
retq   
<<<sep_in_sample>>>
shell_quote (const char *string)
{
  if (sh_quoting_options == ((void *)0))
    init_sh_quoting_options ();
  return quotearg_alloc (string, strlen (string), sh_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     158a <free_history_node+0x45>
testb  $0x10,0x38(%rdi)
je     158a <free_history_node+0x45>
mov    0x18(%rdi),%rdi
callq  155d <free_history_node+0x18>
mov    0x40(%rbx),%rdi
callq  1566 <free_history_node+0x21>
mov    0x58(%rbx),%rdi
callq  156f <free_history_node+0x2a>
mov    0x50(%rbx),%rdi
callq  1578 <free_history_node+0x33>
mov    0x48(%rbx),%rdi
callq  1581 <free_history_node+0x3c>
mov    0x10(%rbx),%rdi
callq  158a <free_history_node+0x45>
mov    %rbx,%rdi
callq  1592 <free_history_node+0x4d>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_history_node (NODE *n)
{
  if (n && (n->flags & 0x10))
    {
      free (n->contents);
      info_free_references (n->references);
      free (n->next); free (n->prev); free (n->up);
      free (n->nodename);
    }
  free (n);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 10
20 10
21 11
22 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  c3d <err_unboundvar+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  c4d <err_unboundvar+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
err_unboundvar (s)
     const char *s;
{
  report_error (gettext("%s: unbound variable"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # ca <shell_quote+0xc>
jne    d1 <shell_quote+0x13>
callq  0 <init_sh_quoting_options>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    0x0(%rip),%rdx        # f0 <shell_quote+0x32>
mov    %rbx,%rdi
callq  f8 <shell_quote+0x3a>
pop    %rbx
retq   
<<<sep_in_sample>>>
shell_quote (const char *string)
{
  if (sh_quoting_options == ((void *)0))
    init_sh_quoting_options ();
  return quotearg_alloc (string, strlen (string), sh_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4ca <sys_detect_dev_null_output+0x7>
mov    (%rax),%rsi
mov    $0x0,%edi
mov    $0xa,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %al
mov    $0x1,%edx
cmp    %al,%cl
je     559 <sys_detect_dev_null_output+0x96>
mov    $0x0,%dl
cmpl   $0x3fffffff,0x0(%rip)        # 4f4 <sys_detect_dev_null_output+0x31>
jg     559 <sys_detect_dev_null_output+0x96>
mov    0x0(%rip),%eax        # 4fc <sys_detect_dev_null_output+0x39>
and    $0xf000,%eax
cmp    $0x2000,%eax
jne    559 <sys_detect_dev_null_output+0x96>
sub    $0x98,%rsp
mov    %rsp,%rsi
mov    $0x0,%edi
callq  51c <sys_detect_dev_null_output+0x59>
mov    $0x0,%edx
test   %eax,%eax
jne    544 <sys_detect_dev_null_output+0x81>
mov    (%rsp),%rax
cmp    %rax,0x0(%rip)        # 530 <sys_detect_dev_null_output+0x6d>
jne    544 <sys_detect_dev_null_output+0x81>
mov    0x8(%rsp),%rax
cmp    %rax,0x0(%rip)        # 53e <sys_detect_dev_null_output+0x7b>
sete   %dl
movzbl %dl,%edx
mov    %dl,0x0(%rip)        # 54a <sys_detect_dev_null_output+0x87>
andb   $0x1,0x0(%rip)        # 551 <sys_detect_dev_null_output+0x8e>
add    $0x98,%rsp
retq   
mov    %dl,0x0(%rip)        # 55f <sys_detect_dev_null_output+0x9c>
andb   $0x1,0x0(%rip)        # 566 <sys_detect_dev_null_output+0xa3>
retq   
<<<sep_in_sample>>>
sys_detect_dev_null_output (void)
{
  static char const dev_null[] = "/dev/null";
  struct stat dev_null_stat;
  dev_null_output = (strcmp (archive_name_array[0], dev_null) == 0
       || (! ((archive) >= (1 << 30))
    && ((((archive_stat.st_mode)) & 0170000) == (0020000))
    && stat (dev_null, &dev_null_stat) == 0
    && archive_stat.st_dev == dev_null_stat.st_dev
    && archive_stat.st_ino == dev_null_stat.st_ino));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 2
19 8
20 8
21 8
22 6
23 8
24 8
25 9
26 9
27 9
28 10
29 10
30 6
31 6
32 6
33 6
34 11
35 11
36 6
37 6
38 6
<<<sep_out_sample>>>
cmp    $0x3,%edi
jbe    e8 <cdio_is_discmode_cdrom+0xa>
cmp    $0x10,%edi
jne    ee <cdio_is_discmode_cdrom+0x10>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cdio_is_discmode_cdrom(discmode_t discmode)
{
  switch (discmode) {
  case CDIO_DISC_MODE_CD_DA:
  case CDIO_DISC_MODE_CD_DATA:
  case CDIO_DISC_MODE_CD_XA:
  case CDIO_DISC_MODE_CD_MIXED:
  case CDIO_DISC_MODE_NO_INFO:
    return 1;
  default:
    return 0;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 9
6 9
7 11
8 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     195 <osip_sem_trywait+0x10>
sub    $0x8,%rsp
callq  193 <osip_sem_trywait+0xe>
jmp    19b <osip_sem_trywait+0x16>
mov    $0xfffffffe,%eax
retq   
add    $0x8,%rsp
nop
retq   
<<<sep_in_sample>>>
osip_sem_trywait (struct osip_sem *_sem)
{
  osip_sem_t *sem = (osip_sem_t *) _sem;
  if (sem == ((void *)0))
    return -2;
  return sem_trywait (sem);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 5
7 5
8 7
9 7
10 7
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rax        # 1794 <env_opt_end+0x8>
mov    %rax,%rbx
sub    0x0(%rip),%rbx        # 179e <env_opt_end+0x12>
add    $0x2,%ebx
cmp    $0x6,%ebx
jg     17aa <env_opt_end+0x1e>
test   %edi,%edi
je     1812 <env_opt_end+0x86>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 17b5 <env_opt_end+0x29>
movb   $0xff,(%rax)
mov    0x0(%rip),%rax        # 17bf <env_opt_end+0x33>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 17ca <env_opt_end+0x3e>
movb   $0xf0,(%rax)
mov    $0x0,%edi
callq  17d7 <env_opt_end+0x4b>
cmp    %eax,%ebx
jge    1808 <env_opt_end+0x7c>
mov    %ebx,%edx
mov    0x0(%rip),%rsi        # 17e4 <env_opt_end+0x58>
mov    $0x0,%edi
callq  17ee <env_opt_end+0x62>
lea    -0x2(%rbx),%edx
mov    0x0(%rip),%rax        # 17f8 <env_opt_end+0x6c>
lea    0x2(%rax),%rsi
mov    $0x3e,%edi
callq  1806 <env_opt_end+0x7a>
jmp    1812 <env_opt_end+0x86>
mov    $0x0,%edi
callq  1812 <env_opt_end+0x86>
mov    0x0(%rip),%rdi        # 1819 <env_opt_end+0x8d>
test   %rdi,%rdi
je     1844 <env_opt_end+0xb8>
callq  1823 <env_opt_end+0x97>
movq   $0x0,0x0(%rip)        # 182e <env_opt_end+0xa2>
movq   $0x0,0x0(%rip)        # 1839 <env_opt_end+0xad>
movq   $0x0,0x0(%rip)        # 1844 <env_opt_end+0xb8>
pop    %rbx
retq   
<<<sep_in_sample>>>
env_opt_end (register int emptyok)
{
  register int len;
  len = opt_replyp - opt_reply + 2;
  if (emptyok || len > 6)
    {
      *opt_replyp++ = 255;
      *opt_replyp++ = 240;
      if ((ring_empty_count(&netoring)) > len)
 {
   ring_supply_data (&netoring, opt_reply, len);
   printsub ('>', &opt_reply[2], len - 2);
 }
      else
 printf ("slc_end_reply: not enough room\n");
    }
  if (opt_reply)
    {
      free (opt_reply);
      opt_reply = opt_replyp = opt_replyend = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 12
29 12
30 12
31 15
32 15
33 17
34 17
35 17
36 19
37 20
38 20
39 20
40 22
41 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rcx,%rcx
jne    1db2 <gsl_vector_char_const_view_array_with_stride+0x47>
mov    $0x4,%cl
mov    $0x37,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d8a <gsl_vector_char_const_view_array_with_stride+0x1f>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    1e0f <gsl_vector_char_const_view_array_with_stride+0xa4>
test   %rdx,%rdx
jne    1df5 <gsl_vector_char_const_view_array_with_stride+0x8a>
mov    $0x4,%ecx
mov    $0x3d,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  1dcd <gsl_vector_char_const_view_array_with_stride+0x62>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    1e0f <gsl_vector_char_const_view_array_with_stride+0xa4>
mov    %rcx,(%rdi)
mov    %rdx,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_char_const_view_array_with_stride (const char * base,
                                              size_t stride,
                                              size_t n)
{
  _gsl_vector_char_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 55
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  if (stride == 0)
    {
      do { gsl_error ("stride must be positive integer",
 "view_source.c"
      ,
 61
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = (char *)base ;
    v.size = n;
    v.stride = stride;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 12
11 12
12 12
13 12
14 12
15 12
16 15
17 15
18 17
19 17
20 17
21 17
22 17
23 21
24 21
25 21
26 21
27 21
28 21
29 32
30 32
31 32
32 32
33 32
34 34
35 34
36 34
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_size (const gsl_block * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0xffffffffffffffff,%rbp
mov    $0xfffffffffffffffe,%r14
jmp    2da3 <fetch_number+0x29>
mov    %r14,%rbp
jmp    2da3 <fetch_number+0x29>
mov    %r14,%rbp
mov    %r12,%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  2d58 <fetch_token>
movzbl (%rbx),%eax
movzbl 0x8(%rbx),%ecx
cmp    $0x2,%cl
je     2e04 <fetch_number+0x8a>
cmp    $0x18,%cl
je     2e0d <fetch_number+0x93>
cmp    $0x2c,%al
je     2e12 <fetch_number+0x98>
cmp    $0x1,%cl
jne    2d9b <fetch_number+0x21>
lea    -0x30(%rax),%edx
cmp    $0x9,%dl
ja     2da0 <fetch_number+0x26>
cmp    $0xfffffffffffffffe,%rbp
je     2da3 <fetch_number+0x29>
cmp    $0xffffffffffffffff,%rbp
jne    2dea <fetch_number+0x70>
movzbl %al,%ebp
sub    $0x30,%ebp
movslq %ebp,%rbp
jmp    2df7 <fetch_number+0x7d>
lea    0x0(%rbp,%rbp,4),%rdx
movzbl %al,%eax
lea    -0x30(%rax,%rdx,2),%rbp
cmp    $0x8000,%rbp
cmovae %r14,%rbp
jmp    2da3 <fetch_number+0x29>
mov    $0xfffffffffffffffe,%rax
jmp    2e15 <fetch_number+0x9b>
mov    %rbp,%rax
jmp    2e15 <fetch_number+0x9b>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
fetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)
{
  Idx num = ((Idx) -1);
  unsigned char c;
  while (1)
    {
      fetch_token (token, input, syntax);
      c = token->opr.c;
      if (__builtin_expect (token->type == END_OF_RE, 0))
 return ((Idx) -2);
      if (token->type == OP_CLOSE_DUP_NUM || c == ',')
 break;
      num = ((token->type != CHARACTER || c < '0' || '9' < c
       || num == ((Idx) -2))
      ? ((Idx) -2)
      : ((num == ((Idx) -1)) ? c - '0' : num * 10 + c - '0'));
      num = (num > (0x7fff)) ? ((Idx) -2) : num;
    }
  return num;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 17
11 17
12 17
13 17
14 17
15 7
16 7
17 7
18 7
19 8
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 16
28 16
29 13
30 13
31 13
32 14
33 14
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 17
44 17
45 17
46 10
47 10
48 10
49 10
50 10
51 20
52 20
53 20
54 20
55 20
56 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     73 <osip_message_set_proxy_authorization+0x73>
mov    %rdi,%rbp
mov    $0x0,%eax
cmpb   $0x0,(%rsi)
je     78 <osip_message_set_proxy_authorization+0x78>
lea    0x8(%rsp),%rdi
callq  25 <osip_message_set_proxy_authorization+0x25>
mov    %eax,%edx
test   %edx,%edx
jne    78 <osip_message_set_proxy_authorization+0x78>
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  38 <osip_message_set_proxy_authorization+0x38>
mov    %eax,%ebx
test   %eax,%eax
je     4c <osip_message_set_proxy_authorization+0x4c>
mov    0x8(%rsp),%rdi
callq  48 <osip_message_set_proxy_authorization+0x48>
mov    %ebx,%eax
jmp    78 <osip_message_set_proxy_authorization+0x78>
movl   $0x2,0x1a0(%rbp)
lea    0x128(%rbp),%rdi
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
callq  6c <osip_message_set_proxy_authorization+0x6c>
mov    $0x0,%eax
jmp    78 <osip_message_set_proxy_authorization+0x78>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_message_set_proxy_authorization (osip_message_t * sip, const char *hvalue)
{
  osip_proxy_authorization_t *proxy_authorization;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_authorization_init(&proxy_authorization);
  if (i != 0)
    return i;
  i = osip_authorization_parse(proxy_authorization, hvalue);
  if (i != 0) {
    osip_authorization_free (proxy_authorization);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->proxy_authorizations, proxy_authorization, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 5
10 5
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 10
20 11
21 11
22 12
23 12
24 13
25 13
26 15
27 16
28 16
29 16
30 16
31 17
32 17
33 6
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  2e <jpeg_get_large+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
  return (void *) malloc(sizeofobject);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    %esi,%r15d
mov    %edx,%r14d
mov    %ecx,0x1c(%rsp)
mov    %r8d,%r13d
mov    %r9d,%r12d
cmpl   $0x0,0x0(%rip)        # 28 <add_media+0x28>
jne    65 <add_media+0x65>
cmpl   $0x1,0x0(%rip)        # 31 <add_media+0x31>
jle    65 <add_media+0x65>
mov    0x60(%rsp),%eax
mov    %eax,0x10(%rsp)
mov    %r9d,0x8(%rsp)
mov    %r8d,(%rsp)
mov    %ecx,%r9d
mov    %edx,%r8d
mov    %esi,%ecx
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 5b <add_media+0x5b>
mov    $0x0,%eax
callq  65 <add_media+0x65>
mov    $0x28,%esi
mov    $0x1,%edi
callq  74 <add_media+0x74>
mov    %rax,%rbx
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  93 <add_media+0x93>
mov    %rax,0x8(%rbx)
mov    %rbp,%rsi
mov    %rax,%rdi
callq  a2 <add_media+0xa2>
mov    %r15d,0x10(%rbx)
mov    %r14d,0x14(%rbx)
mov    0x1c(%rsp),%eax
mov    %eax,0x18(%rbx)
mov    %r13d,0x1c(%rbx)
mov    %r12d,0x20(%rbx)
mov    0x60(%rsp),%eax
mov    %eax,0x24(%rbx)
mov    0x0(%rip),%rax        # c7 <add_media+0xc7>
mov    %rax,(%rbx)
mov    %rbx,0x0(%rip)        # d1 <add_media+0xd1>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
add_media (char *name, int w, int h, int llx, int lly, int urx, int ury)
{
  MediaEntry *entry;
  do { if (!quiet && verbose >= (2)) fprintf (stderr, "add_media: name=%s, w=%d, h=%d, llx=%d, lly=%d, urx=%d, ury=%d\n", name, w, h, llx, lly, urx, ury); } while (0)
                                     ;
  entry = xcalloc (1, sizeof (*entry));
  entry->name = xmalloc (strlen (name) + 1);
  strcpy (entry->name, name);
  entry->w = w;
  entry->h = h;
  entry->llx = llx;
  entry->lly = lly;
  entry->urx = urx;
  entry->ury = ury;
  entry->next = media_names;
  media_names = entry;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 6
31 6
32 6
33 6
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 8
43 8
44 8
45 9
46 10
47 11
48 11
49 12
50 13
51 14
52 14
53 15
54 15
55 16
56 17
57 17
58 17
59 17
60 17
61 17
62 17
63 17
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %edi,%r14d
mov    %esi,%r12d
mov    %rdx,%r13
mov    %ecx,%ebp
mov    %r8,%rbx
test   %r8,%r8
jne    2d33 <uinfile_opendup_with_name+0x26>
callq  2d31 <uinfile_opendup_with_name+0x24>
jmp    2d62 <uinfile_opendup_with_name+0x55>
mov    $0x3,%esi
mov    %ecx,%edi
callq  2d3f <uinfile_opendup_with_name+0x32>
mov    %rbx,0x8(%rsp)
mov    %eax,(%rsp)
mov    %r14d,%r9d
mov    %ebp,%r8d
mov    %r13,%rcx
mov    %r12d,%edx
mov    $0xffffffff,%esi
mov    $0x0,%edi
callq  955 <uinfile_i_open>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
uinfile_opendup_with_name(int xdupfd, mode_t mode, UINFORMAT ** uinformat, int oflags, char * name)
{
 int ret;
 int buftype;
 ;
 if (name == ((void *)0))
  return uinfile_opendup(xdupfd, mode, uinformat, oflags);
 buftype = uinfile_decode_buftype(oflags, 3);
 ret = uinfile_i_open((char *)((void *)0), -1, mode,
    uinformat, oflags, xdupfd, buftype, name);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 6
13 6
14 7
15 7
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 12
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 34d <yy_fatal_error+0x13>
mov    $0x0,%eax
callq  357 <yy_fatal_error+0x1d>
mov    $0x2,%edi
callq  361 <full_write>
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %ecx,%r12d
cmp    %edx,%esi
jne    bfa <_sse_addr_f+0x26>
mov    %ecx,%r8d
mov    %esi,%ecx
mov    $0x58,%edx
mov    $0xf3,%esi
callq  9d0 <_ssexr>
jmp    c30 <_sse_addr_f+0x5c>
cmp    %ecx,%esi
jne    c14 <_sse_addr_f+0x40>
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x58,%edx
mov    $0xf3,%esi
callq  9d0 <_ssexr>
jmp    c30 <_sse_addr_f+0x5c>
callq  bba <_sse_movr_f>
mov    %r12d,%r8d
mov    %ebx,%ecx
mov    $0x58,%edx
mov    $0xf3,%esi
mov    %rbp,%rdi
callq  9d0 <_ssexr>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_sse_addr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf3,0x58,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf3,0x58,r0,r1);
    else {
 _sse_movr_f(_jit,r0,r1);
 _ssexr(_jit,0xf3,0x58,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffff9c,%edi
je     e <careadlinkatcwd+0xe>
callq  e <careadlinkatcwd+0xe>
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rax,%rdi
callq  1f <careadlinkatcwd+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
careadlinkatcwd (int fd, char const *filename, char *buffer,
                 size_t buffer_size)
{
  if (fd != -100)
    abort ();
  return readlink (filename, buffer, buffer_size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    %rdi,%rcx
mov    $0x22,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1c27 <WriteCalcJacob+0x24>
mov    %rbx,%rcx
mov    $0x36,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1c3e <WriteCalcJacob+0x3b>
mov    %rbx,%rcx
mov    $0x2e,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1c55 <WriteCalcJacob+0x52>
mov    %rbx,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1c6c <WriteCalcJacob+0x69>
mov    $0x0,%r8d
mov    $0x70000,%ecx
mov    $0x0,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1c87 <WriteCalcJacob+0x84>
mov    $0x6,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1ca2 <WriteCalcJacob+0x9f>
mov    %rbx,%rcx
mov    $0x15,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1cb9 <WriteCalcJacob+0xb6>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
WriteCalcJacob (PFILE pfile, PVMMAPSTRCT pvmGlo, PVMMAPSTRCT pvmJacob)
{
  fprintf (pfile, "/*----- Jacobian calculations */\n\n");
  fprintf (pfile, "void CalcJacob (PDOUBLE pdTime, double rgModelVars[],\n");
  fprintf (pfile, "                long column, double rgdJac[])\n");
  fprintf (pfile, "{\n");
  ForAllVar (pfile, pvmGlo, &WriteOneDecl, 0x70000, ((void *)0));
  ForAllVar (pfile, pvmJacob, &WriteOneEquation, (0), (PVOID) 6);
  fprintf (pfile, "\n} /* CalcJacob */\n\n\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 8
36 8
37 8
38 8
39 9
40 9
41 9
42 9
43 9
44 10
45 10
46 10
47 10
<<<sep_out_sample>>>
mov    0x230(%rdi),%rax
cmpl   $0x1,0x1b0(%rdi)
jle    19 <start_iMCU_row+0x19>
movl   $0x1,0x30(%rax)
jmp    46 <start_iMCU_row+0x46>
mov    0x1a4(%rdi),%ecx
lea    -0x1(%rcx),%edx
cmp    %edx,0xb0(%rdi)
jae    39 <start_iMCU_row+0x39>
mov    0x1b8(%rdi),%rdx
mov    0xc(%rdx),%edx
mov    %edx,0x30(%rax)
jmp    46 <start_iMCU_row+0x46>
mov    0x1b8(%rdi),%rdx
mov    0x48(%rdx),%edx
mov    %edx,0x30(%rax)
movl   $0x0,0x28(%rax)
movl   $0x0,0x2c(%rax)
retq   
<<<sep_in_sample>>>
start_iMCU_row (j_decompress_ptr cinfo)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }
  coef->MCU_ctr = 0;
  coef->MCU_vert_offset = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 7
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 10
15 10
16 10
17 12
18 13
19 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
cmpl   $0x2,(%rdi)
je     259 <value_to_array+0x3e>
mov    $0x8,%esi
mov    $0x1,%edi
callq  238 <value_to_array+0x1d>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  243 <value_to_array+0x28>
mov    %rax,0x0(%rbp)
movl   $0x2,(%rbx)
movq   $0x1,0x28(%rbx)
mov    %rbp,0x30(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
value_to_array(struct grecs_value *val)
{
 if (val->type == 2)
  return;
 else {
  struct grecs_value **vp;
  vp = grecs_calloc(1, sizeof(*vp));
  vp[0] = grecs_value_ptr_from_static(val);
  val->type = 2;
  val->v.arg.c = 1;
  val->v.arg.v = vp;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 9
15 10
16 11
17 13
18 13
19 13
20 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
mov    $0xa1,%edx
mov    $0x0,%esi
callq  53 <free_alias_data+0x17>
mov    $0xa2,%edx
mov    $0x0,%esi
mov    (%rbx),%rdi
callq  65 <free_alias_data+0x29>
mov    $0xa3,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  77 <free_alias_data+0x3b>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_alias_data (data)
     void * data;
{
  register alias_t *a;
  a = (alias_t *)data;
  sh_xfree((a->value), "alias.c", 161);
  sh_xfree((a->name), "alias.c", 162);
  sh_xfree((data), "alias.c", 163);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 9
16 9