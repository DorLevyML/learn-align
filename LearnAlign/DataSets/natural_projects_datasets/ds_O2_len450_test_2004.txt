mov    0x8(%rdi),%r9
mov    (%rdi),%r8
mov    0x10(%rdi),%r10
test   %r9,%r9
je     296 <gsl_combination_prev+0xb6>
mov    %r9,%rax
sub    $0x1,%rax
je     245 <gsl_combination_prev+0x65>
lea    0x0(,%rax,8),%rcx
lea    (%r10,%rcx,1),%rdx
mov    -0x8(%r10,%rcx,1),%rcx
mov    (%rdx),%rsi
add    $0x1,%rcx
cmp    %rcx,%rsi
jne    290 <gsl_combination_prev+0xb0>
lea    -0x10(%r10,%r9,8),%rcx
jmp    23f <gsl_combination_prev+0x5f>
nopl   0x0(%rax)
mov    %rcx,%rdx
mov    (%rcx),%rsi
lea    -0x8(%rcx),%rcx
mov    -0x8(%rdx),%rdi
add    $0x1,%rdi
cmp    %rdi,%rsi
jne    290 <gsl_combination_prev+0xb0>
sub    $0x1,%rax
jne    228 <gsl_combination_prev+0x48>
mov    (%r10),%rsi
test   %rsi,%rsi
je     296 <gsl_combination_prev+0xb6>
mov    %r10,%rdx
mov    $0x1,%eax
sub    $0x1,%rsi
cmp    %rax,%r9
mov    %rsi,(%rdx)
jbe    285 <gsl_combination_prev+0xa5>
mov    %r8,%rdx
sub    %r9,%rdx
add    %rdx,%rax
neg    %rdx
lea    (%r10,%rdx,8),%rdx
nopl   0x0(%rax)
mov    %rax,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r8,%rax
jne    278 <gsl_combination_prev+0x98>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
jmp    255 <gsl_combination_prev+0x75>
mov    $0xffffffff,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_combination_prev (gsl_combination * c)
{
  const size_t n = c->n;
  const size_t k = c->k;
  size_t *data = c->data;
  size_t i;
  if(k == 0)
    {
      return GSL_FAILURE;
    }
  i = k - 1;
  while(i > 0 && data[i] == data[i-1] + 1)
    {
      i--;
    }
  if(i == 0 && data[i] == 0)
    {
      return GSL_FAILURE;
    }
  data[i++]--;
  for(; i < k; i++)
    {
      data[i] = n - k + i;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 7
5 7
6 12
7 12
8 12
9 12
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 20
34 21
35 20
36 21
37 21
38 21
39 21
40 21
41 21
42 21
43 23
44 23
45 21
46 21
47 25
48 25
49 25
50 25
51 25
52 9
53 9
54 9
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     7b0 <gsasl_server_callback_cipher_get+0x10>
mov    0xd0(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_cipher_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cipher : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
xor    %edx,%edx
mov    %rdi,%rbx
sub    $0x10,%rsp
cmpq   $0xf,0x0(%rip)        # 22 <send_echo+0x12>
ja     68 <send_echo+0x58>
mov    0x0(%rip),%rsi        # 2b <send_echo+0x1b>
test   %rsi,%rsi
je     4f <send_echo+0x3f>
mov    0x0(%rip),%rax        # 37 <send_echo+0x27>
mov    %rbx,%rdi
mov    %rax,%rcx
sub    %rdx,%rcx
cmp    %rax,%rdx
cmovae %rax,%rcx
xor    %r8d,%r8d
callq  4f <send_echo+0x3f>
mov    %rbx,%rdi
callq  57 <send_echo+0x47>
test   %eax,%eax
mov    %eax,%ebx
js     90 <send_echo+0x80>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %esi,%esi
mov    %rsp,%rdi
callq  72 <send_echo+0x62>
xor    %edx,%edx
xor    %r8d,%r8d
mov    $0x10,%ecx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  87 <send_echo+0x77>
mov    $0x10,%edx
jmp    24 <send_echo+0x14>
xchg   %ax,%ax
callq  95 <send_echo+0x85>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
mov    $0x1,%edi
callq  a8 <send_echo+0x98>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
send_echo (PING * ping)
{
  size_t off = 0;
  int rc;
  if (((data_length) >= sizeof (struct timeval)))
    {
      struct timeval tv;
      gettimeofday (&tv, ((void *)0));
      ping_set_data (ping, &tv, 0, sizeof (tv), 0);
      off += sizeof (tv);
    }
  if (data_buffer)
    ping_set_data (ping, data_buffer, off,
     data_length > off ? data_length - off : data_length,
     0);
  rc = ping_xmit (ping);
  if (rc < 0)
    error (1, (*__errno_location ()), "sending packet");
  return rc;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 5
6 5
7 12
8 12
9 12
10 14
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 16
19 16
20 17
21 16
22 17
23 20
24 20
25 20
26 20
27 20
28 8
29 8
30 8
31 9
32 9
33 9
34 9
35 9
36 9
37 10
38 10
39 10
40 18
41 18
42 18
43 18
44 18
45 18
46 20
47 20
48 20
49 20
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
cmpq   $0x0,0x40(%rdi)
je     86 <rec_sex_ast_node_destroy+0x26>
mov    0x28(%rbp,%rbx,8),%rdi
add    $0x1,%rbx
callq  80 <rec_sex_ast_node_destroy+0x20>
cmp    %rbx,0x40(%rbp)
ja     72 <rec_sex_ast_node_destroy+0x12>
mov    0x0(%rbp),%eax
cmp    $0x1a,%eax
je     c8 <rec_sex_ast_node_destroy+0x68>
cmp    $0x1b,%eax
je     b0 <rec_sex_ast_node_destroy+0x50>
mov    0x20(%rbp),%rdi
callq  9c <rec_sex_ast_node_destroy+0x3c>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   aa <rec_sex_ast_node_destroy+0x4a>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdi
callq  b9 <rec_sex_ast_node_destroy+0x59>
mov    0x10(%rbp),%rdi
callq  c2 <rec_sex_ast_node_destroy+0x62>
jmp    93 <rec_sex_ast_node_destroy+0x33>
nopl   0x0(%rax)
mov    0x8(%rbp),%rdi
callq  d1 <rec_sex_ast_node_destroy+0x71>
jmp    93 <rec_sex_ast_node_destroy+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_destroy (rec_sex_ast_node_t node)
{
  size_t i;
  for (i = 0; i < node->num_children; i++)
    {
      rec_sex_ast_node_destroy (node->children[i]);
    }
  if (node->type == REC_SEX_STR)
    {
      free (node->val.string);
    }
  else if (node->type == REC_SEX_NAME)
    {
      free (node->val.name[0]);
      free (node->val.name[1]);
    }
  free (node->fixed_val);
  free (node);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 6
9 4
10 6
11 4
12 4
13 8
14 8
15 8
16 12
17 12
18 17
19 17
20 19
21 18
22 19
23 19
24 18
25 18
26 14
27 14
28 15
29 15
30 15
31 15
32 10
33 10
34 10
35 10
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
sub    $0x18,%rsp
xorpd  %xmm0,%xmm0
ucomisd %xmm1,%xmm0
ja     38 <gsl_multimin_test_gradient+0x38>
movsd  %xmm1,0x8(%rsp)
callq  1d <gsl_multimin_test_gradient+0x1d>
movsd  0x8(%rsp),%xmm1
xor    %eax,%eax
ucomisd %xmm0,%xmm1
seta   %al
add    $0x18,%rsp
lea    -0x2(%rax,%rax,1),%eax
retq   
nopl   (%rax)
mov    $0xd,%ecx
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  51 <gsl_multimin_test_gradient+0x51>
mov    $0xd,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_test_gradient (const gsl_vector *g, double epsabs)
{
  double norm;
  if (epsabs < 0.0)
    {
      do { gsl_error ("absolute tolerance is negative", "convergence.c", 31, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
    }
  norm = gsl_blas_dnrm2(g);
  if (norm < epsabs)
    {
      return GSL_SUCCESS;
    }
  return GSL_CONTINUE;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 8
8 13
9 13
10 13
11 13
12 14
13 13
14 14
15 14
16 6
17 6
18 6
19 6
20 6
21 6
22 14
23 14
24 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1349 <config_parse+0x9>
test   %rax,%rax
je     1364 <config_parse+0x24>
mov    $0x0,%esi
mov    %rax,%rdi
callq  135b <config_parse+0x1b>
test   %eax,%eax
jne    1364 <config_parse+0x24>
add    $0x8,%rsp
retq   
mov    $0x1,%edi
callq  136e <config_parse+0x2e>
<<<sep_in_sample>>>
config_parse(char const *conffile)
{
 struct grecs_node *tree;
 tree = grecs_parse(conffile);
 if (!tree)
  exit(1);
 if (grecs_tree_process(tree, direvent_kw))
  exit(1);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 6
13 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  5de <sh_notbuiltin+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   5ec <sh_notbuiltin+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_notbuiltin (s)
     char *s;
{
  builtin_error (gettext("%s: not a shell builtin"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swverid_get_object_name(SWVERID * swverid)
{
 return swverid->object_nameM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%ecx
mov    $0xffffffff,%edx
mov    %rsi,%rbx
callq  4b33 <newer+0x13>
test   %eax,%eax
jne    4b40 <newer+0x20>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x8(%rbx),%rdx
mov    0x10(%rbx),%rsi
mov    $0x0,%edi
pop    %rbx
xor    %eax,%eax
jmpq   4b55 <newer+0x35>
<<<sep_in_sample>>>
newer (int argc, char **argv)
{
  if (getit (argc, argv, -1, "w"))
    printf ("Local file \"%s\" is newer than remote file \"%s\"\n",
     argv[2], argv[1]);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 3
7 3
8 6
9 6
10 6
11 4
12 4
13 4
14 6
15 4
16 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4c56 <info_scroll_forward+0x6>
test   %eax,%eax
jne    4c67 <info_scroll_forward+0x17>
mov    0x0(%rip),%eax        # 4c60 <info_scroll_forward+0x10>
test   %eax,%eax
jle    4c70 <info_scroll_forward+0x20>
imul   %eax,%esi
xor    %edx,%edx
jmpq   4bd0 <_scroll_forward>
xchg   %ax,%ax
mov    0x18(%rdi),%rax
sub    $0x2,%rax
jmp    4c64 <info_scroll_forward+0x14>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_scroll_forward (WINDOW *window, int count)
{
  int lines;
  if (info_explicit_arg)
    lines = count;
  else if (default_window_size > 0)
    lines = default_window_size * count;
  else
    lines = (window->height - 2) * count;
  _scroll_forward (window, lines, 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 9
8 10
9 10
10 10
11 9
12 9
13 9
14 9
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 2727 <c_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_set_out (FILE * out_str )
{
        c_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     10 <pop_is_updated+0x10>
mov    0x78(%rax),%eax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pop_is_updated (mu_mailbox_t mbox)
{
  pop_data_t mpd = mbox->data;
  if (mpd == ((void *)0))
    return 0;
  return mpd->is_updated;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 6
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  6b3 <seek_error_details+0x23>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 6bc <seek_error_details+0x2c>
test   %rax,%rax
je     6c3 <seek_error_details+0x33>
callq  *%rax
mov    %rsp,%rsi
mov    %r12,%rdi
callq  6ce <seek_error_details+0x3e>
mov    %rbp,%rdi
mov    %rax,%r12
callq  6d9 <seek_error_details+0x49>
mov    $0x0,%edi
mov    %rax,%rbp
callq  6e6 <seek_error_details+0x56>
xor    %edi,%edi
mov    %rax,%rdx
mov    %r12,%r8
xor    %eax,%eax
mov    %rbp,%rcx
mov    %ebx,%esi
callq  6fa <seek_error_details+0x6a>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
movl   $0x2,0x0(%rip)        # 712 <seek_error_details+0x82>
jne    71d <seek_error_details+0x8d>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  722 <seek_error_details+0x92>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
seek_error_details (char const *name, off_t offset)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot seek to %s"), quotearg_colon (name), umaxtostr (offset, buf)); exit_status = 2; } while (0)
                                   ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 5
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0x1,%edx
jmpq   1fcd <info_read_completing_in_echo_area_with_exclusions+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
info_read_completing_in_echo_area_with_exclusions (const char *prompt,
     REFERENCE **completions, reference_bool_fn exclude)
{
  return info_read_completing_internal (prompt, completions, 1, exclude);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
lea    0x1c(%rsp),%rdi
fstpt  (%rsp)
callq  31 <printf_frexpl+0x31>
mov    0x1c(%rsp),%edx
fadd   %st(0),%st
lea    -0x1(%rdx),%eax
cmp    $0xffffc002,%eax
mov    %eax,0x1c(%rsp)
jge    58 <printf_frexpl+0x58>
fstpt  (%rsp)
lea    0x3ffd(%rdx),%edi
callq  53 <printf_frexpl+0x53>
mov    $0xffffc002,%eax
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 7
17 8
18 9
19 8
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 17
29 17
30 17
31 17
<<<sep_out_sample>>>
mov    (%rdi),%rcx
movabs $0x41a705af1fe3fb79,%rdx
mov    %rcx,%rax
mul    %rdx
shr    $0xf,%rdx
imul   $0xfffffffffffe0ce3,%rdx,%rax
imul   $0xfffffffffffff4ec,%rdx,%rdx
add    %rax,%rcx
imul   $0x41a7,%rcx,%rcx
add    %rcx,%rdx
js     50 <ran1_get+0x50>
mov    %rdx,(%rdi)
mov    0x8(%rdi),%rax
shr    $0x1a,%rax
lea    (%rdi,%rax,8),%rcx
mov    0x10(%rcx),%rax
mov    %rax,0x8(%rdi)
mov    %rdx,0x10(%rcx)
retq   
add    $0x7fffffff,%rdx
mov    %rdx,(%rdi)
jmp    37 <ran1_get+0x37>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ran1_get (void *vstate)
{
  ran1_state_t *state = (ran1_state_t *) vstate;
  const unsigned long int x = state->x;
  const long int h = x / q;
  const long int t = a * (x - h * q) - h * r;
  if (t < 0)
    {
      state->x = t + m;
    }
  else
    {
      state->x = t;
    }
  {
    unsigned long int j = state->n / (1 + 2147483646/32);
    state->n = state->shuffle[j];
    state->shuffle[j] = state->x;
  }
  return state->n;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 6
7 6
8 6
9 6
10 7
11 7
12 13
13 16
14 16
15 16
16 17
17 17
18 18
19 21
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    $0x8,%esi
jmpq   2da <mu_attribute_set_draft+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_set_draft (mu_attribute_t attr)
{
  return mu_attribute_set_flags (attr, 0x08);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
subq   $0x1,0x40(%rdi)
cmp    $0xa,%sil
je     e8 <rec_parser_ungetc+0x68>
mov    (%rbx),%rsi
test   %rsi,%rsi
je     c0 <rec_parser_ungetc+0x40>
mov    %ebp,%edi
callq  a5 <rec_parser_ungetc+0x25>
cmp    %ebp,%eax
je     b2 <rec_parser_ungetc+0x32>
movl   $0x2,0x34(%rbx)
mov    %eax,%ebp
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rax
test   %rax,%rax
je     105 <rec_parser_ungetc+0x85>
mov    0x18(%rbx),%rdx
cmp    %rdx,%rax
jae    f0 <rec_parser_ungetc+0x70>
sub    $0x1,%rdx
mov    %ebp,%eax
mov    %rdx,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
subq   $0x1,0x38(%rdi)
jmp    96 <rec_parser_ungetc+0x16>
nop
movl   $0x2,0x34(%rbx)
add    $0x8,%rsp
mov    $0xffffffff,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
mov    0x0(%rip),%rdi        # 10c <rec_parser_ungetc+0x8c>
mov    $0x0,%esi
xor    %eax,%eax
or     $0xffffffff,%ebp
callq  11b <rec_parser_ungetc+0x9b>
jmp    b2 <rec_parser_ungetc+0x32>
nopl   (%rax)
<<<sep_in_sample>>>
rec_parser_ungetc (rec_parser_t parser,
                   int ci)
{
  int res;
  parser->character--;
  if (((char) ci) == '\n')
    {
      parser->line--;
    }
  if (parser->in_file)
    {
      res = ungetc (ci, parser->in_file);
      if (res != ci)
        {
          parser->error = REC_PARSER_EUNGETC;
        }
    }
  else if (parser->in_buffer)
    {
      if (parser->p > parser->in_buffer)
        {
          res = ci;
          parser->p--;
        }
      else
        {
          res = (-1);
          parser->error = REC_PARSER_EUNGETC;
        }
    }
  else
    {
      rpl_fprintf (stderr, "rec_parser_ungetc: no backend in parser. This is a bug.  Please report it.");
      return (-1);
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 10
10 10
11 10
12 12
13 12
14 13
15 13
16 15
17 15
18 37
19 37
20 37
21 37
22 37
23 37
24 18
25 18
26 18
27 20
28 20
29 20
30 23
31 37
32 23
33 37
34 37
35 37
36 37
37 37
38 8
39 8
40 8
41 28
42 37
43 27
44 37
45 37
46 37
47 37
48 33
49 33
50 33
51 33
52 33
53 33
54 33
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
mov    %ecx,%edx
mov    %r8d,%ecx
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %r8d,%ebp
push   %rbx
sub    $0x8,%rsp
callq  24d <swdef_write_attribute_to_buffer+0x1d>
cmp    $0x4f,%ebp
mov    %eax,%ebx
je     265 <swdef_write_attribute_to_buffer+0x35>
mov    %r13,%rsi
mov    %r12,%rdi
callq  25f <swdef_write_attribute_to_buffer+0x2f>
test   %eax,%eax
js     272 <swdef_write_attribute_to_buffer+0x42>
add    %eax,%ebx
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0xffffffff,%ebx
jmp    265 <swdef_write_attribute_to_buffer+0x35>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swdef_write_attribute_to_buffer(STROB * buf, char *keyword, char *value, int level, int attribute_type)
{
 int iret, ret;
 ret = swdef_write_keyword_to_buffer(buf, keyword, level, attribute_type);
 if (attribute_type != 'O') {
  iret = swdef_write_value_to_buffer(buf, value);
  if (iret < 0)
   return -1;
  ret += iret;
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 5
13 4
14 5
15 6
16 6
17 6
18 7
19 7
20 9
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 8
29 8
30 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     2c0 <user_mailbox_name+0x20>
add    $0x8,%rsp
mov    %rdi,%rsi
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   2bf <user_mailbox_name+0x1f>
nop
mov    $0x0,%edi
callq  2ca <user_mailbox_name+0x2a>
test   %rax,%rax
je     330 <user_mailbox_name+0x90>
mov    $0x0,%edi
callq  2d9 <user_mailbox_name+0x39>
mov    %rax,%rdi
test   %rdi,%rdi
jne    2ae <user_mailbox_name+0xe>
callq  2e6 <user_mailbox_name+0x46>
mov    %eax,%edi
callq  2ed <user_mailbox_name+0x4d>
test   %rax,%rax
mov    %rax,%rbp
je     318 <user_mailbox_name+0x78>
mov    0x38(%rax),%rdi
callq  2fe <user_mailbox_name+0x5e>
mov    %rbp,%rdi
mov    %rax,(%rbx)
callq  309 <user_mailbox_name+0x69>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
xor    %eax,%eax
callq  324 <user_mailbox_name+0x84>
mov    $0x16,%eax
jmp    30b <user_mailbox_name+0x6b>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  33a <user_mailbox_name+0x9a>
mov    %rax,%rdi
jmp    2dc <user_mailbox_name+0x3c>
nop
<<<sep_in_sample>>>
user_mailbox_name (const char *user, char **mailbox_name)
{
  if (!user)
    user = (getenv ("LOGNAME")) ? getenv ("LOGNAME") : getenv ("USER");
  if (user)
    {
      int rc = mu_construct_user_mailbox_url (mailbox_name, user);
      if (rc)
 return rc;
    }
  else
    {
      struct mu_auth_data *auth = mu_get_auth_by_uid (getuid ());
      if (!auth)
        {
          mu_error ("Who am I?");
          return 22;
        }
      *mailbox_name = strdup (auth->mailbox);
      mu_auth_data_free (auth);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 23
8 7
9 7
10 23
11 23
12 7
13 7
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 13
24 13
25 13
26 14
27 13
28 14
29 19
30 19
31 20
32 19
33 20
34 22
35 23
36 23
37 23
38 23
39 23
40 16
41 16
42 16
43 17
44 17
45 17
46 4
47 4
48 4
49 4
50 4
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movq   $0x0,0x20(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_tokenize_begin(struct dico_tokbuf *tb)
{
    memset(tb, 0, sizeof(*tb));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
movzbl (%rdi),%edx
mov    %rdi,%rax
testb  $0x6,0x0(%rdx,%rdx,1)
je     571 <next_token+0x21>
add    $0x1,%rax
movzbl (%rax),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
jne    560 <next_token+0x10>
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_token (const char *s)
{
  while ((((stopchar_map[(unsigned char)((*(s)))])&(((0x0002|0x0004)))) != 0)) ++(s);
  return (char *)s;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x0,%edi
callq  4aa <yy_grecserror+0x1a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecserror(char *s)
{
  grecs_error (&grecs_current_locus, 0, "%s", s);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     f39 <gsl_vector_uint_isneg+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x2,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%edi
cvtsi2sd %rdi,%xmm0
ucomisd %xmm1,%xmm0
jae    f3f <gsl_vector_uint_isneg+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    f20 <gsl_vector_uint_isneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_isneg (const gsl_vector_uint * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     930 <gsl_vector_uint_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  94f <gsl_vector_uint_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_uint_view_array ( unsigned int * base, size_t n)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = (unsigned int *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
jmpq   d5 <icmp_echo_decode+0x5>
<<<sep_in_sample>>>
icmp_echo_decode (unsigned char * buffer, size_t bufsize,
    struct ip **ipp, icmphdr_t ** icmpp)
{
  return icmp_generic_decode (buffer, bufsize, ipp, icmpp);
}
<<<sep_in_sample>>>
1 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%rdi
mov    %rdx,%rsi
shr    %rsi
je     a17 <gsl_vector_float_reverse+0x57>
lea    -0x4(,%rdx,4),%rdx
mov    %rdi,%r8
xor    %ecx,%ecx
neg    %r8
imul   %rdi,%rdx
shl    $0x2,%r8
shl    $0x2,%rdi
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
movss  (%rdx),%xmm0
add    $0x1,%rcx
movss  (%rax),%xmm1
movss  %xmm1,(%rdx)
add    %r8,%rdx
movss  %xmm0,(%rax)
add    %rdi,%rax
cmp    %rsi,%rcx
jne    9f8 <gsl_vector_float_reverse+0x38>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_reverse (gsl_vector_float * v)
{
  float * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          float tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 8
18 15
19 15
20 15
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  0 <domd5.constprop.0>
movb   $0x0,0x20(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
swlib_md5(int uxfio_fd, unsigned char *bindigest, int do_ascii) {
    int ret;
    ret = domd5(uxfio_fd, bindigest, do_ascii, 0);
    bindigest[32] = '\0';
    return ret;
}
<<<sep_in_sample>>>
1 1
2 1
3 3
4 4
5 6
6 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2a98 <dispose_variable+0x78>
mov    0x28(%rdi),%esi
test   $0x20000,%esi
je     2a88 <dispose_variable+0x68>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2a4c <dispose_variable+0x2c>
mov    $0xd00,%edx
mov    $0x0,%esi
callq  2a4c <dispose_variable+0x2c>
mov    (%rbx),%rdi
mov    $0xd02,%edx
mov    $0x0,%esi
callq  2a5e <dispose_variable+0x3e>
testb  $0x1,0x28(%rbx)
je     2a6e <dispose_variable+0x4e>
movl   $0x1,0x0(%rip)        # 2a6e <dispose_variable+0x4e>
mov    %rbx,%rdi
mov    $0xd07,%edx
mov    $0x0,%esi
pop    %rbx
jmpq   2a81 <dispose_variable+0x61>
nopl   0x0(%rax)
mov    0x8(%rdi),%rdi
callq  b60 <dispose_variable_value.isra.3>
jmp    2a34 <dispose_variable+0x14>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dispose_variable (var)
     SHELL_VAR *var;
{
  if (var == 0)
    return;
  if (((((var)->attributes) & (0x0020000))) == 0)
    dispose_variable_value (var);
  do { if ((var)->exportstr) sh_xfree(((var)->exportstr), "variables.c", 3328); } while (0);
  sh_xfree((var->name), "variables.c", 3330);
  if (((((var)->attributes) & (0x0000001))))
    array_needs_making = 1;
  sh_xfree((var), "variables.c", 3335);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 9
15 9
16 9
17 9
18 10
19 10
20 11
21 12
22 12
23 12
24 13
25 12
26 12
27 7
28 7
29 7
30 7
31 13
32 13
33 13
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
jmpq   679 <gsl_cdf_gaussian_P+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_cdf_gaussian_P (const double x, const double sigma)
{
  return gsl_cdf_ugaussian_P (x / sigma);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%rbp
mov    0x18(%rdi),%rbx
test   %rbx,%rbx
je     42 <gl_tree_search+0x32>
test   %rbp,%rbp
je     50 <gl_tree_search+0x40>
mov    0x20(%rbx),%rdi
mov    %r12,%rsi
callq  *%rbp
test   %eax,%eax
js     68 <gl_tree_search+0x58>
je     58 <gl_tree_search+0x48>
mov    (%rbx),%rbx
test   %rbx,%rbx
xchg   %ax,%ax
jne    24 <gl_tree_search+0x14>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax)
cmp    0x20(%rbx),%r12
jb     38 <gl_tree_search+0x28>
ja     68 <gl_tree_search+0x58>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rbx
jmp    1f <gl_tree_search+0xf>
xchg   %ax,%ax
<<<sep_in_sample>>>
gl_tree_search (gl_oset_t set, const void *elt)
{
  gl_setelement_compar_fn compar = set->base.compar_fn;
  gl_oset_node_t node;
  for (node = set->root; node != ((void *)0); )
    {
      int cmp = (compar != ((void *)0)
                 ? compar (node->value, elt)
                 : (node->value > elt ? 1 :
                    node->value < elt ? -1 : 0));
      if (cmp < 0)
        node = node->right;
      else if (cmp > 0)
        node = node->left;
      else
        return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 5
9 9
10 9
11 9
12 9
13 9
14 11
15 11
16 13
17 14
18 5
19 5
20 5
21 19
22 19
23 18
24 19
25 19
26 19
27 9
28 9
29 10
30 19
31 19
32 16
33 19
34 19
35 19
36 12
37 12
38 12
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    0x0(%rip),%eax        # 8ba <NormalRandom+0xa>
movsd  %xmm0,0x10(%rsp)
movsd  %xmm1,0x18(%rsp)
test   %eax,%eax
jne    9e0 <NormalRandom+0x130>
cmpq   $0x0,0x0(%rip)        # 8d6 <NormalRandom+0x26>
jne    9b8 <NormalRandom+0x108>
nopl   0x0(%rax)
callq  8e5 <NormalRandom+0x35>
movapd %xmm0,%xmm2
addsd  %xmm0,%xmm2
subsd  0x0(%rip),%xmm2        # 8f5 <NormalRandom+0x45>
movsd  %xmm2,0x8(%rsp)
callq  900 <NormalRandom+0x50>
movapd %xmm0,%xmm1
movsd  0x8(%rsp),%xmm2
addsd  %xmm0,%xmm1
movapd %xmm2,%xmm3
mulsd  %xmm2,%xmm3
subsd  0x0(%rip),%xmm1        # 91e <NormalRandom+0x6e>
movapd %xmm1,%xmm0
mulsd  %xmm1,%xmm0
addsd  %xmm0,%xmm3
ucomisd 0x0(%rip),%xmm3        # 932 <NormalRandom+0x82>
jae    8e0 <NormalRandom+0x30>
xorpd  %xmm4,%xmm4
ucomisd %xmm4,%xmm3
jp     940 <NormalRandom+0x90>
je     8e0 <NormalRandom+0x30>
movapd %xmm3,%xmm0
movsd  %xmm1,0x28(%rsp)
movsd  %xmm2,0x20(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  95b <NormalRandom+0xab>
mulsd  0x0(%rip),%xmm0        # 963 <NormalRandom+0xb3>
movsd  0x8(%rsp),%xmm3
movsd  0x20(%rsp),%xmm2
movsd  0x28(%rsp),%xmm1
divsd  %xmm3,%xmm0
sqrtsd %xmm0,%xmm3
ucomisd %xmm3,%xmm3
jp     9f7 <NormalRandom+0x147>
movapd %xmm1,%xmm0
mulsd  %xmm3,%xmm2
movq   $0x1,0x0(%rip)        # 996 <NormalRandom+0xe6>
mulsd  %xmm3,%xmm0
movsd  %xmm2,0x0(%rip)        # 9a2 <NormalRandom+0xf2>
mulsd  0x18(%rsp),%xmm0
addsd  0x10(%rsp),%xmm0
add    $0x38,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movsd  0x18(%rsp),%xmm0
movq   $0x0,0x0(%rip)        # 9c9 <NormalRandom+0x119>
mulsd  0x0(%rip),%xmm0        # 9d1 <NormalRandom+0x121>
addsd  0x10(%rsp),%xmm0
add    $0x38,%rsp
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm0        # 9e8 <NormalRandom+0x138>
mov    $0x1,%edi
callq  9f2 <NormalRandom+0x142>
jmpq   8ce <NormalRandom+0x1e>
movsd  %xmm1,0x20(%rsp)
movsd  %xmm2,0x8(%rsp)
callq  a08 <NormalRandom+0x158>
movsd  0x20(%rsp),%xmm1
movapd %xmm0,%xmm3
movsd  0x8(%rsp),%xmm2
jmpq   983 <NormalRandom+0xd3>
nopl   (%rax)
<<<sep_in_sample>>>
NormalRandom (double dMean, double dStdDev)
{
  double dRacine, dTemp1, dTemp2, dTemp3;
  if (vbNotInitd)
    InitRandom (314159265.3589793, 1);
  if (vRandRec.switchG != 0) {
    vRandRec.switchG = 0;
    return (dMean + dStdDev * (vRandRec.memGauss));
  }
  do {
    dTemp1 = 2 * RandomShuffle () - 1;
    dTemp2 = 2 * RandomShuffle () - 1;
    dRacine = dTemp1 * dTemp1 + dTemp2 * dTemp2;
  } while ((dRacine >= 1) || (dRacine == 0));
  dTemp3 = sqrt(-2 * log(dRacine) / dRacine);
  vRandRec.memGauss = dTemp1 * dTemp3;
  vRandRec.switchG = 1;
  return (dMean + dStdDev * (dTemp2 * dTemp3));
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 12
16 12
17 13
18 12
19 13
20 13
21 12
22 13
23 13
24 13
25 14
26 14
27 14
28 14
29 14
30 14
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 18
45 16
46 17
47 18
48 16
49 18
50 18
51 19
52 19
53 19
54 8
55 7
56 8
57 8
58 19
59 19
60 19
61 5
62 5
63 5
64 5
65 5
66 5
67 15
68 15
69 15
70 15
71 15
72 15
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
movzbl %sil,%esi
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
mov    0x163c(%rdi,%rax,8),%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
get_track_preemphasis_image(const void *p_user_data, track_t i_track)
{
  const _img_private_t *p_env = p_user_data;
  return ( p_env->tocent[i_track-p_env->gen.i_first_track].flags
    & PRE_EMPHASIS ) ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <_free_group+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_free_group(void *item, void *data)
{
    free(item);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
movslq %esi,%rbx
sub    $0x18,%rsp
mov    0x18(%rdi),%rax
add    0x8(%rdi),%rbx
test   %rax,%rax
je     cb0 <PreventLexSplit+0x40>
cmpb   $0x0,(%rax)
je     cb0 <PreventLexSplit+0x40>
mov    %rbx,%rsi
nopl   0x0(%rax)
sub    $0x1,%rsi
cmpb   $0xa,(%rsi)
jne    c98 <PreventLexSplit+0x28>
movb   $0x0,(%rsi)
sub    %rbx,%rsi
jne    ce0 <PreventLexSplit+0x70>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     cca <PreventLexSplit+0x5a>
mov    %esi,0xc(%rsp)
callq  cc2 <PreventLexSplit+0x52>
test   %eax,%eax
mov    0xc(%rsp),%esi
je     c8e <PreventLexSplit+0x1e>
cmp    $0x1000,%esi
je     c8e <PreventLexSplit+0x1e>
movb   $0x0,(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rbp),%rdi
add    $0x18,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
jmpq   cf4 <PreventLexSplit+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
PreventLexSplit (PINPUTBUF pibIn, int iOffset)
{
  long lDelta;
  PBUF pbufEOB = pibIn->pbufOrg + iOffset;
  PBUF pbufEOBOld;
  if (!((!(pibIn)) || ((!(pibIn)->pbufCur || !*(pibIn)->pbufCur) && (!(pibIn)->pfileIn || feof((pibIn)->pfileIn))))
      || (iOffset == 0x1000)) {
    pbufEOBOld = pbufEOB;
    while (*(--pbufEOB) != ('\n'))
      ;
    *pbufEOB = '\0';
    if ((lDelta = (long) (pbufEOB - pbufEOBOld)))
      fseek (pibIn->pfileIn, lDelta, 1);
  }
  else
    *pbufEOB = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 6
7 4
8 6
9 6
10 6
11 6
12 4
13 4
14 9
15 9
16 9
17 11
18 12
19 12
20 17
21 17
22 17
23 17
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 16
35 17
36 17
37 17
38 17
39 17
40 13
41 17
42 13
43 17
44 17
45 13
46 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  489 <xstrdup+0x9>
test   %rax,%rax
je     493 <xstrdup+0x13>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  49d <xstrdup+0x1d>
xor    %esi,%esi
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
callq  4ab <xstrdup+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xstrdup (const char *ptr)
{
  char *result;
  result = strdup (ptr);
  if (result == 0)
    fatal((((floc *)0)), 0, (gettext ("virtual memory exhausted")));
  return result;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 8
6 8
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
eval_scheme_string_function (command)
     char *command;
{
  }
<<<sep_in_sample>>>
1 4
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  af <next_separator+0xf>
test   %rax,%rax
je     e0 <next_separator+0x40>
test   %r12d,%r12d
mov    %rax,%rbx
je     d8 <next_separator+0x38>
mov    %r12d,%esi
mov    %rbp,%rdi
callq  c7 <next_separator+0x27>
test   %rax,%rax
je     d8 <next_separator+0x38>
cmp    %rax,%rbx
mov    $0x0,%eax
cmovae %rax,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ebx,%ebx
jmp    d8 <next_separator+0x38>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_separator (const char *ch, int separator_osip_to_find, int before_separator)
{
  const char *ind;
  const char *tmp;
  ind = strchr (ch, separator_osip_to_find);
  if (ind == ((void *)0))
    return ((void *)0);
  tmp = ((void *)0);
  if (before_separator != 0)
    tmp = strchr (ch, before_separator);
  if (tmp != ((void *)0)) {
    if (ind < tmp)
      return ind;
  }
  else
    return ind;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 6
8 6
9 9
10 9
11 9
12 10
13 10
14 10
15 11
16 11
17 17
18 17
19 17
20 18
21 18
22 18
23 18
24 18
25 7
26 7
27 7
<<<sep_out_sample>>>
cmp    $0x0,%rdi
je     1f8 <get_line_node_addr+0x58>
mov    0x0(%rip),%rdx        # 1b0 <get_line_node_addr+0x10>
xor    %eax,%eax
cmp    $0x0,%rdx
jne    1cc <get_line_node_addr+0x2c>
jmp    1fb <get_line_node_addr+0x5b>
nopl   (%rax)
mov    (%rdx),%rdx
cmp    $0x0,%rdx
je     1e0 <get_line_node_addr+0x40>
add    $0x1,%eax
cmp    %rdx,%rdi
jne    1c0 <get_line_node_addr+0x20>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1ee <get_line_node_addr+0x4e>
mov    $0xffffffff,%eax
add    $0x8,%rsp
retq   
xor    %eax,%eax
retq   
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
get_line_node_addr( const line_t * const lp )
  {
  const line_t * p = &buffer_head;
  int addr = 0;
  while( p != lp && ( p = p->q_forw ) != &buffer_head ) ++addr;
  if( addr && p == &buffer_head )
    { set_error_msg( "Invalid address" ); return -1; }
  return addr;
  }
<<<sep_in_sample>>>
1 5
2 5
3 5
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 9
16 9
17 2
18 7
19 7
20 7
21 9
22 9
23 5
24 5
25 9
26 9
<<<sep_out_sample>>>
push   %rbp
mov    $0x1000,%edx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    %rbx,%rdi
sub    $0x1018,%rsp
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x1008(%rsp)
xor    %eax,%eax
callq  1a2 <histfile_restore+0x32>
test   %rax,%rax
jle    1d8 <histfile_restore+0x68>
mov    %rsp,%rsi
mov    %rbp,%rdi
movb   $0x0,(%rsp,%rax,1)
callq  1b6 <histfile_restore+0x46>
mov    0x1008(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1e5 <histfile_restore+0x75>
add    $0x1018,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1e3 <histfile_restore+0x73>
jmp    1b6 <histfile_restore+0x46>
callq  1ea <histfile_restore+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
histfile_restore (backup, orig)
     const char *backup;
     const char *orig;
{
  char linkbuf[4096 +1];
  ssize_t n;
  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)
    {
      linkbuf[n] = '\0';
      return (rename (backup, linkbuf));
    }
  return (rename (backup, orig));
}
<<<sep_in_sample>>>
1 4
2 7
3 4
4 4
5 4
6 7
7 4
8 7
9 4
10 4
11 4
12 7
13 7
14 7
15 10
16 10
17 9
18 10
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 13
32 13
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    0x8(%rdi),%rax
js     20 <__gmpz_set_si+0x20>
mov    %rsi,(%rax)
setne  %al
movzbl %al,%eax
mov    %eax,0x4(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
neg    %rsi
mov    %rsi,(%rax)
mov    $0xffffffff,%eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_set_si (mpz_ptr dest, signed long int val)
{
  mp_size_t size;
  mp_limb_t vl;
  vl = (mp_limb_t) ((val) >= 0 ? ((unsigned long int) (val)) : (- (((unsigned long int) ((val) + 1)) - 1)));
  ((dest)->_mp_d)[0] = vl & ((~ ((mp_limb_t) (0))) >> 0);
  size = vl != 0;
  ((dest)->_mp_size) = val >= 0 ? size : -size;
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 6
5 7
6 7
7 8
8 8
9 8
10 5
11 5
12 8
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  149 <redisplay_after_signal+0x9>
mov    0x0(%rip),%rdi        # 150 <redisplay_after_signal+0x10>
callq  155 <redisplay_after_signal+0x15>
mov    0x0(%rip),%eax        # 15b <redisplay_after_signal+0x1b>
test   %eax,%eax
je     16b <redisplay_after_signal+0x2b>
mov    0x0(%rip),%rdi        # 166 <redisplay_after_signal+0x26>
callq  16b <redisplay_after_signal+0x2b>
mov    0x0(%rip),%rdi        # 172 <redisplay_after_signal+0x32>
mov    $0x1,%esi
callq  17c <redisplay_after_signal+0x3c>
callq  181 <redisplay_after_signal+0x41>
mov    0x0(%rip),%rdi        # 188 <redisplay_after_signal+0x48>
callq  18d <redisplay_after_signal+0x4d>
mov    0x0(%rip),%rdi        # 194 <redisplay_after_signal+0x54>
add    $0x8,%rsp
jmpq   19d <redisplay_after_signal+0x5d>
nopl   (%rax)
<<<sep_in_sample>>>
redisplay_after_signal (void)
{
  terminal_clear_screen ();
  display_clear_display (the_display);
  if (auto_footnotes_p)
    info_get_or_remove_footnotes (active_window);
  window_mark_chain (windows, 0x01);
  display_update_display ();
  display_cursor_at_point (active_window);
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 8
14 9
15 9
16 10
17 11
18 10
19 10
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   7a9 <xformat_set_groupname+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_set_groupname (XFORMAT * xux, char * name)
{
 ;
        ahs_set_tar_groupname(xux->ahsM, name);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 7e6 <yyget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_lineno (void)
{
    return yylineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    %rsi,%r8
movabs $0x8000000080000001,%rdx
and    $0x3,%r8d
sub    $0x2,%r8
mov    %r8,%rax
mul    %rdx
shr    $0x1f,%rdx
mov    %rdx,%rcx
shl    $0x20,%rcx
sub    %rdx,%rcx
mov    %r8,%rdx
sub    %rcx,%rdx
jne    70 <ran_set+0x40>
and    $0xffffffff,%esi
mov    %rsi,(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
sub    %edx,%esi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  unsigned long int diff = ((s % 4UL) - 2UL) % 0xffffffffUL;
  if (diff)
    state->x = (s - diff) & 0xffffffffUL;
  else
    state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 8
15 8
16 8
17 8
18 6
19 6
20 6
<<<sep_out_sample>>>
push   %r12
lea    -0x1(%rsi),%eax
mov    %rdi,%r12
push   %rbp
lea    (%rdx,%rax,8),%rbp
push   %rbx
mov    %rdx,%rbx
nopl   0x0(%rax)
cmp    %rbp,%rbx
je     d5 <add+0x55>
add    $0x8,%rbx
mov    (%rbx),%rdi
callq  a9 <add+0x29>
mov    %r12,%rdi
mov    %rax,%rsi
callq  b4 <add+0x34>
test   %eax,%eax
je     98 <add+0x18>
callq  bd <add+0x3d>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
mov    $0x4,%edi
callq  d0 <add+0x50>
cmp    %rbp,%rbx
jne    9d <add+0x1d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add(void *object, int argc, char **argv)
{
    dico_list_t list = object;
    while (--argc) {
 if (dico_list_append(list, strdup(*++argv)))
     dico_log(4, (*__errno_location ()), "dico_list_append");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 6
24 6
25 4
26 4
27 8
28 8
29 8
30 8
31 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm1,0x8(%rsp)
callq  68f <gsl_cdf_gaussian_Qinv+0xf>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_gaussian_Qinv (const double Q, const double sigma)
{
  return sigma * gsl_cdf_ugaussian_Qinv (Q);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 3
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     5f <rcfile_error+0x5f>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
testb  $0x1,0x0(%rip)        # 69 <rcfile_error+0x69>
je     80 <rcfile_error+0x80>
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 87 <rcfile_error+0x87>
mov    $0xa,%edi
callq  91 <rcfile_error+0x91>
mov    0x0(%rip),%rbp        # 98 <rcfile_error+0x98>
test   %rbp,%rbp
jne    100 <rcfile_error+0x100>
lea    0xf0(%rsp),%rax
mov    %rbx,%rdi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  cc <rcfile_error+0xcc>
mov    0x0(%rip),%rdi        # d3 <rcfile_error+0xd3>
lea    0x8(%rsp),%rdx
mov    %rax,%rsi
callq  e0 <rcfile_error+0xe0>
mov    0x0(%rip),%rsi        # e7 <rcfile_error+0xe7>
mov    $0xa,%edi
callq  f1 <rcfile_error+0xf1>
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x0(%rip),%r12        # 107 <rcfile_error+0x107>
mov    $0x0,%edi
movb   $0x1,0x0(%rip)        # 113 <rcfile_error+0x113>
callq  118 <rcfile_error+0x118>
mov    0x0(%rip),%rdi        # 11f <rcfile_error+0x11f>
mov    %rax,%rsi
mov    %rbp,%rcx
mov    %r12,%rdx
xor    %eax,%eax
callq  12f <rcfile_error+0x12f>
jmpq   9d <rcfile_error+0x9d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rcfile_error(const char *msg, ...)
{
    va_list ap;
    if (((flags[((QUIET) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((QUIET) % (sizeof(unsigned) * 8)))) != 0))
 return;
    fprintf(stderr, "\n");
    if (lineno > 0) {
 errors = 1;
 fprintf(stderr, gettext("Error in %s on line %lu: "), nanorc, (unsigned long)lineno);
    }
    __builtin_va_start(ap,msg);
    vfprintf(stderr, gettext(msg), ap);
    __builtin_va_end(ap);
    fprintf(stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 4
22 4
23 15
24 15
25 15
26 15
27 15
28 15
29 6
30 6
31 6
32 7
33 7
34 7
35 11
36 12
37 11
38 11
39 11
40 11
41 11
42 12
43 12
44 12
45 12
46 12
47 14
48 14
49 14
50 15
51 15
52 15
53 15
54 15
55 15
56 9
57 9
58 8
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 8a <nettle_ccm_aes192_decrypt+0xa>
mov    %rsi,%rax
lea    0x28(%rdi),%rsi
mov    %rcx,%r9
mov    %rax,%rcx
jmpq   9c <nettle_ccm_aes192_decrypt+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_ccm_decrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes192_encrypt,
       length, dst, src);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
add    $0x1,%esi
sub    $0x8,%rsp
movzbl %sil,%esi
callq  590 <cdio_get_track_last_lsn+0x10>
cmp    $0xffff4f0b,%eax
je     59a <cdio_get_track_last_lsn+0x1a>
sub    $0x1,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
cdio_get_track_last_lsn(const CdIo_t *p_cdio, track_t u_track)
{
  lsn_t lsn = cdio_get_track_lsn(p_cdio, u_track+1);
  if (-45301 == lsn) return -45301;
  return lsn - 1;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x90,%rsp
mov    %rsp,%rsi
callq  2c63 <panel_unlink+0x13>
test   %eax,%eax
jne    2c77 <panel_unlink+0x27>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x8000,%eax
je     2c80 <panel_unlink+0x30>
add    $0x90,%rsp
pop    %rbx
retq   
mov    %rbx,%rdi
callq  2c88 <panel_unlink+0x38>
add    $0x90,%rsp
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panel_unlink(name)
    char *name;
{
    struct stat statbuf;
    if (xstat(name, &statbuf) == 0 && ((((statbuf.st_mode)) & 0170000) == (0100000)))
 unlink(name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 6
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  66 <nntp_itr_dup+0x16>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     8f <nntp_itr_dup+0x3f>
mov    (%rbx),%rax
mov    %rax,(%rdx)
mov    0x8(%rbx),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rbx),%rax
mov    %rax,0x10(%rdx)
mov    %rdx,0x0(%rbp)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_dup (void **ptr, void *owner)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  struct nntp_iterator *clone = malloc (sizeof *nntp_iterator);
  if (clone == ((void *)0))
    return 12;
  *clone = *nntp_iterator;
  *ptr = clone;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 9
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rsi
mov    (%rdi),%rdi
callq  c0 <dico_strategy_dup+0x10>
test   %rax,%rax
je     d5 <dico_strategy_dup+0x25>
mov    0x10(%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x18(%rbx),%rdx
mov    %rdx,0x18(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_strategy_dup(const dico_strategy_t strat)
{
    dico_strategy_t np = dico_strategy_create(strat->name, strat->descr);
    if (np) {
 np->sel = strat->sel;
 np->closure = strat->closure;
    }
    return np;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 6
11 6
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  f1 <suffix+0x11>
cmp    $0x2,%eax
jg     120 <suffix+0x40>
mov    0x0(%rip),%rdi        # fd <suffix+0x1d>
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  10c <suffix+0x2c>
mov    $0x1,%edi
callq  116 <suffix+0x36>
nopw   %cs:0x0(%rax,%rax,1)
movslq %eax,%rdx
mov    $0x0,%edi
mov    $0x3,%ecx
lea    -0x2(%rbx,%rdx,1),%r8
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     170 <suffix+0x90>
cmp    $0x4,%eax
jle    f6 <suffix+0x16>
lea    -0x4(%rbx,%rdx,1),%rax
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    f6 <suffix+0x16>
movb   $0x0,(%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   168 <suffix+0x88>
nopl   0x0(%rax,%rax,1)
movb   $0x0,(%r8)
jmp    157 <suffix+0x77>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
suffix(char name[], char suff[])
{
  int n;
  n = strlen(name);
  if (n > 2 && !strcmp(name + n - 2, ".c"))
    {
      name[n - 2] = '\0';
      strcat(name, suff);
    }
  else if (n > 4 && !strcmp(name + n - 4, ".sbs"))
    {
      name[n - 4] = '\0';
      strcat(name, suff);
    }
  else
    {
      fprintf(stderr, "dap: name must end in .c or .sbs: %s\n", name);
      exit(1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 17
10 17
11 17
12 17
13 17
14 18
15 18
16 18
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 12
33 20
34 13
35 13
36 20
37 20
38 13
39 13
40 7
41 7
42 7
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_add_digit_to_numeric_arg (WINDOW *window, int count)
{}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
cmp    $0x4a2,%rsi
jle    190 <__gmpn_bdiv_qr_itch+0x10>
jmpq   18e <__gmpn_bdiv_qr_itch+0xe>
xchg   %ax,%ax
mov    %rdi,%rax
retq   
<<<sep_in_sample>>>
__gmpn_bdiv_qr_itch (mp_size_t nn, mp_size_t dn)
{
  if ((! ((__builtin_constant_p (1187) && (1187) == 0) || (!(__builtin_constant_p (1187) && (1187) == 9223372036854775807L) && (dn) >= (1187)))))
    return nn;
  else
    return __gmpn_mu_bdiv_qr_itch (nn, dn);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
jmp    20cc <get_directory_entries+0x1c>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  580 <open_failure_recover>
test   %al,%al
je     20f8 <get_directory_entries+0x48>
mov    0x1a8(%rbx),%edi
callq  20d7 <get_directory_entries+0x27>
test   %rax,%rax
mov    %rax,0x1a0(%rbx)
je     20c0 <get_directory_entries+0x10>
pop    %rbx
mov    0x0(%rip),%esi        # 20ea <get_directory_entries+0x3a>
mov    %rax,%rdi
jmpq   20f2 <get_directory_entries+0x42>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_directory_entries (struct tar_stat_info *st)
{
  while (! (st->dirstream = fdopendir (st->fd)))
    if (! open_failure_recover (st))
      return 0;
  return streamsavedir (st->dirstream, savedir_sort_order);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 3
10 3
11 3
12 3
13 3
14 7
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
test   $0x1,%dil
mov    $0xcc,%edx
jne    50 <nettle_sha3_512_init+0x50>
test   $0x2,%dil
jne    60 <nettle_sha3_512_init+0x60>
test   $0x4,%dil
jne    78 <nettle_sha3_512_init+0x78>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     30 <nettle_sha3_512_init+0x30>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     3f <nettle_sha3_512_init+0x3f>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     47 <nettle_sha3_512_init+0x47>
movb   $0x0,(%rdi)
repz retq 
nopl   0x0(%rax)
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0xcb,%dl
test   $0x2,%dil
je     11 <nettle_sha3_512_init+0x11>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     17 <nettle_sha3_512_init+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    17 <nettle_sha3_512_init+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_sha3_512_init (struct sha3_512_ctx *ctx)
{
  memset (ctx, 0, __builtin_offsetof (struct sha3_512_ctx, block));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edi,%ebp
mov    $0x40,%edi
push   %rbx
callq  363 <swutil_writelogline+0x13>
mov    %r12,%rsi
mov    %rax,%rbx
mov    %rax,%rdi
callq  0 <printlogline>
mov    %rbx,%rdi
callq  379 <swutil_writelogline+0x29>
mov    %rbx,%rdi
mov    %rax,%r12
callq  384 <swutil_writelogline+0x34>
mov    %ebp,%edi
mov    %r12d,%edx
mov    %rax,%rsi
callq  391 <swutil_writelogline+0x41>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  39c <swutil_writelogline+0x4c>
cmp    %eax,%ebp
je     3b9 <swutil_writelogline+0x69>
mov    $0x0,%ecx
mov    $0x10d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b9 <swutil_writelogline+0x69>
mov    %rbx,%rdi
callq  3c1 <swutil_writelogline+0x71>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swutil_writelogline(int logfd, char * sptr)
{
 int ret;
 STROB * buf = strob_open(64);
 printlogline(buf, sptr);
 ret = uxfio_unix_safe_write(logfd, strob_str(buf), strob_strlen(buf));
 if (ret != (int)strob_strlen(buf)) {
  swlib_exception("error writing logfile", (char*)"swutillib.c", 269, (char*)__FUNCTION__);;
 }
 strob_close(buf);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 6
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 10
32 10
33 12
34 12
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     228 <free_name+0x28>
mov    0x10(%rdi),%rdi
callq  212 <free_name+0x12>
mov    0x58(%rbx),%rdi
callq  21b <free_name+0x1b>
mov    %rbx,%rdi
pop    %rbx
jmpq   224 <free_name+0x24>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
free_name (struct name *p)
{
  if (p)
    {
      free (p->name);
      free (p->caname);
      free (p);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 6
8 6
9 7
10 9
11 7
12 7
13 9
14 9
15 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  2d <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  36 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  3f <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  48 <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  51 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  5a <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  62 <modnewton1_free+0x42>
mov    %rbx,%rdi
pop    %rbx
jmpq   6b <modnewton1_free+0x4b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 12
19 11
20 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
mov    $0x0,%esi
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
callq  a2f <rmt_write__+0x2f>
mov    %rsp,%rsi
mov    %ebx,%edi
callq  50 <do_command>
cmp    $0xffffffff,%eax
je     aa8 <rmt_write__+0xa8>
mov    $0x1,%esi
mov    $0xd,%edi
callq  a4d <rmt_write__+0x4d>
mov    %rax,%r13
movslq %ebx,%rax
mov    %r12,%rsi
mov    0x0(,%rax,8),%edi
mov    %rbp,%rdx
callq  a65 <rmt_write__+0x65>
mov    %r13,%rsi
mov    %rax,%r12
mov    $0xd,%edi
callq  a75 <rmt_write__+0x75>
cmp    %rbp,%r12
je     ab0 <rmt_write__+0xb0>
mov    $0x5,%esi
mov    %ebx,%edi
callq  0 <_rmt_shutdown>
mov    %r12,%rax
mov    0x48(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    ad5 <rmt_write__+0xd5>
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    a89 <rmt_write__+0x89>
nopl   0x0(%rax)
mov    %ebx,%edi
callq  1e0 <get_status>
test   %rax,%rax
js     aa8 <rmt_write__+0xa8>
cmp    %rax,%r12
je     ad0 <rmt_write__+0xd0>
mov    %rax,%r12
jmp    a7a <rmt_write__+0x7a>
nopw   %cs:0x0(%rax,%rax,1)
mov    %r12,%rax
jmp    a89 <rmt_write__+0x89>
callq  ada <rmt_write__+0xda>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rmt_write__ (int handle, char *buffer, size_t length)
{
  char command_buffer[64];
  void (*pipe_handler) (int);
  size_t written;
  sprintf (command_buffer, "W%lu\n", (unsigned long) length);
  if (do_command (handle, command_buffer) == -1)
    return 0;
  pipe_handler = signal (13, ((__sighandler_t) 1));
  written = full_write ((to_remote[handle][1]), buffer, length);
  signal (13, pipe_handler);
  if (written == length)
    {
      long int r = get_status (handle);
      if (r < 0)
 return 0;
      if (r == length)
 return length;
      written = r;
    }
  _rmt_shutdown (handle, 5);
  return written;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 9
21 9
22 9
23 9
24 10
25 10
26 10
27 10
28 10
29 11
30 10
31 11
32 11
33 12
34 12
35 21
36 21
37 21
38 22
39 23
40 23
41 23
42 23
43 23
44 23
45 23
46 23
47 23
48 23
49 8
50 8
51 8
52 14
53 14
54 15
55 15
56 17
57 17
58 17
59 17
60 17
61 17
62 17
63 23
64 23
<<<sep_out_sample>>>
mov    (%rdi),%rax
sub    (%rsi),%rax
sar    $0x4,%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
member_file_hash_compare (void const *x, void const *y)
{
  do { int result; do { (result) = (((struct member_file const *) x)->mf_link) - (((struct member_file const *) y)->mf_link); } while (0); return result; } while (0)
                                               ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
and    $0x7f,%edi
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
movzbl 0x0(%rip),%eax        # 36e <echo+0x1e>
cmp    $0x1f,%dil
mov    %al,(%rsp)
jle    3c0 <echo+0x70>
cmp    $0x7f,%dil
je     3e0 <echo+0x90>
lea    0x2(%rsp),%rdx
mov    %dil,0x1(%rsp)
mov    %rsp,%rsi
movb   $0xd,(%rdx)
movb   $0xa,0x1(%rdx)
add    $0x2,%rdx
sub    %rsi,%rdx
mov    $0x1,%edi
callq  3a2 <echo+0x52>
mov    0x8(%rsp),%rax
xor    %fs:0x28,%rax
jne    3f4 <echo+0xa4>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x40,%edi
movb   $0x5e,0x1(%rsp)
mov    %rsp,%rsi
mov    %dil,0x2(%rsp)
lea    0x3(%rsp),%rdx
jmp    38a <echo+0x3a>
nopw   0x0(%rax,%rax,1)
movb   $0x5e,0x1(%rsp)
movb   $0x3f,0x2(%rsp)
mov    %rsp,%rsi
lea    0x3(%rsp),%rdx
jmp    38a <echo+0x3a>
callq  3f9 <echo+0xa9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
echo (register char c)
{
  register char *p;
  char buf[8];
  p = buf;
  c &= 0177;
  *p++ = escapechar;
  if (c < ' ')
    {
      *p++ = '^';
      *p++ = c + '@';
    }
  else if (c == 0177)
    {
      *p++ = '^';
      *p++ = '?';
    }
  else
    *p++ = c;
  *p++ = '\r';
  *p++ = '\n';
  write (1, buf, p - buf);
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 7
7 8
8 7
9 8
10 13
11 13
12 19
13 19
14 19
15 20
16 21
17 21
18 22
19 22
20 22
21 23
22 23
23 23
24 23
25 23
26 23
27 11
28 10
29 11
30 11
31 11
32 11
33 11
34 15
35 16
36 16
37 16
38 16
39 23
40 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 3ab <set_prompt+0xb>
callq  3b0 <set_prompt+0x10>
mov    %rbx,%rdi
callq  3b8 <set_prompt+0x18>
mov    %rbx,%rdi
mov    %rax,%rsi
callq  3c3 <set_prompt+0x23>
pop    %rbx
mov    %rax,0x0(%rip)        # 3cb <set_prompt+0x2b>
mov    %rax,0x0(%rip)        # 3d2 <set_prompt+0x32>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_prompt(const char *value)
{
 free(dgawk_prompt);
 dgawk_prompt = estrdup(value, strlen(value));
 dbg_prompt = dgawk_prompt;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 6
11 4
12 5
13 6
14 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    0x0(%rip),%rbp        # 6fa <skip_pad+0xa>
push   %rbx
mov    0x0(%rip),%ebx        # 701 <skip_pad+0x11>
callq  706 <skip_pad+0x16>
mov    %rax,%r12
nopl   0x0(%rax)
movslq %ebx,%rdx
movsbq 0x0(%rbp,%rdx,1),%rdx
test   %dl,%dl
je     73e <skip_pad+0x4e>
mov    (%r12),%rcx
testb  $0x20,0x1(%rcx,%rdx,2)
je     760 <skip_pad+0x70>
add    $0x1,%ebx
movslq %ebx,%rdx
mov    %ebx,0x0(%rip)        # 734 <skip_pad+0x44>
movsbq 0x0(%rbp,%rdx,1),%rdx
test   %dl,%dl
jne    71d <skip_pad+0x2d>
callq  550 <read_line>
test   %eax,%eax
mov    0x0(%rip),%rbp        # 74c <skip_pad+0x5c>
je     752 <skip_pad+0x62>
movb   $0x1a,0x0(%rbp)
movl   $0x0,0x0(%rip)        # 75c <skip_pad+0x6c>
xor    %ebx,%ebx
jmp    710 <skip_pad+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skip_pad(void)
{ for (;;)
      { if (line[pos] == '\0')
         {
            if (read_line()) line[0] = 0x1A;
            pos = 0;
         }
         else if (((*__ctype_b_loc ())[(int) ((line[pos]))] & (unsigned short int) _ISspace))
         {
            pos++;
         }
         else
         {
            break;
         }
      }
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 8
14 8
15 8
16 10
17 3
18 10
19 3
20 3
21 3
22 5
23 5
24 5
25 5
26 5
27 6
28 6
29 6
30 18
31 18
32 18
33 18
34 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    %rdi,%rbx
mov    $0x15,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  9ab <WriteIncludes+0x1b>
mov    %rbx,%rcx
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  9c2 <WriteIncludes+0x32>
mov    %rbx,%rcx
mov    $0x12,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  9d9 <WriteIncludes+0x49>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  9f0 <WriteIncludes+0x60>
mov    %rbx,%rcx
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a07 <WriteIncludes+0x77>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a1e <WriteIncludes+0x8e>
mov    %rbx,%rcx
mov    $0x14,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a35 <WriteIncludes+0xa5>
mov    %rbx,%rcx
mov    $0x16,%edx
mov    $0x1,%esi
pop    %rbx
mov    $0x0,%edi
jmpq   a4d <WriteIncludes+0xbd>
nopl   (%rax)
<<<sep_in_sample>>>
WriteIncludes (PFILE pfile)
{
  fprintf (pfile, "\n#include <stdlib.h>\n");
  fprintf (pfile, "#include <stdio.h>\n");
  fprintf (pfile, "#include <math.h>\n");
  fprintf (pfile, "#include <string.h>\n");
  fprintf (pfile, "#include <float.h>\n");
  fprintf (pfile, "#include \"modelu.h\"\n");
  fprintf (pfile, "#include \"random.h\"\n");
  fprintf (pfile, "#include \"yourcode.h\"\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 8
31 8
32 8
33 9
34 9
35 9
36 9
37 9
38 10
39 10
40 10
41 11
42 10
43 10
44 10
<<<sep_out_sample>>>
jmpq   25 <gss_seal+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_seal (OM_uint32 * minor_status,
   gss_ctx_id_t context_handle,
   int conf_req_flag,
   int qop_req,
   gss_buffer_t input_message_buffer,
   int *conf_state, gss_buffer_t output_message_buffer)
{
  return gss_wrap (minor_status, context_handle, conf_req_flag,
     (gss_qop_t) qop_req,
     input_message_buffer, conf_state, output_message_buffer);
}
<<<sep_in_sample>>>
1 8
2 8
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0x18,%esi
jmpq   80d <nettle_serpent192_set_key+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
nettle_serpent192_set_key (struct serpent_ctx *ctx, const uint8_t *key)
{
  nettle_serpent_set_key (ctx, 24, key);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  11 <open_input_file+0x11>
test   %rax,%rax
mov    %rax,%r12
je     51 <open_input_file+0x51>
mov    $0x1,%esi
mov    $0x1410,%edi
callq  28 <open_input_file+0x28>
lea    0x410(%rax),%rdi
mov    %rax,%rbx
mov    %r12,0x8(%rax)
mov    %rbp,%rsi
mov    $0x1000,%edx
callq  43 <open_input_file+0x43>
movl   $0x1,(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbp,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  60 <open_output_file>
<<<sep_in_sample>>>
open_input_file(const char *path)
{
 FILE *fp = fopen(path, "r");
 FILEOP *fileop;
 if (fp == ((void *)0))
  die("cannot open file '%s'.", path);
 fileop = check_calloc(sizeof(FILEOP), 1);
 fileop->fp = fp;
 strlimcpy(fileop->path, path, sizeof(fileop->path));
 fileop->type = 1;
 return fileop;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 5
8 3
9 5
10 7
11 7
12 7
13 9
14 7
15 8
16 9
17 9
18 9
19 10
20 12
21 12
22 12
23 12
24 12
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzwl 0x60(%rdi),%edx
cmp    %rsi,%rdx
jl     80 <__rfield+0x80>
movzwl 0x62(%rbx),%eax
movzwl %ax,%ecx
lea    -0x1(%rbp,%rcx,1),%rcx
cmp    %rdx,%rcx
jle    45 <__rfield+0x45>
mov    (%rbx),%rax
mov    %rbx,%rdi
cmp    $0x0,%rax
je     a0 <__rfield+0xa0>
cmp    $0x0,%rax
je     90 <__rfield+0x90>
callq  41 <__rfield+0x41>
movzwl 0x62(%rbx),%eax
mov    0x58(%rbx),%rdx
mov    %bp,0x0(%rip)        # 50 <__rfield+0x50>
mov    %rdx,0x0(%rip)        # 57 <__rfield+0x57>
movzwl 0x64(%rbx),%edx
lea    -0x1(%rax,%rdx,1),%eax
mov    %ax,0x0(%rip)        # 66 <__rfield+0x66>
mov    $0x1,%eax
mov    %ax,0x0(%rip)        # 72 <__rfield+0x72>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  8a <__rfield+0x8a>
movzwl 0x60(%rbx),%edx
jmp    15 <__rfield+0x15>
callq  95 <__rfield+0x95>
movzwl 0x62(%rbx),%eax
jmp    45 <__rfield+0x45>
nopl   0x0(%rax,%rax,1)
callq  a5 <__rfield+0xa5>
movzwl 0x62(%rbx),%eax
jmp    45 <__rfield+0x45>
<<<sep_in_sample>>>
__rfield (__bs2FILE *p, long w)
{
  if (w > p->IMAGE.length)
    __rerror ("Outint, outfix etc: Width on out field is greater than IMAGE.length");
  if (p->IMAGE.pos + w - 1 > p->IMAGE.length)
    if (((__bs1FILE *) p)->h.pp == &__p6FILE)
      __rpoutimage (((__bs6FILE *) p));
    else if (((__bs1FILE *) p)->h.pp == &__p5FILE)
      __rdoutimage ((__bs5FILE *) p);
    else
      __rooutimage (p);
  __et.obj = p->IMAGE.obj;
  __et.start = p->IMAGE.start + p->IMAGE.pos - 1;
  __et.length = w;
  __et.pos = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 6
17 6
18 8
19 8
20 11
21 11
22 12
23 14
24 12
25 13
26 13
27 13
28 15
29 15
30 16
31 16
32 16
33 16
34 16
35 4
36 4
37 4
38 4
39 9
40 9
41 9
42 9
43 7
44 7
45 7
<<<sep_out_sample>>>
test   %edi,%edi
jne    1f0 <tty_setlitecho+0x10>
orl    $0x200,0x0(%rip)        # 1ee <tty_setlitecho+0xe>
retq   
nop
andl   $0xfffffdff,0x0(%rip)        # 1fa <tty_setlitecho+0x1a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_setlitecho (int on)
{
  if (on)
    termbuf.c_lflag &= ~0001000;
  else
    termbuf.c_lflag |= 0001000;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 4
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     60 <osip_mutex_destroy+0x20>
callq  4e <osip_mutex_destroy+0xe>
mov    0x0(%rip),%rax        # 55 <osip_mutex_destroy+0x15>
mov    %rbx,%rdi
test   %rax,%rax
je     68 <osip_mutex_destroy+0x28>
pop    %rbx
jmpq   *%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   75 <osip_mutex_destroy+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_mutex_destroy (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return;
  pthread_mutex_destroy (mut);
  { if (mut!=((void *)0)) { if (osip_free_func) osip_free_func(mut); else free(mut);} };
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 6
6 7
7 7
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 8
17 7
18 7
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     f8 <_auth_lb_grow+0x78>
mov    0x8(%rbx),%rdx
mov    0x10(%rbx),%rax
mov    %rdx,%rcx
sub    %rax,%rcx
cmp    %rcx,%rbp
ja     d0 <_auth_lb_grow+0x50>
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rax,%rdi
callq  bc <_auth_lb_grow+0x3c>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x0(%rbp,%rdx,1),%r13
mov    %r13,%rsi
callq  dd <_auth_lb_grow+0x5d>
test   %rax,%rax
mov    %rax,(%rbx)
je     114 <_auth_lb_grow+0x94>
mov    %r13,0x8(%rbx)
mov    %rax,%rdi
mov    0x10(%rbx),%rax
jmp    ae <_auth_lb_grow+0x2e>
nopw   0x0(%rax,%rax,1)
mov    %rdx,%rdi
callq  100 <_auth_lb_grow+0x80>
test   %rax,%rax
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jne    e9 <_auth_lb_grow+0x69>
add    $0x8,%rsp
mov    $0xc,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 9
13 9
14 9
15 9
16 9
17 9
18 18
19 18
20 18
21 18
22 19
23 21
24 20
25 21
26 21
27 21
28 21
29 21
30 21
31 11
32 12
33 12
34 13
35 12
36 13
37 14
38 14
39 14
40 14
41 14
42 5
43 5
44 16
45 5
46 6
47 7
48 16
49 21
50 17
51 21
52 21
53 21
54 21
55 21
56 21
<<<sep_out_sample>>>
mov    0x148(%rdi),%rdi
jmpq   43c <VdbeAllocColor+0xc>
<<<sep_in_sample>>>
VdbeAllocColor(Viewport *v, Colormap colormap, XColor *c)
{
  int result;
  result = XAllocColor (v->dpy, colormap, c);
  return result;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   44c0 <rpmpsf_write_swdef_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmpsf_write_info(TOPSF * topsf, int uxfio_ofd)
{
 int ret = rpmpsf_write_swdef_internal(topsf, uxfio_ofd, 0 );
 return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ecx
lea    0x8(%rsi),%rdi
sub    $0x10,%rsp
cmp    $0x2,%ecx
mov    0x70(%rsi),%rax
jne    a0 <cb_logging_facility+0x60>
test   %rax,%rax
je     5f <cb_logging_facility+0x1f>
mov    (%rax),%ebx
test   %ebx,%ebx
je     80 <cb_logging_facility+0x40>
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
callq  6d <cb_logging_facility+0x2d>
mov    $0x1,%ebx
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x28(%rax),%rdi
mov    %rdx,0x8(%rsp)
callq  8e <cb_logging_facility+0x4e>
mov    0x8(%rsp),%rdx
mov    %rax,(%rdx)
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
callq  ae <cb_logging_facility+0x6e>
mov    $0x1,%ebx
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cb_logging_facility(enum grecs_callback_command cmd, grecs_node_t *node, void *varptr, void *cb_data)
{
 grecs_locus_t *locus = &node->locus; grecs_value_t *value = node->v.value;
 if (cmd != grecs_callback_set_value) {
  grecs_error(locus, 0, "Unexpected block statement");
  return 1;
 }
 if (!value || value->type != 0) {
  grecs_error(locus, 0, "expected string argument");
  return 1;
 }
 *(char**)varptr = grecs_strdup(value->v.string);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 4
6 3
7 4
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 10
18 14
19 14
20 14
21 14
22 14
23 12
24 12
25 12
26 12
27 12
28 14
29 14
30 14
31 14
32 14
33 5
34 5
35 5
36 5
37 6
38 14
39 14
40 14
41 14
42 14
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9a6 <_rl_release_sigint+0x6>
test   %eax,%eax
je     9be <_rl_release_sigint+0x1e>
mov    0x0(%rip),%eax        # 9b0 <_rl_release_sigint+0x10>
movl   $0x0,0x0(%rip)        # 9ba <_rl_release_sigint+0x1a>
test   %eax,%eax
jne    9c0 <_rl_release_sigint+0x20>
repz retq 
mov    0x0(%rip),%edi        # 9c6 <_rl_release_sigint+0x26>
jmpq   9cb <_rl_release_sigint+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_release_sigint ()
{
  if (sigint_blocked == 0)
    return;
  sigint_blocked = 0;
  do { if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 5
6 6
7 6
8 6
9 6
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x14(%rsi),%ebp
cmp    %ebp,(%rdi)
movslq %ebp,%rdx
jl     31 <__gmpq_get_den+0x31>
mov    0x8(%rdi),%rdi
mov    %ebp,0x4(%rbx)
mov    0x18(%r12),%rsi
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
jmpq   31 <__gmpq_get_den+0x31>
mov    %rdx,%rsi
mov    %rdx,0x8(%rsp)
callq  3e <__gmpq_get_den+0x3e>
mov    0x8(%rsp),%rdx
mov    %rax,%rdi
jmp    1c <__gmpq_get_den+0x1c>
<<<sep_in_sample>>>
__gmpq_get_den (mpz_ptr den, mpq_srcptr src)
{
  mp_size_t size = (((&((src)->_mp_den)))->_mp_size);
  mp_ptr dp;
  dp = (__builtin_expect (((size) > ((den)->_mp_alloc)) != 0, 0) ? (mp_ptr) __gmpz_realloc(den,size) : ((den)->_mp_d));
  ((den)->_mp_size) = size;
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (dp, (((&((src)->_mp_den)))->_mp_d), size); } while (0); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 5
9 5
10 5
11 5
12 6
13 7
14 8
15 8
16 8
17 8
18 7
19 5
20 5
21 5
22 5
23 5
24 5
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    0x8(%rsi),%rbp
xor    %ebx,%ebx
mov    0x10(%rsi),%r14
test   %rbp,%rbp
jne    a9 <gsl_combination_fprintf+0x29>
jmp    e8 <gsl_combination_fprintf+0x68>
nop
add    $0x1,%rbx
cmp    %rbp,%rbx
je     e8 <gsl_combination_fprintf+0x68>
mov    (%r14,%rbx,8),%rdx
xor    %eax,%eax
mov    %r12,%rsi
mov    %r13,%rdi
callq  ba <gsl_combination_fprintf+0x3a>
test   %eax,%eax
jns    a0 <gsl_combination_fprintf+0x20>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d7 <gsl_combination_fprintf+0x57>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x5,%eax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_fprintf (FILE * stream, const gsl_combination * c, const char *format)
{
  size_t k = c->k ;
  size_t * data = c->data ;
  size_t i;
  for (i = 0; i < k; i++)
    {
      int status = fprintf (stream, format, data[i]);
      if (status < 0)
        {
          do { gsl_error ("fprintf failed", "file.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 15
31 15
32 15
33 15
34 11
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 14
43 15
44 15
45 15
<<<sep_out_sample>>>
test   $0x4000,%edi
je     2b00 <uinfile_decode_buftype+0x10>
mov    $0x3,%eax
retq   
xchg   %ax,%ax
jmpq   620 <uinfile_decode_buftype.part.6>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uinfile_decode_buftype(int oflags, int v)
{
 ;
 if ((oflags & (1 << 14))) {
  v = 3;
 } else if ((oflags & (1 << 15))) {
  v = 2;
 } else if ((oflags & (1 << 13))) {
  v = 1;
 }
 ;
 return v;
}
<<<sep_in_sample>>>
1 4
2 4
3 13
4 13
5 13
6 13
7 13
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 847 <yyset_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_in (FILE * in_str )
{
        yyin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x20,%edi
callq  6e <dup_line_node+0xe>
test   %rax,%rax
je     88 <dup_line_node+0x28>
test   %rbx,%rbx
je     86 <dup_line_node+0x26>
mov    0x10(%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x18(%rbx),%edx
mov    %edx,0x18(%rax)
pop    %rbx
retq   
callq  8d <dup_line_node+0x2d>
mov    (%rax),%esi
xor    %edi,%edi
callq  96 <dup_line_node+0x36>
mov    $0x0,%edi
callq  a0 <dup_line_node+0x40>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dup_line_node( line_t * const lp )
  {
  line_t * const p = (line_t *) malloc( sizeof (line_t) );
  if( !p )
    {
    show_strerror( 0, (*__errno_location ()) );
    set_error_msg( "Memory exhausted" );
    return 0;
    }
  if( lp ) { p->pos = lp->pos; p->len = lp->len; }
  return p;
  }
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 10
8 10
9 10
10 10
11 10
12 10
13 12
14 12
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 12
23 12
24 12
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
add    $0x18,%esi
mov    0xc0(%rax),%rdi
sub    0xc(%rdi),%esi
test   %edx,%edx
mov    %esi,0x4c(%rdi)
je     5bc0 <_jit_trampoline+0x60>
orb    $0x1,0x50(%rdi)
mov    0x14(%rax),%eax
test   %eax,%eax
jle    5bbb <_jit_trampoline+0x5b>
lea    -0x1(%rax),%edx
xor    %ecx,%ecx
mov    $0x1,%esi
add    $0x1,%rdx
nopl   0x0(%rax)
mov    %rcx,%rax
shl    $0x4,%rax
testb  $0x10,0x0(%rax)
je     5bb2 <_jit_trampoline+0x52>
mov    %rsi,%rax
shl    %cl,%rax
or     %rax,0x40(%rdi)
add    $0x1,%rcx
cmp    %rdx,%rcx
jne    5b98 <_jit_trampoline+0x38>
repz retq 
nopl   (%rax)
orb    $0x2,0x50(%rdi)
jmp    5b7c <_jit_trampoline+0x1c>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_trampoline(jit_state_t *_jit, jit_int32_t frame, jit_bool_t prolog)
{
    jit_int32_t regno;
    ((void) (0));
    frame += 24;
    frame -= _jit->comp->function->self.aoff;
    _jit->comp->function->frame = frame;
    if (prolog)
 _jit->comp->function->define_frame = 1;
    else
 _jit->comp->function->assume_frame = 1;
    for (regno = 0; regno < _jit->comp->reglen; regno++)
 if (((_rvs[regno].spec) & 0xffff0000) & 0x10000000)
     (*(&_jit->comp->function->regset) |= 1LL << (regno));
}
<<<sep_in_sample>>>
1 6
2 5
3 6
4 6
5 8
6 7
7 8
8 9
9 12
10 12
11 12
12 12
13 12
14 14
15 14
16 14
17 14
18 14
19 13
20 13
21 14
22 14
23 14
24 14
25 12
26 12
27 12
28 12
29 11
30 11
31 11
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm5        # 6c8 <gsl_cdf_beta_Q+0x8>
ucomisd %xmm5,%xmm0
jb     6d8 <gsl_cdf_beta_Q+0x18>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
jae    700 <gsl_cdf_beta_Q+0x40>
movapd %xmm0,%xmm4
movapd %xmm2,%xmm3
movsd  0x0(%rip),%xmm0        # 6f2 <gsl_cdf_beta_Q+0x32>
movapd %xmm1,%xmm2
movapd %xmm5,%xmm1
jmpq   240 <beta_inc_AXPY>
nop
movapd %xmm5,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_beta_Q (const double x, const double a, const double b)
{
  double Q;
  if ( x >= 1.0)
    {
      return 0.0;
    }
  if ( x <= 0.0 )
    {
      return 1.0;
    }
  Q = beta_inc_AXPY (-1.0, 1.0, a, b, x);
  return Q;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 8
8 8
9 8
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 10
18 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xffffffff,%edi
movl   $0x1,0x0(%rip)        # 1a71 <togxbinary+0x11>
movzbl 0x0(%rip),%eax        # 1a78 <togxbinary+0x18>
je     1ae0 <togxbinary+0x80>
and    $0x2,%eax
cmp    $0x1,%edi
je     1ac0 <togxbinary+0x60>
test   %al,%al
je     1aa8 <togxbinary+0x48>
mov    $0x0,%edi
callq  1a90 <togxbinary+0x30>
mov    $0x2,%edi
callq  1a9a <togxbinary+0x3a>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  1ab2 <togxbinary+0x52>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
test   %al,%al
je     1af0 <togxbinary+0x90>
mov    $0x0,%edi
callq  1ace <togxbinary+0x6e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
xor    %edi,%edi
and    $0x2,%eax
sete   %dil
jmp    1a7d <togxbinary+0x1d>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  1afa <togxbinary+0x9a>
mov    $0x2,%edi
callq  1b04 <togxbinary+0xa4>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
togxbinary (int val)
{
  donebinarytoggle = 1;
  if (val == -1)
    val = (options[0]&0x02) ? 0 : 1;
  if (val == 1)
    {
      if ((options[0]&0x02))
 {
   printf ("Already transmitting in binary mode.\n");
 }
      else
 {
   printf ("Negotiating binary mode on output.\n");
   tel_enter_binary (2);
 }
    }
  else
    {
      if ((!(options[0]&0x02)))
 {
   printf ("Already transmitting in network ascii mode.\n");
 }
      else
 {
   printf ("Negotiating network ascii mode on output.\n");
   tel_leave_binary (2);
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 4
6 4
7 6
8 6
9 20
10 20
11 26
12 26
13 27
14 27
15 31
16 31
17 31
18 31
19 22
20 22
21 31
22 31
23 31
24 31
25 8
26 8
27 10
28 10
29 31
30 31
31 31
32 31
33 5
34 5
35 5
36 5
37 5
38 14
39 14
40 15
41 15
42 31
43 31
44 31
45 31
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30 <xfree+0x10>
jmpq   2a <xfree+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   3a <xfree+0x1a>
<<<sep_in_sample>>>
xfree(pointer)
    void *pointer;
{
    if (pointer)
 free(pointer);
    else
 fatal("xfree: trying to free NULL");
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
6 7
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    (%rdi),%rdi
mov    0x20(%rsp),%r10
mov    0x28(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %r10,0x8(%rsp)
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  0 <interp2d_eval>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_eval_deriv_x_e (const gsl_interp2d * interp, const double xarr[],
                             const double yarr[], const double zarr[],
                             const double x, const double y,
                             gsl_interp_accel * xa, gsl_interp_accel * ya, double * z)
{
  return interp2d_eval(interp->type->eval_deriv_x, interp,
                       xarr, yarr, zarr, x, y, xa, ya, z);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  6e <findsymbol+0xe>
mov    %rax,%rbp
callq  0 <common>
mov    $0x0,%r9d
mov    %rax,%rcx
mov    %rbp,%r8
mov    $0x0,%edx
mov    $0x400,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  98 <findsymbol+0x38>
mov    $0x0,%edi
callq  a2 <findsymbol+0x42>
test   %eax,%eax
je     b8 <findsymbol+0x58>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  c0 <findsymbol+0x60>
mov    %rax,%rbx
callq  0 <common>
mov    $0x0,%r9d
mov    %rax,%rcx
mov    %rbx,%r8
mov    $0x0,%edx
mov    $0x400,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  ea <findsymbol+0x8a>
mov    $0x0,%edi
callq  f4 <findsymbol+0x94>
test   %eax,%eax
jne    a6 <findsymbol+0x46>
xor    %eax,%eax
jmp    ab <findsymbol+0x4b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
findsymbol(char *pattern)
{
 snprintf(comline, sizeof(comline), "%s -d %s > %s", common(), quote_shell(pattern), temp1);
 if (system(comline) != 0)
  return "global command failed";
 snprintf(comline, sizeof(comline), "%s -rs %s >> %s", common(), quote_shell(pattern), temp1);
 if (system(comline) != 0)
  return "global command failed";
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 5
21 10
22 10
23 10
24 10
25 10
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 7
39 7
40 7
41 7
42 9
43 9
44 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  7cb <update_progress_meter+0xb>
mov    %rax,%rbx
mov    (%rax),%ebp
callq  70 <can_output>
test   %eax,%eax
je     7de <update_progress_meter+0x1e>
callq  7de <update_progress_meter+0x1e>
mov    $0x0,%esi
mov    $0xe,%edi
callq  7ed <update_progress_meter+0x2d>
mov    $0x1,%edi
callq  7f7 <update_progress_meter+0x37>
mov    %ebp,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
update_progress_meter(int ignore)
{
 int save_errno;
 save_errno = (*__errno_location ());
 if (can_output())
  refresh_progress_meter();
 signal(14, update_progress_meter);
 alarm(1);
 (*__errno_location ()) = save_errno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 8
15 8
16 9
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  1621 <compare_sum_entry+0x11>
mov    0x0(%rbp),%rdi
mov    %rax,%rbx
callq  162d <compare_sum_entry+0x1d>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
pop    %rbp
jmpq   163e <compare_sum_entry+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
compare_sum_entry(struct hashtab_elem **s1, struct hashtab_elem **s2)
{
  struct command_data *ud1 = hashtab_get_value (*s1);
  struct command_data *ud2 = hashtab_get_value (*s2);
  return compare_stats_entry (&(ud1->s), &(ud2->s));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 3
9 4
10 6
11 5
12 5
13 6
14 6
15 5
16 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  3cdc <gsl_sf_ellint_RF+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3cf0 <gsl_sf_ellint_RF+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x285,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d06 <gsl_sf_ellint_RF+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_RF(double x, double y, double z, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_RF_e(x, y, z, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_RF_e(x, y, z, mode, &result)", "ellint.c", 645, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    %rsi,%rax
nopl   0x0(%rax,%rax,1)
lea    0x1(%rax),%rsi
cmp    %rsi,%rdx
jbe    2b <gsl_interp_bsearch+0x2b>
lea    (%rdx,%rax,1),%rcx
shr    %rcx
movsd  (%rdi,%rcx,8),%xmm1
ucomisd %xmm0,%xmm1
jbe    30 <gsl_interp_bsearch+0x30>
mov    %rcx,%rdx
cmp    %rsi,%rdx
ja     11 <gsl_interp_bsearch+0x11>
repz retq 
nopl   (%rax)
mov    %rcx,%rax
jmp    8 <gsl_interp_bsearch+0x8>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_bsearch(const double x_array[], double x,
                   size_t index_lo, size_t index_hi)
{
  size_t ilo = index_lo;
  size_t ihi = index_hi;
  while(ihi > ilo + 1) {
    size_t i = (ihi + ilo)/2;
    if(x_array[i] > x)
      ihi = i;
    else
      ilo = i;
  }
  return ilo;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 7
7 7
8 8
9 8
10 8
11 7
12 6
13 6
14 14
15 14
16 7
17 7
18 7
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %rdi,%r12
push   %rbp
push   %rbx
je     218 <array_dequote_escapes+0x68>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     218 <array_dequote_escapes+0x68>
mov    0x10(%rdi),%edx
test   %edx,%edx
je     218 <array_dequote_escapes+0x68>
mov    0x10(%rax),%rbx
cmp    %rbx,%rax
je     20b <array_dequote_escapes+0x5b>
nopl   (%rax)
mov    0x8(%rbx),%rdi
callq  1e1 <array_dequote_escapes+0x31>
mov    0x8(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     1fc <array_dequote_escapes+0x4c>
mov    $0x17c,%edx
mov    $0x0,%esi
callq  1fc <array_dequote_escapes+0x4c>
mov    %rbp,0x8(%rbx)
mov    0x10(%rbx),%rbx
cmp    %rbx,0x18(%r12)
jne    1d8 <array_dequote_escapes+0x28>
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
array_dequote_escapes(array)
ARRAY *array;
{
 ARRAY_ELEMENT *a;
 char *t;
 if (array == 0 || ((array)->head) == 0 || ((array)->num_elements == 0))
  return (ARRAY *)((void *)0);
 for (a = ((array->head)->next); a != array->head; a = ((a)->next)) {
  t = dequote_escapes (a->value);
  do { if (a->value) sh_xfree((a->value), "array.c", 380); } while (0);
  a->value = t;
 }
 return array;
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 3
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 9
18 9
19 10
20 9
21 10
22 10
23 10
24 10
25 10
26 11
27 8
28 8
29 8
30 14
31 14
32 3
33 14
34 14
35 14
36 14
37 14
38 7
39 14
40 14
41 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  1e <_mu_rfc822_size+0xe>
mov    (%rax),%rdi
mov    %rbx,%rsi
mov    %rax,%rbp
callq  2c <_mu_rfc822_size+0x1c>
test   %eax,%eax
jne    3b <_mu_rfc822_size+0x2b>
mov    0x20(%rbp),%rdx
add    0x10(%rbp),%rdx
sub    %rdx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mu_rfc822_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _mu_rfc822_stream *s = mu_stream_get_owner (stream);
  int rc = mu_stream_size (s->stream, psize);
  if (rc == 0)
    *psize -= s->envelope_length + s->mark_length;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
lea    0x0(,%rdx,4),%r10
xor    %edx,%edx
test   %rcx,%rcx
push   %rbx
mov    %rsi,%rbx
je     cc0 <gsl_permute_float+0x80>
nopl   0x0(%rax,%rax,1)
mov    (%rdi,%rdx,8),%rax
cmp    %rax,%rdx
jae    c71 <gsl_permute_float+0x31>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%rdx
jb     c68 <gsl_permute_float+0x28>
cmp    %rax,%rdx
ja     cb4 <gsl_permute_float+0x74>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     cb4 <gsl_permute_float+0x74>
movss  (%rbx),%xmm1
jmp    c8e <gsl_permute_float+0x4e>
nopl   (%rax)
mov    %r8,%rax
mov    %r9,%r8
mov    %r10,%r11
mov    (%rdi,%r8,8),%r9
imul   %r8,%r11
imul   %r10,%rax
add    %rsi,%r11
cmp    %r9,%rdx
movss  (%r11),%xmm0
movss  %xmm0,(%rsi,%rax,1)
jne    c88 <gsl_permute_float+0x48>
movss  %xmm1,(%r11)
add    $0x1,%rdx
add    %r10,%rbx
cmp    %rcx,%rdx
jne    c58 <gsl_permute_float+0x18>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_float (const size_t * p, float * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        float t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                float r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 4
7 4
8 6
9 7
10 7
11 7
12 8
13 7
14 7
15 9
16 9
17 11
18 12
19 12
20 18
21 18
22 18
23 18
24 27
25 23
26 27
27 23
28 24
29 23
30 19
31 23
32 24
33 19
34 30
35 4
36 4
37 4
38 4
39 34
40 34
41 34
42 34
<<<sep_out_sample>>>
push   %rbx
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # f <main+0xf>
callq  14 <main+0x14>
test   %eax,%eax
jle    50 <main+0x50>
cmp    $0x5,%ebx
ja     8 <main+0x8>
mov    %ebx,%edx
nop
jmpq   *0x0(,%rdx,8)
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 37 <main+0x37>
xor    %ebx,%ebx
cmp    $0x3e,%eax
sete   %bl
lea    (%rbx,%rbx,4),%ebx
callq  47 <main+0x47>
test   %eax,%eax
jg     18 <main+0x18>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ebx,%ebx
cmp    $0x6b,%eax
sete   %bl
shl    $0x2,%ebx
jmp    8 <main+0x8>
nopl   (%rax)
xor    %ebx,%ebx
cmp    $0x72,%eax
sete   %bl
lea    (%rbx,%rbx,2),%ebx
jmp    8 <main+0x8>
nopl   (%rax)
xor    %ebx,%ebx
cmp    $0x67,%eax
sete   %bl
add    %ebx,%ebx
jmp    8 <main+0x8>
nopl   0x0(%rax)
xor    %ebx,%ebx
cmp    $0x3c,%eax
sete   %bl
jmpq   8 <main+0x8>
nopl   (%rax)
cmp    $0x3c,%eax
je     a9 <main+0xa9>
mov    %eax,%edi
callq  a4 <main+0xa4>
jmpq   8 <main+0x8>
xor    %ebx,%ebx
mov    $0xa,%al
jmp    9d <main+0x9d>
<<<sep_in_sample>>>
main(int argc, char **argv)
{
    int c;
    int state = S_INIT;
    while ((c = _IO_getc (stdin)) > 0) {
 switch (state) {
 case S_INIT:
     if (c == '<')
  state = S_OPEN;
     break;
 case S_OPEN:
     if (c == 'g')
  state = S_OG;
     else
  state = S_INIT;
     break;
 case S_OG:
     if (c == 'r')
  state = S_OR;
     else
  state = S_INIT;
     break;
 case S_OR:
     if (c == 'k')
  state = S_OK;
     else
  state = S_INIT;
     break;
 case S_OK:
     if (c == '>')
  state = S_GRK;
     else
  state = S_INIT;
     break;
 case S_GRK:
     if (c == '<') {
  state = S_INIT;
  c = '\n';
     }
     putchar(c);
     break;
 }
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 5
15 15
16 15
17 15
18 15
19 5
20 5
21 5
22 5
23 45
24 45
25 45
26 45
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 8
46 8
47 8
48 8
49 8
50 36
51 36
52 40
53 40
54 41
55 37
56 38
57 38
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
lea    0x320(%rsi),%rsi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movsd  0x640(%rdi),%xmm0
divsd  0x320(%rsi),%xmm0
movsd  %xmm0,0x640(%rdi)
callq  3fd0 <divunit+0x30>
test   %eax,%eax
je     3fe0 <divunit+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
lea    0x320(%rbx),%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   3ff5 <divunit+0x55>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
divunit(struct unittype *left, struct unittype *right)
{
  int myerr;
  left->factor /= right->factor;
  myerr = moveproduct(left->numerator, right->denominator);
  if (!myerr)
    myerr = moveproduct(left->denominator, right->numerator);
  return myerr;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 6
12 6
13 9
14 9
15 9
16 9
17 9
18 9
19 7
20 7
21 9
22 9
23 7
24 7
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x210,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
test   %rdi,%rdi
jne    3b8c <pathwalk+0x7c>
jmp    3bb0 <pathwalk+0xa0>
nopl   (%rax)
sub    %ebx,%eax
movslq %eax,%rbp
mov    %rbx,%rsi
mov    %rsp,%rdi
mov    %rbp,%rdx
callq  3b5b <pathwalk+0x4b>
movb   $0x0,(%rsp,%rbp,1)
mov    %r13,%rsi
mov    %rsp,%rdi
callq  *%r14
test   %eax,%eax
jne    3bb2 <pathwalk+0xa2>
mov    %rbx,%rdi
mov    $0x3a,%esi
callq  3b79 <pathwalk+0x69>
test   %rax,%rax
mov    %rax,%rbx
je     3bb0 <pathwalk+0xa0>
xor    %eax,%eax
cmp    %rbx,%r12
setne  %al
add    %rax,%rbx
mov    $0x3a,%esi
mov    %rbx,%rdi
callq  3b99 <pathwalk+0x89>
test   %rax,%rax
jne    3b48 <pathwalk+0x38>
mov    %rbx,%rdi
callq  3ba6 <pathwalk+0x96>
jmp    3b4a <pathwalk+0x3a>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
mov    0x208(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    3bd5 <pathwalk+0xc5>
add    $0x210,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
callq  3bda <pathwalk+0xca>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pathwalk (char *path, PathWalkProc proc, void *context)
{
  char buf[512];
  char *cp;
  char *cp2;
  int len, i;
  for (cp = path; cp; cp = strchr (cp, ':'))
    {
      if (cp != path)
 cp++;
      cp2 = strchr (cp, ':');
      if (cp2)
 len = cp2 - cp;
      else
 len = strlen (cp);
      memcpy (buf, cp, len);
      buf[len] = '\0';
      i = (*proc) (buf, context);
      if (i != 0)
 return i;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 7
10 2
11 2
12 2
13 2
14 7
15 7
16 7
17 7
18 13
19 16
20 16
21 16
22 16
23 16
24 17
25 18
26 18
27 18
28 19
29 19
30 7
31 7
32 7
33 7
34 7
35 7
36 10
37 10
38 10
39 10
40 11
41 11
42 11
43 12
44 12
45 15
46 15
47 15
48 15
49 22
50 23
51 23
52 23
53 23
54 23
55 23
56 23
57 23
58 23
59 23
60 23
61 23
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_dcpi1_bdiv_qr_n_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_oset_nx_create_empty (gl_oset_implementation_t implementation,
                         gl_setelement_compar_fn compar_fn,
                         gl_setelement_dispose_fn dispose_fn)
{
  return implementation->nx_create_empty (implementation, compar_fn,
                                          dispose_fn);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
mov    %rsi,%rdi
push   %r14
push   %r13
push   %r12
mov    %ecx,%r12d
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    %rdx,0x8(%rsp)
callq  1354 <getoption+0x24>
movzbl (%r15),%edx
cmp    $0x3b,%dl
je     13cd <getoption+0x9d>
test   %dl,%dl
je     13cd <getoption+0x9d>
lea    0x1(%rax),%eax
mov    %r15,%rdi
xor    %r14d,%r14d
mov    %eax,0x4(%rsp)
xchg   %ax,%ax
mov    %rbx,%rsi
callq  1378 <getoption+0x48>
test   %eax,%eax
je     13e8 <getoption+0xb8>
movslq %r14d,%rbp
lea    (%r15,%rbp,1),%r13
movzbl 0x0(%r13),%eax
cmp    $0xa,%al
je     13b7 <getoption+0x87>
test   %al,%al
lea    0x1(%r15,%rbp,1),%rax
setne  %cl
test   %cl,%cl
jne    13a5 <getoption+0x75>
jmp    13b7 <getoption+0x87>
nopl   0x0(%rax)
test   %r8b,%r8b
je     13b7 <getoption+0x87>
movzbl (%rax),%r8d
add    $0x1,%r14d
add    $0x1,%rax
cmp    $0xa,%r8b
jne    13a0 <getoption+0x70>
add    $0x1,%r14d
movslq %r14d,%rdx
lea    (%r15,%rdx,1),%rdi
movzbl (%rdi),%eax
cmp    $0x3b,%al
je     13cd <getoption+0x9d>
test   %al,%al
jne    1370 <getoption+0x40>
xor    %r14d,%r14d
add    $0x18,%rsp
mov    %r14d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
add    0x4(%rsp),%r14d
mov    $0x0,%esi
movslq %r14d,%rbp
lea    (%r15,%rbp,1),%r13
mov    %r13,%rdi
callq  1401 <getoption+0xd1>
test   %eax,%eax
je     1438 <getoption+0x108>
test   %r12d,%r12d
je     1383 <getoption+0x53>
mov    0x0(%rip),%rdi        # 1415 <getoption+0xe5>
mov    0x0(%rip),%edx        # 141b <getoption+0xeb>
mov    $0x0,%esi
xor    %eax,%eax
callq  1427 <getoption+0xf7>
mov    $0x1,%edi
callq  1431 <getoption+0x101>
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
add    $0x2,%r14d
test   %rdi,%rdi
je     13d0 <getoption+0xa0>
movslq %r14d,%rsi
add    %r15,%rsi
callq  1451 <getoption+0x121>
lea    0x1(%r14,%rax,1),%r14d
jmpq   13d0 <getoption+0xa0>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getoption(char *step, char *key, char *optvalue, int equals)
{
  int s;
  int keylen;
  keylen = strlen(key);
  for (s = 0; step[s] && step[s] != ';'; s++)
    {
      if (!linecmp(step + s, key))
 {
   s += keylen + 1;
   if (!linecmp(step + s, "="))
     {
       s += 2;
       if (optvalue)
  s += linecpy(optvalue, step + s) + 1;
       return s;
     }
   else if (equals)
     {
       fprintf(stderr, "sbstrans: before %d: missing = in option\n", sbslineno);
       exit(1);
     }
 }
      while (step[s] && step[s] != '\n')
 s++;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 6
22 10
23 10
24 8
25 8
26 8
27 8
28 8
29 8
30 24
31 24
32 24
33 24
34 24
35 24
36 24
37 24
38 24
39 24
40 24
41 24
42 24
43 25
44 25
45 24
46 24
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
55 27
56 28
57 28
58 28
59 28
60 28
61 28
62 28
63 28
64 28
65 28
66 10
67 11
68 11
69 11
70 11
71 11
72 11
73 11
74 18
75 18
76 20
77 20
78 20
79 20
80 20
81 21
82 21
83 21
84 14
85 13
86 14
87 14
88 15
89 15
90 15
91 15
92 15
93 15
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%r9
mov    0x8(%rsi),%r10
je     12df <gsl_vector_uchar_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12d5 <gsl_vector_uchar_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
xor    %ecx,%ecx
test   %r8,%r8
je     130b <gsl_vector_uchar_swap+0x6b>
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%esi
movzbl (%rax),%edi
add    $0x1,%rcx
mov    %dil,(%rdx)
mov    %sil,(%rax)
add    %r9,%rdx
add    %r10,%rax
cmp    %r8,%rcx
jne    12f0 <gsl_vector_uchar_swap+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_uchar_swap (gsl_vector_uchar * v, gsl_vector_uchar * w)
{
  unsigned char * d1 = v->data ;
  unsigned char * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          unsigned char tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 13
18 13
19 13
20 13
21 17
22 18
23 13
24 18
25 19
26 19
27 19
28 13
29 13
30 22
31 23
32 23
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    %rdx,%rcx
cmp    $0x1,%eax
je     2e8 <gc_hash_write+0x28>
cmp    $0x2,%eax
jne    2e0 <gc_hash_write+0x20>
lea    0xb8(%rdi),%rdx
mov    %rcx,%rdi
jmpq   2de <gc_hash_write+0x1e>
xchg   %ax,%ax
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x1c(%rdi),%rdx
mov    %rcx,%rdi
jmpq   2f4 <gc_hash_write+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gc_hash_write (gc_hash_handle handle, size_t len, const char *data)
{
  _gc_hash_ctx *ctx = handle;
  switch (ctx->alg)
    {
    case GC_MD5:
      md5_process_bytes (data, len, &ctx->md5Context);
      break;
    case GC_SHA1:
      sha1_process_bytes (data, len, &ctx->sha1Context);
      break;
    default:
      break;
    }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 10
8 10
9 10
10 10
11 10
12 10
13 7
14 7
15 7
16 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     150 <malloc_watch+0x60>
movslq 0x0(%rip),%rcx        # fc <malloc_watch+0xc>
mov    %ecx,%esi
sub    $0x1,%esi
js     12d <malloc_watch+0x3d>
movslq %esi,%rax
cmp    %rdi,0x0(,%rax,8)
je     150 <malloc_watch+0x60>
mov    %esi,%eax
jmp    125 <malloc_watch+0x35>
nopl   0x0(%rax)
movslq %eax,%rdx
cmp    %rdi,0x0(,%rdx,8)
je     150 <malloc_watch+0x60>
sub    $0x1,%eax
cmp    $0xffffffff,%eax
jne    118 <malloc_watch+0x28>
xor    %eax,%eax
cmp    $0x20,%ecx
je     158 <malloc_watch+0x68>
lea    0x1(%rcx),%edx
mov    %rdi,0x0(,%rcx,8)
mov    %edx,0x0(%rip)        # 145 <malloc_watch+0x55>
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
test   %esi,%esi
mov    0x0(%rip),%rax        # 161 <malloc_watch+0x71>
jle    184 <malloc_watch+0x94>
mov    $0x0,%edx
nopl   0x0(%rax,%rax,1)
mov    (%rdx),%rcx
add    $0x8,%rdx
mov    %rcx,-0x10(%rdx)
cmp    $0x0,%rdx
jne    170 <malloc_watch+0x80>
movslq %esi,%rcx
jmp    134 <malloc_watch+0x44>
nopl   0x0(%rax)
<<<sep_in_sample>>>
malloc_watch (addr)
     void * addr;
{
  register int i;
  void * ret;
  if (addr == 0)
    return addr;
  ret = (void *)0;
  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
        break;
    }
  if (i < 0)
    {
      if (_malloc_nwatch == 32)
 {
   ret = _malloc_watch_list[0];
   _malloc_nwatch--;
   for (i = 0; i < _malloc_nwatch; i++)
     _malloc_watch_list[i] = _malloc_watch_list[i+1];
 }
      _malloc_watch_list[_malloc_nwatch++] = addr;
    }
  return ret;
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 9
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 9
17 9
18 9
19 8
20 16
21 16
22 23
23 23
24 23
25 23
26 23
27 23
28 23
29 23
30 20
31 18
32 20
33 20
34 20
35 21
36 21
37 21
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    %rsi,%rdi
je     7b0 <api_clear_array+0x40>
movabs $0x2000ffffffff,%rdx
and    0x40(%rsi),%rdx
xor    %eax,%eax
cmp    $0x5,%rdx
je     790 <api_clear_array+0x20>
retq   
nop
sub    $0x8,%rsp
mov    (%rsi),%rax
xor    %esi,%esi
callq  *0x28(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
api_clear_array(awk_ext_id_t id, awk_array_t a_cookie)
{
 NODE *node = (NODE *) a_cookie;
 if ( node == ((void *)0)
     || node->type != Node_var_array
     || (node->flags & 0x2000) != 0)
  return awk_false;
 (void) ((node)->sub.nodep.l.lp[5](node, ((void *)0)));
 return awk_true;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 6
5 6
6 7
7 6
8 6
9 10
10 10
11 2
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 7
20 7
21 7
<<<sep_out_sample>>>
mov    0x30(%rdi),%rcx
mov    %rdx,%r8
xor    %edx,%edx
jmpq   4a0 <gl_array_sortedlist_indexof_from_to>
xchg   %ax,%ax
<<<sep_in_sample>>>
gl_array_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
                             const void *elt)
{
  return gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count,
                                              elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_int_data (const gsl_block_int * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
closeScene()
{
 int i;
 for (i=0; i<128; ++i) {
  if (stbl[i].type != 0) {
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    %esi,0x48(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_set_preview_level(TARU * taru, int preview_level)
{
 taru->preview_levelM = preview_level;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_digest (osip_authorization_t * authorization)
{
  return authorization->digest;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %esi,%r12d
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
cmp    %r12d,(%rbx)
je     188 <selectNamedWeapon+0x38>
add    $0x1,%ebp
add    $0x38,%rbx
cmp    $0x4,%ebp
jne    167 <selectNamedWeapon+0x17>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    %r13,%rdi
callq  *0x8(%rbx)
cmp    $0x1,%eax
jne    16c <selectNamedWeapon+0x1c>
mov    %ebp,0x868(%r13)
jmp    17a <selectNamedWeapon+0x2a>
nopl   0x0(%rax)
<<<sep_in_sample>>>
selectNamedWeapon(craft * c, int id)
{
 int n;
 for (n = 0; n < 4; ++n) {
  if (wtbl[n].mask == id && (*wtbl[n].select) (c) == 1) {
   c->curWeapon = n;
   return 1;
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 2
8 2
9 2
10 5
11 5
12 4
13 4
14 4
15 4
16 10
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 6
29 7
30 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
lea    0x1c(%rsp),%rdi
fstpt  (%rsp)
callq  31 <printf_frexpl+0x31>
mov    0x1c(%rsp),%edx
fadd   %st(0),%st
lea    -0x1(%rdx),%eax
cmp    $0xffffc002,%eax
mov    %eax,0x1c(%rsp)
jge    58 <printf_frexpl+0x58>
fstpt  (%rsp)
lea    0x3ffd(%rdx),%edi
callq  53 <printf_frexpl+0x53>
mov    $0xffffc002,%eax
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 7
17 8
18 9
19 8
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 17
29 17
30 17
31 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    $0x1,%ebx
sub    $0x8,%rsp
cmpq   $0x0,0x40(%rdi)
je     2b0 <rec_sex_ast_print_node+0x30>
mov    0x20(%rbp,%rbx,8),%rdi
callq  29f <rec_sex_ast_print_node+0x1f>
cmp    %rbx,0x40(%rbp)
lea    0x1(%rbx),%rax
jbe    2b0 <rec_sex_ast_print_node+0x30>
mov    %rax,%rbx
jmp    295 <rec_sex_ast_print_node+0x15>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  2bc <rec_sex_ast_print_node+0x3c>
mov    0x0(%rbp),%esi
xor    %eax,%eax
mov    $0x0,%edi
callq  2cb <rec_sex_ast_print_node+0x4b>
mov    0x0(%rbp),%eax
cmp    $0x18,%eax
je     308 <rec_sex_ast_print_node+0x88>
cmp    $0x1b,%eax
je     320 <rec_sex_ast_print_node+0xa0>
cmp    $0x1a,%eax
je     2f0 <rec_sex_ast_print_node+0x70>
add    $0x8,%rsp
mov    $0x0,%edi
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   2ef <rec_sex_ast_print_node+0x6f>
nop
mov    0x8(%rbp),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  300 <rec_sex_ast_print_node+0x80>
jmp    2dd <rec_sex_ast_print_node+0x5d>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%esi
xor    %eax,%eax
mov    $0x0,%edi
callq  317 <rec_sex_ast_print_node+0x97>
mov    0x0(%rbp),%eax
cmp    $0x1b,%eax
jne    2d8 <rec_sex_ast_print_node+0x58>
nop
mov    0x8(%rbp),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  330 <rec_sex_ast_print_node+0xb0>
mov    0x0(%rbp),%eax
jmp    2d8 <rec_sex_ast_print_node+0x58>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_print_node (rec_sex_ast_node_t node)
{
  int i;
  for (i = 0; i < node->num_children; i++)
    {
      rec_sex_ast_print_node (node->children[i]);
    }
  __printf__ ("------- node\n");
  __printf__ ("type: %d\n", node->type);
  if (node->type == REC_SEX_INT)
    {
      __printf__("value: %d\n", node->val.integer);
    }
  if (node->type == REC_SEX_NAME)
    {
      __printf__("value: %s\n", node->val.name[0]);
    }
  if (node->type == REC_SEX_STR)
    {
      __printf__("value: %s\n", node->val.string);
    }
  __printf__("\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 6
9 6
10 4
11 4
12 4
13 4
14 4
15 4
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 14
27 14
28 18
29 18
30 23
31 22
32 22
33 23
34 23
35 22
36 22
37 20
38 20
39 20
40 20
41 20
42 20
43 12
44 12
45 12
46 12
47 12
48 14
49 14
50 14
51 16
52 16
53 16
54 16
55 16
56 16
57 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d8 <sdp_message_i_info_set+0x38>
cmp    $0xffffffff,%esi
push   %rbx
mov    %rdx,%rbx
je     1d0 <sdp_message_i_info_set+0x30>
add    $0xb8,%rdi
callq  1ba <sdp_message_i_info_set+0x1a>
test   %rax,%rax
je     1de <sdp_message_i_info_set+0x3e>
mov    %rbx,0x30(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %rdx,0x40(%rdi)
xor    %eax,%eax
pop    %rbx
retq   
mov    $0xfffffffe,%eax
retq   
mov    $0xffffffff,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_i_info_set (sdp_message_t * sdp, int pos_media, char *info)
{
  sdp_media_t *med;
  if (sdp == ((void *)0))
    return -2;
  if (pos_media == -1) {
    sdp->i_info = info;
    return 0;
  }
  med = osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return -1;
  med->i_info = info;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 2
5 2
6 6
7 10
8 10
9 11
10 11
11 13
12 14
13 15
14 15
15 15
16 7
17 8
18 15
19 15
20 5
21 15
22 12
23 15
24 15
25 15
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ping_set_count (PING * ping, size_t count)
{
  ping->ping_count = count;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
test   %rsi,%rsi
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
cmove  0x0(%rip),%rbp        # 2fb <__gmpz_inp_str+0x1b>
push   %rbx
xor    %ebx,%ebx
callq  303 <__gmpz_inp_str+0x23>
mov    %rax,%r14
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbp,%rdi
add    $0x1,%rbx
callq  31c <__gmpz_inp_str+0x3c>
mov    (%r14),%r8
movslq %eax,%rdx
testb  $0x20,0x1(%r8,%rdx,2)
jne    310 <__gmpz_inp_str+0x30>
mov    %rbx,%r8
mov    %rbp,%rsi
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13d,%edx
mov    %eax,%ecx
pop    %r13
pop    %r14
jmpq   345 <__gmpz_inp_str+0x65>
<<<sep_in_sample>>>
__gmpz_inp_str (mpz_ptr x, FILE *stream, int base)
{
  int c;
  size_t nread;
  if (stream == 0)
    stream = stdin;
  nread = 0;
  do
    {
      c = _IO_getc (stream);
      nread++;
    }
  while (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace));
  return __gmpz_inp_str_nowhite (x, stream, base, c, nread);
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 2
11 7
12 7
13 7
14 7
15 10
16 11
17 10
18 13
19 13
20 13
21 13
22 14
23 14
24 14
25 15
26 15
27 15
28 14
29 14
30 15
31 15
32 14
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%eax
mov    %rdi,%rbx
mov    0x10(%rdi),%rbp
test   %eax,%eax
je     80 <dumpdir_next+0x40>
mov    (%rdi),%rax
mov    %rbp,%r12
add    (%rax),%r12
cmpb   $0x0,(%r12)
je     a8 <dumpdir_next+0x68>
mov    %r12,%rdi
callq  6a <dumpdir_next+0x2a>
lea    0x1(%rbp,%rax,1),%rax
mov    %rax,0x10(%rbx)
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rdi),%rdx
xor    %eax,%eax
cmp    0x10(%rdx),%rbp
jae    76 <dumpdir_next+0x36>
mov    0x18(%rdx),%rax
mov    (%rax,%rbp,8),%rax
add    $0x1,%rbp
mov    %rbp,0x10(%rdi)
pop    %rbx
pop    %rbp
sub    $0x1,%rax
pop    %r12
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    76 <dumpdir_next+0x36>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dumpdir_next (struct dumpdir_iter *itr)
{
  size_t cur = itr->next;
  char *ret = ((void *)0);
  if (itr->all)
    {
      ret = itr->dump->contents + cur;
      if (*ret == 0)
 return ((void *)0);
      itr->next += strlen (ret) + 1;
    }
  else if (cur < itr->dump->elc)
    {
      ret = itr->dump->elv[cur] - 1;
      itr->next++;
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 2
6 3
7 5
8 5
9 7
10 7
11 7
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 18
20 18
21 18
22 18
23 18
24 12
25 9
26 12
27 12
28 14
29 14
30 15
31 15
32 18
33 18
34 14
35 18
36 18
37 18
38 9
39 9
40 9
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edx,%edx
callq  1580 <findEntry>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
headerIsEntry(Header h, int_32 tag)
{
    return (findEntry(h, tag, 0) ? 1 : 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 3
8 4
9 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 17 <do_last_file+0x7>
sub    $0x1,%rax
mov    %rax,0x0(%rip)        # 22 <do_last_file+0x12>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_last_file(void)
{
    selected = filelist_len - 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdi,%rdi
je     89d <_dico_list_remove+0x4d>
mov    0x8(%rdi),%rbx
test   %rbx,%rbx
je     89d <_dico_list_remove+0x4d>
mov    %rdx,%rbp
test   %rdx,%rdx
mov    $0x0,%eax
mov    %rsi,%r12
mov    %rcx,%r14
cmove  %rax,%rbp
nopw   0x0(%rax,%rax,1)
mov    0x10(%rbx),%rdi
mov    %r12,%rsi
callq  *%rbp
test   %eax,%eax
je     8c0 <_dico_list_remove+0x70>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    888 <_dico_list_remove+0x38>
callq  8a2 <_dico_list_remove+0x52>
movl   $0x2,(%rax)
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    %r14,%rdx
mov    %rbx,%rsi
mov    %r13,%rdi
mov    %eax,0xc(%rsp)
callq  60 <_dico_list_remove_item>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_dico_list_remove(struct dico_list *list, void *data, dico_list_comp_t cmp,
    void **pptr)
{
    struct list_entry *p;
    if (!list || !list->head) {
 (*__errno_location ()) = 2;
 return 1;
    }
    if (!cmp)
 cmp = cmp_ptr;
    for (p = list->head; p; p = p->next)
 if (cmp(p->data, data) == 0)
     break;
    if (!p) {
 (*__errno_location ()) = 2;
 return 1;
    }
    _dico_list_remove_item(list, p, pptr);
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 5
14 10
15 10
16 10
17 10
18 10
19 10
20 12
21 12
22 12
23 12
24 12
25 11
26 11
27 11
28 15
29 15
30 20
31 16
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 18
40 18
41 18
42 18
43 18
44 18
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 20
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     69f <swlib_test_verbose+0xf>
cmp    %esi,0xc(%rdi)
mov    $0x1,%eax
jle    6d8 <swlib_test_verbose+0x48>
test   %esi,%esi
jg     6e0 <swlib_test_verbose+0x50>
cmp    $0x2,%esi
jg     6ef <swlib_test_verbose+0x5f>
cmp    0x0(%rip),%esi        # 6ae <swlib_test_verbose+0x1e>
jl     6c6 <swlib_test_verbose+0x36>
test   %edx,%edx
mov    $0x1,%eax
jne    700 <swlib_test_verbose+0x70>
cmp    $0x5,%esi
jg     702 <swlib_test_verbose+0x72>
xor    %eax,%eax
test   %ecx,%ecx
sete   %al
retq   
cmp    $0x5,%esi
setg   %dl
xor    %eax,%eax
test   %ecx,%ecx
setne  %al
and    %edx,%eax
nopl   (%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
test   %r8d,%r8d
mov    $0x1,%eax
jne    6d8 <swlib_test_verbose+0x48>
cmp    $0x2,%esi
jle    6a8 <swlib_test_verbose+0x18>
test   %r9d,%r9d
mov    $0x1,%eax
je     6a8 <swlib_test_verbose+0x18>
repz retq 
nopl   0x0(%rax,%rax,1)
repz retq 
test   %ecx,%ecx
je     6be <swlib_test_verbose+0x2e>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_test_verbose(struct swEvents * ev, int verbose_level, int swbis_event,
  int is_swi_event, int event_status, int is_posix_event)
{
 if (
  (ev && (verbose_level >= ev->verbose_threshholdM)) ||
  (verbose_level >= 1 && event_status != 0) ||
  (verbose_level >= 3 && is_posix_event) ||
  (verbose_level >= verbose_swbis_event_thresholdG && swbis_event) ||
  (verbose_level >= 6 && is_swi_event) ||
  (verbose_level >= verbose_swbis_event_thresholdG && !is_swi_event)
 ) {
  return 1;
 } else {
  return 0;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 12
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 8
13 12
14 8
15 8
16 8
17 10
18 10
19 10
20 10
21 9
22 9
23 9
24 9
25 9
26 12
27 12
28 16
29 16
30 5
31 12
32 5
33 6
34 6
35 6
36 12
37 6
38 16
39 16
40 16
41 8
42 8
43 8
44 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x810,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
mov    0x30(%rdi),%rax
movl   $0x2,(%rax)
mov    0x18(%rdi),%rax
add    $0x1,%rax
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x22,-0x2(%rax)
jne    10e0 <ReadReaction_L1+0x30>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  10f9 <ReadReaction_L1+0x49>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1108 <ReadReaction_L1+0x58>
mov    $0x3c,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  1128 <ReadReaction_L1+0x78>
mov    0x18(%rbx),%rdx
jmp    1133 <ReadReaction_L1+0x83>
xchg   %ax,%ax
mov    %rax,%rdx
lea    0x1(%rdx),%rax
mov    %rax,0x18(%rbx)
cmpb   $0x22,(%rdx)
jne    1130 <ReadReaction_L1+0x80>
lea    0x400(%rsp),%rsi
mov    %rdx,0x18(%rbx)
mov    %rbx,%rdi
callq  1154 <ReadReaction_L1+0xa4>
lea    0x400(%rsp),%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  116b <ReadReaction_L1+0xbb>
lea    0x400(%rsp),%rdx
xor    %ecx,%ecx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  1180 <ReadReaction_L1+0xd0>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1190 <ReadReaction_L1+0xe0>
mov    0x808(%rsp),%rax
xor    %fs:0x28,%rax
jne    11ba <ReadReaction_L1+0x10a>
add    $0x810,%rsp
pop    %rbx
retq   
callq  11bf <ReadReaction_L1+0x10f>
nop
<<<sep_in_sample>>>
ReadReaction_L1 (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 60);
  while (*pibIn->pbufCur++ != '"');
  pibIn->pbufCur = pibIn->pbufCur - 1;
  GetaString (pibIn, szEqn);
  printf ("reaction %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 0);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 13
38 12
39 13
40 13
41 14
42 14
43 14
44 14
45 14
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 16
55 16
56 16
57 16
58 17
59 17
60 17
61 17
62 17
63 17
64 17
65 17
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 26f <do_para_begin+0xf>
mov    0x20(%rax),%rbx
cmp    0x8(%rax),%rbx
je     2a1 <do_para_begin+0x41>
mov    %rbx,%rdx
jmp    284 <do_para_begin+0x24>
xchg   %ax,%ax
mov    0x20(%rax),%rdx
mov    0x18(%rdx),%rdi
subq   $0x1,0x40(%rax)
mov    %rdi,0x20(%rax)
callq  296 <do_para_begin+0x36>
test   %al,%al
mov    0x0(%rip),%rax        # 29f <do_para_begin+0x3f>
je     280 <do_para_begin+0x20>
test   %bpl,%bpl
movq   $0x0,0x30(%rax)
jne    2b8 <do_para_begin+0x58>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   2c6 <do_para_begin+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_para_begin(_Bool allow_update)
{
    filestruct *current_save = openfile->current;
    if (openfile->current != openfile->fileage) {
 do {
     openfile->current = openfile->current->prev;
     openfile->current_y--;
 } while (!begpar(openfile->current));
    }
    openfile->current_x = 0;
    if (allow_update)
 edit_redraw(current_save);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 7
15 6
16 8
17 8
18 8
19 8
20 11
21 10
22 11
23 13
24 13
25 13
26 13
27 13
28 13
29 12
30 13
31 13
32 12
33 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 5e <yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  6a <yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  74 <yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    41a8 <gsl_matrix_complex_long_double_const_column+0x38>
shl    $0x5,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  41ca <gsl_matrix_complex_long_double_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_const_column (const gsl_matrix_complex_long_double * m, const size_t j)
{
  _gsl_vector_complex_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 2;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
test   %rsi,%rsi
je     3da <get_version+0xa>
cmpb   $0x0,(%rsi)
jne    3e0 <get_version+0x10>
mov    $0x2,%eax
retq   
jmpq   0 <get_version.part.0>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_version (char const *context, char const *version)
{
  if (version == 0 || *version == 0)
    return numbered_existing_backups;
  else
    return ((backup_types) [__xargmatch_internal (context, version, backup_args, (char const *) (backup_types), sizeof *(backup_types), argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 7
8 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
cmp    $0x2,%edi
je     24 <main+0x24>
mov    (%rsi),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  19 <main+0x19>
mov    $0x1,%eax
add    $0x20,%rsp
pop    %rbx
retq   
mov    0x8(%rsi),%rdi
callq  2d <main+0x2d>
xor    %ecx,%ecx
movzwl %ax,%esi
xor    %edx,%edx
xor    %eax,%eax
movl   $0x0,0x10(%rsp)
movl   $0x78,0x8(%rsp)
movl   $0x3,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x9,%edi
callq  63 <main+0x63>
test   %rax,%rax
mov    %rax,%rbx
je     83 <main+0x83>
mov    0x0(%rip),%rdi        # 72 <main+0x72>
callq  77 <main+0x77>
mov    %rbx,%rdi
callq  7f <main+0x7f>
xor    %eax,%eax
jmp    1e <main+0x1e>
mov    $0x1,%eax
jmp    1e <main+0x1e>
<<<sep_in_sample>>>
main (int argc, char *const *argv)
{
  struct MHD_Daemon *d;
  if (argc != 2)
    {
      printf ("%s PORT\n", argv[0]);
      return 1;
    }
  d = MHD_start_daemon (
   MHD_USE_SELECT_INTERNALLY | MHD_USE_DEBUG,
                        atoi (argv[1]),
                        ((void *)0), ((void *)0), &ahc_echo, "<html><head><title>libmicrohttpd demo</title></head><body>libmicrohttpd demo</body></html>",
   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,
   MHD_OPTION_END);
  if (d == ((void *)0))
    return 1;
  (void) _IO_getc (stdin);
  MHD_stop_daemon (d);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 20
11 20
12 20
13 11
14 11
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 15
27 9
28 15
29 17
30 17
31 18
32 18
33 19
34 19
35 16
36 16
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    $0x0,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
jmpq   12 <areadlinkat+0x12>
<<<sep_in_sample>>>
areadlinkat (int fd, char const *filename)
{
  return careadlinkat (fd, filename, ((void *)0), 0, ((void *)0), readlinkat);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  1cf <call_arg_warn+0xf>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 1d8 <call_arg_warn+0x18>
test   %rax,%rax
je     1df <call_arg_warn+0x1f>
callq  *%rax
mov    %r12,%rdi
callq  1e7 <call_arg_warn+0x27>
mov    $0x0,%edi
mov    %rax,%r12
callq  1f4 <call_arg_warn+0x34>
mov    %ebx,%esi
mov    %rbp,%r8
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
jmpq   20c <call_arg_warn+0x4c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
call_arg_warn (char const *call, char const *name)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot %s"), quotearg_colon (name), call); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 4
24 4
25 4
26 4
27 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  1fb <_body_read+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   21a <_body_read+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_body_read (mu_stream_t stream, char *buffer, size_t n, mu_off_t off, size_t *pn)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_read (body->fstream, buffer, n, off, pn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 4
11 4
12 5
13 4
14 4
15 4
16 5
17 5
18 5
19 4
20 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x10,%rsp
test   %rsi,%rsi
je     232 <osip_message_set_call_id+0x42>
cmpb   $0x0,(%rsi)
mov    %rsi,0x8(%rsp)
je     232 <osip_message_set_call_id+0x42>
cmpq   $0x0,0x98(%rdi)
mov    %rdi,%rbp
mov    $0xfffffffb,%ebx
jne    232 <osip_message_set_call_id+0x42>
lea    0x98(%rdi),%rdi
callq  227 <osip_message_set_call_id+0x37>
test   %eax,%eax
mov    %eax,%ebx
mov    0x8(%rsp),%rsi
je     240 <osip_message_set_call_id+0x50>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x98(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
callq  256 <osip_message_set_call_id+0x66>
test   %eax,%eax
mov    %eax,%r12d
je     232 <osip_message_set_call_id+0x42>
mov    0x98(%rbp),%rdi
mov    %r12d,%ebx
callq  26c <osip_message_set_call_id+0x7c>
movq   $0x0,0x98(%rbp)
jmp    232 <osip_message_set_call_id+0x42>
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_message_set_call_id (osip_message_t * sip, const char *hvalue)
{
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  if (sip->call_id != ((void *)0))
    return -5;
  i = osip_call_id_init (&(sip->call_id));
  if (i != 0)
    return i;
  sip->message_property = 2;
  i = osip_call_id_parse (sip->call_id, hvalue);
  if (i != 0) {
    osip_call_id_free (sip->call_id);
    sip->call_id = ((void *)0);
    return i;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 2
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 7
14 6
15 8
16 8
17 9
18 8
19 9
20 9
21 19
22 19
23 19
24 19
25 19
26 19
27 19
28 12
29 11
30 12
31 13
32 12
33 13
34 14
35 16
36 14
37 15
38 16
39 16
<<<sep_out_sample>>>
push   %r14
mov    %edi,%r14d
mov    0x0(%rip),%rdi        # f0c <rcfile_process_section+0xc>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  f20 <rcfile_process_section+0x20>
test   %rax,%rax
mov    %rax,%rbx
je     f5c <rcfile_process_section+0x5c>
nopl   0x0(%rax,%rax,1)
xor    %ecx,%ecx
mov    %rbx,%rsi
mov    %r12,%r9
mov    %r13,%r8
mov    $0x0,%edx
mov    %r14d,%edi
callq  f48 <rcfile_process_section+0x48>
mov    0x18(%rbx),%rdi
mov    %rbp,%rsi
callq  f54 <rcfile_process_section+0x54>
test   %rax,%rax
mov    %rax,%rbx
jne    f30 <rcfile_process_section+0x30>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rcfile_process_section (int method, char *name, void *data, MESSAGE msg)
{
  RC_SECTION *sec;
  for (sec = rc_section_lookup (parse_tree, name);
       sec; sec = rc_section_lookup (sec->next, name))
    rc_run_section (method, sec, anubis_rc_sections, ((void *)0), data, msg);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 5
24 5
25 5
26 4
27 5
28 4
29 7
30 7
31 7
32 7
33 7
34 7
35 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 11e7 <getcoprocbyname+0x7>
push   %rbx
xor    %ebx,%ebx
test   %rdx,%rdx
je     120c <getcoprocbyname+0x2c>
movzbl (%rdi),%eax
cmp    %al,(%rdx)
jne    120c <getcoprocbyname+0x2c>
mov    %rdi,%rsi
mov    %rdx,%rdi
callq  1201 <getcoprocbyname+0x21>
test   %eax,%eax
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getcoprocbyname (name)
     const char *name;
{
  return ((sh_coproc.c_name && ((sh_coproc.c_name)[0] == (name)[0] && strcmp(sh_coproc.c_name, name) == 0)) ? &sh_coproc : 0);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rstat_min(gsl_rstat_workspace *w)
{
  return w->min;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 639 <cpp_restart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     670 <cpp_restart+0x40>
mov    0x0(%rip),%rdx        # 64a <cpp_restart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     670 <cpp_restart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  560 <cpp__init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   d0 <cpp__load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  240 <cpp_ensure_buffer_stack>
mov    0x0(%rip),%rbp        # 67c <cpp_restart+0x4c>
mov    0x0(%rip),%rax        # 683 <cpp_restart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 68f <cpp_restart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  699 <cpp_restart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    653 <cpp_restart+0x23>
jmp    656 <cpp_restart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_restart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        cpp_ensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            cpp__create_buffer(cpp_in,16384 );
 }
 cpp__init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 cpp__load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
mov    $0x0,%esi
sub    $0x8,%rsp
callq  e <jumpback+0xe>
mov    $0x1,%esi
mov    $0x0,%edi
callq  1d <jumpback+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
jumpback(int sig)
{
 signal(sig, jumpback);
 siglongjmp(env, 1);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    0x1d0(%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
jpeg_write_m_byte (j_compress_ptr cinfo, int val)
{
  (*cinfo->marker->write_marker_byte) (cinfo, val);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # fe7 <psset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psset_out (FILE * out_str )
{
        psout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
movzbl (%rdi),%edx
mov    %rdi,%rax
cmp    $0x2f,%dl
jne    214c <stripped_prefix_len+0x2c>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
movzbl (%rax),%edx
cmp    $0x2f,%dl
je     2130 <stripped_prefix_len+0x10>
test   %dl,%dl
je     2150 <stripped_prefix_len+0x30>
add    $0x1,%rax
cmp    $0x2f,%dl
je     2160 <stripped_prefix_len+0x40>
movzbl (%rax),%edx
test   %dl,%dl
jne    2140 <stripped_prefix_len+0x20>
mov    $0xffffffffffffffff,%rax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x1,%rsi
jne    2174 <stripped_prefix_len+0x54>
jmp    217e <stripped_prefix_len+0x5e>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
movzbl (%rax),%edx
cmp    $0x2f,%dl
je     2170 <stripped_prefix_len+0x50>
jmp    214c <stripped_prefix_len+0x2c>
sub    %rdi,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stripped_prefix_len (char const *file_name, size_t num)
{
  char const *p = file_name + 0;
  while (((*p) == '/'))
    p++;
  while (*p)
    {
      _Bool slash = ((*p) == '/');
      p++;
      if (slash)
 {
   if (--num == 0)
     return p - file_name;
   while (((*p) == '/'))
     p++;
 }
    }
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 4
8 4
9 4
10 6
11 6
12 9
13 10
14 10
15 10
16 6
17 6
18 18
19 19
20 19
21 12
22 12
23 12
24 12
25 15
26 14
27 14
28 14
29 14
30 13
31 13
32 13
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
je     12b0 <add_argless_short_opt+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x10(%rsi)
jne    12a7 <add_argless_short_opt+0x7>
mov    0x18(%rsi),%eax
or     0x18(%rdi),%eax
test   $0x10,%al
jne    12a7 <add_argless_short_opt+0x7>
mov    (%rcx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rcx)
mov    0x8(%rdi),%edx
mov    %dl,(%rax)
jmp    12a7 <add_argless_short_opt+0x7>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_argless_short_opt (const struct argp_option *opt,
                       const struct argp_option *real,
                       const char *domain, void *cookie)
{
  char **snao_end = cookie;
  if (!(opt->arg || real->arg)
      && !((opt->flags | real->flags) & 0x10))
    *(*snao_end)++ = opt->key;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 10
4 10
5 10
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
mov    %rsi,%rbx
callq  967 <gl_linked_nx_add_after+0x17>
test   %rax,%rax
je     986 <gl_linked_nx_add_after+0x36>
mov    (%rbx),%rdx
mov    %r12,0x10(%rax)
mov    %rbx,0x8(%rax)
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
mov    %rax,(%rbx)
addq   $0x1,0x40(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  gl_list_node_t new_node =
    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));
  if (new_node == ((void *)0))
    return ((void *)0);
  new_node->value = elt;
  new_node->prev = node;
  new_node->next = node->next;
  new_node->next->prev = new_node;
  node->next = new_node;
  list->count++;
  return new_node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 3
9 5
10 5
11 9
12 7
13 8
14 9
15 10
16 11
17 12
18 14
19 14
20 14
21 14
22 14
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edi
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  c9 <osip_gettimeofday+0x19>
test   %eax,%eax
js     108 <osip_gettimeofday+0x58>
mov    (%rsp),%rax
mov    0x8(%rsp),%rcx
movabs $0x20c49ba5e353f7cf,%rdx
mov    %rax,(%rbx)
mov    %rcx,%rax
sar    $0x3f,%rcx
imul   %rdx
sar    $0x7,%rdx
sub    %rcx,%rdx
mov    %rdx,0x8(%rbx)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  113 <osip_gettimeofday+0x63>
jmp    f8 <osip_gettimeofday+0x48>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_gettimeofday (struct timeval *tp, void *tz)
{
  struct timespec ts;
  if (clock_gettime (1, &ts) < 0) {
    gettimeofday (tp, tz);
    return 0;
  }
  tp->tv_sec = ts.tv_sec + offset.tv_sec;
  tp->tv_usec = ts.tv_nsec / 1000;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 8
12 9
13 9
14 8
15 9
16 9
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 5
28 5
29 5
30 6
31 6
<<<sep_out_sample>>>
sub    $0x28,%rsp
movslq %edi,%rax
mov    %rdx,%r9
mov    %r8d,0x10(%rsp)
mov    %ecx,0x8(%rsp)
mov    %rsi,%r8
movq   $0x0,(%rsp)
shr    $0x1f,%edi
xor    %ecx,%ecx
mov    $0x4,%edx
mov    %rax,%rsi
callq  50 <to_chars>
add    $0x28,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
major_to_chars (int v, char *p, size_t s, int archive_format, int termch)
{
  to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, "major_t", archive_format, termch);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
jmp    f6e <maildir_deliver_new+0x1e>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2e,0x13(%rax)
jne    f90 <maildir_deliver_new+0x40>
mov    %rbx,%rdi
callq  f76 <maildir_deliver_new+0x26>
test   %rax,%rax
jne    f68 <maildir_deliver_new+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
lea    0x13(%rax),%r13
mov    0x90(%rbp),%rdi
mov    $0x0,%esi
mov    %r13,%rdx
callq  fa8 <maildir_deliver_new+0x58>
mov    0x90(%rbp),%rdi
mov    %rax,%r12
xor    %edx,%edx
mov    %r13,%rsi
callq  3c0 <mk_info_filename.constprop.4>
mov    %r12,%rdi
mov    %rax,%rsi
mov    %rax,%r13
callq  fca <maildir_deliver_new+0x7a>
mov    %r12,%rdi
callq  fd2 <maildir_deliver_new+0x82>
mov    %r13,%rdi
callq  fda <maildir_deliver_new+0x8a>
jmp    f6e <maildir_deliver_new+0x1e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
maildir_deliver_new (struct _amd_data *amd, DIR *dir)
{
  struct dirent *entry;
  while ((entry = readdir (dir)))
    {
      char *oldname, *newname;
      switch (entry->d_name[0])
 {
 case '.':
   break;
 default:
   oldname = maildir_mkfilename (amd->name, "new", entry->d_name);
   newname = mk_info_filename (amd->name, "cur", entry->d_name, 0);
   rename (oldname, newname);
   free (oldname);
   free (newname);
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 7
11 7
12 4
13 4
14 4
15 4
16 20
17 20
18 20
19 20
20 20
21 20
22 20
23 12
24 12
25 12
26 12
27 12
28 13
29 12
30 13
31 13
32 13
33 14
34 14
35 13
36 14
37 15
38 15
39 16
40 16
41 16
42 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  139 <revstatcmp+0x9>
add    $0x8,%rsp
neg    %eax
retq   
<<<sep_in_sample>>>
revstatcmp (const FTSENT *a, const FTSENT *b)
{
  return (- statcmp (a, b));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x20,%rsp
mov    %rdx,(%rsp)
mov    %rsp,%rdx
movq   $0x0,0x8(%rsp)
movq   $0x0,0x18(%rsp)
mov    %rcx,0x10(%rsp)
callq  1bcb <set_file_times+0x2b>
test   %eax,%eax
js     1bd8 <set_file_times+0x38>
add    $0x20,%rsp
pop    %rbx
retq   
nopl   (%rax)
callq  1bdd <set_file_times+0x3d>
cmpl   $0x1e,(%rax)
je     1bcf <set_file_times+0x2f>
mov    %rbx,%rdi
callq  1bea <set_file_times+0x4a>
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
set_file_times (int fd,
  const char *name, unsigned long atime, unsigned long mtime)
{
  struct timespec ts[2];
  memset (&ts, 0, sizeof ts);
  ts[0].tv_sec = atime;
  ts[1].tv_sec = mtime;
  if (fdutimens (fd, name, ts) < 0 && (*__errno_location ()) != 30)
    utime_error (name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 8
6 5
7 5
8 7
9 8
10 8
11 8
12 10
13 10
14 10
15 10
16 8
17 8
18 8
19 9
20 9
21 10
22 10
23 10
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x18,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  44 <grecs_txtacc_alloc_entry+0x14>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  4f <grecs_txtacc_alloc_entry+0x1f>
mov    %rbp,0x8(%rbx)
mov    %rax,(%rbx)
mov    %rbx,%rsi
movq   $0x0,0x10(%rbx)
mov    %r12,%rdi
callq  69 <grecs_txtacc_alloc_entry+0x39>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_alloc_entry(struct grecs_list *list, size_t size)
{
 struct grecs_txtacc_entry *p = grecs_malloc(sizeof (*p));
 p->buf = grecs_malloc(size);
 p->size = size;
 p->len = 0;
 grecs_list_append(list, p);
 return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 4
11 5
12 4
13 7
14 6
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
movq   $0x0,(%rcx)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
        JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x3f,%edi
push   %rbx
sub    $0x8,%rsp
callq  10 <debug_open+0x10>
mov    0x0(%rip),%rbx        # 17 <debug_open+0x17>
mov    %eax,%ebp
test   %rbx,%rbx
je     38 <debug_open+0x38>
mov    %ebp,%edi
callq  25 <debug_open+0x25>
xor    %eax,%eax
test   %rbx,%rbx
sete   %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  47 <debug_open+0x47>
mov    %rax,0x0(%rip)        # 4e <debug_open+0x4e>
mov    %rax,%rbx
jmp    1e <debug_open+0x1e>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
debug_open (void)
{
  int um = umask (077);
  if (!debug_fp)
    debug_fp = fopen ("/tmp/telnet.debug", "a");
  umask (um);
  return debug_fp == ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 4
7 3
8 4
9 4
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 5
21 5
22 5
23 5
24 5
25 5
26 5
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x20,%rsp
cmp    $0x1,%edi
je     168 <substr_sel+0x58>
cmp    $0x2,%edi
je     150 <substr_sel+0x40>
xor    %eax,%eax
test   %edi,%edi
je     130 <substr_sel+0x20>
add    $0x20,%rsp
pop    %rbx
retq   
xchg   %ax,%ax
mov    (%rbx),%rdi
lea    0x18(%rsp),%rsi
xor    %edx,%edx
callq  13f <substr_sel+0x2f>
test   %eax,%eax
je     1c0 <substr_sel+0xb0>
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
xchg   %ax,%ax
mov    0x8(%rsi),%rdi
callq  159 <substr_sel+0x49>
add    $0x20,%rsp
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rdx,%rax
mov    0x8(%rsi),%rbx
lea    0x18(%rsp),%rsi
xor    %edx,%edx
mov    %rax,%rdi
callq  17e <substr_sel+0x6e>
mov    %eax,%edx
xor    %eax,%eax
test   %edx,%edx
jne    128 <substr_sel+0x18>
mov    0x18(%rsp),%rdi
callq  190 <substr_sel+0x80>
mov    0x18(%rsp),%rdi
mov    %rbx,%rsi
xor    %ebx,%ebx
callq  19f <substr_sel+0x8f>
mov    0x18(%rsp),%rdi
test   %rax,%rax
setne  %bl
callq  1af <substr_sel+0x9f>
mov    %ebx,%eax
jmpq   128 <substr_sel+0x18>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x18(%rsp),%rdi
mov    %eax,0xc(%rsp)
callq  1ce <substr_sel+0xbe>
mov    0x18(%rsp),%rdx
mov    0xc(%rsp),%eax
mov    %rdx,0x8(%rbx)
jmpq   128 <substr_sel+0x18>
<<<sep_in_sample>>>
substr_sel(int cmd, struct dico_key *key, const char *dict_word)
{
    unsigned *sample;
    unsigned *tmp;
    int res;
    switch (cmd) {
    case 0:
 if (utf8_mbstr_to_wc(key->word, &sample, ((void *)0)))
     return 1;
 utf8_wc_strupper(sample);
 key->call_data = sample;
 break;
    case 1:
 sample = key->call_data;
 if (utf8_mbstr_to_wc(dict_word, &tmp, ((void *)0)))
     return 0;
 utf8_wc_strupper(tmp);
 res = !!utf8_wc_strstr(tmp, sample);
 free(tmp);
 return res;
    case 2:
 free(key->call_data);
 break;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 6
7 6
8 25
9 6
10 6
11 26
12 26
13 26
14 26
15 8
16 8
17 8
18 8
19 8
20 8
21 26
22 9
23 26
24 26
25 26
26 22
27 22
28 26
29 25
30 26
31 26
32 26
33 26
34 14
35 15
36 15
37 15
38 15
39 15
40 16
41 15
42 15
43 17
44 17
45 18
46 18
47 18
48 18
49 19
50 18
51 18
52 19
53 20
54 20
55 20
56 10
57 10
58 10
59 11
60 12
61 11
62 12
<<<sep_out_sample>>>
mov    %edi,%esi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  90 <recurse_1>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 5a <showReadMe+0xa>
mov    $0x0,%esi
mov    $0x0,%edi
callq  69 <showReadMe+0x19>
test   %eax,%eax
je     82 <showReadMe+0x32>
mov    0x0(%rip),%edx        # 73 <showReadMe+0x23>
mov    $0x0,%esi
mov    $0x0,%edi
callq  82 <showReadMe+0x32>
mov    0x0(%rip),%eax        # 88 <showReadMe+0x38>
mov    $0x2,%esi
mov    $0x2,%edi
add    $0x8,%rsp
lea    -0x2(%rax),%edx
jmpq   9e <showReadMe+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
showReadMe()
{
  int res = show_readme("/usr/share/doc/gnudos/prime/README", " README ", GNU_DOS_LEVEL);
  if(res != 0)
  {
    res = show_readme("/usr/local/share/doc/gnudos/prime/README", " README ", GNU_DOS_LEVEL);
  }
  drawMenuBar(2, 2, SCREEN_W-2);
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 10
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    0x8(%rsi),%rdi
callq  *%rax
xor    %edx,%edx
test   %eax,%eax
jne    2b <try_auth+0x1b>
movl   $0x0,(%rbx)
mov    $0x1,%dl
mov    %edx,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
try_auth (void *item, void *data)
{
  int (*authenticate) (mu_authority_t) = item;
  struct auth_cb *cb = data;
  if (authenticate (cb->authority) == 0)
    {
      cb->status = 0;
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 10
7 5
8 5
9 7
10 8
11 11
12 11
13 11
14 11
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
control_set_driver_null (void *vstate, const gsl_odeiv2_driver * d)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
callq  2c6 <findfile+0x6>
mov    %rax,%rbx
callq  0 <common>
mov    %rbx,%r8
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%r9d
mov    $0x400,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  2f0 <findfile+0x30>
mov    $0x0,%edi
callq  2fa <findfile+0x3a>
xor    %edx,%edx
test   %eax,%eax
mov    $0x0,%eax
cmovne %rax,%rdx
mov    %rdx,%rax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
findfile(char *pattern)
{
 snprintf(comline, sizeof(comline), "%s -P %s > %s", common(), quote_shell(pattern), temp1);
 if (system(comline) != 0)
  return "global command failed";
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 5
16 5
17 5
18 5
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  76 <field_width_error+0x16>
add    $0x8,%rsp
mov    %rbx,%rcx
mov    %rbp,%r8
pop    %rbx
pop    %rbp
mov    %rax,%rdx
xor    %esi,%esi
xor    %edi,%edi
xor    %eax,%eax
jmpq   90 <tape_pad_output>
<<<sep_in_sample>>>
field_width_error (const char *filename, const char *fieldname)
{
  error (0, 0, gettext ("%s: field width not sufficient for storing %s"),
  filename, fieldname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 5
9 3
10 3
11 5
12 5
13 3
14 3
15 3
16 3
17 3
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
mov    $0x20,%edi
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # d4 <osip_sem_init+0x14>
test   %rax,%rax
je     120 <osip_sem_init+0x60>
callq  *%rax
mov    %rax,%rbx
test   %rbx,%rbx
je     130 <osip_sem_init+0x70>
xor    %esi,%esi
mov    %rbx,%rdi
mov    %ebp,%edx
callq  ef <osip_sem_init+0x2f>
test   %eax,%eax
mov    %rbx,%rdi
je     106 <osip_sem_init+0x46>
mov    0x0(%rip),%rax        # fd <osip_sem_init+0x3d>
test   %rax,%rax
je     110 <osip_sem_init+0x50>
callq  *%rax
xor    %edi,%edi
add    $0x8,%rsp
mov    %rdi,%rax
pop    %rbx
pop    %rbp
retq   
callq  115 <osip_sem_init+0x55>
xor    %edi,%edi
jmp    106 <osip_sem_init+0x46>
nopl   0x0(%rax)
callq  125 <osip_sem_init+0x65>
mov    %rax,%rbx
jmp    de <osip_sem_init+0x1e>
nopw   0x0(%rax,%rax,1)
xor    %edi,%edi
jmp    106 <osip_sem_init+0x46>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_sem_init (unsigned int value)
{
  osip_sem_t *sem = (osip_sem_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_sem_t)):malloc(sizeof (osip_sem_t)));
  if (sem == ((void *)0))
    return ((void *)0);
  if (sem_init (sem, 0, value) == 0)
    return (struct osip_sem *) sem;
  { if (sem!=((void *)0)) { if (osip_free_func) osip_free_func(sem); else free(sem);} };
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 8
24 9
25 10
26 10
27 10
28 10
29 10
30 8
31 9
32 9
33 9
34 3
35 3
36 3
37 3
38 5
39 5
40 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r11
cmp    (%rdi),%r11
mov    0x8(%rdi),%rax
je     20f0 <gsl_matrix_ulong_div_elements+0x40>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  20dd <gsl_matrix_ulong_div_elements+0x2d>
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%r10
cmp    %rax,%r10
jne    20c4 <gsl_matrix_ulong_div_elements+0x14>
test   %r11,%r11
mov    0x10(%rdi),%r14
mov    0x10(%rsi),%r13
je     2156 <gsl_matrix_ulong_div_elements+0xa6>
shl    $0x3,%r14
shl    $0x3,%r13
xor    %r12d,%r12d
xor    %ebp,%ebp
xor    %ebx,%ebx
nopl   (%rax)
test   %r10,%r10
je     2147 <gsl_matrix_ulong_div_elements+0x97>
mov    %rbp,%r9
mov    %r12,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %ecx,%ecx
nopl   (%rax)
mov    (%r9,%rcx,8),%rax
xor    %edx,%edx
divq   (%r8,%rcx,8)
mov    %rax,(%r9,%rcx,8)
add    $0x1,%rcx
cmp    %r10,%rcx
jne    2130 <gsl_matrix_ulong_div_elements+0x80>
add    $0x1,%rbx
add    %r14,%rbp
add    %r13,%r12
cmp    %r11,%rbx
jne    2118 <gsl_matrix_ulong_div_elements+0x68>
xor    %eax,%eax
jmp    20e2 <gsl_matrix_ulong_div_elements+0x32>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_div_elements (gsl_matrix_ulong * a, const gsl_matrix_ulong * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 18
47 18
48 16
49 16
50 16
51 14
52 14
53 14
54 14
55 14
56 21
57 21
58 21
<<<sep_out_sample>>>
add    0xe8(%rdi),%rsi
lea    0x1(%rsi),%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
translate_line_number (struct file_data const *file, lin i)
{
  return i + file->prefix_lines + 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
movq   $0x0,(%rsp)
callq  b59 <grecs_print_locus+0x19>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_print_locus(grecs_locus_t *locus, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_locus(locus, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 996 <gsl_vector_long_set+0x6>
test   %eax,%eax
je     99f <gsl_vector_long_set+0xf>
cmp    %rsi,(%rdi)
jbe    9b8 <gsl_vector_long_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
shl    $0x3,%rax
imul   %rsi,%rax
mov    %rdx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   9d1 <gsl_vector_long_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_set (gsl_vector_long * v, const size_t i, long x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  69 <xmalloc+0x9>
test   %rax,%rax
je     70 <xmalloc+0x10>
pop    %rbx
retq   
mov    %rbx,%rdi
pop    %rbx
jmp    30 <fixup_null_alloc>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (size_t n)
{
  void *p;
  p = malloc (n);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 8
7 8
8 6
9 8
10 6
11 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 136 <tty_isediting+0x6>
and    $0x2,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_isediting (void)
{
  return termbuf.c_lflag & 0000002;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %edx,%edx
push   %rbx
mov    %rdi,%rax
mov    %esi,%r10d
mov    %rcx,%rbx
je     7f4 <maildir_new_message_name+0x14>
test   $0x4,%sil
jne    850 <maildir_new_message_name+0x70>
mov    0x48(%rax),%r9
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %r9,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     830 <maildir_new_message_name+0x50>
mov    0x50(%rax),%rdx
mov    0x40(%rax),%rax
mov    %r9,%rsi
mov    0x90(%rax),%rdi
callq  820 <maildir_new_message_name+0x40>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x50(%rax),%rsi
mov    0x40(%rax),%rax
mov    %r10d,%edx
mov    0x90(%rax),%rdi
callq  3c0 <mk_info_filename.constprop.4>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
movq   $0x0,(%rcx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maildir_new_message_name (struct _amd_message *amsg, int flags, int expunge,
     char **pname)
{
  struct _maildir_message *msg = (struct _maildir_message *) amsg;
  if (expunge && (flags & 0x04))
    {
      *pname = ((void *)0);
    }
  else if (strcmp (msg->dir, "cur") == 0)
    *pname = mk_info_filename (amsg->amd->name, "cur", msg->file_name, flags);
  else
    *pname = maildir_mkfilename (amsg->amd->name, msg->dir, msg->file_name);
  return 0;
}
<<<sep_in_sample>>>
1 5
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 9
10 9
11 9
12 9
13 9
14 9
15 12
16 12
17 12
18 12
19 12
20 12
21 14
22 14
23 14
24 14
25 10
26 10
27 10
28 10
29 10
30 10
31 14
32 14
33 14
34 14
35 7
36 14
37 14
38 14
39 14
<<<sep_out_sample>>>
mov    %edx,%edx
movq   $0x0,(%r8)
movq   $0x0,0x8(%r8)
movq   $0x0,0x10(%r8)
movq   $0x0,0x18(%r8)
mov    %r8,%rax
movq   $0x0,0x20(%r8)
movzwl 0x1a(%rsi,%rdx,2),%edx
movl   $0x0,(%r9)
add    %rdx,%rsi
movzbl 0x2(%rsi),%edx
and    $0x7f,%dl
cmp    $0x3,%edx
je     930 <__bam_safe_getdata+0x60>
lea    0x3(%rsi),%rdx
mov    %rdx,(%r8)
movzwl (%rsi),%edx
mov    %edx,0x8(%r8)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
test   %ecx,%ecx
je     925 <__bam_safe_getdata+0x55>
orl    $0x2,0x18(%r8)
movl   $0x1,(%r9)
xor    %r8d,%r8d
mov    0x4(%rsi),%ecx
mov    0x8(%rsi),%edx
xor    %r9d,%r9d
mov    %rax,%rsi
jmpq   954 <__bam_safe_getdata+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__bam_safe_getdata(dbp, h, i, ovflok, dbt, freedbtp)
 DB *dbp;
 PAGE *h;
 u_int32_t i;
 int ovflok;
 DBT *dbt;
 int *freedbtp;
{
 BKEYDATA *bk;
 BOVERFLOW *bo;
 memset(dbt, 0, sizeof(DBT));
 *freedbtp = 0;
 bk = ((BKEYDATA *)((u_int8_t *)h + ((PAGE *)h)->inp[i]));
 if (((bk->type) & ~(0x80)) == 3) {
  if (!ovflok)
   return(0);
  bo = (BOVERFLOW *)bk;
  (dbt)->flags |= (0x002);
  *freedbtp = 1;
  return (CDB___db_goff(dbp, dbt, bo->tlen, bo->pgno, ((void *)0), ((void *)0)));
 } else {
  dbt->data = bk->data;
  dbt->size = bk->len;
 }
 return (0);
}
<<<sep_in_sample>>>
1 13
2 11
3 11
4 11
5 11
6 8
7 11
8 13
9 12
10 13
11 14
12 14
13 14
14 14
15 22
16 22
17 23
18 23
19 26
20 26
21 26
22 15
23 15
24 18
25 19
26 20
27 20
28 20
29 20
30 20
31 20
32 20
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
mov    $0x2,%edx
push   %rbp
mov    %rsi,%rbp
mov    %rdi,%rsi
mov    %rbp,%rdi
push   %rbx
callq  1ca <assoc_replace+0x1a>
test   %rax,%rax
mov    %rax,%rbx
je     230 <assoc_replace+0x80>
cmp    %rbp,0x8(%rax)
je     1ea <assoc_replace+0x3a>
mov    $0x6b,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  1ea <assoc_replace+0x3a>
xor    %eax,%eax
test   %r12,%r12
mov    0x10(%rbx),%rbp
je     21b <assoc_replace+0x6b>
mov    %r12,%rdi
callq  1fd <assoc_replace+0x4d>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x6d,%edx
callq  210 <assoc_replace+0x60>
mov    %r12,%rsi
mov    %rax,%rdi
callq  21b <assoc_replace+0x6b>
mov    %rax,0x10(%rbx)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    222 <assoc_replace+0x72>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assoc_replace (hash, key, value)
     HASH_TABLE *hash;
     char *key;
     char *value;
{
  BUCKET_CONTENTS *b;
  void * t;
  b = hash_search (key, hash, 0x02);
  if (b == 0)
    return (void *)0;
  if (b->key != key)
    sh_xfree((key), "assoc.c", 107);
  t = b->data;
  b->data = value ? (char *)strcpy (sh_xmalloc((1 + strlen (value)), "assoc.c", 109), (value)) : (char *)0;
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 8
4 5
5 5
6 8
7 8
8 5
9 8
10 9
11 8
12 9
13 11
14 11
15 12
16 12
17 12
18 12
19 14
20 14
21 13
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 15
34 16
35 16
36 16
37 16
38 16
39 10
40 10
41 10
<<<sep_out_sample>>>
mov    %esi,%edx
lea    0x8(%rdi),%rsi
jmpq   ba0 <__insert_file_id.isra.4>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
insert_file_id (struct stat const *st, enum file_id_type type)
{
  __insert_file_id (st, type);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
orb    $0x40,0x85(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_intermediate (const void *item)
{
  struct file *f = (struct file *) item;
  f->intermediate = 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x1,%edi
callq  1bbe <get_screen_lines+0xe>
test   %eax,%eax
mov    $0xffffffff,%edx
je     1bf8 <get_screen_lines+0x48>
xor    %eax,%eax
xor    %edx,%edx
mov    $0x5413,%esi
mov    %ax,(%rsp)
mov    %dx,0x2(%rsp)
xor    %eax,%eax
mov    %rsp,%rdx
mov    $0x1,%edi
callq  1be8 <get_screen_lines+0x38>
test   %eax,%eax
js     1c00 <get_screen_lines+0x50>
movzwl (%rsp),%eax
test   %ax,%ax
je     1c00 <get_screen_lines+0x50>
movzwl %ax,%edx
mov    %edx,%eax
add    $0x18,%rsp
retq   
nop
mov    $0x0,%edi
callq  1c0a <get_screen_lines+0x5a>
test   %rax,%rax
je     1c20 <get_screen_lines+0x70>
mov    $0xa,%edx
xor    %esi,%esi
mov    %rax,%rdi
callq  1c1e <get_screen_lines+0x6e>
jmp    1bf5 <get_screen_lines+0x45>
movzwl (%rsp),%eax
jmp    1bf5 <get_screen_lines+0x45>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_screen_lines ()
{
  if (isatty (1))
    {
      struct winsize ws;
      ws.ws_col = ws.ws_row = 0;
      if ((ioctl(1, 0x5413, (char *) &ws) < 0) || ws.ws_row == 0)
 {
   const char *lines = getenv ("LINES");
   if (lines)
     ws.ws_row = strtol (lines, ((void *)0), 10);
 }
      return ws.ws_row;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 15
6 3
7 6
8 6
9 7
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 13
22 16
23 16
24 16
25 16
26 9
27 9
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
push   %rbx
movslq %esi,%rbx
sub    $0x10,%rsp
mov    0x88(%rdi),%r9
mov    (%r9,%rbx,8),%rax
lea    0x0(,%rbx,8),%r8
test   %rax,%rax
je     5688 <transit_state_singlebyte+0x48>
movzbl (%rdx),%edx
mov    (%rax,%rdx,4),%edx
xor    %eax,%eax
test   %edx,%edx
cmovns %edx,%eax
mov    %eax,(%rcx)
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
test   %ebp,%ebp
js     56b8 <transit_state_singlebyte+0x78>
mov    0x98(%r12),%rax
mov    (%rax,%r8,1),%rax
test   %rax,%rax
je     56c7 <transit_state_singlebyte+0x87>
movzbl (%rdx),%edx
mov    (%rax,%rdx,4),%eax
mov    %eax,(%rcx)
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
cmp    0x0(%rip),%rdx        # 56bf <transit_state_singlebyte+0x7f>
je     56f0 <transit_state_singlebyte+0xb0>
xor    %ebp,%ebp
xor    %ebx,%ebx
jmp    5657 <transit_state_singlebyte+0x17>
mov    %r12,%rsi
mov    %ebp,%edi
mov    %rcx,0x8(%rsp)
mov    %rdx,(%rsp)
callq  5360 <build_state>
mov    0x88(%r12),%r9
mov    (%rsp),%rdx
mov    0x8(%rsp),%rcx
jmpq   5657 <transit_state_singlebyte+0x17>
callq  56f5 <transit_state_singlebyte+0xb5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
transit_state_singlebyte (struct dfa *d, int s, unsigned char const *p,
                                  int *next_state)
{
  int *t;
  int works = s;
  status_transit_state rval = TRANSIT_STATE_IN_PROGRESS;
  while (rval == TRANSIT_STATE_IN_PROGRESS)
    {
      if ((t = d->trans[works]) != ((void *)0))
        {
          works = t[*p];
          rval = TRANSIT_STATE_DONE;
          if (works < 0)
            works = 0;
        }
      else if (works < 0)
        {
          if (p == buf_end)
            {
              abort ();
            }
          works = 0;
        }
      else if (d->fails[works])
        {
          works = d->fails[works][*p];
          rval = TRANSIT_STATE_DONE;
        }
      else
        {
          build_state(works, d);
        }
    }
  *next_state = works;
  return rval;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 9
11 9
12 9
13 11
14 11
15 11
16 11
17 11
18 34
19 36
20 36
21 36
22 36
23 36
24 36
25 36
26 16
27 16
28 24
29 24
30 24
31 24
32 26
33 26
34 34
35 36
36 36
37 36
38 36
39 36
40 36
41 36
42 18
43 18
44 22
45 22
46 22
47 31
48 31
49 31
50 31
51 31
52 31
53 31
54 31
55 31
56 20
57 20
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
sub    $0x18,%rsp
callq  48 <mu_nntp_stream_readline+0x18>
mov    %rax,%rbx
xor    %eax,%eax
movq   $0x0,0x8(%rsp)
test   %rbx,%rbx
je     62 <mu_nntp_stream_readline+0x32>
mov    0x8(%rbx),%edx
test   %edx,%edx
je     80 <mu_nntp_stream_readline+0x50>
test   %rbp,%rbp
je     70 <mu_nntp_stream_readline+0x40>
mov    0x8(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
lea    0x8(%rsp),%rcx
mov    %r13,%rdx
mov    %r12,%rsi
callq  93 <mu_nntp_stream_readline+0x63>
cmpq   $0x0,0x8(%rsp)
jne    62 <mu_nntp_stream_readline+0x32>
mov    (%rbx),%rdx
movl   $0x0,0x80(%rdx)
movl   $0x1,0x8(%rbx)
jmp    62 <mu_nntp_stream_readline+0x32>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_nntp_stream_readline (mu_stream_t stream, char *buf, size_t buflen, mu_off_t offset, size_t *pn)
{
  struct mu_nntp_stream *nntp_stream = mu_stream_get_owner (stream);
  size_t n = 0;
  int status = 0;
  (void)offset;
  if (nntp_stream)
    {
      if (!nntp_stream->done)
 {
   status = mu_nntp_readline (nntp_stream->nntp, buf, buflen, &n);
   if (n == 0)
     {
       nntp_stream->nntp->state = MU_NNTP_NO_STATE;
       nntp_stream->done = 1;
     }
 }
    }
  if (pn)
    *pn = n;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 5
12 4
13 7
14 7
15 9
16 9
17 9
18 19
19 19
20 20
21 20
22 22
23 22
24 22
25 22
26 22
27 22
28 22
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 14
37 14
38 15
39 15
40 15
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 7 <maybe_print_progname+0x7>
jne    10 <maybe_print_progname+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 17 <maybe_print_progname+0x17>
mov    0x0(%rip),%rdi        # 1e <maybe_print_progname+0x1e>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   2a <maybe_print_progname+0x2a>
<<<sep_in_sample>>>
maybe_print_progname ()
{
  if (error_with_progname)
    fprintf (stderr, "%s: ", program_name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    0x18(%rdi),%rdi
jmpq   40 <_body_get_lines0>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_body_get_lines (mu_body_t body, size_t *plines)
{
  return _body_get_lines0 (body->fstream, plines);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %esi,%esi
jmpq   c7 <VAllocColor+0x7>
<<<sep_in_sample>>>
VAllocColor(char *name)
{
 return VAllocDepthCueuedColor(name, 0);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  501 <rec_parser_new_str+0x11>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %rax,%rsi
jmpq   515 <rec_parser_new_str+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_parser_new_str (const char *buffer,
                    const char *source)
{
  return rec_parser_new_mem (buffer, strlen (buffer), source);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 4
9 4
10 5
11 5
12 4
13 4
14 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
xor    (%rdi),%rax
xor    %edx,%edx
div    %rsi
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
entry_hashfunc (const void *pv, size_t buckets)
{
  const struct SharefileEntry *p = pv;
  return (p->device ^ p->inode) % buckets;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   273 <gsl_vector_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_fscanf (FILE * stream, gsl_vector * v)
{
  int status = gsl_block_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm3        # 10 <gsl_cdf_logistic_Pinv+0x10>
ucomisd %xmm3,%xmm0
jnp    60 <gsl_cdf_logistic_Pinv+0x60>
ucomisd 0x0(%rip),%xmm2        # 1e <gsl_cdf_logistic_Pinv+0x1e>
jp     30 <gsl_cdf_logistic_Pinv+0x30>
movsd  0x0(%rip),%xmm0        # 28 <gsl_cdf_logistic_Pinv+0x28>
jne    30 <gsl_cdf_logistic_Pinv+0x30>
add    $0x18,%rsp
retq   
nop
subsd  %xmm2,%xmm3
movsd  %xmm1,0x8(%rsp)
divsd  %xmm3,%xmm2
movapd %xmm2,%xmm0
callq  47 <gsl_cdf_logistic_Pinv+0x47>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
mulsd  %xmm1,%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm0        # 68 <gsl_cdf_logistic_Pinv+0x68>
jne    16 <gsl_cdf_logistic_Pinv+0x16>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_cdf_logistic_Pinv (const double P, const double a)
{
  double x;
  if (P == 1.0)
    {
      return (__builtin_inff());
    }
  else if (P == 0.0)
    {
      return (-(__builtin_inff()));
    }
  x = a * log(P/(1-P));
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 8
7 8
8 10
9 8
10 14
11 14
12 14
13 12
14 12
15 12
16 12
17 12
18 12
19 14
20 12
21 14
22 14
23 6
24 4
25 14
26 14
27 14
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  1d92 <gsl_stats_int_variance+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1da4 <gsl_stats_int_variance+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_int_variance (const int data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_int_mean (data, stride, n);
  return gsl_stats_int_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
mov    0xe0(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_cseq (const osip_message_t * sip)
{
  return sip->cseq;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   0 <_url_remote_init>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_url_remote_sendmail_init (mu_url_t url)
{
  return _url_remote_init (url, "sendmail");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edi,%edi
jle    200a <my_malloc+0x1a>
movslq %edi,%rdi
callq  2000 <my_malloc+0x10>
test   %rax,%rax
je     2019 <my_malloc+0x29>
add    $0x8,%rsp
retq   
mov    $0xf9,%esi
mov    $0x0,%edi
callq  3e0 <my_assert.constprop.18>
mov    0x0(%rip),%rcx        # 2020 <my_malloc+0x30>
mov    $0x0,%edi
mov    $0x25,%edx
mov    $0x1,%esi
callq  2034 <my_malloc+0x44>
mov    $0x1,%edi
callq  203e <my_malloc+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
my_malloc(int size)
{ void *ptr;
      ((void)((size > 0) || (my_assert("size > 0", "marst.c", 249), 1)));
      ptr = malloc(size);
      if (ptr == ((void *)0))
      { fprintf(stderr, "Main storage requested not available\n");
         exit(1);
      }
      return ptr;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 10
9 10
10 3
11 3
12 3
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <userdata_free+0x11>
callq  11 <userdata_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     1f <userdata_free+0x1f>
callq  1f <userdata_free+0x1f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2d <userdata_free+0x2d>
callq  2d <userdata_free+0x2d>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     40 <userdata_free+0x40>
pop    %rbx
jmpq   3c <userdata_free+0x3c>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
userdata_free (struct userdata *udata)
{
  do { if (udata->login) free (udata->login); } while (0);
  do { if (udata->name) free (udata->name); } while (0);
  do { if (udata->comments) free (udata->comments); } while (0);
  do { if (udata->home) free (udata->home); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 6
20 6
21 7
22 7
23 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
cmpq   $0x0,(%rdi)
je     a0c <wordsplit_free_words+0x4c>
mov    0x10(%rdi),%rax
xor    %ebx,%ebx
nopl   (%rax)
mov    0x8(%rbp),%rdx
lea    (%rbx,%rax,1),%rcx
mov    (%rdx,%rcx,8),%rdi
test   %rdi,%rdi
je     a02 <wordsplit_free_words+0x42>
callq  9ee <wordsplit_free_words+0x2e>
mov    0x10(%rbp),%rax
mov    0x8(%rbp),%rdx
lea    (%rbx,%rax,1),%rcx
movq   $0x0,(%rdx,%rcx,8)
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     9d8 <wordsplit_free_words+0x18>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_words (struct wordsplit *ws)
{
  size_t i;
  for (i = 0; i < ws->ws_wordc; i++)
    {
      char *p = ws->ws_wordv[ws->ws_offs + i];
      if (p)
 {
   free (p);
   ws->ws_wordv[ws->ws_offs + i] = ((void *)0);
 }
    }
  ws->ws_wordc = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 7
14 7
15 9
16 10
17 10
18 10
19 10
20 4
21 4
22 4
23 13
24 14
25 14
26 14
27 14
28 14
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x30(%rdi),%rdi
callq  733 <xformat_set_user_systempair+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    740 <xformat_set_user_systempair+0x20>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbp,%rdi
callq  748 <xformat_set_user_systempair+0x28>
test   %eax,%eax
jne    739 <xformat_set_user_systempair+0x19>
mov    0x30(%r12),%rdi
mov    %rbp,%rsi
callq  759 <xformat_set_user_systempair+0x39>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
xformat_set_user_systempair(XFORMAT * xux, char * name)
{
 int ret;
 ;
 ret = ahs_set_user_systempair(xux->ahsM, name);
 if (ret && is_all_digits(name) == 0) {
  ;
  ahs_set_tar_username(xux->ahsM, name);
 }
 ;
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 5
10 6
11 12
12 12
13 12
14 12
15 12
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 12
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 8cb <debug_message_prefix+0xb>
xor    %eax,%eax
mov    $0x0,%esi
callq  8d7 <debug_message_prefix+0x17>
mov    0x0(%rip),%eax        # 8dd <debug_message_prefix+0x1d>
test   %eax,%eax
je     8ef <debug_message_prefix+0x2f>
mov    0x0(%rip),%eax        # 8e7 <debug_message_prefix+0x27>
test   $0x20,%al
jne    928 <debug_message_prefix+0x68>
test   $0x10,%al
jne    908 <debug_message_prefix+0x48>
mov    0x0(%rip),%rsi        # 8f6 <debug_message_prefix+0x36>
mov    $0x20,%edi
add    $0x8,%rsp
jmpq   904 <debug_message_prefix+0x44>
nopl   0x0(%rax)
mov    0x0(%rip),%edx        # 90e <debug_message_prefix+0x4e>
mov    0x0(%rip),%rdi        # 915 <debug_message_prefix+0x55>
mov    $0x0,%esi
xor    %eax,%eax
callq  921 <debug_message_prefix+0x61>
jmp    8ef <debug_message_prefix+0x2f>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 92f <debug_message_prefix+0x6f>
mov    0x0(%rip),%rdi        # 936 <debug_message_prefix+0x76>
xor    %eax,%eax
mov    $0x0,%esi
callq  942 <debug_message_prefix+0x82>
mov    0x0(%rip),%eax        # 948 <debug_message_prefix+0x88>
test   $0x10,%al
je     8ef <debug_message_prefix+0x2f>
jmp    908 <debug_message_prefix+0x48>
xchg   %ax,%ax
<<<sep_in_sample>>>
debug_message_prefix (void)
{
  xfprintf (debug, "m4debug:");
  if (current_line)
  {
    if (debug_level & 32)
      xfprintf (debug, "%s:", current_file);
    if (debug_level & 16)
      xfprintf (debug, "%d:", current_line);
  }
  _IO_putc (' ', debug);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 8
13 8
14 11
15 11
16 12
17 11
18 11
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 7
27 7
28 7
29 7
30 7
31 7
32 8
33 8
34 8
35 8
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm2
jbe    50 <gsl_cdf_pareto_Q+0x10>
movsd  0x0(%rip),%xmm0        # 4e <gsl_cdf_pareto_Q+0xe>
retq   
nop
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
jmpq   5d <gsl_cdf_pareto_Q+0x1d>
<<<sep_in_sample>>>
gsl_cdf_pareto_Q (const double x, const double a, const double b)
{
  double Q;
  if (x < b)
    {
      Q = 1;
    }
  else
    {
      Q = pow(b/x, a);
    }
  return Q;
}
<<<sep_in_sample>>>
1 4
2 4
3 13
4 13
5 13
6 10
7 10
8 10
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     ef1 <gsl_matrix_fscanf+0x91>
lea    0x0(,%r15,8),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    eae <gsl_matrix_fscanf+0x4e>
jmp    ee0 <gsl_matrix_fscanf+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     ee0 <gsl_matrix_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  ec5 <gsl_matrix_fscanf+0x65>
test   %eax,%eax
je     ea0 <gsl_matrix_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   f14 <gsl_matrix_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_fscanf (FILE * stream, gsl_matrix * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_raw_fscanf (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <file_fmt+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
file_fmt(const char *str, void *data)
{
 fputs(str, (FILE*)data);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    22f8 <gsl_matrix_long_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,8),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  231a <gsl_matrix_long_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_superdiagonal (gsl_matrix_long * m,
                                      const size_t k)
{
  _gsl_vector_long_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # 5bd <strwidth+0xd>
mov    %rdi,0x8(%rsp)
mov    (%rax),%eax
test   %eax,%eax
jne    5d8 <strwidth+0x28>
callq  5cd <strwidth+0x1d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
callq  5e2 <strwidth+0x32>
lea    0x1(%rax),%ebp
lea    0x0(%rip),%rsi        # 5ec <strwidth+0x3c>
lea    0x0(,%rbp,4),%edi
callq  5f8 <strwidth+0x48>
lea    0x8(%rsp),%rsi
xor    %ecx,%ecx
movslq %ebp,%rdx
mov    %rax,%rdi
mov    %rax,%rbx
callq  60d <strwidth+0x5d>
cmp    $0xffffffff,%eax
je     630 <strwidth+0x80>
mov    %rbx,%rdi
movslq %eax,%rsi
callq  61d <strwidth+0x6d>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  627 <strwidth+0x77>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
mov    %rbx,%rdi
mov    %rax,(%rsp)
callq  63c <strwidth+0x8c>
mov    (%rsp),%rax
jmp    5cd <strwidth+0x1d>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strwidth(const char *str)
{
  wchar_t *widestr;
  int len;
  if (!utf8mode)
    return strlen(str);
  len = strlen(str)+1;
  widestr = mymalloc(sizeof(wchar_t)*len, "(strwidth)");
  len = mbsrtowcs(widestr, &str, len, ((void *)0));
  if (len==-1){
    free(widestr);
    return -1;
  }
  len=wcswidth(widestr, len);
  free(widestr);
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 2
6 5
7 5
8 5
9 6
10 17
11 17
12 17
13 17
14 17
15 7
16 7
17 7
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 8
26 9
27 10
28 10
29 14
30 14
31 14
32 15
33 14
34 15
35 17
36 16
37 17
38 17
39 17
40 11
41 11
42 11
43 12
44 12
45 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     f70 <file_buffer_of_window+0x20>
mov    (%rax),%rdi
test   %rdi,%rdi
je     f70 <file_buffer_of_window+0x20>
jmpq   f66 <file_buffer_of_window+0x16>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_buffer_of_window (WINDOW *window)
{
  if (!window->node)
    return ((void *)0);
  if (window->node->fullpath)
    return info_find_file (window->node->fullpath);
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 6
8 6
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     6693 <remove_quoted_escapes+0x33>
callq  6673 <remove_quoted_escapes+0x13>
mov    %rbx,%rdi
mov    %rax,%rbp
mov    %rax,%rsi
callq  6681 <remove_quoted_escapes+0x21>
mov    $0xffa,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  6693 <remove_quoted_escapes+0x33>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
remove_quoted_escapes (string)
     char *string;
{
  char *t;
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      sh_xfree((t), "subst.c", 4090);
    }
  return (string);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 8
9 7
10 8
11 8
12 9
13 9
14 9
15 9
16 12
17 12
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
mov    (%rdi),%r11
push   %rbx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3ead <gsl_matrix_char_scale+0x5d>
xor    %r8d,%r8d
xor    %r9d,%r9d
nopw   0x0(%rax,%rax,1)
test   %r10,%r10
je     3ea1 <gsl_matrix_char_scale+0x51>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
nopl   0x0(%rax)
mov    %rax,%rdx
add    0x18(%rdi),%rdx
add    $0x1,%rax
cmp    %rax,%rsi
movsbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
jne    3e80 <gsl_matrix_char_scale+0x30>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
jne    3e70 <gsl_matrix_char_scale+0x20>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_scale (gsl_matrix_char * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 11
16 11
17 11
18 9
19 11
20 11
21 11
22 11
23 11
24 9
25 7
26 7
27 7
28 7
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x1,%esi
mov    %rbx,%rdx
callq  4348 <gsl_block_char_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     436a <gsl_block_char_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4365 <gsl_block_char_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_char_fread (FILE * stream, gsl_block_char * b)
{
  size_t n = b->size ;
  char * data = b->data ;
  size_t items = fread (data, 1 * sizeof (char), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  112 <osip_fifo_get+0x12>
test   %eax,%eax
jne    15d <osip_fifo_get+0x5d>
mov    (%rbx),%rdi
callq  11e <osip_fifo_get+0x1e>
cmpl   $0x1,0x24(%rbx)
je     168 <osip_fifo_get+0x68>
lea    0x10(%rbx),%rbp
xor    %esi,%esi
mov    %rbp,%rdi
callq  132 <osip_fifo_get+0x32>
xor    %esi,%esi
mov    %rbp,%rdi
mov    %rax,%r12
callq  13f <osip_fifo_get+0x3f>
mov    %rbp,%rdi
mov    %r12,%rbp
callq  14a <osip_fifo_get+0x4a>
test   %eax,%eax
mov    (%rbx),%rdi
setle  %al
movzbl %al,%eax
mov    %eax,0x24(%rbx)
callq  15d <osip_fifo_get+0x5d>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    $0x0,%r8d
xor    %ecx,%ecx
mov    $0x2,%edx
mov    $0x71,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  186 <osip_fifo_get+0x86>
mov    (%rbx),%rdi
callq  18e <osip_fifo_get+0x8e>
jmp    15d <osip_fifo_get+0x5d>
<<<sep_in_sample>>>
osip_fifo_get (osip_fifo_t * ff)
{
  void *el = ((void *)0);
  int i = osip_sem_wait (ff->qisempty);
  if (i != 0)
    return ((void *)0);
  osip_mutex_lock (ff->qislocked);
  if (ff->state != osip_empty) {
    el = osip_list_get (&ff->queue, 0);
    osip_list_remove (&ff->queue, 0);
  }
  else {
    osip_trace ("port_fifo.c", 113, TRACE_LEVEL2, ((void *)0), "no element in fifo.\n");
    osip_mutex_unlock (ff->qislocked);
    return 0;
  }
  if (osip_list_size (&ff->queue) <= 0)
    ff->state = osip_empty;
  else
    ff->state = osip_ok;
  osip_mutex_unlock (ff->qislocked);
  return el;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 2
5 2
6 4
7 4
8 5
9 5
10 7
11 7
12 8
13 8
14 9
15 9
16 9
17 9
18 10
19 10
20 9
21 10
22 17
23 22
24 17
25 20
26 21
27 20
28 20
29 20
30 21
31 23
32 23
33 23
34 23
35 23
36 23
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 14
45 14
46 15
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   473 <gsl_vector_uint_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_fscanf (FILE * stream, gsl_vector_uint * v)
{
  int status = gsl_block_uint_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x48(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x38,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
mov    0x8(%rdi),%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tterm_width (struct tterm * tterm)
{
  struct tterm *t = tterm ? tterm : &tterm_default;
  return t->width;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x118,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x108(%rsp)
xor    %eax,%eax
callq  27 <acm_fopen+0x27>
test   %rax,%rax
je     50 <acm_fopen+0x50>
mov    0x108(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    9b <acm_fopen+0x9b>
add    $0x118,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x0,%esi
mov    %rsp,%rdi
callq  5d <acm_fopen+0x5d>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  68 <acm_fopen+0x68>
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  73 <acm_fopen+0x73>
test   %rax,%rax
jne    2c <acm_fopen+0x2c>
mov    0x0(%rip),%rdi        # 7f <acm_fopen+0x7f>
mov    $0x0,%ecx
mov    %rbx,%rdx
mov    $0x0,%esi
callq  91 <acm_fopen+0x91>
mov    $0x1,%edi
callq  9b <acm_fopen+0x9b>
callq  a0 <acm_find_file>
<<<sep_in_sample>>>
acm_fopen(char *name, char *access)
{
 FILE *f;
 char libname[256];
 if ((f = fopen(name, access)) == (FILE *) ((void *)0)) {
  strcpy(libname, _acm_fopen_library_dir);
  strcat(libname, name);
  if ((f = fopen(libname, access)) == (FILE *) ((void *)0)) {
            fprintf(stderr, errmsg, name, _acm_fopen_library_dir);
            exit(1);
  }
 }
 return f;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 14
13 14
14 14
15 14
16 14
17 14
18 14
19 14
20 6
21 6
22 6
23 7
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 9
32 9
33 9
34 9
35 9
36 10
37 10
38 14
<<<sep_out_sample>>>
jmpq   9a5 <NetClose+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
NetClose (int fd)
{
  return close (fd);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    0x0(%rip),%rax        # cfa <eval_statement_list+0xa>
je     d3a <eval_statement_list+0x4a>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    (%rdi),%rbx
test   %rbx,%rbx
jne    d18 <eval_statement_list+0x28>
jmp    d36 <eval_statement_list+0x46>
mov    (%rbx),%rbx
test   %rbx,%rbx
je     d36 <eval_statement_list+0x46>
mov    %rax,%rdi
callq  d20 <eval_statement_list+0x30>
mov    0x8(%rbx),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
callq  d2f <eval_statement_list+0x3f>
mov    0x0(%rbp),%edx
test   %edx,%edx
je     d10 <eval_statement_list+0x20>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
eval_statement_list (lst, env, return_seen)
     List *lst;
     Environment *env;
     int *return_seen;
{
  ListItem *i;
  Stmt *stmt;
  Node *n = nvoid;
  if (lst == ((void *)0))
    return nvoid;
  for (i = lst->head; i; i = i->next)
    {
      node_free (n);
      stmt = (Stmt *) i->data;
      n = eval_statement (stmt, env, return_seen);
      if (*return_seen)
 return n;
    }
  return n;
}
<<<sep_in_sample>>>
1 9
2 8
3 9
4 5
5 5
6 5
7 5
8 5
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 13
17 13
18 15
19 15
20 15
21 15
22 16
23 16
24 16
25 20
26 20
27 20
28 20
29 20
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%dil
setbe  %al
retq   
<<<sep_in_sample>>>
__rdigit (char c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
cmove  0x0(%rip),%rbx        # 1e <__gmpq_out_str+0x1e>
add    $0x10,%rbp
mov    %rbx,%rdi
callq  2a <__gmpq_out_str+0x2a>
mov    $0x1,%esi
mov    %rbp,%rdi
mov    %rax,%r12
callq  3a <__gmpq_out_str+0x3a>
test   %eax,%eax
jne    60 <__gmpq_out_str+0x60>
mov    %rbx,%rdi
callq  46 <__gmpq_out_str+0x46>
xor    %edx,%edx
test   %eax,%eax
cmove  %r12,%rdx
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
mov    %rdx,%rax
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rsi
mov    $0x2f,%edi
callq  6d <__gmpq_out_str+0x6d>
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  7b <__gmpq_out_str+0x7b>
lea    0x1(%r12,%rax,1),%r12
jmp    3e <__gmpq_out_str+0x3e>
<<<sep_in_sample>>>
__gmpq_out_str (FILE *stream, int base, mpq_srcptr q)
{
  size_t written;
  if (stream == ((void *)0))
    stream = stdout;
  written = __gmpz_out_str (stream, base, (&((q)->_mp_num)));
  if ((__builtin_constant_p (1) && (1) == 0 ? (((&((q)->_mp_den)))->_mp_size < 0 ? -1 : ((&((q)->_mp_den)))->_mp_size > 0) : __gmpz_cmp_ui ((&((q)->_mp_den)),1)) != 0)
    {
      _IO_putc ('/', stream);
      written += 1 + __gmpz_out_str (stream, base, (&((q)->_mp_den)));
    }
  return ferror (stream) ? 0 : written;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 7
12 6
13 6
14 7
15 7
16 6
17 7
18 7
19 7
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 9
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
movsd  (%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0x8(%rdi),%xmm0
movsd  %xmm0,0x8(%rsi)
movsd  0x10(%rdi),%xmm0
movsd  %xmm0,0x10(%rsi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
DIStoACMWorld(dis_world_coordinates * in, VPoint * out)
{
 out->x = (in->x);
 out->y = (in->y);
 out->z = (in->z);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x8(%rbp),%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     c3a <dico_argv_free+0x2a>
nopl   (%rax)
add    $0x8,%rbx
callq  c31 <dico_argv_free+0x21>
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    c28 <dico_argv_free+0x18>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   c48 <dico_argv_free+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_argv_free (char **argv)
{
  int i;
  for (i = 0; argv[i]; i++)
    free (argv[i]);
  free (argv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 4
15 7
16 6
17 7
18 7
19 6
20 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4d36 <info_scroll_forward_page_only+0x6>
test   %eax,%eax
jne    4d47 <info_scroll_forward_page_only+0x17>
mov    0x0(%rip),%eax        # 4d40 <info_scroll_forward_page_only+0x10>
test   %eax,%eax
jle    4d58 <info_scroll_forward_page_only+0x28>
imul   %eax,%esi
mov    $0x1,%edx
jmpq   4bd0 <_scroll_forward>
nopl   0x0(%rax)
mov    0x18(%rdi),%rax
sub    $0x2,%rax
jmp    4d44 <info_scroll_forward_page_only+0x14>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_scroll_forward_page_only (WINDOW *window, int count)
{
  int lines;
  if (info_explicit_arg)
    lines = count;
  else if (default_window_size > 0)
    lines = default_window_size * count;
  else
    lines = (window->height - 2) * count;
  _scroll_forward (window, lines, 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 9
8 10
9 10
10 10
11 9
12 9
13 9
14 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  6fc <gsl_sf_bessel_Yn+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    710 <gsl_sf_bessel_Yn+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xd7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  726 <gsl_sf_bessel_Yn+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Yn(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Yn_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Yn_e(n, x, &result)", "bessel_Yn.c", 215, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movsd  0x640(%rdi),%xmm0
mulsd  0x640(%rsi),%xmm0
movsd  %xmm0,0x640(%rdi)
callq  3f69 <multunit+0x29>
test   %eax,%eax
je     3f78 <multunit+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
lea    0x320(%rbx),%rdi
lea    0x320(%rbp),%rsi
pop    %rbx
pop    %rbp
jmpq   3f91 <multunit+0x51>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
multunit(struct unittype *left, struct unittype *right)
{
  int myerr;
  left->factor *= right->factor;
  myerr = moveproduct(left->numerator, right->numerator);
  if (!myerr)
    myerr = moveproduct(left->denominator, right->denominator);
  return myerr;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 9
13 9
14 9
15 9
16 9
17 9
18 7
19 7
20 9
21 9
22 7
23 7
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rdi,%rbx
callq  12fb <il_message+0xb>
test   %rbx,%rbx
mov    $0x0,%edi
cmovne %rbx,%rdi
callq  130c <il_message+0x1c>
xor    %eax,%eax
callq  1313 <il_message+0x23>
pop    %rbx
xor    %eax,%eax
jmpq   131b <il_message+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_message(message)
    char *message;
{
    il_reset_line();
    il_set_static_text(message ? message : "Wait....");
    il_update();
    il_update_point();
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 5
6 5
7 5
8 5
9 6
10 6
11 8
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    $0x0,%edx
jmpq   1c0 <internal_read_file>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_file (const char *filename, size_t *length)
{
  return internal_read_file (filename, length, "r");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  661 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6a0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  67f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6b8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6a0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6c4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  59 <xdico_list_create+0x9>
test   %rax,%rax
je     63 <xdico_list_create+0x13>
add    $0x8,%rsp
retq   
callq  68 <xdico_list_create+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdico_list_create()
{
    dico_list_t p = dico_list_create();
    if (!p)
 xalloc_die();
    return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
8 5
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rsi,%rcx
mov    $0xe,%edi
mov    $0x8,%esi
jmpq   15 <nettle_aes256_set_encrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes256_set_encrypt_key(struct aes256_ctx *ctx, const uint8_t *key)
{
  _nettle_aes_set_key (14, 32 / 4, ctx->keys, key);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
test   %rbp,%rbp
je     1a0 <canon_doc_option+0x70>
callq  146 <canon_doc_option+0x16>
mov    %rbp,%rdx
mov    %rax,%r8
jmp    153 <canon_doc_option+0x23>
xchg   %ax,%ax
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
mov    (%r8),%rsi
add    $0x1,%rdx
movzbl %cl,%edi
movzwl (%rsi,%rdi,2),%esi
test   $0x2000,%si
jne    150 <canon_doc_option+0x20>
xor    %eax,%eax
cmp    $0x2d,%cl
setne  %al
test   %cl,%cl
je     197 <canon_doc_option+0x67>
and    $0x8,%esi
je     18d <canon_doc_option+0x5d>
jmp    197 <canon_doc_option+0x67>
xchg   %ax,%ax
mov    (%r8),%rsi
add    $0x1,%rdx
testb  $0x8,(%rsi,%rcx,2)
jne    197 <canon_doc_option+0x67>
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
jne    180 <canon_doc_option+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 9
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 11
36 11
37 11
38 15
39 15
40 15
41 15
42 15
43 15
44 5
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%r15d        # 465 <removeCopyFile+0x15>
test   %r15d,%r15d
jne    480 <removeCopyFile+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rbp
mov    %rbp,%rdi
callq  493 <removeCopyFile+0x43>
mov    0x0(%rip),%r14        # 49a <removeCopyFile+0x4a>
mov    %rax,%r12
mov    %r14,%rdi
callq  4a5 <removeCopyFile+0x55>
lea    0x2(%r12,%rax,1),%rdi
mov    %rax,%rbx
callq  4b2 <removeCopyFile+0x62>
test   %rax,%rax
mov    %rax,%r13
je     580 <removeCopyFile+0x130>
mov    %rbx,%rdx
mov    %r14,%rsi
mov    %rax,%rdi
callq  4cc <removeCopyFile+0x7c>
lea    0x1(%r13,%rbx,1),%rdi
lea    0x1(%r12),%rdx
mov    %rbp,%rsi
movb   $0x2f,0x0(%r13,%rbx,1)
callq  4e4 <removeCopyFile+0x94>
test   %r15d,%r15d
jle    564 <removeCopyFile+0x114>
sub    $0x1,%r15d
xor    %ebx,%ebx
mov    %r15d,%r14d
add    $0x1,%r14
jmp    509 <removeCopyFile+0xb9>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r14,%rbx
je     564 <removeCopyFile+0x114>
mov    0x0(,%rbx,8),%r12
mov    %r13,%rdi
mov    %ebx,%ebp
mov    %r12,%rsi
callq  51e <removeCopyFile+0xce>
test   %eax,%eax
jne    500 <removeCopyFile+0xb0>
cmp    %r15d,%ebx
jl     538 <removeCopyFile+0xe8>
jmp    55d <removeCopyFile+0x10d>
nopl   0x0(%rax)
mov    0x0(,%rbx,8),%r12
add    $0x1,%ebp
mov    %r12,%rdi
movslq %ebp,%rbx
mov    0x0(,%rbx,8),%rsi
callq  54e <removeCopyFile+0xfe>
mov    0x0(%rip),%eax        # 554 <removeCopyFile+0x104>
lea    -0x1(%rax),%r15d
cmp    %ebp,%r15d
jg     530 <removeCopyFile+0xe0>
mov    %r15d,0x0(%rip)        # 564 <removeCopyFile+0x114>
add    $0x8,%rsp
mov    %r13,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   57a <removeCopyFile+0x12a>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x1,%edx
mov    $0x1,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
mov    $0x0,%edi
jmpq   5a2 <removeCopyFile+0x152>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
removeCopyFile(int i)
{
  if(numCopyFiles == 0) return;
  int j, k;
  char *str = (char *) malloc(strlen(files[i])+strlen(cwd)+2);
  if(!str) { msgBox("Insufficient memory", 1, ERROR); return; }
  strcpy(str, cwd);
  strcat(str, "/");
  strcat(str, files[i]);
  strcat(str, "\0");
  for(j = 0; j < numCopyFiles; j++)
  {
    if(strcmp(str, copyFiles[j]) == 0)
    {
      for(k = j; k < numCopyFiles-1; k++)
      {
 strcpy(copyFiles[k], copyFiles[k+1]);
      }
      numCopyFiles--;
      free(str);
      return;
    }
  }
  free(str);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 25
12 25
13 25
14 25
15 25
16 25
17 25
18 25
19 25
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 5
33 6
34 7
35 7
36 7
37 7
38 9
39 9
40 9
41 8
42 9
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 13
55 13
56 13
57 13
58 13
59 13
60 13
61 15
62 15
63 15
64 15
65 15
66 17
67 17
68 17
69 17
70 17
71 15
72 15
73 15
74 15
75 19
76 25
77 24
78 25
79 25
80 25
81 25
82 25
83 25
84 24
85 24
86 25
87 6
88 6
89 25
90 25
91 25
92 25
93 25
94 25
95 6
96 6
97 6
<<<sep_out_sample>>>
jmpq   5 <list_iterator+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
list_iterator(void *object)
{
    return dico_list_iterator(object);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
outline_compare_count (dico_result_t rp)
{
    struct result *res = (struct result *) rp;
    return res->compare_count;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mov    %edi,%edi
jmpq   26a7 <sshalloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sshalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rcx,0x38(%rsp)
xor    %ecx,%ecx
test   $0x40,%dl
je     30 <openat_safer+0x30>
lea    0x60(%rsp),%rax
mov    0x38(%rsp),%ecx
movl   $0x18,0x8(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  37 <openat_safer+0x37>
mov    %eax,%edi
callq  3e <openat_safer+0x3e>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
openat_safer (int fd, char const *file, int flags, ...)
{
  mode_t mode = 0;
  if (flags & 0100)
    {
      va_list ap;
      __builtin_va_start(ap,flags);
      mode = __builtin_va_arg(ap,mode_t);
      __builtin_va_end(ap);
    }
  return fd_safer (openat (fd, file, flags, mode));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 8
8 7
9 7
10 7
11 7
12 11
13 11
14 11
15 11
16 12
17 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x38,%edi
callq  13e <name_elt_alloc+0xe>
mov    0x0(%rip),%rdx        # 145 <name_elt_alloc+0x15>
test   %rdx,%rdx
je     170 <name_elt_alloc+0x40>
mov    0x8(%rdx),%rcx
mov    %rcx,0x8(%rax)
mov    0x8(%rdx),%rcx
test   %rcx,%rcx
je     15e <name_elt_alloc+0x2e>
mov    %rax,(%rcx)
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
mov    $0x38,%edi
movl   $0x3,0x10(%rax)
mov    %rax,0x0(%rip)        # 192 <name_elt_alloc+0x62>
callq  197 <name_elt_alloc+0x67>
mov    0x0(%rip),%rdx        # 19e <name_elt_alloc+0x6e>
jmp    14a <name_elt_alloc+0x1a>
<<<sep_in_sample>>>
name_elt_alloc (void)
{
  struct name_elt *elt;
  elt = xmalloc (sizeof (*elt));
  if (!name_head)
    {
      name_head = elt;
      name_head->prev = name_head->next = ((void *)0);
      name_head->type = NELT_NOOP;
      elt = xmalloc (sizeof (*elt));
    }
  elt->prev = name_head->prev;
  if (name_head->prev)
    name_head->prev->next = elt;
  elt->next = name_head;
  name_head->prev = elt;
  return elt;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 12
8 12
9 13
10 13
11 13
12 14
13 15
14 16
15 18
16 18
17 18
18 8
19 8
20 10
21 9
22 7
23 10
24 10
25 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  2d <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  36 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  3f <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  48 <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  51 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  5a <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  62 <modnewton1_free+0x42>
mov    %rbx,%rdi
pop    %rbx
jmpq   6b <modnewton1_free+0x4b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 12
19 11
20 11
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
swlib_tty_termios(void)
{
 return(&save_termios);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,0x0(%rip)        # 25b <sigsegv_install_handler+0xb>
callq  100 <install_for.constprop.0>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigsegv_install_handler (sigsegv_handler_t handler)
{
  user_handler = handler;
  { int sig; sig = 11; { install_for (sig); } }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rdi,%rax
mov    %esi,%ecx
imul   %rsi,%rdx
shr    $0x20,%rax
shr    $0x20,%rsi
mov    %edi,%edi
imul   %rax,%rcx
imul   %rsi,%rdi
imul   %rsi,%rax
add    %rcx,%rdi
mov    $0x0,%ecx
mov    %rax,%r8
movabs $0x100000000,%rax
cmovae %rcx,%rax
mov    %rdi,%rcx
shl    $0x20,%rdi
shr    $0x20,%rcx
xor    %esi,%esi
add    %r8,%rcx
cmp    %rdi,%rdx
setb   %sil
add    %rsi,%rcx
add    %rcx,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
ummul (UCell a, UCell b)
{
  UDCell res;
  UCell m,ul,lu,uu;
  res.lo = a*b;
  ul = (((UCell)(a))>>((sizeof(Cell) * 8)/2))*((b)&((~(UCell)0)>>((sizeof(Cell) * 8)/2)));
  lu = ((a)&((~(UCell)0)>>((sizeof(Cell) * 8)/2)))*(((UCell)(b))>>((sizeof(Cell) * 8)/2));
  uu = (((UCell)(a))>>((sizeof(Cell) * 8)/2))*(((UCell)(b))>>((sizeof(Cell) * 8)/2));
  m = ul+lu;
  res.hi = (uu
     + (((UCell)(m<ul))<<((sizeof(Cell) * 8)/2))
     + (((UCell)(m))>>((sizeof(Cell) * 8)/2))
     + (res.lo<(((UCell)(m))<<((sizeof(Cell) * 8)/2)))
     );
  return res;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 5
5 6
6 7
7 7
8 6
9 7
10 8
11 11
12 11
13 8
14 11
15 11
16 12
17 13
18 12
19 13
20 11
21 13
22 13
23 12
24 13
25 16
26 16
<<<sep_out_sample>>>
xor    %edi,%edi
sub    $0x8,%rsp
callq  b <init_noninteractive+0xb>
mov    0x0(%rip),%eax        # 11 <init_noninteractive+0x11>
movl   $0x0,0x0(%rip)        # 1b <init_noninteractive+0x1b>
mov    $0x1,%edi
movl   $0x0,0x0(%rip)        # 2a <init_noninteractive+0x2a>
movl   $0x0,0x0(%rip)        # 34 <init_noninteractive+0x34>
movl   $0x1,0x0(%rip)        # 3e <init_noninteractive+0x3e>
mov    %eax,0x0(%rip)        # 44 <init_noninteractive+0x44>
mov    0x0(%rip),%eax        # 4a <init_noninteractive+0x4a>
test   %eax,%eax
jne    5b <init_noninteractive+0x5b>
xor    %edi,%edi
cmpl   $0x0,0x0(%rip)        # 57 <init_noninteractive+0x57>
setne  %dil
add    $0x8,%rsp
jmpq   64 <init_noninteractive+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_noninteractive ()
{
  bash_history_reinit (0);
  interactive_shell = startup_state = interactive = 0;
  expand_aliases = posixly_correct;
  no_line_editing = 1;
  set_job_control (forced_interactive||jobs_m_flag);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 5
5 4
6 7
7 4
8 4
9 6
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 7
19 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  4fb <emit_bug_reporting_address+0xb>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  50a <emit_bug_reporting_address+0x1a>
mov    $0x0,%edi
callq  514 <emit_bug_reporting_address+0x24>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%edx
xor    %eax,%eax
callq  528 <emit_bug_reporting_address+0x38>
mov    0x0(%rip),%rbx        # 52f <emit_bug_reporting_address+0x3f>
mov    $0x0,%edi
callq  539 <emit_bug_reporting_address+0x49>
mov    %rax,%rdi
mov    %rbx,%rsi
pop    %rbx
jmpq   545 <emit_bug_reporting_address+0x55>
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  printf (gettext ("\nReport bugs to: %s\n"), "bug-tar@gnu.org");
  printf (gettext ("%s home page: <%s>\n"), "GNU tar", "http://www.gnu.org/software/tar/");
  fputs_unlocked (gettext ("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),stdout)
                ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 7
21 5
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 647 <grecs_set_keywords+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_set_keywords (struct grecs_keyword *kwd)
{
  config_keywords.kwd = kwd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_fdiv (const double x, const double y)
{
  return x / y;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    $0x100,%edx
jmp    d20 <safe_xstat>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_lstat (const char *pathname, struct stat *buf)
{
  return safe_xstat (pathname, buf, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r15
mov    %ecx,%r15d
push   %r14
mov    %edx,%r14d
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
movzwl %r9w,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
cmp    0x2288(%rdi),%rbp
mov    0x168(%rdi),%r12
je     95 <VdbeDrawLine+0x55>
mov    0x170(%rdi),%rsi
mov    0x148(%rdi),%rdi
mov    %rbp,%rdx
mov    %r8d,0xc(%rsp)
callq  89 <VdbeDrawLine+0x49>
mov    0xc(%rsp),%r8d
mov    %rbp,0x2288(%rbx)
mov    0x170(%rbx),%rdx
mov    0x148(%rbx),%rdi
mov    %r15d,%r9d
mov    %r8d,(%rsp)
mov    %r13d,%ecx
mov    %r14d,%r8d
mov    %r12,%rsi
callq  b8 <VdbeDrawLine+0x78>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
VdbeDrawLine(Viewport *v, int x1, int y1, int x2, int y2,
      Color color)
{
  Drawable d;
  d = (Drawable) v->dbeDrawable;
  if (color != v->lastPixel) {
    XSetForeground (v->dpy, v->gc, color);
    v->lastPixel = color;
  }
  XDrawLine (v->dpy, d, v->gc, x1, y1, x2, y2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 3
11 3
12 3
13 6
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
testb  $0x1,0x50(%rdi)
mov    %rdi,%rax
jne    48 <call_chunkfun+0x18>
mov    0x38(%rdi),%rax
mov    %rsi,%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x48(%rdi),%rdi
mov    0x38(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_chunkfun (struct obstack *h, size_t size)
{
  if (h->use_extra_arg)
    return h->chunkfun.extra (h->extra_arg, size);
  else
    return h->chunkfun.plain (size);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    $0x0,%ebx
callq  221 <authenticate_imap_select+0x11>
mov    0x40(%rax),%r12
nopl   (%rax)
cmpq   $0x0,(%rbx)
je     250 <authenticate_imap_select+0x40>
movl   $0x1,0x10(%r12)
mov    %rbp,%rdi
callq  *0x8(%rbx)
add    $0x10,%rbx
cmp    $0x26,%eax
je     228 <authenticate_imap_select+0x18>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    $0x26,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
authenticate_imap_select (mu_authority_t auth)
{
  mu_folder_t folder = mu_authority_get_owner (auth);
  f_imap_t f_imap = folder->data;
  struct auth_tab *p;
  int status = 38;
  for (p = auth_tab; status == 38 && p->name; p++)
    {
      f_imap->state = IMAP_AUTH;
      status = p->method (auth);
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 3
7 4
8 4
9 7
10 7
11 9
12 10
13 10
14 7
15 7
16 7
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
mov    (%rdi),%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_get_ifd(XFORMAT * xux)
{
 ;
 return xux->ifdM;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%eax
mov    %rcx,%r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
cmove  %rax,%rbx
mov    %rdi,0x18(%rsp)
callq  ec0 <quotearg_buffer+0x30>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    0x30(%rbx),%rax
mov    0x4(%rbx),%r9d
mov    0x18(%rsp),%rdi
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
callq  0 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
   char const *arg, size_t argsize,
   struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
           p->style, p->flags, p->quote_these_too,
           p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
mov    0x0(%rip),%rbx        # 10d <usage+0xd>
callq  112 <usage+0x12>
mov    0x0(%rip),%rdi        # 119 <usage+0x19>
mov    %rax,%rsi
mov    %rbx,%rdx
xor    %eax,%eax
callq  126 <usage+0x26>
mov    $0x1,%edi
callq  130 <ceil_log_8>
<<<sep_in_sample>>>
usage (void)
{
  fprintf (stderr, gettext ("Try `%s --help' for more information.\n"),
    program_name);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
xor    %ecx,%ecx
mov    $0x1,%edx
jmpq   274c <swlib_write_catalog_stream+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swlib_write_catalog_stream(XFORMAT * package, int ofd)
{
 int ret;
 ret = taruib_write_catalog_stream((void*)package,
    ofd, 1, 0);
 return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # a <u32reset+0xa>
test   %eax,%eax
je     2b <u32reset+0x2b>
mov    0x0(%rip),%rdi        # 15 <u32reset+0x15>
cmp    $0xffffffffffffffff,%rdi
je     2b <u32reset+0x2b>
callq  20 <u32reset+0x20>
movq   $0xffffffffffffffff,0x0(%rip)        # 2b <u32reset+0x2b>
movl   $0x0,0x0(%rip)        # 35 <u32reset+0x35>
movl   $0x0,0x0(%rip)        # 3f <u32reset+0x3f>
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
u32reset ()
{
  if (u32init && localconv != (iconv_t)-1)
    {
      iconv_close (localconv);
      localconv = (iconv_t)-1;
    }
  u32init = 0;
  utf8locale = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 6
10 8
11 9
12 10
13 10
14 10
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%r12d
push   %rbp
push   %rbx
mov    $0x3,%ebx
callq  1134 <open_files+0x14>
mov    %eax,%ebp
callq  113b <open_files+0x1b>
mov    0x0(%rip),%rdi        # 1142 <open_files+0x22>
movslq %eax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  1151 <open_files+0x31>
cmp    $0x3,%ebp
jle    119c <open_files+0x7c>
nopw   %cs:0x0(%rax,%rax,1)
xor    %edx,%edx
xor    %eax,%eax
mov    $0x1,%esi
mov    %ebx,%edi
callq  1170 <open_files+0x50>
cmp    $0xffffffff,%eax
je     1195 <open_files+0x75>
mov    0x0(%rip),%rdi        # 117c <open_files+0x5c>
test   %eax,%eax
mov    $0x0,%ecx
cmove  %r12,%rcx
mov    %ebx,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1195 <open_files+0x75>
add    $0x1,%ebx
cmp    %ebp,%ebx
jne    1160 <open_files+0x40>
pop    %rbx
pop    %rbp
pop    %r12
mov    0x0(%rip),%rsi        # 11a7 <open_files+0x87>
mov    $0xa,%edi
jmpq   11b1 <open_files+0x91>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
open_files ()
{
  register int i;
  int f, fd_table_size;
  fd_table_size = getdtablesize ();
  fprintf (stderr, "pid %ld open files:", (long)getpid ());
  for (i = 3; i < fd_table_size; i++)
    {
      if ((f = fcntl (i, 1, 0)) != -1)
 fprintf (stderr, " %d (%s)", i, f ? "close" : "open");
    }
  fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 10
3 2
4 2
5 7
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 7
33 7
34 7
35 13
36 13
37 13
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x14,%edi
push   %rbx
mov    %rdx,%rbx
callq  e7 <gsasl_sha1+0x17>
test   %rax,%rax
mov    %rax,(%rbx)
je     108 <gsasl_sha1+0x38>
pop    %rbx
mov    %rbp,%rdi
mov    %r12,%rsi
mov    %rax,%rdx
pop    %rbp
pop    %r12
jmpq   101 <gsasl_sha1+0x31>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x7,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_sha1 (const char *in, size_t inlen, char *out[20])
{
  *out = malloc (20);
  if (!*out)
    return GSASL_MALLOC_ERROR;
  return gc_sha1 (in, inlen, *out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 3
9 4
10 3
11 4
12 7
13 6
14 6
15 6
16 7
17 7
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x3,%eax
je     78e <afm_set_verbose+0xe>
mov    %esi,(%rdi)
xor    %al,%al
repz retq 
<<<sep_in_sample>>>
afm_set_verbose (AFMHandle handle, unsigned int level)
{
  if (handle == ((void *)0))
    return 3;
  handle->verbose = level;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
push   %r14
test   %rdi,%rdi
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    (%rsi),%r12d
je     3a0 <extract_colon_unit+0x90>
mov    %r12d,%ebx
callq  32e <extract_colon_unit+0x1e>
cmp    %rax,%rbx
jae    3a0 <extract_colon_unit+0x90>
lea    0x0(%rbp,%rbx,1),%r14
movzbl (%r14),%eax
test   %al,%al
je     3a0 <extract_colon_unit+0x90>
cmp    $0x3a,%al
mov    %r12d,%ebx
jne    354 <extract_colon_unit+0x44>
jmp    3ab <extract_colon_unit+0x9b>
nopl   0x0(%rax)
cmp    $0x3a,%al
je     362 <extract_colon_unit+0x52>
add    $0x1,%ebx
mov    %ebx,%eax
movzbl 0x0(%rbp,%rax,1),%eax
test   %al,%al
jne    350 <extract_colon_unit+0x40>
mov    %ebx,%eax
sub    %r12d,%eax
mov    %eax,%r12d
lea    0x1(%r12),%edi
callq  374 <extract_colon_unit+0x64>
add    $0x1,%ebx
mov    %rax,%rbp
mov    %r12,%rdx
mov    %r14,%rsi
mov    %rax,%rdi
callq  388 <extract_colon_unit+0x78>
movb   $0x0,0x0(%rbp,%r12,1)
mov    %ebx,0x0(%r13)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
xor    %r12d,%r12d
mov    $0x1,%edi
jmp    36f <extract_colon_unit+0x5f>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extract_colon_unit (char *string, int *idx)
{
  unsigned int i = (unsigned int) *idx;
  unsigned int start = i;
  if (!string || i >= strlen (string))
    return ((void *)0);
  if (!string[i])
    return ((void *)0);
  while (string[i] && string[i] != ":"[0])
    i++;
  {
    char *value = xmalloc ((i - start) + 1);
    strncpy (value, &string[start], (i - start));
    value[i - start] = 0;
    i++;
    *idx = i;
    return value;
  }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 10
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 12
36 15
37 12
38 13
39 13
40 13
41 13
42 14
43 15
44 17
45 19
46 19
47 19
48 19
49 19
50 19
51 19
52 19
53 19
54 19
55 19
56 6
57 19
58 19
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %rdi,%r12
mov    $0x16,%eax
push   %rbp
push   %rbx
je     45a <mu_server_destroy+0x6a>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     460 <mu_server_destroy+0x70>
mov    0xa0(%rbp),%rsi
test   %rsi,%rsi
jne    423 <mu_server_destroy+0x33>
jmp    433 <mu_server_destroy+0x43>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    (%rsi),%rbx
mov    %rbp,%rdi
callq  42e <mu_server_destroy+0x3e>
test   %rbx,%rbx
jne    420 <mu_server_destroy+0x30>
mov    0xb8(%rbp),%rax
test   %rax,%rax
je     448 <mu_server_destroy+0x58>
mov    0xc0(%rbp),%rdi
callq  *%rax
mov    %rbp,%rdi
callq  450 <mu_server_destroy+0x60>
movq   $0x0,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
xor    %eax,%eax
jmp    45a <mu_server_destroy+0x6a>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_server_destroy (mu_server_t *psrv)
{
  mu_server_t srv;
  struct _mu_connection *p;
  if (!psrv)
    return 22;
  srv = *psrv;
  if (!srv)
    return 0;
  for (p = srv->head; p; )
    {
      struct _mu_connection *next = p->next;
      destroy_connection (srv, p);
      p = next;
    }
  if (srv->f_free)
    srv->f_free (srv->server_data);
  free (srv);
  *psrv = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 6
5 2
6 2
7 5
8 7
9 8
10 8
11 10
12 10
13 10
14 10
15 10
16 14
17 12
18 13
19 13
20 10
21 10
22 16
23 16
24 16
25 17
26 17
27 18
28 18
29 19
30 20
31 21
32 21
33 21
34 21
35 21
36 9
37 9
38 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # d7 <c__load_buffer_state+0x7>
mov    0x0(%rip),%rdx        # de <c__load_buffer_state+0xe>
lea    (%rax,%rdx,8),%rdx
mov    (%rdx),%rax
mov    0x20(%rax),%rcx
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # f4 <c__load_buffer_state+0x24>
mov    (%rdx),%rdx
mov    %rax,0x0(%rip)        # fe <c__load_buffer_state+0x2e>
mov    %rcx,0x0(%rip)        # 105 <c__load_buffer_state+0x35>
mov    (%rdx),%rdx
mov    %rdx,0x0(%rip)        # 10f <c__load_buffer_state+0x3f>
movzbl (%rax),%eax
mov    %al,0x0(%rip)        # 118 <c__load_buffer_state+0x48>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
c__load_buffer_state (void)
{
     (yy_n_chars) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_n_chars;
 (c_text) = (yy_c_buf_p) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_buf_pos;
 c_in = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_input_file;
 (yy_hold_char) = *(yy_c_buf_p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 3
11 5
12 5
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
mov    %rbx,%rdi
js     6f <rpl_fclose+0x6f>
callq  18 <rpl_fclose+0x18>
test   %eax,%eax
jne    50 <rpl_fclose+0x50>
mov    %rbx,%rdi
callq  24 <rpl_fclose+0x24>
test   %eax,%eax
je     6c <rpl_fclose+0x6c>
callq  2d <rpl_fclose+0x2d>
mov    (%rax),%r12d
mov    %rbx,%rdi
mov    %rax,%rbp
callq  3b <rpl_fclose+0x3b>
test   %r12d,%r12d
je     49 <rpl_fclose+0x49>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  58 <rpl_fclose+0x58>
xor    %esi,%esi
mov    $0x1,%edx
mov    %eax,%edi
callq  66 <rpl_fclose+0x66>
cmp    $0xffffffffffffffff,%rax
jne    1c <rpl_fclose+0x1c>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   78 <rpl_fclose+0x78>
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 8
8 7
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 12
19 11
20 12
21 13
22 13
23 15
24 16
25 19
26 19
27 19
28 19
29 19
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 12
39 19
40 19
41 19
42 12
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
je     2c7 <nettle_yarrow256_seed+0x17>
mov    %rdi,%rbx
callq  2be <nettle_yarrow256_seed+0xe>
mov    %rbx,%rdi
pop    %rbx
jmpq   2c7 <nettle_yarrow256_seed+0x17>
lea    0x0(%rip),%rcx        # 2ce <nettle_yarrow256_seed+0x1e>
lea    0x0(%rip),%rsi        # 2d5 <nettle_yarrow256_seed+0x25>
lea    0x0(%rip),%rdi        # 2dc <nettle_yarrow256_seed+0x2c>
mov    $0x73,%edx
callq  2e6 <nettle_yarrow256_seed+0x36>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_yarrow256_seed(struct yarrow256_ctx *ctx,
        size_t length,
        const uint8_t *seed_file)
{
  ((length > 0) ? (void) (0) : __assert_fail ("length > 0", "yarrow256.c", 115, __PRETTY_FUNCTION__));
  nettle_sha256_update(&ctx->pools[YARROW_FAST], length, seed_file);
  nettle_yarrow256_fast_reseed(ctx);
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 5
5 6
6 7
7 8
8 7
9 5
10 5
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r12
movslq %esi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  18f <argcpy+0xf>
lea    0x1(%rax,%r12,1),%rdi
mov    %rax,%rbp
callq  19c <argcpy+0x1c>
test   %rax,%rax
je     1b5 <argcpy+0x35>
lea    0x1(%rbp),%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1b0 <argcpy+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x0,%edi
callq  1bf <argcpy+0x3f>
mov    $0x1,%edi
callq  1c9 <argcpy+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argcpy(char arg[], int extra)
{
  char *cpy;
  if (!(cpy = malloc(strlen(arg) + extra + 1)))
    {
      perror("dap");
      exit(1);
    }
  strcpy(cpy, arg);
  return cpy;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 6
21 6
22 7
23 7
24 7
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   65d <rmdir_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
rmdir_error (char const *name)
{
  call_arg_error ("rmdir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # b <jinit_read_gif+0xb>
mov    $0x0,%edi
mov    $0x34,%edx
mov    $0x1,%esi
callq  1f <jinit_read_gif+0x1f>
mov    $0x1,%edi
callq  29 <jinit_read_gif+0x29>
<<<sep_in_sample>>>
jinit_read_gif (j_compress_ptr cinfo)
{
  fprintf(stderr, "GIF input is unsupported for legal reasons.  Sorry.\n");
  exit(1);
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
jmp    973 <skipws+0x23>
nop
mov    %rbx,%rdi
callq  968 <skipws+0x18>
cmp    $0x1,%rax
jne    998 <skipws+0x48>
cmpb   $0xa,(%rbx)
jne    9c0 <skipws+0x70>
mov    0x8(%rbp),%rdx
mov    %r12d,%esi
mov    %rbx,%rdi
callq  982 <skipws+0x32>
test   %rax,%rax
jne    960 <skipws+0x10>
pop    %rbx
mov    0x8(%rbp),%rdi
pop    %rbp
pop    %r12
jmpq   994 <skipws+0x44>
nopl   0x0(%rax)
neg    %rax
mov    %rax,%rsi
mov    0x8(%rbp),%rdi
mov    $0x1,%edx
callq  9ac <skipws+0x5c>
pop    %rbx
mov    0x8(%rbp),%rdi
pop    %rbp
pop    %r12
jmpq   9b9 <skipws+0x69>
nopl   0x0(%rax)
mov    $0xffffffffffffffff,%rsi
jmp    99e <skipws+0x4e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
skipws(struct outline_file *file, char *buf, size_t size)
{
    while (fgets(buf, size, file->fp)) {
 size_t len = strlen(buf);
 if (!(len == 1 && buf[0] == '\n')) {
     fseek(file->fp, -(off_t)len, 1);
     break;
 }
    }
    return ftell(file->fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 5
15 3
16 3
17 3
18 3
19 3
20 3
21 11
22 10
23 11
24 11
25 10
26 10
27 10
28 10
29 6
30 6
31 6
32 11
33 10
34 11
35 11
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     188 <refree+0x68>
movq   $0x0,0x28(%rdi)
callq  136 <refree+0x16>
mov    0x48(%rbx),%rdi
test   %rdi,%rdi
je     144 <refree+0x24>
callq  144 <refree+0x24>
mov    0x50(%rbx),%rdi
test   %rdi,%rdi
je     152 <refree+0x32>
callq  152 <refree+0x32>
cmpw   $0x0,0x60(%rbx)
jne    168 <refree+0x48>
mov    %rbx,%rdi
pop    %rbx
jmpq   162 <refree+0x42>
nopw   0x0(%rax,%rax,1)
mov    0x58(%rbx),%rdi
callq  171 <refree+0x51>
mov    0x58(%rbx),%rdi
callq  17a <refree+0x5a>
mov    %rbx,%rdi
pop    %rbx
jmpq   183 <refree+0x63>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
refree(Regexp *rp)
{
 if (rp == ((void *)0))
  return;
 rp->pat.translate = ((void *)0);
 regfree(& rp->pat);
 if (rp->regs.start)
  free(rp->regs.start);
 if (rp->regs.end)
  free(rp->regs.end);
 if (rp->dfa) {
  dfafree(rp->dfareg);
  free(rp->dfareg);
 }
 free(rp);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 6
7 7
8 7
9 7
10 8
11 9
12 9
13 9
14 10
15 11
16 11
17 15
18 16
19 15
20 15
21 12
22 12
23 13
24 13
25 15
26 16
27 15
28 15
29 16
30 16
31 16
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1b86 <php_set_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_set_debug (int bdebug )
{
        php__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0xc(%rdi),%esi
mov    $0x1,%edx
jmpq   13d <varray_append+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
varray_append(VARRAY *vb)
{
 return varray_assign(vb, vb->length, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x38,%rsp
movapd %xmm0,%xmm5
ucomisd %xmm3,%xmm2
movsd  %xmm0,(%rsp)
movsd  %xmm1,0x8(%rsp)
movsd  %xmm2,0x20(%rsp)
movsd  %xmm3,0x28(%rsp)
jae    79e <BetaRandom+0x11e>
xorpd  %xmm0,%xmm0
ucomisd %xmm5,%xmm0
jae    79e <BetaRandom+0x11e>
ucomisd %xmm1,%xmm0
jae    79e <BetaRandom+0x11e>
movsd  0x0(%rip),%xmm7        # 6c9 <BetaRandom+0x49>
ucomisd (%rsp),%xmm7
ja     720 <BetaRandom+0xa0>
movsd  (%rsp),%xmm0
callq  6da <BetaRandom+0x5a>
movsd  %xmm0,(%rsp)
movsd  0x8(%rsp),%xmm0
callq  6ea <BetaRandom+0x6a>
movsd  (%rsp),%xmm2
addsd  %xmm2,%xmm0
divsd  %xmm0,%xmm2
movsd  0x20(%rsp),%xmm6
movsd  0x28(%rsp),%xmm1
add    $0x38,%rsp
subsd  %xmm6,%xmm1
movapd %xmm2,%xmm0
mulsd  %xmm1,%xmm0
addsd  %xmm6,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
ucomisd 0x8(%rsp),%xmm7
jbe    6d0 <BetaRandom+0x50>
nopl   0x0(%rax,%rax,1)
callq  735 <BetaRandom+0xb5>
movsd  %xmm0,0x10(%rsp)
callq  740 <BetaRandom+0xc0>
movsd  0x0(%rip),%xmm1        # 748 <BetaRandom+0xc8>
movsd  0x10(%rsp),%xmm2
divsd  (%rsp),%xmm1
movsd  %xmm0,0x18(%rsp)
movapd %xmm2,%xmm0
callq  762 <BetaRandom+0xe2>
movsd  0x0(%rip),%xmm1        # 76a <BetaRandom+0xea>
movsd  0x18(%rsp),%xmm3
divsd  0x8(%rsp),%xmm1
movsd  %xmm0,0x10(%rsp)
movapd %xmm3,%xmm0
callq  785 <BetaRandom+0x105>
movsd  0x10(%rsp),%xmm2
addsd  %xmm2,%xmm0
ucomisd 0x0(%rip),%xmm0        # 797 <BetaRandom+0x117>
ja     730 <BetaRandom+0xb0>
jmpq   6f3 <BetaRandom+0x73>
mov    $0x0,%edi
callq  7a8 <BetaRandom+0x128>
xor    %edi,%edi
callq  7af <BetaRandom+0x12f>
nop
<<<sep_in_sample>>>
BetaRandom (double alpha, double beta, double a, double b)
{
  double u1, u2, w;
  if (b <= a || alpha <= 0 || beta <= 0) {
    printf ("Error: bad shape or range for a beta variate - Exiting\n\n");
    exit (0);
  }
  if ((alpha < 1) && (beta < 1))
    do {
      u1 = Randoms();
      u2 = Randoms();
      u1 = pow(u1, 1/alpha);
      u2 = pow(u2, 1/beta);
      w = u1 + u2;
    } while (w > 1.0);
  else {
    u1 = GammaRandom(alpha);
    u2 = GammaRandom(beta);
    w = u1 + u2;
  }
  return (a + (u1/w) * (b - a));
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 8
15 8
16 8
17 17
18 17
19 17
20 18
21 18
22 19
23 19
24 21
25 21
26 21
27 22
28 21
29 21
30 21
31 21
32 22
33 22
34 8
35 8
36 8
37 10
38 10
39 11
40 12
41 12
42 12
43 11
44 12
45 12
46 13
47 13
48 13
49 12
50 13
51 13
52 14
53 14
54 15
55 15
56 15
57 5
58 5
59 6
60 6
61 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x1,%esi
mov    %rdi,(%rsp)
mov    %rsp,%rdi
movl   $0x4,0x8(%rsp)
callq  8460 <do_assignment_internal>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_assignment (string)
     char *string;
{
  WORD_DESC td;
  td.flags = 0x000004;
  td.word = string;
  return do_assignment_internal (&td, 1);
}
<<<sep_in_sample>>>
1 3
2 7
3 6
4 7
5 5
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1c7 <dico_strategy_count+0x7>
jmpq   1cc <dico_strategy_count+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dico_strategy_count()
{
    return dico_list_count(strategy_list);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
jmpq   50 <cmdline_parser_release>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0x0,%eax
nopl   (%rax)
movsbl (%rax),%edx
cmp    %edi,%edx
je     208 <wordsplit_quote_char+0x28>
sub    $0x2,%rax
cmp    $0x0,%rax
ja     1e8 <wordsplit_quote_char+0x8>
mov    $0xffffffff,%eax
retq   
nopl   0x0(%rax)
movsbl -0x1(%rax),%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
wordsplit_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof(quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 7
5 7
6 5
7 4
8 4
9 10
10 11
11 11
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 8f7 <fsfromline+0x7>
push   %rbx
mov    %rdi,%rbx
mov    0x20(%rax),%rax
mov    0x8(%rax),%rdx
cmp    %rdi,%rdx
jl     928 <fsfromline+0x38>
jmp    91d <fsfromline+0x2d>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rax),%rax
test   %rax,%rax
je     947 <fsfromline+0x57>
mov    0x8(%rax),%rdx
cmp    %rdx,%rbx
jne    910 <fsfromline+0x20>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x10(%rax),%rax
test   %rax,%rax
je     947 <fsfromline+0x57>
nopl   0x0(%rax)
cmp    %rbx,0x8(%rax)
je     922 <fsfromline+0x32>
mov    0x10(%rax),%rax
test   %rax,%rax
jne    938 <fsfromline+0x48>
mov    $0x0,%edi
callq  951 <fsfromline+0x61>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x2,%edi
xor    %eax,%eax
callq  963 <fsfromline+0x73>
xor    %eax,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
fsfromline(ssize_t lineno)
{
    filestruct *f = openfile->current;
    if (lineno <= openfile->current->lineno)
 while (f->lineno != lineno && f->prev != ((void *)0))
     f = f->prev;
    else
 while (f->lineno != lineno && f->next != ((void *)0))
     f = f->next;
    if (f->lineno != lineno) {
 statusline(ALERT, gettext("Internal error: can't match line %d.  " "Please save your work.")
                            , lineno);
 return ((void *)0);
    }
    return f;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 16
17 16
18 16
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 13
36 16
37 16
<<<sep_out_sample>>>
mov    %rsi,0x28(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_nonce_count (osip_authentication_info_t * authentication_info, char *nonce_count)
{
  authentication_info->nonce_count = (char *) nonce_count;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x1,%edx
mov    $0x2f,%esi
jmpq   109f <swlib_squash_trailing_slash+0xf>
nop
<<<sep_in_sample>>>
swlib_squash_trailing_slash(char *path)
{
 squash_trailing_char(path, '/', 1);
 return;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d0 <osip_sem_trywait+0x10>
jmpq   1ca <osip_sem_trywait+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
<<<sep_in_sample>>>
osip_sem_trywait (struct osip_sem *_sem)
{
  osip_sem_t *sem = (osip_sem_t *) _sem;
  if (sem == ((void *)0))
    return -2;
  return sem_trywait (sem);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  8ac <gsl_sf_bessel_In+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    8c0 <gsl_sf_bessel_In+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xe0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8d6 <gsl_sf_bessel_In+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_In(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_In_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_In_e(n, x, &result)", "bessel_In.c", 224, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %r8,%rbx
sub    $0x2028,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2018(%rsp)
xor    %eax,%eax
test   %dl,%dl
je     80 <print_quoted+0x80>
lea    0x10(%rsp),%r13
mov    %rsi,%r8
mov    %rsi,%r15
mov    $0xffffffffffffffff,%rcx
mov    %rbx,%rdx
mov    $0x2000,%esi
mov    %r13,%rdi
callq  53 <print_quoted+0x53>
cmp    $0x1fff,%rax
mov    %rax,%r14
ja     c0 <print_quoted+0xc0>
mov    %r13,%rdi
mov    %rax,%rsi
callq  69 <print_quoted+0x69>
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
xor    %eax,%eax
callq  79 <print_quoted+0x79>
jmp    8d <print_quoted+0x8d>
nopl   0x0(%rax,%rax,1)
mov    %r8,%rdx
mov    %rcx,%rsi
xor    %eax,%eax
callq  8d <print_quoted+0x8d>
mov    0x2018(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    138 <print_quoted+0x138>
add    $0x2028,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   %cs:0x0(%rax,%rax,1)
lea    0x1(%rax),%rsi
mov    %rsi,%rdi
mov    %rsi,0x8(%rsp)
callq  d1 <print_quoted+0xd1>
mov    0x8(%rsp),%rsi
mov    %r15,%r8
mov    $0xffffffffffffffff,%rcx
mov    %rbx,%rdx
mov    %rax,%rdi
mov    %rax,0x8(%rsp)
callq  f0 <print_quoted+0xf0>
mov    0x8(%rsp),%r9
mov    %r14,%rsi
mov    %r9,%rdi
callq  100 <print_quoted+0x100>
mov    0x8(%rsp),%r9
xor    %eax,%eax
mov    %r12,%rsi
mov    %rbp,%rdi
mov    %r9,%rdx
callq  115 <print_quoted+0x115>
mov    0x8(%rsp),%r9
cmp    %r13,%r9
je     8d <print_quoted+0x8d>
mov    %r9,%rdi
mov    %eax,0x8(%rsp)
callq  12f <print_quoted+0x12f>
mov    0x8(%rsp),%eax
jmpq   8d <print_quoted+0x8d>
callq  13d <print_quoted+0x13d>
<<<sep_in_sample>>>
print_quoted (FILE *fp,
       const struct quoting_options *qopts,
       _Bool dest_is_tty,
       const char *format,
       const char *s)
{
  int rv;
  if (dest_is_tty)
    {
      char smallbuf[8192];
      size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, s, -1, qopts);
      char *buf;
      if (len < sizeof smallbuf)
 buf = smallbuf;
      else
 {
   buf = xmalloc (len + 1);
   quotearg_buffer (buf, len + 1, s, -1, qopts);
 }
      len = qmark_chars (buf, len);
      rv = fprintf (fp, format, buf);
      if (buf != smallbuf)
 {
   free (buf);
   buf = ((void *)0);
 }
    }
  else
    {
      rv = fprintf (fp, format, s);
    }
  return rv;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 13
25 11
26 13
27 20
28 20
29 20
30 21
31 21
32 21
33 21
34 21
35 21
36 21
37 30
38 30
39 30
40 30
41 33
42 33
43 33
44 33
45 33
46 33
47 33
48 33
49 33
50 33
51 33
52 33
53 17
54 17
55 17
56 17
57 18
58 18
59 18
60 18
61 18
62 18
63 18
64 20
65 20
66 20
67 20
68 21
69 21
70 21
71 21
72 21
73 21
74 22
75 22
76 22
77 24
78 24
79 24
80 24
81 24
82 33
<<<sep_out_sample>>>
jmpq   5 <c_strstr+0x5>
<<<sep_in_sample>>>
c_strstr (const char *haystack, const char *needle)
{
  return strstr (haystack, needle);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
cmp    $0x3,%edi
mov    0x78(%rsi),%rax
jg     20b0 <__osip_transport_error_callback+0x20>
movslq %edi,%rcx
mov    0x290(%rax,%rcx,8),%rax
test   %rax,%rax
je     20d8 <__osip_transport_error_callback+0x48>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
mov    %edi,%r9d
mov    $0x0,%r8d
xor    %ecx,%ecx
mov    $0x1,%edx
mov    $0x645,%esi
mov    $0x0,%edi
xor    %eax,%eax
jmpq   20d1 <__osip_transport_error_callback+0x41>
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_transport_error_callback (int type, osip_transaction_t * tr, int error)
{
  osip_t *config = tr->config;
  if (type >= OSIP_TRANSPORT_ERROR_CALLBACK_COUNT) {
    osip_trace ("osip.c", 1605, TRACE_LEVEL1, ((void *)0), "invalid callback type %d\n", type);
    return;
  }
  if (config->tp_error_callbacks[type] == ((void *)0))
    return;
  config->tp_error_callbacks[type] (type, tr, error);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 8
5 8
6 8
7 8
8 10
9 10
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
mov    %r8,%rdx
push   %rbx
mov    %r8,%rbx
sub    $0x10,%rsp
callq  313 <gsl_stats_long_double_covariance+0x23>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
movsd  %xmm0,0x8(%rsp)
callq  327 <gsl_stats_long_double_covariance+0x37>
movsd  0x8(%rsp),%xmm2
add    $0x10,%rsp
mov    %rbx,%r8
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdi
mov    %r14,%rsi
pop    %r13
pop    %r14
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
jmpq   355 <gsl_stats_long_double_covariance+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_covariance (const long double data1[], const size_t stride1,
                                const long double data2[], const size_t stride2,
                                const size_t n)
{
  const double mean1 = gsl_stats_long_double_mean (data1, stride1, n);
  const double mean2 = gsl_stats_long_double_mean (data2, stride2, n);
  return gsl_stats_long_double_covariance_m(data1, stride1,
                                          data2, stride2,
                                          n,
                                          mean1, mean2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 5
14 6
15 6
16 6
17 5
18 6
19 7
20 11
21 7
22 7
23 7
24 11
25 11
26 11
27 7
28 7
29 11
30 11
31 6
32 7
33 7
34 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # ee6 <gsl_vector_short_ptr+0x6>
test   %eax,%eax
je     eef <gsl_vector_short_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    f00 <gsl_vector_short_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f1d <gsl_vector_short_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_ptr (gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   e0 <find_db_entry>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mod_info(dico_handle_t hp)
{
    struct dictdb *db = (struct dictdb *) hp;
    return find_db_entry(db, "00-database""-info");
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
test   %rax,%rax
js     1370 <str_kilobytes+0x40>
cvtsi2sd %rax,%xmm0
mov    0x30(%rdi),%rax
movsd  0x0(%rip),%xmm1        # 134a <str_kilobytes+0x1a>
mulsd  %xmm0,%xmm1
test   %rax,%rax
js     1390 <str_kilobytes+0x60>
cvtsi2sd %rax,%xmm0
mulsd  0x0(%rip),%xmm0        # 1360 <str_kilobytes+0x30>
addsd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 136c <str_kilobytes+0x3c>
retq   
nopl   (%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
jmp    133e <str_kilobytes+0xe>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
jmp    1358 <str_kilobytes+0x28>
<<<sep_in_sample>>>
str_kilobytes(NODE *symbol)
{
 unsigned long bucket_cnt;
 double kb;
 bucket_cnt = symbol->sub.nodep.reflags;
 kb = (((double) bucket_cnt) * sizeof (BUCKET) +
  ((double) symbol->sub.nodep.cnt) * sizeof (BUCKET *)) / 1024.0;
 return kb;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 7
6 6
7 6
8 7
9 7
10 7
11 7
12 6
13 6
14 9
15 9
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 7
30 7
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 7 <SetJoystickPort+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
SetJoystickPort (char * name)
{
    joystick_port = name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   33 <register_xidle+0x13>
<<<sep_in_sample>>>
register_xidle()
{
    static struct dicod_command cmd[] = {
 { "XIDLE", 1, 1, ((void *)0), "report inactivity timeout, reset idle timer",
   dicod_xidle },
 { ((void *)0) }
    };
    dicod_capa_register("xidle", cmd, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
<<<sep_out_sample>>>
movslq 0x88(%rdi),%rdx
mov    $0x0,%eax
cmp    0x0(%rip),%edx        # 2652 <wordsplit_strerror+0x12>
jge    265c <wordsplit_strerror+0x1c>
mov    0x0(,%rdx,8),%rax
repz retq 
<<<sep_in_sample>>>
wordsplit_strerror (struct wordsplit *ws)
{
  if (ws->ws_errno < _wordsplit_nerrs)
    return _wordsplit_errstr[ws->ws_errno];
  return "unknown error";
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 4
6 6
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm0
jmpq   d <gsl_nan+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_nan (void)
{
  return gsl_fdiv (0.0, 0.0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
callq  69 <strcasestr+0x19>
mov    %r13,%rdi
mov    %rax,%r15
callq  74 <strcasestr+0x24>
sub    %rax,%r15
add    %r12,%r15
mov    %r15,0x8(%rsp)
jb     f4 <strcasestr+0xa4>
callq  86 <strcasestr+0x36>
mov    (%rax),%r15
movzbl 0x0(%r13),%eax
mov    %al,0x7(%rsp)
movzbl 0x7(%rsp),%ebp
xor    %ebx,%ebx
jmp    af <strcasestr+0x5f>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl 0x0(%r13,%rbx,1),%ebp
test   %bpl,%bpl
je     100 <strcasestr+0xb0>
movsbl (%r12,%rbx,1),%edx
movsbq %dl,%rax
mov    %edx,%r14d
testb  $0x1,0x1(%r15,%rax,2)
je     cd <strcasestr+0x7d>
mov    %edx,%edi
callq  ca <strcasestr+0x7a>
mov    %eax,%r14d
movsbq %bpl,%rsi
movsbl %bpl,%eax
testb  $0x1,0x1(%r15,%rsi,2)
je     e4 <strcasestr+0x94>
mov    %eax,%edi
callq  e4 <strcasestr+0x94>
cmp    %eax,%r14d
je     a0 <strcasestr+0x50>
add    $0x1,%r12
cmp    %r12,0x8(%rsp)
jae    92 <strcasestr+0x42>
xor    %eax,%eax
jmp    103 <strcasestr+0xb3>
nopl   0x0(%rax,%rax,1)
mov    %r12,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strcasestr (char const *s1, char const *s2)
{
  char const *s1p;
  char const *s2p;
  char const *s1last;
  for (s1last = &s1[strlen (s1) - strlen (s2)]; s1 <= s1last; s1++)
    for (s1p = s1, s2p = s2; (((*__ctype_b_loc ())[(int) ((*s1p))] & (unsigned short int) _ISupper) ? tolower (*s1p) : (*s1p)) == (((*__ctype_b_loc ())[(int) ((*s2p))] & (unsigned short int) _ISupper) ? tolower (*s2p) : (*s2p)); s1p++)
      if (*++s2p == '\0')
 return (char *) s1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 2
23 2
24 2
25 2
26 2
27 8
28 8
29 8
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 6
47 6
48 6
49 10
50 10
51 10
52 10
53 11
54 11
55 11
56 11
57 11
58 11
59 11
60 11
61 11
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2436 <php_set_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_set_debug (int bdebug )
{
        php__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x3b,%esi
jg     20f8 <osip_set_message_callback+0x18>
movslq %esi,%rsi
xor    %eax,%eax
mov    %rdx,0x90(%rdi,%rsi,8)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    %esi,%r9d
mov    $0x0,%r8d
xor    %ecx,%ecx
mov    $0x2,%edx
mov    $0x652,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  211d <osip_set_message_callback+0x3d>
mov    $0xfffffffe,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_set_message_callback (osip_t * config, int type, osip_message_cb_t cb)
{
  if (type >= OSIP_MESSAGE_CALLBACK_COUNT) {
    osip_trace ("osip.c", 1618, TRACE_LEVEL2, ((void *)0), "invalid callback type %d\n", type);
    return -2;
  }
  config->msg_callbacks[type] = cb;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 8
5 7
6 8
7 8
8 2
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 9
19 9
20 9
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 7ea <rl_clear_pending_input+0xa>
andq   $0xfffffffffffdffff,0x0(%rip)        # 7f5 <rl_clear_pending_input+0x15>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_clear_pending_input ()
{
  rl_pending_input = 0;
  (rl_readline_state &= ~(0x0020000));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
push   %r12
xor    %eax,%eax
mov    %rsi,%r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
mov    0x0(%rip),%rdi        # 17 <prerror+0x17>
push   %rbx
mov    %rdx,%rbx
mov    0x0(%rip),%rdx        # 22 <prerror+0x22>
callq  27 <prerror+0x27>
mov    0x0(%rip),%rdi        # 2e <prerror+0x2e>
mov    %r12,%rdx
mov    %rbp,%rsi
callq  39 <prerror+0x39>
test   %rbx,%rbx
je     54 <prerror+0x54>
mov    0x0(%rip),%rdi        # 45 <prerror+0x45>
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  54 <prerror+0x54>
pop    %rbx
pop    %rbp
pop    %r12
mov    0x0(%rip),%rsi        # 5f <prerror+0x5f>
mov    $0xa,%edi
jmpq   69 <prerror+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
prerror (const char *fmt, va_list ap, const char *diag)
{
  fprintf (stderr, "%s: ", progname);
  vfprintf (stderr, fmt, ap);
  if (diag)
    fprintf (stderr, ": %s", diag);
  fputc ('\n', stderr);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 2
9 2
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 8
24 8
25 8
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
push   %rbx
callq  18e0 <expbxor>
cmpl   $0x7c,0x0(%rip)        # 192d <expbor+0xd>
mov    %rax,%rbx
jne    1958 <expbor+0x38>
nopw   0x0(%rax,%rax,1)
callq  270 <readtok>
callq  18e0 <expbxor>
or     %rax,%rbx
cmpl   $0x7c,0x0(%rip)        # 194c <expbor+0x2c>
movl   $0x6,0x0(%rip)        # 1956 <expbor+0x36>
je     1938 <expbor+0x18>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
expbor ()
{
  register intmax_t val1, val2;
  val1 = expbxor ();
  while (curtok == '|')
    {
      readtok ();
      val2 = expbxor ();
      val1 = val1 | val2;
      lasttok = 6;
    }
  return (val1);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 4
5 5
6 5
7 7
8 8
9 9
10 5
11 10
12 5
13 13
14 13
15 13
16 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  a9 <swi_com_set_header_index+0x9>
test   %eax,%eax
js     b3 <swi_com_set_header_index+0x13>
mov    %eax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
mov    $0x62,%esi
mov    $0x0,%edi
callq  c2 <swi_com_set_header_index+0x22>
movl   $0x0,(%rbx)
mov    $0xffffffff,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
swi_com_set_header_index(SWHEADER * header, SWPATH_EX * swpath_ex, int * ai)
{
 int index_offset;
 int retval;
 index_offset = glbindex_find_by_swpath_ex(header, swpath_ex);
 if (index_offset >= 0) {
         *ai = index_offset;
  retval = 0;
 } else {
  swi_com_internal_error("swi_common.c", 98);
  *ai = 0;
  retval = -1;
 }
 return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 6
5 6
6 7
7 8
8 15
9 15
10 10
11 10
12 10
13 11
14 12
15 15
16 15
17 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  63c <gsl_sf_bessel_Knu+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    650 <gsl_sf_bessel_Knu+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xb7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  666 <gsl_sf_bessel_Knu+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Knu(const double nu, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Knu_e(nu, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Knu_e(nu, x, &result)", "bessel_Knu.c", 183, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   643 <gsl_sort_vector_float_smallest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_float_smallest (float * dest, const size_t k,
                                     const gsl_vector_float * v)
{
  return gsl_sort_float_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     18 <udf_get_filename+0x18>
mov    (%rdi),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
cmovne %rdx,%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
udf_get_filename(const udf_dirent_t *p_udf_dirent)
{
  if (!p_udf_dirent) return ((void *)0);
  if (!p_udf_dirent->psz_name) return "..";
  return p_udf_dirent->psz_name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 3
10 6
11 6
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
sub    $0x8,%rsp
callq  bd <gsl_ntuple_open+0x1d>
test   %rax,%rax
mov    %rax,%rbx
je     f0 <gsl_ntuple_open+0x50>
mov    %r13,0x8(%rax)
mov    %r12,0x10(%rax)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  da <gsl_ntuple_open+0x3a>
test   %rax,%rax
mov    %rax,(%rbx)
je     10d <gsl_ntuple_open+0x6d>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x8,%ecx
mov    $0x46,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  109 <gsl_ntuple_open+0x69>
xor    %eax,%eax
jmp    e5 <gsl_ntuple_open+0x45>
mov    %rbx,%rdi
callq  115 <gsl_ntuple_open+0x75>
mov    $0x5,%ecx
mov    $0x52,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12e <gsl_ntuple_open+0x8e>
xor    %eax,%eax
jmp    e5 <gsl_ntuple_open+0x45>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ntuple_open (char *filename, void *ntuple_data, size_t size)
{
  gsl_ntuple *ntuple = (gsl_ntuple *)malloc (sizeof (gsl_ntuple));
  if (ntuple == 0)
    {
      do { gsl_error ("failed to allocate space for ntuple struct",
 "ntuple.c"
      ,
 70
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                   ;
    }
  ntuple->ntuple_data = ntuple_data;
  ntuple->size = size;
  ntuple->file = fopen (filename, "rb");
  if (ntuple->file == 0)
    {
      free (ntuple);
      do { gsl_error ("unable to open ntuple file for reading",
 "ntuple.c"
      ,
 82
      , GSL_EFAILED) ; return 0 ; } while (0)
                                    ;
    }
  return ntuple;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 2
9 2
10 3
11 4
12 3
13 4
14 13
15 14
16 15
17 15
18 15
19 16
20 15
21 16
22 16
23 27
24 27
25 27
26 27
27 27
28 27
29 6
30 6
31 6
32 6
33 6
34 10
35 10
36 18
37 18
38 19
39 19
40 19
41 19
42 19
43 23
44 23
45 23
<<<sep_out_sample>>>
mov    %esi,0x54(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shcmd_set_append2(SHCMD * shcmd, int do_append)
{
 shcmd->append2_ = do_append;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  9c <scram_free_client_final+0xc>
mov    0x8(%rbx),%rdi
callq  a5 <scram_free_client_final+0x15>
mov    0x10(%rbx),%rdi
callq  ae <scram_free_client_final+0x1e>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
scram_free_client_final (struct scram_client_final *cl)
{
  free (cl->cbind);
  free (cl->nonce);
  free (cl->proof);
  memset (cl, 0, sizeof (*cl));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x1,%edi
callq  9e3 <init_profiling_signals+0x13>
mov    $0x0,%esi
mov    $0xa,%edi
add    $0x8,%rsp
jmpq   9f6 <init_profiling_signals+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_profiling_signals()
{
 signal(1, dump_and_exit);
 signal(10, just_dump);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 4
9 4
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
test   %r10,%r10
je     1dc1 <gsl_matrix_float_scale+0x71>
push   %rbx
lea    0x0(,%r9,4),%rbx
shl    $0x2,%r11
xor    %ecx,%ecx
xor    %esi,%esi
nopl   0x0(%rax)
test   %r9,%r9
je     1db1 <gsl_matrix_float_scale+0x61>
mov    0x18(%rdi),%rdx
lea    (%rcx,%rbx,1),%r8
lea    (%rdx,%rcx,1),%rax
add    %r8,%rdx
nopl   0x0(%rax)
movss  (%rax),%xmm1
add    $0x4,%rax
cvtps2pd %xmm1,%xmm1
mulsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,-0x4(%rax)
cmp    %rdx,%rax
jne    1d90 <gsl_matrix_float_scale+0x40>
add    $0x1,%rsi
add    %r11,%rcx
cmp    %r10,%rsi
jne    1d78 <gsl_matrix_float_scale+0x28>
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_scale (gsl_matrix_float * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 2
7 2
8 2
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 9
27 9
28 7
29 7
30 7
31 7
32 15
33 15
34 15
35 15
36 15
37 15
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_set_protocol (osip_via_t * via, char *protocol)
{
  via->protocol = protocol;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
jmpq   65 <alphabetic+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alphabetic (c)
     int c;
{
  return rl_alphabetic (c);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     5b <__gmp_printf+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rdi,%rdx
mov    $0x0,%edi
mov    0x0(%rip),%rsi        # 77 <__gmp_printf+0x77>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  9b <__gmp_printf+0x9b>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_printf (const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 6
19 2
20 6
21 6
22 5
23 5
24 5
25 5
26 5
27 6
28 9
29 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x10,%rsp
lea    0xc(%rsp),%rsi
callq  725 <ahs_set_gid_by_name+0x15>
test   %eax,%eax
mov    (%rbx),%rax
jne    740 <ahs_set_gid_by_name+0x30>
mov    0xc(%rsp),%edx
mov    %rdx,0x20(%rax)
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movq   $0x1fffff,0x20(%rax)
add    $0x10,%rsp
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
ahs_set_gid_by_name(AHS * xhs, char * groupname) {
 gid_t x;
 ;
 if (taru_get_gid_by_name(groupname, &x)) {
  ;
  ahs_vfile_hdr(xhs)->c_gid = (07777777);
 } else {
  ;
  ahs_vfile_hdr(xhs)->c_gid = (unsigned long)x;
 }
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 4
6 4
7 4
8 6
9 4
10 9
11 9
12 11
13 11
14 11
15 11
16 6
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 5a6 <must_be_building+0x6>
mov    %rsi,%rax
test   %edx,%edx
je     5b0 <must_be_building+0x10>
repz retq 
nop
mov    %rdi,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
jmpq   5c2 <must_be_building+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
must_be_building (directive, defs)
     char *directive;
     DEF_FILE *defs;
{
  if (!building_builtin)
    line_error (defs, "%s must be inside of a $BUILTIN block", directive);
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
callq  1c6 <decode+0x16>
movsbq 0x0(%rbp),%rdx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rdx,2)
je     1f0 <decode+0x40>
jmp    22c <decode+0x7c>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  1e8 <decode+0x38>
test   %eax,%eax
je     220 <decode+0x70>
add    $0x10,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    1e0 <decode+0x30>
mov    %rbp,%r8
mov    %r12,%rcx
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
callq  211 <decode+0x61>
add    $0x10,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
mov    0x8(%rbx),%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
lea    0x8(%rsp),%rsi
xor    %edx,%edx
mov    %rbp,%rdi
callq  23b <decode+0x8b>
mov    %rax,%rbx
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
jne    251 <decode+0xa1>
cmp    $0x3f8,%rbx
jbe    26a <decode+0xba>
mov    %rbp,%r8
mov    %r12,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  26a <decode+0xba>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
decode (char *name, CODE *codetab, const char *what)
{
  CODE *cp;
  if (((*__ctype_b_loc ())[(int) ((*name))] & (unsigned short int) _ISdigit))
    {
      char *p;
      unsigned long n = strtoul (name, &p, 0);
      if (*p || n > 0x03f8)
 error (1, 0, "invalid %s number: %s", what, name);
      return n;
    }
  for (cp = codetab; cp->c_name; cp++)
    {
      if (strcasecmp (name, cp->c_name) == 0)
 return cp->c_val;
    }
  error (1, 0, "unknown %s name: %s", what, name);
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 14
16 14
17 14
18 14
19 12
20 12
21 12
22 12
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 19
31 18
32 19
33 19
34 19
35 19
36 19
37 15
38 19
39 19
40 19
41 19
42 19
43 7
44 7
45 7
46 7
47 7
48 8
49 8
50 8
51 8
52 8
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 19
61 10
62 19
63 19
64 19
65 19
66 19
<<<sep_out_sample>>>
push   %rbp
xor    %esi,%esi
xor    %eax,%eax
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  9e2 <check_file_permissions+0x12>
cmp    $0xffffffff,%eax
mov    %eax,%ebx
je     a20 <check_file_permissions+0x50>
mov    $0x1,%edx
mov    %rbp,%rdi
mov    %eax,%esi
callq  340 <stat_check>
mov    %ebx,%edi
mov    %eax,%ebp
callq  a01 <check_file_permissions+0x31>
xor    %edx,%edx
test   %ebp,%ebp
je     a11 <check_file_permissions+0x41>
mov    $0x100c,%dx
cmp    $0x16,%ebp
cmovne %ebp,%edx
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  a25 <check_file_permissions+0x55>
mov    (%rax),%eax
xor    %edx,%edx
cmp    $0x2,%eax
cmovne %eax,%edx
add    $0x8,%rsp
pop    %rbx
mov    %edx,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_file_permissions (const char *file)
{
  int fd = -1;
  int err = 0;
  if ((fd = open (file, 00)) == -1)
    return (*__errno_location ()) == 2 ? 0 : (*__errno_location ());
  err = stat_check (file, fd, 1);
  close (fd);
  fd = -1;
  if (err)
    {
      if (err == 22)
 err = (0x1000 +12);
      return err;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 8
16 7
17 8
18 16
19 10
20 10
21 12
22 12
23 12
24 17
25 17
26 17
27 17
28 17
29 17
30 6
31 6
32 6
33 6
34 6
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    $0x1,%ebx
sub    $0x8,%rsp
callq  19f <shpat_to_regex+0x1f>
mov    $0x5e,%edx
xor    %esi,%esi
mov    %r12,%rdi
callq  1ae <shpat_to_regex+0x2e>
movsbl 0x0(%rbp),%edx
test   %dl,%dl
jne    1d9 <shpat_to_regex+0x59>
jmp    220 <shpat_to_regex+0xa0>
nopl   0x0(%rax,%rax,1)
mov    %ebx,%esi
mov    %r12,%rdi
mov    %r13d,%ebx
callq  1cd <shpat_to_regex+0x4d>
add    $0x1,%rbp
movsbl 0x0(%rbp),%edx
test   %dl,%dl
je     220 <shpat_to_regex+0xa0>
cmp    $0x3f,%dl
lea    0x1(%rbx),%r13d
je     240 <shpat_to_regex+0xc0>
cmp    $0x2b,%dl
je     260 <shpat_to_regex+0xe0>
cmp    $0x2a,%dl
jne    1c0 <shpat_to_regex+0x40>
mov    %ebx,%esi
mov    $0x2e,%edx
mov    %r12,%rdi
callq  1fb <shpat_to_regex+0x7b>
add    $0x1,%rbp
mov    $0x2a,%edx
mov    %r13d,%esi
mov    %r12,%rdi
add    $0x2,%ebx
callq  212 <shpat_to_regex+0x92>
movsbl 0x0(%rbp),%edx
test   %dl,%dl
jne    1d9 <shpat_to_regex+0x59>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %ebx,%esi
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x24,%edx
jmpq   239 <shpat_to_regex+0xb9>
nopl   0x0(%rax)
mov    %ebx,%esi
mov    $0x2e,%edx
mov    %r12,%rdi
callq  24f <shpat_to_regex+0xcf>
mov    %r13d,%ebx
jmpq   1cd <shpat_to_regex+0x4d>
nopw   0x0(%rax,%rax,1)
mov    %ebx,%esi
mov    %r12,%rdi
mov    $0x5c,%edx
callq  26f <shpat_to_regex+0xef>
mov    $0x2b,%edx
mov    %r13d,%esi
mov    %r12,%rdi
add    $0x2,%ebx
callq  282 <shpat_to_regex+0x102>
jmpq   1cd <shpat_to_regex+0x4d>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shpat_to_regex(STROB * buf, char * shell_pattern)
{
 char * s;
 int i;
 i = 0;
 strob_strcpy(buf, "");
 s = shell_pattern;
 strob_chr_index(buf, i++, (int)('^'));
 while (*s) {
  if (*s == '?') {
   strob_chr_index(buf, i++, (int)('.'));
  } else if (*s == '+') {
   strob_chr_index(buf, i++, (int)('\\'));
   strob_chr_index(buf, i++, (int)('+'));
  } else if (*s == '*') {
   strob_chr_index(buf, i++, (int)('.'));
   strob_chr_index(buf, i++, (int)('*'));
  } else {
   strob_chr_index(buf, i++, (int)(*s));
  }
  s++;
 }
 strob_chr_index(buf, i++, (int)('$'));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 8
9 2
10 6
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 19
21 19
22 19
23 19
24 21
25 9
26 9
27 9
28 10
29 11
30 10
31 12
32 12
33 15
34 15
35 16
36 16
37 16
38 16
39 21
40 17
41 17
42 17
43 17
44 17
45 9
46 9
47 9
48 9
49 24
50 23
51 23
52 24
53 24
54 24
55 24
56 23
57 23
58 23
59 11
60 11
61 11
62 11
63 11
64 11
65 11
66 13
67 13
68 13
69 13
70 14
71 14
72 14
73 14
74 14
75 14
76 14
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     a00 <rc_set_debug_level+0x50>
cmpb   $0x0,0x1(%rdi)
jne    9e0 <rc_set_debug_level+0x30>
callq  9c4 <rc_set_debug_level+0x14>
movsbl (%rbx),%edx
mov    (%rax),%rax
movsbq %dl,%rcx
testb  $0x8,0x1(%rax,%rcx,2)
je     9e0 <rc_set_debug_level+0x30>
sub    $0x30,%edx
mov    %edx,0x0(%rip)        # 9de <rc_set_debug_level+0x2e>
pop    %rbx
retq   
mov    $0x0,%edi
callq  9ea <rc_set_debug_level+0x3a>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   9f8 <rc_set_debug_level+0x48>
nopl   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # a0a <rc_set_debug_level+0x5a>
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rc_set_debug_level (char *arg)
{
  if (!arg)
    debug_level = 0;
  else if (arg[1] != 0 || !((*__ctype_b_loc ())[(int) ((arg[0]))] & (unsigned short int) _ISdigit))
    {
      mprintf (gettext("Not a valid debugging level: %s"), arg);
      return;
    }
  else
    debug_level = arg[0] - '0';
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 11
14 11
15 12
16 12
17 7
18 7
19 7
20 7
21 7
22 12
23 7
24 7
25 4
26 12
27 12
28 12
<<<sep_out_sample>>>
cmp    $0x9,%dil
sete   %al
cmp    $0x20,%dil
sete   %dl
or     %edx,%eax
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_space (unsigned char c)
{
  return (c == 0x20) || (c == 0x09);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    2c98 <gsl_vector_int_set_basis+0x48>
shl    $0x2,%rdi
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     2c82 <gsl_vector_int_set_basis+0x32>
xchg   %ax,%ax
add    $0x1,%rax
movl   $0x0,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    2c70 <gsl_vector_int_set_basis+0x20>
imul   %rsi,%rdi
xor    %eax,%eax
movl   $0x1,(%r8,%rdi,1)
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2cb5 <gsl_vector_int_set_basis+0x65>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_set_basis (gsl_vector_int * v, size_t i)
{
  int * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const int zero = 0 ;
  const int one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(int *) (data + 1 * k * stride) = zero;
    }
  *(int *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 13
16 13
17 17
18 18
19 17
20 18
21 18
22 2
23 11
24 11
25 11
26 11
27 11
28 11
29 19
30 19
31 19
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
mov    $0xc0800000,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  ddf4 <_sse_bungti_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r14d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  cad0 <_sse_movi_f>
mov    0x0(%rbp),%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
and    $0x7fff,%ecx
callq  2540 <_sse_bungtr_f>
mov    %r14d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  de42 <_sse_bungti_f+0x72>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_bungti_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bungtr_f(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %esi,%esi
jmpq   1557 <afmrealloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%rdi
jmpq   9 <ppd_font_add+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ppd_font_add (struct ppd * ppd, const char * fontname)
{
  string_htable_add (ppd->fonts, fontname);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
jmpq   310 <gsl_blas_dnrm2>
<<<sep_in_sample>>>
gsl_blas_snrm2 (const gsl_vector_float * X)
{
  return cblas_snrm2 (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   5 <__gmpn_sec_mul+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_mul (mp_ptr rp,
      mp_srcptr ap, mp_size_t an,
      mp_srcptr bp, mp_size_t bn,
      mp_ptr tp)
{
  __gmpn_mul_basecase (rp, ap, an, bp, bn);
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 419 <smaprestart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     450 <smaprestart+0x40>
mov    0x0(%rip),%rdx        # 42a <smaprestart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     450 <smaprestart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  320 <smap_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c0 <smap_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  140 <smapensure_buffer_stack>
mov    0x0(%rip),%rbp        # 45c <smaprestart+0x4c>
mov    0x0(%rip),%rax        # 463 <smaprestart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 46f <smaprestart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  479 <smaprestart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    433 <smaprestart+0x23>
jmp    436 <smaprestart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smaprestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        smapensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            smap_create_buffer(smapin,16384 );
 }
 smap_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 smap_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_generic_unimplemented_set_blocksize (void *p_user_data,
                                          uint16_t i_blocksize) {
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_dcolor (j_decompress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x48,%rsp
xor    %eax,%eax
mov    %rdi,%rdx
mov    $0x7,%ecx
mov    %rsp,%rdi
cmp    $0xa,%esi
rep stos %rax,%es:(%rdi)
je     61 <quoting_options_from_style+0x61>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
callq  66 <quoting_options_from_style+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 3
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 5
28 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     c0f <gsl_vector_ulong_isneg+0x3f>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rdi
test   %rdi,%rdi
js     c18 <gsl_vector_ulong_isneg+0x48>
cvtsi2sd %rdi,%xmm0
ucomisd %xmm1,%xmm0
jae    c2f <gsl_vector_ulong_isneg+0x5f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    bf0 <gsl_vector_ulong_isneg+0x20>
mov    $0x1,%eax
retq   
nopl   (%rax)
mov    %rdi,%r8
and    $0x1,%edi
shr    %r8
or     %rdi,%r8
cvtsi2sd %r8,%xmm0
addsd  %xmm0,%xmm0
jmp    bfd <gsl_vector_ulong_isneg+0x2d>
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_isneg (const gsl_vector_ulong * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 11
16 6
17 6
18 6
19 6
20 17
21 18
22 18
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 13
31 13
32 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%esi        # ba <defer_terminit+0xa>
cmp    $0xffffffff,%esi
je     e3 <defer_terminit+0x33>
mov    0x0(%rip),%edx        # c5 <defer_terminit+0x15>
mov    $0x20,%edi
callq  cf <defer_terminit+0x1f>
movl   $0x0,0x0(%rip)        # d9 <defer_terminit+0x29>
movl   $0x0,0x0(%rip)        # e3 <defer_terminit+0x33>
mov    0x0(%rip),%eax        # e9 <defer_terminit+0x39>
mov    0x0(%rip),%edx        # ef <defer_terminit+0x3f>
test   %eax,%eax
jne    f7 <defer_terminit+0x47>
test   %edx,%edx
je     11d <defer_terminit+0x6d>
mov    0x0(%rip),%edi        # fd <defer_terminit+0x4d>
movq   $0x0,(%rsp)
mov    $0x5414,%esi
mov    %ax,0x2(%rsp)
mov    %dx,(%rsp)
xor    %eax,%eax
mov    %rsp,%rdx
callq  11d <defer_terminit+0x6d>
callq  122 <defer_terminit+0x72>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defer_terminit (void)
{
  if (def_tspeed != -1)
    {
      clientstat (32, def_tspeed, def_rspeed);
      def_tspeed = def_rspeed = 0;
    }
  if (def_col || def_row)
    {
      struct winsize ws;
      memset ((char *) &ws, 0, sizeof (ws));
      ws.ws_col = def_col;
      ws.ws_row = def_row;
      rpl_ioctl (pty, 0x5414, (char *) &ws);
    }
  deferslc ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 11
18 14
19 12
20 13
21 14
22 14
23 14
24 16
25 17
26 17
27 17
<<<sep_out_sample>>>
jmpq   65 <alphabetic+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alphabetic (c)
     int c;
{
  return rl_alphabetic (c);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1c4c <gsl_sf_expm1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1c60 <gsl_sf_expm1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x256,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c76 <gsl_sf_expm1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expm1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_expm1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_expm1_e(x, &result)", "exp.c", 598, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rax
mov    0x8(%rdi),%rdx
mov    (%rdx),%rdx
cmp    $0x0,%rax
jle    20 <__gmpz_get_si+0x20>
movabs $0x7fffffffffffffff,%rax
and    %rdx,%rax
retq   
nop
mov    $0x0,%eax
jne    30 <__gmpz_get_si+0x30>
repz retq 
nopl   0x0(%rax)
lea    -0x1(%rdx),%rax
movabs $0x7fffffffffffffff,%rdx
and    %rdx,%rax
not    %rax
retq   
<<<sep_in_sample>>>
__gmpz_get_si (mpz_srcptr z)
{
  mp_ptr zp = ((z)->_mp_d);
  mp_size_t size = ((z)->_mp_size);
  mp_limb_t zl = zp[0];
  if (size > 0)
    return zl & 9223372036854775807L;
  else if (size < 0)
    return -1 - (long) ((zl - 1) & 9223372036854775807L);
  else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 7
7 7
8 7
9 7
10 11
11 8
12 12
13 12
14 9
15 9
16 9
17 9
18 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x18(%rsi),%rbp
cmp    %rbp,%rdi
je     11a0 <find_history+0x40>
mov    %rdx,%r12
mov    %rcx,%r13
jmp    119b <find_history+0x3b>
xchg   %ax,%ax
mov    (%rbx),%rsi
mov    %r13,%rdx
mov    %r12,%rdi
callq  118e <find_history+0x2e>
test   %eax,%eax
je     11b0 <find_history+0x50>
mov    0x18(%rbx),%rbx
cmp    %rbp,%rbx
je     11a0 <find_history+0x40>
test   %rbx,%rbx
jne    1180 <find_history+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
find_history(const filestruct *h_start, const filestruct
 *h_end, const char *s, size_t len)
{
    const filestruct *p;
    for (p = h_start; p != h_end->prev && p != ((void *)0); p = p->prev) {
 if (strncmp(s, p->data, len) == 0)
     return (filestruct *)p;
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 5
23 5
24 5
25 10
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
mov    $0x1,%ecx
jmpq   90 <internal_free>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_free (mem, file, line)
     void * mem;
     const char *file;
     int line;
{
  internal_free (mem, file, line, 0x01);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x20(%rdi),%r13d
mov    0x80(%rdi),%rbx
test   $0x800,%r13d
jne    1d0 <skip_delim+0x40>
and    $0x1000,%r13d
cmp    $0x1,%r13d
adc    $0x0,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
and    $0x1000,%r13d
je     218 <skip_delim+0x88>
mov    0x70(%rdi),%r12
mov    0x28(%rdi),%rdi
movzbl (%r12,%rbx,1),%r14d
movsbl %r14b,%esi
callq  1ef <skip_delim+0x5f>
test   %rax,%rax
je     218 <skip_delim+0x88>
mov    0x78(%rbp),%rax
jmp    206 <skip_delim+0x76>
nopw   0x0(%rax,%rax,1)
cmp    (%r12,%rbx,1),%r14b
jne    20f <skip_delim+0x7f>
add    $0x1,%rbx
cmp    %rax,%rbx
jb     200 <skip_delim+0x70>
sub    $0x1,%rbx
jmp    1b6 <skip_delim+0x26>
nopl   (%rax)
mov    0x78(%rbp),%r12
jmp    236 <skip_delim+0xa6>
xchg   %ax,%ax
mov    0x70(%rbp),%rax
mov    0x28(%rbp),%rdi
movsbl (%rax,%rbx,1),%esi
callq  231 <skip_delim+0xa1>
test   %rax,%rax
je     20f <skip_delim+0x7f>
add    $0x1,%rbx
cmp    %r12,%rbx
jb     220 <skip_delim+0x90>
sub    $0x1,%rbx
jmpq   1b6 <skip_delim+0x26>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skip_delim (struct wordsplit *wsp)
{
  size_t start = wsp->ws_endp;
  if (wsp->ws_flags & 0x00000800)
    {
      if ((wsp->ws_flags & 0x00001000) &&
   (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)))
 {
   int delim = wsp->ws_input[start];
   do
     start++;
   while (start < wsp->ws_len && delim == wsp->ws_input[start]);
 }
      else
 {
   do
     start++;
   while (start < wsp->ws_len && (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)));
 }
      start--;
    }
  if (!(wsp->ws_flags & 0x00001000))
    start++;
  return start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 3
9 4
10 4
11 4
12 23
13 23
14 25
15 25
16 25
17 25
18 25
19 25
20 25
21 25
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 6
30 6
31 6
32 6
33 6
34 12
35 12
36 11
37 12
38 12
39 20
40 20
41 20
42 20
43 20
44 20
45 18
46 18
47 18
48 18
49 18
50 18
51 17
52 18
53 18
54 20
55 20
56 20
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0x7,%sil
jne    294 <openssl_bf_encrypt+0x54>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     289 <openssl_bf_encrypt+0x49>
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x1,%ecx
mov    %r13,%rdx
add    $0x8,%rbp
add    $0x8,%r12
callq  283 <openssl_bf_encrypt+0x43>
sub    $0x8,%rbx
jne    268 <openssl_bf_encrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0xc9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ad <openssl_bf_encrypt+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
openssl_bf_encrypt(const void *ctx, size_t length,
     uint8_t *dst, const uint8_t *src)
{
  ((!(length % 8)) ? (void) (0) : __assert_fail ("!(length % 8)", "nettle-openssl.c", 201, __PRETTY_FUNCTION__));
  while (length)
    {
      BF_ecb_encrypt(src, dst, ctx, 1);
      length -= 8;
      dst += 8;
      src += 8;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0xc,%edi
ja     183 <get_regex_type_context+0x13>
mov    %edi,%edi
shl    $0x4,%rdi
mov    0x0(%rdi),%eax
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_regex_type_context (unsigned int ix)
{
  if (ix < N_REGEX_MAP_ENTRIES)
    return regex_map[ix].context;
  else
    return 0u;
}
<<<sep_in_sample>>>
1 6
2 3
3 3
4 4
5 4
6 4
7 7
8 7
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %edx,%ecx
mov    $0x0,%edx
jmpq   11bf <gen_input_radio+0xf>
nop
<<<sep_in_sample>>>
gen_input_radio(const char *name, const char *value, int checked, const char *title)
{
 return gen_input_with_title_checked(name, value, "radio", checked, title);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
and    $0x7fff,%edx
lea    -0x20(%rsi),%eax
shl    $0x4,%rdx
mov    0x0(%rdx),%edx
and    $0x7fff,%edx
cmp    $0x7,%eax
jbe    9170 <_emit_ldxi_d+0x40>
and    $0x7fff,%esi
shl    $0x4,%rsi
mov    0x0(%rsi),%esi
and    $0x7fff,%esi
jmpq   9230 <_sse_ldxi_d>
nopl   0x0(%rax)
movslq %esi,%rsi
shl    $0x4,%rsi
mov    0x0(%rsi),%esi
and    $0x7fff,%esi
jmpq   9020 <_x87_ldxi_d>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_emit_ldxi_d(jit_state_t *_jit, jit_fpr_t r0, jit_gpr_t r1, jit_word_t i0)
{
    if (((r0) >= _ST0 && (r0) <= _ST7))
 _x87_ldxi_d(_jit, (((_rvs[((r0) & 0x00007fff)].spec) & 0x00007fff)), (((_rvs[((r1) & 0x00007fff)].spec) & 0x00007fff)), i0);
    else
 _sse_ldxi_d(_jit, (((_rvs[((r0) & 0x00007fff)].spec) & 0x00007fff)), (((_rvs[((r1) & 0x00007fff)].spec) & 0x00007fff)), i0);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 3
7 3
8 6
9 6
10 6
11 6
12 6
13 6
14 4
15 4
16 4
17 4
18 4
19 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 287 <rpm_clearenv+0x7>
cmp    0x0(%rip),%rdi        # 28e <rpm_clearenv+0xe>
je     2a0 <rpm_clearenv+0x20>
movq   $0x0,0x0(%rip)        # 29b <rpm_clearenv+0x1b>
xor    %eax,%eax
retq   
xchg   %ax,%ax
test   %rdi,%rdi
je     290 <rpm_clearenv+0x10>
sub    $0x8,%rsp
callq  2ae <rpm_clearenv+0x2e>
movq   $0x0,0x0(%rip)        # 2b9 <rpm_clearenv+0x39>
movq   $0x0,0x0(%rip)        # 2c4 <rpm_clearenv+0x44>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpm_clearenv (void)
{
  ;
  if (environ == last_environ && environ != ((void *)0))
    {
      free (environ);
      last_environ = ((void *)0);
    }
  environ = ((void *)0);
  ;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 9
5 12
6 12
7 12
8 4
9 4
10 2
11 6
12 7
13 9
14 12
15 12
16 12
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbx
mov    0x8(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    3a4 <hash_free_items+0x44>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     394 <hash_free_items+0x34>
cmp    0x0(%rip),%rdi        # 38f <hash_free_items+0x2f>
je     394 <hash_free_items+0x34>
callq  *%r12
movq   $0x0,(%rbx)
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     380 <hash_free_items+0x20>
movq   $0x0,0x18(%r13)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_free_items (struct hash_table_s* ht, hash_map_func_t free_fn)
{
  void **vec = ht->ht_vec;
  void **end = &vec[ht->ht_size];
  for (; vec < end; vec++)
    {
      void *item = *vec;
      if (!((item) == 0 || (void *) (item) == hash_deleted_item))
 (*free_fn) (item);
      *vec = 0;
    }
  ht->ht_fill = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 4
11 5
12 5
13 7
14 8
15 8
16 8
17 8
18 9
19 10
20 5
21 5
22 5
23 12
24 13
25 13
26 13
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    $0x5413,%esi
mov    %edi,%ebx
sub    $0x10,%rsp
mov    %rsp,%rdx
callq  16 <set_winsize+0x16>
test   %eax,%eax
jne    29 <set_winsize+0x29>
mov    %rsp,%rdx
mov    $0x5414,%esi
mov    %ebx,%edi
callq  29 <set_winsize+0x29>
add    $0x10,%rsp
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
set_winsize (tty)
     int tty;
{
  struct winsize w;
  if (ioctl (tty, 0x5413, &w) == 0)
      (void) ioctl (tty, 0x5414, &w);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1127 <put_reserved_word+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  1135 <put_reserved_word+0x15>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1142 <put_reserved_word+0x22>
pop    %rbx
mov    0x0(%rip),%rsi        # 114a <put_reserved_word+0x2a>
mov    $0x0,%edi
jmpq   1154 <put_reserved_word+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_reserved_word(const char *word)
{
 strbuf_puts(outbuf, reserved_begin);
 strbuf_puts(outbuf, word);
 strbuf_puts(outbuf, reserved_end);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 6
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_message_qop (osip_authorization_t * authorization, char *message_qop)
{
  authorization->message_qop = (char *) message_qop;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     490 <gsasl_client_callback_password_get+0x10>
mov    0x40(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_password_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_password : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rdi
xor    %eax,%eax
mov    %rsi,%rdx
mov    $0x0,%esi
callq  36 <print_dir+0x16>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
print_dir(int flag, const char *dir, void *data)
{
 FILE *fp = data;
 fprintf(fp, "%s\n", dir);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
ucomisd 0x0(%rip),%xmm0        # c <__rentier+0xc>
jae    1c <__rentier+0x1c>
movsd  0x0(%rip),%xmm1        # 16 <__rentier+0x16>
ucomisd %xmm0,%xmm1
jbe    32 <__rentier+0x32>
mov    $0x0,%edi
movsd  %xmm0,0x8(%rsp)
callq  2c <__rentier+0x2c>
movsd  0x8(%rsp),%xmm0
cvttsd2si %xmm0,%rax
cvtsi2sd %rax,%xmm1
lea    -0x1(%rax),%rdx
ucomisd %xmm0,%xmm1
cmova  %rdx,%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__rentier (double r)
{
  long j;
  if ((r >= ((double) (~(1L<<63))) + 1.0) ||
      (r < -((double) (~(1L<<63))) + 1.0))
     __rerror ("Entier: Argument out of integer bounds");
  j = r;
  return ((j > r) ? j - 1 : j);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 8
13 8
14 8
15 8
16 9
17 9
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_comment_equal_fn (void *data1,
                           void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # a66 <should_ignore_glob_matches+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
should_ignore_glob_matches ()
{
  return globignore.num_ignores;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     3da <get_version+0xa>
cmpb   $0x0,(%rsi)
jne    3e0 <get_version+0x10>
mov    $0x2,%eax
retq   
jmpq   0 <get_version.part.0>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_version (char const *context, char const *version)
{
  if (version == 0 || *version == 0)
    return numbered_existing_backups;
  else
    return ((backup_types) [__xargmatch_internal (context, version, backup_args, (char const *) (backup_types), sizeof *(backup_types), argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 7
8 7
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   0 <history_search_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_search (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     1154 <fdSetIo+0x24>
cmpl   $0xbeefdead,0x8(%rdi)
jne    1154 <fdSetIo+0x24>
movslq 0xc(%rdi),%rax
lea    (%rax,%rax,2),%rax
mov    %rsi,0x10(%rdi,%rax,8)
add    $0x8,%rsp
retq   
callq  1159 <fdSetIo+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
fdSetIo(FD_t fd, FDIO_t io) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 168, __PRETTY_FUNCTION__));
    fd->fps[fd->nfps].io = io;
    return;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 5
12 5
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%eax
mov    %rcx,%r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
cmove  %rax,%rbx
mov    %rdi,0x18(%rsp)
callq  f80 <quotearg_buffer+0x30>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    0x30(%rbx),%rax
mov    0x4(%rbx),%r9d
mov    0x18(%rsp),%rdi
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
callq  100 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # a43 <pies_acl_install+0x13>
test   %rdi,%rdi
je     a80 <pies_acl_install+0x50>
mov    %rbx,%rsi
callq  a50 <pies_acl_install+0x20>
test   %rax,%rax
je     abf <pies_acl_install+0x8f>
cmp    %rbx,%rax
je     aa8 <pies_acl_install+0x78>
test   %rbp,%rbp
je     ab8 <pies_acl_install+0x88>
mov    0x10(%rax),%rdx
mov    0x8(%rax),%rax
mov    %rdx,0x8(%rbp)
mov    %rax,0x0(%rbp)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
xor    %r8d,%r8d
xor    %esi,%esi
mov    $0x0,%ecx
mov    $0x0,%edx
callq  a94 <pies_acl_install+0x64>
test   %rax,%rax
mov    %rax,0x0(%rip)        # a9e <pies_acl_install+0x6e>
je     abf <pies_acl_install+0x8f>
mov    %rax,%rdi
jmp    a48 <pies_acl_install+0x18>
nopl   (%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
jmp    a74 <pies_acl_install+0x44>
callq  ac4 <pies_acl_install+0x94>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pies_acl_install (pies_acl_t acl, grecs_locus_t * locus)
{
  pies_acl_t ret;
  if (!((acl_table
  || (acl_table = hash_initialize (0, 0,
       acl_hasher,
       acl_compare, 0)))
 && (ret = hash_insert (acl_table, acl))))
    xalloc_die ();
  if (ret != acl)
    {
      if (locus)
 *locus = ret->locus;
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 10
14 10
15 12
16 12
17 13
18 13
19 13
20 13
21 14
22 17
23 17
24 17
25 17
26 17
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 17
39 16
40 17
41 17
42 17
43 17
44 14
45 14
46 9
47 9
<<<sep_out_sample>>>
jmpq   145 <TransformPred+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TransformPred (PANALYSIS panal, PMCPREDOUT pMCPredOut)
{
  OutspecToLinearArray (panal, pMCPredOut);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmp    $0x1,%edi
mov    %edi,0xc(%rsp)
mov    %rsi,(%rsp)
jle    18a0 <cd+0x60>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  1865 <cd+0x25>
cmp    $0x5,%eax
je     1870 <cd+0x30>
add    $0x18,%rsp
retq   
nop
cmpl   $0x1f4,0x0(%rip)        # 187a <cd+0x3a>
jne    186a <cd+0x2a>
mov    0x0(%rip),%eax        # 1882 <cd+0x42>
test   %eax,%eax
jne    18d8 <cd+0x98>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  189a <cd+0x5a>
add    $0x18,%rsp
retq   
nop
lea    0xc(%rsp),%rdi
mov    $0x0,%edx
mov    %rsp,%rsi
callq  18b2 <cd+0x72>
test   %eax,%eax
jne    1851 <cd+0x11>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    (%rax),%rsi
xor    %eax,%eax
callq  18c9 <cd+0x89>
movl   $0xffffffff,0x0(%rip)        # 18d3 <cd+0x93>
jmp    186a <cd+0x2a>
nopl   (%rax)
mov    $0x0,%edi
callq  18e2 <cd+0xa2>
jmp    1886 <cd+0x46>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cd (int argc, char **argv)
{
  if (argc < 2 && !another (&argc, &argv, "remote-directory"))
    {
      printf ("usage: %s remote-directory\n", argv[0]);
      code = -1;
      return;
    }
  if (command ("CWD %s", argv[1]) == 5 && code == 500)
    {
      if (verbose)
 printf ("CWD command not recognized, trying XCWD\n");
      command ("XCWD %s", argv[1]);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 15
14 15
15 15
16 9
17 9
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 15
27 15
28 15
29 3
30 3
31 3
32 3
33 3
34 3
35 5
36 5
37 5
38 5
39 5
40 6
41 7
42 7
43 12
44 12
45 12
46 12
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  81b <_prog_readline+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   83a <_prog_readline+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_prog_readline (mu_stream_t stream, char *optr, size_t osize,
  mu_off_t offset, size_t *pnbytes)
{
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  return mu_stream_readline (fs->in, optr, osize, offset, pnbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%esi
xor    %eax,%eax
mov    $0x20,%ecx
mov    %rsi,%rdi
test   %rdx,%rdx
rep stos %rax,%es:(%rdi)
jne    270d <set_filename_bstab+0x2d>
jmp    2715 <set_filename_bstab+0x35>
nopl   0x0(%rax)
add    $0x1,%rdx
movb   $0x1,0x0(%rax)
je     2715 <set_filename_bstab+0x35>
movsbq (%rdx),%rax
test   %al,%al
jne    2700 <set_filename_bstab+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_filename_bstab (string)
     const char *string;
{
  const char *s;
  memset (filename_bstab, 0, sizeof (filename_bstab));
  for (s = string; s && *s; s++)
    filename_bstab[*s] = 1;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 7
13 6
14 6
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
mov    $0x3a,%edx
jmpq   158a <quotearg_colon_mem+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8 <osip_dialog_set_state+0x8>
mov    %esi,0x58(%rdi)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_dialog_set_state (osip_dialog_t * dialog, state_t state)
{
  if (dialog == ((void *)0))
    return;
  dialog->state = state;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  8ec <gsl_stats_float_wsd+0x1c>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rcx
mov    %r14,%r8
pop    %r13
pop    %r14
jmpq   908 <gsl_stats_float_wsd+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_float_wsd (const float w[], const size_t wstride, const float data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_float_wmean (w, wstride, data, stride, n);
  return gsl_stats_float_wsd_m (w, wstride, data, stride, n, wmean) ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 4
14 4
15 5
16 5
17 5
18 4
19 4
20 5
21 5
22 4
23 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  1ae <werr+0xe>
test   %rax,%rax
mov    %rax,%rbx
jne    1c0 <werr+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %rax,%rdx
mov    %rbp,%rsi
mov    $0x2,%edi
callq  1d0 <werr+0x30>
cmp    %rbx,%rax
je     1b6 <werr+0x16>
mov    0x0(%rip),%rax        # 1dc <werr+0x3c>
mov    (%rax),%rax
mov    0x20(%rax),%edi
callq  1e7 <werr+0x47>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
werr (char const *s)
{
  ssize_t len;
  if (! (len = strlen (s)))
    return;
  if (len != write (2, s, len))
    thank_you_and_goodnight ((top->program-> tyag));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 8
10 8
11 8
12 8
13 8
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
callq  807 <buffer_sample_get+0x17>
mov    $0x200,%edi
mov    %rax,%r12
callq  814 <buffer_sample_get+0x24>
mov    %rax,%r13
jmp    83c <buffer_sample_get+0x4c>
nopl   0x0(%rax)
mov    %al,0x0(%r13,%rbx,1)
mov    %r12,%rsi
mov    %eax,%edi
add    $0x1,%rbx
callq  833 <buffer_sample_get+0x43>
cmp    $0x200,%rbx
je     84a <buffer_sample_get+0x5a>
mov    0x18(%rbp),%rdi
callq  845 <buffer_sample_get+0x55>
cmp    $0xffffffff,%eax
jne    820 <buffer_sample_get+0x30>
mov    %r13,0x0(%rbp)
mov    %rbx,0x8(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
pop    %r13
jmpq   864 <buffer_sample_get+0x74>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_sample_get (buffer_t * buffer, const char *filename)
{
  FILE *out = xwfopen (filename);
  size_t cur = 0;
  int c;
  char *sample_buffer = ((char *) xmalloc (sizeof (char) * (512)));
  for (; (cur < 512) && ((c = (_IO_getc ((buffer)->stream))) != (-1)); cur++)
    {
      sample_buffer[cur] = c;
      _IO_putc (c, out);
    }
  buffer->buf = sample_buffer;
  buffer->bufsize = cur;
  fclose (out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 4
8 2
9 3
10 6
11 3
12 6
13 6
14 6
15 6
16 9
17 10
18 10
19 7
20 10
21 7
22 7
23 7
24 7
25 7
26 7
27 12
28 13
29 15
30 15
31 15
32 14
33 15
34 15
35 14
36 14
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
je     12f <do_update_pointer+0xf>
mov    0x8(%rax),%rax
mov    %rax,(%rdi)
repz retq 
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_update_pointer (__dhp *qp)
{
  if (*qp != 0L)
    *qp = (*qp)->gl;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
test   %rdi,%rdi
je     6a0 <EXTRACTOR_common_unzip_go_to_first_file+0x60>
mov    0x68(%rdi),%rax
lea    0xf8(%rdi),%rdx
lea    0x70(%rdi),%rsi
movq   $0x0,0x40(%rdi)
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
mov    %rax,0x48(%rdi)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
callq  150 <get_current_file_info>
xor    %edx,%edx
test   %eax,%eax
sete   %dl
mov    %rdx,0x50(%rbx)
add    $0x20,%rsp
pop    %rbx
retq   
mov    $0xffffff9a,%eax
jmp    69a <EXTRACTOR_common_unzip_go_to_first_file+0x5a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
EXTRACTOR_common_unzip_go_to_first_file (struct EXTRACTOR_UnzipFile *file)
{
  int err;
  if (((void *)0) == file)
    return (-102);
  file->pos_in_central_dir = file->offset_central_dir;
  file->num_file = 0;
  err = get_current_file_info (file,
          &file->cur_file_info,
          &file->cur_file_info_internal,
          ((void *)0), 0, ((void *)0), 0, ((void *)0), 0);
  file->current_file_ok = ((0) == err);
  return err;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 6
7 8
8 8
9 7
10 8
11 8
12 8
13 6
14 8
15 8
16 8
17 8
18 12
19 12
20 12
21 12
22 14
23 14
24 14
25 5
26 5
27 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x40,%edi
callq  1ab <swi_distdata_create+0xb>
mov    %rax,%rbx
mov    %rax,%rdi
callq  1b6 <swi_distdata_create+0x16>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_distdata_create(void)
{
 SWI_DISTDATA * part1 = (SWI_DISTDATA*)malloc(sizeof(SWI_DISTDATA));
 swi_distdata_initialize(part1);
 return part1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     ce1 <savebuf+0x41>
mov    %rdi,%rbp
mov    %rsi,%rdi
callq  cb9 <savebuf+0x19>
test   %rax,%rax
je     cd8 <savebuf+0x38>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  ccc <savebuf+0x2c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x0(%rip)        # cdf <savebuf+0x3f>
je     cea <savebuf+0x4a>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
callq  cef <savebuf+0x4f>
nop
<<<sep_in_sample>>>
savebuf (char const *s, size_t size)
{
  char *rv;
  if (! size)
    return ((void *)0);
  rv = malloc (size);
  if (! rv)
    {
      if (! using_plan_a)
 xalloc_die ();
    }
  else
    memcpy (rv, s, size);
  return rv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 13
13 13
14 13
15 13
16 15
17 15
18 15
19 15
20 15
21 9
22 9
23 15
24 5
25 15
26 15
27 15
28 10
29 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     6d0 <hashtab_free+0x20>
callq  6be <hashtab_free+0xe>
mov    0x10(%rbx),%rdi
callq  6c7 <hashtab_free+0x17>
mov    %rbx,%rdi
pop    %rbx
jmpq   6d0 <hashtab_free+0x20>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hashtab_free(struct hashtab *st)
{
 if (st) {
  hashtab_clear(st);
  free(st->tab);
  free(st);
 }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 5
7 5
8 6
9 8
10 6
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
mov    %r8,%rdx
push   %rbx
mov    %r8,%rbx
sub    $0x10,%rsp
callq  b13 <gsl_stats_float_covariance+0x23>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
movsd  %xmm0,0x8(%rsp)
callq  b27 <gsl_stats_float_covariance+0x37>
movsd  0x8(%rsp),%xmm2
add    $0x10,%rsp
mov    %rbx,%r8
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdi
mov    %r14,%rsi
pop    %r13
pop    %r14
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
jmpq   b55 <gsl_stats_float_covariance+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_float_covariance (const float data1[], const size_t stride1,
                                const float data2[], const size_t stride2,
                                const size_t n)
{
  const double mean1 = gsl_stats_float_mean (data1, stride1, n);
  const double mean2 = gsl_stats_float_mean (data2, stride2, n);
  return gsl_stats_float_covariance_m(data1, stride1,
                                          data2, stride2,
                                          n,
                                          mean1, mean2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 5
14 6
15 6
16 6
17 5
18 6
19 7
20 11
21 7
22 7
23 7
24 11
25 11
26 11
27 7
28 7
29 11
30 11
31 6
32 7
33 7
34 7
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdx,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%rbp
mov    0x10(%rsi),%r15
mov    %rdi,(%rsp)
mov    (%rsi),%r12
cmp    %rbp,%r15
je     1759 <gsl_matrix_long_fprintf+0x99>
lea    0x0(,%r15,8),%rax
xor    %r13d,%r13d
xor    %r15d,%r15d
test   %r12,%r12
mov    %rax,0x8(%rsp)
jne    1716 <gsl_matrix_long_fprintf+0x56>
jmp    1748 <gsl_matrix_long_fprintf+0x88>
nopw   0x0(%rax,%rax,1)
add    $0x1,%r15
add    0x8(%rsp),%r13
cmp    %r12,%r15
je     1748 <gsl_matrix_long_fprintf+0x88>
mov    %r13,%rsi
add    0x18(%rbx),%rsi
mov    (%rsp),%rdi
mov    %r14,%r8
mov    $0x1,%ecx
mov    %rbp,%rdx
callq  1731 <gsl_matrix_long_fprintf+0x71>
test   %eax,%eax
je     1708 <gsl_matrix_long_fprintf+0x48>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
mov    (%rsp),%rdi
add    $0x18,%rsp
pop    %rbx
pop    %rbp
mov    %r15,%rdx
mov    %r14,%r8
mov    $0x1,%ecx
imul   %r12,%rdx
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   1783 <gsl_matrix_long_fprintf+0xc3>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_fprintf (FILE * stream, const gsl_matrix_long * m,
                                const char *format)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_raw_fprintf (stream,
                                                  m->data,
                                                  size1 * size2, 1,
                                                  format);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_raw_fprintf (stream,
                                                      m->data + i * 1 * tda,
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 7
12 3
13 5
14 8
15 8
16 8
17 18
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 20
29 20
30 20
31 20
32 20
33 20
34 20
35 24
36 24
37 29
38 29
39 29
40 29
41 29
42 29
43 29
44 29
45 29
46 29
47 18
48 29
49 29
50 29
51 29
52 29
53 29
54 29
55 10
56 10
57 29
58 29
59 29
60 10
61 10
62 10
63 10
64 29
65 29
66 29
67 29
68 10
69 10
<<<sep_out_sample>>>
push   %rbp
movapd %xmm0,%xmm1
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
movsd  %xmm1,0x8(%rsp)
callq  588 <gsl_sf_bessel_Kn_e+0x18>
movsd  0x8(%rsp),%xmm1
mov    %eax,%ebp
movsd  0x0(%rip),%xmm0        # 598 <gsl_sf_bessel_Kn_e+0x28>
xorpd  %xmm1,%xmm0
callq  5a1 <gsl_sf_bessel_Kn_e+0x31>
movsd  (%rbx),%xmm2
mov    %ebp,%eax
movsd  0x8(%rsp),%xmm1
mulsd  %xmm0,%xmm2
mulsd  0x0(%rip),%xmm1        # 5b9 <gsl_sf_bessel_Kn_e+0x49>
movsd  0x0(%rip),%xmm3        # 5c1 <gsl_sf_bessel_Kn_e+0x51>
mulsd  0x8(%rbx),%xmm0
movsd  %xmm2,(%rbx)
andpd  %xmm3,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_bessel_Kn_e(const int n, const double x, gsl_sf_result * result)
{
  const int status = gsl_sf_bessel_Kn_scaled_e(n, x, result);
  const double ex = exp(-x);
  result->val *= ex;
  result->err *= ex;
  result->err += x * 2.2204460492503131e-16 * fabs(result->val);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 3
10 4
11 4
12 4
13 5
14 9
15 7
16 5
17 7
18 7
19 6
20 5
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5e7 <il_end_of_line+0x7>
mov    0x38(%rax),%rdx
movl   $0x6,0x10(%rax)
mov    %rdx,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_end_of_line()
{
    il->point = il->length;
    il->last_operation = 6;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 4
6 4
<<<sep_out_sample>>>
movzbl (%rdx),%r9d
test   %r8,%r8
mov    %r9d,%r10d
je     164d <gsl_stats_char_minmax+0x2d>
xor    %r11d,%r11d
nop
movzbl (%rdx),%eax
cmp    %al,%r9b
cmovg  %eax,%r9d
cmp    %al,%r10b
cmovl  %eax,%r10d
add    $0x1,%r11
add    %rcx,%rdx
cmp    %r8,%r11
jne    1630 <gsl_stats_char_minmax+0x10>
mov    %r9b,(%rdi)
mov    %r10b,(%rsi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_char_minmax (char * min_out, char * max_out,
                             const char data[], const size_t stride,
                             const size_t n)
{
  char min = data[0 * stride];
  char max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      char xi = data[i * stride];
      if (xi < min)
        min = xi;
      if (xi > max)
        max = xi;
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 8
3 6
4 8
5 8
6 8
7 10
8 10
9 10
10 10
11 10
12 8
13 8
14 8
15 8
16 16
17 17
18 17
19 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x80(%rdi)
je     390 <_ping_setbuf+0x50>
cmpq   $0x0,0x78(%rbx)
je     368 <_ping_setbuf+0x28>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
movslq 0x70(%rbx),%rbp
mov    %rbp,%rdi
callq  374 <_ping_setbuf+0x34>
test   %rax,%rax
mov    %rax,0x78(%rbx)
je     3b2 <_ping_setbuf+0x72>
mov    %rbp,%rdx
xor    %esi,%esi
mov    %rax,%rdi
callq  38a <_ping_setbuf+0x4a>
jmp    35a <_ping_setbuf+0x1a>
nopl   0x0(%rax)
mov    0x50(%rdi),%rax
test   %sil,%sil
lea    0x8(%rax),%rdi
jne    3a1 <_ping_setbuf+0x61>
lea    0x50(%rax),%rdi
callq  3a6 <_ping_setbuf+0x66>
test   %rax,%rax
mov    %rax,0x80(%rbx)
jne    353 <_ping_setbuf+0x13>
mov    $0xffffffff,%eax
jmp    35c <_ping_setbuf+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_ping_setbuf (PING * p, _Bool use_ipv6)
{
  if (!p->ping_buffer)
    {
      p->ping_buffer = malloc (((use_ipv6)? ((p)->ping_datalen + sizeof (struct icmp6_hdr)) : (60 + (p)->ping_datalen + (8 + 3 * sizeof (n_time)))));
      if (!p->ping_buffer)
 return -1;
    }
  if (!p->ping_cktab)
    {
      p->ping_cktab = malloc (p->ping_cktab_size);
      if (!p->ping_cktab)
 return -1;
      memset (p->ping_cktab, 0, p->ping_cktab_size);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 9
8 9
9 16
10 17
11 17
12 17
13 17
14 17
15 11
16 11
17 11
18 12
19 11
20 12
21 14
22 14
23 14
24 14
25 14
26 14
27 5
28 5
29 5
30 5
31 5
32 5
33 6
34 5
35 6
36 7
37 7
38 7
<<<sep_out_sample>>>
mov    0x68(%rdi),%rax
mov    0x14(%rax),%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_get_tarheader_flags(XFORMAT * xux)
{
 return xux->taruM->taru_tarheaderflagsM;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 1518 <gsl_sf_legendre_deriv_array+0x8>
jmpq   151d <gsl_sf_legendre_deriv_array+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_sf_legendre_deriv_array
(const gsl_sf_legendre_t norm, const size_t lmax, const double x,
 double result_array[], double result_deriv_array[])
{
  int s = gsl_sf_legendre_deriv_array_e(norm, lmax, x, 1.0, result_array, result_deriv_array);
  return s;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  c69 <sh_openpipe+0x9>
test   %eax,%eax
js     c97 <sh_openpipe+0x37>
mov    (%rbx),%edi
mov    $0x40,%edx
mov    $0x1,%esi
callq  c7e <sh_openpipe+0x1e>
mov    0x4(%rbx),%edi
mov    %eax,(%rbx)
mov    $0x40,%edx
mov    $0x1,%esi
callq  c92 <sh_openpipe+0x32>
mov    %eax,0x4(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_openpipe (pv)
     int *pv;
{
  int r;
  if ((r = pipe (pv)) < 0)
    return r;
  pv[0] = move_to_high_fd (pv[0], 1, 64);
  pv[1] = move_to_high_fd (pv[1], 1, 64);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 9
17 10
18 10
19 10
<<<sep_out_sample>>>
test   %edi,%edi
push   %rbx
jne    650 <sh_ttyerror+0x30>
callq  62a <sh_ttyerror+0xa>
mov    (%rax),%edi
callq  631 <sh_ttyerror+0x11>
mov    $0x0,%edi
mov    %rax,%rbx
callq  63e <sh_ttyerror+0x1e>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   64c <sh_ttyerror+0x2c>
nopl   0x0(%rax)
callq  655 <sh_ttyerror+0x35>
mov    (%rax),%edi
callq  65c <sh_ttyerror+0x3c>
mov    $0x0,%edi
mov    %rax,%rbx
jmp    639 <sh_ttyerror+0x19>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_ttyerror (set)
     int set;
{
  if (set)
    builtin_error (gettext("error setting terminal attributes: %s"), strerror ((*__errno_location ())));
  else
    builtin_error (gettext("error getting terminal attributes: %s"), strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 7
15 7
16 5
17 5
18 5
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movzbl (%rdi),%eax
test   %al,%al
je     1cc <xvasprintf+0x7c>
cmp    $0x25,%al
jne    1a0 <xvasprintf+0x50>
cmpb   $0x73,0x1(%rdi)
jne    1a0 <xvasprintf+0x50>
mov    %rdi,%r9
xor    %r8d,%r8d
jmp    17b <xvasprintf+0x2b>
nopl   (%rax)
cmp    $0x25,%cl
jne    1a0 <xvasprintf+0x50>
cmpb   $0x73,0x1(%rax)
jne    1a0 <xvasprintf+0x50>
lea    0x2(%r9),%rax
movzbl (%rax),%ecx
add    $0x1,%r8
mov    %rax,%r9
test   %cl,%cl
jne    170 <xvasprintf+0x20>
mov    %r8,%rdi
callq  0 <xstrcat>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rsi,%rdx
mov    %rdi,%rsi
lea    0x8(%rsp),%rdi
callq  1b0 <xvasprintf+0x60>
mov    %eax,%edx
mov    0x8(%rsp),%rax
test   %edx,%edx
jns    195 <xvasprintf+0x45>
callq  1c0 <xvasprintf+0x70>
cmpl   $0xc,(%rax)
je     1d1 <xvasprintf+0x81>
xor    %eax,%eax
add    $0x18,%rsp
retq   
xor    %r8d,%r8d
jmp    18d <xvasprintf+0x3d>
callq  1d6 <xvasprintf+0x86>
<<<sep_in_sample>>>
xvasprintf (const char *format, va_list args)
{
  char *result;
  {
    size_t argcount = 0;
    const char *f;
    for (f = format;;)
      {
 if (*f == '\0')
   return xstrcat (argcount, args);
 if (*f != '%')
   break;
 f++;
 if (*f != 's')
   break;
 f++;
 argcount++;
      }
  }
  if (vasprintf (&result, format, args) < 0)
    {
      if ((*__errno_location ()) == 12)
 xalloc_die ();
      return ((void *)0);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 9
3 9
4 9
5 11
6 11
7 14
8 14
9 14
10 5
11 5
12 5
13 11
14 11
15 14
16 14
17 14
18 9
19 17
20 17
21 9
22 9
23 10
24 10
25 27
26 27
27 27
28 20
29 20
30 20
31 20
32 20
33 26
34 20
35 20
36 22
37 22
38 22
39 24
40 27
41 27
42 5
43 5
44 23
<<<sep_out_sample>>>
push   %r12
xor    %r12d,%r12d
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rdi)
cmpq   $0x0,(%rdi)
mulsd  0x0(%rip),%xmm0        # bc1 <gsl_integration_qawo_table_set+0x21>
movsd  %xmm1,0x10(%rdi)
mov    %esi,0x20(%rdi)
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # bd5 <gsl_integration_qawo_table_set+0x35>
movsd  %xmm0,0x18(%rdi)
jne    be5 <gsl_integration_qawo_table_set+0x45>
jmp    c19 <gsl_integration_qawo_table_set+0x79>
xchg   %ax,%ax
movsd  0x18(%rbx),%xmm0
mov    %r12,%rdi
mulsd  %xmm1,%xmm0
add    0x28(%rbx),%rdi
movsd  %xmm1,0x8(%rsp)
add    $0x1,%rbp
add    $0xc8,%r12
callq  1f0 <compute_moments>
cmp    %rbp,(%rbx)
movsd  0x8(%rsp),%xmm1
mulsd  0x0(%rip),%xmm1        # c17 <gsl_integration_qawo_table_set+0x77>
ja     be0 <gsl_integration_qawo_table_set+0x40>
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_integration_qawo_table_set (gsl_integration_qawo_table * t,
                                    double omega, double L,
                                    enum gsl_integration_qawo_enum sine)
{
  t->omega = omega;
  t->sine = sine;
  t->L = L;
  t->par = 0.5 * omega * L;
  {
    size_t i;
    double scale = 1.0;
    for (i = 0 ; i < t->n; i++)
      {
        compute_moments (t->par * scale, t->chebmo + 25*i);
        scale *= 0.5;
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 12
3 4
4 12
5 4
6 4
7 4
8 5
9 12
10 8
11 7
12 6
13 8
14 11
15 8
16 12
17 12
18 12
19 12
20 14
21 14
22 14
23 14
24 12
25 12
26 14
27 12
28 15
29 15
30 12
31 19
32 19
33 19
34 19
35 19
36 19
37 19
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # bc7 <il_just_one_space+0x7>
mov    0x58(%rax),%rdx
mov    0x18(%rax),%rax
cmpb   $0x20,(%rdx,%rax,1)
je     be0 <il_just_one_space+0x20>
retq   
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
xor    %eax,%eax
callq  beb <il_just_one_space+0x2b>
mov    $0x20,%edi
callq  bf5 <il_just_one_space+0x35>
mov    0x0(%rip),%rax        # bfc <il_just_one_space+0x3c>
movl   $0x10,0x10(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_just_one_space()
{
    if (il->buffer[il->point] == ' ')
    {
 il_delete_horizontal_space();
 il_insert_char(' ');
 il->last_operation = 16;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 9
7 9
8 2
9 5
10 5
11 6
12 6
13 7
14 7
15 9
16 9
17 9
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%rdi
mov    %rdx,%rsi
shr    %rsi
je     887 <gsl_vector_reverse+0x57>
lea    -0x8(,%rdx,8),%rdx
mov    %rdi,%r8
xor    %ecx,%ecx
neg    %r8
imul   %rdi,%rdx
shl    $0x3,%r8
shl    $0x3,%rdi
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
movsd  (%rdx),%xmm0
add    $0x1,%rcx
movsd  (%rax),%xmm1
movsd  %xmm1,(%rdx)
add    %r8,%rdx
movsd  %xmm0,(%rax)
add    %rdi,%rax
cmp    %rsi,%rcx
jne    868 <gsl_vector_reverse+0x38>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_reverse (gsl_vector * v)
{
  double * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          double tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 8
18 15
19 15
20 15
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%ecx
test   %ecx,%ecx
jne    bd <grecs_tree_join+0x1d>
mov    (%rsi),%edx
mov    %rsi,%rbp
test   %edx,%edx
je     c8 <grecs_tree_join+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x30(%rsi),%rsi
mov    $0x1,%edx
callq  d6 <grecs_tree_join+0x36>
mov    0x30(%rbp),%rdi
test   %rdi,%rdi
mov    %rdi,%rax
je     f5 <grecs_tree_join+0x55>
nopw   0x0(%rax,%rax,1)
mov    %rbx,0x28(%rax)
mov    0x38(%rax),%rax
test   %rax,%rax
jne    e8 <grecs_tree_join+0x48>
cmpq   $0x0,0x70(%rbp)
je     130 <grecs_tree_join+0x90>
mov    0x70(%rbx),%rdx
mov    $0x0,%esi
callq  10a <grecs_tree_join+0x6a>
mov    0x70(%rbp),%rdi
callq  113 <grecs_tree_join+0x73>
movq   $0x0,0x70(%rbp)
movq   $0x0,0x30(%rbp)
add    $0x8,%rsp
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
movq   $0x0,0x70(%rbx)
jmp    113 <grecs_tree_join+0x73>
<<<sep_in_sample>>>
grecs_tree_join(struct grecs_node *dst, struct grecs_node *src)
{
 struct grecs_node *p;
 if (dst->type != grecs_node_root || src->type != grecs_node_root)
  return 1;
 grecs_node_bind(dst, src->down, 1);
 for (p = src->down; p; p = p->next)
  p->up = dst;
 if (!src->v.texttab) {
  dst->v.texttab = src->v.texttab;
 } else {
  grecs_tree_recurse(src->down, reset_locus, dst->v.texttab);
  grecs_symtab_free(src->v.texttab);
 }
 src->v.texttab = ((void *)0);
 src->down = ((void *)0);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 18
14 18
15 18
16 18
17 18
18 6
19 6
20 6
21 7
22 7
23 7
24 7
25 7
26 8
27 7
28 7
29 7
30 9
31 9
32 12
33 12
34 12
35 13
36 13
37 15
38 16
39 18
40 18
41 17
42 18
43 18
44 18
45 10
46 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  5d <etar_close+0xd>
mov    %rbx,%rdi
pop    %rbx
jmpq   66 <etar_close+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
etar_close (ETAR * etar)
{
 free(etar->tar_hdrM);
 free(etar);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %r14
mov    0x0(%rip),%edx        # 498 <sig_number+0x8>
push   %r13
mov    %rdi,%r13
test   %edx,%edx
push   %r12
push   %rbp
push   %rbx
je     520 <sig_number+0x90>
cmpb   $0x53,0x0(%r13)
je     536 <sig_number+0xa6>
test   %edx,%edx
mov    $0xffffffff,%eax
jle    506 <sig_number+0x76>
lea    -0x1(%rdx),%r12d
movzbl 0x0(%r13),%ebp
xor    %ebx,%ebx
add    $0x1,%r12
jmp    4d9 <sig_number+0x49>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     510 <sig_number+0x80>
mov    %rbx,%rax
movslq %ebx,%r14
shl    $0x4,%rax
mov    0x0(%rax),%rsi
cmp    %bpl,(%rsi)
jne    4d0 <sig_number+0x40>
mov    %r13,%rdi
callq  4f7 <sig_number+0x67>
test   %eax,%eax
jne    4d0 <sig_number+0x40>
shl    $0x4,%r14
mov    0x0(%r14),%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffff,%eax
pop    %r14
retq   
xchg   %ax,%ax
callq  525 <sig_number+0x95>
cmpb   $0x53,0x0(%r13)
mov    0x0(%rip),%edx        # 530 <sig_number+0xa0>
jne    4b0 <sig_number+0x20>
cmpb   $0x49,0x1(%r13)
jne    4b0 <sig_number+0x20>
cmpb   $0x47,0x2(%r13)
lea    0x3(%r13),%rax
cmove  %rax,%r13
jmpq   4b0 <sig_number+0x20>
<<<sep_in_sample>>>
sig_number (abbrev)
     const char *abbrev;
{
  int i;
  if (sig_table_nelts == 0)
    signame_init ();
  if (abbrev[0] == 'S' && abbrev[1] == 'I' && abbrev[2] == 'G')
    abbrev += 3;
  for (i = 0; i < sig_table_nelts; i++)
    if (abbrev[0] == sig_table[i].abbrev[0]
 && strcmp (abbrev, sig_table[i].abbrev) == 0)
      return sig_table[i].number;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 3
8 3
9 5
10 7
11 7
12 9
13 13
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 12
35 12
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 13
48 14
49 14
50 14
51 6
52 7
53 7
54 7
55 7
56 7
57 8
58 8
59 8
60 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x70(%rdi),%rdi
callq  a55 <swpath_form_storage_path+0x15>
mov    %rbx,%rdi
mov    $0xc8,%edx
mov    %rax,%rsi
callq  a65 <swpath_form_storage_path+0x25>
mov    %rbp,%rdi
mov    %rbx,%rsi
callq  490 <swpath__form_path1.constprop.15>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   a7e <swpath_form_storage_path+0x3e>
xchg   %ax,%ax
<<<sep_in_sample>>>
swpath_form_storage_path(SWPATH * swpath, STROB * buf)
{
 strob_strncpy(buf, strob_str(swpath->prepath_), 200);
 swpath__form_path1(swpath, buf, ((void *)0));
 return strob_str(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 6
16 5
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
mov    0x10(%r9),%rax
mov    0x40(%rsp),%r12
test   %rax,%rax
je     8f0 <gsl_multifit_nlinear_eval_fvv+0x50>
mov    0x28(%r9),%rdx
mov    %r12,%rcx
callq  *%rax
addq   $0x1,0x40(%rbx)
mov    %eax,%r13d
test   %rbp,%rbp
je     8df <gsl_multifit_nlinear_eval_fvv+0x3f>
mov    %rbp,%rsi
mov    %r12,%rdi
callq  8df <gsl_multifit_nlinear_eval_fvv+0x3f>
add    $0x18,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    0x48(%rsp),%rax
mov    %r12,(%rsp)
mov    %rax,0x8(%rsp)
callq  903 <gsl_multifit_nlinear_eval_fvv+0x63>
mov    %eax,%r13d
jmp    8cf <gsl_multifit_nlinear_eval_fvv+0x2f>
<<<sep_in_sample>>>
gsl_multifit_nlinear_eval_fvv(const double h,
                              const gsl_vector *x,
                              const gsl_vector *v,
                              const gsl_vector *f,
                              const gsl_matrix *J,
                              const gsl_vector *swts,
                              gsl_multifit_nlinear_fdf *fdf,
                              gsl_vector *yvv, gsl_vector *work)
{
  int status;
  if (fdf->fvv != ((void *)0))
    {
      status = ((*((fdf)->fvv)) (x, v, fdf->params, yvv));
      ++(fdf->nevalfvv);
    }
  else
    {
      status = gsl_multifit_nlinear_fdfvv(h, x, v, f, J,
                                          swts, fdf, yvv, work);
    }
  if (swts)
    gsl_vector_mul(yvv, swts);
  return status;
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 11
9 9
10 11
11 11
12 13
13 13
14 13
15 14
16 13
17 21
18 21
19 22
20 22
21 22
22 24
23 24
24 24
25 24
26 24
27 24
28 24
29 24
30 18
31 18
32 18
33 18
34 18
35 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
cmp    $0x3,%edi
mov    (%rsi),%rcx
je     148 <op_wc_strchr_ci+0x38>
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x4,%edi
xor    %eax,%eax
callq  134 <op_wc_strchr_ci+0x24>
mov    $0x1,%edx
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rdi
callq  20 <strtowc>
mov    0x10(%rbx),%rdi
mov    %rax,%rbp
callq  20 <strtowc>
mov    (%rax),%esi
mov    %rbp,%rdi
callq  167 <op_wc_strchr_ci+0x57>
test   %rax,%rax
mov    $0x2,%edx
je     139 <op_wc_strchr_ci+0x29>
sub    %rbp,%rax
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
sar    $0x2,%rsi
callq  187 <op_wc_strchr_ci+0x77>
add    $0x8,%rsp
xor    %edx,%edx
pop    %rbx
mov    %edx,%eax
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
op_wc_strchr_ci(int argc, char **argv)
{
    unsigned *wa, *wb;
    const unsigned *p;
    char *opname = *argv++;
    argc--;
    if (argc != 2) {
 dico_log(4, 0, "%s requires two arguments", opname);
 return 1;
    }
    wa = strtowc(argv[0]);
    wb = strtowc(argv[1]);
    p = utf8_wc_strchr_ci(wa, wb[0]);
    if (!p)
 return 2;
    printf("%td\n", p - wa);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 5
7 7
8 8
9 8
10 8
11 8
12 8
13 9
14 18
15 18
16 18
17 18
18 18
19 18
20 11
21 11
22 12
23 11
24 12
25 13
26 13
27 13
28 14
29 15
30 14
31 16
32 16
33 16
34 16
35 16
36 16
37 18
38 17
39 18
40 18
41 18
42 18
43 18
<<<sep_out_sample>>>
mov    $0x1,%edi
jmpq   3e9a <info_tile_windows+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_tile_windows (WINDOW *window, int count)
{
  window_tile_windows (1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%rdx
test   %rax,%rax
je     17d <gsl_combination_init_last+0x2d>
mov    %rdx,%rsi
mov    0x10(%rdi),%rcx
sub    %rax,%rsi
mov    %rsi,%rax
neg    %rsi
lea    (%rcx,%rsi,8),%rcx
mov    %rax,(%rcx,%rax,8)
add    $0x1,%rax
cmp    %rdx,%rax
jne    170 <gsl_combination_init_last+0x20>
repz retq 
nop
<<<sep_in_sample>>>
gsl_combination_init_last (gsl_combination * c)
{
  const size_t k = c->k ;
  size_t i;
  size_t n = c->n;
  for (i = 0; i < k; i++)
    {
      c->data[i] = n - k + i;
    }
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 8
12 8
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
jmpq   5 <c_strstr+0x5>
<<<sep_in_sample>>>
c_strstr (const char *haystack, const char *needle)
{
  return strstr (haystack, needle);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  24b <_stdout_file_write+0x1b>
mov    0x8(%rsp),%r8
mov    0x8(%rax),%rcx
add    $0x10,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   130 <_file_write>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_stdout_file_write (mu_stream_t stream, const char *iptr, size_t isize,
      mu_off_t offset, size_t *nbytes)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  return _file_write (stream, iptr, isize, fs->offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     66 <cdio_log+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  210 <cdio_logv>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
cdio_log(cdio_log_level_t level, const char format[], ...)
{
  va_list args;
  __builtin_va_start(args,format);
  cdio_logv (level, format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 7
25 7
26 7
<<<sep_out_sample>>>
test   $0x2,%dil
je     70 <wsnode_flagstr+0x70>
movb   $0x77,0x0(%rip)        # d <wsnode_flagstr+0xd>
mov    %edi,%eax
movb   $0x0,0x0(%rip)        # 16 <wsnode_flagstr+0x16>
and    $0x4,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbc,%eax
add    $0x71,%eax
mov    %al,0x0(%rip)        # 2a <wsnode_flagstr+0x2a>
mov    %edi,%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffe8,%eax
add    $0x45,%eax
mov    %al,0x0(%rip)        # 40 <wsnode_flagstr+0x40>
mov    %edi,%eax
and    $0x10,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0x20,%edi
and    $0xffffffc3,%eax
add    $0x6a,%eax
cmp    $0x1,%edi
mov    %al,0x0(%rip)        # 5c <wsnode_flagstr+0x5c>
sbb    %eax,%eax
and    $0xffffffba,%eax
add    $0x73,%eax
mov    %al,0x0(%rip)        # 6a <wsnode_flagstr+0x6a>
mov    $0x0,%eax
retq   
mov    %edi,%eax
and    $0x1,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbf,%eax
add    $0x6e,%eax
mov    %al,0x0(%rip)        # 86 <wsnode_flagstr+0x86>
jmp    d <wsnode_flagstr+0xd>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_flagstr (int flags)
{
  static char retbuf[6];
  char *p = retbuf;
  if (flags & 0x02)
    *p++ = 'w';
  else if (flags & 0x01)
    *p++ = 'n';
  else
    *p++ = '-';
  if (flags & 0x04)
    *p++ = 'q';
  else
    *p++ = '-';
  if (flags & 0x08)
    *p++ = 'E';
  else
    *p++ = '-';
  if (flags & 0x10)
    *p++ = 'j';
  else
    *p++ = '-';
  if (flags & 0x20)
    *p++ = 's';
  else
    *p++ = '-';
  *p = 0;
  return retbuf;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 11
5 27
6 11
7 12
8 12
9 12
10 12
11 12
12 15
13 15
14 16
15 16
16 16
17 16
18 16
19 19
20 19
21 20
22 20
23 23
24 20
25 20
26 24
27 20
28 24
29 24
30 24
31 24
32 29
33 29
34 7
35 7
36 8
37 8
38 8
39 8
40 8
41 8
42 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # ae <mu_get_canned_container+0xe>
callq  b3 <mu_get_canned_container+0x13>
test   %rax,%rax
je     c0 <mu_get_canned_container+0x20>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
xor    %eax,%eax
jmp    bb <mu_get_canned_container+0x1b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_get_canned_container (const char *name)
{
  struct mu_cfg_cont **pcont = mu_assoc_ref (section_tab, name);
  return pcont ? *pcont : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 4
11 4
12 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     860 <dicod_get_database_info+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    0x50(%rdi),%rdx
mov    0x10(%rdx),%rdx
mov    0x30(%rdx),%rdx
test   %rdx,%rdx
je     859 <dicod_get_database_info+0x9>
mov    0x40(%rdi),%rdi
jmpq   *%rdx
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_get_database_info(dicod_database_t *db)
{
    if (db->info)
 return db->info;
    else {
 dicod_module_instance_t *inst = db->instance;
 if (inst->module->dico_db_info)
     return inst->module->dico_db_info(db->mod_handle);
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 11
5 11
6 7
7 7
8 7
9 7
10 7
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
movsd  0x0(%rbp),%xmm0
lea    0x20(%rsp),%rsi
lea    0x28(%rsp),%rdi
callq  c00 <DISWorldCoordinatesToGeocentric+0x20>
movsd  0x28(%rsp),%xmm3
movsd  0x0(%rip),%xmm1        # c0e <DISWorldCoordinatesToGeocentric+0x2e>
movsd  0x0(%rip),%xmm0        # c16 <DISWorldCoordinatesToGeocentric+0x36>
mulsd  %xmm3,%xmm1
movsd  0x20(%rsp),%xmm5
mulsd  %xmm3,%xmm1
subsd  %xmm1,%xmm0
sqrtsd %xmm0,%xmm2
ucomisd %xmm2,%xmm2
jp     cd2 <DISWorldCoordinatesToGeocentric+0xf2>
movsd  0x0(%rip),%xmm1        # c3e <DISWorldCoordinatesToGeocentric+0x5e>
lea    0x20(%rsp),%rsi
lea    0x28(%rsp),%rdi
movsd  0x10(%rbp),%xmm4
divsd  %xmm2,%xmm1
movsd  %xmm3,0x18(%rsp)
movapd %xmm4,%xmm2
movsd  %xmm4,0x10(%rsp)
movsd  0x8(%rbp),%xmm0
addsd  %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
mulsd  %xmm5,%xmm2
movsd  %xmm2,(%rsp)
callq  c7e <DISWorldCoordinatesToGeocentric+0x9e>
movsd  0x8(%rsp),%xmm1
movsd  0x28(%rsp),%xmm0
movsd  (%rsp),%xmm2
mulsd  0x0(%rip),%xmm1        # c97 <DISWorldCoordinatesToGeocentric+0xb7>
mulsd  %xmm2,%xmm0
movsd  0x20(%rsp),%xmm5
movsd  0x10(%rsp),%xmm4
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x8(%rbx)
mulsd  %xmm2,%xmm5
movapd %xmm1,%xmm0
addsd  %xmm4,%xmm0
movsd  %xmm5,(%rbx)
mulsd  %xmm3,%xmm0
movsd  %xmm0,0x10(%rbx)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
movsd  %xmm5,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  ce2 <DISWorldCoordinatesToGeocentric+0x102>
movsd  0x8(%rsp),%xmm5
movapd %xmm0,%xmm2
movsd  (%rsp),%xmm3
jmpq   c36 <DISWorldCoordinatesToGeocentric+0x56>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
DISWorldCoordinatesToGeocentric(WorldCoordinates * w,
        dis_world_coordinates * p)
{
 double N, N1;
 double cos_latitude, sin_latitude;
 sin_latitude = sin(w->latitude);
 cos_latitude = cos(w->latitude);
 N = 6378137.0 / sqrt(1.0 - (0.006694380004260806515 * sin_latitude * sin_latitude));
 N1 = N + w->z;
 p->x = N1 * cos_latitude * cos(w->longitude);
 p->y = N1 * cos_latitude * sin(w->longitude);
 p->z = (((6356752.3142 * 6356752.3142) / (6378137.0 * 6378137.0)) * N + w->z) * sin_latitude;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 9
24 8
25 8
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 12
35 12
36 10
37 12
38 11
39 10
40 12
41 12
42 11
43 10
44 12
45 12
46 10
47 12
48 12
49 13
50 13
51 13
52 13
53 13
54 13
55 8
56 8
57 8
58 8
59 8
60 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  89 <_rl_with_macro_input+0x9>
mov    %rbx,0x0(%rip)        # 90 <_rl_with_macro_input+0x10>
movl   $0x0,0x0(%rip)        # 9a <_rl_with_macro_input+0x1a>
orq    $0x800,0x0(%rip)        # a5 <_rl_with_macro_input+0x25>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_with_macro_input (string)
     char *string;
{
  _rl_push_executing_macro ();
  rl_executing_macro = string;
  executing_macro_index = 0;
  (rl_readline_state |= (0x0000800));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rcx        # 4648 <subunitroot+0x18>
mov    (%rsi),%rax
mov    %edi,0xc(%rsp)
mov    %rdx,(%rsp)
cmp    (%rcx),%rax
jne    4750 <subunitroot+0x120>
nopl   0x0(%rax)
add    $0x8,%r13
mov    0x0(%r13),%r14
cmp    %rax,%r14
je     4660 <subunitroot+0x30>
xor    %ebx,%ebx
test   %r14,%r14
je     470d <subunitroot+0xdd>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 4687 <subunitroot+0x57>
mov    %r14,%rsi
mov    %r13,%rbp
mov    (%rax),%r12
cmp    %rsi,%r12
je     46a4 <subunitroot+0x74>
mov    %r14,%rdi
callq  469d <subunitroot+0x6d>
test   %eax,%eax
jne    46b1 <subunitroot+0x81>
add    $0x1,%ebx
add    $0x8,%rbp
mov    0x0(%rbp),%rsi
test   %rsi,%rsi
jne    4690 <subunitroot+0x60>
mov    %ebx,%eax
cltd   
idivl  0xc(%rsp)
test   %edx,%edx
mov    %eax,%r12d
jne    4730 <subunitroot+0x100>
test   %eax,%eax
mov    %eax,%ebx
jle    46fd <subunitroot+0xcd>
mov    (%rsp),%r15
jmp    46d4 <subunitroot+0xa4>
nopl   0x0(%rax,%rax,1)
mov    0x0(%r13),%r14
mov    %r14,%rdi
add    $0x8,%r15
callq  46e0 <subunitroot+0xb0>
sub    $0x1,%ebx
mov    %rax,-0x8(%r15)
jne    46d0 <subunitroot+0xa0>
mov    (%rsp),%rax
sub    $0x1,%r12d
movslq %r12d,%r12
lea    0x8(%rax,%r12,8),%rax
mov    %rax,(%rsp)
mov    0x0(%rbp),%r14
mov    %rbp,%r13
test   %r14,%r14
jne    4680 <subunitroot+0x50>
mov    (%rsp),%rax
movq   $0x0,(%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    %r14,%rdi
callq  4738 <subunitroot+0x108>
test   %eax,%eax
jne    46fd <subunitroot+0xcd>
add    $0x18,%rsp
mov    $0x6,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %rax,%r14
jmpq   466d <subunitroot+0x3d>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
subunitroot(int n,char *current[], char *out[])
{
  char **ptr;
  int count=0;
  while(*current==NULLUNIT) current++;
  ptr=current;
  while(*ptr){
    while(*ptr){
      if (*ptr!=NULLUNIT){
        if (strcmp(*current,*ptr)) break;
        count++;
      }
      ptr++;
    }
    if (count % n != 0){
      if (!ignore_dimless(*current))
        return 6;
    } else {
      for(count /= n;count>0;count--) *(out++) = dupstr(*current);
    }
    current=ptr;
  }
  *out = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 2
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 19
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 13
36 8
37 8
38 8
39 15
40 15
41 15
42 15
43 15
44 15
45 19
46 19
47 19
48 19
49 19
50 19
51 19
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 19
60 19
61 19
62 19
63 19
64 19
65 7
66 7
67 23
68 23
69 25
70 24
71 25
72 25
73 25
74 25
75 25
76 25
77 25
78 25
79 16
80 16
81 16
82 16
83 25
84 17
85 25
86 25
87 25
88 25
89 25
90 25
91 25
92 5
93 5
94 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x48(%rdi),%rdi
test   %rdi,%rdi
je     3ba <nist_snd_1xx+0x1a>
callq  3ba <nist_snd_1xx+0x1a>
mov    0x8(%rbp),%rsi
mov    %rbx,%rdi
mov    %rsi,0x48(%rbx)
callq  3ca <nist_snd_1xx+0x2a>
test   %eax,%eax
jne    3f8 <nist_snd_1xx+0x58>
mov    0x48(%rbx),%rdx
mov    %rbx,%rsi
mov    $0x32,%edi
callq  3df <nist_snd_1xx+0x3f>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    $0x11,%esi
pop    %rbx
pop    %rbp
jmpq   3f2 <nist_snd_1xx+0x52>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
pop    %rbp
jmpq   0 <nist_handle_transport_error>
<<<sep_in_sample>>>
nist_snd_1xx (osip_transaction_t * nist, osip_event_t * evt)
{
  int i;
  if (nist->last_response != ((void *)0)) {
    osip_message_free (nist->last_response);
  }
  nist->last_response = evt->sip;
  i = __osip_transaction_snd_xxx (nist, nist->last_response);
  if (i != 0) {
    nist_handle_transport_error (nist, i);
    return;
  }
  else
    __osip_message_callback (OSIP_NIST_STATUS_1XX_SENT, nist, nist->last_response);
  __osip_transaction_set_state (nist, NIST_PROCEEDING);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 7
11 8
12 7
13 8
14 9
15 9
16 14
17 14
18 14
19 14
20 16
21 15
22 15
23 16
24 16
25 15
26 15
27 16
28 10
29 10
30 16
31 16
32 10
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     56 <__gmp_fscanf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  92 <__gmp_fscanf+0x92>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_fscanf (FILE *fp, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doscan (&__gmp_fscanf_funs, fp, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 6
18 2
19 6
20 6
21 5
22 5
23 5
24 5
25 5
26 6
27 9
28 9
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%esi
push   %r14
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x98,%rsp
lea    0x10(%rsp),%rbx
movq   $0x0,(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
lea    0x3(%rbx),%rax
mov    %rax,0x8(%rsp)
mov    0x8(%rsp),%rdi
movl   $0x726964,(%rbx)
callq  852 <is_dir_name+0x52>
mov    %rbx,%rsi
mov    %rbp,%rdi
mov    %rax,%r12
callq  860 <is_dir_name+0x60>
test   %eax,%eax
je     8c1 <is_dir_name+0xc1>
mov    %r12,%rax
lea    0x50(%rsp),%rcx
mov    $0x0,%r14d
sub    %rbx,%rax
mov    $0x0,%r15d
lea    0x1(%rax),%r13
lea    (%rcx,%rax,1),%r12
jmp    895 <is_dir_name+0x95>
nopl   (%rax)
add    $0x10,%r14
mov    -0x10(%r14),%r15
test   %r15,%r15
je     8f0 <is_dir_name+0xf0>
lea    0x50(%rsp),%rdi
mov    %r13,%rdx
mov    %rbx,%rsi
callq  8a5 <is_dir_name+0xa5>
mov    %r15,%rsi
mov    %r12,%rdi
callq  8b0 <is_dir_name+0xb0>
lea    0x50(%rsp),%rsi
mov    %rbp,%rdi
callq  8bd <is_dir_name+0xbd>
test   %eax,%eax
jne    888 <is_dir_name+0x88>
mov    $0x1,%eax
mov    0x88(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    90a <is_dir_name+0x10a>
add    $0x98,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
addq   $0x8,(%rsp)
mov    (%rsp),%rax
mov    -0x8(%rax),%rsi
test   %rsi,%rsi
jne    842 <is_dir_name+0x42>
xor    %eax,%eax
jmp    8c6 <is_dir_name+0xc6>
callq  90f <is_dir_name+0x10f>
<<<sep_in_sample>>>
is_dir_name (char *filename)
{
  unsigned i;
  for (i = 0; info_suffixes[i]; i++)
    {
      unsigned c;
      char trydir[50];
      strcpy (trydir, "dir");
      strcat (trydir, info_suffixes[i]);
      if (mbscasecmp (filename, trydir) == 0)
        return 1;
      for (c = 0; compress_suffixes[c].suffix; c++)
        {
          char dir_compressed[50];
          strcpy (dir_compressed, trydir);
          strcat (dir_compressed, compress_suffixes[c].suffix);
          if (mbscasecmp (filename, dir_compressed) == 0)
            return 1;
        }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 9
16 9
17 9
18 8
19 9
20 10
21 10
22 9
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 15
40 15
41 15
42 15
43 16
44 16
45 16
46 17
47 17
48 17
49 17
50 17
51 11
52 22
53 22
54 22
55 22
56 22
57 22
58 22
59 22
60 22
61 22
62 22
63 22
64 22
65 4
66 4
67 4
68 4
69 21
70 21
71 22
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 49eb <us_az_hdy+0xb>
movl   $0x3,0x0(%rip)        # 49f5 <us_az_hdy+0x15>
jmpq   49fa <us_az_hdy+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
us_az_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_AZ";
  observe_us_hdy = 3;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 10
2 11
3 12
4 12
<<<sep_out_sample>>>
mov    0x10(%rdi),%r9
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
movzbl (%r9),%ecx
test   %r10,%r10
mov    %ecx,%edi
je     186b <gsl_vector_char_minmax+0x3b>
xor    %r8d,%r8d
nopl   0x0(%rax)
movzbl (%r9),%eax
cmp    %al,%dil
cmovg  %eax,%edi
cmp    %al,%cl
cmovl  %eax,%ecx
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
jne    1850 <gsl_vector_char_minmax+0x20>
mov    %dil,(%rsi)
mov    %cl,(%rdx)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_char_minmax (const gsl_vector_char * v,
                             char * min_out,
                             char * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  char max = v->data[0 * stride];
  char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 7
2 5
3 6
4 7
5 10
6 8
7 10
8 10
9 10
10 12
11 12
12 12
13 12
14 12
15 10
16 10
17 10
18 10
19 22
20 23
21 23
22 23
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_version (osip_authorization_t * authorization)
{
  return authorization->version;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
test   %edi,%edi
je     9f3 <_rl_vi_motion_command+0x23>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  9e6 <_rl_vi_motion_command+0x16>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_motion_command (c)
     int c;
{
  return (((c) ? (char *)strchr ((vi_motion), (c)) != (char *)((void *)0) : 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 4
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x3,0x0(%rip)        # 72b <newForm+0xb>
je     828 <newForm+0x108>
mov    0x0(%rip),%eax        # 737 <newForm+0x17>
movabs $0x4620656c706d6153,%rdx
movl   $0x0,0x0(%rip)        # 74b <newForm+0x2b>
movl   $0x0,0x0(%rip)        # 755 <newForm+0x35>
movl   $0x0,0x0(%rip)        # 75f <newForm+0x3f>
movabs $0x6f46656c706d6153,%rcx
movl   $0x1,0x0(%rip)        # 773 <newForm+0x53>
sub    $0x11,%eax
mov    %eax,0x0(%rip)        # 77c <newForm+0x5c>
mov    0x0(%rip),%eax        # 782 <newForm+0x62>
sub    $0x5,%eax
mov    %eax,0x0(%rip)        # 78b <newForm+0x6b>
mov    0x0(%rip),%rax        # 792 <newForm+0x72>
mov    %rdx,(%rax)
movl   $0x6d726f,0x8(%rax)
mov    $0x676f,%edx
mov    0x0(%rip),%rax        # 7a8 <newForm+0x88>
mov    %rcx,(%rax)
mov    %dx,0xc(%rax)
movl   $0x662e6d72,0x8(%rax)
movb   $0x0,0xe(%rax)
xor    %eax,%eax
movl   $0x1,0x0(%rip)        # 7c6 <newForm+0xa6>
movl   $0x0,0x0(%rip)        # 7d0 <newForm+0xb0>
movl   $0x0,0x0(%rip)        # 7da <newForm+0xba>
movl   $0x0,0x0(%rip)        # 7e4 <newForm+0xc4>
movl   $0x0,0x0(%rip)        # 7ee <newForm+0xce>
movl   $0x0,0x0(%rip)        # 7f8 <newForm+0xd8>
movl   $0x0,0x0(%rip)        # 802 <newForm+0xe2>
movl   $0x0,0x0(%rip)        # 80c <newForm+0xec>
callq  811 <newForm+0xf1>
xor    %eax,%eax
callq  818 <newForm+0xf8>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   823 <newForm+0x103>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
callq  82f <newForm+0x10f>
test   %eax,%eax
jne    731 <newForm+0x11>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
newForm()
{
  if(FILE_STATE == MODIFIED)
  {
    if(!saveForm()) return;
  }
  selected_tool = 0;
  adding_tool = 0;
  selected_form_tool = 0;
  activeWindow = 1;
  FORM_WIDTH = SCREEN_W-17;
  FORM_HEIGHT = SCREEN_H-5;
  strcpy(FORM_TITLE, "Sample Form");
  strcpy(form_file_name, "SampleForm.fog");
  NEW_FILE = 1;
  FILE_STATE = NEW;
  total_form_tools = 0;
  int i;
  for(i = 0; i < 5; i++)
    tool_count[i] = 0;
  drawForm();
  drawToolBox();
  drawStatusBar();
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 11
5 13
6 7
7 8
8 9
9 14
10 10
11 11
12 11
13 12
14 12
15 12
16 13
17 13
18 13
19 14
20 14
21 14
22 14
23 14
24 14
25 21
26 15
27 16
28 17
29 20
30 20
31 20
32 20
33 20
34 21
35 22
36 22
37 23
38 25
39 23
40 23
41 5
42 5
43 5
44 5
45 25
46 25
47 25
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # f57 <xtrace_init+0x7>
mov    $0xffffffff,%edi
xor    %eax,%eax
jmpq   f63 <xtrace_init+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xtrace_init ()
{
  xtrace_set (-1, stderr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x30,%rsp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
je     7c0 <gsl_permute_matrix_complex_float+0x40>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7b0 <gsl_permute_matrix_complex_float+0x30>
add    $0x30,%rsp
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
xor    %ebx,%ebx
cmpq   $0x0,(%rsi)
je     7f3 <gsl_permute_matrix_complex_float+0x73>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  7de <gsl_permute_matrix_complex_float+0x5e>
mov    %rsp,%rsi
mov    %r12,%rdi
add    $0x1,%rbx
callq  7ed <gsl_permute_matrix_complex_float+0x6d>
cmp    %rbx,0x0(%rbp)
ja     7d0 <gsl_permute_matrix_complex_float+0x50>
add    $0x30,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_permute_matrix_complex_float (const gsl_permutation * p, gsl_matrix_complex_float * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_complex_float_view r = gsl_matrix_complex_float_row (A, i);
          gsl_permute_vector_complex_float (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 17
16 5
17 17
18 17
19 17
20 17
21 17
22 10
23 10
24 10
25 10
26 12
27 12
28 12
29 12
30 13
31 13
32 10
33 13
34 10
35 10
36 17
37 15
38 17
39 17
40 17
41 17
42 17
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   32d <close_warn+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
close_warn (char const *name)
{
  call_arg_warn ("close", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movl   $0x1,(%rdi)
movl   $0x43524943,0x4(%rdi)
movb   $0x0,0x8(%rdi)
movsd  %xmm2,0x8(%rsp)
callq  11c0 <pict_newpoint>
movsd  0x8(%rsp),%xmm2
mov    %rax,0x18(%rbx)
movsd  %xmm2,0x80(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
pict_circle(pict *p, double cx, double cy, double r)
{
  p->pict_npts = 1;
  strcpy(p->pict_type, "CIRC");
  p->pict_pt = pict_newpoint(cx, cy);
  p->pict_r = r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 4
7 2
8 5
9 6
10 5
11 6
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 257 <write_2_bytes+0x7>
push   %rbx
mov    %edi,%ebx
movzbl %bh,%edi
callq  262 <write_2_bytes+0x12>
movzbl %bl,%edi
mov    0x0(%rip),%rsi        # 26c <write_2_bytes+0x1c>
pop    %rbx
jmpq   272 <write_2_bytes+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_2_bytes (unsigned int val)
{
  _IO_putc (((val >> 8) & 0xFF), outfile);
  _IO_putc ((val & 0xFF), outfile);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
mov    0x0(%rip),%rsi        # 4c <GetKeywordCode+0xc>
push   %rbp
push   %rbx
cmpb   $0x0,(%rsi)
je     8c <GetKeywordCode+0x4c>
mov    %rdi,%rbp
mov    $0x0,%ebx
jmp    6c <GetKeywordCode+0x2c>
nopl   (%rax)
add    $0x10,%rbx
mov    (%rbx),%rsi
cmpb   $0x0,(%rsi)
je     78 <GetKeywordCode+0x38>
mov    %rbp,%rdi
callq  74 <GetKeywordCode+0x34>
test   %eax,%eax
jne    60 <GetKeywordCode+0x20>
test   %r12,%r12
je     84 <GetKeywordCode+0x44>
mov    0xc(%rbx),%eax
mov    %eax,(%r12)
mov    0x8(%rbx),%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x0,%ebx
jmp    78 <GetKeywordCode+0x38>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetKeywordCode (PSTR szKeyword, PINT pfContext)
{
  PKM pkm = &vrgkmKeywordMap[0];
  while (*pkm->szKeyword && MyStrcmp (szKeyword, pkm->szKeyword))
    pkm++;
  if (pfContext)
    *pfContext = pkm->fContext;
  return (pkm->iKWCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 4
8 4
9 3
10 3
11 3
12 5
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 7
23 7
24 8
25 9
26 9
27 9
28 9
29 3
30 3
31 3
<<<sep_out_sample>>>
mov    %esi,%edx
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     16c <programming_error+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
xor    %esi,%esi
mov    0x0(%rip),%edi        # 177 <programming_error+0x67>
callq  17c <programming_error+0x6c>
lea    0xe0(%rsp),%rax
mov    0x0(%rip),%rdi        # 18b <programming_error+0x7b>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  1b7 <programming_error+0xa7>
mov    0x0(%rip),%rsi        # 1be <programming_error+0xae>
mov    $0xa,%edi
callq  1c8 <programming_error+0xb8>
mov    0x0(%rip),%eax        # 1ce <programming_error+0xbe>
test   %eax,%eax
jne    1fe <programming_error+0xee>
mov    $0x0,%edi
callq  1dc <programming_error+0xcc>
mov    0x0(%rip),%rdi        # 1e3 <programming_error+0xd3>
mov    %rax,%rsi
xor    %eax,%eax
callq  1ed <programming_error+0xdd>
mov    0x0(%rip),%rdi        # 1f4 <programming_error+0xe4>
callq  1f9 <programming_error+0xe9>
callq  1fe <programming_error+0xee>
callq  203 <programming_error+0xf3>
mov    $0x0,%ebx
test   %rax,%rax
mov    $0x0,%edi
cmovne %rax,%rbx
callq  219 <programming_error+0x109>
mov    0x0(%rip),%rdi        # 220 <programming_error+0x110>
mov    %rax,%rsi
mov    %rbx,%rdx
xor    %eax,%eax
callq  22d <programming_error+0x11d>
jmp    1d2 <programming_error+0xc2>
nop
<<<sep_in_sample>>>
programming_error (const char *format, ...)
{
  va_list args;
  char *h;
  give_terminal_to (shell_pgrp, 0);
  __builtin_va_start(args,format);
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  __builtin_va_end(args);
  if (remember_on_history)
    {
      h = last_history_line ();
      fprintf (stderr, gettext("last command: %s\n"), h ? h : "(null)");
    }
  fprintf (stderr, gettext("Aborting..."));
  fflush (stderr);
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 5
21 5
22 6
23 7
24 7
25 7
26 6
27 6
28 6
29 6
30 6
31 7
32 8
33 8
34 8
35 10
36 10
37 10
38 15
39 15
40 15
41 15
42 15
43 15
44 16
45 16
46 17
47 12
48 13
49 13
50 13
51 13
52 13
53 13
54 13
55 13
56 13
57 13
58 13
59 13
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_process_context_token (OM_uint32 * minor_status,
      const gss_ctx_id_t context_handle,
      const gss_buffer_t token_buffer)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5209 <_jit_indirect+0x9>
orl    $0x8,0xc(%rax)
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_indirect(jit_state_t *_jit)
{
    jit_node_t *node;
    node = _jit_label(_jit);
    node->flag |= 0x00000008;
    return (node);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 7
5 7
6 7
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     b2 <seen_file+0x32>
sub    $0x28,%rsp
mov    0x8(%rdx),%rax
mov    %rsi,(%rsp)
mov    %rsp,%rsi
mov    %rax,0x8(%rsp)
mov    (%rdx),%rax
mov    %rax,0x10(%rsp)
callq  a8 <seen_file+0x28>
test   %rax,%rax
setne  %al
add    $0x28,%rsp
repz retq 
<<<sep_in_sample>>>
seen_file (Hash_table const *ht, char const *file,
           struct stat const *stats)
{
  struct F_triple new_ent;
  if (ht == ((void *)0))
    return 0;
  new_ent.name = (char *) file;
  new_ent.st_ino = stats->st_ino;
  new_ent.st_dev = stats->st_dev;
  return !!hash_lookup (ht, &new_ent);
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 3
5 8
6 7
7 10
8 8
9 9
10 9
11 10
12 10
13 10
14 11
15 11
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rdx,%rbp
mov    $0xa,%edx
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
test   %rsi,%rsi
lea    0x8(%rsp),%rax
cmove  %rax,%rbx
mov    %rbx,%rsi
callq  51c <swlib_atoi2+0x2c>
test   %rbp,%rbp
mov    %rax,%r13
je     52b <swlib_atoi2+0x3b>
movl   $0x0,0x0(%rbp)
cmp    %r12,(%rbx)
je     560 <swlib_atoi2+0x70>
movabs $0x7fffffffffffffff,%rax
add    %r13,%rax
cmp    $0xfffffffffffffffd,%rax
jbe    54d <swlib_atoi2+0x5d>
callq  548 <swlib_atoi2+0x58>
cmpl   $0x22,(%rax)
je     565 <swlib_atoi2+0x75>
add    $0x18,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
test   %r13,%r13
jne    530 <swlib_atoi2+0x40>
test   %rbp,%rbp
je     571 <swlib_atoi2+0x81>
movl   $0x1,0x0(%rbp)
callq  576 <swlib_atoi2+0x86>
mov    0x0(%rip),%rdi        # 57d <swlib_atoi2+0x8d>
mov    %r12,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  58f <swlib_atoi2+0x9f>
add    $0x18,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
<<<sep_in_sample>>>
swlib_atoi2(const char *nptr, char ** fp_endptr, int * result)
{
 long ret;
 char * endptr;
 char ** a_endptr;
 if (fp_endptr)
  a_endptr = fp_endptr;
 else
  a_endptr = &endptr;
 ret = strtol(nptr, a_endptr, 10);
 if (result) *result = 0;
 if (
  (*a_endptr == nptr && ret == 0) ||
  ((ret == (-9223372036854775807L - 1L) || ret == 9223372036854775807L) && (*__errno_location ()) == 34)
 ) {
  if (result) {
   *result = 1;
  }
  fprintf(stderr, "%s: strtol error when converting [%s]\n", swlib_utilname_get(), nptr);
 }
 return (int)ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 10
7 2
8 2
9 2
10 9
11 9
12 9
13 10
14 10
15 11
16 10
17 11
18 11
19 12
20 12
21 14
22 14
23 13
24 13
25 14
26 14
27 14
28 22
29 22
30 22
31 22
32 22
33 22
34 22
35 22
36 13
37 13
38 16
39 16
40 17
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 22
49 22
50 22
51 22
52 22
53 22
54 22
55 22
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 856 <grecs_grecs_get_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_get_debug (void)
{
        return grecs_grecs__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x48(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_targetname (osip_authentication_info_t *
       authentication_info)
{
  return authentication_info->targetname;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     a1 <printer_free+0x11>
callq  a1 <printer_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     af <printer_free+0x1f>
callq  af <printer_free+0x1f>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     c0 <printer_free+0x30>
pop    %rbx
jmpq   be <printer_free+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_free (struct printer * printer)
{
  do { if (printer->key) free (printer->key); } while (0);
  do { if (printer->ppdkey) free (printer->ppdkey); } while (0);
  do { if (printer->command) free (printer->command); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 5
16 5
17 6
18 6
19 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    $0x2800,%esi
mov    (%rdi),%rdi
mov    %rdx,%rcx
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bench_cipher(void *arg)
{
  struct bench_cipher_info *info = arg;
  info->crypt(info->ctx, 10240, info->data, info->data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  ad <sig_exit+0xd>
mov    $0x1,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  bc <sig_exit+0x1c>
mov    %ebx,%edi
callq  c3 <sig_exit+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sig_exit (int code)
{
  info (1, gettext("Signal Caught. Exiting Cleanly..."));
  quit (code);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
mov    %edx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%r13d        # f8e <put_anchor_force+0x1e>
callq  f93 <put_anchor_force+0x23>
mov    %r12d,%edx
mov    %rbp,%rsi
mov    $0x0,%edi
callq  fa3 <put_anchor_force+0x33>
mov    $0x0,%edi
movl   $0x0,0x0(%rip)        # fb2 <put_anchor_force+0x42>
callq  fb7 <put_anchor_force+0x47>
mov    %ebx,%edx
mov    $0x52,%esi
mov    %rax,%rdi
callq  fc6 <put_anchor_force+0x56>
mov    %r13d,0x0(%rip)        # fcd <put_anchor_force+0x5d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_anchor_force(char *name, int length, int lineno)
{
 static STRBUF sb[1];
 int saveflag = wflag;
 strbuf_clear(sb);
 strbuf_nputs(sb, name, length);
 wflag = 0;
 put_anchor(strbuf_value(sb), 'R', lineno);
 wflag = saveflag;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 2
8 2
9 2
10 4
11 5
12 6
13 6
14 6
15 6
16 8
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 10
25 10
26 10
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
push   %r14
mov    %edx,%r14d
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  16 <echo_text+0x16>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  21 <echo_text+0x21>
lea    0x5(%rbx,%rax,1),%r13
mov    %r13,%rdi
callq  2e <echo_text+0x2e>
mov    %rbp,%rcx
mov    %rax,%rdi
mov    %rax,%rbx
mov    %r12,%rdx
xor    %eax,%eax
mov    %r13,%rsi
callq  44 <echo_text+0x44>
test   %r14b,%r14b
je     57 <echo_text+0x57>
mov    %eax,%eax
movl   $0xa262620,(%rbx,%rax,1)
movb   $0x0,0x4(%rbx,%rax,1)
mov    %rbx,%rdx
mov    0x0(%rip),%rdi        # 61 <echo_text+0x61>
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
xor    %eax,%eax
jmpq   75 <echo_text+0x75>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_text (const char* format_pz, const char* arg_pz, _Bool cascade)
{
  static char const continue_z[] = " &&\n";
  size_t sz = strlen (format_pz) + strlen (arg_pz) + sizeof (continue_z);
  char * bf = scribble_get (sz);
  unsigned int len = (unsigned)snprintf (bf, sz, format_pz, arg_pz);
  if (cascade)
    memcpy (bf + len, continue_z, sizeof (continue_z));
  fprintf (output, echo_string_z, bf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 5
19 6
20 6
21 6
22 6
23 7
24 7
25 8
26 8
27 8
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 9
37 9
38 9
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_diagonal (gsl_matrix_int * m)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_int v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_diagonal (gsl_matrix_uint * m)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_uint v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1820 <gsl_permute_vector_ushort+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1815 <gsl_permute_vector_ushort+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1831 <gsl_permute_vector_ushort+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_ushort (const gsl_permutation * p, gsl_vector_ushort * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_ushort (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_int_size (const gsl_block_int * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movslq 0x868(%rdi),%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
mov    0x0(%rax),%rax
test   %rax,%rax
je     288 <doWeaponUpdate+0x28>
jmpq   *%rax
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
doWeaponUpdate(craft * c)
{
 if (wtbl[c->curWeapon].update != ((void *)0))
  return (*wtbl[c->curWeapon].update) (c);
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdi
movsd  0x0(%rip),%xmm0        # 1f <init_diag_levenberg+0xf>
callq  24 <init_diag_levenberg+0x14>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_diag_levenberg(const gsl_matrix * JTJ, gsl_vector * diag)
{
  (void)JTJ;
  gsl_vector_set_all(diag, 1.0);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     470 <gsl_permute_vector_complex+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  465 <gsl_permute_vector_complex+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  481 <gsl_permute_vector_complex+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_complex (const gsl_permutation * p, gsl_vector_complex * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  f <timer_compare+0xf>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
timer_compare(void const *data1, void const *data2)
{
    const struct timer_slot *t1 = data1;
    const struct timer_slot *t2 = data2;
    return strcasecmp(t1->name, t2->name) == 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
jmp    403 <all_digits+0x13>
nopw   0x0(%rax,%rax,1)
sub    $0x30,%eax
cmp    $0x9,%al
ja     410 <all_digits+0x20>
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
jne    3f8 <all_digits+0x8>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
all_digits (string)
     char *string;
{
  register char *s;
  for (s = string; *s; s++)
    if (((*s) >= '0' && (*s) <= '9') == 0)
      return (0);
  return (1);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 5
7 5
8 5
9 5
10 8
11 8
12 7
13 9
14 9
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x30(%rdi)
mov    %rdi,%rbx
je     1280 <window_adjust_pagetop+0x50>
callq  1240 <window_adjust_pagetop+0x10>
mov    0x38(%rbx),%rcx
movslq %eax,%rsi
mov    0x18(%rbx),%rdx
cmp    %rcx,%rsi
jge    1278 <window_adjust_pagetop+0x48>
sub    $0x1,%rdx
mov    %rbx,%rdi
xor    %esi,%esi
mov    %rdx,%rcx
shr    $0x3f,%rcx
add    %rcx,%rdx
pop    %rbx
sar    %rdx
sub    %edx,%eax
cmovns %eax,%esi
jmpq   1271 <window_adjust_pagetop+0x41>
nopl   0x0(%rax)
sub    %rcx,%rsi
cmp    %rsi,%rdx
jle    1250 <window_adjust_pagetop+0x20>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
window_adjust_pagetop (WINDOW *window)
{
  register int line;
  if (!window->node)
    return;
  line = window_line_of_point (window);
  if (line < window->pagetop
      || line - window->pagetop > window->height - 1)
    {
      int new_pagetop = line - ((window->height - 1) / 2);
      if (new_pagetop < 0)
        new_pagetop = 0;
      set_window_pagetop (window, new_pagetop);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 6
6 7
7 7
8 7
9 7
10 7
11 10
12 13
13 13
14 10
15 10
16 10
17 15
18 10
19 10
20 10
21 13
22 13
23 8
24 8
25 8
26 15
27 15
28 15
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%rbx
mov    %rdx,0x30(%rcx)
mov    %rcx,%rdx
callq  3d70 <gsl_eigen_francis_Z+0x10>
movq   $0x0,0x30(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_eigen_francis_Z (gsl_matrix * H, gsl_vector_complex * eval,
                     gsl_matrix * Z, gsl_eigen_francis_workspace * w)
{
  int s;
  w->Z = Z;
  s = gsl_eigen_francis(H, eval, w);
  w->Z = ((void *)0);
  return s;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 9
8 9
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdx,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %rdx,%rdx
je     be0 <gsl_block_complex_raw_fscanf+0xa0>
shl    $0x4,%rcx
mov    %rdi,%r13
lea    0x10(%rsi),%rbp
mov    %rcx,%r15
xor    %r12d,%r12d
jmp    b85 <gsl_block_complex_raw_fscanf+0x45>
nopl   (%rax)
add    $0x8,%rbx
cmp    %rbx,%rbp
jne    b89 <gsl_block_complex_raw_fscanf+0x49>
add    $0x1,%r12
add    %r15,%rbp
cmp    %r14,%r12
je     be0 <gsl_block_complex_raw_fscanf+0xa0>
lea    -0x10(%rbp),%rbx
lea    0x8(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  b9d <gsl_block_complex_raw_fscanf+0x5d>
movsd  0x8(%rsp),%xmm0
cmp    $0x1,%eax
movsd  %xmm0,(%rbx)
je     b70 <gsl_block_complex_raw_fscanf+0x30>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bc5 <gsl_block_complex_raw_fscanf+0x85>
add    $0x18,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_raw_fscanf (FILE * stream,
                                  double * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 2; k++)
        {
          double tmp;
          int status = fscanf (stream, "%lg", &tmp) ;
          data [2 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 7
22 7
23 7
24 7
25 5
26 13
27 13
28 13
29 13
30 13
31 14
32 15
33 14
34 15
35 17
36 17
37 17
38 17
39 17
40 22
41 17
42 22
43 22
44 22
45 22
46 22
47 22
48 22
49 22
50 22
51 21
52 22
53 22
54 22
55 22
56 22
57 22
58 22
59 22
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
mov    %rbp,%rsi
push   %rbx
mov    (%rdi),%rdi
mov    %rdx,%rbx
callq  67 <des_compat_des3_encrypt+0x17>
mov    0x8(%r12),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  7a <des_compat_des3_encrypt+0x2a>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    0x10(%r12),%rdi
pop    %r12
jmpq   91 <des_compat_des3_encrypt+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
des_compat_des3_encrypt(struct des_compat_des3 *ctx,
   uint32_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_des_encrypt(ctx->keys[0], length, dst, src);
  nettle_des_decrypt(ctx->keys[1], length, dst, dst);
  nettle_des_encrypt(ctx->keys[2], length, dst, dst);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 6
21 7
22 6
23 6
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    $0x0,%eax
nopl   (%rax)
movsbl (%rax),%edx
cmp    %edi,%edx
je     348 <argcv_quote_char+0x28>
sub    $0x2,%rax
cmp    $0x0,%rax
ja     328 <argcv_quote_char+0x8>
mov    $0xffffffff,%eax
retq   
nopl   0x0(%rax)
movsbl -0x1(%rax),%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
argcv_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof(quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 7
5 7
6 5
7 4
8 4
9 10
10 11
11 11
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    0x40(%rdi),%rdi
jmpq   19 <folder_pop_open+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
folder_pop_open (mu_folder_t folder, int flags)
{
  mu_mailbox_t mbox = folder->data;
  return mu_mailbox_open (mbox, flags);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  6c <scram_free_server_first+0xc>
mov    0x8(%rbx),%rdi
callq  75 <scram_free_server_first+0x15>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
scram_free_server_first (struct scram_server_first *sf)
{
  free (sf->nonce);
  free (sf->salt);
  memset (sf, 0, sizeof (*sf));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rcx,0x38(%rsp)
xor    %ecx,%ecx
test   $0x40,%dl
je     30 <openat_safer+0x30>
lea    0x60(%rsp),%rax
mov    0x38(%rsp),%ecx
movl   $0x18,0x8(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  37 <openat_safer+0x37>
mov    %eax,%edi
callq  3e <openat_safer+0x3e>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
openat_safer (int fd, char const *file, int flags, ...)
{
  mode_t mode = 0;
  if (flags & 0100)
    {
      va_list ap;
      __builtin_va_start(ap,flags);
      mode = __builtin_va_arg(ap,mode_t);
      __builtin_va_end(ap);
    }
  return fd_safer (openat (fd, file, flags, mode));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 8
8 7
9 7
10 7
11 7
12 11
13 11
14 11
15 11
16 12
17 12
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   fc3 <gsl_sort_vector_int_smallest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_int_smallest (int * dest, const size_t k,
                                     const gsl_vector_int * v)
{
  return gsl_sort_int_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,%esi
mov    $0x0,%edi
lea    0x8(%rsp),%rdx
movq   $0x0,0x8(%rsp)
callq  5e <mu_syslog_facility_to_string+0x1e>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_syslog_facility_to_string (int n)
{
  const char *res = ((void *)0);
  mu_kwd_xlat_tok (kw_facility, n, &res);
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
clock_refresh()
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
lea    0xc(%rsp),%rsi
movl   $0x0,0xc(%rsp)
callq  4b0 <command_recurse.constprop.3>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
shcmd_command(SHCMD ** cmd_vector)
{
 int pids = 0;
 return command_recurse(cmd_vector, &pids, 0, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 3
6 4
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
test   %rdx,%rdx
fldt   (%rdi)
fstpt  0x10(%rsp)
je     2a4 <gsl_stats_long_double_min_index+0x64>
shl    $0x4,%rsi
xor    %ebx,%ebx
xor    %r14d,%r14d
mov    %rsi,%r13
lea    (%rdi,%rsi,1),%rbp
fldt   0x10(%rsp)
jmp    298 <gsl_stats_long_double_min_index+0x58>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     2b8 <gsl_stats_long_double_min_index+0x78>
fldt   0x0(%rbp)
fldt   0x10(%rsp)
fucomip %st(1),%st
jbe    295 <gsl_stats_long_double_min_index+0x55>
fld    %st(0)
fstpt  0x10(%rsp)
mov    %rbx,%r14
add    %r13,%rbp
fstpt  (%rsp)
callq  2a0 <gsl_stats_long_double_min_index+0x60>
test   %eax,%eax
je     278 <gsl_stats_long_double_min_index+0x38>
add    $0x20,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
add    $0x20,%rsp
mov    %r14,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_min_index (const long double data[], const size_t stride,
                                const size_t n)
{
  long double min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      long double xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          return i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 3
9 6
10 4
11 4
12 6
13 8
14 6
15 5
16 8
17 8
18 8
19 8
20 8
21 6
22 6
23 6
24 8
25 9
26 9
27 9
28 8
29 8
30 8
31 8
32 14
33 14
34 14
35 14
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 20
53 20
54 20
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rax
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 134f <fetch_handler+0xf>
mov    (%rax),%rax
mov    0x30(%rax),%rsi
mov    0x38(%rax),%rdx
callq  135f <fetch_handler+0x1f>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 1369 <fetch_handler+0x29>
mov    %rdx,0x0(%rip)        # 1370 <fetch_handler+0x30>
je     13a8 <fetch_handler+0x68>
mov    0x10(%rbx),%rdi
mov    0x0(%rip),%rdx        # 137d <fetch_handler+0x3d>
mov    $0x0,%esi
callq  1387 <fetch_handler+0x47>
mov    0x10(%rbx),%rsi
mov    $0xa,%edi
callq  1395 <fetch_handler+0x55>
pop    %rbx
mov    0x0(%rip),%rdi        # 139d <fetch_handler+0x5d>
jmpq   13a2 <fetch_handler+0x62>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  13b7 <fetch_handler+0x77>
pop    %rbx
mov    0x0(%rip),%rdi        # 13bf <fetch_handler+0x7f>
mov    %rax,%rsi
xor    %eax,%eax
jmpq   13c9 <fetch_handler+0x89>
nopl   0x0(%rax)
<<<sep_in_sample>>>
fetch_handler (struct handler_param *param)
{
  return_data = gdbm_fetch (gdbm_file, param->argv[0]->v.dat);
  if (return_data.dptr != ((void *)0))
    {
      datum_format (param->fp, &return_data, dsdef[1]);
      fputc ('\n', param->fp);
      free (return_data.dptr);
    }
  else
    fprintf (stderr, dgettext ("gdbm", "No such item found.\n"));
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 4
10 3
11 3
12 4
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 12
21 8
22 8
23 8
24 11
25 11
26 11
27 12
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     27e0 <gsl_matrix_uint_add+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  27cf <gsl_matrix_uint_add+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%r8
cmp    %rax,%r8
jne    27b6 <gsl_matrix_uint_add+0x16>
test   %r10,%r10
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r12
je     283f <gsl_matrix_uint_add+0x9f>
shl    $0x2,%r13
shl    $0x2,%r12
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
nopl   (%rax)
test   %r8,%r8
je     2830 <gsl_matrix_uint_add+0x90>
mov    %rbx,%rdx
mov    %rbp,%r9
add    0x18(%rdi),%rdx
add    0x18(%rsi),%r9
xor    %eax,%eax
nopl   (%rax)
mov    (%r9,%rax,4),%ecx
add    %ecx,(%rdx,%rax,4)
add    $0x1,%rax
cmp    %r8,%rax
jne    2820 <gsl_matrix_uint_add+0x80>
add    $0x1,%r11
add    %r13,%rbx
add    %r12,%rbp
cmp    %r10,%r11
jne    2808 <gsl_matrix_uint_add+0x68>
xor    %eax,%eax
jmp    27d4 <gsl_matrix_uint_add+0x34>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_add (gsl_matrix_uint * a, const gsl_matrix_uint * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 28, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 21
55 21
56 21
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    ab9 <gsl_matrix_equal+0x19>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     ae0 <gsl_matrix_equal+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  ad2 <gsl_matrix_equal+0x32>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     b48 <gsl_matrix_equal+0xa8>
lea    0x0(,%r8,8),%r12
lea    0x0(,%rax,8),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     b39 <gsl_matrix_equal+0x99>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movsd  (%r9,%rax,8),%xmm0
ucomisd (%r8,%rax,8),%xmm0
jp     b4f <gsl_matrix_equal+0xaf>
jne    b4f <gsl_matrix_equal+0xaf>
add    $0x1,%rax
cmp    %rdx,%rax
jne    b20 <gsl_matrix_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    b05 <gsl_matrix_equal+0x65>
mov    $0x1,%eax
jmp    ad4 <gsl_matrix_equal+0x34>
xor    %eax,%eax
jmp    ad4 <gsl_matrix_equal+0x34>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_equal (const gsl_matrix * a, const gsl_matrix * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 30
18 30
19 30
20 30
21 30
22 14
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 20
40 20
41 20
42 20
43 16
44 16
45 16
46 14
47 14
48 14
49 14
50 14
51 29
52 29
53 23
54 23
55 23
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    %rdx,%rdi
push   %rbx
mov    %rdx,%rbx
callq  5e5 <gsl_linalg_hessenberg_unpack+0x15>
mov    %rbx,%rdx
mov    %rbp,%rdi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   5f7 <gsl_linalg_hessenberg_unpack+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_linalg_hessenberg_unpack(gsl_matrix * H, gsl_vector * tau,
                             gsl_matrix * U)
{
  int s;
  gsl_matrix_set_identity(U);
  s = gsl_linalg_hessenberg_unpack_accum(H, tau, U);
  return s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 3
7 3
8 5
9 6
10 6
11 6
12 8
13 8
14 8
15 6
16 6
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   2f3 <gsl_vector_float_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_fscanf (FILE * stream, gsl_vector_float * v)
{
  int status = gsl_block_float_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %rsi,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rax
xor    %rsi,%rax
sub    %rdx,%rax
je     2e <__gmpz_limbs_finish+0x2e>
mov    0x8(%rdi),%rdx
cmpq   $0x0,-0x8(%rdx,%rax,8)
je     28 <__gmpz_limbs_finish+0x28>
jmp    2e <__gmpz_limbs_finish+0x2e>
cmpq   $0x0,-0x8(%rdx,%rax,8)
jne    2e <__gmpz_limbs_finish+0x2e>
sub    $0x1,%rax
jne    20 <__gmpz_limbs_finish+0x20>
mov    %eax,%edx
neg    %edx
test   %rsi,%rsi
cmovs  %edx,%eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_limbs_finish (mpz_ptr x, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((((x)->_mp_d))[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <__rdunlock+0x9>
cmpb   $0x0,0x89(%rbx)
je     19 <__rdunlock+0x19>
movb   $0x0,0x89(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__rdunlock (__bs5FILE *p)
{
  char c;
  c = __rdcheckpoint (p);
  if (p->locked)
    {
      p->locked = 0;
    }
  return (c);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 10
8 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
xor    %edi,%edi
cmpq   $0x0,0x0(%rip)        # 67e <exclude_languages+0xe>
je     698 <exclude_languages+0x28>
mov    $0x1,%dil
mov    $0x0,%edx
xor    %esi,%esi
xor    %eax,%eax
callq  691 <exclude_languages+0x21>
mov    0x0(%rip),%rdi        # 698 <exclude_languages+0x28>
mov    %rbx,%rsi
mov    $0x0,%edx
callq  6a5 <exclude_languages+0x35>
pop    %rbx
mov    %rax,0x0(%rip)        # 6ad <exclude_languages+0x3d>
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
exclude_languages (char *lang_names)
{
  if (langs_excluded)
    error (1, 0, "can't mix --include and --exclude options");
  langs_excluded = append_strings_to_vector (langs_excluded, lang_names, white_space);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 5
17 6
18 6
<<<sep_out_sample>>>
mov    %edi,%esi
mov    $0x0,%edi
jmpq   165c <coproc_fdchk+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
coproc_fdchk (fd)
     int fd;
{
  coproc_checkfd (&sh_coproc, fd);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   819 <xformat_set_mtime+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_set_mtime (XFORMAT * xux, time_t mtime)
{
 ;
        ahs_set_mtime(xux->ahsM, mtime);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_min_fminimizer_name (const gsl_min_fminimizer * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rdx
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x1,0x0(%rip)        # 2e68 <env_send+0x18>
je     2ea0 <env_send+0x50>
callq  2e6f <env_send+0x1f>
test   %rax,%rax
mov    %rax,%rbp
je     2e98 <env_send+0x48>
callq  2e7c <env_send+0x2c>
mov    0x10(%rbp),%rdi
callq  2e85 <env_send+0x35>
add    $0x8,%rsp
xor    %edi,%edi
pop    %rbx
pop    %rbp
jmpq   2e92 <env_send+0x42>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2ea7 <env_send+0x57>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   2eb4 <env_send+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
env_send (const char *var)
{
  register struct env_lst *ep;
  if ((!(options[39]&0x01))
    )
    {
      fprintf (stderr,
        "Cannot send '%s': Telnet ENVIRON option not enabled\n", var);
      return;
    }
  ep = env_find (var);
  if (ep == 0)
    {
      fprintf (stderr, "Cannot send '%s': variable not defined\n", var);
      return;
    }
  env_opt_start_info ();
  env_opt_add (ep->var);
  env_opt_end (0);
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 2
5 2
6 2
7 4
8 4
9 11
10 12
11 11
12 12
13 17
14 18
15 18
16 20
17 19
18 20
19 20
20 19
21 19
22 14
23 14
24 14
25 20
26 14
27 20
28 20
29 14
30 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 5d <releaseVResources+0xd>
mov    0x8(%rax),%rbx
test   %rbx,%rbx
jne    73 <releaseVResources+0x23>
jmp    93 <releaseVResources+0x43>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rbx
mov    (%rbx),%rdi
callq  7b <releaseVResources+0x2b>
mov    0x10(%rbx),%rbp
mov    %rbx,%rdi
callq  87 <releaseVResources+0x37>
test   %rbp,%rbp
jne    70 <releaseVResources+0x20>
mov    0x0(%rip),%rax        # 93 <releaseVResources+0x43>
mov    0x30(%rax),%rdi
movq   $0x0,0x8(%rax)
test   %rdi,%rdi
je     b8 <releaseVResources+0x68>
callq  a9 <releaseVResources+0x59>
mov    0x0(%rip),%rax        # b0 <releaseVResources+0x60>
movq   $0x0,0x30(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
releaseVResources (void)
{
 VColor *p = _VDefaultWorkContext->VColorList, *next;
 while (p) {
  free (p->color_name);
  next = p->next;
  free (p);
  p = next;
 }
 _VDefaultWorkContext->VColorList = ((void *)0);
 if (_VDefaultWorkContext->visTable) {
  free(_VDefaultWorkContext->visTable);
  _VDefaultWorkContext->visTable = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 8
11 5
12 5
13 6
14 7
15 7
16 4
17 4
18 4
19 11
20 10
21 11
22 11
23 12
24 13
25 13
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
html_ostream_write_mem (html_ostream_t first_arg, const void *data, size_t len)
{
  const struct html_ostream_implementation *vtable =
    ((struct html_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->write_mem (first_arg,data,len);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %edi,%esi
xor    %edi,%edi
jmpq   10ec <quotearg_style+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
quotearg_style (enum quoting_style s, char const *arg)
{
  return quotearg_n_style (0, s, arg);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r14
movq   $0x0,(%rdx)
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    $0x3,%r12d
push   %rbp
mov    $0x0,%ebp
push   %rbx
movq   $0x0,(%rsi)
mov    %rdi,%rsi
mov    $0x0,%edi
callq  854 <ogsnames+0x34>
cmpb   $0x2f,0x0(%rip)        # 85b <ogsnames+0x3b>
mov    $0x0,%eax
cmove  %rax,%rbp
jmp    894 <ogsnames+0x74>
nopw   %cs:0x0(%rax,%rax,1)
movb   $0x0,(%rbx)
mov    %rbp,%rdi
callq  87b <ogsnames+0x5b>
cmp    $0x2,%eax
jle    890 <ogsnames+0x70>
lea    -0x3(%rbx),%rsi
mov    $0x0,%edi
mov    %r12,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     8b8 <ogsnames+0x98>
lea    0x1(%rbx),%rbp
mov    $0x2f,%esi
mov    %rbp,%rdi
callq  8a1 <ogsnames+0x81>
test   %rax,%rax
mov    %rax,%rbx
jne    870 <ogsnames+0x50>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
mov    %rbp,0x0(%r13)
mov    $0x2f,%esi
mov    %rbx,%rdi
callq  8cd <ogsnames+0xad>
test   %rax,%rax
je     8a9 <ogsnames+0x89>
mov    %rbx,(%r14)
movb   $0x0,(%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ogsnames(char *file, char **subsystem, char **book)
{
 static char buf[250 + 1];
 char *s, *slash;
 *subsystem = *book = "";
 (void) strcpy(buf,file);
 s = buf;
 if (*s == '/') {
  ++s;
 }
 while ((slash = strchr(s, '/')) != ((void *)0)) {
  *slash = '\0';
  if ((int)strlen(s) >= 3 && strncmp(slash - 3, ".ss", 3) == 0) {
   *subsystem = s;
   s = slash + 1;
   if ((slash = strchr(s, '/')) != ((void *)0)) {
    *book = s;
    *slash = '\0';
   }
   break;
  }
  s = slash + 1;
 }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 13
8 2
9 7
10 2
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 12
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 22
31 11
32 11
33 11
34 11
35 11
36 11
37 24
38 24
39 24
40 24
41 24
42 24
43 24
44 15
45 14
46 16
47 16
48 16
49 16
50 16
51 17
52 18
53 24
54 24
55 24
56 24
57 24
58 24
59 24
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_scheme_string_variable (name, number, value)
     DStr_string_descriptor *name;
     int number;
     DStr_string_descriptor *value;
{
  char *command;
  char *var_name;
  return 0;
  }
<<<sep_in_sample>>>
1 9
2 9
3 9
<<<sep_out_sample>>>
test   %r8,%r8
je     be <gsl_stats_wmean+0x5e>
fldz   
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
shl    $0x3,%rcx
xor    %eax,%eax
fld    %st(0)
nopw   0x0(%rax,%rax,1)
movsd  (%rdi),%xmm0
ucomisd %xmm1,%xmm0
jbe    a2 <gsl_stats_wmean+0x42>
movsd  %xmm0,-0x18(%rsp)
fldl   -0x18(%rsp)
fadd   %st,%st(1)
fld    %st(2)
fsubrl (%rdx)
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    80 <gsl_stats_wmean+0x20>
fstp   %st(0)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wmean (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t size)
{
  long double wmean = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      double wi = w[i * wstride];
      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 4
5 4
6 12
7 6
8 4
9 4
10 8
11 9
12 9
13 11
14 11
15 11
16 12
17 12
18 12
19 12
20 12
21 12
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 16
33 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # 1bbc <gsl_complex_arccsc_real+0xc>
movsd  0x0(%rip),%xmm1        # 1bc4 <gsl_complex_arccsc_real+0x14>
ucomisd %xmm0,%xmm2
jae    1bd0 <gsl_complex_arccsc_real+0x20>
ucomisd %xmm1,%xmm0
jb     1bf0 <gsl_complex_arccsc_real+0x40>
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  1bdd <gsl_complex_arccsc_real+0x2d>
xorpd  %xmm1,%xmm1
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
ucomisd 0x0(%rip),%xmm0        # 1bf8 <gsl_complex_arccsc_real+0x48>
jb     1c28 <gsl_complex_arccsc_real+0x78>
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  1c07 <gsl_complex_arccsc_real+0x57>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 1c13 <gsl_complex_arccsc_real+0x63>
xorpd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 1c1f <gsl_complex_arccsc_real+0x6f>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  1c35 <gsl_complex_arccsc_real+0x85>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 1c41 <gsl_complex_arccsc_real+0x91>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_arccsc_real (double a)
{
  gsl_complex z;
  if (a <= -1.0 || a >= 1.0)
    {
      do {(&z)->dat[0]=(asin (1 / a)); (&z)->dat[1]=(0.0);} while(0);
    }
  else
    {
      if (a >= 0.0)
        {
          do {(&z)->dat[0]=(1.57079632679489661923); (&z)->dat[1]=(-acosh (1 / a));} while(0);
        }
      else
        {
          do {(&z)->dat[0]=(-1.57079632679489661923); (&z)->dat[1]=(acosh (-1 / a));} while(0);
        }
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 20
13 20
14 20
15 10
16 10
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 20
25 20
26 20
27 16
28 16
29 16
30 16
31 16
32 20
33 20
34 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <get_home_dir+0x9>
mov    %eax,%edi
callq  20 <get_home_dir+0x10>
test   %rax,%rax
je     30 <get_home_dir+0x20>
mov    0x20(%rax),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
xor    %eax,%eax
jmp    29 <get_home_dir+0x19>
<<<sep_in_sample>>>
get_home_dir ()
{
  char *home_dir;
  struct passwd *entry;
  home_dir = (char *)((void *)0);
  entry = getpwuid (getuid ());
  if (entry)
    home_dir = entry->pw_dir;
  return (home_dir);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 7
6 7
7 8
8 10
9 10
10 10
11 5
12 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  206c <gsl_vector_long_calloc+0xc>
test   %rax,%rax
mov    %rax,%rbx
je     20b8 <gsl_vector_long_calloc+0x58>
lea    0x0(,%rbp,8),%r12
mov    0x10(%rax),%rdi
xor    %esi,%esi
mov    %r12,%rdx
callq  208a <gsl_vector_long_calloc+0x2a>
test   %rbp,%rbp
je     20b0 <gsl_vector_long_calloc+0x50>
mov    0x10(%rbx),%rcx
lea    (%r12,%rcx,1),%rdx
nopw   0x0(%rax,%rax,1)
movq   $0x0,(%rcx)
add    $0x8,%rcx
cmp    %rdx,%rcx
jne    20a0 <gsl_vector_long_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    20b3 <gsl_vector_long_calloc+0x53>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_long_calloc (const size_t n)
{
  size_t i;
  gsl_vector_long * v = gsl_vector_long_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 1 * n * sizeof(long));
  for (i = 0; i < 1 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 8
22 8
23 8
24 13
25 13
26 13
27 13
28 6
29 6
30 6
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
mov    $0x1,%esi
push   %rbp
mov    %rdi,%rbp
mov    $0x80,%edi
push   %rbx
callq  19 <xargs_open_generic+0x19>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  24 <xargs_open_generic+0x24>
movl   $0x0,0x24(%rbx)
mov    %rax,(%rbx)
xor    %edi,%edi
movq   $0x0,0x8(%rbx)
callq  3d <xargs_open_generic+0x3d>
movl   $0x0,0x18(%rbx)
mov    %rax,0x10(%rbx)
mov    %rbx,%rax
movl   $0x0,0x1c(%rbx)
mov    %r12d,0x2c(%rbx)
movl   $0x0,0x20(%rbx)
movl   $0x0,0x38(%rbx)
movq   $0x0,0x40(%rbx)
movl   $0x0,0x28(%rbx)
movl   $0x0,0x30(%rbx)
movl   $0x0,0x34(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xargs_open_generic(const char *command, int max_args)
{
 XARGS *xp;
 xp = check_calloc(sizeof(XARGS), 1);
 xp->command = check_strdup(command);
 xp->type = 0;
 xp->pipe = ((void *)0);
 xp->result = strbuf_open(0);
 xp->end_of_arg = 0;
 xp->unread = 0;
 xp->max_args = max_args;
 xp->seqno = 0;
 xp->skip_assembly = 0;
 xp->verbose = ((void *)0);
 xp->ignore_error = 0;
 xp->put_gpath = 0;
 xp->trim_line = 0;
 return xp;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 2
8 4
9 5
10 4
11 5
12 6
13 5
14 8
15 7
16 8
17 9
18 8
19 19
20 10
21 11
22 12
23 13
24 14
25 15
26 16
27 17
28 19
29 19
30 19
31 19
32 19
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x0,0x4(%rdi)
movl   $0x0,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_set_to_null (version_t version)
{
  size_t n;
  for (n = 0 ; n < 3 ; n++)
    version[n] = 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     1de <font_info_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    1c0 <font_info_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
font_info_hash_1 (struct font_info *font_info)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((font_info->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exact_free (RC_REGEX *regex)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbx
callq  f00 <term>
mov    0x0(%rip),%edx        # 10ec <and+0xc>
cmp    0x0(%rip),%edx        # 10f2 <and+0x12>
mov    %eax,%ebx
jge    1109 <and+0x29>
mov    0x0(%rip),%rax        # 10fd <and+0x1d>
movslq %edx,%rcx
mov    (%rax,%rcx,8),%rax
cmpb   $0x2d,(%rax)
je     1110 <and+0x30>
mov    %ebx,%eax
pop    %rbx
retq   
nopl   (%rax)
cmpb   $0x61,0x1(%rax)
jne    1109 <and+0x29>
cmpb   $0x0,0x2(%rax)
jne    1109 <and+0x29>
add    $0x1,%edx
mov    %edx,0x0(%rip)        # 1125 <and+0x45>
callq  10e0 <and>
test   %eax,%eax
setne  %al
test   %ebx,%ebx
setne  %bl
movzbl %bl,%ebx
and    %eax,%ebx
jmp    1109 <and+0x29>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
and ()
{
  int value, v2;
  value = term ();
  if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'a' && !argv[pos][2])
    {
      do { ++pos; if (0 && pos >= argc) beyond (); } while (0);
      v2 = and ();
      return (value && v2);
    }
  return (value);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 11
6 5
7 5
8 5
9 5
10 5
11 5
12 12
13 12
14 12
15 12
16 5
17 5
18 5
19 5
20 7
21 7
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    5140 <gsl_matrix_long_double_const_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  5162 <gsl_matrix_long_double_const_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_const_superdiagonal (const gsl_matrix_long_double * m,
                                      const size_t k)
{
  _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     230 <setenv+0x60>
cmpb   $0x0,(%rdi)
je     230 <setenv+0x60>
mov    %rsi,%r12
mov    $0x3d,%esi
mov    %edx,%ebp
callq  1f0 <setenv+0x20>
test   %rax,%rax
jne    230 <setenv+0x60>
test   %ebp,%ebp
je     248 <setenv+0x78>
xor    %edx,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  206 <setenv+0x36>
mov    %rax,%rcx
mov    $0xffffffff,%eax
test   %rcx,%rcx
je     221 <setenv+0x51>
mov    0x28(%rcx),%edx
xor    %eax,%eax
and    $0xef,%dh
or     $0x1,%edx
mov    %edx,0x28(%rcx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
callq  235 <setenv+0x65>
movl   $0x16,(%rax)
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    %rbx,%rdi
callq  250 <setenv+0x80>
test   %rax,%rax
mov    %rax,%rcx
jne    213 <setenv+0x43>
jmp    1f9 <setenv+0x29>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setenv (name, value, rewrite)
     const char *name;
     const char *value;
     int rewrite;
{
  SHELL_VAR *var;
  char *v;
  if (name == 0 || *name == '\0' || strchr (name, '=') != 0)
    {
      (*__errno_location ()) = 22;
      return -1;
    }
  var = 0;
  v = (char *)value;
  if (rewrite == 0)
    var = find_variable (name);
  if (var == 0)
    var = bind_variable (name, v, 0);
  if (var == 0)
    return -1;
  ((var)->attributes &= ~(0x0001000));
  ((var)->attributes |= (0x0000001));
  return 0;
}
<<<sep_in_sample>>>
1 5
2 8
3 5
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 15
16 15
17 18
18 18
19 18
20 18
21 18
22 20
23 19
24 19
25 21
26 23
27 21
28 22
29 22
30 24
31 24
32 24
33 24
34 24
35 10
36 10
37 11
38 24
39 24
40 24
41 24
42 24
43 16
44 16
45 17
46 16
47 17
48 17
49 17
<<<sep_out_sample>>>
cmpb   $0x24,-0x1(%rdi)
je     7b0 <has_right_delimiter+0x20>
lea    -0x2(%rdi),%rsi
mov    $0x3,%ecx
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
sete   %al
movzbl %al,%eax
retq   
nopl   (%rax)
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
has_right_delimiter (char const *pattern)
{
  return (pattern[-1] == '$' || (strcmp ((pattern - 2), ("\\>")) == 0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
<<<sep_out_sample>>>
jmpq   725 <dbop_update+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dbop_update(DBOP *dbop, const char *key, const char *dat)
{
 dbop_put(dbop, key, dat);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_PREC()
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  2e72 <gsl_stats_char_variance+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   2e84 <gsl_stats_char_variance+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_char_variance (const char data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_char_mean (data, stride, n);
  return gsl_stats_char_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 87 <gsl_set_error_handler_off+0x7>
movq   $0x0,0x0(%rip)        # 92 <gsl_set_error_handler_off+0x12>
retq   
<<<sep_in_sample>>>
gsl_set_error_handler_off (void)
{
  gsl_error_handler_t * previous_handler = gsl_error_handler;
  gsl_error_handler = no_error_handler;
  return previous_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  13 <fixup_url+0x13>
cmpq   $0x0,0x0(%rip)        # 1b <fixup_url+0x1b>
je     70 <fixup_url+0x70>
cmpq   $0x0,0x0(%rip)        # 25 <fixup_url+0x25>
je     88 <fixup_url+0x88>
cmpq   $0x0,0x0(%rip)        # 2f <fixup_url+0x2f>
je     a0 <fixup_url+0xa0>
cmpq   $0x0,0x0(%rip)        # 39 <fixup_url+0x39>
je     58 <fixup_url+0x58>
cmpl   $0x1,0x0(%rip)        # 42 <fixup_url+0x42>
jne    4e <fixup_url+0x4e>
movl   $0x1,0x0(%rip)        # 4e <fixup_url+0x4e>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  67 <fixup_url+0x67>
jmp    3b <fixup_url+0x3b>
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  7f <fixup_url+0x7f>
jmp    1d <fixup_url+0x1d>
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  97 <fixup_url+0x97>
jmp    27 <fixup_url+0x27>
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  af <fixup_url+0xaf>
jmp    31 <fixup_url+0x31>
<<<sep_in_sample>>>
fixup_url()
{
    xdico_assign_string(&dico_url.proto, "dict");
    if (!dico_url.host)
 xdico_assign_string(&dico_url.host, "gnu.org.ua");
    if (!dico_url.port)
 xdico_assign_string(&dico_url.port, "2628");
    if (!dico_url.req.database)
 xdico_assign_string(&dico_url.req.database, "!");
    if (!dico_url.req.strategy)
 xdico_assign_string(&dico_url.req.strategy, ".");
    if (mode == mode_match)
 dico_url.req.type = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 10
12 10
13 12
14 12
15 13
16 14
17 14
18 14
19 11
20 11
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 5
29 7
30 7
31 7
32 7
33 7
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_data (const gsl_combination * c)
{
  return c->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 5e <yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  6a <yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  74 <yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
lea    0x1c(%rsp),%rdi
fstpt  (%rsp)
callq  31 <printf_frexpl+0x31>
mov    0x1c(%rsp),%edx
fadd   %st(0),%st
lea    -0x1(%rdx),%eax
cmp    $0xffffc002,%eax
mov    %eax,0x1c(%rsp)
jge    58 <printf_frexpl+0x58>
fstpt  (%rsp)
lea    0x3ffd(%rdx),%edi
callq  53 <printf_frexpl+0x53>
mov    $0xffffc002,%eax
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 7
17 8
18 9
19 8
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 17
29 17
30 17
31 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1f1 <scram_print_client_final+0x11>
test   %al,%al
je     230 <scram_print_client_final+0x50>
mov    0x8(%rbx),%rcx
mov    0x10(%rbx),%r8
xor    %eax,%eax
mov    (%rbx),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  20f <scram_print_client_final+0x2f>
test   %eax,%eax
jle    230 <scram_print_client_final+0x50>
xor    %eax,%eax
cmpq   $0x0,0x0(%rbp)
sete   %al
add    $0x8,%rsp
pop    %rbx
neg    %eax
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
scram_print_client_final (struct scram_client_final *cl, char **out)
{
  int n;
  if (!scram_valid_client_final (cl))
    return -1;
  n = asprintf (out, "c=%s,r=%s,p=%s", cl->cbind, cl->nonce, cl->proof);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 10
22 10
23 7
24 10
25 10
26 10
27 10
28 5
29 10
30 10
31 10
32 10
<<<sep_out_sample>>>
mov    %rcx,%r8
sub    $0x8,%rsp
mov    %edx,%ecx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  fa9 <swlib_fatal+0x19>
mov    $0xfc,%edi
callq  fb3 <swlib_fatal+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_fatal(char * reason, char * file,
   int line, char * function)
{
 e_msg("fatal error", reason,file, line, function);
 exit(252);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # eb7 <tar_dirname+0x7>
mov    0x0(%rip),%rdx        # ebe <tar_dirname+0xe>
lea    (%rax,%rax,2),%rax
lea    (%rdx,%rax,8),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tar_dirname (void)
{
  return wd[chdir_current].name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # d7 <ps_load_buffer_state+0x7>
mov    0x0(%rip),%rdx        # de <ps_load_buffer_state+0xe>
lea    (%rax,%rdx,8),%rdx
mov    (%rdx),%rax
mov    0x1c(%rax),%ecx
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # f3 <ps_load_buffer_state+0x23>
mov    (%rdx),%rdx
mov    %rax,0x0(%rip)        # fd <ps_load_buffer_state+0x2d>
mov    %ecx,0x0(%rip)        # 103 <ps_load_buffer_state+0x33>
mov    (%rdx),%rdx
mov    %rdx,0x0(%rip)        # 10d <ps_load_buffer_state+0x3d>
movzbl (%rax),%eax
mov    %al,0x0(%rip)        # 116 <ps_load_buffer_state+0x46>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ps_load_buffer_state (void)
{
     (yy_n_chars) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_n_chars;
 (pstext) = (yy_c_buf_p) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_buf_pos;
 psin = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_input_file;
 (yy_hold_char) = *(yy_c_buf_p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 3
11 5
12 5
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
add    $0xa,%esi
jmpq   1e18 <swi_fl_add_store+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_fl_add_store(SWI_FILELIST * fl, int len) {
 STRAR * ar = (STRAR*)fl;
 char * s;
 s = strar_return_store(ar, len + 10);
 return s;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
jmpq   925 <grecs_grecs_alloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_alloc (grecs_grecs__size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0x3a,%esi
jmpq   eba <quotearg_colon+0xa>
<<<sep_in_sample>>>
quotearg_colon (char const *arg)
{
  return quotearg_char (arg, ':');
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
xorpd  %xmm6,%xmm6
movapd %xmm0,%xmm4
ucomisd %xmm0,%xmm6
jae    6b0 <gsl_cdf_beta_P+0x40>
movsd  0x0(%rip),%xmm5        # 686 <gsl_cdf_beta_P+0x16>
ucomisd %xmm5,%xmm4
movapd %xmm5,%xmm0
jb     698 <gsl_cdf_beta_P+0x28>
repz retq 
nopw   0x0(%rax,%rax,1)
movapd %xmm2,%xmm3
movapd %xmm1,%xmm2
movapd %xmm6,%xmm1
jmpq   240 <beta_inc_AXPY>
nopl   0x0(%rax)
movapd %xmm6,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_beta_P (const double x, const double a, const double b)
{
  double P;
  if (x <= 0.0 )
    {
      return 0.0;
    }
  if ( x >= 1.0 )
    {
      return 1.0;
    }
  P = beta_inc_AXPY (1.0, 0.0, a, b, x);
  return P;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 8
6 8
7 10
8 8
9 14
10 14
11 12
12 12
13 12
14 12
15 12
16 6
17 14
18 14
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     58 <cdio_read+0x28>
mov    0x120(%rdi),%rax
test   %rax,%rax
je     50 <cdio_read+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffffffffffe,%rax
retq   
mov    $0xfffffffffffffffd,%rax
retq   
<<<sep_in_sample>>>
cdio_read (const CdIo_t *p_cdio, void *p_buf, size_t i_size)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.read)
    return (p_cdio->op.read) (p_cdio->env, p_buf, i_size);
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 7
11 3
12 3
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r8d
push   %r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
cmp    $0x7fffffff,%rcx
jbe    925a <_sse_ldxi_d+0x2a>
lea    0x7fffffff(%rcx),%rax
cmp    $0x7ffffffe,%rax
ja     9280 <_sse_ldxi_d+0x50>
mov    %ebp,(%rsp)
mov    %rbx,%rdi
mov    $0x28,%r9d
mov    $0x10,%edx
mov    $0xf2,%esi
callq  de0 <_ssexrx.constprop.74>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x20000000,%esi
mov    %rcx,0x18(%rsp)
mov    %edx,0x14(%rsp)
callq  9293 <_sse_ldxi_d+0x63>
mov    %eax,%r12d
mov    0x18(%rsp),%rcx
mov    %rbx,%rdi
and    $0x7fff,%r12d
mov    %eax,%r13d
shl    $0x4,%r12
mov    0x0(%r12),%esi
mov    %rcx,%rdx
and    $0x7fff,%esi
callq  2b60 <_movi>
mov    0x0(%r12),%r9d
mov    0x14(%rsp),%r8d
mov    %rbx,%rdi
mov    %ebp,(%rsp)
mov    $0xf2,%esi
xor    %ecx,%ecx
mov    $0x10,%edx
and    $0x7fff,%r9d
callq  de0 <_ssexrx.constprop.74>
add    $0x28,%rsp
mov    %rbx,%rdi
mov    %r13d,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   9302 <_sse_ldxi_d+0xd2>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_ldxi_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_word_t i0)
{
    jit_int32_t reg;
    if ((((i0) >= 0 && (long long)(i0) <= 0x7fffffffLL) || ((i0) < 0 && (long long)(i0) > -0x80000000LL)))
 _ssexrx(_jit,0xf2,0x10,i0,r1,_NOREG,0x00,r0);
    else {
 reg = _jit_get_reg(_jit,0x20000000);
 _movi(_jit, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), i0);
 _ssexrx(_jit,0xf2,0x10,0,r1,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),0x00,r0);
 _jit_unget_reg(_jit,reg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 12
21 12
22 12
23 12
24 12
25 12
26 7
27 7
28 7
29 7
30 8
31 8
32 8
33 8
34 7
35 8
36 8
37 8
38 8
39 8
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 12
50 10
51 10
52 12
53 12
54 12
55 12
56 10
57 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     868 <lintwarn_ln+0x58>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
xor    %eax,%eax
mov    %rsi,%rbp
mov    0x0(%rip),%ebx        # 873 <lintwarn_ln+0x63>
mov    %edi,0x0(%rip)        # 879 <lintwarn_ln+0x69>
callq  40 <print_included_from>
lea    0xf0(%rsp),%rax
cmpq   $0x0,0x0(%rip)        # 891 <lintwarn_ln+0x81>
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
je     8f0 <lintwarn_ln+0xe0>
mov    $0x0,%edi
callq  8bc <lintwarn_ln+0xac>
lea    0x8(%rsp),%rcx
mov    %rbp,%rdx
mov    %rax,%rsi
xor    %edi,%edi
callq  8ce <lintwarn_ln+0xbe>
cmpq   $0x0,0x0(%rip)        # 8d9 <lintwarn_ln+0xc9>
mov    %ebx,0x0(%rip)        # 8df <lintwarn_ln+0xcf>
je     918 <lintwarn_ln+0x108>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  8fa <lintwarn_ln+0xea>
lea    0x8(%rsp),%rcx
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x1,%edi
callq  90f <lintwarn_ln+0xff>
jmp    8ce <lintwarn_ln+0xbe>
nopl   0x0(%rax)
mov    $0x2,%edi
callq  922 <lintwarn_ln+0x112>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
lintwarn_ln(int line, const char *mesg, ...)
{
 va_list args;
 int saveline;
 saveline = sourceline;
 sourceline = line;
 print_included_from();
 __builtin_va_start(args,mesg);
 if (lintfunc == r_fatal)
  err(1, gettext("fatal: "), mesg, args);
 else
  err(0, gettext("warning: "), mesg, args);
 __builtin_va_end(args);
 sourceline = saveline;
 if (lintfunc == r_fatal)
  gawk_exit(2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 7
19 2
20 5
21 6
22 7
23 8
24 9
25 8
26 8
27 8
28 8
29 8
30 9
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 15
39 14
40 15
41 17
42 17
43 17
44 17
45 17
46 10
47 10
48 10
49 10
50 10
51 10
52 10
53 10
54 10
55 16
56 16
57 17
58 17
59 17
60 17
61 17
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
xor    %ebx,%ebx
sub    $0x10,%rsp
lea    0x8(%rsp),%rdx
mov    %rdi,(%rsp)
mov    %rsp,%rdi
callq  8d <rec_rset_type_field_fex+0x1d>
test   %al,%al
je     ad <rec_rset_type_field_fex+0x3d>
mov    0x8(%rsp),%rdi
mov    $0x1,%esi
callq  a0 <rec_rset_type_field_fex+0x30>
mov    0x8(%rsp),%rdi
mov    %rax,%rbx
callq  ad <rec_rset_type_field_fex+0x3d>
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_type_field_fex (const char *str)
{
  rec_fex_t fex = ((void *)0);
  const char *p;
  char *name;
  p = str;
  if (rec_parse_regexp (&p,
                        "^" "[a-zA-Z%][a-zA-Z0-9_]*" "(\\." "[a-zA-Z%][a-zA-Z0-9_]*" ")?" "(," "[a-zA-Z%][a-zA-Z0-9_]*" "(\\." "[a-zA-Z%][a-zA-Z0-9_]*" ")?" ")*",
                        &name))
    {
      fex = rec_fex_new (name, REC_FEX_CSV);
      free (name);
    }
  return fex;
}
<<<sep_in_sample>>>
1 2
2 7
3 3
4 2
5 7
6 6
7 7
8 7
9 7
10 7
11 11
12 11
13 11
14 12
15 11
16 12
17 15
18 15
19 15
20 15
21 15
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x64,%edi
push   %rbp
push   %rbx
callq  11 <linize+0x11>
mov    %rax,%rbx
callq  19 <linize+0x19>
mov    $0x0,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  2c <linize+0x2c>
test   %rax,%rax
je     4d <linize+0x4d>
mov    %rbp,%rdi
mov    %rax,%rsi
callq  3c <linize+0x3c>
mov    $0x0,%edx
xor    %esi,%esi
mov    %rbx,%rdi
callq  4b <linize+0x4b>
jmp    2c <linize+0x2c>
mov    %rbx,%rdi
callq  55 <linize+0x55>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
linize(char * text)
{
 char * s;
 STROB * tmp;
 STRAR * strar;
 tmp = strob_open(100);
 strar = strar_open();
 s = strob_strtok(tmp, text, "\n");
 while (s) {
  strar_add(strar, s);
  s = strob_strtok(tmp, ((void *)0), "\n");
 }
 strob_close(tmp);
 return strar;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 2
5 2
6 6
7 6
8 7
9 8
10 8
11 8
12 7
13 8
14 9
15 9
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 15
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # f <eu+0xf>
movsd  0x0(%rip),%xmm0        # 17 <eu+0x17>
movsd  0x0(%rip),%xmm1        # 1f <eu+0x1f>
nop
xorpd  %xmm4,%xmm4
ucomisd %xmm4,%xmm1
mulsd  0x0(%rip),%xmm1        # 30 <eu+0x30>
jbe    128 <eu+0x128>
movapd %xmm0,%xmm3
subsd  %xmm1,%xmm3
ucomisd 0x0(%rip),%xmm3        # 46 <eu+0x46>
setb   %al
test   %al,%al
je     147 <eu+0x147>
mov    0x0(%rip),%rax        # 58 <eu+0x58>
movsd  %xmm0,0x28(%rax)
movsd  %xmm0,0x20(%rax)
callq  67 <eu+0x67>
mov    0x0(%rip),%rax        # 6e <eu+0x6e>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 78 <eu+0x78>
je     ab <eu+0xab>
nopw   0x0(%rax,%rax,1)
movsd  0x20(%rax),%xmm0
movsd  %xmm0,0x28(%rax)
movsd  0x60(%rax),%xmm0
movsd  %xmm0,0x68(%rax)
mov    0x108(%rax),%rax
test   %rax,%rax
jne    80 <eu+0x80>
movq   $0x0,0x0(%rip)        # ab <eu+0xab>
callq  b0 <eu+0xb0>
mov    0x0(%rip),%rax        # b7 <eu+0xb7>
movsd  0x0(%rip),%xmm1        # bf <eu+0xbf>
test   %rax,%rax
mov    %rax,0x0(%rip)        # c9 <eu+0xc9>
je     fa <eu+0xfa>
nopl   0x0(%rax,%rax,1)
movsd  0x60(%rax),%xmm0
mulsd  %xmm1,%xmm0
addsd  0x28(%rax),%xmm0
movsd  %xmm0,0x20(%rax)
mov    0x108(%rax),%rax
test   %rax,%rax
jne    d0 <eu+0xd0>
movq   $0x0,0x0(%rip)        # fa <eu+0xfa>
mov    0x0(%rip),%rax        # 101 <eu+0x101>
add    $0x1,%rax
cvtsi2sd %rax,%xmm0
mov    %rax,0x0(%rip)        # 111 <eu+0x111>
mulsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # 11d <eu+0x11d>
jmpq   20 <eu+0x20>
nopw   0x0(%rax,%rax,1)
movapd %xmm0,%xmm5
movsd  0x0(%rip),%xmm2        # 134 <eu+0x134>
subsd  %xmm1,%xmm5
ucomisd %xmm5,%xmm2
setb   %al
test   %al,%al
jne    51 <eu+0x51>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
eu (void)
{
  double t;
  for (it = 0, t = tstart; !(tstep>0 ? t-0.0625*tstep>=tstop : t-0.0625*tstep<=tstop ); t = tstart + (++it) * tstep)
    {
      symtab->sy_value = symtab->sy_val[0] = t;
      field();
      for (fsp = dqueue; fsp != ((void *)0); fsp = fsp->sy_link)
 {
   fsp->sy_val[0] = fsp->sy_value;
   fsp->sy_pri[0] = fsp->sy_prime;
 }
      printq();
      for (fsp = dqueue; fsp != ((void *)0); fsp = fsp->sy_link)
 fsp->sy_value = fsp->sy_val[0] + tstep * fsp->sy_prime;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 10
26 10
27 11
28 11
29 8
30 8
31 8
32 8
33 13
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
43 15
44 14
45 14
46 14
47 14
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 4
57 4
58 4
59 4
60 4
61 4
62 4
63 17
64 17
65 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  8be <s_char+0xe>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
s_char (struct xdatum *xd, char *str)
{
  xd_store (xd, str, 1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %esi,%ebx
sub    $0x8,%rsp
test   %esi,%esi
js     61d7 <info_global_next_node+0x37>
jne    61c2 <info_global_next_node+0x22>
jmp    61d0 <info_global_next_node+0x30>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%ebx
nopl   0x0(%rax,%rax,1)
je     61d0 <info_global_next_node+0x30>
xor    %esi,%esi
mov    %rbp,%rdi
callq  40f0 <forward_move_node_structure>
test   %eax,%eax
je     61b8 <info_global_next_node+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
add    $0x8,%rsp
neg    %esi
pop    %rbx
pop    %rbp
jmpq   61e4 <info_global_next_node+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_global_next_node (WINDOW *window, int count)
{
  if (count < 0)
    info_global_prev_node (window, -count);
  else
    {
      while (count)
        {
          if (forward_move_node_structure (window, 0))
            break;
          count--;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 14
20 14
21 14
22 14
23 14
24 4
25 14
26 14
27 4
28 4
<<<sep_out_sample>>>
push   %rbp
mov    %r9,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
mov    (%r9),%edx
mov    0x260(%rdi),%rax
lea    (%r8,%rdx,8),%rcx
mov    (%rbx),%edx
callq  *0x18(%rax)
addl   $0x1,0x0(%rbp)
addl   $0x1,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
merged_1v_upsample (j_decompress_ptr cinfo,
      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
      JDIMENSION in_row_groups_avail,
      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
      JDIMENSION out_rows_avail)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
    output_buf + *out_row_ctr);
  (*out_row_ctr)++;
  (*in_row_group_ctr)++;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 10
12 11
13 12
14 12
15 12
16 12
17 12
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     459 <swheader_set_image_head+0x19>
callq  459 <swheader_set_image_head+0x19>
mov    %rbp,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swheader_set_image_head(SWHEADER * swheader, void * image)
{
 ;
 if (swheader->image_head_) free(swheader->image_head_);
 swheader->image_head_=image;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  3d0c <gsl_sf_fermi_dirac_3half+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3d20 <gsl_sf_fermi_dirac_3half+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x65b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d36 <gsl_sf_fermi_dirac_3half+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_fermi_dirac_3half(const double x)
{
  gsl_sf_result result; int status = gsl_sf_fermi_dirac_3half_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_fermi_dirac_3half_e(x, &result)", "fermi_dirac.c", 1627, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 326a <just_dump+0xa>
callq  326f <just_dump+0xf>
callq  3274 <just_dump+0x14>
mov    0x0(%rip),%rdi        # 327b <just_dump+0x1b>
callq  3280 <just_dump+0x20>
mov    0x0(%rip),%rdi        # 3287 <just_dump+0x27>
callq  328c <just_dump+0x2c>
mov    %ebx,%edi
mov    $0x0,%esi
pop    %rbx
jmpq   3299 <just_dump+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
just_dump(int signum)
{
 extern INSTRUCTION *code_block;
 dump_prog(code_block);
 dump_funcs();
 dump_fcall_stack(prof_fp);
 fflush(prof_fp);
 signal(signum, just_dump);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 6
8 7
9 7
10 8
11 8
12 9
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 5e <yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  6a <yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  74 <yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
callq  9f8 <mbox_unset_attr_flags+0x8>
mov    %rax,%rdi
callq  a00 <mbox_unset_attr_flags+0x10>
mov    %rax,%rdx
mov    $0x16,%eax
test   %rdx,%rdx
je     a14 <mbox_unset_attr_flags+0x24>
not    %ebx
and    %ebx,0x28(%rdx)
xor    %al,%al
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_unset_attr_flags (mu_attribute_t attr, int flags)
{
  mu_message_t msg = mu_attribute_get_owner (attr);
  mbox_message_t mum = mu_message_get_owner (msg);
  if (mum == ((void *)0))
    return 22;
  mum->attr_flags &= ~flags;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 5
9 5
10 7
11 7
12 8
13 9
14 9
15 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2d21 <info_namelist_free+0x21>
push   %rbx
jmp    2d13 <info_namelist_free+0x13>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    (%rdi),%rbx
callq  2d1b <info_namelist_free+0x1b>
test   %rbx,%rbx
jne    2d10 <info_namelist_free+0x10>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
info_namelist_free (struct info_namelist_entry *top)
{
  while (top)
    {
      struct info_namelist_entry *next = top->next;
      free (top);
      top = next;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 7
7 5
8 6
9 3
10 3
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x30(%rdi)
jne    a8 <_url_imaps_init+0x18>
movq   $0x3e1,0x30(%rdi)
cmpq   $0x0,0x28(%rbx)
movq   $0x0,0x68(%rbx)
mov    $0x16,%ebp
je     c8 <_url_imaps_init+0x38>
mov    0x58(%rbx),%ebp
test   %ebp,%ebp
je     d8 <_url_imaps_init+0x48>
mov    $0x16,%ebp
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
cmpq   $0x0,0x20(%rbx)
jne    c8 <_url_imaps_init+0x38>
mov    $0x2,%edi
callq  e9 <_url_imaps_init+0x59>
test   %rax,%rax
mov    %rax,0x20(%rbx)
je     ff <_url_imaps_init+0x6f>
movb   $0x2a,(%rax)
mov    0x20(%rbx),%rax
movb   $0x0,0x1(%rax)
jmp    c8 <_url_imaps_init+0x38>
mov    $0xc,%ebp
jmp    c8 <_url_imaps_init+0x38>
<<<sep_in_sample>>>
_url_imaps_init (mu_url_t url)
{
  if (url->port == 0)
    url->port = 993;
  url->_destroy = url_imap_destroy;
  if (!url->host || url->qargc)
    return 22;
  if (!url->auth)
    {
      url->auth = malloc (1 + 1);
      if (!url->auth)
 return 12;
      url->auth[0] = '*';
      url->auth[1] = '\0';
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 6
9 5
10 7
11 6
12 6
13 6
14 6
15 7
16 17
17 17
18 17
19 17
20 17
21 17
22 8
23 8
24 10
25 10
26 11
27 10
28 11
29 13
30 14
31 14
32 14
33 12
34 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 326 <__db_pthread_mutex_unlock+0x6>
test   %eax,%eax
je     368 <__db_pthread_mutex_unlock+0x48>
push   %rbx
movzbl 0x68(%rdi),%eax
mov    %rdi,%rbx
test   $0x1,%al
jne    360 <__db_pthread_mutex_unlock+0x40>
test   $0x2,%al
je     370 <__db_pthread_mutex_unlock+0x50>
callq  33f <__db_pthread_mutex_unlock+0x1f>
test   %eax,%eax
jne    356 <__db_pthread_mutex_unlock+0x36>
movl   $0x0,0x5c(%rbx)
mov    %rbx,%rdi
callq  352 <__db_pthread_mutex_unlock+0x32>
test   %eax,%eax
je     380 <__db_pthread_mutex_unlock+0x60>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x0,0x5c(%rdi)
pop    %rbx
jmpq   37d <__db_pthread_mutex_unlock+0x5d>
nopl   (%rax)
lea    0x28(%rbx),%rdi
pop    %rbx
jmpq   38a <__db_pthread_mutex_unlock+0x6a>
<<<sep_in_sample>>>
__db_pthread_mutex_unlock(mutexp)
 MUTEX *mutexp;
{
 int ret;
 if (!CDB___db_global_values.db_mutexlocks || ((mutexp)->flags & (0x001)))
  return (0);
 if (((mutexp)->flags & (0x002))) {
  if ((ret = pthread_mutex_lock(&mutexp->mutex)) != 0)
   return (ret);
  mutexp->locked = 0;
  if ((ret = pthread_mutex_unlock(&mutexp->mutex)) != 0)
   return (ret);
  if ((ret = pthread_cond_signal(&mutexp->cond)) != 0)
   return (ret);
 } else {
  mutexp->locked = 0;
  if ((ret = pthread_mutex_unlock(&mutexp->mutex)) != 0)
   return (ret);
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 3
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 10
15 11
16 11
17 11
18 11
19 21
20 21
21 21
22 6
23 21
24 21
25 21
26 6
27 21
28 21
29 16
30 21
31 17
32 17
33 13
34 21
35 13
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     13e5 <gsl_matrix_long_double_set_identity+0x55>
fldz   
shl    $0x4,%r9
mov    %rax,%rdi
xor    %ecx,%ecx
nop
test   %rsi,%rsi
je     13d7 <gsl_matrix_long_double_set_identity+0x47>
mov    %rdi,%rdx
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cmp    %rax,%rcx
je     13e7 <gsl_matrix_long_double_set_identity+0x57>
fld    %st(0)
add    $0x1,%rax
add    $0x10,%rdx
fstpt  -0x10(%rdx)
cmp    %rsi,%rax
jne    13c0 <gsl_matrix_long_double_set_identity+0x30>
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    13b0 <gsl_matrix_long_double_set_identity+0x20>
fstp   %st(0)
repz retq 
fld1   
jmp    13c7 <gsl_matrix_long_double_set_identity+0x37>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_set_identity (gsl_matrix_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const long double zero = 0.0L;
  const long double one = 1.0L;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(long double *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 14
8 14
9 14
10 10
11 10
12 12
13 12
14 12
15 12
16 12
17 14
18 14
19 14
20 12
21 12
22 14
23 12
24 12
25 10
26 10
27 10
28 10
29 10
30 10
31 14
32 14
33 14
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
mov    $0x40800000,%esi
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  ef24 <_x87_bgti_d+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r12d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  e610 <_x87_movi_d>
mov    0x0(%rbp),%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0x7,%esi
and    $0x7fff,%r8d
callq  0 <_x87jcc>
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  ef79 <_x87_bgti_d+0x79>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_x87_bgti_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x7, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_inquire_context (OM_uint32 * minor_status,
       const gss_ctx_id_t context_handle,
       gss_name_t * src_name,
       gss_name_t * targ_name,
       OM_uint32 * lifetime_rec,
       gss_OID * mech_type,
       OM_uint32 * ctx_flags, int *locally_initiated, int *open)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 10
2 10
3 10
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x1028(%rsi),%edx
mov    0x102c(%rsi),%esi
cmp    %esi,%edx
jae    3e70 <is_ungetc+0x40>
mov    0x1020(%rbx),%rax
lea    0x1(%rdx),%ecx
mov    %ecx,0x1028(%rbx)
mov    %bpl,(%rax,%rdx,1)
add    $0x8,%rsp
pop    %rbx
mov    $0x1,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x1020(%rbx),%rdi
add    $0x400,%esi
mov    %esi,0x102c(%rbx)
callq  3e88 <is_ungetc+0x58>
mov    0x1028(%rbx),%edx
mov    %rax,0x1020(%rbx)
jmp    3e52 <is_ungetc+0x22>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_ungetc (int ch, InputStream *is)
{
  if (is->unget_pos >= is->unget_alloc)
    {
      is->unget_alloc += 1024;
      is->unget_ch = xrealloc (is->unget_ch, is->unget_alloc);
    }
  is->unget_ch[is->unget_pos++] = ch;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 10
20 6
21 5
22 5
23 6
24 6
25 6
26 6
27 6
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
push   %rbx
sub    $0x8,%rsp
mov    0x38(%rdi),%rbp
mov    0x0(%rbp),%rdi
callq  745 <__bt_dnpage+0x15>
test   %rax,%rax
mov    %rax,%rbx
je     770 <__bt_dnpage+0x40>
mov    %rax,%rdi
callq  755 <__bt_dnpage+0x25>
mov    0x0(%rbp),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
pop    %rbp
xor    %edx,%edx
jmpq   769 <__bt_dnpage+0x39>
nopl   0x0(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__bt_dnpage(dbp, pgno)
 DB *dbp;
 u_int32_t pgno;
{
 BTREE *t;
 PAGE *h;
 t = dbp->internal;
 if ((h = mpool_get(t->bt_mp, pgno, 0)) != ((void *)0)) {
  __bt_dpage(h);
  (void)mpool_put(t->bt_mp, h, 0);
 }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 7
6 8
7 8
8 8
9 8
10 8
11 9
12 9
13 10
14 12
15 10
16 12
17 12
18 10
19 10
20 10
21 12
22 12
23 12
24 12
25 12
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,0x50(%rdi)
mov    %rdi,%rbx
je     30 <__rdbclose+0x30>
cmpb   $0x0,0x78(%rdi)
jne    38 <__rdbclose+0x38>
mov    0x48(%rbx),%rdi
xor    %eax,%eax
callq  1b <__rdbclose+0x1b>
cmp    $0xffffffff,%eax
je     30 <__rdbclose+0x30>
movb   $0x0,0x50(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  3d <__rdbclose+0x3d>
mov    0x48(%rbx),%rdi
xor    %eax,%eax
callq  48 <__rdbclose+0x48>
cmp    $0xffffffff,%eax
jne    20 <__rdbclose+0x20>
jmp    30 <__rdbclose+0x30>
<<<sep_in_sample>>>
__rdbclose (__bs10FILE *p)
{
  if (((__bs1FILE *) p)->open)
    {
      if (p->locked)
 (void) __rdbunlock (p);
      if (fclose (((__bs1FILE *) p)->file) == (-1))
 return (0);
      ((__bs1FILE *) p)->open = 0;
      return (1);
    }
  else
    return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 10
14 14
15 14
16 14
17 13
18 14
19 14
20 14
21 6
22 7
23 7
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    $0x0,%esi
callq  a1 <page_range_free+0x11>
mov    %rbx,%rdi
pop    %rbx
jmpq   aa <page_range_free+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
page_range_free (struct page_range * page_range)
{
  da_free (page_range->intervals, (da_map_func_t) free);
  free (page_range);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 4
9 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x320(%rdi),%rax
mov    0x368(%rax),%rax
test   %rax,%rax
jle    60 <countOrdinance+0x60>
shl    $0x5,%rax
lea    0x870(%rdi),%rbx
mov    %rsi,%r12
lea    0x870(%rdi,%rax,1),%r13
xor    %ebp,%ebp
nopl   (%rax)
mov    (%rbx),%rdi
mov    %r12,%rsi
callq  43 <countOrdinance+0x43>
cmp    $0x1,%eax
adc    $0x0,%ebp
add    $0x20,%rbx
cmp    %r13,%rbx
jne    38 <countOrdinance+0x38>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
add    $0x8,%rsp
xor    %ebp,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
<<<sep_in_sample>>>
countOrdinance(craft * c, char *type)
{
 register int i, count = 0;
 for (i = 0; i < c->cinfo->sCount; ++i) {
  if (strcmp(c->station[i].type, type) == 0)
   ++count;
 }
 return count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 3
15 3
16 5
17 5
18 5
19 6
20 6
21 6
22 4
23 4
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 3
34 9
35 9
36 9
37 9
38 9
39 9
40 9
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   1bd9 <xformat_get_tar_chksum+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_get_tar_chksum (XFORMAT * xux, void * tarhdr)
{
 ;
 return ahs_get_tar_chksum(xux->ahsM, tarhdr);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rdi
callq  18 <osip_message_set_accept+0x18>
test   %eax,%eax
mov    %eax,%ebx
je     30 <osip_message_set_accept+0x30>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
mov    %r12,%rsi
callq  3d <osip_message_set_accept+0x3d>
test   %eax,%eax
mov    %eax,%r12d
jne    70 <osip_message_set_accept+0x70>
mov    0x8(%rsp),%rsi
lea    0x28(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
mov    $0xffffffff,%edx
callq  61 <osip_message_set_accept+0x61>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
mov    %r12d,%ebx
callq  7d <osip_message_set_accept+0x7d>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_set_accept (osip_message_t * sip, const char *hvalue)
{
  osip_accept_t *accept;
  int i;
  i = osip_content_type_init(&accept);
  if (i != 0)
    return i;
  i = osip_content_type_parse(accept, hvalue);
  if (i != 0) {
    osip_content_type_free (accept);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->accepts, accept, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 5
11 6
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 8
20 8
21 8
22 9
23 8
24 9
25 14
26 14
27 13
28 14
29 14
30 16
31 16
32 16
33 16
34 16
35 16
36 16
37 10
38 11
39 10
40 16
41 16
42 16
43 16
44 16
45 16
46 16
<<<sep_out_sample>>>
sub    $0xe8,%rsp
test   %al,%al
mov    %rdi,0x8(%rsp)
mov    %rdx,0x40(%rsp)
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
je     5e <__gmp_sprintf+0x5e>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rdx
lea    0x18(%rsp),%rcx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
movl   $0x10,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
mov    %rax,0x28(%rsp)
callq  9c <__gmp_sprintf+0x9c>
add    $0xe8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_sprintf (char *buf, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doprnt (&__gmp_sprintf_funs, &buf, fmt, ap);
  __builtin_va_end(ap);
  do {} while (0);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 2
19 6
20 6
21 6
22 5
23 5
24 5
25 5
26 5
27 6
28 10
29 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # be6 <GetNModelVars+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetNModelVars (void)
{
  return (vnModelVars);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_response (osip_authorization_t * authorization)
{
  return authorization->response;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # c8 <initialize_aliases+0x8>
je     d0 <initialize_aliases+0x10>
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x40,%edi
callq  de <initialize_aliases+0x1e>
mov    %rax,0x0(%rip)        # e5 <initialize_aliases+0x25>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initialize_aliases ()
{
  if (aliases == 0)
    aliases = hash_create (64);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 2
6 4
7 4
8 4
9 5
10 5
11 5
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  de5 <gsl_stats_char_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  df8 <gsl_stats_char_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  e15 <gsl_stats_char_ttest+0x55>
test   %rbp,%rbp
js     e78 <gsl_stats_char_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # e27 <gsl_stats_char_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     e98 <gsl_stats_char_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     eb2 <gsl_stats_char_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    e1f <gsl_stats_char_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    e39 <gsl_stats_char_ttest+0x79>
test   %rbp,%rbp
js     eec <gsl_stats_char_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     f03 <gsl_stats_char_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  ee3 <gsl_stats_char_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   e57 <gsl_stats_char_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    ebc <gsl_stats_char_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    ece <gsl_stats_char_ttest+0x10e>
<<<sep_in_sample>>>
gsl_stats_char_ttest (const char data1[],
                           const size_t stride1, const size_t n1,
                           const char data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_char_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_char_mean (data2, stride2, n2);
  const double pv = gsl_stats_char_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3ac <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%r8
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3dd <version_etc+0x7d>
add    $0xd8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 7
16 6
17 6
18 6
19 6
20 6
21 7
22 9
23 9
24 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # e97 <chdir_count+0x7>
xor    %eax,%eax
lea    -0x1(%rdx),%ecx
test   %rdx,%rdx
cmovne %ecx,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chdir_count (void)
{
  if (wd_count == 0)
    return wd_count;
  return wd_count - 1;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
test   %rcx,%rcx
je     13990 <gsl_fft_real_float_unpack+0x40>
lea    0x0(,%rdx,4),%r8
xor    %eax,%eax
shl    $0x3,%rdx
nopl   0x0(%rax,%rax,1)
movss  (%rdi),%xmm0
add    $0x1,%rax
movss  %xmm0,(%rsi)
movl   $0x0,0x4(%rsi)
add    %r8,%rdi
add    %rdx,%rsi
cmp    %rcx,%rax
jne    13968 <gsl_fft_real_float_unpack+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x1,%cl
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  139aa <gsl_fft_real_float_unpack+0x5a>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_real_float_unpack (const float real_coefficient[],
                               float complex_coefficient[],
                               const size_t stride, const size_t n)
{
  size_t i;
  if (n == 0)
    {
      do { gsl_error ("length n must be positive integer", "real_unpack.c", 31, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  for (i = 0; i < n; i++)
    {
      ((complex_coefficient)[2*(stride)*(i)]) = real_coefficient[i * stride];
      ((complex_coefficient)[2*(stride)*(i)+1]) = 0.0;
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 12
8 10
9 12
10 13
11 13
12 13
13 10
14 10
15 15
16 15
17 15
18 4
19 8
20 8
21 8
22 8
23 8
24 8
25 16
26 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8a8 <mu_folder_unsubscribe+0x18>
mov    0x90(%rdi),%rax
test   %rax,%rax
je     8a8 <mu_folder_unsubscribe+0x18>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_folder_unsubscribe (mu_folder_t folder, const char *name)
{
  if (folder == ((void *)0) || folder->_unsubscribe == ((void *)0))
    return 22;
  return folder->_unsubscribe (folder, name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   66d <savedir_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
savedir_error (char const *name)
{
  call_arg_error ("savedir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
xor    %edi,%edi
jmpq   1ab7 <swpath_shallow_create_export+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swpath_shallow_create_export(void)
{
 return swpath_create_export(((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 856 <grecs_grecs_get_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_get_debug (void)
{
        return grecs_grecs__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  72a9 <initialize_pager+0x9>
mov    %eax,%edi
callq  72b0 <initialize_pager+0x10>
test   %eax,%eax
je     72c7 <initialize_pager+0x27>
cmpb   $0x0,0x0(%rip)        # 72bb <initialize_pager+0x1b>
je     72c7 <initialize_pager+0x27>
mov    0x0(%rip),%eax        # 72c3 <initialize_pager+0x23>
test   %eax,%eax
je     72f0 <initialize_pager+0x50>
movl   $0x7fffffff,0x0(%rip)        # 72d1 <initialize_pager+0x31>
movl   $0x7fffffff,0x0(%rip)        # 72db <initialize_pager+0x3b>
movl   $0x0,0x0(%rip)        # 72e5 <initialize_pager+0x45>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %edi,%edi
callq  72f7 <initialize_pager+0x57>
mov    $0x0,%esi
mov    $0x0,%edi
callq  7306 <initialize_pager+0x66>
cmpl   $0x1,0x0(%rip)        # 730d <initialize_pager+0x6d>
jle    7328 <initialize_pager+0x88>
cmpl   $0x1,0x0(%rip)        # 7316 <initialize_pager+0x76>
jg     72db <initialize_pager+0x3b>
movl   $0x7fffffff,0x0(%rip)        # 7322 <initialize_pager+0x82>
jmp    72db <initialize_pager+0x3b>
nopl   0x0(%rax)
movl   $0x7fffffff,0x0(%rip)        # 7332 <initialize_pager+0x92>
jmp    730f <initialize_pager+0x6f>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initialize_pager(FILE *fp)
{
 if (! os_isatty(fileno(fp)) || ! input_from_tty || input_fd != 0) {
  screen_width = 2147483647;
  screen_height = 2147483647;
 } else {
  rl_reset_terminal(((void *)0));
  rl_get_screen_size(&screen_height, &screen_width);
  if (screen_height <= 1)
   screen_height = 2147483647;
  if (screen_width <= 1)
   screen_width = 2147483647;
 }
 pager_lines_printed = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 5
14 14
15 15
16 15
17 15
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 11
26 11
27 12
28 12
29 12
30 10
31 10
32 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 207 <valcpy+0x7>
movslq %edi,%rax
lea    0x0(,%rax,4),%rcx
cmpl   $0x0,(%rdx,%rax,4)
jg     250 <valcpy+0x50>
push   %rbx
je     238 <valcpy+0x38>
mov    0x0(%rip),%rdx        # 222 <valcpy+0x22>
mov    %rsi,%rdi
lea    (%rdx,%rax,8),%rbx
callq  22e <valcpy+0x2e>
movsd  %xmm0,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rcx,%rbx
add    0x0(%rip),%rbx        # 242 <valcpy+0x42>
mov    %rsi,%rdi
callq  24a <valcpy+0x4a>
mov    %eax,(%rbx)
pop    %rbx
retq   
xchg   %ax,%ax
mov    0x0(%rip),%rdx        # 257 <valcpy+0x57>
mov    (%rdx,%rax,8),%rdi
jmpq   260 <pctiles>
<<<sep_in_sample>>>
valcpy(int v, char *val)
{
  if (dap_obs[0].do_len[v] > 0)
    strcpy(dap_obs[0].do_str[v], val);
  else if (dap_obs[0].do_len[v] == 0)
    dap_obs[0].do_int[v] = atoi(val);
  else
    dap_obs[0].do_dbl[v] = atof(val);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 5
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 6
17 6
18 6
19 6
20 6
21 9
22 9
23 9
24 4
25 4
26 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
jmpq   1d45 <java_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 246 <taruib_set_datalen+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taruib_set_datalen(int n)
{
 g_taruib_gst_lenM = n;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    3578 <gsl_vector_short_set_basis+0x48>
add    %rdi,%rdi
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     3563 <gsl_vector_short_set_basis+0x33>
nopl   (%rax)
xor    %r9d,%r9d
add    $0x1,%rax
mov    %r9w,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    3550 <gsl_vector_short_set_basis+0x20>
imul   %rsi,%rdi
mov    $0x1,%eax
mov    %ax,(%r8,%rdi,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3595 <gsl_vector_short_set_basis+0x65>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_short_set_basis (gsl_vector_short * v, size_t i)
{
  short * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const short zero = 0 ;
  const short one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(short *) (data + 1 * k * stride) = zero;
    }
  *(short *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 15
13 13
14 15
15 15
16 13
17 13
18 17
19 17
20 17
21 18
22 18
23 18
24 2
25 11
26 11
27 11
28 11
29 11
30 11
31 19
32 19
33 19
<<<sep_out_sample>>>
mov    0x48(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x38,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
control_set_driver_null (void *vstate, const gsl_odeiv2_driver * d)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # b1 <history_total_bytes+0x11>
test   %rbp,%rbp
je     105 <history_total_bytes+0x65>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     105 <history_total_bytes+0x65>
add    $0x8,%rbp
xor    %r12d,%r12d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rdi
add    $0x8,%rbp
callq  dc <history_total_bytes+0x3c>
mov    0x8(%rbx),%rdi
mov    %rax,%r13
callq  e8 <history_total_bytes+0x48>
mov    -0x8(%rbp),%rbx
add    %eax,%r13d
add    %r13d,%r12d
test   %rbx,%rbx
jne    d0 <history_total_bytes+0x30>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    f7 <history_total_bytes+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 5
23 5
24 4
25 4
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 4
34 4
35 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  387f <gsl_matrix_short_calloc+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     38c7 <gsl_matrix_short_calloc+0x57>
imul   %r12,%rbp
mov    0x18(%rax),%rdi
xor    %esi,%esi
lea    0x0(%rbp,%rbp,1),%r12
mov    %r12,%rdx
callq  389e <gsl_matrix_short_calloc+0x2e>
test   %rbp,%rbp
je     38bf <gsl_matrix_short_calloc+0x4f>
mov    0x18(%rbx),%rcx
lea    (%r12,%rcx,1),%rdx
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x2,%rcx
mov    %ax,-0x2(%rcx)
cmp    %rdx,%rcx
jne    38b0 <gsl_matrix_short_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    38c2 <gsl_matrix_short_calloc+0x52>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_calloc (const size_t n1, const size_t n2)
{
  size_t i;
  gsl_matrix_short * m = gsl_matrix_short_alloc (n1, n2);
  if (m == 0)
    return 0;
  memset(m->data, 0, 1 * n1 * n2 * sizeof(short));
  for (i = 0; i < 1 * n1 * n2; i++)
    {
      m->data[i] = 0;
    }
  return m;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 8
25 8
26 8
27 13
28 13
29 13
30 13
31 6
32 6
33 6
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  98f <rl_replace_line+0xf>
cmp    0x0(%rip),%eax        # 995 <rl_replace_line+0x15>
mov    %rax,%rbx
jge    9d0 <rl_replace_line+0x50>
mov    0x0(%rip),%rdi        # 9a1 <rl_replace_line+0x21>
mov    %rbp,%rsi
callq  9a9 <rl_replace_line+0x29>
test   %r12d,%r12d
mov    %ebx,0x0(%rip)        # 9b2 <rl_replace_line+0x32>
je     9b9 <rl_replace_line+0x39>
callq  9b9 <rl_replace_line+0x39>
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x1,%edi
jmpq   9c7 <rl_replace_line+0x47>
nopw   0x0(%rax,%rax,1)
mov    %eax,%edi
callq  9d7 <rl_replace_line+0x57>
jmp    99a <rl_replace_line+0x1a>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_replace_line (text, clear_undo)
     const char *text;
     int clear_undo;
{
  int len;
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
  rl_end = len;
  if (clear_undo)
    rl_free_undo_list ();
  _rl_fix_point (1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 6
9 7
10 9
11 9
12 9
13 11
14 10
15 11
16 12
17 14
18 14
19 14
20 13
21 13
22 13
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <ppd_load_buffer_state+0x7>
mov    0x0(%rip),%rdx        # e <ppd_load_buffer_state+0xe>
lea    (%rax,%rdx,8),%rdx
mov    (%rdx),%rax
mov    0x1c(%rax),%ecx
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # 23 <ppd_load_buffer_state+0x23>
mov    (%rdx),%rdx
mov    %rax,0x0(%rip)        # 2d <ppd_load_buffer_state+0x2d>
mov    %ecx,0x0(%rip)        # 33 <ppd_load_buffer_state+0x33>
mov    (%rdx),%rdx
mov    %rdx,0x0(%rip)        # 3d <ppd_load_buffer_state+0x3d>
movzbl (%rax),%eax
mov    %al,0x0(%rip)        # 46 <ppd_load_buffer_state+0x46>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppd_load_buffer_state (void)
{
     (yy_n_chars) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_n_chars;
 (ppdtext) = (yy_c_buf_p) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_buf_pos;
 ppdin = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_input_file;
 (yy_hold_char) = *(yy_c_buf_p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 3
11 5
12 5
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
movsd  0x0(%rip),%xmm3        # 3fc <gsl_odeiv2_control_yp_new+0xc>
jmpq   401 <gsl_odeiv2_control_yp_new+0x11>
<<<sep_in_sample>>>
gsl_odeiv2_control_yp_new (double eps_abs, double eps_rel)
{
  return gsl_odeiv2_control_standard_new (eps_abs, eps_rel, 0.0, 1.0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    (%rsi),%rdx
sub    $0x1,%rcx
sub    $0x1,%rdx
jmp    224 <font_info_hash_cmp+0x14>
cmp    (%rdx),%al
jne    235 <font_info_hash_cmp+0x25>
add    $0x1,%rcx
movzbl (%rcx),%eax
add    $0x1,%rdx
test   %al,%al
jne    220 <font_info_hash_cmp+0x10>
xor    %eax,%eax
movzbl (%rdx),%edx
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
font_info_hash_cmp (struct font_info *x, struct font_info *y)
{
  do { int result; do { unsigned char const *xx = (unsigned char const *) (x->key) - 1; unsigned char const *yy = (unsigned char const *) (y->key) - 1; do { if (*++xx == '\0') { yy++; break; } } while (*xx == *++yy); (result) = *xx - *yy; } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_isnonneg (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 18
2 18
3 18
<<<sep_out_sample>>>
mov    %edi,%eax
not    %eax
shr    $0x1f,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_normed_time (n_time t)
{
  return (t & (1UL << 31)) ? 0 : 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
test   %rdx,%rdx
je     71 <full_read+0x71>
mov    %edi,%r13d
mov    %rsi,%rbp
xor    %r12d,%r12d
jmp    30 <full_read+0x30>
nopl   (%rax)
test   %rax,%rax
je     58 <full_read+0x58>
add    %rax,%r12
add    %rax,%rbp
sub    %rax,%rbx
je     44 <full_read+0x44>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r13d,%edi
callq  3e <full_read+0x3e>
cmp    $0xffffffffffffffff,%rax
jne    20 <full_read+0x20>
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
callq  5d <full_read+0x5d>
movl   $0x0,(%rax)
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    44 <full_read+0x44>
<<<sep_in_sample>>>
full_read (int fd, void *buf, size_t count)
{
  size_t total = 0;
  char *ptr = ( char *) buf;
  while (count > 0)
    {
      size_t n_rw = safe_read (fd, ptr, count);
      if (n_rw == (size_t) -1)
 break;
      if (n_rw == 0)
 {
   (*__errno_location ()) = 0;
   break;
 }
      total += n_rw;
      ptr += n_rw;
      count -= n_rw;
    }
  return total;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 3
12 3
13 3
14 10
15 10
16 15
17 16
18 5
19 5
20 7
21 7
22 7
23 7
24 8
25 8
26 20
27 20
28 20
29 20
30 20
31 20
32 20
33 20
34 12
35 12
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 3
44 3
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 1a <dico_markup_lookup+0xa>
jmpq   1f <dico_markup_lookup+0xf>
nop
<<<sep_in_sample>>>
dico_markup_lookup(const char *name)
{
    return dico_list_locate(dico_markup_list, (void *)name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
movl   $0x0,(%rdx)
mov    %rdx,%rcx
movb   $0x0,(%rdi)
mov    $0x0,%r8d
mov    $0x3e8,%edx
jmpq   3e0 <doExhaustFd_i.isra.0.constprop.3>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swgpReadFdNonblock(char * pipe_buf, int fd_from, int * len)
{
 int ret;
 *len = 0;
 *pipe_buf = '\0';
 ret = doExhaustFd_i((void*)pipe_buf, fd_from,
  "ret2", 0, 1000, len,
  (ssize_t(*)(int, void *, size_t))(uxfio_unix_safe_read));
 return ret;
}
<<<sep_in_sample>>>
1 4
2 6
3 5
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
jmpq   19e5 <asm_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
mov    %edi,%r12d
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 16de <run_ext_exit_handlers+0xe>
test   %rbx,%rbx
jne    16eb <run_ext_exit_handlers+0x1b>
jmp    1705 <run_ext_exit_handlers+0x35>
nopl   (%rax)
mov    %rbp,%rbx
mov    (%rbx),%rbp
mov    0x10(%rbx),%rdi
mov    %r12d,%esi
callq  *0x8(%rbx)
mov    %rbx,%rdi
callq  1700 <run_ext_exit_handlers+0x30>
test   %rbp,%rbp
jne    16e8 <run_ext_exit_handlers+0x18>
pop    %rbx
pop    %rbp
movq   $0x0,0x0(%rip)        # 1712 <run_ext_exit_handlers+0x42>
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
run_ext_exit_handlers(int exitval)
{
 struct ext_exit_handler *p, *next;
 for (p = list_head; p != ((void *)0); p = next) {
  next = p->next;
  p->funcp(p->arg0, exitval);
  free(p);
 }
 list_head = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 6
13 6
14 6
15 7
16 7
17 4
18 4
19 10
20 10
21 9
22 10
23 10
24 10
<<<sep_out_sample>>>
jmpq   55 <crlf+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 5f9 <asm_restart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     630 <asm_restart+0x40>
mov    0x0(%rip),%rdx        # 60a <asm_restart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     630 <asm_restart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  520 <asm__init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   0 <asm__load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  170 <asm_ensure_buffer_stack>
mov    0x0(%rip),%rbp        # 63c <asm_restart+0x4c>
mov    0x0(%rip),%rax        # 643 <asm_restart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 64f <asm_restart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  659 <asm_restart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    613 <asm_restart+0x23>
jmp    616 <asm_restart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_restart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        asm_ensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            asm__create_buffer(asm_in,16384 );
 }
 asm__init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 asm__load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
xor    %edi,%edi
sub    $0x50,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
callq  1f34 <mu_rfc2822_msg_id+0x24>
lea    0x8(%rsp),%rdi
mov    %rax,0x8(%rsp)
callq  1f43 <mu_rfc2822_msg_id+0x33>
lea    0x30(%rsp),%rdi
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0xf,%esi
callq  1f5a <mu_rfc2822_msg_id+0x4a>
lea    0x10(%rsp),%rdi
callq  1f64 <mu_rfc2822_msg_id+0x54>
test   %ebx,%ebx
jne    1fc0 <mu_rfc2822_msg_id+0xb0>
mov    0x10(%rsp),%rbx
callq  1f72 <mu_rfc2822_msg_id+0x62>
lea    0x30(%rsp),%rdx
lea    0x18(%rsp),%rdi
movslq %eax,%rcx
mov    %rbx,%r8
mov    $0x0,%esi
xor    %eax,%eax
callq  1f8e <mu_rfc2822_msg_id+0x7e>
mov    0x10(%rsp),%rdi
callq  1f98 <mu_rfc2822_msg_id+0x88>
mov    0x18(%rsp),%rax
mov    %rax,0x0(%rbp)
xor    %eax,%eax
mov    0x48(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    1ff7 <mu_rfc2822_msg_id+0xe7>
add    $0x50,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
lea    0x20(%rsp),%rdi
xor    %esi,%esi
callq  1fcc <mu_rfc2822_msg_id+0xbc>
mov    0x10(%rsp),%r12
callq  1fd6 <mu_rfc2822_msg_id+0xc6>
lea    0x30(%rsp),%rdx
lea    0x18(%rsp),%rdi
movslq %eax,%rcx
mov    %r12,%r9
mov    %ebx,%r8d
mov    $0x0,%esi
xor    %eax,%eax
callq  1ff5 <mu_rfc2822_msg_id+0xe5>
jmp    1f8e <mu_rfc2822_msg_id+0x7e>
callq  1ffc <mu_rfc2822_msg_id+0xec>
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_rfc2822_msg_id (int subpart, char **pval)
{
  char date[4+2+2+2+2+2+1];
  time_t t = time (((void *)0));
  struct tm *tm = localtime (&t);
  char *host;
  char *p;
  mu_strftime (date, sizeof date, "%Y%m%d%H%M%S", tm);
  mu_get_host_name (&host);
  if (subpart)
    {
      struct timeval tv;
      gettimeofday (&tv, ((void *)0));
      mu_asprintf (&p, "<%s.%lu.%d@%s>",
     date,
     (unsigned long) getpid (),
     subpart,
     host);
    }
  else
    mu_asprintf (&p, "<%s.%lu@%s>", date, (unsigned long) getpid (), host);
  free (host);
  *pval = p;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 2
8 2
9 2
10 2
11 4
12 5
13 4
14 5
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 10
23 10
24 21
25 21
26 21
27 21
28 21
29 21
30 21
31 21
32 21
33 22
34 22
35 23
36 23
37 25
38 25
39 25
40 25
41 25
42 25
43 25
44 25
45 25
46 25
47 13
48 13
49 13
50 14
51 16
52 14
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 14
61 25
62 25
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbx
mov    0x20(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    580 <hash_map_arg+0x40>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     577 <hash_map_arg+0x37>
cmp    0x0(%rip),%rdi        # 56f <hash_map_arg+0x2f>
je     577 <hash_map_arg+0x37>
mov    %r12,%rsi
callq  *%r13
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     560 <hash_map_arg+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_map_arg (struct hash_table *ht, hash_map_arg_func_t map, void *arg)
{
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  for (slot = ht->ht_vec; slot < end; slot++)
    {
      if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
 (*map) (*slot, arg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 5
21 5
22 5
23 10
24 10
25 10
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  6c <scram_free_server_first+0xc>
mov    0x8(%rbx),%rdi
callq  75 <scram_free_server_first+0x15>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
scram_free_server_first (struct scram_server_first *sf)
{
  free (sf->nonce);
  free (sf->salt);
  memset (sf, 0, sizeof (*sf));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rdi
callq  10 <_registrar_get_list.part.0>
mov    0x8(%rsp),%rdi
mov    %rbx,%rsi
callq  32f <mu_unregistrar_record+0x1f>
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_unregistrar_record (mu_record_t record)
{
  mu_list_t list;
  _registrar_get_list (&list);
  mu_list_remove (list, record);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
cmp    $0x1,%edi
ja     d <system_quote_length+0xd>
mov    %rsi,%rdi
jmpq   d <system_quote_length+0xd>
push   %rax
callq  13 <system_quote_length+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_quote_length (enum system_command_interpreter interpreter,
                     const char *string)
{
  switch (interpreter)
    {
    case SCI_SYSTEM:
    case SCI_POSIX_SH:
      return shell_quote_length (string);
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 8
4 8
5 3
6 10
7 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
cmp    %rax,0x8(%rdi)
sete   %al
movzbl %al,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
finished_p (void *owner)
{
  struct list_iterator *itr = owner;
  return itr->cur == &itr->list->head;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%eax        # 4ea <gpath_close+0x1a>
test   %eax,%eax
jle    5a9 <gpath_close+0xd9>
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,0x0(%rip)        # 4fd <gpath_close+0x2d>
je     520 <gpath_close+0x50>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    5c2 <gpath_close+0xf2>
add    $0x38,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 526 <gpath_close+0x56>
cmp    $0x1,%eax
je     558 <gpath_close+0x88>
cmp    $0x2,%eax
je     562 <gpath_close+0x92>
mov    0x0(%rip),%rdi        # 537 <gpath_close+0x67>
callq  53c <gpath_close+0x6c>
cmpl   $0x1,0x0(%rip)        # 543 <gpath_close+0x73>
jne    4ff <gpath_close+0x2f>
movl   $0x1,0x0(%rip)        # 54f <gpath_close+0x7f>
jmp    4ff <gpath_close+0x2f>
nopl   0x0(%rax)
mov    0x0(%rip),%eax        # 55e <gpath_close+0x8e>
test   %eax,%eax
jne    598 <gpath_close+0xc8>
mov    0x0(%rip),%ecx        # 568 <gpath_close+0x98>
mov    %rsp,%rdi
mov    $0x0,%edx
mov    $0x20,%esi
xor    %eax,%eax
callq  57c <gpath_close+0xac>
mov    0x0(%rip),%rdi        # 583 <gpath_close+0xb3>
mov    %rsp,%rdx
mov    $0x0,%esi
callq  590 <gpath_close+0xc0>
jmp    530 <gpath_close+0x60>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 59f <gpath_close+0xcf>
callq  5a4 <gpath_close+0xd4>
jmpq   4ff <gpath_close+0x2f>
mov    $0x0,%ecx
mov    $0x106,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5c2 <gpath_close+0xf2>
callq  5c7 <gpath_close+0xf7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_close(void)
{
 char fid[32];
 ((opened > 0) ? (void) (0) : __assert_fail ("opened > 0", "gpathop.c", 262, __PRETTY_FUNCTION__));
 if (--opened > 0)
  return;
 if (_mode == 1 && created) {
  dbop_close(dbop);
  return;
 }
 if (_mode == 1 || _mode == 2) {
  snprintf(fid, sizeof(fid), "%d", _nextkey);
  dbop_update(dbop, " __.NEXTKEY", fid);
 }
 dbop_close(dbop);
 if (_mode == 1)
  created = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 18
13 18
14 18
15 18
16 18
17 18
18 7
19 7
20 7
21 11
22 11
23 15
24 15
25 16
26 16
27 17
28 17
29 17
30 7
31 7
32 7
33 12
34 12
35 12
36 12
37 12
38 12
39 13
40 13
41 13
42 13
43 13
44 13
45 8
46 8
47 9
48 4
49 4
50 4
51 4
52 4
53 18
54 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
callq  202 <mypclose+0x12>
mov    %rbp,%rdi
movslq %eax,%rbx
callq  20d <mypclose+0x1d>
mov    $0x1,%esi
mov    $0x2,%edi
callq  21c <mypclose+0x2c>
mov    $0x1,%esi
mov    $0x3,%edi
mov    %rax,%r13
callq  22e <mypclose+0x3e>
mov    $0x1,%esi
mov    $0x1,%edi
mov    %rax,%r12
callq  240 <mypclose+0x50>
mov    %rax,%rbp
jmp    24d <mypclose+0x5d>
nopl   (%rax)
cmp    $0xffffffff,%eax
je     2c0 <mypclose+0xd0>
lea    0xc(%rsp),%rdi
callq  257 <mypclose+0x67>
cmp    0x0(,%rbx,4),%eax
jne    248 <mypclose+0x58>
cmp    $0xffffffff,%eax
je     2c0 <mypclose+0xd0>
mov    %r13,%rsi
mov    $0x2,%edi
callq  272 <mypclose+0x82>
mov    %r12,%rsi
mov    $0x3,%edi
callq  27f <mypclose+0x8f>
mov    %rbp,%rsi
mov    $0x1,%edi
callq  28c <mypclose+0x9c>
mov    0x0(%rip),%rsi        # 293 <mypclose+0xa3>
mov    $0x14,%edi
callq  29d <mypclose+0xad>
movl   $0x0,0x0(,%rbx,4)
mov    0xc(%rsp),%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
movl   $0xffffffff,0xc(%rsp)
jmp    265 <mypclose+0x75>
<<<sep_in_sample>>>
mypclose(FILE *ptr)
{
 int f;
 pid_t r;
 int status;
 sighandler_t hstat, istat, qstat;
 f = fileno(ptr);
 (void) fclose(ptr);
 istat = signal(2, ((__sighandler_t) 1));
 qstat = signal(3, ((__sighandler_t) 1));
 hstat = signal(1, ((__sighandler_t) 1));
 while((r = wait(&status)) != popen_pid[f] && r != -1)
  ;
 if(r == -1)
  status = -1;
 (void) signal(2, istat);
 (void) signal(3, qstat);
 (void) signal(1, hstat);
 (void) signal(20, tstat);
 popen_pid[f] = 0;
 return(status);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 8
9 7
10 8
11 9
12 9
13 9
14 10
15 10
16 9
17 10
18 11
19 11
20 10
21 11
22 11
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 14
32 14
33 16
34 16
35 16
36 17
37 17
38 17
39 18
40 18
41 18
42 19
43 19
44 19
45 20
46 22
47 22
48 22
49 22
50 22
51 22
52 22
53 22
54 15
55 15
<<<sep_out_sample>>>
mov    %esi,%ecx
mov    %rdx,%r8
mov    $0x0,%esi
mov    $0x0,%edx
jmpq   80 <find_lsn_recurse>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_fs_find_lsn_with_path(CdIo_t *p_cdio, lsn_t i_lsn,
                 char **ppsz_full_filename)
{
  return find_lsn_recurse (p_cdio, (iso9660_readdir_t *) iso9660_fs_readdir,
      "/", i_lsn, ppsz_full_filename);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0xc(%rsp),%rdi
callq  12 <printf_frexp+0x12>
mov    0xc(%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,0xc(%rsp)
jge    38 <printf_frexp+0x38>
lea    0x3fd(%rdx),%edi
callq  33 <printf_frexp+0x33>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  139c <shcmd_set_dstfile+0xc>
mov    %rax,0x38(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shcmd_set_dstfile(SHCMD * shcmd, char * name)
{
 shcmd->dstfile_ = strdup(name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
xor    %edi,%edi
callq  880 <unbind_args+0x10>
add    $0x8,%rsp
jmpq   889 <unbind_args+0x19>
nopl   0x0(%rax)
<<<sep_in_sample>>>
unbind_args ()
{
  remember_args ((WORD_LIST *)((void *)0), 1);
  pop_args ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 4
7 4
<<<sep_out_sample>>>
test   %r8,%r8
je     50 <gsl_stats_long_double_wmean+0x50>
fldz   
shl    $0x4,%rsi
shl    $0x4,%rcx
xor    %eax,%eax
fld    %st(0)
fld    %st(1)
nopl   (%rax)
fldt   (%rdi)
fucomi %st(3),%st
jbe    30 <gsl_stats_long_double_wmean+0x30>
fadd   %st,%st(2)
fldt   (%rdx)
fsub   %st(2),%st
fxch   %st(1)
fdiv   %st(3),%st
fmulp  %st,%st(1)
faddp  %st,%st(1)
jmp    32 <gsl_stats_long_double_wmean+0x32>
xchg   %ax,%ax
fstp   %st(0)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    18 <gsl_stats_long_double_wmean+0x18>
fstp   %st(1)
fstp   %st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_wmean (const long double w[], const size_t wstride, const long double data[], const size_t stride, const size_t size)
{
  long double wmean = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      long double wi = w[i * wstride];
      if (wi > 0)
        {
          W += wi;
          wmean += (data[i * stride] - wmean) * (wi / W);
        }
    }
  return wmean;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 4
5 12
6 6
7 4
8 3
9 3
10 8
11 9
12 9
13 11
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 16
35 16
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
and    $0x1ff,%si
mov    %rdi,%rbx
sub    $0x8,%rsp
movzwl 0xa8(%rdi),%eax
movzbl 0x82(%rdi),%r9d
movzbl 0x81(%rdi),%r8d
movzbl 0x80(%rdi),%ecx
movzbl 0x79(%rdi),%edx
and    $0xfe00,%ax
or     %esi,%eax
movzbl 0x78(%rdi),%esi
mov    %ax,0xa8(%rdi)
mov    0xa8(%rbx),%eax
mov    0x1c(%rdi),%edi
mov    %eax,(%rsp)
callq  1570 <simplify_attributes.isra.1>
mov    %eax,0xac(%rbx)
add    $0x8,%rsp
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
term_ostream__set_color (term_ostream_t stream, term_color_t color)
{
  stream->curr_attr.color = color;
  stream->simp_attr = simplify_attributes (stream, stream->curr_attr);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 4
7 4
8 4
9 4
10 3
11 3
12 4
13 3
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 87 <alog_remote_user+0x7>
jmpq   0 <print_str>
nopl   0x0(%rax)
<<<sep_in_sample>>>
alog_remote_user(FILE *fp, struct alog_instr *instr, int argc, char **argv)
{
    print_str(fp, user_name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    1200 <gsl_vector_long_double_set_basis+0x40>
shl    $0x4,%rdi
test   %rcx,%rcx
je     11f2 <gsl_vector_long_double_set_basis+0x32>
fldz   
mov    %r8,%rdx
xor    %eax,%eax
add    $0x1,%rax
fstpt  (%rdx)
fldt   (%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    11e0 <gsl_vector_long_double_set_basis+0x20>
fstp   %st(0)
imul   %rsi,%rdi
fld1   
xor    %eax,%eax
fstpt  (%r8,%rdi,1)
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  121d <gsl_vector_long_double_set_basis+0x5d>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_set_basis (gsl_vector_long_double * v, size_t i)
{
  long double * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const long double zero = 0.0L ;
  const long double one = 1.0L;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(long double *) (data + 1 * k * stride) = zero;
    }
  *(long double *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 13
17 13
18 13
19 17
20 17
21 18
22 17
23 18
24 18
25 2
26 11
27 11
28 11
29 11
30 11
31 11
32 19
33 19
34 19
<<<sep_out_sample>>>
mov    0x28(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x28,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  189 <_body_truncate+0x9>
mov    %rbx,%rsi
mov    0x18(%rax),%rdi
pop    %rbx
jmpq   196 <_body_truncate+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_body_truncate (mu_stream_t stream, mu_off_t n)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_truncate (body->fstream, n);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   a55 <xformat_clear_pass_buffer+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_clear_pass_buffer(XFORMAT * xux)
{
 ;
 return taruib_clear_buffer();
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x28,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  468 <read_error_details+0x28>
mov    (%rax),%ebp
mov    0x0(%rip),%rax        # 471 <read_error_details+0x31>
test   %rax,%rax
je     478 <read_error_details+0x38>
callq  *%rax
mov    %rsp,%rsi
mov    %r13,%rdi
callq  483 <read_error_details+0x43>
mov    %r12,%rdi
mov    %rax,%r13
callq  48e <read_error_details+0x4e>
mov    %rbx,%rdx
mov    %rax,%r12
mov    $0x0,%esi
mov    $0x0,%edi
callq  4a3 <read_error_details+0x63>
xor    %edi,%edi
mov    %rax,%rdx
mov    %rbx,%r9
xor    %eax,%eax
mov    %r13,%r8
mov    %r12,%rcx
mov    %ebp,%esi
callq  4ba <read_error_details+0x7a>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
movl   $0x2,0x0(%rip)        # 4d2 <read_error_details+0x92>
jne    4df <read_error_details+0x9f>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  4e4 <read_error_details+0xa4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_error_details (char const *name, off_t offset, size_t size)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, ngettext ("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes", size), quotearg_colon (name), umaxtostr (offset, buf), (unsigned long) size); exit_status = 2; } while (0)
                         ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 7
38 7
39 5
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   198 <medium_name_fputs+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
medium_name_fputs (struct medium * medium, FILE * stream)
{
  fputs (medium->name, stream);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdx,%rdx
movzbl (%rdi),%r9d
je     153d <gsl_stats_uchar_max_index+0x2d>
xor    %ecx,%ecx
nopl   (%rax)
movzbl (%rdi),%r8d
cmp    %r9b,%r8b
jbe    152f <gsl_stats_uchar_max_index+0x1f>
mov    %rcx,%rax
mov    %r8d,%r9d
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    1520 <gsl_stats_uchar_max_index+0x10>
repz retq 
repz retq 
nop
<<<sep_in_sample>>>
gsl_stats_uchar_max_index (const unsigned char data[], const size_t stride,
                                const size_t n)
{
  unsigned char max = data[0 * stride];
  size_t i, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned char xi = data[i * stride];
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  return max_index;
}
<<<sep_in_sample>>>
1 5
2 6
3 4
4 6
5 6
6 6
7 8
8 9
9 9
10 9
11 9
12 6
13 6
14 6
15 6
16 6
17 16
18 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     325d <eval_warning+0x5d>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rbp
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    0x0(%rip),%r12        # 327e <eval_warning+0x7e>
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3298 <eval_warning+0x98>
lea    0xf8(%rbx),%rsi
lea    0x8(%rsp),%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    0x0(%rip),%rdi        # 32b1 <eval_warning+0xb1>
callq  *%r12
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
eval_warning (struct eval_env *env, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc_error_printer (rc_error_printer_data, &env->loc, gettext("warning"),
      fmt, ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 4
21 2
22 5
23 4
24 4
25 5
26 4
27 4
28 4
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 8
37 8
38 8
39 8
40 8
<<<sep_out_sample>>>
push   %rbx
callq  e46 <_temp_file_open+0x6>
mov    0x18(%rax),%rdi
xor    %esi,%esi
mov    %rax,%rbx
callq  e54 <_temp_file_open+0x14>
cmp    $0xffffffff,%eax
je     e78 <_temp_file_open+0x38>
mov    $0x0,%esi
mov    %eax,%edi
callq  e65 <_temp_file_open+0x25>
xor    %edx,%edx
test   %rax,%rax
mov    %rax,(%rbx)
je     e78 <_temp_file_open+0x38>
mov    %edx,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  e7d <_temp_file_open+0x3d>
mov    (%rax),%edx
pop    %rbx
mov    %edx,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_temp_file_open (mu_stream_t stream)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  int fd;
  fd = mu_tempfile (fs->filename, ((void *)0));
  if (fd == -1)
    return (*__errno_location ());
  fs->file = fdopen (fd, "r+b");
  if (fs->file == ((void *)0))
    return (*__errno_location ());
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 3
6 5
7 6
8 6
9 8
10 8
11 8
12 11
13 9
14 8
15 9
16 12
17 12
18 12
19 12
20 10
21 10
22 12
23 12
24 12
25 12
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
mov    $0x1,%edi
push   %rbx
sub    $0x8,%rsp
callq  780 <copy_dv>
mov    %ebp,%edi
mov    %rax,%rsi
mov    %rax,%rbx
callq  630 <array_size>
test   %eax,%eax
mov    %eax,%ebp
jne    9e0 <own_same+0x40>
movq   $0x0,(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %eax,%edi
callq  5f0 <my_malloc>
movslq %ebp,%rdx
mov    %rax,(%rbx)
xor    %esi,%esi
mov    %rax,%rdi
callq  9f7 <own_same+0x57>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
own_same(int type, struct dv *dope)
{
      struct dv *dv;
      int size;
      dv = copy_dv(1, dope);
      size = array_size(type, dv);
      dv->base = size == 0 ? ((void *)0) : my_malloc(size);
      if (size != 0) memset(dv->base, 0, size);
      return dv;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 5
7 6
8 6
9 5
10 6
11 7
12 6
13 7
14 7
15 10
16 10
17 10
18 10
19 10
20 10
21 7
22 7
23 8
24 7
25 8
26 8
27 8
28 10
29 10
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rsi,%rcx
xor    %r9d,%r9d
mov    %edi,%esi
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
xor    %r8d,%r8d
xor    %edx,%edx
mov    $0x1,%edi
callq  440 <get_pwent>
add    $0x28,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_get_tar_group_by_gid(gid_t gid, char * tarbuf)
{
 int ret;
 ;
 ret = get_pwent(1, gid, ((void *)0), tarbuf, ((void *)0), ((void *)0),
   l_getgidbyname,
   l_tar_sysdata_getgroup,
   &dbpair_group_nset,
   groupCacheM
  );
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 12
14 12
15 12
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
jmpq   13b5 <da_str_print+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_str_print (const char * s1, FILE * stream)
{
  fputs ((const char *) s1, stream);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 7f6b <getdatadir+0xb>
mov    (%rbx),%rdi
callq  7f73 <getdatadir+0x13>
lea    0x0(%rip),%rsi        # 7f7a <getdatadir+0x1a>
lea    0x10(%rax),%edi
mov    %rax,%r12
movslq %r12d,%r12
callq  7f88 <getdatadir+0x28>
mov    0x0(%rip),%rbp        # 7f8f <getdatadir+0x2f>
mov    (%rbx),%rsi
mov    %rax,%rdi
mov    %rax,0x0(%rbp)
callq  7f9e <getdatadir+0x3e>
mov    (%rbx),%rax
cmpb   $0x2f,-0x1(%rax,%r12,1)
je     8040 <getdatadir+0xe0>
mov    0x0(%rbp),%rdi
xor    %r12d,%r12d
callq  7fb9 <getdatadir+0x59>
mov    %rax,%rdi
mov    %rax,%rbx
callq  7fc4 <getdatadir+0x64>
cmp    $0x3,%rax
jne    802e <getdatadir+0xce>
movsbl (%rbx),%edi
callq  7fd2 <getdatadir+0x72>
cmp    $0x62,%eax
jne    802e <getdatadir+0xce>
movsbl 0x1(%rbx),%edi
callq  7fe0 <getdatadir+0x80>
cmp    $0x69,%eax
jne    802e <getdatadir+0xce>
movsbl 0x2(%rbx),%edi
callq  7fee <getdatadir+0x8e>
cmp    $0x6e,%eax
jne    802e <getdatadir+0xce>
lea    0x0(%rip),%rbx        # 7ffa <getdatadir+0x9a>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%eax
cmp    $0x2e,%al
je     8000 <getdatadir+0xa0>
cmp    $0x2f,%al
mov    0x0(%rbp),%rdi
sete   %al
movzbl %al,%eax
add    %rax,%rbx
callq  801f <getdatadir+0xbf>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  802a <getdatadir+0xca>
mov    0x0(%rbp),%r12
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rbp),%rax
movb   $0x0,-0x1(%rax,%r12,1)
jmpq   7fad <getdatadir+0x4d>
nop
<<<sep_in_sample>>>
getdatadir()
{
    int progdirlen;
    char *p;
    progdirlen = strlen(progdir);
    datadir = (char *) mymalloc(progdirlen + strlen("../share/units") + 2,
                                "(getdatadir)");
    strcpy(datadir, progdir);
    if (((progdir[progdirlen - 1]) == '/'))
      datadir[progdirlen - 1] = '\0';
    p = pathend(datadir);
    if ((strlen(p) == 3) && (tolower(p[0]) == 'b')
       && (tolower(p[1]) == 'i') && (tolower(p[2]) == 'n')) {
      p = "../share/units";
      while (*p == '.')
        p++;
      if (((*p) == '/'))
        p++;
      strcpy(pathend(datadir), p);
      return datadir;
    }
    else
      return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 6
8 6
9 5
10 9
11 6
12 6
13 8
14 8
15 6
16 8
17 9
18 9
19 9
20 11
21 23
22 11
23 12
24 11
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 16
43 15
44 15
45 15
46 18
47 19
48 18
49 18
50 18
51 19
52 19
53 19
54 19
55 20
56 24
57 24
58 24
59 24
60 24
61 24
62 10
63 10
64 10
65 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     340 <mu_vartab_getvar+0x10>
jmpq   a0 <mu_vartab_getvar.part.1>
nopw   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_vartab_getvar (mu_vartab_t vt, const char *name, const char **pvalue)
{
  struct vardefn *vdefn;
  if (!vt)
    return 22;
  vdefn = mu_assoc_ref (vt->assoc, name);
  if (!vdefn)
    return (0x1000 +40);
  return vardefn_expand (name, vdefn, pvalue);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 10
6 10
7 10
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0x10(%rdi),%rcx
mov    %rdi,%rbx
mov    0x18(%rdi),%rsi
lea    (%rdx,%rcx,1),%rdx
cmp    %rdx,%rsi
jbe    40 <__gmp_asprintf_memory+0x40>
mov    0x8(%rdi),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rcx,%rdi
callq  30 <__gmp_asprintf_memory+0x30>
add    %rbp,0x10(%rbx)
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
add    %rdx,%rdx
mov    %rdx,0x18(%rdi)
mov    0x8(%rdi),%rdi
callq  *0x0(%rip)        # 51 <__gmp_asprintf_memory+0x51>
mov    0x10(%rbx),%rcx
mov    %rax,0x8(%rbx)
mov    %rax,%rdi
jmp    22 <__gmp_asprintf_memory+0x22>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_asprintf_memory (struct gmp_asprintf_t *d, const char *str, size_t len)
{
  do { size_t alloc, newsize, newalloc; do {} while (0); alloc = (d)->alloc; newsize = (d)->size + (len); if (alloc <= newsize) { newalloc = 2*newsize; (d)->alloc = newalloc; (d)->buf = ((char *) (*__gmp_reallocate_func) ((d)->buf, (alloc) * sizeof (char), (newalloc) * sizeof (char))); } } while (0);
  memcpy (d->buf + d->size, str, len);
  d->size += len;
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 5
18 7
19 7
20 7
21 7
22 7
23 7
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rcx
lea    0x4(%rsp),%rdx
lea    0x8(%rsp),%rsi
callq  3786 <uxfio_get_fd_mem+0x16>
test   %eax,%eax
js     3798 <uxfio_get_fd_mem+0x28>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    378f <uxfio_get_fd_mem+0x1f>
<<<sep_in_sample>>>
uxfio_get_fd_mem(int uxfio_fildes, int * data_len)
{
 char * s;
 int ret;
 int end;
 ret = uxfio_get_dynamic_buffer(uxfio_fildes,
     &s,
     &end,
     data_len);
 if (ret < 0) return ((void *)0);
 return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 10
7 10
8 11
9 12
10 12
11 12
12 10
13 10
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     3c0 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 3c7 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     3e8 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     435 <argp_version_parser+0x85>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 3ef <argp_version_parser+0x3f>
test   %rdx,%rdx
je     410 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  404 <argp_version_parser+0x54>
jmp    3d9 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rax
mov    $0x0,%esi
mov    0x30(%rax),%rdi
callq  421 <argp_version_parser+0x71>
mov    $0x0,%esi
mov    %rax,%rdx
mov    %rbx,%rdi
xor    %eax,%eax
callq  433 <argp_version_parser+0x83>
jmp    3d9 <argp_version_parser+0x29>
xor    %edi,%edi
callq  43c <argp_version_parser+0x8c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 18
4 21
5 21
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 14
15 14
16 14
17 21
18 21
19 21
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 15
40 15
41 15
<<<sep_out_sample>>>
test   %rdx,%rdx
je     770 <gsl_stats_short_quantile_from_sorted_data+0x70>
sub    $0x1,%rdx
js     778 <gsl_stats_short_quantile_from_sorted_data+0x78>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     79f <gsl_stats_short_quantile_from_sorted_data+0x9f>
test   %rax,%rax
js     7b0 <gsl_stats_short_quantile_from_sorted_data+0xb0>
cvtsi2sd %rax,%xmm1
add    %rsi,%rsi
movapd %xmm0,%xmm2
imul   %rsi,%rax
movsd  0x0(%rip),%xmm0        # 744 <gsl_stats_short_quantile_from_sorted_data+0x44>
subsd  %xmm1,%xmm2
add    %rdi,%rsi
movswl (%rdi,%rax,1),%edx
movswl (%rsi,%rax,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    723 <gsl_stats_short_quantile_from_sorted_data+0x23>
add    %rsi,%rsi
imul   %rdx,%rsi
movswl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nop
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   731 <gsl_stats_short_quantile_from_sorted_data+0x31>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_short_quantile_from_sorted_data (const short sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 18
18 8
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 18
30 11
31 21
32 21
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 7
42 7
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
51 8
52 8
53 8
54 8
55 8
56 8
57 8
58 8
59 8
<<<sep_out_sample>>>
testb  $0x20,0x240(%rdi)
jne    d0 <__log_set_lg_bsize+0x40>
mov    0x50(%rdi),%eax
shr    $0x2,%eax
cmp    %esi,%eax
jb     b0 <__log_set_lg_bsize+0x20>
mov    %esi,0x4c(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%esi
callq  c0 <__log_set_lg_bsize+0x30>
mov    $0x16,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%edx
mov    $0x0,%esi
jmpq   df <__log_set_lg_bsize+0x4f>
nop
<<<sep_in_sample>>>
__log_set_lg_bsize(dbenv, lg_bsize)
 DB_ENV *dbenv;
 u_int32_t lg_bsize;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_lg_bsize", 1));;
 if (lg_bsize > dbenv->lg_max / 4) {
  CDB___db_err(dbenv, "log buffer size must be <= log file size / 4");
  return (22);
 }
 dbenv->lg_bsize = lg_bsize;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 10
8 11
9 11
10 11
11 4
12 7
13 7
14 7
15 8
16 12
17 12
18 12
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 819 <afmrestart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     850 <afmrestart+0x40>
mov    0x0(%rip),%rdx        # 82a <afmrestart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     850 <afmrestart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  720 <afm_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c0 <afm_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  4e0 <afmensure_buffer_stack>
mov    0x0(%rip),%rbp        # 85c <afmrestart+0x4c>
mov    0x0(%rip),%rax        # 863 <afmrestart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 86f <afmrestart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  879 <afmrestart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    833 <afmrestart+0x23>
jmp    836 <afmrestart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmrestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        afmensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            afm_create_buffer(afmin,16384 );
 }
 afm_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 afm_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r12
cmp    %edx,%esi
mov    %rdi,%r12
push   %rbp
mov    %ecx,%ebp
push   %rbx
mov    %esi,%ebx
je     1b6b <_sse_mulr_f+0x1b>
cmp    %ecx,%esi
mov    %edx,%r8d
je     1b6e <_sse_mulr_f+0x1e>
callq  1af0 <_sse_movr_f.part.12>
mov    %ebp,%r8d
mov    %ebx,%ecx
mov    %r12,%rdi
mov    $0x59,%edx
pop    %rbx
pop    %rbp
pop    %r12
mov    $0xf3,%esi
jmpq   1a80 <_ssexr>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_mulr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf3,0x59,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf3,0x59,r0,r1);
    else {
 _sse_movr_f(_jit,r0,r1);
 _ssexr(_jit,0xf3,0x59,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 6
11 5
12 5
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 9
21 9
22 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    (%rsi),%eax
test   %rdi,%rdi
je     132 <growbuffer+0x12>
test   %eax,%eax
jne    150 <growbuffer+0x30>
add    $0x64,%eax
mov    %eax,(%rsi)
movslq %eax,%rdi
callq  13f <growbuffer+0x1f>
mov    %rax,(%rbx)
test   %rax,%rax
je     162 <growbuffer+0x42>
pop    %rbx
retq   
nopl   0x0(%rax)
add    $0x64,%eax
mov    %eax,(%rsi)
movslq %eax,%rsi
callq  15d <growbuffer+0x3d>
mov    %rax,(%rbx)
jmp    142 <growbuffer+0x22>
mov    0x0(%rip),%rax        # 169 <growbuffer+0x49>
lea    0x0(%rip),%rsi        # 170 <growbuffer+0x50>
mov    (%rax),%rdx
mov    0x0(%rip),%rax        # 17a <growbuffer+0x5a>
mov    (%rax),%rdi
xor    %eax,%eax
callq  184 <growbuffer+0x64>
mov    $0x1,%edi
callq  18e <growbuffer+0x6e>
xchg   %ax,%ax
<<<sep_in_sample>>>
growbuffer(char **buf, int *bufsize)
{
  int usemalloc;
  usemalloc = !*buf || !*bufsize;
  *bufsize += 100;
  if (usemalloc)
    *buf = malloc(*bufsize);
  else
    *buf = realloc(*buf,*bufsize);
  if (!*buf){
    fprintf(stderr, "%s: memory allocation error (growbuffer)\n",progname);
    exit(1);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 10
15 10
16 14
17 14
18 14
19 5
20 5
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 12
33 12
34 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     670 <output_init+0x30>
mov    0x0(%rip),%eax        # 64b <output_init+0xb>
movl   $0xffffffff,0x4(%rdi)
movl   $0xffffffff,(%rdi)
test   %eax,%eax
movzbl 0x8(%rdi),%eax
setne  %dl
and    $0xfffffffe,%eax
or     %edx,%eax
mov    %al,0x8(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 67b <output_init+0x3b>
xor    %esi,%esi
mov    $0x2000,%ecx
mov    $0x1,%edx
callq  68c <output_init+0x4c>
mov    0x0(%rip),%rdi        # 693 <output_init+0x53>
callq  698 <output_init+0x58>
mov    %eax,%edi
callq  0 <set_append_mode>
mov    0x0(%rip),%rdi        # 6a6 <output_init+0x66>
callq  6ab <output_init+0x6b>
mov    %eax,%edi
callq  0 <set_append_mode>
mov    0x0(%rip),%rdi        # 6b9 <output_init+0x79>
callq  6be <output_init+0x7e>
mov    $0x1,%esi
mov    %eax,%edi
xor    %eax,%eax
callq  6cc <output_init+0x8c>
cmp    $0xffffffff,%eax
je     6e0 <output_init+0xa0>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   6df <output_init+0x9f>
nop
callq  6e5 <output_init+0xa5>
cmpl   $0x9,(%rax)
jne    6d1 <output_init+0x91>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
output_init (struct output *out)
{
  if (out)
    {
      out->out = out->err = (-1);
      out->syncout = !!output_sync;
      return;
    }
  setvbuf (stdout, 0, 1, 8192);
  set_append_mode (fileno (stdout));
  set_append_mode (fileno (stderr));
  if (((fcntl (fileno (stdout), 1) != -1) || ((*__errno_location ()) != 9)))
    atexit (close_stdout);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 2
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 13
37 14
38 13
39 13
40 12
41 12
42 12
43 14
44 14
45 14
<<<sep_out_sample>>>
mov    (%rdi),%r9
cmp    0x8(%rdi),%r9
je     3070 <gsl_matrix_uint_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3066 <gsl_matrix_uint_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %r9,%r9
je     30d4 <gsl_matrix_uint_transpose+0x94>
xor    %eax,%eax
lea    0x1(%rax),%r11
cmp    %r9,%r11
je     30d4 <gsl_matrix_uint_transpose+0x94>
mov    0x10(%rdi),%rdx
mov    %rax,%rsi
mov    0x18(%rdi),%rcx
imul   %rdx,%rsi
lea    0x0(,%rdx,4),%r10
add    %rsi,%rdx
add    %rdx,%rax
lea    (%rcx,%rax,4),%rdx
lea    (%rcx,%rsi,4),%rcx
mov    %r11,%rax
nopl   0x0(%rax,%rax,1)
mov    (%rdx),%r8d
mov    (%rcx,%rax,4),%esi
mov    %r8d,(%rcx,%rax,4)
add    $0x1,%rax
mov    %esi,(%rdx)
add    %r10,%rdx
cmp    %r9,%rax
jne    30b0 <gsl_matrix_uint_transpose+0x70>
mov    %r11,%rax
lea    0x1(%rax),%r11
cmp    %r9,%r11
jne    3080 <gsl_matrix_uint_transpose+0x40>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_transpose (gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned int tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 20
31 19
32 20
33 12
34 21
35 21
36 12
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x18,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  44 <grecs_txtacc_alloc_entry+0x14>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  4f <grecs_txtacc_alloc_entry+0x1f>
mov    %rbp,0x8(%rbx)
mov    %rax,(%rbx)
mov    %rbx,%rsi
movq   $0x0,0x10(%rbx)
mov    %r12,%rdi
callq  69 <grecs_txtacc_alloc_entry+0x39>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_alloc_entry(struct grecs_list *list, size_t size)
{
 struct grecs_txtacc_entry *p = grecs_malloc(sizeof (*p));
 p->buf = grecs_malloc(size);
 p->size = size;
 p->len = 0;
 grecs_list_append(list, p);
 return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 4
11 5
12 4
13 7
14 6
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmp    $0x1,%edi
mov    %edi,0xc(%rsp)
mov    %rsi,(%rsp)
jle    2120 <makedir+0x60>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  20e5 <makedir+0x25>
cmp    $0x5,%eax
je     20f0 <makedir+0x30>
add    $0x18,%rsp
retq   
nop
cmpl   $0x1f4,0x0(%rip)        # 20fa <makedir+0x3a>
jne    20ea <makedir+0x2a>
mov    0x0(%rip),%eax        # 2102 <makedir+0x42>
test   %eax,%eax
jne    2158 <makedir+0x98>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  211a <makedir+0x5a>
add    $0x18,%rsp
retq   
nop
lea    0xc(%rsp),%rdi
mov    $0x0,%edx
mov    %rsp,%rsi
callq  2132 <makedir+0x72>
test   %eax,%eax
jne    20d1 <makedir+0x11>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    (%rax),%rsi
xor    %eax,%eax
callq  2149 <makedir+0x89>
movl   $0xffffffff,0x0(%rip)        # 2153 <makedir+0x93>
jmp    20ea <makedir+0x2a>
nopl   (%rax)
mov    $0x0,%edi
callq  2162 <makedir+0xa2>
jmp    2106 <makedir+0x46>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
makedir (int argc, char **argv)
{
  if (argc < 2 && !another (&argc, &argv, "directory-name"))
    {
      printf ("usage: %s directory-name\n", argv[0]);
      code = -1;
      return;
    }
  if (command ("MKD %s", argv[1]) == 5 && code == 500)
    {
      if (verbose)
 printf ("MKD command not recognized, trying XMKD\n");
      command ("XMKD %s", argv[1]);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 15
14 15
15 15
16 9
17 9
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 15
27 15
28 15
29 3
30 3
31 3
32 3
33 3
34 3
35 5
36 5
37 5
38 5
39 5
40 6
41 7
42 7
43 12
44 12
45 12
46 12
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_line_begin ()
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl 0x60(%rdi),%eax
lea    -0x3(%rax),%ecx
cmp    $0x5,%cl
ja     3a4 <DISProcessNewDRParameters+0x24>
mov    $0x1,%eax
shl    %cl,%rax
test   $0x33,%al
jne    3d0 <DISProcessNewDRParameters+0x50>
lea    0x1a0(%rbp),%rdi
mov    %rbx,%rsi
mov    $0x15,%ecx
rep movsq %ds:(%rsi),%es:(%rdi)
add    $0x8,%rsp
lea    0x48(%rbx),%rdi
lea    0x20(%rbp),%rsi
pop    %rbx
pop    %rbp
jmpq   3c9 <DISProcessNewDRParameters+0x49>
nopl   0x0(%rax)
callq  3d5 <DISProcessNewDRParameters+0x55>
jmp    3a4 <DISProcessNewDRParameters+0x24>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
DISProcessNewDRParameters(dis_entity_state_pdu * pdu, dis_dr_parameters * dr)
{
 switch (pdu->dr_parm.algorithm) {
 case 7:
 case 8:
 case 3:
 case 4:
  DISGenerateDRParameters(pdu, dr);
  break;
 case 1:
 case 2:
 case 5:
 case 6:
 case 9:
  break;
 case 0:
 default:
  break;
 }
 dr->pdu = *pdu;
 DISEulerToMatrix(&pdu->orientation, &dr->R0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 20
15 20
16 20
17 20
18 22
19 21
20 21
21 22
22 22
23 21
24 21
25 8
26 9
27 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     f26 <lerror+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  f57 <lerror+0x87>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
lerror (struct locus *loc, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vlerror (loc, fmt, ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 7
25 7
26 7
<<<sep_out_sample>>>
movswl 0x2(%rdi),%edx
mov    %rdi,%rax
mov    0x20(%rdi),%rsi
test   %edx,%edx
lea    -0x1(%rdx),%r8d
jle    ed <VGetPlanes+0xed>
mov    %r8d,%edx
sub    $0x590,%rsp
xor    %r9d,%r9d
lea    0x3(%rdx,%rdx,2),%r11
lea    -0x78(%rsp),%rcx
mov    %rsi,%rdx
shl    $0x3,%r11
lea    (%rsi,%r11,1),%rdi
jmp    46 <VGetPlanes+0x46>
nopl   0x0(%rax,%rax,1)
mov    %r9d,%r8d
mov    %r10d,%r9d
movslq %r8d,%r8
movsd  0x8(%rdx),%xmm3
lea    (%r8,%r8,2),%r8
movsd  0x10(%rdx),%xmm1
movapd %xmm3,%xmm2
add    $0x18,%rdx
lea    (%rsi,%r8,8),%r8
movapd %xmm1,%xmm0
add    $0x18,%rcx
lea    0x1(%r9),%r10d
movsd  0x10(%r8),%xmm5
movsd  0x8(%r8),%xmm4
mulsd  %xmm5,%xmm2
mulsd  %xmm4,%xmm0
subsd  %xmm0,%xmm2
movsd  -0x18(%rdx),%xmm0
mulsd  %xmm0,%xmm5
mulsd  %xmm4,%xmm0
movsd  %xmm2,-0x18(%rcx)
movsd  (%r8),%xmm2
mulsd  %xmm2,%xmm1
mulsd  %xmm3,%xmm2
subsd  %xmm5,%xmm1
subsd  %xmm2,%xmm0
movsd  %xmm1,-0x10(%rcx)
movsd  %xmm0,-0x8(%rcx)
cmp    %rdi,%rdx
jne    40 <VGetPlanes+0x40>
xor    %edx,%edx
nop
mov    -0x78(%rsp,%rdx,1),%rcx
mov    %rcx,(%rsi,%rdx,1)
mov    -0x70(%rsp,%rdx,1),%rcx
mov    %rcx,0x8(%rsi,%rdx,1)
mov    -0x68(%rsp,%rdx,1),%rcx
mov    %rcx,0x10(%rsi,%rdx,1)
add    $0x18,%rdx
cmp    %rdx,%r11
jne    c0 <VGetPlanes+0xc0>
add    $0x590,%rsp
repz retq 
<<<sep_in_sample>>>
VGetPlanes(VPolygon * poly)
{
 VPoint tmp[64], *p;
 int i, lasti;
 lasti = poly->numVtces - 1;
 p = poly->vertex;
 for (i = 0; i < poly->numVtces; ++i) {
  tmp[i].x = p->y * poly->vertex[lasti].z - p->z *
   poly->vertex[lasti].y;
  tmp[i].y = p->z * poly->vertex[lasti].x - p->x *
   poly->vertex[lasti].z;
  tmp[i].z = p->x * poly->vertex[lasti].y - p->y *
   poly->vertex[lasti].x;
  lasti = i;
  p++;
 }
 for (i = 0; i < poly->numVtces; ++i)
  poly->vertex[i] = tmp[i];
 return poly;
}
<<<sep_in_sample>>>
1 5
2 2
3 6
4 7
5 5
6 7
7 7
8 2
9 7
10 7
11 7
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 15
25 8
26 8
27 8
28 7
29 8
30 9
31 8
32 8
33 8
34 10
35 10
36 12
37 8
38 10
39 10
40 12
41 10
42 12
43 10
44 12
45 7
46 7
47 7
48 7
49 18
50 18
51 18
52 18
53 18
54 18
55 18
56 17
57 17
58 20
59 20
<<<sep_out_sample>>>
push   %r12
test   %esi,%esi
mov    %esi,%r12d
push   %rbp
push   %rbx
jle    1ad0 <swlib_unix_dirtrunc_n+0x40>
mov    %rdi,%rbp
mov    %esi,%ebx
jmp    1aad <swlib_unix_dirtrunc_n+0x1d>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%ebx
je     1ac8 <swlib_unix_dirtrunc_n+0x38>
mov    %rbp,%rdi
callq  1ab5 <swlib_unix_dirtrunc_n+0x25>
test   %eax,%eax
jne    1aa8 <swlib_unix_dirtrunc_n+0x18>
mov    %r12d,%eax
sub    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    %r12d,%eax
pop    %r12
retq   
xor    %eax,%eax
jmp    1abe <swlib_unix_dirtrunc_n+0x2e>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_unix_dirtrunc_n(STROB * buf, int n)
{
 int i;
 int ret;
 i = n;
 while(i > 0) {
  ret = swlib_unix_dirtrunc(buf);
  if (ret == 0) break;
  i--;
 }
 return n - i;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 6
30 6
31 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
mov    %rsi,%rbx
callq  1de <gl_locale_name_environ+0xe>
test   %rax,%rax
je     1e8 <gl_locale_name_environ+0x18>
cmpb   $0x0,(%rax)
jne    215 <gl_locale_name_environ+0x45>
mov    %rbx,%rdi
callq  1f0 <gl_locale_name_environ+0x20>
test   %rax,%rax
je     1fa <gl_locale_name_environ+0x2a>
cmpb   $0x0,(%rax)
jne    215 <gl_locale_name_environ+0x45>
mov    $0x0,%edi
callq  204 <gl_locale_name_environ+0x34>
mov    %rax,%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     215 <gl_locale_name_environ+0x45>
cmpb   $0x0,(%rdx)
cmovne %rdx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_locale_name_environ (int category, const char *categoryname)
{
  const char *retval;
  retval = getenv ("LC_ALL");
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != ((void *)0) && retval[0] != '\0')
    {
        return retval;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 15
19 11
20 11
21 15
22 15
23 16
24 16
25 16
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2778 <gsl_vector_uint_free+0x38>
mov    0x20(%rdi),%eax
test   %eax,%eax
jne    2760 <gsl_vector_uint_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   2759 <gsl_vector_uint_free+0x19>
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
callq  2769 <gsl_vector_uint_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   2772 <gsl_vector_uint_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_free (gsl_vector_uint * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_uint_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%edi
callq  16fb <xformat_read+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_read(XFORMAT * xux, void * buf, size_t count)
{
 ;
 return uxfio_sfread(xux->ifdM, buf, count);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # a76 <raw_job_exit_status+0x6>
mov    0x0(%rip),%rax        # a7d <raw_job_exit_status+0xd>
movslq %edi,%rdi
test   %edx,%edx
mov    (%rax,%rdi,8),%rax
je     ab0 <raw_job_exit_status+0x40>
mov    0x8(%rax),%rsi
xor    %eax,%eax
mov    %rsi,%rdx
nopl   0x0(%rax)
mov    0xc(%rdx),%ecx
mov    (%rdx),%rdx
test   %ecx,%ecx
cmovne %ecx,%eax
cmp    %rdx,%rsi
jne    a98 <raw_job_exit_status+0x28>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    0x8(%rax),%rcx
mov    %rcx,%rdx
jmp    ac3 <raw_job_exit_status+0x53>
nopl   0x0(%rax)
mov    %rax,%rdx
mov    (%rdx),%rax
cmp    %rax,%rcx
jne    ac0 <raw_job_exit_status+0x50>
mov    0xc(%rdx),%eax
retq   
nop
<<<sep_in_sample>>>
raw_job_exit_status (job)
     int job;
{
  register PROCESS *p;
  int fail;
  WAIT ret;
  if (pipefail_opt)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
 {
   if ((p->status) != 0)
     fail = (p->status);
   p = p->next;
 }
      while (p != jobs[job]->pipe);
      (ret) = fail;
      return ret;
    }
  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}
<<<sep_in_sample>>>
1 7
2 10
3 10
4 7
5 10
6 7
7 10
8 9
9 10
10 10
11 13
12 15
13 13
14 13
15 17
16 17
17 17
18 17
19 21
20 21
21 21
22 21
23 21
24 21
25 21
26 21
27 23
28 24
29 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x20(%rsi),%edi
callq  b5c <pred_nogroup+0xc>
test   %rax,%rax
sete   %al
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_nogroup (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  (void) pred_ptr;
  return getgrgid (stat_buf->st_gid) == ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 247 <freeAllNavaids+0x7>
test   %rdi,%rdi
je     261 <freeAllNavaids+0x21>
push   %rbx
jmp    253 <freeAllNavaids+0x13>
nop
mov    %rbx,%rdi
mov    (%rdi),%rbx
callq  25b <freeAllNavaids+0x1b>
test   %rbx,%rbx
jne    250 <freeAllNavaids+0x10>
pop    %rbx
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
freeAllNavaids (void)
{
 navaid_t *n = test_navaid, *p;
 while (n) {
  p = n;
  n = n->next;
  free (p);
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 2
5 2
6 2
7 6
8 6
9 7
10 4
11 4
12 9
13 9
14 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     fa0 <gsl_permute_vector_ulong+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f95 <gsl_permute_vector_ulong+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  fb1 <gsl_permute_vector_ulong+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_ulong (const gsl_permutation * p, gsl_vector_ulong * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_ulong (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    1070 <gsl_matrix_long_double_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  1092 <gsl_matrix_long_double_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_superdiagonal (gsl_matrix_long_double * m,
                                      const size_t k)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%esi
mov    $0x1,%edi
callq  140 <daemonize+0x10>
xor    %esi,%esi
xor    %edi,%edi
callq  149 <daemonize+0x19>
cmp    $0xffffffff,%eax
je     1a0 <daemonize+0x70>
mov    0x0(%rip),%rax        # 155 <daemonize+0x25>
mov    0x0(%rip),%edx        # 15b <daemonize+0x2b>
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 167 <daemonize+0x37>
and    $0xffffffffffffffdf,%rax
or     $0x40,%rax
mov    %rax,0x0(%rip)        # 176 <daemonize+0x46>
callq  17b <daemonize+0x4b>
mov    $0x0,%edi
callq  185 <daemonize+0x55>
mov    $0x0,%edx
mov    %rax,%rsi
mov    $0x1,%edi
xor    %eax,%eax
callq  199 <daemonize+0x69>
pop    %rbx
jmpq   19f <daemonize+0x6f>
nop
mov    $0x0,%edi
callq  1aa <daemonize+0x7a>
mov    %rax,%rbx
callq  1b2 <daemonize+0x82>
mov    (%rax),%esi
mov    %rbx,%rdx
mov    $0x1,%edi
xor    %eax,%eax
callq  1c3 <daemonize+0x93>
jmp    14e <daemonize+0x1e>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
daemonize (void)
{
  signal (1, ((__sighandler_t) 1));
  if (daemon (0, 0) == -1)
    anubis_error (1, (*__errno_location ()), gettext("daemon() failed"));
  topt &= ~0x00000020;
  topt |= 0x00000040;
  openlog (log_tag, 0x01, log_facility);
  info (1, gettext("%s daemon startup succeeded."), version);
  write_pid_file ();
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 6
11 8
12 8
13 8
14 6
15 7
16 7
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 12
26 10
27 10
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%eax        # 3e <osip_build_random_number+0xe>
test   %eax,%eax
je     60 <osip_build_random_number+0x30>
callq  47 <osip_build_random_number+0x17>
mov    %rax,%rdx
test   %edx,%edx
je     d0 <osip_build_random_number+0xa0>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
lea    0x10(%rsp),%rdi
xor    %esi,%esi
callq  6c <osip_build_random_number+0x3c>
xor    %esi,%esi
xor    %eax,%eax
mov    $0x0,%edi
mov    0x10(%rsp),%rbp
add    0x18(%rsp),%ebp
callq  83 <osip_build_random_number+0x53>
test   %eax,%eax
mov    %eax,%r12d
jle    b3 <osip_build_random_number+0x83>
mov    $0x200,%ebx
nop
lea    0xc(%rsp),%rsi
mov    $0x4,%edx
mov    %r12d,%edi
callq  a2 <osip_build_random_number+0x72>
add    0xc(%rsp),%ebp
sub    $0x1,%ebx
jne    90 <osip_build_random_number+0x60>
mov    %r12d,%edi
callq  b3 <osip_build_random_number+0x83>
mov    %ebp,%edi
callq  ba <osip_build_random_number+0x8a>
movl   $0x1,0x0(%rip)        # c4 <osip_build_random_number+0x94>
callq  c9 <osip_build_random_number+0x99>
mov    %rax,%rdx
test   %edx,%edx
jne    52 <osip_build_random_number+0x22>
lea    0x10(%rsp),%rdi
xor    %esi,%esi
callq  dc <osip_build_random_number+0xac>
mov    0x10(%rsp),%rdi
add    0x18(%rsp),%edi
callq  ea <osip_build_random_number+0xba>
callq  ef <osip_build_random_number+0xbf>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_build_random_number ()
{
  if (!random_seed_set) {
    unsigned int ticks;
    struct timeval tv;
    int fd;
    gettimeofday (&tv, ((void *)0));
    ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);
    fd = open ("/dev/urandom", 00);
    if (fd > 0) {
      unsigned int r;
      int i;
      for (i = 0; i < 512; i++) {
        read (fd, &r, sizeof (r));
        ticks += r;
      }
      close (fd);
    }
    srand48 (ticks);
    random_seed_set = 1;
  }
  {
    int val = (int) lrand48 ();
    if (val == 0) {
      unsigned int ticks;
      struct timeval tv;
      gettimeofday (&tv, ((void *)0));
      ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);
      srand48 (ticks);
      return (unsigned int) lrand48 ();
    }
    return val;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 23
9 23
10 24
11 24
12 34
13 34
14 34
15 34
16 34
17 34
18 7
19 7
20 7
21 9
22 9
23 9
24 8
25 8
26 9
27 10
28 9
29 10
30 10
31 10
32 14
33 14
34 14
35 14
36 15
37 13
38 13
39 17
40 17
41 19
42 19
43 20
44 23
45 23
46 24
47 24
48 27
49 27
50 27
51 29
52 29
53 29
54 30
55 34
56 34
57 34
58 34
59 34
60 34
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strob_get_length(STROB * strb)
{
 return strb->length_;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
xor    %ecx,%ecx
xor    %edx,%edx
push   %rbx
sub    $0x8,%rsp
callq  f3f0 <call_expand_word_internal.constprop.21>
mov    %rax,%rbx
mov    %rax,%rdi
callq  8ba0 <word_list_split>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  10a45 <expand_word+0x25>
test   %rbp,%rbp
je     10a60 <expand_word+0x40>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   10a58 <expand_word+0x38>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
expand_word (word, quoted)
     WORD_DESC *word;
     int quoted;
{
  WORD_LIST *result, *tresult;
  tresult = call_expand_word_internal (word, quoted, 0, (int *)((void *)0), (int *)((void *)0));
  result = word_list_split (tresult);
  dispose_words (tresult);
  return (result ? dequote_list (result) : result);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 4
5 4
6 6
7 6
8 7
9 7
10 8
11 7
12 8
13 9
14 9
15 10
16 9
17 10
18 10
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
cmpb   $0x22,(%rsi)
push   %rbx
mov    %rdi,%rbx
je     220 <yytnamerr+0x20>
test   %rbx,%rbx
je     280 <yytnamerr+0x80>
mov    %rbx,%rdi
callq  216 <yytnamerr+0x16>
sub    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    %rsi,%rcx
xor    %eax,%eax
movzbl 0x1(%rcx),%edx
cmp    $0x27,%dl
je     209 <yytnamerr+0x9>
jle    260 <yytnamerr+0x60>
cmp    $0x2c,%dl
je     209 <yytnamerr+0x9>
cmp    $0x5c,%dl
jne    270 <yytnamerr+0x70>
cmpb   $0x5c,0x2(%rcx)
lea    0x2(%rcx),%rdx
jne    209 <yytnamerr+0x9>
mov    %rdx,%rcx
test   %rbx,%rbx
je     252 <yytnamerr+0x52>
movzbl (%rcx),%edx
mov    %dl,(%rbx,%rax,1)
add    $0x1,%rax
jmp    225 <yytnamerr+0x25>
nopl   0x0(%rax,%rax,1)
cmp    $0x22,%dl
jne    270 <yytnamerr+0x70>
test   %rbx,%rbx
je     219 <yytnamerr+0x19>
movb   $0x0,(%rbx,%rax,1)
pop    %rbx
retq   
add    $0x1,%rcx
jmp    247 <yytnamerr+0x47>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
mov    %rsi,%rdi
jmpq   289 <yytnamerr+0x89>
nopl   0x0(%rax)
<<<sep_in_sample>>>
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      long unsigned int yyn = 0;
      char const *yyp = yystr;
      for (;;)
        switch (*++yyp)
          {
          case '\'':
          case ',':
            goto do_not_strip_quotes;
          case '\\':
            if (*++yyp != '\\')
              goto do_not_strip_quotes;
          default:
            if (yyres)
              yyres[yyn] = *yyp;
            yyn++;
            break;
          case '"':
            if (yyres)
              yyres[yyn] = '\0';
            return yyn;
          }
    do_not_strip_quotes: ;
    }
  if (! yyres)
    return strlen (yystr);
  return stpcpy (yyres, yystr) - yyres;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 28
6 28
7 30
8 30
9 30
10 31
11 31
12 31
13 3
14 3
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 14
24 14
25 14
26 14
27 17
28 17
29 18
30 18
31 19
32 26
33 26
34 8
35 8
36 22
37 22
38 23
39 31
40 31
41 8
42 8
43 8
44 31
45 29
46 29
47 29
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1f19 <gsl_complex_sech+0x9>
callq  1f1e <gsl_complex_sech+0xe>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_sech (gsl_complex a)
{
  gsl_complex z = gsl_complex_cosh (a);
  return gsl_complex_inverse (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x18(%rdi),%rdi
callq  735 <__osip_add_nict+0x15>
lea    0x60(%rbx),%rdi
mov    %rbp,%rsi
mov    $0xffffffff,%edx
callq  746 <__osip_add_nict+0x26>
mov    0x18(%rbx),%rdi
callq  74f <__osip_add_nict+0x2f>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_add_nict (osip_t * osip, osip_transaction_t * nict)
{
  osip_mutex_lock (osip->nict_fastmutex);
  osip_list_add (&osip->osip_nict_transactions, nict, -1);
  osip_mutex_unlock (osip->nict_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1606 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
callq  b6 <__xreadlink+0x16>
mov    %rax,%rbx
mov    (%rax),%r12d
xor    %eax,%eax
test   %rbp,%rbp
jne    cd <__xreadlink+0x2d>
jmp    e2 <__xreadlink+0x42>
nopl   (%rax)
cmpl   $0x4,(%rbx)
jne    e2 <__xreadlink+0x42>
mov    %r12d,(%rbx)
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r14,%rdi
callq  de <__xreadlink+0x3e>
test   %eax,%eax
js     c8 <__xreadlink+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__xreadlink(path, buf, size)
    const char *path;
    char *buf;
    size_t size;
{
    int chars;
    int old_errno = (*__errno_location ());
    if (size <= 0)
 return size;
    do
    {
 (*__errno_location ()) = old_errno;
 chars = readlink(path, buf, size);
    }
    while (chars < 0 && (*__errno_location ()) == 4);
    return chars;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 9
13 8
14 8
15 8
16 8
17 15
18 15
19 12
20 13
21 13
22 13
23 13
24 15
25 15
26 17
27 17
28 17
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_size (const gsl_block_short * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cmp    $0xffffffff,%ecx
mov    (%rdi),%rax
je     190 <AlibSetClipRect+0x30>
mov    %si,0x1840(%rax)
mov    %dx,0x1842(%rax)
mov    %cx,0x1844(%rax)
mov    %r8w,0x1846(%rax)
retq   
nopw   %cs:0x0(%rax,%rax,1)
cmp    $0xffffffff,%r8d
jne    168 <AlibSetClipRect+0x8>
movzwl 0x1834(%rax),%esi
movzwl 0x1836(%rax),%edi
xor    %edx,%edx
mov    %dx,0x1840(%rax)
xor    %ecx,%ecx
mov    %cx,0x1842(%rax)
lea    -0x1(%rsi),%edx
mov    %dx,0x1844(%rax)
lea    -0x1(%rdi),%edx
mov    %dx,0x1846(%rax)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
AlibSetClipRect(Viewport *v, int x1, int y1,
  int x2, int y2)
{
  if (x2 == -1 && y2 == -1) {
    v->w->clip.x1 = 0;
    v->w->clip.y1 = 0;
    v->w->clip.x2 = v->w->width - 1;
    v->w->clip.y2 = v->w->height - 1;
  }
  else {
    v->w->clip.x1 = x1;
    v->w->clip.y1 = y1;
    v->w->clip.x2 = x2;
    v->w->clip.y2 = y2;
  }
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 11
5 12
6 13
7 14
8 14
9 14
10 4
11 4
12 7
13 8
14 5
15 5
16 6
17 6
18 7
19 7
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
mov    $0x10,%edi
jmpq   49a <new_exclude+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
new_exclude (void)
{
  return xzalloc (sizeof *new_exclude ());
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
xor    %r9d,%r9d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
mov    $0x0,%r8d
sub    $0x20,%rsp
mov    $0x1f90,%esi
mov    $0x4,%edi
movl   $0x0,0x10(%rsp)
movl   $0x3,0x8(%rsp)
movl   $0x3,(%rsp)
callq  3a <main+0x3a>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     56 <main+0x56>
callq  4c <main+0x4c>
mov    %rbx,%rdi
callq  54 <main+0x54>
xor    %eax,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main()
{
  struct MHD_Daemon *daemon;
  daemon = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION,
                            8080, ((void *)0), ((void *)0),
                            &answer_to_connection, ((void *)0),
                            MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 3,
                            MHD_OPTION_END);
  if (((void *)0) == daemon)
    return 1;
  getchar();
  MHD_stop_daemon(daemon);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 10
16 9
17 9
18 11
19 12
20 12
21 13
22 14
23 14
24 14
<<<sep_out_sample>>>
movzwl %dx,%edx
movzbl %sil,%esi
mov    $0x1,%ecx
jmpq   1f90 <iso9660_open_ext_private>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_open_fuzzy_ext (const char *psz_path,
   iso_extension_mask_t iso_extension_mask,
   uint16_t i_fuzz)
{
  return iso9660_open_ext_private(psz_path, iso_extension_mask, i_fuzz,
      1);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x620(%rdi),%rdi
callq  357 <free_mbdata+0x17>
cmpq   $0x0,0x630(%rbx)
je     38c <free_mbdata+0x4c>
nopl   0x0(%rax)
mov    %rbp,%rax
add    $0x1,%rbp
shl    $0x5,%rax
add    0x628(%rbx),%rax
mov    0x10(%rax),%rdi
callq  383 <free_mbdata+0x43>
cmp    %rbp,0x630(%rbx)
ja     368 <free_mbdata+0x28>
mov    0x628(%rbx),%rdi
callq  398 <free_mbdata+0x58>
mov    0x6a8(%rbx),%rdi
callq  3a4 <free_mbdata+0x64>
mov    0x6c0(%rbx),%rdi
test   %rdi,%rdi
je     3f4 <free_mbdata+0xb4>
cmpq   $0x0,0x670(%rbx)
js     3e5 <free_mbdata+0xa5>
mov    $0xffffffffffffffff,%rbp
nopl   0x0(%rax)
mov    (%rdi,%rbp,8),%rdi
add    $0x1,%rbp
callq  3d5 <free_mbdata+0x95>
cmp    %rbp,0x670(%rbx)
mov    0x6c0(%rbx),%rdi
jg     3c8 <free_mbdata+0x88>
add    $0x8,%rsp
sub    $0x8,%rdi
pop    %rbx
pop    %rbp
jmpq   3f4 <free_mbdata+0xb4>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
free_mbdata (struct dfa *d)
{
  size_t i;
  free (d->multibyte_prop);
  for (i = 0; i < d->nmbcsets; ++i)
    free (d->mbcsets[i].chars);
  free (d->mbcsets);
  free (d->mb_follows.elems);
  if (d->mb_trans)
    {
      state_num s;
      for (s = -1; s < d->tralloc; s++)
        free (d->mb_trans[s]);
      free (d->mb_trans - 1);
    }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 6
12 5
13 6
14 6
15 6
16 6
17 5
18 5
19 7
20 7
21 8
22 8
23 9
24 9
25 9
26 12
27 12
28 12
29 12
30 13
31 12
32 13
33 12
34 12
35 12
36 16
37 14
38 16
39 16
40 14
41 16
42 16
43 16
44 16
45 16
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%rax
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
nop
add    $0x10,%rax
add    $0x1,%ebx
cmpq   $0x0,(%rax)
jne    60 <mc_maclist_set_random_vendor_from_list+0x10>
callq  72 <mc_maclist_set_random_vendor_from_list+0x22>
movslq %ebx,%rbx
cqto   
idiv   %rbx
shl    $0x4,%rdx
add    %r12,%rdx
movzbl 0x8(%rdx),%eax
mov    %al,0x0(%rbp)
movzbl 0x9(%rdx),%eax
mov    %al,0x1(%rbp)
movzbl 0xa(%rdx),%eax
mov    %al,0x2(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mc_maclist_set_random_vendor_from_list (mac_t *mac, card_mac_list_item_t *list)
{
 int i, num = 0;
 while (list[++num].name);
 num = random()%num;
 for (i=0; i<3; i++) {
  mac->byte[i] = list[num].byte[i];
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 7
20 7
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
push   %rbx
callq  16cc <find_global_variable_last_nameref+0xc>
test   %rax,%rax
mov    %rax,%rbp
je     1720 <find_global_variable_last_nameref+0x60>
mov    0x28(%rax),%ecx
test   $0x8,%ch
je     1730 <find_global_variable_last_nameref+0x70>
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     1738 <find_global_variable_last_nameref+0x78>
cmpb   $0x0,(%rdi)
je     1738 <find_global_variable_last_nameref+0x78>
mov    $0x8,%ebx
jmp    1709 <find_global_variable_last_nameref+0x49>
nopl   0x0(%rax)
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     1740 <find_global_variable_last_nameref+0x80>
cmpb   $0x0,(%rdi)
je     1740 <find_global_variable_last_nameref+0x80>
mov    %rax,%rbp
callq  170e <find_global_variable_last_nameref+0x4e>
test   %rax,%rax
je     1730 <find_global_variable_last_nameref+0x70>
mov    0x28(%rax),%ecx
test   $0x8,%ch
je     1730 <find_global_variable_last_nameref+0x70>
sub    $0x1,%ebx
jne    16f8 <find_global_variable_last_nameref+0x38>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
mov    %rbp,%rax
nopl   0x0(%rax,%rax,1)
test   %r12d,%r12d
je     1720 <find_global_variable_last_nameref+0x60>
and    $0x10,%ch
jne    1722 <find_global_variable_last_nameref+0x62>
jmp    1720 <find_global_variable_last_nameref+0x60>
nopl   0x0(%rax)
<<<sep_in_sample>>>
find_global_variable_last_nameref (name, vflags)
     const char *name;
     int vflags;
{
  SHELL_VAR *v, *nv;
  char *newname;
  int level;
  nv = v = find_global_variable_noref (name);
  level = 0;
  while (v && ((((v)->attributes) & (0x0000800))))
    {
      level++;
      if (level > 8)
        return ((SHELL_VAR *)0);
      newname = ((v)->value);
      if (newname == 0 || *newname == '\0')
 return ((vflags && ((((v)->attributes) & (0x0001000)))) ? v : (SHELL_VAR *)0);
      nv = v;
      v = find_global_variable_noref (newname);
    }
  return nv;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 8
6 10
7 8
8 10
9 10
10 10
11 10
12 15
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 15
21 16
22 16
23 16
24 16
25 16
26 19
27 10
28 10
29 10
30 10
31 10
32 13
33 13
34 10
35 22
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 22
45 16
46 16
47 17
48 17
49 17
50 17
51 17
52 17
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    (%rax),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
jmpq   1c9b <gsl_sort_vector2_int+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector2_int (gsl_vector_int * v1, gsl_vector_int * v2)
{
  gsl_sort2_int (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edi,%edi
movl   $0x0,0x0(%rip)        # 160 <start_slc+0x10>
je     167 <start_slc+0x17>
callq  167 <start_slc+0x17>
mov    $0x3,%r9d
mov    $0x22,%r8d
mov    $0xfa,%ecx
mov    $0xff,%edx
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  18e <start_slc+0x3e>
movq   $0x0,0x0(%rip)        # 199 <start_slc+0x49>
add    $0x8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
start_slc (register int getit)
{
  slcchange = 0;
  if (getit)
    init_termbuf ();
  sprintf ((char *) slcbuf, "%c%c%c%c", 255, 250, 34, 3);
  slcptr = slcbuf + 4;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 4
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 7ea <rl_clear_pending_input+0xa>
andq   $0xfffffffffffdffff,0x0(%rip)        # 7f5 <rl_clear_pending_input+0x15>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_clear_pending_input ()
{
  rl_pending_input = 0;
  (rl_readline_state &= ~(0x0020000));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1f6 <define_default_variables+0x6>
test   %eax,%eax
jne    25c <define_default_variables+0x6c>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rbx        # 207 <define_default_variables+0x17>
test   %rbx,%rbx
je     256 <define_default_variables+0x66>
mov    $0x0,%ebp
nopl   0x0(%rax)
mov    %rbx,%rdi
add    $0x10,%rbp
callq  224 <define_default_variables+0x34>
mov    0x0(%rip),%rdx        # 22b <define_default_variables+0x3b>
xor    %ecx,%ecx
mov    %rbx,%rdi
mov    $0x1,%r8d
mov    %eax,%esi
mov    0x8(%rdx),%r9
mov    -0x8(%rbp),%rdx
movq   $0x0,(%rsp)
callq  24d <define_default_variables+0x5d>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
jne    218 <define_default_variables+0x28>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
define_default_variables (void)
{
  const char **s;
  if (no_builtin_variables_flag)
    return;
  for (s = default_variables; *s != 0; s += 2)
    define_variable_in_set((s[0]),(strlen (s[0])),(s[1]),(o_default),(1), current_variable_set_list->set,((floc *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 6
25 6
26 6
27 8
28 8
29 8
30 8
31 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     2d0 <gsl_blas_zdotc+0x30>
mov    $0x13,%ecx
mov    $0xaf,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c5 <gsl_blas_zdotc+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  2f0 <gsl_blas_zdotc+0x50>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotc)
{
  if (X->size == Y->size)
    {
      cblas_zdotc_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotc)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 175, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 12
6 12
7 12
8 12
9 12
10 12
11 14
12 14
13 14
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 14
25 14
26 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x10,%rdi
mov    $0x0,%esi
callq  ad0 <init_itemlist_from_varlist.isra.0>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
it_init_arrayvars (itp)
     ITEMLIST *itp;
{
  init_itemlist_from_varlist (itp, all_array_variables);
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 6
6 6
7 6
8 6
<<<sep_out_sample>>>
push   %r13
mov    $0x40,%ecx
mov    %edi,%r13d
push   %r12
mov    $0x200,%r12d
push   %rbp
push   %rbx
mov    %esi,%ebx
sub    $0x218,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
test   %esi,%esi
mov    %rsp,%rbp
rep stos %rax,%es:(%rdi)
jg     966 <zero_fill+0x46>
jmp    990 <zero_fill+0x70>
nop
sub    %eax,%ebx
test   %ebx,%ebx
jle    990 <zero_fill+0x70>
cmp    $0x200,%ebx
movslq %ebx,%rdx
mov    %rbp,%rsi
cmovg  %r12,%rdx
mov    %r13d,%edi
callq  97e <zero_fill+0x5e>
test   %eax,%eax
jns    960 <zero_fill+0x40>
mov    $0xffffffff,%eax
jmp    992 <zero_fill+0x72>
nopl   0x0(%rax)
xor    %eax,%eax
mov    0x208(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    9b3 <zero_fill+0x93>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  9b8 <zero_fill+0x98>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
zero_fill(int fd, int amount)
{
 int ret;
 int rem;
 size_t am;
 char buf[512];
 memset(buf, '\0', sizeof(buf));
 rem = amount;
 while (rem > 0) {
  if (rem > (int)sizeof(buf))
   am = sizeof(buf);
  else
   am = (size_t)rem;
  ret = uxfio_write(fd, (void*)buf, am);
  if (ret < 0) return -1;
  rem -= ret;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 13
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 7
14 9
15 7
16 7
17 9
18 9
19 9
20 16
21 9
22 9
23 13
24 13
25 14
26 13
27 14
28 14
29 15
30 15
31 15
32 15
33 15
34 18
35 19
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     768 <mu_mailbox_sync+0x28>
mov    0xa0(%rdi),%rdx
test   %rdx,%rdx
je     768 <mu_mailbox_sync+0x28>
mov    0x30(%rdi),%eax
and    $0xe,%eax
jne    760 <mu_mailbox_sync+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
jmpq   *%rdx
nopw   0x0(%rax,%rax,1)
mov    $0x1003,%eax
nopl   (%rax)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_sync (mu_mailbox_t mbox)
{
  if (mbox == ((void *)0) || mbox->_sync == ((void *)0))
    return (0x1000 +3);
  if (!(mbox->flags & (0x00000004|0x00000002|0x00000008)))
    return 0;
  return mbox->_sync (mbox);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 8
10 8
11 7
12 7
13 4
14 4
15 8
16 8
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     24b <printflen+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rsi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  27c <printflen+0x8c>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
printflen (const char *format, ...)
{
  va_list args;
  int res;
  __builtin_va_start(args,format);
  res = vprintflen (format, args);
  __builtin_va_end(args);
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 5
18 6
19 5
20 5
21 5
22 5
23 5
24 6
25 9
26 9
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
mov    %r8,%rdx
push   %rbx
mov    %r8,%rbx
sub    $0x10,%rsp
callq  603 <gsl_stats_covariance+0x23>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
movsd  %xmm0,0x8(%rsp)
callq  617 <gsl_stats_covariance+0x37>
movsd  0x8(%rsp),%xmm2
add    $0x10,%rsp
mov    %rbx,%r8
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdi
mov    %r14,%rsi
pop    %r13
pop    %r14
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
jmpq   645 <gsl_stats_covariance+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_covariance (const double data1[], const size_t stride1,
                                const double data2[], const size_t stride2,
                                const size_t n)
{
  const double mean1 = gsl_stats_mean (data1, stride1, n);
  const double mean2 = gsl_stats_mean (data2, stride2, n);
  return gsl_stats_covariance_m(data1, stride1,
                                          data2, stride2,
                                          n,
                                          mean1, mean2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 5
14 6
15 6
16 6
17 5
18 6
19 7
20 11
21 7
22 7
23 7
24 11
25 11
26 11
27 7
28 7
29 11
30 11
31 6
32 7
33 7
34 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm3        # 70 <gsl_odeiv2_driver_set_hmax+0x10>
movsd  0x20(%rdi),%xmm1
andpd  %xmm3,%xmm2
andpd  %xmm3,%xmm1
ucomisd %xmm2,%xmm1
ja     a8 <gsl_odeiv2_driver_set_hmax+0x48>
movsd  0x28(%rdi),%xmm1
ucomisd %xmm2,%xmm1
ja     a8 <gsl_odeiv2_driver_set_hmax+0x48>
ucomisd 0x0(%rip),%xmm0        # 96 <gsl_odeiv2_driver_set_hmax+0x36>
je     d0 <gsl_odeiv2_driver_set_hmax+0x70>
movsd  %xmm2,0x30(%rdi)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x81,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c1 <gsl_odeiv2_driver_set_hmax+0x61>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x8a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e9 <gsl_odeiv2_driver_set_hmax+0x89>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_driver_set_hmax (gsl_odeiv2_driver * d, const double hmax)
{
  if ((fabs (hmax) < fabs (d->h)) || (fabs (hmax) < d->hmin))
    {
      do { gsl_error ("hmin <= fabs(h) <= hmax required", "driver.c", 129, GSL_EINVAL) ; return 0 ; } while (0);
    }
  if (hmax > 0.0 || hmax < 0.0)
    {
      d->hmax = fabs (hmax);
    }
  else
    {
      do { gsl_error ("invalid hmax", "driver.c", 138, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 7
13 7
14 9
15 16
16 16
17 16
18 16
19 5
20 5
21 5
22 5
23 5
24 16
25 16
26 16
27 16
28 13
29 13
30 13
31 13
32 13
33 16
34 16
35 16
<<<sep_out_sample>>>
mov    (%rdi),%rcx
xor    %eax,%eax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdx
test   %rcx,%rcx
je     3957 <gsl_vector_uchar_set_zero+0x27>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movb   $0x0,(%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    3948 <gsl_vector_uchar_set_zero+0x18>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_uchar_set_zero (gsl_vector_uchar * v)
{
  unsigned char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const unsigned char zero = 0U ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(unsigned char *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 5
5 8
6 8
7 8
8 8
9 10
10 10
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1d8 <__osip_nist_free+0x38>
xor    %ecx,%ecx
mov    $0x0,%edi
xor    %eax,%eax
mov    $0x0,%r8d
mov    $0x5,%edx
mov    $0x49,%esi
callq  1c7 <__osip_nist_free+0x27>
mov    0x0(%rip),%rax        # 1ce <__osip_nist_free+0x2e>
mov    %rbx,%rdi
test   %rax,%rax
je     1e0 <__osip_nist_free+0x40>
callq  *%rax
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  1e5 <__osip_nist_free+0x45>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
__osip_nist_free (osip_nist_t * nist)
{
  if (nist == ((void *)0))
    return 0;
  osip_trace ("nist.c", 73, TRACE_LEVEL5, ((void *)0), "free nist resource\n");
  { if (nist!=((void *)0)) { if (osip_free_func) osip_free_func(nist); else free(nist);} };
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 6
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # 7b <option_string_to_eol+0xb>
xor    %r9d,%r9d
mov    $0x4,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    %rax,(%rsp)
callq  97 <option_string_to_eol+0x27>
cltq   
mov    0x0(,%rax,4),%eax
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
option_string_to_eol (const char *option,
        const char *arg)
{
  (((sizeof (((eol_args))) / sizeof (*((eol_args)))) == (sizeof (((eol_types))) / sizeof (*((eol_types)))) + 1) ? (void) (0) : __assert_fail ("(sizeof (((eol_args))) / sizeof (*((eol_args)))) == (sizeof (((eol_types))) / sizeof (*((eol_types)))) + 1", "buffer.c", 103, __PRETTY_FUNCTION__));
  return (eol_types [__xargmatch_internal ((option), (arg), (eol_args), (const char *) (eol_types), sizeof (*(eol_types)), 0, argmatch_die)]);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
test   %edi,%edi
js     2f40 <dis_canSimulate+0x30>
movslq %edi,%rdi
movabs $0x100000001,%rax
imul   $0x3a8,%rdi,%rdi
add    0x0(%rip),%rdi        # 2f2f <dis_canSimulate+0x1f>
cmp    %rax,(%rdi)
sete   %al
movzbl %al,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
cmp    0x0(%rip),%edi        # 2f48 <dis_canSimulate+0x38>
jle    2f14 <dis_canSimulate+0x4>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
dis_canSimulate ( int eid )
{
 Entity_t *e;
 if ( eid >= 0 || eid <= entity_top ) {
  e = &entities[eid];
  if ( e->local == 1 && e->state == 1 ) {
   return 1;
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 10
13 4
14 4
15 11
16 11
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
jmpq   29 <user_option_add+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
user_option_add (a2ps_job * job, const char * key, const char * value)
{
  pair_add (job->user_options, key, value);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x10,%edi
callq  8b <grecs_txtacc_create+0xb>
mov    %rax,%rbx
callq  93 <grecs_txtacc_create+0x13>
mov    %rax,(%rbx)
movq   $0x0,0x20(%rax)
callq  a3 <grecs_txtacc_create+0x23>
mov    %rax,0x8(%rbx)
movq   $0x0,0x20(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_create()
{
 struct grecs_txtacc *acc = grecs_malloc(sizeof (*acc));
 acc->cur = grecs_list_create();
 acc->cur->free_entry = grecs_txtacc_entry_free;
 acc->mem = grecs_list_create();
 acc->mem->free_entry = grecs_txtacc_entry_free;
 return acc;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 6
9 6
10 7
11 9
12 9
13 9
14 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 697 <delete_statics+0x7>
test   %rax,%rax
je     6b0 <delete_statics+0x20>
movq   $0x0,(%rax)
mov    $0x0,%edi
jmpq   6ad <delete_statics+0x1d>
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delete_statics()
{
     if (static_symbol_list) {
   static_symbol_list->free_data = static_free;
   linked_list_destroy(&static_symbol_list);
     }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 5
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     3419 <argp_state_help+0x69>
mov    0x1c(%rdi),%eax
test   $0x2,%al
jne    3400 <argp_state_help+0x50>
test   %rsi,%rsi
je     3400 <argp_state_help+0x50>
mov    %ebp,%edx
mov    0x40(%rbx),%r8
mov    (%rbx),%rdi
or     $0x80,%dl
test   $0x40,%al
cmovne %edx,%ebp
mov    %rsi,%rdx
mov    %rbx,%rsi
mov    %ebp,%ecx
callq  1fe0 <_help>
testb  $0x20,0x1c(%rbx)
jne    3400 <argp_state_help+0x50>
test   $0x100,%ebp
jne    340e <argp_state_help+0x5e>
and    $0x200,%ebp
jne    3407 <argp_state_help+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %edi,%edi
callq  340e <argp_state_help+0x5e>
mov    0x0(%rip),%edi        # 3414 <argp_state_help+0x64>
callq  3419 <argp_state_help+0x69>
test   %rsi,%rsi
je     3400 <argp_state_help+0x50>
mov    0x0(%rip),%r8        # 3425 <argp_state_help+0x75>
mov    %rsi,%rdx
mov    %ebp,%ecx
xor    %esi,%esi
xor    %edi,%edi
callq  1fe0 <_help>
jmp    33f0 <argp_state_help+0x40>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)
{
  if ((!state || ! (state->flags & 0x02)) && stream)
    {
      if (state && (state->flags & 0x40))
        flags |= 0x80;
      _help (state ? state->root_argp : 0, state, stream, flags,
             state ? state->name : (program_invocation_short_name));
      if (!state || ! (state->flags & 0x20))
        {
          if (flags & 0x100)
            exit (argp_err_exit_status);
          if (flags & 0x200)
            exit (0);
        }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 9
24 9
25 11
26 11
27 13
28 13
29 17
30 17
31 17
32 17
33 14
34 14
35 12
36 12
37 3
38 3
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x64(%rdi),%rdi
mov    $0xb,%edx
callq  2f2 <swi_xfile_set_state+0x12>
movb   $0x0,0x6f(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_xfile_set_state(SWI_XFILE * s, char * state)
{
 strncpy(s->stateM, state, sizeof(s->stateM) -1);
 s->stateM[sizeof(s->stateM)-1] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 5
<<<sep_out_sample>>>
cmp    $0xfff,%edi
ja     224 <rsync_roll+0x44>
mov    0x0(%rip),%rax        # 1ef <rsync_roll+0xf>
add    %edi,%esi
nopl   0x0(%rax)
cmp    %esi,%edi
je     290 <rsync_roll+0xb0>
mov    %edi,%edx
add    $0x1,%edi
movzbl 0x0(%rdx),%edx
add    %rdx,%rax
cmp    $0x1000,%edi
jne    1f8 <rsync_roll+0x18>
mov    %rax,0x0(%rip)        # 21e <rsync_roll+0x3e>
sub    $0x1000,%esi
add    %edi,%esi
cmp    %esi,%edi
jae    28a <rsync_roll+0xaa>
mov    0x0(%rip),%r8        # 231 <rsync_roll+0x51>
mov    0x0(%rip),%r9        # 238 <rsync_roll+0x58>
mov    $0xffffffff,%r10d
jmp    24a <rsync_roll+0x6a>
add    $0x1,%edi
cmp    %esi,%edi
je     27b <rsync_roll+0x9b>
mov    %rax,%r8
lea    -0x1000(%rdi),%ecx
mov    %edi,%edx
movzbl 0x0(%rdx),%eax
movzbl 0x0(%rcx),%ecx
sub    %rcx,%rax
add    %r8,%rax
cmp    %r10,%r9
jne    240 <rsync_roll+0x60>
test   $0xfff,%eax
cmove  %rdx,%r9
add    $0x1,%edi
cmp    %esi,%edi
jne    247 <rsync_roll+0x67>
mov    %rax,0x0(%rip)        # 282 <rsync_roll+0xa2>
mov    %r9,0x0(%rip)        # 289 <rsync_roll+0xa9>
retq   
repz retq 
nopl   0x0(%rax)
mov    %rax,0x0(%rip)        # 297 <rsync_roll+0xb7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rsync_roll(unsigned int start, unsigned int num)
{
    unsigned i;
    if (start < 4096) {
        for (i = start; i < 4096; i++) {
            if (i == start + num)
                return;
            rsync_sum += (ulg)window[i];
        }
        num -= (4096 - start);
        start = 4096;
    }
    for (i = start; i < start+num; i++) {
        rsync_sum += (ulg)window[i];
        rsync_sum -= (ulg)window[i - 4096];
        if (rsync_chunk_end == 0xFFFFFFFFUL && ((rsync_sum) % 4096 == 0))
            rsync_chunk_end = i;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 8
9 5
10 8
11 8
12 5
13 5
14 5
15 10
16 13
17 13
18 13
19 13
20 13
21 16
22 16
23 13
24 13
25 13
26 15
27 15
28 14
29 14
30 15
31 14
32 15
33 16
34 16
35 17
36 17
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  661 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6a0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  67f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6b8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6a0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6c4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x18(%rdi),%rax
cmp    $0x40,%rsi
mov    $0x40,%edx
movq   $0x0,(%rsp)
cmovbe %rsi,%rdx
mov    %rsp,%rsi
callq  *0x8(%rax)
mov    (%rsp),%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_urandomb_ui (gmp_randstate_ptr rstate, unsigned long bits)
{
  mp_limb_t a[1];
  a[0] = 0;
  do { gmp_randstate_ptr __rstate = (rstate); (*((gmp_randfnptr_t *) ((__rstate)->_mp_algdata._mp_lc))->randget_fn) (__rstate, a, ((bits) < ((8 * 8)) ? (bits) : ((8 * 8)))); } while (0);
  return a[0];
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 4
6 5
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    $0x2,%eax
retq   
<<<sep_in_sample>>>
nettle_version_minor (void)
{
  return 2;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    (%rdi),%r14
mov    0x18(%rdi),%r12
mov    0x8(%rdi),%rbp
mov    0x10(%rdi),%r15
test   %r14,%r14
fldt   (%r12)
je     75 <gsl_matrix_long_double_max+0x75>
shl    $0x4,%r15
xor    %r13d,%r13d
mov    %r15,0x38(%rsp)
test   %rbp,%rbp
je     88 <gsl_matrix_long_double_max+0x88>
mov    %r12,%rbx
xor    %r15d,%r15d
jmp    53 <gsl_matrix_long_double_max+0x53>
nop
fstp   %st(0)
add    $0x1,%r15
add    $0x10,%rbx
cmp    %rbp,%r15
fldt   0x20(%rsp)
je     88 <gsl_matrix_long_double_max+0x88>
fldt   (%rbx)
fucomi %st(1),%st
fxch   %st(1)
fcmovnbe %st(1),%st
fstpt  0x20(%rsp)
fld    %st(0)
fstpt  (%rsp)
fstpt  0x10(%rsp)
callq  6d <gsl_matrix_long_double_max+0x6d>
test   %eax,%eax
fldt   0x10(%rsp)
je     40 <gsl_matrix_long_double_max+0x40>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x1,%r13
add    0x38(%rsp),%r12
cmp    %r14,%r13
jne    32 <gsl_matrix_long_double_max+0x32>
jmp    75 <gsl_matrix_long_double_max+0x75>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_max (const gsl_matrix_long_double * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long double max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long double x = m->data[i * tda + j];
          if (x > max)
            max = x;
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            return x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 4
11 5
12 8
13 6
14 8
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 12
34 12
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 8
52 8
53 8
54 8
55 8
56 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <getViewerCount+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getViewerCount(void)
{
 return vl_count;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
priv_set_remove_linkdir (void)
{
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6e6 <using_history+0x6>
mov    %eax,0x0(%rip)        # 6ec <using_history+0xc>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
using_history ()
{
  history_offset = history_length;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
movq   $0x0,0x30(%rdi)
movsd  %xmm0,(%rdi)
movsd  %xmm0,0x8(%rdi)
movsd  %xmm0,0x10(%rdi)
movsd  %xmm0,0x18(%rdi)
movsd  %xmm0,0x20(%rdi)
movsd  %xmm0,0x28(%rdi)
mov    0x38(%rdi),%rdi
jmpq   5d2 <gsl_rstat_reset+0x32>
<<<sep_in_sample>>>
gsl_rstat_reset(gsl_rstat_workspace *w)
{
  int status;
  w->min = 0.0;
  w->max = 0.0;
  w->mean = 0.0;
  w->M2 = 0.0;
  w->M3 = 0.0;
  w->M4 = 0.0;
  w->n = 0;
  status = gsl_rstat_quantile_reset(w->median_workspace_p);
  return status;
}
<<<sep_in_sample>>>
1 4
2 10
3 4
4 5
5 6
6 7
7 8
8 9
9 11
10 11
<<<sep_out_sample>>>
mov    $0x2,%edx
jmpq   4760 <rpmpsf_write_beautify_psf_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmpsf_write_beautify_psf(TOPSF *topsf, int fd_out)
{
 return rpmpsf_write_beautify_psf_internal(topsf, fd_out, 2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0x10,%esi
jmpq   1bcd <nettle_cast128_set_key+0xd>
<<<sep_in_sample>>>
nettle_cast128_set_key(struct cast128_ctx *ctx, const uint8_t *key)
{
  nettle_cast5_set_key (ctx, 16, key);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 107 <postmsg+0x7>
push   %rbx
mov    %rdi,%rbx
je     117 <postmsg+0x17>
mov    0x0(%rip),%eax        # 113 <postmsg+0x13>
test   %eax,%eax
jne    140 <postmsg+0x40>
mov    %rbx,%rdi
callq  11f <postmsg+0x1f>
mov    0x0(%rip),%rdi        # 126 <postmsg+0x26>
callq  12b <postmsg+0x2b>
mov    %rbx,%rsi
mov    $0x14a,%edx
mov    $0x0,%edi
pop    %rbx
jmpq   13e <postmsg+0x3e>
xchg   %ax,%ax
callq  145 <postmsg+0x45>
mov    0x0(%rip),%rdi        # 14c <postmsg+0x4c>
mov    $0xffffffff,%edx
mov    %rbx,%rsi
callq  159 <postmsg+0x59>
mov    0x0(%rip),%rdi        # 160 <postmsg+0x60>
callq  165 <postmsg+0x65>
jmp    12b <postmsg+0x2b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
postmsg(char *msg)
{
 if (linemode == YES || incurses == NO) {
  (void) printf("%s\n", msg);
  fflush(stdout);
 }
 else {
  clearmsg();
  waddnstr(stdscr,(msg),-1);
  wrefresh(stdscr);
 }
 (void) strncpy(lastmsg, msg, sizeof(lastmsg) - 1);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 12
13 12
14 12
15 13
16 12
17 12
18 8
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
movslq %esi,%rsi
mov    0xa8(%rdi,%rsi,8),%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_mset_count (rec_mset_t mset,
                rec_mset_type_t type)
{
  return mset->count[type];
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%r9        # 7 <loglike+0x7>
movzbl (%r9),%eax
test   %al,%al
je     65 <loglike+0x65>
mov    0x0(%rip),%r10        # 16 <loglike+0x16>
mov    $0x1,%ecx
xor    %r8d,%r8d
xor    %esi,%esi
jmp    4c <loglike+0x4c>
nopw   0x0(%rax,%rax,1)
movslq %esi,%rax
add    $0x1,%esi
lea    0x1(%rcx),%rdx
movsd  (%rdi,%rax,8),%xmm0
movsd  %xmm0,(%r10,%r8,8)
movzbl (%r9,%rcx,1),%eax
test   %al,%al
je     65 <loglike+0x65>
mov    %rcx,%r8
mov    %rdx,%rcx
cmp    $0x21,%al
jne    28 <loglike+0x28>
movq   $0x0,(%r10,%r8,8)
movzbl (%r9,%rcx,1),%eax
lea    0x1(%rcx),%rdx
test   %al,%al
jne    46 <loglike+0x46>
mov    0x0(%rip),%eax        # 6b <loglike+0x6b>
test   %eax,%eax
jle    107 <loglike+0x107>
push   %r12
xorpd  %xmm3,%xmm3
push   %rbp
xor    %ebp,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
mov    0x0(%rip),%r12        # 8a <loglike+0x8a>
nopw   0x0(%rax,%rax,1)
mov    (%r12,%rbx,1),%rsi
movsd  %xmm3,0x18(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%rdi        # a3 <loglike+0xa3>
add    $0x1,%ebp
add    $0x8,%rsi
callq  *0x0(%rip)        # b0 <loglike+0xb0>
mov    0x0(%rip),%r12        # b7 <loglike+0xb7>
movapd %xmm0,%xmm2
movsd  %xmm2,0x10(%rsp)
mov    (%r12,%rbx,1),%rax
add    $0x8,%rbx
movsd  (%rax),%xmm1
movsd  %xmm1,0x8(%rsp)
callq  d8 <loglike+0xd8>
mulsd  0x8(%rsp),%xmm0
movsd  0x10(%rsp),%xmm2
cmp    %ebp,0x0(%rip)        # ea <loglike+0xea>
movsd  0x18(%rsp),%xmm3
subsd  %xmm2,%xmm0
addsd  %xmm0,%xmm3
jg     90 <loglike+0x90>
add    $0x20,%rsp
movapd %xmm3,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
retq   
xorpd  %xmm3,%xmm3
movapd %xmm3,%xmm0
retq   
<<<sep_in_sample>>>
loglike(double *selparam)
{
  int s;
  int p;
  double expected;
  double ll;
  int c;
  for (s = 0, p = 0; sel[s]; s++)
    {
      if (sel[s] != '!')
 allparam[s] = selparam[p++];
      else
 allparam[s] = 0.0;
    }
  for (ll = 0.0, c = 0; c < nc; c++)
    {
      expected = ex(allparam, tab[c] + 1);
      ll += tab[c][0] * log(expected) - expected;
    }
  return ll;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 11
6 11
7 8
8 8
9 8
10 8
11 11
12 11
13 11
14 11
15 11
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 13
24 8
25 8
26 8
27 8
28 15
29 15
30 15
31 2
32 15
33 2
34 15
35 2
36 15
37 2
38 2
39 2
40 17
41 17
42 17
43 17
44 15
45 17
46 17
47 18
48 17
49 18
50 18
51 18
52 18
53 18
54 18
55 18
56 18
57 15
58 18
59 18
60 18
61 15
62 21
63 21
64 21
65 21
66 21
67 21
68 15
69 21
70 21
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  91f <idna_to_ascii_lz+0xf>
mov    %rax,%rbx
mov    $0x9,%eax
test   %rbx,%rbx
je     946 <idna_to_ascii_lz+0x36>
mov    %rbp,%rsi
mov    %r12d,%edx
mov    %rbx,%rdi
callq  93a <idna_to_ascii_lz+0x2a>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  944 <idna_to_ascii_lz+0x34>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
idna_to_ascii_lz (const char *input, char **output, int flags)
{
  char *utf8;
  int rc;
  utf8 = stringprep_locale_to_utf8 (input);
  if (!utf8)
    return IDNA_ICONV_ERROR;
  rc = idna_to_ascii_8z (utf8, output, flags);
  free (utf8);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 7
9 6
10 6
11 8
12 8
13 8
14 8
15 9
16 8
17 9
18 10
19 11
20 11
21 11
22 11
23 11
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x20,%edi
push   %rbp
push   %rbx
mov    %rsi,%rbx
callq  1604 <swverid_debug_print+0x14>
mov    %r12,%rdi
mov    %rax,%rsi
mov    %rax,%rbp
callq  1612 <swverid_debug_print+0x22>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  161f <swverid_debug_print+0x2f>
mov    %rbp,%rdi
callq  1627 <swverid_debug_print+0x37>
mov    0x48(%r12),%ecx
mov    %rax,%r8
mov    %rbx,%rdi
mov    $0x0,%edx
xor    %esi,%esi
xor    %eax,%eax
callq  1640 <swverid_debug_print+0x50>
mov    %rbp,%rdi
callq  1648 <swverid_debug_print+0x58>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1654 <swverid_debug_print+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swverid_debug_print(SWVERID * swverid, STROB * buf)
{
 STROB * tmp;
 tmp = strob_open(32);
 swverid_print(swverid, tmp);
 strob_strcpy(buf, "");
 strob_sprintf(buf, 0, "%d: %s", swverid->alter_uuidM, strob_str(tmp));
 strob_close(tmp);
 return strob_str(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 5
9 5
10 4
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 9
27 10
28 10
29 10
30 9
31 9
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3ac <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%r8
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3dd <version_etc+0x7d>
add    $0xd8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 7
16 6
17 6
18 6
19 6
20 6
21 7
22 9
23 9
24 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1ed7 <find_function+0x7>
jmpq   960 <hash_lookup>
nopl   0x0(%rax)
<<<sep_in_sample>>>
find_function (name)
     const char *name;
{
  return (hash_lookup (name, shell_functions));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
term_change_eof (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x2,%esi
jmpq   53a <mu_attribute_unset_flagged+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_unset_flagged (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x02);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  763 <CDB___log_init_print+0x13>
test   %eax,%eax
je     770 <CDB___log_init_print+0x20>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
mov    $0x2,%edx
mov    $0x0,%esi
pop    %rbx
jmpq   783 <CDB___log_init_print+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___log_init_print(dbenv)
 DB_ENV *dbenv;
{
 int ret;
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register1_print, 1)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register_print, 2)) != 0)
  return (ret);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 5
6 5
7 5
8 12
9 12
10 12
11 8
12 8
13 8
14 12
15 8
16 8
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x20(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_nx_add (gl_oset_t set, const void *elt)
{
  return ((const struct gl_oset_impl_base *) set)->vtable->nx_add (set, elt);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     1e16 <gsl_vector_ushort_add_constant+0x36>
mov    0x10(%rdi),%rax
add    %r8,%r8
xor    %edx,%edx
nopl   (%rax)
movzwl (%rax),%ecx
add    $0x1,%rdx
cvtsi2sd %ecx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    1df8 <gsl_vector_ushort_add_constant+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_add_constant (gsl_vector_ushort * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 6
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %r15
mov    %r9d,%r15d
push   %r14
mov    %r8,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # ccb8 <ch_tg_hdy+0x28>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  1f0 <ch_base_hdy>
mov    0x0(%rip),%rdi        # cccb <ch_tg_hdy+0x3b>
mov    0x0(%rip),%rbx        # ccd2 <ch_tg_hdy+0x42>
callq  ccd7 <ch_tg_hdy+0x47>
mov    0x70(%rsp),%ecx
mov    %r15d,0x18(%rsp)
mov    %r12d,%esi
mov    %r14,0x10(%rsp)
mov    %r13d,0x8(%rsp)
mov    $0x1,%r9d
movl   $0x5,(%rsp)
mov    $0x0,%r8d
mov    %rax,%rdx
mov    %ecx,0x20(%rsp)
mov    0x0(%rbp),%edi
mov    %rbx,%rcx
callq  cd12 <ch_tg_hdy+0x82>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ch_tg_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_TG";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[169].ht_text),
    ptr_cc_id, "+", 1, 5, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
mov    $0x4,%edi
push   %rbx
sub    $0x18,%rsp
callq  92 <dico_log_stream_create+0x12>
test   %rax,%rax
mov    %rax,%rbx
je     f0 <dico_log_stream_create+0x70>
lea    0x8(%rsp),%rdi
mov    %rax,%rdx
mov    $0x2,%esi
callq  ac <dico_log_stream_create+0x2c>
test   %eax,%eax
jne    f0 <dico_log_stream_create+0x70>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  bf <dico_log_stream_create+0x3f>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  ce <dico_log_stream_create+0x4e>
mov    0x8(%rsp),%rdi
mov    $0x400,%edx
mov    $0x1,%esi
callq  e2 <dico_log_stream_create+0x62>
mov    %ebp,(%rbx)
mov    0x8(%rsp),%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dico_log_stream_create(int level)
{
    struct log_stream *p = malloc(sizeof(*p));
    dico_stream_t stream;
    if (!p || dico_stream_create(&stream, 0x02, p))
 return ((void *)0);
    dico_stream_set_write(stream, log_write);
    dico_stream_set_destroy(stream, log_destroy);
    dico_stream_set_buffer(stream, dico_buffer_line, 1024);
    p->level = level;
    return stream;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 5
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 8
20 8
21 8
22 9
23 9
24 9
25 9
26 10
27 11
28 12
29 12
30 12
31 12
32 12
33 6
34 12
35 12
36 12
<<<sep_out_sample>>>
movsd  0x10(%rsi),%xmm1
ucomisd 0x0(%rip),%xmm1        # d <VEyeToScreen+0xd>
jbe    60 <VEyeToScreen+0x60>
movsd  0x130(%rdi),%xmm0
movswl 0x128(%rdi),%r8d
mulsd  (%rsi),%xmm0
divsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
movsd  0x138(%rdi),%xmm0
mulsd  0x8(%rsi),%xmm0
divsd  %xmm1,%xmm0
add    %r8d,%eax
sar    $0x2,%eax
mov    %eax,(%rdx)
movswl 0x12a(%rdi),%eax
cvttsd2si %xmm0,%edx
sub    %edx,%eax
sar    $0x2,%eax
mov    %eax,(%rcx)
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
VEyeToScreen(Viewport * v, VPoint * p, int *x, int *y)
{
 register int valid;
 if (p->z > 0.0) {
  *x = (v->Middl.x + (int) (v->Scale.x * p->x / p->z)) >> 2;
  *y = (v->Middl.y - (int) (v->Scale.y * p->y / p->z)) >> 2;
  valid = 1;
 }
 else
  valid = 0;
 return valid;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 10
24 12
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1,%eax
cmove  %rax,%rsi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
minstd_set (void *vstate, unsigned long int s)
{
  minstd_state_t *state = (minstd_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s;
  return;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
mov    $0x40800000,%esi
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  f5e4 <_x87_bungti_d+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r12d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  e610 <_x87_movi_d>
mov    0x0(%rbp),%ecx
mov    %r14d,%r8d
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0x2,%esi
and    $0x7fff,%ecx
callq  0 <_x87jcc>
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  f637 <_x87_bungti_d+0x77>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_x87_bungti_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x2, i0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), r0); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
cmp    $0x1c,%edi
ja     20 <gdbm_strerror+0x20>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rsi
mov    $0x0,%edi
jmpq   1a <gdbm_strerror+0x1a>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   2f <gdbm_strerror+0x2f>
<<<sep_in_sample>>>
gdbm_strerror (gdbm_error error)
{
  if (((int)error < 0) || ((int)error > 28))
    {
      return dgettext ("gdbm", "Unknown error");
    }
  else
    {
      return dgettext ("gdbm", gdbm_errlist[(int)error]);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 9
5 9
6 9
7 9
8 5
9 5
10 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  649 <dispose_function_def+0x9>
mov    %rbx,%rdi
mov    $0xf1,%edx
mov    $0x0,%esi
pop    %rbx
jmpq   65c <dispose_function_def+0x1c>
<<<sep_in_sample>>>
dispose_function_def (c)
     FUNCTION_DEF *c;
{
  dispose_function_def_contents (c);
  sh_xfree((c), "dispose_cmd.c", 241);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 6
8 5
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x0,%eax
je     299 <set_current_flags+0x29>
nopw   0x0(%rax,%rax,1)
movsbl (%rdi),%esi
mov    (%rax),%rcx
mov    %rax,%rdx
add    $0x1,%rdi
add    $0x10,%rax
mov    %esi,(%rcx)
cmpb   $0x0,0x8(%rdx)
jne    280 <set_current_flags+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_current_flags (bitmap)
     const char *bitmap;
{
  int i;
  if (bitmap == 0)
    return;
  for (i = 0; shell_flags[i].name; i++)
    *(shell_flags[i].value) = bitmap[i];
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    0x38(%rdx),%eax
cmp    $0x1,%eax
je     928 <pred_links+0x38>
jb     918 <pred_links+0x28>
cmp    $0x2,%eax
jne    910 <pred_links+0x20>
mov    0x40(%rdx),%rax
cmp    %rax,0x10(%rsi)
sete   %al
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x40(%rdx),%rax
cmp    %rax,0x10(%rsi)
seta   %al
retq   
nopl   0x0(%rax)
mov    0x40(%rdx),%rax
cmp    %rax,0x10(%rsi)
setb   %al
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_links (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  switch (pred_ptr->args.numinfo.kind)
    {
    case COMP_GT:
      if (stat_buf->st_nlink > pred_ptr->args.numinfo.l_val)
 return (1);
      break;
    case COMP_LT:
      if (stat_buf->st_nlink < pred_ptr->args.numinfo.l_val)
 return (1);
      break;
    case COMP_EQ:
      if (stat_buf->st_nlink == pred_ptr->args.numinfo.l_val)
 return (1);
      break;
    }
  return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 15
8 15
9 15
10 15
11 15
12 19
13 20
14 20
15 7
16 7
17 7
18 7
19 7
20 11
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  54c <gsl_sf_airy_zero_Ai_deriv+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    560 <gsl_sf_airy_zero_Ai_deriv+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x21c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  576 <gsl_sf_airy_zero_Ai_deriv+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_airy_zero_Ai_deriv(unsigned int s)
{
  gsl_sf_result result; int status = gsl_sf_airy_zero_Ai_deriv_e(s, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_airy_zero_Ai_deriv_e(s, &result)", "airy_zero.c", 540, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  4fb <emit_bug_reporting_address+0xb>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  50a <emit_bug_reporting_address+0x1a>
mov    $0x0,%edi
callq  514 <emit_bug_reporting_address+0x24>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%edx
xor    %eax,%eax
callq  528 <emit_bug_reporting_address+0x38>
mov    0x0(%rip),%rbx        # 52f <emit_bug_reporting_address+0x3f>
mov    $0x0,%edi
callq  539 <emit_bug_reporting_address+0x49>
mov    %rax,%rdi
mov    %rbx,%rsi
pop    %rbx
jmpq   545 <emit_bug_reporting_address+0x55>
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  __printf__ (gettext ("\nReport bugs to: %s\n"), "bug-recutils@gnu.org");
  __printf__ (gettext ("%s home page: <%s>\n"), "GNU recutils", "http://www.gnu.org/software/recutils/");
  fputs_unlocked (gettext ("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),stdout)
                ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 7
21 5
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_header (MESSAGE msg)
{
  return msg->header;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_char_location (rec_field_t field)
{
  return field->char_location;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 9a <swssh_deactivate_sanity_check+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swssh_deactivate_sanity_check(void)
{
 g_active_flag = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
mov    %rcx,%r8
cmp    $0x1,%eax
je     40 <call_macro+0x40>
cmp    $0x2,%eax
jne    20 <call_macro+0x20>
mov    0x20(%rdi),%rax
mov    %rcx,%rdi
jmpq   *%rax
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 2a <call_macro+0x2a>
mov    $0x0,%edx
xor    %esi,%esi
xor    %eax,%eax
callq  38 <call_macro+0x38>
callq  3d <call_macro+0x3d>
nopl   (%rax)
mov    %rdx,%rcx
mov    %esi,%edx
mov    %rdi,%rsi
mov    %r8,%rdi
jmpq   50 <expand_token.isra.0>
<<<sep_in_sample>>>
call_macro (symbol *sym, int argc, token_data **argv,
                 struct obstack *expansion)
{
  switch ((((&(sym)->data)->type)))
    {
    case TOKEN_FUNC:
      (*(((&(sym)->data)->u.func))) (expansion, argc, argv);
      break;
    case TOKEN_TEXT:
      expand_user_macro (expansion, sym, argc, argv);
      break;
    case TOKEN_VOID:
    default:
      (m4_error (warning_status, 0, "INTERNAL ERROR: bad symbol type in call_macro ()"))
                                                                    ;
      abort ();
    }
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 3
12 14
13 14
14 14
15 14
16 14
17 16
18 16
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
push   %r12
mov    $0x1,%ecx
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
callq  37e7 <gsl_fft_complex_radix2_inverse+0x17>
test   %eax,%eax
jne    383e <gsl_fft_complex_radix2_inverse+0x6e>
test   %rbx,%rbx
js     3848 <gsl_fft_complex_radix2_inverse+0x78>
cvtsi2sd %rbx,%xmm1
movsd  0x0(%rip),%xmm0        # 37fd <gsl_fft_complex_radix2_inverse+0x2d>
test   %rbx,%rbx
divsd  %xmm1,%xmm0
je     383e <gsl_fft_complex_radix2_inverse+0x6e>
mov    %r12,%rsi
mov    %rbp,%rdi
xor    %ecx,%ecx
shl    $0x4,%rsi
nopw   0x0(%rax,%rax,1)
add    $0x1,%rcx
movsd  (%rdi),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,(%rdi)
movsd  0x8(%rdi),%xmm1
mulsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rdi)
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    3818 <gsl_fft_complex_radix2_inverse+0x48>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbx,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmp    37f5 <gsl_fft_complex_radix2_inverse+0x25>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_radix2_inverse (gsl_complex_packed_array data,
                                          const size_t stride, const size_t n)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_radix2_transform (data, stride, n, sign);
  if (status)
    {
      return status;
    }
  {
    const double norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((data)[2*(stride)*(i)]) *= norm;
        ((data)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 5
9 6
10 6
11 11
12 11
13 11
14 11
15 13
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 15
26 15
27 16
28 16
29 16
30 16
31 13
32 13
33 20
34 20
35 20
36 20
37 20
38 11
39 11
40 11
41 11
42 11
43 11
44 11
45 11
46 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1a7 <proclist_count+0x7>
jmpq   1ac <proclist_count+0xc>
<<<sep_in_sample>>>
proclist_count ()
{
  return list_count (process_list);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # bb <clearScreen+0xb>
mov    $0x4,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  cf <clearScreen+0x1f>
mov    0x0(%rip),%rcx        # d6 <clearScreen+0x26>
mov    $0x7,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  ea <clearScreen+0x3a>
mov    0x0(%rip),%rcx        # f1 <clearScreen+0x41>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   109 <clearScreen+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
clearScreen()
{
 fprintf(stdout, "\e[2J");
 fprintf(stdout, "\x1b[37;4m");
 fprintf(stdout, "\e[3J\e[1;1H");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 5
18 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
test   %rsi,%rsi
je     14 <osip_message_set_accept_language+0x14>
cmpb   $0x0,(%rsi)
jne    20 <osip_message_set_accept_language+0x20>
add    $0x20,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
mov    %rdi,%rbp
lea    0x18(%rsp),%rdi
mov    %rsi,0x8(%rsp)
callq  32 <osip_message_set_accept_language+0x32>
test   %eax,%eax
mov    %eax,%ebx
mov    0x8(%rsp),%rsi
jne    14 <osip_message_set_accept_language+0x14>
mov    0x18(%rsp),%rdi
callq  47 <osip_message_set_accept_language+0x47>
test   %eax,%eax
mov    %eax,%r12d
jne    70 <osip_message_set_accept_language+0x70>
mov    0x18(%rsp),%rsi
lea    0x48(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
mov    $0xffffffff,%edx
callq  6b <osip_message_set_accept_language+0x6b>
jmp    14 <osip_message_set_accept_language+0x14>
nopl   (%rax)
mov    0x18(%rsp),%rdi
mov    %r12d,%ebx
callq  7d <osip_message_set_accept_language+0x7d>
jmp    14 <osip_message_set_accept_language+0x14>
nop
<<<sep_in_sample>>>
osip_message_set_accept_language (osip_message_t * sip, const char *hvalue)
{
  osip_accept_language_t *accept_language;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_accept_encoding_init(&accept_language);
  if (i != 0)
    return i;
  i = osip_accept_encoding_parse(accept_language, hvalue);
  if (i != 0) {
    osip_accept_encoding_free (accept_language);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->accept_languages, accept_language, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 2
6 5
7 5
8 5
9 5
10 18
11 18
12 18
13 18
14 18
15 18
16 18
17 18
18 7
19 7
20 7
21 8
22 7
23 8
24 8
25 10
26 10
27 11
28 10
29 11
30 16
31 16
32 15
33 16
34 16
35 17
36 17
37 12
38 13
39 12
40 13
41 13
<<<sep_out_sample>>>
push   %r12
mov    $0x1,%eax
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    (%rdi),%ebx
cmp    (%rsi),%ebx
je     1930 <grecs_node_eq+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
xor    %al,%al
test   %ebx,%ebx
je     1925 <grecs_node_eq+0x15>
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  1943 <grecs_node_eq+0x33>
test   %eax,%eax
jne    1968 <grecs_node_eq+0x58>
cmp    $0x2,%ebx
jne    1925 <grecs_node_eq+0x15>
mov    0x70(%r12),%rsi
mov    0x70(%rbp),%rdi
callq  195a <grecs_node_eq+0x4a>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    1925 <grecs_node_eq+0x15>
nopl   0x0(%rax)
mov    $0x1,%eax
jmp    1925 <grecs_node_eq+0x15>
nop
<<<sep_in_sample>>>
grecs_node_eq(struct grecs_node *a, struct grecs_node *b)
{
 if (a->type != b->type)
  return 1;
 if (a->type == grecs_node_root)
  return 0;
 if (strcmp(a->ident, b->ident))
  return 1;
 if (a->type == grecs_node_block &&
     !grecs_value_eq(a->v.value, b->v.value))
  return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 13
11 13
12 13
13 13
14 13
15 6
16 5
17 5
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 10
26 10
27 10
28 9
29 9
30 9
31 9
32 9
33 4
34 4
35 4
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
jmpq   a50 <quotearg_n_options>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl (%rdi),%eax
test   %al,%al
jne    83 <mu_str_skip_cset_comp+0x23>
jmp    93 <mu_str_skip_cset_comp+0x33>
nopl   (%rax)
add    $0x1,%rbx
movzbl (%rbx),%eax
test   %al,%al
je     93 <mu_str_skip_cset_comp+0x33>
movsbl %al,%esi
mov    %rbp,%rdi
callq  8e <mu_str_skip_cset_comp+0x2e>
test   %rax,%rax
je     78 <mu_str_skip_cset_comp+0x18>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_str_skip_cset_comp (const char *str, const char *cset)
{
  for (; *str && strchr (cset, *str) == ((void *)0); str++)
    ;
  return (char*) str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  3adc <gsl_sf_ellint_Pcomp+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3af0 <gsl_sf_ellint_Pcomp+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x25d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b06 <gsl_sf_ellint_Pcomp+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_Pcomp(double k, double n, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_Pcomp_e(k, n, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_Pcomp_e(k, n, mode, &result)", "ellint.c", 605, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
test   %rsi,%rsi
jne    10 <strmatch+0x10>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
test   %rdi,%rdi
je     5 <strmatch+0x5>
jmpq   1a <strmatch+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strmatch (pattern, string, flags)
     char *pattern;
     char *string;
     int flags;
{
  if (string == 0 || pattern == 0)
    return 1;
  return (xstrmatch (pattern, string, flags));
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 6
7 6
8 8
9 8
<<<sep_out_sample>>>
push   %r15
mov    %ecx,%r15d
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    (%rdi),%eax
test   %eax,%eax
jg     b3b <rec_fex_member_p+0x3b>
jmp    b80 <rec_fex_member_p+0x80>
nopl   0x0(%rax)
mov    0x10(%rbp),%rax
cmp    %r14d,0x1c(%rax)
je     b5c <rec_fex_member_p+0x5c>
add    $0x1,%ebx
cmp    %ebx,(%r12)
jle    b80 <rec_fex_member_p+0x80>
movslq %ebx,%rax
mov    %r13,%rdi
lea    (%r12,%rax,8),%rbp
mov    0x10(%rbp),%rax
mov    0x8(%rax),%rsi
callq  b52 <rec_fex_member_p+0x52>
test   %al,%al
je     b32 <rec_fex_member_p+0x32>
cmp    $0xffffffff,%r14d
jne    b28 <rec_fex_member_p+0x28>
cmp    $0xffffffff,%r15d
je     b6c <rec_fex_member_p+0x6c>
mov    0x10(%rbp),%rax
cmp    %r15d,0x18(%rax)
jne    b32 <rec_fex_member_p+0x32>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_fex_member_p (rec_fex_t fex,
                  const char *fname,
                  int min,
                  int max)
{
  _Bool res = 0;
  int i;
  for (i = 0; i < fex->num_elems; i++)
    {
      if (rec_field_name_equal_p (fname,
                                  fex->elems[i]->field_name)
          && ((min == -1) || (fex->elems[i]->min == min))
          && ((max == -1) || (fex->elems[i]->max == max)))
        {
          res = 1;
          break;
        }
    }
  return res;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 5
13 8
14 8
15 8
16 8
17 8
18 12
19 12
20 12
21 8
22 8
23 8
24 8
25 10
26 10
27 11
28 10
29 10
30 10
31 10
32 12
33 12
34 13
35 13
36 13
37 13
38 13
39 20
40 15
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 6
50 20
51 20
52 20
53 20
54 20
55 20
56 20
57 20
<<<sep_out_sample>>>
mov    (%rdi),%rsi
push   %rbx
test   %rsi,%rsi
je     210 <grecs_list_pop+0x20>
mov    0x10(%rsi),%rbx
callq  202 <grecs_list_pop+0x12>
mov    %rbx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
xor    %ebx,%ebx
jmp    202 <grecs_list_pop+0x12>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_list_pop(struct grecs_list *lp)
{
 void *data;
 struct grecs_list_entry *ep = lp->head;
 if (ep) {
  data = ep->data;
  grecs_list_remove_entry(lp, ep);
 } else
  data = ((void *)0);
 return data;
}
<<<sep_in_sample>>>
1 4
2 2
3 5
4 5
5 6
6 7
7 11
8 11
9 11
10 11
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    59e0 <gsl_matrix_float_const_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,4),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  5a02 <gsl_matrix_float_const_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_const_subdiagonal (const gsl_matrix_float * m,
                                    const size_t k)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %r14
movzwl %di,%edi
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdx,%rbx
lea    0x2(%rbx),%r12
callq  91d <makerequest+0x1d>
mov    %r13,%rdi
mov    %ax,(%rbx)
callq  928 <makerequest+0x28>
mov    %r13,%rsi
mov    %rax,%r14
mov    %r12,%rdi
mov    $0x1f6,%edx
callq  93b <makerequest+0x3b>
cmp    $0x1f6,%r14
mov    $0x1f6,%edx
mov    %rbp,%rsi
cmovbe %r14,%rdx
add    %r12,%rdx
lea    0x1(%rdx),%r13
movb   $0x0,(%rdx)
mov    %r13,%rdi
callq  960 <makerequest+0x60>
mov    %rbp,%rdi
callq  968 <makerequest+0x68>
add    %r13,%rax
movb   $0x0,(%rax)
add    $0x1,%rax
sub    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
makerequest (int request, const char *name, struct tftphdr *tp,
      const char *mode)
{
  register char *cp;
  size_t arglen, len;
  tp->th_opcode = htons ((unsigned short) request);
  cp = (char *) &(tp->th_u1.tu_stuff);
  len = 512 +4 - sizeof (struct tftphdr) - sizeof ("netascii");
  arglen = strlen (name);
  strncpy (cp, name, len);
  cp += (arglen < len) ? arglen : len;
  *cp++ = '\0';
  strcpy (cp, mode);
  cp += strlen (mode);
  *cp++ = '\0';
  return cp - (char *) tp;
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 7
11 6
12 9
13 6
14 9
15 10
16 9
17 10
18 10
19 10
20 11
21 11
22 13
23 11
24 11
25 12
26 12
27 13
28 13
29 14
30 14
31 14
32 15
33 15
34 16
35 17
36 17
37 17
38 17
39 17
40 17
41 17
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 469 <meta1restart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     4a0 <meta1restart+0x40>
mov    0x0(%rip),%rdx        # 47a <meta1restart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     4a0 <meta1restart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  370 <meta1_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c0 <meta1_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  140 <meta1ensure_buffer_stack>
mov    0x0(%rip),%rbp        # 4ac <meta1restart+0x4c>
mov    0x0(%rip),%rax        # 4b3 <meta1restart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 4bf <meta1restart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  4c9 <meta1restart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    483 <meta1restart+0x23>
jmp    486 <meta1restart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1restart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        meta1ensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            meta1_create_buffer(meta1in,16384 );
 }
 meta1_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 meta1_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%eax
mov    %rcx,%r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
cmove  %rax,%rbx
mov    %rdi,0x18(%rsp)
callq  f80 <quotearg_buffer+0x30>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    0x30(%rbx),%rax
mov    0x4(%rbx),%r9d
mov    0x18(%rsp),%rdi
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
callq  100 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   3e8 <grecs_txtacc_clear+0x8>
<<<sep_in_sample>>>
grecs_txtacc_clear(struct grecs_txtacc *acc)
{
 grecs_list_clear(acc->cur);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 86 <atfield+0x6>
mov    0x0(%rip),%esi        # 8c <atfield+0xc>
mov    0x0(%rip),%rdi        # 93 <atfield+0x13>
jmpq   98 <atfield+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
atfield(void)
{
 wmove(stdscr,(fldline),(fldcolumn));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x10(%rsi),%rax
cmp    $0x5,%rax
jbe    94b8 <_jit_putargi_d+0x78>
mov    $0x20000000,%esi
movsd  %xmm0,0x8(%rsp)
callq  946a <_jit_putargi_d+0x2a>
movsd  0x8(%rsp),%xmm0
movslq %eax,%r13
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0x130,%esi
mov    %eax,%r12d
callq  9486 <_jit_putargi_d+0x46>
mov    0x10(%rbp),%rdx
mov    %rbx,%rdi
mov    %r13,%r8
mov    $0x138,%esi
mov    $0xf,%ecx
callq  949f <_jit_putargi_d+0x5f>
add    $0x18,%rsp
mov    %rbx,%rdi
mov    %r12d,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   94b4 <_jit_putargi_d+0x74>
nopl   0x0(%rax)
add    $0x18,%rsp
mov    $0x1f,%edx
mov    $0x130,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
sub    %rax,%rdx
jmpq   94d4 <_jit_putargi_d+0x94>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_putargi_d(jit_state_t *_jit, jit_float64_t u, jit_node_t *v)
{
    jit_int32_t regno;
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_wd(_jit,jit_code_movi_d,_XMM0 - v->u.w,u);
    else
    {
 regno = _jit_get_reg(_jit,0x20000000);
 _jit_new_node_wd(_jit,jit_code_movi_d,regno,u);
 _jit_new_node_www(_jit,jit_code_stxi_d,v->u.w,_RBP,regno);
 _jit_unget_reg(_jit,regno);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 10
19 9
20 10
21 11
22 11
23 11
24 11
25 11
26 11
27 14
28 12
29 12
30 14
31 14
32 14
33 14
34 12
35 12
36 14
37 6
38 6
39 14
40 14
41 14
42 14
43 6
44 6
45 6
<<<sep_out_sample>>>
mov    0x18(%rdi),%edi
mov    $0x5307,%esi
xor    %eax,%eax
jmpq   5f <audio_stop_linux+0xf>
nop
<<<sep_in_sample>>>
audio_stop_linux (void *p_user_data)
{
  const _img_private_t *p_env = p_user_data;
  return ioctl(p_env->gen.fd, 0x5307);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_cnonce (osip_authentication_info_t * authentication_info)
{
  return authentication_info->cnonce;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%r10d        # 132b <tk_hdy+0xb>
xor    %eax,%eax
movq   $0x0,0x0(%rip)        # 1338 <tk_hdy+0x18>
test   %r10d,%r10d
sete   %al
mov    %eax,0x0(%rip)        # 1344 <tk_hdy+0x24>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  1350 <tk_hdy+0x30>
mov    0x0(%rip),%r11d        # 1357 <tk_hdy+0x37>
xor    %eax,%eax
test   %r11d,%r11d
sete   %al
mov    %eax,0x0(%rip)        # 1365 <tk_hdy+0x45>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tk_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "TK";
  use_other_cc = !use_other_cc;
  nz_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 11
3 11
4 10
5 11
6 11
7 11
8 12
9 12
10 12
11 13
12 13
13 13
14 13
15 13
16 14
17 14
18 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     280 <iso9660_xa_free+0x10>
jmpq   27a <iso9660_xa_free+0xa>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_xa_free (iso9660_xa_t *_xa)
{
  if (_xa != ((void *)0))
    free(_xa);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
sub    $0x28,%rsp
xorpd  %xmm0,%xmm0
ucomisd %xmm0,%xmm3
jnp    128 <gsl_cdf_gumbel2_Qinv+0x88>
ucomisd 0x0(%rip),%xmm3        # ba <gsl_cdf_gumbel2_Qinv+0x1a>
jp     c8 <gsl_cdf_gumbel2_Qinv+0x28>
jne    c8 <gsl_cdf_gumbel2_Qinv+0x28>
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm4        # d0 <gsl_cdf_gumbel2_Qinv+0x30>
movsd  %xmm2,0x18(%rsp)
xorpd  %xmm4,%xmm3
movsd  %xmm1,0x10(%rsp)
movapd %xmm4,(%rsp)
movapd %xmm3,%xmm0
callq  ee <gsl_cdf_gumbel2_Qinv+0x4e>
movapd (%rsp),%xmm4
xorpd  %xmm4,%xmm0
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm2
movsd  0x0(%rip),%xmm5        # 10b <gsl_cdf_gumbel2_Qinv+0x6b>
add    $0x28,%rsp
divsd  %xmm0,%xmm2
divsd  %xmm1,%xmm5
movapd %xmm2,%xmm0
movapd %xmm5,%xmm1
jmpq   124 <gsl_cdf_gumbel2_Qinv+0x84>
nopl   0x0(%rax)
jne    b2 <gsl_cdf_gumbel2_Qinv+0x12>
movsd  0x0(%rip),%xmm0        # 132 <gsl_cdf_gumbel2_Qinv+0x92>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel2_Qinv (const double Q, const double a, const double b)
{
  double x;
  if (Q == 0.0)
    {
      return (__builtin_inff());
    }
  else if (Q == 1.0)
    {
      return 0.0;
    }
  x = pow(b / (-log1p(-Q)), 1/a);
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 8
7 8
8 8
9 14
10 14
11 14
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 14
25 12
26 12
27 12
28 12
29 12
30 12
31 4
32 6
33 14
34 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x288,%edi
callq  9ee <rec_aggregate_reg_new+0xe>
test   %rax,%rax
je     9fe <rec_aggregate_reg_new+0x1e>
movq   $0x0,0x280(%rax)
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_aggregate_reg_new (void)
{
  rec_aggregate_reg_t new;
  new = malloc (sizeof (struct rec_aggregate_reg_s));
  if (new)
    {
      new->num_functions = 0;
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 10
8 10
9 10
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%edi
mov    $0xc,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x18,%rsp
callq  37 <smtp_has_starttls+0x17>
test   %eax,%eax
jne    6b <smtp_has_starttls+0x4b>
jmp    79 <smtp_has_starttls+0x59>
nopl   (%rax)
mov    0x8(%rsp),%rdx
mov    $0x0,%edi
mov    %rbp,%rcx
mov    $0x1,%eax
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rdx,%rsi
cmove  %eax,%ebx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     88 <smtp_has_starttls+0x68>
lea    0x8(%rsp),%rdi
callq  75 <smtp_has_starttls+0x55>
test   %eax,%eax
jne    40 <smtp_has_starttls+0x20>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_has_starttls (void)
{
  char *in;
  int has_tls = 0;
  if (!writeln ("EHLO [127.0.0.1]"))
    return 0;
  do
    {
      if (!readln (&in))
 return 0;
      if (strncmp (in, "250-STARTTLS", strlen ("250-STARTTLS")) == 0)
 has_tls = 1;
    }
  while (strncmp (in, "250 ", 4) != 0);
  return has_tls;
}
<<<sep_in_sample>>>
1 2
2 5
3 11
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 11
13 11
14 11
15 12
16 11
17 12
18 14
19 14
20 14
21 12
22 14
23 14
24 9
25 9
26 9
27 9
28 16
29 6
30 16
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 16
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
mov    $0x28,%edi
sub    $0x8,%rsp
callq  1b <mu_observer_create+0x1b>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     31 <mu_observer_create+0x31>
mov    %rbp,0x8(%rdx)
xor    %al,%al
mov    %rdx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_observer_create (mu_observer_t *pobserver, void *owner)
{
  mu_observer_t observer;
  observer = calloc (sizeof (*observer), 1);
  if (observer == ((void *)0))
    return 12;
  observer->owner = owner;
  *pobserver = observer;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 2
8 4
9 4
10 6
11 5
12 5
13 7
14 9
15 8
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  8b9 <print_version+0x9>
mov    $0x0,%edi
callq  8c3 <print_version+0x13>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   8cf <print_version+0x1f>
nop
<<<sep_in_sample>>>
print_version(const char *program_version, FILE *stream)
{
  print_version_only(program_version, stream);
  fputs (gettext("License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"),
  stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 6
9 4
10 4
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 7c9 <gcide_markup_yyrestart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     800 <gcide_markup_yyrestart+0x40>
mov    0x0(%rip),%rdx        # 7da <gcide_markup_yyrestart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     800 <gcide_markup_yyrestart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  6d0 <gcide_markup_yy_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c0 <gcide_markup_yy_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  4d0 <yyensure_buffer_stack>
mov    0x0(%rip),%rbp        # 80c <gcide_markup_yyrestart+0x4c>
mov    0x0(%rip),%rax        # 813 <gcide_markup_yyrestart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 81f <gcide_markup_yyrestart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  829 <gcide_markup_yyrestart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    7e3 <gcide_markup_yyrestart+0x23>
jmp    7e6 <gcide_markup_yyrestart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gcide_markup_yyrestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        yyensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            gcide_markup_yy_create_buffer(gcide_markup_yyin,16384 );
 }
 gcide_markup_yy_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 gcide_markup_yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1c26 <java_get_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_get_debug (void)
{
        return java__flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
yywrap(void)
{
       return 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  154 <init_diag_more+0x14>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   c0 <update_diag_more>
<<<sep_in_sample>>>
init_diag_more(const gsl_matrix * J, gsl_vector * diag)
{
  int status;
  gsl_vector_set_zero(diag);
  status = update_diag_more(J, diag);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 7
9 5
10 5
11 7
12 7
13 5
<<<sep_out_sample>>>
test   %edx,%edx
push   %rbx
mov    %esi,%ebx
je     18 <get_key_len+0x18>
test   %esi,%esi
je     38 <get_key_len+0x38>
cmp    %esi,%edx
mov    %edx,%eax
jne    42 <get_key_len+0x42>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %esi,%esi
mov    %esi,%eax
je     50 <get_key_len+0x50>
xchg   %ax,%ax
cmpb   $0x0,(%rdi)
je     2e <get_key_len+0x2e>
add    $0x1,%rdi
sub    $0x1,%eax
jne    20 <get_key_len+0x20>
sub    %eax,%ebx
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  42 <get_key_len+0x42>
mov    $0x0,%edi
callq  4c <get_key_len+0x4c>
mov    %ebx,%eax
pop    %rbx
retq   
callq  55 <get_key_len+0x55>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_key_len(char *s, unsigned int len, int numeric)
{
  if (numeric)
    {
      if (len == 0)
        fatal ("hashtab.c (get_key_len): hashing a num with len == 0");
      if (len != numeric)
        fatal ("hashtab.c (get_key_len): hashing a num with len != numeric");
      return len;
    }
  else
    {
      if (!len)
        return strlen (s);
      else
        {
          unsigned int i;
          for (i = len; i && (*s != '\0'); s++, i--)
            ;
          return len - i;
        }
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 7
8 7
9 7
10 23
11 23
12 23
13 13
14 13
15 13
16 13
17 18
18 18
19 18
20 18
21 18
22 20
23 20
24 23
25 23
26 23
27 6
28 6
29 8
30 8
31 8
32 23
33 23
34 14
35 23
36 23
37 23
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_uri (const osip_message_t * sip)
{
  return sip->req_uri;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
xor    %eax,%eax
cmpw   $0x0,0x62(%rcx)
je     cc3 <avoid_dfa+0x33>
add    %rsi,%rdx
cmp    %rdx,%rsi
jb     cb9 <avoid_dfa+0x29>
jmp    cc3 <avoid_dfa+0x33>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rsi
cmp    %rdx,%rsi
je     cc8 <avoid_dfa+0x38>
cmpb   $0xa,(%rsi)
jne    cb0 <avoid_dfa+0x20>
mov    $0x1,%eax
repz retq 
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
avoid_dfa(NODE *re, char *str, size_t len)
{
 char *end;
 if (! re->sub.nodep.r.preg->has_anchor)
  return 0;
 for (end = str + len; str < end; str++)
  if (*str == '\n')
   return 1;
 return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 10
17 10
18 5
19 5
20 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
test   %rbp,%rbp
je     1a0 <canon_doc_option+0x70>
callq  146 <canon_doc_option+0x16>
mov    %rbp,%rdx
mov    %rax,%r8
jmp    153 <canon_doc_option+0x23>
xchg   %ax,%ax
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
mov    (%r8),%rsi
add    $0x1,%rdx
movzbl %cl,%edi
movzwl (%rsi,%rdi,2),%esi
test   $0x2000,%si
jne    150 <canon_doc_option+0x20>
xor    %eax,%eax
cmp    $0x2d,%cl
setne  %al
test   %cl,%cl
je     197 <canon_doc_option+0x67>
and    $0x8,%esi
je     18d <canon_doc_option+0x5d>
jmp    197 <canon_doc_option+0x67>
xchg   %ax,%ax
mov    (%r8),%rsi
add    $0x1,%rdx
testb  $0x8,(%rsi,%rcx,2)
jne    197 <canon_doc_option+0x67>
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
jne    180 <canon_doc_option+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 9
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 11
36 11
37 11
38 15
39 15
40 15
41 15
42 15
43 15
44 5
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
mov    %rsi,0x68(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_maxbuf_set (Gsasl * ctx,
      Gsasl_client_callback_maxbuf cb)
{
  ctx->cbc_maxbuf = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmp    $0x1,%edi
je     9c8 <ds_verbose+0x58>
mov    0x8(%rsi),%rdi
lea    0x8(%rsp),%rsi
mov    $0xa,%edx
callq  98c <ds_verbose+0x1c>
mov    0x8(%rsp),%rdx
cmpb   $0x0,(%rdx)
jne    9a8 <ds_verbose+0x38>
mov    %eax,0x0(%rip)        # 99c <ds_verbose+0x2c>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  9b2 <ds_verbose+0x42>
mov    %rax,%rdi
xor    %eax,%eax
callq  9bc <ds_verbose+0x4c>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%esi        # 9ce <ds_verbose+0x5e>
mov    $0x0,%edi
xor    %eax,%eax
callq  9da <ds_verbose+0x6a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
ds_verbose(int argc, char **argv)
{
    if (argc == 1)
 printf("%d\n", debug_level);
    else {
 char *p;
 int n = strtoul(argv[1], &p, 10);
 if (*p)
     script_error(gettext ("invalid number"));
 else
     debug_level = n;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 7
5 7
6 7
7 7
8 8
9 8
10 8
11 7
12 13
13 13
14 13
15 9
16 9
17 9
18 9
19 9
20 13
21 13
22 13
23 4
24 4
25 4
26 4
27 13
28 13
29 13
<<<sep_out_sample>>>
movabs $0x8ffffffff,%rax
and    0x8(%rsi),%rax
movabs $0x800000007,%rdx
cmp    %rdx,%rax
sete   %al
movzbl %al,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_indirect_p(jit_state_t *_jit, jit_node_t *node)
{
    return (node->code == jit_code_label && !!(node->flag & 0x00000008));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     d14 <gsl_vector_long_double_scale+0x34>
movsd  %xmm0,-0x10(%rsp)
mov    0x10(%rdi),%rax
shl    $0x4,%rsi
xor    %edx,%edx
fldl   -0x10(%rsp)
fldt   (%rax)
add    $0x1,%rdx
fmul   %st(1),%st
fstpt  (%rax)
add    %rsi,%rax
cmp    %rcx,%rdx
jne    d00 <gsl_vector_long_double_scale+0x20>
fstp   %st(0)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_scale (gsl_vector_long_double * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 6
12 8
13 8
14 8
15 6
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
jmpq   0 <fs_stat_translate>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_fs_stat_translate (CdIo_t *p_cdio, const char psz_path[],
      _Bool b_mode2)
{
  return fs_stat_translate(p_cdio, (stat_root_t *) _fs_stat_root,
      (stat_traverse_t *) _fs_stat_traverse,
      psz_path);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1010,%edi
callq  e <rl_make_bare_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
jne    10 <rl_make_bare_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_make_bare_keymap ()
{
  register int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc (257 * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < 257; i++)
    {
      keymap[i].type = 0;
      keymap[i].function = (rl_command_func_t *)((void *)0);
    }
  return (keymap);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,0xc(%rsp)
mov    0xc(%rsp),%edi
lea    0xc(%rsp),%rsi
callq  156 <recurse+0x16>
mov    (%rax),%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
recurse (volatile int n)
{
  return *recurse_1 (n, &n);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %rdi,%rdi
cmove  %rax,%rdi
test   %rsi,%rsi
movl   $0x8,(%rdi)
je     f3d <set_custom_quoting+0x2d>
test   %rdx,%rdx
je     f3d <set_custom_quoting+0x2d>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
callq  f42 <set_custom_quoting+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 6
7 7
8 7
9 7
10 9
11 10
12 11
13 11
14 8
15 8
<<<sep_out_sample>>>
jmpq   55 <crlf+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
jmpq   d5 <CDB___db_loadme+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_loadme()
{
 getpid();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  69 <xmalloc+0x9>
test   %rax,%rax
je     70 <xmalloc+0x10>
pop    %rbx
retq   
mov    %rbx,%rdi
pop    %rbx
jmp    30 <fixup_null_alloc>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (size_t n)
{
  void *p;
  p = malloc (n);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 8
7 8
8 6
9 8
10 6
11 6
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    0x0(%rip),%r13        # 8ab <rl_clear_history+0xb>
push   %r12
push   %rbp
push   %rbx
callq  8b4 <rl_clear_history+0x14>
mov    0x0(%rip),%edx        # 8ba <rl_clear_history+0x1a>
test   %edx,%edx
jle    908 <rl_clear_history+0x68>
mov    %rax,%r12
xor    %ebp,%ebp
xor    %r14d,%r14d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%r12),%rbx
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     8f1 <rl_clear_history+0x51>
cmp    %r13,%rdi
cmove  %r14,%r13
callq  8e9 <rl_clear_history+0x49>
movq   $0x0,0x10(%rbx)
mov    %rbx,%rdi
add    $0x1,%ebp
add    $0x8,%r12
callq  900 <rl_clear_history+0x60>
cmp    %ebp,0x0(%rip)        # 906 <rl_clear_history+0x66>
jg     8d0 <rl_clear_history+0x30>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,0x0(%rip)        # 913 <rl_clear_history+0x73>
movl   $0x0,0x0(%rip)        # 91d <rl_clear_history+0x7d>
pop    %r13
movl   $0x0,0x0(%rip)        # 929 <rl_clear_history+0x89>
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_clear_history ()
{
  HIST_ENTRY **hlist, *hent;
  register int i;
  UNDO_LIST *ul, *saved_undo_list;
  saved_undo_list = rl_undo_list;
  hlist = history_list ();
  for (i = 0; i < history_length; i++)
    {
      hent = hlist[i];
      if (ul = (UNDO_LIST *)hent->data)
 {
   if (ul == saved_undo_list)
     saved_undo_list = 0;
   _rl_free_undo_list (ul);
   hent->data = 0;
 }
      _rl_free_history_entry (hent);
    }
  history_offset = history_length = 0;
  rl_undo_list = saved_undo_list;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 2
5 2
6 2
7 7
8 8
9 8
10 8
11 8
12 8
13 14
14 14
15 10
16 11
17 11
18 11
19 14
20 14
21 15
22 16
23 18
24 8
25 8
26 18
27 8
28 8
29 22
30 22
31 22
32 21
33 20
34 22
35 20
36 22
37 22
38 22
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  df <newstr_grow2+0xf>
mov    0x0(%rip),%rsi        # e6 <newstr_grow2+0x16>
movslq %eax,%rbx
lea    (%rsi,%rbx,1),%rdx
cmp    %rdx,0x0(%rip)        # f4 <newstr_grow2+0x24>
jb     158 <newstr_grow2+0x88>
mov    %rbx,%rdx
mov    %rbp,%rdi
callq  101 <newstr_grow2+0x31>
add    0x0(%rip),%rbx        # 108 <newstr_grow2+0x38>
mov    %r12,%rdi
mov    %rbx,0x0(%rip)        # 112 <newstr_grow2+0x42>
callq  117 <newstr_grow2+0x47>
movslq %eax,%rbp
lea    (%rbx,%rbp,1),%rdx
cmp    %rdx,0x0(%rip)        # 125 <newstr_grow2+0x55>
jae    13a <newstr_grow2+0x6a>
mov    %eax,%esi
mov    $0x0,%edi
callq  133 <newstr_grow2+0x63>
mov    0x0(%rip),%rbx        # 13a <newstr_grow2+0x6a>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  148 <newstr_grow2+0x78>
pop    %rbx
add    %rbp,0x0(%rip)        # 150 <newstr_grow2+0x80>
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %eax,%esi
mov    $0x0,%edi
callq  164 <newstr_grow2+0x94>
mov    0x0(%rip),%rsi        # 16b <newstr_grow2+0x9b>
jmp    f6 <newstr_grow2+0x26>
nopl   (%rax)
<<<sep_in_sample>>>
newstr_grow2(char *s1, char *s2)
{
  __extension__ ({ struct obstack *__o = (&os_newstr); int __len = (strlen(s1)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); bcopy (((char *) (s1)), (__o->next_free), (__len)); __o->next_free += __len; (void) 0; });
  __extension__ ({ struct obstack *__o = (&os_newstr); int __len = (strlen(s2)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); bcopy (((char *) (s2)), (__o->next_free), (__len)); __o->next_free += __len; (void) 0; });
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 3
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 5
32 4
33 5
34 5
35 5
36 5
37 3
38 3
39 3
40 3
41 3
42 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
movq   $0x0,(%rsp)
callq  bb9 <grecs_print_node+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_node(struct grecs_node *node, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 return grecs_format_node(node, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
<<<sep_out_sample>>>
testb  $0x1,0x50(%rdi)
mov    %rdi,%rax
jne    48 <call_chunkfun+0x18>
mov    0x38(%rdi),%rax
mov    %rsi,%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x48(%rdi),%rdi
mov    0x38(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_chunkfun (struct obstack *h, size_t size)
{
  if (h->use_extra_arg)
    return h->chunkfun.extra (h->extra_arg, size);
  else
    return h->chunkfun.plain (size);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
cmp    %rdx,%rdi
jbe    720 <gsl_matrix_complex_superdiagonal+0x50>
sub    %rdx,%rdi
mov    %rdx,%rcx
mov    0x10(%rsi),%r10
mov    (%rsi),%rdx
shl    $0x4,%rcx
add    0x18(%rsi),%rcx
mov    0x20(%rsi),%r8
movl   $0x0,0x20(%rax)
lea    0x1(%r10),%r9
cmp    %rdx,%rdi
cmova  %rdx,%rdi
mov    %r9,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rdi,(%rax)
mov    %r8,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  742 <gsl_matrix_complex_superdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_superdiagonal (gsl_matrix_complex * m,
                                      const size_t k)
{
  _gsl_vector_complex_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 2;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 12
6 11
7 13
8 12
9 11
10 11
11 14
12 17
13 13
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
mov    $0xc0800000,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d2b4 <_sse_blti_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r14d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  cad0 <_sse_movi_f>
mov    0x0(%rbp),%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
and    $0x7fff,%ecx
callq  2190 <_sse_bltr_f>
mov    %r14d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  d302 <_sse_blti_f+0x72>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_blti_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bltr_f(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   3e8 <grecs_txtacc_clear+0x8>
<<<sep_in_sample>>>
grecs_txtacc_clear(struct grecs_txtacc *acc)
{
 grecs_list_clear(acc->cur);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     38 <print_str+0x38>
mov    %rsi,%rdi
callq  19 <print_str+0x19>
mov    %rax,%rsi
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rcx
pop    %rbx
pop    %rbp
mov    $0x1,%edx
jmpq   32 <print_str+0x32>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%esi
mov    $0x0,%ebx
jmp    1c <print_str+0x1c>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_str(FILE *fp, const char *arg)
{
    size_t len;
    if (!arg) {
 arg = "-";
 len = 1;
    } else
 len = strlen(arg);
    fwrite(arg, len, 1, fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 8
9 8
10 8
11 10
12 9
13 9
14 10
15 10
16 9
17 9
18 9
19 6
20 5
21 5
22 5
<<<sep_out_sample>>>
mov    $0xffffffff,%r9d
jmpq   6c9b <gsl_fft_complex_float_forward+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_float_forward (gsl_complex_packed_array_float data,
                                   const size_t stride,
                                   const size_t n,
                                   const gsl_fft_complex_wavetable_float * wavetable,
                                   gsl_fft_complex_workspace_float * work)
{
  gsl_fft_direction sign = gsl_fft_forward;
  int status = gsl_fft_complex_float_transform (data, stride, n,
                                                    wavetable, work, sign);
  return status;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %edi,%ecx
shr    $0x5,%al
and    $0x1f,%ecx
and    $0x7,%eax
mov    0x0(,%rax,4),%eax
shr    %cl,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
libunistring_is_basic (char c)
{
  return (libunistring_is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))
         & 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
test   %rbp,%rbp
je     1a0 <canon_doc_option+0x70>
callq  146 <canon_doc_option+0x16>
mov    %rbp,%rdx
mov    %rax,%r8
jmp    153 <canon_doc_option+0x23>
xchg   %ax,%ax
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
mov    (%r8),%rsi
add    $0x1,%rdx
movzbl %cl,%edi
movzwl (%rsi,%rdi,2),%esi
test   $0x2000,%si
jne    150 <canon_doc_option+0x20>
xor    %eax,%eax
cmp    $0x2d,%cl
setne  %al
test   %cl,%cl
je     197 <canon_doc_option+0x67>
and    $0x8,%esi
je     18d <canon_doc_option+0x5d>
jmp    197 <canon_doc_option+0x67>
xchg   %ax,%ax
mov    (%r8),%rsi
add    $0x1,%rdx
testb  $0x8,(%rsi,%rcx,2)
jne    197 <canon_doc_option+0x67>
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
jne    180 <canon_doc_option+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 9
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 11
36 11
37 11
38 15
39 15
40 15
41 15
42 15
43 15
44 5
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  3b5c <gsl_sf_ellint_F+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3b70 <gsl_sf_ellint_F+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x267,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b86 <gsl_sf_ellint_F+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_F(double phi, double k, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_F_e(phi, k, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_F_e(phi, k, mode, &result)", "ellint.c", 615, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsbq (%rdi),%rbp
movsbl %bpl,%edi
test   %edi,%edi
mov    %edi,0xc(%rsp)
je     52 <upcase+0x52>
callq  20 <upcase+0x20>
mov    0xc(%rsp),%edi
mov    %rax,%r12
nopw   0x0(%rax,%rax,1)
mov    (%r12),%rdx
testb  $0x2,0x1(%rdx,%rbp,2)
je     42 <upcase+0x42>
callq  40 <upcase+0x40>
mov    %al,(%rbx)
add    $0x1,%rbx
movsbq (%rbx),%rbp
movsbl %bpl,%edi
test   %edi,%edi
jne    30 <upcase+0x30>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
upcase (register char *argument)
{
  register int c;
  while ((c = *argument) != 0)
    {
      if (((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISlower))
 {
   *argument = toupper (c);
 }
      argument++;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 8
19 8
20 10
21 4
22 4
23 4
24 4
25 12
26 12
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   1c39 <xformat_set_sys_db_g_policy+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_set_sys_db_g_policy(XFORMAT * xux, int c)
{
 ;
 ahs_set_sys_db_g_policy(xux->ahsM, c);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # d <close_stdout+0xd>
callq  12 <close_stdout+0x12>
test   %eax,%eax
jne    60 <close_stdout+0x60>
callq  1b <close_stdout+0x1b>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # 25 <close_stdout+0x25>
movl   $0x0,(%rbx)
callq  30 <close_stdout+0x30>
test   %eax,%eax
jne    8d <close_stdout+0x8d>
mov    0x0(%rip),%rdi        # 3b <close_stdout+0x3b>
callq  40 <close_stdout+0x40>
test   %eax,%eax
jne    8d <close_stdout+0x8d>
mov    0x0(%rip),%rdi        # 4b <close_stdout+0x4b>
callq  50 <close_stdout+0x50>
test   %eax,%eax
je     59 <close_stdout+0x59>
cmpl   $0x9,(%rbx)
jne    a3 <close_stdout+0xa3>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%edi
callq  6a <close_stdout+0x6a>
mov    %rax,%rbp
callq  72 <close_stdout+0x72>
mov    (%rax),%esi
mov    %rax,%rbx
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x1,%edi
xor    %eax,%eax
callq  8b <close_stdout+0x8b>
jmp    1e <close_stdout+0x1e>
mov    0x0(%rip),%rdi        # 94 <close_stdout+0x94>
callq  99 <close_stdout+0x99>
mov    $0x1,%edi
callq  a3 <close_stdout+0xa3>
mov    $0x1,%edi
callq  ad <close_stdout+0xad>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (fwriteerror_no_ebadf (stdout))
    error (1, (*__errno_location ()), "%s", gettext ("write error"));
  (*__errno_location ()) = 0;
  if (ferror (stderr) || fflush (stderr))
    {
      fclose (stderr);
      exit (1);
    }
  if (fclose (stderr) && (*__errno_location ()) != 9)
    exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 11
20 11
21 11
22 11
23 11
24 11
25 13
26 13
27 13
28 13
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 8
42 8
43 9
44 9
45 12
46 12
<<<sep_out_sample>>>
jmpq   a95 <yyalloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    %rsi,%rdi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  282 <mc_mac_read_string+0x12>
xor    %r8d,%r8d
cmp    $0x11,%rax
jne    2f0 <mc_mac_read_string+0x80>
cmpb   $0x3a,0x2(%rbp,%r8,1)
jne    2d0 <mc_mac_read_string+0x60>
add    $0x3,%r8
cmp    $0xf,%r8
jne    28b <mc_mac_read_string+0x1b>
xor    %ebx,%ebx
nop
xor    %esi,%esi
mov    %rbp,%rdi
mov    $0x10,%edx
callq  2af <mc_mac_read_string+0x3f>
mov    %al,(%r12,%rbx,1)
add    $0x1,%rbx
add    $0x3,%rbp
cmp    $0x6,%rbx
jne    2a0 <mc_mac_read_string+0x30>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 2d7 <mc_mac_read_string+0x67>
mov    %rbp,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  2e6 <mc_mac_read_string+0x76>
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
mov    0x0(%rip),%rdi        # 2f7 <mc_mac_read_string+0x87>
mov    %rax,%rcx
mov    %rbp,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  309 <mc_mac_read_string+0x99>
mov    $0xffffffff,%eax
jmp    2c3 <mc_mac_read_string+0x53>
<<<sep_in_sample>>>
mc_mac_read_string (mac_t *mac, char *string)
{
 int nbyte = 5;
 if (strlen(string) != 17) {
  fprintf (stderr, "[ERROR] Incorrect format: MAC length should be 17. %s(%lu)\n", string, strlen(string));
  return -1;
 }
 for (nbyte=2; nbyte<16; nbyte+=3) {
  if (string[nbyte] != ':') {
   fprintf (stderr, "[ERROR] Incorrect format: %s\n", string);
   return -1;
  }
 }
 for (nbyte=0; nbyte<6; nbyte++) {
  mac->byte[nbyte] = (char) (strtoul(string+nbyte*3, 0, 16) & 0xFF);
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 9
12 9
13 9
14 8
15 8
16 8
17 8
18 15
19 15
20 15
21 15
22 15
23 15
24 15
25 14
26 14
27 17
28 18
29 18
30 18
31 18
32 18
33 10
34 10
35 10
36 10
37 10
38 18
39 18
40 11
41 18
42 18
43 5
44 5
45 5
46 5
47 5
48 5
49 6
50 6
<<<sep_out_sample>>>
push   %r12
movapd %xmm0,%xmm1
mov    %esi,%r12d
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rdx,%rbx
sub    $0x10,%rsp
movsd  0x0(%rip),%xmm0        # 7ac <gsl_sf_bessel_In_array+0x1c>
andpd  %xmm1,%xmm0
ucomisd 0x0(%rip),%xmm0        # 7b8 <gsl_sf_bessel_In_array+0x28>
jbe    800 <gsl_sf_bessel_In_array+0x70>
xor    %eax,%eax
sub    %edi,%esi
js     7d0 <gsl_sf_bessel_In_array+0x40>
movq   $0x0,(%rbx,%rax,8)
add    $0x1,%rax
cmp    %eax,%esi
jge    7c0 <gsl_sf_bessel_In_array+0x30>
mov    $0x10,%ecx
mov    $0xca,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7e9 <gsl_sf_bessel_In_array+0x59>
mov    $0x10,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
movsd  %xmm1,(%rsp)
callq  80a <gsl_sf_bessel_In_array+0x7a>
movsd  (%rsp),%xmm1
mov    %r12d,%esi
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%rdx
mov    %ebp,%edi
movapd %xmm1,%xmm0
callq  826 <gsl_sf_bessel_In_array+0x96>
sub    %ebp,%r12d
js     7ee <gsl_sf_bessel_In_array+0x5e>
movslq %r12d,%r12
movsd  0x8(%rsp),%xmm2
lea    0x8(%rbx,%r12,8),%rdx
nopl   0x0(%rax)
movsd  (%rbx),%xmm1
add    $0x8,%rbx
mulsd  %xmm2,%xmm1
movsd  %xmm1,-0x8(%rbx)
cmp    %rdx,%rbx
jne    840 <gsl_sf_bessel_In_array+0xb0>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
<<<sep_in_sample>>>
gsl_sf_bessel_In_array(const int nmin, const int nmax, const double x, double * result_array)
{
  double ax = fabs(x);
  if(ax > 7.0978271289338397e+02 - 1.0) {
    int j;
    for(j=0; j<=nmax-nmin; j++) result_array[j] = 0.0;
    do { gsl_error ("overflow", "bessel_In.c", 202, GSL_EOVRFLW) ; return GSL_EOVRFLW ; } while (0);
  }
  else {
    int j;
    double eax = exp(ax);
    int status = gsl_sf_bessel_In_scaled_array(nmin, nmax, x, result_array);
    for(j=0; j<=nmax-nmin; j++) result_array[j] *= eax;
    return status;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 11
34 12
35 12
36 11
37 12
38 12
39 12
40 12
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 13
53 16
54 16
55 16
56 16
57 16
58 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movswq 0x4(%rdi),%rdi
callq  e <__rb+0xe>
mov    0x0(%rip),%rdx        # 15 <__rb+0x15>
mov    %rbx,(%rax)
movb   $0x0,0x18(%rax)
mov    %rax,0x0(%rip)        # 23 <__rb+0x23>
mov    %rax,0x0(%rip)        # 2a <__rb+0x2a>
mov    %rdx,0x10(%rax)
mov    %rdx,0x30(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
__rb (__pty ppx)
{
  __dhp x;
  x = __ralloc ((long) ppx->size);
  x->pm = 0;
  x->pp = ppx;
  x->sl = x->dl = __lb;
  __lb = __pb = x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 7
6 6
7 5
8 8
9 8
10 7
11 7
12 9
13 9
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
push   %r12
push   %rbp
mov    %r8d,%ebp
push   %rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 237 <findlev+0x17>
lea    (%rax,%rax,2),%r8
shl    $0x5,%r8
mov    0x0(%r8),%rax
mov    (%rax,%rdi,4),%eax
cmp    $0xffffffff,%eax
je     2f0 <findlev+0xd0>
test   %eax,%eax
jne    2a0 <findlev+0x80>
test   %ebp,%ebp
mov    $0xffffffff,%eax
jle    2dd <findlev+0xbd>
mov    0x0(%r8),%rax
mov    (%rax,%rdi,4),%eax
cmp    (%rdx),%eax
je     332 <findlev+0x112>
add    $0x4,%rdx
xor    %ebx,%ebx
jmp    289 <findlev+0x69>
nopl   0x0(%rax)
add    $0x4,%rdx
cmp    %eax,-0x4(%rdx)
je     2db <findlev+0xbb>
add    $0x1,%ebx
cmp    %ebp,%ebx
jne    280 <findlev+0x60>
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
test   %ebp,%ebp
jle    290 <findlev+0x70>
mov    0x0(%r8),%rax
mov    %rcx,%r12
xor    %ebx,%ebx
mov    (%rax,%rdi,8),%r13
jmp    2cb <findlev+0xab>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%ebx
add    $0x8,%r12
cmp    %ebp,%ebx
je     290 <findlev+0x70>
mov    (%r12),%rsi
mov    %r13,%rdi
callq  2d7 <findlev+0xb7>
test   %eax,%eax
jne    2c0 <findlev+0xa0>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
test   %ebp,%ebp
jle    2dd <findlev+0xbd>
mov    0x0(%r8),%rdx
movsd  (%rdx,%rdi,8),%xmm0
ucomisd (%rsi),%xmm0
jnp    326 <findlev+0x106>
add    $0x8,%rsi
xor    %ebx,%ebx
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    %ebp,%ebx
je     2dd <findlev+0xbd>
add    $0x8,%rsi
ucomisd -0x8(%rsi),%xmm0
jp     310 <findlev+0xf0>
jne    310 <findlev+0xf0>
jmp    2db <findlev+0xbb>
nopw   %cs:0x0(%rax,%rax,1)
jne    306 <findlev+0xe6>
xor    %ebx,%ebx
jmp    2db <findlev+0xbb>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findlev(int class, double dlevel[], int ilevel[], char *slevel[], int nlevels)
{
  int v;
  if (dap_obs[dap_ono].do_len[class] == (-1))
    {
      for (v = 0; v < nlevels; v++)
 {
   if (dap_obs[dap_ono].do_dbl[class] ==
       dlevel[v])
     break;
 }
    }
  else if (dap_obs[dap_ono].do_len[class] == 0)
    {
      for (v = 0; v < nlevels; v++)
 {
   if (dap_obs[dap_ono].do_int[class] ==
       ilevel[v])
     break;
 }
    }
  else
    {
      for (v = 0; v < nlevels; v++)
 {
   if (!strcmp(dap_obs[dap_ono].do_str[class],
        slevel[v]))
     break;
 }
    }
  if (v < nlevels)
    return v;
  return -1;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 13
16 13
17 15
18 33
19 15
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 15
32 15
33 15
34 34
35 33
36 34
37 34
38 34
39 34
40 34
41 24
42 24
43 24
44 24
45 24
46 24
47 24
48 24
49 24
50 24
51 24
52 24
53 26
54 26
55 26
56 26
57 26
58 24
59 34
60 34
61 34
62 34
63 34
64 34
65 34
66 6
67 6
68 8
69 8
70 8
71 8
72 8
73 8
74 8
75 6
76 6
77 6
78 6
79 8
80 8
81 8
82 8
83 8
84 8
85 17
86 17
87 17
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
mov    $0x0,%edx
test   %rax,%rax
cmove  %rdx,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_char_location_str (rec_field_t field)
{
  char *res;
  if (field->char_location_str)
    {
      res = field->char_location_str;
    }
  else
    {
      res = "";
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 10
3 10
4 10
5 13
6 13
<<<sep_out_sample>>>
push   %r13
mov    0x0(%rip),%rax        # 15b9 <prev_date+0x9>
mov    %rdx,%r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0xc(%rax),%ecx
mov    %rdi,%rbx
mov    (%rdi),%edi
lea    0x1(%rcx),%edx
cmp    %edx,%edi
jg     15e8 <prev_date+0x38>
mov    0x8(%rax),%edx
cmp    %edx,%edi
jl     15e8 <prev_date+0x38>
mov    0x4(%rax),%esi
cmp    %esi,0x0(%rbp)
je     1670 <prev_date+0xc0>
nopl   (%rax)
sub    $0x1,%edi
test   %edi,%edi
mov    %edi,(%rbx)
mov    0x0(%rbp),%r12d
jne    1620 <prev_date+0x70>
lea    -0x1(%r12),%eax
test   %eax,%eax
jle    1640 <prev_date+0x90>
cmp    $0x2,%eax
mov    %eax,0x0(%rbp)
je     1654 <prev_date+0xa4>
sub    $0x1,%eax
cltq   
mov    0x0(,%rax,4),%eax
mov    %eax,(%rbx)
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    0x0(%r13),%edx
mov    %r12d,%esi
callq  162c <prev_date+0x7c>
mov    %eax,%edx
mov    $0x1,%eax
test   %edx,%edx
jne    1619 <prev_date+0x69>
lea    -0x1(%r12),%eax
test   %eax,%eax
jg     15fe <prev_date+0x4e>
movl   $0xc,0x0(%rbp)
subl   $0x1,0x0(%r13)
mov    0x0(%rbp),%eax
cmp    $0x2,%eax
jne    1606 <prev_date+0x56>
mov    0x0(%r13),%edi
callq  165d <prev_date+0xad>
mov    %eax,(%rbx)
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rax),%eax
cmp    %eax,0x0(%r13)
jne    15e8 <prev_date+0x38>
sub    $0x1,%edx
xor    %eax,%eax
mov    %edx,(%rbx)
jmp    1619 <prev_date+0x69>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
prev_date (day, month, year)
     int *day;
     int *month;
     int *year;
{
  auto Bool no_missing_date = (0==0);
  if ((*day <= greg->last_day + 1)
      && (*day >= greg->first_day)
      && (*month == greg->month) && (*year == greg->year))
    {
      no_missing_date = (!(0==0));
      *day = greg->first_day - 1;
    }
  else
    {
      (*day)--;
      if (!*day || !valid_date (*day, *month, *year))
 {
   (*month)--;
   if (*month < 1)
     {
       *month = 12;
       (*year)--;
     }
   if (*month == 2)
     *day = days_of_february (*year);
   else
     *day = dvec[*month - 1];
 }
    }
  return (no_missing_date);
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 5
5 5
6 5
7 5
8 7
9 5
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 16
22 17
23 16
24 16
25 17
26 19
27 20
28 20
29 25
30 19
31 25
32 28
33 28
34 28
35 28
36 6
37 32
38 32
39 32
40 32
41 32
42 17
43 17
44 17
45 17
46 6
47 17
48 17
49 19
50 20
51 20
52 22
53 23
54 23
55 25
56 25
57 26
58 26
59 26
60 6
61 32
62 32
63 32
64 32
65 32
66 32
67 9
68 9
69 9
70 12
71 11
72 12
73 12
74 12
<<<sep_out_sample>>>
xorpd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # 3dc <gsl_odeiv2_control_y_new+0xc>
jmpq   3e1 <gsl_odeiv2_control_y_new+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv2_control_y_new (double eps_abs, double eps_rel)
{
  return gsl_odeiv2_control_standard_new (eps_abs, eps_rel, 1.0, 0.0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     4320 <gsl_block_uchar_raw_fscanf+0x80>
mov    %rdi,%r13
mov    %rcx,%r14
mov    %rsi,%rbx
xor    %ebp,%ebp
jmp    42d4 <gsl_block_uchar_raw_fscanf+0x34>
nopl   0x0(%rax)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     4320 <gsl_block_uchar_raw_fscanf+0x80>
lea    0xc(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  42e8 <gsl_block_uchar_raw_fscanf+0x48>
mov    0xc(%rsp),%edx
cmp    $0x1,%eax
mov    %dl,(%rbx)
je     42c8 <gsl_block_uchar_raw_fscanf+0x28>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  430c <gsl_block_uchar_raw_fscanf+0x6c>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
gsl_block_uchar_raw_fscanf (FILE * stream,
                                  unsigned char * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          unsigned int tmp;
          int status = fscanf (stream, "%u", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 13
21 13
22 13
23 13
24 13
25 14
26 15
27 14
28 15
29 17
30 17
31 17
32 17
33 17
34 22
35 17
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 21
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_minimum (const gsl_multimin_fdfminimizer * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r12
cmp    $0x7,%rsi
mov    $0xffffffff,%eax
push   %rbp
mov    %rsi,%rbp
push   %rbx
jbe    4e <icmp_generic_encode+0x4e>
xor    %eax,%eax
mov    %rdi,%rbx
mov    %ecx,%r12d
mov    %dl,(%rdi)
movb   $0x0,0x1(%rdi)
mov    %ax,0x2(%rdi)
movzwl %r8w,%edi
callq  2d <icmp_generic_encode+0x2d>
movzwl %r12w,%edi
mov    %ax,0x6(%rbx)
callq  3a <icmp_generic_encode+0x3a>
mov    %ebp,%esi
mov    %ax,0x4(%rbx)
mov    %rbx,%rdi
callq  48 <icmp_generic_encode+0x48>
mov    %ax,0x2(%rbx)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
icmp_generic_encode (unsigned char * buffer, size_t bufsize, int type, int ident,
       int seqno)
{
  icmphdr_t *icmp;
  if (bufsize < 8)
    return -1;
  icmp = (icmphdr_t *) buffer;
  icmp->icmp_type = type;
  icmp->icmp_code = 0;
  icmp->icmp_cksum = 0;
  icmp->icmp_hun.ih_idseq.icd_seq = htons (seqno);
  icmp->icmp_hun.ih_idseq.icd_id = htons (ident);
  icmp->icmp_cksum = icmp_cksum (buffer, bufsize);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 3
5 3
6 3
7 5
8 10
9 10
10 10
11 8
12 9
13 10
14 11
15 11
16 12
17 11
18 12
19 13
20 12
21 13
22 13
23 13
24 14
25 15
26 15
27 15
28 15
29 15
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   c33 <gsl_sort_vector_long_largest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_largest (long * dest, const size_t k,
                                    const gsl_vector_long * v)
{
  return gsl_sort_long_largest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   32d <close_warn+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
close_warn (char const *name)
{
  call_arg_warn ("close", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    0x0(%rip),%rdx        # e <error+0xe>
mov    0x0(%rip),%rdi        # 15 <error+0x15>
mov    $0x0,%esi
xor    %eax,%eax
callq  21 <error+0x21>
mov    $0x2,%edi
callq  2b <error+0x2b>
<<<sep_in_sample>>>
error(const char *s)
{
  fprintf(stderr, "%s: %s\n", program_name, s);
  exit(2);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rdi,%rbx
mov    $0x0,%edi
callq  4e0 <print_param_prob+0x10>
movzbl 0x1(%rbx),%esi
mov    $0x0,%eax
cmp    (%rax),%esi
je     510 <print_param_prob+0x40>
add    $0x10,%rax
cmp    $0x0,%rax
jb     4e9 <print_param_prob+0x19>
pop    %rbx
mov    $0x0,%edi
xor    %eax,%eax
jmpq   506 <print_param_prob+0x36>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
mov    0x8(%rax),%rdi
jmpq   51a <print_param_prob+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_param_prob (struct icmp6_hdr *icmp6)
{
  struct icmp_code_descr *p;
  printf ("Parameter problem: ");
  for (p = icmp_param_prob_desc;
       p < icmp_param_prob_desc + sizeof(icmp_param_prob_desc)/sizeof((icmp_param_prob_desc)[0]); p++)
    {
      if (p->code == icmp6->icmp6_code)
 {
   puts (p->diag);
   return;
 }
    }
  printf ("Unknown code %d\n", icmp6->icmp6_code);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 5
8 8
9 8
10 6
11 5
12 5
13 15
14 14
15 14
16 14
17 14
18 15
19 10
20 10
21 10
<<<sep_out_sample>>>
mov    0x320(%rdi),%rax
movsd  0x288(%rdi),%xmm0
subsd  0x1c0(%rax),%xmm0
xor    %eax,%eax
movapd %xmm0,%xmm1
cmpltsd 0x0(%rip),%xmm1        # 506 <speedBrakeRetract+0x26>
andnpd %xmm0,%xmm1
movsd  %xmm1,0x288(%rdi)
retq   
<<<sep_in_sample>>>
speedBrakeRetract(craft * c)
{
 c->speedBrakeSetting -= c->cinfo->speedBrakeIncr;
 if (c->speedBrakeSetting < 0.0)
  c->speedBrakeSetting = 0.0;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 7
5 3
6 3
7 3
8 3
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    38 <__ham_set_h_nelem+0x38>
mov    %esi,%ebp
mov    $0x2,%esi
callq  1e <__ham_set_h_nelem+0x1e>
test   %eax,%eax
jne    2c <__ham_set_h_nelem+0x2c>
mov    0xd0(%rbx),%rdx
mov    %ebp,0x8(%rdx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   51 <__ham_set_h_nelem+0x51>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__ham_set_h_nelem(dbp, h_nelem)
 DB *dbp;
 u_int32_t h_nelem;
{
 HASH *hashp;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_h_nelem", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x02)) != 0) return (__ret); };
 hashp = dbp->h_internal;
 hashp->h_nelem = h_nelem;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 6
20 11
21 6
22 11
23 11
24 6
25 6
26 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 3a7 <gsl_multilarge_nlinear_default_parameters+0x7>
movsd  0x0(%rip),%xmm0        # 3af <gsl_multilarge_nlinear_default_parameters+0xf>
movsd  0x0(%rip),%xmm1        # 3b7 <gsl_multilarge_nlinear_default_parameters+0x17>
mov    %rdi,%rax
movsd  0x0(%rip),%xmm2        # 3c2 <gsl_multilarge_nlinear_default_parameters+0x22>
movl   $0x0,0x18(%rdi)
mov    %rdx,(%rdi)
mov    0x0(%rip),%rdx        # 3d3 <gsl_multilarge_nlinear_default_parameters+0x33>
movsd  %xmm0,0x20(%rdi)
movsd  0x0(%rip),%xmm3        # 3e0 <gsl_multilarge_nlinear_default_parameters+0x40>
movq   $0x0,0x48(%rdi)
movsd  0x0(%rip),%xmm4        # 3f0 <gsl_multilarge_nlinear_default_parameters+0x50>
mov    %rdx,0x8(%rdi)
mov    0x0(%rip),%rdx        # 3fb <gsl_multilarge_nlinear_default_parameters+0x5b>
movsd  %xmm1,0x28(%rdi)
movsd  0x0(%rip),%xmm5        # 408 <gsl_multilarge_nlinear_default_parameters+0x68>
movsd  %xmm2,0x30(%rdi)
mov    %rdx,0x10(%rdi)
movsd  %xmm3,0x38(%rdi)
movsd  %xmm4,0x40(%rdi)
movsd  %xmm5,0x50(%rdi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_default_parameters(void)
{
  gsl_multilarge_nlinear_parameters params;
  params.trs = gsl_multilarge_nlinear_trs_lm;
  params.scale = gsl_multilarge_nlinear_scale_more;
  params.solver = gsl_multilarge_nlinear_solver_cholesky;
  params.fdtype = GSL_MULTILARGE_NLINEAR_FWDIFF;
  params.factor_up = 3.0;
  params.factor_down = 2.0;
  params.avmax = 0.75;
  params.h_df = 1.4901161193847656e-08;
  params.h_fvv = 0.01;
  params.max_iter = 0;
  params.tol = 1.0e-6;
  return params;
}
<<<sep_in_sample>>>
1 15
2 15
3 15
4 2
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 16
23 16
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %rdi,%rdi
je     408 <_asn1_set_value_lv+0x68>
mov    %edx,%edi
mov    %edx,%ebx
lea    0xc(%rsp),%rdx
mov    %rsi,%r13
xor    %esi,%esi
callq  3c5 <_asn1_set_value_lv+0x25>
mov    %ebx,%edi
add    0xc(%rsp),%edi
callq  3d0 <_asn1_set_value_lv+0x30>
test   %rax,%rax
mov    %rax,%rbp
je     408 <_asn1_set_value_lv+0x68>
lea    0xc(%rsp),%rcx
mov    %rax,%rdx
mov    %ebx,%esi
mov    %r13,%rdi
callq  3ea <_asn1_set_value_lv+0x4a>
mov    0xc(%rsp),%edx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  3f9 <_asn1_set_value_lv+0x59>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_asn1_set_value_lv (asn1_node node, const void *value, unsigned int len)
{
  int len2;
  void *temp;
  if (node == ((void *)0))
    return node;
  asn1_length_der (len, ((void *)0), &len2);
  temp = malloc (len + len2);
  if (temp == ((void *)0))
    return ((void *)0);
  asn1_octet_der (value, len, temp, &len2);
  return _asn1_set_value_m (node, temp, len2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 9
19 8
20 9
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 12
29 12
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 2
39 13
40 13
41 13
42 13
43 13
44 13
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0xa8(%rdi),%rdi
test   %rdi,%rdi
je     9e9 <taru_exattlist_get_free+0x79>
xor    %ebx,%ebx
jmp    9a1 <taru_exattlist_get_free+0x31>
nopl   0x0(%rax)
mov    0x4(%rax),%edx
test   %edx,%edx
je     9d0 <taru_exattlist_get_free+0x60>
mov    0xa8(%rbp),%rdi
add    $0x1,%ebx
mov    %ebx,%esi
callq  9a8 <taru_exattlist_get_free+0x38>
test   %rax,%rax
jne    990 <taru_exattlist_get_free+0x20>
callq  9b2 <taru_exattlist_get_free+0x42>
mov    0xa8(%rbp),%rdi
mov    %rax,%rsi
mov    %rax,%rbx
callq  9c4 <taru_exattlist_get_free+0x54>
add    $0x18,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rax,%rdi
mov    %rax,0x8(%rsp)
callq  9dd <taru_exattlist_get_free+0x6d>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x3,%dil
callq  9f1 <taru_exattlist_get_free+0x81>
mov    %rax,0xa8(%rbp)
mov    %rax,%rdi
movl   $0x1,0x18(%rax)
jmp    985 <taru_exattlist_get_free+0x15>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_exattlist_get_free(struct new_cpio_header * file_hdr)
{
 EXATT *p;
 int index;
 if (file_hdr->extattlistM == ((void *)0)) {
  file_hdr->extattlistM = (void*)cplob_open(3);
  ((CPLOB*)(file_hdr->extattlistM))->refcountM = 1;
 }
 index = 0;
 while((p=(EXATT*) cplob_val(file_hdr->extattlistM, index))) {
  if (p->is_in_useM == 0) {
   taru_exatt_init(p);
   return p;
  }
  index++;
 }
 p = taru_exatt_create();
 cplob_add_nta(file_hdr->extattlistM, (char*)p);
 return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 11
12 11
13 11
14 11
15 15
16 10
17 10
18 10
19 10
20 17
21 18
22 18
23 17
24 18
25 20
26 19
27 20
28 20
29 20
30 20
31 12
32 12
33 12
34 10
35 20
36 20
37 20
38 20
39 6
40 6
41 6
42 7
43 7
44 7
45 7
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%r9
test   %r8,%r8
mov    (%rcx),%rdi
je     d6c <gsl_vector_ulong_min_index+0x3c>
shl    $0x3,%r9
xor    %edx,%edx
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
mov    (%rcx),%rsi
cmp    %rdi,%rsi
jae    d5e <gsl_vector_ulong_min_index+0x2e>
mov    %rdx,%rax
mov    %rsi,%rdi
add    $0x1,%rdx
add    %r9,%rcx
cmp    %r8,%rdx
jne    d50 <gsl_vector_ulong_min_index+0x20>
repz retq 
xor    %eax,%eax
retq   
nop
<<<sep_in_sample>>>
gsl_vector_ulong_min_index (const gsl_vector_ulong * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned long min = v->data[0 * stride];
  size_t imin = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 8
5 5
6 8
7 8
8 8
9 6
10 6
11 10
12 11
13 11
14 11
15 11
16 8
17 8
18 8
19 8
20 8
21 6
22 18
23 18
<<<sep_out_sample>>>
push   %rbx
mov    (%rdx),%rax
mov    %rdi,%rbx
mov    $0x1,%ecx
mov    $0x1,%edx
lea    0x8(%rax),%rdi
callq  c70 <bad_argc.isra.0>
test   %al,%al
je     3920 <m4_divnum+0x20>
pop    %rbx
retq   
mov    %rbx,%rdi
mov    0x0(%rip),%esi        # 3929 <m4_divnum+0x29>
pop    %rbx
jmpq   630 <shipout_int>
nop
<<<sep_in_sample>>>
m4_divnum (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 1, 1))
    return;
  shipout_int (obs, current_diversion);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 5
13 5
14 6
15 5
16 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%esi
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  10b3 <swlib_squash_embedded_dot_slash+0x13>
mov    %rax,%rbx
test   %rax,%rax
setne  %al
cmp    %rbp,%rbx
jne    10f8 <swlib_squash_embedded_dot_slash+0x58>
cmp    %rbp,%rbx
je     10d0 <swlib_squash_embedded_dot_slash+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
test   %al,%al
je     10c6 <swlib_squash_embedded_dot_slash+0x26>
lea    0x2(%rbx),%rdi
callq  10dd <swlib_squash_embedded_dot_slash+0x3d>
add    $0x8,%rsp
lea    0x3(%rbx),%rsi
lea    0x1(%rbx),%rdi
pop    %rbx
pop    %rbp
mov    %rax,%rdx
jmpq   10f3 <swlib_squash_embedded_dot_slash+0x53>
nopl   0x0(%rax,%rax,1)
test   %al,%al
je     10c1 <swlib_squash_embedded_dot_slash+0x21>
jmp    10d4 <swlib_squash_embedded_dot_slash+0x34>
xchg   %ax,%ax
<<<sep_in_sample>>>
swlib_squash_embedded_dot_slash(char *path)
{
 char *p1;
 p1 = strstr(path, "/./");
 if (p1 && p1 != path) {
  memmove(p1+1, p1 + 3, strlen(p1 + 2));
 } else if (p1 && p1 == path) {
  memmove(p1+1, p1 + 3, strlen(p1 + 2));
 }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 7
13 7
14 10
15 10
16 10
17 10
18 10
19 7
20 7
21 8
22 8
23 10
24 8
25 8
26 10
27 10
28 8
29 8
30 8
31 5
32 5
33 5
34 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
imul   $0x41c64e6d,%rax,%rax
add    $0x3039,%rax
and    $0x7fffffff,%eax
mov    %rax,(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rand_get (void *vstate)
{
  rand_state_t *state = (rand_state_t *) vstate;
  state->x = (1103515245 * state->x + 12345) & 0x7fffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
<<<sep_out_sample>>>
mov    %esi,0x68(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gcide_iterator_store_flags(gcide_iterator_t itr, int flags)
{
    itr->flags = flags;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
test   %rbp,%rbp
je     1a0 <canon_doc_option+0x70>
callq  146 <canon_doc_option+0x16>
mov    %rbp,%rdx
mov    %rax,%r8
jmp    153 <canon_doc_option+0x23>
xchg   %ax,%ax
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
mov    (%r8),%rsi
add    $0x1,%rdx
movzbl %cl,%edi
movzwl (%rsi,%rdi,2),%esi
test   $0x2000,%si
jne    150 <canon_doc_option+0x20>
xor    %eax,%eax
cmp    $0x2d,%cl
setne  %al
test   %cl,%cl
je     197 <canon_doc_option+0x67>
and    $0x8,%esi
je     18d <canon_doc_option+0x5d>
jmp    197 <canon_doc_option+0x67>
xchg   %ax,%ax
mov    (%r8),%rsi
add    $0x1,%rdx
testb  $0x8,(%rsi,%rcx,2)
jne    197 <canon_doc_option+0x67>
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
jne    180 <canon_doc_option+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 9
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 11
36 11
37 11
38 15
39 15
40 15
41 15
42 15
43 15
44 5
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rsi
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x90,%rsp
callq  b8 <acm_find_file+0x18>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  c3 <acm_find_file+0x23>
test   %eax,%eax
jne    d8 <acm_find_file+0x38>
add    $0x90,%rsp
mov    $0x0,%eax
pop    %rbx
retq   
nopl   (%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  e7 <acm_find_file+0x47>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  f2 <acm_find_file+0x52>
mov    %rsp,%rsi
mov    $0x0,%edi
callq  ff <acm_find_file+0x5f>
test   %eax,%eax
je     c7 <acm_find_file+0x27>
mov    0x0(%rip),%rdi        # 10a <acm_find_file+0x6a>
mov    $0x0,%ecx
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  11e <acm_find_file+0x7e>
mov    $0x1,%edi
callq  128 <acm_find_file+0x88>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
acm_find_file(char *name)
{
 static char pname[1024];
 struct stat statbuf;
 strcpy(pname, name);
 if (stat(name, &statbuf) != 0) {
  strcpy(pname, _acm_fopen_library_dir);
  strcat(pname, name);
  if (stat(pname, &statbuf) != 0) {
            fprintf(stderr, errmsg, name, _acm_fopen_library_dir);
            exit(1);
        }
 }
 return pname;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 5
7 6
8 6
9 6
10 6
11 6
12 15
13 15
14 15
15 15
16 15
17 7
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 11
35 11
36 11
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  12 <xfreopen+0x12>
test   %rax,%rax
je     20 <xfreopen+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %rbx,%rbx
je     70 <xfreopen+0x70>
mov    %rbp,%rsi
mov    $0x1,%edi
callq  32 <xfreopen+0x32>
mov    %rbx,%rsi
xor    %edi,%edi
mov    %rax,%r12
callq  3f <xfreopen+0x3f>
mov    $0x0,%edi
mov    %rax,%rbp
callq  4c <xfreopen+0x4c>
mov    %rax,%rbx
callq  54 <xfreopen+0x54>
mov    %rbx,%rdx
mov    %rbp,%rcx
mov    %r12,%r8
pop    %rbx
pop    %rbp
pop    %r12
mov    (%rax),%esi
mov    0x0(%rip),%edi        # 69 <xfreopen+0x69>
xor    %eax,%eax
jmpq   70 <xfreopen+0x70>
cmp    0x0(%rip),%r12        # 77 <xfreopen+0x77>
je     ac <xfreopen+0xac>
cmp    0x0(%rip),%r12        # 80 <xfreopen+0x80>
je     be <xfreopen+0xbe>
cmp    0x0(%rip),%r12        # 89 <xfreopen+0x89>
je     9a <xfreopen+0x9a>
mov    $0x0,%edi
callq  95 <xfreopen+0x95>
mov    %rax,%rbx
jmp    25 <xfreopen+0x25>
mov    $0x0,%edi
callq  a4 <xfreopen+0xa4>
mov    %rax,%rbx
jmpq   25 <xfreopen+0x25>
mov    $0x0,%edi
callq  b6 <xfreopen+0xb6>
mov    %rax,%rbx
jmpq   25 <xfreopen+0x25>
mov    $0x0,%edi
callq  c8 <xfreopen+0xc8>
mov    %rax,%rbx
jmpq   25 <xfreopen+0x25>
<<<sep_in_sample>>>
xfreopen (char const *filename, char const *mode, FILE *fp)
{
  if (!freopen_safer (filename, mode, fp))
    {
      char const *f = (filename ? filename
                       : (fp == stdin ? gettext ("stdin")
                          : (fp == stdout ? gettext ("stdout")
                             : (fp == stderr ? gettext ("stderr")
                                : gettext ("unknown stream")))));
      error (exit_failure, (*__errno_location ()), gettext ("failed to reopen %s with mode %s"),
             quote_n (0, f), quote_n (1, mode));
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 13
11 13
12 13
13 13
14 13
15 6
16 6
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 13
33 13
34 13
35 10
36 10
37 10
38 10
39 6
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
<<<sep_out_sample>>>
push   %rbx
xor    %r9d,%r9d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
mov    $0x0,%r8d
sub    $0x20,%rsp
mov    $0x22b8,%esi
mov    $0x8,%edi
movl   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movl   $0x4,(%rsp)
callq  44 <main+0x44>
mov    %rax,%rbx
mov    $0x1,%eax
test   %rbx,%rbx
je     60 <main+0x60>
callq  56 <main+0x56>
mov    %rbx,%rdi
callq  5e <main+0x5e>
xor    %eax,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
main ()
{
  struct MHD_Daemon *daemon;
  daemon = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY, 8888, ((void *)0), ((void *)0),
                             &answer_to_connection, ((void *)0),
                             MHD_OPTION_NOTIFY_COMPLETED, request_completed,
                             ((void *)0), MHD_OPTION_END);
  if (((void *)0) == daemon)
    return 1;
  (void) getchar ();
  MHD_stop_daemon (daemon);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 9
17 8
18 8
19 10
20 11
21 11
22 12
23 13
24 13
25 13
<<<sep_out_sample>>>
mov    0x6c(%rdi),%eax
mov    0x68(%rdi),%ecx
cmp    %ecx,%eax
jge    228 <UpdateNDoses+0x78>
mov    0x70(%rdi),%r9
movslq %eax,%r8
lea    0x0(,%r8,8),%r10
movsd  (%r9,%r8,8),%xmm0
xor    %r8d,%r8d
movsd  %xmm0,(%rsi)
movsd  (%rdx),%xmm1
ucomisd %xmm0,%xmm1
setae  %r8b
test   %r8d,%r8d
mov    %r8d,0x4(%rdi)
je     23b <UpdateNDoses+0x8b>
movsd  0x8(%r9,%r10,1),%xmm0
movsd  %xmm0,(%rsi)
ucomisd (%rdx),%xmm0
seta   %dl
movzbl %dl,%edx
test   %edx,%edx
mov    %edx,0x4(%rdi)
jne    248 <UpdateNDoses+0x98>
add    $0x1,%eax
cmp    %eax,%ecx
mov    %eax,0x6c(%rdi)
jle    23b <UpdateNDoses+0x8b>
movsd  0x10(%r9,%r10,1),%xmm0
movsd  %xmm0,(%rsi)
movl   $0x1,0x4(%rdi)
retq   
nopl   0x0(%rax)
mov    0x4(%rdi),%eax
movsd  0x0(%rip),%xmm2        # 233 <UpdateNDoses+0x83>
movsd  %xmm2,(%rsi)
test   %eax,%eax
jne    248 <UpdateNDoses+0x98>
movq   $0x0,0x10(%rdi)
retq   
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
UpdateNDoses (PIFN pifn, PDOUBLE pdTnext, PDOUBLE pdTime)
{
  int j;
  j = pifn->iDoseCur;
  if (j < pifn->nDoses) {
    *pdTnext = pifn->rgT0s[j];
    pifn->bOn = (*pdTime >= *pdTnext);
    if (pifn->bOn) {
      *pdTnext = pifn->rgT0s[j+1];
      pifn->bOn = (*pdTime < *pdTnext);
      if (!pifn->bOn)
        if (++pifn->iDoseCur < pifn->nDoses) {
          *pdTnext = pifn->rgT0s[pifn->iDoseCur + 1];
          pifn->bOn = 1;
        }
    }
  }
  else
    *pdTnext = ((double)1.79769313486231570815e+308L);
  if (!pifn->bOn)
    pifn->dVal = 0.0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
7 6
8 6
9 7
10 6
11 7
12 7
13 7
14 8
15 7
16 8
17 9
18 9
19 10
20 10
21 10
22 11
23 10
24 11
25 12
26 12
27 12
28 12
29 13
30 13
31 14
32 14
33 14
34 20
35 19
36 19
37 20
38 20
39 21
40 21
41 21
42 21
43 21
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initExtendedOption(void){
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   2b <direntry_cmp_name+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    $0x0,%edx
mov    %rax,%rcx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  24 <xalloc_die+0x24>
callq  29 <xalloc_die+0x29>
<<<sep_in_sample>>>
xalloc_die ()
{
  anubis_error (1, 0, "%s", gettext("Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x6,(%rdi)
ja     8e0 <matherr+0xe0>
mov    (%rdi),%eax
jmpq   *0x0(,%rax,8)
nopw   %cs:0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  82e <matherr+0x2e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  84e <matherr+0x4e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  86e <matherr+0x6e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  88e <matherr+0x8e>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  8ae <matherr+0xae>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  8ce <matherr+0xce>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rsi
mov    $0x0,%edi
callq  8ee <matherr+0xee>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
matherr (struct exception *x)
{
  switch (x->type)
    {
    case 1:
      rterrors ("domain error in %s", x->name);
      break;
    case 2:
      rterrors ("singularity error in %s", x->name);
      break;
    case 3:
      rterrors ("range error (overflow) in %s", x->name);
      break;
    case 5:
      rterrors ("range error (total loss of significance) in %s",
  x->name);
      break;
    case 6:
      rterrors ("range error (partial loss of significance) in %s",
  x->name);
      break;
    case 4:
      rtsquawks ("range error (underflow) in %s", x->name);
      break;
    default:
      rterrors ("unknown error in %s", x->name);
      break;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 19
8 19
9 19
10 30
11 30
12 30
13 30
14 6
15 6
16 6
17 30
18 30
19 30
20 30
21 9
22 9
23 9
24 30
25 30
26 30
27 30
28 12
29 12
30 12
31 30
32 30
33 30
34 30
35 23
36 23
37 23
38 30
39 30
40 30
41 30
42 15
43 15
44 15
45 30
46 30
47 30
48 30
49 26
50 26
51 26
52 30
53 30
54 30
55 30
<<<sep_out_sample>>>
mov    %rdi,%rsi
xor    %eax,%eax
mov    $0x0,%edi
jmpq   1f <print_item+0xf>
nop
<<<sep_in_sample>>>
print_item(void *item)
{
    printf("%s", (char*)item);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1018 <gsl_vector_int_isnull+0x38>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x2,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdl (%rdx),%xmm0
ucomisd %xmm1,%xmm0
jp     101e <gsl_vector_int_isnull+0x3e>
jne    101e <gsl_vector_int_isnull+0x3e>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1000 <gsl_vector_int_isnull+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_isnull (const gsl_vector_int * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
movslq %ecx,%rax
test   %edx,%edx
movsd  (%rsi),%xmm4
lea    0x0(,%rax,8),%r8
movsd  %xmm2,(%rdi,%rax,8)
je     80 <backward_recurse_c+0x80>
test   %ecx,%ecx
jle    6f <backward_recurse_c+0x6f>
neg    %ecx
lea    -0x8(%rdi,%r8,1),%rdx
mov    $0xc7,%eax
lea    0xc7(%rcx,%rcx,1),%r8d
movsd  0x0(%rip),%xmm3        # 38 <backward_recurse_c+0x38>
nopl   0x0(%rax,%rax,1)
mov    %eax,%ecx
movapd %xmm3,%xmm6
imul   %eax,%ecx
sub    $0x2,%eax
sub    $0x8,%rdx
cvtsi2sd %ecx,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
addsd  0x10(%rdx),%xmm2
divsd  %xmm2,%xmm6
movsd  %xmm6,0x8(%rdx)
cmp    %r8d,%eax
jne    40 <backward_recurse_c+0x40>
movsd  (%rdi),%xmm0
subsd  %xmm4,%xmm0
movsd  %xmm0,(%rsi)
retq   
nopl   0x0(%rax)
test   %ecx,%ecx
jle    6f <backward_recurse_c+0x6f>
mov    $0x63,%r9d
lea    -0x8(%rdi,%r8,1),%rdx
mov    $0x63,%eax
movsd  0x0(%rip),%xmm3        # 9c <backward_recurse_c+0x9c>
sub    %ecx,%r9d
nop
mov    %eax,%r8d
movapd %xmm3,%xmm5
imul   %eax,%r8d
sub    $0x1,%eax
sub    $0x8,%rdx
shl    $0x2,%r8d
cvtsi2sd %r8d,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
addsd  0x10(%rdx),%xmm2
divsd  %xmm2,%xmm5
movsd  %xmm5,0x8(%rdx)
cmp    %r9d,%eax
jne    a0 <backward_recurse_c+0xa0>
cmp    $0x63,%ecx
jne    6f <backward_recurse_c+0x6f>
movsd  (%rdi),%xmm0
addsd  %xmm0,%xmm0
movsd  %xmm0,(%rdi)
subsd  %xmm4,%xmm0
movsd  %xmm0,(%rsi)
retq   
<<<sep_in_sample>>>
backward_recurse_c(double aa, double qq, double xx, double *ff,
                               double *gx, int even_odd, int ni)
{
  int ii, nn;
  double g1;
  g1 = *gx;
  ff[ni] = xx;
  if (even_odd == 0)
  {
      for (ii=0; ii<ni; ii++)
      {
          nn = 100 - ii - 1;
          ff[ni-ii-1] = -1.0/((4*nn*nn - aa)/qq + ff[ni-ii]);
      }
      if (ni == 100 - 1)
          ff[0] *= 2.0;
  }
  else
  {
      for (ii=0; ii<ni; ii++)
      {
          nn = 100 - ii - 1;
          ff[ni-ii-1] = -1.0/(((2*nn + 1)*(2*nn + 1) - aa)/qq + ff[ni-ii]);
      }
  }
  *gx = ff[0] - g1;
}
<<<sep_in_sample>>>
1 7
2 8
3 6
4 7
5 7
6 8
7 20
8 20
9 20
10 20
11 20
12 20
13 20
14 20
15 23
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 23
24 23
25 23
26 20
27 20
28 20
29 26
30 26
31 26
32 26
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 13
53 10
54 10
55 15
56 15
57 16
58 16
59 16
60 26
61 26
62 26
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
jbe    160 <gsl_ran_rayleigh_tail_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
movapd %xmm0,%xmm4
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
divsd  %xmm2,%xmm4
movapd %xmm1,%xmm0
subsd  %xmm4,%xmm1
movsd  %xmm4,(%rsp)
addsd  %xmm4,%xmm0
mulsd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 193 <gsl_ran_rayleigh_tail_pdf+0x43>
callq  198 <gsl_ran_rayleigh_tail_pdf+0x48>
movsd  (%rsp),%xmm4
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
add    $0x18,%rsp
divsd  %xmm2,%xmm4
movapd %xmm4,%xmm0
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_rayleigh_tail_pdf (const double x, const double a, const double sigma)
{
  if (x < a)
    {
      return 0 ;
    }
  else
    {
      double u = x / sigma ;
      double v = a / sigma ;
      double p = (u / sigma) * exp((v + u) * (v - u) / 2.0) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 10
7 9
8 2
9 10
10 9
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 14
22 11
23 11
24 11
25 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  b4c <akima_free+0xc>
mov    0x8(%rbx),%rdi
callq  b55 <akima_free+0x15>
mov    0x10(%rbx),%rdi
callq  b5e <akima_free+0x1e>
mov    0x18(%rbx),%rdi
callq  b67 <akima_free+0x27>
mov    %rbx,%rdi
pop    %rbx
jmpq   b70 <akima_alloc>
<<<sep_in_sample>>>
akima_free (void * vstate)
{
  akima_state_t *state = (akima_state_t *) vstate;
  free (state->b);
  free (state->c);
  free (state->d);
  free (state->_m);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 9
13 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%edi
callq  3e <__gmp_sqrt_of_negative+0xe>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_sqrt_of_negative (void)
{
  __gmp_exception (GMP_ERROR_SQRT_OF_NEGATIVE);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
callq  60 <findLocalEntity>
not    %eax
shr    $0x1f,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dis_isLocalEntity (const dis_entity_id *id)
{
 int eid = findLocalEntity ( id );
 return (eid >= 0) ? 1 : 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
callq  16 <sh_single_quote+0x16>
test   %rbx,%rbx
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jne    32 <sh_single_quote+0x32>
jmp    60 <sh_single_quote+0x60>
nopl   0x0(%rax)
add    $0x1,%rdx
add    $0x1,%rbx
je     60 <sh_single_quote+0x60>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     60 <sh_single_quote+0x60>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    28 <sh_single_quote+0x28>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    32 <sh_single_quote+0x32>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_single_quote (string)
     char *string;
{
  register int c;
  char *result, *r, *s;
  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 9
7 8
8 8
9 9
10 9
11 9
12 11
13 9
14 9
15 9
16 9
17 9
18 9
19 12
20 11
21 12
22 14
23 15
24 16
25 16
26 9
27 9
28 9
29 19
30 20
31 22
32 22
33 22
<<<sep_out_sample>>>
xor    %ecx,%ecx
mov    $0x1,%edx
xor    %esi,%esi
jmpq   210 <gen_page_generic_begin>
xchg   %ax,%ax
<<<sep_in_sample>>>
gen_page_frameset_begin(const char *title)
{
 return gen_page_generic_begin(title, 0, 1, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    0x80(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_get_cnum (osip_authorization_t * authorization)
{
  return authorization->cnum;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1770 <gsl_matrix_int_ispos+0x50>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1764 <gsl_matrix_int_ispos+0x44>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm0,%xmm1
jae    1776 <gsl_matrix_int_ispos+0x56>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1750 <gsl_matrix_int_ispos+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    1741 <gsl_matrix_int_ispos+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_int_ispos (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
lea    0x10(%rbp),%edi
push   %rbx
callq  71 <add_hugestring+0x11>
lea    0x8(%rax),%rcx
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rax,%rbx
mov    %rcx,%rdi
callq  86 <add_hugestring+0x26>
mov    %rax,%rcx
mov    0x0(%rip),%rax        # 90 <add_hugestring+0x30>
movb   $0x0,0x8(%rbx,%rbp,1)
mov    %rbx,0x0(%rip)        # 9c <add_hugestring+0x3c>
mov    %rax,(%rbx)
mov    %rcx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_hugestring (const char *str, unsigned int len)
{
  struct hugestring *new = xmalloc (sizeof (struct hugestring) + len);
  memcpy (new->buffer, str, len);
  new->buffer[len] = '\0';
  new->next = hugestrings;
  hugestrings = new;
  return new->buffer;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 4
9 4
10 4
11 3
12 4
13 4
14 4
15 6
16 5
17 7
18 6
19 9
20 9
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
movzwl 0xc(%rdi),%r8d
movzwl 0x8(%rdi),%eax
movzwl %r8w,%ecx
add    %rcx,%rax
lea    -0x1(%rax),%rdx
cmp    %rdx,%rcx
jg     43 <__rtstrip+0x43>
mov    (%rdi),%rsi
sub    $0x2,%rax
cmpb   $0x20,0x18(%rsi,%rax,1)
je     3e <__rtstrip+0x3e>
jmp    6f <__rtstrip+0x6f>
nopl   0x0(%rax)
cmpb   $0x20,0x17(%rsi,%rax,1)
lea    -0x1(%rax),%rdx
jne    78 <__rtstrip+0x78>
mov    %rdx,%rax
cmp    %rax,%rcx
jle    30 <__rtstrip+0x30>
xor    %ecx,%ecx
xor    %esi,%esi
xor    %edi,%edi
movq   $0x0,0x0(%rip)        # 54 <__rtstrip+0x54>
mov    %cx,0x0(%rip)        # 5b <__rtstrip+0x5b>
mov    $0x0,%eax
mov    %si,0x0(%rip)        # 67 <__rtstrip+0x67>
mov    %di,0x0(%rip)        # 6e <__rtstrip+0x6e>
retq   
mov    %rdx,%rax
nopw   0x0(%rax,%rax,1)
mov    %r8w,0x0(%rip)        # 80 <__rtstrip+0x80>
sub    0xc(%rdi),%ax
mov    $0x1,%edx
mov    %rsi,0x0(%rip)        # 90 <__rtstrip+0x90>
mov    %dx,0x0(%rip)        # 97 <__rtstrip+0x97>
add    $0x1,%eax
mov    %ax,0x0(%rip)        # a1 <__rtstrip+0xa1>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
__rtstrip (__txtvp t)
{
  long pos;
  for (pos = (long) t->start + (long) t->length - 1;
       (long) t->start <= pos && t->obj->string[pos - 1] == ' '; pos--);
  if (pos < (long) t->start)
    {
      __et.obj = 0L;
      __et.pos = __et.start = __et.length = 0;
    }
  else
    {
      __et.obj = t->obj;
      __et.start = t->start;
      __et.pos = 1;
      __et.length = pos - (long) t->start + 1;
    }
  return (&__et);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 4
19 4
20 9
21 9
22 9
23 8
24 9
25 19
26 9
27 9
28 19
29 5
30 5
31 14
32 16
33 15
34 13
35 15
36 16
37 16
38 19
39 19
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 166 <CDB_db_env_set_region_init+0x6>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
CDB_db_env_set_region_init(onoff)
 int onoff;
{
 CDB___db_global_values.db_region_init = onoff;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # f <close_stdout_status+0xf>
callq  14 <close_stdout_status+0x14>
test   %eax,%eax
jne    60 <close_stdout_status+0x60>
mov    0x0(%rip),%rdi        # 1f <close_stdout_status+0x1f>
callq  24 <close_stdout_status+0x24>
test   %eax,%eax
jne    30 <close_stdout_status+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    $0x0,%edi
callq  3a <close_stdout_status+0x3a>
mov    %rax,%rbp
callq  42 <close_stdout_status+0x42>
mov    (%rax),%esi
add    $0x8,%rsp
mov    %ebx,%edi
pop    %rbx
mov    %rbp,%rdx
xor    %eax,%eax
pop    %rbp
jmpq   56 <close_stdout_status+0x56>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  6a <close_stdout_status+0x6a>
xor    %esi,%esi
mov    %rax,%rdx
mov    %ebx,%edi
xor    %eax,%eax
callq  78 <close_stdout_status+0x78>
jmp    18 <close_stdout_status+0x18>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_stdout_status (int status)
{
  if (ferror (stdout))
    error (status, 0, gettext ("write error"));
  if (fclose (stdout) != 0)
    error (status, (*__errno_location ()), gettext ("write error"));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 6
19 6
20 6
21 6
22 6
23 7
24 6
25 7
26 6
27 6
28 7
29 6
30 6
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1010,%edi
callq  e <rl_make_bare_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
jne    10 <rl_make_bare_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_make_bare_keymap ()
{
  register int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc (257 * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < 257; i++)
    {
      keymap[i].type = 0;
      keymap[i].function = (rl_command_func_t *)((void *)0);
    }
  return (keymap);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rdx,%rdi
sar    $0x3f,%rdi
mov    %rdi,%rcx
xor    %rdx,%rcx
sub    %rdi,%rcx
jne    26 <__gmpz_roinit_n+0x26>
jmp    2e <__gmpz_roinit_n+0x2e>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rcx
je     2e <__gmpz_roinit_n+0x2e>
cmpq   $0x0,-0x8(%rsi,%rcx,8)
je     20 <__gmpz_roinit_n+0x20>
mov    %ecx,%edi
movl   $0x0,(%rax)
mov    %rsi,0x8(%rax)
neg    %edi
test   %rdx,%rdx
cmovs  %edi,%ecx
mov    %ecx,0x4(%rax)
retq   
<<<sep_in_sample>>>
__gmpz_roinit_n (mpz_ptr x, mp_srcptr xp, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((xp)[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_alloc) = 0;
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
  ((x)->_mp_d) = (mp_ptr) xp;
  return x;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 5
16 7
17 6
18 6
19 6
20 6
21 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%r12d        # 195 <checkCutOrCopyFile+0x15>
test   %r12d,%r12d
jne    1aa <checkCutOrCopyFile+0x2a>
mov    0x0(%rip),%edx        # 1a0 <checkCutOrCopyFile+0x20>
xor    %eax,%eax
test   %edx,%edx
je     251 <checkCutOrCopyFile+0xd1>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%r13
mov    %r13,%rdi
callq  1bd <checkCutOrCopyFile+0x3d>
mov    0x0(%rip),%r15        # 1c4 <checkCutOrCopyFile+0x44>
mov    %rax,%r14
mov    %r15,%rdi
callq  1cf <checkCutOrCopyFile+0x4f>
lea    0x2(%r14,%rax,1),%rdi
mov    %rax,%rbx
callq  1dc <checkCutOrCopyFile+0x5c>
test   %rax,%rax
mov    %rax,%rbp
je     2e0 <checkCutOrCopyFile+0x160>
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %rax,%rdi
callq  1f6 <checkCutOrCopyFile+0x76>
lea    0x1(%rbp,%rbx,1),%rdi
lea    0x1(%r14),%rdx
movb   $0x2f,0x0(%rbp,%rbx,1)
mov    %r13,%rsi
callq  20c <checkCutOrCopyFile+0x8c>
test   %r12d,%r12d
jle    260 <checkCutOrCopyFile+0xe0>
lea    -0x1(%r12),%eax
xor    %ebx,%ebx
lea    0x8(,%rax,8),%r12
jmp    231 <checkCutOrCopyFile+0xb1>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rbx
cmp    %r12,%rbx
je     260 <checkCutOrCopyFile+0xe0>
mov    0x0(%rbx),%rdi
mov    %rbp,%rsi
callq  240 <checkCutOrCopyFile+0xc0>
test   %eax,%eax
jne    228 <checkCutOrCopyFile+0xa8>
mov    %rbp,%rdi
callq  24c <checkCutOrCopyFile+0xcc>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x0(%rip),%eax        # 266 <checkCutOrCopyFile+0xe6>
test   %eax,%eax
jle    2c0 <checkCutOrCopyFile+0x140>
sub    $0x1,%eax
xor    %ebx,%ebx
lea    0x8(,%rax,8),%r12
jmp    289 <checkCutOrCopyFile+0x109>
nopl   0x0(%rax)
add    $0x8,%rbx
cmp    %r12,%rbx
je     2c0 <checkCutOrCopyFile+0x140>
mov    0x0(%rbx),%rdi
mov    %rbp,%rsi
callq  298 <checkCutOrCopyFile+0x118>
test   %eax,%eax
jne    280 <checkCutOrCopyFile+0x100>
mov    %rbp,%rdi
callq  2a4 <checkCutOrCopyFile+0x124>
add    $0x8,%rsp
mov    $0x2,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  2c8 <checkCutOrCopyFile+0x148>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    $0x1,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2f4 <checkCutOrCopyFile+0x174>
xor    %eax,%eax
jmpq   251 <checkCutOrCopyFile+0xd1>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
checkCutOrCopyFile(int i)
{
  if(numCutFiles == 0 && numCopyFiles == 0) return 0;
  int j;
  char *str = (char *) malloc(strlen(files[i])+strlen(cwd)+2);
  if(!str) { msgBox("Insufficient memory", 1, ERROR); return 0; }
  strcpy(str, cwd);
  strcat(str, "/");
  strcat(str, files[i]);
  strcat(str, "\0");
  for(j = 0; j < numCutFiles; j++)
  {
    if(strcmp(cutFiles[j], str) == 0)
    {
      free(str); return 1;
    }
  }
  for(j = 0; j < numCopyFiles; j++)
  {
    if(strcmp(copyFiles[j], str) == 0)
    {
      free(str); return 2;
    }
  }
  free(str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 6
27 5
28 6
29 7
30 7
31 7
32 7
33 9
34 9
35 8
36 9
37 9
38 11
39 11
40 11
41 11
42 11
43 11
44 11
45 11
46 11
47 11
48 13
49 13
50 13
51 13
52 13
53 15
54 15
55 15
56 27
57 27
58 27
59 27
60 27
61 27
62 27
63 27
64 18
65 18
66 18
67 18
68 18
69 18
70 18
71 18
72 18
73 18
74 18
75 20
76 20
77 20
78 20
79 20
80 22
81 22
82 27
83 22
84 27
85 27
86 27
87 27
88 27
89 27
90 27
91 27
92 25
93 25
94 27
95 26
96 27
97 27
98 27
99 27
100 27
101 27
102 27
103 27
104 6
105 6
106 6
107 6
108 6
109 6
110 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # c16 <gsl_vector_int_set+0x6>
test   %eax,%eax
je     c1f <gsl_vector_int_set+0xf>
cmp    %rsi,(%rdi)
jbe    c38 <gsl_vector_int_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
shl    $0x2,%rax
imul   %rsi,%rax
mov    %edx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   c51 <gsl_vector_int_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_set (gsl_vector_int * v, const size_t i, int x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_int.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     2890 <gsl_matrix_uint_sub+0x40>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  287f <gsl_matrix_uint_sub+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%r8
cmp    %rax,%r8
jne    2866 <gsl_matrix_uint_sub+0x16>
test   %r10,%r10
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r12
je     28ef <gsl_matrix_uint_sub+0x9f>
shl    $0x2,%r13
shl    $0x2,%r12
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
nopl   (%rax)
test   %r8,%r8
je     28e0 <gsl_matrix_uint_sub+0x90>
mov    %rbx,%rdx
mov    %rbp,%r9
add    0x18(%rdi),%rdx
add    0x18(%rsi),%r9
xor    %eax,%eax
nopl   (%rax)
mov    (%r9,%rax,4),%ecx
sub    %ecx,(%rdx,%rax,4)
add    $0x1,%rax
cmp    %r8,%rax
jne    28d0 <gsl_matrix_uint_sub+0x80>
add    $0x1,%r11
add    %r13,%rbx
add    %r12,%rbp
cmp    %r10,%r11
jne    28b8 <gsl_matrix_uint_sub+0x68>
xor    %eax,%eax
jmp    2884 <gsl_matrix_uint_sub+0x34>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_sub (gsl_matrix_uint * a, const gsl_matrix_uint * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 21
55 21
56 21
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 127 <print_bibtex+0x7>
mov    %edx,%esi
cmpl   $0x1,(%rax,%rsi,4)
je     138 <print_bibtex+0x18>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
cmp    $0x1,%ecx
jne    12f <print_bibtex+0xf>
push   %rbx
sub    $0x10,%rsp
cmp    $0x1a,%edx
je     193 <print_bibtex+0x73>
cmpq   $0x0,0x0(%rip)        # 14f <print_bibtex+0x2f>
mov    $0x0,%ebx
jne    16b <print_bibtex+0x4b>
jmp    1a8 <print_bibtex+0x88>
nopl   0x0(%rax,%rax,1)
add    $0x18,%rbx
cmpq   $0x0,-0x10(%rbx)
je     1a8 <print_bibtex+0x88>
cmpq   $0x0,(%rbx)
jne    160 <print_bibtex+0x40>
cmp    %edx,-0x8(%rbx)
jne    160 <print_bibtex+0x40>
mov    %r9,%rdi
mov    %edx,0xc(%rsp)
mov    %r9,(%rsp)
callq  186 <print_bibtex+0x66>
mov    0xc(%rsp),%edx
mov    %rax,(%rbx)
mov    (%rsp),%r9
jmp    160 <print_bibtex+0x40>
mov    %r9,%rdi
callq  19b <print_bibtex+0x7b>
mov    %rax,0x0(%rip)        # 1a2 <print_bibtex+0x82>
nopw   0x0(%rax,%rax,1)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
print_bibtex (void *cls,
       const char *plugin_name,
       enum EXTRACTOR_MetaType type,
       enum EXTRACTOR_MetaFormat format,
       const char *data_mime_type,
       const char *data,
       size_t data_len)
{
  unsigned int i;
  if (1 != print[type])
    return 0;
  if (EXTRACTOR_METAFORMAT_UTF8 != format)
    return 0;
  if (EXTRACTOR_METATYPE_BIBTEX_ENTRY_TYPE == type)
    {
      entry_type = strdup (data);
      return 0;
    }
  for (i = 0; ((void *)0) != btm[i].bibTexName; i++)
    if ( (((void *)0) == btm[i].value) &&
  (btm[i].le_type == type) )
      btm[i].value = strdup (data);
  return 0;
}
<<<sep_in_sample>>>
1 10
2 10
3 10
4 10
5 24
6 24
7 24
8 12
9 12
10 8
11 8
12 14
13 14
14 19
15 19
16 19
17 19
18 19
19 19
20 19
21 19
22 20
23 20
24 20
25 20
26 22
27 22
28 22
29 22
30 22
31 22
32 22
33 22
34 16
35 16
36 16
37 16
38 24
39 24
40 24
41 24
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
je     12b0 <add_argless_short_opt+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x10(%rsi)
jne    12a7 <add_argless_short_opt+0x7>
mov    0x18(%rsi),%eax
or     0x18(%rdi),%eax
test   $0x10,%al
jne    12a7 <add_argless_short_opt+0x7>
mov    (%rcx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rcx)
mov    0x8(%rdi),%edx
mov    %dl,(%rax)
jmp    12a7 <add_argless_short_opt+0x7>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_argless_short_opt (const struct argp_option *opt,
                       const struct argp_option *real,
                       const char *domain, void *cookie)
{
  char **snao_end = cookie;
  if (!(opt->arg || real->arg)
      && !((opt->flags | real->flags) & 0x10))
    *(*snao_end)++ = opt->key;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 10
4 10
5 10
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
mov    %rdx,%r8
mov    %rcx,%r9
xor    %edx,%edx
xor    %ecx,%ecx
jmpq   bdf <mu_mailer_send_message+0xf>
nop
<<<sep_in_sample>>>
mu_mailer_send_message (mu_mailer_t mailer, mu_message_t msg,
   mu_address_t from, mu_address_t to)
{
  return mu_mailer_send_fragments (mailer, msg, 0, ((void *)0), from, to);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <gid_substitute+0x6>
xor    %edx,%edx
push   %rbx
mov    %rdi,%rbx
test   %eax,%eax
je     18 <gid_substitute+0x18>
mov    %edx,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  27 <gid_substitute+0x27>
mov    %eax,%edx
mov    0x0(%rip),%eax        # 2f <gid_substitute+0x2f>
test   %edx,%edx
je     10 <gid_substitute+0x10>
mov    $0x1,%edx
movl   $0xfffffffe,0x0(%rip)        # 42 <gid_substitute+0x42>
mov    $0xfffffffe,%eax
mov    %edx,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gid_substitute (int *negative)
{
  intmax_t r;
  int eid = 0;
  static gid_t gid_nobody;
   if (!gid_nobody) {
 if (taru_get_gid_by_name("nobody", &gid_nobody)) {
  eid = -2;
      gid_nobody = -2;
 }
   }
   r = (gid_t)gid_nobody;
  *negative = eid < 0;
  return r;
}
<<<sep_in_sample>>>
1 6
2 6
3 2
4 2
5 6
6 6
7 13
8 15
9 15
10 15
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 13
22 15
23 15
24 15
<<<sep_out_sample>>>
push   %rbp
xor    %r8d,%r8d
xor    %edi,%edi
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 4f2 <go_looking+0x12>
mov    0x0(%rip),%rcx        # 4f9 <go_looking+0x19>
movb   $0x0,0x0(%rip)        # 500 <go_looking+0x20>
mov    0x20(%rax),%rbx
mov    0x30(%rax),%rbp
mov    %rbx,%rsi
mov    %rbp,%rdx
callq  513 <go_looking+0x33>
cmp    $0x1,%eax
je     530 <go_looking+0x50>
mov    %rbx,%rdi
callq  520 <go_looking+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   52b <go_looking+0x4b>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 537 <go_looking+0x57>
cmp    %rbx,0x20(%rax)
jne    518 <go_looking+0x38>
cmp    %rbp,0x30(%rax)
jne    518 <go_looking+0x38>
mov    $0x0,%edi
callq  54d <go_looking+0x6d>
mov    %rax,%rdi
callq  555 <go_looking+0x75>
jmp    518 <go_looking+0x38>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
go_looking(void)
{
    filestruct *was_current = openfile->current;
    size_t was_current_x = openfile->current_x;
    int didfind;
    came_full_circle = 0;
    didfind = findnextstr(
  0,
  openfile->current, openfile->current_x, last_search, ((void *)0));
    if (didfind == 1 && openfile->current == was_current &&
  openfile->current_x == was_current_x)
 statusbar(gettext("This is the only occurrence"));
    edit_redraw(was_current);
    search_replace_abort();
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 2
5 2
6 3
7 7
8 6
9 3
10 4
11 7
12 7
13 7
14 10
15 10
16 13
17 13
18 15
19 15
20 15
21 14
22 14
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 12
31 12
32 12
33 12
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
jbe    f0 <gsl_ran_gaussian_tail_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
movapd %xmm0,%xmm3
sub    $0x28,%rsp
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
divsd  %xmm2,%xmm3
mulsd  0x0(%rip),%xmm0        # 10e <gsl_ran_gaussian_tail_pdf+0x2e>
movsd  %xmm3,0x18(%rsp)
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  121 <gsl_ran_gaussian_tail_pdf+0x41>
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
movsd  0x0(%rip),%xmm0        # 135 <gsl_ran_gaussian_tail_pdf+0x55>
xorpd  %xmm3,%xmm0
mulsd  %xmm3,%xmm0
mulsd  0x0(%rip),%xmm0        # 145 <gsl_ran_gaussian_tail_pdf+0x65>
callq  14a <gsl_ran_gaussian_tail_pdf+0x6a>
movsd  0x0(%rip),%xmm1        # 152 <gsl_ran_gaussian_tail_pdf+0x72>
movsd  0x10(%rsp),%xmm2
movapd %xmm0,%xmm3
mulsd  0x8(%rsp),%xmm1
movsd  0x0(%rip),%xmm0        # 16a <gsl_ran_gaussian_tail_pdf+0x8a>
mulsd  0x0(%rip),%xmm1        # 172 <gsl_ran_gaussian_tail_pdf+0x92>
add    $0x28,%rsp
mulsd  %xmm2,%xmm1
divsd  %xmm1,%xmm0
mulsd  %xmm3,%xmm0
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ran_gaussian_tail_pdf (const double x, const double a, const double sigma)
{
  if (x < a)
    {
      return 0;
    }
  else
    {
      double N, p;
      double u = x / sigma ;
      double f = gsl_sf_erfc (a / (sqrt (2.0) * sigma));
      N = 0.5 * f;
      p = (1 / (N * sqrt (2 * 3.14159265358979323846) * sigma)) * exp (-u * u / 2);
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 10
7 2
8 11
9 11
10 10
11 11
12 10
13 11
14 11
15 11
16 13
17 11
18 13
19 13
20 13
21 13
22 13
23 12
24 13
25 13
26 12
27 13
28 13
29 16
30 13
31 13
32 13
33 16
34 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl 0x0(%rip),%edx        # 1bb <visit_justprint_quoted+0xb>
mov    0x10(%rdi),%r8
mov    0x0(%rip),%rsi        # 1c6 <visit_justprint_quoted+0x16>
mov    0x0(%rip),%rdi        # 1cd <visit_justprint_quoted+0x1d>
mov    $0x0,%ecx
callq  1d7 <visit_justprint_quoted+0x27>
mov    0x0(%rip),%edi        # 1dd <visit_justprint_quoted+0x2d>
callq  1e2 <visit_justprint_quoted+0x32>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
visit_justprint_quoted (struct process_data *procdata, void *context)
{
  (void) context;
  print_quoted (stdout, quote_opts, stdout_is_a_tty,
                "%s",
                procdata->original_filename);
  putchar (separator);
  return VISIT_CONTINUE;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 7
9 7
10 9
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %rdi,0x8(%rsp)
lea    0x8(%rsp),%rdi
callq  2a0 <dup_container>
test   %eax,%eax
jne    3a1 <_dup_cont_action+0x31>
mov    (%rbx),%rax
mov    0x38(%rax),%rdi
test   %rdi,%rdi
je     3b0 <_dup_cont_action+0x40>
mov    0x8(%rsp),%rsi
callq  3a1 <_dup_cont_action+0x31>
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
lea    0x38(%rax),%rdi
callq  3b9 <_dup_cont_action+0x49>
test   %eax,%eax
jne    3a1 <_dup_cont_action+0x31>
mov    (%rbx),%rax
mov    0x38(%rax),%rdi
jmp    397 <_dup_cont_action+0x27>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_dup_cont_action (void *item, void *cbdata)
{
  int rc;
  struct mu_cfg_cont *cont = item;
  struct dup_data *pdd = cbdata;
  rc = dup_container (&cont);
  if (rc)
    return rc;
  if (!pdd->cont->v.section.children)
    {
      int rc = mu_list_create (&pdd->cont->v.section.children);
      if (rc)
 return rc;
    }
  return mu_list_append (pdd->cont->v.section.children, cont);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 6
6 6
7 7
8 7
9 9
10 9
11 9
12 9
13 15
14 15
15 16
16 16
17 16
18 16
19 11
20 11
21 12
22 12
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     18 <gss_oid_equal+0x18>
test   %rsi,%rsi
je     18 <gss_oid_equal+0x18>
mov    (%rdi),%edx
xor    %eax,%eax
cmp    (%rsi),%edx
je     20 <gss_oid_equal+0x20>
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    0x8(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  31 <gss_oid_equal+0x31>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
gss_oid_equal (gss_const_OID first_oid, gss_const_OID second_oid)
{
  return first_oid && second_oid &&
    first_oid->length == second_oid->length &&
    memcmp (first_oid->elements, second_oid->elements,
     second_oid->length) == 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 3
8 3
9 7
10 7
11 4
12 4
13 4
14 2
15 5
16 5
17 5
18 4
19 4
20 7
21 4
22 7
<<<sep_out_sample>>>
sub    $0x7e8,%rsp
mov    0x0(%rip),%edx        # 189d <ask_if_junkable+0xd>
mov    %fs:0x28,%rax
mov    %rax,0x7d8(%rsp)
xor    %eax,%eax
test   %edx,%edx
mov    $0x1,%al
je     18d8 <ask_if_junkable+0x48>
mov    0x7d8(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1947 <ask_if_junkable+0xb7>
add    $0x7e8,%rsp
retq   
nopl   0x0(%rax)
mov    %rdi,%rdx
xor    %eax,%eax
mov    $0x0,%edi
callq  18e7 <ask_if_junkable+0x57>
mov    0x0(%rip),%rdi        # 18ee <ask_if_junkable+0x5e>
callq  18f3 <ask_if_junkable+0x63>
mov    0x0(%rip),%rdx        # 18fa <ask_if_junkable+0x6a>
mov    $0x3e8,%esi
mov    %rsp,%rdi
callq  1907 <ask_if_junkable+0x77>
test   %rax,%rax
je     1940 <ask_if_junkable+0xb0>
lea    0x3f0(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %rsp,%rdi
callq  1923 <ask_if_junkable+0x93>
test   %eax,%eax
jle    1940 <ask_if_junkable+0xb0>
movzbl 0x3f0(%rsp),%eax
and    $0xffffffdf,%eax
cmp    $0x59,%al
sete   %al
movzbl %al,%eax
jmpq   18b6 <ask_if_junkable+0x26>
nop
xor    %eax,%eax
jmpq   18b6 <ask_if_junkable+0x26>
callq  194c <ask_if_junkable+0xbc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ask_if_junkable(char *s, int len)
{
  char line[1000];
  char word[1000];
  if (always_yes)
    return 1;
  (void)printf ("Junk `%*s'? ", len, s);
  (void)fflush (stdout);
  if (fgets (line, 1000, stdin) &&
      (sscanf (line, " %s ", word) > 0) &&
      ((word[0] == 'y') || (word[0] == 'Y')))
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 6
8 5
9 14
10 14
11 14
12 14
13 14
14 14
15 7
16 7
17 7
18 7
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 9
33 9
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 13
42 13
43 14
44 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  13bc <shcmd_set_errfile+0xc>
mov    %rax,0x48(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shcmd_set_errfile(SHCMD * shcmd, char * name)
{
 shcmd->errfile_ = strdup(name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
test   %edx,%edx
jne    e50 <taru_set_tarheader_flag+0x10>
not    %esi
and    %esi,0x14(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
or     %esi,0x14(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_set_tarheader_flag(TARU * taru, int flag, int n) {
 if (n) {
  taru->taru_tarheaderflagsM |= flag;
 } else {
  taru->taru_tarheaderflagsM &= ~flag;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 3
8 3
9 3
<<<sep_out_sample>>>
cmp    $0x1f,%esi
push   %rbx
mov    %rdi,%rbx
je     6078 <_jit_retr_d+0x28>
movslq %esi,%rcx
mov    $0x1f,%edx
mov    $0x12f,%esi
callq  606b <_jit_retr_d+0x1b>
mov    %rbx,%rdi
pop    %rbx
jmpq   6074 <_jit_retr_d+0x24>
nopl   0x0(%rax)
mov    $0x1f,%edx
mov    $0x1,%esi
callq  6087 <_jit_retr_d+0x37>
mov    %rbx,%rdi
pop    %rbx
jmpq   6090 <_jit_reti_d>
<<<sep_in_sample>>>
_jit_retr_d(jit_state_t *_jit, jit_int32_t u)
{
    if (_XMM0 != u)
 _jit_new_node_ww(_jit,jit_code_movr_d,_XMM0,u);
    else
 _jit_new_node_w(_jit,jit_code_live,_XMM0);
    _jit_ret(_jit);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 7
10 8
11 7
12 7
13 6
14 6
15 6
16 7
17 8
18 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
sub    $0x18,%rsp
mov    0xc0(%rdi),%rbx
test   %rbx,%rbx
jne    114 <wordsplit_dump_nodes+0x64>
jmpq   170 <wordsplit_dump_nodes+0xc0>
nopl   0x0(%rax)
mov    0x18(%rbx),%r14
mov    0x58(%r12),%r13
callq  0 <wsnode_flagstr>
mov    0x10(%rbx),%r8d
mov    %rax,%r9
mov    0xd0(%r12),%esi
mov    %rbx,%rcx
mov    %ebp,%edx
xor    %eax,%eax
mov    %r14,(%rsp)
mov    $0x0,%edi
add    $0x1,%ebp
callq  *%r13
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     170 <wordsplit_dump_nodes+0xc0>
mov    0x10(%rbx),%edi
test   $0x2,%dil
jne    d8 <wordsplit_dump_nodes+0x28>
mov    0x18(%rbx),%rdx
mov    0x20(%rbx),%r13d
mov    0x58(%r12),%r14
mov    %rdx,%r15
add    0x98(%r12),%r15
sub    %edx,%r13d
callq  0 <wsnode_flagstr>
mov    0x10(%rbx),%r8d
mov    0xd0(%r12),%esi
mov    %rax,%r9
mov    %rbx,%rcx
mov    %ebp,%edx
xor    %eax,%eax
mov    %r15,0x8(%rsp)
mov    %r13d,(%rsp)
mov    $0x0,%edi
callq  *%r14
mov    0x8(%rbx),%rbx
add    $0x1,%ebp
test   %rbx,%rbx
jne    114 <wordsplit_dump_nodes+0x64>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nop
<<<sep_in_sample>>>
wordsplit_dump_nodes (struct wordsplit *wsp)
{
  struct wordsplit_node *p;
  int n = 0;
  for (p = wsp->ws_head, n = 0; p; p = p->next, n++)
    {
      if (p->flags & 0x02)
 wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%s;",
         wsp->ws_lvl,
         n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);
      else
 wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%.*s;",
         wsp->ws_lvl,
         n, p, p->flags, wsnode_flagstr (p->flags),
         (int) (p->v.segm.end - p->v.segm.beg),
         wsp->ws_input + p->v.segm.beg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 2
9 2
10 5
11 5
12 5
13 5
14 5
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 5
27 8
28 5
29 5
30 5
31 7
32 7
33 7
34 16
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 5
52 5
53 5
54 5
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 18
63 18
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 6 <dicod_xidle+0x6>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   12 <dicod_xidle+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_xidle(dico_stream_t str, int argc, char **argv)
{
    stream_printf(str, "110 %lu second(s)\n", inactivity_timeout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbx
callq  c36 <_prog_flush+0x6>
mov    0x18(%rax),%rdi
mov    %rax,%rbx
callq  c42 <_prog_flush+0x12>
mov    0x20(%rbx),%rdi
callq  c4b <_prog_flush+0x1b>
xor    %eax,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
_prog_flush (mu_stream_t stream)
{
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  mu_stream_flush (fs->in);
  mu_stream_flush (fs->out);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk1imp_order (void *vstate)
{
  rk1imp_state_t *state = (rk1imp_state_t *) vstate;
  state = 0;
  return 1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
mov    %rbx,%rdi
js     6f <rpl_fclose+0x6f>
callq  18 <rpl_fclose+0x18>
test   %eax,%eax
jne    50 <rpl_fclose+0x50>
mov    %rbx,%rdi
callq  24 <rpl_fclose+0x24>
test   %eax,%eax
je     6c <rpl_fclose+0x6c>
callq  2d <rpl_fclose+0x2d>
mov    (%rax),%r12d
mov    %rbx,%rdi
mov    %rax,%rbp
callq  3b <rpl_fclose+0x3b>
test   %r12d,%r12d
je     49 <rpl_fclose+0x49>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  58 <rpl_fclose+0x58>
xor    %esi,%esi
mov    $0x1,%edx
mov    %eax,%edi
callq  66 <rpl_fclose+0x66>
cmp    $0xffffffffffffffff,%rax
jne    1c <rpl_fclose+0x1c>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   78 <rpl_fclose+0x78>
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 8
8 7
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 12
19 11
20 12
21 13
22 13
23 15
24 16
25 19
26 19
27 19
28 19
29 19
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 12
39 19
40 19
41 19
42 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1aac <gsl_sf_psi_1piy+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1ac0 <gsl_sf_psi_1piy+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x352,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ad6 <gsl_sf_psi_1piy+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_psi_1piy(const double x)
{
  gsl_sf_result result; int status = gsl_sf_psi_1piy_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_psi_1piy_e(x, &result)", "psi.c", 850, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     728 <output_close+0x38>
callq  6fe <output_close+0xe>
mov    (%rbx),%edi
test   %edi,%edi
js     709 <output_close+0x19>
callq  709 <output_close+0x19>
mov    0x4(%rbx),%edi
test   %edi,%edi
js     719 <output_close+0x29>
cmp    (%rbx),%edi
je     719 <output_close+0x29>
callq  719 <output_close+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   722 <output_close+0x32>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 72e <output_close+0x3e>
test   %eax,%eax
jne    738 <output_close+0x48>
pop    %rbx
retq   
nopl   0x0(%rax)
pop    %rbx
xor    %edi,%edi
jmpq   1d0 <log_working_directory>
<<<sep_in_sample>>>
output_close (struct output *out)
{
  if (! out)
    {
      if (stdio_traced)
        log_working_directory (0);
      return;
    }
  output_dump (out);
  if (out->out >= 0)
    close (out->out);
  if (out->err >= 0 && out->err != out->out)
    close (out->err);
  output_init (out);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 9
6 10
7 10
8 10
9 11
10 12
11 12
12 12
13 12
14 12
15 13
16 14
17 15
18 14
19 14
20 5
21 5
22 5
23 15
24 15
25 15
26 15
27 6
28 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  e19 <gsl_complex_sec+0x9>
callq  e1e <gsl_complex_sec+0xe>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_sec (gsl_complex a)
{
  gsl_complex z = gsl_complex_cos (a);
  return gsl_complex_inverse (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  3c <ModifyOneParm+0xc>
test   %eax,%eax
jne    58 <ModifyOneParm+0x28>
mov    (%rbx),%rdi
movsd  0x8(%rbx),%xmm0
callq  4d <ModifyOneParm+0x1d>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x8(%rbx),%rsi
mov    (%rbx),%rdi
callq  64 <ModifyOneParm+0x34>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ModifyOneParm (PVOID pData, PVOID pNullInfo)
{
  PVARMOD pvarmod = (PVARMOD) pData;
  if (IsInput(pvarmod->hvar))
    SetInput (pvarmod->hvar, pvarmod->uvar.pifn);
  else
    SetVar (pvarmod->hvar, pvarmod->uvar.dVal);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 5
15 5
16 5
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %r12
test   %esi,%esi
push   %rbp
push   %rbx
mov    %esi,%ebx
jle    255 <linetable_print+0x95>
xor    %esi,%esi
mov    %rdi,%r12
mov    %ebx,%edi
callq  1da <linetable_print+0x1a>
mov    %rax,%rbp
mov    0x0(%rip),%rax        # 1e4 <linetable_print+0x24>
cmp    %ebx,0xc(%rax)
je     210 <linetable_print+0x50>
lea    0x1(%rbx),%edi
xor    %esi,%esi
callq  1f3 <linetable_print+0x33>
pop    %rbx
sub    %rbp,%rax
mov    %rbp,%rdi
mov    %r12,%rcx
pop    %rbp
pop    %r12
mov    %rax,%rdx
mov    $0x1,%esi
jmpq   20d <linetable_print+0x4d>
nopl   (%rax)
mov    0x0(%rip),%rdx        # 217 <linetable_print+0x57>
mov    %r12,%rcx
mov    $0x1,%esi
mov    %rbp,%rdi
sub    %rbp,%rdx
callq  22a <linetable_print+0x6a>
mov    0x0(%rip),%rax        # 231 <linetable_print+0x71>
cmpb   $0xa,-0x1(%rax)
je     250 <linetable_print+0x90>
pop    %rbx
pop    %rbp
mov    %r12,%rsi
mov    $0xa,%edi
pop    %r12
jmpq   248 <linetable_print+0x88>
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x0,%edi
xor    %eax,%eax
callq  261 <linetable_print+0xa1>
<<<sep_in_sample>>>
linetable_print(FILE *op, int lineno)
{
 const char *s, *p;
 if (lineno <= 0)
  die("linetable_print: line number must >= 1 (lineno = %d)", lineno);
 s = linetable_get(lineno, ((void *)0));
 if (vb->length == lineno) {
  fwrite(s, 1, endp - s, op);
  if (endp[-1] != '\n')
   fputc('\n', op);
 } else {
  p = linetable_get(lineno + 1, ((void *)0));
  fwrite(s, 1, p - s, op);
 }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 12
16 12
17 12
18 15
19 13
20 13
21 13
22 15
23 15
24 13
25 13
26 13
27 13
28 8
29 8
30 8
31 8
32 8
33 8
34 9
35 9
36 9
37 15
38 15
39 10
40 10
41 15
42 10
43 10
44 15
45 15
46 15
47 15
48 5
49 5
50 5
<<<sep_out_sample>>>
push   %r12
mov    $0x1,%r8d
mov    %rsi,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdx,%rbx
callq  3e8 <gsl_dft_complex_float_inverse+0x18>
test   %rbx,%rbx
js     440 <gsl_dft_complex_float_inverse+0x70>
cvtsi2ss %rbx,%xmm1
movss  0x0(%rip),%xmm0        # 3fa <gsl_dft_complex_float_inverse+0x2a>
xor    %edi,%edi
test   %rbx,%rbx
divss  %xmm1,%xmm0
lea    0x0(,%r12,8),%rsi
mov    %rbp,%rcx
je     436 <gsl_dft_complex_float_inverse+0x66>
movss  (%rcx),%xmm1
add    $0x1,%rdi
mulss  %xmm0,%xmm1
movss  %xmm1,(%rcx)
movss  0x4(%rcx),%xmm1
mulss  %xmm0,%xmm1
movss  %xmm1,0x4(%rcx)
add    %rsi,%rcx
cmp    %rbx,%rdi
jne    410 <gsl_dft_complex_float_inverse+0x40>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbx,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2ss %rdx,%xmm1
addss  %xmm1,%xmm1
jmp    3f2 <gsl_dft_complex_float_inverse+0x22>
<<<sep_in_sample>>>
gsl_dft_complex_float_inverse (const float data[],
                                   const size_t stride, const size_t n,
                                   float result[])
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_dft_complex_float_transform (data, stride, n, result, sign);
  {
    const float norm = 1.0F / (float)n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((result)[2*(stride)*(i)]) *= norm;
        ((result)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 4
8 6
9 8
10 8
11 8
12 8
13 10
14 10
15 8
16 8
17 8
18 10
19 12
20 10
21 12
22 12
23 13
24 13
25 13
26 13
27 10
28 10
29 17
30 17
31 17
32 17
33 17
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    %rsi,(%rdi)
jbe    2f08 <gsl_vector_short_alloc_row_from_matrix+0x58>
mov    $0x28,%edi
callq  2ecb <gsl_vector_short_alloc_row_from_matrix+0x1b>
test   %rax,%rax
je     2f2a <gsl_vector_short_alloc_row_from_matrix+0x7a>
mov    0x10(%rbx),%rcx
lea    (%rcx,%rcx,1),%rdx
imul   %rbp,%rdx
add    0x18(%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x8(%rbx),%rdx
movq   $0x1,0x8(%rax)
movq   $0x0,0x18(%rax)
mov    %rdx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xb5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f21 <gsl_vector_short_alloc_row_from_matrix+0x71>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x8,%ecx
mov    $0xbd,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f43 <gsl_vector_short_alloc_row_from_matrix+0x93>
xor    %eax,%eax
jmp    2efb <gsl_vector_short_alloc_row_from_matrix+0x4b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_alloc_row_from_matrix (gsl_matrix_short * m,
                                              const size_t i)
{
  gsl_vector_short * v;
  const size_t M = m->size1;
  if (i >= M)
    {
      do { gsl_error ("row index is out of range", "getset_source.c", 181, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_short *) malloc (sizeof (gsl_vector_short));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 189
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * i * m->tda ;
  v->size = m->size2;
  v->stride = 1;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 10
9 10
10 11
11 11
12 20
13 20
14 20
15 20
16 20
17 21
18 22
19 23
20 21
21 25
22 25
23 25
24 25
25 25
26 8
27 8
28 8
29 8
30 8
31 25
32 8
33 25
34 25
35 25
36 13
37 13
38 13
39 13
40 13
41 17
42 17
43 17
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x50(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->indexof_from_to (list, start_index, end_index, elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    0x20(%rdi),%rsi
movswl 0x2(%rdi),%edi
jmpq   10 <VCopyPolygon+0x10>
<<<sep_in_sample>>>
VCopyPolygon(VPolygon * poly)
{
 return VCreatePolygonFromTemplate(poly->numVtces, poly->vertex, poly);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     48 <mc_maclist_get_cardname_from_list+0x48>
movzbl (%rdi),%ecx
lea    0x10(%rsi),%rdx
jmp    28 <mc_maclist_get_cardname_from_list+0x28>
nopl   0x0(%rax)
mov    %rdx,%rsi
add    $0x10,%rdx
mov    -0x10(%rdx),%rax
test   %rax,%rax
je     48 <mc_maclist_get_cardname_from_list+0x48>
cmp    %cl,0x8(%rsi)
jne    18 <mc_maclist_get_cardname_from_list+0x18>
movzbl 0x9(%rsi),%r8d
cmp    %r8b,0x1(%rdi)
jne    18 <mc_maclist_get_cardname_from_list+0x18>
movzbl 0xa(%rsi),%esi
cmp    %sil,0x2(%rdi)
jne    18 <mc_maclist_get_cardname_from_list+0x18>
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mc_maclist_get_cardname_from_list (const mac_t *mac, card_mac_list_item_t *list)
{
 int i = 0;
 while (list[i].name) {
  if ((mac->byte[0] == list[i].byte[0]) &&
      (mac->byte[1] == list[i].byte[1]) &&
      (mac->byte[2] == list[i].byte[2]))
  {
   return list[i].name;
  }
  i++;
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 14
23 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 3e7 <context_pop+0x7>
push   %rbx
mov    0x0(%rip),%rbx        # 3ef <context_pop+0xf>
callq  3f4 <context_pop+0x14>
mov    0x0(%rip),%rdi        # 3fb <context_pop+0x1b>
movq   $0x0,0x0(%rip)        # 406 <context_pop+0x26>
callq  40b <context_pop+0x2b>
test   %rbx,%rbx
movq   $0x0,0x0(%rip)        # 419 <context_pop+0x39>
movq   $0x0,0x0(%rip)        # 424 <context_pop+0x44>
movq   $0x0,0x0(%rip)        # 42f <context_pop+0x4f>
movq   $0x0,0x0(%rip)        # 43a <context_pop+0x5a>
movq   $0x0,0x0(%rip)        # 445 <context_pop+0x65>
je     4f8 <context_pop+0x118>
mov    (%rbx),%rax
mov    0x30(%rbx),%rdx
mov    %rax,0x0(%rip)        # 459 <context_pop+0x79>
mov    0x8(%rbx),%rax
mov    %rax,0x0(%rip)        # 464 <context_pop+0x84>
mov    0x10(%rbx),%rax
mov    %rdx,0x0(%rip)        # 46f <context_pop+0x8f>
mov    %rax,0x0(%rip)        # 476 <context_pop+0x96>
mov    0x18(%rbx),%rax
mov    %rax,0x0(%rip)        # 481 <context_pop+0xa1>
mov    0x20(%rbx),%rax
mov    %rax,0x0(%rip)        # 48c <context_pop+0xac>
mov    0x28(%rbx),%rax
mov    %rax,0x0(%rip)        # 497 <context_pop+0xb7>
mov    0x38(%rbx),%eax
mov    %eax,0x0(%rip)        # 4a0 <context_pop+0xc0>
mov    0x40(%rbx),%rax
mov    %rax,0x0(%rip)        # 4ab <context_pop+0xcb>
mov    0x48(%rbx),%rax
mov    %rax,0x0(%rip)        # 4b6 <context_pop+0xd6>
mov    0x50(%rbx),%rax
mov    %rax,0x0(%rip)        # 4c1 <context_pop+0xe1>
mov    0x0(%rip),%rax        # 4c8 <context_pop+0xe8>
test   %rax,%rax
je     4f0 <context_pop+0x110>
mov    0x0(%rip),%rdx        # 4d4 <context_pop+0xf4>
mov    (%rax,%rdx,8),%rdi
callq  4dd <context_pop+0xfd>
mov    0x58(%rbx),%rdi
callq  4e6 <context_pop+0x106>
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
xor    %edi,%edi
jmp    4d8 <context_pop+0xf8>
nopl   0x0(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
context_pop ()
{
  struct context *cp = context_tos;
  fclose (yyin);
  yyin = ((void *)0);
  free (point.file);
  point.file = ((void *)0);
  memset (&yylloc, 0, sizeof (yylloc));
  if (!cp)
    return 1;
  context_tos = cp->parent;
  yylloc = cp->locus;
  point = cp->point;
  interactive = cp->interactive;
  ino = cp->ino;
  dev = cp->dev;
  yyin = cp->file;
  yy_delete_buffer (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)));
  yy_switch_to_buffer (cp->buf);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 2
3 3
4 4
5 6
6 5
7 6
8 9
9 7
10 8
11 8
12 8
13 8
14 9
15 11
16 13
17 11
18 12
19 12
20 12
21 13
22 12
23 12
24 12
25 12
26 12
27 13
28 13
29 14
30 14
31 15
32 15
33 16
34 16
35 17
36 17
37 18
38 18
39 18
40 18
41 18
42 18
43 19
44 19
45 20
46 21
47 21
48 21
49 18
50 18
51 18
52 10
53 21
54 21
55 21
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
testb  $0x1,0x50(%rdi)
mov    %rdi,%rax
jne    48 <call_chunkfun+0x18>
mov    0x38(%rdi),%rax
mov    %rsi,%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x48(%rdi),%rdi
mov    0x38(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_chunkfun (struct obstack *h, size_t size)
{
  if (h->use_extra_arg)
    return h->chunkfun.extra (h->extra_arg, size);
  else
    return h->chunkfun.plain (size);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
push   %rbp
test   %r8,%r8
movzbl (%rdx),%r10d
push   %rbx
je     15b7 <gsl_stats_uchar_minmax_index+0x47>
mov    %r10d,%r11d
xor    %ebx,%ebx
xor    %ebp,%ebp
xor    %eax,%eax
nopl   0x0(%rax)
movzbl (%rdx),%r9d
cmp    %r10b,%r9b
jae    1597 <gsl_stats_uchar_minmax_index+0x27>
mov    %rax,%rbp
mov    %r9d,%r10d
cmp    %r11b,%r9b
jbe    15a2 <gsl_stats_uchar_minmax_index+0x32>
mov    %rax,%rbx
mov    %r9d,%r11d
add    $0x1,%rax
add    %rcx,%rdx
cmp    %r8,%rax
jne    1588 <gsl_stats_uchar_minmax_index+0x18>
mov    %rbp,(%rdi)
mov    %rbx,(%rsi)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    15ae <gsl_stats_uchar_minmax_index+0x3e>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_uchar_minmax_index (size_t * min_index_out,
                                   size_t * max_index_out, const unsigned char data[],
                                   const size_t stride, const size_t n)
{
  unsigned char min = data[0 * stride];
  unsigned char max = data[0 * stride];
  size_t i, min_index = 0, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned char xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  *min_index_out = min_index;
  *max_index_out = max_index;
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 4
5 8
6 6
7 7
8 7
9 8
10 8
11 10
12 11
13 11
14 11
15 11
16 16
17 16
18 16
19 16
20 8
21 8
22 8
23 8
24 22
25 23
26 24
27 24
28 24
29 7
30 7
31 7
32 7
<<<sep_out_sample>>>
mov    (%rsi),%r8
xorpd  %xmm2,%xmm2
test   %r8,%r8
je     2a7 <scaled_enorm+0x57>
mov    0x8(%rsi),%rax
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
xorpd  %xmm2,%xmm2
lea    0x0(,%rax,8),%r10
mov    0x8(%rdi),%rax
lea    0x0(,%rax,8),%r9
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movsd  (%rcx),%xmm1
add    $0x1,%rax
add    %r10,%rcx
mulsd  (%rdx),%xmm1
add    %r9,%rdx
cmp    %r8,%rax
mulsd  %xmm1,%xmm1
addsd  %xmm1,%xmm2
jne    288 <scaled_enorm+0x38>
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     2b3 <scaled_enorm+0x63>
repz retq 
movapd %xmm2,%xmm0
sub    $0x8,%rsp
callq  2c0 <scaled_enorm+0x70>
add    $0x8,%rsp
jmp    2b1 <scaled_enorm+0x61>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
scaled_enorm (const gsl_vector * d, const gsl_vector * f)
{
  double e2 = 0;
  size_t i, n = f->size;
  for (i = 0; i < n; i++)
    {
      double fi = gsl_vector_get (f, i);
      double di = gsl_vector_get (d, i);
      double u = di * fi;
      e2 += u * u;
    }
  return sqrt (e2);
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 5
5 5
6 5
7 5
8 3
9 3
10 3
11 3
12 5
13 5
14 9
15 5
16 5
17 9
18 9
19 5
20 10
21 10
22 5
23 12
24 12
25 12
26 13
27 12
28 2
29 12
30 13
31 13
32 13
<<<sep_out_sample>>>
mov    $0x2,%esi
jmpq   2aa <mu_attribute_set_flagged+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_set_flagged (mu_attribute_t attr)
{
  return mu_attribute_set_flags (attr, 0x02);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     14 <nntp_itr_getitem+0x14>
mov    0x10(%rdi),%rax
mov    %rax,(%rsi)
movq   $0x0,0x10(%rdi)
test   %rdx,%rdx
je     20 <nntp_itr_getitem+0x20>
movq   $0x0,(%rdx)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_getitem (void *owner, void **item, const void **pkey)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  if (item)
    {
      *((char **)item) = nntp_iterator->item;
      nntp_iterator->item = ((void *)0);
    }
  if (pkey)
    *pkey = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 9
7 9
8 10
9 12
10 12
11 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  ec9 <xdr_dis_service_type+0x9>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_service_type(xdrs, objp)
	XDR *xdrs;
	dis_service_type *objp;
{
	if (!xdr_byte_u_char(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 9
6 5
7 9
8 9
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
ucomisd %xmm3,%xmm2
movsd  %xmm0,0x8(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x18(%rsp)
jae    1288 <TruncInvGGammaRandom+0x68>
mov    $0x1,%ebx
jmp    1258 <TruncInvGGammaRandom+0x38>
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    $0x19,%ebx
je     12ac <TruncInvGGammaRandom+0x8c>
movsd  0x10(%rsp),%xmm1
movsd  0x8(%rsp),%xmm0
callq  1269 <TruncInvGGammaRandom+0x49>
movsd  (%rsp),%xmm4
ucomisd %xmm0,%xmm4
ja     1250 <TruncInvGGammaRandom+0x30>
ucomisd 0x18(%rsp),%xmm0
ja     1250 <TruncInvGGammaRandom+0x30>
add    $0x20,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movsd  (%rsp),%xmm0
mov    $0x0,%edi
movsd  0x18(%rsp),%xmm1
mov    $0x2,%eax
callq  12a2 <TruncInvGGammaRandom+0x82>
add    $0x20,%rsp
xorpd  %xmm0,%xmm0
pop    %rbx
retq   
mov    $0x0,%edi
xor    %eax,%eax
callq  12b8 <TruncInvGGammaRandom+0x98>
movsd  0x10(%rsp),%xmm3
mov    $0x0,%edi
movsd  0x8(%rsp),%xmm2
mov    $0x4,%eax
movsd  0x18(%rsp),%xmm1
movsd  (%rsp),%xmm0
callq  12de <TruncInvGGammaRandom+0xbe>
jmpq   1258 <TruncInvGGammaRandom+0x38>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TruncInvGGammaRandom (double alpha, double beta, double a, double b)
{
  double X = 0.0;
  int iter = 0;
  if (a >= b)
    printf ("TruncLogNormalRandom: min >= max  [%g %g]\n", a, b);
  else do {
    if(++iter == 25) {
      printf("TruncInvGGammaRandom: problem with range: ");
      printf("min %g, max %g, alpha %g, beta %g\n", a, b, alpha, beta);
    }
    X = InvGGammaRandom(alpha, beta);
  }
  while (X < a || X > b);
  return X;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 2
8 5
9 8
10 8
11 8
12 8
13 8
14 8
15 12
16 12
17 12
18 14
19 14
20 14
21 14
22 14
23 16
24 16
25 16
26 16
27 6
28 6
29 6
30 6
31 6
32 16
33 3
34 16
35 16
36 9
37 9
38 9
39 10
40 10
41 10
42 10
43 10
44 10
45 10
46 10
47 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x2,%edi
callq  454 <rl_begin_undo_group+0x14>
addl   $0x1,0x0(%rip)        # 45b <rl_begin_undo_group+0x1b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_begin_undo_group ()
{
  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
  _rl_undo_group_level++;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
11 6
<<<sep_out_sample>>>
cvtsi2sd %edx,%xmm0
lea    0x1(%rdx),%eax
mov    %ecx,0x104(%rsi)
add    $0x1,%ecx
mov    %edx,0x100(%rsi)
mov    %eax,%edi
shr    $0x1f,%edi
add    %edi,%eax
sar    %eax
mov    %eax,0x108(%rsi)
mov    %ecx,%eax
shr    $0x1f,%eax
add    %eax,%ecx
sar    %ecx
mov    %ecx,0x10c(%rsi)
divsd  0x0(%rip),%xmm0        # 53c <resizeChaserWindow+0x3c>
movsd  %xmm0,0x290(%rsi)
retq   
<<<sep_in_sample>>>
resizeChaserWindow(craft * c, viewer * u, int width, int height, int initial_flag)
{
 u->width = width;
 u->height = height;
 u->xCenter = (u->width + 1) / 2;
 u->yCenter = (u->height + 1) / 2;
 u->scaleFactor = (double) width / (double) 1200;;
}
<<<sep_in_sample>>>
1 7
2 5
3 4
4 6
5 3
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <mu_alloc_die+0xb>
test   %rax,%rax
je     12 <mu_alloc_die+0x12>
callq  *%rax
mov    $0x0,%esi
mov    $0x0,%edi
callq  21 <mu_alloc_die+0x21>
mov    %rax,%rdi
xor    %eax,%eax
callq  2b <mu_alloc_die+0x2b>
callq  30 <mu_alloc>
<<<sep_in_sample>>>
mu_alloc_die ()
{
  if (mu_alloc_die_hook)
    mu_alloc_die_hook ();
  mu_error (dgettext ("mailutils", "Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # ad7 <dap_arrnum+0x7>
push   %rbp
push   %rbx
lea    (%rax,%rax,2),%rbp
mov    $0xffffffff,%eax
shl    $0x5,%rbp
mov    0x0(%rbp),%ebx
test   %ebx,%ebx
jle    b4a <dap_arrnum+0x7a>
movzbl (%rdi),%r10d
xor    %r9d,%r9d
xor    %eax,%eax
nopl   0x0(%rax)
mov    0x0(%rbp),%r11
xor    %edx,%edx
test   %r10b,%r10b
mov    (%r11,%r9,1),%r8
je     b33 <dap_arrnum+0x63>
cmp    %r10b,(%r8)
jne    b3a <dap_arrnum+0x6a>
mov    $0x1,%edx
jmp    b2b <dap_arrnum+0x5b>
xchg   %ax,%ax
add    $0x1,%rdx
cmp    -0x1(%r8,%rdx,1),%cl
jne    b3a <dap_arrnum+0x6a>
movzbl (%rdi,%rdx,1),%ecx
test   %cl,%cl
jne    b20 <dap_arrnum+0x50>
cmpb   $0x5b,(%r8,%rdx,1)
je     b4d <dap_arrnum+0x7d>
add    $0x1,%eax
add    $0x8,%r9
cmp    %ebx,%eax
jne    b00 <dap_arrnum+0x30>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
lea    0x1(%rax),%edx
cmp    %ebx,%edx
jge    bb6 <dap_arrnum+0xe6>
sub    %eax,%ebx
mov    $0x1,%r9d
nopl   0x0(%rax)
movslq %edx,%rdx
mov    (%r11,%rdx,8),%r8
xor    %edx,%edx
test   %r10b,%r10b
je     b93 <dap_arrnum+0xc3>
cmp    %r10b,(%r8)
jne    bb0 <dap_arrnum+0xe0>
mov    $0x1,%edx
jmp    b8b <dap_arrnum+0xbb>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rdx
cmp    -0x1(%r8,%rdx,1),%cl
jne    bb0 <dap_arrnum+0xe0>
movzbl (%rdi,%rdx,1),%ecx
test   %cl,%cl
jne    b80 <dap_arrnum+0xb0>
cmpb   $0x5b,(%r8,%rdx,1)
jne    bb0 <dap_arrnum+0xe0>
add    $0x1,%r9d
cmp    %ebx,%r9d
lea    (%r9,%rax,1),%edx
jne    b60 <dap_arrnum+0x90>
nopw   0x0(%rax,%rax,1)
pop    %rbx
mov    %r9d,(%rsi)
pop    %rbp
retq   
mov    $0x1,%r9d
jmp    bb0 <dap_arrnum+0xe0>
xchg   %ax,%ax
<<<sep_in_sample>>>
dap_arrnum(char vname[], int *dim)
{
  int v;
  int n;
  int d;
  for (v = 0; v < dap_obs[dap_ono].do_nvar; v++)
    {
      for (n = 0; vname[n] && vname[n] == dap_obs[dap_ono].do_nam[v][n]; n++)
 ;
      if (!vname[n] && dap_obs[dap_ono].do_nam[v][n] == '[')
 {
   for (d = 1; v + d < dap_obs[dap_ono].do_nvar; d++)
     {
       for (n = 0; vname[n] &&
       vname[n] == dap_obs[dap_ono].do_nam[v + d][n]; n++)
  ;
       if (vname[n] || dap_obs[dap_ono].do_nam[v + d][n] != '[')
  break;
     }
   *dim = d;
   return v;
 }
    }
  return -1;
}
<<<sep_in_sample>>>
1 6
2 2
3 2
4 6
5 24
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 10
31 10
32 6
33 6
34 6
35 6
36 24
37 25
38 25
39 25
40 12
41 12
42 12
43 12
44 12
45 12
46 15
47 15
48 14
49 14
50 14
51 14
52 14
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 14
61 14
62 17
63 17
64 12
65 12
66 12
67 12
68 12
69 25
70 20
71 25
72 25
73 12
74 12
75 12
<<<sep_out_sample>>>
mov    %edi,%eax
xor    %edi,%edi
movb   $0x0,0x0(%rip)        # 439b <ntoa+0xb>
test   %eax,%eax
js     43d8 <ntoa+0x48>
mov    $0x0,%ecx
nopl   0x0(%rax)
xor    %edx,%edx
sub    $0x1,%rcx
div    %esi
mov    %edx,%edx
test   %eax,%eax
movzbl 0x0(%rdx),%edx
mov    %dl,(%rcx)
jne    43a8 <ntoa+0x18>
test   %dil,%dil
mov    %rcx,%rax
je     43cf <ntoa+0x3f>
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
nopl   0x0(%rax,%rax,1)
neg    %eax
mov    $0x1,%edi
jmp    439f <ntoa+0xf>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ntoa (int32_t value, int radix)
{
  _Bool negative;
  uint32_t uvalue;
  static char str[256];
  char *s = &str[sizeof str];
  *--s = '\0';
  if (value < 0)
    {
      negative = 1;
      uvalue = -(uint32_t) value;
    }
  else
    {
      negative = 0;
      uvalue = (uint32_t) value;
    }
  do
    {
      *--s = digits[uvalue % radix];
      uvalue /= radix;
    }
  while (uvalue > 0);
  if (negative)
    *--s = '-';
  return s;
}
<<<sep_in_sample>>>
1 16
2 15
3 7
4 8
5 8
6 15
7 15
8 20
9 20
10 20
11 20
12 23
13 20
14 20
15 23
16 24
17 20
18 24
19 25
20 25
21 27
22 27
23 27
24 11
25 10
26 10
27 10
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 8d6 <_rl_fix_point+0x6>
mov    0x0(%rip),%eax        # 8dc <_rl_fix_point+0xc>
cmp    %eax,%edx
jle    900 <_rl_fix_point+0x30>
mov    %eax,0x0(%rip)        # 8e6 <_rl_fix_point+0x16>
test   %edi,%edi
je     8f8 <_rl_fix_point+0x28>
mov    0x0(%rip),%edx        # 8f0 <_rl_fix_point+0x20>
cmp    %edx,%eax
jl     910 <_rl_fix_point+0x40>
test   %edx,%edx
js     920 <_rl_fix_point+0x50>
repz retq 
nopw   0x0(%rax,%rax,1)
test   %edx,%edx
jns    8e6 <_rl_fix_point+0x16>
movl   $0x0,0x0(%rip)        # 90e <_rl_fix_point+0x3e>
jmp    8e6 <_rl_fix_point+0x16>
mov    %eax,0x0(%rip)        # 916 <_rl_fix_point+0x46>
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 92a <_rl_fix_point+0x5a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  do { if (rl_point > rl_end) rl_point = rl_end; else if (rl_point < 0) rl_point = 0; } while (0);
  if (fix_mark_too)
    do { if (rl_mark > rl_end) rl_mark = rl_end; else if (rl_mark < 0) rl_mark = 0; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
sub    $0x28,%rsp
lea    0x10(%rsp),%rax
mov    %rax,(%rsp)
callq  1692 <gsl_sf_coupling_3j+0x12>
test   %eax,%eax
movsd  0x10(%rsp),%xmm0
jne    16a8 <gsl_sf_coupling_3j+0x28>
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
mov    %eax,%ecx
mov    $0x19e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16be <gsl_sf_coupling_3j+0x3e>
movsd  0x10(%rsp),%xmm0
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_sf_coupling_3j(int two_ja, int two_jb, int two_jc,
                          int two_ma, int two_mb, int two_mc)
{
  gsl_sf_result result; int status = gsl_sf_coupling_3j_e(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_coupling_3j_e(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc, &result)",
 "coupling.c"
  ,
 414
  , status) ; return result.val ; } while (0); } ; return result.val;
                                            ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 8
7 4
8 10
9 10
10 10
11 4
12 4
13 4
14 4
15 4
16 8
17 10
18 10
19 10
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    (%rdi),%r12
mov    %rsi,%rbx
mov    0x10(%rdi),%rsi
mov    %rbx,%rdi
callq  *0x30(%rbp)
mov    0x8(%rbp),%rsi
shl    $0x4,%rax
lea    (%r12,%rax,1),%rcx
cmp    %rsi,%rcx
jae    728 <hash_get_next+0x78>
test   %rcx,%rcx
mov    %rcx,%rdx
jne    6f1 <hash_get_next+0x41>
jmp    718 <hash_get_next+0x68>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rdx),%rdx
test   %rdx,%rdx
je     718 <hash_get_next+0x68>
cmp    %rbx,(%rdx)
jne    6e8 <hash_get_next+0x38>
mov    0x8(%rdx),%rax
test   %rax,%rax
je     718 <hash_get_next+0x68>
mov    (%rax),%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rcx),%rax
test   %rax,%rax
jne    702 <hash_get_next+0x52>
add    $0x10,%rcx
cmp    %rcx,%rsi
ja     710 <hash_get_next+0x60>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
callq  72d <hash_get_next+0x7d>
nopl   (%rax)
<<<sep_in_sample>>>
hash_get_next (const Hash_table *table, const void *entry)
{
  struct hash_entry const *bucket
    = table->bucket + table->hasher (entry, table->n_buckets);
  struct hash_entry const *cursor;
  if (! (bucket < table->bucket_limit))
    abort ();
  for (cursor = bucket; cursor; cursor = cursor->next)
    if (cursor->data == entry && cursor->next)
      return cursor->next->data;
  while (++bucket < table->bucket_limit)
    if (bucket->data)
      return bucket->data;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 6
11 4
12 3
13 6
14 6
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 10
29 15
30 15
31 15
32 15
33 15
34 12
35 12
36 12
37 11
38 11
39 11
40 15
41 15
42 14
43 15
44 15
45 7
46 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  88e <get_lineno+0xe>
movslq %eax,%rdi
callq  896 <get_lineno+0x16>
mov    0x8(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     8b1 <get_lineno+0x31>
mov    $0x58e,%edx
mov    $0x0,%esi
callq  8b1 <get_lineno+0x31>
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
get_lineno (var)
     SHELL_VAR *var;
{
  char *p;
  int ln;
  ln = executing_line_number ();
  p = itos (ln);
  do { if (((var)->value)) sh_xfree((((var)->value)), "variables.c", 1422); } while (0);
  ((var)->value = (p));
  return (var);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 7
7 7
8 8
9 7
10 8
11 8
12 8
13 8
14 8
15 9
16 11
17 11
18 11
19 11
20 11
21 11
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # a4a <dicod_show_std_help+0xa>
mov    $0x0,%esi
jmpq   a54 <dicod_show_std_help+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_show_std_help(dico_stream_t str)
{
    dico_list_iterate(command_list, _print_help, str);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r14
test   %edi,%edi
mov    %r8d,%r14d
push   %r13
mov    %esi,%r13d
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
js     5f <fdutimensat+0x5f>
mov    %rcx,%rsi
callq  20 <fdutimensat+0x20>
test   %rbp,%rbp
mov    %eax,%ebx
je     2c <fdutimensat+0x2c>
cmp    $0xffffffff,%eax
je     40 <fdutimensat+0x40>
cmp    $0x1,%ebx
je     64 <fdutimensat+0x64>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
callq  45 <fdutimensat+0x45>
cmpl   $0x26,(%rax)
jne    31 <fdutimensat+0x31>
mov    %r14d,%ecx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %r13d,%edi
callq  5b <fdutimensat+0x5b>
mov    %eax,%ebx
jmp    2c <fdutimensat+0x2c>
test   %rdx,%rdx
jne    4a <fdutimensat+0x4a>
callq  69 <fdutimensat+0x69>
mov    $0xffffffff,%ebx
movl   $0x9,(%rax)
jmp    31 <fdutimensat+0x31>
<<<sep_in_sample>>>
fdutimensat (int fd, int dir, char const *file, struct timespec const ts[2],
             int atflag)
{
  int result = 1;
  if (0 <= fd)
    result = rpl_futimens (fd, ts);
  if (file && (fd < 0 || (result == -1 && (*__errno_location ()) == 38)))
    result = rpl_utimensat (dir, file, ts, atflag);
  if (result == 1)
    {
      (*__errno_location ()) = 9;
      result = -1;
    }
  return result;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 6
13 6
14 7
15 6
16 7
17 7
18 7
19 9
20 9
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 15
29 7
30 7
31 7
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 7
40 7
41 11
42 12
43 11
44 11
<<<sep_out_sample>>>
cmp    $0xffffffff,%edi
mov    %rsi,%rax
mov    %edx,%esi
je     1b90 <fchmod_or_chmod+0x10>
jmpq   1b8f <fchmod_or_chmod+0xf>
nop
mov    %rax,%rdi
jmpq   1b98 <fchmod_or_chmod+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fchmod_or_chmod (int fd, const char *name, mode_t mode)
{
  if (1 && fd != -1)
    return fchmod (fd, mode);
  else
    return chmod (name, mode);
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 3
5 4
6 4
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%edx
mov    %rdi,%rbx
test   %edx,%edx
jle    1e0 <strhash_reset+0x20>
mov    0x8(%rdi),%rcx
xor    %eax,%eax
movq   $0x0,(%rcx,%rax,8)
add    $0x1,%rax
cmp    %eax,%edx
jg     1d0 <strhash_reset+0x10>
mov    0x10(%rbx),%rdi
callq  1e9 <strhash_reset+0x29>
movq   $0x0,0x18(%rbx)
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strhash_reset(STRHASH *sh)
{
 int i;
 for (i = 0; i < sh->buckets; i++) {
  { (&sh->htab[i])->slh_first = ((void *)0); };
 }
 pool_reset(sh->pool);
 sh->entries = 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 4
8 5
9 5
10 4
11 4
12 7
13 7
14 8
15 9
16 9
17 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1617 <yyget_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_text (void)
{
        return yytext;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <str_eq+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
str_eq (const void *elt1, const void *elt2)
{
  return strcmp (elt1, elt2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
movslq (%rdi),%rsi
mov    0x0(%rip),%rax        # a <__gmpz_clear+0xa>
mov    0x8(%rdi),%rdi
shl    $0x3,%rsi
jmpq   *%rax
<<<sep_in_sample>>>
__gmpz_clear (mpz_ptr x)
{
  (*__gmp_free_func) (((x)->_mp_d), (((x)->_mp_alloc)) * sizeof (mp_limb_t));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  a89 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  a92 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # b <give_usage+0xb>
mov    $0x0,%edi
xor    %eax,%eax
callq  17 <give_usage+0x17>
add    $0x8,%rsp
jmpq   20 <give_usage+0x20>
<<<sep_in_sample>>>
give_usage(void)
{
  printf ("Usage: %s [-hrR] [-n <recs>] <files>\n          [--num <recs>] [--raw] [--reverse] [--help]\n",
          program_name);
  print_wtmp_file_location ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 6
7 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_arg(void *arg1, void *arg2)
{
      struct arg arg;
      arg.arg1 = arg1;
      arg.arg2 = arg2;
      return arg;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%ebx
nopw   %cs:0x0(%rax,%rax,1)
mov    0x20(%rbx),%rdi
add    $0x28,%rbx
callq  871d <option_help+0x1d>
mov    -0x28(%rbx),%rdx
mov    0x0(%rip),%rdi        # 8728 <option_help+0x28>
mov    %rax,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  8737 <option_help+0x37>
cmpq   $0x0,(%rbx)
jne    8710 <option_help+0x10>
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
option_help()
{
 const struct dbg_option *opt;
 for (opt = option_list; opt->name; opt++)
  fprintf(out_fp, "\t%-15.15s - %s\n", opt->name, gettext(opt->help_txt));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 6
16 6
17 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     102 <gsl_vector_complex_long_double_isnull+0x62>
shl    $0x5,%rsi
mov    0x10(%rdi),%rax
xor    %edx,%edx
fldz   
jmp    d7 <gsl_vector_complex_long_double_isnull+0x37>
nopw   0x0(%rax,%rax,1)
jne    e8 <gsl_vector_complex_long_double_isnull+0x48>
fldt   0x10(%rax)
fucomip %st(1),%st
jp     f0 <gsl_vector_complex_long_double_isnull+0x50>
jne    f8 <gsl_vector_complex_long_double_isnull+0x58>
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
je     100 <gsl_vector_complex_long_double_isnull+0x60>
fldt   (%rax)
fucomip %st(1),%st
jnp    c0 <gsl_vector_complex_long_double_isnull+0x20>
fstp   %st(0)
jmp    fa <gsl_vector_complex_long_double_isnull+0x5a>
nopl   0x0(%rax)
fstp   %st(0)
jmp    fa <gsl_vector_complex_long_double_isnull+0x5a>
nopl   0x0(%rax)
fstp   %st(0)
jmp    fa <gsl_vector_complex_long_double_isnull+0x5a>
nopl   0x0(%rax)
fstp   %st(0)
xor    %eax,%eax
retq   
nopl   (%rax)
fstp   %st(0)
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_long_double_isnull (const gsl_vector_complex_long_double * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 6
17 6
18 6
19 6
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 13
34 13
35 13
36 13
37 17
38 17
39 17
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
test   %r10,%r10
je     274b <gsl_matrix_long_add_constant+0x6b>
push   %rbx
lea    0x0(,%r9,8),%rbx
shl    $0x3,%r11
xor    %esi,%esi
xor    %r8d,%r8d
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     273b <gsl_matrix_long_add_constant+0x5b>
mov    0x18(%rdi),%rdx
lea    (%rsi,%rbx,1),%rcx
lea    (%rdx,%rsi,1),%rax
add    %rdx,%rcx
nopl   0x0(%rax)
cvtsi2sdq (%rax),%xmm1
addsd  %xmm0,%xmm1
add    $0x8,%rax
cvttsd2si %xmm1,%rdx
mov    %rdx,-0x8(%rax)
cmp    %rcx,%rax
jne    2720 <gsl_matrix_long_add_constant+0x40>
add    $0x1,%r8
add    %r11,%rsi
cmp    %r10,%r8
jne    2708 <gsl_matrix_long_add_constant+0x28>
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_matrix_long_add_constant (gsl_matrix_long * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 2
7 2
8 2
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 9
25 9
26 7
27 7
28 7
29 7
30 15
31 15
32 15
33 15
34 15
35 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  ee9 <rc_system_init+0x9>
callq  eee <rc_system_init+0xe>
callq  ef3 <rc_system_init+0x13>
add    $0x8,%rsp
jmpq   efc <rc_system_init+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rc_system_init (void)
{
  control_section_init ();
  translate_section_init ();
  rule_section_init ();
  smtp_rule_section_init ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 7
6 6
7 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x2018,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
callq  8b6 <fatalperror+0x26>
mov    (%rax),%edi
callq  8bd <fatalperror+0x2d>
mov    $0x2000,%esi
mov    %rax,%r8
mov    %rsp,%rdi
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %eax,%eax
callq  8d7 <fatalperror+0x47>
mov    %rsp,%rsi
mov    %ebx,%edi
callq  8e1 <fatalperror+0x51>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fatalperror (int f, char *msg)
{
  char buf[8192];
  snprintf (buf, sizeof buf, "%s: %s", msg, strerror ((*__errno_location ())));
  fatal (f, buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
testb  $0x1,0x50(%rdi)
mov    %rdi,%rax
jne    48 <call_chunkfun+0x18>
mov    0x38(%rdi),%rax
mov    %rsi,%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x48(%rdi),%rdi
mov    0x38(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_chunkfun (struct obstack *h, size_t size)
{
  if (h->use_extra_arg)
    return h->chunkfun.extra (h->extra_arg, size);
  else
    return h->chunkfun.plain (size);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    0x0(%rip),%rdi        # 1b <start_msgs+0xb>
callq  20 <start_msgs+0x10>
mov    $0x0,%esi
mov    $0xe,%edi
callq  2f <start_msgs+0x1f>
mov    %rsp,%rsi
xor    %edx,%edx
xor    %edi,%edi
movq   $0x4,(%rsp)
movq   $0x4,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,0x18(%rsp)
callq  5e <start_msgs+0x4e>
xor    %eax,%eax
add    $0x28,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_msgs (void)
{
  struct itimerval itimer;
  message (current_state);
  signal (14, disp_msg);
  itimer.it_value.tv_sec = itimer.it_interval.tv_sec = 4;
  itimer.it_value.tv_usec = itimer.it_interval.tv_usec = 0;
  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 8
8 8
9 8
10 6
11 6
12 7
13 7
14 8
15 10
16 10
17 10
18 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  259 <filter_open+0x9>
mov    (%rax),%rdi
add    $0x8,%rsp
jmpq   265 <filter_open+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filter_open (mu_stream_t stream)
{
  mu_filter_t filter = mu_stream_get_owner (stream);
  return mu_stream_open (filter->stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  89 <_rl_with_macro_input+0x9>
mov    %rbx,0x0(%rip)        # 90 <_rl_with_macro_input+0x10>
movl   $0x0,0x0(%rip)        # 9a <_rl_with_macro_input+0x1a>
orq    $0x800,0x0(%rip)        # a5 <_rl_with_macro_input+0x25>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_with_macro_input (string)
     char *string;
{
  _rl_push_executing_macro ();
  rl_executing_macro = string;
  executing_macro_index = 0;
  (rl_readline_state |= (0x0000800));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
mov    %rdx,%rdi
mov    %ecx,%esi
mov    %r8d,%edx
jmpq   d <qcopy_acl+0xd>
<<<sep_in_sample>>>
qcopy_acl (const char *src_name, int source_desc, const char *dst_name,
           int dest_desc, mode_t mode)
{
  return qset_acl (dst_name, dest_desc, mode);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r12
xor    %eax,%eax
mov    %rdi,%r12
mov    $0x0,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
xor    %ebx,%ebx
callq  188 <escapeprint+0x18>
test   %rbp,%rbp
je     203 <escapeprint+0x93>
nopl   (%rax)
movzbl (%r12,%rbx,1),%eax
mov    %eax,%edx
movzbl %al,%edi
and    $0xdf,%edx
sub    $0x41,%edx
cmp    $0x19,%edx
jbe    1f0 <escapeprint+0x80>
movzbl %al,%esi
lea    -0x30(%rsi),%edx
mov    %esi,%edi
cmp    $0x9,%edx
jbe    1f0 <escapeprint+0x80>
cmp    $0x20,%esi
je     1f0 <escapeprint+0x80>
cmp    $0x2e,%esi
je     1f0 <escapeprint+0x80>
xor    %eax,%eax
mov    $0x0,%edi
add    $0x1,%rbx
callq  1cf <escapeprint+0x5f>
test   $0xf,%bl
jne    1fe <escapeprint+0x8e>
nopl   0x0(%rax)
cmp    %rbx,%rbp
jbe    203 <escapeprint+0x93>
mov    $0x0,%edi
xor    %eax,%eax
callq  1e9 <escapeprint+0x79>
jmp    190 <escapeprint+0x20>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbx
callq  1f9 <escapeprint+0x89>
test   $0xf,%bl
je     1d8 <escapeprint+0x68>
cmp    %rbx,%rbp
ja     190 <escapeprint+0x20>
pop    %rbx
pop    %rbp
pop    %r12
mov    $0xa,%edi
jmpq   211 <escapeprint+0xa1>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
escapeprint (const char *str, size_t len)
{
  size_t i;
  printf (" (length %lu bytes):\n\t", (unsigned long) len);
  for (i = 0; i < len; i++)
    {
      if (((str[i] & 0xFF) >= 'A' && (str[i] & 0xFF) <= 'Z') ||
   ((str[i] & 0xFF) >= 'a' && (str[i] & 0xFF) <= 'z') ||
   ((str[i] & 0xFF) >= '0' && (str[i] & 0xFF) <= '9')
   || (str[i] & 0xFF) == ' ' || (str[i] & 0xFF) == '.')
 printf ("%c", (str[i] & 0xFF));
      else
 printf ("\\x%02X", (str[i] & 0xFF));
      if ((i + 1) % 16 == 0 && (i + 1) < len)
 printf ("'\n\t'");
    }
  printf ("\n");
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 2
8 5
9 4
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 9
22 9
23 8
24 8
25 10
26 10
27 10
28 10
29 13
30 13
31 14
32 13
33 14
34 14
35 14
36 14
37 14
38 15
39 15
40 15
41 15
42 15
43 14
44 11
45 14
46 14
47 5
48 5
49 18
50 18
51 18
52 17
53 17
54 17
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # df6 <gsl_vector_ushort_const_ptr+0x6>
test   %eax,%eax
je     dff <gsl_vector_ushort_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    e10 <gsl_vector_ushort_const_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e2d <gsl_vector_ushort_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_const_ptr (const gsl_vector_ushort * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_ushort.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const unsigned short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %r12
test   %rsi,%rsi
push   %rbp
push   %rbx
mov    %rsi,%rbx
je     70 <osip_message_set__header+0x70>
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %rdx,%r12
callq  1a <osip_message_set__header+0x1a>
test   %eax,%eax
mov    %r12,%rdx
js     30 <osip_message_set__header+0x30>
pop    %rbx
mov    %rbp,%rsi
mov    %eax,%edi
pop    %rbp
pop    %r12
jmpq   2f <osip_message_set__header+0x2f>
nop
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  3b <osip_message_set__header+0x3b>
test   %eax,%eax
jne    48 <osip_message_set__header+0x48>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    $0x0,%r8d
xor    %ecx,%ecx
mov    $0x3,%edx
mov    $0x1a2,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  66 <osip_message_set__header+0x66>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   (%rax)
mov    $0xfffffffb,%eax
jmp    3f <osip_message_set__header+0x3f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_set__header (osip_message_t * sip, const char *hname, const char *hvalue)
{
  int my_index;
  if (hname == ((void *)0))
    return -5;
  my_index = __osip_message_is_known_header (hname);
  if (my_index >= 0) {
    int ret;
    ret = __osip_message_call_method (my_index, sip, hvalue);
    if (ret != 0)
      return ret;
    return 0;
  }
  if (osip_message_set_header (sip, hname, hvalue) != 0) {
    osip_trace ("osip_message_parse.c", 418, TRACE_LEVEL3, ((void *)0), "Could not set unknown header\n");
    return 0;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 6
11 7
12 9
13 7
14 19
15 9
16 9
17 19
18 19
19 9
20 9
21 14
22 14
23 14
24 14
25 14
26 19
27 19
28 19
29 19
30 19
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 19
39 19
40 15
41 19
42 19
43 19
44 5
45 5
46 5
<<<sep_out_sample>>>
mov    %esi,%edx
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
<<<sep_out_sample>>>
callq  1385 <rl_reset_line_state+0x5>
mov    0x0(%rip),%rdx        # 138c <rl_reset_line_state+0xc>
mov    $0x0,%eax
movl   $0x1,0x0(%rip)        # 139b <rl_reset_line_state+0x1b>
test   %rdx,%rdx
cmovne %rdx,%rax
mov    %rax,0x0(%rip)        # 13a9 <rl_reset_line_state+0x29>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_reset_line_state ()
{
  rl_on_new_line ();
  rl_display_prompt = rl_prompt ? rl_prompt : "";
  forced_display = 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 4
6 4
7 4
8 7
9 7
10 7
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
lea    0x138(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  af <osip_message_get_record_route+0x1f>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    c8 <osip_message_get_record_route+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  c2 <osip_message_get_record_route+0x32>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
osip_message_get_record_route (const osip_message_t * sip, int pos, osip_record_route_t ** dest)
{
  osip_record_route_t *record_route;
  *dest = ((void *)0);
  if (osip_list_size (&sip->record_routes) <= pos)
    return -1;
  record_route = (osip_record_route_t *) osip_list_get (&sip->record_routes, pos);
  *dest = record_route;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 9
17 8
18 10
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
callq  1d <swheaderline_set_level+0x1d>
test   %rax,%rax
mov    %rax,%rbx
je     48 <swheaderline_set_level+0x48>
mov    %ebp,%ecx
mov    $0x0,%edx
mov    $0x4,%esi
mov    %rsp,%rdi
xor    %eax,%eax
callq  3b <swheaderline_set_level+0x3b>
movzwl (%rsp),%eax
movb   $0x0,0x3(%rsp)
mov    %ax,0x1(%rbx)
mov    0x8(%rsp),%rax
xor    %fs:0x28,%rax
jne    5f <swheaderline_set_level+0x5f>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
callq  64 <swheaderline_set_level+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swheaderline_set_level(char *outputline, int level)
{
 char slev[4];
        char * p = swheaderline_get_type_pointer(outputline);
 if (p) {
  snprintf(slev, sizeof(slev), "%02d",level);
  slev[sizeof(slev) - 1] = '\0';
  memcpy(p+1, slev, 2);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 5
10 4
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 7
20 8
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 6d7 <_hs_append_history_line+0x17>
mov    (%rax,%rdi,8),%rbp
mov    0x0(%rbp),%r12
mov    %r12,%rdi
callq  6e7 <_hs_append_history_line+0x27>
mov    %r13,%rdi
mov    %rax,%rbx
callq  6f2 <_hs_append_history_line+0x32>
lea    0x2(%rbx,%rax,1),%rsi
mov    %r12,%rdi
callq  6ff <_hs_append_history_line+0x3f>
test   %rax,%rax
je     730 <_hs_append_history_line+0x70>
mov    %rax,0x0(%rbp)
movb   $0xa,(%rax,%rbx,1)
mov    %r13,%rsi
mov    0x0(%rbp),%rax
add    $0x8,%rsp
lea    0x1(%rax,%rbx,1),%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   727 <_hs_append_history_line+0x67>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_hs_append_history_line (which, line)
     int which;
     const char *line;
{
  HIST_ENTRY *hent;
  size_t newlen, curlen;
  char *newline;
  hent = the_history[which];
  curlen = strlen (hent->line);
  newlen = curlen + strlen (line) + 2;
  newline = realloc (hent->line, newlen);
  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 9
11 9
12 9
13 10
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 14
22 15
23 16
24 16
25 18
26 16
27 18
28 18
29 18
30 18
31 16
32 16
33 18
34 18
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     51 <mu_asnprintf+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  82 <mu_asnprintf+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mu_asnprintf (char **pbuf, size_t *psize, const char *fmt, ...)
{
  int rc;
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc = mu_vasnprintf (pbuf, psize, fmt, ap);
  __builtin_va_end(ap);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 6
17 5
18 5
19 5
20 5
21 5
22 6
23 9
24 9
<<<sep_out_sample>>>
cmp    0x0(%rip),%rdi        # 1127 <history_reset+0x7>
je     1150 <history_reset+0x30>
cmp    0x0(%rip),%rdi        # 1130 <history_reset+0x10>
je     1138 <history_reset+0x18>
repz retq 
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 113f <history_reset+0x1f>
mov    %rax,0x0(%rip)        # 1146 <history_reset+0x26>
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 1157 <history_reset+0x37>
mov    %rax,0x0(%rip)        # 115e <history_reset+0x3e>
retq   
nop
<<<sep_in_sample>>>
history_reset(const filestruct *h)
{
    if (h == search_history)
 search_history = searchbot;
    else if (h == replace_history)
 replace_history = replacebot;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 4
12 4
13 4
14 4
<<<sep_out_sample>>>
mov    (%rcx),%rax
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  void (**addfnptr) (struct exclude *, char const *, int) = data;
  (*addfnptr) (ex, pattern, options);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x90,%rsp
mov    %rsp,%rsi
callq  1f3 <cdio_is_device_generic+0x13>
test   %eax,%eax
jne    218 <cdio_is_device_generic+0x38>
mov    0x18(%rsp),%eax
and    $0xb000,%eax
cmp    $0x2000,%eax
sete   %al
add    $0x90,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
callq  21d <cdio_is_device_generic+0x3d>
mov    (%rax),%edi
callq  224 <cdio_is_device_generic+0x44>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  236 <cdio_is_device_generic+0x56>
add    $0x90,%rsp
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_is_device_generic(const char *source_name)
{
  struct stat buf;
  if (0 != stat(source_name, &buf)) {
    cdio_warn ("Can't get file status for %s:\n%s", source_name,
                strerror((*__errno_location ())));
    return 0;
  }
  return (((((buf.st_mode)) & 0170000) == (0060000)) || ((((buf.st_mode)) & 0170000) == (0020000)));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 6
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 10
25 7
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
mov    0x0(%rip),%edx        # 125e <tree8_to_bits+0xe>
mov    %rsi,0x8(%rsp)
mov    %rdi,0x18(%rsp)
lea    0x8(%rsp),%rsi
lea    0x18(%rsp),%rdi
callq  1277 <tree8_to_bits+0x27>
add    $0x20,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
tree8_to_bits (unsigned char *bv_0, unsigned char const *hits_tree8)
{
  unsigned char* bv = bv_0;
  tree8_to_bits_1 (&bv, &hits_tree8, tree8_levels);
  return bv_0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 3
7 4
8 4
9 4
10 6
11 6
12 6
13 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     3419 <argp_state_help+0x69>
mov    0x1c(%rdi),%eax
test   $0x2,%al
jne    3400 <argp_state_help+0x50>
test   %rsi,%rsi
je     3400 <argp_state_help+0x50>
mov    %ebp,%edx
mov    0x40(%rbx),%r8
mov    (%rbx),%rdi
or     $0x80,%dl
test   $0x40,%al
cmovne %edx,%ebp
mov    %rsi,%rdx
mov    %rbx,%rsi
mov    %ebp,%ecx
callq  1fe0 <_help>
testb  $0x20,0x1c(%rbx)
jne    3400 <argp_state_help+0x50>
test   $0x100,%ebp
jne    340e <argp_state_help+0x5e>
and    $0x200,%ebp
jne    3407 <argp_state_help+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %edi,%edi
callq  340e <argp_state_help+0x5e>
mov    0x0(%rip),%edi        # 3414 <argp_state_help+0x64>
callq  3419 <argp_state_help+0x69>
test   %rsi,%rsi
je     3400 <argp_state_help+0x50>
mov    0x0(%rip),%r8        # 3425 <argp_state_help+0x75>
mov    %rsi,%rdx
mov    %ebp,%ecx
xor    %esi,%esi
xor    %edi,%edi
callq  1fe0 <_help>
jmp    33f0 <argp_state_help+0x40>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)
{
  if ((!state || ! (state->flags & 0x02)) && stream)
    {
      if (state && (state->flags & 0x40))
        flags |= 0x80;
      _help (state ? state->root_argp : 0, state, stream, flags,
             state ? state->name : (program_invocation_short_name));
      if (!state || ! (state->flags & 0x20))
        {
          if (flags & 0x100)
            exit (argp_err_exit_status);
          if (flags & 0x200)
            exit (0);
        }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 9
24 9
25 11
26 11
27 13
28 13
29 17
30 17
31 17
32 17
33 14
34 14
35 12
36 12
37 3
38 3
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
cmpq   $0x0,0x28(%rdx)
mov    %rdx,%rbx
je     6b8 <filter_doc+0x38>
mov    %esi,%r12d
mov    %rdx,%rdi
mov    %rcx,%rsi
callq  69f <filter_doc+0x1f>
mov    0x28(%rbx),%rcx
mov    %rbp,%rsi
mov    %r12d,%edi
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdx
jmpq   *%rcx
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    %rdi,%rax
pop    %r12
retq   
<<<sep_in_sample>>>
filter_doc (const char *doc, int key, const struct argp *argp,
     const struct argp_state *state)
{
  if (argp->help_filter)
    {
      void *input = _argp_input (argp, state);
      return (*argp->help_filter) (key, doc, input);
    }
  else
    return doc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 3
7 4
8 4
9 6
10 6
11 6
12 7
13 7
14 7
15 11
16 11
17 11
18 7
19 7
20 7
21 11
22 11
23 11
24 11
25 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3b9 <gc_md5+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_md5 (const void *in, size_t inlen, void *resbuf)
{
  md5_buffer (in, inlen, resbuf);
  return GC_OK;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
imul   %rsi,%rdi
jmpq   c9 <grecs_calloc+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
grecs_calloc(size_t nmemb, size_t size)
{
 return grecs_zalloc(nmemb * size);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     fc <builtin_error+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
xor    %eax,%eax
mov    %rdi,%rbx
callq  0 <builtin_error_prolog>
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 11d <builtin_error+0x7d>
movl   $0x8,0x8(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  141 <builtin_error+0xa1>
mov    0x0(%rip),%rsi        # 148 <builtin_error+0xa8>
mov    $0xa,%edi
callq  152 <builtin_error+0xb2>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
builtin_error (const char *format, ...)
{
  va_list args;
  builtin_error_prolog ();
  __builtin_va_start(args,format);
  vfprintf (stderr, format, args);
  __builtin_va_end(args);
  fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 4
19 2
20 4
21 5
22 6
23 6
24 6
25 5
26 5
27 5
28 5
29 5
30 6
31 8
32 8
33 8
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     68 <next+0x68>
xor    %edx,%edx
xor    %esi,%esi
callq  1a <next+0x1a>
test   %eax,%eax
lea    -0x1(%rax),%ebx
je     40 <next+0x40>
nopl   0x0(%rax)
mov    %rbp,%rdi
sub    $0x1,%ebx
callq  33 <next+0x33>
cmp    $0xffffffff,%ebx
jne    28 <next+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    0x0(%rip),%rcx        # 47 <next+0x47>
add    $0x8,%rsp
mov    $0xa,%edx
pop    %rbx
pop    %rbp
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   61 <next+0x61>
nopl   0x0(%rax)
xor    %ebx,%ebx
mov    %rbp,%rdi
sub    $0x1,%ebx
callq  75 <next+0x75>
cmp    $0xffffffff,%ebx
jne    28 <next+0x28>
jmp    38 <next+0x38>
nopl   0x0(%rax)
<<<sep_in_sample>>>
next(dico_iterator_t itr, char *arg)
{
    int skip = arg ? strtoul(arg, ((void *)0), 0) : 1;
    if (skip == 0)
 fprintf(stderr, "next arg?\n");
    while (skip--)
 dico_iterator_next(itr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 7
16 6
17 7
18 6
19 6
20 8
21 8
22 8
23 8
24 8
25 5
26 8
27 5
28 8
29 8
30 5
31 5
32 5
33 5
34 5
35 7
36 6
37 7
38 6
39 6
40 6
41 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     196 <mperror+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0x20(%rsp),%rdx
mov    %rsi,%rax
lea    0xe0(%rsp),%rcx
mov    %edi,%esi
mov    %rax,%rdi
mov    %rdx,0x18(%rsp)
lea    0x8(%rsp),%rdx
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rcx,0x10(%rsp)
callq  0 <vmsg>
add    $0xd8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mperror (int err_num, const char *fmt, ...)
{
  va_list args;
  __builtin_va_start(args,fmt);
  vmsg (fmt, err_num, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 2
18 4
19 5
20 5
21 4
22 5
23 4
24 4
25 4
26 5
27 7
28 7
29 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x28,%edi
callq  1e <next_append_slot+0xe>
mov    0x0(%rip),%rdx        # 25 <next_append_slot+0x15>
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movb   $0x0,0x20(%rax)
test   %rdx,%rdx
je     60 <next_append_slot+0x50>
mov    %rax,0x18(%rdx)
mov    %rax,0x0(%rip)        # 58 <next_append_slot+0x48>
add    $0x8,%rsp
retq   
nopl   (%rax)
mov    %rax,0x0(%rip)        # 67 <next_append_slot+0x57>
mov    %rax,0x0(%rip)        # 6e <next_append_slot+0x5e>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_append_slot()
{
  struct append_queue *n = (ck_malloc((1)*sizeof(struct append_queue)));
  n->fname = ((void *)0);
  n->text = ((void *)0);
  n->textlen = 0;
  n->next = ((void *)0);
  n->free = 0;
  if (append_tail)
      append_tail->next = n;
  else
      append_head = n;
  return append_tail = n;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 9
5 4
6 5
7 6
8 7
9 8
10 9
11 9
12 10
13 13
14 14
15 14
16 14
17 12
18 13
19 14
20 14
21 14
<<<sep_out_sample>>>
test   %esi,%esi
jne    7a0 <CDB___db_removechk+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   7b0 <CDB___db_statchk>
<<<sep_in_sample>>>
CDB___db_removechk(dbp, flags)
 const DB *dbp;
 u_int32_t flags;
{
 switch (flags) {
 case 0:
  break;
 default:
  return (CDB___db_ferr(dbp->dbenv, "DB->remove", 0));
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 12
4 12
5 12
6 9
7 9
8 9
9 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1386 <ea_end_of_line+0x6>
mov    %eax,0x0(%rip)        # 138c <ea_end_of_line+0xc>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
ea_end_of_line (WINDOW *window, int count)
{
  input_line_point = input_line_end;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <gsl_permutation_get+0x6>
test   %eax,%eax
je     f <gsl_permutation_get+0xf>
cmp    %rsi,(%rdi)
jbe    20 <gsl_permutation_get+0x20>
mov    0x8(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d <gsl_permutation_get+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permutation_get (const gsl_permutation * p, const size_t i)
{
  if ((gsl_check_range && (i >= p->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_permutation.h", 90, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return p->data[i];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 8
18 8
<<<sep_out_sample>>>
test   %rcx,%rcx
mov    %rdx,%rax
je     5a0 <output_file_now+0x20>
cmpq   $0xffffffffffffffff,0x30(%rdx)
je     5bd <output_file_now+0x3d>
movzbl %r9b,%r9d
jmpq   598 <output_file_now+0x18>
nopl   0x0(%rax,%rax,1)
test   %r9b,%r9b
jne    5b0 <output_file_now+0x30>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x1,%edx
mov    %rax,%rsi
jmpq   5bd <output_file_now+0x3d>
push   %rax
mov    $0x0,%ecx
mov    $0x747,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5d7 <output_file_now+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_file_now (char const *from, _Bool *from_needs_removal,
   const struct stat *from_st, char const *to,
   mode_t mode, _Bool backup)
{
  if (to == ((void *)0))
    {
      if (backup)
 create_backup (from, from_st, 1);
    }
  else
    {
      ((from_st->st_size != -1) ? (void) (0) : __assert_fail ("from_st->st_size != -1", "patch.c", 1863, __PRETTY_FUNCTION__));
      move_file (from, from_needs_removal, from_st, to, mode, backup);
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 12
5 12
6 13
7 13
8 13
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 4
17 12
18 12
19 12
20 12
21 12
22 12
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 167 <current_history+0x7>
cmp    0x0(%rip),%eax        # 16d <current_history+0xd>
je     180 <current_history+0x20>
mov    0x0(%rip),%rdx        # 176 <current_history+0x16>
test   %rdx,%rdx
je     180 <current_history+0x20>
mov    (%rdx,%rax,8),%rax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
current_history ()
{
  return ((history_offset == history_length) || the_history == 0)
  ? (HIST_ENTRY *)((void *)0)
  : the_history[history_offset];
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 3
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
test   %edi,%edi
jne    350 <jobserver_pre_child+0x40>
mov    0x0(%rip),%edi        # 31a <jobserver_pre_child+0xa>
test   %edi,%edi
js     350 <jobserver_pre_child+0x40>
sub    $0x8,%rsp
mov    $0x1,%edx
mov    $0x2,%esi
xor    %eax,%eax
callq  333 <jobserver_pre_child+0x23>
mov    0x0(%rip),%edi        # 339 <jobserver_pre_child+0x29>
mov    $0x1,%edx
mov    $0x2,%esi
xor    %eax,%eax
add    $0x8,%rsp
jmpq   34e <jobserver_pre_child+0x3e>
xchg   %ax,%ax
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
jobserver_pre_child (int recursive)
{
  if (!recursive && job_fds[0] >= 0)
    {
      (void) fcntl ((job_fds[0]), 2, 1);
      (void) fcntl ((job_fds[1]), 2, 1);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
movslq %esi,%rbx
mov    $0x42,%esi
add    $0xd,%rbx
sub    $0x8,%rsp
mov    0x30(%rdi),%rax
shl    $0x4,%rbx
mov    0x78(%rax),%edx
mov    0x10(%rax,%rbx,1),%rdi
xor    %eax,%eax
not    %edx
and    $0x1a4,%edx
callq  16b8 <redirect_to_file+0x38>
cmp    $0xffffffff,%eax
mov    %eax,%r12d
je     16f8 <redirect_to_file+0x78>
mov    0x30(%rbp),%rax
mov    0x60(%rax),%rdi
test   %rdi,%rdi
je     16ea <redirect_to_file+0x6a>
callq  16d2 <redirect_to_file+0x52>
test   %rax,%rax
je     16ea <redirect_to_file+0x6a>
add    0x30(%rbp),%rbx
mov    0x14(%rax),%edx
mov    0x10(%rax),%esi
mov    0x10(%rbx),%rdi
callq  16ea <redirect_to_file+0x6a>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  16fd <redirect_to_file+0x7d>
mov    (%rax),%edi
callq  1704 <redirect_to_file+0x84>
add    0x30(%rbp),%rbx
mov    %rax,%r13
mov    $0x0,%edi
mov    0x10(%rbx),%rbx
callq  1719 <redirect_to_file+0x99>
mov    %r13,%rcx
mov    %rax,%rsi
mov    $0x3,%edi
mov    %rbx,%rdx
xor    %eax,%eax
callq  172e <redirect_to_file+0xae>
jmp    16ea <redirect_to_file+0x6a>
<<<sep_in_sample>>>
redirect_to_file (struct prog *master, int stream)
{
  struct passwd *pw;
  int fd = open (master->v.p.comp->redir[stream].v.file, 02|0100,
   0644 & ~master->v.p.comp->umask);
  if (fd == -1)
    {
      logmsg (3, gettext("cannot open output file %s: %s"),
  master->v.p.comp->redir[stream].v.file,
  strerror ((*__errno_location ())));
      return -1;
    }
  if (master->v.p.comp->privs.user
      && (pw = getpwnam (master->v.p.comp->privs.user)) != ((void *)0))
    chown (master->v.p.comp->redir[stream].v.file, pw->pw_uid, pw->pw_gid);
  return fd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 2
10 5
11 4
12 5
13 4
14 4
15 5
16 4
17 4
18 6
19 4
20 6
21 13
22 13
23 13
24 13
25 14
26 14
27 14
28 15
29 15
30 15
31 15
32 15
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 10
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 8
50 8
51 8
52 8
53 8
54 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2a9 <func_from_key+0x9>
test   %rax,%rax
je     2c0 <func_from_key+0x20>
mov    0x18(%rax),%rax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    2b2 <func_from_key+0x12>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
func_from_key(int *kbinput)
{
    const sc *s = get_shortcut(kbinput);
    if (s)
 return s->scfunc;
    else
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 8
7 8
8 8
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 156 <newline_added+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
newline_added( void ) { return newline_added_; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  9c <scram_free_client_final+0xc>
mov    0x8(%rbx),%rdi
callq  a5 <scram_free_client_final+0x15>
mov    0x10(%rbx),%rdi
callq  ae <scram_free_client_final+0x1e>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
scram_free_client_final (struct scram_client_final *cl)
{
  free (cl->cbind);
  free (cl->nonce);
  free (cl->proof);
  memset (cl, 0, sizeof (*cl));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
movslq (%rdi),%rdx
mov    0x18(%rdi),%rax
subq   $0x1,0xa8(%rax,%rdx,8)
mov    %esi,(%rdi)
movslq %esi,%rsi
addq   $0x1,0xa8(%rax,%rsi,8)
retq   
nop
<<<sep_in_sample>>>
rec_mset_elem_set_type (rec_mset_elem_t elem,
                        rec_mset_type_t type)
{
  elem->mset->count[elem->type]--;
  elem->type = type;
  elem->mset->count[type]++;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
jmpq   5 <cmp_group_name+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cmp_group_name(const void *item, void *data)
{
    return strcmp((char*)item, (char*)data);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     96 <report+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  c7 <report+0x87>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
report (FILE *stream, const char *psz_format, ...)
{
  va_list args;
  __builtin_va_start(args,psz_format);
  vfprintf (stream, psz_format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 7
25 7
26 7
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     12c <stream_set_read+0x1c>
test   %rsi,%rsi
mov    $0x0,%eax
cmovne %rsi,%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
stream_set_read (struct net_stream *str, stream_read_t read)
{
  if (!str)
    return 22;
  str->read = read ? read : _def_read;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 5
7 5
8 6
9 7
10 7
<<<sep_out_sample>>>
mov    0x10(%rdx),%r8
cmp    $0x5,%r8
jbe    6230 <_jit_getarg_uc+0x20>
movslq %esi,%rdx
mov    $0xf,%ecx
mov    $0x67,%esi
jmpq   622c <_jit_getarg_uc+0x1c>
nopl   0x0(%rax)
mov    $0xd,%ecx
movslq %esi,%rdx
mov    $0x4e,%esi
sub    %r8,%rcx
jmpq   6245 <_jit_getarg_uc+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_getarg_uc(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_extr_uc,u,_RDI - v->u.w);
    else
 _jit_new_node_www(_jit,jit_code_ldxi_uc,u,_RBP,v->u.w);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 7
7 7
8 7
9 5
10 5
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     475 <osip_clrspace+0xa5>
movzbl (%rdi),%ebx
test   %bl,%bl
je     442 <osip_clrspace+0x72>
callq  3ee <osip_clrspace+0x1e>
mov    %rbp,%rsi
jmp    3ff <osip_clrspace+0x2f>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rsi
movzbl (%rsi),%ebx
cmp    $0x20,%bl
je     3f8 <osip_clrspace+0x28>
cmp    $0xd,%bl
je     3f8 <osip_clrspace+0x28>
sub    $0x9,%ebx
cmp    $0x1,%bl
jbe    3f8 <osip_clrspace+0x28>
lea    -0x1(%rbp,%rax,1),%rcx
mov    %rcx,%rax
nopl   0x0(%rax)
movzbl (%rax),%edx
cmp    $0x20,%dl
je     435 <osip_clrspace+0x65>
cmp    $0xd,%dl
je     435 <osip_clrspace+0x65>
sub    $0x9,%edx
cmp    $0x1,%dl
ja     44b <osip_clrspace+0x7b>
sub    $0x1,%rax
cmp    %rsi,%rax
jae    420 <osip_clrspace+0x50>
movb   $0x0,0x0(%rbp)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
lea    0x1(%rax),%rdx
cmp    %rdx,%rcx
jb     458 <osip_clrspace+0x88>
movb   $0x0,0x1(%rax)
cmp    %rbp,%rsi
je     442 <osip_clrspace+0x72>
sub    %rsi,%rax
mov    %rbp,%rdi
lea    0x2(%rax),%rdx
callq  46c <osip_clrspace+0x9c>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    444 <osip_clrspace+0x74>
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_clrspace (char *word)
{
  char *pbeg;
  char *pend;
  size_t len;
  if (word == ((void *)0))
    return -1;
  if (*word == '\0')
    return 0;
  len = strlen (word);
  pbeg = word;
  while ((' ' == *pbeg) || ('\r' == *pbeg) || ('\n' == *pbeg) || ('\t' == *pbeg))
    pbeg++;
  pend = word + len - 1;
  while ((' ' == *pend) || ('\r' == *pend) || ('\n' == *pend) || ('\t' == *pend)) {
    pend--;
    if (pend < pbeg) {
      *word = '\0';
      return 0;
    }
  }
  if (pend + 1 <= word + (len - 1))
    pend[1] = '\0';
  if (pbeg != word)
    memmove (word, pbeg, pend - pbeg + 2);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 8
8 8
9 8
10 10
11 12
12 12
13 12
14 13
15 13
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 14
24 14
25 14
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 16
35 17
36 17
37 18
38 19
39 27
40 27
41 27
42 27
43 22
44 22
45 22
46 23
47 24
48 24
49 25
50 25
51 25
52 25
53 27
54 26
55 27
56 27
57 27
58 7
59 7
60 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm0        # 80 <gsl_cdf_logistic_Qinv+0x10>
jnp    d0 <gsl_cdf_logistic_Qinv+0x60>
movsd  0x0(%rip),%xmm3        # 8a <gsl_cdf_logistic_Qinv+0x1a>
ucomisd %xmm3,%xmm2
jp     a0 <gsl_cdf_logistic_Qinv+0x30>
movsd  0x0(%rip),%xmm0        # 98 <gsl_cdf_logistic_Qinv+0x28>
jne    a0 <gsl_cdf_logistic_Qinv+0x30>
add    $0x18,%rsp
retq   
nop
movapd %xmm3,%xmm0
movsd  %xmm1,0x8(%rsp)
subsd  %xmm2,%xmm0
divsd  %xmm2,%xmm0
callq  b7 <gsl_cdf_logistic_Qinv+0x47>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
mulsd  %xmm1,%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm0        # d8 <gsl_cdf_logistic_Qinv+0x68>
jne    82 <gsl_cdf_logistic_Qinv+0x12>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_logistic_Qinv (const double Q, const double a)
{
  double x;
  if (Q == 0.0)
    {
      return (__builtin_inff());
    }
  else if (Q == 1.0)
    {
      return (-(__builtin_inff()));
    }
  x = a * log((1-Q)/Q);
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 8
6 8
7 8
8 10
9 8
10 14
11 14
12 14
13 12
14 12
15 12
16 12
17 12
18 12
19 14
20 12
21 14
22 14
23 6
24 4
25 14
26 14
<<<sep_out_sample>>>
test   %rsi,%rsi
je     43a <taru_get_recorded_header+0xa>
mov    0x10(%rdi),%eax
mov    %eax,(%rsi)
mov    0x8(%rdi),%rdi
jmpq   443 <taru_get_recorded_header+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_get_recorded_header(TARU * taru, int * len)
{
 if (len) *len = taru->header_lengthM;
 return strob_str(taru->headerM);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %esi,%esi
mov    %rsp,%rdi
callq  aee <dis_setTimeAbsolute+0xe>
cvtsi2sdq 0x8(%rsp),%xmm1
cvtsi2sdq (%rsp),%xmm0
divsd  0x0(%rip),%xmm1        # b03 <dis_setTimeAbsolute+0x23>
movl   $0x1,0x0(%rip)        # b0d <dis_setTimeAbsolute+0x2d>
xor    %eax,%eax
addsd  %xmm1,%xmm0
movsd  %xmm0,0x0(%rip)        # b1b <dis_setTimeAbsolute+0x3b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
dis_setTimeAbsolute(void)
{
 struct timeval tv;
 gettimeofday(&tv, ((void *)0));
 theTime = tv.tv_sec + tv.tv_usec / 1000000.0;
 absoluteTime = 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 6
9 8
10 5
11 5
12 8
13 8
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x28,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  468 <read_error_details+0x28>
mov    (%rax),%ebp
mov    0x0(%rip),%rax        # 471 <read_error_details+0x31>
test   %rax,%rax
je     478 <read_error_details+0x38>
callq  *%rax
mov    %rsp,%rsi
mov    %r13,%rdi
callq  483 <read_error_details+0x43>
mov    %r12,%rdi
mov    %rax,%r13
callq  48e <read_error_details+0x4e>
mov    %rbx,%rdx
mov    %rax,%r12
mov    $0x0,%esi
mov    $0x0,%edi
callq  4a3 <read_error_details+0x63>
xor    %edi,%edi
mov    %rax,%rdx
mov    %rbx,%r9
xor    %eax,%eax
mov    %r13,%r8
mov    %r12,%rcx
mov    %ebp,%esi
callq  4ba <read_error_details+0x7a>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
movl   $0x2,0x0(%rip)        # 4d2 <read_error_details+0x92>
jne    4df <read_error_details+0x9f>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  4e4 <read_error_details+0xa4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_error_details (char const *name, off_t offset, size_t size)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, ngettext ("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes", size), quotearg_colon (name), umaxtostr (offset, buf), (unsigned long) size); exit_status = 2; } while (0)
                         ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 7
38 7
39 5
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2f0 <gsl_multimin_fdfminimizer_free+0x40>
mov    (%rdi),%rax
mov    0x30(%rdi),%rdi
callq  *0x30(%rax)
mov    0x30(%rbx),%rdi
callq  2cc <gsl_multimin_fdfminimizer_free+0x1c>
mov    0x28(%rbx),%rdi
callq  2d5 <gsl_multimin_fdfminimizer_free+0x25>
mov    0x20(%rbx),%rdi
callq  2de <gsl_multimin_fdfminimizer_free+0x2e>
mov    0x18(%rbx),%rdi
callq  2e7 <gsl_multimin_fdfminimizer_free+0x37>
mov    %rbx,%rdi
pop    %rbx
jmpq   2f0 <gsl_multimin_fdfminimizer_free+0x40>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_free (gsl_multimin_fdfminimizer * s)
{
  if (!s) { return ; };
  (s->type->free) (s->state);
  free (s->state);
  gsl_vector_free (s->dx);
  gsl_vector_free (s->gradient);
  gsl_vector_free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 10
18 9
19 10
20 10
21 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  420 <find_directory>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_name (const char *dir)
{
  return find_directory (dir)->name;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  188c <gsl_sf_eta+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    18a0 <gsl_sf_eta+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x419,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  18b6 <gsl_sf_eta+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_eta(const double s)
{
  gsl_sf_result result; int status = gsl_sf_eta_e(s, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_eta_e(s, &result)", "zeta.c", 1049, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   68 <nettle_gcm_camellia128_update+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_camellia128_update (struct gcm_camellia128_ctx *ctx,
   size_t length, const uint8_t *data)
{
  nettle_gcm_update(&(ctx)->gcm, &(ctx)->key, (length), (data));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%rdi
mov    $0x10,%edx
sub    $0x8,%rsp
callq  1e <extend+0x1e>
mov    %rbp,(%rax)
movq   $0x0,0x8(%rax)
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extend (struct link *tp, void const *x, struct divvy *to)
{
  struct link *pair = alloc (to, "struct link", sizeof (struct link)); pair->entry = x; pair->next = ((void *)0); tp->next = pair; return pair;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 2
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
mov    %rsi,%rbx
je     5e8 <_gsasl_digest_md5_server_finish+0x38>
lea    0x68(%rsi),%rdi
callq  5c2 <_gsasl_digest_md5_server_finish+0x12>
lea    0x98(%rbx),%rdi
callq  5ce <_gsasl_digest_md5_server_finish+0x1e>
lea    0x110(%rbx),%rdi
callq  5da <_gsasl_digest_md5_server_finish+0x2a>
mov    %rbx,%rdi
pop    %rbx
jmpq   5e3 <_gsasl_digest_md5_server_finish+0x33>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_digest_md5_server_finish (Gsasl_session * sctx, void *mech_data)
{
  _Gsasl_digest_md5_server_state *state = mech_data;
  if (!state)
    return;
  digest_md5_free_challenge (&state->challenge);
  digest_md5_free_response (&state->response);
  digest_md5_free_finish (&state->finish);
  free (state);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 6
6 6
7 7
8 7
9 8
10 8
11 9
12 10
13 9
14 9
15 10
16 10
17 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x28(%rax),%rax
jmpq   *%rax
<<<sep_in_sample>>>
fd_ostream_free (fd_ostream_t first_arg)
{
  const struct fd_ostream_implementation *vtable =
    ((struct fd_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->free (first_arg);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
mov    $0x0,%edx
test   %rax,%rax
cmove  %rdx,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_location_str (rec_record_t record)
{
  char *res;
  if (record->location_str)
    {
      res = record->location_str;
    }
  else
    {
      res = "";
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 10
3 10
4 10
5 13
6 13
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    0x18(%rdi),%rdi
mov    %rbx,%rdx
callq  5f <gear1_reset+0x1f>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  6d <gear1_reset+0x2d>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  7b <gear1_reset+0x3b>
mov    0x0(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  89 <gear1_reset+0x49>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gear1_reset (void *vstate, size_t dim)
{
  gear1_state_t *state = (gear1_state_t *) vstate;
  memset((state->y_onestep),0,(dim)*sizeof(double));
  memset((state->y0_orig),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->k),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3a0 <socket_error+0x30>
mov    $0x0,%edi
callq  383 <socket_error+0x13>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
pop    %rbx
mov    $0x1,%edi
xor    %eax,%eax
jmpq   398 <socket_error+0x28>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  3aa <socket_error+0x3a>
mov    %rax,%rbx
callq  3b2 <socket_error+0x42>
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
pop    %rbx
xor    %eax,%eax
jmpq   3c4 <socket_error+0x54>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
socket_error (const char *msg)
{
  if (msg)
    anubis_error (1, 0, gettext("Could not write to socket: %s"), msg);
  else
    anubis_error (1, (*__errno_location ()), gettext("Could not write to socket"));
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 7
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 6
24 6
25 6
<<<sep_out_sample>>>
lea    (%rdi,%rdi,2),%rax
push   %rbp
lea    (%rdi,%rax,4),%rbp
push   %rbx
mov    %rdi,%rbx
shl    $0x3,%rbp
sub    $0x8,%rsp
mov    %rbp,%rdi
callq  ed <cue_TRACK_init+0x1d>
test   %rbx,%rbx
mov    %rax,%rdx
lea    0x0(%rbp,%rax,1),%rcx
je     150 <cue_TRACK_init+0x80>
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rdx)
movq   $0x0,0x8(%rdx)
add    $0x68,%rdx
movb   $0x0,-0x58(%rdx)
movq   $0x0,-0x48(%rdx)
movq   $0x0,-0x40(%rdx)
movq   $0x0,-0x38(%rdx)
movl   $0x0,-0x30(%rdx)
movq   $0x0,-0x20(%rdx)
movl   $0x0,-0x18(%rdx)
movl   $0x0,-0x14(%rdx)
cmp    %rcx,%rdx
jne    100 <cue_TRACK_init+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cue_TRACK_init (size_t entries)
{
  struct cue_TRACK *track;
  size_t entry;
  track = xmalloc (sizeof (*track) * entries);
  for (entry = 0; entry < entries; entry++)
    {
      track[entry].datatype = 0;
      track[entry].FLAGS = ((void *)0);
      track[entry].ISRC[0] = '\0';
      track[entry].PERFORMER = ((void *)0);
      track[entry].SONGWRITER = ((void *)0);
      track[entry].TITLE = ((void *)0);
      track[entry].PREGAP.initialized = 0;
      track[entry].INDEX = ((void *)0);
      track[entry].IndexEntries = 0;
      track[entry].POSTGAP.initialized = 0;
    }
  return track;
}
<<<sep_in_sample>>>
1 5
2 2
3 5
4 2
5 2
6 5
7 2
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 8
16 9
17 9
18 10
19 11
20 12
21 13
22 14
23 15
24 16
25 17
26 6
27 6
28 20
29 20
30 20
31 20
32 20
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 9a6 <yyset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_debug (int bdebug )
{
        yy_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <__rprintfilline+0x7>
test   %rax,%rax
je     3d <__rprintfilline+0x3d>
mov    0x0(%rip),%rcx        # 13 <__rprintfilline+0x13>
nopl   0x0(%rax,%rax,1)
add    $0x18,%rax
cmp    %rcx,0x10(%rax)
jle    18 <__rprintfilline+0x18>
add    -0x10(%rax),%rcx
mov    -0x18(%rax),%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 36 <__rprintfilline+0x36>
xor    %eax,%eax
jmpq   3d <__rprintfilline+0x3d>
mov    0x0(%rip),%rcx        # 44 <__rprintfilline+0x44>
mov    $0xc,%edx
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   58 <__rprintfilline+0x58>
<<<sep_in_sample>>>
__rprintfilline (void)
{
  __map *mapindeks = __curent_map;
  if (__curent_map)
    {
      while ((++mapindeks)->fromline <= __cline);
      mapindeks--;
      fprintf (stderr, "\n\"%s\", line %ld: "
        ,mapindeks->fil, __cline + mapindeks->line);
    }
  else
    fprintf (stderr, "\n\"\", line : ");
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 12
16 12
17 12
18 12
19 12
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r9
cmp    (%rdi),%r9
mov    0x8(%rdi),%rax
je     18e8 <gsl_matrix_div_elements+0x38>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  18d9 <gsl_matrix_div_elements+0x29>
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rcx
cmp    %rax,%rcx
jne    18c0 <gsl_matrix_div_elements+0x10>
test   %r9,%r9
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%rbp
je     1950 <gsl_matrix_div_elements+0xa0>
shl    $0x3,%r12
shl    $0x3,%rbp
xor    %ebx,%ebx
xor    %r11d,%r11d
xor    %r10d,%r10d
xchg   %ax,%ax
test   %rcx,%rcx
je     1941 <gsl_matrix_div_elements+0x91>
mov    %r11,%rdx
mov    %rbx,%r8
add    0x18(%rdi),%rdx
add    0x18(%rsi),%r8
xor    %eax,%eax
nopl   (%rax)
movsd  (%rdx,%rax,8),%xmm0
divsd  (%r8,%rax,8),%xmm0
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    1928 <gsl_matrix_div_elements+0x78>
add    $0x1,%r10
add    %r12,%r11
add    %rbp,%rbx
cmp    %r9,%r10
jne    1910 <gsl_matrix_div_elements+0x60>
xor    %eax,%eax
jmp    18de <gsl_matrix_div_elements+0x2e>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_div_elements (gsl_matrix * a, const gsl_matrix * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 4
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 23
15 23
16 23
17 23
18 23
19 5
20 5
21 5
22 14
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 16
40 18
41 18
42 18
43 16
44 16
45 16
46 14
47 14
48 14
49 14
50 14
51 21
52 21
53 21
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    %sil,0x9c(%rax)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
etar_set_typeflag(ETAR * etar, int tar_type)
{
 ((struct tar_header *)((etar)->tar_hdrM))->typeflag = tar_type;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   e35 <rpmFreeSignature+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmFreeSignature(Header h)
{
    headerFree(h);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    1790 <gsl_matrix_float_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,4),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  17b2 <gsl_matrix_float_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_row (gsl_matrix_float * m, const size_t i)
{
  _gsl_vector_float_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
cmp    $0x40,%esi
ja     48 <addr_field_by_mask+0x48>
mov    %esi,%esi
jmpq   *0x0(,%rsi,8)
xchg   %ax,%ax
mov    0x30(%rdi),%rax
retq   
nopl   (%rax)
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
mov    0x8(%rdi),%rax
retq   
nopl   (%rax)
mov    0x10(%rdi),%rax
retq   
nopl   (%rax)
mov    0x18(%rdi),%rax
retq   
nopl   (%rax)
mov    0x20(%rdi),%rax
retq   
nopl   (%rax)
mov    0x28(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addr_field_by_mask (mu_address_t addr, int mask)
{
  switch (mask)
    {
    case 0x0001:
      return addr->addr;
    case 0x0002:
      return addr->comments;
    case 0x0004:
      return addr->personal;
    case 0x0008:
      return addr->email;
    case 0x0010:
      return addr->local_part;
    case 0x0020:
      return addr->domain;
    case 0x0040:
      return addr->route;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 18
7 18
8 18
9 6
10 6
11 6
12 8
13 8
14 8
15 10
16 10
17 10
18 12
19 12
20 12
21 14
22 14
23 14
24 16
25 16
26 16
27 20
28 21
29 21
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 2b <getnewunit+0xb>
movslq (%rbx),%r12
cmp    $0x63,%r12d
jg     78 <getnewunit+0x58>
lea    0x0(%rip),%rsi        # 3b <getnewunit+0x1b>
mov    $0x648,%edi
callq  45 <getnewunit+0x25>
mov    0x0(%rip),%rbp        # 4c <getnewunit+0x2c>
mov    %rax,0x0(%rbp,%r12,8)
movslq (%rbx),%rax
mov    0x0(%rbp,%rax,8),%rdi
test   %rdi,%rdi
je     78 <getnewunit+0x58>
callq  63 <getnewunit+0x43>
movslq (%rbx),%rax
lea    0x1(%rax),%edx
mov    0x0(%rbp,%rax,8),%rax
mov    %edx,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
getnewunit()
{
  if (nextunit>=100)
    return 0;
  memtable[nextunit] = (struct unittype *)
    mymalloc(sizeof(struct unittype),"(getnewunit)");
  if (!memtable[nextunit])
    return 0;
  initializeunit(memtable[nextunit]);
  return memtable[nextunit++];
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 6
9 6
10 6
11 5
12 5
13 7
14 7
15 7
16 7
17 9
18 10
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 4
30 11
31 11
32 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
lea    0x1(%rsi),%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  15 <xmemdup0+0x15>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  23 <xmemdup0+0x23>
movb   $0x0,(%rax,%rbx,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xmemdup0 (void const *p, size_t s)
{
  char *result = ((char *) (sizeof (char) == 1 ? xmalloc (s + 1) : xnmalloc (s + 1, sizeof (char))));
  memcpy (result, p, s);
  result[s] = 0;
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 7
14 7
15 7
16 7
<<<sep_out_sample>>>
mov    (%rdi),%rsi
cmp    0x8(%rdi),%rsi
je     20a0 <gsl_matrix_float_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2096 <gsl_matrix_float_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %rsi,%rsi
je     210a <gsl_matrix_float_transpose+0x9a>
xor    %eax,%eax
lea    0x1(%rax),%r9
cmp    %rsi,%r9
je     210a <gsl_matrix_float_transpose+0x9a>
mov    0x10(%rdi),%rdx
mov    %rax,%r10
mov    0x18(%rdi),%rcx
imul   %rdx,%r10
lea    0x0(,%rdx,4),%r8
add    %r10,%rdx
add    %rdx,%rax
lea    (%rcx,%rax,4),%rdx
lea    (%rcx,%r10,4),%rcx
mov    %r9,%rax
nopl   0x0(%rax,%rax,1)
movss  (%rdx),%xmm1
movss  (%rcx,%rax,4),%xmm0
movss  %xmm1,(%rcx,%rax,4)
add    $0x1,%rax
movss  %xmm0,(%rdx)
add    %r8,%rdx
cmp    %rsi,%rax
jne    20e0 <gsl_matrix_float_transpose+0x70>
mov    %r9,%rax
lea    0x1(%rax),%r9
cmp    %rsi,%r9
jne    20b0 <gsl_matrix_float_transpose+0x40>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_float_transpose (gsl_matrix_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                float tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 20
31 19
32 20
33 12
34 21
35 21
36 12
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_name (const gsl_multifit_nlinear_workspace * w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%r9
mov    0x8(%rsi),%r10
je     142f <gsl_vector_char_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1425 <gsl_vector_char_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
xor    %ecx,%ecx
test   %r8,%r8
je     145b <gsl_vector_char_swap+0x6b>
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%esi
movzbl (%rax),%edi
add    $0x1,%rcx
mov    %dil,(%rdx)
mov    %sil,(%rax)
add    %r9,%rdx
add    %r10,%rax
cmp    %r8,%rcx
jne    1440 <gsl_vector_char_swap+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_char_swap (gsl_vector_char * v, gsl_vector_char * w)
{
  char * d1 = v->data ;
  char * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          char tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 13
18 13
19 13
20 13
21 17
22 18
23 13
24 18
25 19
26 19
27 19
28 13
29 13
30 22
31 23
32 23
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1721 <xdr_dis_event_report_pdu+0x11>
test   %eax,%eax
jne    1730 <xdr_dis_event_report_pdu+0x20>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0xc(%rbp),%rsi
mov    %rbx,%rdi
callq  173c <xdr_dis_event_report_pdu+0x2c>
test   %eax,%eax
je     1725 <xdr_dis_event_report_pdu+0x15>
lea    0x12(%rbp),%rsi
mov    %rbx,%rdi
callq  174c <xdr_dis_event_report_pdu+0x3c>
test   %eax,%eax
je     1725 <xdr_dis_event_report_pdu+0x15>
lea    0x18(%rbp),%rsi
mov    %rbx,%rdi
callq  175c <xdr_dis_event_report_pdu+0x4c>
test   %eax,%eax
je     1725 <xdr_dis_event_report_pdu+0x15>
lea    0x20(%rbp),%rsi
mov    %rbx,%rdi
callq  176c <xdr_dis_event_report_pdu+0x5c>
test   %eax,%eax
setne  %al
movzbl %al,%eax
jmp    1727 <xdr_dis_event_report_pdu+0x17>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_event_report_pdu(xdrs, objp)
	XDR *xdrs;
	dis_event_report_pdu *objp;
{
	if (!xdr_dis_pdu_header(xdrs, &objp->hdr)) {
		return (FALSE);
	}
	if (!xdr_dis_entity_id(xdrs, &objp->orig_id)) {
		return (FALSE);
	}
	if (!xdr_dis_entity_id(xdrs, &objp->recv_id)) {
		return (FALSE);
	}
	if (!xdr_dis_event_id(xdrs, &objp->event_type)) {
		return (FALSE);
	}
	if (!xdr_dis_datum_spec_record(xdrs, &objp->datum_info)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 21
11 21
12 21
13 21
14 21
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 14
26 14
27 14
28 14
29 14
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1600 <gsl_permute_vector_int+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15f5 <gsl_permute_vector_int+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1611 <gsl_permute_vector_int+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_int (const gsl_permutation * p, gsl_vector_int * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_int (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1f1 <scram_print_client_final+0x11>
test   %al,%al
je     230 <scram_print_client_final+0x50>
mov    0x8(%rbx),%rcx
mov    0x10(%rbx),%r8
xor    %eax,%eax
mov    (%rbx),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  20f <scram_print_client_final+0x2f>
test   %eax,%eax
jle    230 <scram_print_client_final+0x50>
xor    %eax,%eax
cmpq   $0x0,0x0(%rbp)
sete   %al
add    $0x8,%rsp
pop    %rbx
neg    %eax
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
scram_print_client_final (struct scram_client_final *cl, char **out)
{
  int n;
  if (!scram_valid_client_final (cl))
    return -1;
  n = asprintf (out, "c=%s,r=%s,p=%s", cl->cbind, cl->nonce, cl->proof);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 10
22 10
23 7
24 10
25 10
26 10
27 10
28 5
29 10
30 10
31 10
32 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0xc(%rsp),%rdi
callq  12 <printf_frexp+0x12>
mov    0xc(%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,0xc(%rsp)
jge    38 <printf_frexp+0x38>
lea    0x3fd(%rdx),%edi
callq  33 <printf_frexp+0x33>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
jmpq   a50 <quotearg_n_options>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
cmp    $0x2,%edi
je     10 <catchsig+0x10>
mov    %edi,0x0(%rip)        # b <catchsig+0xb>
retq   
nopl   0x0(%rax)
movzbl 0x0(%rip),%eax        # 17 <catchsig+0x17>
test   %al,%al
je     5 <catchsig+0x5>
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
catchsig (int s)
{
  if (! (s == 2 && ignore_SIGINT))
    signal_received = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     4f <__osip_nict_free+0x4f>
xor    %ecx,%ecx
mov    $0x0,%edi
xor    %eax,%eax
mov    $0x0,%r8d
mov    $0x5,%edx
mov    $0x93,%esi
callq  27 <__osip_nict_free+0x27>
mov    0x48(%rbx),%rdi
test   %rdi,%rdi
je     3e <__osip_nict_free+0x3e>
mov    0x0(%rip),%rax        # 37 <__osip_nict_free+0x37>
test   %rax,%rax
je     68 <__osip_nict_free+0x68>
callq  *%rax
mov    0x0(%rip),%rax        # 45 <__osip_nict_free+0x45>
mov    %rbx,%rdi
test   %rax,%rax
je     58 <__osip_nict_free+0x58>
callq  *%rax
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  5d <__osip_nict_free+0x5d>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  6d <__osip_nict_free+0x6d>
nopl   (%rax)
jmp    3e <__osip_nict_free+0x3e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_nict_free (osip_nict_t * nict)
{
  if (nict == ((void *)0))
    return 0;
  osip_trace ("nict.c", 147, TRACE_LEVEL5, ((void *)0), "free nict resource\n");
  { if (nict->destination!=((void *)0)) { if (osip_free_func) osip_free_func(nict->destination); else free(nict->destination);} };
  { if (nict!=((void *)0)) { if (osip_free_func) osip_free_func(nict); else free(nict);} };
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 9
28 7
29 9
30 9
31 9
32 9
33 6
34 6
35 6
36 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rdi
jmpq   979 <swpath_get_pfiles+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swpath_get_pfiles(SWPATH * swpath)
{
 return strob_str(swpath->pfiles_);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
mov    %rsi,%rbx
callq  1de <gl_locale_name_environ+0xe>
test   %rax,%rax
je     1e8 <gl_locale_name_environ+0x18>
cmpb   $0x0,(%rax)
jne    215 <gl_locale_name_environ+0x45>
mov    %rbx,%rdi
callq  1f0 <gl_locale_name_environ+0x20>
test   %rax,%rax
je     1fa <gl_locale_name_environ+0x2a>
cmpb   $0x0,(%rax)
jne    215 <gl_locale_name_environ+0x45>
mov    $0x0,%edi
callq  204 <gl_locale_name_environ+0x34>
mov    %rax,%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     215 <gl_locale_name_environ+0x45>
cmpb   $0x0,(%rdx)
cmovne %rdx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_locale_name_environ (int category, const char *categoryname)
{
  const char *retval;
  retval = getenv ("LC_ALL");
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != ((void *)0) && retval[0] != '\0')
    {
        return retval;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 15
19 11
20 11
21 15
22 15
23 16
24 16
25 16
<<<sep_out_sample>>>
mov    %rsi,%rcx
xor    %edx,%edx
xor    %esi,%esi
jmpq   210 <gen_page_generic_begin>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gen_page_index_begin(const char *title, const char *header_item)
{
 return gen_page_generic_begin(title, 0, 0, header_item);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x0,0x50(%rdi)
je     40 <__roboutbyte+0x40>
cmp    $0xff,%rbp
jbe    25 <__roboutbyte+0x25>
mov    $0x0,%edi
callq  25 <__roboutbyte+0x25>
mov    0x48(%rbx),%rsi
mov    %ebp,%edi
callq  30 <__roboutbyte+0x30>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  4a <__roboutbyte+0x4a>
jmp    12 <__roboutbyte+0x12>
<<<sep_in_sample>>>
__roboutbyte (__bs9FILE *p, long x)
{
  if (!((__bs1FILE *) p)->open)
    __rerror ("Outbyte: File closed");
  if ((x < 0) | (x >= 256))
    __rerror ("Outbyte: Illegal byte value");
  (void) putc ((int) x, ((__bs1FILE *) p)->file);
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 4
22 4
23 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
cmp    $0x2,%edi
mov    (%rsi),%rcx
je     2c8 <op_toupper+0x38>
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x4,%edi
mov    $0x1,%ebp
callq  2b9 <op_toupper+0x29>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rdi
callq  2d1 <op_toupper+0x41>
test   %eax,%eax
mov    %eax,%ebp
jne    2e9 <op_toupper+0x59>
mov    0x8(%rbx),%rdi
callq  2e0 <op_toupper+0x50>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
callq  2ee <op_toupper+0x5e>
xchg   %ax,%ax
<<<sep_in_sample>>>
op_toupper(int argc, char **argv)
{
    char *opname = *argv++;
    argc--;
    if (argc != 1) {
 dico_log(4, 0, "%s requires one arguments", opname);
 return 1;
    }
    if (utf8_toupper(argv[0]))
 abort();
    printf("%s\n", argv[0]);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 3
7 5
8 6
9 6
10 6
11 6
12 7
13 6
14 13
15 13
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 9
24 9
25 11
26 11
27 13
28 13
29 13
30 13
31 13
32 10
33 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 247 <invalidate_cached_dirfd+0x7>
test   %rax,%rax
je     288 <invalidate_cached_dirfd+0x48>
sub    $0xa8,%rsp
mov    %rsi,0x88(%rsp)
lea    0x50(%rsp),%rsi
mov    %edi,0x40(%rsp)
mov    %rax,%rdi
mov    %rsp,0x80(%rsp)
callq  274 <invalidate_cached_dirfd+0x34>
test   %rax,%rax
je     281 <invalidate_cached_dirfd+0x41>
mov    %rax,%rdi
callq  1b0 <remove_cached_dirfd>
add    $0xa8,%rsp
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
invalidate_cached_dirfd (int dirfd, const char *name)
{
  struct cached_dirfd dir, key, *entry;
  if (!cached_dirfds)
    return;
  dir.fd = dirfd;
  key.parent = &dir;
  key.name = (char *) name;
  entry = hash_lookup (cached_dirfds, &key);
  if (entry)
    remove_cached_dirfd (entry);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 8
6 9
7 6
8 9
9 7
10 9
11 10
12 10
13 11
14 11
15 12
16 12
17 12
<<<sep_out_sample>>>
movzwl 0x1c(%rdi),%ecx
mov    0x14(%rdi),%edx
mov    %rsi,%rax
cmpw   $0xfffe,0x18(%rdi)
mov    %edx,(%rsi)
lea    0x1(%rcx),%edx
mov    %dx,0x1c(%rdi)
mov    %dx,0x4(%rsi)
je     20 <DISxIssueEntityID+0x20>
repz retq 
xor    %edx,%edx
mov    %dx,0x18(%rdi)
retq   
<<<sep_in_sample>>>
DISxIssueEntityID(DISxApplicationInfo * info, dis_entity_id * e)
{
 e->sim_id = info->id;
 e->entity_id = ++info->last_entity;
 if (info->last_event == 0xfffe) {
  info->last_event = 0;
 }
 return e;
}
<<<sep_in_sample>>>
1 4
2 3
3 2
4 5
5 3
6 4
7 4
8 4
9 5
10 9
11 6
12 6
13 9
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rsp,%rsi
callq  1963 <mu_url_is_same_host+0x13>
test   %eax,%eax
mov    %eax,%ebx
setne  %bpl
cmp    $0x1028,%eax
je     1988 <mu_url_is_same_host+0x38>
test   %bpl,%bpl
je     1988 <mu_url_is_same_host+0x38>
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
lea    0x8(%rsp),%rsi
mov    %r12,%rdi
callq  1995 <mu_url_is_same_host+0x45>
cmp    $0x1028,%eax
jne    19c8 <mu_url_is_same_host+0x78>
cmp    %eax,%ebx
jne    19aa <mu_url_is_same_host+0x5a>
test   %bpl,%bpl
mov    $0x1,%eax
jne    1979 <mu_url_is_same_host+0x29>
mov    0x8(%rsp),%rsi
mov    (%rsp),%rdi
callq  19b8 <mu_url_is_same_host+0x68>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    1979 <mu_url_is_same_host+0x29>
nopw   0x0(%rax,%rax,1)
test   %eax,%eax
je     199c <mu_url_is_same_host+0x4c>
jmp    1977 <mu_url_is_same_host+0x27>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_url_is_same_host (mu_url_t url1, mu_url_t url2) { const char *s1, *s2; int status1, status2; status1 = mu_url_sget_host (url1, &s1); if (status1 && status1 != (0x1000 +40)) return 0; status2 = mu_url_sget_host (url2, &s2); if (status2 && status2 != (0x1000 +40)) return 0; if (status1 && status1 == status2) return 1; return mu_c_strcasecmp (s1, s2) == 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # bb <clearScreen+0xb>
mov    $0x4,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  cf <clearScreen+0x1f>
mov    0x0(%rip),%rcx        # d6 <clearScreen+0x26>
mov    $0x7,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  ea <clearScreen+0x3a>
mov    0x0(%rip),%rcx        # f1 <clearScreen+0x41>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   109 <clearScreen+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
clearScreen()
{
 fprintf(stdout, "\e[2J");
 fprintf(stdout, "\x1b[37;4m");
 fprintf(stdout, "\e[3J\e[1;1H");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 5
18 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
imul   %rsi,%rdi
jmpq   c9 <grecs_calloc+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
grecs_calloc(size_t nmemb, size_t size)
{
 return grecs_zalloc(nmemb * size);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  ddc <gsl_sf_laguerre_2+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    df0 <gsl_sf_laguerre_2+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x144,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e06 <gsl_sf_laguerre_2+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_laguerre_2(double a, double x)
{
  gsl_sf_result result; int status = gsl_sf_laguerre_2_e(a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_laguerre_2_e(a, x, &result)", "laguerre.c", 324, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
lea    0x10(%rsp),%rax
mov    %rax,(%rsp)
callq  1742 <gsl_sf_coupling_6j+0x12>
test   %eax,%eax
movsd  0x10(%rsp),%xmm0
jne    1758 <gsl_sf_coupling_6j+0x28>
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
mov    %eax,%ecx
mov    $0x1b0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  176e <gsl_sf_coupling_6j+0x3e>
movsd  0x10(%rsp),%xmm0
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_sf_coupling_6j(int two_ja, int two_jb, int two_jc,
                          int two_jd, int two_je, int two_jf)
{
  gsl_sf_result result; int status = gsl_sf_coupling_6j_e(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_coupling_6j_e(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, &result)",
 "coupling.c"
  ,
 432
  , status) ; return result.val ; } while (0); } ; return result.val;
                                            ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 8
7 4
8 10
9 10
10 10
11 4
12 4
13 4
14 4
15 4
16 8
17 10
18 10
19 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 60b <debug_init+0xb>
callq  0 <debug_set_file>
mov    $0x0,%r8d
mov    $0x0,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   62d <debug_init+0x2d>
nopl   (%rax)
<<<sep_in_sample>>>
debug_init (void)
{
  debug_set_file (stderr);
  _obstack_begin ((&trace), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
<<<sep_out_sample>>>
sub    $0x118,%rsp
mov    %rdi,%r8
mov    %fs:0x28,%rax
mov    %rax,0x108(%rsp)
xor    %eax,%eax
test   %rdi,%rdi
mov    $0xffffffffffffffff,%rax
je     728 <dstrspn+0xb8>
cmpq   $0x0,0x10(%rdi)
je     758 <dstrspn+0xe8>
test   %rsi,%rsi
mov    $0xffffffffffffffff,%rax
je     728 <dstrspn+0xb8>
cmpq   $0x0,0x10(%rsi)
je     748 <dstrspn+0xd8>
xor    %eax,%eax
mov    $0x20,%ecx
mov    %rsp,%rdi
rep stos %rax,%es:(%rdi)
mov    (%rsi),%rcx
test   %rcx,%rcx
je     6f0 <dstrspn+0x80>
mov    0x10(%rsi),%rax
add    %rax,%rcx
nopl   0x0(%rax,%rax,1)
movzbl (%rax),%edx
add    $0x1,%rax
cmp    %rcx,%rax
movb   $0xff,(%rsp,%rdx,1)
jne    6e0 <dstrspn+0x70>
mov    (%r8),%rcx
xor    %eax,%eax
test   %rcx,%rcx
je     728 <dstrspn+0xb8>
mov    0x10(%r8),%rsi
movzbl (%rsi),%eax
cmpb   $0x0,(%rsp,%rax,1)
mov    $0x0,%eax
jne    71a <dstrspn+0xaa>
jmp    728 <dstrspn+0xb8>
xchg   %ax,%ax
movzbl (%rsi,%rax,1),%edx
cmpb   $0x0,(%rsp,%rdx,1)
je     728 <dstrspn+0xb8>
add    $0x1,%rax
cmp    %rcx,%rax
jne    710 <dstrspn+0xa0>
nopl   0x0(%rax,%rax,1)
mov    0x108(%rsp),%rdi
xor    %fs:0x28,%rdi
jne    765 <dstrspn+0xf5>
add    $0x118,%rsp
retq   
nopl   0x0(%rax,%rax,1)
cmpq   $0x0,(%rsi)
jne    728 <dstrspn+0xb8>
jmpq   6bf <dstrspn+0x4f>
nopl   0x0(%rax,%rax,1)
cmpq   $0x0,(%rdi)
jne    728 <dstrspn+0xb8>
xchg   %ax,%ax
jmpq   6a8 <dstrspn+0x38>
callq  76a <dstrspn+0xfa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dstrspn (string, charset)
     DStr_string_descriptor *string;
     DStr_string_descriptor *charset;
{
  char charlist[256];
  size_t i;
  if ((string) == ((void *)0) || ((string)->string == ((void *)0) && (string)->length != 0))
    return -1;
  if ((charset) == ((void *)0) || ((charset)->string == ((void *)0) && (charset)->length != 0))
    return -1;
  bzero (charlist, 256);
  for (i = 0; i < charset->length; i++)
    charlist[charset->string[i]] = -1;
  for (i = 0; i < string->length; i++)
    if (charlist[string->string[i]] == 0)
      return i;
  return string->length;
  }
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 8
8 7
9 7
10 7
11 9
12 8
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 13
28 12
29 13
30 12
31 14
32 14
33 14
34 14
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 14
46 14
47 14
48 14
49 18
50 18
51 18
52 18
53 18
54 18
55 9
56 9
57 9
58 9
59 7
60 7
61 7
62 7
63 18
64 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  149 <xalloc+0x9>
test   %rax,%rax
je     153 <xalloc+0x13>
add    $0x8,%rsp
retq   
mov    0x0(%rip),%rcx        # 15a <xalloc+0x1a>
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  16e <xalloc+0x2e>
callq  173 <xalloc+0x33>
<<<sep_in_sample>>>
xalloc(size_t size)
{
  void *p = malloc(size);
  if (!p)
    {
      fprintf(stderr, "Virtual memory exhausted.\n");
      abort();
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 10
6 10
7 6
8 6
9 6
10 6
11 6
12 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 797 <gpath_search+0x7>
xor    %eax,%eax
test   %rdx,%rdx
je     810 <gpath_search+0x80>
cmp    %esi,0x28(%rdx)
jb     7f2 <gpath_search+0x62>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x20(%rdx),%rbp
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     7e8 <gpath_search+0x58>
mov    %rdi,%r13
mov    %esi,%r12d
mov    %r12,%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  7ce <gpath_search+0x3e>
test   %eax,%eax
jne    7d9 <gpath_search+0x49>
cmpb   $0x0,(%rbx,%r12,1)
je     7f8 <gpath_search+0x68>
add    $0x8,%rbp
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
jne    7c0 <gpath_search+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmp    7f2 <gpath_search+0x62>
nopl   0x0(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_search (const char *file, unsigned int len)
{
  if (gpaths && (len <= gpaths->maxlen))
    {
      const char **gp;
      for (gp = gpaths->searchpath; *gp != ((void *)0); ++gp)
        if ((strncmp ((*gp), (file), (len)) == 0) && (*gp)[len] == '\0')
          return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 10
3 3
4 3
5 3
6 3
7 2
8 2
9 2
10 2
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 6
27 6
28 6
29 6
30 10
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 8
40 11
41 11
42 11
43 11
44 11
45 11
46 11
47 11
<<<sep_out_sample>>>
mov    0x10(%rdx),%rax
cmp    $0x5,%rax
jbe    63b0 <_jit_putargr+0x20>
movslq %esi,%r8
mov    $0xf,%ecx
mov    %rax,%rdx
mov    $0x81,%esi
jmpq   63af <_jit_putargr+0x1f>
nop
mov    $0xd,%edx
movslq %esi,%rcx
mov    $0x4b,%esi
sub    %rax,%rdx
jmpq   63c5 <_jit_putargr+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_putargr(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_movr,_RDI - v->u.w,u);
    else
 _jit_new_node_www(_jit,jit_code_stxi_l,v->u.w,_RBP,u);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 7
7 7
8 7
9 7
10 5
11 5
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
test   $0x2,%dil
je     70 <wsnode_flagstr+0x70>
movb   $0x77,0x0(%rip)        # d <wsnode_flagstr+0xd>
mov    %edi,%eax
movb   $0x0,0x0(%rip)        # 16 <wsnode_flagstr+0x16>
and    $0x4,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbc,%eax
add    $0x71,%eax
mov    %al,0x0(%rip)        # 2a <wsnode_flagstr+0x2a>
mov    %edi,%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffe8,%eax
add    $0x45,%eax
mov    %al,0x0(%rip)        # 40 <wsnode_flagstr+0x40>
mov    %edi,%eax
and    $0x10,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0x20,%edi
and    $0xffffffc3,%eax
add    $0x6a,%eax
cmp    $0x1,%edi
mov    %al,0x0(%rip)        # 5c <wsnode_flagstr+0x5c>
sbb    %eax,%eax
and    $0xffffffba,%eax
add    $0x73,%eax
mov    %al,0x0(%rip)        # 6a <wsnode_flagstr+0x6a>
mov    $0x0,%eax
retq   
mov    %edi,%eax
and    $0x1,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbf,%eax
add    $0x6e,%eax
mov    %al,0x0(%rip)        # 86 <wsnode_flagstr+0x86>
jmp    d <wsnode_flagstr+0xd>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_flagstr (int flags)
{
  static char retbuf[6];
  char *p = retbuf;
  if (flags & 0x02)
    *p++ = 'w';
  else if (flags & 0x01)
    *p++ = 'n';
  else
    *p++ = '-';
  if (flags & 0x04)
    *p++ = 'q';
  else
    *p++ = '-';
  if (flags & 0x08)
    *p++ = 'E';
  else
    *p++ = '-';
  if (flags & 0x10)
    *p++ = 'j';
  else
    *p++ = '-';
  if (flags & 0x20)
    *p++ = 's';
  else
    *p++ = '-';
  *p = 0;
  return retbuf;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 11
5 27
6 11
7 12
8 12
9 12
10 12
11 12
12 15
13 15
14 16
15 16
16 16
17 16
18 16
19 19
20 19
21 20
22 20
23 23
24 20
25 20
26 24
27 20
28 24
29 24
30 24
31 24
32 29
33 29
34 7
35 7
36 8
37 8
38 8
39 8
40 8
41 8
42 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1b99 <gsl_complex_arccsc+0x9>
callq  1b9e <gsl_complex_arccsc+0xe>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_arccsc (gsl_complex a)
{
  gsl_complex z = gsl_complex_inverse (a);
  return gsl_complex_arcsin (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
callq  e <fopen_safer+0xe>
test   %rax,%rax
mov    %rax,%rbx
je     26 <fopen_safer+0x26>
mov    %rax,%rdi
mov    %rbx,%rbp
callq  21 <fopen_safer+0x21>
cmp    $0x2,%eax
jbe    30 <fopen_safer+0x30>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %eax,%edi
callq  37 <fopen_safer+0x37>
test   %eax,%eax
mov    %eax,%ebx
js     63 <fopen_safer+0x63>
mov    %rbp,%rdi
callq  45 <fopen_safer+0x45>
test   %eax,%eax
jne    80 <fopen_safer+0x80>
mov    %r12,%rsi
mov    %ebx,%edi
callq  53 <fopen_safer+0x53>
test   %rax,%rax
je     80 <fopen_safer+0x80>
mov    %rax,%rbp
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
callq  68 <fopen_safer+0x68>
mov    (%rax),%r12d
mov    %rax,%rbx
mov    %rbp,%rdi
callq  76 <fopen_safer+0x76>
xor    %ebp,%ebp
mov    %r12d,(%rbx)
jmp    26 <fopen_safer+0x26>
nopl   (%rax)
callq  85 <fopen_safer+0x85>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    %ebx,%edi
callq  92 <fopen_safer+0x92>
mov    %r12d,0x0(%rbp)
xor    %ebp,%ebp
jmp    26 <fopen_safer+0x26>
<<<sep_in_sample>>>
fopen_safer (char const *file, char const *mode)
{
  FILE *fp = fopen (file, mode);
  if (fp)
    {
      int fd = fileno (fp);
      if (0 <= fd && fd <= 2)
        {
          int f = dup_safer (fd);
          if (f < 0)
            {
              int e = (*__errno_location ());
              rpl_fclose (fp);
              (*__errno_location ()) = e;
              return ((void *)0);
            }
          if (rpl_fclose (fp) != 0
              || ! (fp = fdopen (f, mode)))
            {
              int e = (*__errno_location ());
              close (f);
              (*__errno_location ()) = e;
              return ((void *)0);
            }
        }
    }
  return fp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 28
16 28
17 28
18 28
19 28
20 28
21 9
22 9
23 10
24 9
25 10
26 17
27 17
28 17
29 17
30 18
31 18
32 18
33 18
34 18
35 18
36 28
37 28
38 28
39 28
40 28
41 12
42 12
43 12
44 13
45 13
46 15
47 14
48 15
49 15
50 20
51 20
52 20
53 21
54 21
55 22
56 23
57 23
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %esi,%ecx
je     2d8 <_get_track_msf_image+0x58>
cmp    $0xaa,%sil
movzbl 0x1d(%rdi),%r8d
je     2e8 <_get_track_msf_image+0x68>
movzbl %cl,%esi
add    $0x1,%r8d
xor    %eax,%eax
cmp    %r8d,%esi
jg     2e0 <_get_track_msf_image+0x60>
test   %cl,%cl
je     2e0 <_get_track_msf_image+0x60>
movzbl 0x1c(%rdi),%eax
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
lea    0x1620(%rdi,%rax,8),%rax
movzwl 0x1(%rax),%ecx
mov    %cx,(%rdx)
movzbl 0x3(%rax),%eax
mov    %al,0x2(%rdx)
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x1(%r8),%ecx
jmp    292 <_get_track_msf_image+0x12>
xchg   %ax,%ax
<<<sep_in_sample>>>
_get_track_msf_image(void *p_user_data, track_t i_track, msf_t *msf)
{
  const _img_private_t *p_env = p_user_data;
  if (((void *)0) == msf) return 0;
  if (i_track == CDIO_CDROM_LEADOUT_TRACK) i_track = p_env->gen.i_tracks+1;
  if (i_track <= p_env->gen.i_tracks+1 && i_track != 0) {
    *msf = p_env->tocent[i_track-p_env->gen.i_first_track].start_msf;
    return 1;
  } else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 5
5 5
6 5
7 6
8 6
9 4
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 4
28 4
29 11
30 11
31 5
32 5
33 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  419 <grecs_value_free+0x9>
mov    %rbx,%rdi
pop    %rbx
jmpq   422 <grecs_value_free+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_value_free(struct grecs_value *val)
{
 grecs_value_free_content(val);
 grecs_free(val);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  2d <modnewton1_free+0xd>
mov    0x28(%rbx),%rdi
callq  36 <modnewton1_free+0x16>
mov    0x20(%rbx),%rdi
callq  3f <modnewton1_free+0x1f>
mov    0x18(%rbx),%rdi
callq  48 <modnewton1_free+0x28>
mov    0x10(%rbx),%rdi
callq  51 <modnewton1_free+0x31>
mov    0x8(%rbx),%rdi
callq  5a <modnewton1_free+0x3a>
mov    (%rbx),%rdi
callq  62 <modnewton1_free+0x42>
mov    %rbx,%rdi
pop    %rbx
jmpq   6b <modnewton1_free+0x4b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
modnewton1_free (void *vstate)
{
  modnewton1_state_t *state = (modnewton1_state_t *) vstate;
  gsl_vector_free (state->rhs);
  free (state->fYk);
  free (state->Yk);
  gsl_vector_free (state->dScal);
  gsl_vector_free (state->dYk);
  gsl_permutation_free (state->p);
  gsl_matrix_free (state->IhAJ);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 12
19 11
20 11
<<<sep_out_sample>>>
mov    %esi,0x24(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shcmd_set_srcfd(SHCMD * shcmd, int fd)
{
 shcmd->srcfd_=fd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rcx),%rcx
mov    0x8(%rcx),%eax
test   %eax,%eax
je     100 <CDB___bam_pgout+0x20>
movzbl 0x19(%rdx),%eax
and    $0xf,%eax
cmp    $0x9,%al
je     108 <CDB___bam_pgout+0x28>
mov    (%rcx),%rcx
xor    %r8d,%r8d
jmpq   100 <CDB___bam_pgout+0x20>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rdi
jmpq   110 <CDB___bam_pgout+0x30>
<<<sep_in_sample>>>
CDB___bam_pgout(dbenv, pg, pp, cookie)
 DB_ENV *dbenv;
 db_pgno_t pg;
 void *pp;
 DBT *cookie;
{
 DB_PGINFO *pginfo;
 PAGE *h;
 pginfo = (DB_PGINFO *)cookie->data;
 if (!pginfo->needswap)
  return (0);
 h = pp;
 return (((((PAGE *)h)->type) & 0x0f) == 9 ? CDB___bam_mswap(pp) :
     CDB___db_byteswap(dbenv, pg, pp, pginfo->db_pagesize, 0));
}
<<<sep_in_sample>>>
1 9
2 10
3 10
4 10
5 13
6 13
7 13
8 13
9 13
10 13
11 13
12 15
13 15
14 15
15 13
16 13
<<<sep_out_sample>>>
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  79b <gsl_stats_short_pvariance+0x1b>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,0x8(%rsp)
callq  7af <gsl_stats_short_pvariance+0x2f>
mov    %rbp,%rax
sub    $0x1,%rax
js     800 <gsl_stats_short_pvariance+0x80>
cvtsi2sd %rax,%xmm1
movsd  0x8(%rsp),%xmm2
mov    %rbx,%rax
sub    $0x1,%rax
mulsd  %xmm1,%xmm2
js     848 <gsl_stats_short_pvariance+0xc8>
cvtsi2sd %rax,%xmm1
mulsd  %xmm1,%xmm0
lea    -0x2(%rbp,%rbx,1),%rax
test   %rax,%rax
addsd  %xmm2,%xmm0
js     820 <gsl_stats_short_pvariance+0xa0>
cvtsi2sd %rax,%xmm1
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmp    7bd <gsl_stats_short_pvariance+0x3d>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
add    $0x18,%rsp
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   7d5 <gsl_stats_short_pvariance+0x55>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_short_pvariance (const short data1[],
                               const size_t stride1, const size_t n1,
                               const short data2[],
                               const size_t stride2, const size_t n2)
{
  const double var1 = gsl_stats_short_variance (data1, stride1, n1);
  const double var2 = gsl_stats_short_variance (data2, stride2, n2);
  const double pooled_variance =
    (((n1 - 1) * var1) + ((n2 - 1) * var2)) / (n1 + n2 - 2);
  return pooled_variance;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 6
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 11
33 11
34 11
35 11
36 11
37 8
38 11
39 11
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 11
51 9
52 9
53 9
54 11
55 11
56 11
57 11
58 9
59 8
60 11
61 11
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0x8(%rdi),%rdx
mov    %rdi,%rbx
cmp    $0x1,%rdx
jbe    81 <gmp_snprintf_memory+0x31>
sub    $0x1,%rdx
mov    (%rdi),%rdi
cmp    %rdx,%rbp
cmovbe %rbp,%rdx
mov    %rdx,%r12
callq  7a <gmp_snprintf_memory+0x2a>
add    %r12,(%rbx)
sub    %r12,0x8(%rbx)
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gmp_snprintf_memory (struct gmp_snprintf_t *d, const char *str, size_t len)
{
  size_t n;
  do {} while (0);
  if (d->size > 1)
    {
      n = ((d->size-1) < (len) ? (d->size-1) : (len));
      memcpy (d->buf, str, n);
      d->buf += n;
      d->size -= n;
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 5
8 5
9 7
10 8
11 7
12 7
13 7
14 8
15 9
16 10
17 13
18 13
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    %rsi,%rdi
setne  %al
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_mu_list_ptr_comparator (const void *item, const void *value)
{
  return item != value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x28(%rsi),%rdx
mov    (%rsi),%rcx
mov    %rdi,%rax
mov    %rsi,0x8(%rdi)
add    $0x28,%rsi
movq   $0x0,0x10(%rdi)
mov    %rsi,0x20(%rdi)
movq   $0x0,0x28(%rdi)
mov    %rcx,(%rdi)
mov    %rdx,0x18(%rdi)
movq   $0x0,0x30(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_iterator (gl_list_t list)
{
  gl_list_iterator_t result;
  result.vtable = list->base.vtable;
  result.list = list;
  result.p = list->root.next;
  result.q = &list->root;
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 2
4 8
5 7
6 8
7 7
8 8
9 8
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%rsi
test   %rcx,%rcx
movsd  (%rsi),%xmm1
je     10e <gsl_histogram_min_bin+0x3e>
xor    %edx,%edx
xor    %eax,%eax
nopl   0x0(%rax)
add    $0x1,%rdx
cmp    %rcx,%rdx
je     10c <gsl_histogram_min_bin+0x3c>
movsd  (%rsi,%rdx,8),%xmm0
ucomisd %xmm0,%xmm1
jbe    e8 <gsl_histogram_min_bin+0x18>
mov    %rdx,%rax
add    $0x1,%rdx
cmp    %rcx,%rdx
movapd %xmm0,%xmm1
jne    f1 <gsl_histogram_min_bin+0x21>
repz retq 
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_histogram_min_bin (const gsl_histogram * h)
{
  size_t i;
  size_t imin = 0;
  double min = h->bin[0];
  for (i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
          imin = i;
        }
    }
  return imin;
}
<<<sep_in_sample>>>
1 6
2 5
3 6
4 5
5 6
6 6
7 4
8 4
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 6
17 6
18 8
19 6
20 6
21 4
22 15
<<<sep_out_sample>>>
push   %rbp
lea    0x1(%rcx),%rsi
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%rdi
sub    $0x8,%rsp
callq  308 <xattr_acls_d_decoder+0x18>
mov    %rbp,0x50(%rbx)
mov    %rax,0x48(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattr_acls_d_decoder (struct tar_stat_info *st,
                      char const *keyword, char const *arg, size_t size)
{
  st->acls_d_ptr = xmemdup (arg, size + 1);
  st->acls_d_len = size;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 4
7 3
8 4
9 5
10 4
11 6
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 716 <malloc_set_register+0x6>
mov    %edi,0x0(%rip)        # 71c <malloc_set_register+0xc>
retq   
<<<sep_in_sample>>>
malloc_set_register(n)
     int n;
{
  int old;
  old = malloc_register;
  malloc_register = n;
  return old;
}
<<<sep_in_sample>>>
1 5
2 6
3 8
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rax
mov    0x8(%rdi),%r8
test   %rax,%rax
je     40 <__gmpz_cmpabs_ui+0x40>
mov    %rax,%rcx
sar    $0x3f,%rcx
xor    %rcx,%rax
mov    %rax,%rdx
mov    $0x1,%eax
sub    %rcx,%rdx
cmp    $0x1,%rdx
je     30 <__gmpz_cmpabs_ui+0x30>
repz retq 
nopw   0x0(%rax,%rax,1)
cmp    (%r8),%rsi
jb     28 <__gmpz_cmpabs_ui+0x28>
seta   %al
movzbl %al,%eax
neg    %eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
test   %rsi,%rsi
setne  %al
neg    %eax
retq   
<<<sep_in_sample>>>
__gmpz_cmpabs_ui (mpz_srcptr u, unsigned long int v_digit)
{
  mp_ptr up;
  mp_size_t un;
  mp_limb_t ul;
  up = ((u)->_mp_d);
  un = ((u)->_mp_size);
  if (un == 0)
    return -(v_digit != 0);
  un = ((un) >= 0 ? (un) : -(un));
  if (un == 1)
    {
      ul = up[0];
      if (ul > v_digit)
 return 1;
      if (ul < v_digit)
 return -1;
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 7
2 6
3 8
4 8
5 10
6 10
7 10
8 10
9 20
10 10
11 11
12 11
13 21
14 21
15 14
16 14
17 16
18 16
19 16
20 21
21 21
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %rsi,%r12
push   %rbp
push   %rbx
je     292 <gss_release_oid_set+0x12>
movl   $0x0,(%rdi)
test   %r12,%r12
je     2e4 <gss_release_oid_set+0x64>
mov    (%r12),%rax
test   %rax,%rax
je     2e4 <gss_release_oid_set+0x64>
cmpq   $0x0,(%rax)
mov    0x8(%rax),%rbx
je     2eb <gss_release_oid_set+0x6b>
xor    %ebp,%ebp
nopl   0x0(%rax)
mov    0x8(%rbx),%rdi
add    $0x1,%rbp
add    $0x10,%rbx
callq  2c1 <gss_release_oid_set+0x41>
mov    (%r12),%rax
cmp    %rbp,(%rax)
ja     2b0 <gss_release_oid_set+0x30>
mov    0x8(%rax),%rdi
callq  2d3 <gss_release_oid_set+0x53>
mov    (%r12),%rdi
callq  2dc <gss_release_oid_set+0x5c>
movq   $0x0,(%r12)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
mov    %rbx,%rdi
jmp    2ce <gss_release_oid_set+0x4e>
<<<sep_in_sample>>>
gss_release_oid_set (OM_uint32 * minor_status, gss_OID_set * set)
{
  gss_OID cur;
  size_t i;
  if (minor_status)
    *minor_status = 0;
  if (!set || *set == ((gss_OID_set) 0))
    return 0;
  for (i = 0, cur = (*set)->elements; i < (*set)->count; i++, cur++)
    free (cur->elements);
  free ((*set)->elements);
  free (*set);
  *set = ((gss_OID_set) 0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 6
8 7
9 7
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 10
19 9
20 9
21 10
22 9
23 9
24 9
25 9
26 11
27 12
28 12
29 13
30 15
31 15
32 15
33 15
34 15
35 9
36 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    $0x7fffffff,%rcx
jbe    a332 <_ldxi_l+0x32>
lea    0x7fffffff(%rcx),%rax
cmp    $0x7ffffffe,%rax
ja     a380 <_ldxi_l+0x80>
mov    %r13d,%r8d
mov    %r12d,%edx
mov    %rbx,%rdi
mov    $0x28,%ecx
mov    $0x1,%esi
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %r12d,%esi
mov    %r13d,%ecx
xor    %r9d,%r9d
mov    $0x28,%r8d
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x8b,(%rax)
add    $0x8,%rsp
pop    %rbx
mov    %ebp,%edx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   ad0 <_rx.isra.34>
xchg   %ax,%ax
mov    $0x20000000,%esi
callq  a38a <_ldxi_l+0x8a>
mov    %eax,%r14d
mov    %rbp,%rdx
mov    %rbx,%rdi
and    $0x7fff,%r14d
mov    %eax,%r15d
shl    $0x4,%r14
mov    0x0(%r14),%esi
and    $0x7fff,%esi
callq  2b60 <_movi>
mov    0x0(%r14),%ecx
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %r13d,%edx
and    $0x7fff,%ecx
callq  1420 <_ldxr_l>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %r15d,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   a3e7 <_ldxi_l+0xe7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_ldxi_l(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_word_t i0)
{
    jit_int32_t reg;
    if ((((i0) >= 0 && (long long)(i0) <= 0x7fffffffLL) || ((i0) < 0 && (long long)(i0) > -0x80000000LL))) {
 _rex(_jit, 0, 1, r0, _NOREG, r1);
 *_jit->pc.uc++ = 0x8b;
 _rx(_jit, r0, i0, r1, _NOREG, 0x00);
    }
    else {
 reg = _jit_get_reg(_jit,0x20000000);
 _movi(_jit, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), i0);
 _ldxr_l(_jit, r0, r1, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)));
 _jit_unget_reg(_jit,reg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 7
25 7
26 7
27 7
28 7
29 6
30 6
31 6
32 15
33 15
34 7
35 15
36 15
37 15
38 15
39 15
40 7
41 7
42 10
43 10
44 11
45 11
46 11
47 11
48 10
49 11
50 11
51 11
52 11
53 12
54 12
55 12
56 12
57 12
58 12
59 15
60 13
61 13
62 15
63 15
64 15
65 15
66 15
67 15
68 13
69 13
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1579 <gsl_vector_uchar_isneg+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm1,%xmm0
jae    157f <gsl_vector_uchar_isneg+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1560 <gsl_vector_uchar_isneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_isneg (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
21 13
<<<sep_out_sample>>>
mov    (%rdi),%r9
movq   %xmm0,-0x8(%rsp)
mov    0x18(%rdi),%rsi
mov    -0x8(%rsp),%rcx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r10
test   %r9,%r9
je     f98 <gsl_matrix_complex_float_set_all+0x58>
lea    0x0(,%r8,8),%r11
shl    $0x3,%r10
xor    %edi,%edi
nopl   (%rax)
test   %r8,%r8
je     f8c <gsl_matrix_complex_float_set_all+0x4c>
lea    (%rsi,%r11,1),%rdx
mov    %rsi,%rax
nopl   0x0(%rax)
mov    %rcx,(%rax)
add    $0x8,%rax
cmp    %rdx,%rax
jne    f80 <gsl_matrix_complex_float_set_all+0x40>
add    $0x1,%rdi
add    %r10,%rsi
cmp    %r9,%rdi
jne    f70 <gsl_matrix_complex_float_set_all+0x30>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_set_all (gsl_matrix_complex_float * m, gsl_complex_float x)
{
  size_t i, j;
  float * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex_float *) (data + 2 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 2
3 4
4 2
5 6
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 12
19 12
20 10
21 10
22 8
23 8
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
mov    %edi,%edi
jmpq   1757 <yyalloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
callq  496 <alias_expand_word+0x6>
test   %rax,%rax
je     4d0 <alias_expand_word+0x40>
mov    0x8(%rax),%rbx
mov    %rbx,%rdi
callq  4a7 <alias_expand_word+0x17>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x118,%edx
callq  4ba <alias_expand_word+0x2a>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   4c6 <alias_expand_word+0x36>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alias_expand_word (s)
     char *s;
{
  alias_t *r;
  r = find_alias (s);
  return (r ? (char *)strcpy (sh_xmalloc((1 + strlen (r->value)), "alias.c", 280), (r->value)) : (char *)((void *)0));
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 6
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdx,%rdx
je     1001 <swverid_set_tag+0x41>
mov    %rdi,%rbx
mov    $0x8,%ecx
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    1010 <swverid_set_tag+0x50>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     ff5 <swverid_set_tag+0x35>
callq  fed <swverid_set_tag+0x2d>
movq   $0x0,0x10(%rbx)
mov    %rbp,%rdi
callq  ffd <swverid_set_tag+0x3d>
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x20(%rbx),%rdi
xor    %esi,%esi
callq  101b <swverid_set_tag+0x5b>
test   %rax,%rax
je     1033 <swverid_set_tag+0x73>
mov    0x20(%rbx),%rdi
xor    %esi,%esi
callq  102b <swverid_set_tag+0x6b>
mov    %rax,%rdi
callq  1033 <swverid_set_tag+0x73>
mov    %rbp,%rdi
callq  103b <swverid_set_tag+0x7b>
mov    0x20(%rbx),%rdi
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
xor    %esi,%esi
jmpq   104f <swverid_set_tag+0x8f>
nop
<<<sep_in_sample>>>
swverid_set_tag(SWVERID * swverid, char * key, char *value)
{
 if (value == ((void *)0)) return;
 if (!strcmp(key, "catalog")) {
  if (swverid->catalogM) {
   free(swverid->catalogM);
   swverid->catalogM = ((void *)0);
  }
  swverid->catalogM=swlib_strdup(value);
 } else {
  if (cplob_val(swverid->taglistM,0)) {
   free(cplob_val(swverid->taglistM,0));
  }
  cplob_additem(swverid->taglistM, 0, swlib_strdup(value));
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 7
17 9
18 9
19 9
20 16
21 16
22 16
23 16
24 16
25 11
26 11
27 11
28 11
29 11
30 12
31 12
32 12
33 12
34 12
35 14
36 14
37 14
38 16
39 14
40 16
41 16
42 14
43 14
44 14
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 1f7 <linecmp+0x7>
mov    (%rdi),%r9
movsbl (%r9),%edx
lea    -0x1(%r9,%rax,1),%r8
mov    (%rsi),%rax
cmp    %r8,%r9
movsbl (%rax),%esi
jae    28b <linecmp+0x9b>
cmp    %sil,%dl
jne    28b <linecmp+0x9b>
mov    %r9,%rdx
jmp    233 <linecmp+0x43>
nopl   0x0(%rax,%rax,1)
movsbl 0x1(%rdx),%edx
movsbl 0x1(%rax),%esi
cmp    %sil,%dl
jne    270 <linecmp+0x80>
mov    %rdi,%rax
mov    %rcx,%rdx
lea    0x1(%rdx),%rcx
lea    0x1(%rax),%rdi
cmp    %r8,%rcx
jne    220 <linecmp+0x30>
movsbl 0x1(%rdx),%edx
movsbl 0x1(%rax),%esi
sub    %r9,%r8
lea    0x0(,%r8,4),%rcx
mov    0x0(%rip),%rax        # 25a <linecmp+0x6a>
mov    (%rax,%rcx,1),%eax
test   %eax,%eax
jne    285 <linecmp+0x95>
movsbl %sil,%eax
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 277 <linecmp+0x87>
sub    %r9,%rcx
shl    $0x2,%rcx
mov    (%rax,%rcx,1),%eax
test   %eax,%eax
je     261 <linecmp+0x71>
movsbl %dl,%eax
sub    %esi,%eax
retq   
xor    %ecx,%ecx
jmp    253 <linecmp+0x63>
nop
<<<sep_in_sample>>>
linecmp(char **s1, char **s2)
{
  char *t1, *t2;
  char *e1;
  for (e1 = *s1 + keylen - 1, t1 = *s1, t2 = *s2; t1 < e1 && *t1 == *t2; t1++, t2++)
    ;
  return (keymap[t1 - *s1] ? *t1 - *t2 : *t2 - *t1);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 7
29 7
30 7
31 7
32 7
33 7
34 8
35 8
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 5
46 5
47 5
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
jmpq   5 <strtoumax+0x5>
<<<sep_in_sample>>>
strtoumax (char const *ptr, char **endptr, int base)
{
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: (sizeof (uintmax_t) == sizeof (unsigned long int) || sizeof (uintmax_t) == sizeof (unsigned long long int)) ? 1 : -1; }))]
                                                      ;
  if (sizeof (uintmax_t) != sizeof (unsigned long int))
    return strtoull (ptr, endptr, base);
  return strtoul (ptr, endptr, base);
}
<<<sep_in_sample>>>
1 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%rdi        # 187b <reset_db_visibility+0xb>
callq  1880 <reset_db_visibility+0x10>
mov    %rax,%rdi
mov    %rax,0x8(%rsp)
callq  188d <reset_db_visibility+0x1d>
test   %rax,%rax
je     18ae <reset_db_visibility+0x3e>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdi
movl   $0x1,0x38(%rax)
callq  18a9 <reset_db_visibility+0x39>
test   %rax,%rax
jne    1898 <reset_db_visibility+0x28>
lea    0x8(%rsp),%rdi
callq  18b8 <reset_db_visibility+0x48>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
reset_db_visibility()
{
    dicod_database_t *db;
    dico_iterator_t itr;
    itr = xdico_list_iterator(database_list);
    for (db = dico_iterator_first(itr); db; db = dico_iterator_next(itr))
 db->visible = 1;
    dico_iterator_destroy(&itr);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 5
6 6
7 6
8 6
9 6
10 6
11 7
12 6
13 6
14 6
15 8
16 8
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdi
mov    0x8(%rsi),%rcx
mov    (%rsi),%rsi
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
lea    0x10(%rdi),%rdx
add    %rcx,%rcx
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_const_imag (const gsl_vector_complex_long_double * v)
{
  gsl_vector_long_double s = {0, 0, 0, 0, 0};
  s.data = v->data + 1;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_long_double_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 12
5 12
6 12
7 4
8 6
9 12
10 12
11 12
12 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 39b <get_locale_var+0xb>
test   %rax,%rax
je     3a5 <get_locale_var+0x15>
cmpb   $0x0,(%rax)
jne    3cc <get_locale_var+0x3c>
callq  3aa <get_locale_var+0x1a>
test   %rax,%rax
je     3b4 <get_locale_var+0x24>
cmpb   $0x0,(%rax)
jne    3cc <get_locale_var+0x3c>
mov    0x0(%rip),%rax        # 3bb <get_locale_var+0x2b>
test   %rax,%rax
je     3d8 <get_locale_var+0x48>
cmpb   $0x0,(%rax)
mov    $0x0,%edx
cmove  %rdx,%rax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_locale_var (var)
     char *var;
{
  char *locale;
  locale = lc_all;
  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
    locale = "";
  return (locale);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 7
8 8
9 8
10 8
11 8
12 9
13 10
14 10
15 11
16 11
17 11
18 13
19 13
20 13
21 11
22 13
23 13
24 13
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    %rdx,%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdx
mov    (%rdi),%rdi
jmpq   2b6 <gsl_spline_eval_deriv2_e+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline_eval_deriv2_e (const gsl_spline * spline,
                          double x,
                          gsl_interp_accel * a,
                          double * d2)
{
  return gsl_interp_eval_deriv2_e (spline->interp,
                                   spline->x, spline->y,
                                   x, a, d2);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1c43 <gsl_matrix_short_isnonneg+0x53>
xorpd  %xmm1,%xmm1
lea    (%rax,%rax,1),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     1c37 <gsl_matrix_short_isnonneg+0x47>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movswl (%rsi,%rax,2),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm0,%xmm1
ja     1c49 <gsl_matrix_short_isnonneg+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1c20 <gsl_matrix_short_isnonneg+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    1c0e <gsl_matrix_short_isnonneg+0x1e>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_short_isnonneg (const gsl_matrix_short * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  14 <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  22 <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
xmemdup (const void *p, size_t n)
{
  void *q = xmalloc (n);
  memcpy (q, p, n);
  return q;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbp
mov    $0x9,%edx
mov    %rsi,%rbp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 52 <yy_stack_print+0x22>
callq  57 <yy_stack_print+0x27>
cmp    %rbp,%rbx
ja     7f <yy_stack_print+0x4f>
nopl   0x0(%rax)
movswl (%rbx),%edx
mov    0x0(%rip),%rdi        # 6a <yy_stack_print+0x3a>
xor    %eax,%eax
mov    $0x0,%esi
add    $0x2,%rbx
callq  7a <yy_stack_print+0x4a>
cmp    %rbx,%rbp
jae    60 <yy_stack_print+0x30>
mov    0x0(%rip),%rsi        # 86 <yy_stack_print+0x56>
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   96 <yy_stack_print+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
{
  fprintf (stderr, "Stack now");
  for (; bottom <= top; ++bottom)
    fprintf (stderr, " %d", *bottom);
  fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 2
9 3
10 3
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 4
19 5
20 4
21 4
22 6
23 7
24 6
25 7
26 7
27 6
28 6
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 6d7 <_hs_append_history_line+0x17>
mov    (%rax,%rdi,8),%rbp
mov    0x0(%rbp),%r12
mov    %r12,%rdi
callq  6e7 <_hs_append_history_line+0x27>
mov    %r13,%rdi
mov    %rax,%rbx
callq  6f2 <_hs_append_history_line+0x32>
lea    0x2(%rbx,%rax,1),%rsi
mov    %r12,%rdi
callq  6ff <_hs_append_history_line+0x3f>
test   %rax,%rax
je     730 <_hs_append_history_line+0x70>
mov    %rax,0x0(%rbp)
movb   $0xa,(%rax,%rbx,1)
mov    %r13,%rsi
mov    0x0(%rbp),%rax
add    $0x8,%rsp
lea    0x1(%rax,%rbx,1),%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   727 <_hs_append_history_line+0x67>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_hs_append_history_line (which, line)
     int which;
     const char *line;
{
  HIST_ENTRY *hent;
  size_t newlen, curlen;
  char *newline;
  hent = the_history[which];
  curlen = strlen (hent->line);
  newlen = curlen + strlen (line) + 2;
  newline = realloc (hent->line, newlen);
  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 9
11 9
12 9
13 10
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 14
22 15
23 16
24 16
25 18
26 16
27 18
28 18
29 18
30 18
31 16
32 16
33 18
34 18
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  cb <_mapfile_close+0xb>
mov    0x8(%rax),%rdi
mov    %rax,%rbx
cmp    $0xffffffffffffffff,%rdi
je     130 <_mapfile_close+0x70>
test   %rdi,%rdi
je     ea <_mapfile_close+0x2a>
mov    0x10(%rax),%rsi
callq  e6 <_mapfile_close+0x26>
test   %eax,%eax
jne    120 <_mapfile_close+0x60>
xor    %ebp,%ebp
mov    (%rbx),%edi
callq  f3 <_mapfile_close+0x33>
test   %eax,%eax
jne    110 <_mapfile_close+0x50>
movq   $0xffffffffffffffff,0x8(%rbx)
movl   $0xffffffff,(%rbx)
add    $0x8,%rsp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
xchg   %ax,%ax
callq  115 <_mapfile_close+0x55>
mov    (%rax),%ebp
jmp    f7 <_mapfile_close+0x37>
nopl   0x0(%rax)
callq  125 <_mapfile_close+0x65>
mov    (%rax),%ebp
jmp    ec <_mapfile_close+0x2c>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %ebp,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_close (mu_stream_t stream)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  int err = 0;
  if (mfs->ptr != ((void *) -1))
    {
      if (mfs->ptr && munmap (mfs->ptr, mfs->size) != 0)
 err = (*__errno_location ());
      if (close (mfs->fd) != 0)
 err = (*__errno_location ());
      mfs->ptr = ((void *) -1);
      mfs->fd = -1;
    }
  return err;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 3
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 4
16 9
17 9
18 9
19 9
20 11
21 12
22 15
23 15
24 15
25 15
26 15
27 15
28 10
29 10
30 10
31 10
32 8
33 8
34 8
35 8
36 15
37 4
38 15
39 15
40 15
41 15
42 15
<<<sep_out_sample>>>
cvtsi2sd %rsi,%xmm1
cvtsi2sd %rdi,%xmm0
divsd  0x0(%rip),%xmm1        # 82 <timespectod+0x12>
addsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
timespectod (struct timespec a)
{
  return a.tv_sec + a.tv_nsec / 1e9;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
sub    0x8(%rsi),%rax
test   %rax,%rax
mov    %rax,0x8(%rdi)
js     230 <tvsub+0x20>
mov    (%rdi),%rax
sub    (%rsi),%rax
mov    %rax,(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rdi),%rcx
add    $0xf4240,%rax
mov    %rax,0x8(%rdi)
lea    -0x1(%rcx),%rdx
mov    %rdx,(%rdi)
mov    %rdx,%rax
sub    (%rsi),%rax
mov    %rax,(%rdi)
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
tvsub (struct timeval *out, struct timeval *in)
{
  if ((out->tv_usec -= in->tv_usec) < 0)
    {
      --out->tv_sec;
      out->tv_usec += 1000000;
    }
  out->tv_sec -= in->tv_sec;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 8
9 8
10 8
11 5
12 6
13 6
14 5
15 5
16 6
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
mov    %rdx,%rdi
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  9b <_asn1_str_cpy+0x1b>
cmp    %rbx,%rax
mov    %rax,%r12
jb     e0 <_asn1_str_cpy+0x60>
xor    %eax,%eax
test   %rbx,%rbx
jne    b8 <_asn1_str_cpy+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    -0x1(%rbx),%r12
mov    %rbp,%rsi
mov    %r13,%rdi
mov    %r12,%rdx
callq  ca <_asn1_str_cpy+0x4a>
movb   $0x0,-0x1(%r13,%rbx,1)
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
lea    0x1(%rax),%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  ef <_asn1_str_cpy+0x6f>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_asn1_str_cpy (char *dest, size_t dest_tot_size, const char *src)
{
  size_t str_size = strlen (src);
  if (dest_tot_size > str_size)
    {
      strcpy (dest, src);
      return str_size;
    }
  else
    {
      if (dest_tot_size > 0)
 {
   str_size = dest_tot_size - 1;
   memcpy (dest, src, str_size);
   dest[str_size] = 0;
   return str_size;
 }
      else
 return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 3
13 4
14 19
15 11
16 11
17 21
18 21
19 21
20 21
21 21
22 21
23 21
24 13
25 14
26 14
27 14
28 14
29 15
30 21
31 16
32 21
33 21
34 21
35 21
36 21
37 21
38 6
39 6
40 6
41 6
42 21
43 7
44 21
45 21
46 21
47 21
48 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  1f9 <cplob_close+0x9>
mov    (%rbx),%rdi
callq  201 <cplob_close+0x11>
mov    %rbx,%rdi
pop    %rbx
jmpq   20a <cplob_close+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cplob_close(CPLOB * lob)
{
        cplob_freeall (lob);
 free(lob->list);
 free(lob);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 20ab <config_help+0xb>
xor    %edx,%edx
mov    $0x0,%esi
callq  20b7 <config_help+0x17>
mov    0x0(%rip),%rdi        # 20be <config_help+0x1e>
xor    %ecx,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
add    $0x8,%rsp
jmpq   20d3 <config_help+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
config_help ()
{
  static char docstring[] =
    "Configuration file structure for pies.\n" "For more information, use `info pies configuration'."
                                                              ;
  grecs_format_docstring (stdout, docstring, 0);
  grecs_format_statement_array (stdout, pies_keywords, 1, 0);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 7
7 7
8 7
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
jmpq   13c3 <quotearg_custom_mem+0x13>
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
mov    %rsi,%rbx
je     5e8 <_gsasl_digest_md5_server_finish+0x38>
lea    0x68(%rsi),%rdi
callq  5c2 <_gsasl_digest_md5_server_finish+0x12>
lea    0x98(%rbx),%rdi
callq  5ce <_gsasl_digest_md5_server_finish+0x1e>
lea    0x110(%rbx),%rdi
callq  5da <_gsasl_digest_md5_server_finish+0x2a>
mov    %rbx,%rdi
pop    %rbx
jmpq   5e3 <_gsasl_digest_md5_server_finish+0x33>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_digest_md5_server_finish (Gsasl_session * sctx, void *mech_data)
{
  _Gsasl_digest_md5_server_state *state = mech_data;
  if (!state)
    return;
  digest_md5_free_challenge (&state->challenge);
  digest_md5_free_response (&state->response);
  digest_md5_free_finish (&state->finish);
  free (state);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 6
6 6
7 7
8 7
9 8
10 8
11 9
12 10
13 9
14 9
15 10
16 10
17 10
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ecx
xor    %edx,%edx
mov    %esi,%ebx
sub    $0x20,%rsp
test   %ecx,%ecx
mov    %esi,0xc(%rsp)
js     57 <mu_nntp_carrier_is_ready+0x57>
mov    %ecx,%eax
mov    $0x51eb851f,%edx
mov    %ecx,%esi
imul   %edx
sar    $0x1f,%esi
mov    %ecx,%eax
sar    $0x5,%edx
sub    %esi,%edx
movslq %edx,%rdx
mov    %rdx,0x10(%rsp)
mov    $0x10624dd3,%edx
imul   %edx
sar    $0x6,%edx
sub    %esi,%edx
imul   $0x3e8,%edx,%edx
sub    %edx,%ecx
lea    0x10(%rsp),%rdx
imul   $0x3e8,%ecx,%ecx
movslq %ecx,%rcx
mov    %rcx,0x18(%rsp)
lea    0xc(%rsp),%rsi
callq  61 <mu_nntp_carrier_is_ready+0x61>
xor    %edx,%edx
test   %eax,%eax
jne    6d <mu_nntp_carrier_is_ready+0x6d>
and    0xc(%rsp),%ebx
mov    %ebx,%edx
add    $0x20,%rsp
mov    %edx,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_nntp_carrier_is_ready (mu_stream_t carrier, int flag, int timeout)
{
  struct timeval tv, *tvp = ((void *)0);
  int wflags = flag;
  int status;
  if (timeout >= 0)
    {
      tv.tv_sec = timeout / 100;
      tv.tv_usec = (timeout % 1000) * 1000;
      tvp = &tv;
    }
  status = mu_stream_wait (carrier, &wflags, tvp);
  if (status)
    return 0;
  return wflags & flag;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 6
7 4
8 6
9 8
10 8
11 8
12 8
13 8
14 9
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 9
27 9
28 9
29 12
30 12
31 14
32 13
33 13
34 15
35 15
36 16
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
jmpq   15 <std_control_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
std_control_free (void *vstate)
{
  std_control_state_t *state = (std_control_state_t *) vstate;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <MCVarListToArray+0x6>
mov    0x0(%rip),%rdx        # d <MCVarListToArray+0xd>
movslq %eax,%rcx
add    $0x1,%eax
mov    %rdi,(%rdx,%rcx,8)
mov    %eax,0x0(%rip)        # 1d <MCVarListToArray+0x1d>
mov    $0x1,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
MCVarListToArray (PVOID pv_pMCVar, PVOID pv_Null)
{
  vrgpMCVar[viMCVar] = (MCVAR *) pv_pMCVar;
  viMCVar++;
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 3
6 4
7 6
8 6
9 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   65d <rmdir_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
rmdir_error (char const *name)
{
  call_arg_error ("rmdir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e <arg_missing+0xe>
mov    0x0(%rip),%rdi        # 15 <arg_missing+0x15>
mov    %rax,%rsi
mov    %rbx,%rdx
xor    %eax,%eax
callq  22 <arg_missing+0x22>
mov    $0x1,%edi
callq  2c <option_prefixes+0xc>
<<<sep_in_sample>>>
arg_missing(
    const char *option)
{
    fprintf (stderr, gettext("indent: missing argument to parameter %s\n"), option);
    exit (invocation_error);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
callq  30d <gsl_histogram2d_ysigma+0xd>
mov    0x8(%rbx),%rcx
mov    (%rbx),%rsi
xorpd  %xmm1,%xmm1
test   %rcx,%rcx
je     3cb <gsl_histogram2d_ysigma+0xcb>
fldz   
mov    0x18(%rbx),%rdi
shl    $0x3,%rcx
xorpd  %xmm3,%xmm3
xor    %r8d,%r8d
fld    %st(0)
movsd  0x0(%rip),%xmm6        # 33c <gsl_histogram2d_ysigma+0x3c>
movsd  (%rdi),%xmm5
test   %rsi,%rsi
movsd  0x8(%rdi,%r8,1),%xmm4
je     3b0 <gsl_histogram2d_ysigma+0xb0>
mov    %r8,%rdx
add    0x20(%rbx),%rdx
xor    %eax,%eax
movapd %xmm3,%xmm2
nopl   0x0(%rax)
movsd  (%rdx),%xmm1
ucomisd %xmm3,%xmm1
jbe    36e <gsl_histogram2d_ysigma+0x6e>
addsd  %xmm1,%xmm2
add    $0x1,%rax
add    %rcx,%rdx
cmp    %rsi,%rax
jne    360 <gsl_histogram2d_ysigma+0x60>
ucomisd %xmm3,%xmm2
jbe    3b0 <gsl_histogram2d_ysigma+0xb0>
addsd  %xmm4,%xmm5
movsd  %xmm2,(%rsp)
fldl   (%rsp)
movapd %xmm5,%xmm1
mulsd  %xmm6,%xmm1
fadd   %st,%st(1)
subsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm1
movsd  %xmm1,(%rsp)
fldl   (%rsp)
fsub   %st(3),%st
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x8,%r8
cmp    %rcx,%r8
je     3bf <gsl_histogram2d_ysigma+0xbf>
movapd %xmm4,%xmm5
jmp    340 <gsl_histogram2d_ysigma+0x40>
fstp   %st(0)
fstpl  0x8(%rsp)
movsd  0x8(%rsp),%xmm1
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     3db <gsl_histogram2d_ysigma+0xdb>
add    $0x10,%rsp
pop    %rbx
retq   
movapd %xmm1,%xmm0
callq  3e4 <gsl_histogram2d_ysigma+0xe4>
jmp    3d5 <gsl_histogram2d_ysigma+0xd5>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_ysigma (const gsl_histogram2d * h)
{
  const double ymean = gsl_histogram2d_ymean (h);
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  size_t i;
  size_t j;
  long double wvariance = 0;
  long double W = 0;
  for (j = 0; j < ny; j++)
    {
      double yj = (h->yrange[j + 1] + h->yrange[j]) / 2.0 - ymean;
      double wj = 0;
      for (i = 0; i < nx; i++)
        {
          double wij = h->bin[i * ny + j];
          if (wij > 0)
            wj += wij;
        }
      if (wj > 0)
        {
          W += wj;
          wvariance += ((yj * yj) - wvariance) * (wj / W);
        }
    }
  {
    double ysigma = sqrt (wvariance);
    return ysigma;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 4
7 10
8 10
9 10
10 9
11 9
12 9
13 13
14 10
15 9
16 12
17 12
18 14
19 12
20 14
21 14
22 14
23 14
24 13
25 13
26 16
27 17
28 17
29 18
30 14
31 14
32 14
33 14
34 20
35 20
36 12
37 22
38 22
39 12
40 12
41 22
42 12
43 23
44 23
45 23
46 23
47 23
48 23
49 23
50 23
51 23
52 10
53 10
54 10
55 10
56 10
57 10
58 10
59 27
60 27
61 27
62 30
63 30
64 30
65 27
66 27
67 27
68 27
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
callq  21 <print_file_info+0x21>
mov    %rax,0x8(%rsp)
movabs $0x64696c61766e69,%rax
movb   $0x0,0x1a(%rsp)
mov    %rax,0x10(%rsp)
xor    %eax,%eax
test   %rbp,%rbp
mov    %ax,0x18(%rsp)
je     e0 <print_file_info+0xe0>
mov    %rbx,%rdi
callq  52 <print_file_info+0x52>
lea    0x10(%rsp),%rsi
mov    %eax,%edi
callq  5e <print_file_info+0x5e>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  6d <print_file_info+0x6d>
mov    %rbx,%rdi
callq  75 <print_file_info+0x75>
mov    $0x0,%edi
movzwl %ax,%esi
xor    %eax,%eax
callq  84 <print_file_info+0x84>
mov    %rbx,%rdi
callq  8c <print_file_info+0x8c>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  9b <print_file_info+0x9b>
lea    0x8(%rsp),%rdi
callq  a5 <print_file_info+0xa5>
cmpb   $0x0,0x0(%rbp)
mov    $0x0,%esi
mov    %rax,%rdx
mov    $0x0,%edi
cmovne %rbp,%rsi
xor    %eax,%eax
callq  c1 <print_file_info+0xc1>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    f0 <print_file_info+0xf0>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  e8 <print_file_info+0xe8>
mov    %rax,%rbp
jmpq   4a <print_file_info+0x4a>
callq  f5 <print_file_info+0xf5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_file_info(const udf_dirent_t *p_udf_dirent, const char* psz_dirname)
{
  time_t mod_time = udf_get_modification_time(p_udf_dirent);
  char psz_mode[11]="invalid";
  const char *psz_fname= psz_dirname
    ? psz_dirname : udf_get_filename(p_udf_dirent);
  printf("%s ", udf_mode_string(udf_get_posix_filemode(p_udf_dirent),
    psz_mode));
  printf("%4d ", udf_get_link_count(p_udf_dirent));
  printf("%lu ", (long unsigned int) udf_get_file_length(p_udf_dirent));
  printf("%s %s", *psz_fname ? psz_fname : "/", ctime(&mod_time));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 6
16 4
17 6
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 9
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 11
42 11
43 11
44 11
45 11
46 11
47 11
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 12
56 6
57 6
58 6
59 6
60 12
61 12
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
test   %eax,%eax
mov    0x8(%rdi),%rax
jne    60 <next+0x20>
mov    0x8(%rax),%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x10(%rax),%rax
mov    %rax,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next (void *owner)
{
  struct list_iterator *itr = owner;
  if (itr->backwards)
    itr->cur = itr->cur->prev;
  else
    itr->cur = itr->cur->next;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 7
6 7
7 9
8 9
9 9
10 5
11 5
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     b0d <trace+0x5d>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # b17 <trace+0x67>
test   %rdi,%rdi
je     bc0 <trace+0x110>
callq  b25 <trace+0x75>
mov    $0x1,%edx
mov    %eax,%edi
mov    $0x2,%esi
xor    %eax,%eax
callq  b38 <trace+0x88>
mov    0x0(%rip),%rbp        # b3f <trace+0x8f>
callq  b44 <trace+0x94>
mov    %rbp,%rdi
movslq %eax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  b56 <trace+0xa6>
lea    0xf0(%rsp),%rax
mov    0x0(%rip),%rdi        # b65 <trace+0xb5>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  b91 <trace+0xe1>
mov    0x0(%rip),%rsi        # b98 <trace+0xe8>
mov    $0xa,%edi
callq  ba2 <trace+0xf2>
mov    0x0(%rip),%rdi        # ba9 <trace+0xf9>
callq  bae <trace+0xfe>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  bcf <trace+0x11f>
test   %rax,%rax
mov    %rax,0x0(%rip)        # bd9 <trace+0x129>
jne    bee <trace+0x13e>
mov    0x0(%rip),%rbp        # be2 <trace+0x132>
mov    %rbp,0x0(%rip)        # be9 <trace+0x139>
jmpq   b3f <trace+0x8f>
mov    %rax,%rdi
jmpq   b20 <trace+0x70>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trace (const char *format, ...)
{
  va_list args;
  static FILE *tracefp = (FILE *)((void *)0);
  if (tracefp == ((void *)0))
    tracefp = fopen("/tmp/bash-trace.log", "a+");
  if (tracefp == ((void *)0))
    tracefp = stderr;
  else
    fcntl (fileno (tracefp), 2, 1);
  fprintf(tracefp, "TRACE: pid %ld: ", (long)getpid());
  __builtin_va_start(args,format);
  vfprintf (tracefp, format, args);
  fprintf (tracefp, "\n");
  __builtin_va_end(args);
  fflush(tracefp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 5
21 5
22 5
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 11
36 12
37 13
38 13
39 13
40 12
41 12
42 12
43 12
44 12
45 13
46 14
47 14
48 14
49 16
50 16
51 17
52 17
53 17
54 17
55 17
56 6
57 6
58 6
59 7
60 6
61 7
62 8
63 8
64 8
65 8
66 8
67 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 4cb <io_setup+0xb>
movq   $0x0,0x0(%rip)        # 4d6 <io_setup+0x16>
movq   $0x0,0x0(%rip)        # 4e1 <io_setup+0x21>
movq   $0x0,0x0(%rip)        # 4ec <io_setup+0x2c>
movq   $0x0,0x0(%rip)        # 4f7 <io_setup+0x37>
movq   $0x0,0x0(%rip)        # 502 <io_setup+0x42>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
io_setup (void)
{
  pfrontp = pbackp = ptyobuf;
  nfrontp = nbackp = netobuf;
  netip = netibuf;
  ptyip = ptyibuf;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
test   %edx,%edx
jle    1dd <strbuf_nputc+0x4d>
push   %rbp
movslq %edx,%rcx
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x18(%rdi),%rax
add    %rax,%rcx
cmp    %rcx,0x10(%rdi)
jb     1e0 <strbuf_nputc+0x50>
sub    $0x1,%edx
mov    %ebp,%esi
jmp    1c4 <strbuf_nputc+0x34>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rcx
sub    $0x1,%edx
cmp    $0xffffffff,%edx
mov    %rcx,0x18(%rbx)
mov    %sil,(%rax)
jne    1c0 <strbuf_nputc+0x30>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
repz retq 
nop
mov    %edx,%esi
mov    %edx,0xc(%rsp)
callq  1eb <strbuf_nputc+0x5b>
mov    0x18(%rbx),%rax
mov    0xc(%rsp),%edx
jmp    1af <strbuf_nputc+0x1f>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strbuf_nputc(STRBUF *sb, int c, int len)
{
 if (len > 0) {
  if (sb->curp + len > sb->endp)
   __strbuf_expandbuf(sb, len);
  while (len-- > 0)
   *sb->curp++ = c;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 7
19 6
20 6
21 7
22 7
23 6
24 9
25 9
26 9
27 9
28 9
29 5
30 5
31 5
32 5
33 5
34 5
35 5
<<<sep_out_sample>>>
test   %rsi,%rsi
je     50 <cdio_open_am_osx+0x20>
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%edi
callq  45 <cdio_open_am_osx+0x15>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_open_am_osx (const char *psz_source_name, const char *psz_access_mode)
{
  if (psz_access_mode != ((void *)0))
    cdio_warn ("there is only one access mode for OS X. Arg %s ignored",
               psz_access_mode);
  return cdio_open_osx(psz_source_name);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1249 <xdr_dis_request_id+0x9>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_request_id(xdrs, objp)
	XDR *xdrs;
	dis_request_id *objp;
{
	if (!xdr_byte_u_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 9
6 5
7 9
8 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %rdi,%rdi
cmove  %rax,%rdi
test   %rsi,%rsi
movl   $0x8,(%rdi)
je     f3d <set_custom_quoting+0x2d>
test   %rdx,%rdx
je     f3d <set_custom_quoting+0x2d>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
callq  f42 <set_custom_quoting+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 6
7 7
8 7
9 7
10 9
11 10
12 11
13 11
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 78f <handle_signal+0xf>
callq  794 <handle_signal+0x14>
mov    0x0(%rip),%rbx        # 79b <handle_signal+0x1b>
mov    $0x0,%edi
callq  7a5 <handle_signal+0x25>
mov    0x0(%rip),%rdi        # 7ac <handle_signal+0x2c>
mov    %rax,%rsi
mov    %ebp,%ecx
mov    %rbx,%rdx
xor    %eax,%eax
callq  7bb <handle_signal+0x3b>
mov    $0x3,%edi
callq  7c5 <handle_signal+0x45>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
handle_signal (the_signal)
     int the_signal;
{
  rpl_fflush (stdout);
  fprintf (stderr, gettext("\n%s: program aborted by signal %d\n"), prgr_name,
    the_signal);
  my_exit (3);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
lea    0x28(%rdi),%rsi
mov    %r8,(%rsp)
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 29 <nettle_ccm_aes192_set_nonce+0x19>
mov    %r9,0x8(%rsp)
mov    %rcx,%r9
mov    %rax,%rcx
callq  39 <nettle_ccm_aes192_set_nonce+0x29>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
nettle_ccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx, size_t length, const uint8_t *nonce,
       size_t authlen, size_t msglen, size_t taglen)
{
  nettle_ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes192_encrypt,
  length, nonce, authlen, msglen, taglen);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
<<<sep_out_sample>>>
push   %r13
mov    %r8,%r13
push   %r12
mov    %ecx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
mov    0x38(%rdi),%rdi
lea    0x18(%rsp),%rcx
lea    0xc(%rsp),%rsi
mov    %edx,0xc(%rsp)
xor    %edx,%edx
callq  6f <__db_meta2pgset+0x2f>
test   %eax,%eax
jne    af <__db_meta2pgset+0x6f>
mov    0x18(%rsp),%rdx
movzbl 0x19(%rdx),%eax
and    $0xf,%eax
cmp    $0x8,%al
je     c0 <__db_meta2pgset+0x80>
cmp    $0x9,%al
jne    e0 <__db_meta2pgset+0xa0>
mov    %rbp,%rsi
mov    %r13,%r8
mov    %r12d,%ecx
mov    %rbx,%rdi
callq  98 <__db_meta2pgset+0x58>
mov    0x18(%rsp),%rsi
mov    %eax,%ebp
mov    0x38(%rbx),%rdi
xor    %edx,%edx
callq  aa <__db_meta2pgset+0x6a>
test   %eax,%eax
cmove  %ebp,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rsi
mov    %r13,%r8
mov    %r12d,%ecx
mov    %rbx,%rdi
callq  d1 <__db_meta2pgset+0x91>
mov    0x18(%rsp),%rsi
mov    %eax,%ebp
jmp    9f <__db_meta2pgset+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rdx,%rsi
mov    $0xffff86f4,%ebp
jmp    9f <__db_meta2pgset+0x5f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__db_meta2pgset(dbp, vdp, pgno, flags, pgset)
 DB *dbp;
 VRFY_DBINFO *vdp;
 db_pgno_t pgno;
 u_int32_t flags;
 DB *pgset;
{
 PAGE *h;
 int ret, t_ret;
 if ((ret = CDB_memp_fget(dbp->mpf, &pgno, 0, &h)) != 0)
  return (ret);
 switch (((((PAGE *)h)->type) & 0x0f)) {
 case 9:
  ret = CDB___bam_meta2pgset(dbp, vdp, (BTMETA *)h, flags, pgset);
  break;
 case 8:
  ret = CDB___ham_meta2pgset(dbp, vdp, (HMETA *)h, flags, pgset);
  break;
 default:
  ret = (-30988);
  break;
 }
 if ((t_ret = CDB_memp_fput(dbp->mpf, h, 0)) != 0)
  return (t_ret);
 return (ret);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 10
11 10
12 10
13 7
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 23
33 23
34 23
35 23
36 23
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 17
45 17
46 17
47 17
48 17
49 17
50 17
51 18
52 18
53 12
54 20
55 20
56 20
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
sub    $0x18,%rsp
mov    0xc0(%rdi),%rbx
test   %rbx,%rbx
jne    114 <wordsplit_dump_nodes+0x64>
jmpq   170 <wordsplit_dump_nodes+0xc0>
nopl   0x0(%rax)
mov    0x18(%rbx),%r14
mov    0x58(%r12),%r13
callq  0 <wsnode_flagstr>
mov    0x10(%rbx),%r8d
mov    %rax,%r9
mov    0xd0(%r12),%esi
mov    %rbx,%rcx
mov    %ebp,%edx
xor    %eax,%eax
mov    %r14,(%rsp)
mov    $0x0,%edi
add    $0x1,%ebp
callq  *%r13
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     170 <wordsplit_dump_nodes+0xc0>
mov    0x10(%rbx),%edi
test   $0x2,%dil
jne    d8 <wordsplit_dump_nodes+0x28>
mov    0x18(%rbx),%rdx
mov    0x20(%rbx),%r13d
mov    0x58(%r12),%r14
mov    %rdx,%r15
add    0x98(%r12),%r15
sub    %edx,%r13d
callq  0 <wsnode_flagstr>
mov    0x10(%rbx),%r8d
mov    0xd0(%r12),%esi
mov    %rax,%r9
mov    %rbx,%rcx
mov    %ebp,%edx
xor    %eax,%eax
mov    %r15,0x8(%rsp)
mov    %r13d,(%rsp)
mov    $0x0,%edi
callq  *%r14
mov    0x8(%rbx),%rbx
add    $0x1,%ebp
test   %rbx,%rbx
jne    114 <wordsplit_dump_nodes+0x64>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nop
<<<sep_in_sample>>>
wordsplit_dump_nodes (struct wordsplit *wsp)
{
  struct wordsplit_node *p;
  int n = 0;
  for (p = wsp->ws_head, n = 0; p; p = p->next, n++)
    {
      if (p->flags & 0x02)
 wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%s;",
         wsp->ws_lvl,
         n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);
      else
 wsp->ws_debug ("(%02d) %4d: %p: %#04x (%s):%.*s;",
         wsp->ws_lvl,
         n, p, p->flags, wsnode_flagstr (p->flags),
         (int) (p->v.segm.end - p->v.segm.beg),
         wsp->ws_input + p->v.segm.beg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 2
9 2
10 5
11 5
12 5
13 5
14 5
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 5
27 8
28 5
29 5
30 5
31 7
32 7
33 7
34 16
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 5
52 5
53 5
54 5
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 18
63 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  a0c <gsl_vector_complex_float_calloc+0xc>
test   %rax,%rax
mov    %rax,%rbx
je     a57 <gsl_vector_complex_float_calloc+0x57>
lea    0x0(,%rbp,8),%r12
mov    0x10(%rax),%rdi
xor    %esi,%esi
mov    %r12,%rdx
callq  a2a <gsl_vector_complex_float_calloc+0x2a>
add    %rbp,%rbp
je     a4f <gsl_vector_complex_float_calloc+0x4f>
mov    0x10(%rbx),%rcx
lea    (%rcx,%r12,1),%rdx
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rcx)
add    $0x4,%rcx
cmp    %rdx,%rcx
jne    a40 <gsl_vector_complex_float_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    a52 <gsl_vector_complex_float_calloc+0x52>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_calloc (const size_t n)
{
  size_t i;
  gsl_vector_complex_float * v = gsl_vector_complex_float_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 2 * n * sizeof(float));
  for (i = 0; i < 2 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 8
22 8
23 8
24 13
25 13
26 13
27 13
28 6
29 6
30 6
<<<sep_out_sample>>>
mov    %esi,0x60(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicol_set_task_debug(SWICOL * swicol, int do_debug)
{
 swicol->debug_task_scriptsM = do_debug;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     668 <pop_get_transport2+0x28>
mov    0x58(%rdi),%rax
test   %rax,%rax
je     668 <pop_get_transport2+0x28>
mov    0x98(%rax),%rax
test   %rax,%rax
je     668 <pop_get_transport2+0x28>
mov    0x20(%rax),%rdi
jmpq   663 <pop_get_transport2+0x23>
nopl   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
pop_get_transport2 (pop_message_t mpm, mu_transport_t *ptr, mu_transport_t *ptr2)
{
  if (mpm && mpm->mpd && mpm->mpd->mbox)
 return mu_stream_get_transport2 (mpm->mpd->mbox->stream, ptr, ptr2);
  return 22;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 6
13 6
14 6
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     3c0 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 3c7 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     3e8 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     435 <argp_version_parser+0x85>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 3ef <argp_version_parser+0x3f>
test   %rdx,%rdx
je     410 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  404 <argp_version_parser+0x54>
jmp    3d9 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rax
mov    $0x0,%esi
mov    0x30(%rax),%rdi
callq  421 <argp_version_parser+0x71>
mov    $0x0,%esi
mov    %rax,%rdx
mov    %rbx,%rdi
xor    %eax,%eax
callq  433 <argp_version_parser+0x83>
jmp    3d9 <argp_version_parser+0x29>
xor    %edi,%edi
callq  43c <argp_version_parser+0x8c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 18
4 21
5 21
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 14
15 14
16 14
17 21
18 21
19 21
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 15
40 15
41 15
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 7 <version_etc_hook+0x7>
mov    0x0(%rip),%rsi        # e <version_etc_hook+0xe>
mov    $0x0,%ecx
mov    $0x0,%edx
jmpq   1d <version_etc_hook+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU inetutils", "1.9.4",
                  program_authors);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    $0x1,%esi
sub    $0x8,%rsp
mov    (%rbx),%rcx
callq  3c <fp_write+0x1c>
mov    (%rbx),%rdi
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   4e <fp_write+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
fp_write(void *data, const char *buf, size_t size, size_t *pret)
{
    struct pfile_stream *p = data;
    *pret = fwrite(buf, 1, size, p->fp);
    return ferror(p->fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 2
8 4
9 4
10 5
11 4
12 6
13 6
14 6
15 5
16 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_min (const gsl_rng * r)
{
  return r->type->min;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x2,%esi
mov    %rbx,%rdx
callq  3998 <gsl_block_short_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     39ba <gsl_block_short_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  39b5 <gsl_block_short_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_short_fread (FILE * stream, gsl_block_short * b)
{
  size_t n = b->size ;
  short * data = b->data ;
  size_t items = fread (data, 1 * sizeof (short), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
xor    %eax,%eax
jmpq   ac7 <yywrap+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yywrap ()
{
  return context_pop ();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   134a <coproc_closeall+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
coproc_closeall ()
{
  coproc_close (&sh_coproc);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
callq  a56 <swheader_get_attribute+0x6>
test   %rax,%rax
je     a8c <swheader_get_attribute+0x3c>
mov    (%rax),%rbx
test   %rbx,%rbx
je     a7f <swheader_get_attribute+0x2f>
mov    %rax,%rdx
jmp    a73 <swheader_get_attribute+0x23>
nopl   0x0(%rax,%rax,1)
mov    %rcx,%rbx
add    $0x8,%rdx
mov    (%rdx),%rcx
test   %rcx,%rcx
jne    a70 <swheader_get_attribute+0x20>
mov    %rax,%rdi
callq  a87 <swheader_get_attribute+0x37>
mov    %rbx,%rax
pop    %rbx
retq   
xor    %eax,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
swheader_get_attribute(SWHEADER *swheader, char *attribute_keyword, int * is_multi) {
 char **list;
 char **pp;
 char * ret=(char*)(((void *)0));
 ;
 list = swheader_get_attribute_list(swheader,
     attribute_keyword, is_multi);
 pp = list;
 if (!list) return (char*)(((void *)0));
 while (*pp) {
  ret=*pp;
  pp++;
 }
 free(list);
 return ret;
}
<<<sep_in_sample>>>
1 1
2 6
3 9
4 9
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 12
13 10
14 10
15 10
16 14
17 14
18 15
19 16
20 16
21 9
22 16
23 16
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
vector_bfgs_restart (void *vstate)
{
  vector_bfgs_state_t *state = (vector_bfgs_state_t *) vstate;
  state->iter = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rdi
xor    %edx,%edx
mov    %rcx,%rsi
mov    %rcx,%rbp
push   %rbx
sub    $0x8,%rsp
callq  db6 <_cb_include_meta1+0x16>
test   %eax,%eax
mov    %eax,%ebx
je     dd0 <_cb_include_meta1+0x30>
mov    $0x1,%ebx
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdi
callq  dd9 <_cb_include_meta1+0x39>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_cb_include_meta1 (enum grecs_callback_command cmd,
     grecs_locus_t *locus,
     void *varptr, grecs_value_t *value, void *cb_data)
{
  if (assert_grecs_value_type (locus, value, 0))
    return 1;
  meta1_config_parse (value->v.string);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 6
13 9
14 9
15 9
16 9
17 9
18 9
19 7
20 7
21 9
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
cmp    $0x1,%edx
je     122 <Vinvfx+0x122>
jle    cb <Vinvfx+0xcb>
cmp    $0x2,%edx
je     6f <Vinvfx+0x6f>
xor    %ecx,%ecx
cmp    $0x3,%edx
xorpd  %xmm2,%xmm2
jne    178 <Vinvfx+0x178>
nopl   0x0(%rax,%rax,1)
movapd %xmm2,%xmm1
movq   $0x0,(%rsi)
xor    %eax,%eax
nopl   (%rax)
lea    (%rcx,%rax,1),%edx
movslq %edx,%rdx
movsd  0x0(,%rdx,8),%xmm0
mulsd  (%rdi,%rax,8),%xmm0
add    $0x1,%rax
cmp    $0x21,%rax
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rsi)
jne    38 <Vinvfx+0x38>
add    $0x21,%ecx
add    $0x8,%rsi
cmp    $0x441,%ecx
jne    28 <Vinvfx+0x28>
repz retq 
xorpd  %xmm2,%xmm2
xor    %r8d,%r8d
nopw   %cs:0x0(%rax,%rax,1)
movapd %xmm2,%xmm1
movq   $0x0,(%rsi)
mov    %r8d,%edx
xor    %eax,%eax
movslq %edx,%rcx
add    $0x1,%edx
movsd  0x0(,%rcx,8),%xmm0
mulsd  (%rdi,%rax,1),%xmm0
add    $0x10,%rax
cmp    $0x110,%rax
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rsi)
jne    90 <Vinvfx+0x90>
add    $0x11,%r8d
add    $0x8,%rsi
cmp    $0x121,%r8d
jne    80 <Vinvfx+0x80>
repz retq 
xor    %r8d,%r8d
test   %edx,%edx
xorpd  %xmm2,%xmm2
jne    17a <Vinvfx+0x17a>
movapd %xmm2,%xmm1
movq   $0x0,(%rsi)
mov    %r8d,%edx
xor    %eax,%eax
movslq %edx,%rcx
add    $0x1,%edx
movsd  0x0(,%rcx,8),%xmm0
mulsd  (%rdi,%rax,1),%xmm0
add    $0x40,%rax
cmp    $0x140,%rax
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rsi)
jne    ea <Vinvfx+0xea>
add    $0x5,%r8d
add    $0x8,%rsi
cmp    $0x19,%r8d
jne    da <Vinvfx+0xda>
repz retq 
xorpd  %xmm2,%xmm2
xor    %r8d,%r8d
movapd %xmm2,%xmm1
movq   $0x0,(%rsi)
mov    %r8d,%edx
xor    %eax,%eax
nopl   0x0(%rax)
movslq %edx,%rcx
add    $0x1,%edx
movsd  0x0(,%rcx,8),%xmm0
mulsd  (%rdi,%rax,1),%xmm0
add    $0x20,%rax
cmp    $0x120,%rax
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rsi)
jne    140 <Vinvfx+0x140>
add    $0x9,%r8d
add    $0x8,%rsi
cmp    $0x51,%r8d
jne    129 <Vinvfx+0x129>
repz retq 
repz retq 
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Vinvfx (const double *fx, double *c, const int d)
{
  int i, j;
  switch (d)
    {
    case 0:
      for (i = 0; i <= 4; i++)
 {
   c[i] = 0.0;
   for (j = 0; j <= 4; j++)
     c[i] += V1inv[i * 5 + j] * fx[j * 8];
 }
      break;
    case 1:
      for (i = 0; i <= 8; i++)
 {
   c[i] = 0.0;
   for (j = 0; j <= 8; j++)
     c[i] += V2inv[i * 9 + j] * fx[j * 4];
 }
      break;
    case 2:
      for (i = 0; i <= 16; i++)
 {
   c[i] = 0.0;
   for (j = 0; j <= 16; j++)
     c[i] += V3inv[i * 17 + j] * fx[j * 2];
 }
      break;
    case 3:
      for (i = 0; i <= 32; i++)
 {
   c[i] = 0.0;
   for (j = 0; j <= 32; j++)
     c[i] += V4inv[i * 33 + j] * fx[j];
 }
      break;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 33
12 33
13 33
14 33
15 33
16 35
17 35
18 35
19 35
20 34
21 35
22 35
23 34
24 34
25 34
26 31
27 31
28 31
29 31
30 4
31 4
32 25
33 25
34 25
35 25
36 27
37 27
38 27
39 27
40 27
41 26
42 27
43 27
44 26
45 26
46 26
47 23
48 23
49 23
50 4
51 4
52 4
53 4
54 9
55 9
56 9
57 9
58 11
59 11
60 11
61 11
62 11
63 10
64 11
65 11
66 10
67 10
68 10
69 7
70 7
71 7
72 7
73 4
74 17
75 17
76 17
77 17
78 17
79 19
80 19
81 19
82 19
83 19
84 18
85 19
86 19
87 18
88 18
89 18
90 15
91 15
92 15
93 15
94 15
95 15
96 15
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 857 <mu_cfg_yyset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yyset_out (FILE * out_str )
{
        mu_cfg_yyout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     e0 <rec_field_destroy+0x40>
mov    (%rdi),%rdi
callq  b1 <rec_field_destroy+0x11>
mov    0x8(%rbx),%rdi
callq  ba <rec_field_destroy+0x1a>
mov    0x10(%rbx),%rdi
callq  c3 <rec_field_destroy+0x23>
mov    0x20(%rbx),%rdi
callq  cc <rec_field_destroy+0x2c>
mov    0x30(%rbx),%rdi
callq  d5 <rec_field_destroy+0x35>
mov    %rbx,%rdi
pop    %rbx
jmpq   de <rec_field_destroy+0x3e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_destroy (rec_field_t field)
{
  if (field)
    {
      free (field->name);
      free (field->value);
      free (field->source);
      free (field->location_str);
      free (field->char_location_str);
      free (field);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 12
17 10
18 10
19 12
20 12
21 12
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
mov    %rsi,%rbx
mov    $0x28,%esi
sub    $0x8,%rsp
callq  ecb <wsnode_new+0x1b>
test   %rax,%rax
je     ee0 <wsnode_new+0x30>
mov    %rax,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   e10 <_wsplt_nomem>
xchg   %ax,%ax
<<<sep_in_sample>>>
wsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)
{
  struct wordsplit_node *node = calloc (1, sizeof (*node));
  if (!node)
    return _wsplt_nomem (wsp);
  *pnode = node;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 3
9 4
10 4
11 6
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 5
20 8
21 8
22 5
23 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x62,0x14(%rsp)
jne    473 <get_bool+0x23>
mov    0x10(%rsp),%edx
mov    0x18(%rsp),%eax
test   %edx,%edx
je     46e <get_bool+0x1e>
mov    0x18(%rsp),%rax
mov    (%rax),%eax
add    $0x8,%rsp
retq   
mov    $0x0,%edi
xor    %eax,%eax
callq  47f <get_bool+0x2f>
nop
<<<sep_in_sample>>>
get_bool(struct desc x)
{
      bool val;
      switch (x.type)
      { case 'b':
            val = (x.lval ? *x.u.bool_ptr : x.u.bool_val);
            break;
         default:
            fault("evaluation of a Boolean formal parameter not possibl"
               "e because final actual parameter is not of Boolean type"
               );
      }
      return val;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 14
11 14
12 9
13 9
14 9
15 9
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1cf0 <gsl_vector_ushort_mul+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ce5 <gsl_vector_ushort_mul+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1d29 <gsl_vector_ushort_mul+0x69>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rsi
add    %r10,%r10
add    %r9,%r9
xor    %ecx,%ecx
nopl   (%rax)
movzwl (%rax),%edx
add    $0x1,%rcx
imul   (%rsi),%dx
add    %r9,%rsi
mov    %dx,(%rax)
add    %r10,%rax
cmp    %r8,%rcx
jne    1d10 <gsl_vector_ushort_mul+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_mul (gsl_vector_ushort * a, const gsl_vector_ushort * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 77, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] *= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %esi,%esi
mov    0x0(%rip),%ebx        # 19b1 <ea_kill_word+0x11>
js     19e0 <ea_kill_word+0x40>
callq  19b8 <ea_kill_word+0x18>
mov    0x0(%rip),%esi        # 19be <ea_kill_word+0x1e>
cmp    %ebx,%esi
je     19c9 <ea_kill_word+0x29>
mov    %ebx,%edi
callq  400 <ea_kill_text>
mov    %ebx,0x0(%rip)        # 19cf <ea_kill_word+0x2f>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   19dd <ea_kill_word+0x3d>
nopl   (%rax)
neg    %esi
callq  19e7 <ea_kill_word+0x47>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   19f5 <ea_kill_word+0x55>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ea_kill_word (WINDOW *window, int count)
{
  int orig_point = input_line_point;
  if (count < 0)
    ea_backward_kill_word (window, -count);
  else
    {
      ea_forward_word (window, count);
      if (input_line_point != orig_point)
        ea_kill_text (orig_point, input_line_point);
      input_line_point = orig_point;
    }
  window_line_map_init (window);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 4
8 8
9 9
10 9
11 9
12 10
13 10
14 11
15 14
16 13
17 14
18 14
19 13
20 13
21 5
22 5
23 14
24 13
25 14
26 14
27 13
28 13
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
xorpd  %xmm0,%xmm0
ucomisd %xmm2,%xmm0
ja     cb <gsl_ran_chisq_pdf+0x9b>
sub    $0x28,%rsp
ucomisd 0x0(%rip),%xmm1        # 4e <gsl_ran_chisq_pdf+0x1e>
jnp    d0 <gsl_ran_chisq_pdf+0xa0>
mulsd  0x0(%rip),%xmm1        # 5c <gsl_ran_chisq_pdf+0x2c>
movsd  %xmm2,0x10(%rsp)
movapd %xmm1,%xmm0
movsd  %xmm1,0x18(%rsp)
callq  71 <gsl_ran_chisq_pdf+0x41>
movsd  0x10(%rsp),%xmm2
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm2        # 85 <gsl_ran_chisq_pdf+0x55>
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
callq  94 <gsl_ran_chisq_pdf+0x64>
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm2
subsd  0x0(%rip),%xmm1        # a8 <gsl_ran_chisq_pdf+0x78>
mulsd  %xmm0,%xmm1
subsd  %xmm2,%xmm1
subsd  0x8(%rsp),%xmm1
movapd %xmm1,%xmm0
callq  bf <gsl_ran_chisq_pdf+0x8f>
mulsd  0x0(%rip),%xmm0        # c7 <gsl_ran_chisq_pdf+0x97>
add    $0x28,%rsp
repz retq 
nopl   (%rax)
jne    54 <gsl_ran_chisq_pdf+0x24>
movsd  0x0(%rip),%xmm0        # de <gsl_ran_chisq_pdf+0xae>
xorpd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # ea <gsl_ran_chisq_pdf+0xba>
callq  ef <gsl_ran_chisq_pdf+0xbf>
mulsd  0x0(%rip),%xmm0        # f7 <gsl_ran_chisq_pdf+0xc7>
jmp    c7 <gsl_ran_chisq_pdf+0x97>
<<<sep_in_sample>>>
gsl_ran_chisq_pdf (const double x, const double nu)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      if(nu == 2.0)
        {
          return exp(-x/2.0) / 2.0;
        }
      else
        {
          double p;
          double lngamma = gsl_sf_lngamma (nu / 2);
          p = exp ((nu / 2 - 1) * log (x/2) - x/2 - lngamma) / 2;
          return p;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 2
6 9
7 9
8 16
9 16
10 16
11 16
12 16
13 17
14 16
15 17
16 17
17 17
18 17
19 17
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 21
29 21
30 21
31 9
32 11
33 11
34 11
35 11
36 11
37 11
<<<sep_out_sample>>>
mov    $0x1,%edx
jmpq   310 <get_value>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swheaderline_get_value(char *output_line, int *value_len)
{
 return get_value(output_line, value_len, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movsbl %sil,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   0 <insert_name>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
insert_name_in_linklist (char *name, char first)
{
  return insert_name (&linklist, name, first);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     1dd6 <gsl_vector_ushort_scale+0x36>
mov    0x10(%rdi),%rax
add    %r8,%r8
xor    %edx,%edx
nopl   (%rax)
movzwl (%rax),%ecx
add    $0x1,%rdx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    1db8 <gsl_vector_ushort_scale+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ushort_scale (gsl_vector_ushort * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 6
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
neg    %esi
xor    %edx,%edx
jmpq   2ce0 <info_search_1>
nopl   0x0(%rax)
<<<sep_in_sample>>>
info_search_backward (WINDOW *window, int count)
{
  info_search_1 (window, -count, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  249f <gsl_matrix_long_calloc+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     24e8 <gsl_matrix_long_calloc+0x58>
imul   %r12,%rbp
mov    0x18(%rax),%rdi
xor    %esi,%esi
lea    0x0(,%rbp,8),%r12
mov    %r12,%rdx
callq  24c1 <gsl_matrix_long_calloc+0x31>
test   %rbp,%rbp
je     24e0 <gsl_matrix_long_calloc+0x50>
mov    0x18(%rbx),%rcx
lea    (%r12,%rcx,1),%rdx
xchg   %ax,%ax
movq   $0x0,(%rcx)
add    $0x8,%rcx
cmp    %rdx,%rcx
jne    24d0 <gsl_matrix_long_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    24e3 <gsl_matrix_long_calloc+0x53>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_long_calloc (const size_t n1, const size_t n2)
{
  size_t i;
  gsl_matrix_long * m = gsl_matrix_long_alloc (n1, n2);
  if (m == 0)
    return 0;
  memset(m->data, 0, 1 * n1 * n2 * sizeof(long));
  for (i = 0; i < 1 * n1 * n2; i++)
    {
      m->data[i] = 0;
    }
  return m;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 8
24 8
25 8
26 13
27 13
28 13
29 13
30 6
31 6
32 6
<<<sep_out_sample>>>
mov    $0x1,%edx
jmpq   1110 <expint_En_impl>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_expint_En_scaled_e(const int n, const double x, gsl_sf_result * result)
{
  return expint_En_impl(n, x, result, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     25e <_cdio_strdup_upper+0x3e>
callq  230 <_cdio_strdup_upper+0x10>
movzbl (%rax),%edi
mov    %rax,%rbp
test   %dil,%dil
je     254 <_cdio_strdup_upper+0x34>
mov    %rax,%rbx
xchg   %ax,%ax
callq  245 <_cdio_strdup_upper+0x25>
add    $0x1,%rbx
mov    %al,-0x1(%rbx)
movzbl (%rbx),%edi
test   %dil,%dil
jne    240 <_cdio_strdup_upper+0x20>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
xor    %ebp,%ebp
jmp    254 <_cdio_strdup_upper+0x34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_cdio_strdup_upper (const char str[])
{
  char *new_str = ((void *)0);
  if (str)
    {
      char *p;
      p = new_str = strdup (str);
      while (*p)
        {
          *p = toupper ((unsigned char) *p);
          p++;
        }
    }
  return new_str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 7
7 8
8 7
9 8
10 8
11 8
12 8
13 10
14 11
15 10
16 8
17 8
18 8
19 15
20 15
21 15
22 15
23 15
24 3
25 3
26 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     c350 <register_exec_hook+0xa0>
cmpq   $0x0,0x0(%rip)        # c2ce <register_exec_hook+0x1e>
mov    %rsi,%rbp
je     c2e8 <register_exec_hook+0x38>
xor    %eax,%eax
test   %rsi,%rsi
je     c2e8 <register_exec_hook+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    0x0(%rip),%r12d        # c2ef <register_exec_hook+0x3f>
cmp    $0xa,%r12d
je     c350 <register_exec_hook+0xa0>
xor    %r13d,%r13d
test   %r12d,%r12d
jle    c318 <register_exec_hook+0x68>
mov    0x0(%rip),%eax        # c303 <register_exec_hook+0x53>
shr    $0xd,%eax
and    $0x1,%eax
movzbl %al,%r13d
cmp    %r13d,%r12d
jg     c360 <register_exec_hook+0xb0>
mov    $0x1,%r13d
add    $0x1,%r12d
test   %rbp,%rbp
mov    %rbx,0x0(,%r13,8)
mov    %r12d,0x0(%rip)        # c32e <register_exec_hook+0x7e>
je     c390 <register_exec_hook+0xe0>
mov    %rbp,0x0(%rip)        # c337 <register_exec_hook+0x87>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    %r12d,%edx
movzbl %al,%eax
shl    $0x3,%rax
sub    %r13d,%edx
movslq %edx,%rdx
lea    0x0(%rax),%rsi
lea    0x0(%rax),%rdi
shl    $0x3,%rdx
callq  c387 <register_exec_hook+0xd7>
jmp    c318 <register_exec_hook+0x68>
nopl   0x0(%rax)
mov    $0x1,%eax
jmpq   c2da <register_exec_hook+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
register_exec_hook(Func_pre_exec preh, Func_post_exec posth)
{
 int pos = 0;
 if (! preh || (post_execute && posth))
  return 0;
 if (num_exec_hook == 10)
  return 0;
 if (num_exec_hook > 0) {
  pos = !! (do_flags & DO_DEBUG);
  if (num_exec_hook > pos)
   memmove(pre_execute + pos + 1, pre_execute + pos,
     (num_exec_hook - pos) * sizeof (preh));
 }
 pre_execute[pos] = preh;
 num_exec_hook++;
 if (posth)
  post_execute = posth;
 return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 4
14 4
15 19
16 19
17 19
18 19
19 19
20 19
21 19
22 6
23 6
24 6
25 3
26 8
27 8
28 9
29 9
30 9
31 9
32 10
33 10
34 10
35 15
36 16
37 14
38 15
39 16
40 17
41 19
42 18
43 19
44 19
45 19
46 19
47 19
48 19
49 19
50 5
51 19
52 19
53 19
54 19
55 19
56 19
57 12
58 11
59 11
60 12
61 11
62 11
63 11
64 11
65 11
66 11
67 11
68 18
69 18
70 18
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm5        # 8 <gsl_expm1+0x8>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm2        # 14 <gsl_expm1+0x14>
andpd  %xmm5,%xmm1
ucomisd %xmm1,%xmm2
jbe    78 <gsl_expm1+0x78>
movsd  0x0(%rip),%xmm7        # 26 <gsl_expm1+0x26>
movapd %xmm0,%xmm1
movapd %xmm0,%xmm3
movapd %xmm7,%xmm4
movsd  0x0(%rip),%xmm8        # 3b <gsl_expm1+0x3b>
nopl   0x0(%rax,%rax,1)
addsd  %xmm7,%xmm4
movapd %xmm0,%xmm2
divsd  %xmm4,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm3
movapd %xmm1,%xmm6
andpd  %xmm5,%xmm6
movapd %xmm3,%xmm2
andpd  %xmm5,%xmm2
mulsd  %xmm8,%xmm2
ucomisd %xmm2,%xmm6
ja     40 <gsl_expm1+0x40>
movapd %xmm3,%xmm0
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
callq  81 <gsl_expm1+0x81>
subsd  0x0(%rip),%xmm0        # 89 <gsl_expm1+0x89>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_expm1 (const double x)
{
  if (fabs(x) < 0.69314718055994530942)
    {
      double i = 1.0;
      double sum = x;
      double term = x / 1.0;
      do
        {
          i++ ;
          term *= x/i;
          sum += term;
        }
      while (fabs(term) > fabs(sum) * 2.2204460492503131e-16) ;
      return sum ;
    }
  else
    {
      return exp(x) - 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 10
14 11
15 11
16 11
17 12
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 12
26 12
27 12
28 2
29 19
30 19
31 21
32 21
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     3510 <gsl_matrix_short_mul_elements+0x40>
mov    $0x13,%ecx
mov    $0x56,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  34ff <gsl_matrix_short_mul_elements+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%r8
cmp    %rax,%r8
jne    34e6 <gsl_matrix_short_mul_elements+0x16>
test   %r10,%r10
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r12
je     3576 <gsl_matrix_short_mul_elements+0xa6>
add    %r13,%r13
add    %r12,%r12
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
nopl   0x0(%rax,%rax,1)
test   %r8,%r8
je     3567 <gsl_matrix_short_mul_elements+0x97>
mov    %rbx,%rcx
mov    %rbp,%r9
add    0x18(%rdi),%rcx
add    0x18(%rsi),%r9
xor    %eax,%eax
nopl   (%rax)
movzwl (%rcx,%rax,2),%edx
imul   (%r9,%rax,2),%dx
mov    %dx,(%rcx,%rax,2)
add    $0x1,%rax
cmp    %r8,%rax
jne    3550 <gsl_matrix_short_mul_elements+0x80>
add    $0x1,%r11
add    %r13,%rbx
add    %r12,%rbp
cmp    %r10,%r11
jne    3538 <gsl_matrix_short_mul_elements+0x68>
xor    %eax,%eax
jmp    3504 <gsl_matrix_short_mul_elements+0x34>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_mul_elements (gsl_matrix_short * a, const gsl_matrix_short * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 86, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 18
47 16
48 16
49 16
50 14
51 14
52 14
53 14
54 14
55 21
56 21
57 21
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    $0xb,%edx
imul   $0x3a8,%rdi,%rdi
add    0x0(%rip),%rdi        # dc6 <dis_setEntityMarkings+0x16>
add    $0x298,%rdi
jmpq   dd2 <dis_setEntityMarkings+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dis_setEntityMarkings(int eid, char *markings)
{
 strncpy(entities[eid].markings, markings, 11);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    $0x0,%edx
mov    $0x14b,%esi
mov    %rdi,%rbx
sub    $0x160,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x158(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
callq  183 <cannotwrite+0x33>
mov    %rsp,%rdi
callq  18b <cannotwrite+0x3b>
mov    %rbx,%rdi
callq  193 <cannotwrite+0x43>
mov    $0x1,%edi
callq  19d <cannotwrite+0x4d>
<<<sep_in_sample>>>
cannotwrite(char *file)
{
    char msg[((250) + 80) + 1];
    snprintf(msg, sizeof(msg), "Removed file %s because write failed", file);
    myperror(msg);
    unlink(file);
    myexit(1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 6
15 6
16 7
17 7
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
test   %r10,%r10
movzwl (%rdi),%eax
je     2137 <gsl_matrix_short_min+0x57>
push   %rbx
lea    (%r9,%r9,1),%rbx
add    %r11,%r11
xor    %r8d,%r8d
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     212a <gsl_matrix_short_min+0x4a>
lea    (%rdi,%rbx,1),%rsi
mov    %rdi,%rdx
nopl   0x0(%rax)
movzwl (%rdx),%ecx
cmp    %cx,%ax
cmovg  %ecx,%eax
add    $0x2,%rdx
cmp    %rsi,%rdx
jne    2118 <gsl_matrix_short_min+0x38>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
jne    2108 <gsl_matrix_short_min+0x28>
pop    %rbx
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_short_min (const gsl_matrix_short * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  short min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          short x = m->data[i * tda + j];
          if (x < min)
            min = x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 8
6 6
7 8
8 2
9 2
10 2
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 10
23 10
24 8
25 8
26 8
27 8
28 18
29 18
30 18
<<<sep_out_sample>>>
mov    (%rdi),%r11
push   %rbx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3b0d <gsl_matrix_uchar_add_constant+0x5d>
xor    %r8d,%r8d
xor    %r9d,%r9d
nopw   0x0(%rax,%rax,1)
test   %r10,%r10
je     3b01 <gsl_matrix_uchar_add_constant+0x51>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
nopl   0x0(%rax)
mov    %rax,%rdx
add    0x18(%rdi),%rdx
add    $0x1,%rax
cmp    %rax,%rsi
movzbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
jne    3ae0 <gsl_matrix_uchar_add_constant+0x30>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
jne    3ad0 <gsl_matrix_uchar_add_constant+0x20>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_add_constant (gsl_matrix_uchar * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 11
16 11
17 11
18 9
19 11
20 11
21 11
22 11
23 11
24 9
25 7
26 7
27 7
28 7
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
push   %r13
mov    $0x1,%r13d
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edi
sub    $0x8,%rsp
callq  279d <request_restart_components+0x1d>
cmp    $0xffffffff,%eax
mov    %eax,%r12d
je     27f3 <request_restart_components+0x73>
mov    0x0(%rip),%rdi        # 27ac <request_restart_components+0x2c>
mov    $0x0,%esi
callq  27b6 <request_restart_components+0x36>
test   %rax,%rax
mov    %rax,%rbp
jne    27d3 <request_restart_components+0x53>
jmp    2801 <request_restart_components+0x81>
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
add    $0x8,%rbx
callq  27d3 <request_restart_components+0x53>
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    27c0 <request_restart_components+0x40>
mov    %rbp,%rdi
xor    %r13d,%r13d
callq  27e6 <request_restart_components+0x66>
mov    $0xa,%esi
mov    %r12d,%edi
callq  27f3 <request_restart_components+0x73>
add    $0x8,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  2806 <request_restart_components+0x86>
mov    (%rax),%edi
callq  280d <request_restart_components+0x8d>
mov    0x0(%rip),%rbx        # 2814 <request_restart_components+0x94>
mov    %rax,%rbp
mov    $0x0,%edi
callq  2821 <request_restart_components+0xa1>
mov    %rbp,%rcx
mov    %rax,%rsi
mov    $0x3,%edi
mov    %rbx,%rdx
xor    %eax,%eax
callq  2836 <request_restart_components+0xb6>
jmp    27f3 <request_restart_components+0x73>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
request_restart_components (char **argv)
{
  FILE *fp;
  pid_t pid = pidfile_read (1);
  if (pid == -1)
    return 1;
  fp = fopen (ctlfile, "w");
  if (!fp)
    {
      logmsg (3, gettext("cannot open control file `%s': %s"),
       ctlfile, strerror ((*__errno_location ())));
      return 1;
    }
  for (; *argv; argv++)
    fprintf (fp, "%s\n", *argv);
  fclose (fp);
  kill (pid, 10);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 4
8 2
9 4
10 5
11 4
12 5
13 7
14 7
15 7
16 8
17 7
18 8
19 8
20 15
21 15
22 15
23 14
24 15
25 14
26 14
27 14
28 16
29 18
30 16
31 17
32 17
33 17
34 19
35 19
36 19
37 19
38 19
39 19
40 19
41 11
42 10
43 10
44 10
45 10
46 10
47 10
48 10
49 10
50 10
51 10
52 10
53 10
54 12
55 12
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 857 <yyset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_out (FILE * out_str )
{
        yyout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     cd0 <include_symbol+0xa0>
mov    0x18(%rdi),%edx
cmp    $0x2,%edx
je     c50 <include_symbol+0x20>
cmp    $0x1,%edx
mov    $0x1,%eax
je     c90 <include_symbol+0x60>
repz retq 
nopl   (%rax)
mov    0x20(%rdi),%rax
mov    0x0(%rip),%esi        # c5a <include_symbol+0x2a>
cmpb   $0x5f,(%rax)
je     cb0 <include_symbol+0x80>
mov    0x70(%rdi),%ecx
mov    0x74(%rdi),%edx
cmp    $0x2,%ecx
je     cd3 <include_symbol+0xa3>
xor    %eax,%eax
cmp    $0xffffffff,%edx
je     cc0 <include_symbol+0x90>
mov    %eax,%ecx
or     $0x1,%ecx
test   %edx,%edx
cmovns %ecx,%eax
cmpq   $0x0,0x48(%rdi)
je     ce0 <include_symbol+0xb0>
and    %eax,%esi
cmp    %esi,%eax
sete   %al
movzbl %al,%eax
retq   
nopl   (%rax)
xor    %al,%al
cmpl   $0x10e,0x40(%rdi)
jne    c4b <include_symbol+0x1b>
cmpq   $0x0,0x48(%rdi)
je     c4b <include_symbol+0x1b>
xor    %eax,%eax
testb  $0x10,0x0(%rip)        # cab <include_symbol+0x7b>
setne  %al
retq   
nop
mov    %esi,%eax
and    $0x8,%eax
jne    c5f <include_symbol+0x2f>
jmp    c4b <include_symbol+0x1b>
nopl   0x0(%rax)
xor    %eax,%eax
cmp    $0x3,%ecx
setne  %al
add    %eax,%eax
jmp    c7b <include_symbol+0x4b>
nopl   0x0(%rax)
xor    %eax,%eax
retq   
cmp    $0xffffffff,%edx
je     ce5 <include_symbol+0xb5>
mov    $0x4,%eax
jmp    c71 <include_symbol+0x41>
nop
or     $0x20,%eax
jmp    c82 <include_symbol+0x52>
mov    $0x6,%eax
jmp    c7b <include_symbol+0x4b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
include_symbol(Symbol *sym)
{
     int type = 0;
     if (!sym)
   return 0;
     if (sym->type == SymIdentifier) {
   if (sym->name[0] == '_' && !(symbol_map & 0x0008))
        return 0;
   if (sym->storage == StaticStorage)
        type |= 0x0004;
   if (sym->arity == -1 && sym->storage != AutoStorage)
        type |= 0x0002;
   else if (sym->arity >= 0)
        type |= 0x0001;
   if (!sym->source)
        type |= 0x0020;
     } else if (sym->type == SymToken) {
   if (sym->token_type == 270 && sym->source)
        type |= 0x0010;
   else
        return 0;
     }
     return (symbol_map & type) == type;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 17
7 17
8 17
9 24
10 24
11 7
12 7
13 7
14 7
15 9
16 11
17 9
18 9
19 3
20 11
21 11
22 14
23 14
24 14
25 14
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 5
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 18
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 7
54 7
55 5
56 5
57 11
58 11
59 10
60 10
61 10
62 16
63 16
64 11
65 12
66 12
<<<sep_out_sample>>>
mov    $0x0,%edx
jmpq   1c0 <internal_read_file>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_file (const char *filename, size_t *length)
{
  return internal_read_file (filename, length, "r");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x8,%esi
mov    %rbx,%rdx
callq  20f8 <gsl_block_ulong_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     211a <gsl_block_ulong_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2115 <gsl_block_ulong_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_ulong_fread (FILE * stream, gsl_block_ulong * b)
{
  size_t n = b->size ;
  unsigned long * data = b->data ;
  size_t items = fread (data, 1 * sizeof (unsigned long), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_call_id_set_host (osip_call_id_t * callid, char *host)
{
  callid->host = host;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d0 <osip_cond_signal+0x10>
jmpq   ca <osip_cond_signal+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_cond_signal (struct osip_cond *_cond)
{
  if (!_cond)
    return -2;
  return pthread_cond_signal (&_cond->cv);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 6
7 6
<<<sep_out_sample>>>
test   %edx,%edx
jle    3c <cblas_csscal+0x3c>
test   %edi,%edi
jle    3c <cblas_csscal+0x3c>
add    %edx,%edx
xor    %eax,%eax
movslq %edx,%rdx
shl    $0x2,%rdx
nopl   0x0(%rax,%rax,1)
movss  (%rsi),%xmm1
add    $0x1,%eax
mulss  %xmm0,%xmm1
movss  %xmm1,(%rsi)
movss  0x4(%rsi),%xmm1
mulss  %xmm0,%xmm1
movss  %xmm1,0x4(%rsi)
add    %rdx,%rsi
cmp    %edi,%eax
jne    18 <cblas_csscal+0x18>
repz retq 
<<<sep_in_sample>>>
cblas_csscal (const int N, const float alpha, void *X, const int incX)
{
{
  int i;
  int ix = 0;
  if (incX <= 0) {
    return;
  }
  for (i = 0; i < N; i++) {
    (((float *) X)[2*(ix)]) *= alpha;
    (((float *) X)[2*(ix)+1]) *= alpha;
    ix += incX;
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 10
11 9
12 10
13 10
14 11
15 11
16 11
17 11
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbp
lea    0x4(%rsi),%rcx
mov    %rsi,%rdx
xor    %eax,%eax
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
sub    $0x18,%rsp
lea    0xf(%rsp),%r8
callq  154 <string_to_version+0x24>
cmp    $0x2,%eax
je     1a8 <string_to_version+0x78>
cmp    $0x3,%eax
je     190 <string_to_version+0x60>
mov    %rbp,%rdi
callq  166 <string_to_version+0x36>
mov    $0x0,%edi
mov    %rax,%rbx
callq  173 <string_to_version+0x43>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  187 <string_to_version+0x57>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
movsbl 0xf(%rsp),%eax
sub    $0x60,%eax
mov    %eax,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
string_to_version (const char * version_string, version_t version)
{
  char d;
  switch (sscanf (version_string, "%d.%d%c",
    &(version[0]), &(version[1]), &d))
    {
    case 2:
      version[2] = 0;
      break;
    case 3:
      version[2] = d - 'a' + 1;
      break;
    default:
      error (1, 0,
      gettext ("invalid version number `%s'"), quotearg (version_string));
      break;
    };
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 2
6 2
7 2
8 4
9 2
10 4
11 4
12 4
13 4
14 4
15 4
16 14
17 14
18 15
19 14
20 15
21 14
22 14
23 14
24 14
25 14
26 14
27 18
28 18
29 18
30 18
31 18
32 11
33 11
34 11
35 18
36 18
37 18
38 18
39 18
40 8
41 18
42 18
43 18
44 18
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
mov    0x8(%rdi),%rdi
lea    0x18(%rsp),%rcx
callq  29f <transcript_read+0x1f>
test   %eax,%eax
jne    2e0 <transcript_read+0x60>
mov    0x18(%rsp),%rcx
mov    %rbp,%rdx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    %eax,0xc(%rsp)
callq  90 <print_transcript>
test   %r12,%r12
mov    0xc(%rsp),%eax
je     2ce <transcript_read+0x4e>
mov    0x18(%rsp),%rdx
mov    %rdx,(%r12)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rdi
callq  2e9 <transcript_read+0x69>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
transcript_read(void *data, char *buf, size_t size, size_t *pret)
{
    struct transcript_stream *p = data;
    size_t nbytes;
    if (dico_stream_read(p->transport, buf, size, &nbytes) == 0) {
 print_transcript(p, 0x1, buf, nbytes);
 if (pret)
     *pret = nbytes;
    } else
 return dico_stream_last_error(p->transport);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 8
23 8
24 12
25 12
26 12
27 12
28 12
29 12
30 10
31 10
32 12
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
cmpq   $0x0,0x18(%rdi)
mov    $0x16,%eax
je     820 <_url_prog_init+0x10>
repz retq 
xchg   %ax,%ax
cmpq   $0x0,0x20(%rdi)
jne    81c <_url_prog_init+0xc>
cmpq   $0x0,0x28(%rdi)
jne    81c <_url_prog_init+0xc>
cmpq   $0x0,0x30(%rdi)
jne    81c <_url_prog_init+0xc>
cmpq   $0x0,0x38(%rdi)
je     81c <_url_prog_init+0xc>
movq   $0x0,0xb0(%rdi)
xor    %al,%al
retq   
<<<sep_in_sample>>>
_url_prog_init (mu_url_t url)
{
  if (url->secret || url->auth || url->host || url->port)
    return 22;
  if (!url->path)
    return 22;
  url->_uplevel = _url_prog_uplevel;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 9
5 9
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 7
15 8
16 9
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %edi,%r12d
push   %rbp
push   %rbx
sub    $0x28,%rsp
callq  ba5 <findlock+0x15>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # baf <findlock+0x1f>
mov    0x170(%rax),%rax
mov    0x38(%rax),%rcx
test   %rcx,%rcx
mov    %rcx,0x18(%rsp)
je     c28 <findlock+0x98>
lea    0x10(%rsp),%rdi
mov    %rbx,%rdx
mov    $0x1,%esi
callq  bd6 <findlock+0x46>
test   %rax,%rax
mov    %rax,%rbp
je     c28 <findlock+0x98>
mov    0x8(%rax),%rdi
mov    %rbx,%rdx
mov    $0x1,%esi
callq  bef <findlock+0x5f>
test   %rax,%rax
je     c38 <findlock+0xa8>
mov    0x0(%rip),%rax        # bfb <findlock+0x6b>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    0xd0(%rax),%rdi
xor    %eax,%eax
callq  c11 <findlock+0x81>
mov    $0x2,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    $0x28,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    0x8(%rbp),%rax
test   %r12b,%r12b
mov    (%rax),%rax
mov    0x8(%rax),%rax
mov    %rax,0x0(%r13)
mov    $0x1,%eax
je     c16 <findlock+0x86>
lea    0x10(%rsp),%rdi
mov    %rbp,%rsi
mov    %eax,0xc(%rsp)
callq  c62 <findlock+0xd2>
mov    0xc(%rsp),%eax
jmp    c16 <findlock+0x86>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findlock (_Bool delete, struct delta **target)
{
  struct rcslock const *rl;
  struct link box, *found;
  char const *me = getcaller ();
  if (! (box.next = ((top->repository. r)-> locks))
      || ! (found = lock_memq (&box, 1, me)))
    return 0;
  if (lock_memq (found->next, 1, me))
    {
      generic_error ((top->repository. filename), "multiple revisions locked by %s; please specify one", me);
      return 2;
    }
  rl = found->next->entry;
  *target = rl->delta;
  if (delete)
    lock_drop (&box, found);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 12
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 19
44 8
45 19
46 19
47 19
48 19
49 19
50 19
51 14
52 16
53 15
54 15
55 15
56 18
57 16
58 17
59 17
60 17
61 17
62 17
63 17
64 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <_tree_recurse>
test   %eax,%eax
je     5d0 <grecs_tree_recurse+0x20>
cmp    $0x3,%eax
je     5d0 <grecs_tree_recurse+0x20>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_tree_recurse(struct grecs_node *node, grecs_tree_recursor_t recfun,
     void *data)
{
 switch (_tree_recurse(node, recfun, data)) {
 case grecs_tree_recurse_ok:
 case grecs_tree_recurse_stop:
  return 0;
 default:
  break;
 }
 return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 11
8 12
9 12
10 12
11 7
12 12
13 12
14 12
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x10(%rsi),%rbx
sub    $0x8,%rsp
mov    (%rsi),%rdi
test   %rdi,%rdi
jne    40 <find_string_in_alist+0x40>
jmp    67 <find_string_in_alist+0x67>
nopl   0x0(%rax)
movzbl (%rdi),%eax
cmp    %al,0x0(%rbp)
je     80 <find_string_in_alist+0x80>
mov    %rbx,%r12
add    $0x10,%rbx
mov    -0x10(%rbx),%rdi
test   %rdi,%rdi
je     67 <find_string_in_alist+0x67>
test   %r13d,%r13d
je     28 <find_string_in_alist+0x28>
mov    $0x20,%edx
mov    %rbp,%rsi
callq  52 <find_string_in_alist+0x52>
cmp    $0x1,%eax
jne    8f <find_string_in_alist+0x8f>
mov    %rbx,%r12
add    $0x10,%rbx
mov    -0x10(%rbx),%rdi
test   %rdi,%rdi
jne    40 <find_string_in_alist+0x40>
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rsi
mov    %rbp,%rdi
callq  8b <find_string_in_alist+0x8b>
test   %eax,%eax
jne    30 <find_string_in_alist+0x30>
mov    0x8(%r12),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
<<<sep_in_sample>>>
find_string_in_alist (string, alist, flags)
     char *string;
     STRING_INT_ALIST *alist;
     int flags;
{
  register int i;
  int r;
  for (i = r = 0; alist[i].word; i++)
    {
      if (flags)
 r = strmatch (alist[i].word, string, (1 << 5)) != 1;
      else
 r = ((string)[0] == (alist[i].word)[0] && strcmp(string, alist[i].word) == 0);
      if (r)
 return (alist[i].token);
    }
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 8
5 5
6 5
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 13
16 13
17 13
18 8
19 8
20 8
21 8
22 8
23 10
24 10
25 11
26 11
27 11
28 14
29 14
30 8
31 8
32 8
33 8
34 8
35 18
36 17
37 18
38 18
39 18
40 18
41 18
42 18
43 13
44 13
45 13
46 13
47 13
48 15
49 18
50 18
51 18
52 18
53 18
54 18
55 18
<<<sep_out_sample>>>
mov    %rsi,0x38(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_algorithm (osip_authorization_t * authorization, char *algorithm)
{
  authorization->algorithm = (char *) algorithm;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8ef <osip_transaction_set_your_instance+0xf>
mov    %rsi,0x2c40(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_your_instance (osip_transaction_t * transaction, void *ptr)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->reserved1 = ptr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
test   %edi,%edi
je     25 <_nettle_umac_l2_init+0x25>
lea    -0x1(%rdi),%eax
lea    0x4(%rsi,%rax,4),%rdx
nopl   0x0(%rax)
mov    (%rsi),%eax
add    $0x4,%rsi
bswap  %eax
and    $0x1ffffff,%eax
mov    %eax,-0x4(%rsi)
cmp    %rdx,%rsi
jne    10 <_nettle_umac_l2_init+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_nettle_umac_l2_init (unsigned size, uint32_t *k)
{
  unsigned i;
  for (i = 0; i < size; i++)
    {
      uint32_t w = k[i];
      w = (((((w)<<(8)) | ((w)>>((-(8)&31)))) & 0x00FF00FFUL) | ((((w)<<(24)) | ((w)>>((-(24)&31)))) & 0xFF00FF00UL));
      k[i] = w & 0x01ffffffUL;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 8
10 8
11 4
12 4
13 4
14 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  4b <check_pid+0xb>
test   %eax,%eax
mov    %eax,%ebx
jne    60 <check_pid+0x20>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  65 <check_pid+0x25>
cmp    %ebx,%eax
je     51 <check_pid+0x11>
callq  6e <check_pid+0x2e>
xor    %esi,%esi
movl   $0x0,(%rax)
mov    %ebx,%edi
mov    %rax,%rbp
callq  80 <check_pid+0x40>
mov    %eax,%edx
mov    %ebx,%eax
test   %edx,%edx
je     53 <check_pid+0x13>
cmpl   $0x3,0x0(%rbp)
jne    53 <check_pid+0x13>
jmp    51 <check_pid+0x11>
<<<sep_in_sample>>>
check_pid (char *pidfile)
{
  int pid = read_pid(pidfile);
  if ((!pid) || (pid == getpid ()))
    return 0;
  (*__errno_location ()) = 0;
  if (kill(pid, 0) && (*__errno_location ()) == 3)
   return(0);
  return pid;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 3
7 4
8 5
9 10
10 10
11 10
12 10
13 10
14 4
15 4
16 4
17 6
18 7
19 6
20 7
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
mov    0x320(%rdi),%rax
movsd  0x288(%rdi),%xmm0
addsd  0x1c0(%rax),%xmm0
movsd  0x1a8(%rax),%xmm1
ucomisd %xmm1,%xmm0
movsd  %xmm0,0x288(%rdi)
jbe    4d5 <speedBrakeExtend+0x35>
movsd  %xmm1,0x288(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
speedBrakeExtend(craft * c)
{
 c->speedBrakeSetting += c->cinfo->speedBrakeIncr;
 if (c->speedBrakeSetting > c->cinfo->maxSpeedBrake)
  c->speedBrakeSetting = c->cinfo->maxSpeedBrake;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 4
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c <rpl_fclose+0xc>
test   %eax,%eax
mov    %rbx,%rdi
js     6f <rpl_fclose+0x6f>
callq  18 <rpl_fclose+0x18>
test   %eax,%eax
jne    50 <rpl_fclose+0x50>
mov    %rbx,%rdi
callq  24 <rpl_fclose+0x24>
test   %eax,%eax
je     6c <rpl_fclose+0x6c>
callq  2d <rpl_fclose+0x2d>
mov    (%rax),%r12d
mov    %rbx,%rdi
mov    %rax,%rbp
callq  3b <rpl_fclose+0x3b>
test   %r12d,%r12d
je     49 <rpl_fclose+0x49>
mov    %r12d,0x0(%rbp)
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  58 <rpl_fclose+0x58>
xor    %esi,%esi
mov    $0x1,%edx
mov    %eax,%edi
callq  66 <rpl_fclose+0x66>
cmp    $0xffffffffffffffff,%rax
jne    1c <rpl_fclose+0x1c>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   78 <rpl_fclose+0x78>
<<<sep_in_sample>>>
rpl_fclose (FILE *fp)
{
  int saved_errno = 0;
  int fd;
  int result = 0;
  fd = fileno (fp);
  if (fd < 0)
    return fclose (fp);
  if ((!(__freading (fp) != 0) || lseek (fileno (fp), 0, 1) != -1)
      && rpl_fflush (fp))
    saved_errno = (*__errno_location ());
  result = fclose (fp);
  if (saved_errno != 0)
    {
      (*__errno_location ()) = saved_errno;
      result = (-1);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 8
8 7
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 12
19 11
20 12
21 13
22 13
23 15
24 16
25 19
26 19
27 19
28 19
29 19
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 12
39 19
40 19
41 19
42 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0xc(%rsp),%rdi
callq  12 <printf_frexp+0x12>
mov    0xc(%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,0xc(%rsp)
jge    38 <printf_frexp+0x38>
lea    0x3fd(%rdx),%edi
callq  33 <printf_frexp+0x33>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
mov    %rsi,%rbx
mov    $0x48,%esi
sub    $0x8,%rsp
callq  13b <cdio_stream_new+0x1b>
mov    %rbp,(%rax)
mov    (%rbx),%rcx
mov    %rcx,0x8(%rax)
mov    0x8(%rbx),%rcx
mov    %rcx,0x10(%rax)
mov    0x10(%rbx),%rcx
mov    %rcx,0x18(%rax)
mov    0x18(%rbx),%rcx
mov    %rcx,0x20(%rax)
mov    0x20(%rbx),%rcx
mov    %rcx,0x28(%rax)
mov    0x28(%rbx),%rcx
mov    %rcx,0x30(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_stream_new(void *user_data, const cdio_stream_io_functions *funcs)
{
  CdioDataSource_t *new_obj;
  new_obj = calloc (1, sizeof (CdioDataSource_t));
  new_obj->user_data = user_data;
  memcpy(&(new_obj->op), funcs, sizeof(cdio_stream_io_functions));
  return new_obj;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 2
8 4
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 8
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     bc0 <gsl_vector_long_double_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bb5 <gsl_vector_long_double_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     bf7 <gsl_vector_long_double_sub+0x67>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x4,%r10
shl    $0x4,%r9
xor    %edx,%edx
nop
fldt   (%rax)
add    $0x1,%rdx
fldt   (%rcx)
add    %r9,%rcx
fsubrp %st,%st(1)
fstpt  (%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    be0 <gsl_vector_long_double_sub+0x50>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_sub (gsl_vector_long_double * a, const gsl_vector_long_double * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # e4b <release_all_vars+0xb>
xor    %esi,%esi
mov    (%rdi),%rax
callq  *0x28(%rax)
mov    0x0(%rip),%rdi        # e5a <release_all_vars+0x1a>
xor    %esi,%esi
mov    (%rdi),%rax
callq  *0x28(%rax)
mov    0x0(%rip),%rdi        # e69 <release_all_vars+0x29>
xor    %esi,%esi
mov    (%rdi),%rax
mov    0x28(%rax),%rax
add    $0x8,%rsp
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
release_all_vars()
{
 (void) ((symbol_table)->sub.nodep.l.lp[5](symbol_table, ((void *)0)));
 (void) ((func_table)->sub.nodep.l.lp[5](func_table, ((void *)0)));
 (void) ((global_table)->sub.nodep.l.lp[5](global_table, ((void *)0)));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 5
16 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rdi
callq  97d <gsl_multifit_fdfridge_iterate+0xd>
mov    0x78(%rbx),%rcx
mov    0x40(%rbx),%rdx
mov    %rcx,0x30(%rdx)
mov    0x80(%rbx),%rcx
mov    %rcx,0x38(%rdx)
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfridge_iterate (gsl_multifit_fdfridge * w)
{
  int status = gsl_multifit_fdfsolver_iterate(w->s);
  w->fdf->nevalf = w->fdftik.nevalf;
  w->fdf->nevaldf = w->fdftik.nevaldf;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
mov    $0x336,%edx
mov    $0x10,%edi
callq  1118 <make_subshell_command+0x18>
mov    %rbx,0x8(%rax)
movl   $0x1,(%rax)
mov    %rax,%rsi
pop    %rbx
mov    $0xd,%edi
jmpq   1130 <make_coproc_command>
<<<sep_in_sample>>>
make_subshell_command (command)
     COMMAND *command;
{
  SUBSHELL_COM *temp;
  temp = (SUBSHELL_COM *)sh_xmalloc((sizeof (SUBSHELL_COM)), "make_cmd.c", 822);
  temp->command = command;
  temp->flags = 0x01;
  return (make_command (cm_subshell, (SIMPLE_COM *)temp));
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 5
7 6
8 7
9 8
10 9
11 8
12 8
<<<sep_out_sample>>>
jmpq   2025 <cpp_realloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_realloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_diagonal (gsl_matrix_ulong * m)
{
  _gsl_vector_ulong_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_ulong v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    0x20(%rdi),%rdi
mov    $0x1,%edx
callq  60 <genlabelparexp>
mov    0x0(%rip),%rcx        # 12fc <gen_thunk_lable+0x1c>
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   1314 <gen_thunk_lable+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gen_thunk_lable (exp_t *rex)
{
  genlabelparexp (rex->left, rex, 1);
  fprintf (ccode, "__reth();");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 4
12 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4f36 <do_insertfile_void+0x6>
test   $0x800000,%eax
jne    4f50 <do_insertfile_void+0x20>
and    $0x2080,%eax
add    $0xffffff80,%eax
je     4f58 <do_insertfile_void+0x28>
xor    %edi,%edi
jmpq   4f4e <do_insertfile_void+0x1e>
xchg   %ax,%ax
jmpq   4f55 <do_insertfile_void+0x25>
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x0,%edi
callq  4f66 <do_insertfile_void+0x36>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   4f72 <do_insertfile_void+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_insertfile_void(void)
{
    if (((flags[((RESTRICTED) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((RESTRICTED) % (sizeof(unsigned) * 8)))) != 0)) {
 show_restricted_warning();
 return;
    }
    if (((flags[((VIEW_MODE) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((VIEW_MODE) % (sizeof(unsigned) * 8)))) != 0) && !((flags[((MULTIBUFFER) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((MULTIBUFFER) % (sizeof(unsigned) * 8)))) != 0))
 statusbar(gettext("Key invalid in non-multibuffer mode"));
    else
 do_insertfile(
  0
  );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 7
5 7
6 7
7 10
8 10
9 10
10 4
11 4
12 2
13 8
14 8
15 13
16 8
17 8
18 8
<<<sep_out_sample>>>
mov    $0x4,%esi
jmpq   55a <mu_attribute_unset_deleted+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_unset_deleted (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x04);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl (%rdi),%edi
callq  11 <cdio_audio_get_msf_seconds+0x11>
movzbl 0x1(%rbx),%edi
movzbl %al,%ebp
callq  1d <cdio_audio_get_msf_seconds+0x1d>
mov    $0x3c,%edx
add    $0x8,%rsp
movzbl %al,%eax
imul   %edx,%ebp
pop    %rbx
add    %ebp,%eax
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_audio_get_msf_seconds(msf_t *p_msf)
{
  return
    cdio_from_bcd8(p_msf->m)*60 + cdio_from_bcd8(p_msf->s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 5
15 4
16 5
17 5
18 5
<<<sep_out_sample>>>
mov    0x48(%rsi),%edx
mov    0x20(%rsi),%rax
mov    0x30(%rsi),%rdi
test   %edx,%edx
mov    (%rax),%rax
je     148 <copy_pixel_rows+0x38>
sub    $0x1,%edx
lea    0x1(%rdi,%rdx,1),%rcx
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movzbl -0x1(%rax),%edx
add    $0x1,%rdi
cmp    %rcx,%rdi
mov    %dl,-0x1(%rdi)
jne    130 <copy_pixel_rows+0x20>
mov    0x30(%rsi),%rdi
mov    0x18(%rsi),%rcx
mov    0x40(%rsi),%rdx
mov    $0x1,%esi
jmpq   15a <copy_pixel_rows+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
copy_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
   JDIMENSION rows_supplied)
{
  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;
  register char * bufferptr;
  register JSAMPROW ptr;
  register JDIMENSION col;
  ptr = dest->pub.buffer[0];
  bufferptr = dest->iobuffer;
  for (col = dest->samples_per_row; col > 0; col--) {
    *bufferptr++ = (char) (((int) (*ptr++)));
  }
  (void) ((size_t) fwrite((const void *) (dest->iobuffer), (size_t) 1, (size_t) (dest->buffer_width), (dest->pub.output_file)));
}
<<<sep_in_sample>>>
1 10
2 8
3 9
4 10
5 8
6 10
7 10
8 10
9 10
10 11
11 11
12 11
13 10
14 11
15 10
16 10
17 13
18 13
19 13
20 13
21 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4a0 <gl_array_sortedlist_indexof_from_to>
add    $0x8,%rsp
add    $0x1,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_sortedlist_search_from_to (gl_list_t list,
                                    gl_listelement_compar_fn compar,
                                    size_t low, size_t high,
                                    const void *elt)
{
  size_t index =
    gl_array_sortedlist_indexof_from_to (list, compar, low, high, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 5
2 6
3 9
4 8
5 9
6 9
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rsi,%rbx
mov    $0x5310,%esi
sub    $0x10,%rsp
mov    0x18(%rdi),%edi
mov    %rsp,%rdx
movb   $0x1,0x5(%rsp)
callq  11df <get_last_session_linux+0x1f>
test   %eax,%eax
jne    11f0 <get_last_session_linux+0x30>
mov    (%rsp),%eax
mov    %eax,(%rbx)
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
retq   
callq  11f5 <get_last_session_linux+0x35>
mov    (%rax),%edi
callq  11fc <get_last_session_linux+0x3c>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  120b <get_last_session_linux+0x4b>
mov    $0xffffffff,%eax
jmp    11ea <get_last_session_linux+0x2a>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_last_session_linux (void *p_user_data,
                                lsn_t *i_last_session)
{
  const _img_private_t *p_env = p_user_data;
  struct cdrom_multisession ms;
  int i_rc;
  ms.addr_format = 0x01;
  i_rc = ioctl(p_env->gen.fd, 0x5310, &ms);
  if (0 == i_rc) {
    *i_last_session = ms.addr.lba;
    return DRIVER_OP_SUCCESS;
  } else {
    cdio_warn ("ioctl CDROMMULTISESSION failed: %s\n", strerror((*__errno_location ())));
    return DRIVER_OP_ERROR;
  }
}
<<<sep_in_sample>>>
1 3
2 8
3 3
4 8
5 3
6 8
7 8
8 7
9 8
10 9
11 9
12 10
13 10
14 11
15 16
16 16
17 16
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_subname (rec_sex_ast_node_t node)
{
  return node->val.name[1];
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_set_tar_chksum (XFORMAT * xux) { }
<<<sep_in_sample>>>
1 1
2 1
<<<sep_out_sample>>>
test   %rsi,%rsi
lea    (%rdi,%rsi,1),%rax
je     91 <unsunder+0x21>
nopl   0x0(%rax)
cmpb   $0x0,(%rdi)
jne    88 <unsunder+0x18>
movb   $0xa,(%rdi)
add    $0x1,%rdi
cmp    %rax,%rdi
jne    80 <unsunder+0x10>
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unsunder(char *str, size_t true_len)
{
    ((void) (0));
    for (; true_len > 0; true_len--, str++) {
 if (*str == '\0')
     *str = '\n';
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 6
8 4
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
test   %r8,%r8
push   %rbx
mov    %rdi,%rbx
mov    %esi,%edi
mov    %edx,%esi
mov    %ecx,%edx
je     15f0 <xformat_open_archive_by_fd_and_name+0x30>
mov    %r8,%rcx
callq  15d7 <xformat_open_archive_by_fd_and_name+0x17>
test   %rax,%rax
mov    %rax,0x28(%rbx)
je     1600 <xformat_open_archive_by_fd_and_name+0x40>
mov    %rbx,%rdi
callq  80 <open_archive_init>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %esi,%edx
mov    %edi,%esi
mov    %rbx,%rdi
pop    %rbx
jmpq   15fd <xformat_open_archive_by_fd_and_name+0x3d>
nopl   (%rax)
mov    $0xffffffff,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_open_archive_by_fd_and_name(XFORMAT * xux, int fd, int flags, mode_t mode, char * name)
{
 ;
 if (name == ((void *)0))
  return xformat_open_archive_by_fd(xux, fd, flags, mode);
 xux->swvarfsM = swvarfs_opendup_with_name(fd, flags, mode, name);
 if (xux->swvarfsM == ((void *)0)) return -1;
 open_archive_init(xux);
 return 0;
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 2
5 2
6 2
7 4
8 6
9 6
10 7
11 6
12 7
13 8
14 8
15 9
16 10
17 10
18 10
19 5
20 5
21 5
22 10
23 5
24 5
25 7
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  598 <_grecs_simple_list_create+0x8>
test   %ebx,%ebx
je     5a4 <_grecs_simple_list_create+0x14>
movq   $0x0,0x20(%rax)
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_grecs_simple_list_create(int dispose)
{
 struct grecs_list *lp = grecs_list_create();
 if (dispose)
  lp->free_entry = listel_dispose;
 return lp;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rdi
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
retq   
<<<sep_in_sample>>>
__rtextassign (__txtvp t1x, __txtvp t2x)
{
  *t1x = *t2x;
  return (t1x);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 5
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  145 <make_directory+0x15>
mov    $0x60,%edi
mov    %rax,%rbp
callq  152 <make_directory+0x22>
cmp    $0x1,%rbp
mov    %rax,%rbx
movq   $0x0,(%rax)
movq   $0x0,0x30(%rax)
movq   $0x0,0x28(%rax)
movq   $0x0,0x40(%rax)
movl   $0x0,0x3c(%rax)
jbe    18f <make_directory+0x5f>
cmpb   $0x2f,-0x1(%r12,%rbp,1)
lea    -0x1(%rbp),%rax
cmove  %rax,%rbp
lea    0x1(%rbp),%rdi
callq  198 <make_directory+0x68>
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
mov    %rax,0x58(%rbx)
callq  1aa <make_directory+0x7a>
mov    %r13,0x50(%rbx)
movb   $0x0,(%rax,%rbp,1)
mov    %rbx,%rax
movq   $0x0,0x48(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_directory (const char *name, char *caname)
{
  size_t namelen = strlen (name);
  struct directory *directory = xmalloc (sizeof (*directory));
  directory->next = ((void *)0);
  directory->dump = directory->idump = ((void *)0);
  directory->orig = ((void *)0);
  directory->flags = 0;
  if (namelen > 1 && ((name[namelen - 1]) == '/'))
    namelen--;
  directory->name = xmalloc (namelen + 1);
  memcpy (directory->name, name, namelen);
  directory->name[namelen] = 0;
  directory->caname = caname;
  directory->tagfile = ((void *)0);
  return directory;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 4
12 9
13 4
14 5
15 6
16 6
17 7
18 8
19 9
20 10
21 9
22 10
23 11
24 11
25 12
26 12
27 12
28 11
29 12
30 14
31 13
32 17
33 15
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
test   %rdx,%rdx
xorpd  %xmm0,%xmm0
je     3a6 <gsl_stats_char_median_from_sorted_data+0x36>
lea    -0x1(%rdx),%rax
shr    %rdx
shr    %rax
cmp    %rdx,%rax
je     3b0 <gsl_stats_char_median_from_sorted_data+0x40>
imul   %rsi,%rax
imul   %rsi,%rdx
movsbl (%rdi,%rax,1),%ecx
movsbl (%rdi,%rdx,1),%eax
add    %ecx,%eax
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 3a6 <gsl_stats_char_median_from_sorted_data+0x36>
repz retq 
nopl   0x0(%rax,%rax,1)
imul   %rsi,%rax
movsbl (%rdi,%rax,1),%eax
cvtsi2sd %eax,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_char_median_from_sorted_data (const char sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 6
5 7
6 6
7 10
8 10
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 19
17 19
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmpq   $0x0,0x0(%rip)        # 97c <grecs_preproc_add_include_dir+0xc>
je     9a0 <grecs_preproc_add_include_dir+0x30>
callq  983 <grecs_preproc_add_include_dir+0x13>
mov    0x0(%rip),%rdi        # 98a <grecs_preproc_add_include_dir+0x1a>
mov    %rax,%rsi
add    $0x18,%rsp
jmpq   996 <grecs_preproc_add_include_dir+0x26>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rdi,0x8(%rsp)
callq  9aa <grecs_preproc_add_include_dir+0x3a>
mov    0x8(%rsp),%rdi
mov    %rax,0x0(%rip)        # 9b6 <grecs_preproc_add_include_dir+0x46>
movq   $0x0,0x20(%rax)
jmp    97e <grecs_preproc_add_include_dir+0xe>
<<<sep_in_sample>>>
grecs_preproc_add_include_dir(char *dir)
{
 if (!grecs_usr_include_path) {
  grecs_usr_include_path = grecs_list_create();
  grecs_usr_include_path->free_entry = incl_free;
 }
 grecs_list_append(grecs_usr_include_path, grecs_strdup(dir));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 7
5 7
6 7
7 8
8 7
9 7
10 7
11 4
12 5
13 4
14 5
15 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    0x10(%rdi),%esi
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
add    %edx,%esi
add    $0x1,%esi
callq  50d <taru_append_to_header_buffer+0x1d>
mov    0x8(%rbx),%rdi
callq  516 <taru_append_to_header_buffer+0x26>
movslq 0x10(%rbx),%rdx
mov    %r12,%rsi
lea    (%rax,%rdx,1),%rdi
movslq %ebp,%rdx
callq  529 <taru_append_to_header_buffer+0x39>
add    %ebp,0x10(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_append_to_header_buffer(TARU * taru, char * buf, int len)
{
 char * s;
 strob_set_length(taru->headerM, taru->header_lengthM + len + 1);
 s = strob_str(taru->headerM);
 memcpy(s + taru->header_lengthM, buf, len);
 taru->header_lengthM += len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 7
20 8
21 8
22 8
23 8
24 8
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 836 <yyset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
xor    %r8d,%r8d
movl   $0x0,(%rsp)
xor    %ecx,%ecx
callq  f98 <getopt+0x18>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getopt (int argc, char *const *argv, const char *optstring)
{
  return _getopt_internal (argc, argv, optstring,
      (const struct option *) 0,
      (int *) 0,
      0, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 7
8 7
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
mov    %r8,%rdx
push   %rbx
mov    %r8,%rbx
sub    $0x10,%rsp
callq  1413 <gsl_stats_long_covariance+0x23>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
movsd  %xmm0,0x8(%rsp)
callq  1427 <gsl_stats_long_covariance+0x37>
movsd  0x8(%rsp),%xmm2
add    $0x10,%rsp
mov    %rbx,%r8
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdi
mov    %r14,%rsi
pop    %r13
pop    %r14
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
jmpq   1455 <gsl_stats_long_covariance+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_covariance (const long data1[], const size_t stride1,
                                const long data2[], const size_t stride2,
                                const size_t n)
{
  const double mean1 = gsl_stats_long_mean (data1, stride1, n);
  const double mean2 = gsl_stats_long_mean (data2, stride2, n);
  return gsl_stats_long_covariance_m(data1, stride1,
                                          data2, stride2,
                                          n,
                                          mean1, mean2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 5
14 6
15 6
16 6
17 5
18 6
19 7
20 11
21 7
22 7
23 7
24 11
25 11
26 11
27 7
28 7
29 11
30 11
31 6
32 7
33 7
34 7
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   66d <savedir_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
savedir_error (char const *name)
{
  call_arg_error ("savedir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     547 <mu_list_destroy+0x77>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     547 <mu_list_destroy+0x77>
mov    0x20(%rbp),%rdi
callq  4f3 <mu_list_destroy+0x23>
mov    0x8(%rbp),%rbx
cmp    %rbp,%rbx
jne    503 <mu_list_destroy+0x33>
jmp    522 <mu_list_destroy+0x52>
xchg   %ax,%ax
mov    %r12,%rbx
mov    0x30(%rbp),%rax
mov    0x8(%rbx),%r12
test   %rax,%rax
je     515 <mu_list_destroy+0x45>
mov    (%rbx),%rdi
callq  *%rax
mov    %rbx,%rdi
callq  51d <mu_list_destroy+0x4d>
cmp    %rbp,%r12
jne    500 <mu_list_destroy+0x30>
mov    0x20(%rbp),%rdi
callq  52b <mu_list_destroy+0x5b>
lea    0x20(%rbp),%rdi
mov    %rbp,%rsi
callq  537 <mu_list_destroy+0x67>
mov    %rbp,%rdi
callq  53f <mu_list_destroy+0x6f>
movq   $0x0,0x0(%r13)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_destroy (mu_list_t *plist)
{
  if (plist && *plist)
    {
      mu_list_t list = *plist;
      struct list_data *current;
      struct list_data *previous;
      mu_monitor_wrlock (list->monitor);
      for (current = list->head.next; current != &list->head;)
 {
   previous = current;
   current = current->next;
   do { if ((list)->destroy_item) (list)->destroy_item ((previous)->item); } while (0);
   free (previous);
 }
      mu_monitor_unlock (list->monitor);
      mu_monitor_destroy (&list->monitor, list);
      free (list);
      *plist = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 12
20 13
21 12
22 13
23 13
24 13
25 13
26 14
27 14
28 9
29 9
30 16
31 16
32 17
33 17
34 17
35 18
36 18
37 19
38 21
39 21
40 21
41 21
42 21
43 21
44 21
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 808 <stop_children+0x8>
je     852 <stop_children+0x52>
push   %rbx
mov    $0xf,%edi
xor    %ebx,%ebx
callq  817 <stop_children+0x17>
mov    0x0(%rip),%eax        # 81d <stop_children+0x1d>
test   %eax,%eax
jne    83d <stop_children+0x3d>
jmp    858 <stop_children+0x58>
nopl   0x0(%rax,%rax,1)
mov    $0x1,%edi
add    $0x1,%ebx
callq  835 <stop_children+0x35>
cmp    0x0(%rip),%ebx        # 83b <stop_children+0x3b>
jae    858 <stop_children+0x58>
mov    $0x1,%edi
callq  847 <stop_children+0x47>
cmpq   $0x0,0x0(%rip)        # 84f <stop_children+0x4f>
jne    828 <stop_children+0x28>
pop    %rbx
repz retq 
nopl   0x0(%rax)
pop    %rbx
mov    $0x9,%edi
jmpq   863 <stop_children+0x63>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stop_children()
{
    int i;
    if (!childtab)
 return;
    stop_all(15);
    for (i = 0; i < shutdown_timeout; i++) {
 cleanup_children(1);
 if (num_children == 0)
     return;
 sleep(1);
    }
    stop_all(9);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 7
6 6
7 7
8 7
9 7
10 7
11 7
12 11
13 7
14 11
15 7
16 7
17 8
18 8
19 9
20 9
21 14
22 14
23 14
24 14
25 13
26 13
27 13
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0xc(%rsp),%rdi
callq  12 <printf_frexp+0x12>
mov    0xc(%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,0xc(%rsp)
jge    38 <printf_frexp+0x38>
lea    0x3fd(%rdx),%edi
callq  33 <printf_frexp+0x33>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 1700 <xtrace_print_case_command_head+0x10>
test   %rbx,%rbx
cmove  0x0(%rip),%rbx        # 170b <xtrace_print_case_command_head+0x1b>
mov    %rbx,0x0(%rip)        # 1712 <xtrace_print_case_command_head+0x22>
callq  1717 <xtrace_print_case_command_head+0x27>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1722 <xtrace_print_case_command_head+0x32>
mov    0x8(%rbp),%rax
mov    0x0(%rip),%rdi        # 172d <xtrace_print_case_command_head+0x3d>
mov    $0x0,%esi
mov    (%rax),%rdx
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   1742 <xtrace_print_case_command_head+0x52>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xtrace_print_case_command_head (case_command)
     CASE_COM *case_command;
{
  xtrace_fp = (xtrace_fp ? xtrace_fp : stderr);
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 6
19 7
20 7
21 6
22 6
<<<sep_out_sample>>>
push   %r14
test   %rdi,%rdi
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
je     492 <assoc_dequote+0x82>
mov    0xc(%rdi),%edx
test   %edx,%edx
je     492 <assoc_dequote+0x82>
mov    0x8(%rdi),%eax
xor    %r13d,%r13d
xor    %r12d,%r12d
test   %eax,%eax
jle    486 <assoc_dequote+0x76>
nopl   0x0(%rax)
mov    (%r14),%rax
mov    (%rax,%r13,1),%rbx
test   %rbx,%rbx
je     478 <assoc_dequote+0x68>
nopl   0x0(%rax)
mov    0x10(%rbx),%rdi
callq  451 <assoc_dequote+0x41>
mov    0x10(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     46c <assoc_dequote+0x5c>
mov    $0xce,%edx
mov    $0x0,%esi
callq  46c <assoc_dequote+0x5c>
mov    %rbp,0x10(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    448 <assoc_dequote+0x38>
add    $0x1,%r12d
add    $0x8,%r13
cmp    %r12d,0x8(%r14)
jg     438 <assoc_dequote+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14,%rax
pop    %r14
retq   
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   (%rax)
<<<sep_in_sample>>>
assoc_dequote (h)
     HASH_TABLE *h;
{
  int i;
  BUCKET_CONTENTS *tlist;
  char *t;
  if (h == 0 || ((h)->nentries == 0))
    return ((HASH_TABLE *)((void *)0));
  for (i = 0; i < h->nbuckets; i++)
    for (tlist = ((h && (i < h->nbuckets)) ? h->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); tlist; tlist = tlist->next)
      {
 t = dequote_string ((char *)tlist->data);
 do { if (tlist->data) sh_xfree((tlist->data), "assoc.c", 206); } while (0);
 tlist->data = t;
      }
  return h;
}
<<<sep_in_sample>>>
1 3
2 7
3 3
4 3
5 3
6 3
7 3
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 13
26 12
27 13
28 13
29 13
30 13
31 13
32 14
33 10
34 10
35 10
36 9
37 9
38 9
39 9
40 17
41 17
42 17
43 17
44 9
45 17
46 17
47 17
48 17
49 17
50 17
51 8
52 17
53 17
54 17
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mulsd  0x18(%rdi),%xmm0
lea    0x8(%rsp),%rdi
mov    %rsp,%rsi
callq  3fe <DISComputeDRMatrix+0x1e>
movsd  (%rsp),%xmm5
lea    0xa0(%rbp),%rsi
movsd  0x0(%rip),%xmm2        # 412 <DISComputeDRMatrix+0x32>
xor    %r8d,%r8d
xorpd  %xmm4,%xmm4
xor    %ecx,%ecx
subsd  %xmm5,%xmm2
movsd  0x8(%rsp),%xmm3
lea    (%rsi,%r8,1),%rdx
lea    (%rbx,%r8,1),%rdi
xor    %eax,%eax
cmp    %eax,%ecx
je     4b7 <DISComputeDRMatrix+0xd7>
movapd %xmm4,%xmm0
movsd  (%rdx),%xmm1
add    $0x8,%rdx
mulsd  %xmm3,%xmm1
subsd  %xmm1,%xmm0
movsd  0x78(%rdx),%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
movsd  %xmm0,(%rdi,%rax,8)
add    $0x1,%rax
cmp    $0x3,%rax
jne    42f <DISComputeDRMatrix+0x4f>
add    $0x1,%ecx
add    $0x20,%r8
cmp    $0x3,%ecx
jne    425 <DISComputeDRMatrix+0x45>
movsd  0x0(%rip),%xmm6        # 47b <DISComputeDRMatrix+0x9b>
movq   $0x0,0x58(%rbx)
movq   $0x0,0x38(%rbx)
movq   $0x0,0x18(%rbx)
movq   $0x0,0x70(%rbx)
movq   $0x0,0x68(%rbx)
movsd  %xmm6,0x78(%rbx)
movq   $0x0,0x60(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
movapd %xmm5,%xmm0
jmpq   43b <DISComputeDRMatrix+0x5b>
<<<sep_in_sample>>>
DISComputeDRMatrix(dis_dr_parameters * dr, double dT, VMatrix * m)
{
 double theta = dr->omega * dT;
 double cosTheta = cos(theta);
 double sinTheta = sin(theta);
 double Icos, x = (1.0 - cosTheta);
 int i, j;
 for (i = 0; i < 3; ++i) {
  for (j = 0; j < 3; ++j) {
   if (i == j) {
    Icos = cosTheta;
   }
   else {
    Icos = 0.0;
   }
   m->m[i][j] = Icos -
    dr->skew.m[i][j] * sinTheta +
    dr->aat.m[i][j] * x;
  }
 }
 m->m[0][3] = m->m[1][3] = m->m[2][3] = 0.0;
 m->m[3][0] = m->m[3][1] = m->m[3][2] = 0.0;
 m->m[3][3] = 1.0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 6
13 6
14 14
15 8
16 6
17 6
18 2
19 2
20 2
21 10
22 10
23 14
24 17
25 17
26 17
27 16
28 18
29 18
30 17
31 16
32 16
33 9
34 9
35 8
36 8
37 8
38 8
39 23
40 21
41 21
42 21
43 22
44 22
45 23
46 22
47 24
48 24
49 24
50 24
51 11
52 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4c0 <gsasl_client_callback_passcode_get+0x10>
mov    0x48(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_passcode_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_passcode : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    0x20(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strob_get_fill_char(STROB * strb)
{
 return strb->fill_charM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   20 <reset_or_restore_signal_handlers>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reset_signal_handlers ()
{
  reset_or_restore_signal_handlers (reset_signal);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x40(%rdi),%rdi
test   %rdi,%rdi
je     7f0 <dicod_free_database+0x30>
mov    0x50(%rbx),%rax
mov    0x10(%rax),%rax
mov    0x18(%rax),%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     7ea <dicod_free_database+0x2a>
callq  *%rdx
movq   $0x0,0x40(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_free_database(dicod_database_t *dp)
{
    int rc = 0;
    if (dp->mod_handle) {
 dicod_module_instance_t *inst = dp->instance;
 if (inst->module->dico_free_db) {
     rc = inst->module->dico_free_db(dp->mod_handle);
     dp->mod_handle = ((void *)0);
 }
    }
    return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 6
8 6
9 3
10 6
11 6
12 7
13 8
14 12
15 12
16 12
17 3
18 12
19 12
20 12
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     2eb <error+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
xor    %esi,%esi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  31e <error+0x8e>
add    $0xd8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
error (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vdiag (fmt, ((void *)0), ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 5
19 5
20 4
21 4
22 4
23 4
24 4
25 5
26 7
27 7
28 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  16ec <gsl_sf_transport_5+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1700 <gsl_sf_transport_5+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x1eb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1716 <gsl_sf_transport_5+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_transport_5(const double x)
{
  gsl_sf_result result; int status = gsl_sf_transport_5_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_transport_5_e(x, &result)", "transport.c", 491, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     b8 <xmalloc+0x38>
mov    0x0(%rip),%eax        # 94 <xmalloc+0x14>
test   %eax,%eax
je     ce <xmalloc+0x4e>
mov    %rbx,%rdi
callq  a0 <xmalloc+0x20>
test   %rax,%rax
mov    %rax,%rbp
je     f6 <xmalloc+0x76>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
mov    $0x0,%edi
callq  c4 <xmalloc+0x44>
mov    0x0(%rip),%eax        # ca <xmalloc+0x4a>
test   %eax,%eax
jne    98 <xmalloc+0x18>
xor    %edi,%edi
callq  d5 <xmalloc+0x55>
mov    %rbx,%rdi
mov    %rax,0x0(%rip)        # df <xmalloc+0x5f>
movl   $0x1,0x0(%rip)        # e9 <xmalloc+0x69>
callq  ee <xmalloc+0x6e>
test   %rax,%rax
mov    %rax,%rbp
jne    a8 <xmalloc+0x28>
mov    %rbx,%rsi
xor    %eax,%eax
mov    $0x0,%edi
callq  40 <allocerr>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
xmalloc (bytes)
     size_t bytes;
{
  void * temp;
  if (bytes == 0)
    internal_warning("xmalloc: size argument is 0");
  do { if (brkfound == 0) { lbreak = (void *)sbrk (0); brkfound++; } } while (0);
  temp = malloc (bytes);
  if (temp == 0)
    allocerr ("xmalloc", bytes);
  return (temp);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 8
11 8
12 9
13 8
14 9
15 12
16 12
17 12
18 12
19 12
20 12
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 7
31 7
32 8
33 9
34 8
35 9
36 10
37 10
38 10
39 10
40 12
41 12
42 12
43 12
44 12
45 12
<<<sep_out_sample>>>
movsbl (%rsi),%ecx
test   %cl,%cl
je     150 <compvar+0x60>
movzbl (%rdi),%eax
test   %al,%al
je     160 <compvar+0x70>
movsbl %al,%r9d
movsbl %cl,%r8d
sub    %r8d,%r9d
jne    16c <compvar+0x7c>
cmp    $0x3d,%al
jne    143 <compvar+0x53>
jmp    148 <compvar+0x58>
nopl   0x0(%rax)
add    $0x1,%rsi
movsbl (%rsi),%ecx
add    $0x1,%rdi
test   %cl,%cl
je     150 <compvar+0x60>
movzbl (%rdi),%r8d
test   %r8b,%r8b
je     160 <compvar+0x70>
movsbl %r8b,%eax
movsbl %cl,%r9d
sub    %r9d,%eax
jne    14a <compvar+0x5a>
cmp    $0x3d,%r8b
je     148 <compvar+0x58>
cmp    $0x3d,%cl
jne    118 <compvar+0x28>
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
movsbl (%rdi),%eax
xor    %ecx,%ecx
sub    %ecx,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
test   %edx,%edx
jne    14a <compvar+0x5a>
movsbl (%rdi),%eax
sub    %ecx,%eax
retq   
mov    %r9d,%eax
retq   
<<<sep_in_sample>>>
compvar(char *enva, char *envb, int lazy)
{
 int c;
 for (; *envb; enva++, envb++) {
  if (*enva == 0) {
   if (lazy)
    return 0;
   break;
  }
  if (c = *enva - *envb)
   return c;
  if (*enva == '=' || *envb == '=')
   return c;
 }
 return *enva - *envb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 10
8 10
9 10
10 10
11 12
12 12
13 12
14 12
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 10
24 10
25 10
26 10
27 12
28 12
29 12
30 12
31 12
32 16
33 16
34 15
35 4
36 15
37 15
38 15
39 15
40 6
41 6
42 15
43 15
44 15
45 10
46 10
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
movzwl %r9w,%ebp
push   %rbx
sub    $0x18,%rsp
cmp    $0xffff,%r9w
je     14f <VdbeFillRectangle+0x7f>
cmp    0x2288(%rdi),%rbp
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%r13d
mov    %ecx,%r14d
mov    0x168(%rdi),%r15
je     12c <VdbeFillRectangle+0x5c>
mov    0x170(%rdi),%rsi
mov    0x148(%rdi),%rdi
mov    %rbp,%rdx
mov    %r8d,0xc(%rsp)
callq  120 <VdbeFillRectangle+0x50>
mov    0xc(%rsp),%r8d
mov    %rbp,0x2288(%rbx)
mov    0x170(%rbx),%rdx
mov    0x148(%rbx),%rdi
mov    %r14d,%r9d
mov    %r8d,(%rsp)
mov    %r12d,%ecx
mov    %r13d,%r8d
mov    %r15,%rsi
callq  14f <VdbeFillRectangle+0x7f>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
VdbeFillRectangle(Viewport *v,
    int x, int y, int w, int h, Color color)
{
  Drawable d;
  if (color != 0xffff) {
    d = (Drawable) v->dbeDrawable;
    if (color != v->lastPixel) {
      XSetForeground (v->dpy, v->gc, color);
      v->lastPixel = color;
    }
    XFillRectangle(v->dpy, d, v->gc, x, y, w, h);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 6
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
callq  472 <_env_msg_date+0x12>
mov    %rax,%rdi
callq  47a <_env_msg_date+0x1a>
mov    %rax,%r8
mov    $0x16,%eax
test   %r8,%r8
je     4b0 <_env_msg_date+0x50>
mov    0x8(%r8),%rsi
test   %rsi,%rsi
je     4b0 <_env_msg_date+0x50>
test   %rbx,%rbx
je     4b8 <_env_msg_date+0x58>
mov    %rbp,%rdx
mov    %rbx,%rdi
callq  4a0 <_env_msg_date+0x40>
test   %r12,%r12
movb   $0x0,-0x1(%rbx,%rbp,1)
je     4d0 <_env_msg_date+0x70>
mov    %rbp,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
test   %r12,%r12
je     4b0 <_env_msg_date+0x50>
mov    %rsi,%rdi
callq  4c5 <_env_msg_date+0x65>
pop    %rbx
pop    %rbp
mov    %rax,(%r12)
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
jmp    4b0 <_env_msg_date+0x50>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_env_msg_date (mu_envelope_t envelope, char *buf, size_t len, size_t *pnwrite)
{
  mu_message_t msg = mu_envelope_get_owner (envelope);
  struct _mu_rfc822_message *env = mu_message_get_owner (msg);
  if (!env || !env->date)
    return 22;
  if (buf)
    {
      strncpy (buf, env->date, len);
      buf[len-1] = 0;
      if (pnwrite)
 *pnwrite = len;
    }
  else if (!pnwrite)
    return 22;
  else
    *pnwrite = strlen (env->date);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 6
12 5
13 5
14 5
15 5
16 5
17 7
18 7
19 9
20 9
21 9
22 11
23 10
24 11
25 12
26 18
27 19
28 19
29 19
30 19
31 19
32 14
33 14
34 17
35 17
36 19
37 19
38 17
39 18
40 19
41 19
42 18
43 18
44 18
<<<sep_out_sample>>>
push   %r12
lea    0x180(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  1f <osip_message_get_header+0x1f>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    38 <osip_message_get_header+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  32 <osip_message_get_header+0x32>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
osip_message_get_header (const osip_message_t * sip, int pos, osip_header_t ** dest)
{
  *dest = ((void *)0);
  if (osip_list_size (&sip->headers) <= pos)
    return -1;
  *dest = (osip_header_t *) osip_list_get (&sip->headers, pos);
  return pos;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 2
8 3
9 4
10 4
11 5
12 4
13 6
14 6
15 6
16 7
17 6
18 8
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
test   %rsi,%rsi
je     7d8 <api_sym_lookup_scalar+0x18>
test   %rcx,%rcx
je     7d8 <api_sym_lookup_scalar+0x18>
cmpl   $0x4,0x40(%rsi)
je     7e0 <api_sym_lookup_scalar+0x20>
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
mov    %rcx,0x8(%rsp)
mov    %edx,0x4(%rsp)
callq  7f0 <api_sym_lookup_scalar+0x30>
mov    0x8(%rsp),%rcx
mov    0x4(%rsp),%edx
add    $0x10,%rsp
mov    %rbx,%rdi
pop    %rbx
mov    %rcx,%rsi
jmpq   0 <node_to_awk_value>
nopl   0x0(%rax)
<<<sep_in_sample>>>
api_sym_lookup_scalar(awk_ext_id_t id,
   awk_scalar_t cookie,
   awk_valtype_t wanted,
   awk_value_t *result)
{
 NODE *node = (NODE *) cookie;
 if (node == ((void *)0)
     || result == ((void *)0)
     || node->type != Node_var)
  return awk_false;
 update_global_values();
 return node_to_awk_value(node, result, wanted);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 7
5 7
6 7
7 7
8 9
9 9
10 13
11 13
12 13
13 13
14 11
15 11
16 11
17 11
18 12
19 12
20 13
21 12
22 13
23 12
24 12
25 12
<<<sep_out_sample>>>
test   %esi,%esi
jle    b00 <lm_wont+0x10>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   b0a <lm_wont+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_wont (unsigned char *cmd, int len)
{
  if (len < 1)
    {
             printf ("lm_wont: no command!!!\n");
      return;
    }
  switch (cmd[0])
    {
    case 2:
    default:
      return;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <emalloc+0x9>
test   %rax,%rax
je     43 <emalloc+0x13>
add    $0x8,%rsp
retq   
callq  48 <emalloc+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
emalloc (size_t size)
{
  void *p = malloc (size);
  if (!p)
    ealloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
mov    %rsi,%rbx
mov    $0x28,%esi
sub    $0x8,%rsp
callq  ecb <wsnode_new+0x1b>
test   %rax,%rax
je     ee0 <wsnode_new+0x30>
mov    %rax,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   e10 <_wsplt_nomem>
xchg   %ax,%ax
<<<sep_in_sample>>>
wsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)
{
  struct wordsplit_node *node = calloc (1, sizeof (*node));
  if (!node)
    return _wsplt_nomem (wsp);
  *pnode = node;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 3
9 4
10 4
11 6
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 5
20 8
21 8
22 5
23 5
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
jne    1421 <var_lookup+0x21>
jmp    1440 <var_lookup+0x40>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
je     1440 <var_lookup+0x40>
mov    0x20(%rbx),%rsi
mov    %rbp,%rdi
callq  960 <hash_lookup>
test   %rax,%rax
je     1418 <var_lookup+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
var_lookup (name, vcontext)
     const char *name;
     VAR_CONTEXT *vcontext;
{
  VAR_CONTEXT *vc;
  SHELL_VAR *v;
  v = (SHELL_VAR *)((void *)0);
  for (vc = vcontext; vc; vc = vc->down)
    if (v = hash_lookup (name, vc->table))
      break;
  return v;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 7
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     1a0 <SetEquation+0x30>
test   %rsi,%rsi
mov    %rsi,%rbp
je     1a0 <SetEquation+0x30>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     194 <SetEquation+0x24>
callq  194 <SetEquation+0x24>
mov    %rbp,%rdi
callq  19c <SetEquation+0x2c>
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
SetEquation (PVMMAPSTRCT pvm, PSTR szEqn)
{
  if (!pvm || !szEqn)
    return;
  if (pvm->szEqn)
    free (pvm->szEqn);
  pvm->szEqn = CopyString (szEqn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 6
14 7
15 7
16 7
17 8
18 8
19 8
20 8
21 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     610 <make_uppercase+0x40>
movzbl (%rdi),%edx
mov    %rdi,%rbx
test   %dl,%dl
je     606 <make_uppercase+0x36>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%edi
add    $0x1,%rbx
callq  5fc <make_uppercase+0x2c>
mov    %al,-0x1(%rbx)
movzbl (%rbx),%edx
test   %dl,%dl
jne    5f0 <make_uppercase+0x20>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    609 <make_uppercase+0x39>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_uppercase (char *s)
{
  unsigned char *p;
  if (!s)
    return ((void *)0);
  for (p = (unsigned char*) s; *p; p++)
    *p = toupper (*p);
  return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 7
16 6
17 6
18 6
19 5
20 9
21 9
22 9
23 9
24 5
25 5
26 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x20(%rdi),%rdi
callq  bbd <free_state+0xd>
mov    0x30(%rbx),%rdi
callq  bc6 <free_state+0x16>
mov    0x38(%rbx),%rax
lea    0x8(%rbx),%rdx
cmp    %rdx,%rax
je     be5 <free_state+0x35>
mov    0x8(%rax),%rdi
callq  bdc <free_state+0x2c>
mov    0x38(%rbx),%rdi
callq  be5 <free_state+0x35>
mov    0x10(%rbx),%rdi
callq  bee <free_state+0x3e>
mov    0x48(%rbx),%rdi
callq  bf7 <free_state+0x47>
mov    0x40(%rbx),%rdi
callq  c00 <free_state+0x50>
mov    %rbx,%rdi
pop    %rbx
jmpq   c09 <free_state+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
free_state (re_dfastate_t *state)
{
  free ((&state->non_eps_nodes)->elems);
  free ((&state->inveclosure)->elems);
  if (state->entrance_nodes != &state->nodes)
    {
      free ((state->entrance_nodes)->elems);
      free (state->entrance_nodes);
    }
  free ((&state->nodes)->elems);
  free (state->word_trtable);
  free (state->trtable);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 8
14 8
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 14
23 13
24 13
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_legendre_P1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_legendre_P1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_legendre_P1_e(x, &result)", "legendre_poly.c", 751, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
test   %r8,%r8
mov    (%rdx),%r10d
push   %rbx
je     fde <gsl_stats_uint_minmax_index+0x4e>
shl    $0x2,%rcx
mov    %r10d,%r11d
xor    %ebx,%ebx
xor    %ebp,%ebp
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%r9d
cmp    %r10d,%r9d
jae    fbe <gsl_stats_uint_minmax_index+0x2e>
mov    %rax,%rbp
mov    %r9d,%r10d
cmp    %r11d,%r9d
jbe    fc9 <gsl_stats_uint_minmax_index+0x39>
mov    %rax,%rbx
mov    %r9d,%r11d
add    $0x1,%rax
add    %rcx,%rdx
cmp    %r8,%rax
jne    fb0 <gsl_stats_uint_minmax_index+0x20>
mov    %rbp,(%rdi)
mov    %rbx,(%rsi)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    fd5 <gsl_stats_uint_minmax_index+0x45>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uint_minmax_index (size_t * min_index_out,
                                   size_t * max_index_out, const unsigned int data[],
                                   const size_t stride, const size_t n)
{
  unsigned int min = data[0 * stride];
  unsigned int max = data[0 * stride];
  size_t i, min_index = 0, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned int xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  *min_index_out = min_index;
  *max_index_out = max_index;
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 4
5 8
6 8
7 6
8 7
9 7
10 8
11 8
12 10
13 11
14 11
15 11
16 11
17 16
18 16
19 16
20 16
21 8
22 8
23 8
24 8
25 22
26 23
27 24
28 24
29 24
30 7
31 7
32 7
33 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmpq   $0x0,0x0(%rip)        # 97c <grecs_preproc_add_include_dir+0xc>
je     9a0 <grecs_preproc_add_include_dir+0x30>
callq  983 <grecs_preproc_add_include_dir+0x13>
mov    0x0(%rip),%rdi        # 98a <grecs_preproc_add_include_dir+0x1a>
mov    %rax,%rsi
add    $0x18,%rsp
jmpq   996 <grecs_preproc_add_include_dir+0x26>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rdi,0x8(%rsp)
callq  9aa <grecs_preproc_add_include_dir+0x3a>
mov    0x8(%rsp),%rdi
mov    %rax,0x0(%rip)        # 9b6 <grecs_preproc_add_include_dir+0x46>
movq   $0x0,0x20(%rax)
jmp    97e <grecs_preproc_add_include_dir+0xe>
<<<sep_in_sample>>>
grecs_preproc_add_include_dir(char *dir)
{
 if (!grecs_usr_include_path) {
  grecs_usr_include_path = grecs_list_create();
  grecs_usr_include_path->free_entry = incl_free;
 }
 grecs_list_append(grecs_usr_include_path, grecs_strdup(dir));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 7
5 7
6 7
7 8
8 7
9 7
10 7
11 4
12 5
13 4
14 5
15 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6c9 <sdp_message_b_bwtype_get+0x9>
test   %rax,%rax
je     6e0 <sdp_message_b_bwtype_get+0x20>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    6d1 <sdp_message_b_bwtype_get+0x11>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_b_bwtype_get (sdp_message_t * sdp, int pos_media, int pos)
{
  sdp_bandwidth_t *band = sdp_message_bandwidth_get (sdp, pos_media, pos);
  if (band == ((void *)0))
    return ((void *)0);
  return band->b_bwtype;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 7
7 7
8 7
9 5
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%ecx
test   %ecx,%ecx
jne    bd <grecs_tree_join+0x1d>
mov    (%rsi),%edx
mov    %rsi,%rbp
test   %edx,%edx
je     c8 <grecs_tree_join+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x30(%rsi),%rsi
mov    $0x1,%edx
callq  d6 <grecs_tree_join+0x36>
mov    0x30(%rbp),%rdi
test   %rdi,%rdi
mov    %rdi,%rax
je     f5 <grecs_tree_join+0x55>
nopw   0x0(%rax,%rax,1)
mov    %rbx,0x28(%rax)
mov    0x38(%rax),%rax
test   %rax,%rax
jne    e8 <grecs_tree_join+0x48>
cmpq   $0x0,0x70(%rbp)
je     130 <grecs_tree_join+0x90>
mov    0x70(%rbx),%rdx
mov    $0x0,%esi
callq  10a <grecs_tree_join+0x6a>
mov    0x70(%rbp),%rdi
callq  113 <grecs_tree_join+0x73>
movq   $0x0,0x70(%rbp)
movq   $0x0,0x30(%rbp)
add    $0x8,%rsp
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
movq   $0x0,0x70(%rbx)
jmp    113 <grecs_tree_join+0x73>
<<<sep_in_sample>>>
grecs_tree_join(struct grecs_node *dst, struct grecs_node *src)
{
 struct grecs_node *p;
 if (dst->type != grecs_node_root || src->type != grecs_node_root)
  return 1;
 grecs_node_bind(dst, src->down, 1);
 for (p = src->down; p; p = p->next)
  p->up = dst;
 if (!src->v.texttab) {
  dst->v.texttab = src->v.texttab;
 } else {
  grecs_tree_recurse(src->down, reset_locus, dst->v.texttab);
  grecs_symtab_free(src->v.texttab);
 }
 src->v.texttab = ((void *)0);
 src->down = ((void *)0);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 18
14 18
15 18
16 18
17 18
18 6
19 6
20 6
21 7
22 7
23 7
24 7
25 7
26 8
27 7
28 7
29 7
30 9
31 9
32 12
33 12
34 12
35 13
36 13
37 15
38 16
39 18
40 18
41 17
42 18
43 18
44 18
45 10
46 10
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    $0xffffffffffffffff,%rdx
mov    %esi,%ecx
shr    $0x6,%rax
shl    %cl,%rdx
lea    (%rdi,%rax,8),%r8
and    (%r8),%rdx
lea    0x8(%r8),%rax
jne    2d <__gmpn_scan1+0x2d>
add    $0x8,%rax
mov    -0x8(%rax),%rdx
test   %rdx,%rdx
je     20 <__gmpn_scan1+0x20>
bsf    %rdx,%rdx
sub    %rdi,%rax
movslq %edx,%rdx
lea    -0x40(%rdx,%rax,8),%rax
retq   
<<<sep_in_sample>>>
__gmpn_scan1 (mp_srcptr up, mp_bitcnt_t starting_bit)
{
  mp_size_t starting_word;
  mp_limb_t alimb;
  int cnt;
  mp_srcptr p;
  starting_word = starting_bit / (64 - 0);
  p = up + starting_word;
  alimb = *p++;
  alimb &= - (mp_limb_t) 1 << (starting_bit % (64 - 0));
  while (alimb == 0)
    alimb = *p++;
  do { do {} while (0); __asm__ ("bsfq %1,%q0" : "=r" (cnt) : "rm" ((UDItype)(alimb))); } while (0);
  return (p - up - 1) * (64 - 0) + cnt;
}
<<<sep_in_sample>>>
1 7
2 10
3 10
4 7
5 10
6 8
7 11
8 9
9 11
10 12
11 12
12 11
13 11
14 13
15 14
16 14
17 14
18 15
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  5e9 <free_and_assign+0x9>
mov    %rbx,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
free_and_assign(char *dest, char *src)
{
    free(dest);
    return src;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    0x320(%rdi),%rdx
xor    %eax,%eax
mov    0x368(%rdx),%rcx
movsd  0x1e8(%rdx),%xmm0
movsd  %xmm0,0x2c8(%rdi)
mov    %rcx,%rsi
shl    $0x5,%rsi
test   %rcx,%rcx
jle    7e9 <genericResupply+0x79>
nopl   0x0(%rax)
mov    0x448(%rdx,%rax,1),%rcx
mov    %rcx,0x870(%rdi,%rax,1)
mov    0x450(%rdx,%rax,1),%rcx
mov    %rcx,0x878(%rdi,%rax,1)
mov    0x458(%rdx,%rax,1),%rcx
mov    %rcx,0x880(%rdi,%rax,1)
mov    0x460(%rdx,%rax,1),%rcx
mov    %rcx,0x888(%rdi,%rax,1)
add    $0x20,%rax
cmp    %rsi,%rax
jne    7a0 <genericResupply+0x30>
jmpq   7ee <genericResupply+0x7e>
xchg   %ax,%ax
<<<sep_in_sample>>>
genericResupply(craft * c)
{
 int i;
 c->fuel = c->cinfo->maxFuel;
 for (i = 0; i < c->cinfo->sCount; i++) {
  c->station[i] = c->cinfo->station[i];
 }
 initDamage(c);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 8
23 8
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %rdi,%rdi
cmove  %rax,%rdi
test   %rsi,%rsi
movl   $0x8,(%rdi)
je     f3d <set_custom_quoting+0x2d>
test   %rdx,%rdx
je     f3d <set_custom_quoting+0x2d>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
callq  f42 <set_custom_quoting+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 6
7 7
8 7
9 7
10 9
11 10
12 11
13 11
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x58,%rsp
lea    0x8(%rsp),%rsi
movq   $0x0,0x10(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
callq  145c <restore_date+0x2c>
test   %eax,%eax
je     14c8 <restore_date+0x98>
mov    0x10(%rsp),%rdi
lea    0x18(%rsp),%rbx
test   %rdi,%rdi
je     147d <restore_date+0x4d>
xor    %edx,%edx
mov    %rbx,%rsi
callq  1479 <restore_date+0x49>
test   %eax,%eax
jne    14f0 <restore_date+0xc0>
mov    %rbx,%rdi
callq  1485 <restore_date+0x55>
mov    0x10(%rsp),%rdi
callq  148f <restore_date+0x5f>
mov    %rbx,%rdi
callq  1497 <restore_date+0x67>
mov    %rax,%rdi
callq  149f <restore_date+0x6f>
cmp    $0x1,%rax
mov    %rax,0x48(%rbp)
sbb    %eax,%eax
and    $0xc,%eax
mov    0x48(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1528 <restore_date+0xf8>
add    $0x58,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdi
lea    0x10(%rsp),%rcx
mov    $0x1,%edx
mov    $0x0,%esi
callq  14e1 <restore_date+0xb1>
jmpq   1460 <restore_date+0x30>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  14f8 <restore_date+0xc8>
lea    0x20(%rsp),%rdi
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x19,%esi
callq  150f <restore_date+0xdf>
mov    0x10(%rsp),%rdi
callq  1519 <restore_date+0xe9>
lea    0x20(%rsp),%rdi
callq  1523 <restore_date+0xf3>
jmpq   149f <restore_date+0x6f>
callq  152d <restore_date+0xfd>
nopl   (%rax)
<<<sep_in_sample>>>
restore_date (mu_message_t msg, mbox_data_t mud)
{
  mu_header_t hdr;
  char *date = ((void *)0);
  time_t t;
  int rc = 0;
  if (mu_message_get_header (msg, &hdr) == 0)
    mu_header_aget_value_n (hdr, "Date", 1, &date);
  if (date && mu_parse_date (date, &t, ((void *)0)))
    {
      char datebuf[24 +1];
      mu_strftime (datebuf, sizeof datebuf, "%a %b %d %H:%M:%S %Y",
     localtime (&t));
      free (date);
      date = strdup (datebuf);
    }
  else
    {
      time (&t);
      free (date);
      date = strdup (ctime (&t));
    }
  mud->date = date;
  if (!mud->date)
    rc = 12;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 4
7 2
8 2
9 2
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 19
23 19
24 20
25 20
26 21
27 21
28 21
29 21
30 6
31 23
32 6
33 6
34 27
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 13
50 13
51 12
52 12
53 12
54 12
55 12
56 14
57 14
58 15
59 15
60 10
61 27
62 27
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   179a <setconfig+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setconfig (const char *file)
{
  return fopen (file, "r");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
mov    %rsi,0x40(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_realm (osip_authentication_info_t *
       authentication_info, char *realm)
{
  authentication_info->realm = (char *) realm;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x2,0x0(%rip)        # 2e <args_open_filelist+0xe>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    50 <args_open_filelist+0x30>
mov    0x0(%rip),%rax        # 46 <args_open_filelist+0x26>
mov    %rax,0x0(%rip)        # 4d <args_open_filelist+0x2d>
pop    %rbx
retq   
nop
mov    $0x0,%esi
mov    %rbx,%rdi
callq  5d <args_open_filelist+0x3d>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 67 <args_open_filelist+0x47>
jne    4d <args_open_filelist+0x2d>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  76 <args_open_filelist+0x56>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
args_open_filelist(const char *filename)
{
 type = 2;
 if (!strcmp(filename, "-")) {
  ip = stdin;
 } else {
  ip = fopen(filename, "r");
  if (ip == ((void *)0))
   die("cannot open '%s'.", filename);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 11
12 11
13 11
14 7
15 7
16 7
17 8
18 7
19 8
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  1d4 <strar_add+0x14>
mov    %rbp,%rdi
mov    %eax,%esi
callq  1de <strar_add+0x1e>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1e9 <strar_add+0x29>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strar_add(STRAR * strar, char * src)
{
 char * last;
 last = strar_return_store(strar, strlen(src));
 strcpy(last, src);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
test   $0xf,%sil
jne    113 <nettle_aes256_encrypt+0x23>
mov    %rdx,%r8
mov    0x0(%rip),%rdx        # 100 <nettle_aes256_encrypt+0x10>
mov    %rcx,%r9
mov    %rsi,%rcx
mov    %rdi,%rsi
mov    $0xe,%edi
jmpq   113 <nettle_aes256_encrypt+0x23>
lea    0x0(%rip),%rcx        # 11a <nettle_aes256_encrypt+0x2a>
push   %rax
lea    0x0(%rip),%rsi        # 122 <nettle_aes256_encrypt+0x32>
lea    0x0(%rip),%rdi        # 129 <nettle_aes256_encrypt+0x39>
mov    $0x50,%edx
callq  133 <nettle_aes256_encrypt+0x43>
<<<sep_in_sample>>>
nettle_aes256_encrypt(const struct aes256_ctx *ctx,
        size_t length, uint8_t *dst,
        const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "aes-encrypt.c", 80, __PRETTY_FUNCTION__));
  _nettle_aes_encrypt(14, ctx->keys, &_nettle_aes_encrypt_table,
        length, dst, src);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 5
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x38(%rbp),%rbx
sub    $0x28,%rsp
mov    0x8(%rdi),%rdi
callq  176 <term_styled_ostream__free+0x16>
mov    0x10(%rbp),%rdi
callq  17f <term_styled_ostream__free+0x1f>
mov    0x18(%rbp),%rdi
callq  188 <term_styled_ostream__free+0x28>
mov    0x20(%rbp),%rdi
callq  191 <term_styled_ostream__free+0x31>
movq   $0x0,(%rsp)
jmp    1aa <term_styled_ostream__free+0x4a>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rsp),%rdi
callq  1aa <term_styled_ostream__free+0x4a>
lea    0x18(%rsp),%r8
lea    0x10(%rsp),%rcx
lea    0x8(%rsp),%rdx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  1c4 <term_styled_ostream__free+0x64>
test   %eax,%eax
je     1a0 <term_styled_ostream__free+0x40>
mov    %rbx,%rdi
callq  1d0 <term_styled_ostream__free+0x70>
add    $0x28,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   1de <term_styled_ostream__free+0x7e>
xchg   %ax,%ax
<<<sep_in_sample>>>
term_styled_ostream__free (term_styled_ostream_t stream)
{
  term_ostream_free (stream->destination);
  cr_cascade_destroy (stream->css_document);
  cr_sel_eng_destroy (stream->css_engine);
  free (stream->curr_classes);
  {
    void *ptr = ((void *)0);
    const void *key;
    size_t keylen;
    void *data;
    while (hash_iterate (&stream->cache, &ptr, &key, &keylen, &data) == 0)
      {
        free (data);
      }
  }
  hash_destroy (&stream->cache);
  free (stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 6
13 6
14 8
15 12
16 12
17 14
18 14
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 17
28 17
29 19
30 18
31 19
32 19
33 18
34 18
<<<sep_out_sample>>>
cmp    $0x4,%edi
mov    $0x0,%eax
cmovge %eax,%edi
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rdi
jmpq   c5b <command_errstr+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
command_errstr (code)
     int code;
{
  if (code > 3)
    code = 0;
  return (gettext(cmd_error_table[code]));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gcide_idx_defs(struct gcide_idx_file *file)
{
    return file->header.ihdr_num_defs;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
push   %rbx
mov    %rdi,%rbx
callq  *0xa0(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_list_iterator (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->iterator (list);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1257 <dir_history_reset+0x7>
push   %rbx
test   %rdi,%rdi
je     129f <dir_history_reset+0x4f>
mov    0x0(%rip),%eax        # 1263 <dir_history_reset+0x13>
test   %eax,%eax
jle    128f <dir_history_reset+0x3f>
xor    %ebx,%ebx
nopl   0x0(%rax)
mov    (%rdi,%rbx,8),%rdi
callq  1279 <dir_history_reset+0x29>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    0x0(%rip),%eax        # 1286 <dir_history_reset+0x36>
mov    0x0(%rip),%rdi        # 128d <dir_history_reset+0x3d>
jl     1270 <dir_history_reset+0x20>
callq  1294 <dir_history_reset+0x44>
movq   $0x0,0x0(%rip)        # 129f <dir_history_reset+0x4f>
movl   $0x0,0x0(%rip)        # 12a9 <dir_history_reset+0x59>
movl   $0x0,0x0(%rip)        # 12b3 <dir_history_reset+0x63>
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_history_reset()
{
    if (dir_history)
    {
 int i;
 for (i = 0; i < dir_history_count; i++)
     xfree(dir_history[i]);
 xfree(dir_history);
 dir_history = ((void *)0);
    }
    dir_history_count = 0;
    dir_history_point = 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 8
18 9
19 11
20 12
21 13
22 13
23 13
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rcx
mov    $0x0,%edx
mov    %edi,%ebp
mov    $0x2000,%esi
push   %rbx
sub    $0x2018,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
mov    %rsp,%rbx
callq  836 <fatal+0x36>
mov    %rsp,%rdx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     839 <fatal+0x39>
mov    %eax,%ecx
mov    %rbx,%rsi
mov    %ebp,%edi
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmove  %rcx,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbx,%rdx
movslq %edx,%rdx
callq  87b <fatal+0x7b>
mov    $0x1,%edi
callq  885 <fatal+0x85>
mov    $0x1,%edi
callq  88f <fatal+0x8f>
nop
<<<sep_in_sample>>>
fatal (int f, char *msg)
{
  char buf[8192];
  snprintf (buf, sizeof buf, "telnetd: %s.\r\n", msg);
  write (f, buf, (int) strlen (buf));
  sleep (1);
            exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 2
7 2
8 2
9 2
10 2
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 6
36 6
37 7
38 7
39 7
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
jmpq   210 <lm_alloc>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_alloc_accel (const void * params, const size_t n, const size_t p)
{
  return lm_alloc(1, params, n, p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  75e <get_bashpid+0xe>
movslq %eax,%rdi
callq  766 <get_bashpid+0x16>
mov    0x8(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     781 <get_bashpid+0x31>
mov    $0x5b8,%edx
mov    $0x0,%esi
callq  781 <get_bashpid+0x31>
orl    $0x12,0x28(%rbx)
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_bashpid (var)
     SHELL_VAR *var;
{
  int pid;
  char *p;
  pid = getpid ();
  p = itos (pid);
  do { if (((var)->value)) sh_xfree((((var)->value)), "variables.c", 1464); } while (0);
  ((var)->attributes |= (0x0000010|0x0000002));
  ((var)->value = (p));
  return (var);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 7
7 7
8 8
9 7
10 8
11 8
12 8
13 8
14 8
15 9
16 10
17 12
18 12
19 12
20 12
21 12
22 12
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r13
lea    (%rsi,%rdx,1),%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
push   %rbx
mov    %edi,%ebx
mov    %esi,%edi
sub    $0x18,%rsp
cmp    %ecx,%r13d
cmovbe %r13d,%ecx
cmp    %ecx,%ebx
mov    %ecx,%ebp
ja     190 <gsl_ran_hypergeometric_pdf+0x80>
cmp    %esi,%ebx
ja     190 <gsl_ran_hypergeometric_pdf+0x80>
cmp    %ecx,%edx
jae    142 <gsl_ran_hypergeometric_pdf+0x32>
lea    (%rdx,%rbx,1),%eax
cmp    %ecx,%eax
nop
jb     190 <gsl_ran_hypergeometric_pdf+0x80>
mov    %ebx,%esi
callq  149 <gsl_ran_hypergeometric_pdf+0x39>
mov    %ebp,%esi
mov    %r12d,%edi
movsd  %xmm0,(%rsp)
sub    %ebx,%esi
callq  15a <gsl_ran_hypergeometric_pdf+0x4a>
mov    %ebp,%esi
mov    %r13d,%edi
movsd  %xmm0,0x8(%rsp)
callq  16a <gsl_ran_hypergeometric_pdf+0x5a>
movsd  (%rsp),%xmm1
addsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
jmpq   18c <gsl_ran_hypergeometric_pdf+0x7c>
nopl   0x0(%rax)
add    $0x18,%rsp
xorpd  %xmm0,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_ran_hypergeometric_pdf (const unsigned int k,
                            const unsigned int n1,
                            const unsigned int n2,
                            unsigned int t)
{
  if (t > n1 + n2)
    {
      t = n1 + n2 ;
    }
  if (k > n1 || k > t)
    {
      return 0 ;
    }
  else if (t > n2 && k + n2 < t )
    {
      return 0 ;
    }
  else
    {
      double p;
      double c1 = gsl_sf_lnchoose(n1,k);
      double c2 = gsl_sf_lnchoose(n2,t-k);
      double c3 = gsl_sf_lnchoose(n1+n2,t);
      p = exp(c1 + c2 - c3) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 10
13 10
14 10
15 10
16 10
17 14
18 14
19 14
20 14
21 14
22 14
23 21
24 21
25 22
26 22
27 21
28 22
29 22
30 23
31 23
32 22
33 23
34 24
35 24
36 27
37 27
38 27
39 27
40 27
41 24
42 24
43 24
44 24
45 27
46 12
47 27
48 27
49 27
50 27
51 27
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     1dc0 <gsl_block_float_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    0x0(,%rcx,4),%r14
mov    %rsi,%rbx
jne    1d6c <gsl_block_float_raw_fwrite+0x3c>
jmp    1db0 <gsl_block_float_raw_fwrite+0x80>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     1db0 <gsl_block_float_raw_fwrite+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  1d81 <gsl_block_float_raw_fwrite+0x51>
cmp    $0x1,%rax
je     1d60 <gsl_block_float_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1da0 <gsl_block_float_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x4,%esi
callq  1dcd <gsl_block_float_raw_fwrite+0x9d>
cmp    %r12,%rax
je     1db0 <gsl_block_float_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1deb <gsl_block_float_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    1da5 <gsl_block_float_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_float_raw_fwrite (FILE * stream, const float * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 1 * sizeof (float), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 1 * i * stride,
                                1 * sizeof (float),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  cf1 <is_cdrom_linux+0x11>
test   %al,%al
jne    d00 <is_cdrom_linux+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %edx,%edx
mov    %rbx,%rdi
xor    %eax,%eax
mov    $0x800,%esi
callq  d11 <is_cdrom_linux+0x31>
test   %eax,%eax
mov    %eax,%ebx
js     d40 <is_cdrom_linux+0x60>
xor    %edx,%edx
mov    %eax,%edi
mov    $0x5331,%esi
xor    %eax,%eax
callq  d27 <is_cdrom_linux+0x47>
cmp    $0xffffffff,%eax
mov    %ebx,%edi
setne  %bpl
callq  d35 <is_cdrom_linux+0x55>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
test   %rbp,%rbp
je     d60 <is_cdrom_linux+0x80>
mov    %rbp,%rsi
mov    $0x0,%edi
mov    $0x8,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
sete   %bpl
mov    %ebp,%eax
jmp    d37 <is_cdrom_linux+0x57>
nopl   0x0(%rax)
xor    %ebp,%ebp
mov    %ebp,%eax
jmp    d37 <is_cdrom_linux+0x57>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_cdrom_linux(const char *drive, char *mnttype)
{
  _Bool is_cd=0;
  int cdfd;
  if ( !cdio_is_device_quiet_generic(drive) ) {
    return(0);
  }
  cdfd = open(drive, (00|04000), 0);
  if ( cdfd >= 0 ) {
    if ( ioctl(cdfd, 0x5331, 0) != -1 ) {
      is_cd = 1;
    }
    close(cdfd);
    }
  else if ( mnttype && (strcmp(mnttype, "iso9660") == 0) ) {
    is_cd = 1;
  }
  return(is_cd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 19
10 19
11 19
12 19
13 19
14 8
15 8
16 8
17 8
18 8
19 9
20 8
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 13
29 10
30 13
31 3
32 19
33 19
34 19
35 19
36 19
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 3
45 3
46 3
47 3
48 3
49 3
50 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    2250 <gsl_matrix_long_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,8),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  2272 <gsl_matrix_long_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_subdiagonal (gsl_matrix_long * m,
                                    const size_t k)
{
  _gsl_vector_long_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x2,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_hard_ignored (sig)
     int sig;
{
  return (sigmodes[sig] & 0x2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 2b38 <rebuild_prerequisites+0x8>
test   %rbx,%rbx
jne    2b48 <rebuild_prerequisites+0x18>
jmp    2b5f <rebuild_prerequisites+0x2f>
nop
mov    (%rbx),%rbx
test   %rbx,%rbx
je     2b5f <rebuild_prerequisites+0x2f>
mov    0x10(%rbx),%eax
test   %eax,%eax
jne    2b40 <rebuild_prerequisites+0x10>
mov    %rbx,%rdi
callq  2b57 <rebuild_prerequisites+0x27>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    2b48 <rebuild_prerequisites+0x18>
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rebuild_prerequisites ()
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (((prog)->type == TYPE_COMPONENT))
      prog_rebuild_prerequisites (prog);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 4
16 4
17 4
18 7
19 7
20 7
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
__gmpn_sec_sqr_itch (mp_size_t an)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    $0x100,%ecx
jmpq   1a <lchmodat+0xa>
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x204,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  a55 <make_bare_simple_command+0x15>
mov    $0x205,%edx
mov    $0x0,%esi
mov    $0x18,%edi
mov    %rax,%rbx
callq  a6c <make_bare_simple_command+0x2c>
mov    0x0(%rip),%edx        # a72 <make_bare_simple_command+0x32>
mov    %rax,0x18(%rbx)
movl   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
mov    %edx,0x4(%rax)
mov    %rbx,%rax
movl   $0x4,(%rbx)
movq   $0x0,0x10(%rbx)
movl   $0x0,0x4(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
make_bare_simple_command ()
{
  COMMAND *command;
  SIMPLE_COM *temp;
  command = (COMMAND *)sh_xmalloc((sizeof (COMMAND)), "make_cmd.c", 516);
  command->value.Simple = temp = (SIMPLE_COM *)sh_xmalloc((sizeof (SIMPLE_COM)), "make_cmd.c", 517);
  temp->flags = 0;
  temp->line = line_number;
  temp->words = (WORD_LIST *)((void *)0);
  temp->redirects = (REDIRECT *)((void *)0);
  command->type = cm_simple;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  return (command);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 6
9 5
10 6
11 8
12 6
13 7
14 9
15 10
16 8
17 15
18 11
19 12
20 13
21 15
22 15
23 15
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0x98(%rsi),%rsi
mov    0x20(%rax),%rax
jmpq   *%rax
<<<sep_in_sample>>>
gsl_multifit_nlinear_rcond (double *rcond, const gsl_multifit_nlinear_workspace * w)
{
  int status = (w->type->rcond) (rcond, w->state);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  16 <setup_utmp+0x16>
add    $0x8,%rsp
lea    0x5(%rbx),%rdi
mov    %rbp,%rcx
pop    %rbx
pop    %rbp
mov    %rax,%rdx
mov    $0x0,%esi
jmpq   30 <start_login>
<<<sep_in_sample>>>
setup_utmp (char *line, char *host)
{
  char *ut_id = utmp_ptsid (line, "tn");
  utmp_init (line + sizeof ("/dev/") - 1, ".telnet", ut_id, host);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 5
9 4
10 4
11 5
12 5
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x8,%edi
callq  5eb <ahs_open+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     603 <ahs_open+0x23>
callq  5f8 <ahs_open+0x18>
mov    %rax,%rdi
mov    %rax,(%rbx)
callq  603 <ahs_open+0x23>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahs_open(void) {
 AHS * xhs;
 ;
 xhs = (AHS *)malloc(sizeof(AHS));
 if (!xhs) return ((void *)0);
 xhs->file_hdrM = ahsStaticCreateFilehdr();
 taru_init_header(ahs_vfile_hdr(xhs));
 return xhs;
}
<<<sep_in_sample>>>
1 1
2 4
3 4
4 5
5 4
6 5
7 6
8 7
9 6
10 7
11 9
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  bc5 <system_fh_tx_compressed+0x15>
test   %rax,%rax
je     be0 <system_fh_tx_compressed+0x30>
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    0x60(%rax),%rcx
jmpq   bdf <system_fh_tx_compressed+0x2f>
nop
mov    %rbx,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   bf1 <system_fh_tx_compressed+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_fh_tx_compressed (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "tx_compressed" " unknown)"); else put_ulong (form, argc, argv, stats->tx_compressed); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x40(%rdi),%rax
mov    0x10(%rax),%rbp
mov    %rax,(%rsp)
test   %rbp,%rbp
je     2d9 <folder_mbox_unsubscribe+0x59>
mov    0x8(%rax),%r12
mov    %rsi,%r14
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    (%r12,%rbx,8),%r15
lea    0x0(,%rbx,8),%r13
test   %r15,%r15
je     2d0 <folder_mbox_unsubscribe+0x50>
mov    %r14,%rsi
mov    %r15,%rdi
callq  2cc <folder_mbox_unsubscribe+0x4c>
test   %eax,%eax
je     2f0 <folder_mbox_unsubscribe+0x70>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    2b0 <folder_mbox_unsubscribe+0x30>
add    $0x18,%rsp
mov    $0x1028,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
mov    %r15,%rdi
mov    %eax,0xc(%rsp)
callq  2fc <folder_mbox_unsubscribe+0x7c>
mov    (%rsp),%rax
mov    0x8(%rax),%rdx
mov    0xc(%rsp),%eax
movq   $0x0,(%rdx,%r13,1)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nop
<<<sep_in_sample>>>
folder_mbox_unsubscribe (mu_folder_t folder, const char *name)
{
  fmbox_t fmbox = folder->data;
  size_t i;
  for (i = 0; i < fmbox->sublen; i++)
    {
      if (fmbox->subscribe[i] && strcmp (fmbox->subscribe[i], name) == 0)
 {
   free (fmbox->subscribe[i]);
   fmbox->subscribe[i] = ((void *)0);
   return 0;
 }
    }
  return (0x1000 +40);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 3
11 5
12 5
13 5
14 5
15 5
16 5
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 5
27 5
28 5
29 15
30 14
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 9
40 9
41 9
42 10
43 10
44 11
45 10
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 15
<<<sep_out_sample>>>
push   %rbp
xor    %esi,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  f0 <YesNoFromLex+0x10>
mov    %eax,%ebp
callq  f7 <YesNoFromLex+0x17>
movsbq (%rbx),%rcx
mov    (%rax),%rdx
testb  $0x4,0x1(%rdx,%rcx,2)
je     120 <YesNoFromLex+0x40>
xor    %eax,%eax
cmp    $0xc8,%ebp
sete   %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   12e <YesNoFromLex+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
YesNoFromLex (PSTR szLex)
{
  int ikwcode = GetKeywordCode (szLex, ((void *)0));
  BOOL bReturn;
  bReturn = (!((*__ctype_b_loc ())[(int) ((szLex[0]))] & (unsigned short int) _ISalpha) ? atoi(szLex)
             : ikwcode == 200 ? 1
             : ikwcode == 201 ? 0
             : 0);
  return bReturn;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 5
11 6
12 6
13 7
14 7
15 7
16 10
17 10
18 10
19 10
20 10
21 10
22 6
23 10
24 10
25 6
26 6
<<<sep_out_sample>>>
addsd  %xmm0,%xmm0
movslq %esi,%rax
test   %esi,%esi
lea    0x0(,%rax,8),%rdx
movsd  (%rdi,%rax,8),%xmm2
subsd  0x0(%rip),%xmm0        # 1e <clenshaw+0x1e>
jle    77 <clenshaw+0x77>
lea    -0x1(%rsi),%ecx
movapd %xmm0,%xmm4
lea    -0x8(%rdi,%rdx,1),%rax
lea    -0x10(%rdi,%rdx,1),%rdx
shl    $0x3,%rcx
addsd  %xmm0,%xmm4
sub    %rcx,%rdx
xorpd  %xmm3,%xmm3
jmp    50 <clenshaw+0x50>
nopw   0x0(%rax,%rax,1)
movapd %xmm2,%xmm3
movapd %xmm1,%xmm2
movapd %xmm2,%xmm1
sub    $0x8,%rax
mulsd  %xmm4,%xmm1
subsd  %xmm3,%xmm1
addsd  0x8(%rax),%xmm1
cmp    %rdx,%rax
jne    48 <clenshaw+0x48>
mulsd  %xmm0,%xmm2
movapd %xmm1,%xmm0
subsd  %xmm2,%xmm0
retq   
movapd %xmm2,%xmm1
xorpd  %xmm2,%xmm2
jmp    6a <clenshaw+0x6a>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
clenshaw(const double * c, int N, double u)
{
  double B_np1 = 0.0;
  double B_n = c[N];
  double B_nm1;
  int n;
  for(n=N; n>0; n--) {
    B_nm1 = 2.0*(2.0*u-1.0) * B_n - B_np1 + c[n-1];
    B_np1 = B_n;
    B_n = B_nm1;
  }
  return B_n - (2.0*u-1.0)*B_np1;
}
<<<sep_in_sample>>>
1 2
2 4
3 7
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 3
16 3
17 3
18 3
19 8
20 8
21 8
22 8
23 8
24 8
25 7
26 7
27 12
28 12
29 12
30 13
31 4
32 3
33 3
34 3
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     f8 <_auth_lb_grow+0x78>
mov    0x8(%rbx),%rdx
mov    0x10(%rbx),%rax
mov    %rdx,%rcx
sub    %rax,%rcx
cmp    %rcx,%rbp
ja     d0 <_auth_lb_grow+0x50>
mov    %rbp,%rdx
mov    %r12,%rsi
add    %rax,%rdi
callq  bc <_auth_lb_grow+0x3c>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x0(%rbp,%rdx,1),%r13
mov    %r13,%rsi
callq  dd <_auth_lb_grow+0x5d>
test   %rax,%rax
mov    %rax,(%rbx)
je     114 <_auth_lb_grow+0x94>
mov    %r13,0x8(%rbx)
mov    %rax,%rdi
mov    0x10(%rbx),%rax
jmp    ae <_auth_lb_grow+0x2e>
nopw   0x0(%rax,%rax,1)
mov    %rdx,%rdi
callq  100 <_auth_lb_grow+0x80>
test   %rax,%rax
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jne    e9 <_auth_lb_grow+0x69>
add    $0x8,%rsp
mov    $0xc,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 9
13 9
14 9
15 9
16 9
17 9
18 18
19 18
20 18
21 18
22 19
23 21
24 20
25 21
26 21
27 21
28 21
29 21
30 21
31 11
32 12
33 12
34 13
35 12
36 13
37 14
38 14
39 14
40 14
41 14
42 5
43 5
44 16
45 5
46 6
47 7
48 16
49 21
50 17
51 21
52 21
53 21
54 21
55 21
56 21
<<<sep_out_sample>>>
test   %rsi,%rsi
je     3ce <file_block_read+0xe>
cmpb   $0x0,0x121(%rdi)
je     3d0 <file_block_read+0x10>
repz retq 
jmpq   c0 <file_block_read.part.1>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_block_read (struct file_data *current, size_t size)
{
  if (size && ! current->eof)
    {
      size_t s = block_read (current->desc,
        ((char *) (current)->buffer) + current->buffered, size);
      if (s == (18446744073709551615UL))
 pfatal_with_name (current->name);
      current->buffered += s;
      current->eof = s < size;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2f9 <fclosepipe+0x9>
mov    %eax,%edi
callq  300 <fclosepipe+0x10>
mov    %rbx,%rdi
callq  308 <fclosepipe+0x18>
cmp    $0xffffffff,%eax
je     320 <fclosepipe+0x30>
pop    %rbx
mov    $0x0,%edi
jmpq   318 <fclosepipe+0x28>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
fclosepipe(FILE *fp)
{
  closepipe(fileno(fp));
  if (fclose(fp) != (-1))
    perror("trueprint" ": could not close diff stream");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 5
12 5
13 5
14 6
15 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdi),%rax
mov    %rsi,%r10
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %r10,%rdx
callq  *0x18(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_step_apply(
  gsl_odeiv_step * s,
  double t,
  double h,
  double y[],
  double yerr[],
  const double dydt_in[],
  double dydt_out[],
  const gsl_odeiv_system * dydt)
{
  return s->type->apply(s->state, s->dimension, t, h, y, yerr, dydt_in, dydt_out, dydt);
}
<<<sep_in_sample>>>
1 10
2 11
3 10
4 11
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 12
13 12
14 12
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1691 <gsl_matrix_long_fwrite+0x91>
lea    0x0(,%r15,8),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    164e <gsl_matrix_long_fwrite+0x4e>
jmp    1680 <gsl_matrix_long_fwrite+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1680 <gsl_matrix_long_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1665 <gsl_matrix_long_fwrite+0x65>
test   %eax,%eax
je     1640 <gsl_matrix_long_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   16b4 <gsl_matrix_long_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_fwrite (FILE * stream, const gsl_matrix_long * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    0x8(%rdi),%rdi
lea    0x0(,%rax,8),%esi
mov    0x0(%rip),%rax        # 14 <__gmp_randclear_mt+0x14>
movslq %esi,%rsi
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
__gmp_randclear_mt (gmp_randstate_t rstate)
{
  (*__gmp_free_func) ((void *) ((rstate)->_mp_seed->_mp_d),
        ((rstate->_mp_seed)->_mp_alloc) * 8);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    $0x5413,%esi
mov    %edi,%ebx
sub    $0x10,%rsp
mov    %rsp,%rdx
callq  16 <set_winsize+0x16>
test   %eax,%eax
jne    29 <set_winsize+0x29>
mov    %rsp,%rdx
mov    $0x5414,%esi
mov    %ebx,%edi
callq  29 <set_winsize+0x29>
add    $0x10,%rsp
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
set_winsize (tty)
     int tty;
{
  struct winsize w;
  if (ioctl (tty, 0x5413, &w) == 0)
      (void) ioctl (tty, 0x5414, &w);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
callq  0 <make_local_connection_fd>
cmp    $0xffffffff,%eax
je     1f8 <make_local_connection+0x28>
lea    0x8(%rsp),%rdi
mov    %eax,%esi
callq  1ea <make_local_connection+0x1a>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    1ef <make_local_connection+0x1f>
nopl   0x0(%rax)
<<<sep_in_sample>>>
make_local_connection (char *exec_path, char **exec_args)
{
  int fd;
  NET_STREAM str;
  fd = make_local_connection_fd (exec_path, exec_args);
  if (fd == -1)
    return ((void *)0);
  net_create_stream (&str, fd);
  return str;
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 6
5 8
6 8
7 8
8 9
9 10
10 10
11 10
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  14 <xmemdup+0x14>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  22 <xmemdup+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
xmemdup (const void *p, size_t n)
{
  void *q = xmalloc (n);
  memcpy (q, p, n);
  return q;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     40 <dep_hash_1+0x40>
sub    $0x1,%rax
movzbl 0x1(%rax),%edx
lea    0x1(%rax),%rdi
xor    %eax,%eax
test   %dl,%dl
je     4d <dep_hash_1+0x4d>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    20 <dep_hash_1+0x20>
repz retq 
xchg   %ax,%ax
mov    0x10(%rdi),%rax
mov    (%rax),%rax
sub    $0x1,%rax
jmp    d <dep_hash_1+0xd>
repz retq 
nop
<<<sep_in_sample>>>
dep_hash_1 (const void *key)
{
  const struct dep *d = key;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((d)->name ? (d)->name : (d)->file->name))) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
display_mk82(craft *c, craftType *ct, viewer *u, int *x, int *y)
{
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  409 <remove_trailing_whitespace+0x9>
sub    $0x1,%eax
test   %eax,%eax
jle    439 <remove_trailing_whitespace+0x39>
movslq %eax,%rdx
movzbl (%rbx,%rdx,1),%ecx
cmp    $0x9,%cl
jne    44f <remove_trailing_whitespace+0x4f>
lea    -0x1(%rbx,%rdx,1),%rdx
jmp    434 <remove_trailing_whitespace+0x34>
nopl   0x0(%rax,%rax,1)
movzbl (%rdx),%ecx
sub    $0x1,%rdx
cmp    $0x9,%cl
jne    448 <remove_trailing_whitespace+0x48>
sub    $0x1,%eax
jne    428 <remove_trailing_whitespace+0x28>
add    $0x1,%eax
cltq   
movb   $0x0,(%rbx,%rax,1)
pop    %rbx
retq   
nopl   0x0(%rax)
cmp    $0x20,%cl
je     434 <remove_trailing_whitespace+0x34>
jmp    439 <remove_trailing_whitespace+0x39>
cmp    $0x20,%cl
je     41c <remove_trailing_whitespace+0x1c>
jmp    439 <remove_trailing_whitespace+0x39>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remove_trailing_whitespace (string)
     char *string;
{
  register int i;
  i = strlen (string) - 1;
  while (i > 0 && (((string[i]) == ' ') || ((string[i]) == '\t')))
    i--;
  string[++i] = '\0';
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 9
24 9
25 9
26 6
27 6
28 6
29 6
30 6
31 6
32 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x3a,%edi
callq  2dd <regex_print_flags+0xd>
test   $0x1,%bl
jne    320 <regex_print_flags+0x50>
test   $0x2,%bl
jne    330 <regex_print_flags+0x60>
test   $0x4,%bl
jne    340 <regex_print_flags+0x70>
test   $0x20,%bl
nop
jne    310 <regex_print_flags+0x40>
and    $0x10,%ebx
jne    300 <regex_print_flags+0x30>
pop    %rbx
retq   
nopl   0x0(%rax)
pop    %rbx
mov    $0x0,%edi
xor    %eax,%eax
jmpq   30d <regex_print_flags+0x3d>
nopl   (%rax)
mov    $0x0,%edi
xor    %eax,%eax
callq  31c <regex_print_flags+0x4c>
jmp    2f2 <regex_print_flags+0x22>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  32c <regex_print_flags+0x5c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  33c <regex_print_flags+0x6c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
callq  34c <regex_print_flags+0x7c>
jmp    2ec <regex_print_flags+0x1c>
xchg   %ax,%ax
<<<sep_in_sample>>>
regex_print_flags (int flags)
{
  printf (":");
  if (flags & 0x00000001)
    printf ("exact");
  else if (flags & 0x00000002)
    printf ("posix");
  else if (flags & 0x00000004)
    printf ("perl");
  if (flags & 0x00000020)
    printf (" :scase");
  if (flags & 0x00000010)
    printf (" :basic");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 10
12 10
13 10
14 12
15 12
16 14
17 14
18 14
19 14
20 13
21 13
22 13
23 13
24 11
25 11
26 11
27 11
28 11
29 5
30 5
31 5
32 5
33 5
34 7
35 7
36 7
37 7
38 7
39 9
40 9
41 9
42 9
43 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # fb0 <prog_lookup_by_tag+0x10>
test   %rbx,%rbx
jne    fc8 <prog_lookup_by_tag+0x28>
jmp    fd8 <prog_lookup_by_tag+0x38>
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rbx
test   %rbx,%rbx
je     fd8 <prog_lookup_by_tag+0x38>
mov    0x18(%rbx),%rdi
mov    %rbp,%rsi
callq  fd4 <prog_lookup_by_tag+0x34>
test   %eax,%eax
jne    fc0 <prog_lookup_by_tag+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
prog_lookup_by_tag (const char *tag)
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (strcmp (prog->tag, tag) == 0)
      break;
  return prog;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 8
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
callq  cfb2 <gsl_fft_halfcomplex_float_inverse+0x12>
test   %eax,%eax
jne    d003 <gsl_fft_halfcomplex_float_inverse+0x63>
test   %rbx,%rbx
js     d010 <gsl_fft_halfcomplex_float_inverse+0x70>
cvtsi2sd %rbx,%xmm0
movsd  0x0(%rip),%xmm1        # cfc8 <gsl_fft_halfcomplex_float_inverse+0x28>
test   %rbx,%rbx
divsd  %xmm0,%xmm1
je     d003 <gsl_fft_halfcomplex_float_inverse+0x63>
lea    0x0(,%r12,4),%rsi
mov    %rbp,%rdi
xor    %ecx,%ecx
xchg   %ax,%ax
movss  (%rdi),%xmm0
add    $0x1,%rcx
cvtps2pd %xmm0,%xmm0
mulsd  %xmm1,%xmm0
unpcklpd %xmm0,%xmm0
cvtpd2ps %xmm0,%xmm2
movss  %xmm2,(%rdi)
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    cfe0 <gsl_fft_halfcomplex_float_inverse+0x40>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbx,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
jmp    cfc0 <gsl_fft_halfcomplex_float_inverse+0x20>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_halfcomplex_float_inverse (float data[], const size_t stride,
                                       const size_t n,
                                       const gsl_fft_halfcomplex_wavetable_float * wavetable,
                                       gsl_fft_real_workspace_float * work)
{
  int status = gsl_fft_halfcomplex_float_transform (data, stride, n, wavetable, work);
  if (status)
    {
      return status;
    }
  {
    const double norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        data[stride*i] *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 7
9 7
10 12
11 12
12 12
13 12
14 14
15 12
16 14
17 14
18 14
19 14
20 14
21 16
22 14
23 16
24 16
25 16
26 16
27 16
28 16
29 14
30 14
31 20
32 20
33 20
34 20
35 20
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  149 <is_var+0x9>
test   %eax,%eax
je     158 <is_var+0x18>
cmpl   $0x2,0x18(%rbx)
mov    $0x1,%eax
je     160 <is_var+0x20>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
testl  $0xfffffffd,0x70(%rbx)
pop    %rbx
sete   %al
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
is_var(Symbol *symp)
{
     if (include_symbol(symp)) {
   if (symp->type == SymIdentifier)
        return symp->storage == ExternStorage ||
         symp->storage == StaticStorage;
   else
        return 1;
     }
     return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 8
8 4
9 11
10 11
11 11
12 5
13 5
14 11
15 5
16 11
17 11
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    $0x0,%esi
push   %rbx
callq  2d7 <gdbm_import+0x17>
test   %rax,%rax
mov    %rax,%rbx
je     300 <gdbm_import+0x40>
mov    %rbp,%rdi
mov    %r12d,%edx
mov    %rax,%rsi
callq  2ed <gdbm_import+0x2d>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  2f7 <gdbm_import+0x37>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
movl   $0x3,0x0(%rip)        # 30a <gdbm_import+0x4a>
mov    $0xffffffff,%eax
jmp    2f9 <gdbm_import+0x39>
<<<sep_in_sample>>>
gdbm_import (GDBM_FILE dbf, const char *importfile, int flag)
{
  FILE *fp;
  int rc;
  fp = fopen (importfile, "r");
  if (!fp)
    {
      gdbm_errno = 3;
      return -1;
    }
  rc = gdbm_import_from_file (dbf, fp, flag);
  fclose (fp);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 2
8 5
9 6
10 5
11 6
12 11
13 11
14 11
15 11
16 12
17 11
18 12
19 13
20 14
21 14
22 14
23 14
24 14
25 8
26 9
27 9
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
callq  c63 <parse_init_script+0x13>
test   %rax,%rax
mov    %rax,(%rsp)
je     cb0 <parse_init_script+0x60>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
movq   $0x0,0x8(%rsp)
movq   $0x0,0x10(%rsp)
callq  c8e <parse_init_script+0x3e>
mov    (%rsp),%rdi
callq  c97 <parse_init_script+0x47>
mov    0x8(%rsp),%rdi
callq  ca1 <parse_init_script+0x51>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
callq  cb5 <parse_init_script+0x65>
cmpl   $0x2,(%rax)
mov    %rax,%rbp
je     ca1 <parse_init_script+0x51>
mov    $0x0,%edi
callq  cc7 <parse_init_script+0x77>
mov    0x0(%rbp),%esi
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x4,%edi
xor    %eax,%eax
callq  cdc <parse_init_script+0x8c>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_init_script(const char *name)
{
    struct init_script scr;
    scr.fp = fopen(name, "r");
    if (!scr.fp) {
 if ((*__errno_location ()) != 2)
     dico_log(4, (*__errno_location ()), gettext ("Cannot open init file %s"), name);
 return;
    }
    scr.buf = ((void *)0);
    scr.size = 0;
    parse_script_file(name, script_getline, &scr);
    fclose(scr.fp);
    free(scr.buf);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 5
8 4
9 5
10 12
11 12
12 12
13 10
14 11
15 12
16 13
17 13
18 14
19 14
20 15
21 15
22 15
23 15
24 15
25 6
26 6
27 6
28 6
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 15
38 15
39 15
40 15
41 15
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_tree_iterator_free (gl_oset_iterator_t *iterator)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpw   $0x1,0x14(%rdi)
je     1d <__rdiscrete+0x1d>
mov    $0x0,%edi
callq  1d <__rdiscrete+0x1d>
movabs $0x6765c793fa10079d,%rax
movslq 0x1c(%rbx),%rdx
imul   0x0(%rbp),%rax
or     $0x1,%rax
mov    %rax,0x0(%rbp)
shr    %rax
test   %rdx,%rdx
cvtsi2sd %rax,%xmm1
addsd  0x0(%rip),%xmm1        # 4b <__rdiscrete+0x4b>
mulsd  0x0(%rip),%xmm1        # 53 <__rdiscrete+0x53>
jle    8b <__rdiscrete+0x8b>
movsd  0x20(%rbx),%xmm0
xor    %eax,%eax
ucomisd %xmm1,%xmm0
jbe    74 <__rdiscrete+0x74>
jmp    7d <__rdiscrete+0x7d>
nopl   0x0(%rax)
movsd  0x20(%rbx,%rax,8),%xmm0
ucomisd %xmm1,%xmm0
ja     7d <__rdiscrete+0x7d>
add    $0x1,%rax
cmp    %rdx,%rax
jl     68 <__rdiscrete+0x68>
movslq 0x18(%rbx),%rdx
add    $0x8,%rsp
pop    %rbx
pop    %rbp
add    %rdx,%rax
retq   
xor    %eax,%eax
jmp    7d <__rdiscrete+0x7d>
<<<sep_in_sample>>>
__rdiscrete (__arrp A, long *U)
{
  long j;
  double basic;
  if (A->h.dim != 1)
    __rerror ("Disrete: Multi dimensional array");
  basic = ((((double)(((unsigned long)(*U= (*U*7450580596923828125L)|1))>>1))+0.5)/((double)((~(1L<<63)))+1.0));
  for (j = 0; j < A->limits[0].size; j++)
    if ((*(double *)(((char *)A)+sizeof(__ah)+ sizeof(__arrlimit)+sizeof(double)*(j))) > basic)
      break;
  return (A->limits[0].low + j);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 7
11 8
12 7
13 7
14 7
15 7
16 8
17 7
18 7
19 7
20 8
21 9
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 8
31 8
32 8
33 11
34 12
35 12
36 12
37 11
38 12
39 8
40 8
<<<sep_out_sample>>>
mov    (%rsi),%eax
xor    %edx,%edx
cmp    %eax,(%rdi)
mov    $0xffffffff,%eax
setg   %dl
cmovge %edx,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
intcmp(int *i1, int *i2)
{
  if (*i1 < *i2)
    return -1;
  else if (*i1 > *i2)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 8
8 8
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    0x0(%rip),%eax        # 91 <readln+0x11>
test   %eax,%eax
je     138 <readln+0xb8>
movq   $0x0,0x8(%rsp)
xor    %eax,%eax
xor    %ebp,%ebp
xor    %ebx,%ebx
jmp    db <readln+0x5b>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%edi        # b6 <readln+0x36>
lea    0x0(%rbp,%rbx,1),%rsi
xor    %ecx,%ecx
mov    $0x1,%edx
callq  c7 <readln+0x47>
test   %rax,%rax
jle    f8 <readln+0x78>
add    %rax,%rbx
cmpb   $0xa,-0x1(%rbp,%rbx,1)
je     108 <readln+0x88>
mov    0x8(%rsp),%rax
cmp    %rax,%rbx
jne    b0 <readln+0x30>
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  ed <readln+0x6d>
mov    %rax,%rbp
jmp    b0 <readln+0x30>
nopw   0x0(%rax,%rax,1)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
cmp    0x8(%rsp),%rbx
je     158 <readln+0xd8>
movb   $0x0,0x0(%rbp,%rbx,1)
mov    %rbp,%rsi
mov    %rbp,(%r12)
mov    $0x0,%edi
xor    %eax,%eax
callq  127 <readln+0xa7>
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    $0x0,%edi
callq  142 <readln+0xc2>
test   %rax,%rax
mov    %rax,(%r12)
setne  %al
add    $0x10,%rsp
pop    %rbx
pop    %rbp
movzbl %al,%eax
pop    %r12
retq   
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  165 <readln+0xe5>
mov    %rax,%rbp
jmp    10f <readln+0x8f>
<<<sep_in_sample>>>
readln (char **out)
{
  if (sockfd)
    {
      size_t allocated = 0, used = 0;
      char *input = ((void *)0);
      do
 {
   ssize_t nread;
   if (used == allocated)
     input = x2realloc (input, &allocated);
     nread = recv (sockfd, &input[used], 1, 0);
   if (nread <= 0)
     return 0;
   used += nread;
 }
      while (input[used - 1] != '\n');
      if (used == allocated)
 input = x2realloc (input, &allocated);
      input[used] = '\0';
      *out = input;
      printf ("%s", *out);
    }
  else
    {
      *out = readline ("");
      if (*out == ((void *)0))
 return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 6
12 5
13 5
14 5
15 12
16 12
17 12
18 12
19 12
20 13
21 13
22 15
23 17
24 17
25 17
26 10
27 10
28 11
29 11
30 11
31 11
32 11
33 11
34 31
35 14
36 31
37 31
38 31
39 31
40 31
41 18
42 18
43 20
44 22
45 21
46 22
47 22
48 22
49 31
50 30
51 31
52 31
53 31
54 31
55 31
56 26
57 26
58 27
59 26
60 27
61 31
62 31
63 31
64 27
65 31
66 31
67 19
68 19
69 19
70 19
71 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     2bf <nettle_chacha_poly1305_encrypt+0x4f>
testb  $0x3f,0x90(%rdi)
mov    %rdi,%rbx
jne    2ca <nettle_chacha_poly1305_encrypt+0x5a>
mov    %rdx,%r12
mov    %rcx,%r13
callq  120 <poly1305_pad>
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2aa <nettle_chacha_poly1305_encrypt+0x3a>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  0 <poly1305_update>
add    %rbp,0x90(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
lea    0x0(%rip),%rcx        # 2d1 <nettle_chacha_poly1305_encrypt+0x61>
lea    0x0(%rip),%rsi        # 2d8 <nettle_chacha_poly1305_encrypt+0x68>
lea    0x0(%rip),%rdi        # 2df <nettle_chacha_poly1305_encrypt+0x6f>
mov    $0x81,%edx
callq  2e9 <nettle_chacha_poly1305_encrypt+0x79>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_chacha_poly1305_encrypt (struct chacha_poly1305_ctx *ctx,
    size_t length, uint8_t *dst, const uint8_t *src)
{
  if (!length)
    return;
  ((ctx->data_size % 64 == 0) ? (void) (0) : __assert_fail ("ctx->data_size % 64 == 0", "chacha-poly1305.c", 129, __PRETTY_FUNCTION__));
  poly1305_pad (ctx);
  nettle_chacha_crypt (&ctx->chacha, length, dst, src);
  poly1305_update (ctx, length, dst);
  ctx->data_size += length;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 10
25 11
26 11
27 11
28 11
29 11
30 11
31 6
32 6
33 6
34 6
35 6
36 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%r12
mov    %r12,%rdi
callq  79b <_print_help+0x1b>
mov    %r12,%rsi
mov    %rbp,%rdi
mov    %rax,%r13
callq  7a9 <_print_help+0x29>
mov    0x10(%rbx),%rdx
mov    %r13d,%eax
test   %rdx,%rdx
je     7d2 <_print_help+0x52>
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  7c4 <_print_help+0x44>
mov    0x10(%rbx),%rdi
callq  7cd <_print_help+0x4d>
lea    0x1(%r13,%rax,1),%eax
xor    %edx,%edx
cmp    $0x1e,%eax
jg     7dd <_print_help+0x5d>
mov    $0x1f,%dl
sub    %eax,%edx
mov    0x18(%rbx),%r9
mov    %rbp,%rdi
mov    $0x0,%r8d
mov    %edx,%ecx
mov    $0x0,%esi
xor    %eax,%eax
callq  7f8 <_print_help+0x78>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_print_help(void *item, void *data)
{
    struct dicod_command *p = item;
    dico_stream_t str = data;
    int len = strlen(p->keyword);
    stream_writez(str, p->keyword);
    if (p->param) {
 stream_printf(str, " %s", p->param);
 len += strlen(p->param) + 1;
    }
    if (len < 31)
 len = 31 - len;
    else
 len = 0;
    stream_printf(str, "%*.*s -- %s\n", len, len, "", p->help);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 6
12 6
13 5
14 6
15 7
16 5
17 7
18 7
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 14
27 11
28 11
29 12
30 12
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edx,%edx
callq  ebb <read_line+0xb>
add    $0x8,%rsp
cltq   
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_line(int fd, void * buf, size_t len)
{
 return swgp_read_line(fd, (STROB*)buf, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rdx,%rdx
mov    (%rax),%rax
mov    %rax,(%rsi)
je     86 <getitem+0x16>
movq   $0x0,(%rdx)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
getitem (void *owner, void **pret, const void **pkey)
{
  struct list_iterator *itr = owner;
  *pret = itr->cur->item;
  if (pkey)
    *pkey = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 5
6 6
7 8
8 8
9 8
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
clock_refresh()
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
lea    -0x1(%rdi),%ebx
sub    $0x68,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x58(%rsp)
xor    %eax,%eax
cmp    $0x1,%edi
jle    53 <main+0x53>
nopl   0x0(%rax)
add    $0x8,%rbp
mov    0x0(%rbp),%rdi
callq  35 <main+0x35>
sub    $0x1,%ebx
jne    28 <main+0x28>
xor    %eax,%eax
mov    0x58(%rsp),%rsi
xor    %fs:0x28,%rsi
jne    c0 <main+0xc0>
add    $0x68,%rsp
pop    %rbx
pop    %rbp
retq   
mov    %rsp,%rbx
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 67 <main+0x67>
mov    $0x50,%esi
mov    %rbx,%rdi
callq  74 <main+0x74>
test   %rax,%rax
je     3a <main+0x3a>
mov    %rbx,%rdx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     7c <main+0x7c>
mov    %eax,%ecx
mov    %rbx,%rdi
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmove  %rcx,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbx,%rdx
movb   $0x0,-0x1(%rsp,%rdx,1)
callq  be <main+0xbe>
jmp    60 <main+0x60>
callq  c5 <main+0xc5>
<<<sep_in_sample>>>
main(int argc, char **argv)
{
    if (argc > 1) {
 while (--argc)
     print_greek(*++argv);
    } else {
 char buf[80];
 while (fgets(buf, sizeof(buf), stdin)) {
     buf[strlen(buf)-1] = 0;
     print_greek(buf);
 }
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 5
13 5
14 5
15 4
16 4
17 14
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 14
27 8
28 8
29 8
30 8
31 8
32 8
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 10
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 10
53 10
54 14
<<<sep_out_sample>>>
lea    -0x1(%rsi),%rdx
xor    %eax,%eax
test   %rsi,%rsi
cmovne %rdx,%rax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
move_mbleft(const char *buf, size_t pos)
{
    size_t before, char_len = 0;
    ((void) (0));
    if (mb_cur_max() > pos)
 before = 0;
    else
 before = pos - mb_cur_max();
    while (before < pos) {
 char_len = parse_mbchar(buf + before, ((void *)0), ((void *)0));
 before += char_len;
    }
    return before - char_len;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 14
6 14
<<<sep_out_sample>>>
jmpq   925 <grecs_grecs_alloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_alloc (grecs_grecs__size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x28,%rsp
movsd  0x0(%rip),%xmm2        # 6c <gsl_ran_logistic_pdf+0xc>
movsd  0x0(%rip),%xmm3        # 74 <gsl_ran_logistic_pdf+0x14>
andpd  %xmm2,%xmm0
movsd  %xmm1,0x8(%rsp)
movapd %xmm2,0x10(%rsp)
xorpd  %xmm3,%xmm0
divsd  %xmm1,%xmm0
callq  91 <gsl_ran_logistic_pdf+0x31>
movsd  0x0(%rip),%xmm3        # 99 <gsl_ran_logistic_pdf+0x39>
movsd  0x8(%rsp),%xmm1
movapd 0x10(%rsp),%xmm2
addsd  %xmm0,%xmm3
add    $0x28,%rsp
andpd  %xmm2,%xmm1
mulsd  %xmm3,%xmm1
mulsd  %xmm3,%xmm1
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_logistic_pdf (const double x, const double a)
{
  double u = exp (-fabs(x)/a);
  double p = u / (fabs(a) * (1 + u) * (1 + u));
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 6
15 4
16 4
17 4
18 4
19 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%eax
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
test   %eax,%eax
je     3d48 <is_close+0x28>
callq  3d33 <is_close+0x13>
mov    0x1020(%rbx),%rdi
test   %rdi,%rdi
je     3d59 <is_close+0x39>
pop    %rbx
jmpq   3d45 <is_close+0x25>
nopl   (%rax)
callq  3d4d <is_close+0x2d>
mov    0x1020(%rbx),%rdi
test   %rdi,%rdi
jne    3d3f <is_close+0x1f>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_close (InputStream *is)
{
  if (is->is_pipe)
    pclose (is->fp);
  else
    fclose (is->fp);
  if (is->unget_ch)
    xfree (is->unget_ch);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 3
6 3
7 4
8 7
9 7
10 7
11 9
12 8
13 8
14 6
15 7
16 7
17 7
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %rdi,%rdi
cmove  %rax,%rdi
test   %rsi,%rsi
movl   $0x8,(%rdi)
je     e7d <set_custom_quoting+0x2d>
test   %rdx,%rdx
je     e7d <set_custom_quoting+0x2d>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
callq  e82 <set_custom_quoting+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 6
7 7
8 7
9 7
10 9
11 10
12 11
13 11
14 8
15 8
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 1027 <open_diag+0x7>
jne    1030 <open_diag+0x10>
jmpq   102e <open_diag+0xe>
xchg   %ax,%ax
jmpq   1035 <open_diag+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
open_diag (char const *name)
{
  if (ignore_failed_read_option)
    open_warn (name);
  else
    open_error (name);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,0x8(%rsp)
movl   $0x0,(%rsp)
xor    %r9d,%r9d
callq  38 <_getopt_long_r+0x18>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
_getopt_long_r (int argc, char **argv, const char *options,
  const struct option *long_options, int *opt_index,
  struct _getopt_data *d)
{
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
        0, 0, d);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 7
7 7
8 7
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
add    %rbp,%r14
push   %rbx
mov    %rdx,%rbx
callq  2f9 <is_separate_word+0x19>
movslq %eax,%rdi
callq  301 <is_separate_word+0x21>
mov    %rax,%r13
callq  309 <is_separate_word+0x29>
movslq %eax,%rdi
callq  311 <is_separate_word+0x31>
mov    %rbp,%rsi
mov    %rbx,%rdi
mov    %rax,%r12
callq  31f <is_separate_word+0x3f>
lea    (%rbx,%rax,1),%rdi
xor    %edx,%edx
mov    %r13,%rsi
callq  32d <is_separate_word+0x4d>
lea    (%rbx,%r14,1),%rdi
xor    %edx,%edx
mov    %r12,%rsi
callq  33b <is_separate_word+0x5b>
test   %rbp,%rbp
jne    380 <is_separate_word+0xa0>
mov    %rbx,%rdi
mov    $0x1,%ebp
callq  34d <is_separate_word+0x6d>
cmp    %r14,%rax
je     35f <is_separate_word+0x7f>
mov    %r12,%rdi
callq  35a <is_separate_word+0x7a>
mov    %eax,%ebp
xor    $0x1,%ebp
mov    %r13,%rdi
callq  367 <is_separate_word+0x87>
mov    %r12,%rdi
callq  36f <is_separate_word+0x8f>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    %r13,%rdi
xor    %ebp,%ebp
callq  38a <is_separate_word+0xaa>
test   %al,%al
je     340 <is_separate_word+0x60>
jmp    35f <is_separate_word+0x7f>
<<<sep_in_sample>>>
is_separate_word(size_t position, size_t length, const char *buf)
{
    char *before = (char *)nmalloc((mb_cur_max()) * sizeof(char)), *after = (char *)nmalloc((mb_cur_max()) * sizeof(char));
    size_t word_end = position + length;
    _Bool retval;
    ((void) (0));
    parse_mbchar(buf + move_mbleft(buf, position), before, ((void *)0));
    parse_mbchar(buf + word_end, after, ((void *)0));
    retval = (position == 0 || !is_alpha_mbchar(before)) &&
  (word_end == strlen(buf) || !is_alpha_mbchar(after));
    free(before);
    free(after);
    return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 7
18 7
19 3
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
28 8
29 9
30 9
31 10
32 10
33 10
34 9
35 9
36 10
37 10
38 10
39 10
40 11
41 11
42 12
43 12
44 14
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 9
53 9
54 9
55 9
56 9
57 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x20(%rdi),%r13d
mov    0x80(%rdi),%rbx
test   $0x800,%r13d
jne    1d0 <skip_delim+0x40>
and    $0x1000,%r13d
cmp    $0x1,%r13d
adc    $0x0,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
and    $0x1000,%r13d
je     218 <skip_delim+0x88>
mov    0x70(%rdi),%r12
mov    0x28(%rdi),%rdi
movzbl (%r12,%rbx,1),%r14d
movsbl %r14b,%esi
callq  1ef <skip_delim+0x5f>
test   %rax,%rax
je     218 <skip_delim+0x88>
mov    0x78(%rbp),%rax
jmp    206 <skip_delim+0x76>
nopw   0x0(%rax,%rax,1)
cmp    (%r12,%rbx,1),%r14b
jne    20f <skip_delim+0x7f>
add    $0x1,%rbx
cmp    %rax,%rbx
jb     200 <skip_delim+0x70>
sub    $0x1,%rbx
jmp    1b6 <skip_delim+0x26>
nopl   (%rax)
mov    0x78(%rbp),%r12
jmp    236 <skip_delim+0xa6>
xchg   %ax,%ax
mov    0x70(%rbp),%rax
mov    0x28(%rbp),%rdi
movsbl (%rax,%rbx,1),%esi
callq  231 <skip_delim+0xa1>
test   %rax,%rax
je     20f <skip_delim+0x7f>
add    $0x1,%rbx
cmp    %r12,%rbx
jb     220 <skip_delim+0x90>
sub    $0x1,%rbx
jmpq   1b6 <skip_delim+0x26>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skip_delim (struct wordsplit *wsp)
{
  size_t start = wsp->ws_endp;
  if (wsp->ws_flags & 0x00000800)
    {
      if ((wsp->ws_flags & 0x00001000) &&
   (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)))
 {
   int delim = wsp->ws_input[start];
   do
     start++;
   while (start < wsp->ws_len && delim == wsp->ws_input[start]);
 }
      else
 {
   do
     start++;
   while (start < wsp->ws_len && (strchr ((wsp)->ws_delim, (wsp->ws_input[start])) != ((void *)0)));
 }
      start--;
    }
  if (!(wsp->ws_flags & 0x00001000))
    start++;
  return start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 3
9 4
10 4
11 4
12 23
13 23
14 25
15 25
16 25
17 25
18 25
19 25
20 25
21 25
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 6
30 6
31 6
32 6
33 6
34 12
35 12
36 11
37 12
38 12
39 20
40 20
41 20
42 20
43 20
44 20
45 18
46 18
47 18
48 18
49 18
50 18
51 17
52 18
53 18
54 20
55 20
56 20
<<<sep_out_sample>>>
jmpq   150 <nntp_itr_next>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_first (void *data)
{
  return nntp_itr_next (data);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  0 <bufmap_free>
test   %rbx,%rbx
je     ac <bufmap_reset+0x2c>
nopw   %cs:0x0(%rax,%rax,1)
add    %rbp,0x8(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    a0 <bufmap_reset+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bufmap_reset (struct bufmap *map, ssize_t fixup)
{
  bufmap_free (map);
  if (map)
    {
      for (; map; map = map->next)
 map->start += fixup;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 7
11 6
12 6
13 6
14 9
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1666 <yyset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_debug (int bdebug )
{
        yy_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdx
mov    $0x200,%ecx
mov    $0x0,%edi
callq  97 <etar_emit_header+0x17>
mov    $0xffffffff,%edx
cmp    $0x200,%eax
mov    $0x200,%eax
cmove  %eax,%edx
add    $0x8,%rsp
mov    %edx,%eax
retq   
<<<sep_in_sample>>>
etar_emit_header(ETAR * etar, int fd)
{
 int ret;
 ret = atomicio((ssize_t (*)(int, void *, size_t))(write),
  fd, (void*)(((struct tar_header *)((etar)->tar_hdrM))), 512);
 if (ret != 512) {
  return -1;
 }
 return 512;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 7
7 7
8 7
9 7
10 10
11 10
12 10
<<<sep_out_sample>>>
push   %rbx
mov    0xa0(%rsi),%r8
mov    %rdi,%rbx
mov    0xa8(%rsi),%rsi
mov    0xa0(%rdi),%r9
test   %rsi,%rsi
lea    -0x1(%rsi),%rdx
je     1567 <convert_eols+0x87>
lea    0x1(%r9),%rax
jmp    152d <convert_eols+0x4d>
nopl   0x0(%rax,%rax,1)
add    $0x1,%r8
test   %rdx,%rdx
mov    %cl,-0x1(%rax)
mov    %rax,%r9
lea    -0x1(%rdx),%rcx
je     1567 <convert_eols+0x87>
mov    %rdx,%rsi
add    $0x1,%rax
mov    %rcx,%rdx
movzbl (%r8),%ecx
lea    -0x1(%rax),%r10
cmp    $0xd,%cl
jne    1510 <convert_eols+0x30>
test   %rdx,%rdx
je     1560 <convert_eols+0x80>
movzbl 0x1(%r8),%ecx
add    $0x1,%r8
cmp    $0xa,%cl
je     1590 <convert_eols+0xb0>
movb   $0xd,-0x1(%rax)
lea    -0x1(%rdx),%rcx
jmp    1523 <convert_eols+0x43>
nopw   0x0(%rax,%rax,1)
mov    %rax,%r9
movb   $0xd,(%r10)
movb   $0x0,(%r9)
mov    0xa0(%rbx),%rdi
sub    %rdi,%r9
lea    0x1(%r9),%rsi
mov    %r9,0xa8(%rbx)
callq  1585 <convert_eols+0xa5>
mov    %rax,0xa0(%rbx)
pop    %rbx
retq   
xchg   %ax,%ax
lea    -0x2(%rsi),%rdx
jmpq   1510 <convert_eols+0x30>
nopl   0x0(%rax)
<<<sep_in_sample>>>
convert_eols (FILE_BUFFER *destination, FILE_BUFFER *source)
{
  register char *d = destination->contents;
  register char *s = source->contents;
  long textlen = source->filesize;
  while (textlen--)
    {
      if (*s == '\r' && textlen && s[1] == '\n')
        {
          s++;
          textlen--;
        }
      *d++ = *s++;
    }
  *d = '\0';
  destination->filesize = d - destination->contents;
  destination->contents = xrealloc (destination->contents,
                                    d - destination->contents + 1);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 5
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 13
13 6
14 13
15 13
16 6
17 6
18 2
19 2
20 2
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 10
29 8
30 8
31 13
32 6
33 6
34 6
35 13
36 13
37 15
38 16
39 16
40 18
41 16
42 17
43 17
44 19
45 19
46 19
47 11
48 11
49 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzbl %sil,%edi
mov    (%rbx),%rsi
callq  10 <sexp_put_raw_char+0x10>
test   %eax,%eax
js     21 <sexp_put_raw_char+0x21>
addl   $0x1,0x40(%rbx)
movl   $0x0,0x44(%rbx)
pop    %rbx
retq   
callq  26 <sexp_put_raw_char+0x26>
mov    (%rax),%edi
callq  2d <sexp_put_raw_char+0x2d>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  3c <sexp_put_raw_char+0x3c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sexp_put_raw_char(struct sexp_output *output, uint8_t c)
{
  if (_IO_putc (c, output->f) < 0)
    die("Write failed: %s\n", strerror((*__errno_location ())));
  output->pos++;
  output->soft_newline = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 6
10 7
11 7
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  1d <rk4imp_free+0xd>
mov    0x28(%rbx),%rdi
callq  26 <rk4imp_free+0x16>
mov    0x20(%rbx),%rdi
callq  2f <rk4imp_free+0x1f>
mov    (%rbx),%rdi
callq  37 <rk4imp_free+0x27>
mov    0x8(%rbx),%rdi
callq  40 <rk4imp_free+0x30>
mov    0x10(%rbx),%rdi
callq  49 <rk4imp_free+0x39>
mov    0x18(%rbx),%rdi
callq  52 <rk4imp_free+0x42>
mov    %rbx,%rdi
pop    %rbx
jmpq   5b <rk4imp_free+0x4b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4imp_free (void *vstate)
{
  rk4imp_state_t *state = (rk4imp_state_t *) vstate;
  free (state->y_onestep);
  free (state->y0_orig);
  free (state->y0);
  free (state->k1nu);
  free (state->k2nu);
  free (state->ytmp1);
  free (state->ytmp2);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 12
19 11
20 11
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    %esi,%edx
mov    %rdx,0x18(%rax)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahs_set_uid(AHS * xhs, uid_t uid) {
 ;
        ahs_vfile_hdr(xhs)->c_uid = uid;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     aeb <osip_transaction_set_out_socket+0xb>
mov    %esi,0x74(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_out_socket (osip_transaction_t * transaction, int sock)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->out_socket = sock;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
jmpq   995 <sv_path+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_path (name)
     char *name;
{
  phash_flush ();
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %edi,%eax
sub    $0x8,%rsp
mov    %rsi,%rdi
mov    %eax,%esi
callq  fe0 <swextopt_is_option_true+0x10>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   fec <swextopt_is_option_true+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swextopt_is_option_true(enum eOpts nopt, struct extendedOptions * options)
{
 char * val;
 val = get_opta(options, nopt);
 return swextopt_is_value_true(val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 6
7 5
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%esi
mov    $0x0,%esi
sbb    %edi,%edi
xor    %eax,%eax
and    $0xfffffffc,%edi
add    $0x7,%edi
callq  1b <mu_debug_syslog_printer+0x1b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_debug_syslog_printer (void *unused, mu_log_level_t level, const char *str)
{
  syslog ((level == 0) ? 3 : 7, "%s", str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 1743 <skip+0x13>
lea    0x1(%rax),%edi
callq  174b <skip+0x1b>
sub    $0x1,%ebx
mov    %rax,%rbp
js     17d0 <skip+0xa0>
mov    0x0(%rip),%edx        # 1759 <skip+0x29>
movslq %edx,%rax
mov    0x0(,%rax,8),%rdi
test   %rdi,%rdi
je     17e5 <skip+0xb5>
mov    0x0(,%rax,4),%ecx
test   %ecx,%ecx
je     17ab <skip+0x7b>
jmp    17e5 <skip+0xb5>
nopw   %cs:0x0(%rax,%rax,1)
movslq %ecx,%rdx
sub    $0x1,%ebx
addl   $0x1,0x0(,%rdx,4)
cmp    $0xffffffff,%ebx
je     17d0 <skip+0xa0>
mov    0x0(,%rdx,8),%rdi
test   %rdi,%rdi
je     17e3 <skip+0xb3>
mov    0x0(,%rdx,4),%eax
test   %eax,%eax
jne    17e3 <skip+0xb3>
mov    %rbp,%rsi
callq  380 <dap_getline>
test   %eax,%eax
mov    0x0(%rip),%ecx        # 17bb <skip+0x8b>
jns    1780 <skip+0x50>
movslq %ecx,%rax
movl   $0x1,0x0(,%rax,4)
jmp    1780 <skip+0x50>
nopl   (%rax)
add    $0x8,%rsp
mov    %rbp,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
jmpq   17e3 <skip+0xb3>
mov    %ecx,%edx
mov    0x0(%rip),%rdi        # 17ec <skip+0xbc>
mov    $0x0,%esi
xor    %eax,%eax
callq  17f8 <skip+0xc8>
mov    $0x1,%edi
callq  1802 <skip+0xd2>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skip(int nlines)
{
  char *line;
  line = dap_malloc(dap_linelen + 1, "skip: line");
  while (--nlines >= 0)
    {
      if (!dap_in[dap_ono] || eof[dap_ono])
 {
   fprintf(dap_err, "(skip) tried to read past end of file (%d).\n",
    dap_ono);
   exit(1);
 }
      if (dap_getline(dap_in[dap_ono], line) < 0)
 eof[dap_ono] = 1;
      lineno[dap_ono]++;
    }
  dap_free(line, "skip: line");
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 4
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 15
23 5
24 15
25 5
26 5
27 7
28 7
29 7
30 7
31 7
32 7
33 13
34 13
35 13
36 14
37 13
38 14
39 14
40 14
41 14
42 18
43 17
44 17
45 18
46 18
47 17
48 7
49 9
50 9
51 9
52 9
53 11
54 11
55 11
<<<sep_out_sample>>>
mov    0x38(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexget_leng (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyg->yyleng_r;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0xe8(%rdi),%rbx
mov    0x48(%rbx),%rsi
test   %rsi,%rsi
je     11a <CDB___ham_release_meta+0x2a>
mov    0x70(%rbx),%edx
mov    (%rdi),%rdi
shr    $0x2,%edx
and    $0x1,%edx
callq  11a <CDB___ham_release_meta+0x2a>
testb  $0x4,0x150(%rbp)
movq   $0x0,0x48(%rbx)
jne    132 <CDB___ham_release_meta+0x42>
cmpq   $0x0,0x8(%rbp)
je     150 <CDB___ham_release_meta+0x60>
movq   $0x0,0x38(%rbx)
andl   $0xfffffffb,0x70(%rbx)
add    $0x8,%rsp
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x38(%rbx)
je     132 <CDB___ham_release_meta+0x42>
mov    0x0(%rbp),%rax
lea    0x38(%rbx),%rsi
mov    0x28(%rax),%rdi
callq  168 <CDB___ham_release_meta+0x78>
jmp    132 <CDB___ham_release_meta+0x42>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___ham_release_meta(dbc)
 DBC *dbc;
{
 HASH_CURSOR *hcp;
 hcp = (HASH_CURSOR *)dbc->internal;
 if (hcp->hdr)
  (void)CDB___ham_put_page(dbc->dbp, (PAGE *)hcp->hdr,
      ((hcp)->flags & (0x0004)) ? 1 : 0);
 hcp->hdr = ((void *)0);
 if (!((dbc)->flags & (0x004)) &&
     dbc->txn == ((void *)0) && hcp->hlock.off != 0)
  (void)CDB_lock_put(dbc->dbp->dbenv, &hcp->hlock);
 hcp->hlock.off = 0;
 (hcp)->flags &= ~(0x0004);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 10
15 9
16 10
17 10
18 10
19 13
20 14
21 16
22 16
23 16
24 16
25 16
26 16
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b7 <read_stdin+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_stdin (void)
{
  FILE * input_file = stdin;
  return input_file;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 30d8 <gsl_sf_legendre_deriv2_array+0x8>
jmpq   30dd <gsl_sf_legendre_deriv2_array+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_sf_legendre_deriv2_array
(const gsl_sf_legendre_t norm, const size_t lmax, const double x,
 double result_array[], double result_deriv_array[], double result_deriv2_array[])
{
  int s = gsl_sf_legendre_deriv2_array_e(norm, lmax, x, 1.0, result_array, result_deriv_array, result_deriv2_array);
  return s;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 326 <gsl_vector_set+0x6>
test   %eax,%eax
je     32f <gsl_vector_set+0xf>
cmp    %rsi,(%rdi)
jbe    348 <gsl_vector_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rdx
shl    $0x3,%rax
imul   %rsi,%rax
movsd  %xmm0,(%rdx,%rax,1)
retq   
nopl   (%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   361 <gsl_vector_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_set (gsl_vector * v, const size_t i, double x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_double.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1419 <gsl_vector_short_isnonneg+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
add    %rsi,%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movswl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm0,%xmm1
ja     141f <gsl_vector_short_isnonneg+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1400 <gsl_vector_short_isnonneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_isnonneg (const gsl_vector_short * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  5cc <gsl_stats_wsd+0x1c>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rcx
mov    %r14,%r8
pop    %r13
pop    %r14
jmpq   5e8 <gsl_stats_wsd+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wsd (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_wmean (w, wstride, data, stride, n);
  return gsl_stats_wsd_m (w, wstride, data, stride, n, wmean) ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 4
14 4
15 5
16 5
17 5
18 4
19 4
20 5
21 5
22 4
23 4
<<<sep_out_sample>>>
lea    0x1(%rdi),%rax
imul   %rdi,%rax
add    $0x2,%rdi
shr    %rax
imul   %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mul3 (mp_limb_t m)
{
  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;
  mp_limb_t m2 = (m + 2);
  return m01 * m2;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 5
6 6
7 6
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm2        # 10 <gsl_cdf_rayleigh_P+0x10>
movapd %xmm2,(%rsp)
movapd %xmm0,%xmm1
xorpd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 29 <gsl_cdf_rayleigh_P+0x29>
movapd %xmm1,%xmm0
callq  32 <gsl_cdf_rayleigh_P+0x32>
movapd (%rsp),%xmm2
add    $0x18,%rsp
xorpd  %xmm2,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_rayleigh_P (const double x, const double sigma)
{
  double u = x / sigma;
  double P = -expm1 (-u*u/2);
  return P;
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 4
14 6
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     7d7 <mu_record_list_p+0x27>
mov    0x60(%rdi),%rcx
mov    $0x1,%al
test   %rcx,%rcx
je     7d7 <mu_record_list_p+0x27>
sub    $0x8,%rsp
callq  *%rcx
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
mu_record_list_p (mu_record_t record, const char *name, int flags)
{
  if (record == ((void *)0))
    return 22;
  return record == ((void *)0)
          || !record->_list_p
          || record->_list_p (record, name, flags);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 6
5 7
6 6
7 6
8 2
9 7
10 7
11 7
12 8
13 7
14 8
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  681 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6c0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  69f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6d8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6c0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6e4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
movslq %edi,%rax
imul   $0x5a0,%rax,%rax
add    $0x0,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lookupCraftByIndex(int craft_index)
{
 return &ctype[craft_index];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     2fc0 <gsl_matrix_ushort_add+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2faf <gsl_matrix_ushort_add+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%r8
cmp    %rax,%r8
jne    2f96 <gsl_matrix_ushort_add+0x16>
test   %r10,%r10
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r12
je     3021 <gsl_matrix_ushort_add+0xa1>
add    %r13,%r13
add    %r12,%r12
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
nopl   0x0(%rax,%rax,1)
test   %r8,%r8
je     3012 <gsl_matrix_ushort_add+0x92>
mov    %rbx,%rdx
mov    %rbp,%r9
add    0x18(%rdi),%rdx
add    0x18(%rsi),%r9
xor    %eax,%eax
nopl   (%rax)
movzwl (%r9,%rax,2),%ecx
add    %cx,(%rdx,%rax,2)
add    $0x1,%rax
cmp    %r8,%rax
jne    3000 <gsl_matrix_ushort_add+0x80>
add    $0x1,%r11
add    %r13,%rbx
add    %r12,%rbp
cmp    %r10,%r11
jne    2fe8 <gsl_matrix_ushort_add+0x68>
xor    %eax,%eax
jmp    2fb4 <gsl_matrix_ushort_add+0x34>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_add (gsl_matrix_ushort * a, const gsl_matrix_ushort * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 28, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 21
55 21
56 21
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%rdx
test   %rax,%rax
je     1270 <unlink_prog+0x30>
mov    %rdx,(%rax)
mov    (%rdi),%rdx
test   %rdx,%rdx
je     1260 <unlink_prog+0x20>
mov    %rax,0x8(%rdx)
retq   
nopl   0x0(%rax)
mov    %rax,0x0(%rip)        # 1267 <unlink_prog+0x27>
retq   
nopl   0x0(%rax,%rax,1)
mov    %rdx,0x0(%rip)        # 1277 <unlink_prog+0x37>
jmp    1252 <unlink_prog+0x12>
nopl   0x0(%rax)
<<<sep_in_sample>>>
unlink_prog (struct prog *pp)
{
  struct prog *x;
  if ((x = pp->prev))
    x->next = pp->next;
  else
    proghead = pp->next;
  if ((x = pp->next))
    x->prev = pp->prev;
  else
    progtail = pp->prev;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 5
6 5
7 8
8 8
9 9
10 9
11 9
12 11
13 11
14 11
15 7
16 7
17 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f9 <safe_write+0x9>
test   %rax,%rax
js     103 <safe_write+0x13>
add    $0x8,%rsp
retq   
callq  108 <safe_write+0x18>
mov    (%rax),%esi
mov    $0x0,%edx
mov    $0x1,%edi
pop    %rcx
xor    %eax,%eax
jmpq   11c <safe_write+0x2c>
<<<sep_in_sample>>>
safe_write (int socket, const char *str, size_t len)
{
  if (write (socket, str, len) < 0)
    error (1, (*__errno_location ()), "error sending data");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 4
8 4
9 4
10 4
11 5
12 4
13 4
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
push   %rbx
movapd %xmm0,%xmm2
mov    %rdi,%rbx
sub    $0x10,%rsp
movsd  0x0(%rip),%xmm1        # 964 <gsl_sf_erf_Z_e+0x14>
movsd  %xmm2,0x8(%rsp)
xorpd  %xmm2,%xmm1
movapd %xmm1,%xmm0
mulsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # 97e <gsl_sf_erf_Z_e+0x2e>
callq  983 <gsl_sf_erf_Z_e+0x33>
divsd  0x0(%rip),%xmm0        # 98b <gsl_sf_erf_Z_e+0x3b>
xor    %eax,%eax
movsd  0x8(%rsp),%xmm2
movsd  0x0(%rip),%xmm3        # 99b <gsl_sf_erf_Z_e+0x4b>
movapd %xmm0,%xmm1
movsd  %xmm0,(%rbx)
mulsd  %xmm2,%xmm0
andpd  %xmm3,%xmm1
movsd  0x0(%rip),%xmm2        # 9b3 <gsl_sf_erf_Z_e+0x63>
andpd  %xmm3,%xmm0
mulsd  %xmm1,%xmm2
mulsd  0x0(%rip),%xmm0        # 9c3 <gsl_sf_erf_Z_e+0x73>
addsd  %xmm2,%xmm0
movsd  %xmm0,0x8(%rbx)
movsd  0x0(%rip),%xmm0        # 9d4 <gsl_sf_erf_Z_e+0x84>
ucomisd %xmm1,%xmm0
jbe    9f8 <gsl_sf_erf_Z_e+0xa8>
mov    $0xf,%ecx
mov    $0x180,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9f3 <gsl_sf_erf_Z_e+0xa3>
mov    $0xf,%eax
add    $0x10,%rsp
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_sf_erf_Z_e(double x, gsl_sf_result * result)
{
  {
    const double ex2 = exp(-x*x/2.0);
    result->val = ex2 / (1.41421356237309504880 * 1.77245385090551602729816748334);
    result->err = fabs(x * result->val) * 2.2204460492503131e-16;
    result->err += 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    if (fabs((result)->val) < 2.2250738585072014e-308) do { gsl_error ("underflow", "erfc.c", 384, GSL_EUNDRFLW) ; return GSL_EUNDRFLW ; } while (0);;
    return GSL_SUCCESS;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 9
14 6
15 7
16 7
17 5
18 6
19 7
20 7
21 6
22 7
23 6
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 11
36 11
37 11
38 11
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     e58 <rec_rset_set_type+0x88>
cmpq   $0x0,(%rdi)
mov    %rdi,%rbx
je     e60 <rec_rset_set_type+0x90>
mov    $0x5,%edi
callq  df1 <rec_rset_set_type+0x21>
mov    (%rbx),%rdi
xor    %edx,%edx
mov    %rax,%rsi
callq  dfe <rec_rset_set_type+0x2e>
test   %rax,%rax
je     e18 <rec_rset_set_type+0x48>
add    $0x8,%rsp
mov    %rbp,%rsi
mov    %rax,%rdi
pop    %rbx
pop    %rbp
jmpq   e14 <rec_rset_set_type+0x44>
nopl   0x0(%rax)
mov    $0x5,%edi
callq  e22 <rec_rset_set_type+0x52>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  e2d <rec_rset_set_type+0x5d>
mov    (%rbx),%rdi
mov    %rax,%rbp
callq  e38 <rec_rset_set_type+0x68>
add    $0x8,%rsp
mov    %rbp,%rdx
mov    $0x1,%ecx
pop    %rbx
pop    %rbp
mov    $0x1,%esi
mov    %rax,%rdi
jmpq   e53 <rec_rset_set_type+0x83>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
callq  e65 <rec_rset_set_type+0x95>
mov    %rax,(%rbx)
jmpq   de7 <rec_rset_set_type+0x17>
nopl   (%rax)
<<<sep_in_sample>>>
rec_rset_set_type (rec_rset_t rset,
                   const char *type)
{
  rec_field_t rec_field;
  if (!type)
    {
      return;
    }
  if (!rset->descriptor)
    {
      rset->descriptor = rec_record_new ();
    }
  rec_field = rec_record_get_field_by_name (rset->descriptor,
                                            rec_std_field_name ((REC_FIELD_REC)),
                                            0);
  if (rec_field)
    {
      rec_field_set_value (rec_field, type);
    }
  else
    {
      rec_field = rec_field_new (rec_std_field_name ((REC_FIELD_REC)), type);
      rec_mset_append (rec_record_mset (rset->descriptor), 1, (void *) rec_field, 1);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 9
10 13
11 13
12 13
13 13
14 13
15 13
16 16
17 16
18 25
19 18
20 18
21 25
22 25
23 18
24 18
25 22
26 22
27 22
28 22
29 22
30 23
31 22
32 23
33 25
34 23
35 23
36 25
37 25
38 23
39 23
40 23
41 23
42 25
43 25
44 25
45 25
46 25
47 11
48 11
49 11
50 11
<<<sep_out_sample>>>
push   %rbp
mov    $0x1000,%edx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    %rbx,%rdi
sub    $0x1018,%rsp
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x1008(%rsp)
xor    %eax,%eax
callq  1a2 <histfile_restore+0x32>
test   %rax,%rax
jle    1d8 <histfile_restore+0x68>
mov    %rsp,%rsi
mov    %rbp,%rdi
movb   $0x0,(%rsp,%rax,1)
callq  1b6 <histfile_restore+0x46>
mov    0x1008(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    1e5 <histfile_restore+0x75>
add    $0x1018,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1e3 <histfile_restore+0x73>
jmp    1b6 <histfile_restore+0x46>
callq  1ea <histfile_restore+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
histfile_restore (backup, orig)
     const char *backup;
     const char *orig;
{
  char linkbuf[4096 +1];
  ssize_t n;
  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)
    {
      linkbuf[n] = '\0';
      return (rename (backup, linkbuf));
    }
  return (rename (backup, orig));
}
<<<sep_in_sample>>>
1 4
2 7
3 4
4 4
5 4
6 7
7 4
8 7
9 4
10 4
11 4
12 7
13 7
14 7
15 10
16 10
17 9
18 10
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 12
28 12
29 12
30 12
31 13
32 13
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     68 <i_is_value_true+0x68>
mov    $0x0,%esi
mov    $0x1,%ebp
callq  1d <i_is_value_true+0x1d>
test   %eax,%eax
je     58 <i_is_value_true+0x58>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  2e <i_is_value_true+0x2e>
test   %eax,%eax
je     58 <i_is_value_true+0x58>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  3f <i_is_value_true+0x3f>
test   %eax,%eax
je     58 <i_is_value_true+0x58>
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %ebp,%ebp
callq  52 <i_is_value_true+0x52>
test   %eax,%eax
sete   %bpl
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %ebp,%ebp
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
i_is_value_true(char * s)
{
 if (
  s != ((void *)0) &&
  (
   strcasecmp(s, "t") == 0 ||
   strcasecmp(s, "true") == 0 ||
   strcasecmp(s, "yes") == 0 ||
   strcasecmp(s, "y") == 0 ||
   0
  )
 ) {
  return 1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 6
8 13
9 6
10 4
11 4
12 7
13 7
14 7
15 6
16 6
17 8
18 8
19 8
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
28 16
29 16
30 16
31 16
32 16
33 16
34 16
35 15
36 16
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 7 <nettle_hmac_sha384_set_key+0x7>
mov    %rsi,%r8
mov    %rdx,%r9
lea    0xd8(%rdi),%rsi
lea    0x1b0(%rdi),%rdx
jmpq   20 <nettle_hmac_sha384_digest>
<<<sep_in_sample>>>
nettle_hmac_sha384_set_key(struct hmac_sha512_ctx *ctx,
      size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_sha384), (key_length), (key) );
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x18(%rsi),%rcx
mov    %rdi,%rax
mov    (%rsi),%rdi
test   %rcx,%rcx
jne    12b <gl_tree_iterator+0x1b>
jmp    133 <gl_tree_iterator+0x23>
nopl   0x0(%rax)
mov    %rdx,%rcx
mov    (%rcx),%rdx
test   %rdx,%rdx
jne    128 <gl_tree_iterator+0x18>
mov    %rdi,(%rax)
mov    %rsi,0x8(%rax)
movq   $0x0,0x10(%rax)
mov    %rcx,0x18(%rax)
movq   $0x0,0x20(%rax)
movq   $0x0,0x28(%rax)
movq   $0x0,0x30(%rax)
retq   
nop
<<<sep_in_sample>>>
gl_tree_iterator (gl_oset_t set)
{
  gl_oset_iterator_t result;
  gl_oset_node_t node;
  result.vtable = set->base.vtable;
  result.set = set;
  node = set->root;
  if (node != ((void *)0))
    while (node->left != ((void *)0))
      node = node->left;
  result.p = node;
  result.q = ((void *)0);
  return result;
}
<<<sep_in_sample>>>
1 7
2 2
3 5
4 8
5 8
6 8
7 8
8 10
9 9
10 9
11 9
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 14
20 14
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%eax
mov    %edx,%ebx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rsp)
mulsd  0x0(%rip),%xmm0        # 165 <display+0x25>
movsd  0x0(%rip),%xmm2        # 16d <display+0x2d>
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  17a <display+0x3a>
movsd  0x0(%rip),%xmm0        # 182 <display+0x42>
ucomisd 0x0(%rip),%xmm0        # 18a <display+0x4a>
jbe    1ad <display+0x6d>
mulsd  0x8(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x1,%eax
divsd  0x0(%rip),%xmm0        # 1a4 <display+0x64>
callq  1a9 <display+0x69>
test   %ebx,%ebx
jne    1c0 <display+0x80>
add    $0x10,%rsp
mov    $0xa,%edi
pop    %rbx
jmpq   1bc <display+0x7c>
nopl   0x0(%rax)
cvtsi2sd %rbx,%xmm1
mov    $0x0,%edi
movsd  0x8(%rsp),%xmm0
mov    $0x1,%eax
mulsd  0x0(%rip),%xmm0        # 1dd <display+0x9d>
mulsd  %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 1e9 <display+0xa9>
callq  1ee <display+0xae>
add    $0x10,%rsp
mov    $0xa,%edi
pop    %rbx
jmpq   1fd <display+0xbd>
nopl   (%rax)
<<<sep_in_sample>>>
display(const char *name, const char *mode, unsigned block_size,
 double time)
{
  printf("%18s %11s %7.2f",
  name, mode,
  10240 / (time * 1048576.0));
  if (frequency > 0.0)
    {
      printf(" %11.2f", time * frequency / 10240);
      if (block_size > 0)
 printf(" %12.2f", time * frequency * block_size / 10240);
    }
  printf("\n");
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 4
6 4
7 3
8 3
9 6
10 4
11 4
12 4
13 4
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 14
25 13
26 14
27 13
28 13
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 14
38 13
39 14
40 13
41 13
<<<sep_out_sample>>>
cmp    $0x2,%edi
push   %rbx
mov    %rsi,%rbx
je     790 <deny_cb+0x30>
mov    $0x0,%edi
callq  773 <deny_cb+0x13>
mov    %rbx,%rdi
mov    %rax,%rdx
xor    %esi,%esi
xor    %eax,%eax
callq  782 <deny_cb+0x22>
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
xor    %esi,%esi
callq  79a <deny_cb+0x3a>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
deny_cb (enum grecs_callback_command cmd,
  grecs_locus_t *locus,
  void *varptr,
  grecs_value_t *value,
  void *cb_data)
{
  pies_acl_t acl = varptr;
  if (cmd != grecs_callback_set_value)
    {
      grecs_error (locus, 0, gettext("unexpected block statement"));
      return 1;
    }
  parse_acl_line (locus, 0, acl, value);
  return 0;
}
<<<sep_in_sample>>>
1 8
2 6
3 6
4 8
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 15
14 15
15 15
16 13
17 13
18 13
19 14
20 15
21 15
22 15
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x668,%rsp
lea    0x10(%rsp),%rbp
mov    %rbp,%rdi
callq  4589 <unit2num+0x19>
mov    %rbx,%rdi
callq  4591 <unit2num+0x21>
test   %eax,%eax
je     45a0 <unit2num+0x30>
add    $0x668,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    0x0(%rip),%rdx        # 45a7 <unit2num+0x37>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  45b2 <unit2num+0x42>
test   %eax,%eax
je     45c8 <unit2num+0x58>
add    $0x668,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %rbx,%rdi
mov    %eax,0xc(%rsp)
callq  45d4 <unit2num+0x64>
mov    0xc(%rsp),%eax
jmp    4595 <unit2num+0x25>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unit2num(struct unittype *input)
{
  struct unittype one;
  int err;
  initializeunit(&one);
  if ((err=completereduce(input)))
    return err;
  if (compareunits(input,&one,ignore_nothing))
    return 5;
  freeunit(input);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 12
13 12
14 12
15 12
16 12
17 8
18 8
19 8
20 8
21 8
22 8
23 12
24 9
25 12
26 12
27 12
28 12
29 10
30 10
31 10
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  661 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6a0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  67f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6b8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6a0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6c4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%r8
movzbl 0x18(%rdi),%edx
mov    %rsi,%rcx
mov    %rdi,%rbx
mov    0x20(%rdi),%rsi
mov    0x8(%rdi),%rdi
callq  9ab <checked_print_quoted+0x1b>
test   %eax,%eax
js     9b8 <checked_print_quoted+0x28>
pop    %rbx
retq   
nopl   0x0(%rax)
callq  9bd <checked_print_quoted+0x2d>
mov    0x10(%rbx),%rsi
mov    (%rax),%edi
pop    %rbx
jmpq   9c9 <checked_print_quoted+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
checked_print_quoted (struct format_val *dest,
                           const char *format, const char *s)
{
  int rv = print_quoted (dest->stream, dest->quote_opts, dest->dest_is_tty,
                         format, s);
  if (rv < 0)
    nonfatal_nontarget_file_error ((*__errno_location ()), dest->filename);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 8
12 8
13 8
14 7
15 7
16 7
17 8
18 7
19 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  d <gnewton_free+0xd>
mov    0x8(%rbx),%rdi
callq  16 <gnewton_free+0x16>
mov    0x18(%rbx),%rdi
callq  1f <gnewton_free+0x1f>
mov    0x20(%rbx),%rdi
pop    %rbx
jmpq   29 <gnewton_free+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gnewton_free (void * vstate)
{
  gnewton_state_t * state = (gnewton_state_t *) vstate;
  gsl_vector_free(state->d);
  gsl_vector_free(state->x_trial);
  gsl_matrix_free(state->lu);
  gsl_permutation_free(state->permutation);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x2060,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2028(%rsp)
xor    %eax,%eax
test   %rdi,%rdi
mov    %rsi,0x2038(%rsp)
mov    %rdx,0x2040(%rsp)
mov    %rcx,0x2048(%rsp)
mov    %r8,0x2050(%rsp)
mov    %r9,0x2058(%rsp)
je     35b0 <rpmGetPath+0x130>
mov    %rdi,%rsi
lea    0x20(%rsp),%rdi
xor    %eax,%eax
callq  34db <rpmGetPath+0x5b>
movslq %eax,%rdi
lea    0x2070(%rsp),%rax
movl   $0x8,0x8(%rsp)
movb   $0x0,(%rdi)
mov    %rax,0x10(%rsp)
lea    0x2030(%rsp),%rax
mov    %rax,0x18(%rsp)
jmp    352b <rpmGetPath+0xab>
nopl   (%rax)
mov    %ecx,%edx
add    0x18(%rsp),%rdx
add    $0x8,%ecx
mov    %ecx,0x8(%rsp)
mov    (%rdx),%rsi
test   %rsi,%rsi
je     354a <rpmGetPath+0xca>
xor    %eax,%eax
callq  3525 <rpmGetPath+0xa5>
movslq %eax,%rdi
movb   $0x0,(%rdi)
mov    0x8(%rsp),%ecx
cmp    $0x30,%ecx
jb     3508 <rpmGetPath+0x88>
mov    0x10(%rsp),%rdx
mov    (%rdx),%rsi
lea    0x8(%rdx),%rax
mov    %rax,0x10(%rsp)
test   %rsi,%rsi
jne    351e <rpmGetPath+0x9e>
lea    0x20(%rsp),%rdx
mov    $0x2000,%ecx
xor    %edi,%edi
callq  355b <rpmGetPath+0xdb>
lea    0x20(%rsp),%rdi
callq  3565 <rpmGetPath+0xe5>
lea    0x20(%rsp),%rdi
mov    %rax,%rbx
callq  3572 <rpmGetPath+0xf2>
mov    %rax,%rdi
callq  357a <rpmGetPath+0xfa>
lea    0x1(%rax),%rdi
callq  3583 <rpmGetPath+0x103>
test   %rax,%rax
je     35c2 <rpmGetPath+0x142>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3593 <rpmGetPath+0x113>
mov    0x2028(%rsp),%rbx
xor    %fs:0x28,%rbx
jne    35d7 <rpmGetPath+0x157>
add    $0x2060,%rsp
pop    %rbx
retq   
nop
mov    $0x1,%dil
callq  35b8 <rpmGetPath+0x138>
test   %rax,%rax
je     35c9 <rpmGetPath+0x149>
movb   $0x0,(%rax)
jmp    3593 <rpmGetPath+0x113>
callq  35c7 <rpmGetPath+0x147>
jmp    3588 <rpmGetPath+0x108>
nopl   0x0(%rax)
callq  35d5 <rpmGetPath+0x155>
jmp    35bd <rpmGetPath+0x13d>
callq  35dc <rpmGetPath+0x15c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rpmGetPath(const char *path, ...)
{
    char buf[8192];
    const char * s;
    char * t, * te;
    va_list ap;
    if (path == ((void *)0))
 return (strcpy((malloc(strlen("")+1) ? : vmefail()), ("")));
    t = buf;
    te = rpm_stpcpy(t, path);
    *te = '\0';
    __builtin_va_start(ap,path);
    while ((s = __builtin_va_arg(ap,const char *)) != ((void *)0)) {
 te = rpm_stpcpy(te, s);
 *te = '\0';
    }
    __builtin_va_end(ap);
    expandMacros(((void *)0), ((void *)0), buf, sizeof(buf));
    return (strcpy((malloc(strlen(rpmCleanPath(buf))+1) ? : vmefail()), (rpmCleanPath(buf))));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 2
8 2
9 2
10 2
11 2
12 7
13 10
14 10
15 10
16 10
17 10
18 12
19 12
20 11
21 12
22 12
23 12
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 14
34 14
35 14
36 15
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 18
47 18
48 18
49 18
50 19
51 19
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 19
60 19
61 19
62 19
63 19
64 20
65 20
66 20
67 20
68 20
69 20
70 20
71 8
72 8
73 8
74 8
75 8
76 8
77 19
78 19
79 19
80 8
81 8
82 20
83 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  289 <parse_accesscheck+0x9>
cmpq   $0x0,(%rax)
movb   $0x0,0x1b(%rax)
movb   $0x0,0x1a(%rax)
movb   $0x0,0x19(%rax)
movb   $0x0,0x18(%rax)
je     2b8 <parse_accesscheck+0x38>
movl   $0x3f666666,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
movl   $0x3e4ccccd,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
parse_accesscheck (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = insert_primary_noarg (entry);
  our_pred->need_stat = our_pred->need_type = 0;
  our_pred->side_effects = our_pred->no_default_print = 0;
  if (( ((our_pred)->pred_func) == (pred_executable) ))
    our_pred->est_success_rate = 0.2;
  else
    our_pred->est_success_rate = 0.9;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 9
4 7
5 7
6 8
7 8
8 9
9 12
10 14
11 14
12 14
13 14
14 10
15 14
16 14
17 14
18 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
lea    0x1(%rsi),%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  15 <unescape+0x15>
test   %rax,%rax
je     c4 <unescape+0xc4>
test   %rbx,%rbx
je     bf <unescape+0xbf>
movzbl 0x0(%rbp),%ecx
test   %cl,%cl
je     bf <unescape+0xbf>
lea    0x1(%rax),%rdx
jmp    5f <unescape+0x5f>
nopl   0x0(%rax)
mov    %rdx,%rsi
mov    %cl,-0x1(%rdx)
add    $0x1,%rbp
sub    $0x1,%rbx
test   %rbx,%rbx
je     98 <unescape+0x98>
movzbl 0x0(%rbp),%ecx
add    $0x1,%rdx
test   %cl,%cl
je     98 <unescape+0x98>
cmp    $0x2,%rbx
jbe    40 <unescape+0x40>
cmp    $0x3d,%cl
jne    40 <unescape+0x40>
movzbl 0x1(%rbp),%esi
cmp    $0x32,%sil
je     a8 <unescape+0xa8>
cmp    $0x33,%sil
jne    40 <unescape+0x40>
cmpb   $0x44,0x2(%rbp)
jne    40 <unescape+0x40>
sub    $0x3,%rbx
add    $0x3,%rbp
mov    %rdx,%rsi
test   %rbx,%rbx
movb   $0x3d,-0x1(%rdx)
jne    53 <unescape+0x53>
nopl   0x0(%rax)
movb   $0x0,(%rsi)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmpb   $0x43,0x2(%rbp)
jne    40 <unescape+0x40>
mov    %rdx,%rsi
movb   $0x2c,-0x1(%rdx)
add    $0x3,%rbp
sub    $0x3,%rbx
jmp    4e <unescape+0x4e>
mov    %rax,%rsi
jmp    98 <unescape+0x98>
xor    %eax,%eax
jmp    9b <unescape+0x9b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unescape (const char *str, size_t len)
{
  char *out = malloc (len + 1);
  char *p = out;
  if (!out)
    return ((void *)0);
  while (len > 0 && *str)
    {
      if (len >= 3 && str[0] == '=' && str[1] == '2' && str[2] == 'C')
 {
   *p++ = ',';
   str += 3;
   len -= 3;
 }
      else if (len >= 3 && str[0] == '=' && str[1] == '3' && str[2] == 'D')
 {
   *p++ = '=';
   str += 3;
   len -= 3;
 }
      else
 {
   *p++ = *str;
   str++;
   len--;
 }
    }
  *p = '\0';
  return out;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 23
19 23
20 24
21 25
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 15
36 15
37 15
38 15
39 19
40 18
41 17
42 7
43 17
44 7
45 7
46 28
47 30
48 30
49 30
50 30
51 30
52 9
53 9
54 11
55 11
56 12
57 13
58 13
59 7
60 7
61 6
62 6
63 6
<<<sep_out_sample>>>
sub    $0x48,%rsp
xor    %eax,%eax
mov    %rdi,%rdx
mov    $0x7,%ecx
mov    %rsp,%rdi
cmp    $0xa,%esi
rep stos %rax,%es:(%rdi)
je     61 <quoting_options_from_style+0x61>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
callq  66 <quoting_options_from_style+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 3
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 5
28 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  3c8c <gsl_sf_fermi_dirac_mhalf+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3ca0 <gsl_sf_fermi_dirac_mhalf+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x651,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3cb6 <gsl_sf_fermi_dirac_mhalf+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_fermi_dirac_mhalf(const double x)
{
  gsl_sf_result result; int status = gsl_sf_fermi_dirac_mhalf_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_fermi_dirac_mhalf_e(x, &result)", "fermi_dirac.c", 1617, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     926 <gsl_stats_ushort_absdev_m+0x76>
xorpd  %xmm2,%xmm2
add    %rsi,%rsi
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 8c6 <gsl_stats_ushort_absdev_m+0x16>
nopw   %cs:0x0(%rax,%rax,1)
movzwl (%rdi),%ecx
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
cvtsi2sd %ecx,%xmm1
subsd  %xmm0,%xmm1
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
jne    8d0 <gsl_stats_ushort_absdev_m+0x20>
test   %rax,%rax
js     908 <gsl_stats_ushort_absdev_m+0x58>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    8f4 <gsl_stats_ushort_absdev_m+0x44>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_absdev_m (const unsigned short data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 6
4 6
5 8
6 8
7 8
8 10
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 8
17 13
18 13
19 13
20 13
21 13
22 15
23 15
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 6
34 6
35 6
<<<sep_out_sample>>>
sub    $0x48,%rsp
xor    %eax,%eax
mov    %rdi,%rdx
mov    $0x7,%ecx
mov    %rsp,%rdi
cmp    $0xa,%esi
rep stos %rax,%es:(%rdi)
je     61 <quoting_options_from_style+0x61>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
callq  66 <quoting_options_from_style+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { literal_quoting_style, 0, { 0 }, ((void *)0), ((void *)0) };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 3
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 5
28 5
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  f9 <gsl_combination_calloc+0x9>
test   %rax,%rax
je     11f <gsl_combination_calloc+0x2f>
test   %rbx,%rbx
je     11d <gsl_combination_calloc+0x2d>
mov    0x10(%rax),%rcx
xor    %edx,%edx
nopl   0x0(%rax)
mov    %rdx,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    110 <gsl_combination_calloc+0x20>
pop    %rbx
retq   
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_combination_calloc (const size_t n, const size_t k)
{
  size_t i;
  gsl_combination * c = gsl_combination_alloc (n, k);
  if (c == 0)
    return 0;
  for (i = 0; i < k; i++)
    {
      c->data[i] = i;
    }
  return c;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 9
12 7
13 7
14 7
15 12
16 12
17 6
18 12
19 12
20 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%rdi        # 2cc <gsl_odeiv_control_standard_new+0xc>
movsd  %xmm0,0x18(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  2e8 <gsl_odeiv_control_standard_new+0x28>
movsd  (%rsp),%xmm3
mov    %rax,%rdi
movsd  0x8(%rsp),%xmm2
mov    %rax,%rbx
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm0
callq  30a <gsl_odeiv_control_standard_new+0x4a>
test   %eax,%eax
mov    %rbx,%rdi
jne    320 <gsl_odeiv_control_standard_new+0x60>
add    $0x20,%rsp
mov    %rdi,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,(%rsp)
callq  328 <gsl_odeiv_control_standard_new+0x68>
mov    (%rsp),%eax
mov    $0x0,%edi
mov    $0xa7,%edx
mov    $0x0,%esi
mov    %eax,%ecx
callq  341 <gsl_odeiv_control_standard_new+0x81>
xor    %edi,%edi
jmp    311 <gsl_odeiv_control_standard_new+0x51>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_control_standard_new(double eps_abs, double eps_rel,
                               double a_y, double a_dydt)
{
  gsl_odeiv_control * c =
    gsl_odeiv_control_alloc (gsl_odeiv_control_standard);
  int status = gsl_odeiv_control_init (c, eps_abs, eps_rel, a_y, a_dydt);
  if (status != GSL_SUCCESS)
    {
      gsl_odeiv_control_free (c);
      do { gsl_error ("error trying to initialize control", "cstd.c", 167, status) ; return 0 ; } while (0);
    }
  return c;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 3
7 3
8 4
9 6
10 6
11 6
12 4
13 6
14 6
15 6
16 7
17 12
18 7
19 13
20 13
21 13
22 13
23 13
24 13
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
jne    16f0 <mu_message_get_num_parts+0x20>
mov    $0x16,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
test   %rsi,%rsi
mov    %rsi,%rbp
je     16de <mu_message_get_num_parts+0xe>
mov    0x88(%rdi),%rax
test   %rax,%rax
je     1710 <mu_message_get_num_parts+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   *%rax
nopl   0x0(%rax)
mov    0x40(%rdi),%rdi
test   %rdi,%rdi
je     1730 <mu_message_get_num_parts+0x60>
add    $0x8,%rsp
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   1727 <mu_message_get_num_parts+0x57>
nopw   0x0(%rax,%rax,1)
lea    0x40(%rbx),%rdi
xor    %edx,%edx
mov    %rbx,%rsi
callq  173e <mu_message_get_num_parts+0x6e>
test   %eax,%eax
jne    16e3 <mu_message_get_num_parts+0x13>
mov    0x40(%rbx),%rdi
jmp    1719 <mu_message_get_num_parts+0x49>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_message_get_num_parts (mu_message_t msg, size_t *pparts)
{
  if (msg == ((void *)0) || pparts == ((void *)0))
    return 22;
  if (msg->_get_num_parts)
    return msg->_get_num_parts (msg, pparts);
  if (msg->mime == ((void *)0))
    {
      int status = mu_mime_create (&(msg->mime), msg, 0);
      if (status != 0)
 return status;
    }
  return mu_mime_get_num_parts (msg->mime, pparts);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 14
9 14
10 14
11 14
12 14
13 3
14 3
15 3
16 5
17 5
18 5
19 14
20 14
21 14
22 6
23 6
24 7
25 7
26 7
27 14
28 13
29 14
30 14
31 13
32 13
33 9
34 9
35 9
36 9
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0xa0,%rsp
callq  23 <findFullFileName+0x13>
lea    0x8(%rsp),%rsi
movb   $0x0,-0x2(%r12,%rax,1)
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%edi
callq  42 <findFullFileName+0x32>
test   %eax,%eax
jle    c5 <findFullFileName+0xb5>
sub    $0x1,%eax
xor    %ebx,%ebx
lea    0x8(,%rax,8),%rbp
jmp    8b <findFullFileName+0x7b>
nopl   (%rax)
mov    0x28(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     82 <findFullFileName+0x72>
mov    0x8(%rsp),%rax
mov    %r12,%rsi
mov    (%rax,%rbx,1),%rdi
add    $0x13,%rdi
callq  7d <findFullFileName+0x6d>
test   %rax,%rax
jne    d8 <findFullFileName+0xc8>
add    $0x8,%rbx
cmp    %rbp,%rbx
je     c5 <findFullFileName+0xb5>
mov    0x8(%rsp),%rax
lea    0x10(%rsp),%rsi
mov    (%rax,%rbx,1),%rax
lea    0x13(%rax),%rdi
callq  a2 <findFullFileName+0x92>
cmp    $0xffffffff,%eax
jne    58 <findFullFileName+0x48>
callq  ac <findFullFileName+0x9c>
mov    (%rax),%edi
callq  b3 <findFullFileName+0xa3>
mov    $0x1,%edx
mov    $0x1,%esi
mov    %rax,%rdi
callq  c5 <findFullFileName+0xb5>
add    $0xa0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # df <findFullFileName+0xcf>
mov    0x0(%rip),%rdi        # e6 <findFullFileName+0xd6>
callq  eb <findFullFileName+0xdb>
mov    0x0(%rip),%rbp        # f2 <findFullFileName+0xe2>
mov    %rbp,%rdi
callq  fa <findFullFileName+0xea>
mov    $0x2f,%edx
mov    %dx,0x0(%rbp,%rax,1)
mov    0x8(%rsp),%rax
mov    0x0(%rip),%rdi        # 110 <findFullFileName+0x100>
mov    (%rax,%rbx,1),%rsi
add    $0x13,%rsi
callq  11d <findFullFileName+0x10d>
add    $0xa0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
findFullFileName(char *f)
{
  int n;
  struct dirent **eps;
  struct stat st;
  f[strlen(f)-2] = '\0';
  n = scandir(".", &eps, one, alphasort);
  if(n >= 0)
  {
    int cnt;
    for(cnt = 0; cnt < n; ++cnt)
    {
      int x = lstat(eps[cnt]->d_name,&st);
      if(x == -1) { msgBox(strerror((*__errno_location ())), 1, ERROR); return; }
      if(((((st.st_mode)) & 0170000) == (0040000)))
      {
      }
      else
      {
 if(strstr(eps[cnt]->d_name, f))
 {
  strcpy(open_file_name, cwd);
  strcat(open_file_name, "/");
  strcat(open_file_name, eps[cnt]->d_name);
   return;
 }
      }
    }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 7
8 6
9 7
10 7
11 7
12 7
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 15
21 15
22 15
23 15
24 20
25 20
26 20
27 20
28 20
29 20
30 20
31 20
32 11
33 11
34 13
35 13
36 13
37 13
38 13
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 30
49 30
50 30
51 30
52 30
53 30
54 22
55 22
56 22
57 23
58 23
59 23
60 23
61 23
62 24
63 24
64 24
65 24
66 24
67 30
68 30
69 30
70 30
71 30
72 30
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3198 <eval_error+0x58>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rdx,%rcx
lea    0xf8(%rbp),%rsi
xor    %edx,%edx
lea    0x8(%rsp),%r8
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    0x0(%rip),%rdi        # 31d2 <eval_error+0x92>
mov    %rax,0x18(%rsp)
callq  *0x0(%rip)        # 31dd <eval_error+0x9d>
test   %ebx,%ebx
jne    31eb <eval_error+0xab>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
lea    0x30(%rbp),%rdi
mov    %ebx,%esi
callq  31f6 <eval_error+0xb6>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
eval_error (int retcode, struct eval_env *env, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc_error_printer (rc_error_printer_data, &env->loc, ((void *)0), fmt, ap);
  __builtin_va_end(ap);
  if (retcode)
    longjmp(env->jmp, retcode);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 5
21 5
22 5
23 5
24 4
25 4
26 4
27 4
28 5
29 4
30 5
31 7
32 7
33 9
34 9
35 9
36 9
37 8
38 8
39 8
40 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x2,%edi
callq  454 <rl_begin_undo_group+0x14>
addl   $0x1,0x0(%rip)        # 45b <rl_begin_undo_group+0x1b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_begin_undo_group ()
{
  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
  _rl_undo_group_level++;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
11 6
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%eax
mov    %rcx,%r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
cmove  %rax,%rbx
mov    %rdi,0x18(%rsp)
callq  f80 <quotearg_buffer+0x30>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    0x30(%rbx),%rax
mov    0x4(%rbx),%r9d
mov    0x18(%rsp),%rdi
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
callq  100 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  7c <_mapfile_destroy+0xc>
mov    %rbx,%rdi
callq  84 <_mapfile_destroy+0x14>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_destroy(void *data)
{
    struct _mapfile_stream *str = data;
    free(str->filename);
    free(str);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 7
8 7
9 7
10 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # b76 <gsl_vector_uint_const_ptr+0x6>
test   %eax,%eax
je     b7f <gsl_vector_uint_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    b90 <gsl_vector_uint_const_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x2,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bad <gsl_vector_uint_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_const_ptr (const gsl_vector_uint * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_uint.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const unsigned int *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 2
12 5
13 5
14 5
15 5
16 5
17 5
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1092 <tty_read+0x12>
mov    0x0(%rip),%rcx        # 1099 <tty_read+0x19>
test   %rcx,%rcx
je     10a2 <tty_read+0x22>
xor    %eax,%eax
callq  *%rcx
movslq %ebp,%rdx
mov    %rbx,%rsi
xor    %edi,%edi
callq  10af <tty_read+0x2f>
mov    0x0(%rip),%rdx        # 10b6 <tty_read+0x36>
mov    %eax,%ebx
test   %rdx,%rdx
je     10c1 <tty_read+0x41>
xor    %eax,%eax
callq  *%rdx
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_read(buf, length)
    char *buf;
    int length;
{
    int bytes;
    tty_update();
    if (tty_enter_idle_hook)
 (*tty_enter_idle_hook)();
    bytes = xread(0, buf, length);
    if (tty_exit_idle_hook)
 (*tty_exit_idle_hook)();
    return bytes;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 6
8 7
9 7
10 7
11 8
12 8
13 9
14 9
15 9
16 9
17 10
18 9
19 10
20 10
21 11
22 11
23 13
24 13
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x30,%edi
callq  6e <swuts_create+0xe>
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,0x20(%rax)
movb   $0x0,0x28(%rax)
movb   $0x0,0x29(%rax)
movb   $0x0,0x2a(%rax)
movb   $0x0,0x2b(%rax)
movl   $0xffffffff,0x2c(%rax)
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swuts_create(void)
{
 SWUTS * uts;
 uts = (SWUTS *) malloc (sizeof(SWUTS));
 uts->machineM = ((void *)0);
        uts->sysnameM = ((void *)0);
        uts->releaseM = ((void *)0);
        uts->versionM = ((void *)0);
        uts->arch_tripletM = ((void *)0);
 uts->result_machineM = 0;
        uts->result_sysnameM = 0;
        uts->result_releaseM = 0;
        uts->result_versionM = 0;
        uts->match_resultM = -1;
 return uts;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 14
14 16
15 16
16 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7e7 <grecs_grecs_get_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_get_in (void)
{
        return grecs_grecs_in;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  e21 <swc_print_umask+0x11>
lea    -0x1(%rbp),%rsi
mov    %eax,%ecx
mov    %rbx,%rdi
mov    $0x0,%edx
xor    %eax,%eax
callq  e36 <swc_print_umask+0x26>
cltq   
movb   $0x0,(%rbx,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc_print_umask(char * buf, size_t len)
{
 int ret;
 mode_t mode = swlib_get_umask();
        ret = snprintf(buf, len-1, "%03o", (unsigned int)mode);
 buf[ret] = '\0';
 return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 8
16 8
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    %rdx,%r8
mov    (%rsi),%rcx
je     d8 <x2nrealloc+0x38>
xor    %edx,%edx
movabs $0x7fffffffffffffff,%rax
div    %r8
cmp    %rax,%rcx
ja     f4 <x2nrealloc+0x54>
add    %rcx,%rcx
mov    %rcx,(%rsi)
imul   %r8,%rcx
mov    %rcx,%rsi
jmpq   d1 <x2nrealloc+0x31>
nopl   0x0(%rax)
test   %rcx,%rcx
jne    c2 <x2nrealloc+0x22>
xor    %edx,%edx
mov    $0x40,%eax
xor    %ecx,%ecx
div    %r8
test   %rax,%rax
sete   %cl
add    %rax,%rcx
jmp    c2 <x2nrealloc+0x22>
push   %rax
callq  fa <x2nrealloc+0x5a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
x2nrealloc (void *p, size_t *pn, size_t s)
{
  size_t n = *pn;
  if (! p)
    {
      if (! n)
 {
   enum { DEFAULT_MXFAST = 64 };
   n = DEFAULT_MXFAST / s;
   n += !n;
 }
    }
  else
    {
      if (((size_t) -1) / 2 / s < n)
 xalloc_die ();
      n *= 2;
    }
  *pn = n;
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 4
2 2
3 3
4 4
5 15
6 15
7 15
8 15
9 15
10 17
11 19
12 20
13 20
14 20
15 20
16 6
17 6
18 9
19 9
20 10
21 9
22 10
23 10
24 10
25 10
26 2
27 16
28 16
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpl   $0x2,0x4(%rdi)
je     f0 <bufferstate+0x50>
mov    0x10(%rbx),%rax
mov    %rax,0x0(%r13)
mov    0x20(%rbx),%rax
sub    0x10(%rbx),%rax
mov    %rax,(%r12)
mov    0x28(%rbx),%rax
sub    0x20(%rbx),%rax
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    0x60(%rdi),%edi
xor    %esi,%esi
mov    $0x1,%edx
callq  ff <bufferstate+0x5f>
cmp    0x10(%rbx),%rax
je     c0 <bufferstate+0x20>
mov    0x0(%rip),%rcx        # 10c <bufferstate+0x6c>
mov    $0x2c,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  120 <bufferstate+0x80>
jmp    bc <bufferstate+0x1c>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bufferstate(UXFIO * uxfio, intmax_t *left, intmax_t *right, intmax_t *unused)
{
 if (uxfio->buffertypeM == 2) {
  if (lseek(uxfio->buffdM, (off_t) 0, 1) != uxfio->posM) {
   ;
   fprintf(stderr,
   "uxfio internal error: buffer file position.\n");
  }
 }
 *left = uxfio->posM;
 *right = uxfio->endM - uxfio->posM;
 *unused = uxfio->lenM - uxfio->endM;
 ;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 10
14 11
15 11
16 11
17 12
18 12
19 12
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 4
29 4
30 4
31 4
32 4
33 4
34 6
35 6
36 6
37 6
38 6
39 6
40 6
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 613 <tty_key_human2machine+0x13>
movzbl (%rdi),%edx
test   %eax,%eax
jne    61f <tty_key_human2machine+0x1f>
cmp    $0x5e,%dl
jne    688 <tty_key_human2machine+0x88>
lea    0x1(%r13),%rbx
mov    %r13,%rbp
jmp    63f <tty_key_human2machine+0x3f>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbp
mov    %dl,-0x1(%rbx)
movzbl 0x0(%rbp),%edx
add    $0x1,%rbx
test   %dl,%dl
je     698 <tty_key_human2machine+0x98>
cmp    $0x5e,%dl
jne    630 <tty_key_human2machine+0x30>
movzbl 0x1(%rbp),%r12d
test   %r12b,%r12b
je     688 <tty_key_human2machine+0x88>
movzbl %r12b,%edi
callq  65b <tty_key_human2machine+0x5b>
cmp    $0x47,%eax
je     688 <tty_key_human2machine+0x88>
cmp    $0x5a,%eax
je     688 <tty_key_human2machine+0x88>
and    $0x7f,%r12d
add    $0x2,%rbp
sub    $0x20,%r12d
movslq %r12d,%r12
movzbl 0x0(%r12),%eax
mov    %al,-0x1(%rbx)
jmp    637 <tty_key_human2machine+0x37>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
movb   $0x0,-0x1(%rbx)
add    $0x8,%rsp
mov    %r13,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_key_human2machine(key_seq)
    unsigned char *key_seq;
{
    unsigned char *first;
    unsigned char *second;
    first = second = key_seq;
    if (tty_kbdmode == 0 && *key_seq != '^')
 return ((void *)0);
    while (*second)
    {
 if (*second == '^')
 {
     if (*++second)
     {
  if (toupper(*second) == 'G' || toupper(*second) == 'Z')
      return ((void *)0);
  *first++ = key_ctrl_table[(*second++ & 0x7F) - ' '];
     }
     else
  return ((void *)0);
 }
 else
     *first++ = *second++;
    }
    *first = 0;
    return (char *)key_seq;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 3
15 3
16 3
17 23
18 23
19 23
20 23
21 9
22 9
23 11
24 11
25 13
26 13
27 13
28 15
29 15
30 15
31 15
32 15
33 15
34 17
35 17
36 17
37 17
38 17
39 17
40 17
41 17
42 27
43 8
44 27
45 27
46 27
47 27
48 27
49 27
50 25
51 27
52 26
53 27
54 27
55 27
56 27
57 27
58 27
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # d <close_stdout+0xd>
callq  12 <close_stdout+0x12>
test   %eax,%eax
jne    60 <close_stdout+0x60>
callq  1b <close_stdout+0x1b>
mov    %rax,%rbx
mov    0x0(%rip),%rdi        # 25 <close_stdout+0x25>
movl   $0x0,(%rbx)
callq  30 <close_stdout+0x30>
test   %eax,%eax
jne    8d <close_stdout+0x8d>
mov    0x0(%rip),%rdi        # 3b <close_stdout+0x3b>
callq  40 <close_stdout+0x40>
test   %eax,%eax
jne    8d <close_stdout+0x8d>
mov    0x0(%rip),%rdi        # 4b <close_stdout+0x4b>
callq  50 <close_stdout+0x50>
test   %eax,%eax
je     59 <close_stdout+0x59>
cmpl   $0x9,(%rbx)
jne    a3 <close_stdout+0xa3>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%edi
callq  6a <close_stdout+0x6a>
mov    %rax,%rbp
callq  72 <close_stdout+0x72>
mov    (%rax),%esi
mov    %rax,%rbx
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x1,%edi
xor    %eax,%eax
callq  8b <close_stdout+0x8b>
jmp    1e <close_stdout+0x1e>
mov    0x0(%rip),%rdi        # 94 <close_stdout+0x94>
callq  99 <close_stdout+0x99>
mov    $0x1,%edi
callq  a3 <close_stdout+0xa3>
mov    $0x1,%edi
callq  ad <close_stdout+0xad>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (fwriteerror_no_ebadf (stdout))
    error (1, (*__errno_location ()), "%s", gettext ("write error"));
  (*__errno_location ()) = 0;
  if (ferror (stderr) || fflush (stderr))
    {
      fclose (stderr);
      exit (1);
    }
  if (fclose (stderr) && (*__errno_location ()) != 9)
    exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 11
20 11
21 11
22 11
23 11
24 11
25 13
26 13
27 13
28 13
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 8
42 8
43 9
44 9
45 12
46 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
callq  16 <sh_single_quote+0x16>
test   %rbx,%rbx
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jne    32 <sh_single_quote+0x32>
jmp    60 <sh_single_quote+0x60>
nopl   0x0(%rax)
add    $0x1,%rdx
add    $0x1,%rbx
je     60 <sh_single_quote+0x60>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     60 <sh_single_quote+0x60>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    28 <sh_single_quote+0x28>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    32 <sh_single_quote+0x32>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_single_quote (string)
     char *string;
{
  register int c;
  char *result, *r, *s;
  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 9
7 8
8 8
9 9
10 9
11 9
12 11
13 9
14 9
15 9
16 9
17 9
18 9
19 12
20 11
21 12
22 14
23 15
24 16
25 16
26 9
27 9
28 9
29 19
30 20
31 22
32 22
33 22
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     3e10 <swlib_imaxtostr+0x40>
mov    $0x16,%esi
mov    %rbx,%rdi
callq  3dee <swlib_imaxtostr+0x1e>
mov    %rbx,%rdi
callq  3df6 <swlib_imaxtostr+0x26>
add    $0x8,%rsp
mov    %rbp,%rdi
mov    %rax,%rsi
pop    %rbx
pop    %rbp
jmpq   3e07 <swlib_imaxtostr+0x37>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rbx        # 3e17 <swlib_imaxtostr+0x47>
test   %rbx,%rbx
jne    3de1 <swlib_imaxtostr+0x11>
mov    $0x20,%edi
callq  3e26 <swlib_imaxtostr+0x56>
mov    %rax,0x0(%rip)        # 3e2d <swlib_imaxtostr+0x5d>
mov    %rax,%rbx
jmp    3de1 <swlib_imaxtostr+0x11>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_imaxtostr(intmax_t i, STROB * pbuf)
{
 static STROB * sbuf;
 STROB * buf;
 char * ret;
 if (pbuf == ((void *)0)) {
  if (sbuf == ((void *)0))
   sbuf = strob_open(32);
  buf = sbuf;
 } else {
  buf = pbuf;
 }
 strob_setlen(buf, (((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)) + 1) + 1)+1);
 ret = imaxtostr(i, strob_str(buf));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 13
9 13
10 13
11 14
12 14
13 16
14 14
15 14
16 16
17 16
18 14
19 14
20 7
21 7
22 7
23 8
24 8
25 8
26 8
27 8
28 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     11 <lmniel_free+0x11>
callq  11 <lmniel_free+0x11>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     1f <lmniel_free+0x1f>
callq  1f <lmniel_free+0x1f>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     2d <lmniel_free+0x2d>
callq  2d <lmniel_free+0x2d>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     3b <lmniel_free+0x3b>
callq  3b <lmniel_free+0x3b>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     49 <lmniel_free+0x49>
callq  49 <lmniel_free+0x49>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     57 <lmniel_free+0x57>
callq  57 <lmniel_free+0x57>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     65 <lmniel_free+0x65>
callq  65 <lmniel_free+0x65>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     78 <lmniel_free+0x78>
pop    %rbx
jmpq   74 <lmniel_free+0x74>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lmniel_free(void *vstate)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  if (state->A)
    gsl_matrix_free(state->A);
  if (state->J)
    gsl_matrix_free(state->J);
  if (state->diag)
    gsl_vector_free(state->diag);
  if (state->rhs)
    gsl_vector_free(state->rhs);
  if (state->work)
    gsl_vector_free(state->work);
  if (state->A_copy)
    gsl_matrix_free(state->A_copy);
  if (state->x_trial)
    gsl_vector_free(state->x_trial);
  if (state->f_trial)
    gsl_vector_free(state->f_trial);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 15
27 16
28 16
29 16
30 17
31 18
32 18
33 18
34 20
35 19
36 19
37 20
38 20
39 20
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1f26 <cpp_set_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_set_debug (int bdebug )
{
        cpp__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
ucomisd %xmm3,%xmm2
movsd  %xmm0,0x8(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x18(%rsp)
jae    1456 <TruncNormalRandom+0x96>
mov    $0x1,%ebx
jmp    13f8 <TruncNormalRandom+0x38>
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    $0x19,%ebx
je     1422 <TruncNormalRandom+0x62>
movsd  0x10(%rsp),%xmm1
movsd  0x8(%rsp),%xmm0
callq  1409 <TruncNormalRandom+0x49>
movsd  (%rsp),%xmm4
ucomisd %xmm0,%xmm4
ja     13f0 <TruncNormalRandom+0x30>
ucomisd 0x18(%rsp),%xmm0
ja     13f0 <TruncNormalRandom+0x30>
add    $0x20,%rsp
pop    %rbx
retq   
mov    $0x0,%edi
xor    %eax,%eax
callq  142e <TruncNormalRandom+0x6e>
movsd  0x10(%rsp),%xmm3
mov    $0x0,%edi
movsd  0x8(%rsp),%xmm2
mov    $0x4,%eax
movsd  0x18(%rsp),%xmm1
movsd  (%rsp),%xmm0
callq  1454 <TruncNormalRandom+0x94>
jmp    13f8 <TruncNormalRandom+0x38>
movsd  0x18(%rsp),%xmm1
mov    $0x0,%edi
movsd  (%rsp),%xmm0
mov    $0x2,%eax
callq  1470 <TruncNormalRandom+0xb0>
xor    %edi,%edi
callq  1477 <TruncNormalRandom+0xb7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TruncNormalRandom (double dMean, double dStdDev, double a, double b)
{
  double X = 0.0;
  int iter = 0;
  if (a >= b) {
    printf ("Error: TruncNormalRandom: min >= max  [%g %g]\n", a, b);
    exit (0);
  }
  else do {
    if(++iter == 25) {
      printf("Warning: TruncNormalRandom: problem with range: ");
      printf("min %g, max %g, ave %g, sd %g\n", a, b, dMean, dStdDev);
    }
    X = NormalRandom(dMean, dStdDev);
  }
  while (X < a || X > b);
  return X;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 2
8 5
9 10
10 10
11 10
12 10
13 10
14 10
15 14
16 14
17 14
18 16
19 16
20 16
21 16
22 16
23 18
24 18
25 18
26 11
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 6
38 6
39 6
40 6
41 6
42 7
43 7
44 7
<<<sep_out_sample>>>
push   %rbx
xor    %r8d,%r8d
mov    $0x16,%ecx
mov    $0xa,%esi
sub    $0x20,%rsp
mov    %rsp,%rdx
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  4a <itos+0x2a>
mov    %rax,%rdi
mov    %rax,%rbx
callq  55 <itos+0x35>
lea    0x1(%rax),%rdi
mov    $0x32,%edx
mov    $0x0,%esi
callq  68 <itos+0x48>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  73 <itos+0x53>
mov    0x18(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    89 <itos+0x69>
add    $0x20,%rsp
pop    %rbx
retq   
callq  8e <itos+0x6e>
xchg   %ax,%ax
<<<sep_in_sample>>>
itos (i)
     intmax_t i;
{
  char *p, lbuf[((sizeof (intmax_t) * 8 - (! ((intmax_t) 0 < (intmax_t) -1))) * 302 / 1000 + 1 + (! ((intmax_t) 0 < (intmax_t) -1))) + 1];
  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return ((char *)strcpy (sh_xmalloc((1 + strlen (p)), "itos.c", 50), (p)));
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 3
6 5
7 3
8 3
9 3
10 5
11 6
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x8,%edi
callq  63 <resetflt+0x13>
cmp    $0x1,%rax
je     80 <resetflt+0x30>
xor    %esi,%esi
mov    $0x8,%edi
add    $0x8,%rsp
jmpq   79 <resetflt+0x29>
nopl   0x0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
resetflt (void)
{
  if (signal (8, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (8, ((__sighandler_t) 0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 4
11 4
12 5
13 5
<<<sep_out_sample>>>
jmpq   5 <__gmp_randinit_default+0x5>
<<<sep_in_sample>>>
__gmp_randinit_default (gmp_randstate_t rstate)
{
  __gmp_randinit_mt (rstate);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # afb <string_begin+0xb>
movq   $0x0,0x0(%rip)        # b06 <string_begin+0x16>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_begin (void)
{
  strseg_head = strseg_tail = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     bc0 <via_get_port+0x10>
mov    0x18(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_get_port (osip_via_t * via)
{
  if (via == ((void *)0))
    return ((void *)0);
  return via->port;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
lea    0x20(%rsp),%rsi
lea    0x18(%rsp),%rdi
movq   $0x0,0x18(%rsp)
movq   $0x0,0x20(%rsp)
callq  8e1 <mu_stream_vprintf+0x31>
test   %eax,%eax
jne    946 <mu_stream_vprintf+0x96>
mov    0x18(%rsp),%rbp
mov    %rbp,%rdi
callq  8f2 <mu_stream_vprintf+0x42>
mov    (%r12),%rcx
mov    %rax,%rbx
jmp    91d <mu_stream_vprintf+0x6d>
nopl   0x0(%rax,%rax,1)
mov    0x28(%rsp),%r8
test   %r8,%r8
je     934 <mu_stream_vprintf+0x84>
mov    %r8,%rcx
add    (%r12),%rcx
add    %r8,%rbp
sub    %r8,%rbx
mov    %rcx,(%r12)
je     934 <mu_stream_vprintf+0x84>
lea    0x28(%rsp),%r8
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  930 <mu_stream_vprintf+0x80>
test   %eax,%eax
je     900 <mu_stream_vprintf+0x50>
mov    0x18(%rsp),%rdi
mov    %eax,0xc(%rsp)
callq  942 <mu_stream_vprintf+0x92>
mov    0xc(%rsp),%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_stream_vprintf (mu_stream_t os, mu_off_t *poff, const char *fmt, va_list ap)
{
  char *buf = ((void *)0), *p;
  size_t buflen = 0;
  size_t n;
  int rc;
  rc = mu_vasnprintf (&buf, &buflen, fmt, ap);
  if (rc)
    return rc;
  p = buf;
  n = strlen (buf);
  do
    {
      size_t wrs;
      rc = mu_stream_write (os, p, n, *poff, &wrs);
      if (rc || wrs == 0)
        break;
      p += wrs;
      *poff += wrs;
      n -= wrs;
    }
  while (n > 0);
  free (buf);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 7
9 7
10 3
11 4
12 7
13 8
14 8
15 10
16 11
17 11
18 11
19 11
20 11
21 11
22 16
23 16
24 16
25 19
26 19
27 18
28 22
29 19
30 22
31 15
32 15
33 15
34 15
35 15
36 16
37 16
38 23
39 23
40 23
41 24
42 25
43 25
44 25
45 25
46 25
47 25
48 25
<<<sep_out_sample>>>
push   %rbx
mov    0x98(%rdi),%rax
mov    %rdi,%rbx
mov    $0xe,%esi
movl   $0xffffffff,0x30(%rax)
movq   $0xffffffffffffffff,0x38(%rax)
callq  544 <osip_nict_timeout_k_event+0x24>
mov    %rbx,%rsi
mov    $0x2,%edi
pop    %rbx
jmpq   552 <osip_nict_timeout_k_event+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_nict_timeout_k_event (osip_transaction_t * nict, osip_event_t * evt)
{
  nict->nict_context->timer_k_length = -1;
  nict->nict_context->timer_k_start.tv_sec = -1;
  __osip_transaction_set_state (nict, NICT_TERMINATED);
  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 3
6 4
7 5
8 6
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     90 <mu_progmailer_set_command+0x40>
mov    0x18(%rdi),%rdi
mov    %rsi,%rbp
callq  6a <mu_progmailer_set_command+0x1a>
test   %rbp,%rbp
je     a0 <mu_progmailer_set_command+0x50>
mov    %rbp,%rdi
callq  77 <mu_progmailer_set_command+0x27>
test   %rax,%rax
mov    %rax,0x18(%rbx)
je     90 <mu_progmailer_set_command+0x40>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x16,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
movq   $0x0,0x18(%rbx)
xor    %eax,%eax
jmp    82 <mu_progmailer_set_command+0x32>
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_progmailer_set_command (mu_progmailer_t pm, const char *command)
{
  if (!pm)
    return 22;
  free (pm->command);
  if (command)
    {
      pm->command = strdup (command);
      if (!pm->command)
 return 22;
    }
  else
    pm->command = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 6
11 6
12 8
13 8
14 9
15 8
16 9
17 14
18 15
19 15
20 15
21 15
22 15
23 15
24 4
25 15
26 15
27 15
28 15
29 13
30 14
31 14
32 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  aec <gsl_sf_bessel_yl+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    b00 <gsl_sf_bessel_yl+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x121,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b16 <gsl_sf_bessel_yl+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_yl(const int l, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_yl_e(l, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_yl_e(l, x, &result)", "bessel_y.c", 289, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
test   %ecx,%ecx
push   %rbx
jle    64 <VMatrixMultByRank+0x64>
lea    -0x1(%rcx),%r8d
xorpd  %xmm2,%xmm2
xor    %r11d,%r11d
add    $0x1,%r8
mov    %r8,%rbp
shl    $0x3,%r8
shl    $0x5,%rbp
lea    (%rsi,%r11,1),%r10
lea    (%rdx,%r11,1),%rbx
xor    %ecx,%ecx
movapd %xmm2,%xmm1
lea    (%rdi,%rcx,1),%r9
xor    %eax,%eax
movsd  (%r9,%rax,4),%xmm0
mulsd  (%r10,%rax,1),%xmm0
add    $0x8,%rax
cmp    %r8,%rax
addsd  %xmm0,%xmm1
jne    34 <VMatrixMultByRank+0x34>
movsd  %xmm1,(%rbx,%rcx,1)
add    $0x8,%rcx
cmp    %r8,%rcx
jne    2a <VMatrixMultByRank+0x2a>
add    $0x20,%r11
cmp    %rbp,%r11
jne    20 <VMatrixMultByRank+0x20>
movsd  0x0(%rip),%xmm3        # 6c <VMatrixMultByRank+0x6c>
movq   $0x0,0x58(%rdx)
movq   $0x0,0x38(%rdx)
movq   $0x0,0x18(%rdx)
movq   $0x0,0x70(%rdx)
movq   $0x0,0x68(%rdx)
movsd  %xmm3,0x78(%rdx)
movq   $0x0,0x60(%rdx)
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
VMatrixMultByRank(VMatrix * Mt1, VMatrix * Mt2, VMatrix * R, int rank)
{
 register int I, J, K, r = rank;
 register double x;
 for (I = 0; I < r; ++I)
  for (J = 0; J < r; ++J) {
   x = 0.0;
   for (K = 0; K < r; ++K)
    x += Mt1->m[K][J] * Mt2->m[I][K];
   R->m[I][J] = x;
  }
 R->m[0][3] = R->m[1][3] = R->m[2][3] = 0.0;
 R->m[3][0] = R->m[3][1] = R->m[3][2] = 0.0;
 R->m[3][3] = 1.0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 2
15 2
16 2
17 2
18 9
19 9
20 9
21 8
22 9
23 8
24 10
25 10
26 6
27 6
28 6
29 5
30 5
31 14
32 12
33 12
34 12
35 13
36 13
37 14
38 13
39 15
40 15
41 15
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    0x20(%rax),%rdx
test   %rdx,%rdx
je     52 <dico_iterator_detach+0x42>
cmp    %rdx,%rdi
jne    30 <dico_iterator_detach+0x20>
jmp    47 <dico_iterator_detach+0x37>
nopl   0x0(%rax)
cmp    %rax,%rdi
je     40 <dico_iterator_detach+0x30>
mov    %rax,%rdx
mov    (%rdx),%rax
test   %rax,%rax
jne    28 <dico_iterator_detach+0x18>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    (%rax),%rcx
mov    %rcx,(%rdx)
retq   
mov    (%rdi),%rdx
mov    %rdx,0x20(%rax)
mov    %rdi,%rax
retq   
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_iterator_detach(dico_iterator_t iter)
{
    dico_iterator_t cur, prev;
    for (cur = iter->list->itr, prev = ((void *)0);
  cur;
  prev = cur, cur = cur->next)
 if (cur == iter)
     break;
    if (cur) {
 if (prev)
     prev->next = cur->next;
 else
     cur->list->itr = cur->next;
    }
    return cur;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 6
13 4
14 4
15 4
16 4
17 11
18 11
19 16
20 13
21 13
22 13
23 13
24 4
25 4
26 4
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
xor    %edx,%edx
mov    %rsi,%rcx
test   %rsi,%rsi
setg   %dl
shr    $0x3f,%rcx
sub    %ecx,%edx
movslq %eax,%rcx
cmp    %eax,%edx
jne    48 <__gmpz_cmp_si+0x48>
test   %rcx,%rcx
je     48 <__gmpz_cmp_si+0x48>
mov    0x8(%rdi),%rdx
mov    (%rdx),%rcx
mov    %rsi,%rdx
sar    $0x3f,%rdx
xor    %rdx,%rsi
sub    %rdx,%rsi
cmp    %rcx,%rsi
je     50 <__gmpz_cmp_si+0x50>
mov    %eax,%edx
neg    %edx
cmp    %rcx,%rsi
cmovae %edx,%eax
retq   
nopl   0x0(%rax)
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
__gmpz_cmp_si (mpz_srcptr u, signed long int v_digit)
{
  mp_size_t vsize, usize;
  usize = ((u)->_mp_size);
  vsize = (v_digit > 0) - (v_digit < 0);
  if ((usize == 0) | (usize != vsize))
    return usize - vsize;
  else {
    mp_limb_t u_digit, absv_digit;
    u_digit = ((u)->_mp_d)[0];
    absv_digit = ((v_digit) >= 0 ? ((unsigned long) (v_digit)) : (- (((unsigned long) ((v_digit) + 1)) - 1)));
    if (u_digit == absv_digit)
      return 0;
    if (u_digit > absv_digit)
      return usize;
    else
      return -usize;
  }
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 10
14 10
15 11
16 11
17 11
18 11
19 12
20 12
21 17
22 17
23 17
24 17
25 17
26 17
27 7
28 7
29 7
30 13
31 19
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
mov    $0x0,%esi
push   %r12
mov    %rdi,%r12
mov    $0x20,%edi
push   %rbp
movslq %ecx,%rbp
push   %rbx
mov    %edx,%ebx
mov    $0x50c,%edx
shl    $0x8,%ebx
sub    $0x8,%rsp
and    $0xffff,%ebx
callq  23e2 <append_process+0x32>
mov    0x0(%rip),%rdx        # 23e9 <append_process+0x39>
movq   $0x0,(%rax)
mov    %r12,0x18(%rax)
mov    %r13d,0x8(%rax)
mov    %ebx,0xc(%rax)
movl   $0x0,0x10(%rax)
lea    (%rdx,%rbp,8),%rdi
addl   $0x1,0x0(%rip)        # 240d <append_process+0x5d>
mov    (%rdi),%rdx
mov    0x8(%rdx),%rsi
mov    %rsi,%rcx
jmp    2423 <append_process+0x73>
nopl   0x0(%rax)
mov    %rdx,%rcx
mov    (%rcx),%rdx
cmp    %rdx,%rsi
jne    2420 <append_process+0x70>
mov    %rax,(%rcx)
mov    (%rdi),%rdx
mov    0x8(%rdx),%rdx
mov    %rdx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
append_process (name, pid, status, jid)
     char *name;
     pid_t pid;
     int status;
     int jid;
{
  PROCESS *t, *p;
  t = (PROCESS *)sh_xmalloc((sizeof (PROCESS)), "jobs.c", 1292);
  t->next = (PROCESS *)((void *)0);
  t->pid = pid;
  t->status = (status & 0xff) << 8;
  t->running = 0;
  t->command = name;
  js.c_reaped++;
  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)
    ;
  p->next = t;
  t->next = jobs[jid]->pipe;
}
<<<sep_in_sample>>>
1 6
2 6
3 8
4 6
5 6
6 8
7 6
8 6
9 6
10 6
11 8
12 11
13 6
14 11
15 8
16 15
17 9
18 13
19 10
20 11
21 12
22 15
23 14
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 17
34 18
35 18
36 18
37 19
38 19
39 19
40 19
41 19
42 19
43 19
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
sub    $0x8,%rsp
callq  aa6 <gl_linked_nx_add_first+0x16>
test   %rax,%rax
je     acb <gl_linked_nx_add_first+0x3b>
lea    0x28(%rbx),%rdx
mov    %rbp,0x10(%rax)
mov    %rdx,0x8(%rax)
mov    0x28(%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
addq   $0x1,0x40(%rbx)
mov    %rax,0x28(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_nx_add_first (gl_list_t list, const void *elt)
{
  gl_list_node_t node =
    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));
  if (node == ((void *)0))
    return ((void *)0);
  node->value = elt;
  node->prev = &list->root;
  node->next = list->root.next;
  node->next->prev = node;
  list->root.next = node;
  list->count++;
  return node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 5
9 5
10 8
11 7
12 8
13 9
14 9
15 10
16 12
17 11
18 14
19 14
20 14
21 14
22 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x38,%rsp
movzbl (%rdi),%eax
movq   $0x0,0x10(%rsp)
movq   $0x0,0x18(%rsp)
movq   $0x0,0x20(%rsp)
movq   $0x0,0x28(%rsp)
cmp    $0x2d,%al
je     3c <get_geometry+0x3c>
cmp    $0x2b,%al
jne    c0 <get_geometry+0xc0>
lea    0x28(%rsp),%rcx
lea    0x20(%rsp),%rdx
mov    %rbx,%r8
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  58 <get_geometry+0x58>
cmp    $0x2,%eax
jne    f0 <get_geometry+0xf0>
movsd  0x0(%rip),%xmm0        # 69 <get_geometry+0x69>
movsd  0x10(%rsp),%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%eax
movsd  0x18(%rsp),%xmm1
mulsd  %xmm0,%xmm1
mov    %eax,0x0(%rip)        # 87 <get_geometry+0x87>
cvttsd2si %xmm1,%eax
movsd  0x20(%rsp),%xmm1
mulsd  %xmm0,%xmm1
mulsd  0x28(%rsp),%xmm0
mov    %eax,0x0(%rip)        # a1 <get_geometry+0xa1>
cvttsd2si %xmm1,%eax
mov    %eax,0x0(%rip)        # ab <get_geometry+0xab>
cvttsd2si %xmm0,%eax
mov    %eax,0x0(%rip)        # b5 <get_geometry+0xb5>
xor    %eax,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x28(%rsp),%r9
lea    0x20(%rsp),%r8
lea    0x18(%rsp),%rcx
lea    0x10(%rsp),%rdx
mov    %rdi,(%rsp)
mov    $0x0,%esi
xor    %eax,%eax
callq  e4 <get_geometry+0xe4>
jmpq   58 <get_geometry+0x58>
nopl   0x0(%rax)
cmp    $0x4,%eax
je     61 <get_geometry+0x61>
mov    0x0(%rip),%rbp        # 100 <get_geometry+0x100>
mov    $0x0,%edi
callq  10a <get_geometry+0x10a>
mov    0x0(%rip),%rdi        # 111 <get_geometry+0x111>
mov    %rax,%rsi
mov    %rbx,%rcx
mov    %rbp,%rdx
xor    %eax,%eax
callq  121 <get_geometry+0x121>
mov    $0xfffffffe,%eax
jmp    b7 <get_geometry+0xb7>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_geometry(void *arg)
{
    double w = 0.0, h = 0.0;
    double x = 0.0, y = 0.0;
    int n;
    if (((char *)arg)[0]=='+' || ((char *)arg)[0]=='-') {
 n = sscanf((char *)arg, "%lf%lf%s", &x, &y, (char *)arg);
    } else {
 n = sscanf((char *)arg, "%lfx%lf%lf%lf%s", &w, &h, &x, &y,
     (char *)arg);
    }
    if (n != 4 && n != 2) {
  fprintf(stderr, gettext ("%s: wrong geometry \"%s\"\n"), prgname, (char *)arg);
  return -2;
    }
    code_width = w * unit;
    code_height = h * unit;
    xmargin0 = x * unit;
    ymargin0 = y * unit;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 12
22 12
23 16
24 16
25 16
26 16
27 17
28 17
29 16
30 17
31 18
32 18
33 19
34 17
35 18
36 18
37 19
38 19
39 20
40 21
41 21
42 21
43 21
44 21
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 12
56 12
57 13
58 13
59 13
60 13
61 13
62 13
63 13
64 13
65 13
66 14
67 14
68 14
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     a7b <err_sys+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rsi
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # a92 <err_sys+0x72>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  ab6 <err_sys+0x96>
callq  abb <err_sys+0x9b>
mov    (%rax),%edi
callq  ac2 <err_sys+0xa2>
mov    0x0(%rip),%rdi        # ac9 <err_sys+0xa9>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  ad8 <err_sys+0xb8>
mov    $0x1,%edi
callq  ae2 <err_sys+0xc2>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
err_sys (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vfprintf (stderr, fmt, ap);
  fprintf (stderr, ": %s\n", strerror ((*__errno_location ())));
  __builtin_va_end(ap);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 2
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 8
36 8
37 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1e98 <gsl_vector_ulong_free+0x38>
mov    0x20(%rdi),%eax
test   %eax,%eax
jne    1e80 <gsl_vector_ulong_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   1e79 <gsl_vector_ulong_free+0x19>
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
callq  1e89 <gsl_vector_ulong_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   1e92 <gsl_vector_ulong_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_free (gsl_vector_ulong * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_ulong_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  c8d <slc_import+0xd>
cmp    $0x9,%eax
jle    ce8 <slc_import+0x68>
test   %ebx,%ebx
mov    $0x9,%edx
je     cc0 <slc_import+0x40>
mov    $0x0,%esi
mov    $0x0,%edi
callq  caa <slc_import+0x2a>
pop    %rbx
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
jmpq   cbf <slc_import+0x3f>
nop
mov    $0x0,%esi
mov    $0x0,%edi
callq  ccf <slc_import+0x4f>
pop    %rbx
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
jmpq   ce4 <slc_import+0x64>
nopl   0x0(%rax)
pop    %rbx
mov    $0x0,%edi
jmpq   cf3 <slc_import+0x73>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
slc_import (int def)
{
  if ((ring_empty_count(&netoring)) > (int) sizeof (slc_import_val))
    {
      if (def)
 {
   ring_supply_data (&netoring, slc_import_def,
       sizeof (slc_import_def));
   printsub ('>', &slc_import_def[2], sizeof (slc_import_def) - 2);
 }
      else
 {
   ring_supply_data (&netoring, slc_import_val,
       sizeof (slc_import_val));
   printsub ('>', &slc_import_val[2], sizeof (slc_import_val) - 2);
 }
    }
  else
    printf ("slc_import: not enough room\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 7
9 5
10 7
11 7
12 7
13 20
14 9
15 9
16 9
17 9
18 9
19 13
20 13
21 13
22 20
23 15
24 15
25 15
26 15
27 15
28 20
29 19
30 19
31 19
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1c00 <gsl_monte_miser_free+0xb0>
mov    0xa8(%rdi),%rdi
callq  1b69 <gsl_monte_miser_free+0x19>
mov    0xa0(%rbx),%rdi
callq  1b75 <gsl_monte_miser_free+0x25>
mov    0x98(%rbx),%rdi
callq  1b81 <gsl_monte_miser_free+0x31>
mov    0x90(%rbx),%rdi
callq  1b8d <gsl_monte_miser_free+0x3d>
mov    0x88(%rbx),%rdi
callq  1b99 <gsl_monte_miser_free+0x49>
mov    0x80(%rbx),%rdi
callq  1ba5 <gsl_monte_miser_free+0x55>
mov    0x78(%rbx),%rdi
callq  1bae <gsl_monte_miser_free+0x5e>
mov    0x70(%rbx),%rdi
callq  1bb7 <gsl_monte_miser_free+0x67>
mov    0x68(%rbx),%rdi
callq  1bc0 <gsl_monte_miser_free+0x70>
mov    0x60(%rbx),%rdi
callq  1bc9 <gsl_monte_miser_free+0x79>
mov    0x58(%rbx),%rdi
callq  1bd2 <gsl_monte_miser_free+0x82>
mov    0x50(%rbx),%rdi
callq  1bdb <gsl_monte_miser_free+0x8b>
mov    0x48(%rbx),%rdi
callq  1be4 <gsl_monte_miser_free+0x94>
mov    0x40(%rbx),%rdi
callq  1bed <gsl_monte_miser_free+0x9d>
mov    %rbx,%rdi
pop    %rbx
jmpq   1bf6 <gsl_monte_miser_free+0xa6>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_monte_miser_free (gsl_monte_miser_state * s)
{
  if (!s) { return ; };
  free (s->hits_r);
  free (s->hits_l);
  free (s->fsum2_r);
  free (s->fsum2_l);
  free (s->fsum_r);
  free (s->fsum_l);
  free (s->fmin_r);
  free (s->fmin_l);
  free (s->fmax_r);
  free (s->fmax_l);
  free (s->sigma_r);
  free (s->sigma_l);
  free (s->xmid);
  free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 10
18 10
19 11
20 11
21 12
22 12
23 13
24 13
25 14
26 14
27 15
28 15
29 16
30 16
31 17
32 17
33 18
34 19
35 18
36 18
37 19
38 19
39 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # b1 <history_total_bytes+0x11>
test   %rbp,%rbp
je     105 <history_total_bytes+0x65>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     105 <history_total_bytes+0x65>
add    $0x8,%rbp
xor    %r12d,%r12d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rdi
add    $0x8,%rbp
callq  dc <history_total_bytes+0x3c>
mov    0x8(%rbx),%rdi
mov    %rax,%r13
callq  e8 <history_total_bytes+0x48>
mov    -0x8(%rbp),%rbx
add    %eax,%r13d
add    %r13d,%r12d
test   %rbx,%rbx
jne    d0 <history_total_bytes+0x30>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    f7 <history_total_bytes+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_total_bytes ()
{
  register int i, result;
  for (i = result = 0; the_history && the_history[i]; i++)
    result += (strlen ((the_history[i])->line) + strlen ((the_history[i])->timestamp));
  return (result);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 4
22 5
23 5
24 4
25 4
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 4
34 4
35 4
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 6 <__db_join_put+0x6>
mov    $0x16,%eax
test   %edx,%edx
jne    18 <__db_join_put+0x18>
repz retq 
nopl   0x0(%rax)
mov    (%rdi),%rdx
mov    0x28(%rdx),%rdx
mov    0xe0(%rdx),%rdx
test   %rdx,%rdx
je     f <__db_join_put+0xf>
mov    0x20(%rdx),%rax
cmpl   $0x1,0x74(%rax)
sbb    %eax,%eax
and    $0x7923,%eax
sub    $0x790d,%eax
retq   
<<<sep_in_sample>>>
__db_join_put(dbc, key, data, flags)
 DBC *dbc;
 DBT *key;
 DBT *data;
 u_int32_t flags;
{
 if(key||data||flags){}
 if (CDB___db_global_values.db_panic && (dbc->dbp->dbenv)->reginfo != ((void *)0) && ((REGENV *) ((REGINFO *)(dbc->dbp->dbenv)->reginfo)->primary)->panic != 0) return ((-30989));;
 (key) = (((void *)0));
 (data) = (((void *)0));
 (flags) = (0);
 return (22);
}
<<<sep_in_sample>>>
1 8
2 12
3 8
4 8
5 13
6 13
7 8
8 8
9 8
10 8
11 8
12 8
13 12
14 12
15 12
16 12
17 13
<<<sep_out_sample>>>
mov    %edi,%eax
mov    %esi,%ecx
rol    %cl,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rotl32 (uint32_t x, int n)
{
  return ((x << n) | (x >> (32 - n))) & (4294967295U);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     490 <gsasl_client_callback_password_get+0x10>
mov    0x40(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_password_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_password : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmwrap (void)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 7b6 <gsl_vector_complex_float_const_ptr+0x6>
test   %eax,%eax
je     7bf <gsl_vector_complex_float_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    7d0 <gsl_vector_complex_float_const_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xf0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7ed <gsl_vector_complex_float_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_const_ptr (const gsl_vector_complex_float * v,
                                    const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_float.h", 240, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return ((gsl_complex_float*)&((v)->data[2*(i)*(v)->stride]));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 3
12 6
13 6
14 6
15 6
16 6
17 6
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %r14
test   %rdi,%rdi
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
je     372 <assoc_quote+0x82>
mov    0xc(%rdi),%edx
test   %edx,%edx
je     372 <assoc_quote+0x82>
mov    0x8(%rdi),%eax
xor    %r13d,%r13d
xor    %r12d,%r12d
test   %eax,%eax
jle    366 <assoc_quote+0x76>
nopl   0x0(%rax)
mov    (%r14),%rax
mov    (%rax,%r13,1),%rbx
test   %rbx,%rbx
je     358 <assoc_quote+0x68>
nopl   0x0(%rax)
mov    0x10(%rbx),%rdi
callq  331 <assoc_quote+0x41>
mov    0x10(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     34c <assoc_quote+0x5c>
mov    $0xa0,%edx
mov    $0x0,%esi
callq  34c <assoc_quote+0x5c>
mov    %rbp,0x10(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    328 <assoc_quote+0x38>
add    $0x1,%r12d
add    $0x8,%r13
cmp    %r12d,0x8(%r14)
jg     318 <assoc_quote+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14,%rax
pop    %r14
retq   
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   (%rax)
<<<sep_in_sample>>>
assoc_quote (h)
     HASH_TABLE *h;
{
  int i;
  BUCKET_CONTENTS *tlist;
  char *t;
  if (h == 0 || ((h)->nentries == 0))
    return ((HASH_TABLE *)((void *)0));
  for (i = 0; i < h->nbuckets; i++)
    for (tlist = ((h && (i < h->nbuckets)) ? h->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); tlist; tlist = tlist->next)
      {
 t = quote_string ((char *)tlist->data);
 do { if (tlist->data) sh_xfree((tlist->data), "assoc.c", 160); } while (0);
 tlist->data = t;
      }
  return h;
}
<<<sep_in_sample>>>
1 3
2 7
3 3
4 3
5 3
6 3
7 3
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 13
26 12
27 13
28 13
29 13
30 13
31 13
32 14
33 10
34 10
35 10
36 9
37 9
38 9
39 9
40 17
41 17
42 17
43 17
44 9
45 17
46 17
47 17
48 17
49 17
50 17
51 8
52 17
53 17
54 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
test   %rax,%rax
je     150 <jpeg_stdio_dest+0x40>
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,0x20(%rax)
mov    %rbp,0x28(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rax
mov    $0x38,%edx
xor    %esi,%esi
callq  *(%rax)
mov    %rax,0x28(%rbx)
jmp    125 <jpeg_stdio_dest+0x15>
<<<sep_in_sample>>>
jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
{
  my_dest_ptr dest;
  if (cinfo->dest == ((void *)0)) {
    cinfo->dest = (struct jpeg_destination_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 0,
      ((size_t) sizeof(my_destination_mgr)));
  }
  dest = (my_dest_ptr) cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->outfile = outfile;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 10
10 11
11 12
12 13
13 14
14 14
15 14
16 14
17 14
18 6
19 6
20 6
21 6
22 5
23 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     210 <gsl_multimin_fminimizer_free+0x30>
mov    (%rdi),%rax
mov    0x28(%rdi),%rdi
callq  *0x28(%rax)
mov    0x28(%rbx),%rdi
callq  1fc <gsl_multimin_fminimizer_free+0x1c>
mov    0x18(%rbx),%rdi
callq  205 <gsl_multimin_fminimizer_free+0x25>
mov    %rbx,%rdi
pop    %rbx
jmpq   20e <gsl_multimin_fminimizer_free+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fminimizer_free (gsl_multimin_fminimizer * s)
{
  if (!s) { return ; };
  (s->type->free) (s->state);
  free (s->state);
  gsl_vector_free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 8
14 7
15 7
16 8
17 8
18 8
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 138 <proclist_register+0x8>
push   %rbx
mov    %edi,%ebx
je     160 <proclist_register+0x30>
mov    $0xc,%edi
callq  147 <proclist_register+0x17>
mov    %ebx,(%rax)
movl   $0x1,0x4(%rax)
mov    %rax,%rsi
pop    %rbx
mov    0x0(%rip),%rdi        # 15b <proclist_register+0x2b>
jmpq   160 <proclist_register+0x30>
callq  165 <proclist_register+0x35>
mov    %rax,0x0(%rip)        # 16c <proclist_register+0x3c>
jmp    13d <proclist_register+0xd>
xchg   %ax,%ax
<<<sep_in_sample>>>
proclist_register (pid_t pid)
{
  struct process_status *ps;
  if (!process_list)
    process_list = list_create ();
  ps = xmalloc (sizeof *ps);
  ps->pid = pid;
  ps->running = 1;
  list_append (process_list, ps);
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 6
6 6
7 7
8 8
9 9
10 10
11 9
12 9
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
ucomiss 0x0(%rip),%xmm0        # 7 <cblas_saxpy+0x7>
jnp    140 <cblas_saxpy+0x140>
cmp    $0x1,%edx
je     70 <cblas_saxpy+0x70>
xor    %r9d,%r9d
test   %edx,%edx
jle    158 <cblas_saxpy+0x158>
xor    %eax,%eax
test   %r8d,%r8d
jle    170 <cblas_saxpy+0x170>
test   %edi,%edi
jle    6d <cblas_saxpy+0x6d>
movslq %r9d,%r9
movslq %r8d,%r8
cltq   
movslq %edx,%rdx
lea    (%rsi,%r9,4),%rsi
lea    (%rcx,%rax,4),%rax
shl    $0x2,%r8
shl    $0x2,%rdx
xor    %ecx,%ecx
nopl   0x0(%rax)
movss  (%rsi),%xmm1
add    $0x1,%ecx
mulss  %xmm0,%xmm1
add    %rdx,%rsi
addss  (%rax),%xmm1
movss  %xmm1,(%rax)
add    %r8,%rax
cmp    %edi,%ecx
jne    50 <cblas_saxpy+0x50>
repz retq 
nop
cmp    $0x1,%r8d
jne    12 <cblas_saxpy+0x12>
mov    %edi,%eax
sar    $0x1f,%eax
shr    $0x1e,%eax
lea    (%rdi,%rax,1),%edx
and    $0x3,%edx
sub    %eax,%edx
xor    %eax,%eax
test   %edx,%edx
jle    ab <cblas_saxpy+0xab>
nopl   0x0(%rax)
movss  (%rsi,%rax,4),%xmm1
mulss  %xmm0,%xmm1
addss  (%rcx,%rax,4),%xmm1
movss  %xmm1,(%rcx,%rax,4)
add    $0x1,%rax
cmp    %eax,%edx
jg     90 <cblas_saxpy+0x90>
lea    0x3(%rdx),%eax
cmp    %eax,%edi
jle    17d <cblas_saxpy+0x17d>
sub    $0x4,%edi
movslq %edx,%r8
sub    %rdx,%rdi
lea    0x4(,%r8,4),%r9
and    $0xfffffffc,%edi
add    %r8,%rdi
lea    (%rcx,%r9,1),%rax
add    %r9,%rsi
lea    0x14(%rcx,%rdi,4),%rdx
nopl   0x0(%rax)
movss  -0x4(%rsi),%xmm1
add    $0x10,%rax
add    $0x10,%rsi
mulss  %xmm0,%xmm1
addss  -0x14(%rax),%xmm1
movss  %xmm1,-0x14(%rax)
movss  -0x10(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0x10(%rax),%xmm1
movss  %xmm1,-0x10(%rax)
movss  -0xc(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0xc(%rax),%xmm1
movss  %xmm1,-0xc(%rax)
movss  -0x8(%rsi),%xmm1
mulss  %xmm0,%xmm1
addss  -0x8(%rax),%xmm1
movss  %xmm1,-0x8(%rax)
cmp    %rdx,%rax
jne    e0 <cblas_saxpy+0xe0>
repz retq 
nopl   0x0(%rax,%rax,1)
jne    d <cblas_saxpy+0xd>
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x1,%r9b
sub    %edi,%r9d
imul   %edx,%r9d
jmpq   1d <cblas_saxpy+0x1d>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   28 <cblas_saxpy+0x28>
repz retq 
<<<sep_in_sample>>>
cblas_saxpy (const int N, const float alpha, const float *X, const int incX,
             float *Y, const int incY)
{
{
  int i;
  if (alpha == 0.0) {
    return;
  }
  if (incX == 1 && incY == 1) {
    const int m = N % 4;
    for (i = 0; i < m; i++) {
      Y[i] += alpha * X[i];
    }
    for (i = m; i + 3 < N; i += 4) {
      Y[i] += alpha * X[i];
      Y[i + 1] += alpha * X[i + 1];
      Y[i + 2] += alpha * X[i + 2];
      Y[i + 3] += alpha * X[i + 3];
    }
  } else {
    int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
    int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
    for (i = 0; i < N; i++) {
      Y[iy] += alpha * X[ix];
      ix += incX;
      iy += incY;
    }
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 21
6 21
7 21
8 22
9 22
10 22
11 23
12 23
13 23
14 23
15 23
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 24
24 23
25 24
26 24
27 24
28 24
29 24
30 23
31 23
32 23
33 23
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 10
42 11
43 11
44 11
45 11
46 12
47 12
48 12
49 12
50 12
51 11
52 11
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 14
61 14
62 14
63 14
64 14
65 14
66 15
67 15
68 15
69 15
70 15
71 15
72 16
73 16
74 16
75 16
76 17
77 17
78 17
79 17
80 18
81 18
82 18
83 18
84 14
85 14
86 14
87 14
88 6
89 6
90 6
91 6
92 21
93 21
94 21
95 21
96 21
97 22
98 22
99 22
100 22
101 22
<<<sep_out_sample>>>
push   %rbp
mov    $0x3,%edx
mov    $0x8,%esi
push   %rbx
mov    %rdi,%rbx
lea    0x94(%rdi),%rdi
sub    $0x8,%rsp
callq  89f <is_tar_header+0x1f>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  8aa <is_tar_header+0x2a>
mov    %eax,%eax
xor    %edx,%edx
cmp    %rbp,%rax
jne    8db <is_tar_header+0x5b>
lea    0x101(%rbx),%rsi
mov    $0x0,%edi
mov    $0x5,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
setb   %dl
seta   %al
sub    %edx,%eax
movsbl %al,%eax
cmp    $0x1,%eax
sbb    %edx,%edx
not    %edx
add    $0x2,%edx
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_tar_header (char *buf)
{
  struct tar_header *tar_hdr = (struct tar_header *) buf;
  unsigned long chksum;
  chksum = from_ascii (tar_hdr->chksum, sizeof tar_hdr->chksum, 3);
  if (chksum != tar_checksum (tar_hdr))
    return 0;
  if (!strncmp (tar_hdr->magic, "ustar", 6 - 1))
      return 2;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 5
7 2
8 5
9 6
10 5
11 6
12 6
13 7
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     171 <grecs_asprintf+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  1a2 <grecs_asprintf+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
grecs_asprintf(char **pbuf, size_t *psize, const char *fmt, ...)
{
 int rc;
 va_list ap;
 __builtin_va_start(ap,fmt);
 rc = grecs_vasprintf(pbuf, psize, fmt, ap);
 __builtin_va_end(ap);
 return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 6
17 5
18 5
19 5
20 5
21 5
22 6
23 9
24 9
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
callq  157d <xformat_close_archive+0xd>
movq   $0x0,0x28(%rbx)
movl   $0xffffffff,(%rbx)
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
xformat_close_archive(XFORMAT * xux)
{
 int ret = 0;
 ret = swvarfs_close(xux->swvarfsM);
 xux->swvarfsM = ((void *)0);
 xux->ifdM = -1;
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 8
8 8
9 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2389 <php__scan_string+0x9>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   2395 <php__scan_string+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php__scan_string (const char * yystr )
{
 return php__scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_header_set_value (osip_header_t * header, char *value)
{
  header->hvalue = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 4d8 <get_homedir+0x8>
je     4e0 <get_homedir+0x10>
retq   
nopl   0x0(%rax,%rax,1)
push   %rbx
mov    $0x0,%edi
callq  4eb <get_homedir+0x1b>
test   %rax,%rax
mov    %rax,%rbx
je     4fc <get_homedir+0x2c>
callq  4f8 <get_homedir+0x28>
test   %eax,%eax
jne    51a <get_homedir+0x4a>
nopl   0x0(%rax)
callq  505 <get_homedir+0x35>
mov    %eax,%edi
callq  50c <get_homedir+0x3c>
test   %rax,%rax
je     515 <get_homedir+0x45>
mov    0x20(%rax),%rbx
test   %rbx,%rbx
je     51f <get_homedir+0x4f>
cmpb   $0x0,(%rbx)
jne    528 <get_homedir+0x58>
pop    %rbx
repz retq 
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rsi
xor    %edi,%edi
callq  532 <get_homedir+0x62>
pop    %rbx
mov    %rax,0x0(%rip)        # 53a <get_homedir+0x6a>
jmp    520 <get_homedir+0x50>
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_homedir(void)
{
    if (homedir == ((void *)0)) {
 const char *homenv = getenv("HOME");
 if (homenv == ((void *)0) || geteuid() == 0) {
     const struct passwd *userage = getpwuid(geteuid());
     if (userage != ((void *)0))
  homenv = userage->pw_dir;
 }
 if (homenv != ((void *)0) && strcmp(homenv, "") != 0)
     homedir = mallocstrcpy(((void *)0), homenv);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 13
4 13
5 2
6 4
7 4
8 5
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 8
21 10
22 10
23 10
24 10
25 13
26 13
27 13
28 11
29 11
30 11
31 13
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
sub    $0x8,%rsp
callq  136 <add_visitor+0x16>
mov    0x0(%rip),%rdx        # 13d <add_visitor+0x1d>
mov    %rbx,(%rax)
mov    %rbp,0x8(%rax)
movq   $0x0,0x10(%rax)
test   %rdx,%rdx
je     168 <add_visitor+0x48>
mov    %rax,0x10(%rdx)
mov    %rax,0x0(%rip)        # 15c <add_visitor+0x3c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,0x0(%rip)        # 16f <add_visitor+0x4f>
mov    %rax,0x0(%rip)        # 176 <add_visitor+0x56>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
add_visitor (visitfunc fn, void *context)
{
  struct visitor *p = xmalloc (sizeof (struct visitor));
  p->inspector = fn;
  p->context = context;
  p->next = ((void *)0);
  if (((void *)0) == lastinspector)
    {
      lastinspector = inspectors = p;
    }
  else
    {
      lastinspector->next = p;
      lastinspector = p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 7
9 4
10 5
11 6
12 7
13 7
14 13
15 14
16 16
17 16
18 16
19 16
20 16
21 9
22 9
23 16
24 16
25 16
26 16
27 16
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  6f5 <__osip_add_ist+0x15>
lea    0x50(%rbx),%rdi
mov    %rbp,%rsi
mov    $0xffffffff,%edx
callq  706 <__osip_add_ist+0x26>
mov    0x10(%rbx),%rdi
callq  70f <__osip_add_ist+0x2f>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_add_ist (osip_t * osip, osip_transaction_t * ist)
{
  osip_mutex_lock (osip->ist_fastmutex);
  osip_list_add (&osip->osip_ist_transactions, ist, -1);
  osip_mutex_unlock (osip->ist_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
mov    (%rsi),%eax
cmp    %eax,(%rdi)
setle  %al
movzbl %al,%eax
neg    %eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
_compare_prio (const void *item, const void *value)
{
  const mu_record_t a = (const mu_record_t) item;
  const mu_record_t b = (const mu_record_t) value;
  if (a->priority > b->priority)
    return 0;
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 8
7 8
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
push   %rbx
testb  $0x2,0x10(%rdi)
mov    %rdi,%rbx
je     443 <wsnode_free+0x13>
mov    0x18(%rdi),%rdi
callq  443 <wsnode_free+0x13>
mov    %rbx,%rdi
pop    %rbx
jmpq   44c <wsnode_free+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
wsnode_free (struct wordsplit_node *p)
{
  if (p->flags & 0x02)
    free (p->v.word);
  free (p);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x20(%rdi),%rcx
lea    (%rax,%rcx,8),%rdx
cmp    %rdx,%rax
jae    480 <hash_delete_items+0x20>
movq   $0x0,(%rax)
add    $0x8,%rax
cmp    %rax,%rdx
ja     470 <hash_delete_items+0x10>
movq   $0x0,0x30(%rdi)
movq   $0x0,0x40(%rdi)
movq   $0x0,0x48(%rdi)
movl   $0x0,0x50(%rdi)
mov    %rcx,0x38(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_delete_items (struct hash_table *ht)
{
  void **vec = ht->ht_vec;
  void **end = &vec[ht->ht_size];
  for (; vec < end; vec++)
    *vec = 0;
  ht->ht_fill = 0;
  ht->ht_collisions = 0;
  ht->ht_lookups = 0;
  ht->ht_rehashes = 0;
  ht->ht_empty_slots = ht->ht_size;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 6
7 5
8 5
9 5
10 7
11 8
12 9
13 10
14 11
15 11
16 11
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     750 <gsl_vector_complex_float_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  745 <gsl_vector_complex_float_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     79a <gsl_vector_complex_float_add+0x7a>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rdx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %ecx,%ecx
nop
movss  (%rax),%xmm0
add    $0x1,%rcx
addss  (%rdx),%xmm0
movss  %xmm0,(%rax)
movss  0x4(%rax),%xmm0
addss  0x4(%rdx),%xmm0
add    %r9,%rdx
movss  %xmm0,0x4(%rax)
add    %r10,%rax
cmp    %r8,%rcx
jne    770 <gsl_vector_complex_float_add+0x50>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_vector_complex_float_add (gsl_vector_complex_float * a, const gsl_vector_complex_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_complex_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[2 * i * stride_a] += b->data[2 * i * stride_b];
          a->data[2 * i * stride_a + 1] += b->data[2 * i * stride_b + 1];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 20
12 20
13 20
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 16
29 16
30 16
31 16
32 16
33 13
34 13
35 18
36 20
37 20
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    %rsi,0x8(%rdi)
jbe    1fe0 <gsl_vector_long_alloc_col_from_matrix+0x50>
mov    $0x28,%edi
callq  1fac <gsl_vector_long_alloc_col_from_matrix+0x1c>
test   %rax,%rax
je     2002 <gsl_vector_long_alloc_col_from_matrix+0x72>
mov    0x18(%rbx),%rdx
lea    (%rdx,%rbp,8),%rdx
mov    %rdx,0x10(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    0x10(%rbx),%rdx
movq   $0x0,0x18(%rax)
mov    %rdx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xd2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ff9 <gsl_vector_long_alloc_col_from_matrix+0x69>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x8,%ecx
mov    $0xda,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  201b <gsl_vector_long_alloc_col_from_matrix+0x8b>
xor    %eax,%eax
jmp    1fd3 <gsl_vector_long_alloc_col_from_matrix+0x43>
nop
<<<sep_in_sample>>>
gsl_vector_long_alloc_col_from_matrix (gsl_matrix_long * m,
                                              const size_t j)
{
  gsl_vector_long * v;
  const size_t N = m->size2;
  if (j >= N)
    {
      do { gsl_error ("column index is out of range", "getset_source.c", 210, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_long *) malloc (sizeof (gsl_vector_long));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 218
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * j ;
  v->size = m->size1;
  v->stride = m->tda;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 10
9 10
10 11
11 11
12 20
13 20
14 20
15 21
16 21
17 22
18 23
19 22
20 25
21 25
22 25
23 25
24 25
25 8
26 8
27 8
28 8
29 8
30 25
31 8
32 25
33 25
34 25
35 13
36 13
37 13
38 13
39 13
40 17
41 17
42 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  779 <dstrcspn+0x9>
add    $0x8,%rsp
sub    $0x1,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dstrcspn (string, charset)
     DStr_string_descriptor *string;
     DStr_string_descriptor *charset;
{
  return dstrpbrk (string, charset) - 1;
  }
<<<sep_in_sample>>>
1 4
2 5
3 6
4 5
5 6
6 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
jmpq   1203 <gsl_sort_vector_long+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long (gsl_vector_long * v)
{
  gsl_sort_long (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
cvtsi2sdl (%rdi),%xmm1
subsd  %xmm0,%xmm1
cmp    $0x1,%rdx
mulsd  %xmm1,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
jbe    60b <gsl_stats_int_lag1_autocorrelation_m+0x8b>
shl    $0x2,%rsi
fldz   
mov    $0x1,%eax
lea    (%rdi,%rsi,1),%rcx
jmp    5df <gsl_stats_int_lag1_autocorrelation_m+0x5f>
nopl   (%rax)
cvtsi2sdl (%rdi),%xmm1
subsd  %xmm0,%xmm1
add    %rsi,%rdi
add    %rsi,%rcx
cmp    %rdx,%rax
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fmul   %st(2),%st
fsub   %st(3),%st
fdiv   %st(1),%st
faddp  %st,%st(3)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(3),%st
fdivp  %st,%st(1)
faddp  %st,%st(2)
je     610 <gsl_stats_int_lag1_autocorrelation_m+0x90>
cvtsi2sdl (%rcx),%xmm1
subsd  %xmm0,%xmm1
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
test   %rax,%rax
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fildll -0x18(%rsp)
jns    5b0 <gsl_stats_int_lag1_autocorrelation_m+0x30>
fadds  0x0(%rip)        # 609 <gsl_stats_int_lag1_autocorrelation_m+0x89>
jmp    5b0 <gsl_stats_int_lag1_autocorrelation_m+0x30>
fldz   
nopl   (%rax)
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_int_lag1_autocorrelation_m (const int data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 6
3 7
4 6
5 6
6 6
7 7
8 7
9 5
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 9
18 7
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 12
29 12
30 7
31 10
32 10
33 11
34 11
35 11
36 10
37 10
38 11
39 11
40 11
41 11
42 5
43 5
44 14
45 15
46 15
47 16
48 16
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  e <opentoken+0xe>
mov    %rax,%rdx
mov    %rax,0x0(%rip)        # 18 <opentoken+0x18>
xor    %eax,%eax
test   %rdx,%rdx
je     af <opentoken+0xaf>
mov    $0x400,%edi
callq  2d <opentoken+0x2d>
mov    $0x1000,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    %rax,0x0(%rip)        # 41 <opentoken+0x41>
callq  46 <opentoken+0x46>
movq   $0x0,0x0(%rip)        # 51 <opentoken+0x51>
movq   $0x0,0x0(%rip)        # 5c <opentoken+0x5c>
mov    $0x1,%eax
movq   $0x0,0x0(%rip)        # 6c <opentoken+0x6c>
movb   $0x0,0x0(%rip)        # 73 <opentoken+0x73>
movl   $0x0,0x0(%rip)        # 7d <opentoken+0x7d>
movl   $0x0,0x0(%rip)        # 87 <opentoken+0x87>
movl   $0x0,0x0(%rip)        # 91 <opentoken+0x91>
movl   $0x0,0x0(%rip)        # 9b <opentoken+0x9b>
movl   $0x0,0x0(%rip)        # a5 <opentoken+0xa5>
movl   $0x0,0x0(%rip)        # af <opentoken+0xaf>
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
opentoken(const char *file)
{
 if ((ip = fopen(file, "rb")) == ((void *)0))
  return 0;
 ib = strbuf_open(1024);
 strlimcpy(curfile, file, sizeof(curfile));
 sp = cp = lp = ((void *)0); ptok[0] = '\0'; lineno = 0;
 crflag = cmode = cppmode = ymode = 0;
 continued_line = 0;
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 4
8 3
9 3
10 5
11 5
12 6
13 6
14 6
15 5
16 6
17 7
18 7
19 10
20 7
21 7
22 7
23 8
24 8
25 8
26 8
27 9
28 11
29 11
30 11
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1b67 <php_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_set_out (FILE * out_str )
{
        php_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
push   %r14
xor    %r14d,%r14d
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0xac(%rdi),%edx
movl   $0x0,0xc(%rsp)
test   %edx,%edx
jle    e8d <match_ctx_clean+0xbd>
nopw   0x0(%rax,%rax,1)
mov    0xb8(%r15),%rax
xor    %ebp,%ebp
xor    %ebx,%ebx
mov    (%rax,%r14,1),%r13
mov    0x14(%r13),%eax
test   %eax,%eax
jle    e47 <match_ctx_clean+0x77>
nopw   0x0(%rax,%rax,1)
mov    0x18(%r13),%rdx
add    $0x1,%ebx
mov    (%rdx,%rbp,1),%r12
add    $0x8,%rbp
mov    0x10(%r12),%rdi
callq  e39 <match_ctx_clean+0x69>
mov    %r12,%rdi
callq  e41 <match_ctx_clean+0x71>
cmp    %ebx,0x14(%r13)
jg     e20 <match_ctx_clean+0x50>
mov    0x18(%r13),%rdi
callq  e50 <match_ctx_clean+0x80>
mov    0x8(%r13),%rdx
test   %rdx,%rdx
je     e6b <match_ctx_clean+0x9b>
mov    0x8(%rdx),%rdi
callq  e62 <match_ctx_clean+0x92>
mov    0x8(%r13),%rdi
callq  e6b <match_ctx_clean+0x9b>
mov    %r13,%rdi
add    $0x8,%r14
callq  e77 <match_ctx_clean+0xa7>
addl   $0x1,0xc(%rsp)
mov    0xc(%rsp),%eax
cmp    %eax,0xac(%r15)
jg     e00 <match_ctx_clean+0x30>
movl   $0x0,0xac(%r15)
movl   $0x0,0x94(%r15)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
match_ctx_clean (re_match_context_t *mctx)
{
  int st_idx;
  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)
    {
      int sl_idx;
      re_sub_match_top_t *top = mctx->sub_tops[st_idx];
      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)
 {
   re_sub_match_last_t *last = top->lasts[sl_idx];
   free (last->path.array);
   free (last);
 }
      free (top->lasts);
      if (top->path)
 {
   free (top->path->array);
   free (top->path);
 }
      free (top);
    }
  mctx->nsub_tops = 0;
  mctx->nbkref_ents = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 4
13 4
14 4
15 7
16 8
17 8
18 7
19 8
20 8
21 8
22 8
23 10
24 8
25 10
26 10
27 11
28 11
29 12
30 12
31 8
32 8
33 14
34 14
35 15
36 15
37 15
38 17
39 17
40 18
41 18
42 20
43 20
44 20
45 4
46 4
47 4
48 4
49 22
50 23
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
59 24
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  1f2 <f_ulong+0x12>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_ulong (FILE *fp, void *ptr, int size) { fprintf (fp, "%lu", *(unsigned long*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
mov    $0x3a,%edx
jmpq   158a <quotearg_colon_mem+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     11b <success+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%eax        # 148 <success+0x88>
test   %eax,%eax
je     160 <success+0xa0>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 156 <success+0x96>
lea    0x8(%rsp),%rdx
callq  160 <success+0xa0>
add    $0xd8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
success (const char *format, ...)
{
  va_list arg_ptr;
  __builtin_va_start(arg_ptr,format);
  if (debug)
    vfprintf (stdout, format, arg_ptr);
  __builtin_va_end(arg_ptr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 8
31 8
32 8
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
movq   $0x0,0x10(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
sexp_input_init(struct sexp_input *input, FILE *f)
{
  input->f = f;
  input->coding = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
test   %rdx,%rdx
jne    40 <jit_memcpy+0x10>
mov    %rdi,%rax
retq   
nopl   0x0(%rax)
jmpq   45 <jit_memcpy+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
jit_memcpy(jit_pointer_t dst, const void * src, jit_word_t size)
{
    if (size)
 return (memcpy(dst, src, size));
    return (dst);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 4
7 4
<<<sep_out_sample>>>
push   %r13
mov    $0x1,%eax
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%ecx
cmp    %ecx,(%rdi)
je     270 <cidr_cmp+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x4(%rdi),%edx
cmp    0x4(%rsi),%edx
mov    $0x1,%r12d
je     290 <cidr_cmp+0x50>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
movslq %edx,%r13
lea    0x8(%rsi),%rsi
lea    0x8(%rdi),%rdi
mov    %r13,%rdx
callq  2a3 <cidr_cmp+0x63>
test   %eax,%eax
jne    27e <cidr_cmp+0x3e>
lea    0x18(%rbp),%rsi
lea    0x18(%rbx),%rdi
mov    %r13,%rdx
xor    %r12d,%r12d
callq  2ba <cidr_cmp+0x7a>
test   %eax,%eax
setne  %r12b
jmp    27e <cidr_cmp+0x3e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cidr_cmp(const void *elt1, const void *elt2)
{
 struct grecs_cidr const *cp1 = elt1, *cp2 = elt2;
 return !(cp1->family == cp2->family
   && cp1->len == cp2->len
   && memcmp(cp1->address, cp2->address, cp1->len) == 0
   && memcmp(cp1->netmask, cp2->netmask, cp1->len) == 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 5
20 5
21 4
22 5
23 8
24 4
25 8
26 8
27 8
28 8
29 8
30 8
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 7
39 7
40 7
41 4
42 7
43 4
44 4
45 4
46 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x155,%esi
mov    %rdi,%rbx
mov    $0x0,%edi
callq  a33 <dfaerror+0x13>
mov    $0x0,%edi
mov    %rbx,%rsi
xor    %eax,%eax
callq  a42 <dfaerror+0x22>
mov    $0x2,%edi
callq  a4c <dfaerror+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dfaerror(const char *s)
{
 (*(set_loc("re.c", 341), r_fatal))("%s", s);
 exit(2);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # d68 <probt+0x8>
movsd  0x0(%rip),%xmm2        # d70 <probt+0x10>
andpd  %xmm0,%xmm1
ucomisd %xmm1,%xmm2
jb     d80 <probt+0x20>
jmpq   c90 <probt.part.3>
nop
xorpd  %xmm0,%xmm0
divsd  %xmm0,%xmm0
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
probt(double t1, int di)
{
  double c;
  double ddi;
  if (!finite(t1))
    return 0.0 / 0.0;
  ddi = (double) di;
  dddi = ddi;
  for (c = 1.0; ddi > 2.0; ddi -= 2.0)
    c *= (ddi - 1.0) / (ddi - 2.0);
  if (ddi == 2.0)
    c *= 0.5;
  else
    c /= 3.14159265358979323846;
  return c * dap_simp(&Tfun, atan(t1 / sqrt(dddi)), 1.57079632679489661923, 1024);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 16
11 16
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  cf <diraccess+0xf>
xor    %edx,%edx
test   %eax,%eax
jne    e6 <diraccess+0x26>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
diraccess (char const *dir)
{
  struct stat buf;
  return stat (dir, &buf) == 0 && ((((buf.st_mode)) & 0170000) == (0040000));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 470 <free_ps_list+0x10>
test   %eax,%eax
jle    4a6 <free_ps_list+0x46>
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 47f <free_ps_list+0x1f>
add    $0x1,%ebp
mov    (%rax,%rbx,1),%rdi
callq  48b <free_ps_list+0x2b>
mov    0x0(%rip),%rax        # 492 <free_ps_list+0x32>
movq   $0x0,(%rax,%rbx,1)
add    $0x8,%rbx
cmp    %ebp,0x0(%rip)        # 4a4 <free_ps_list+0x44>
jg     478 <free_ps_list+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
free_ps_list()
{
    int i;
    for (i = 0; i < processes; i++)
    {
 xfree(ps_vect[i]);
 ps_vect[i] = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 4
7 4
8 4
9 4
10 6
11 4
12 6
13 6
14 7
15 7
16 7
17 4
18 4
19 9
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 38 <do_last_line+0x8>
mov    0x10(%rbx),%rax
mov    (%rax),%rdi
mov    %rax,0x20(%rbx)
callq  48 <do_last_line+0x18>
mov    %rax,0x30(%rbx)
callq  51 <do_last_line+0x21>
mov    %rax,0x38(%rbx)
mov    0x0(%rip),%eax        # 5b <do_last_line+0x2b>
movb   $0x1,0x0(%rip)        # 62 <do_last_line+0x32>
movb   $0x0,0x0(%rip)        # 69 <do_last_line+0x39>
lea    -0x1(%rax),%edx
mov    0x0(%rip),%rax        # 73 <do_last_line+0x43>
movslq %edx,%rdx
mov    %rdx,0x40(%rax)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
do_last_line(void)
{
    openfile->current = openfile->filebot;
    openfile->current_x = strlen(openfile->filebot->data);
    openfile->placewewant = xplustabs();
    openfile->current_y = editwinrows - 1;
    refresh_needed = 1;
    focusing = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 5
9 5
10 6
11 7
12 8
13 6
14 6
15 6
16 6
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    %edi,%edx
mov    0x0(%rip),%rdi        # 49 <gotolabel+0x9>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   55 <gotolabel+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gotolabel (int l)
{
  fprintf (ccode, "goto __l%d;", l);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm0        # 3f8 <gsl_sf_laguerre_2_e+0x8>
jnp    4b0 <gsl_sf_laguerre_2_e+0xc0>
movsd  0x0(%rip),%xmm4        # 406 <gsl_sf_laguerre_2_e+0x16>
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 410 <gsl_sf_laguerre_2_e+0x20>
addsd  %xmm0,%xmm4
movsd  0x0(%rip),%xmm2        # 41c <gsl_sf_laguerre_2_e+0x2c>
movsd  0x0(%rip),%xmm5        # 424 <gsl_sf_laguerre_2_e+0x34>
movsd  0x0(%rip),%xmm6        # 42c <gsl_sf_laguerre_2_e+0x3c>
divsd  %xmm4,%xmm3
addsd  %xmm6,%xmm0
xorpd  %xmm4,%xmm2
mulsd  %xmm4,%xmm5
movsd  0x0(%rip),%xmm4        # 444 <gsl_sf_laguerre_2_e+0x54>
mulsd  %xmm1,%xmm3
mulsd  %xmm1,%xmm2
mulsd  %xmm0,%xmm5
movapd %xmm3,%xmm1
andpd  %xmm4,%xmm3
addsd  %xmm6,%xmm1
addsd  %xmm3,%xmm3
mulsd  %xmm2,%xmm1
andpd  %xmm4,%xmm2
addsd  %xmm6,%xmm3
addsd  %xmm2,%xmm2
addsd  %xmm5,%xmm1
andpd  %xmm4,%xmm5
mulsd  %xmm3,%xmm2
movapd %xmm5,%xmm0
movsd  %xmm1,(%rdi)
andpd  %xmm4,%xmm1
addsd  %xmm2,%xmm0
movsd  0x0(%rip),%xmm2        # 494 <gsl_sf_laguerre_2_e+0xa4>
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm0
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
jne    3fe <gsl_sf_laguerre_2_e+0xe>
movsd  0x0(%rip),%xmm0        # 4be <gsl_sf_laguerre_2_e+0xce>
xor    %eax,%eax
mulsd  %xmm1,%xmm0
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 4d0 <gsl_sf_laguerre_2_e+0xe0>
movsd  %xmm0,(%rdi)
andpd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 4e0 <gsl_sf_laguerre_2_e+0xf0>
movsd  %xmm0,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_laguerre_2_e(const double a, const double x, gsl_sf_result * result)
{
  if(a == -2.0) {
    result->val = 0.5*x*x;
    result->err = 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
  else {
    double c0 = 0.5 * (2.0+a)*(1.0+a);
    double c1 = -(2.0+a);
    double c2 = -0.5/(2.0+a);
    result->val = c0 + c1*x*(1.0 + c2*x);
    result->err = 2.0 * 2.2204460492503131e-16 * (fabs(c0) + 2.0 * fabs(c1*x) * (1.0 + 2.0 * fabs(c2*x)));
    result->err += 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 17
5 11
6 9
7 10
8 9
9 9
10 11
11 9
12 10
13 9
14 13
15 12
16 12
17 9
18 12
19 13
20 12
21 13
22 12
23 13
24 13
25 13
26 12
27 13
28 13
29 13
30 12
31 14
32 13
33 13
34 14
35 13
36 14
37 14
38 17
39 17
40 3
41 4
42 17
43 4
44 4
45 5
46 4
47 5
48 5
49 5
50 17
51 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rsi
mov    %rdi,%rbp
mov    $0x0,%edx
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # a28 <string_create+0x18>
callq  a2d <string_create+0x1d>
test   %rax,%rax
mov    %rax,%rbx
je     a48 <string_create+0x38>
addq   $0x1,0x8(%rbx)
mov    (%rbx),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x10,%edi
callq  a52 <string_create+0x42>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  a5d <string_create+0x4d>
mov    0x0(%rip),%rdi        # a64 <string_create+0x54>
mov    %rax,(%rbx)
mov    %rbx,%rsi
movq   $0x0,0x8(%rbx)
callq  a77 <string_create+0x67>
addq   $0x1,0x8(%rbx)
mov    (%rbx),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_create (char *str)
{
  struct strobj *s = list_locate (string_list, str, string_comparator);
  if (!s)
    {
      s = xmalloc (sizeof (*s));
      s->value = strdup (str);
      s->refcnt = 0;
      list_prepend (string_list, s);
    }
  s->refcnt++;
  return s->value;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 4
10 3
11 4
12 11
13 12
14 13
15 13
16 13
17 13
18 13
19 6
20 6
21 7
22 6
23 7
24 9
25 7
26 9
27 8
28 9
29 11
30 12
31 13
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
mov    $0x3,%ecx
mov    $0x0,%edi
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     28 <print_reply+0x28>
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
jmpq   24 <print_reply+0x24>
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x0,%edi
callq  36 <print_reply+0x36>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   42 <print_reply+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_reply(struct dict_connection *conn)
{
    if (strncmp(conn->buf, "552", 3) == 0)
 printf("%s\n", gettext ("No match"));
    else
 printf("Error: %s\n", conn->buf);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 6
12 2
13 4
14 4
15 7
16 4
17 4
18 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,(%rsp)
mov    %esi,0xc(%rsp)
callq  615 <susystem+0x15>
cmp    $0xffffffff,%eax
mov    %eax,%ebx
je     6c0 <susystem+0xc0>
test   %eax,%eax
je     688 <susystem+0x88>
mov    $0x1,%esi
mov    $0x2,%edi
callq  633 <susystem+0x33>
mov    $0x1,%esi
mov    $0x3,%edi
mov    %rax,%r12
callq  645 <susystem+0x45>
lea    0x1c(%rsp),%rsi
xor    %edx,%edx
mov    %ebx,%edi
mov    %rax,%rbp
callq  656 <susystem+0x56>
test   %eax,%eax
js     6d0 <susystem+0xd0>
mov    %r12,%rsi
mov    $0x2,%edi
callq  667 <susystem+0x67>
mov    %rbp,%rsi
mov    $0x3,%edi
callq  674 <susystem+0x74>
mov    0x1c(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0xc(%rsp),%edi
callq  691 <susystem+0x91>
mov    (%rsp),%rcx
mov    $0x0,%edi
xor    %r8d,%r8d
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  6ae <susystem+0xae>
mov    $0x7f,%edi
callq  6b8 <susystem+0xb8>
nopl   0x0(%rax,%rax,1)
add    $0x20,%rsp
mov    $0x7f,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
movl   $0xffffffff,0x1c(%rsp)
jmp    65a <susystem+0x5a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
susystem (char *s, int userid)
{
  sighandler_t istat, qstat;
  int status;
  pid_t pid;
  pid = vfork ();
  switch (pid)
    {
    case -1:
      return (127);
    case 0:
      setuid (userid);
      execl ("/bin/sh", "sh", "-c", s, ((void *)0));
      _exit (127);
    }
  istat = signal (2, ((__sighandler_t) 1));
  qstat = signal (3, ((__sighandler_t) 1));
  if (waitpid (pid, &status, 0) < 0)
    status = -1;
  signal (2, istat);
  signal (3, qstat);
  return (status);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 7
9 6
10 7
11 7
12 7
13 16
14 16
15 16
16 17
17 17
18 16
19 17
20 18
21 18
22 18
23 17
24 18
25 18
26 18
27 20
28 20
29 20
30 21
31 21
32 21
33 22
34 23
35 23
36 23
37 23
38 23
39 23
40 12
41 12
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 14
50 14
51 14
52 23
53 10
54 23
55 23
56 23
57 23
58 23
59 19
60 19
61 19
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0xe8(%rdi),%rbp
callq  1603 <CDB___ham_item_last+0x23>
test   %eax,%eax
je     1620 <CDB___ham_item_last+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x48(%rbp),%r15
mov    0x48(%r15),%r12d
lea    0x1(%r12),%edi
mov    %r12d,0x58(%rbp)
callq  1636 <CDB___ham_item_last+0x56>
mov    %eax,%eax
mov    %rbx,%rdi
mov    %r13d,%esi
add    0x60(%r15,%rax,4),%r12d
orl    $0x100,0x70(%rbp)
mov    %r14,%rdx
mov    %r12d,0x14(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   1664 <CDB___ham_item_last+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___ham_item_last(dbc, mode, pgnop)
 DBC *dbc;
 db_lockmode_t mode;
 db_pgno_t *pgnop;
{
 HASH_CURSOR *hcp;
 int ret;
 hcp = (HASH_CURSOR *)dbc->internal;
 if ((ret = CDB___ham_item_reset(dbc)) != 0)
  return (ret);
 hcp->bucket = hcp->hdr->max_bucket;
 hcp->pgno = ((hcp->bucket) + (hcp)->hdr->spares[CDB___db_log2((hcp->bucket)+1)]);
 (hcp)->flags |= (0x0100);
 return (CDB___ham_item_prev(dbc, mode, pgnop));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 9
13 9
14 9
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 11
25 11
26 12
27 11
28 12
29 12
30 14
31 14
32 12
33 13
34 14
35 12
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 14
44 14
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  7df <symlink_error+0xf>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 7e8 <symlink_error+0x18>
test   %rax,%rax
je     7ef <symlink_error+0x1f>
callq  *%rax
mov    %r12,%rsi
mov    $0x1,%edi
callq  7fc <symlink_error+0x2c>
mov    %rbp,%rdi
mov    %rax,%r12
callq  807 <symlink_error+0x37>
mov    $0x0,%edi
mov    %rax,%rbp
callq  814 <symlink_error+0x44>
mov    %r12,%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  828 <symlink_error+0x58>
pop    %rbx
pop    %rbp
movl   $0x2,0x0(%rip)        # 834 <symlink_error+0x64>
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
symlink_error (char const *contents, char const *name)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot create symlink to %s"), quotearg_colon (name), quote_n (1, contents)); exit_status = 2; } while (0)
                                                 ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 6
29 6
30 4
31 6
32 6
33 6
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   2b <direntry_cmp_name+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %r9,0x48(%rsp)
je     4f7 <swutil_doif_writef+0x47>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%r9
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x28,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  528 <swutil_doif_writef+0x78>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
swutil_doif_writef(int verbose_level, int write_at_level,
   struct sw_logspec * logspec, int fd, char * format, ...)
{
 int ret;
 va_list ap;
 __builtin_va_start(ap,format);
 ret = doif_i_writef(verbose_level,
   write_at_level,
   logspec,
   fd, format, &ap);
 __builtin_va_end(ap);
 return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 7
15 6
16 6
17 6
18 6
19 6
20 7
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     b80 <gsl_sort_vector_long_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b75 <gsl_sort_vector_long_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  b91 <gsl_sort_vector_long_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_index (gsl_permutation * permutation, const gsl_vector_long * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_long_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r12
movzbl (%rdi),%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
movzbl (%rsi),%eax
jmp    ad8 <word_match+0x28>
nopl   0x0(%rax,%rax,1)
cmp    $0xa,%al
je     b38 <word_match+0x88>
test   %al,%al
je     b38 <word_match+0x88>
movzbl 0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %al,%r12b
jne    ac8 <word_match+0x18>
callq  ae2 <word_match+0x32>
movzbl -0x1(%rbx),%edx
mov    (%rax),%rsi
movsbq %dl,%rax
testb  $0x8,(%rsi,%rax,2)
jne    ad0 <word_match+0x20>
cmp    $0x5f,%dl
mov    %rbp,%rax
je     ad0 <word_match+0x20>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
add    $0x1,%rbx
movzbl (%rax),%ecx
movzbl (%rbx),%edx
cmp    %dl,%cl
je     b00 <word_match+0x50>
test   %cl,%cl
jne    b30 <word_match+0x80>
movsbq %dl,%rax
testb  $0x8,(%rsi,%rax,2)
jne    b30 <word_match+0x80>
cmp    $0x5f,%dl
jne    b3f <word_match+0x8f>
mov    $0x5f,%eax
jmp    ad8 <word_match+0x28>
nopl   0x0(%rax)
mov    %edx,%eax
jmp    ad8 <word_match+0x28>
nopl   0x0(%rax)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    $0x1,%eax
jmp    b3a <word_match+0x8a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
word_match (char const *name_0, char const *line)
{
  char const *name = name_0;
  for (;;)
    {
      while (*line != *name)
 {
   if (*line == '\0' || *line == '\n')
     return 0;
   line++;
 }
      if ((((*__ctype_b_loc ())[(int) ((line[-1]))] & (unsigned short int) _ISalnum) || (line[-1]) == '_'))
 {
   line++;
   continue;
 }
      while (*++name == *++line)
 ;
      if (*name == '\0' && !(((*__ctype_b_loc ())[(int) ((*line))] & (unsigned short int) _ISalnum) || (*line) == '_'))
 return 1;
      name = name_0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 8
11 8
12 8
13 8
14 8
15 14
16 6
17 6
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 17
29 17
30 17
31 17
32 17
33 17
34 19
35 19
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 9
48 23
49 23
50 23
51 23
52 20
53 20
54 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  589 <dupstr+0x9>
lea    0x0(%rip),%rsi        # 590 <dupstr+0x10>
lea    0x1(%rax),%edi
callq  598 <dupstr+0x18>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  5a3 <dupstr+0x23>
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dupstr(const char *str)
{
   char *ret;
   ret = mymalloc(strlen(str) + 1,"(dupstr)");
   strcpy(ret, str);
   return (ret);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 59b <askforreturn+0xb>
mov    $0x22,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  5af <askforreturn+0x1f>
callq  5b4 <askforreturn+0x24>
cmpl   $0x1,0x0(%rip)        # 5bb <askforreturn+0x2b>
je     5c8 <askforreturn+0x38>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 5cf <askforreturn+0x3f>
mov    $0xffffffff,%edx
test   %rdi,%rdi
je     5e0 <askforreturn+0x50>
movswl 0x4(%rdi),%edx
add    $0x1,%edx
xor    %esi,%esi
add    $0x8,%rsp
jmpq   5eb <askforreturn+0x5b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
askforreturn(void)
{
    fprintf(stderr, "Press the RETURN key to continue: ");
    getchar();
    if (incurses == YES) {
 wredrawln(curscr, 0, ((curscr) ? (curscr)->_maxy+1 : -1));
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 8
11 8
12 8
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 6
22 6
<<<sep_out_sample>>>
lea    0x2(%rdi),%rdx
lea    0x3(%rdi),%rax
imul   %rdx,%rax
lea    0x1(%rdi),%rdx
imul   %rdi,%rdx
shr    %rax
shr    %rdx
imul   %rdx,%rax
retq   
nop
<<<sep_in_sample>>>
mul4 (mp_limb_t m)
{
  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;
  mp_limb_t m23 = (m + 2) * (m + 3) >> 1;
  return m01 * m23;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 3
6 4
7 3
8 5
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <ostream__write_mem+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ostream__write_mem (ostream_t first_arg, const void *data, size_t len)
{
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  681 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6c0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  69f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6d8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6c0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6e4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
sasl_enabled_p()
{
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    $0x43,%esi
callq  4e81 <swc_get_default_sh_dash_s+0x11>
mov    $0x7,%ecx
mov    %rax,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x0,%eax
seta   %cl
setb   %dl
cmp    %dl,%cl
je     4ea6 <swc_get_default_sh_dash_s+0x36>
mov    0x4e0(%rbx),%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
swc_get_default_sh_dash_s(GB * G)
{
 if (strcmp(get_opta(G->optaM, SW_E_swbis_shell_command), "detect") == 0)
  return "exit 1";
 else
  return G->g_sh_dash_s;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 3
12 3
13 3
14 3
15 6
16 7
17 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r11
cmp    (%rdi),%r11
mov    0x8(%rdi),%rax
je     3920 <gsl_matrix_uchar_mul_elements+0x40>
mov    $0x13,%ecx
mov    $0x56,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  390d <gsl_matrix_uchar_mul_elements+0x2d>
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rbp
cmp    %rax,%rbp
jne    38f4 <gsl_matrix_uchar_mul_elements+0x14>
test   %r11,%r11
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r14
je     3987 <gsl_matrix_uchar_mul_elements+0xa7>
sub    %r13,%r14
xor    %r9d,%r9d
xor    %ebx,%ebx
xor    %r12d,%r12d
nopl   0x0(%rax)
test   %rbp,%rbp
je     3978 <gsl_matrix_uchar_mul_elements+0x98>
lea    (%rbx,%rbp,1),%r10
mov    %rbx,%rdx
nopl   0x0(%rax)
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
mov    %r9,%r8
add    0x18(%rsi),%r8
movzbl (%rcx),%eax
mulb   (%r8,%rdx,1)
add    $0x1,%rdx
cmp    %r10,%rdx
mov    %al,(%rcx)
jne    3958 <gsl_matrix_uchar_mul_elements+0x78>
add    $0x1,%r12
add    %r13,%rbx
add    %r14,%r9
cmp    %r11,%r12
jne    3948 <gsl_matrix_uchar_mul_elements+0x68>
xor    %eax,%eax
jmp    3912 <gsl_matrix_uchar_mul_elements+0x32>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_mul_elements (gsl_matrix_uchar * a, const gsl_matrix_uchar * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 86, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 16
38 16
39 16
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 16
48 18
49 16
50 14
51 14
52 14
53 14
54 14
55 21
56 21
57 21
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
sub    0x18(%rsi),%eax
jne    1cf8 <a_word_hash_cmp+0x28>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rsi
cmp    %rsi,%rdi
je     1cf0 <a_word_hash_cmp+0x20>
jmpq   1cea <a_word_hash_cmp+0x1a>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
a_word_hash_cmp (const void *x, const void *y)
{
  int result = ((struct a_word const *) x)->length - ((struct a_word const *) y)->length;
  if (result)
    return result;
  do { return (((struct a_word const *) x)->str) == (((struct a_word const *) y)->str) ? 0 : strcmp ((((struct a_word const *) x)->str), (((struct a_word const *) y)->str)); } while (0)
                                                          ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%rax
mov    %rdx,%r14
shr    $0x2,%rax
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
lea    0x3(%rax,%rax,2),%rdi
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x20,%rsp
mov    %rdi,0x18(%rsp)
callq  661 <base64_decode_alloc_ctx+0x31>
test   %rax,%rax
mov    %rax,(%rbx)
je     6a0 <base64_decode_alloc_ctx+0x70>
lea    0x18(%rsp),%r8
mov    %rax,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  67f <base64_decode_alloc_ctx+0x4f>
test   %al,%al
je     6b8 <base64_decode_alloc_ctx+0x88>
test   %rbp,%rbp
je     6a0 <base64_decode_alloc_ctx+0x70>
mov    0x18(%rsp),%rdx
mov    %rdx,0x0(%rbp)
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %eax,0xc(%rsp)
callq  6c4 <base64_decode_alloc_ctx+0x94>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
base64_decode_alloc_ctx (struct base64_decode_context *ctx,
                         const char *in, size_t inlen, char **out,
                         size_t *outlen)
{
  size_t needlen = 3 * (inlen / 4) + 3;
  *out = malloc (needlen);
  if (!*out)
    return 1;
  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))
    {
      free (*out);
      *out = ((void *)0);
      return 0;
    }
  if (outlen)
    *outlen = needlen;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 15
29 15
30 16
31 16
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 8
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 11
50 11
51 11
52 12
53 13
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
sub    %edx,0x28(%rdi)
mov    0x18(%rdi),%rdi
mov    %rbp,%rdx
callq  ca <xdrumem_getbytes+0x1a>
add    %rbp,0x18(%rbx)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdrumem_getbytes(register XDR * xdrs, caddr_t addr, register u_int len)
{
 if ((xdrs->x_handy -= len) < 0)
  return ((0));
 bcopy(xdrs->x_private, addr, len);
 xdrs->x_private += len;
 return ((1));
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 3
7 5
8 5
9 5
10 6
11 8
12 8
13 8
14 8
15 8
16 8
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
posix_refcnt (RC_REGEX *regex)
{
  return regex->v.re.re_nsub;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rsi,%rcx
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x1,%edx
mov    $0x1,%edi
callq  80 <report_file_err>
callq  12bd <fatal_target_file_error+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
fatal_target_file_error(int errno_value, const char *name)
{
  report_file_err (1, errno_value, 1, name);
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
cmpb   $0x0,0x50(%rdi)
je     58 <__rpeject+0x58>
test   %r12,%r12
jle    67 <__rpeject+0x67>
cmp    0x70(%rbp),%r12
mov    0x68(%rbp),%rbx
mov    $0x1,%eax
cmovg  %rax,%r12
cmp    %rbx,%r12
jle    78 <__rpeject+0x78>
nopl   0x0(%rax,%rax,1)
mov    0x48(%rbp),%rsi
mov    $0xa,%edi
add    $0x1,%rbx
callq  42 <__rpeject+0x42>
cmp    %rbx,%r12
jg     30 <__rpeject+0x30>
mov    %r12,0x68(%rbp)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  62 <__rpeject+0x62>
test   %r12,%r12
jg     15 <__rpeject+0x15>
mov    $0x0,%edi
callq  71 <__rpeject+0x71>
jmp    15 <__rpeject+0x15>
nopl   0x0(%rax,%rax,1)
mov    0x48(%rbp),%rsi
mov    $0xc,%edi
mov    $0x1,%ebx
callq  8b <__rpeject+0x8b>
addq   $0x1,0x80(%rbp)
cmp    $0x1,%r12
movq   $0x1,0x68(%rbp)
jg     30 <__rpeject+0x30>
jmp    47 <__rpeject+0x47>
<<<sep_in_sample>>>
__rpeject (__bs6FILE *p, long n)
{
  long i;
  if (!((__bs1FILE *) p)->open)
    __rerror ("Eject: File not open");
  if (n <= 0)
    __rerror ("Eject: Parameter out of range");
  if (n > p->lines_per_page)
    n = 1;
  if (n <= p->line)
    {
      (void) putc ('\f', ((__bs1FILE *) p)->file);
      p->line = 1;
      p->page += 1;
    }
  for (i = p->line; i < n; i++)
    (void) putc ('\n', ((__bs1FILE *) p)->file);
  p->line = n;
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 9
11 10
12 9
13 9
14 10
15 10
16 10
17 17
18 17
19 16
20 17
21 16
22 16
23 18
24 20
25 20
26 20
27 20
28 20
29 20
30 5
31 5
32 6
33 6
34 7
35 7
36 7
37 7
38 12
39 12
40 16
41 12
42 14
43 16
44 13
45 16
46 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     24a <ppd_flush_buffer+0x4a>
mov    0x8(%rdi),%rax
movl   $0x0,0x1c(%rdi)
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
movl   $0x1,0x28(%rdi)
movl   $0x0,0x38(%rdi)
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 238 <ppd_flush_buffer+0x38>
test   %rax,%rax
je     24a <ppd_flush_buffer+0x4a>
mov    0x0(%rip),%rdx        # 244 <ppd_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
je     250 <ppd_flush_buffer+0x50>
repz retq 
nopl   0x0(%rax)
jmpq   0 <ppd_load_buffer_state>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppd_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  ppd_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 6
6 7
7 7
8 8
9 9
10 10
11 8
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1207 <name_term+0x7>
jmpq   120c <name_term+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
name_term (void)
{
  free (name_buffer);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 2297 <skip_file+0x7>
push   %rbx
mov    %rdi,%rbx
je     22b9 <skip_file+0x29>
jmp    22c8 <skip_file+0x38>
nop
callq  22a5 <skip_file+0x15>
test   %rax,%rax
je     22ec <skip_file+0x5c>
mov    %rax,%rdi
sub    $0x200,%rbx
callq  22b9 <skip_file+0x29>
mov    %rbx,%rdi
callq  22c1 <skip_file+0x31>
test   %rbx,%rbx
jg     22a0 <skip_file+0x10>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  22d5 <skip_file+0x45>
test   %rax,%rax
js     22e3 <skip_file+0x53>
shl    $0x9,%rax
sub    %rax,%rbx
jmp    22b9 <skip_file+0x29>
movb   $0x0,0x0(%rip)        # 22ea <skip_file+0x5a>
jmp    22b9 <skip_file+0x29>
mov    0x0(%rip),%rax        # 22f3 <skip_file+0x63>
test   %rax,%rax
je     22fa <skip_file+0x6a>
callq  *%rax
mov    $0x0,%edi
callq  2304 <skip_file+0x74>
xor    %esi,%esi
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
callq  2312 <skip_file+0x82>
callq  2317 <skip_file+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skip_file (off_t size)
{
  union block *x;
  if (seekable_archive)
    {
      off_t nblk = seek_archive (size);
      if (nblk >= 0)
 size -= nblk * 512;
      else
 seekable_archive = 0;
    }
  mv_size_left (size);
  while (size > 0)
    {
      x = find_next_block ();
      if (! x)
 do { if (error_hook) error_hook (); error (0, 0, gettext ("Unexpected EOF in archive")); fatal_exit (); } while (0);
      set_next_block_after (x);
      size -= 512;
      mv_size_left (size);
    }
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 4
6 4
7 15
8 16
9 16
10 18
11 19
12 18
13 20
14 20
15 13
16 13
17 22
18 22
19 22
20 6
21 7
22 7
23 8
24 8
25 8
26 10
27 10
28 17
29 17
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_nextnonce (osip_authentication_info_t * authentication_info, char *nextnonce)
{
  authentication_info->nextnonce = (char *) nextnonce;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rsi
callq  492 <gsl_sf_lnbeta_e+0x12>
movsd  0x0(%rip),%xmm0        # 49a <gsl_sf_lnbeta_e+0x1a>
ucomisd 0x8(%rsp),%xmm0
jnp    4b0 <gsl_sf_lnbeta_e+0x30>
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
jne    4a2 <gsl_sf_lnbeta_e+0x22>
movsd  0x0(%rip),%xmm1        # 4ba <gsl_sf_lnbeta_e+0x3a>
mov    $0x1,%ecx
mov    $0x2c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
movsd  %xmm1,(%rbx)
movsd  %xmm1,0x8(%rbx)
callq  4dc <gsl_sf_lnbeta_e+0x5c>
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_lnbeta_e(const double x, const double y, gsl_sf_result * result)
{
  double sgn;
  int status = gsl_sf_lnbeta_sgn_e(x,y,result,&sgn);
  if (sgn == -1) {
    do { (result)->val = (__builtin_nanf ("")); (result)->err = (__builtin_nanf ("")); do { gsl_error ("domain error", "beta.c", 44, GSL_EDOM) ; return GSL_EDOM ; } while (0); } while(0);
  }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 5
9 9
10 9
11 9
12 9
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 9
23 6
24 9
25 9
26 9
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
lea    0x58(%rdi),%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rbp,%rdi
callq  16 <__rooutchar+0x16>
test   %al,%al
jne    35 <__rooutchar+0x35>
mov    (%rbx),%rax
mov    %rbx,%rdi
cmp    $0x0,%rax
je     60 <__rooutchar+0x60>
cmp    $0x0,%rax
je     50 <__rooutchar+0x50>
callq  35 <__rooutchar+0x35>
movsbl %r12b,%esi
mov    %rbp,%rdi
callq  41 <__rooutchar+0x41>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
callq  55 <__rooutchar+0x55>
jmp    35 <__rooutchar+0x35>
nopw   0x0(%rax,%rax,1)
callq  65 <__rooutchar+0x65>
jmp    35 <__rooutchar+0x35>
<<<sep_in_sample>>>
__rooutchar (__bs2FILE *p, char c)
{
  if (!__rtmore (&(p->IMAGE)))
    {
      if (((__bs1FILE *) p)->h.pp == &__p6FILE)
 __rpoutimage (((__bs6FILE *) p));
      else if (((__bs1FILE *) p)->h.pp == &__p5FILE)
 __rdoutimage ((__bs5FILE *) p);
      else
 __rooutimage (p);
    }
  __rtputchar (&(p->IMAGE), c);
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 6
13 5
14 5
15 7
16 7
17 10
18 12
19 12
20 12
21 14
22 14
23 14
24 14
25 14
26 14
27 8
28 8
29 8
30 6
31 6
<<<sep_out_sample>>>
push   %r14
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    1a3f <gsl_matrix_short_equal+0x1f>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     1a68 <gsl_matrix_short_equal+0x48>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a58 <gsl_matrix_short_equal+0x38>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r14
retq   
nopl   (%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     1ac4 <gsl_matrix_short_equal+0xa4>
lea    (%r8,%r8,1),%r12
lea    (%rax,%rax,1),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     1ab5 <gsl_matrix_short_equal+0x95>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movzwl (%r8,%rax,2),%r14d
cmp    %r14w,(%r9,%rax,2)
jne    1acb <gsl_matrix_short_equal+0xab>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1aa0 <gsl_matrix_short_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    1a85 <gsl_matrix_short_equal+0x65>
mov    $0x1,%eax
jmp    1a5a <gsl_matrix_short_equal+0x3a>
xor    %eax,%eax
jmp    1a5a <gsl_matrix_short_equal+0x3a>
nop
<<<sep_in_sample>>>
gsl_matrix_short_equal (const gsl_matrix_short * a, const gsl_matrix_short * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 30
20 30
21 30
22 30
23 30
24 30
25 30
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 20
44 20
45 20
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 29
55 29
56 23
57 23
58 23
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2a0 <skrivprefikspp+0x40>
cmpq   $0x0,0x8(%rdi)
jle    28a <skrivprefikspp+0x2a>
mov    0x38(%rdi),%rdi
callq  260 <skrivprefikspp>
mov    0x0(%rip),%rsi        # 280 <skrivprefikspp+0x20>
mov    $0x2c,%edi
callq  28a <skrivprefikspp+0x2a>
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 294 <skrivprefikspp+0x34>
xor    %eax,%eax
pop    %rbx
jmpq   29c <skrivprefikspp+0x3c>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
skrivprefikspp (decl_t *rd)
{
  if (rd != ((void *)0))
    {
      if (rd->plev > 0)
 {
   skrivprefikspp (rd->prefqual);
   fprintf (ccode, ",");
 }
    gen_adr_prot (ccode, rd);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 7
8 7
9 8
10 8
11 8
12 10
13 10
14 10
15 12
16 10
17 10
18 12
19 12
20 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3b58 <gsl_matrix_short_free+0x38>
mov    0x28(%rdi),%eax
test   %eax,%eax
jne    3b40 <gsl_matrix_short_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   3b39 <gsl_matrix_short_free+0x19>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdi
callq  3b49 <gsl_matrix_short_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   3b52 <gsl_matrix_short_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_free (gsl_matrix_short * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_short_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 2538 <rewind_read_files+0x8>
test   %rbx,%rbx
je     2557 <rewind_read_files+0x27>
nopl   (%rax)
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     254e <rewind_read_files+0x1e>
callq  254e <rewind_read_files+0x1e>
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    2540 <rewind_read_files+0x10>
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rewind_read_files()
{
  struct output *p;
  for (p=file_read; p; p=p->link)
    if (p->fp)
      rewind(p->fp);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 4
11 4
12 4
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x41,%esi
mov    %rdi,%rbx
sub    $0x50,%rsp
mov    %rsp,%rdi
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
callq  705 <mu_get_host_name+0x25>
mov    %rsp,%rdi
movb   $0x0,0x40(%rsp)
callq  712 <mu_get_host_name+0x32>
test   %rax,%rax
je     750 <mu_get_host_name+0x70>
mov    (%rax),%rdi
callq  71f <mu_get_host_name+0x3f>
test   %rax,%rax
mov    $0xc,%edx
je     72e <mu_get_host_name+0x4e>
mov    %rax,(%rbx)
xor    %dl,%dl
mov    0x48(%rsp),%rcx
xor    %fs:0x28,%rcx
mov    %edx,%eax
jne    755 <mu_get_host_name+0x75>
add    $0x50,%rsp
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rsp,%rdi
jmp    71a <mu_get_host_name+0x3a>
callq  75a <mu_get_host_name+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_get_host_name (char **host)
{
  char hostname[64 + 1];
  struct hostent *hp = ((void *)0);
  char *domain = ((void *)0);
  gethostname (hostname, sizeof hostname);
  hostname[sizeof (hostname) - 1] = 0;
  if ((hp = gethostbyname (hostname)))
    domain = hp->h_name;
  else
    domain = hostname;
  domain = strdup (domain);
  if (!domain)
    return 12;
  *host = domain;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 6
6 2
7 2
8 2
9 6
10 8
11 7
12 8
13 8
14 8
15 9
16 12
17 13
18 14
19 13
20 15
21 16
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 11
31 11
32 17
33 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     224 <recentdate+0x44>
cmpb   $0x0,0x68(%rdi)
mov    %rsi,%rbp
jne    230 <recentdate+0x50>
mov    0x60(%rbx),%rdi
mov    %rbp,%rsi
callq  1e0 <recentdate>
mov    0x50(%rbx),%rbx
test   %rbx,%rbx
je     224 <recentdate+0x44>
nopl   0x0(%rax)
mov    (%rbx),%rdi
mov    %rbp,%rsi
callq  1e0 <recentdate>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    210 <recentdate+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rdi
callq  239 <recentdate+0x59>
test   %eax,%eax
js     1f7 <recentdate+0x17>
mov    0x8(%rbx),%rdi
lea    0x20(%rbp),%rsi
callq  24a <recentdate+0x6a>
test   %eax,%eax
jg     1f7 <recentdate+0x17>
mov    0x8(%rbx),%rsi
mov    $0x20,%edx
mov    %rbp,%rdi
callq  25f <recentdate+0x7f>
movb   $0x0,0x1f(%rbp)
jmp    1f7 <recentdate+0x17>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
recentdate (struct delta const *root, struct daterange *r)
{
  if (!root)
    return;
  if (root->selector)
    {
      if (!(0 > (cmpdate (root->date, r->beg)))
          && !(0 < (cmpdate (root->date, r->end))))
        {
          strncpy (r->beg, root->date, (16 + 16));
          r->beg[(16 + 16) - 1] = '\0';
        }
    }
  recentdate (root->ilk, r);
  for (struct wlink *ls = root->branches; ls; ls = ls->next)
    recentdate (ls->entry, r);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 14
11 14
12 14
13 15
14 15
15 15
16 15
17 16
18 16
19 16
20 15
21 15
22 15
23 17
24 17
25 17
26 17
27 17
28 7
29 7
30 7
31 7
32 8
33 8
34 8
35 8
36 8
37 10
38 10
39 10
40 10
41 11
42 11
43 11
<<<sep_out_sample>>>
cmpq   $0x1,0xc8(%rdi)
jbe    6a60 <info_history_node+0x10>
jmpq   6a5f <info_history_node+0xf>
nop
sub    $0x8,%rsp
mov    $0x0,%edi
callq  6a6e <info_history_node+0x1e>
add    $0x8,%rsp
mov    %rax,%rdi
xor    %eax,%eax
jmpq   6a7c <info_history_node+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
info_history_node (WINDOW *window, int count)
{
  if (window->hist_index > 1)
    forget_node (window);
  else
    info_error (gettext ("No earlier node in history"));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 2
6 6
7 6
8 7
9 6
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     240 <string_list_dup+0x30>
callq  223 <string_list_dup+0x13>
mov    $0x0,%esi
mov    %rax,%rbp
mov    %rax,%rdx
mov    %rbx,%rdi
callq  236 <string_list_dup+0x26>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    239 <string_list_dup+0x29>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_list_dup (ANUBIS_LIST orig)
{
  if (orig)
    {
      ANUBIS_LIST ptr = list_create ();
      list_iterate (orig, _string_dup, ptr);
      return ptr;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 6
9 5
10 6
11 6
12 6
13 7
14 10
15 10
16 10
17 10
18 9
19 9
20 9
<<<sep_out_sample>>>
xor    %ecx,%ecx
jmpq   730 <_osip_message_parse>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_parse (osip_message_t * sip, const char *buf, size_t length)
{
  return _osip_message_parse (sip, buf, length, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x78(%rsi),%rdx
mov    %rdi,%rax
mov    %rdx,(%rdi)
mov    0x80(%rsi),%rdx
mov    %rdx,0x8(%rdi)
mov    0x88(%rsi),%rdx
mov    %rdx,0x10(%rdi)
mov    0x90(%rsi),%rdx
mov    %rdx,0x18(%rdi)
mov    0x98(%rsi),%rdx
mov    %rdx,0x20(%rdi)
mov    0xa0(%rsi),%rdx
mov    %rdx,0x28(%rdi)
mov    0xa8(%rsi),%rdx
mov    %rdx,0x30(%rdi)
mov    0xb0(%rsi),%rdx
mov    %rdx,0x38(%rdi)
mov    0xb8(%rsi),%rdx
mov    %rdx,0x40(%rdi)
mov    0xc0(%rsi),%rdx
mov    %rdx,0x48(%rdi)
mov    0xc8(%rsi),%rdx
mov    %rdx,0x50(%rdi)
mov    0xd0(%rsi),%rdx
mov    %rdx,0x58(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_robust_statistics(const gsl_multifit_robust_workspace *w)
{
  return w->stats;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 4
27 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm0        # 2080 <gsl_complex_arctanh_real+0x10>
ucomisd 0x0(%rip),%xmm1        # 2088 <gsl_complex_arctanh_real+0x18>
jbe    2090 <gsl_complex_arctanh_real+0x20>
ucomisd %xmm1,%xmm0
ja     20d0 <gsl_complex_arctanh_real+0x60>
divsd  %xmm1,%xmm0
movsd  %xmm1,0x8(%rsp)
callq  209f <gsl_complex_arctanh_real+0x2f>
movsd  0x8(%rsp),%xmm1
movsd  0x0(%rip),%xmm2        # 20ad <gsl_complex_arctanh_real+0x3d>
cmpltsd 0x0(%rip),%xmm1        # 20b6 <gsl_complex_arctanh_real+0x46>
movsd  0x0(%rip),%xmm3        # 20be <gsl_complex_arctanh_real+0x4e>
andpd  %xmm1,%xmm2
andnpd %xmm3,%xmm1
orpd   %xmm2,%xmm1
add    $0x18,%rsp
retq   
nop
movapd %xmm1,%xmm0
callq  20d9 <gsl_complex_arctanh_real+0x69>
xorpd  %xmm1,%xmm1
jmp    20ca <gsl_complex_arctanh_real+0x5a>
nop
<<<sep_in_sample>>>
gsl_complex_arctanh_real (double a)
{
  gsl_complex z;
  if (a > -1.0 && a < 1.0)
    {
      do {(&z)->dat[0]=(atanh (a)); (&z)->dat[1]=(0);} while(0);
    }
  else
    {
      do {(&z)->dat[0]=(atanh (1 / a)); (&z)->dat[1]=((a < 0) ? 1.57079632679489661923 : -1.57079632679489661923);} while(0);
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 13
19 13
20 13
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     d0 <gsl_rng_memcpy+0x30>
mov    $0x4,%ecx
mov    $0x3d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c5 <gsl_rng_memcpy+0x25>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rsi
mov    0x18(%rax),%rdx
callq  e1 <gsl_rng_memcpy+0x41>
xor    %eax,%eax
jmp    ca <gsl_rng_memcpy+0x2a>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_memcpy (gsl_rng * dest, const gsl_rng * src)
{
  if (dest->type != src->type)
    {
      do { gsl_error ("generators must be of the same type", "rng.c", 61, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  memcpy (dest->state, src->state, src->type->size);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 8
20 8
<<<sep_out_sample>>>
test   %edi,%edi
jne    b30 <_rl_control_keypad+0x20>
mov    0x0(%rip),%rdi        # b1b <_rl_control_keypad+0xb>
test   %rdi,%rdi
je     b3c <_rl_control_keypad+0x2c>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   b2f <_rl_control_keypad+0x1f>
nop
mov    0x0(%rip),%rdi        # b37 <_rl_control_keypad+0x27>
test   %rdi,%rdi
jne    b20 <_rl_control_keypad+0x10>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
_rl_control_keypad (on)
     int on;
{
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 7
7 7
8 7
9 7
10 4
11 4
12 4
13 4
14 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8cf <osip_transaction_set_naptr_record+0xf>
mov    %rsi,0x2c38(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_naptr_record (osip_transaction_t * transaction, osip_naptr_t * record)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->naptr_record = record;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
lea    0xc(%rsp),%rdi
mov    %esi,0xc(%rsp)
mov    $0x1,%esi
callq  0 <unget_input.part.1>
mov    0x0(%rip),%rbx        # 1b95 <parse_escape_sequence+0x25>
xor    %edi,%edi
mov    %rbx,%rsi
callq  1b9f <parse_escape_sequence+0x2f>
mov    %rbx,%rsi
mov    %rax,%rbp
mov    %rax,%rdi
callq  1bad <parse_escape_sequence+0x3d>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  1bb7 <parse_escape_sequence+0x47>
cmp    $0xffffffff,%ebx
je     1bd0 <parse_escape_sequence+0x60>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
cmp    0x0(%rip),%r12        # 1bd7 <parse_escape_sequence+0x67>
jne    1bbc <parse_escape_sequence+0x4c>
mov    $0x0,%edi
callq  1be3 <parse_escape_sequence+0x73>
mov    $0x2,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  1bf2 <parse_escape_sequence+0x82>
cmpl   $0x1,0x0(%rip)        # 1bf9 <parse_escape_sequence+0x89>
movb   $0x0,0x0(%rip)        # 1c00 <parse_escape_sequence+0x90>
movl   $0x0,0x0(%rip)        # 1c0a <parse_escape_sequence+0x9a>
jne    1bbc <parse_escape_sequence+0x4c>
callq  1c11 <parse_escape_sequence+0xa1>
mov    $0x1,%edi
callq  1c1b <parse_escape_sequence+0xab>
jmp    1bbc <parse_escape_sequence+0x4c>
nopl   (%rax)
<<<sep_in_sample>>>
parse_escape_sequence(WINDOW *win, int kbinput)
{
    int retval, *seq;
    size_t seq_len;
    unget_input(&kbinput, 1);
    seq_len = key_buffer_len;
    seq = get_input(((void *)0), seq_len);
    retval = convert_sequence(seq, seq_len);
    free(seq);
    if (retval == (-1)) {
 if (win == edit) {
     statusline(ALERT, gettext("Unknown sequence"));
     suppress_cursorpos = 0;
     lastmessage = HUSH;
     if (currmenu == (1<<0)) {
  reset_cursor();
  curs_set(1);
     }
 }
    }
    return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 7
12 7
13 7
14 8
15 7
16 8
17 8
18 9
19 8
20 9
21 10
22 10
23 22
24 22
25 22
26 22
27 22
28 22
29 22
30 11
31 11
32 12
33 12
34 12
35 12
36 12
37 12
38 15
39 13
40 14
41 15
42 16
43 17
44 17
45 17
46 17
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rsi
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     31d0 <gsl_matrix_int_set_identity+0x50>
shl    $0x2,%rdi
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
test   %r8,%r8
je     31c4 <gsl_matrix_int_set_identity+0x44>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
xor    %edx,%edx
cmp    %rax,%rcx
sete   %dl
mov    %edx,(%rsi,%rax,4)
add    $0x1,%rax
cmp    %r8,%rax
jne    31b0 <gsl_matrix_int_set_identity+0x30>
add    $0x1,%rcx
add    %rdi,%rsi
cmp    %r9,%rcx
jne    31a0 <gsl_matrix_int_set_identity+0x20>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_set_identity (gsl_matrix_int * m)
{
  size_t i, j;
  int * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const int zero = 0;
  const int one = 1;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(int *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 12
11 12
12 12
13 12
14 14
15 14
16 14
17 14
18 12
19 12
20 12
21 10
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
mov    $0xffffffff,%ecx
jmpq   37ba <gsl_fft_complex_radix2_forward+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_radix2_forward (gsl_complex_packed_array data,
                                          const size_t stride, const size_t n)
{
  gsl_fft_direction sign = gsl_fft_forward;
  int status = gsl_fft_complex_radix2_transform (data, stride, n, sign);
  return status;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
mov    $0x40800000,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d464 <_x87_beqi_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r14d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  ccd0 <_x87_movi_f>
mov    0x0(%rbp),%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
and    $0x7fff,%ecx
callq  150 <_x87_beqr_d>
mov    %r14d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  d4b2 <_x87_beqi_f+0x72>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_x87_beqi_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87_beqr_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_set_application_context (osip_t * osip, void *pointer)
{
  osip->application_context = pointer;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdx,%r13
push   %r12
push   %rbp
push   %rbx
cmpb   $0x0,0x5e1(%rdi)
mov    %rdi,%rbx
jne    c70 <copytoks+0x60>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    0x0(,%rsi,8),%r12
je     c65 <copytoks+0x55>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x5b0(%rbx),%rax
mov    $0x3,%edx
mov    %rbx,%rdi
add    $0x1,%rbp
mov    (%rax,%r12,1),%rsi
add    $0x8,%r12
callq  a60 <addtok_mb>
cmp    %r13,%rbp
jne    c40 <copytoks+0x30>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
test   %rdx,%rdx
je     c65 <copytoks+0x55>
lea    0x0(,%rsi,4),%r14
lea    0x0(,%rsi,8),%r12
xor    %ebp,%ebp
nopw   0x0(%rax,%rax,1)
mov    0x620(%rbx),%rax
mov    %rbx,%rdi
add    $0x1,%rbp
mov    (%rax,%r14,1),%edx
mov    0x5b0(%rbx),%rax
add    $0x4,%r14
mov    (%rax,%r12,1),%rsi
add    $0x8,%r12
callq  a60 <addtok_mb>
cmp    %r13,%rbp
jne    c90 <copytoks+0x80>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
copytoks (struct dfa *dfa, size_t tindex, size_t ntokens)
{
  size_t i;
  if (dfa->multibyte)
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa, dfa->tokens[tindex + i], dfa->multibyte_prop[tindex + i]);
  else
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa, dfa->tokens[tindex + i], 3);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 2
9 4
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 8
19 9
20 9
21 9
22 8
23 8
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 5
32 5
33 5
34 5
35 5
36 5
37 6
38 6
39 5
40 6
41 6
42 6
43 6
44 6
45 6
46 5
47 5
48 10
49 10
50 10
51 10
52 10
53 10
54 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x10,%rsp
callq  640 <send_string_list+0x10>
mov    %rax,%rdi
mov    %rax,0x8(%rsp)
callq  64d <send_string_list+0x1d>
test   %rax,%rax
je     672 <send_string_list+0x42>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rsi
mov    %rbx,%rdi
callq  120 <write_header_line>
mov    0x8(%rsp),%rdi
callq  66d <send_string_list+0x3d>
test   %rax,%rax
jne    658 <send_string_list+0x28>
lea    0x8(%rsp),%rdi
callq  67c <send_string_list+0x4c>
add    $0x10,%rsp
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
send_string_list (NET_STREAM sd_server, ANUBIS_LIST list)
{
  char *p;
  ITERATOR itr = iterator_create (list);
  for (p = iterator_first (itr); p; p = iterator_next (itr))
    write_header_line (sd_server, p);
  iterator_destroy (&itr);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 5
7 4
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 5
16 5
17 5
18 5
19 7
20 7
21 8
22 8
23 8
24 8
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     88 <VPrintPolygon+0x88>
movswl 0x2(%rsi),%edx
test   %dx,%dx
je     88 <VPrintPolygon+0x88>
xor    %eax,%eax
mov    $0x0,%esi
xor    %ebp,%ebp
callq  2c <VPrintPolygon+0x2c>
xor    %ebx,%ebx
cmpw   $0x0,0x2(%r12)
jle    79 <VPrintPolygon+0x79>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rax
add    0x20(%r12),%rax
mov    $0x0,%esi
mov    %r13,%rdi
add    $0x1,%ebx
add    $0x18,%rbp
movsd  0x10(%rax),%xmm2
movsd  0x8(%rax),%xmm1
movsd  (%rax),%xmm0
mov    $0x3,%eax
callq  6f <VPrintPolygon+0x6f>
movswl 0x2(%r12),%eax
cmp    %ebx,%eax
jg     40 <VPrintPolygon+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %r13,%rcx
mov    $0x15,%edx
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   a9 <VPrintPolygon+0xa9>
<<<sep_in_sample>>>
VPrintPolygon(FILE * file, VPolygon * p)
{
 int i;
 char *nullPoly = "*** Null Polygon ***\n";
 if (p == (VPolygon *) ((void *)0))
  fprintf(file, nullPoly);
 else {
  if (p->numVtces == 0) {
   fprintf(file, nullPoly);
   return;
  }
  fprintf(file, "%d vertices:\n", p->numVtces);
  for (i = 0; i < p->numVtces; ++i)
   fprintf(file, "%9.6g %9.6g %9.6g\n", p->vertex[i].x,
     p->vertex[i].y, p->vertex[i].z);
 }
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 8
11 8
12 8
13 12
14 12
15 13
16 12
17 13
18 13
19 13
20 13
21 15
22 15
23 14
24 14
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 13
33 13
34 13
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 6
44 6
45 18
46 18
47 18
48 18
49 6
50 6
51 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
cmp    %esi,%eax
jb     70 <xdrumem_inline+0x20>
sub    %esi,%eax
movslq %esi,%rsi
mov    %eax,0x28(%rdi)
mov    0x18(%rdi),%rax
add    %rax,%rsi
mov    %rsi,0x18(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdrumem_inline(register XDR * xdrs, int len)
{
 long *buf = 0;
 if (xdrs->x_handy >= len) {
  xdrs->x_handy -= len;
  buf = (long *) xdrs->x_private;
  xdrs->x_private += len;
 }
 return (buf);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 7
6 5
7 6
8 7
9 7
10 7
11 7
12 3
13 10
14 10
<<<sep_out_sample>>>
jmp    1d <__gmpn_neg+0x1d>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rdx
movq   $0x0,(%rdi)
je     40 <__gmpn_neg+0x40>
add    $0x8,%rsi
add    $0x8,%rdi
mov    (%rsi),%rax
test   %rax,%rax
je     8 <__gmpn_neg+0x8>
neg    %rax
sub    $0x1,%rdx
mov    %rax,(%rdi)
mov    $0x1,%eax
jne    48 <__gmpn_neg+0x48>
repz retq 
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
add    $0x8,%rsi
add    $0x8,%rdi
mov    %rax,0x8(%rsp)
callq  5e <__gmpn_neg+0x5e>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmpn_neg (mp_ptr __gmp_rp, mp_srcptr __gmp_up, mp_size_t __gmp_n)
{
  while (*__gmp_up == 0)
    {
      *__gmp_rp = 0;
      if (!--__gmp_n)
 return 0;
      ++__gmp_up; ++__gmp_rp;
    }
  *__gmp_rp = (- *__gmp_up) & ((~ ((mp_limb_t) (0))) >> 0);
  if (--__gmp_n)
    __gmpn_com (++__gmp_rp, ++__gmp_up, __gmp_n);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 5
5 6
6 8
7 8
8 3
9 3
10 3
11 10
12 11
13 10
14 13
15 11
16 14
17 14
18 7
19 14
20 14
21 2
22 12
23 12
24 12
25 12
26 12
27 14
28 14
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     6ea <mu_url_sget_fvpairs+0x1a>
movslq 0x48(%rdi),%rax
mov    %rax,(%rsi)
mov    0x40(%rdi),%rax
mov    %rax,(%rdx)
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_url_sget_fvpairs (const mu_url_t url, size_t *fvc, char ***fvp)
{
  if (url == ((void *)0))
    return 22;
  *fvc = url->fvcount;
  *fvp = url->fvpairs;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 6
7 6
8 7
9 8
10 8
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  1512 <gsl_stats_long_variance+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1524 <gsl_stats_long_variance+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_variance (const long data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_mean (data, stride, n);
  return gsl_stats_long_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1bb <endBlackBoxRecording+0xb>
callq  1c0 <endBlackBoxRecording+0x10>
movq   $0x0,0x0(%rip)        # 1cb <endBlackBoxRecording+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
endBlackBoxRecording(void)
{
 fclose(bbout);
 bbout = (FILE *) ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
movzbl (%rdi),%eax
cmp    $0xa,%al
je     58 <sortparse+0x58>
test   %al,%al
je     58 <sortparse+0x58>
lea    0x1(%rdi),%rax
mov    $0x1,%r8d
xor    %ecx,%ecx
xor    %r9d,%r9d
movslq %esi,%rsi
jmp    24 <sortparse+0x24>
nop
test   %dl,%dl
je     58 <sortparse+0x58>
test   %r8d,%r8d
je     3c <sortparse+0x3c>
mov    0x0(,%rsi,8),%rdx
movslq %r9d,%r8
add    $0x1,%r9d
mov    %ecx,(%rdx,%r8,4)
xor    %r8d,%r8d
movzbl (%rax),%edx
cmpb   $0x7c,(%rdi)
mov    %rax,%rdi
sete   %r8b
add    $0x1,%ecx
add    $0x1,%rax
cmp    $0xa,%dl
jne    20 <sortparse+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sortparse(char line[], int which)
{
  int v;
  int l;
  int newfield;
  for (v = 0, l = 0, newfield = 1; line[l] && line[l] != '\n'; l++)
    {
      if (newfield)
 start[which][v++] = l;
      newfield = (line[l] == '|');
    }
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 9
11 9
12 9
13 6
14 6
15 8
16 8
17 9
18 9
19 9
20 9
21 10
22 6
23 10
24 6
25 10
26 6
27 6
28 6
29 6
30 6
31 6
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %edi,%ebp
mov    $0x48,%edi
push   %rbx
sub    $0x8,%rsp
callq  1c <file_reader_init+0x1c>
test   $0x1,%al
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x48,%r9d
jne    a0 <file_reader_init+0xa0>
test   $0x2,%dil
jne    b0 <file_reader_init+0xb0>
test   $0x4,%dil
jne    d0 <file_reader_init+0xd0>
mov    %r9d,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%r9b
rep stos %rax,%es:(%rdi)
je     57 <file_reader_init+0x57>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r9b
je     67 <file_reader_init+0x67>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%r9d
je     70 <file_reader_init+0x70>
movb   $0x0,(%rdi)
mov    %ebp,0x34(%rbx)
mov    %r13d,0x30(%rbx)
imul   %r13d,%ebp
movslq %ebp,%rdi
callq  83 <file_reader_init+0x83>
mov    %r12d,0x38(%rbx)
mov    %rax,0x28(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
mov    $0x47,%r9b
test   $0x2,%dil
je     32 <file_reader_init+0x32>
xor    %edx,%edx
add    $0x2,%rdi
sub    $0x2,%r9d
mov    %dx,-0x2(%rdi)
test   $0x4,%dil
je     3c <file_reader_init+0x3c>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%r9d
add    $0x4,%rdi
jmpq   3c <file_reader_init+0x3c>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_reader_init (int record_size, int buffered_records, int backwards)
{
  struct file_rd_info *new;
  new = (struct file_rd_info *) xmalloc (sizeof (struct file_rd_info));
  memset (new, 0, sizeof (struct file_rd_info));
  new->record_size = record_size;
  new->buffered_records = buffered_records;
  new->buffer = (char *) xmalloc (record_size * buffered_records);
  new->backwards = backwards;
  return new;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 2
9 2
10 4
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 6
37 7
38 8
39 8
40 8
41 9
42 8
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 5
52 5
53 5
54 5
55 5
56 5
57 5
58 5
59 5
60 5
61 5
62 5
63 5
64 5
65 5
66 5
67 5
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
movzbl %sil,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %ebp,%edx
mov    %ebx,%esi
mov    %r12,%rdi
callq  24 <print_cdtext_track_info+0x24>
test   %rax,%rax
je     51 <print_cdtext_track_info+0x51>
mov    %ebp,%edx
mov    %ebx,%esi
mov    %r12,%rdi
callq  35 <print_cdtext_track_info+0x35>
mov    %ebx,%edi
mov    %rax,%r13
callq  3f <print_cdtext_track_info+0x3f>
mov    %r13,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  51 <print_cdtext_track_info+0x51>
add    $0x1,%ebx
cmp    $0xa,%ebx
jne    18 <print_cdtext_track_info+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_cdtext_track_info(cdtext_t *cdtext, track_t i_track) {
    cdtext_field_t i;
    for (i=0; i < 10; i++) {
        if (cdtext_get_const(cdtext, i, i_track)) {
            printf("-- \t%s: %s\n", cdtext_field2str(i),
                   cdtext_get_const(cdtext, i, i_track));
        }
    }
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 3
8 1
9 1
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 3
29 3
30 3
31 9
32 9
33 9
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
push   %r14
lea    0x8(%rdi),%r14
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
xor    %ebx,%ebx
jmp    b9a <rec_write_db+0x5a>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  b6b <rec_write_db+0x2b>
test   %ebx,%ebx
mov    %rax,%r12
je     b87 <rec_write_db+0x47>
mov    0x0(%r13),%rdi
mov    $0xa,%edx
mov    %r14,%rsi
callq  0 <rec_writer_putc.isra.0>
test   %al,%al
je     bb8 <rec_write_db+0x78>
mov    %r12,%rsi
mov    %r13,%rdi
add    $0x1,%rbx
callq  b96 <rec_write_db+0x56>
test   %al,%al
je     bb8 <rec_write_db+0x78>
mov    %rbp,%rdi
callq  ba2 <rec_write_db+0x62>
cmp    %rax,%rbx
jb     b60 <rec_write_db+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%eax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_write_db (rec_writer_t writer,
              rec_db_t db)
{
  _Bool ret;
  int i;
  ret = 1;
  for (i = 0; i < rec_db_size (db); i++)
    {
      rec_rset_t rset = rec_db_get_rset (db, i);
      if (i != 0)
        {
          if (!rec_writer_putc (writer, '\n'))
            {
              ret = 0;
              break;
            }
        }
      if (!rec_write_rset (writer, rset))
        {
          ret = 0;
          break;
        }
    }
  return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 9
17 10
18 12
19 12
20 12
21 12
22 12
23 12
24 18
25 18
26 18
27 18
28 18
29 18
30 7
31 7
32 7
33 7
34 25
35 25
36 25
37 25
38 6
39 25
40 25
41 25
42 25
43 25
44 25
45 25
46 14
47 25
48 25
49 25
<<<sep_out_sample>>>
cmpb   $0x2e,(%rdi)
mov    %rdi,%rax
je     1d0 <trimpath+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
cmpb   $0x2f,0x1(%rdi)
lea    0x2(%rdi),%rdx
cmove  %rdx,%rax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
trimpath(const char *path)
{
 if (*path == '.' && *(path + 1) == '/')
  path += 2;
 return path;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 4
7 4
8 4
9 6
10 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  dcf <pred_regex+0xf>
mov    0x38(%r12),%rdi
mov    %rax,%rbx
xor    %r8d,%r8d
xor    %ecx,%ecx
mov    %rbp,%rsi
mov    %eax,%edx
callq  de6 <pred_regex+0x26>
cmp    %eax,%ebx
pop    %rbx
pop    %rbp
sete   %al
pop    %r12
retq   
<<<sep_in_sample>>>
pred_regex (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  int len = strlen (pathname);
(void) stat_buf;
  if (re_match (pred_ptr->args.regex, pathname, len, 0,
  (struct re_registers *) ((void *)0)) == len)
    return (1);
  return (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 5
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 9
16 9
17 5
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  21be <initialize_hostname_list+0xe>
test   %rax,%rax
je     21e8 <initialize_hostname_list+0x38>
mov    %rax,%rdi
callq  1ea0 <snarf_hosts_from_file>
cmpq   $0x0,0x0(%rip)        # 21d3 <initialize_hostname_list+0x23>
je     21dc <initialize_hostname_list+0x2c>
addl   $0x1,0x0(%rip)        # 21dc <initialize_hostname_list+0x2c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  21f2 <initialize_hostname_list+0x42>
mov    $0x0,%edx
test   %rax,%rax
cmove  %rdx,%rax
jmp    21c3 <initialize_hostname_list+0x13>
<<<sep_in_sample>>>
initialize_hostname_list ()
{
  char *temp;
  temp = get_string_value ("HOSTFILE");
  if (temp == 0)
    temp = get_string_value ("hostname_completion_file");
  if (temp == 0)
    temp = "/etc/hosts";
  snarf_hosts_from_file (temp);
  if (hostname_list)
    hostname_list_initialized++;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 9
7 9
8 10
9 10
10 11
11 12
12 12
13 12
14 6
15 6
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  a89 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  a92 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  1b89 <java__scan_string+0x9>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   1b95 <java__scan_string+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java__scan_string (const char * yystr )
{
 return java__scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
lea    0x1(%rsi),%rsi
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  428 <null_at+0x18>
mov    %rax,0x0(%rbp)
movb   $0x0,(%rax,%rbx,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
null_at(char **data, size_t index)
{
    ((void) (0));
    *data = (char *)nrealloc(*data, (index + 1) * sizeof(char));
    (*data)[index] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 5
11 6
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <osip_content_length_init+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
test   %rax,%rax
je     30 <osip_content_length_init+0x30>
callq  *%rax
test   %rax,%rax
mov    %rax,(%rbx)
je     37 <osip_content_length_init+0x37>
movq   $0x0,(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
callq  35 <osip_content_length_init+0x35>
jmp    17 <osip_content_length_init+0x17>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
osip_content_length_init (osip_content_length_t ** cl)
{
  *cl = (osip_content_length_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_content_length_t)):malloc(sizeof (osip_content_length_t)));
  if (*cl == ((void *)0))
    return -4;
  (*cl)->value = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 3
10 4
11 6
12 7
13 8
14 8
15 8
16 3
17 3
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
push   %rbp
movapd %xmm0,%xmm2
push   %rbx
mov    %rdi,%rbx
sub    $0x38,%rsp
lea    0x10(%rsp),%rdi
movsd  %xmm2,0x8(%rsp)
callq  13ad <gamma_inc_a_gt_0+0x1d>
movsd  0x8(%rsp),%xmm2
lea    0x20(%rsp),%rdi
mov    %eax,%ebp
movapd %xmm2,%xmm0
callq  13c3 <gamma_inc_a_gt_0+0x33>
movsd  0x20(%rsp),%xmm0
test   %eax,%eax
movsd  0x10(%rsp),%xmm2
cmove  %ebp,%eax
movapd %xmm0,%xmm3
mulsd  0x18(%rsp),%xmm0
movsd  0x0(%rip),%xmm1        # 13e6 <gamma_inc_a_gt_0+0x56>
mulsd  %xmm2,%xmm3
mulsd  0x28(%rsp),%xmm2
andpd  %xmm1,%xmm0
movsd  %xmm3,(%rbx)
andpd  %xmm1,%xmm2
andpd  %xmm3,%xmm1
addsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm1        # 140c <gamma_inc_a_gt_0+0x7c>
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rbx)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gamma_inc_a_gt_0(double a, double x, gsl_sf_result * result)
{
  gsl_sf_result Q;
  gsl_sf_result G;
  const int stat_Q = gsl_sf_gamma_inc_Q_e(a, x, &Q);
  const int stat_G = gsl_sf_gamma_e(a, &G);
  result->val = G.val * Q.val;
  result->err = fabs(G.val * Q.err) + fabs(G.err * Q.val);
  result->err += 2.0*2.2204460492503131e-16 * fabs(result->val);
  return ((stat_G) != GSL_SUCCESS ? (stat_G) : ((stat_Q) != GSL_SUCCESS ? (stat_Q) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 6
11 5
12 6
13 6
14 7
15 10
16 7
17 10
18 7
19 8
20 8
21 7
22 8
23 8
24 7
25 8
26 9
27 8
28 9
29 9
30 9
31 11
32 11
33 11
34 11
35 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x18(%rsi),%rdi
movsd  (%rdx),%xmm1
movsd  %xmm1,0x8(%rsp)
movapd %xmm1,%xmm0
callq  *(%rsi)
movsd  0x8(%rsp),%xmm1
movsd  %xmm0,0x0(%rbp)
mov    0x18(%rbx),%rdi
movapd %xmm1,%xmm0
callq  *0x8(%rbx)
movsd  %xmm0,0x8(%rbp)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
newton_init (void * vstate, gsl_function_fdf * fdf, double * root)
{
  newton_state_t * state = (newton_state_t *) vstate;
  const double x = *root ;
  state->f = (*((fdf)->f))(x,(fdf)->params);
  state->df = (*((fdf)->df))(x,(fdf)->params) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 4
8 5
9 5
10 5
11 6
12 5
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 8
22 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
encoding_get_name (struct encoding * enc)
{
  return enc->name;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     f0 <rec_mset_elem_destroy+0x30>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     e5 <rec_mset_elem_destroy+0x25>
movslq (%rbx),%rdx
mov    0x18(%rbx),%rax
mov    0x28(%rax,%rdx,8),%rax
test   %rax,%rax
je     e5 <rec_mset_elem_destroy+0x25>
callq  *%rax
mov    %rbx,%rdi
pop    %rbx
jmpq   ee <rec_mset_elem_destroy+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_mset_elem_destroy (rec_mset_elem_t elem)
{
  if (elem)
    {
      if (elem->data && elem->mset->disp_fn[elem->type])
        {
          elem->mset->disp_fn[elem->type] (elem->data);
        }
      free (elem);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 9
15 11
16 9
17 9
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbp
xor    %r8d,%r8d
test   %rcx,%rcx
push   %rbx
mov    %rsi,%rbx
je     1dc4 <gsl_permute_char+0x74>
nopl   (%rax)
mov    (%rdi,%r8,8),%rax
cmp    %rax,%r8
jae    1d79 <gsl_permute_char+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%r8
jb     1d70 <gsl_permute_char+0x20>
cmp    %rax,%r8
ja     1db8 <gsl_permute_char+0x68>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
je     1db8 <gsl_permute_char+0x68>
movzbl (%rbx),%ebp
jmp    1d96 <gsl_permute_char+0x46>
nopl   0x0(%rax)
mov    %r9,%rax
mov    %r10,%r9
mov    %r9,%r11
imul   %rdx,%r11
imul   %rdx,%rax
add    %rsi,%r11
movzbl (%r11),%r10d
mov    %r10b,(%rsi,%rax,1)
mov    (%rdi,%r9,8),%r10
cmp    %r10,%r8
jne    1d90 <gsl_permute_char+0x40>
mov    %bpl,(%r11)
add    $0x1,%r8
add    %rdx,%rbx
cmp    %rcx,%r8
jne    1d60 <gsl_permute_char+0x10>
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_permute_char (const size_t * p, char * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        char t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                char r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 4
7 4
8 6
9 7
10 7
11 7
12 8
13 7
14 7
15 9
16 9
17 11
18 12
19 12
20 18
21 18
22 18
23 18
24 27
25 23
26 23
27 24
28 23
29 23
30 24
31 27
32 19
33 19
34 30
35 4
36 4
37 4
38 4
39 34
40 34
41 34
42 34
43 34
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     3f0 <gsl_blas_sswap+0x30>
mov    $0x13,%ecx
mov    $0x10f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3e5 <gsl_blas_sswap+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  40a <gsl_blas_sswap+0x4a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y)
{
  if (X->size == Y->size)
    {
      cblas_sswap (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                   ((int)(Y->stride)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 271, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 11
6 11
7 11
8 11
9 11
10 11
11 13
12 13
13 13
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 13
23 13
24 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2f0 <gsl_eigen_hermv_free+0x40>
mov    0x28(%rdi),%rdi
callq  2c2 <gsl_eigen_hermv_free+0x12>
mov    0x20(%rbx),%rdi
callq  2cb <gsl_eigen_hermv_free+0x1b>
mov    0x18(%rbx),%rdi
callq  2d4 <gsl_eigen_hermv_free+0x24>
mov    0x10(%rbx),%rdi
callq  2dd <gsl_eigen_hermv_free+0x2d>
mov    0x8(%rbx),%rdi
callq  2e6 <gsl_eigen_hermv_free+0x36>
mov    %rbx,%rdi
pop    %rbx
jmpq   2ef <gsl_eigen_hermv_free+0x3f>
nop
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_hermv_free (gsl_eigen_hermv_workspace * w)
{
  if (!w) { return ; };
  free (w->gs);
  free (w->gc);
  free (w->tau);
  free (w->sd);
  free (w->d);
  free (w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 10
17 9
18 9
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
lea    0x1c(%rsp),%rdi
fstpt  (%rsp)
callq  31 <printf_frexpl+0x31>
mov    0x1c(%rsp),%edx
fadd   %st(0),%st
lea    -0x1(%rdx),%eax
cmp    $0xffffc002,%eax
mov    %eax,0x1c(%rsp)
jge    58 <printf_frexpl+0x58>
fstpt  (%rsp)
lea    0x3ffd(%rdx),%edi
callq  53 <printf_frexpl+0x53>
mov    $0xffffc002,%eax
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 7
17 8
18 9
19 8
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 17
29 17
30 17
31 17
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
cmp    0x8(%rdi),%r11
je     25ea <gsl_matrix_ulong_transpose+0x2a>
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  25e3 <gsl_matrix_ulong_transpose+0x23>
mov    $0x14,%eax
pop    %rbx
retq   
test   %r11,%r11
je     264e <gsl_matrix_ulong_transpose+0x8e>
xor    %esi,%esi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
je     264e <gsl_matrix_ulong_transpose+0x8e>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rdi),%r8
mov    %rbx,%rax
nopw   0x0(%rax,%rax,1)
mov    0x10(%rdi),%rdx
mov    %rsi,%rcx
imul   %rdx,%rcx
imul   %rax,%rdx
add    %rax,%rcx
add    $0x1,%rax
add    %rsi,%rdx
lea    (%r8,%rcx,8),%rcx
cmp    %r11,%rax
lea    (%r8,%rdx,8),%rdx
mov    (%rcx),%r9
mov    (%rdx),%r10
mov    %r10,(%rcx)
mov    %r9,(%rdx)
jne    2610 <gsl_matrix_ulong_transpose+0x50>
mov    %rbx,%rsi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
jne    2600 <gsl_matrix_ulong_transpose+0x40>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_transpose (gsl_matrix_ulong * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned long tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 16
24 16
25 16
26 17
27 16
28 12
29 17
30 19
31 12
32 20
33 19
34 20
35 20
36 21
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
45 27
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  3df <_url_path_default+0xf>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  3ea <_url_path_default+0x1a>
lea    0x2(%rbx,%rax,1),%rdi
callq  3f4 <_url_path_default+0x24>
test   %rax,%rax
mov    %rax,%rbx
je     420 <_url_path_default+0x50>
mov    %rbp,%rcx
mov    %r12,%rdx
mov    %rax,%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  411 <_url_path_default+0x41>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
callq  425 <_url_path_default+0x55>
movl   $0xc,(%rax)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_url_path_default (const char *spooldir, const char *user, int unused)
{
  char *mbox = malloc (strlen (spooldir) + strlen (user) + 2);
  if (!mbox)
    (*__errno_location ()) = 12;
  else
    sprintf (mbox, "%s/%s", spooldir, user);
  return mbox;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 3
14 4
15 7
16 7
17 7
18 7
19 7
20 7
21 9
22 9
23 9
24 9
25 9
26 9
27 5
28 5
29 9
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
test   %edi,%edi
je     c20 <tty_cursor+0x10>
jmpq   250 <tty_cursor.part.1>
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # c27 <tty_cursor+0x17>
test   %rdi,%rdi
je     c40 <tty_cursor+0x30>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   c3b <tty_cursor+0x2b>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_cursor(status)
    int status;
{
    if (status)
    {
 if ((tty_capability[4].string))
     tputs((tty_capability[4].string), 1, tty_writec);
    }
    else
    {
 if ((tty_capability[3].string))
     tputs((tty_capability[3].string), 1, tty_writec);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 11
6 11
7 11
8 12
9 12
10 12
11 12
12 12
13 12
<<<sep_out_sample>>>
and    $0x7,%esi
movq   $0x0,(%rdi)
shl    $0x8,%rsi
mov    %rsi,0x8(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
slatec_set (void *vstate, unsigned long int s)
{
  slatec_state_t *state = (slatec_state_t *) vstate;
  s = s % 8;
  s *= P / 8;
  state->x0 = s % 2048;
  state->x1 = (s - state->x0) / 2048;
}
<<<sep_in_sample>>>
1 4
2 6
3 7
4 7
5 7
6 7
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x10,%rsp
callq  9e3 <s_int+0x13>
lea    0x8(%rsp),%rsi
xor    %edx,%edx
movl   $0x0,(%rax)
mov    %rbp,%rdi
mov    %rax,%rbx
callq  9fb <s_int+0x2b>
mov    0x8(%rsp),%rcx
mov    %rax,(%rsp)
mov    %rax,%rdx
mov    $0x1,%eax
cmpb   $0x0,(%rcx)
jne    a1e <s_int+0x4e>
cmpl   $0x22,(%rbx)
je     a1e <s_int+0x4e>
movslq %edx,%rcx
cmp    %rcx,%rdx
je     a30 <s_int+0x60>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x8,%edx
mov    %rsp,%rsi
mov    %r12,%rdi
callq  a40 <s_int+0x70>
xor    %eax,%eax
jmp    a1e <s_int+0x4e>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
s_int (struct xdatum *xd, char *str) { long n; int t; char *p; (*__errno_location ()) = 0; n = strtol (str, &p, 0); if (*p) return 1; if ((*__errno_location ()) == 34 || (t = n) != n) return 1; xd_store (xd, &n, sizeof (n)); return 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  363 <delete_lockfile+0x13>
test   %eax,%eax
js     370 <delete_lockfile+0x20>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
callq  375 <delete_lockfile+0x25>
mov    (%rax),%edi
cmp    $0x2,%edi
je     367 <delete_lockfile+0x17>
callq  381 <delete_lockfile+0x31>
mov    $0x0,%edi
mov    %rax,%rbp
callq  38e <delete_lockfile+0x3e>
mov    %rbp,%rcx
mov    %rax,%rsi
mov    %rbx,%rdx
mov    $0x1,%edi
xor    %eax,%eax
mov    $0xffffffff,%ebp
callq  3a8 <delete_lockfile+0x58>
jmp    367 <delete_lockfile+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delete_lockfile(const char *lockfilename)
{
    if (unlink(lockfilename) < 0 && (*__errno_location ()) != 2) {
 statusline(MILD, gettext("Error deleting lock file %s: %s"), lockfilename,
   strerror((*__errno_location ())));
 return -1;
    }
    return 1;
}
<<<sep_in_sample>>>
1 2
2 8
3 2
4 2
5 2
6 3
7 3
8 3
9 9
10 9
11 9
12 9
13 9
14 3
15 3
16 3
17 3
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 6
28 4
29 6
30 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
lea    0x1(%rsi),%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  15 <unescape+0x15>
test   %rax,%rax
je     c4 <unescape+0xc4>
test   %rbx,%rbx
je     bf <unescape+0xbf>
movzbl 0x0(%rbp),%ecx
test   %cl,%cl
je     bf <unescape+0xbf>
lea    0x1(%rax),%rdx
jmp    5f <unescape+0x5f>
nopl   0x0(%rax)
mov    %rdx,%rsi
mov    %cl,-0x1(%rdx)
add    $0x1,%rbp
sub    $0x1,%rbx
test   %rbx,%rbx
je     98 <unescape+0x98>
movzbl 0x0(%rbp),%ecx
add    $0x1,%rdx
test   %cl,%cl
je     98 <unescape+0x98>
cmp    $0x2,%rbx
jbe    40 <unescape+0x40>
cmp    $0x3d,%cl
jne    40 <unescape+0x40>
movzbl 0x1(%rbp),%esi
cmp    $0x32,%sil
je     a8 <unescape+0xa8>
cmp    $0x33,%sil
jne    40 <unescape+0x40>
cmpb   $0x44,0x2(%rbp)
jne    40 <unescape+0x40>
sub    $0x3,%rbx
add    $0x3,%rbp
mov    %rdx,%rsi
test   %rbx,%rbx
movb   $0x3d,-0x1(%rdx)
jne    53 <unescape+0x53>
nopl   0x0(%rax)
movb   $0x0,(%rsi)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmpb   $0x43,0x2(%rbp)
jne    40 <unescape+0x40>
mov    %rdx,%rsi
movb   $0x2c,-0x1(%rdx)
add    $0x3,%rbp
sub    $0x3,%rbx
jmp    4e <unescape+0x4e>
mov    %rax,%rsi
jmp    98 <unescape+0x98>
xor    %eax,%eax
jmp    9b <unescape+0x9b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unescape (const char *str, size_t len)
{
  char *out = malloc (len + 1);
  char *p = out;
  if (!out)
    return ((void *)0);
  while (len > 0 && *str)
    {
      if (len >= 3 && str[0] == '=' && str[1] == '2' && str[2] == 'C')
 {
   *p++ = ',';
   str += 3;
   len -= 3;
 }
      else if (len >= 3 && str[0] == '=' && str[1] == '3' && str[2] == 'D')
 {
   *p++ = '=';
   str += 3;
   len -= 3;
 }
      else
 {
   *p++ = *str;
   str++;
   len--;
 }
    }
  *p = '\0';
  return out;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 23
19 23
20 24
21 25
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 15
36 15
37 15
38 15
39 19
40 18
41 17
42 7
43 17
44 7
45 7
46 28
47 30
48 30
49 30
50 30
51 30
52 9
53 9
54 11
55 11
56 12
57 13
58 13
59 7
60 7
61 6
62 6
63 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     c20 <gcide_iterator_flags+0x10>
mov    0x68(%rdi),%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gcide_iterator_flags(gcide_iterator_t itr)
{
    if (!itr)
 return 0;
    return itr->flags;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    5d98 <gsl_matrix_ulong_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,8),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  5dba <gsl_matrix_ulong_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_const_column (const gsl_matrix_ulong * m, const size_t j)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x18,%rsp
test   %rdx,%rdx
je     34c8 <update_export_env_inplace+0x98>
xor    %eax,%eax
cmpb   $0x0,(%rdx)
je     3460 <update_export_env_inplace+0x30>
cmpb   $0x0,0x1(%rdx)
mov    $0x1,%al
je     3460 <update_export_env_inplace+0x30>
cmpb   $0x0,0x2(%rdx)
mov    $0x2,%al
jne    34b0 <update_export_env_inplace+0x80>
movslq %esi,%r12
mov    $0x11bb,%edx
mov    $0x0,%esi
lea    0x1(%r12,%rax,1),%rdi
callq  3477 <update_export_env_inplace+0x47>
mov    %r13,%rsi
mov    %rax,%rbp
mov    %rax,%rdi
callq  3485 <update_export_env_inplace+0x55>
lea    0x0(%rbp,%r12,1),%rdi
mov    %rbx,%rsi
callq  3492 <update_export_env_inplace+0x62>
mov    %rbp,%rdi
xor    %esi,%esi
callq  349c <update_export_env_inplace+0x6c>
mov    %rax,0x0(%rip)        # 34a3 <update_export_env_inplace+0x73>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
mov    %rdx,%rdi
mov    %esi,0xc(%rsp)
callq  34bc <update_export_env_inplace+0x8c>
mov    0xc(%rsp),%esi
jmp    3460 <update_export_env_inplace+0x30>
nopw   0x0(%rax,%rax,1)
movslq %esi,%rsi
mov    $0x11bb,%edx
lea    0x1(%rsi),%rdi
mov    $0x0,%esi
callq  34de <update_export_env_inplace+0xae>
mov    %r13,%rsi
mov    %rax,%rdi
mov    %rax,%rbp
callq  34ec <update_export_env_inplace+0xbc>
jmp    3492 <update_export_env_inplace+0x62>
xchg   %ax,%ax
<<<sep_in_sample>>>
update_export_env_inplace (env_prefix, preflen, value)
     char *env_prefix;
     int preflen;
     char *value;
{
  char *evar;
  evar = (char *)sh_xmalloc(((((value) && (value)[0]) ? ((value)[1] ? ((value)[2] ? strlen(value) : 2) : 1) : 0) + preflen + 1), "variables.c", 4539);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
  export_env = add_or_supercede_exported_var (evar, 0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 7
26 8
27 8
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 8
54 8
55 7
56 8
57 8
58 8
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rdi,%rbx
callq  7cb <scan_num+0xb>
mov    (%rbx),%eax
test   %eax,%eax
jne    7d8 <scan_num+0x18>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
mov    $0x0,%edi
xor    %eax,%eax
jmpq   7e5 <scan_num+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
scan_num(tokp)
 token *tokp;
{
 get_token(tokp);
 switch (tokp->kind) {
 case TOK_IDENT:
  break;
 default:
  error("constant or identifier expected");
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 5
6 5
7 5
8 11
9 11
10 11
11 11
12 9
13 9
14 9
15 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
lea    0x18(%rsp),%r8
lea    0x10(%rsp),%rcx
lea    0x8(%rsp),%rdx
mov    %rsp,%rsi
callq  15d <pr_forward_ed_hunk+0x1d>
test   %eax,%eax
mov    %eax,%ebx
jne    170 <pr_forward_ed_hunk+0x30>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  175 <pr_forward_ed_hunk+0x35>
mov    %ebx,%eax
mov    0x0(%rip),%rsi        # 17e <pr_forward_ed_hunk+0x3e>
movsbl 0x0(%rax),%edi
callq  18a <pr_forward_ed_hunk+0x4a>
mov    0x8(%rsp),%rcx
mov    (%rsp),%rdx
mov    $0x0,%esi
mov    $0x20,%edi
callq  1a2 <pr_forward_ed_hunk+0x62>
mov    0x0(%rip),%rsi        # 1a9 <pr_forward_ed_hunk+0x69>
mov    $0xa,%edi
callq  1b3 <pr_forward_ed_hunk+0x73>
cmp    $0x1,%ebx
je     163 <pr_forward_ed_hunk+0x23>
mov    0x10(%rsp),%rbx
cmp    0x18(%rsp),%rbx
lea    0x0(,%rbx,8),%rbp
jg     1f3 <pr_forward_ed_hunk+0xb3>
nopl   0x0(%rax)
mov    %rbp,%rsi
add    0x0(%rip),%rsi        # 1da <pr_forward_ed_hunk+0x9a>
mov    $0x0,%edi
add    $0x1,%rbx
add    $0x8,%rbp
callq  1ec <pr_forward_ed_hunk+0xac>
cmp    %rbx,0x18(%rsp)
jge    1d0 <pr_forward_ed_hunk+0x90>
mov    0x0(%rip),%rcx        # 1fa <pr_forward_ed_hunk+0xba>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  20e <pr_forward_ed_hunk+0xce>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pr_forward_ed_hunk (struct change *hunk)
{
  lin i, f0, l0, f1, l1;
  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
  if (!changes)
    return;
  begin_output ();
  fputc_unlocked (change_letter[changes],outfile);
  print_number_range (' ', files, f0, l0);
  fputc_unlocked ('\n',outfile);
  if (changes == OLD)
    return;
  for (i = f1; i <= l1; i++)
    print_1_line ("", &files[1].linbuf[i]);
  fputs_unlocked (".\n",outfile);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 5
12 16
13 16
14 16
15 16
16 16
17 7
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 11
31 11
32 13
33 13
34 13
35 13
36 13
37 14
38 14
39 14
40 13
41 13
42 14
43 13
44 13
45 15
46 15
47 15
48 15
49 15
50 16
51 16
52 16
53 16
54 16
<<<sep_out_sample>>>
test   %rdx,%rdx
je     318 <gsl_stats_ushort_mean+0x58>
add    %rsi,%rsi
xor    %eax,%eax
fldz   
jmp    2dc <gsl_stats_ushort_mean+0x1c>
xchg   %ax,%ax
fdivrp %st,%st(1)
add    %rsi,%rdi
cmp    %rdx,%rax
faddp  %st,%st(1)
je     30d <gsl_stats_ushort_mean+0x4d>
movzwl (%rdi),%ecx
add    $0x1,%rax
mov    %rax,-0x20(%rsp)
test   %rax,%rax
mov    %ecx,-0x14(%rsp)
fildl  -0x14(%rsp)
fsub   %st(1),%st
fildll -0x20(%rsp)
jns    2d0 <gsl_stats_ushort_mean+0x10>
add    %rsi,%rdi
cmp    %rdx,%rax
fadds  0x0(%rip)        # 307 <gsl_stats_ushort_mean+0x47>
fdivrp %st,%st(1)
faddp  %st,%st(1)
jne    2dc <gsl_stats_ushort_mean+0x1c>
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_mean (const unsigned short data[], const size_t stride, const size_t size)
{
  long double mean = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      mean += (data[i * stride] - mean) / (i + 1);
    }
  return mean;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 3
6 3
7 3
8 7
9 7
10 5
11 7
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 5
24 7
25 7
26 7
27 5
28 5
29 5
30 5
31 5
32 10
33 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 56 <begin_timing+0x6>
test   %eax,%eax
jne    60 <begin_timing+0x10>
repz retq 
nopl   0x0(%rax)
sub    $0x8,%rsp
callq  69 <begin_timing+0x19>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   74 <begin_timing+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
begin_timing(const char *name)
{
    if (timing_option) {
 timer_start(name);
 clear_stats();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 4
8 5
9 7
10 5
11 5
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     778 <hashtab_foreach+0x58>
mov    %rdx,%r12
mov    0x4(%rdi),%edx
mov    0x0(,%rdx,4),%eax
test   %eax,%eax
je     778 <hashtab_foreach+0x58>
mov    %rsi,%rbp
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    0x10(%r13),%rax
mov    %ebx,%ecx
mov    (%rax,%rcx,8),%rdi
test   %rdi,%rdi
je     76c <hashtab_foreach+0x4c>
mov    %r12,%rsi
callq  *%rbp
test   %eax,%eax
jne    77a <hashtab_foreach+0x5a>
mov    0x4(%r13),%edx
add    $0x1,%ebx
cmp    %ebx,0x0(,%rdx,4)
ja     750 <hashtab_foreach+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hashtab_foreach(struct hashtab *st, hashtab_enumerator_t fun, void *data)
{
 unsigned i;
 if (!st)
  return 0;
 for (i = 0; i < hash_size[st->hash_num]; i++) {
  struct hashent *ep = st->tab[i];
  if (ep) {
   int rc = fun(ep, data);
   if (rc)
    return rc;
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 8
21 8
22 9
23 9
24 10
25 10
26 10
27 6
28 6
29 6
30 5
31 15
32 15
33 15
34 15
35 15
36 15
37 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  3bcc <gsl_sf_fermi_dirac_1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3be0 <gsl_sf_fermi_dirac_1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x642,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3bf6 <gsl_sf_fermi_dirac_1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_fermi_dirac_1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_fermi_dirac_1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_fermi_dirac_1_e(x, &result)", "fermi_dirac.c", 1602, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # cb <closetoken+0xb>
callq  d0 <closetoken+0x10>
mov    0x0(%rip),%rdi        # d7 <closetoken+0x17>
add    $0x8,%rsp
jmpq   e0 <pushbacktoken>
<<<sep_in_sample>>>
closetoken(void)
{
 strbuf_close(ib);
 fclose(ip);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  14d0 <exp2>
mov    0x0(%rip),%ebx        # 16c1 <exp3+0x11>
mov    %rax,%rbp
cmp    $0x2d,%ebx
je     16f2 <exp3+0x42>
jmp    1710 <exp3+0x60>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdx
sub    %rax,%rdx
cmp    $0x2d,%ebx
cmove  %rdx,%rbp
mov    0x0(%rip),%ebx        # 16e3 <exp3+0x33>
movl   $0x6,0x0(%rip)        # 16ed <exp3+0x3d>
cmp    $0x2d,%ebx
jne    1710 <exp3+0x60>
callq  270 <readtok>
callq  14d0 <exp2>
cmp    $0x2b,%ebx
nop
jne    16d0 <exp3+0x20>
add    %rax,%rbp
jmp    16dd <exp3+0x2d>
nopw   0x0(%rax,%rax,1)
cmp    $0x2b,%ebx
je     16f2 <exp3+0x42>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
exp3 ()
{
  register intmax_t val1, val2;
  val1 = exp2 ();
  while ((curtok == '+') || (curtok == '-'))
    {
      int op = curtok;
      readtok ();
      val2 = exp2 ();
      if (op == '+')
 val1 += val2;
      else if (op == '-')
 val1 -= val2;
      lasttok = 6;
    }
  return (val1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 4
7 5
8 5
9 5
10 5
11 13
12 13
13 13
14 13
15 5
16 14
17 5
18 5
19 8
20 9
21 10
22 10
23 10
24 11
25 11
26 11
27 5
28 5
29 17
30 17
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
push   %rbx
mov    $0x10,%edi
callq  8b <grecs_txtacc_create+0xb>
mov    %rax,%rbx
callq  93 <grecs_txtacc_create+0x13>
mov    %rax,(%rbx)
movq   $0x0,0x20(%rax)
callq  a3 <grecs_txtacc_create+0x23>
mov    %rax,0x8(%rbx)
movq   $0x0,0x20(%rax)
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_create()
{
 struct grecs_txtacc *acc = grecs_malloc(sizeof (*acc));
 acc->cur = grecs_list_create();
 acc->cur->free_entry = grecs_txtacc_entry_free;
 acc->mem = grecs_list_create();
 acc->mem->free_entry = grecs_txtacc_entry_free;
 return acc;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 6
9 6
10 7
11 9
12 9
13 9
14 9
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     950 <gsl_sort_vector_ulong_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  945 <gsl_sort_vector_ulong_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  961 <gsl_sort_vector_ulong_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_ulong_index (gsl_permutation * permutation, const gsl_vector_ulong * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_ulong_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r12
lea    0x108(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  9f <osip_message_get_proxy_authenticate+0x1f>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    b8 <osip_message_get_proxy_authenticate+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  b2 <osip_message_get_proxy_authenticate+0x32>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_proxy_authenticate (const osip_message_t * sip, int pos, osip_proxy_authenticate_t ** dest)
{
  osip_proxy_authenticate_t *proxy_authenticate;
  *dest = ((void *)0);
  if (osip_list_size (&sip->proxy_authenticates) <= pos)
    return -1;
  proxy_authenticate = (osip_proxy_authenticate_t *)
    osip_list_get (&sip->proxy_authenticates, pos);
  *dest = proxy_authenticate;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 10
17 9
18 11
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  87c <gsl_sf_bessel_I0+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    890 <gsl_sf_bessel_I0+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xe7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8a6 <gsl_sf_bessel_I0+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_I0(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_I0_e(x, &result);; if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_I0_e(x, &result);", "bessel_I0.c", 231, status) ; return result.val ; } while (0); } ; return result.val;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%r10
mov    0x10(%rdi),%rdi
test   %rax,%rax
je     200 <gsl_multiset_prev+0x90>
mov    %rax,%r8
sub    $0x1,%r8
je     1c7 <gsl_multiset_prev+0x57>
lea    0x0(,%r8,8),%r9
lea    (%rdi,%r9,1),%rcx
mov    (%rcx),%rsi
cmp    %rsi,-0x8(%rdi,%r9,1)
jne    206 <gsl_multiset_prev+0x96>
lea    -0x10(%rdi,%rax,8),%rdx
mov    %r8,%rax
jmp    1c1 <gsl_multiset_prev+0x51>
nopl   (%rax)
mov    %rdx,%rcx
sub    $0x8,%rdx
mov    0x8(%rdx),%rsi
cmp    %rsi,-0x8(%rcx)
jne    1d4 <gsl_multiset_prev+0x64>
sub    $0x1,%rax
jne    1b0 <gsl_multiset_prev+0x40>
mov    (%rdi),%rsi
test   %rsi,%rsi
je     200 <gsl_multiset_prev+0x90>
mov    %rdi,%rcx
xor    %eax,%eax
lea    -0x1(%r10),%rdx
sub    $0x1,%rsi
mov    %rsi,(%rcx)
cmp    %rdx,%rsi
jae    1fd <gsl_multiset_prev+0x8d>
cmp    %rax,%r8
jbe    1fd <gsl_multiset_prev+0x8d>
nopl   0x0(%rax)
add    $0x1,%rax
cmp    %rax,%r8
mov    %rdx,(%rdi,%rax,8)
jne    1f0 <gsl_multiset_prev+0x80>
xor    %eax,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    %r8,%rax
jmp    1d4 <gsl_multiset_prev+0x64>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiset_prev (gsl_multiset * c)
{
  const size_t n = c->n;
  const size_t k = c->k;
  size_t *data = c->data;
  size_t i;
  if(k == 0)
    {
      return GSL_FAILURE;
    }
  i = k - 1;
  while(i > 0 && data[i-1] == data[i])
    {
      --i;
    }
  if(i == 0 && data[i] == 0)
    {
      return GSL_FAILURE;
    }
  data[i]--;
  if (data[i] < n-1)
    {
      while (i < k-1) {
        data[++i] = n - 1;
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 7
5 7
6 12
7 12
8 12
9 12
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 16
26 16
27 16
28 16
29 16
30 21
31 20
32 20
33 21
34 21
35 23
36 23
37 23
38 24
39 23
40 24
41 23
42 27
43 27
44 9
45 9
46 12
47 12
48 12
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    30d8 <gsl_matrix_ushort_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,2),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  30fa <gsl_matrix_ushort_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_superdiagonal (gsl_matrix_ushort * m,
                                      const size_t k)
{
  _gsl_vector_ushort_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ushort v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     5b48 <info_select_reference_this_line+0x28>
cmpq   $0x0,(%rax)
je     5b48 <info_select_reference_this_line+0x28>
xor    %ecx,%ecx
mov    $0x1,%edx
mov    $0x1,%esi
jmpq   5140 <info_menu_or_ref_item>
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_select_reference_this_line (WINDOW *window, int count)
{
  REFERENCE **ref = window->node->references;
  if (!ref || !*ref) return;
  info_menu_or_ref_item (window, 1, 1, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     c2 <mu_refcount_destroy+0x32>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     c2 <mu_refcount_destroy+0x32>
lea    0x8(%rbx),%rdi
mov    %rbx,%rsi
callq  b2 <mu_refcount_destroy+0x22>
mov    %rbx,%rdi
callq  ba <mu_refcount_destroy+0x2a>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_refcount_destroy (mu_refcount_t *prefcount)
{
  if (prefcount && *prefcount)
    {
      mu_refcount_t refcount = *prefcount;
      mu_monitor_destroy (&refcount->lock, refcount);
      free (refcount);
      *prefcount = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 6
13 7
14 7
15 8
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0xc8(%rdi),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swpath_get_is_minimal_layout(SWPATH * swpath)
{
 return swpath->is_minimal_layoutM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 53b <do_statusbar_home+0xb>
jmpq   540 <do_statusbar_end>
<<<sep_in_sample>>>
do_statusbar_home(void)
{
    statusbar_x = 0;
    update_the_statusbar();
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1ad9 <gsl_complex_arcsec+0x9>
callq  1ade <gsl_complex_arcsec+0xe>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_arcsec (gsl_complex a)
{
  gsl_complex z = gsl_complex_inverse (a);
  return gsl_complex_arccos (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7e7 <grecs_grecs_get_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_get_in (void)
{
        return grecs_grecs_in;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x820,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x818(%rsp)
xor    %eax,%eax
mov    0x30(%rdi),%rax
movl   $0x0,0xc(%rsp)
movl   $0x2,(%rax)
mov    0x18(%rdi),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x22,-0x2(%rax)
jne    1700 <ReadReaction_L2+0x40>
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
callq  171b <ReadReaction_L2+0x5b>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1728 <ReadReaction_L2+0x68>
mov    $0x3e,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  1748 <ReadReaction_L2+0x88>
lea    0x410(%rsp),%rdx
lea    0xc(%rsp),%rsi
mov    %rbx,%rdi
callq  175d <ReadReaction_L2+0x9d>
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  1776 <ReadReaction_L2+0xb6>
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
xor    %ecx,%ecx
mov    %rbx,%rdi
callq  178d <ReadReaction_L2+0xcd>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   (%rax)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1798 <ReadReaction_L2+0xd8>
mov    0x818(%rsp),%rax
xor    %fs:0x28,%rax
jne    17c2 <ReadReaction_L2+0x102>
add    $0x820,%rsp
pop    %rbx
retq   
callq  17c7 <ReadReaction_L2+0x107>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ReadReaction_L2 (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  int bInited = 0;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 62);
  ReadApply (pibIn, &bInited, szEqn);
  printf ("reaction %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 0);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 13
36 13
37 13
38 13
39 13
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 15
49 15
50 15
51 15
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
<<<sep_out_sample>>>
xor    %ecx,%ecx
xor    %edx,%edx
jmpq   210 <gen_page_generic_begin>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gen_page_begin(const char *title, int place)
{
 return gen_page_generic_begin(title, place, 0, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c0 <load_history+0x10>
mov    $0x0,%edi
callq  2ca <load_history+0x1a>
mov    $0x0,%edi
callq  2d4 <load_history+0x24>
mov    $0x0,%edi
mov    %rax,%rsi
callq  2e1 <load_history+0x31>
mov    $0x0,%edi
callq  2eb <load_history+0x3b>
mov    $0x0,%edi
callq  2f5 <load_history+0x45>
test   %rax,%rax
mov    %rax,%rbx
je     302 <load_history+0x52>
cmpb   $0x0,(%rax)
jne    308 <load_history+0x58>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rax,%rdi
callq  310 <load_history+0x60>
test   %eax,%eax
je     302 <load_history+0x52>
mov    %rbx,%rdi
callq  31c <load_history+0x6c>
pop    %rbx
mov    0x0(%rip),%eax        # 323 <load_history+0x73>
mov    %eax,0x0(%rip)        # 329 <load_history+0x79>
jmpq   32e <load_history+0x7e>
xchg   %ax,%ax
<<<sep_in_sample>>>
load_history ()
{
  char *hf;
  set_if_not ("HISTSIZE", "500");
  sv_histsize ("HISTSIZE");
  set_if_not ("HISTFILESIZE", get_string_value ("HISTSIZE"));
  sv_histsize ("HISTFILESIZE");
  hf = get_string_value ("HISTFILE");
  if (hf && *hf && file_exists (hf))
    {
      read_history (hf);
      history_lines_in_file = history_lines_read_from_file;
      using_history ();
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 8
18 9
19 9
20 9
21 15
22 15
23 15
24 9
25 9
26 9
27 9
28 11
29 11
30 15
31 12
32 12
33 13
34 13
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  1cf <call_arg_warn+0xf>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 1d8 <call_arg_warn+0x18>
test   %rax,%rax
je     1df <call_arg_warn+0x1f>
callq  *%rax
mov    %r12,%rdi
callq  1e7 <call_arg_warn+0x27>
mov    $0x0,%edi
mov    %rax,%r12
callq  1f4 <call_arg_warn+0x34>
mov    %ebx,%esi
mov    %rbp,%r8
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
jmpq   20c <call_arg_warn+0x4c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
call_arg_warn (char const *call, char const *name)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot %s"), quotearg_colon (name), call); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 4
24 4
25 4
26 4
27 4
<<<sep_out_sample>>>
callq  1da5 <rpl_glob_pattern_p+0x5>
cmp    $0x1,%eax
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
rpl_glob_pattern_p (pattern, quote)
     const char *pattern;
     int quote;
{
  return __glob_pattern_type (pattern, quote) == 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 6
<<<sep_out_sample>>>
push   %r15
mov    %r9,%r15
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%ebp
lea    0x1(%rbp),%eax
mov    %eax,(%rdi)
movslq %ebp,%rax
lea    (%rdi,%rax,8),%rbx
mov    %rsi,%rdi
movq   $0x0,0xa8(%rbx)
callq  26b <rec_mset_register_type+0x3b>
mov    %r12,0x28(%rbx)
mov    %rax,0x8(%rbx)
mov    %ebp,%eax
mov    %r13,0x48(%rbx)
mov    %r14,0x68(%rbx)
mov    %r15,0x88(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_mset_register_type (rec_mset_t mset,
                        char *name,
                        rec_mset_disp_fn_t disp_fn,
                        rec_mset_equal_fn_t equal_fn,
                        rec_mset_dup_fn_t dup_fn,
                        rec_mset_compare_fn_t compare_fn)
{
  rec_mset_type_t new_type;
  new_type = mset->ntypes++;
  mset->count[new_type] = 0;
  mset->name[new_type] = strdup (name);
  mset->disp_fn[new_type] = disp_fn;
  mset->equal_fn[new_type] = equal_fn;
  mset->dup_fn[new_type] = dup_fn;
  mset->compare_fn[new_type] = compare_fn;
  return new_type;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 11
18 10
19 11
20 12
21 11
22 17
23 13
24 14
25 15
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
lea    -0x2(%rsi),%eax
mov    %edi,%ecx
mov    %edi,%edx
sub    %esi,%edx
shr    %edi
shr    %esi
mov    0x0(,%rax,8),%rax
sub    $0x1,%esi
imul   0x0(,%rcx,8),%rax
lea    -0x2(%rdx),%ecx
movzbl 0x0(%rsi),%esi
shr    %edx
sub    $0x1,%edx
imul   0x0(,%rcx,8),%rax
lea    -0x1(%rdi),%ecx
movzbl 0x0(%rcx),%ecx
sub    %esi,%ecx
sub    0x0(%rdx),%cl
shl    %cl,%rax
retq   
nop
<<<sep_in_sample>>>
bc_bin_uiui (unsigned int n, unsigned int k)
{
  return ((__gmp_oddfac_table[n] * facinv[k - 2] * facinv[n - k - 2])
    << (__gmp_fac2cnt_table[n / 2 - 1] - __gmp_fac2cnt_table[k / 2 - 1] - __gmp_fac2cnt_table[(n-k) / 2 - 1]))
    & ((~ ((mp_limb_t) (0))) >> 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 3
8 4
9 3
10 3
11 4
12 4
13 4
14 3
15 4
16 4
17 4
18 4
19 3
20 6
21 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
movq   $0x0,(%rsp)
callq  b59 <grecs_print_locus+0x19>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_print_locus(grecs_locus_t *locus, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_locus(locus, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
8 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1d8 <mu_secret_password+0x38>
mov    0x20(%rdi),%eax
lea    0x1(%rax),%edx
test   %eax,%eax
mov    %edx,0x20(%rdi)
je     1c0 <mu_secret_password+0x20>
mov    0x18(%rbx),%rax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x8(%rdi),%rdx
mov    0x18(%rdi),%rsi
mov    0x10(%rdi),%rdi
callq  0 <obfuscate>
jmp    1b6 <mu_secret_password+0x16>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_secret_password (mu_secret_t sec)
{
  if (!sec)
    return 0;
  if (sec->clref++ == 0)
    obfuscate (sec->obptr, sec->clptr, sec->length);
  return (const char*) sec->clptr;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 7
11 8
12 8
13 8
14 6
15 6
16 6
17 6
18 6
19 6
20 4
21 8
22 8
23 8
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1529 <gsl_vector_uchar_ispos+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm0,%xmm1
jae    152f <gsl_vector_uchar_ispos+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1510 <gsl_vector_uchar_ispos+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_ispos (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
21 13
<<<sep_out_sample>>>
push   %rbx
movslq 0x0(%rip),%rbx        # 3a8 <init_buffer+0x8>
mov    0x0(,%rbx,8),%rax
test   %rax,%rax
je     3e0 <init_buffer+0x40>
movslq 0x0(%rip),%rdx        # 3bc <init_buffer+0x1c>
mov    %rax,0x0(%rip)        # 3c3 <init_buffer+0x23>
mov    %rax,0x0(%rip)        # 3ca <init_buffer+0x2a>
pop    %rbx
shl    $0x9,%rdx
add    %rdx,%rax
mov    %rax,0x0(%rip)        # 3d9 <init_buffer+0x39>
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 3e7 <init_buffer+0x47>
lea    0x0(,%rbx,8),%rdi
callq  3f4 <init_buffer+0x54>
mov    %rax,0x0(,%rbx,8)
movslq 0x0(%rip),%rax        # 403 <init_buffer+0x63>
mov    0x0(,%rax,8),%rax
jmp    3b5 <init_buffer+0x15>
nopl   (%rax)
<<<sep_in_sample>>>
init_buffer (void)
{
  if (! record_buffer_aligned[record_index])
    record_buffer_aligned[record_index] =
      page_aligned_alloc (&record_buffer[record_index], record_size);
  record_start = record_buffer_aligned[record_index];
  current_block = record_start;
  record_end = record_start + blocking_factor;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 8
7 6
8 7
9 9
10 8
11 8
12 8
13 9
14 9
15 5
16 5
17 5
18 4
19 4
20 4
21 4
22 4
<<<sep_out_sample>>>
push   %rbx
movslq 0x10(%rdi),%rdx
mov    %rdi,%rbx
mov    0x8(%rdi),%rax
mov    $0x3d,%esi
mov    (%rax,%rdx,8),%rdi
callq  55a <parse_tag+0x1a>
test   %rax,%rax
je     578 <parse_tag+0x38>
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
callq  390 <parse_label>
mov    %rax,0x18(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
movq   $0x0,0x18(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_tag (struct find_data *fptr)
{
  char *p = strchr (fptr->argv[fptr->tag], '=');
  if (p)
    {
      *p++ = 0;
      fptr->label = parse_label (p);
    }
  else
    fptr->label = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 7
13 7
14 11
15 11
16 11
17 10
18 11
19 11
20 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # bb <clearScreen+0xb>
mov    $0x4,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  cf <clearScreen+0x1f>
mov    0x0(%rip),%rcx        # d6 <clearScreen+0x26>
mov    $0x7,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  ea <clearScreen+0x3a>
mov    0x0(%rip),%rcx        # f1 <clearScreen+0x41>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   109 <clearScreen+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
clearScreen()
{
 fprintf(stdout, "\e[2J");
 fprintf(stdout, "\x1b[37;4m");
 fprintf(stdout, "\e[3J\e[1;1H");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 5
18 5
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rsi,%rax
je     30 <swlib__strlcpy+0x30>
jmp    23 <swlib__strlcpy+0x23>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movzbl -0x1(%rax),%ecx
add    $0x1,%rdi
test   %cl,%cl
mov    %cl,-0x1(%rdi)
je     48 <swlib__strlcpy+0x48>
sub    $0x1,%rdx
jne    10 <swlib__strlcpy+0x10>
movb   $0x0,(%rdi)
nopl   0x0(%rax)
add    $0x1,%rax
cmpb   $0x0,-0x1(%rax)
jne    30 <swlib__strlcpy+0x30>
sub    %rsi,%rax
sub    $0x1,%rax
retq   
nopw   0x0(%rax,%rax,1)
test   %rdx,%rdx
je     29 <swlib__strlcpy+0x29>
sub    %rsi,%rax
sub    $0x1,%rax
retq   
<<<sep_in_sample>>>
swlib__strlcpy(char * dst, const char * src, size_t siz)
{
 register char *d = dst;
 register const char *s = src;
 register size_t n = siz;
 if (n != 0 && --n != 0) {
  do {
   if ((*d++ = *s++) == 0)
    break;
  } while (--n != 0);
 }
 if (n == 0) {
  if (siz != 0)
   *d = '\0';
  while (*s++)
   ;
 }
 return(s - src - 1);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 6
13 6
14 14
15 14
16 15
17 15
18 15
19 18
20 18
21 19
22 19
23 12
24 12
25 18
26 18
27 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3b9 <gc_md5+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_md5 (const void *in, size_t inlen, void *resbuf)
{
  md5_buffer (in, inlen, resbuf);
  return GC_OK;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x28(%rdi),%edx
xor    %eax,%eax
test   %edx,%edx
sete   %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exclude_cross_references (REFERENCE *r)
{
  return r->type == 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     3c0 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 3c7 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     3e8 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     435 <argp_version_parser+0x85>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 3ef <argp_version_parser+0x3f>
test   %rdx,%rdx
je     410 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  404 <argp_version_parser+0x54>
jmp    3d9 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rax
mov    $0x0,%esi
mov    0x30(%rax),%rdi
callq  421 <argp_version_parser+0x71>
mov    $0x0,%esi
mov    %rax,%rdx
mov    %rbx,%rdi
xor    %eax,%eax
callq  433 <argp_version_parser+0x83>
jmp    3d9 <argp_version_parser+0x29>
xor    %edi,%edi
callq  43c <argp_version_parser+0x8c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      dgettext (state->root_argp->argp_domain,
                                "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 18
4 21
5 21
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 14
15 14
16 14
17 21
18 21
19 21
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 15
40 15
41 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 4b <set_requested_style+0xb>
test   %rdi,%rdi
je     55 <set_requested_style+0x15>
callq  55 <set_requested_style+0x15>
xor    %eax,%eax
test   %rbx,%rbx
je     69 <set_requested_style+0x29>
cmpb   $0x0,(%rbx)
je     69 <set_requested_style+0x29>
mov    %rbx,%rdi
callq  69 <set_requested_style+0x29>
mov    %rax,0x0(%rip)        # 70 <set_requested_style+0x30>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_requested_style (const char * arg)
{
  do { const char *my_s2 = (arg); do { if (style_request) free (style_request); } while (0); style_request = !(((const char *) (my_s2) == ((void *)0)) || (*(my_s2) == '\0')) ? xstrdup (my_s2) : ((void *)0); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 4
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
ucomisd %xmm1,%xmm2
ja     80 <gsl_multimin_test_size+0x20>
xor    %eax,%eax
ucomisd %xmm0,%xmm1
seta   %al
lea    -0x2(%rax,%rax,1),%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0xd,%ecx
mov    $0x31,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9d <gsl_multimin_test_size+0x3d>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multimin_test_size (const double size, double epsabs)
{
  if (epsabs < 0.0)
    {
      do { gsl_error ("absolute tolerance is negative", "convergence.c", 49, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
    }
  if (size < epsabs)
    {
      return GSL_SUCCESS;
    }
  return GSL_CONTINUE;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 11
5 11
6 11
7 11
8 11
9 11
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 12
18 12
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
xor    %esi,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x50(%rdi),%rbp
callq  180 <amd_messages_count>
test   %eax,%eax
jne    222 <amd_uidvalidity+0x32>
cmpq   $0x0,0x68(%rbp)
je     230 <amd_uidvalidity+0x40>
test   %r12,%r12
je     220 <amd_uidvalidity+0x30>
mov    0x80(%rbp),%rax
mov    %rax,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  *0x38(%rbp)
test   %eax,%eax
jne    222 <amd_uidvalidity+0x32>
test   %r12,%r12
jne    215 <amd_uidvalidity+0x25>
jmp    220 <amd_uidvalidity+0x30>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
amd_uidvalidity (mu_mailbox_t mailbox, unsigned long *puidvalidity)
{
  struct _amd_data *amd = mailbox->data;
  int status = amd_messages_count (mailbox, ((void *)0));
  if (status != 0)
    return status;
  if (amd->msg_count == 0)
    {
      status = amd->scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  if (puidvalidity)
    *puidvalidity = amd->uidvalidity;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 3
8 4
9 5
10 5
11 7
12 7
13 13
14 13
15 14
16 14
17 15
18 16
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 13
31 13
32 13
33 13
<<<sep_out_sample>>>
mov    %edi,%edi
jmpq   1817 <ppdalloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     19d0 <gsl_vector_int_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19c5 <gsl_vector_int_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1a03 <gsl_vector_int_add+0x63>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%esi
add    %r9,%rcx
add    %esi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    19f0 <gsl_vector_int_add+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_add (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     720 <gsl_sort_vector_float_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  715 <gsl_sort_vector_float_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  731 <gsl_sort_vector_float_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_float_index (gsl_permutation * permutation, const gsl_vector_float * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_float_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     720 <mu_mailbox_message_unseen+0x20>
mov    0x90(%rdi),%rdx
test   %rdx,%rdx
je     720 <mu_mailbox_message_unseen+0x20>
testb  $0x8,0x31(%rdi)
mov    $0x1033,%eax
je     730 <mu_mailbox_message_unseen+0x30>
repz retq 
xchg   %ax,%ax
mov    $0x1003,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
jmpq   *%rdx
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_message_unseen (mu_mailbox_t mbox, size_t *num)
{
  if (mbox == ((void *)0) || mbox->_message_unseen == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_message_unseen (mbox, num);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 5
9 8
10 8
11 4
12 8
13 8
14 7
15 7
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   2ce0 <info_search_1>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_search (WINDOW *window, int count)
{
  info_search_1 (window, count, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 46 <__db_join_del+0x6>
mov    $0x16,%eax
test   %edx,%edx
jne    58 <__db_join_del+0x18>
repz retq 
nopl   0x0(%rax)
mov    (%rdi),%rdx
mov    0x28(%rdx),%rdx
mov    0xe0(%rdx),%rdx
test   %rdx,%rdx
je     4f <__db_join_del+0xf>
mov    0x20(%rdx),%rax
cmpl   $0x1,0x74(%rax)
sbb    %eax,%eax
and    $0x7923,%eax
sub    $0x790d,%eax
retq   
<<<sep_in_sample>>>
__db_join_del(dbc, flags)
 DBC *dbc;
 u_int32_t flags;
{
 if(flags){}
 if (CDB___db_global_values.db_panic && (dbc->dbp->dbenv)->reginfo != ((void *)0) && ((REGENV *) ((REGINFO *)(dbc->dbp->dbenv)->reginfo)->primary)->panic != 0) return ((-30989));;
 (flags) = (0);
 return (22);
}
<<<sep_in_sample>>>
1 6
2 8
3 6
4 6
5 9
6 9
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 9
<<<sep_out_sample>>>
push   %rbx
mov    0x60(%rdi),%rdx
mov    %rsi,%rcx
xor    %esi,%esi
mov    %rdi,%rbx
callq  630 <gl_linked_search_from_to>
test   %rax,%rax
je     f98 <gl_linked_remove+0x28>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   eb0 <gl_linked_remove_node>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_remove (gl_list_t list, const void *elt)
{
  gl_list_node_t node = gl_linked_search_from_to (list, 0, list->count, elt);
  if (node != ((void *)0))
    return gl_linked_remove_node (list, node);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 3
7 4
8 4
9 5
10 5
11 8
12 5
13 5
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
testb  $0x2,0x10(%rdi)
mov    %rdi,%rbx
je     443 <wsnode_free+0x13>
mov    0x18(%rdi),%rdi
callq  443 <wsnode_free+0x13>
mov    %rbx,%rdi
pop    %rbx
jmpq   44c <wsnode_free+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
wsnode_free (struct wordsplit_node *p)
{
  if (p->flags & 0x02)
    free (p->v.word);
  free (p);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
push   %r12
xor    %eax,%eax
cmp    $0x1ff,%rcx
mov    %rdx,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
ja     2d6 <dir_reader+0x26>
jmp    2ea <dir_reader+0x3a>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2e,0x13(%rax)
jne    2f0 <dir_reader+0x40>
mov    %rbx,%rdi
callq  2de <dir_reader+0x2e>
test   %rax,%rax
jne    2d0 <dir_reader+0x20>
mov    $0xffffffffffffffff,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
lea    0x13(%rax),%rcx
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x0,%edx
xor    %eax,%eax
mov    %rcx,%r8
callq  309 <dir_reader+0x59>
pop    %rbx
pop    %rbp
cltq   
pop    %r12
retq   
<<<sep_in_sample>>>
dir_reader (void *cls, uint64_t pos, char *buf, size_t max)
{
  DIR *dir = cls;
  struct dirent *e;
  if (max < 512)
    return 0;
  do
    {
      e = readdir (dir);
      if (e == ((void *)0))
        return (18446744073709551615UL);
  } while (e->d_name[0] == '.');
  return snprintf (buf, max,
     "<a href=\"/%s\">%s</a><br>",
     e->d_name,
     e->d_name);
}
<<<sep_in_sample>>>
1 2
2 6
3 5
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 12
13 12
14 9
15 9
16 10
17 10
18 11
19 17
20 17
21 17
22 17
23 17
24 15
25 13
26 13
27 13
28 13
29 13
30 13
31 17
32 17
33 13
34 17
35 17
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 30e7 <find_tempenv_variable+0x7>
test   %rsi,%rsi
je     30f8 <find_tempenv_variable+0x18>
jmpq   960 <hash_lookup>
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_tempenv_variable (name)
     const char *name;
{
  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
<<<sep_out_sample>>>
movslq %edx,%rcx
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
jmpq   72 <uxfio_unix_safe_write+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uxfio_unix_safe_write(int fd, void * buf, int nbyte) {
 return safeio((ssize_t (*)(int, void *, size_t))write,
     fd, buf, nbyte);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1e87 <asm_set_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_set_in (FILE * in_str )
{
        asm_in = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rdx
lea    0x1(%rdx),%rax
cmp    0x8(%rdi),%rax
jb     5c7 <da_append+0x27>
callq  5bf <da_append+0x1f>
mov    0x28(%rbx),%rdx
lea    0x1(%rdx),%rax
mov    0x30(%rbx),%rcx
mov    %rax,0x28(%rbx)
mov    %rbp,(%rcx,%rdx,8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_append (struct darray * arr, void * elem)
{
  if (((arr)->len + 1 >= (arr)->size))
    da_grow (arr);
  arr->content [arr->len++] = elem;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movzbl %dl,%edx
lea    0xc(%rsp),%rcx
callq  dd1 <cdio_get_devices_with_cap+0x11>
add    $0x18,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_with_cap ( char* search_devices[],
                           cdio_fs_anal_t capabilities, _Bool any)
{
  driver_id_t p_driver_id;
  return cdio_get_devices_with_cap_ret (search_devices, capabilities, any,
                                        &p_driver_id);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 7
7 7
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0xc,%esi
jmpq   d <gcm_aes256_set_nonce_wrapper+0xd>
<<<sep_in_sample>>>
gcm_aes256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)
{
  nettle_gcm_aes256_set_iv (ctx, (16 - 4), nonce);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
jmpq   1695 <swverify_inl_delete+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swverify_inl_delete(INFOLINE * inl) {
 free((void*)inl);
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r12
cmp    $0x4,%edi
push   %rbp
push   %rbx
je     1308 <hexFormat+0x48>
mov    $0xf,%edi
callq  12d3 <hexFormat+0x13>
test   %rax,%rax
je     1350 <hexFormat+0x90>
mov    %rax,%rbx
movabs $0x6e206120746f6e28,%rdx
mov    $0x2972,%ecx
mov    %rdx,(%rax)
movl   $0x65626d75,0x8(%rax)
mov    %cx,0xc(%rax)
movb   $0x0,0xe(%rax)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
add    $0x14,%ecx
mov    %rsi,%r12
mov    %rdx,%rbp
movslq %ecx,%rdi
callq  1319 <hexFormat+0x59>
test   %rax,%rax
mov    %rax,%rbx
je     1360 <hexFormat+0xa0>
mov    %rbp,%rdi
callq  1329 <hexFormat+0x69>
mov    $0x78,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
mov    %dx,0x0(%rbp,%rax,1)
mov    (%r12),%edx
xor    %eax,%eax
callq  1344 <hexFormat+0x84>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
callq  1355 <hexFormat+0x95>
jmp    12d8 <hexFormat+0x18>
nopw   0x0(%rax,%rax,1)
callq  1365 <hexFormat+0xa5>
mov    %rax,%rbx
jmp    1321 <hexFormat+0x61>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hexFormat(int_32 type, const void * data,
  char * formatPrefix, int padding, int element)
{
    char * val;
    if (type != 4) {
 val = (strcpy((malloc(strlen("(not a number)")+1) ? : vmefail()), ("(not a number)")));
    } else {
 val = (malloc(20 + padding) ? : vmefail());
 strcat(formatPrefix, "x");
 sprintf(val, formatPrefix, *((int_32 *) data));
    }
    return val;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 13
18 13
19 13
20 13
21 13
22 13
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 9
32 9
33 9
34 10
35 10
36 9
37 10
38 10
39 10
40 13
41 13
42 13
43 13
44 13
45 13
46 6
47 6
48 6
49 8
50 8
51 8
52 8
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
lea    0xc(%rsp),%rdx
callq  11c5 <GetPunct+0x15>
mov    0xc(%rsp),%ecx
cmp    $0x20,%ecx
je     11e0 <GetPunct+0x30>
xor    %eax,%eax
cmp    $0x8,%ecx
je     11e0 <GetPunct+0x30>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
cmp    %bpl,(%rbx)
sete   %al
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
GetPunct (PINPUTBUF pibIn, PSTR szLex, char chPunct)
{
  int iType;
  NextLex (pibIn, szLex, &iType);
  return ((iType == 0x0008 || iType == 0x0020) && szLex[0] == chPunct);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    0x0(%rbp,%rbx,1),%rdi
test   %rdi,%rdi
je     19f <swi_scripts_delete+0x1f>
callq  19f <swi_scripts_delete+0x1f>
add    $0x8,%rbx
cmp    $0x50,%rbx
jne    190 <swi_scripts_delete+0x10>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   1b7 <swi_scripts_delete+0x37>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_scripts_delete(SWI_SCRIPTS * s)
{
 int i;
 for(i=0; i<10; i++) {
  if (s->swi_coM[i])
   swi_control_script_delete(s->swi_coM[i]);
 }
 free(s);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 6
11 6
12 4
13 4
14 9
15 8
16 9
17 9
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x10(%rsi),%rsi
test   %rsi,%rsi
je     288 <alog_local_ip+0x28>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   0 <print_str>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 28e <alog_local_ip+0x2e>
test   %eax,%eax
je     2b8 <alog_local_ip+0x58>
xor    %esi,%esi
mov    $0x0,%edi
callq  f0 <sockaddr_to_hostname>
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
mov    %rax,%rsi
jmpq   0 <print_str>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  2c2 <alog_local_ip+0x62>
mov    %rax,%rsi
mov    %rax,0x10(%rbx)
jmp    275 <alog_local_ip+0x15>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alog_local_ip(FILE *fp, struct alog_instr *instr, int argc, char **argv)
{
    if (!instr->cache) {
 if (server_addrlen == 0)
     instr->cache = xstrdup("stdin");
 else
     instr->cache = sockaddr_to_hostname(&server_addr, 0);
    }
    print_str(fp, instr->cache);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 10
10 9
11 10
12 10
13 9
14 9
15 4
16 4
17 4
18 7
19 7
20 7
21 7
22 10
23 9
24 10
25 10
26 7
27 9
28 9
29 5
30 5
31 5
32 5
33 5
34 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
xor    %edx,%edx
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  88 <rec_atoi+0x18>
xor    %edx,%edx
cmpb   $0x0,(%rbx)
je     a1 <rec_atoi+0x31>
mov    0x8(%rsp),%rcx
cmpb   $0x0,(%rcx)
jne    a1 <rec_atoi+0x31>
mov    %eax,0x0(%rbp)
mov    $0x1,%edx
add    $0x18,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_atoi (const char *str,
          int *number)
{
  _Bool res;
  long int li;
  char *end;
  int base = 0;
  res = 0;
  li = strtol (str, &end, base);
  if ((*str != '\0') && (*end == '\0'))
    {
      res = 1;
      *number = (int) li;
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 3
5 3
6 3
7 9
8 9
9 8
10 10
11 10
12 10
13 10
14 10
15 13
16 12
17 16
18 16
19 16
20 16
21 16
22 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  21e <ShowHelp+0xe>
mov    $0x0,%edi
callq  228 <ShowHelp+0x18>
mov    $0x0,%edi
callq  232 <ShowHelp+0x22>
mov    $0x0,%edi
callq  23c <ShowHelp+0x2c>
mov    $0x0,%edi
callq  246 <ShowHelp+0x36>
mov    $0x0,%edi
callq  250 <ShowHelp+0x40>
mov    $0x0,%edi
callq  25a <ShowHelp+0x4a>
mov    $0x0,%edi
callq  264 <ShowHelp+0x54>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   272 <ShowHelp+0x62>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ShowHelp ()
{
  printf ("Help:\n");
  printf ("Usage: mod [options] [input-file [output-file]]\n");
  printf ("Options:\n");
  printf ("  -h  Display this information\n");
  printf ("  -H  Display this information\n");
  printf ("  -D  Debug mode\n");
  printf ("  -R  Generate an R deSolve compatible C file\n");
  printf ("Creates file 'output-file' (or 'model.c', by default)\n");
  printf ("according to the input-file specifications.\n\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 11
19 12
20 11
21 11
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  1e73 <mu_url_aget_path+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    1e97 <mu_url_aget_path+0x37>
mov    0x8(%rsp),%rdi
test   %rdi,%rdi
je     1ea0 <mu_url_aget_path+0x40>
callq  1e88 <mu_url_aget_path+0x28>
test   %rax,%rax
mov    %rax,0x0(%rbp)
mov    $0xc,%eax
cmove  %eax,%ebx
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
movq   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_aget_path (mu_url_t url, char **buf) { const char *str; int status = mu_url_sget_path (url, &str); if (status) return status; if (str) { *buf = strdup (str); if (!*buf) status = 12; } else *buf = ((void *)0); return status; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
mov    0x30(%rdi),%rcx
mov    %rdx,%r8
xor    %edx,%edx
jmpq   4a0 <gl_array_sortedlist_indexof_from_to>
xchg   %ax,%ax
<<<sep_in_sample>>>
gl_array_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
                             const void *elt)
{
  return gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count,
                                              elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
movq   $0x0,(%rsi)
mov    %rdx,0x8(%rsi)
mov    %rdx,0x18(%rsi)
movl   $0x0,0x20(%rsi)
movl   $0x0,0x24(%rsi)
je     750 <MakeStringBuffer+0x40>
mov    0x30(%rdi),%rax
mov    %rax,0x30(%rsi)
mov    0x20(%rdi),%eax
movl   $0x1,0x24(%rsi)
mov    %eax,0x20(%rsi)
retq   
nopl   0x0(%rax,%rax,1)
movq   $0x0,0x30(%rsi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
MakeStringBuffer (PINPUTBUF pBuf, PINPUTBUF pbufStr, PSTR sz)
{
  pbufStr->pfileIn = ((void *)0);
  pbufStr->pbufCur = pbufStr->pbufOrg = sz;
  pbufStr->iLineNum = 0;
  pbufStr->iLNPrev = 0;
  pbufStr->pInfo = (pBuf ? pBuf->pInfo : ((void *)0));
  if (pBuf) {
    pbufStr->iLineNum = pBuf->iLineNum;
    pbufStr->iLNPrev = 1;
  }
}
<<<sep_in_sample>>>
1 7
2 3
3 4
4 4
5 5
6 6
7 7
8 7
9 7
10 9
11 10
12 9
13 9
14 9
15 7
16 7
17 7
<<<sep_out_sample>>>
mov    (%rcx),%rax
jmpq   *%rax
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  void (**addfnptr) (struct exclude *, char const *, int) = data;
  (*addfnptr) (ex, pattern, options);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smapwrap (void)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
callq  9 <main+0x9>
test   %rax,%rax
mov    %rax,%rbp
je     98 <main+0x98>
nopl   (%rax)
mov    0x10(%rbp),%ecx
mov    0x0(%rbp),%rsi
xor    %eax,%eax
mov    0x8(%rbp),%rdx
mov    $0x0,%edi
xor    %r12d,%r12d
mov    $0x1,%ebx
callq  37 <main+0x37>
mov    0x18(%rbp),%rax
mov    (%rax),%rsi
test   %rsi,%rsi
jne    4e <main+0x4e>
jmp    81 <main+0x81>
nopl   (%rax)
mov    %rbx,%r12
mov    %rax,%rbx
xor    %eax,%eax
mov    $0x0,%edi
callq  5a <main+0x5a>
mov    0x18(%rbp),%rdx
cmpq   $0x0,0x8(%rdx,%r12,8)
je     74 <main+0x74>
mov    $0x2c,%edi
callq  70 <main+0x70>
mov    0x18(%rbp),%rdx
mov    (%rdx,%rbx,8),%rsi
lea    0x1(%rbx),%rax
test   %rsi,%rsi
jne    48 <main+0x48>
mov    $0xa,%edi
callq  8b <main+0x8b>
callq  90 <main+0x90>
test   %rax,%rax
mov    %rax,%rbp
jne    18 <main+0x18>
callq  9d <main+0x9d>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
main(int argc, char **argv)
{
    struct group *g;
    int i;
    while ((g = getgrent()) != ((void *)0)) {
        printf("%s:%s:%ld:", g->gr_name, g->gr_passwd,
                                     (long) g->gr_gid);
        for (i = 0; g->gr_mem[i] != ((void *)0); i++) {
            printf("%s", g->gr_mem[i]);
            if (g->gr_mem[i+1] != ((void *)0))
                putchar(',');
        }
        putchar('\n');
    }
    endgrent();
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 6
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 9
27 9
28 10
29 10
30 10
31 11
32 11
33 11
34 8
35 8
36 8
37 8
38 13
39 13
40 5
41 5
42 5
43 5
44 15
45 17
46 17
47 17
48 17
49 17
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 517 <set_neturg+0x7>
sub    $0x1,%rax
mov    %rax,0x0(%rip)        # 522 <set_neturg+0x12>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_neturg (void)
{
  neturg = nfrontp - 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
cmp    $0x23,%edi
movl   $0x1,(%rsi)
mov    $0x23,%eax
je     2586 <swlib_c701_escaped_value+0x26>
cmp    $0x5c,%edi
mov    $0x5c,%al
je     2586 <swlib_c701_escaped_value+0x26>
cmp    $0x22,%edi
mov    $0x22,%al
je     2586 <swlib_c701_escaped_value+0x26>
movl   $0x0,(%rsi)
mov    %edi,%eax
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_c701_escaped_value(int src, int * is_escape) {
 *is_escape = 1;
 switch (src) {
  case '\\': return (int)'\\'; break;
  case '#': return (int)'#'; break;
  case '\"': return (int)'\"'; break;
 }
 *is_escape = 0;
 return (int)(src);
}
<<<sep_in_sample>>>
1 3
2 2
3 5
4 3
5 3
6 4
7 3
8 3
9 6
10 3
11 8
12 9
13 10
14 10
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   0 <history_search_internal>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_search (string, direction)
     const char *string;
     int direction;
{
  return (history_search_internal (string, direction, 0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x2f,%esi
mov    %rdi,%rbx
callq  3d9e <tail+0xe>
lea    0x1(%rax),%rdx
test   %rax,%rax
cmove  %rbx,%rdx
mov    %rdx,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
tail(const char *path)
{
    const char *slash = strrchr(path, '/');
    if (slash == ((void *)0))
 return path;
    else
 return ++slash;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 7
6 7
7 7
8 8
9 8
10 8
11 8
<<<sep_out_sample>>>
mov    $0x0,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
jmpq   12 <areadlinkat+0x12>
<<<sep_in_sample>>>
areadlinkat (int fd, char const *filename)
{
  return careadlinkat (fd, filename, ((void *)0), 0, ((void *)0), readlinkat);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     1620 <gsl_sort_vector_uchar_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1615 <gsl_sort_vector_uchar_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1631 <gsl_sort_vector_uchar_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_uchar_index (gsl_permutation * permutation, const gsl_vector_uchar * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_uchar_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
testb  $0x2,0x2d0(%rdi)
mov    0x320(%rdi),%rax
jne    758 <fuelUsed+0x38>
movsd  0x220(%rax),%xmm0
mulsd  0x268(%rdi),%xmm0
mulsd  0x0(%rip),%xmm0        # 748 <fuelUsed+0x28>
divsd  0x0(%rip),%xmm0        # 750 <fuelUsed+0x30>
retq   
nopl   0x0(%rax)
movsd  0x228(%rax),%xmm0
jmp    738 <fuelUsed+0x18>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fuelUsed( craft * c )
{
 double spFuelConsump;
 if (c->flags & (1<<1)) {
  spFuelConsump = c->cinfo->spABFuelConsump;
 }
 else {
  spFuelConsump = c->cinfo->spFuelConsump;
 }
 return spFuelConsump * c->curThrust * deltaT / 3600.0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 8
5 10
6 10
7 10
8 11
9 11
10 5
11 5
12 5
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 167 <current_history+0x7>
cmp    0x0(%rip),%eax        # 16d <current_history+0xd>
je     180 <current_history+0x20>
mov    0x0(%rip),%rdx        # 176 <current_history+0x16>
test   %rdx,%rdx
je     180 <current_history+0x20>
mov    (%rdx,%rax,8),%rax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
current_history ()
{
  return ((history_offset == history_length) || the_history == 0)
  ? (HIST_ENTRY *)((void *)0)
  : the_history[history_offset];
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 3
7 5
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x14,%edi
push   %rbx
mov    %rdx,%rbx
callq  e7 <gsasl_sha1+0x17>
test   %rax,%rax
mov    %rax,(%rbx)
je     108 <gsasl_sha1+0x38>
pop    %rbx
mov    %rbp,%rdi
mov    %r12,%rsi
mov    %rax,%rdx
pop    %rbp
pop    %r12
jmpq   101 <gsasl_sha1+0x31>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x7,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_sha1 (const char *in, size_t inlen, char *out[20])
{
  *out = malloc (20);
  if (!*out)
    return GSASL_MALLOC_ERROR;
  return gc_sha1 (in, inlen, *out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 3
9 4
10 3
11 4
12 7
13 6
14 6
15 6
16 7
17 7
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     451 <gsl_matrix_complex_fwrite+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    40e <gsl_matrix_complex_fwrite+0x4e>
jmp    440 <gsl_matrix_complex_fwrite+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     440 <gsl_matrix_complex_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  425 <gsl_matrix_complex_fwrite+0x65>
test   %eax,%eax
je     400 <gsl_matrix_complex_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   474 <gsl_matrix_complex_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_fwrite (FILE * stream, const gsl_matrix_complex * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_raw_fwrite (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%esi
push   %rbx
sub    $0x18,%rsp
callq  900 <recutl_read_file+0x10>
test   %rax,%rax
mov    %rax,%rbx
je     930 <recutl_read_file+0x40>
lea    0x8(%rsp),%rsi
mov    %rax,%rdi
callq  915 <recutl_read_file+0x25>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  920 <recutl_read_file+0x30>
add    $0x18,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
xor    %ebp,%ebp
jmp    920 <recutl_read_file+0x30>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
recutl_read_file (char *file_name)
{
  char *result;
  FILE *in;
  result = ((void *)0);
  in = fopen (file_name, "r");
  if (in)
    {
      size_t file_size;
      result = fread_file (in, &file_size);
      fclose (in);
    }
  return result;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 6
6 7
7 6
8 7
9 10
10 10
11 10
12 11
13 10
14 11
15 14
16 14
17 14
18 14
19 14
20 14
21 5
22 5
23 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x2018,%rsp
mov    %rsp,%rdi
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
callq  257a <doShellEscape+0x2a>
mov    $0x2000,%edx
mov    %rsp,%rsi
mov    %rbx,%rdi
movb   $0x0,(%rsp,%rbp,1)
callq  2470 <expandU>
test   %eax,%eax
je     25b8 <doShellEscape+0x68>
mov    0x2008(%rsp),%rsi
xor    %fs:0x28,%rsi
jne    2666 <doShellEscape+0x116>
add    $0x2018,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    %rsp,%rdi
callq  25c5 <doShellEscape+0x75>
test   %rax,%rax
mov    %rax,%rbp
je     2650 <doShellEscape+0x100>
cmpq   $0x0,0x10(%rbx)
jne    25fc <doShellEscape+0xac>
jmp    2609 <doShellEscape+0xb9>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rcx
mov    %al,(%rcx)
mov    0x10(%rbx),%rax
addq   $0x1,0x8(%rbx)
lea    -0x1(%rax),%rdx
test   %rdx,%rdx
mov    %rdx,0x10(%rbx)
je     2609 <doShellEscape+0xb9>
mov    %rbp,%rdi
callq  2604 <doShellEscape+0xb4>
cmp    $0xffffffff,%eax
jne    25e0 <doShellEscape+0x90>
mov    %rbp,%rdi
callq  2611 <doShellEscape+0xc1>
mov    0x8(%rbx),%rax
movzbl -0x1(%rax),%edx
cmp    $0xa,%dl
jne    265a <doShellEscape+0x10a>
xchg   %ax,%ax
lea    -0x1(%rax),%rdx
mov    %rdx,0x8(%rbx)
movb   $0x0,(%rax)
mov    0x8(%rbx),%rax
addq   $0x1,0x10(%rbx)
movzbl -0x1(%rax),%edx
cmp    $0xd,%dl
je     2620 <doShellEscape+0xd0>
cmp    $0xa,%dl
je     2620 <doShellEscape+0xd0>
xor    %eax,%eax
jmpq   2592 <doShellEscape+0x42>
nopl   0x0(%rax)
mov    $0x1,%eax
jmpq   2592 <doShellEscape+0x42>
cmp    $0xd,%dl
je     2620 <doShellEscape+0xd0>
xor    %eax,%eax
jmpq   2592 <doShellEscape+0x42>
callq  266b <doShellEscape+0x11b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doShellEscape(MacroBuf *mb, const char *cmd, size_t clen)
{
 char pcmd[8192];
 FILE *shf;
 int rc;
 int c;
 strncpy(pcmd, cmd, clen);
 pcmd[clen] = '\0';
 rc = expandU(mb, pcmd, sizeof(pcmd));
 if (rc)
  return rc;
 if ((shf = popen(pcmd, "r")) == ((void *)0))
  return 1;
 while(mb->nb > 0 && (c = fgetc(shf)) != (-1))
  { *(mb)->t = (c), (mb)->t++, (mb)->nb--; };
 pclose(shf);
 while (((mb->t[-1]) == '\n' || (mb->t[-1]) == '\r')) {
  *(mb->t--) = '\0';
  mb->nb++;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 2
8 2
9 2
10 7
11 9
12 9
13 9
14 8
15 9
16 10
17 10
18 22
19 22
20 22
21 22
22 22
23 22
24 22
25 22
26 12
27 12
28 12
29 12
30 12
31 12
32 14
33 14
34 14
35 14
36 15
37 15
38 15
39 15
40 15
41 14
42 15
43 14
44 14
45 14
46 14
47 14
48 16
49 16
50 17
51 17
52 17
53 17
54 17
55 18
56 18
57 18
58 17
59 19
60 17
61 17
62 17
63 17
64 17
65 21
66 21
67 21
68 13
69 13
70 17
71 17
72 21
73 21
74 22
75 22
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    (%rsi),%rbx
test   %rbx,%rbx
je     7be <addlists+0x3e>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
add    $0x8,%rbp
callq  7a4 <addlists+0x24>
mov    %rbx,%rsi
mov    %r12,%rdi
mov    %rax,%rdx
callq  650 <enlist>
mov    0x0(%rbp),%rbx
mov    %rax,%r12
test   %rbx,%rbx
jne    798 <addlists+0x18>
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addlists (char **old, char **new)
{
  for (; *new; new++)
    old = enlist (old, *new, strlen (*new));
  return old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 3
18 4
19 3
20 3
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdi
mov    0x8(%rsi),%rcx
mov    (%rsi),%rsi
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
lea    0x8(%rdi),%rdx
add    %rcx,%rcx
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_const_imag (const gsl_vector_complex * v)
{
  gsl_vector s = {0, 0, 0, 0, 0};
  s.data = v->data + 1;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 12
5 12
6 12
7 4
8 6
9 12
10 12
11 12
12 14
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_suggest_mechanism (Gsasl * ctx, const char *mechlist)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
xorpd  %xmm1,%xmm1
test   %rcx,%rcx
jle    6b <vnorm_+0x2b>
xor    %eax,%eax
xchg   %ax,%ax
movsd  (%rsi,%rax,8),%xmm0
mulsd  (%rdx,%rax,8),%xmm0
add    $0x1,%rax
cmp    %rcx,%rax
mulsd  %xmm0,%xmm0
addsd  %xmm0,%xmm1
jne    50 <vnorm_+0x10>
cvtsi2sd %rcx,%xmm0
divsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     80 <vnorm_+0x40>
repz retq 
movapd %xmm1,%xmm0
sub    $0x8,%rsp
callq  8d <vnorm_+0x4d>
add    $0x8,%rsp
jmp    7e <vnorm_+0x3e>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vnorm_(long *n, double *v, double *w)
{
  register double d__1;
  register long i;
  register double sum;
  sum = 0.0;
  for (i = 0; i < *n; ++i) {
    d__1 = v[i] * w[i];
    sum += d__1 * d__1;
  }
  return sqrt(sum / (double) (*n));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 8
8 8
9 7
10 7
11 9
12 9
13 7
14 11
15 11
16 11
17 11
18 11
19 12
20 11
21 2
22 11
23 12
24 12
25 12
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r8d
mov    %rdx,%r12
mov    $0x28,%ecx
mov    $0x28,%edx
push   %rbp
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %ebp,%esi
and    $0x7,%esi
or     $0xffffffb8,%esi
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
mov    %sil,(%rax)
mov    (%rbx),%rax
lea    0x8(%rax),%rdx
mov    %rdx,(%rbx)
mov    %r12,(%rax)
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
_movi_p(jit_state_t *_jit, jit_int32_t r0, jit_word_t i0)
{
    _rex(_jit, 0, 1, _NOREG, _NOREG, r0);
    *_jit->pc.uc++ = 0xb8 | ((r0) & 7);
    *_jit->pc.ul++ = i0;
    return (_jit->pc.w);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 2
7 2
8 3
9 2
10 2
11 3
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
23 6
24 7
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  1f9f <gsl_matrix_ulong_calloc+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     1fe8 <gsl_matrix_ulong_calloc+0x58>
imul   %r12,%rbp
mov    0x18(%rax),%rdi
xor    %esi,%esi
lea    0x0(,%rbp,8),%r12
mov    %r12,%rdx
callq  1fc1 <gsl_matrix_ulong_calloc+0x31>
test   %rbp,%rbp
je     1fe0 <gsl_matrix_ulong_calloc+0x50>
mov    0x18(%rbx),%rcx
lea    (%r12,%rcx,1),%rdx
xchg   %ax,%ax
movq   $0x0,(%rcx)
add    $0x8,%rcx
cmp    %rdx,%rcx
jne    1fd0 <gsl_matrix_ulong_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    1fe3 <gsl_matrix_ulong_calloc+0x53>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_ulong_calloc (const size_t n1, const size_t n2)
{
  size_t i;
  gsl_matrix_ulong * m = gsl_matrix_ulong_alloc (n1, n2);
  if (m == 0)
    return 0;
  memset(m->data, 0, 1 * n1 * n2 * sizeof(unsigned long));
  for (i = 0; i < 1 * n1 * n2; i++)
    {
      m->data[i] = 0;
    }
  return m;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 8
24 8
25 8
26 13
27 13
28 13
29 13
30 6
31 6
32 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
mov    $0xc0800000,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  ed74 <_sse_beqi_d+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r14d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  e500 <_sse_movi_d>
mov    0x0(%rbp),%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
and    $0x7fff,%ecx
callq  1cd0 <_sse_beqr_d>
mov    %r14d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  edc2 <_sse_beqi_d+0x72>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_beqi_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_beqr_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    $0x10,%edi
jmpq   49a <new_exclude+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
new_exclude (void)
{
  return xzalloc (sizeof *new_exclude ());
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     1a <__gmpz_fits_ushort_p+0x1a>
xor    %al,%al
cmp    $0x1,%rdx
je     20 <__gmpz_fits_ushort_p+0x20>
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
cmpq   $0xffff,(%rcx)
setbe  %al
retq   
<<<sep_in_sample>>>
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (32767 * 2 + 1)));;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 3
12 3
13 3
14 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %esi,%r13d
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %esi,%esi
mov    %rdx,0x8(%rsp)
mov    %ecx,0x4(%rsp)
jle    d00 <puttest+0xd0>
mov    0x4(%rsp),%eax
mov    0x8(%rsp),%rdx
lea    0x1(%rdi),%r12
mov    $0x1,%ebp
sub    $0x2,%eax
lea    0x8(%rdx,%rax,4),%rbx
nopl   0x0(%rax)
movzbl (%r12),%eax
cmp    $0x6e,%al
je     c7d <puttest+0x4d>
cmp    $0x63,%al
jne    cf0 <puttest+0xc0>
cmpl   $0x1,0x4(%rsp)
jle    cf0 <puttest+0xc0>
mov    0x8(%rsp),%rax
mov    %ebp,%r14d
lea    0x4(%rax),%r15
mov    $0x1,%eax
jmp    cd2 <puttest+0xa2>
nopw   0x0(%rax,%rax,1)
mov    $0x20,%edi
callq  caa <puttest+0x7a>
movslq (%r15),%rsi
mov    0x0(%rip),%rax        # cb4 <puttest+0x84>
mov    (%rax,%rsi,8),%rdi
mov    0x0(%rip),%rsi        # cbf <puttest+0x8f>
callq  cc4 <puttest+0x94>
xor    %eax,%eax
add    $0x4,%r15
sar    %r14d
cmp    %rbx,%r15
je     cf0 <puttest+0xc0>
test   $0x1,%r14b
je     cc6 <puttest+0x96>
test   %eax,%eax
mov    0x0(%rip),%rsi        # ce1 <puttest+0xb1>
jne    ca0 <puttest+0x70>
mov    $0x2a,%edi
callq  ced <puttest+0xbd>
jmp    caa <puttest+0x7a>
nop
add    $0x1,%ebp
add    $0x1,%r12
cmp    %ebp,%r13d
jge    c70 <puttest+0x40>
mov    0x0(%rip),%rsi        # d07 <puttest+0xd7>
add    $0x18,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   d1f <puttest+0xef>
nop
<<<sep_in_sample>>>
puttest(char *testv, int ntest, int *varv, int nvars)
{
  int t;
  int v;
  int bits;
  int first;
  for (t = 1; t <= ntest; t++)
    {
      if (testv[t] == 'c' || testv[t] == 'n')
 {
   for (bits = t, v = 1, first = 1; v < nvars; bits = (bits >> 1), v++)
     {
       if (bits & 0x1)
  {
    if (first)
      {
        _IO_putc (' ', dap_lst);
        first = 0;
      }
    else
      _IO_putc ('*', dap_lst);
    fprintf(dap_lst, "%s", dap_obs[0].do_nam[varv[v]]);
  }
     }
 }
    }
  _IO_putc ('\n', dap_lst);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 7
10 2
11 2
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 9
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 17
34 17
35 22
36 22
37 22
38 22
39 22
40 22
41 22
42 11
43 11
44 11
45 13
46 13
47 15
48 17
49 15
50 21
51 21
52 21
53 21
54 7
55 7
56 7
57 7
58 27
59 28
60 27
61 28
62 28
63 28
64 28
65 28
66 28
67 27
68 27
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
test   %eax,%eax
je     2f0 <output_char+0x10>
repz retq 
nopl   0x0(%rax)
mov    0x8(%rdi),%rdi
movsbl %sil,%esi
jmpq   2fd <output_char+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
output_char (struct output * out, unsigned char c)
{
  if (out->to_void)
    return;
  ds_strccat (out->chunk, c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%edx
xor    %eax,%eax
mov    $0x0,%esi
callq  231 <f_uint+0x11>
mov    %ebx,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_uint (FILE *fp, void *ptr, int size) { fprintf (fp, "%u", *(unsigned*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  2642 <gsl_stats_short_sd+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   2654 <gsl_stats_short_sd+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_short_sd (const short data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_short_mean (data, stride, n);
  return gsl_stats_short_sd_m (data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
cmp    0x8(%rdi),%r11
je     2b2a <gsl_matrix_long_transpose+0x2a>
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b23 <gsl_matrix_long_transpose+0x23>
mov    $0x14,%eax
pop    %rbx
retq   
test   %r11,%r11
je     2b8e <gsl_matrix_long_transpose+0x8e>
xor    %esi,%esi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
je     2b8e <gsl_matrix_long_transpose+0x8e>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rdi),%r8
mov    %rbx,%rax
nopw   0x0(%rax,%rax,1)
mov    0x10(%rdi),%rdx
mov    %rsi,%rcx
imul   %rdx,%rcx
imul   %rax,%rdx
add    %rax,%rcx
add    $0x1,%rax
add    %rsi,%rdx
lea    (%r8,%rcx,8),%rcx
cmp    %r11,%rax
lea    (%r8,%rdx,8),%rdx
mov    (%rcx),%r9
mov    (%rdx),%r10
mov    %r10,(%rcx)
mov    %r9,(%rdx)
jne    2b50 <gsl_matrix_long_transpose+0x50>
mov    %rbx,%rsi
lea    0x1(%rsi),%rbx
cmp    %r11,%rbx
jne    2b40 <gsl_matrix_long_transpose+0x40>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_transpose (gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                long tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 16
24 16
25 16
26 17
27 16
28 12
29 17
30 19
31 12
32 20
33 19
34 20
35 20
36 21
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
45 27
<<<sep_out_sample>>>
sub    $0x38,%rsp
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm0        # c50 <gsl_complex_tan+0x10>
movsd  0x0(%rip),%xmm6        # c58 <gsl_complex_tan+0x18>
andpd  %xmm1,%xmm0
ucomisd %xmm0,%xmm6
ja     d50 <gsl_complex_tan+0x110>
movsd  0x0(%rip),%xmm0        # c6e <gsl_complex_tan+0x2e>
movsd  %xmm1,0x28(%rsp)
xorpd  %xmm1,%xmm0
movsd  %xmm3,0x10(%rsp)
callq  c83 <gsl_complex_tan+0x43>
movapd %xmm0,%xmm2
movapd %xmm0,%xmm4
movsd  0x10(%rsp),%xmm3
mulsd  %xmm0,%xmm2
addsd  %xmm0,%xmm4
movsd  0x0(%rip),%xmm0        # ca1 <gsl_complex_tan+0x61>
movsd  %xmm3,0x20(%rsp)
subsd  %xmm2,%xmm0
divsd  %xmm0,%xmm4
movapd %xmm3,%xmm0
movsd  %xmm4,0x8(%rsp)
callq  cbe <gsl_complex_tan+0x7e>
movsd  0x8(%rsp),%xmm4
movapd %xmm0,%xmm2
movsd  0x28(%rsp),%xmm1
mulsd  %xmm4,%xmm4
mulsd  %xmm0,%xmm2
movapd %xmm1,%xmm0
movsd  %xmm4,0x18(%rsp)
mulsd  %xmm4,%xmm2
addsd  0x0(%rip),%xmm2        # cec <gsl_complex_tan+0xac>
movsd  %xmm2,0x10(%rsp)
callq  cf7 <gsl_complex_tan+0xb7>
movsd  0x20(%rsp),%xmm3
movsd  %xmm0,0x8(%rsp)
movapd %xmm3,%xmm5
addsd  %xmm3,%xmm5
movapd %xmm5,%xmm0
callq  d14 <gsl_complex_tan+0xd4>
movsd  0x0(%rip),%xmm3        # d1c <gsl_complex_tan+0xdc>
movsd  0x18(%rsp),%xmm4
mulsd  %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # d2e <gsl_complex_tan+0xee>
movsd  0x10(%rsp),%xmm2
divsd  0x8(%rsp),%xmm1
add    $0x38,%rsp
mulsd  %xmm4,%xmm3
divsd  %xmm2,%xmm3
divsd  %xmm2,%xmm1
movapd %xmm3,%xmm0
retq   
nop
movapd %xmm3,%xmm0
movsd  %xmm3,0x10(%rsp)
movsd  %xmm1,0x18(%rsp)
callq  d65 <gsl_complex_tan+0x125>
movsd  0x18(%rsp),%xmm1
movsd  %xmm0,0x8(%rsp)
movapd %xmm1,%xmm0
callq  d7a <gsl_complex_tan+0x13a>
movsd  0x8(%rsp),%xmm4
movapd %xmm0,%xmm2
movsd  0x10(%rsp),%xmm3
mulsd  %xmm4,%xmm4
mulsd  %xmm0,%xmm2
movapd %xmm3,%xmm0
addsd  %xmm3,%xmm0
addsd  %xmm4,%xmm2
movsd  %xmm2,0x8(%rsp)
callq  da9 <gsl_complex_tan+0x169>
movsd  0x0(%rip),%xmm3        # db1 <gsl_complex_tan+0x171>
movsd  0x8(%rsp),%xmm2
mulsd  %xmm0,%xmm3
movsd  0x18(%rsp),%xmm1
movsd  %xmm2,0x10(%rsp)
movapd %xmm1,%xmm0
divsd  %xmm2,%xmm3
addsd  %xmm1,%xmm0
movsd  %xmm3,0x8(%rsp)
callq  dde <gsl_complex_tan+0x19e>
movsd  0x0(%rip),%xmm1        # de6 <gsl_complex_tan+0x1a6>
movsd  0x10(%rsp),%xmm2
mulsd  %xmm0,%xmm1
movsd  0x8(%rsp),%xmm3
add    $0x38,%rsp
movapd %xmm3,%xmm0
divsd  %xmm2,%xmm1
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_tan (gsl_complex a)
{
  double R = ((a).dat[0]), I = ((a).dat[1]);
  gsl_complex z;
  if (fabs (I) < 1)
    {
      double D = pow (cos (R), 2.0) + pow (sinh (I), 2.0);
      do {(&z)->dat[0]=(0.5 * sin (2 * R) / D); (&z)->dat[1]=(0.5 * sinh (2 * I) / D);} while(0);
    }
  else
    {
      double u = exp (-I);
      double C = 2 * u / (1 - pow (u, 2.0));
      double D = 1 + pow (cos (R), 2.0) * pow (C, 2.0);
      double S = pow (C, 2.0);
      double T = 1.0 / tanh (I);
      do {(&z)->dat[0]=(0.5 * sin (2 * R) * S / D); (&z)->dat[1]=(T / D);} while(0);
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 12
9 12
10 12
11 12
12 12
13 13
14 13
15 14
16 13
17 13
18 13
19 14
20 13
21 13
22 14
23 13
24 14
25 14
26 14
27 16
28 14
29 14
30 16
31 14
32 14
33 14
34 14
35 16
36 17
37 16
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 16
46 17
47 16
48 20
49 17
50 17
51 17
52 20
53 20
54 20
55 7
56 7
57 7
58 7
59 7
60 7
61 7
62 7
63 7
64 7
65 8
66 7
67 7
68 8
69 8
70 7
71 7
72 8
73 8
74 8
75 8
76 8
77 8
78 8
79 8
80 8
81 8
82 8
83 8
84 8
85 8
86 8
87 20
88 20
89 8
90 20
91 20
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   1c89 <xformat_get_mode+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_get_mode (XFORMAT * xux)
{
 ;
 return ahs_get_mode(xux->ahsM);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%dil
setbe  %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_digit_p (char c)
{
  return ((c >= '0') && (c <= '9'));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xor    %eax,%eax
test   %edi,%edi
je     9f3 <_rl_vi_motion_command+0x23>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  9e6 <_rl_vi_motion_command+0x16>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_motion_command (c)
     int c;
{
  return (((c) ? (char *)strchr ((vi_motion), (c)) != (char *)((void *)0) : 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 4
12 5
13 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x8(%rdi),%rax
mov    %rdi,%rbx
test   %rax,%rax
je     1a8 <smtp_reply_alloc_space+0x58>
mov    0x10(%rdi),%rdx
lea    0x1(%rsi,%rdx,1),%rdx
cmp    %rdx,%rax
ja     19d <smtp_reply_alloc_space+0x4d>
lea    0x8(%rdi),%r12
mov    (%rdi),%rdi
jmp    183 <smtp_reply_alloc_space+0x33>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdi
mov    %r12,%rsi
callq  18b <smtp_reply_alloc_space+0x3b>
mov    0x10(%rbx),%rdx
mov    %rax,(%rbx)
lea    0x1(%rbp,%rdx,1),%rdx
cmp    0x8(%rbx),%rdx
jae    180 <smtp_reply_alloc_space+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
lea    0x1(%rsi),%rdi
mov    %rdi,0x8(%rbx)
callq  1b5 <smtp_reply_alloc_space+0x65>
mov    %rax,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
smtp_reply_alloc_space (ANUBIS_SMTP_REPLY reply, size_t len)
{
  if (reply->buffer_size == 0)
    {
      reply->buffer_size = len + 1;
      reply->buffer = xmalloc (reply->buffer_size);
    }
  else
    while (reply->reply_length + len + 1 >= reply->buffer_size)
      reply->buffer = x2realloc (reply->buffer, &reply->buffer_size);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 3
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 9
21 10
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 5
31 5
32 6
33 6
34 11
35 11
36 11
37 11
38 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  411 <xdr_dis_entity_id+0x11>
xor    %edx,%edx
test   %eax,%eax
je     42a <xdr_dis_entity_id+0x2a>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  423 <xdr_dis_entity_id+0x23>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_entity_id(xdrs, objp)
	XDR *xdrs;
	dis_entity_id *objp;
{
	if (!xdr_dis_simulation_addr(xdrs, &objp->sim_id)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->entity_id)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 6
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_gradient (const gsl_multimin_fdfminimizer * s)
{
  return s->gradient;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 63ca <unfreeze_jobs_list+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unfreeze_jobs_list ()
{
  jobs_list_frozen = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
mov    $0xc0800000,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  e154 <_sse_bunordi_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r14d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  cad0 <_sse_movi_f>
mov    0x0(%rbp),%ecx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
and    $0x7fff,%ecx
callq  2630 <_sse_bunordr_f>
mov    %r14d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  e1a2 <_sse_bunordi_f+0x72>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_bunordi_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bunordr_f(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 76 <alloc_word_desc+0x6>
test   %eax,%eax
jle    a0 <alloc_word_desc+0x30>
mov    0x0(%rip),%rdx        # 81 <alloc_word_desc+0x11>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 8a <alloc_word_desc+0x1a>
cltq   
mov    (%rdx,%rax,8),%rax
movl   $0x0,0x8(%rax)
movq   $0x0,(%rax)
retq   
nop
sub    $0x8,%rsp
mov    $0x58,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  b8 <alloc_word_desc+0x48>
movl   $0x0,0x8(%rax)
movq   $0x0,(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alloc_word_desc ()
{
  WORD_DESC *temp;
  do { if ((wdcache).nc > 0) { (temp) = (WORD_DESC *)((WORD_DESC **)((wdcache).data))[--(wdcache).nc]; } else (temp) = (WORD_DESC *)sh_xmalloc((sizeof (WORD_DESC)), "make_cmd.c", 88); } while (0);
  temp->flags = 0;
  temp->word = 0;
  return temp;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 8
12 8
13 2
14 4
15 4
16 4
17 4
18 5
19 6
20 8
21 8
22 8
<<<sep_out_sample>>>
cmp    $0x9,%edi
ja     190 <face_eo_ps+0xb0>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
nopw   0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
xchg   %ax,%ax
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    %edi,%ecx
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
callq  1a9 <face_eo_ps+0xc9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
face_eo_ps (enum face_e face)
{
  switch (face) {
  case Plain:
    return "p";
  case Symbol:
    return "sy";
  case Keyword:
    return "k";
  case Keyword_strong:
    return "K";
  case Comment:
    return "c";
  case Comment_strong:
    return "C";
  case Label:
    return "l";
  case Label_strong:
    return "L";
  case String:
    return "str";
  case Error:
    return "e";
  default:
    error (1, 0, "face_eo_ps: %d", face);
  }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 23
10 28
11 28
12 13
13 13
14 13
15 15
16 15
17 15
18 5
19 5
20 5
21 9
22 9
23 9
24 11
25 11
26 11
27 17
28 17
29 17
30 19
31 19
32 19
33 21
34 21
35 21
36 2
37 25
38 25
39 25
40 25
41 25
42 25
43 27
44 28
45 28
<<<sep_out_sample>>>
movl   $0x5,0x40(%rdi)
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x30(%rdi)
movq   $0x0,0x38(%rdi)
movq   $0x0,0x20(%rdi)
movl   $0x0,0x44(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
null_array(NODE *symbol)
{
 symbol->type = Node_var_array;
 symbol->sub.nodep.l.lp = null_array_func;
 symbol->sub.nodep.r.bv = ((void *)0);
 symbol->sub.nodep.reflags = symbol->sub.nodep.cnt = 0;
 symbol->sub.nodep.reserved = 0;
 symbol->flags = 0;
 ((void) (0));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
sub    %esi,%ecx
sub    %edi,%edx
lea    (%rcx,%rcx,2),%eax
lea    (%rdx,%rax,4),%eax
cltq   
retq   
nopl   (%rax)
<<<sep_in_sample>>>
m_between (m1, y1, m2, y2)
     const int m1;
     const int y1;
     const int m2;
     const int y2;
{
  return (((y2 - y1) * 12) + (m2 - m1));
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 8
7 8
<<<sep_out_sample>>>
push   %rbx
movslq %edi,%rbx
sub    $0x90,%rsp
mov    0x0(%rip),%rax        # 12 <update_mail_file+0x12>
mov    %rsp,%rsi
mov    (%rax,%rbx,8),%rax
mov    (%rax),%rdi
callq  21 <update_mail_file+0x21>
test   %eax,%eax
mov    0x0(%rip),%rax        # 2a <update_mail_file+0x2a>
mov    (%rax,%rbx,8),%rax
je     60 <update_mail_file+0x60>
movq   $0x0,0x18(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x20(%rax)
movl   $0x0,0x28(%rax)
add    $0x90,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x48(%rsp),%rdx
mov    %rdx,0x10(%rax)
mov    0x58(%rsp),%rdx
mov    %rdx,0x18(%rax)
mov    0x30(%rsp),%rdx
orl    $0x1,0x28(%rax)
mov    %rdx,0x20(%rax)
add    $0x90,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
update_mail_file (i)
     int i;
{
  char *file;
  struct stat finfo;
  file = mailfiles[i]->name;
  if (mailstat (file, &finfo) == 0)
    do { mailfiles[i]->access_time = finfo.st_atim.tv_sec; mailfiles[i]->mod_time = finfo.st_mtim.tv_sec; mailfiles[i]->file_size = finfo.st_size; mailfiles[i]->flags |= 0x01; } while (0);
  else
    do { mailfiles[i]->access_time = mailfiles[i]->mod_time = 0; mailfiles[i]->file_size = 0; mailfiles[i]->flags = 0; } while (0);
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 6
5 7
6 6
7 7
8 7
9 7
10 8
11 8
12 7
13 10
14 10
15 10
16 10
17 11
18 11
19 11
20 11
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isupper (int c)
{
  switch (c)
    {
    case 'a' + ('A' - 'a'): case 'b' + ('A' - 'a'): case 'c' + ('A' - 'a'): case 'd' + ('A' - 'a'): case 'e' + ('A' - 'a'): case 'f' + ('A' - 'a'): case 'g' + ('A' - 'a'): case 'h' + ('A' - 'a'): case 'i' + ('A' - 'a'): case 'j' + ('A' - 'a'): case 'k' + ('A' - 'a'): case 'l' + ('A' - 'a'): case 'm' + ('A' - 'a'): case 'n' + ('A' - 'a'): case 'o' + ('A' - 'a'): case 'p' + ('A' - 'a'): case 'q' + ('A' - 'a'): case 'r' + ('A' - 'a'): case 's' + ('A' - 'a'): case 't' + ('A' - 'a'): case 'u' + ('A' - 'a'): case 'v' + ('A' - 'a'): case 'w' + ('A' - 'a'): case 'x' + ('A' - 'a'): case 'y' + ('A' - 'a'): case 'z' + ('A' - 'a'):
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_open_netbsd(const char *source_name)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
lea    -0x30(%rdi),%eax
cmp    $0x9,%al
jbe    d0 <mu_hex2ul+0x30>
lea    -0x61(%rdi),%eax
cmp    $0x19,%al
jbe    c0 <mu_hex2ul+0x20>
lea    -0x41(%rdi),%edx
mov    $0xffffffffffffffff,%rax
cmp    $0x19,%dl
jbe    e0 <mu_hex2ul+0x40>
repz retq 
nop
movsbl %dil,%eax
sub    $0x57,%eax
cltq   
retq   
nopw   0x0(%rax,%rax,1)
movsbl %dil,%eax
sub    $0x30,%eax
cltq   
retq   
nopw   0x0(%rax,%rax,1)
movsbl %dil,%eax
sub    $0x37,%eax
cltq   
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_hex2ul (char hex)
{
  if (hex >= '0' && hex <= '9')
   return hex - '0';
  if (hex >= 'a' && hex <= 'z')
    return hex - 'a' + 10;
  if (hex >= 'A' && hex <= 'Z')
    return hex - 'A' + 10;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 7
8 9
9 7
10 7
11 10
12 10
13 6
14 6
15 6
16 6
17 6
18 4
19 4
20 4
21 4
22 4
23 8
24 8
25 8
26 10
27 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  15b9 <yy_scan_string+0x9>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   15c4 <yy_scan_string+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xd8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,
                                       elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     6d3 <mu_list_get_comparator+0x13>
mov    0x28(%rdi),%rax
mov    %rax,(%rsi)
xor    %eax,%eax
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_get_comparator (mu_list_t list, mu_list_comparator_t *comp)
{
  if (!list)
    return 22;
  *comp = list->comp;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 5
6 6
7 7
8 7
<<<sep_out_sample>>>
cmp    %rsi,(%rdi)
jb     250 <list_item+0x30>
test   %rsi,%rsi
mov    0x8(%rdi),%rax
je     249 <list_item+0x29>
test   %rax,%rax
jne    23d <list_item+0x1d>
jmp    249 <list_item+0x29>
nopl   (%rax)
test   %rsi,%rsi
je     249 <list_item+0x29>
mov    (%rax),%rax
sub    $0x1,%rsi
test   %rax,%rax
jne    238 <list_item+0x18>
mov    0x8(%rax),%rax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
list_item (struct list *list, size_t n)
{
  struct list_entry *p;
  if (n > list->count)
    return ((void *)0);
  for (p = list->head; n > 0 && p; p = p->next, n--)
    ;
  return p->data;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 5
20 9
21 9
<<<sep_out_sample>>>
movzbl 0xaa(%rdi),%eax
shr    $0x2,%al
and    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
term_ostream__get_weight (term_ostream_t stream)
{
  return stream->curr_attr.weight;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rsi,0x98(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topsf_set_mtime(TOPSF * topsf, time_t tm)
{
 topsf->mtimeM = tm;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
mov    %rdi,%r14
mov    %rsi,%rdi
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     4040 <gsl_block_uchar_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
mov    %rsi,%rbx
jne    3fec <gsl_block_uchar_raw_fwrite+0x3c>
jmp    4030 <gsl_block_uchar_raw_fwrite+0x80>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r13,%rbx
cmp    %r12,%rbp
je     4030 <gsl_block_uchar_raw_fwrite+0x80>
mov    %r14,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  4001 <gsl_block_uchar_raw_fwrite+0x51>
cmp    $0x1,%rax
je     3fe0 <gsl_block_uchar_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4020 <gsl_block_uchar_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r14,%rcx
mov    $0x1,%esi
callq  404d <gsl_block_uchar_raw_fwrite+0x9d>
cmp    %r12,%rax
je     4030 <gsl_block_uchar_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  406b <gsl_block_uchar_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    4025 <gsl_block_uchar_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uchar_raw_fwrite (FILE * stream, const unsigned char * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 1 * sizeof (unsigned char), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 1 * i * stride,
                                1 * sizeof (unsigned char),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
mov    %rdi,%rsi
xor    %eax,%eax
xor    %edi,%edi
jmpq   197c <statusbar+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
statusbar(const char *msg)
{
    statusline(HUSH, msg);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
jmpq   1c55 <php_alloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_alloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    $0x100,%ecx
jmpq   1a <lchmodat+0xa>
<<<sep_in_sample>>>
lchmodat (int fd, char const *file, mode_t mode)
{
  return fchmodat (fd, file, mode, 0x100);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 99b <dicod_add_command+0xb>
test   %rdi,%rdi
je     9b0 <dicod_add_command+0x20>
mov    %rbx,%rsi
pop    %rbx
jmpq   9a9 <dicod_add_command+0x19>
nopl   0x0(%rax)
callq  9b5 <dicod_add_command+0x25>
mov    $0x0,%esi
mov    %rax,%rdi
mov    %rax,0x0(%rip)        # 9c4 <dicod_add_command+0x34>
callq  9c9 <dicod_add_command+0x39>
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 9d3 <dicod_add_command+0x43>
pop    %rbx
jmpq   9d9 <dicod_add_command+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dicod_add_command(struct dicod_command *cmd)
{
    if (!command_list) {
 command_list = xdico_list_create();
 dico_list_set_comparator(command_list, _cmd_arg_cmp);
    }
    xdico_list_append(command_list, cmd);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 7
7 8
8 7
9 7
10 4
11 5
12 5
13 4
14 5
15 7
16 7
17 8
18 7
19 7
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
test   %esi,%esi
js     4735 <info_prev_line+0x55>
cmpq   $0xffffffffffffffff,0x28(%rdi)
je     4720 <info_prev_line+0x40>
test   %esi,%esi
mov    %esi,%ebx
je     470d <info_prev_line+0x2d>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  4630 <point_prev_line>
sub    $0x1,%ebx
jne    4700 <info_prev_line+0x20>
add    $0x18,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   450 <move_to_goal_column>
nopl   0x0(%rax,%rax,1)
mov    %esi,0xc(%rsp)
callq  4729 <info_prev_line+0x49>
cltq   
mov    0xc(%rsp),%esi
mov    %rax,0x28(%rbp)
jmp    46f4 <info_prev_line+0x14>
add    $0x18,%rsp
neg    %esi
pop    %rbx
pop    %rbp
jmpq   4742 <info_prev_line+0x62>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_prev_line (WINDOW *window, int count)
{
  if (count < 0)
    info_next_line (window, -count);
  else
    {
      if (window->goal_column == -1)
        window->goal_column = window_get_cursor_column (window);
      while (count--)
        point_prev_line (window);
      move_to_goal_column (window);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 7
8 7
9 9
10 9
11 9
12 9
13 10
14 10
15 9
16 9
17 13
18 11
19 13
20 13
21 11
22 11
23 11
24 8
25 8
26 8
27 8
28 8
29 13
30 4
31 13
32 13
33 4
34 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     ab <debug_print+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rsi
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # c2 <debug_print+0x72>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  e6 <debug_print+0x96>
add    $0xd8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
debug_print(const char *s, ...)
{
 va_list ap;
 __builtin_va_start(ap,s);
 (void)vfprintf(stderr, s, ap);
 __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 2
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 7
28 7
29 7
<<<sep_out_sample>>>
cmp    $0x12,%dil
ja     408 <process_slc+0x68>
test   %dil,%dil
jne    3c0 <process_slc+0x20>
and    $0x3,%esi
cmp    $0x3,%sil
je     430 <process_slc+0x90>
cmp    $0x2,%sil
je     428 <process_slc+0x88>
repz retq 
nopl   0x0(%rax)
mov    %esi,%eax
movzbl %dil,%edi
mov    %esi,%r8d
and    $0xffffff80,%eax
and    $0x3,%r8d
movzbl %al,%r9d
movslq %edi,%rax
shl    $0x4,%rax
lea    0x0(%rax),%rcx
movzbl 0x0(%rax),%eax
and    $0x3,%eax
cmp    %al,%r8b
je     418 <process_slc+0x78>
test   %r9d,%r9d
jne    3ba <process_slc+0x1a>
movzbl %dl,%edx
movsbl %sil,%esi
jmpq   402 <process_slc+0x62>
nopw   0x0(%rax,%rax,1)
movsbl %dil,%edi
xor    %edx,%edx
xor    %esi,%esi
jmpq   415 <process_slc+0x75>
nopl   (%rax)
cmp    %dl,0x3(%rcx)
je     3ba <process_slc+0x1a>
test   %r9d,%r9d
je     3f6 <process_slc+0x56>
repz retq 
nopl   0x0(%rax)
jmpq   42d <process_slc+0x8d>
nopl   (%rax)
callq  435 <process_slc+0x95>
jmpq   43a <process_slc+0x9a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
process_slc (register unsigned char func, register unsigned char flag,
      register cc_t val)
{
  register int hislevel, mylevel, ack;
  if (func > 18)
    {
      add_slc (func, 0, 0);
      return;
    }
  if (func == 0)
    {
      if ((flag = flag & 0x03) == 3)
 {
   default_slc ();
   send_slc ();
 }
      else if (flag == 2)
 {
   send_slc ();
 }
      return;
    }
  hislevel = flag & 0x03;
  mylevel = slctab[func].current.flag & 0x03;
  ack = flag & 0x80;
  if (hislevel == mylevel && (val == slctab[func].current.val || ack))
    {
      return;
    }
  else if (ack)
    {
      return;
    }
  else
    {
      change_slc (func, flag, val);
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 10
4 10
5 12
6 12
7 12
8 17
9 17
10 17
11 17
12 25
13 24
14 23
15 25
16 23
17 25
18 24
19 24
20 24
21 24
22 24
23 26
24 26
25 30
26 30
27 36
28 36
29 36
30 36
31 7
32 7
33 7
34 7
35 7
36 26
37 26
38 26
39 26
40 26
41 26
42 19
43 19
44 14
45 15
46 15
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a37 <yyget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_out (void)
{
        return yyout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
test   %rdx,%rdx
mov    %rdx,0x20(%rsp)
mov    %rcx,0x28(%rsp)
mov    0x78(%rsp),%r12
jle    e2e <Do_Importance_Ratios+0xfe>
movslq 0x70(%rsp),%r15
xorpd  %xmm1,%xmm1
lea    0x0(,%rcx,8),%r14
mov    %rsi,%r13
xor    %ebx,%ebx
lea    (%r9,%r15,4),%rbp
cmpq   $0x0,0x28(%rsp)
movq   $0x0,(%r12,%rbx,8)
xorpd  %xmm0,%xmm0
jle    dd0 <Do_Importance_Ratios+0xa0>
xor    %eax,%eax
xorpd  %xmm0,%xmm0
xor    %r8d,%r8d
jmp    db5 <Do_Importance_Ratios+0x85>
nop
mov    (%r9,%r8,4),%r10d
test   %r10d,%r10d
je     da8 <Do_Importance_Ratios+0x78>
mov    (%rdi,%rbx,8),%rdx
addsd  (%rdx,%rax,1),%xmm0
movsd  %xmm0,(%r12,%rbx,8)
add    $0x1,%r8
add    $0x8,%rax
cmp    %r14,%rax
je     dd0 <Do_Importance_Ratios+0xa0>
cmpq   $0x0,0x0(%r13,%rax,1)
je     dac <Do_Importance_Ratios+0x7c>
cmp    %r8,%r15
jne    d90 <Do_Importance_Ratios+0x60>
mov    0x0(%rbp),%edx
xor    %r10d,%r10d
test   %edx,%edx
sete   %r10b
jmp    d94 <Do_Importance_Ratios+0x64>
mov    %r9,0x18(%rsp)
mov    %rdi,0x10(%rsp)
movsd  %xmm1,0x8(%rsp)
callq  de5 <Do_Importance_Ratios+0xb5>
movsd  %xmm0,(%r12,%rbx,8)
add    $0x1,%rbx
cmp    0x20(%rsp),%rbx
movsd  0x8(%rsp),%xmm1
mov    0x10(%rsp),%rdi
mov    0x18(%rsp),%r9
addsd  %xmm0,%xmm1
jne    d70 <Do_Importance_Ratios+0x40>
lea    (%r12,%rbx,8),%rax
mov    %r12,%rcx
nopl   (%rax)
movsd  (%rcx),%xmm0
add    $0x8,%rcx
divsd  %xmm1,%xmm0
movsd  %xmm0,-0x8(%rcx)
cmp    %rax,%rcx
jne    e18 <Do_Importance_Ratios+0xe8>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
Do_Importance_Ratios (double **pdY, PMCVAR *pLikes, long nSims,
                           long nPreds, long nDesignPts, int *piDesign_mask,
                           int nDesignPt_tried, double *pdIR)
{
  long i, j, k;
  double dSumL = 0;
  BOOL bOn;
  for (k = 0; k < nSims; k++) {
    pdIR[k] = 0;
    j = 0;
    for (i = 0; i < nPreds; i++) {
      if (pLikes[i] != ((void *)0)) {
        if (j == nDesignPt_tried)
          bOn = ! piDesign_mask[j];
        else
          bOn = piDesign_mask[j];
        if (bOn)
          pdIR[k] = pdIR[k] + pdY[k][i];
        j++;
      }
    }
    pdIR[k] = exp(pdIR[k]);
    dSumL = dSumL + pdIR[k];
  }
  for (k = 0; k < nSims; k++)
    pdIR[k] = pdIR[k] / dSumL;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 8
9 4
10 4
11 4
12 8
13 14
14 6
15 6
16 6
17 8
18 14
19 11
20 9
21 11
22 11
23 11
24 11
25 10
26 10
27 10
28 16
29 17
30 17
31 18
32 18
33 18
34 19
35 19
36 11
37 11
38 12
39 12
40 13
41 13
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 22
51 22
52 8
53 8
54 23
55 8
56 8
57 23
58 8
59 8
60 8
61 8
62 26
63 26
64 26
65 26
66 25
67 25
68 27
69 27
70 27
71 27
72 27
73 27
74 27
75 27
76 27
<<<sep_out_sample>>>
movzbl %dil,%eax
retq   
<<<sep_in_sample>>>
__rrank (char c)
{
  return ((unsigned char) c);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
lea    0x18(%rdi),%rcx
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
testb  $0x2,0x20(%rdi)
jne    390 <__log_newfh+0x70>
mov    0xc0(%rbx),%rax
lea    0x18(%rsp),%rdx
mov    $0x11,%r8d
mov    %rbx,%rdi
mov    0x20(%rax),%esi
mov    %esi,0x14(%rbx)
callq  353 <__log_newfh+0x33>
test   %eax,%eax
mov    %eax,%ebp
je     37b <__log_newfh+0x5b>
mov    %eax,%edi
callq  360 <__log_newfh+0x40>
mov    0x98(%rbx),%rdi
mov    0x18(%rsp),%rdx
mov    %rax,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  37b <__log_newfh+0x5b>
mov    0x18(%rsp),%rdi
callq  385 <__log_newfh+0x65>
add    $0x28,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rcx,%rdi
mov    %rcx,0x8(%rsp)
callq  39d <__log_newfh+0x7d>
mov    0x8(%rsp),%rcx
jmp    333 <__log_newfh+0x13>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__log_newfh(dblp)
 DB_LOG *dblp;
{
 LOG *lp;
 int ret;
 char *name;
 if (((&dblp->lfh)->flags & (0x02)))
  (void)CDB___os_closehandle(&dblp->lfh);
 lp = dblp->reginfo.primary;
 dblp->lfname = lp->lsn.file;
 if ((ret = CDB___log_name(dblp, dblp->lfname,
     &name, &dblp->lfh,
     0x001 | 0x010)) != 0)
  CDB___db_err(dblp->dbenv,
      "CDB_log_put: %s: %s", name, CDB_db_strerror(ret));
 CDB___os_freestr(name);
 return (ret);
}
<<<sep_in_sample>>>
1 3
2 8
3 3
4 3
5 3
6 7
7 7
8 10
9 11
10 11
11 11
12 10
13 10
14 11
15 11
16 11
17 11
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 16
27 16
28 18
29 18
30 18
31 18
32 18
33 18
34 8
35 8
36 8
37 8
38 8
39 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     248 <rewrite_cancel+0x18>
callq  241 <rewrite_cancel+0x11>
movq   $0x0,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rewrite_cancel(REWRITE *rewrite)
{
 if (rewrite->pattern) {
  free(rewrite->pattern);
  rewrite->pattern = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 7
9 7
10 7
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x88,%rsp
mov    %rsp,%rdi
callq  cf6 <swgp_signal_unblock+0x16>
mov    %ebp,%esi
mov    %rsp,%rdi
callq  d00 <swgp_signal_unblock+0x20>
mov    %rbx,%rdx
mov    %rsp,%rsi
mov    $0x1,%edi
callq  d10 <swgp_signal_unblock+0x30>
test   %eax,%eax
mov    %eax,%ebx
js     d28 <swgp_signal_unblock+0x48>
add    $0x88,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  d2d <swgp_signal_unblock+0x4d>
mov    (%rax),%edi
callq  d34 <swgp_signal_unblock+0x54>
mov    0x0(%rip),%rdi        # d3b <swgp_signal_unblock+0x5b>
mov    %rax,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  d4c <swgp_signal_unblock+0x6c>
add    $0x88,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swgp_signal_unblock(int signo, sigset_t * oset)
{
 int ret;
 sigset_t newmask;
 sigemptyset(&newmask);
 sigaddset(&newmask, signo);
 if ((ret=sigprocmask(1, &newmask, oset)) < 0)
   fprintf(stderr,
   "swgp_signal_block error, signal=%d: %s\n",
    signo, strerror((*__errno_location ())));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 12
19 12
20 12
21 12
22 12
23 12
24 10
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 12
34 12
35 12
36 12
37 12
38 12
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  10b <_s_readline+0x1b>
mov    0x8(%rsp),%r8
mov    (%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   129 <_s_readline+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_s_readline (mu_stream_t stream, char *optr, size_t osize,
      mu_off_t offset, size_t *nbytes)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_readline (s->fstream, optr, osize, offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
push   %rbx
callq  c6 <_file_destroy+0x6>
mov    0x18(%rax),%rdi
mov    %rax,%rbx
test   %rdi,%rdi
je     d7 <_file_destroy+0x17>
callq  d7 <_file_destroy+0x17>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     f1 <_file_destroy+0x31>
callq  e5 <_file_destroy+0x25>
lea    0x28(%rbx),%rdi
mov    %rax,%rsi
callq  f1 <_file_destroy+0x31>
mov    %rbx,%rdi
pop    %rbx
jmpq   fa <_file_destroy+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_file_destroy (mu_stream_t stream)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  if (fs->filename)
    free (fs->filename);
  if (fs->cache)
    mu_stream_destroy (&fs->cache, mu_stream_get_owner (fs->cache));
  free (fs);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 4
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 9
17 8
18 8
<<<sep_out_sample>>>
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x40(%rdi),%rcx
lea    0x8(%rsp),%r8
callq  eca <mu_stream_sequential_read+0x1a>
test   %eax,%eax
jne    ee0 <mu_stream_sequential_read+0x30>
mov    0x8(%rsp),%rdx
add    %rdx,0x40(%rbx)
test   %rbp,%rbp
je     ee0 <mu_stream_sequential_read+0x30>
mov    %rdx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_stream_sequential_read (mu_stream_t stream, char *buf, size_t size,
      size_t *nbytes)
{
  size_t rdbytes;
  int rc = mu_stream_read (stream, buf, size, stream->offset, &rdbytes);
  if (!rc)
    {
      stream->offset += rdbytes;
      if (nbytes)
 *nbytes = rdbytes;
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 8
12 8
13 9
14 9
15 10
16 13
17 13
18 13
19 13
20 13
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     171 <grecs_asprintf+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  1a2 <grecs_asprintf+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
grecs_asprintf(char **pbuf, size_t *psize, const char *fmt, ...)
{
 int rc;
 va_list ap;
 __builtin_va_start(ap,fmt);
 rc = grecs_vasprintf(pbuf, psize, fmt, ap);
 __builtin_va_end(ap);
 return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 6
17 5
18 5
19 5
20 5
21 5
22 6
23 9
24 9
<<<sep_out_sample>>>
push   %rbp
movabs $0x20c49ba5e353f7cf,%r10
push   %rbx
mov    %edi,%ebx
sub    $0x88,%rsp
mov    0x60(%rsi),%rcx
mov    0x48(%rsi),%r9
mov    %fs:0x28,%rax
mov    %rax,0x78(%rsp)
xor    %eax,%eax
lea    0x10(%rsp),%rbp
mov    %rcx,%rax
mov    %rcx,%rdi
mov    0x58(%rsi),%rcx
imul   %r10
mov    0x50(%rsi),%rsi
sar    $0x3f,%rdi
mov    %rsi,%rax
sar    $0x3f,%rsi
mov    %rdx,%r8
imul   %r10
sar    $0x7,%r8
xor    %eax,%eax
sub    %rdi,%r8
mov    %rbp,%rdi
sar    $0x7,%rdx
sub    %rsi,%rdx
mov    $0x62,%esi
mov    %rdx,(%rsp)
mov    $0x0,%edx
callq  aa <write_stat_time+0x7a>
mov    %rbp,%rdx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     ad <write_stat_time+0x7d>
mov    %eax,%ecx
mov    %ebx,%edi
mov    %rbp,%rsi
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmove  %rcx,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbp,%rdx
callq  ec <write_stat_time+0xbc>
mov    0x78(%rsp),%rbx
xor    %fs:0x28,%rbx
jne    106 <write_stat_time+0xd6>
add    $0x88,%rsp
pop    %rbx
pop    %rbp
retq   
callq  10b <write_stat_time+0xdb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_stat_time (int fd, struct stat *stat)
{
  char buf[4 * sizeof (long) * 3 + 2];
  time_t a_sec, m_sec;
  long a_usec = 0, m_usec = 0;
  a_sec = stat->st_atim.tv_sec;
  a_usec = stat->st_atim.tv_nsec / 1000;
  m_sec = stat->st_mtim.tv_sec;
  m_usec = stat->st_mtim.tv_nsec / 1000;
  snprintf (buf, sizeof (buf), "T%ld %ld %ld %ld\n",
     m_sec, m_usec, a_sec, a_usec);
  return write (fd, buf, strlen (buf));
}
<<<sep_in_sample>>>
1 2
2 9
3 2
4 2
5 2
6 9
7 10
8 2
9 2
10 2
11 10
12 9
13 9
14 10
15 9
16 7
17 9
18 7
19 7
20 9
21 7
22 9
23 10
24 10
25 10
26 7
27 7
28 10
29 10
30 10
31 10
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 12
52 13
53 13
54 13
55 13
56 13
57 13
58 13
59 13
60 13
<<<sep_out_sample>>>
cmpb   $0x0,0xb0(%rdi)
je     20 <shcmd_getgid+0x20>
push   %rcx
add    $0xb0,%rdi
callq  16 <shcmd_getgid+0x16>
test   %rax,%rax
je     25 <shcmd_getgid+0x25>
mov    0x10(%rax),%eax
jmp    2c <shcmd_getgid+0x2c>
or     $0xffffffffffffffff,%rax
retq   
mov    $0xfffffffffffffffe,%rax
pop    %rdx
retq   
<<<sep_in_sample>>>
shcmd_getgid(SHCMD *cmd)
{
 struct group * pw;
 if (strlen(cmd->group_)) {
  pw = getgrnam(cmd->group_);
  if (pw) {
   return pw->gr_gid;
  } else {
   return -2;
  }
 } else {
  return -1;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 5
6 6
7 6
8 7
9 7
10 12
11 14
12 9
13 14
14 14
<<<sep_out_sample>>>
mov    0x20(%rdi),%rdi
jmpq   179 <rec_sex_parser_print_ast+0x9>
<<<sep_in_sample>>>
rec_sex_parser_print_ast (rec_sex_parser_t parser)
{
  rec_sex_ast_print (parser->ast);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%edi        # 2226 <net_read+0x6>
push   %rbx
mov    $0x2000,%edx
mov    $0x0,%esi
callq  2236 <net_read+0x16>
test   %eax,%eax
mov    %rax,%rbx
mov    %eax,0x0(%rip)        # 2241 <net_read+0x21>
js     22a0 <net_read+0x80>
je     22c0 <net_read+0xa0>
test   %eax,%eax
jle    2295 <net_read+0x75>
mov    0x0(%rip),%ecx        # 224f <net_read+0x2f>
movq   $0x0,0x0(%rip)        # 225a <net_read+0x3a>
test   %ecx,%ecx
jle    2272 <net_read+0x52>
xor    %eax,%eax
mov    %ebx,%esi
mov    $0x0,%edi
callq  226c <net_read+0x4c>
mov    0x0(%rip),%eax        # 2272 <net_read+0x52>
mov    0x0(%rip),%edx        # 2278 <net_read+0x58>
test   %edx,%edx
jle    2295 <net_read+0x75>
mov    0x0(%rip),%rsi        # 2283 <net_read+0x63>
mov    %eax,%edx
mov    $0x0,%edi
callq  228f <net_read+0x6f>
mov    0x0(%rip),%eax        # 2295 <net_read+0x75>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
callq  22a5 <net_read+0x85>
mov    %rax,%rdx
mov    %ebx,%eax
cmpl   $0xb,(%rdx)
jne    2295 <net_read+0x75>
xor    %eax,%eax
movl   $0x0,0x0(%rip)        # 22bb <net_read+0x9b>
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
mov    $0x0,%esi
mov    $0x6,%edi
callq  22d1 <net_read+0xb1>
xor    %edi,%edi
callq  22d8 <net_read+0xb8>
mov    0x0(%rip),%eax        # 22de <net_read+0xbe>
pop    %rbx
retq   
<<<sep_in_sample>>>
net_read (void)
{
  ncc = read (net, netibuf, sizeof (netibuf));
  if (ncc < 0 && (*__errno_location ()) == 11)
    ncc = 0;
  else if (ncc == 0)
    {
      syslog (6, "telnetd:  peer died");
      cleanup (0);
    }
  else if (ncc > 0)
    {
      netip = netibuf;
      if (debug_level[debug_report]>=1) debug_output_data ("td: netread %d chars\r\n", ncc)
                                                          ;
      if (debug_level[debug_net_data]>=1) printdata ("nd", netip, ncc);
    }
  return ncc;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 4
7 3
8 3
9 4
10 6
11 11
12 11
13 14
14 13
15 14
16 14
17 14
18 14
19 14
20 14
21 14
22 16
23 16
24 16
25 16
26 16
27 16
28 16
29 16
30 19
31 19
32 19
33 4
34 4
35 4
36 4
37 4
38 5
39 5
40 19
41 19
42 19
43 8
44 8
45 8
46 8
47 9
48 9
49 9
50 19
51 19
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
cmpl   $0x1,0x118(%rdi)
jne    bb <a2ps_print_buffer+0x4b>
cmp    %rcx,%rdx
mov    %rsi,%r13
mov    %rdx,%rbx
mov    %rcx,%rbp
mov    %r8d,%r14d
jae    b2 <a2ps_print_buffer+0x42>
nopl   (%rax)
movzbl 0x0(%r13,%rbx,1),%esi
mov    %r14d,%edx
mov    %r12,%rdi
add    $0x1,%rbx
callq  ad <a2ps_print_buffer+0x3d>
cmp    %rbx,%rbp
ja     98 <a2ps_print_buffer+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
callq  c0 <a2ps_open_output_session>
<<<sep_in_sample>>>
a2ps_print_buffer (a2ps_job * job,
     const unsigned char * buffer,
     size_t start, size_t end,
     enum face_e new_face)
{
  size_t i;
  switch (job->output_format)
    {
    case ps:
      for (i = start ; i < end ; i++)
 ps_print_char (job, buffer [i], new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 11
18 11
19 10
20 11
21 10
22 10
23 16
24 16
25 16
26 16
27 16
28 16
29 14
<<<sep_out_sample>>>
push   %rbx
callq  6 <xvprintf+0x6>
test   %eax,%eax
mov    %eax,%ebx
js     10 <xvprintf+0x10>
mov    %ebx,%eax
pop    %rbx
retq   
mov    0x0(%rip),%rdi        # 17 <xvprintf+0x17>
callq  1c <xvprintf+0x1c>
test   %eax,%eax
jne    c <xvprintf+0xc>
callq  25 <xvprintf+0x25>
mov    0x0(%rip),%edi        # 2b <xvprintf+0x2b>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
callq  39 <xvprintf+0x39>
jmp    c <xvprintf+0xc>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xvprintf (char const *__restrict format, va_list args)
{
  int retval = vprintf (format, args);
  if (retval < 0 && ! ferror (stdout))
    error (exit_failure, (*__errno_location ()), ((const char *) ("cannot perform formatted output")));
  return retval;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 7
7 7
8 7
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
cmp    $0x0,%rdi
je     1258 <is_exec_in_local_dir+0x18>
cmp    $0x0,%rdi
sete   %al
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
is_exec_in_local_dir (const PRED_FUNC pred_func)
{
  return pred_execdir == pred_func || pred_okdir == pred_func;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
mov    %rsi,%rdx
sub    $0x48,%rsp
lea    0x40(%rdx),%r9
mov    %rsp,%rsi
mov    %rsp,%r8
nopl   0x0(%rax)
movzbl 0x3(%rdx),%eax
movzbl 0x2(%rdx),%ecx
add    $0x4,%rdx
add    $0x4,%r8
shl    $0x10,%ecx
shl    $0x18,%eax
or     %ecx,%eax
movzbl -0x4(%rdx),%ecx
or     %ecx,%eax
movzbl -0x3(%rdx),%ecx
shl    $0x8,%ecx
or     %ecx,%eax
mov    %eax,-0x4(%r8)
cmp    %r9,%rdx
jne    5b8 <md4_compress+0x18>
callq  0 <md4_transform>
add    $0x48,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
md4_compress(struct md4_ctx *ctx, const uint8_t *block)
{
  uint32_t data[16];
  unsigned i;
  for (i = 0; i<16; i++, block += 4)
    data[i] = ( (((uint32_t) (block)[3]) << 24) | (((uint32_t) (block)[2]) << 16) | (((uint32_t) (block)[1]) << 8) | ((uint32_t) (block)[0]));
  md4_transform(ctx->state, data);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 7
23 8
24 8
25 8
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     15e3 <gsl_matrix_uint_isneg+0x53>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     15d7 <gsl_matrix_uint_isneg+0x47>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
mov    (%rsi,%rax,4),%ecx
cvtsi2sd %rcx,%xmm0
ucomisd %xmm1,%xmm0
jae    15e9 <gsl_matrix_uint_isneg+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    15c0 <gsl_matrix_uint_isneg+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    15b2 <gsl_matrix_uint_isneg+0x22>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_uint_isneg (const gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 13
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_diagonal (gsl_matrix_short * m)
{
  _gsl_vector_short_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_short v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    %rsi,%rdx
lea    0x8(%rdi),%rsi
mov    (%rdi),%rdi
jmpq   50 <rec_writer_puts.isra.1>
nop
<<<sep_in_sample>>>
rec_write_string (rec_writer_t writer,
                  const char *str)
{
  return rec_writer_puts (writer, str);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_state (const gsl_rng * r)
{
  return r->state;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   3e3a <poshistfilename+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
poshistfilename(void)
{
    return construct_filename("/.nano/filepos_history");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %edi,%edi
mov    %edi,%edx
mov    %edi,0xc(%rsp)
js     90 <file_align_to_string+0x30>
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  7f <file_align_to_string+0x1f>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
lea    0xc(%rsp),%rdi
mov    $0x4,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  a9 <file_align_to_string+0x49>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
file_align_to_string (file_align_t file_align)
{
  static char buf[25];
  if (file_align < 0)
    return argmatch_to_argument ((char const *) &(file_align), (file_align_args), (const char *) (file_align_types), sizeof (*(file_align_types)))
                                       ;
  sprintf (buf, "%d", file_align);
  return buf;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 7
7 7
8 7
9 7
10 8
11 9
12 9
13 9
14 5
15 5
16 5
17 5
18 5
19 9
20 9
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x406,%esi
xor    %eax,%eax
jmpq   6e <dup_cloexec+0xe>
<<<sep_in_sample>>>
dup_cloexec (int fd)
{
  return rpl_fcntl (fd, 1030, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 7 <version_etc_hook+0x7>
mov    0x0(%rip),%rsi        # e <version_etc_hook+0xe>
mov    $0x0,%ecx
mov    $0x0,%edx
jmpq   1d <version_etc_hook+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU cflow", "1.5",
                  program_authors);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # bcb <recutl_reset_indexes+0xb>
callq  bd0 <recutl_reset_indexes+0x10>
movq   $0x0,0x0(%rip)        # bdb <recutl_reset_indexes+0x1b>
movq   $0x0,0x0(%rip)        # be6 <recutl_reset_indexes+0x26>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
recutl_reset_indexes (void)
{
  free (recutl_indexes);
  recutl_indexes = ((void *)0);
  recutl_indexes_size = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
test   %edi,%edi
jne    4b8 <mu_gocs_logging_init+0x48>
test   %rsi,%rsi
mov    $0x0,%eax
cmove  %rax,%rsi
mov    (%rsi),%eax
test   %eax,%eax
jne    4c0 <mu_gocs_logging_init+0x50>
movq   $0x0,0x0(%rip)        # 491 <mu_gocs_logging_init+0x21>
mov    0x8(%rsi),%rdi
test   %rdi,%rdi
je     4b8 <mu_gocs_logging_init+0x48>
sub    $0x8,%rsp
callq  4a3 <mu_gocs_logging_init+0x33>
mov    %rax,0x0(%rip)        # 4aa <mu_gocs_logging_init+0x3a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    %eax,0x0(%rip)        # 4c6 <mu_gocs_logging_init+0x56>
movq   $0x0,0x0(%rip)        # 4d1 <mu_gocs_logging_init+0x61>
jmp    491 <mu_gocs_logging_init+0x21>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_gocs_logging_init (enum mu_gocs_op op, void *data)
{
  struct mu_gocs_logging *p = data;
  if (op == mu_gocs_op_set)
    {
      if (!p)
 {
   static struct mu_gocs_logging default_gocs_logging = { (2<<3) };
   p = &default_gocs_logging;
 }
      if (p->facility)
 {
   mu_log_facility = p->facility;
   mu_debug_default_printer = mu_debug_syslog_printer;
 }
      else
 mu_debug_default_printer = mu_debug_stderr_printer;
      if (p->tag)
 mu_log_tag = strdup (p->tag);
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 9
4 9
5 9
6 11
7 11
8 11
9 17
10 18
11 18
12 18
13 2
14 19
15 19
16 22
17 22
18 22
19 22
20 22
21 22
22 22
23 13
24 14
25 14
26 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     d671 <regfree+0x11>
callq  c40 <free_dfa_content>
mov    0x20(%rbx),%rdi
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
callq  d689 <regfree+0x29>
mov    0x28(%rbx),%rdi
movq   $0x0,0x20(%rbx)
callq  d69a <regfree+0x3a>
movq   $0x0,0x28(%rbx)
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
regfree (regex_t *preg)
{
  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
  if (__builtin_expect (dfa != ((void *)0), 1))
    free_dfa_content (dfa);
  preg->buffer = ((void *)0);
  preg->allocated = 0;
  free (preg->fastmap);
  preg->fastmap = ((void *)0);
  free (preg->translate);
  preg->translate = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 8
8 6
9 7
10 8
11 10
12 9
13 10
14 11
15 12
16 12
17 12
<<<sep_out_sample>>>
movzbl 0x30(%rsi),%eax
cmp    $0xb,%al
je     1168 <calc_next+0x58>
cmp    $0x10,%al
je     1148 <calc_next+0x38>
mov    0x8(%rsi),%rax
test   %rax,%rax
je     112d <calc_next+0x1d>
mov    0x20(%rsi),%rdx
mov    %rdx,0x20(%rax)
mov    0x10(%rsi),%rax
test   %rax,%rax
je     113e <calc_next+0x2e>
mov    0x20(%rsi),%rdx
mov    %rdx,0x20(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    0x10(%rsi),%rax
mov    0x8(%rsi),%rdx
mov    0x18(%rax),%rcx
mov    %rcx,0x20(%rdx)
mov    0x20(%rsi),%rdx
mov    %rdx,0x20(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rax
mov    %rsi,0x20(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
calc_next (void *extra, bin_tree_t *node)
{
  switch (node->token.type)
    {
    case OP_DUP_ASTERISK:
      node->left->next = node;
      break;
    case CONCAT:
      node->left->next = node->right->first;
      node->right->next = node->next;
      break;
    default:
      if (node->left)
 node->left->next = node->next;
      if (node->right)
 node->right->next = node->next;
      break;
    }
  return REG_NOERROR;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 13
7 13
8 13
9 14
10 14
11 15
12 15
13 15
14 16
15 16
16 20
17 20
18 20
19 9
20 9
21 9
22 9
23 10
24 10
25 20
26 20
27 20
28 6
29 6
30 20
31 20
32 20
<<<sep_out_sample>>>
test   %rdi,%rdi
je     60 <sdp_message_v_version_get+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_v_version_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->v_version;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xffffffff,%edi
jmpq   610 <lutimens>
<<<sep_in_sample>>>
utimens (char const *file, struct timespec const timespec[2])
{
  return fdutimens (-1, file, timespec);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicol_get_umask(SWICOL * swicol)
{
 return swicol->umaskM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3ac <version_etc+0x4c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%r8
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x20,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3dd <version_etc+0x7d>
add    $0xd8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_etc (FILE *stream,
             const char *command_name, const char *package,
             const char *version, ...)
{
  va_list authors;
  __builtin_va_start(authors,version);
  version_etc_va (stream, command_name, package, version, authors);
  __builtin_va_end(authors);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 7
16 6
17 6
18 6
19 6
20 6
21 7
22 9
23 9
24 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    2b90 <gsl_matrix_int_subdiagonal+0x50>
mov    0x10(%rsi),%r8
sub    %rdx,%rdi
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
lea    0x0(,%r8,4),%rcx
mov    %r9,0x18(%rax)
imul   %rdx,%rcx
mov    0x8(%rsi),%rdx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  2bb2 <gsl_matrix_int_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_subdiagonal (gsl_matrix_int * m,
                                    const size_t k)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 12
7 14
8 17
9 11
10 17
11 11
12 12
13 11
14 12
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     7b0 <gsasl_server_callback_cipher_get+0x10>
mov    0xd0(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_cipher_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cipher : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    0x0(%rip),%r13        # 8ab <rl_clear_history+0xb>
push   %r12
push   %rbp
push   %rbx
callq  8b4 <rl_clear_history+0x14>
mov    0x0(%rip),%edx        # 8ba <rl_clear_history+0x1a>
test   %edx,%edx
jle    908 <rl_clear_history+0x68>
mov    %rax,%r12
xor    %ebp,%ebp
xor    %r14d,%r14d
nopw   %cs:0x0(%rax,%rax,1)
mov    (%r12),%rbx
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     8f1 <rl_clear_history+0x51>
cmp    %r13,%rdi
cmove  %r14,%r13
callq  8e9 <rl_clear_history+0x49>
movq   $0x0,0x10(%rbx)
mov    %rbx,%rdi
add    $0x1,%ebp
add    $0x8,%r12
callq  900 <rl_clear_history+0x60>
cmp    %ebp,0x0(%rip)        # 906 <rl_clear_history+0x66>
jg     8d0 <rl_clear_history+0x30>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,0x0(%rip)        # 913 <rl_clear_history+0x73>
movl   $0x0,0x0(%rip)        # 91d <rl_clear_history+0x7d>
pop    %r13
movl   $0x0,0x0(%rip)        # 929 <rl_clear_history+0x89>
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_clear_history ()
{
  HIST_ENTRY **hlist, *hent;
  register int i;
  UNDO_LIST *ul, *saved_undo_list;
  saved_undo_list = rl_undo_list;
  hlist = history_list ();
  for (i = 0; i < history_length; i++)
    {
      hent = hlist[i];
      if (ul = (UNDO_LIST *)hent->data)
 {
   if (ul == saved_undo_list)
     saved_undo_list = 0;
   _rl_free_undo_list (ul);
   hent->data = 0;
 }
      _rl_free_history_entry (hent);
    }
  history_offset = history_length = 0;
  rl_undo_list = saved_undo_list;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 2
5 2
6 2
7 7
8 8
9 8
10 8
11 8
12 8
13 14
14 14
15 10
16 11
17 11
18 11
19 14
20 14
21 15
22 16
23 18
24 8
25 8
26 18
27 8
28 8
29 22
30 22
31 22
32 21
33 20
34 22
35 20
36 22
37 22
38 22
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_previous_node (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->previous_node (list, node);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    $0x0,%edx
jmpq   1c0 <internal_read_file>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_file (const char *filename, size_t *length)
{
  return internal_read_file (filename, length, "r");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rsi
push   %rbx
test   %rsi,%rsi
je     210 <grecs_list_pop+0x20>
mov    0x10(%rsi),%rbx
callq  202 <grecs_list_pop+0x12>
mov    %rbx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
xor    %ebx,%ebx
jmp    202 <grecs_list_pop+0x12>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_list_pop(struct grecs_list *lp)
{
 void *data;
 struct grecs_list_entry *ep = lp->head;
 if (ep) {
  data = ep->data;
  grecs_list_remove_entry(lp, ep);
 } else
  data = ((void *)0);
 return data;
}
<<<sep_in_sample>>>
1 4
2 2
3 5
4 5
5 6
6 7
7 11
8 11
9 11
10 11
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
movl   $0x454e494c,0x4(%rdi)
movb   $0x0,0x8(%rdi)
movsd  %xmm3,0x10(%rsp)
movsd  %xmm2,0x18(%rsp)
movsd  %xmm1,0x8(%rsp)
movsd  %xmm0,(%rsp)
callq  1caf <pict_rectangle+0x2f>
movsd  0x18(%rsp),%xmm2
mov    %rbx,%rdi
movsd  0x8(%rsp),%xmm1
addsd  (%rsp),%xmm2
movapd %xmm2,%xmm0
movsd  %xmm2,0x18(%rsp)
callq  1cd2 <pict_rectangle+0x52>
movsd  0x10(%rsp),%xmm3
mov    %rbx,%rdi
movsd  0x18(%rsp),%xmm2
addsd  0x8(%rsp),%xmm3
movapd %xmm2,%xmm0
movapd %xmm3,%xmm1
movsd  %xmm3,0x10(%rsp)
callq  1cfa <pict_rectangle+0x7a>
movsd  0x10(%rsp),%xmm3
mov    %rbx,%rdi
movsd  (%rsp),%xmm0
movapd %xmm3,%xmm1
callq  1d11 <pict_rectangle+0x91>
movsd  0x8(%rsp),%xmm1
mov    %rbx,%rdi
movsd  (%rsp),%xmm0
add    $0x20,%rsp
pop    %rbx
jmpq   1d29 <pict_rectangle+0xa9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
pict_rectangle(pict *p, double llx, double lly, double sx, double sy)
{
  strcpy(p->pict_type, "LINE");
  pict_point(p, llx, lly);
  pict_point(p, llx + sx, lly);
  pict_point(p, llx + sx, lly + sy);
  pict_point(p, llx, lly + sy);
  pict_point(p, llx, lly);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 8
32 8
33 8
34 9
35 9
36 8
37 8
<<<sep_out_sample>>>
mov    %dl,(%rsi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_fl_set_type(SWI_FILELIST * fl, char * hdr, int tartype) {
 *(hdr + 0) = (unsigned char)tartype;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
<<<sep_out_sample>>>
push   %r14
mov    %edi,%r14d
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
callq  66 <xwrite+0x16>
mov    %rax,%rbx
mov    (%rax),%r12d
xor    %eax,%eax
test   %rbp,%rbp
jne    7d <xwrite+0x2d>
jmp    92 <xwrite+0x42>
nopl   (%rax)
cmpl   $0x4,(%rbx)
jne    92 <xwrite+0x42>
mov    %r12d,(%rbx)
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r14d,%edi
callq  8e <xwrite+0x3e>
test   %eax,%eax
js     78 <xwrite+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xwrite(fd, buf, count)
    int fd;
    const char *buf;
    size_t count;
{
    int chars;
    int old_errno = (*__errno_location ());
    if (count <= 0)
 return count;
    do
    {
 (*__errno_location ()) = old_errno;
 chars = write(fd, buf, count);
    }
    while (chars < 0 && (*__errno_location ()) == 4);
    return chars;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 9
13 8
14 8
15 8
16 8
17 15
18 15
19 12
20 13
21 13
22 13
23 13
24 15
25 15
26 17
27 17
28 17
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
test   %r10,%r10
je     32a4 <gsl_matrix_ushort_scale+0x64>
push   %rbx
lea    (%r9,%r9,1),%rbx
add    %r11,%r11
xor    %esi,%esi
xor    %r8d,%r8d
nopl   (%rax)
test   %r9,%r9
je     3294 <gsl_matrix_ushort_scale+0x54>
mov    0x18(%rdi),%rdx
lea    (%rsi,%rbx,1),%rcx
lea    (%rdx,%rsi,1),%rax
add    %rdx,%rcx
nopl   0x0(%rax)
movzwl (%rax),%edx
add    $0x2,%rax
cvtsi2sd %edx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%edx
mov    %dx,-0x2(%rax)
cmp    %rcx,%rax
jne    3278 <gsl_matrix_ushort_scale+0x38>
add    $0x1,%r8
add    %r11,%rsi
cmp    %r10,%r8
jne    3260 <gsl_matrix_ushort_scale+0x20>
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_scale (gsl_matrix_ushort * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 2
7 2
8 2
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 7
28 7
29 7
30 7
31 15
32 15
33 15
34 15
35 15
36 15
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     32b <cdio_debug+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    $0x1,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  210 <cdio_logv>
add    $0xd8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_debug (const char format[], ...) { va_list args; __builtin_va_start(args,format); cdio_logv (CDIO_LOG_DEBUG, format, args); __builtin_va_end(args); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  174b <hide+0xb>
xor    %eax,%eax
callq  1752 <hide+0x12>
mov    0x0(%rip),%rdi        # 1759 <hide+0x19>
add    $0x8,%rsp
jmpq   1762 <hide+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hide()
{
    tty_set_mode(0);
    tty_defaults();
    tty_put_screen(screen);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 6
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  cbe <err_readonly+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   ccc <err_readonly+0x1c>
<<<sep_in_sample>>>
err_readonly (s)
     const char *s;
{
  report_error (gettext("%s: readonly variable"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    (%rdi),%rdi
mov    0x8(%rsi),%rsi
callq  30 <assoc_key_cmp+0x10>
test   %eax,%eax
mov    $0x1,%edx
jne    42 <assoc_key_cmp+0x22>
xor    %edx,%edx
subq   $0x1,(%rbx)
setne  %dl
mov    %edx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assoc_key_cmp(const void *item, void *data)
{
    const struct dico_assoc *aptr = item;
    struct find_closure *clos = data;
    if (strcmp(aptr->key, clos->str) == 0 && --clos->count == 0)
 return 0;
    return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 7
8 5
9 5
10 5
11 5
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%r10d        # b4bb <wf_hdy+0xb>
xor    %eax,%eax
movq   $0x0,0x0(%rip)        # b4c8 <wf_hdy+0x18>
test   %r10d,%r10d
sete   %al
mov    %eax,0x0(%rip)        # b4d4 <wf_hdy+0x24>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  b4e0 <wf_hdy+0x30>
mov    0x0(%rip),%r11d        # b4e7 <wf_hdy+0x37>
xor    %eax,%eax
test   %r11d,%r11d
sete   %al
mov    %eax,0x0(%rip)        # b4f5 <wf_hdy+0x45>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wf_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "WF";
  use_other_cc = !use_other_cc;
  fr_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 11
3 11
4 10
5 11
6 11
7 11
8 12
9 12
10 12
11 13
12 13
13 13
14 13
15 13
16 14
17 14
18 14
<<<sep_out_sample>>>
movslq %edi,%rdi
movslq %esi,%rsi
movl   $0x0,0x0(%rip)        # 50 <putuchar+0x10>
mov    0x0(,%rdi,8),%rdx
movb   $0x0,0x0(%rip)        # 5f <putuchar+0x1f>
movsbl (%rdx,%rsi,1),%eax
cmp    $0xa,%al
mov    %al,0x0(%rip)        # 6b <putuchar+0x2b>
je     100 <putuchar+0xc0>
movzwl 0x0(%rip),%ecx        # 78 <putuchar+0x38>
mov    %eax,%edi
and    %ecx,%edi
cmp    %edi,%ecx
je     b8 <putuchar+0x78>
movzwl 0x0(%rip),%ecx        # 87 <putuchar+0x47>
mov    %eax,%edi
and    %ecx,%edi
cmp    %edi,%ecx
je     d2 <putuchar+0x92>
movzwl 0x0(%rip),%ecx        # 96 <putuchar+0x56>
and    %ecx,%eax
cmp    %eax,%ecx
je     ea <putuchar+0xaa>
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
movb   $0x30,0x0(%rip)        # af <putuchar+0x6f>
jmpq   b4 <putuchar+0x74>
nopl   0x0(%rax)
movzbl 0x1(%rdx,%rsi,1),%ecx
mov    %eax,%edi
mov    %cl,0x0(%rip)        # c5 <putuchar+0x85>
movzwl 0x0(%rip),%ecx        # cc <putuchar+0x8c>
and    %ecx,%edi
cmp    %edi,%ecx
jne    8f <putuchar+0x4f>
movzbl 0x2(%rdx,%rsi,1),%ecx
mov    %cl,0x0(%rip)        # dd <putuchar+0x9d>
movzwl 0x0(%rip),%ecx        # e4 <putuchar+0xa4>
and    %ecx,%eax
cmp    %eax,%ecx
jne    9c <putuchar+0x5c>
movzbl 0x3(%rdx,%rsi,1),%eax
mov    %al,0x0(%rip)        # f5 <putuchar+0xb5>
jmp    9c <putuchar+0x5c>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
putuchar(int pos, int index)
{
  static char c[5];
  memset(c, 0, 5);
  c[0] = lines[pos][index];
  if(c[0] == '\n') return;
  if ((c[0] & mask[0]) == mask[0]) c[1] = lines[pos][index+1];
  if ((c[0] & mask[1]) == mask[1]) c[2] = lines[pos][index+2];
  if ((c[0] & mask[2]) == mask[2]) c[3] = lines[pos][index+3];
  c[4] = '0';
  printf("%s", c);
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 5
5 4
6 5
7 6
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 10
28 11
29 11
30 7
31 8
32 7
33 8
34 8
35 8
36 8
37 8
38 8
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # ac7 <mu_locker_set_default_expire_timeout+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_locker_set_default_expire_timeout (time_t t)
{
  mu_locker_expire_timeout = t;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %esi,(%rax)
retq   
nop
<<<sep_in_sample>>>
set_quoting_style (struct quoting_options *o, enum quoting_style s)
{
  (o ? o : &default_quoting_options)->style = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
cmpb   $0x0,(%rbx)
je     39 <print_greek+0x39>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  1b <print_greek+0x1b>
test   %rax,%rax
je     50 <print_greek+0x50>
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  2f <print_greek+0x2f>
add    0x8(%rsp),%rbx
cmpb   $0x0,(%rbx)
jne    e <print_greek+0xe>
mov    $0xa,%edi
callq  43 <print_greek+0x43>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
movzbl (%rbx),%ebp
mov    $0x2d,%edi
cmp    $0x2d,%bpl
je     75 <print_greek+0x75>
callq  63 <print_greek+0x63>
mov    (%rax),%rax
movsbq %bpl,%rdx
movsbl %bpl,%edi
testb  $0x20,0x1(%rax,%rdx,2)
je     80 <print_greek+0x80>
callq  7a <print_greek+0x7a>
add    $0x1,%rbx
jmp    9 <print_greek+0x9>
mov    $0x0,%edi
xor    %eax,%eax
callq  8c <print_greek+0x8c>
movsbl (%rbx),%edi
jmp    75 <print_greek+0x75>
<<<sep_in_sample>>>
print_greek(const char *arg)
{
    while (*arg) {
 size_t rd;
 const char *greek = gcide_grk_to_utf8(arg, &rd);
 if (greek) {
     printf("%s", greek);
     arg += rd;
 } else {
     if (!(*arg == '-' || ((*__ctype_b_loc ())[(int) ((*arg))] & (unsigned short int) _ISspace)))
  printf("<!>");
     putchar(*arg);
     arg++;
 }
    }
    putchar('\n');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 7
16 8
17 3
18 3
19 16
20 16
21 17
22 17
23 17
24 17
25 17
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 12
37 13
38 13
39 11
40 11
41 11
42 11
43 11
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     4e <directory_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    30 <directory_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
directory_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((const struct directory *) key)->name)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <get_clk_tck+0x7>
test   %rax,%rax
je     10 <get_clk_tck+0x10>
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x2,%edi
callq  1e <get_clk_tck+0x1e>
mov    %rax,0x0(%rip)        # 25 <get_clk_tck+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_clk_tck ()
{
  static long retval = 0;
  if (retval != 0)
    return (retval);
  retval = sysconf (_SC_CLK_TCK);
  return (retval);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 8
5 8
6 2
7 6
8 6
9 6
10 8
11 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 320 <current+0x10>
mov    0x0(,%rax,8),%rdi
callq  32d <current+0x1d>
movslq 0x0(%rip),%rsi        # 334 <current+0x24>
mov    %rax,%rbx
mov    $0x0,%edi
xor    %eax,%eax
callq  343 <current+0x33>
test   %rbx,%rbx
je     360 <current+0x50>
mov    %rbx,%rdi
callq  *0x10(%rbp)
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   35e <current+0x4e>
xchg   %ax,%ax
mov    $0x0,%edi
mov    $0x0,%esi
xor    %eax,%eax
callq  371 <current+0x61>
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   381 <current+0x71>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
current(struct itr_shell *shp)
{
    char *elt = dico_iterator_current(itr[num]);
    printf("%lu:", (unsigned long) num);
    if (elt)
 shp->print_item(elt);
    else
 printf("%s", "NUL");
    putchar('\n');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 3
10 4
11 4
12 4
13 5
14 5
15 6
16 6
17 10
18 9
19 10
20 10
21 9
22 9
23 8
24 8
25 8
26 8
27 10
28 9
29 10
30 10
31 9
32 9
<<<sep_out_sample>>>
push   %rbp
mov    $0x4,%edi
push   %rbx
sub    $0x28,%rsp
callq  10 <main+0x10>
mov    %rax,%rbx
callq  18 <main+0x18>
mov    %rax,%rbp
callq  20 <main+0x20>
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
mov    %rbp,%r8
movl   $0xffffffff,0x8(%rsp)
movl   $0xffffffff,(%rsp)
mov    %rbx,%rcx
mov    $0x4,%r9d
mov    $0x1,%edx
xor    %esi,%esi
mov    %rax,%rdi
callq  5c <main+0x5c>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
main (int argc, char ** argv ) {
   enum archive_format arf = arf_crcascii;
   DEFER * defers=defer_open(arf);
   PORINODE * porinode=porinode_open();
   TARU * taru = taru_create();
   return taru_process_copy_out(taru, 0, 1, defers, porinode, arf, -1, -1, (intmax_t*)((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 1
2 3
3 1
4 1
5 3
6 3
7 4
8 4
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
mov    $0x3a,%edx
jmpq   158a <quotearg_colon_mem+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x1e0,%rsp
test   %al,%al
mov    %rsi,0x138(%rsp)
mov    %rdx,0x140(%rsp)
mov    %rcx,0x148(%rsp)
mov    %r8,0x150(%rsp)
mov    %r9,0x158(%rsp)
je     74 <outputf+0x74>
movaps %xmm0,0x160(%rsp)
movaps %xmm1,0x170(%rsp)
movaps %xmm2,0x180(%rsp)
movaps %xmm3,0x190(%rsp)
movaps %xmm4,0x1a0(%rsp)
movaps %xmm5,0x1b0(%rsp)
movaps %xmm6,0x1c0(%rsp)
movaps %xmm7,0x1d0(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x128(%rsp)
xor    %eax,%eax
lea    0x1f0(%rsp),%rax
lea    0x20(%rsp),%rbx
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    %rax,0x10(%rsp)
lea    0x130(%rsp),%rax
mov    %rbx,%rdi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  c6 <outputf+0xc6>
mov    %rbx,%rdx
mov    (%rdx),%ecx
add    $0x4,%rdx
lea    -0x1010101(%rcx),%eax
not    %ecx
and    %ecx,%eax
and    $0x80808080,%eax
je     c9 <outputf+0xc9>
mov    %eax,%ecx
shr    $0x10,%ecx
test   $0x8080,%eax
cmove  %ecx,%eax
lea    0x2(%rdx),%rcx
cmove  %rcx,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbx,%rdx
cmp    $0xff,%rdx
ja     14a <outputf+0x14a>
movsbl 0x20(%rsp),%esi
test   %sil,%sil
je     12e <outputf+0x12e>
nopl   0x0(%rax)
add    $0x1,%rbx
mov    $0x1,%edi
callq  126 <outputf+0x126>
movsbl (%rbx),%esi
test   %sil,%sil
jne    118 <outputf+0x118>
mov    0x128(%rsp),%rax
xor    %fs:0x28,%rax
jne    163 <outputf+0x163>
add    $0x1e0,%rsp
pop    %rbx
retq   
mov    $0x0,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  163 <outputf+0x163>
callq  168 <outputf+0x168>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
outputf(char *fmt, ...)
{
      va_list arg;
      char str[255+1], *ptr;
      __builtin_va_start(arg,fmt);
      vsprintf(str, fmt, arg);
      ((strlen(str) <= sizeof(str) - 1) ? (void) (0) : __assert_fail ("strlen(str) <= sizeof(str) - 1", "alglib3.c", 32, __PRETTY_FUNCTION__));
      __builtin_va_end(arg);
      for (ptr = str; *ptr != '\0'; ptr++) outchar(1, *ptr);
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 5
22 6
23 6
24 2
25 5
26 5
27 6
28 5
29 5
30 5
31 6
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 11
62 11
63 11
64 11
65 11
66 11
67 7
68 7
69 7
70 7
71 7
72 11
73 11
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   0 <do_convert>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_charset_convert(cdio_charset_coverter_t*cnv,
                          char * src, int src_len,
                          char ** dst, int * dst_len)
  {
  return do_convert(cnv->ic, src, src_len, dst, dst_len);
  }
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 125a <gsl_matrix_int_const_ptr+0xa>
test   %eax,%eax
je     1269 <gsl_matrix_int_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1280 <gsl_matrix_int_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    12a0 <gsl_matrix_int_const_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,4),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1299 <gsl_matrix_int_const_ptr+0x49>
xor    %eax,%eax
jmp    1279 <gsl_matrix_int_const_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12b9 <gsl_matrix_int_const_ptr+0x69>
xor    %eax,%eax
jmp    1279 <gsl_matrix_int_const_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_int_const_ptr(const gsl_matrix_int * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_int.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_int.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const int *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  39 <file_fmt+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
file_fmt(const char *str, void *data)
{
 fputs(str, (FILE*)data);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x5f8(%rdi),%rax
xor    %ecx,%ecx
mov    0x58(%rax),%rdi
jmpq   180 <dict_entry_add>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setpagedevice (a2ps_job * job, const char * key, const char * value)
{
  dict_entry_add (job->status->pagedevice, key, value, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%r9
mov    %rdx,%r8
shr    %r8
je     e5f <gsl_vector_uint_reverse+0x4f>
lea    -0x4(,%rdx,4),%rdx
mov    %r9,%r10
xor    %ecx,%ecx
neg    %r10
imul   %r9,%rdx
shl    $0x2,%r10
shl    $0x2,%r9
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%esi
mov    (%rax),%edi
add    $0x1,%rcx
mov    %edi,(%rdx)
mov    %esi,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    e48 <gsl_vector_uint_reverse+0x38>
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_reverse (gsl_vector_uint * v)
{
  unsigned int * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          unsigned int tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 15
18 8
19 15
20 16
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
mov    %rsi,0x68(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_maxbuf_set (Gsasl * ctx,
      Gsasl_client_callback_maxbuf cb)
{
  ctx->cbc_maxbuf = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
testb  $0x10,0x29(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
visible_var (var)
     SHELL_VAR *var;
{
  return (((((var)->attributes) & (0x0001000))) == 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_authorization_id_set (Gsasl * ctx,
         Gsasl_client_callback_authorization_id
         cb)
{
  ctx->cbc_authorization_id = cb;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
movslq 0x4(%rdi),%rdx
test   %rcx,%rcx
jle    40 <__gmpf_integer_p+0x40>
mov    %rdx,%rax
sar    $0x3f,%rax
xor    %rax,%rdx
sub    %rax,%rdx
mov    0x10(%rdi),%rax
cmpq   $0x0,(%rax)
jne    36 <__gmpf_integer_p+0x36>
nopl   0x0(%rax)
add    $0x8,%rax
sub    $0x1,%rdx
cmpq   $0x0,(%rax)
je     28 <__gmpf_integer_p+0x28>
xor    %eax,%eax
cmp    %rcx,%rdx
setle  %al
retq   
nop
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
retq   
<<<sep_in_sample>>>
__gmpf_integer_p (mpf_srcptr f)
{
  mp_srcptr fp;
  mp_exp_t exp;
  mp_size_t size;
  size = ((f)->_mp_size);
  exp = ((f)->_mp_exp);
  if (exp <= 0)
    return (size == 0);
  size = ((size) >= 0 ? (size) : -(size));
  for (fp = ((f)->_mp_d); *fp == 0; ++fp)
    --size;
  return size <= exp;
}
<<<sep_in_sample>>>
1 7
2 6
3 8
4 8
5 10
6 10
7 10
8 10
9 11
10 11
11 11
12 11
13 11
14 12
15 11
16 11
17 13
18 13
19 13
20 14
21 14
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rsi),%rax
mov    %rsi,%rbx
mov    (%rsi),%rdx
test   %rax,%rax
je     170 <linked_list_unlink+0x40>
mov    %rdx,(%rax)
mov    (%rsi),%rdx
test   %rdx,%rdx
je     180 <linked_list_unlink+0x50>
mov    %rax,0x8(%rdx)
mov    (%rdi),%rax
test   %rax,%rax
je     15d <linked_list_unlink+0x2d>
mov    0x18(%rbx),%rdi
callq  *%rax
mov    %rbx,%rdi
pop    %rbx
jmpq   166 <linked_list_unlink+0x36>
nopw   %cs:0x0(%rax,%rax,1)
test   %rdx,%rdx
mov    %rdx,0x8(%rdi)
jne    14b <linked_list_unlink+0x1b>
nopl   0x0(%rax)
mov    %rax,0x10(%rdi)
jmp    14f <linked_list_unlink+0x1f>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
linked_list_unlink(struct linked_list *list, struct linked_list_entry *ent)
{
     struct linked_list_entry *p;
     if ((p = ent->prev))
   p->next = ent->next;
     else
   list->head = ent->next;
     if ((p = ent->next))
   p->prev = ent->prev;
     else
   list->tail = ent->prev;
     if (list->free_data)
   list->free_data(ent->data);
     free(ent);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 5
5 4
6 4
7 5
8 5
9 8
10 8
11 9
12 12
13 12
14 12
15 13
16 13
17 14
18 15
19 14
20 14
21 8
22 7
23 8
24 8
25 11
26 11
27 11
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     317 <has_file_part+0x37>
cmpb   $0x0,(%rdi)
je     317 <has_file_part+0x37>
mov    $0x3a,%esi
callq  2ff <has_file_part+0x1f>
test   %rax,%rax
je     317 <has_file_part+0x37>
mov    %rbx,%rdi
xor    %ebp,%ebp
callq  30e <has_file_part+0x2e>
cmpb   $0x3a,-0x1(%rbx,%rax,1)
setne  %bpl
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
has_file_part(char * soc)
{
 if (!soc || strlen(soc) == 0) return 0;
 if (strchr(soc, ':')) {
  if (*(soc+(strlen(soc)-1)) == ':') {
   return 0;
  } else {
   return 1;
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 12
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     540 <rec_parser_destroy+0x20>
mov    0x20(%rdi),%rdi
callq  532 <rec_parser_destroy+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   53b <rec_parser_destroy+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_parser_destroy (rec_parser_t parser)
{
  if (parser)
    {
      free (parser->source);
      free (parser);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 6
8 8
9 6
10 6
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %rbp
mov    $0x9,%edx
mov    %rsi,%rbp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 142 <mu_cfg_yy_stack_print+0x22>
callq  147 <mu_cfg_yy_stack_print+0x27>
cmp    %rbp,%rbx
ja     16f <mu_cfg_yy_stack_print+0x4f>
nopl   0x0(%rax)
movswl (%rbx),%edx
mov    0x0(%rip),%rdi        # 15a <mu_cfg_yy_stack_print+0x3a>
xor    %eax,%eax
mov    $0x0,%esi
add    $0x2,%rbx
callq  16a <mu_cfg_yy_stack_print+0x4a>
cmp    %rbx,%rbp
jae    150 <mu_cfg_yy_stack_print+0x30>
mov    0x0(%rip),%rsi        # 176 <mu_cfg_yy_stack_print+0x56>
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   186 <mu_cfg_yy_stack_print+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yy_stack_print (mu_cfg_yytype_int16 *bottom, mu_cfg_yytype_int16 *top)
{
  fprintf (stderr, "Stack now");
  for (; bottom <= top; ++bottom)
    fprintf (stderr, " %d", *bottom);
  fprintf (stderr, "\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 2
9 3
10 3
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 4
19 5
20 4
21 4
22 6
23 7
24 6
25 7
26 7
27 6
28 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  1ad <normal_reset+0xd>
mov    0x10(%rbx),%rdi
callq  1b6 <normal_reset+0x16>
xorpd  %xmm0,%xmm0
movl   $0x0,0x50(%rbx)
xor    %eax,%eax
movsd  %xmm0,0x18(%rbx)
movsd  %xmm0,0x58(%rbx)
movsd  %xmm0,0x60(%rbx)
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
normal_reset(void *vstate)
{
  normal_state_t *state = (normal_state_t *) vstate;
  gsl_matrix_set_zero(state->ATA);
  gsl_vector_set_zero(state->ATb);
  state->normb = 0.0;
  state->eigen = 0;
  state->eval_min = 0.0;
  state->eval_max = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 7
9 11
10 6
11 8
12 9
13 11
14 11
15 11
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %r9,0x18(%rsp)
mov    %r8d,(%rsp)
mov    %ecx,%r9d
movl   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
xor    %r8d,%r8d
xor    %ecx,%ecx
callq  1aeb <iso9660_dir_init_new+0x2b>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
iso9660_dir_init_new (void *dir,
                      uint32_t self,
                      uint32_t ssize,
                      uint32_t parent,
                      uint32_t psize,
                      const time_t *dir_time)
{
  iso9660_dir_init_new_su (dir, self, ssize, ((void *)0), 0, parent, psize, ((void *)0),
                           0, dir_time);
}
<<<sep_in_sample>>>
1 7
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 10
11 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3678 <gsl_matrix_ushort_free+0x38>
mov    0x28(%rdi),%eax
test   %eax,%eax
jne    3660 <gsl_matrix_ushort_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   3659 <gsl_matrix_ushort_free+0x19>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdi
callq  3669 <gsl_matrix_ushort_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   3672 <gsl_matrix_ushort_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_free (gsl_matrix_ushort * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_ushort_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d42 <close_stream_temp+0x12>
mov    %rbx,%rdi
mov    %eax,%r12d
callq  d4d <close_stream_temp+0x1d>
mov    %eax,%ebp
callq  d54 <close_stream_temp+0x24>
mov    (%rax),%r13d
mov    %rax,%rbx
mov    %r12d,%edi
callq  340 <unregister_fd>
mov    %ebp,%eax
mov    %r13d,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
close_stream_temp (FILE *fp)
{
  int fd = fileno (fp);
  int result = close_stream (fp);
  int saved_errno = (*__errno_location ());
  unregister_fd (fd);
  (*__errno_location ()) = saved_errno;
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 3
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 9
18 7
19 9
20 9
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
push   %rbp
lea    0x0(,%rdx,8),%r10
xor    %edx,%edx
test   %rcx,%rcx
push   %rbx
mov    %rsi,%rbx
je     eeb <gsl_permute_ulong+0x7b>
nopl   0x0(%rax)
mov    (%rdi,%rdx,8),%rax
cmp    %rax,%rdx
jae    ea1 <gsl_permute_ulong+0x31>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%rdx
jb     e98 <gsl_permute_ulong+0x28>
cmp    %rax,%rdx
ja     edf <gsl_permute_ulong+0x6f>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     edf <gsl_permute_ulong+0x6f>
mov    (%rbx),%rbp
jmp    ebe <gsl_permute_ulong+0x4e>
nopl   0x0(%rax)
mov    %r8,%rax
mov    %r9,%r8
mov    %r10,%r11
imul   %r8,%r11
imul   %r10,%rax
add    %rsi,%r11
mov    (%r11),%r9
mov    %r9,(%rsi,%rax,1)
mov    (%rdi,%r8,8),%r9
cmp    %r9,%rdx
jne    eb8 <gsl_permute_ulong+0x48>
mov    %rbp,(%r11)
add    $0x1,%rdx
add    %r10,%rbx
cmp    %rcx,%rdx
jne    e88 <gsl_permute_ulong+0x18>
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_permute_ulong (const size_t * p, unsigned long * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned long t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned long r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 2
6 2
7 4
8 4
9 6
10 7
11 7
12 7
13 8
14 7
15 7
16 9
17 9
18 11
19 12
20 12
21 18
22 18
23 18
24 18
25 27
26 23
27 23
28 24
29 23
30 23
31 24
32 27
33 19
34 19
35 30
36 4
37 4
38 4
39 4
40 34
41 34
42 34
43 34
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0x6,0x0(%rip)        # 2d9 <panels_can_be_displayed+0x9>
jle    304 <panels_can_be_displayed+0x34>
mov    0x0(%rip),%eax        # 2e1 <panels_can_be_displayed+0x11>
test   %eax,%eax
je     2f8 <panels_can_be_displayed+0x28>
xor    %eax,%eax
cmpl   $0xb,0x0(%rip)        # 2ee <panels_can_be_displayed+0x1e>
setg   %al
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
cmpl   $0x5,0x0(%rip)        # 301 <panels_can_be_displayed+0x31>
setg   %al
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panels_can_be_displayed()
{
    if (tty_lines >= 7)
    {
 if (two_panel_mode)
 {
     if (tty_columns >= 6 * 2)
  return 1;
 }
 else
     if (tty_columns >= 6)
  return 1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 14
2 3
3 3
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 11
13 11
14 11
15 15
16 15
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x660(%rdi),%rax
mov    0x28(%rax),%rdx
mov    0x30(%rax),%rax
mov    -0x8(%rax,%rdx,8),%rax
mov    0x70(%rdi),%edx
mov    0x6c(%rax),%ecx
test   %ecx,%ecx
je     210 <file_job_synchronize_pages+0x50>
mov    %edx,%esi
sub    %ecx,%esi
mov    %esi,%ecx
add    $0x1,%ecx
mov    0x84(%rax),%esi
test   %esi,%esi
jne    1fb <file_job_synchronize_pages+0x3b>
movl   $0x1,0x84(%rax)
mov    %edx,0x70(%rax)
mov    0x88(%rax),%edx
mov    %ecx,0x74(%rax)
mov    %edx,0x80(%rax)
retq   
xchg   %ax,%ax
mov    %edx,0x6c(%rax)
mov    $0x1,%ecx
jmp    1e7 <file_job_synchronize_pages+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_job_synchronize_pages (struct a2ps_job * job)
{
  fjob_t * file = ((struct file_job *) (job->jobs->content[job->jobs->len - 1]));
  if (!file->first_page)
    file->first_page = job->pages;
  if (!file->top_page)
    file->top_page = 1;
  file->last_page = job->pages;
  file->top_line = ((struct file_job *) (job->jobs->content[job->jobs->len - 1]))->lines;
  file->pages = file->last_page - file->first_page + 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 7
17 8
18 9
19 10
20 9
21 10
22 10
23 5
24 5
25 5
26 5
<<<sep_out_sample>>>
mov    0x2278(%rdi),%rax
test   %rax,%rax
je     10 <VSetClipRect+0x10>
jmpq   *%rax
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
VSetClipRect (Viewport *v, int x1, int y1, int x2, int y2)
{
  if (v->SetClipRect) {
    v->SetClipRect(v, x1, y1, x2, y2);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %r13
mov    $0x16,%eax
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   %rdi,%rdi
je     15d9 <mu_url_sget_auth+0x29>
mov    0x20(%rdi),%rax
mov    %rsi,%rbp
test   %rax,%rax
je     15e8 <mu_url_sget_auth+0x38>
mov    %rax,0x0(%rbp)
xor    %eax,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    0x88(%rdi),%r8
mov    $0x1028,%ax
test   %r8,%r8
je     15d9 <mu_url_sget_auth+0x29>
xor    %edx,%edx
xor    %esi,%esi
lea    0x8(%rsp),%rcx
callq  *%r8
test   %eax,%eax
jne    15d9 <mu_url_sget_auth+0x29>
mov    0x8(%rsp),%rax
lea    0x1(%rax),%r13
mov    %r13,%rdi
callq  1619 <mu_url_sget_auth+0x69>
test   %rax,%rax
mov    %rax,%r12
je     1667 <mu_url_sget_auth+0xb7>
xor    %ecx,%ecx
mov    %r13,%rdx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  *0x88(%rbx)
test   %eax,%eax
jne    15d9 <mu_url_sget_auth+0x29>
cmpb   $0x0,(%r12)
jne    1646 <mu_url_sget_auth+0x96>
mov    %r12,0x20(%rbx)
mov    %r12,%rax
jmp    15d3 <mu_url_sget_auth+0x23>
mov    %r12,%rdi
callq  164e <mu_url_sget_auth+0x9e>
mov    %r12,%rdi
mov    %rax,0x20(%rbx)
callq  165a <mu_url_sget_auth+0xaa>
mov    0x20(%rbx),%rax
test   %rax,%rax
jne    15d3 <mu_url_sget_auth+0x23>
mov    $0xc,%eax
jmpq   15d9 <mu_url_sget_auth+0x29>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_sget_auth (mu_url_t url, char const **sptr) { if (url == ((void *)0)) return 22; if (!url->auth) { if (url->_get_auth) { size_t n; char *buf; int status = url->_get_auth (url, ((void *)0), 0, &n); if (status) return status; buf = malloc (n + 1); if (!buf) return 12; status = url->_get_auth (url, buf, n + 1, ((void *)0)); if (status) return status; if (buf[0]) { url->auth = mu_url_decode (buf); free (buf); } else url->auth = buf; if (!url->auth) return 12; } else return (0x1000 +40); } *sptr = url->auth; return 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
44 1
45 1
46 1
47 1
48 1
49 1
50 1
51 1
52 1
53 1
54 1
55 1
56 1
57 1
58 1
59 1
60 1
61 1
62 1
<<<sep_out_sample>>>
mov    %edi,0x7c(%rsi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_debug (int bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yy_flex_debug_r = bdebug ;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r15
test   %r15,%r15
je     39a <argmatch_to_argument+0x5a>
mov    %rdi,%r13
mov    %rdx,%r14
mov    %rcx,%rbp
mov    $0x1,%ebx
xor    %esi,%esi
jmp    384 <argmatch_to_argument+0x44>
nopl   0x0(%rax,%rax,1)
lea    0x1(%rbx),%r8
mov    -0x8(%r12,%r8,8),%r15
test   %r15,%r15
je     39a <argmatch_to_argument+0x5a>
mov    %rbx,%rsi
mov    %r8,%rbx
imul   %rbp,%rsi
mov    %rbp,%rdx
mov    %r13,%rdi
add    %r14,%rsi
callq  396 <argmatch_to_argument+0x56>
test   %eax,%eax
jne    370 <argmatch_to_argument+0x30>
add    $0x8,%rsp
mov    %r15,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
argmatch_to_argument (const char *value,
        const char *const *arglist,
        const char *vallist, size_t valsize)
{
  int i;
  for (i = 0; arglist[i]; i++)
    if (!memcmp (value, vallist + valsize * i, valsize))
      return arglist[i];
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  c59 <xclose+0x9>
test   %eax,%eax
jne    c68 <xclose+0x18>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  c72 <xclose+0x22>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   c7e <xclose+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
xclose (int fd)
{
  if (close (fd) != 0)
    close_error (gettext ("(pipe)"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 4
9 4
10 5
11 4
12 4
13 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b30 <via_get_version+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_get_version (osip_via_t * via)
{
  if (via == ((void *)0))
    return ((void *)0);
  return via->version;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
xor    %eax,%eax
push   %rbp
mov    %esi,%ebp
mov    $0x8942,%esi
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
callq  129f <system_fh_txqlen_query+0x1f>
test   %eax,%eax
mov    $0x1,%ecx
js     12b2 <system_fh_txqlen_query+0x32>
mov    0x8(%rbx),%rax
mov    0x10(%rax),%ecx
shr    $0x1f,%ecx
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   12c3 <system_fh_txqlen_query+0x43>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_fh_txqlen_query (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x8942, form->ifr) >= 0)
    select_arg (form, argc, argv, (form->ifr->ifr_ifru.ifru_ivalue >= 0) ? 0 : 1);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 2
9 3
10 3
11 3
12 3
13 6
14 3
15 4
16 4
17 4
18 6
19 6
20 6
21 7
22 7
23 7
24 6
25 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x68(%rdi),%rdi
callq  1d63 <delay_cpio_set_stat+0x13>
lea    0x89(%rax),%rdi
callq  1d6f <delay_cpio_set_stat+0x1f>
mov    %rax,%rbp
mov    0x0(%rip),%rax        # 1d79 <delay_cpio_set_stat+0x29>
lea    0x88(%rbp),%rdi
mov    %rax,0x0(%rbp)
mov    (%rbx),%rax
mov    %rax,0x8(%rbp)
mov    0x8(%rbx),%rax
mov    %rax,0x10(%rbp)
mov    0x10(%rbx),%rax
mov    %rax,0x18(%rbp)
mov    0x18(%rbx),%rax
mov    %rax,0x20(%rbp)
mov    0x20(%rbx),%rax
mov    %rax,0x28(%rbp)
mov    0x28(%rbx),%rax
mov    %rax,0x30(%rbp)
mov    0x30(%rbx),%rax
mov    %rax,0x38(%rbp)
mov    0x38(%rbx),%rax
mov    %rax,0x40(%rbp)
mov    0x40(%rbx),%rax
mov    %rax,0x48(%rbp)
mov    0x48(%rbx),%rax
mov    %rax,0x50(%rbp)
mov    0x50(%rbx),%rax
mov    %rax,0x58(%rbp)
mov    0x58(%rbx),%rax
mov    %rax,0x60(%rbp)
mov    0x60(%rbx),%rax
mov    %rax,0x68(%rbp)
mov    0x68(%rbx),%rax
mov    %rax,0x70(%rbp)
mov    0x70(%rbx),%rax
mov    %rdi,0x70(%rbp)
mov    %rax,0x78(%rbp)
mov    0x68(%rbx),%rsi
callq  1e08 <delay_cpio_set_stat+0xb8>
mov    %r12d,0x80(%rbp)
mov    %rbp,0x0(%rip)        # 1e16 <delay_cpio_set_stat+0xc6>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delay_cpio_set_stat (struct cpio_file_stat *file_stat,
       mode_t invert_permissions)
{
  size_t file_name_len = strlen (file_stat->c_name);
  struct delayed_set_stat *data =
    xmalloc (sizeof (struct delayed_set_stat) + file_name_len + 1);
  data->next = delayed_set_stat_head;
  memcpy (&data->stat, file_stat, sizeof data->stat);
  data->stat.c_name = (char*) (data + 1);
  strcpy (data->stat.c_name, file_stat->c_name);
  data->invert_permissions = invert_permissions;
  delayed_set_stat_head = data;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 6
9 5
10 5
11 7
12 9
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 9
44 8
45 10
46 10
47 11
48 12
49 13
50 13
51 13
52 13
53 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b30 <mu_mailbox_get_stream+0x20>
test   %rsi,%rsi
je     b50 <mu_mailbox_get_stream+0x40>
mov    0x20(%rdi),%rax
test   %rax,%rax
je     b40 <mu_mailbox_get_stream+0x30>
mov    %rax,(%rsi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1006,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x38(%rdi),%rdi
test   %rdi,%rdi
je     b23 <mu_mailbox_get_stream+0x13>
jmpq   b4e <mu_mailbox_get_stream+0x3e>
xchg   %ax,%ax
mov    $0x1005,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_get_stream (mu_mailbox_t mbox, mu_stream_t *pstream)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (pstream == ((void *)0))
    return (0x1000 +5);
  if (mbox->stream == ((void *)0))
    {
      if (mbox->folder)
 return mu_folder_get_stream (mbox->folder, pstream);
    }
  *pstream = mbox->stream;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 7
6 7
7 7
8 12
9 13
10 13
11 13
12 4
13 4
14 4
15 9
16 9
17 9
18 10
19 10
20 6
21 14
22 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 44a <print_filename+0xa>
test   %edx,%edx
je     45a <print_filename+0x1a>
mov    0x0(%rip),%rsi        # 455 <print_filename+0x15>
cmpb   $0x0,(%rsi)
jne    4a8 <print_filename+0x68>
mov    0x0(%rip),%rsi        # 461 <print_filename+0x21>
mov    0x0(%rip),%rdi        # 468 <print_filename+0x28>
callq  46d <print_filename+0x2d>
mov    0x0(%rip),%eax        # 473 <print_filename+0x33>
test   %eax,%eax
je     483 <print_filename+0x43>
mov    0x0(%rip),%rsi        # 47e <print_filename+0x3e>
cmpb   $0x0,(%rsi)
jne    490 <print_filename+0x50>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 497 <print_filename+0x57>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   4a2 <print_filename+0x62>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 4af <print_filename+0x6f>
xor    %eax,%eax
callq  4b6 <print_filename+0x76>
jmp    45a <print_filename+0x1a>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_filename (void)
{
  do { if (color_option && *((filename_color))) printf((sgr_start), ((filename_color))); } while (0);
  fputs_unlocked (filename,stdout);
  do { if (color_option && *((filename_color))) printf((sgr_end), ((filename_color))); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 5
21 5
22 6
23 5
24 5
25 3
26 3
27 3
28 3
29 3
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    (%rcx),%rax
cmp    0x8(%rcx),%rax
je     1410 <gsl_blas_dtrsv+0x30>
mov    $0x14,%ecx
mov    $0x393,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1406 <gsl_blas_dtrsv+0x26>
mov    $0x14,%eax
add    $0x28,%rsp
retq   
cmp    (%r8),%rax
je     1440 <gsl_blas_dtrsv+0x60>
mov    $0x13,%ecx
mov    $0x397,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  142e <gsl_blas_dtrsv+0x4e>
mov    $0x13,%eax
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%r8),%r10
mov    0x18(%rcx),%r9
mov    %r10d,0x10(%rsp)
mov    0x10(%r8),%r8
mov    %r8,0x8(%rsp)
mov    0x10(%rcx),%rcx
mov    %eax,%r8d
mov    %ecx,(%rsp)
mov    %edx,%ecx
mov    %esi,%edx
mov    %edi,%esi
mov    $0x65,%edi
callq  1470 <gsl_blas_dtrsv+0x90>
xor    %eax,%eax
jmp    140b <gsl_blas_dtrsv+0x2b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 915, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (N != X->size)
    {
      do { gsl_error ("invalid length", "blas.c", 919, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_dtrsv (CblasRowMajor, Uplo, TransA, Diag, ((int)(N)), A->data,
               ((int)(A->tda)), X->data, ((int)(X->stride)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 17
12 17
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 17
22 17
23 17
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 16
38 16
39 16
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    0x8(%rdi),%rbx
test   %rbx,%rbx
jne    f06 <release_symbols+0x36>
jmp    f18 <release_symbols+0x48>
nopl   0x0(%rax)
mov    0x8(%rbx),%rax
mov    0x0(%rip),%rdx        # ef3 <release_symbols+0x23>
test   %rax,%rax
mov    %rdx,0x8(%rbx)
mov    %rbx,0x0(%rip)        # f01 <release_symbols+0x31>
je     f18 <release_symbols+0x48>
mov    %rax,%rbx
test   %ebp,%ebp
jne    ee8 <release_symbols+0x18>
mov    (%rbx),%rdi
callq  f12 <release_symbols+0x42>
jmp    ee8 <release_symbols+0x18>
nopl   0x0(%rax)
movq   $0x0,0x8(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
release_symbols(NODE *symlist, int keep_globals)
{
 NODE *p, *next;
 for (p = symlist->sub.nodep.r.rptr; p != ((void *)0); p = next) {
  if (! keep_globals) {
   destroy_symbol(p->sub.nodep.l.lptr);
  }
  next = p->sub.nodep.r.rptr;
  (void) (((BLOCK *) p)->freep = nextfree[BLOCK_NODE].freep, nextfree[BLOCK_NODE].freep = (BLOCK *) p);
 }
 symlist->sub.nodep.r.rptr = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 8
12 9
13 4
14 9
15 9
16 4
17 4
18 5
19 5
20 6
21 6
22 6
23 6
24 11
25 12
26 12
27 12
28 12
29 12
<<<sep_out_sample>>>
movzwl 0xa8(%rdi),%eax
shl    $0x7,%eax
sar    $0x7,%ax
cwtl   
retq   
<<<sep_in_sample>>>
term_ostream__get_color (term_ostream_t stream)
{
  return stream->curr_attr.color;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
callq  ba8 <strob_setlen+0x8>
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
strob_setlen(STROB * strb, int len)
{
 strob_set_length(strb, len);
 return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 267 <get_key_buffer_len+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_key_buffer_len(void)
{
    return key_buffer_len;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 5e <yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  6a <yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  74 <yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
xor    %eax,%eax
sub    $0x1,%rdi
je     16a <ceil_log_2+0x1a>
nopl   0x0(%rax,%rax,1)
add    $0x1,%eax
shr    %rdi
jne    160 <ceil_log_2+0x10>
repz retq 
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
ceil_log_2 (unsigned long n)
{
  int log_2 = 0;
  n--;
  while (n)
    {
      log_2++;
      n >>= 1;
    }
  return log_2;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 5
7 5
8 5
9 11
10 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  851 <xdr_dis_relative_coordinates+0x11>
test   %eax,%eax
jne    860 <xdr_dis_relative_coordinates+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  86c <xdr_dis_relative_coordinates+0x2c>
test   %eax,%eax
je     855 <xdr_dis_relative_coordinates+0x15>
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  87c <xdr_dis_relative_coordinates+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_relative_coordinates(xdrs, objp)
	XDR *xdrs;
	dis_relative_coordinates *objp;
{
	if (!xdr_byte_float(xdrs, &objp->x)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->y)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->z)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm1        # c <Tfun+0xc>
ucomisd 0x0(%rip),%xmm1        # 14 <Tfun+0x14>
jp     28 <Tfun+0x28>
jne    28 <Tfun+0x28>
movsd  0x0(%rip),%xmm0        # 20 <Tfun+0x20>
add    $0x18,%rsp
retq   
nopl   (%rax)
movsd  %xmm1,0x8(%rsp)
callq  33 <Tfun+0x33>
movsd  0x8(%rsp),%xmm1
subsd  0x0(%rip),%xmm1        # 41 <Tfun+0x41>
add    $0x18,%rsp
jmpq   4a <Tfun+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Tfun(double x)
{
  if (dddi == 0.0)
    return 1.0;
  return pow(cos(x), dddi - 1.0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 6
7 6
8 6
9 6
10 6
11 5
12 5
13 5
14 6
15 5
16 5
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  7df <symlink_error+0xf>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 7e8 <symlink_error+0x18>
test   %rax,%rax
je     7ef <symlink_error+0x1f>
callq  *%rax
mov    %r12,%rsi
mov    $0x1,%edi
callq  7fc <symlink_error+0x2c>
mov    %rbp,%rdi
mov    %rax,%r12
callq  807 <symlink_error+0x37>
mov    $0x0,%edi
mov    %rax,%rbp
callq  814 <symlink_error+0x44>
mov    %r12,%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  828 <symlink_error+0x58>
pop    %rbx
pop    %rbp
movl   $0x2,0x0(%rip)        # 834 <symlink_error+0x64>
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
symlink_error (char const *contents, char const *name)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot create symlink to %s"), quotearg_colon (name), quote_n (1, contents)); exit_status = 2; } while (0)
                                                 ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 6
29 6
30 4
31 6
32 6
33 6
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 78 <mousecleanup+0x8>
je     cc <mousecleanup+0x5c>
push   %rbx
xor    %eax,%eax
mov    $0x0,%edi
mov    $0x10,%ebx
callq  8c <mousecleanup+0x1c>
mov    0x0(%rip),%rax        # 93 <mousecleanup+0x23>
cmpq   $0x0,(%rax)
je     c0 <mousecleanup+0x50>
nopl   0x0(%rax)
xor    %eax,%eax
mov    $0x0,%edi
callq  ac <mousecleanup+0x3c>
mov    0x0(%rip),%rax        # b3 <mousecleanup+0x43>
mov    (%rax,%rbx,1),%rax
add    $0x10,%rbx
test   %rax,%rax
jne    a0 <mousecleanup+0x30>
pop    %rbx
movq   $0x0,0x0(%rip)        # cc <mousecleanup+0x5c>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
mousecleanup(void)
{
 int i;
 if (loaded != ((void *)0)) {
  (void) printf("\033[6;0X\033[9;0X");
  for (i = 0; loaded[i].text != ((void *)0); ++i) {
   (void) printf("\033[0;0x");
  }
  loaded = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 6
16 6
17 6
18 6
19 6
20 11
21 9
22 11
23 11
<<<sep_out_sample>>>
push   %rbx
mov    0x60(%rdi),%rdx
mov    %rsi,%rcx
xor    %esi,%esi
mov    %rdi,%rbx
callq  630 <gl_linked_search_from_to>
test   %rax,%rax
je     f98 <gl_linked_remove+0x28>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   eb0 <gl_linked_remove_node>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_remove (gl_list_t list, const void *elt)
{
  gl_list_node_t node = gl_linked_search_from_to (list, 0, list->count, elt);
  if (node != ((void *)0))
    return gl_linked_remove_node (list, node);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 3
7 4
8 4
9 5
10 5
11 8
12 5
13 5
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
add    $0x38,%rsi
jmpq   9 <__rfilename+0x9>
<<<sep_in_sample>>>
__rfilename (long as, __bs1FILE *p)
{
  return (__rcopy (as, &p->filename));
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # a77 <yyset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_out (FILE * out_str )
{
        yyout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    $0x7,%ecx
mov    %rdi,%rbp
mov    $0x0,%edi
mov    %rsi,%r8
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    1330 <set_arg_linux+0x40>
test   %rdx,%rdx
je     1350 <set_arg_linux+0x60>
mov    0x0(%rbp),%rdi
callq  131b <set_arg_linux+0x2b>
mov    %rbx,%rdi
callq  1323 <set_arg_linux+0x33>
mov    %rax,0x0(%rbp)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%edi
mov    $0xc,%ecx
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    1350 <set_arg_linux+0x60>
add    $0x8,%rsp
mov    %rdx,%rdi
pop    %rbx
pop    %rbp
jmpq   1220 <str_to_access_mode_linux>
nop
mov    $0xffffffff,%eax
jmp    1329 <set_arg_linux+0x39>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_arg_linux (void *p_user_data, const char key[], const char value[])
{
  _img_private_t *p_env = p_user_data;
  if (!strcmp (key, "source"))
    {
      if (!value) return DRIVER_OP_ERROR;
      free (p_env->gen.source_name);
      p_env->gen.source_name = strdup (value);
    }
  else if (!strcmp (key, "access-mode"))
    {
      return str_to_access_mode_linux(value);
    }
  else return DRIVER_OP_ERROR;
  return DRIVER_OP_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 2
8 2
9 4
10 4
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 16
20 16
21 16
22 16
23 10
24 10
25 10
26 10
27 10
28 16
29 12
30 16
31 16
32 12
33 12
34 6
35 6
36 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
test   %rsi,%rsi
je     14 <osip_message_set_content_encoding+0x14>
cmpb   $0x0,(%rsi)
jne    20 <osip_message_set_content_encoding+0x20>
add    $0x20,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
mov    %rdi,%rbp
lea    0x18(%rsp),%rdi
mov    %rsi,0x8(%rsp)
callq  32 <osip_message_set_content_encoding+0x32>
test   %eax,%eax
mov    %eax,%ebx
mov    0x8(%rsp),%rsi
jne    14 <osip_message_set_content_encoding+0x14>
mov    0x18(%rsp),%rdi
callq  47 <osip_message_set_content_encoding+0x47>
test   %eax,%eax
mov    %eax,%r12d
jne    70 <osip_message_set_content_encoding+0x70>
mov    0x18(%rsp),%rsi
lea    0xc0(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
mov    $0xffffffff,%edx
callq  6e <osip_message_set_content_encoding+0x6e>
jmp    14 <osip_message_set_content_encoding+0x14>
mov    0x18(%rsp),%rdi
mov    %r12d,%ebx
callq  7d <osip_message_set_content_encoding+0x7d>
jmp    14 <osip_message_set_content_encoding+0x14>
nop
<<<sep_in_sample>>>
osip_message_set_content_encoding (osip_message_t * sip, const char *hvalue)
{
  osip_content_encoding_t *content_encoding;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_content_length_init(&content_encoding);
  if (i != 0)
    return i;
  i = osip_content_length_parse(content_encoding, hvalue);
  if (i != 0) {
    osip_content_length_free (content_encoding);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->content_encodings, content_encoding, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 2
6 5
7 5
8 5
9 5
10 18
11 18
12 18
13 18
14 18
15 18
16 18
17 18
18 7
19 7
20 7
21 8
22 7
23 8
24 8
25 10
26 10
27 11
28 10
29 11
30 16
31 16
32 15
33 16
34 16
35 17
36 12
37 13
38 12
39 13
40 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    0x0(%rip),%edi        # d <gsl_matrix_complex_long_double_get+0xd>
test   %edi,%edi
je     1c <gsl_matrix_complex_long_double_get+0x1c>
cmp    %rdx,(%rsi)
jbe    50 <gsl_matrix_complex_long_double_get+0x50>
cmp    %rcx,0x8(%rsi)
jbe    88 <gsl_matrix_complex_long_double_get+0x88>
imul   0x10(%rsi),%rdx
add    %rdx,%rcx
shl    $0x5,%rcx
add    0x18(%rsi),%rcx
mov    (%rcx),%rdx
mov    %rdx,(%rax)
mov    0x8(%rcx),%rdx
mov    %rdx,0x8(%rax)
mov    0x10(%rcx),%rdx
mov    %rdx,0x10(%rax)
mov    0x18(%rcx),%rdx
mov    %rdx,0x18(%rax)
add    $0x18,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x113,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  6e <gsl_matrix_complex_long_double_get+0x6e>
mov    0x8(%rsp),%rax
fldz   
fstpt  (%rax)
fldt   (%rax)
fstpt  0x10(%rax)
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  a6 <gsl_matrix_complex_long_double_get+0xa6>
mov    0x8(%rsp),%rax
fldz   
fstpt  (%rax)
fldt   (%rax)
fstpt  0x10(%rax)
jmp    4a <gsl_matrix_complex_long_double_get+0x4a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_get(const gsl_matrix_complex_long_double * m,
                     const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      gsl_complex_long_double zero = {{0,0}};
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_long_double.h", 275, GSL_EINVAL) ; return zero ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_long_double.h", 279, GSL_EINVAL) ; return zero ; } while (0) ;
        }
    }
  return *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 7
7 7
8 11
9 11
10 16
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 17
23 17
24 17
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 17
37 17
38 17
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 13
<<<sep_out_sample>>>
callq  1385 <rl_reset_line_state+0x5>
mov    0x0(%rip),%rdx        # 138c <rl_reset_line_state+0xc>
mov    $0x0,%eax
movl   $0x1,0x0(%rip)        # 139b <rl_reset_line_state+0x1b>
test   %rdx,%rdx
cmovne %rdx,%rax
mov    %rax,0x0(%rip)        # 13a9 <rl_reset_line_state+0x29>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_reset_line_state ()
{
  rl_on_new_line ();
  rl_display_prompt = rl_prompt ? rl_prompt : "";
  forced_display = 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 4
6 4
7 4
8 7
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  399 <cpp_reserved_word+0x9>
test   %rax,%rax
je     3b8 <cpp_reserved_word+0x28>
mov    0x8(%rax),%edx
xor    %eax,%eax
cmp    $0x7d0,%edx
cmovg  %edx,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
cpp_reserved_word(const char *str, int len)
{
 struct keyword *keyword;
 keyword = cpp_lookup(str, len);
 return (keyword && ((keyword->token) >= 2001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 6
14 6
15 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,%edx
mov    0x0(%rip),%esi        # 34c <is_hit+0xc>
mov    %rdi,0x8(%rsp)
lea    0x8(%rsp),%rdi
callq  35b <is_hit+0x1b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
is_hit (unsigned char const *hits, int file_number)
{
  return is_hit_1 (&hits, tree8_levels, file_number);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    %rdi,%rax
and    $0xf,%edi
shr    $0x4,%rax
and    $0xf,%eax
lea    (%rax,%rax,4),%rdx
lea    0x0(%rdx),%rax
movzbl 0x0(%rdx),%edx
mov    %dl,(%rsi)
movzbl 0x1(%rax),%edx
mov    %dl,0x1(%rsi)
movzbl 0x2(%rax),%edx
mov    %dl,0x2(%rsi)
movzbl 0x3(%rax),%eax
lea    (%rdi,%rdi,4),%rdx
mov    %al,0x3(%rsi)
lea    0x0(%rdx),%rax
movzbl 0x0(%rdx),%edx
mov    %dl,0x4(%rsi)
movzbl 0x1(%rax),%edx
mov    %dl,0x5(%rsi)
movzbl 0x2(%rax),%edx
mov    %dl,0x6(%rsi)
movzbl 0x3(%rax),%eax
mov    %al,0x7(%rsi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sprint_byte(int i, char *s)
{
  char *c ;
  c=nybble[(i & 0xf0)>>4];
  *s=c[0] ; *(s+1)=c[1] ; *(s+2)=c[2] ; *(s+3)=c[3] ;
  c=nybble[i & 0x0f];
  *(s+4)=c[0] ; *(s+5)=c[1] ; *(s+6)=c[2] ; *(s+7)=c[3] ;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 5
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     bc8 <mu_stream_size+0x18>
mov    0x88(%rdi),%rax
test   %rax,%rax
je     bc8 <mu_stream_size+0x18>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_stream_size (mu_stream_t stream, mu_off_t *psize)
{
  if (stream == ((void *)0) || stream->_size == ((void *)0))
    return 22;
  return stream->_size (stream, psize);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1e80 <gsl_permute_vector_char+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e75 <gsl_permute_vector_char+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1e91 <gsl_permute_vector_char+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_char (const gsl_permutation * p, gsl_vector_char * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_char (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbx
callq  76 <xdico_list_iterator+0x6>
test   %rax,%rax
mov    %rax,%rbx
je     88 <xdico_list_iterator+0x18>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  8d <xdico_list_iterator+0x1d>
cmpl   $0xc,(%rax)
jne    7e <xdico_list_iterator+0xe>
callq  97 <xdico_list_iterator+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdico_list_iterator(dico_list_t list)
{
    dico_iterator_t p = dico_list_iterator(list);
    if (!p && (*__errno_location ()) == 12)
 xalloc_die();
    return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 7
7 7
8 7
9 7
10 4
11 4
12 4
13 5
14 5
<<<sep_out_sample>>>
mov    %edi,%eax
shr    $0x18,%eax
test   %al,%al
jns    1b3 <timeDISToDouble+0x13>
mov    0x0(%rip),%eax        # 1af <timeDISToDouble+0xf>
test   %eax,%eax
jne    1c0 <timeDISToDouble+0x20>
movsd  0x0(%rip),%xmm0        # 1bb <timeDISToDouble+0x1b>
retq   
nopl   0x0(%rax)
and    $0x7fffffff,%edi
sub    $0x18,%rsp
cvtsi2sd %edi,%xmm2
movsd  0x0(%rip),%xmm3        # 1d6 <timeDISToDouble+0x36>
movsd  0x0(%rip),%xmm1        # 1de <timeDISToDouble+0x3e>
movapd %xmm3,%xmm0
movsd  %xmm3,(%rsp)
divsd  0x0(%rip),%xmm2        # 1ef <timeDISToDouble+0x4f>
movsd  %xmm2,0x8(%rsp)
callq  1fa <timeDISToDouble+0x5a>
movsd  (%rsp),%xmm3
movsd  %xmm0,(%rsp)
subsd  %xmm0,%xmm3
movapd %xmm3,%xmm0
divsd  0x0(%rip),%xmm0        # 214 <timeDISToDouble+0x74>
callq  219 <timeDISToDouble+0x79>
movsd  (%rsp),%xmm1
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm3
subsd  %xmm2,%xmm1
ucomisd 0x0(%rip),%xmm1        # 234 <timeDISToDouble+0x94>
ja     260 <timeDISToDouble+0xc0>
movsd  0x0(%rip),%xmm0        # 23e <timeDISToDouble+0x9e>
ucomisd %xmm1,%xmm0
ja     280 <timeDISToDouble+0xe0>
movsd  0x0(%rip),%xmm0        # 24c <timeDISToDouble+0xac>
mulsd  %xmm3,%xmm0
addsd  %xmm2,%xmm0
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
addsd  0x0(%rip),%xmm3        # 268 <timeDISToDouble+0xc8>
movsd  0x0(%rip),%xmm0        # 270 <timeDISToDouble+0xd0>
mulsd  %xmm3,%xmm0
addsd  %xmm2,%xmm0
jmp    254 <timeDISToDouble+0xb4>
nopw   0x0(%rax,%rax,1)
subsd  0x0(%rip),%xmm3        # 288 <timeDISToDouble+0xe8>
movsd  0x0(%rip),%xmm0        # 290 <timeDISToDouble+0xf0>
mulsd  %xmm3,%xmm0
addsd  %xmm2,%xmm0
jmp    254 <timeDISToDouble+0xb4>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timeDISToDouble(dis_timestamp disTime)
{
 double seconds;
 double myseconds;
 double diffseconds;
 double myhour;
 if (disTime.type == 0 || absoluteTime == 0)
  return theTime;
 seconds = disTime.time / timeFactor;
 myseconds = fmod(theTime, 3600.0);
 myhour = rint((theTime - myseconds) / 3600.0);
 diffseconds = myseconds - seconds;
 if (diffseconds > 1800.0)
  return 3600.0 * (myhour + 1) + seconds;
 else if (diffseconds < -1800.0)
  return 3600.0 * (myhour - 1) + seconds;
 else
  return 3600.0 * myhour + seconds;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 8
9 19
10 19
11 9
12 2
13 9
14 10
15 10
16 10
17 10
18 9
19 9
20 10
21 11
22 11
23 11
24 11
25 11
26 11
27 12
28 12
29 11
30 12
31 13
32 13
33 15
34 15
35 15
36 18
37 18
38 18
39 19
40 19
41 19
42 14
43 14
44 14
45 14
46 14
47 14
48 16
49 16
50 16
51 16
52 16
53 16
<<<sep_out_sample>>>
testb  $0x1,0x50(%rdi)
mov    %rdi,%rax
jne    48 <call_chunkfun+0x18>
mov    0x38(%rdi),%rax
mov    %rsi,%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x48(%rdi),%rdi
mov    0x38(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
call_chunkfun (struct obstack *h, size_t size)
{
  if (h->use_extra_arg)
    return h->chunkfun.extra (h->extra_arg, size);
  else
    return h->chunkfun.plain (size);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 6
5 6
6 6
7 6
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <pair_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <pair_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
pair_hash_2 (struct pair *pair)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((pair->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  245 <ssh_init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%r12
mov    (%rax),%r13d
callq  253 <ssh_init_buffer+0x23>
mov    0x0(%rip),%rax        # 25a <ssh_init_buffer+0x2a>
mov    %rbp,(%rbx)
movl   $0x1,0x34(%rbx)
test   %rax,%rax
je     276 <ssh_init_buffer+0x46>
mov    0x0(%rip),%rdx        # 270 <ssh_init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     284 <ssh_init_buffer+0x54>
movl   $0x1,0x2c(%rbx)
movl   $0x0,0x30(%rbx)
xor    %eax,%eax
test   %rbp,%rbp
je     2a2 <ssh_init_buffer+0x72>
mov    %rbp,%rdi
callq  293 <ssh_init_buffer+0x63>
mov    %eax,%edi
callq  29a <ssh_init_buffer+0x6a>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x24(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ssh_init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 ssh_flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
push   %rbx
mov    0xc8(%rdi),%ecx
mov    %rdx,%r9
lea    0xcc(%rdi),%rdx
mov    %rdi,%rbx
mov    %rsi,%r8
mov    $0x48,%esi
callq  b1 <nettle_sha3_512_update+0x21>
mov    %eax,0xc8(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_sha3_512_update (struct sha3_512_ctx *ctx,
   size_t length,
   const uint8_t *data)
{
  ctx->index = _nettle_sha3_update (&ctx->state, 72, ctx->block,
        ctx->index, length, data);
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 4
7 5
8 5
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    $0x1,%ecx
mov    $0x0,%edx
jmpq   31f <mu_property_set+0xf>
nop
<<<sep_in_sample>>>
mu_property_set (mu_property_t prop, const char *key)
{
  return mu_property_set_value (prop, key, "", 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     61e1 <regfree+0x11>
callq  61e1 <regfree+0x11>
mov    0x20(%rbx),%rdi
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
test   %rdi,%rdi
je     6206 <regfree+0x36>
callq  6206 <regfree+0x36>
mov    0x28(%rbx),%rdi
andb   $0xf7,0x38(%rbx)
movq   $0x0,0x20(%rbx)
test   %rdi,%rdi
je     6220 <regfree+0x50>
callq  6220 <regfree+0x50>
movq   $0x0,0x28(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
regfree (preg)
    regex_t *preg;
{
  if (preg->buffer != ((void *)0))
    free (preg->buffer);
  preg->buffer = ((void *)0);
  preg->allocated = 0;
  preg->used = 0;
  if (preg->fastmap != ((void *)0))
    free (preg->fastmap);
  preg->fastmap = ((void *)0);
  preg->fastmap_accurate = 0;
  if (preg->translate != ((void *)0))
    free (preg->translate);
  preg->translate = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 9
8 6
9 7
10 8
11 9
12 9
13 10
14 13
15 12
16 11
17 13
18 13
19 14
20 15
21 16
22 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  196c <gsl_sf_gamma_inc_Q+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1980 <gsl_sf_gamma_inc_Q+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x2cb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1996 <gsl_sf_gamma_inc_Q+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_gamma_inc_Q(const double a, const double x)
{
  gsl_sf_result result; int status = gsl_sf_gamma_inc_Q_e(a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_gamma_inc_Q_e(a, x, &result)", "gamma_inc.c", 715, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  36c <gsl_block_complex_float_calloc+0xc>
test   %rax,%rax
mov    %rax,%rbx
je     3b7 <gsl_block_complex_float_calloc+0x57>
lea    0x0(,%rbp,8),%r12
mov    0x8(%rax),%rdi
xor    %esi,%esi
mov    %r12,%rdx
callq  38a <gsl_block_complex_float_calloc+0x2a>
add    %rbp,%rbp
je     3af <gsl_block_complex_float_calloc+0x4f>
mov    0x8(%rbx),%rcx
lea    (%rcx,%r12,1),%rdx
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rcx)
add    $0x4,%rcx
cmp    %rdx,%rcx
jne    3a0 <gsl_block_complex_float_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    3b2 <gsl_block_complex_float_calloc+0x52>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_float_calloc (const size_t n)
{
  size_t i;
  gsl_block_complex_float * b = gsl_block_complex_float_alloc (n);
  if (b == 0)
    return 0;
  memset(b->data, 0, 2 * n * sizeof(float));
  for (i = 0; i < 2 * n; i++)
    {
      b->data[i] = 0;
    }
  return b;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 8
22 8
23 8
24 13
25 13
26 13
27 13
28 6
29 6
30 6
<<<sep_out_sample>>>
mov    0xe8(%rdi),%rax
mov    %rax,(%rsi)
mov    0xf0(%rdi),%rax
mov    %rax,0x8(%rsi)
mov    0xf8(%rdi),%rax
mov    %rax,0x10(%rsi)
mov    0x100(%rdi),%rax
mov    %rax,0x18(%rsi)
mov    0x108(%rdi),%rax
mov    %rax,0x20(%rsi)
mov    0x110(%rdi),%rax
mov    %rax,0x28(%rsi)
mov    0x118(%rdi),%rax
mov    %rax,0x30(%rsi)
mov    0x120(%rdi),%rax
mov    %rax,0x38(%rsi)
mov    0x128(%rdi),%rax
mov    %rax,0x40(%rsi)
mov    0x130(%rdi),%rax
mov    %rax,0x48(%rsi)
mov    0x138(%rdi),%rax
mov    %rax,0x50(%rsi)
mov    0x140(%rdi),%rax
mov    %rax,0x58(%rsi)
mov    0x148(%rdi),%rax
mov    %rax,0x60(%rsi)
mov    0x150(%rdi),%rax
mov    %rax,0x68(%rsi)
mov    0x158(%rdi),%rax
mov    %rax,0x70(%rsi)
mov    0x160(%rdi),%rax
mov    %rax,0x78(%rsi)
retq   
<<<sep_in_sample>>>
mu_m_server_get_sigset (mu_m_server_t srv, sigset_t *sigset)
{
  *sigset = srv->sigmask;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
lea    0x8(%rsp),%rdi
callq  413 <tcp_conn_free+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tcp_conn_free (void *conn_data, void *server_data)
{
  mu_ip_server_t tcpsrv = (mu_ip_server_t) conn_data;
  mu_ip_server_destroy (&tcpsrv);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
7 5
<<<sep_out_sample>>>
push   %r15
mov    %esi,%r15d
mov    $0x30,%esi
push   %r14
mov    %r8d,%r14d
push   %r13
mov    %r9d,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %ecx,%ebp
mov    %ebp,%edx
push   %rbx
mov    %rdi,%rbx
callq  2aa0 <_alur>
test   %r15d,%r15d
jne    30f0 <_ssecmp+0x60>
mov    %r14d,%ecx
mov    %r13d,%edx
mov    $0x2e,%esi
mov    %rbx,%rdi
callq  2130 <_sser>
mov    %rbx,%rdi
mov    %ebp,%edx
mov    %r12d,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   2fb0 <_cc>
nopw   %cs:0x0(%rax,%rax,1)
mov    %r14d,%r8d
mov    %r13d,%ecx
mov    $0x2e,%edx
mov    $0x66,%esi
mov    %rbx,%rdi
callq  1a80 <_ssexr>
jmp    30cf <_ssecmp+0x3f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_ssecmp(jit_state_t *_jit, jit_bool_t d, jit_int32_t code,
 jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_bool_t rc;
    jit_int32_t reg;
    if ((rc = 1))
 reg = r0;
    else {
 reg = 0;
 _movr(_jit, r0, reg);
    }
    _alur(_jit, 6 << 3, reg, reg);
    if (d)
 _ssexr(_jit,0x66,0x2e,r2,r1);
    else
 _sser(_jit,0x2e,r2,r1);
    _cc(_jit, code, reg);
    if (!rc)
 _xchgr(_jit, r0, reg);
}
<<<sep_in_sample>>>
1 3
2 3
3 12
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 12
13 3
14 3
15 12
16 13
17 13
18 16
19 16
20 16
21 16
22 16
23 17
24 17
25 17
26 20
27 20
28 20
29 20
30 20
31 20
32 17
33 17
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  1b5 <xstat+0x15>
mov    %rax,%rbx
mov    (%rax),%ebp
jmp    1c5 <xstat+0x25>
nopl   0x0(%rax)
cmpl   $0x4,(%rbx)
jne    1d6 <xstat+0x36>
mov    %ebp,(%rbx)
mov    %r12,%rsi
mov    %r13,%rdi
callq  1d2 <xstat+0x32>
test   %eax,%eax
js     1c0 <xstat+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xstat(filename, buf)
    const char *filename;
    struct stat *buf;
{
    int result;
    int old_errno = (*__errno_location ());
    do
    {
 (*__errno_location ()) = old_errno;
 result = stat(filename, buf);
    }
    while (result < 0 && (*__errno_location ()) == 4);
    return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 12
14 12
15 9
16 10
17 10
18 10
19 12
20 12
21 14
22 14
23 14
24 14
25 14
26 14
27 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
cmpq   $0x0,(%rdi)
je     a0c <wordsplit_free_words+0x4c>
mov    0x10(%rdi),%rax
xor    %ebx,%ebx
nopl   (%rax)
mov    0x8(%rbp),%rdx
lea    (%rbx,%rax,1),%rcx
mov    (%rdx,%rcx,8),%rdi
test   %rdi,%rdi
je     a02 <wordsplit_free_words+0x42>
callq  9ee <wordsplit_free_words+0x2e>
mov    0x10(%rbp),%rax
mov    0x8(%rbp),%rdx
lea    (%rbx,%rax,1),%rcx
movq   $0x0,(%rdx,%rcx,8)
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     9d8 <wordsplit_free_words+0x18>
movq   $0x0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_words (struct wordsplit *ws)
{
  size_t i;
  for (i = 0; i < ws->ws_wordc; i++)
    {
      char *p = ws->ws_wordv[ws->ws_offs + i];
      if (p)
 {
   free (p);
   ws->ws_wordv[ws->ws_offs + i] = ((void *)0);
 }
    }
  ws->ws_wordc = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 7
14 7
15 9
16 10
17 10
18 10
19 10
20 4
21 4
22 4
23 13
24 14
25 14
26 14
27 14
28 14
<<<sep_out_sample>>>
jmpq   175 <osip_contact_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_contact_free (osip_contact_t * contact)
{
  osip_from_free ((osip_from_t *) contact);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm0        # 2a8 <gsl_ran_ugaussian_ratio_method+0x8>
jmpq   2ad <gsl_ran_ugaussian_ratio_method+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_ran_ugaussian_ratio_method (const gsl_rng * r)
{
  return gsl_ran_gaussian_ratio_method (r, 1.0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <mkstemp_safer+0x9>
add    $0x8,%rsp
mov    %eax,%edi
jmpq   14 <mkstemp_safer+0x14>
<<<sep_in_sample>>>
mkstemp_safer (char *templ)
{
  return fd_safer (mkstemp (templ));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 3
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rsi        # 208 <smtp_client_greeting+0x8>
mov    %rdi,%rbx
mov    0x18(%rdi),%rdx
xor    %edi,%edi
callq  216 <smtp_client_greeting+0x16>
mov    0x18(%rbx),%rdi
mov    $0x0,%esi
callq  224 <smtp_client_greeting+0x24>
test   %eax,%eax
jne    238 <smtp_client_greeting+0x38>
movl   $0x6,0x10(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
movl   $0x1,0x8(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_client_greeting (struct smtp_client_context *ctx)
{
  smtp_reply_get (0, remote_server, ctx->reply);
  if (smtp_reply_code_eq (ctx->reply, "2"))
    ctx->state = smtp_client_state_helo;
  else
    {
      ctx->status = 76;
      ctx->status = smtp_client_state_stop;
      return;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 9
13 12
14 12
15 12
16 5
17 12
18 12
19 12
<<<sep_out_sample>>>
sub    $0xe8,%rsp
test   %al,%al
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
je     54 <__gmp_snprintf+0x54>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
lea    0xf0(%rsp),%rax
lea    0x18(%rsp),%rcx
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
mov    %rdi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    $0x0,%edi
mov    %rsp,%rsi
movl   $0x18,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
mov    %rax,0x28(%rsp)
callq  96 <__gmp_snprintf+0x96>
add    $0xe8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_snprintf (char *buf, size_t size, const char *fmt, ...)
{
  struct gmp_snprintf_t d;
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  d.buf = buf;
  d.size = size;
  do {} while (0);
  ret = __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 6
16 10
17 6
18 6
19 7
20 8
21 10
22 10
23 6
24 6
25 6
26 10
27 13
28 13
<<<sep_out_sample>>>
addsd  %xmm0,%xmm0
movsd  0x10(%rdi),%xmm1
movsd  0x18(%rdi),%xmm2
mov    0x8(%rdi),%rax
subsd  %xmm1,%xmm0
cmp    %rax,%rsi
cmova  %rax,%rsi
mov    (%rdi),%rax
test   %rsi,%rsi
subsd  %xmm2,%xmm0
subsd  %xmm1,%xmm2
divsd  %xmm2,%xmm0
xorpd  %xmm2,%xmm2
movapd %xmm0,%xmm4
movapd %xmm2,%xmm1
addsd  %xmm0,%xmm4
je     ef <gsl_cheb_eval_n+0x6f>
xorpd  %xmm3,%xmm3
movapd %xmm3,%xmm2
jmp    d8 <gsl_cheb_eval_n+0x58>
nopl   0x0(%rax,%rax,1)
movapd %xmm2,%xmm3
movapd %xmm1,%xmm2
movapd %xmm4,%xmm1
mulsd  %xmm2,%xmm1
subsd  %xmm3,%xmm1
addsd  (%rax,%rsi,8),%xmm1
sub    $0x1,%rsi
jne    d0 <gsl_cheb_eval_n+0x50>
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # fb <gsl_cheb_eval_n+0x7b>
mulsd  (%rax),%xmm1
subsd  %xmm2,%xmm0
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cheb_eval_n (const gsl_cheb_series * cs, const size_t n, const double x)
{
  size_t i;
  double d1 = 0.0;
  double d2 = 0.0;
  size_t eval_order = ((n) < (cs->order) ? (n) : (cs->order));
  double y = (2.0 * x - cs->a - cs->b) / (cs->b - cs->a);
  double y2 = 2.0 * y;
  for (i = eval_order; i >= 1; i--)
    {
      double temp = d1;
      d1 = y2 * d1 - d2 + cs->c[i];
      d2 = temp;
    }
  return y * d1 - d2 + 0.5 * cs->c[0];
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 6
5 7
6 6
7 6
8 6
9 9
10 7
11 7
12 7
13 5
14 8
15 4
16 8
17 9
18 5
19 4
20 4
21 4
22 12
23 12
24 12
25 12
26 12
27 12
28 9
29 9
30 15
31 15
32 15
33 15
34 15
35 16
36 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2d9 <parse_empty+0x9>
movl   $0x3c23d70a,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_empty (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = insert_primary_noarg (entry);
  our_pred->est_success_rate = 0.01f;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 9
5 9
6 9
7 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x21e0,%edi
callq  e <keymap_make_keymap+0xe>
xor    %edx,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x21e0,%rdx
jne    10 <keymap_make_keymap+0x10>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
keymap_make_keymap (void)
{
  int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc ((271 * 2) * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < (271 * 2); i++)
    {
      keymap[i].type = 0;
      keymap[i].value.function = ((void *)0);
    }
  return keymap;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
12 12
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 1d7 <pred_prune+0x7>
je     1f6 <pred_prune+0x26>
cmpb   $0x0,0x0(%rip)        # 1e0 <pred_prune+0x10>
je     20d <pred_prune+0x3d>
test   %rsi,%rsi
je     1f6 <pred_prune+0x26>
mov    0x18(%rsi),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     200 <pred_prune+0x30>
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
movb   $0x1,0x0(%rip)        # 207 <pred_prune+0x37>
mov    $0x1,%eax
retq   
push   %rax
mov    $0x0,%ecx
mov    $0x399,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  227 <pred_prune+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_prune (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  (void) pred_ptr;
  if (options.do_dir_first == 1) {
    ((state.have_stat) ? (void) (0) : __assert_fail ("state.have_stat", "pred.c", 921, __PRETTY_FUNCTION__));
    if (stat_buf != ((void *)0) &&
 ((((stat_buf->st_mode)) & 0170000) == (0040000)))
      state.stop_at_current_level = 1;
  }
  return 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 7
6 7
7 8
8 8
9 7
10 7
11 12
12 12
13 12
14 9
15 12
16 12
17 2
18 6
19 6
20 6
21 6
22 6
23 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     780 <osip_header_get_value+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_header_get_value (const osip_header_t * header)
{
  if (header == ((void *)0))
    return ((void *)0);
  return header->hvalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 3a <add_utmp_file+0xa>
jmpq   3f <add_utmp_file+0xf>
nop
<<<sep_in_sample>>>
add_utmp_file(char *name)
{
  file_reader_add_file(utmp_info, name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x8,%rsp
callq  1298 <namebuf_name+0x18>
mov    0x10(%rbx),%rdx
mov    %rax,%rbp
lea    0x1(%rdx,%rax,1),%rax
cmp    0x8(%rbx),%rax
jb     12ee <namebuf_name+0x6e>
mov    (%rbx),%rdi
lea    0x8(%rbx),%r12
nopl   0x0(%rax)
mov    %r12,%rsi
callq  12c0 <namebuf_name+0x40>
mov    0x10(%rbx),%rdx
mov    %rax,%rdi
mov    %rax,(%rbx)
lea    0x1(%rdx,%rbp,1),%rax
cmp    0x8(%rbx),%rax
jae    12b8 <namebuf_name+0x38>
mov    %r13,%rsi
add    %rdx,%rdi
callq  12e0 <namebuf_name+0x60>
mov    (%rbx),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    (%rbx),%rdi
jmp    12d5 <namebuf_name+0x55>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
namebuf_name (namebuf_t buf, const char *name)
{
  size_t len = strlen (name);
  while (buf->dir_length + len + 1 >= buf->buffer_size)
    buf->buffer = x2realloc (buf->buffer, &buf->buffer_size);
  strcpy (buf->buffer + buf->dir_length, name);
  return buf->buffer;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 2
9 3
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 5
20 4
21 5
22 5
23 4
24 4
25 4
26 6
27 6
28 6
29 7
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   18f3 <gsl_sort_vector_uchar_smallest_index+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_uchar_smallest_index (size_t * p, const size_t k,
                                           const gsl_vector_uchar * v)
{
  return gsl_sort_uchar_smallest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
test   %r8,%r8
movzwl (%rdx),%r10d
push   %rbx
je     12d1 <gsl_stats_ushort_minmax_index+0x51>
add    %rcx,%rcx
mov    %r10d,%r11d
xor    %ebx,%ebx
xor    %ebp,%ebp
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movzwl (%rdx),%r9d
cmp    %r10w,%r9w
jae    12b0 <gsl_stats_ushort_minmax_index+0x30>
mov    %rax,%rbp
mov    %r9d,%r10d
cmp    %r11w,%r9w
jbe    12bc <gsl_stats_ushort_minmax_index+0x3c>
mov    %rax,%rbx
mov    %r9d,%r11d
add    $0x1,%rax
add    %rcx,%rdx
cmp    %r8,%rax
jne    12a0 <gsl_stats_ushort_minmax_index+0x20>
mov    %rbp,(%rdi)
mov    %rbx,(%rsi)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    12c8 <gsl_stats_ushort_minmax_index+0x48>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ushort_minmax_index (size_t * min_index_out,
                                   size_t * max_index_out, const unsigned short data[],
                                   const size_t stride, const size_t n)
{
  unsigned short min = data[0 * stride];
  unsigned short max = data[0 * stride];
  size_t i, min_index = 0, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned short xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  *min_index_out = min_index;
  *max_index_out = max_index;
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 4
5 8
6 8
7 6
8 7
9 7
10 8
11 8
12 10
13 11
14 11
15 11
16 11
17 16
18 16
19 16
20 16
21 8
22 8
23 8
24 8
25 22
26 23
27 24
28 24
29 24
30 7
31 7
32 7
33 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%esi
mov    %rbx,%rdi
sub    $0x8,%rsp
callq  19 <__robouttext+0x19>
jmp    34 <__robouttext+0x34>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  28 <__robouttext+0x28>
mov    %rbp,%rdi
movsbq %al,%rsi
callq  34 <__robouttext+0x34>
mov    %rbx,%rdi
callq  3c <__robouttext+0x3c>
test   %al,%al
jne    20 <__robouttext+0x20>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__robouttext (__bs9FILE *p, __txtvp t)
{
  __rtsetpos (t, 1L);
  while (__rtmore (t))
    __roboutbyte (p, (long) __rtgetchar (t));
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 2
8 3
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 4
17 4
18 4
19 4
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%ecx
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%rax
mov    0x8(%rsi),%rsi
lea    0x1(%rax),%rdx
callq  21 <gsl_histogram_fread+0x21>
test   %eax,%eax
je     30 <gsl_histogram_fread+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x10(%rbx),%rsi
mov    (%rbx),%rdx
add    $0x8,%rsp
pop    %rbx
mov    %rbp,%rdi
mov    $0x1,%ecx
pop    %rbp
jmpq   4a <gsl_histogram_fread+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_fread (FILE * stream, gsl_histogram * h)
{
  int status = gsl_block_raw_fread (stream, h->range, h->n + 1, 1);
  if (status)
    return status;
  status = gsl_block_raw_fread (stream, h->bin, h->n, 1);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 4
12 4
13 8
14 8
15 8
16 8
17 8
18 6
19 6
20 8
21 8
22 6
23 6
24 8
25 6
26 6
<<<sep_out_sample>>>
push   %rbp
lea    0x0(%rip),%rsi        # a568 <open_logfile+0x8>
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rbp        # a574 <open_logfile+0x14>
mov    0x0(%rbp),%rdi
callq  a57d <open_logfile+0x1d>
mov    0x0(%rip),%rbx        # a584 <open_logfile+0x24>
test   %rax,%rax
mov    %rax,(%rbx)
je     a5c8 <open_logfile+0x68>
lea    0x8(%rsp),%rbp
mov    %rbp,%rdi
callq  a599 <open_logfile+0x39>
mov    %rbp,%rdi
callq  a5a1 <open_logfile+0x41>
mov    (%rbx),%rdi
lea    0x0(%rip),%rsi        # a5ab <open_logfile+0x4b>
mov    %rax,%rdx
xor    %eax,%eax
callq  a5b5 <open_logfile+0x55>
mov    0x0(%rip),%rdi        # a5bc <open_logfile+0x5c>
callq  a5c1 <open_logfile+0x61>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%rax        # a5cf <open_logfile+0x6f>
mov    0x0(%rbp),%rcx
lea    0x0(%rip),%rsi        # a5da <open_logfile+0x7a>
mov    (%rax),%rdx
mov    0x0(%rip),%rax        # a5e4 <open_logfile+0x84>
mov    (%rax),%rdi
xor    %eax,%eax
callq  a5ee <open_logfile+0x8e>
xor    %edi,%edi
callq  a5f5 <open_logfile+0x95>
mov    $0x1,%edi
callq  a5ff <open_logfile+0x9f>
<<<sep_in_sample>>>
open_logfile(void)
{
  time_t logtime;
  char * timestr;
  logfile = fopen(logfilename, "at");
  if (!logfile){
    fprintf(stderr, "%s: cannot write to log file '%s'.  ",
            progname, logfilename);
    perror(0);
    exit(1);
  }
  time(&logtime);
  timestr = ctime(&logtime);
  fprintf(logfile, "### Log started %s \n", timestr);
  atexit(close_logfile);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 5
6 5
7 5
8 5
9 6
10 5
11 6
12 12
13 12
14 12
15 13
16 13
17 14
18 14
19 14
20 14
21 14
22 15
23 15
24 16
25 16
26 16
27 16
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 9
37 9
38 10
39 10
<<<sep_out_sample>>>
push   %r14
cmp    %ecx,%edx
mov    %esi,%r14d
push   %r13
lea    -0x1(%rdx),%r13d
push   %r12
mov    %ecx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %edx,%ebx
jge    91 <expand_bottom_edge+0x41>
nopl   0x0(%rax,%rax,1)
mov    %ebx,%ecx
mov    %r14d,%r9d
mov    $0x1,%r8d
mov    %rbp,%rdx
mov    %r13d,%esi
mov    %rbp,%rdi
add    $0x1,%ebx
callq  8c <expand_bottom_edge+0x3c>
cmp    %r12d,%ebx
jne    70 <expand_bottom_edge+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
expand_bottom_edge (JSAMPARRAY image_data, JDIMENSION num_cols,
      int input_rows, int output_rows)
{
  register int row;
  for (row = input_rows; row < output_rows; row++) {
    jcopy_sample_rows(image_data, input_rows-1, image_data, row,
        1, num_cols);
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 6
22 5
23 5
24 9
25 9
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
jmpq   5 <_add_load_dir+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_add_load_dir (void *item, void *unused)
{
    char *str = item;
    return lt_dladdsearchdir(str);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rng_name (const gsl_rng * r)
{
  return r->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    $0x4d2,%esi
je     38 <CDB___db_byteorder+0x38>
cmp    $0x10e1,%esi
mov    $0xffff874f,%eax
je     32 <CDB___db_byteorder+0x32>
test   %esi,%esi
je     38 <CDB___db_byteorder+0x38>
sub    $0x8,%rsp
xor    %eax,%eax
mov    $0x0,%esi
callq  29 <CDB___db_byteorder+0x29>
add    $0x8,%rsp
mov    $0x16,%eax
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
CDB___db_byteorder(dbenv, lorder)
 DB_ENV *dbenv;
 int lorder;
{
 switch (lorder) {
 case 0:
  break;
 case 1234:
  break;
 case 4321:
  return ((-30897));
 default:
  CDB___db_err(dbenv,
     "unsupported byte order, only big and little-endian supported");
  return (22);
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 11
5 5
6 5
7 5
8 4
9 13
10 13
11 13
12 18
13 15
14 18
15 18
16 17
17 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
movslq %esi,%rbx
sub    $0x18,%rsp
mov    0x10(%rdi),%rax
add    0x8(%rdi),%rbx
test   %rax,%rax
je     40 <PreventLexSplit+0x40>
cmpb   $0x0,(%rax)
je     40 <PreventLexSplit+0x40>
mov    %rbx,%rsi
nopl   0x0(%rax)
sub    $0x1,%rsi
cmpb   $0xa,(%rsi)
jne    28 <PreventLexSplit+0x28>
movb   $0x0,(%rsi)
sub    %rbx,%rsi
jne    70 <PreventLexSplit+0x70>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     5a <PreventLexSplit+0x5a>
mov    %esi,0xc(%rsp)
callq  52 <PreventLexSplit+0x52>
test   %eax,%eax
mov    0xc(%rsp),%esi
je     1e <PreventLexSplit+0x1e>
cmp    $0x10000,%esi
je     1e <PreventLexSplit+0x1e>
movb   $0x0,(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rbp),%rdi
add    $0x18,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
jmpq   84 <PreventLexSplit+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
PreventLexSplit (PINPUTBUF pibIn, int iOffset)
{
  long lDelta;
  PBUF pbufEOB = pibIn->pbufOrg + iOffset;
  PBUF pbufEOBOld;
  if (!(!(pibIn) || ((!(pibIn)->pbufCur || !*(pibIn)->pbufCur) && (!(pibIn)->pfileIn || feof((pibIn)->pfileIn))))
      || (iOffset == 0x10000)) {
    pbufEOBOld = pbufEOB;
    while (*(--pbufEOB) != ('\n'))
      ;
    *pbufEOB = '\0';
    if ((lDelta = (long) (pbufEOB - pbufEOBOld)))
      fseek (pibIn->pfileIn, lDelta, 1);
  }
  else *pbufEOB = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 6
7 4
8 6
9 6
10 6
11 6
12 4
13 4
14 9
15 9
16 9
17 11
18 12
19 12
20 16
21 16
22 16
23 16
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 15
35 16
36 16
37 16
38 16
39 16
40 13
41 16
42 13
43 16
44 16
45 13
46 13
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
xor    %eax,%eax
mov    $0x0,%esi
push   %rbp
mov    %r12,%rbp
push   %rbx
mov    (%rdi),%edx
xor    %ebx,%ebx
mov    0x0(%rip),%rdi        # 15c <split_dump+0x1c>
callq  161 <split_dump+0x21>
mov    (%r12),%eax
test   %eax,%eax
jle    1ae <split_dump+0x6e>
nopl   0x0(%rax)
mov    0x8(%rbp),%rcx
mov    0x0(%rip),%rdi        # 17b <split_dump+0x3b>
mov    %ebx,%edx
mov    $0x0,%esi
xor    %eax,%eax
add    $0x18,%rbp
callq  18d <split_dump+0x4d>
mov    0x0(%rbp),%ecx
mov    0x0(%rip),%rdi        # 197 <split_dump+0x57>
mov    %ebx,%edx
xor    %eax,%eax
mov    $0x0,%esi
add    $0x1,%ebx
callq  1a8 <split_dump+0x68>
cmp    %ebx,(%r12)
jg     170 <split_dump+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
split_dump(SPLIT *list)
{
 int i;
 struct part *part;
 fprintf(stderr, "npart: %d\n", list->npart);
 for (i = 0; i < list->npart; i++) {
  part = &list->part[i];
  fprintf(stderr, "string[%d]: |%s|\n", i, part->start);
  fprintf(stderr, "savec[%d] : |%c|\n", i, part->savec);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 2
6 2
7 2
8 5
9 6
10 5
11 5
12 6
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 6
29 9
30 6
31 6
32 11
33 11
34 11
35 11
36 11
<<<sep_out_sample>>>
movl   $0x0,0x30(%rdi)
movl   $0x0,0x34(%rdi)
movzbl 0x3(%rsi),%eax
movzbl 0x2(%rsi),%edx
shl    $0x18,%eax
shl    $0x10,%edx
or     %edx,%eax
movzbl (%rsi),%edx
or     %edx,%eax
movzbl 0x1(%rsi),%edx
shl    $0x8,%edx
or     %edx,%eax
mov    %eax,0x38(%rdi)
movzbl 0x7(%rsi),%eax
movzbl 0x6(%rsi),%edx
shl    $0x18,%eax
shl    $0x10,%edx
or     %edx,%eax
movzbl 0x4(%rsi),%edx
or     %edx,%eax
movzbl 0x5(%rsi),%edx
shl    $0x8,%edx
or     %edx,%eax
mov    %eax,0x3c(%rdi)
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_chacha_set_nonce(struct chacha_ctx *ctx, const uint8_t *nonce)
{
  ctx->state[12] = 0;
  ctx->state[13] = 0;
  ctx->state[14] = ( (((uint32_t) (nonce + 0)[3]) << 24) | (((uint32_t) (nonce + 0)[2]) << 16) | (((uint32_t) (nonce + 0)[1]) << 8) | ((uint32_t) (nonce + 0)[0]));
  ctx->state[15] = ( (((uint32_t) (nonce + 4)[3]) << 24) | (((uint32_t) (nonce + 4)[2]) << 16) | (((uint32_t) (nonce + 4)[1]) << 8) | ((uint32_t) (nonce + 4)[0]));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 15d7 <afm_error+0x7>
mov    %rsi,%rdx
xor    %eax,%eax
mov    $0x0,%esi
jmpq   15e6 <afm_error+0x16>
<<<sep_in_sample>>>
afm_error (AFMHandle handle, char *message)
{
  fprintf (stderr, "AFM Error: %s\n", message);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  8c3 <a2_read_sys_config+0x13>
test   %rax,%rax
mov    %rax,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %rbp,%rdi
xor    %esi,%esi
mov    %rbx,%rdx
callq  8df <a2_read_sys_config+0x2f>
test   %eax,%eax
je     8f0 <a2_read_sys_config+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  8f8 <a2_read_sys_config+0x48>
mov    $0x0,%edi
mov    %rax,%rbp
callq  905 <a2_read_sys_config+0x55>
mov    %rax,%rbx
callq  90d <a2_read_sys_config+0x5d>
mov    (%rax),%esi
add    $0x8,%rsp
mov    %rbx,%rdx
pop    %rbx
mov    %rbp,%rcx
xor    %edi,%edi
xor    %eax,%eax
pop    %rbp
jmpq   924 <a2_read_sys_config+0x74>
<<<sep_in_sample>>>
a2_read_sys_config (a2ps_job * job)
{
  const char *config_file;
  config_file = getenv ("A2PS_CONFIG");
  if (!config_file)
    config_file = "/usr/local/etc/a2ps.cfg";
  if (a2_read_config (job, ((void *)0), config_file))
    return;
  error (0, (*__errno_location ()),
  gettext ("cannot open file `%s'"), quotearg (config_file));
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 6
8 4
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 9
23 9
24 10
25 9
26 10
27 10
28 9
29 9
30 11
31 9
32 11
33 9
34 9
35 9
36 11
37 9
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    2608 <gsl_matrix_uint_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  262a <gsl_matrix_uint_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_column (gsl_matrix_uint * m, const size_t j)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1230 <gsl_vector_ulong_add+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1225 <gsl_vector_ulong_add+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1265 <gsl_vector_ulong_add+0x65>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%rsi
add    %r9,%rcx
add    %rsi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1250 <gsl_vector_ulong_add+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_add (gsl_vector_ulong * a, const gsl_vector_ulong * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x19,%edi
setbe  %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_isalpha (int c)
{
  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     acb <osip_transaction_set_in_socket+0xb>
mov    %esi,0x70(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_set_in_socket (osip_transaction_t * transaction, int sock)
{
  if (transaction == ((void *)0))
    return -2;
  transaction->in_socket = sock;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
mov    $0x178,%edx
push   %r12
mov    %rdi,%r12
mov    $0x18,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
sub    $0x8,%rsp
callq  767 <make_case_command+0x27>
test   %rbp,%rbp
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    %r13d,0x4(%rax)
mov    %r12,0x8(%rax)
je     7b0 <make_case_command+0x70>
cmpq   $0x0,0x0(%rbp)
mov    %rbp,%rax
je     791 <make_case_command+0x51>
mov    %rbp,%rdi
xor    %eax,%eax
callq  791 <make_case_command+0x51>
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%edi
jmpq   7ac <make_case_command+0x6c>
nopl   0x0(%rax)
xor    %eax,%eax
jmp    791 <make_case_command+0x51>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_case_command (word, clauses, lineno)
     WORD_DESC *word;
     PATTERN_LIST *clauses;
     int lineno;
{
  CASE_COM *temp;
  temp = (CASE_COM *)sh_xmalloc((sizeof (CASE_COM)), "make_cmd.c", 376);
  temp->flags = 0;
  temp->line = lineno;
  temp->word = word;
  temp->clauses = ((clauses && clauses->next) ? (PATTERN_LIST *)list_reverse ((GENERIC_LIST *)clauses) : (PATTERN_LIST *)(clauses));
  return (make_command (cm_case, (SIMPLE_COM *)temp));
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 5
5 5
6 7
7 5
8 5
9 7
10 5
11 5
12 7
13 11
14 7
15 8
16 9
17 10
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 13
27 12
28 13
29 13
30 13
31 13
32 12
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     364 <fdGetFp+0x24>
cmpl   $0xbeefdead,0x8(%rdi)
jne    364 <fdGetFp+0x24>
movslq 0xc(%rdi),%rax
lea    (%rax,%rax,2),%rax
mov    0x18(%rdi,%rax,8),%rax
add    $0x8,%rsp
retq   
callq  320 <fdGetFp.part.0>
nopl   0x0(%rax)
<<<sep_in_sample>>>
fdGetFp(FD_t fd) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 180, __PRETTY_FUNCTION__));
    return fd->fps[fd->nfps].fp;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
test   %rax,%rax
je     68 <__rtputchar+0x68>
cmpb   $0x0,0x10(%rax)
jne    58 <__rtputchar+0x58>
movzwl 0xa(%rbx),%eax
cmp    0x8(%rbx),%ax
jbe    31 <__rtputchar+0x31>
mov    $0x0,%edi
callq  2d <__rtputchar+0x2d>
movzwl 0xa(%rbx),%eax
movzwl 0xc(%rbx),%ecx
mov    (%rbx),%rdx
lea    0x1(%rax),%esi
mov    %si,0xa(%rbx)
lea    -0x2(%rcx,%rax,1),%eax
cltq   
mov    %bpl,0x18(%rdx,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  62 <__rtputchar+0x62>
jmp    19 <__rtputchar+0x19>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  72 <__rtputchar+0x72>
mov    (%rbx),%rax
jmp    13 <__rtputchar+0x13>
<<<sep_in_sample>>>
__rtputchar (__txtvp t, char c)
{
  if (t->obj == 0L)
    __rerror ("Putchar: Notext");
  if (t->obj->h.konstant)
    __rerror ("Putchar: Constant text object");
  if (t->pos > t->length)
    __rerror ("Putchar: Illegal pos value");
  t->obj->string[t->start + (t->pos++) - 2] = c;
  return (t);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 7
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 11
30 6
31 6
32 6
33 6
34 4
35 4
36 4
37 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x40,%rsp
mov    %rsp,%rdi
callq  0 <quoting_options_from_style>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  cd0 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_style_mem (int n, enum quoting_style s,
                      char const *arg, size_t argsize)
{
  struct quoting_options const o = quoting_options_from_style (s);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
movzbl (%rdi),%ebx
test   %bl,%bl
je     5d <dico_markup_valid_name_p+0x3d>
js     70 <dico_markup_valid_name_p+0x50>
callq  37 <dico_markup_valid_name_p+0x17>
mov    (%rax),%rdx
jmp    42 <dico_markup_valid_name_p+0x22>
nopl   0x0(%rax)
js     70 <dico_markup_valid_name_p+0x50>
movsbq %bl,%rax
testb  $0x8,(%rdx,%rax,2)
jne    51 <dico_markup_valid_name_p+0x31>
cmp    $0x5f,%bl
jne    70 <dico_markup_valid_name_p+0x50>
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    40 <dico_markup_valid_name_p+0x20>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
dico_markup_valid_name_p(const char *name)
{
    for (; *name; name++)
 if (!((((*name) & ~0x7f) == 0) && (((*__ctype_b_loc ())[(int) ((*name))] & (unsigned short int) _ISalnum) || *name == '_')))
     return 0;
    return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 3
20 3
21 3
22 3
23 7
24 6
25 7
26 7
27 7
28 7
29 7
30 5
31 7
32 7
33 7
34 7
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   2b <direntry_cmp_name+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_name (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return strcmp (dea->name, deb->name);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
movslq %edi,%rdi
shl    $0x3,%rdi
jmpq   3c <strvec_mcreate+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
strvec_mcreate (n)
     int n;
{
  return ((char **)malloc ((n) * sizeof (char *)));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
sub    $0x38,%rsp
movsd  0x0(%rip),%xmm4        # 10bb0 <Ui+0x10>
divsd  0x0(%rip),%xmm2        # 10bb8 <Ui+0x18>
movsd  %xmm4,(%rsp)
movsd  0x0(%rip),%xmm1        # 10bc5 <Ui+0x25>
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
callq  10bd4 <Ui+0x34>
movsd  0x10(%rsp),%xmm2
movsd  %xmm0,0x18(%rsp)
movsd  0x0(%rip),%xmm5        # 10be8 <Ui+0x48>
movapd %xmm2,%xmm0
movsd  0x0(%rip),%xmm1        # 10bf4 <Ui+0x54>
movsd  %xmm5,0x8(%rsp)
movsd  %xmm2,0x28(%rsp)
callq  10c05 <Ui+0x65>
movsd  0x28(%rsp),%xmm2
movsd  %xmm0,0x20(%rsp)
movsd  0x0(%rip),%xmm6        # 10c19 <Ui+0x79>
movapd %xmm2,%xmm0
movsd  0x0(%rip),%xmm1        # 10c25 <Ui+0x85>
movsd  %xmm6,0x10(%rsp)
callq  10c30 <Ui+0x90>
movsd  (%rsp),%xmm1
movsd  0x8(%rsp),%xmm3
mulsd  0x18(%rsp),%xmm1
mulsd  0x20(%rsp),%xmm3
mulsd  0x10(%rsp),%xmm0
movsd  0x28(%rsp),%xmm2
addsd  %xmm3,%xmm1
addsd  %xmm0,%xmm1
movapd %xmm2,%xmm0
mulsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm2        # 10c6b <Ui+0xcb>
mulsd  0x0(%rip),%xmm0        # 10c73 <Ui+0xd3>
addsd  %xmm0,%xmm1
addsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 10c83 <Ui+0xe3>
mulsd  0x0(%rip),%xmm1        # 10c8b <Ui+0xeb>
add    $0x38,%rsp
movapd %xmm1,%xmm0
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Ui(double t)
{
 double W=t/Q;
 return(u[1]*pow(W,5.)+u[2]*pow(W,4.)
  +u[3]*pow(W,3.)+u[4]*pow(W,2.)+u[5]*W+u[6])*Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 4
20 5
21 5
22 5
23 5
24 5
25 4
26 4
27 4
28 4
29 5
30 5
31 4
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 4
41 6
42 6
43 6
44 6
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rsi,%r14
xor    %esi,%esi
push   %r13
mov    %rcx,%r13
push   %r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdx,%rbx
mov    $0x0,%edx
sub    $0x18,%rsp
callq  295 <pair_table_map+0x25>
mov    %rax,%rcx
mov    %rax,0x8(%rsp)
mov    (%rax),%rax
lea    0x8(%rcx),%r15
mov    %rcx,%r12
test   %rax,%rax
je     2e8 <pair_table_map+0x78>
nopl   0x0(%rax)
test   %rbx,%rbx
je     2c2 <pair_table_map+0x52>
mov    0x8(%rax),%rsi
mov    (%rax),%rdi
callq  *%rbx
test   %eax,%eax
je     2d8 <pair_table_map+0x68>
mov    (%r12),%rax
mov    %ebp,%edi
add    $0x1,%ebp
mov    %r13,%rcx
mov    0x8(%rax),%rdx
mov    (%rax),%rsi
callq  *%r14
mov    %r15,%r12
add    $0x8,%r15
mov    -0x8(%r15),%rax
test   %rax,%rax
jne    2b0 <pair_table_map+0x40>
mov    0x8(%rsp),%rdi
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   300 <pair_table_list_short>
<<<sep_in_sample>>>
pair_table_map (struct pair_htable * table,
  pair_ht_map_fn_t map_fn,
  pair_ht_select_fn_t select_fn,
  void const * arg)
{
  int i, num = 0;
  struct pair ** entries;
  entries = (struct pair **)
    hash_dump (table, ((void *)0),
        (hash_cmp_func_t) pair_hash_qcmp);
  for (i = 0 ; entries[i] ; i++) {
    if (!select_fn
 || select_fn (entries[i]-> key, entries[i]->value))
      {
 map_fn (num, entries[i]-> key, entries[i]->value, arg);
 num++;
      }
  }
  free (entries);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 8
5 5
6 5
7 5
8 5
9 6
10 5
11 5
12 8
13 5
14 8
15 8
16 8
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 16
33 15
34 15
35 15
36 15
37 11
38 11
39 11
40 11
41 11
42 19
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 13aa <gsl_matrix_ushort_ptr+0xa>
test   %eax,%eax
je     13b9 <gsl_matrix_ushort_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    13d0 <gsl_matrix_ushort_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    13f0 <gsl_matrix_ushort_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,2),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  13e9 <gsl_matrix_ushort_ptr+0x49>
xor    %eax,%eax
jmp    13c9 <gsl_matrix_ushort_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1409 <gsl_matrix_ushort_ptr+0x69>
xor    %eax,%eax
jmp    13c9 <gsl_matrix_ushort_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_ushort_ptr(gsl_matrix_ushort * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_ushort.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_ushort.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (unsigned short *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     480 <gsl_integration_cquad_workspace_free+0x30>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     467 <gsl_integration_cquad_workspace_free+0x17>
callq  467 <gsl_integration_cquad_workspace_free+0x17>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     475 <gsl_integration_cquad_workspace_free+0x25>
callq  475 <gsl_integration_cquad_workspace_free+0x25>
mov    %rbx,%rdi
pop    %rbx
jmpq   47e <gsl_integration_cquad_workspace_free+0x2e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_integration_cquad_workspace_free (gsl_integration_cquad_workspace * w)
{
  if (w == ((void *)0))
    return;
  if (w->ivals != ((void *)0))
    free (w->ivals);
  if (w->heap != ((void *)0))
    free (w->heap);
  free (w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 6
9 7
10 7
11 7
12 8
13 9
14 10
15 9
16 9
17 10
18 10
19 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # c <gsl_cdf_negative_binomial_P+0xc>
ucomisd %xmm2,%xmm0
ja     40 <gsl_cdf_negative_binomial_P+0x40>
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
ja     40 <gsl_cdf_negative_binomial_P+0x40>
ucomisd %xmm1,%xmm3
ja     70 <gsl_cdf_negative_binomial_P+0x70>
mov    %edi,%edi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm3
addsd  %xmm3,%xmm2
jmpq   36 <gsl_cdf_negative_binomial_P+0x36>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x2a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  59 <gsl_cdf_negative_binomial_P+0x59>
movsd  0x0(%rip),%xmm0        # 61 <gsl_cdf_negative_binomial_P+0x61>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x2f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  89 <gsl_cdf_negative_binomial_P+0x89>
movsd  0x0(%rip),%xmm0        # 91 <gsl_cdf_negative_binomial_P+0x91>
jmp    61 <gsl_cdf_negative_binomial_P+0x61>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_negative_binomial_P (const unsigned int k, const double p, const double n)
{
  double P;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "nbinomial.c", 42, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (n < 0)
    {
      do { gsl_error ("n < 0", "nbinomial.c", 47, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) n;
  b = (double) k + 1.0;
  P = gsl_cdf_beta_P (p, a, b);
  return P;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 10
9 10
10 15
11 18
12 15
13 16
14 16
15 16
16 8
17 8
18 8
19 8
20 8
21 8
22 18
23 18
24 18
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rsi,%rcx
mov    0xe8(%rdi),%rbx
mov    %edx,%esi
mov    %rcx,%rdi
mov    0xd0(%rax),%rax
callq  *0x10(%rax)
mov    0x48(%rbx),%rdx
and    0x4c(%rdx),%eax
cmp    0x48(%rdx),%eax
jbe    11dc <CDB___ham_call_hash+0x2c>
and    0x50(%rdx),%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
CDB___ham_call_hash(dbc, k, len)
 DBC *dbc;
 u_int8_t *k;
 int32_t len;
{
 u_int32_t n, bucket;
 HASH_CURSOR *hcp;
 HASH *hashp;
 hcp = (HASH_CURSOR *)dbc->internal;
 hashp = dbc->dbp->h_internal;
 n = (u_int32_t)(hashp->h_hash(k, len));
 bucket = n & hcp->hdr->high_mask;
 if (bucket > hcp->hdr->max_bucket)
  bucket = bucket & hcp->hdr->low_mask;
 return (bucket);
}
<<<sep_in_sample>>>
1 5
2 10
3 5
4 9
5 11
6 11
7 11
8 11
9 12
10 12
11 13
12 13
13 14
14 16
15 16
16 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # b <give_usage+0xb>
mov    $0x0,%edi
xor    %eax,%eax
callq  17 <give_usage+0x17>
add    $0x8,%rsp
jmpq   20 <desired_entry>
<<<sep_in_sample>>>
give_usage(void)
{
  (void)printf("Usage: %s [-h"
               "p"
               "V] [-f file] [command] ... [user] ... [terminal] ...\n"
               "       [--forwards] [--file <file>] [--strict-match] [--print-controls]\n"
               "       [--user <name>] [--tty <name>] [--command <name>] [--debug]\n"
               "       "
               "[--show-paging] "
               "[--version] [--help]\n", program_name);
  print_acct_file_location ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 12
7 11
<<<sep_out_sample>>>
mov    0x2c(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shcmd_get_dstfd(SHCMD * shcmd)
{
 return shcmd->dstfd_;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  98f <rl_replace_line+0xf>
cmp    0x0(%rip),%eax        # 995 <rl_replace_line+0x15>
mov    %rax,%rbx
jge    9d0 <rl_replace_line+0x50>
mov    0x0(%rip),%rdi        # 9a1 <rl_replace_line+0x21>
mov    %rbp,%rsi
callq  9a9 <rl_replace_line+0x29>
test   %r12d,%r12d
mov    %ebx,0x0(%rip)        # 9b2 <rl_replace_line+0x32>
je     9b9 <rl_replace_line+0x39>
callq  9b9 <rl_replace_line+0x39>
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x1,%edi
jmpq   9c7 <rl_replace_line+0x47>
nopw   0x0(%rax,%rax,1)
mov    %eax,%edi
callq  9d7 <rl_replace_line+0x57>
jmp    99a <rl_replace_line+0x1a>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rl_replace_line (text, clear_undo)
     const char *text;
     int clear_undo;
{
  int len;
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
  rl_end = len;
  if (clear_undo)
    rl_free_undo_list ();
  _rl_fix_point (1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 6
9 7
10 9
11 9
12 9
13 11
14 10
15 11
16 12
17 14
18 14
19 14
20 13
21 13
22 13
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     12e <a_word_hash_1+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    110 <a_word_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
a_word_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct a_word const *) key)->str)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # e68 <checkdb+0x8>
je     e70 <checkdb+0x10>
xor    %eax,%eax
retq   
nopl   (%rax)
xor    %eax,%eax
jmp    e00 <checkdb.part.1>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
checkdb ()
{
  if (!gdbm_file)
    {
      if (!file_name)
 {
   file_name = estrdup ("junk.gdbm");
   terror (dgettext ("gdbm", "warning: using default database file %s"),
   file_name);
 }
      return opendb (file_name);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 14
4 14
5 14
6 14
7 14
8 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  3dc <gsl_sf_bessel_Inu+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3f0 <gsl_sf_bessel_Inu+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x79,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  406 <gsl_sf_bessel_Inu+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Inu(double nu, double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Inu_e(nu, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Inu_e(nu, x, &result)", "bessel_Inu.c", 121, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x2f,(%rdi)
sete   %bpl
callq  17 <dir_len+0x17>
mov    %rax,%rcx
sub    %rbx,%rcx
cmp    %rbp,%rcx
jbe    4d <dir_len+0x4d>
cmpb   $0x2f,-0x1(%rax)
lea    -0x1(%rcx),%rdx
je     3e <dir_len+0x3e>
jmp    4d <dir_len+0x4d>
xchg   %ax,%ax
cmpb   $0x2f,-0x1(%rbx,%rdx,1)
lea    -0x1(%rdx),%rax
jne    43 <dir_len+0x43>
mov    %rax,%rdx
cmp    %rdx,%rbp
jb     30 <dir_len+0x30>
add    $0x8,%rsp
mov    %rdx,%rax
pop    %rbx
pop    %rbp
retq   
mov    %rcx,%rdx
jmp    43 <dir_len+0x43>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dir_len (char const *file)
{
  size_t prefix_length = 0;
  size_t length;
  prefix_length += (prefix_length != 0
                    ? (0
                       && ((file[prefix_length]) == '/'))
                    : (((file[0]) == '/')
                       ? ((0
                           && ((file[1]) == '/') && ! ((file[2]) == '/')
                           ? 2 : 1))
                       : 0));
  for (length = last_component (file) - file;
       prefix_length < length; length--)
    if (! ((file[length - 1]) == '/'))
      break;
  return length;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 13
23 13
24 18
25 18
26 18
27 18
28 18
29 15
30 15
31 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm1        # e7c <gsl_complex_arcsin_real+0xc>
movsd  0x0(%rip),%xmm2        # e84 <gsl_complex_arcsin_real+0x14>
andpd  %xmm0,%xmm1
ucomisd %xmm1,%xmm2
jae    ee8 <gsl_complex_arcsin_real+0x78>
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
ja     ec0 <gsl_complex_arcsin_real+0x50>
callq  e9d <gsl_complex_arcsin_real+0x2d>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # ea9 <gsl_complex_arcsin_real+0x39>
xorpd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # eb5 <gsl_complex_arcsin_real+0x45>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm1        # ec8 <gsl_complex_arcsin_real+0x58>
xorpd  %xmm1,%xmm0
callq  ed1 <gsl_complex_arcsin_real+0x61>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # edd <gsl_complex_arcsin_real+0x6d>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
callq  eed <gsl_complex_arcsin_real+0x7d>
xorpd  %xmm1,%xmm1
jmp    eb5 <gsl_complex_arcsin_real+0x45>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_arcsin_real (double a)
{
  gsl_complex z;
  if (fabs (a) <= 1.0)
    {
      do {(&z)->dat[0]=(asin (a)); (&z)->dat[1]=(0.0);} while(0);
    }
  else
    {
      if (a < 0.0)
        {
          do {(&z)->dat[0]=(-1.57079632679489661923); (&z)->dat[1]=(acosh (-a));} while(0);
        }
      else
        {
          do {(&z)->dat[0]=(1.57079632679489661923); (&z)->dat[1]=(-acosh (a));} while(0);
        }
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 10
8 10
9 10
10 16
11 16
12 16
13 16
14 16
15 20
16 20
17 20
18 12
19 12
20 12
21 12
22 12
23 20
24 20
25 20
26 6
27 6
28 6
29 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10,%edi
callq  17e <swheader_state_create+0xe>
movq   $0x0,(%rax)
movl   $0xffffffff,0x8(%rax)
movl   $0xffffffff,0xc(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swheader_state_create(void)
{
 SWHEADER_STATE * x;
 x = malloc (sizeof(SWHEADER_STATE));
   x->save_current_offset_pM = ((void *)0);
 x->save_current_offsetM = -1;
 x->save_current_offset_vM = -1;
 return x;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 9
8 9
9 9
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    %rdx,%rcx
cmp    $0x1,%eax
je     2e8 <gc_hash_write+0x28>
cmp    $0x2,%eax
jne    2e0 <gc_hash_write+0x20>
lea    0xb8(%rdi),%rdx
mov    %rcx,%rdi
jmpq   2de <gc_hash_write+0x1e>
xchg   %ax,%ax
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x1c(%rdi),%rdx
mov    %rcx,%rdi
jmpq   2f4 <gc_hash_write+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gc_hash_write (gc_hash_handle handle, size_t len, const char *data)
{
  _gc_hash_ctx *ctx = handle;
  switch (ctx->alg)
    {
    case GC_MD5:
      md5_process_bytes (data, len, &ctx->md5Context);
      break;
    case GC_SHA1:
      sha1_process_bytes (data, len, &ctx->sha1Context);
      break;
    default:
      break;
    }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 10
8 10
9 10
10 10
11 10
12 10
13 7
14 7
15 7
16 7
<<<sep_out_sample>>>
mov    0x878(%rdi),%eax
orl    $0x1,0x880(%rdi)
test   %eax,%eax
jle    30 <press_m61a1+0x30>
sub    $0x8,%rsp
mov    $0x5,%esi
callq  1f <press_m61a1+0x1f>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
press_m61a1(craft * c)
{
 c->station[0].info3 |= 1;
 if (c->station[0].info > 0) {
  playContinuousSound(c, 5);
 }
 return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 2
6 5
7 5
8 8
9 8
10 8
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
push   %r12
movapd %xmm0,%xmm3
movapd %xmm1,%xmm2
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  11a6 <gsl_sf_rect_to_polar+0x26>
movsd  (%rbx),%xmm0
ucomisd 0x0(%rip),%xmm0        # 11b2 <gsl_sf_rect_to_polar+0x32>
jbe    1200 <gsl_sf_rect_to_polar+0x80>
movsd  (%rsp),%xmm3
mov    %eax,%r12d
movsd  0x8(%rsp),%xmm2
movapd %xmm3,%xmm1
movapd %xmm2,%xmm0
callq  11cf <gsl_sf_rect_to_polar+0x4f>
movsd  0x0(%rip),%xmm1        # 11d7 <gsl_sf_rect_to_polar+0x57>
mov    %r12d,%eax
movsd  %xmm0,0x0(%rbp)
andpd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # 11eb <gsl_sf_rect_to_polar+0x6b>
movsd  %xmm0,0x8(%rbp)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm4        # 1208 <gsl_sf_rect_to_polar+0x88>
mov    $0x1,%ecx
mov    $0x210,%edx
mov    $0x0,%esi
mov    $0x0,%edi
movsd  %xmm4,0x0(%rbp)
movsd  %xmm4,0x8(%rbp)
callq  122b <gsl_sf_rect_to_polar+0xab>
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_sf_rect_to_polar(const double x, const double y,
                          gsl_sf_result * r, gsl_sf_result * theta)
{
  int stat_h = gsl_sf_hypot_e(x, y, r);
  if(r->val > 0.0) {
    theta->val = atan2(y, x);
    theta->err = 2.0 * 2.2204460492503131e-16 * fabs(theta->val);
    return stat_h;
  }
  else {
    do { (theta)->val = (__builtin_nanf ("")); (theta)->err = (__builtin_nanf ("")); do { gsl_error ("domain error", "trig.c", 528, GSL_EDOM) ; return GSL_EDOM ; } while (0); } while(0);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 8
23 6
24 7
25 7
26 7
27 13
28 13
29 13
30 13
31 13
32 13
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 13
42 11
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     73 <set_program_name+0x73>
mov    $0x2f,%esi
callq  13 <set_program_name+0x13>
test   %rax,%rax
je     63 <set_program_name+0x63>
lea    0x1(%rax),%rdx
mov    %rdx,%rcx
sub    %rbx,%rcx
cmp    $0x6,%rcx
jle    63 <set_program_name+0x63>
lea    -0x6(%rax),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    63 <set_program_name+0x63>
mov    $0x3,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    %rdx,%rbx
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    63 <set_program_name+0x63>
lea    0x4(%rax),%rbx
mov    %rbx,0x0(%rip)        # 63 <set_program_name+0x63>
mov    %rbx,0x0(%rip)        # 6a <set_program_name+0x6a>
mov    %rbx,0x0(%rip)        # 71 <set_program_name+0x71>
pop    %rbx
retq   
mov    0x0(%rip),%rcx        # 7a <set_program_name+0x7a>
mov    $0x37,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  8e <set_program_name+0x8e>
callq  93 <set_program_name+0x93>
<<<sep_in_sample>>>
set_program_name (const char *argv0)
{
  const char *slash;
  const char *base;
  if (argv0 == ((void *)0))
    {
      fputs ("A NULL argv[0] was passed through an exec system call.\n",
             stderr);
      abort ();
    }
  slash = strrchr (argv0, '/');
  base = (slash != ((void *)0) ? slash + 1 : argv0);
  if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
    {
      argv0 = base;
      if (strncmp (base, "lt-", 3) == 0)
        {
          argv0 = base + 3;
          program_invocation_short_name = (char *) argv0;
        }
    }
  program_name = argv0;
  program_invocation_name = (char *) argv0;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 11
6 11
7 12
8 12
9 12
10 12
11 12
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 16
22 16
23 12
24 16
25 16
26 16
27 16
28 18
29 19
30 22
31 23
32 24
33 24
34 7
35 7
36 7
37 7
38 7
39 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 214b <xmitAO+0xb>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xff,(%rax)
callq  215d <xmitAO+0x1d>
mov    0x0(%rip),%rax        # 2164 <xmitAO+0x24>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xf5,(%rax)
callq  2176 <xmitAO+0x36>
mov    $0xf5,%edx
mov    $0xff,%esi
mov    $0x0,%edi
callq  218a <xmitAO+0x4a>
mov    0x0(%rip),%eax        # 2190 <xmitAO+0x50>
test   %eax,%eax
jne    21a0 <xmitAO+0x60>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
jmpq   0 <doflush>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xmitAO (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 245; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 245);
  if (autoflush)
    {
      doflush ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 9
20 9
21 9
22 9
23 7
24 7
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  6b3 <seek_error_details+0x23>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 6bc <seek_error_details+0x2c>
test   %rax,%rax
je     6c3 <seek_error_details+0x33>
callq  *%rax
mov    %rsp,%rsi
mov    %r12,%rdi
callq  6ce <seek_error_details+0x3e>
mov    %rbp,%rdi
mov    %rax,%r12
callq  6d9 <seek_error_details+0x49>
mov    $0x0,%edi
mov    %rax,%rbp
callq  6e6 <seek_error_details+0x56>
xor    %edi,%edi
mov    %rax,%rdx
mov    %r12,%r8
xor    %eax,%eax
mov    %rbp,%rcx
mov    %ebx,%esi
callq  6fa <seek_error_details+0x6a>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
movl   $0x2,0x0(%rip)        # 712 <seek_error_details+0x82>
jne    71d <seek_error_details+0x8d>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  722 <seek_error_details+0x92>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
seek_error_details (char const *name, off_t offset)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot seek to %s"), quotearg_colon (name), umaxtostr (offset, buf)); exit_status = 2; } while (0)
                                   ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 5
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     90 <_cdio_strfreev+0x40>
mov    0x0(%rbp),%rdi
lea    0x8(%rbp),%rbx
test   %rdi,%rdi
je     82 <_cdio_strfreev+0x32>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rbx
callq  79 <_cdio_strfreev+0x29>
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    70 <_cdio_strfreev+0x20>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   90 <_cdio_strfreev+0x40>
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x42,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x5,%edi
xor    %eax,%eax
callq  b7 <_cdio_strfreev+0x67>
jmp    5e <_cdio_strfreev+0xe>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_cdio_strfreev(char **strv)
{
  int n;
  { if (__builtin_expect((!(strv != ((void *)0))),0)) cdio_log (CDIO_LOG_ASSERT, "file %s: line %d (%s): assertion failed: (%s)", "util.c", 66, __PRETTY_FUNCTION__, "strv != NULL"); };
  for(n = 0; strv[n]; n++)
    free(strv[n]);
  free(strv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 5
15 5
16 5
17 8
18 7
19 8
20 8
21 7
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_long_data (const gsl_block_long * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0xffffffffffffffff,%rax
je     a4 <dstrrchr+0x24>
mov    0x10(%rdi),%rcx
test   %rcx,%rcx
je     d8 <dstrrchr+0x58>
cmp    $0xff,%esi
mov    $0xffffffffffffffff,%rax
jbe    b0 <dstrrchr+0x30>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rdi),%rdx
add    %rdx,%rax
movzbl -0x1(%rcx,%rdx,1),%edx
cmp    %esi,%edx
je     cc <dstrrchr+0x4c>
nop
sub    $0x1,%rax
movzbl (%rcx,%rax,1),%edx
cmp    %esi,%edx
jne    c0 <dstrrchr+0x40>
add    $0x1,%rax
retq   
nopl   0x0(%rax)
cmpq   $0x0,(%rdi)
je     95 <dstrrchr+0x15>
xchg   %ax,%ax
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dstrrchr (string, c)
     DStr_string_descriptor *string;
     unsigned int c;
{
  size_t i;
  if ((string) == ((void *)0) || ((string)->string == ((void *)0) && (string)->length != 0))
    return -1;
  if (c > 255)
    return -1;
  for (i = string->length - 1; i >= 0; i--)
    if (string->string[i] == c)
      return i + 1;
  return 0;
  }
<<<sep_in_sample>>>
1 6
2 7
3 6
4 6
5 6
6 6
7 8
8 7
9 8
10 14
11 14
12 10
13 10
14 11
15 11
16 11
17 11
18 10
19 11
20 11
21 11
22 12
23 12
24 12
25 6
26 6
27 6
28 14
29 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  e <next_char+0xe>
cmp    $0xa,%eax
mov    %eax,%ebx
je     30 <next_char+0x30>
addl   $0x1,0x0(%rip)        # 1c <next_char+0x1c>
cmp    $0x5c,%eax
je     50 <next_char+0x50>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
addl   $0x1,0x0(%rip)        # 37 <next_char+0x37>
movl   $0x0,0x0(%rip)        # 41 <next_char+0x41>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  58 <next_char+0x58>
cmp    $0xa,%eax
je     70 <next_char+0x70>
mov    %rbp,%rsi
mov    %eax,%edi
callq  67 <next_char+0x67>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
mov    %rbp,%rdi
addl   $0x1,0x0(%rip)        # 7a <next_char+0x7a>
movl   $0x0,0x0(%rip)        # 84 <next_char+0x84>
callq  89 <next_char+0x89>
addl   $0x1,0x0(%rip)        # 90 <next_char+0x90>
mov    %eax,%ebx
jmp    21 <next_char+0x21>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_char(FILE *infile)
{
 int c = fgetc(infile);
 if (c == '\n')
  do { (grecs_current_locus_point).line++; (grecs_current_locus_point).col = 0; } while (0);
 else {
  grecs_current_locus_point.col++;
  if (c == '\\') {
   int nc = fgetc(infile);
   if (nc == '\n') {
    do { (grecs_current_locus_point).line++; (grecs_current_locus_point).col = 0; } while (0);
    c = fgetc(infile);
    grecs_current_locus_point.col++;
   } else
    ungetc(nc, infile);
  }
 }
 return c;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 7
10 8
11 8
12 19
13 19
14 19
15 19
16 19
17 19
18 5
19 5
20 19
21 19
22 19
23 19
24 19
25 19
26 9
27 9
28 10
29 10
30 15
31 15
32 15
33 19
34 19
35 19
36 19
37 19
38 12
39 11
40 11
41 12
42 13
43 12
44 12
45 12
<<<sep_out_sample>>>
mov    (%rdi),%eax
imul   $0x6c078965,%eax,%eax
mov    %rax,(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
ran_get (void *vstate)
{
  ran_state_t *state = (ran_state_t *) vstate;
  state->x = (1812433253UL * state->x) & 0xffffffffUL;
  return state->x;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
mov    $0xffffffffffffffff,%r8
jmpq   13ec <quotearg_n_custom+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
quotearg_n_custom (int n, char const *left_quote,
     char const *right_quote, char const *arg)
{
  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,
    ((size_t) -1));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x58(%rdi),%rdi
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x4000,%esi
callq  1d72 <init_idh_tables+0x22>
lea    0xb0(%rbx),%rdi
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x4000,%esi
callq  1d93 <init_idh_tables+0x43>
lea    0x1b8(%rbx),%rdi
mov    $0x0,%r8d
mov    $0x0,%ecx
pop    %rbx
mov    $0x0,%edx
mov    $0x4000,%esi
jmpq   1db5 <init_idh_tables+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_idh_tables (struct idhead *idhp)
{
  hash_init (&idhp->idh_member_file_table, 16*1024,
      member_file_hash_1, member_file_hash_2, member_file_hash_compare);
  hash_init (&idhp->idh_file_link_table, 16*1024,
      file_link_hash_1, file_link_hash_2, file_link_hash_compare);
  hash_init (&idhp->idh_dev_ino_table, 16*1024,
      dev_ino_hash_1, dev_ino_hash_2, dev_ino_hash_compare);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 9
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
xor    %eax,%eax
movb   $0x0,0xa(%rdi)
mov    %ax,0x8(%rdi)
lea    0x0(%rip),%rax        # 201 <nettle_base64_encode_init+0x11>
mov    %rax,(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_base64_encode_init(struct base64_encode_ctx *ctx)
{
  ctx->word = ctx->bits = 0;
  ctx->alphabet = base64_encode_table;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4a0 <gl_array_sortedlist_indexof_from_to>
add    $0x8,%rsp
add    $0x1,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_sortedlist_search_from_to (gl_list_t list,
                                    gl_listelement_compar_fn compar,
                                    size_t low, size_t high,
                                    const void *elt)
{
  size_t index =
    gl_array_sortedlist_indexof_from_to (list, compar, low, high, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 5
2 6
3 9
4 8
5 9
6 9
<<<sep_out_sample>>>
test   %rcx,%rcx
je     60c <gsl_permute_complex_float+0xac>
push   %rbp
lea    (%rdx,%rdx,1),%r11
lea    0x0(,%rdx,8),%rbp
xor    %edx,%edx
push   %rbx
mov    %rsi,%rbx
nopl   0x0(%rax)
mov    (%rdi,%rdx,8),%rax
cmp    %rax,%rdx
jae    599 <gsl_permute_complex_float+0x39>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%rdx
jb     590 <gsl_permute_complex_float+0x30>
cmp    %rax,%rdx
ja     5f7 <gsl_permute_complex_float+0x97>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     5f7 <gsl_permute_complex_float+0x97>
movss  (%rbx),%xmm2
movss  0x4(%rbx),%xmm1
jmp    5be <gsl_permute_complex_float+0x5e>
nopw   0x0(%rax,%rax,1)
mov    %r8,%rax
mov    %r10,%r8
mov    %r8,%r9
mov    (%rdi,%r8,8),%r10
imul   %r11,%r9
imul   %r11,%rax
cmp    %r10,%rdx
movss  (%rsi,%r9,4),%xmm0
movss  %xmm0,(%rsi,%rax,4)
movss  0x4(%rsi,%r9,4),%xmm0
movss  %xmm0,0x4(%rsi,%rax,4)
jne    5b8 <gsl_permute_complex_float+0x58>
movss  %xmm2,(%rsi,%r9,4)
movss  %xmm1,0x4(%rsi,%r9,4)
add    $0x1,%rdx
add    %rbp,%rbx
cmp    %rcx,%rdx
jne    580 <gsl_permute_complex_float+0x20>
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
xor    %eax,%eax
retq   
nop
<<<sep_in_sample>>>
gsl_permute_complex_float (const size_t * p, float * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        float t[2];
        for (a = 0; a < 2; a++)
          t[a] = data[i*stride*2 + a];
        while (pk != i)
          {
            for (a = 0; a < 2; a++)
              {
                float r1 = data[pk*stride*2 + a];
                data[k*stride*2 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 2; a++)
          data[k*stride*2 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 18
5 18
6 4
7 2
8 2
9 2
10 6
11 7
12 7
13 7
14 8
15 7
16 7
17 9
18 9
19 11
20 12
21 12
22 18
23 18
24 18
25 18
26 27
27 27
28 27
29 27
30 27
31 27
32 19
33 23
34 24
35 23
36 24
37 19
38 30
39 30
40 4
41 4
42 4
43 4
44 34
45 34
46 34
47 34
48 34
49 34
50 34
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    0x0(%rip),%rdi        # 5e <yy_fatal_error+0xe>
mov    $0x0,%esi
xor    %eax,%eax
callq  6a <yy_fatal_error+0x1a>
mov    $0x2,%edi
callq  74 <yy_fatal_error+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     c0 <osip_from_free+0x50>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     87 <osip_from_free+0x17>
callq  87 <osip_from_free+0x17>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     9d <osip_from_free+0x2d>
mov    0x0(%rip),%rax        # 96 <osip_from_free+0x26>
test   %rax,%rax
je     d8 <osip_from_free+0x68>
callq  *%rax
lea    0x10(%rbx),%rdi
callq  a6 <osip_from_free+0x36>
mov    0x0(%rip),%rax        # ad <osip_from_free+0x3d>
mov    %rbx,%rdi
test   %rax,%rax
je     c8 <osip_from_free+0x58>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   d5 <osip_from_free+0x65>
nopl   (%rax)
callq  dd <osip_from_free+0x6d>
jmp    9d <osip_from_free+0x2d>
nop
<<<sep_in_sample>>>
osip_from_free (osip_from_t * from)
{
  if (from == ((void *)0))
    return;
  if (from->url != ((void *)0)) {
    osip_uri_free (from->url);
  }
  { if (from->displayname!=((void *)0)) { if (osip_free_func) osip_free_func(from->displayname); else free(from->displayname);} };
  osip_uri_param_freelist(&from->gen_params);
  { if (from!=((void *)0)) { if (osip_free_func) osip_free_func(from); else free(from);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 10
19 10
20 10
21 10
22 11
23 10
24 10
25 11
26 11
27 11
28 11
29 11
30 10
31 10
32 8
33 8
34 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  19ac <gsl_sf_legendre_H3d_0+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    19c0 <gsl_sf_legendre_H3d_0+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x22d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19d6 <gsl_sf_legendre_H3d_0+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_H3d_0(const double lambda, const double eta)
{
  gsl_sf_result result; int status = gsl_sf_legendre_H3d_0_e(lambda, eta, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_legendre_H3d_0_e(lambda, eta, &result)", "legendre_H3d.c", 557, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exact_refcnt (RC_REGEX *regex)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x10(%rdi),%rdi
callq  4dd <message_free+0xd>
lea    0x18(%rbx),%rdi
callq  4e6 <message_free+0x16>
lea    0x20(%rbx),%rdi
callq  4ef <message_free+0x1f>
mov    0x28(%rbx),%rdi
callq  4f8 <message_free+0x28>
mov    0x30(%rbx),%rdi
callq  501 <message_free+0x31>
mov    %rbx,%rdi
pop    %rbx
jmpq   50a <message_free+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_free (MESSAGE msg)
{
  destroy_assoc_list (&msg->commands);
  destroy_assoc_list (&msg->header);
  destroy_string_list (&msg->mime_hdr);
  free (msg->body);
  free (msg->boundary);
  free (msg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 9
15 8
16 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0xd8,%rsp
lea    0x10(%rsp),%rdi
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0xc8(%rsp)
xor    %eax,%eax
callq  3bd <chk_md5+0x3d>
mov    %rbp,%rdi
callq  3c5 <chk_md5+0x45>
lea    0x10(%rsp),%rdx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  3d5 <chk_md5+0x55>
lea    0xb0(%rsp),%rsi
lea    0x10(%rsp),%rdi
callq  3e7 <chk_md5+0x67>
mov    %rbx,%rdi
callq  3ef <chk_md5+0x6f>
lea    0x8(%rsp),%rdx
mov    %rsp,%rcx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  402 <chk_md5+0x82>
test   %eax,%eax
jne    468 <chk_md5+0xe8>
cmpq   $0x10,(%rsp)
jne    450 <chk_md5+0xd0>
mov    0x8(%rsp),%rbx
lea    0xb0(%rsp),%rdi
mov    $0x10,%edx
mov    %rbx,%rsi
callq  427 <chk_md5+0xa7>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  431 <chk_md5+0xb1>
mov    %ebp,%eax
mov    0xc8(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    46f <chk_md5+0xef>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x8(%rsp),%rdi
callq  45a <chk_md5+0xda>
mov    $0xffffffff,%eax
jmp    433 <chk_md5+0xb3>
nopl   0x0(%rax)
mov    $0xffffffff,%eax
jmp    433 <chk_md5+0xb3>
callq  474 <chk_md5+0xf4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chk_md5(const char *db_pass, const char *pass)
{
    unsigned char md5digest[16];
    struct md5_ctx md5context;
    size_t size = 0;
    unsigned char *buf = ((void *)0);
    int rc;
    md5_init_ctx(&md5context);
    md5_process_bytes(pass, strlen(pass), &md5context);
    md5_finish_ctx(&md5context, md5digest);
    if (dico_base64_decode((unsigned char*)db_pass, strlen(db_pass),
      &buf, &size))
 return -1;
    if (size != 16) {
 free(buf);
 return -1;
    }
    rc = memcmp(md5digest, buf, sizeof md5digest);
    free(buf);
    return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 8
7 5
8 6
9 2
10 2
11 2
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 14
32 14
33 18
34 18
35 18
36 18
37 18
38 19
39 18
40 19
41 20
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 15
50 15
51 16
52 16
53 16
54 13
55 13
56 21
57 21
<<<sep_out_sample>>>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,(%rdi)
je     538 <swiAddObjectToList+0x48>
add    $0x1,%eax
add    $0x8,%rdi
cmp    $0x9,%eax
jne    4f8 <swiAddObjectToList+0x8>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 515 <swiAddObjectToList+0x25>
mov    $0x0,%edi
mov    $0x28,%edx
mov    $0x1,%esi
callq  529 <swiAddObjectToList+0x39>
mov    $0x58,%edi
callq  533 <swiAddObjectToList+0x43>
nopl   0x0(%rax,%rax,1)
mov    %rsi,(%rdi)
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
swiAddObjectToList(void ** pp, void * p)
{
 int i;
 for(i=0; i < (10 - 1); i++) {
  if (*(pp+i) == (void*)((void *)0)) {
   *(pp+i) = p;
   return 0;
  }
 }
 fprintf(stderr, "too many contained objects, fatal error\n");
 exit(88);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 4
6 4
7 4
8 4
9 2
10 10
11 10
12 10
13 10
14 10
15 11
16 11
17 11
18 6
19 12
20 12
21 12
<<<sep_out_sample>>>
cmp    $0x9,%rdi
push   %rbx
jg     5bd0 <get_dollar_var_value+0x40>
mov    0x0(,%rdi,8),%rbx
test   %rbx,%rbx
je     5c02 <get_dollar_var_value+0x72>
mov    %rbx,%rdi
callq  5bac <get_dollar_var_value+0x1c>
lea    0x1(%rax),%rdi
mov    $0xcac,%edx
mov    $0x0,%esi
callq  5bbf <get_dollar_var_value+0x2f>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   5bcb <get_dollar_var_value+0x3b>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 5bd7 <get_dollar_var_value+0x47>
test   %rax,%rax
je     5c02 <get_dollar_var_value+0x72>
cmp    $0xa,%rdi
lea    -0xb(%rdi),%rdx
jne    5bfa <get_dollar_var_value+0x6a>
jmp    5c10 <get_dollar_var_value+0x80>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%rdx
cmp    $0xffffffffffffffff,%rdx
je     5c10 <get_dollar_var_value+0x80>
mov    (%rax),%rax
test   %rax,%rax
jne    5bf0 <get_dollar_var_value+0x60>
xor    %eax,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x8(%rax),%rax
mov    (%rax),%rbx
mov    %rbx,%rdi
callq  5c1f <get_dollar_var_value+0x8f>
mov    $0xcb2,%edx
lea    0x1(%rax),%rdi
jmp    5bb5 <get_dollar_var_value+0x25>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_dollar_var_value (ind)
     intmax_t ind;
{
  char *temp;
  WORD_LIST *p;
  if (ind < 10)
    temp = dollar_vars[ind] ? (char *)strcpy (sh_xmalloc((1 + strlen (dollar_vars[ind])), "subst.c", 3244), (dollar_vars[ind])) : (char *)((void *)0);
  else
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
 ;
      temp = p ? (char *)strcpy (sh_xmalloc((1 + strlen (p->word->word)), "subst.c", 3250), (p->word->word)) : (char *)((void *)0);
    }
  return (temp);
}
<<<sep_in_sample>>>
1 6
2 3
3 6
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 13
12 13
13 13
14 13
15 16
16 13
17 13
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 16
33 16
34 16
35 16
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    0x0(%rip),%edx        # 51a <ttcbreak+0xa>
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
mov    $0xffffffff,%eax
test   %edx,%edx
je     59a <ttcbreak+0x8a>
mov    0x0(%rip),%rax        # 53a <ttcbreak+0x2a>
mov    %rsp,%rsi
xor    %edi,%edi
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 54a <ttcbreak+0x3a>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 556 <ttcbreak+0x46>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 562 <ttcbreak+0x52>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 56e <ttcbreak+0x5e>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 57a <ttcbreak+0x6a>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 586 <ttcbreak+0x76>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%eax        # 591 <ttcbreak+0x81>
mov    %eax,0x38(%rsp)
callq  59a <ttcbreak+0x8a>
mov    0x48(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    5af <ttcbreak+0x9f>
add    $0x58,%rsp
retq   
nop
callq  5b5 <ttcbreak+0xa5>
<<<sep_in_sample>>>
ttcbreak ()
{
  struct termios tt;
  if (ttsaved == 0)
    return -1;
  tt = ttin;
  return (ttfd_cbreak (0, &tt));
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 5
7 4
8 4
9 6
10 7
11 7
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 7
28 8
29 8
30 8
31 8
32 8
33 8
34 8
<<<sep_out_sample>>>
push   %r14
mov    %esi,%r14d
push   %r13
mov    $0x200,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
test   %rbp,%rbp
jle    429 <disk_buffered_write+0x59>
mov    %r13,%rbx
sub    0x0(%rip),%rbx        # 3f6 <disk_buffered_write+0x26>
je     438 <disk_buffered_write+0x68>
cmp    %rbx,%rbp
mov    0x0(%rip),%rdi        # 402 <disk_buffered_write+0x32>
mov    %r12,%rsi
cmovle %rbp,%rbx
mov    %ebx,%edx
sub    %rbx,%rbp
add    %rbx,%r12
callq  416 <disk_buffered_write+0x46>
add    %rbx,0x0(%rip)        # 41d <disk_buffered_write+0x4d>
add    %rbx,0x0(%rip)        # 424 <disk_buffered_write+0x54>
test   %rbp,%rbp
jg     3ec <disk_buffered_write+0x1c>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
xor    %esi,%esi
mov    %r14d,%edi
callq  442 <disk_buffered_write+0x72>
jmp    3e7 <disk_buffered_write+0x17>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
disk_buffered_write (char *in_buf, int out_des, off_t num_bytes)
{
  off_t bytes_left = num_bytes;
  off_t space_left;
  while (bytes_left > 0)
    {
      space_left = 512 - output_size;
      if (space_left == 0)
 disk_empty_output_buffer (out_des, 0);
      else
 {
   if (bytes_left < space_left)
     space_left = bytes_left;
   memcpy (out_buff, in_buf, (unsigned) space_left);
   out_buff += space_left;
   output_size += space_left;
   in_buf += space_left;
   bytes_left -= space_left;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 7
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 8
13 8
14 8
15 8
16 14
17 14
18 14
19 14
20 18
21 17
22 14
23 15
24 16
25 5
26 5
27 21
28 21
29 21
30 21
31 21
32 21
33 21
34 9
35 9
36 9
37 9
38 9
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
mov    %rdi,%rbx
callq  30b <pool_close+0xb>
mov    %rbx,%rdi
pop    %rbx
jmpq   314 <pool_close+0x14>
<<<sep_in_sample>>>
pool_close(POOL *pool)
{
 __extension__ ({ struct obstack *__o = (&pool->obstack); void *__obj = (((void *)0)); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = (char *)__obj; else (obstack_free) (__o, __obj); });
 free(pool);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
forcefindlib (void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm0        # bc <gsl_hypot3+0xc>
andpd  %xmm0,%xmm1
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm3
ucomisd %xmm2,%xmm1
movapd %xmm3,%xmm4
jbe    f0 <gsl_hypot3+0x40>
ucomisd %xmm1,%xmm3
jbe    100 <gsl_hypot3+0x50>
nopl   0x0(%rax,%rax,1)
xorpd  %xmm0,%xmm0
ucomisd %xmm0,%xmm4
jp     110 <gsl_hypot3+0x60>
jne    110 <gsl_hypot3+0x60>
repz retq 
xchg   %ax,%ax
ucomisd %xmm2,%xmm3
ja     e0 <gsl_hypot3+0x30>
ucomisd %xmm2,%xmm1
movapd %xmm2,%xmm4
jbe    e0 <gsl_hypot3+0x30>
xorpd  %xmm0,%xmm0
movapd %xmm1,%xmm4
ucomisd %xmm0,%xmm4
jnp    ea <gsl_hypot3+0x3a>
xchg   %ax,%ax
divsd  %xmm4,%xmm3
divsd  %xmm4,%xmm1
divsd  %xmm4,%xmm2
mulsd  %xmm3,%xmm3
mulsd  %xmm1,%xmm1
mulsd  %xmm2,%xmm2
addsd  %xmm1,%xmm3
addsd  %xmm2,%xmm3
sqrtsd %xmm3,%xmm0
ucomisd %xmm0,%xmm0
jp     13f <gsl_hypot3+0x8f>
mulsd  %xmm4,%xmm0
retq   
movapd %xmm3,%xmm0
sub    $0x18,%rsp
movsd  %xmm4,0x8(%rsp)
callq  152 <gsl_hypot3+0xa2>
movsd  0x8(%rsp),%xmm4
add    $0x18,%rsp
mulsd  %xmm4,%xmm0
retq   
<<<sep_in_sample>>>
gsl_hypot3(const double x, const double y, const double z)
{
  double xabs = fabs(x);
  double yabs = fabs(y);
  double zabs = fabs(z);
  double w = ((xabs) > (((yabs) > (zabs) ? (yabs) : (zabs))) ? (xabs) : (((yabs) > (zabs) ? (yabs) : (zabs))));
  if (w == 0.0)
    {
      return (0.0);
    }
  else
    {
      double r = w * sqrt((xabs / w) * (xabs / w) +
                          (yabs / w) * (yabs / w) +
                          (zabs / w) * (zabs / w));
      return r;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 18
17 18
18 6
19 6
20 6
21 6
22 6
23 7
24 6
25 7
26 7
27 7
28 13
29 14
30 15
31 13
32 14
33 15
34 13
35 13
36 13
37 13
38 13
39 13
40 18
41 13
42 2
43 2
44 13
45 13
46 18
47 13
48 18
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # b8a <strbuf_release_tempbuf+0xa>
retq   
<<<sep_in_sample>>>
strbuf_release_tempbuf(STRBUF *sb)
{
 used = 0;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
cmpq   $0x0,0x20(%rdi)
je     e50 <message_append_mime_header+0x30>
mov    %rsi,%rdi
callq  e37 <message_append_mime_header+0x17>
mov    0x20(%rbx),%rdi
add    $0x10,%rsp
mov    %rax,%rsi
pop    %rbx
jmpq   e48 <message_append_mime_header+0x28>
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x8(%rsp)
callq  e5a <message_append_mime_header+0x3a>
mov    0x8(%rsp),%rsi
mov    %rax,0x20(%rbx)
jmp    e2f <message_append_mime_header+0xf>
<<<sep_in_sample>>>
message_append_mime_header (MESSAGE msg, const char *buf)
{
  if (!msg->mime_hdr)
    msg->mime_hdr = list_create ();
  list_append (msg->mime_hdr, xstrdup (buf));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 5
7 5
8 5
9 6
10 5
11 6
12 5
13 5
14 5
15 4
16 4
17 4
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 4da <send_delete+0xa>
movb   $0x2,0x0(%rip)        # 4e1 <send_delete+0x11>
callq  4e6 <send_delete+0x16>
mov    %eax,0x0(%rip)        # 4ec <send_delete+0x1c>
mov    $0x2,%eax
mov    0x0(%rip),%edi        # 4f7 <send_delete+0x27>
mov    %ax,0x0(%rip)        # 4fe <send_delete+0x2e>
mov    0x0(%rip),%eax        # 504 <send_delete+0x34>
xor    %ecx,%ecx
mov    $0x10,%r9d
mov    $0x0,%r8d
mov    $0x54,%edx
mov    $0x0,%esi
mov    %eax,0x0(%rip)        # 522 <send_delete+0x52>
callq  527 <send_delete+0x57>
cmp    $0x54,%rax
je     537 <send_delete+0x67>
mov    $0x0,%edi
callq  537 <send_delete+0x67>
mov    0x0(%rip),%edi        # 53d <send_delete+0x6d>
callq  542 <send_delete+0x72>
mov    0x0(%rip),%edi        # 548 <send_delete+0x78>
mov    %eax,0x0(%rip)        # 54e <send_delete+0x7e>
xor    %ecx,%ecx
mov    0x0(%rip),%eax        # 556 <send_delete+0x86>
mov    $0x10,%r9d
mov    $0x0,%r8d
mov    $0x54,%edx
mov    $0x0,%esi
mov    %eax,0x0(%rip)        # 572 <send_delete+0xa2>
callq  577 <send_delete+0xa7>
cmp    $0x54,%rax
je     587 <send_delete+0xb7>
mov    $0x0,%edi
callq  587 <send_delete+0xb7>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_delete (void)
{
  msg.type = 2;
  msg.id_num = htonl (remote_id);
  daemon_addr.sin_family = 2;
  daemon_addr.sin_addr = his_machine_addr;
  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,
       (struct sockaddr *) &daemon_addr,
       sizeof (daemon_addr)) != sizeof (msg))
    perror ("send_delete (remote)");
  msg.id_num = htonl (local_id);
  daemon_addr.sin_addr = my_machine_addr;
  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,
       (struct sockaddr *) &daemon_addr,
       sizeof (daemon_addr)) != sizeof (msg))
    perror ("send_delete (local)");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 4
5 4
6 5
7 7
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 6
16 7
17 7
18 7
19 10
20 10
21 11
22 11
23 13
24 11
25 13
26 12
27 13
28 13
29 13
30 13
31 12
32 13
33 13
34 13
35 16
36 16
37 18
38 18
39 18
<<<sep_out_sample>>>
test   %r8,%r8
mov    (%rdx),%r9
je     dbc <gsl_stats_long_minmax+0x3c>
shl    $0x3,%rcx
mov    %r9,%r10
xor    %r11d,%r11d
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rax
cmp    %rax,%r9
cmovg  %rax,%r9
cmp    %rax,%r10
cmovl  %rax,%r10
add    $0x1,%r11
add    %rcx,%rdx
cmp    %r8,%r11
jne    d98 <gsl_stats_long_minmax+0x18>
mov    %r9,(%rdi)
mov    %r10,(%rsi)
retq   
mov    %r9,%r10
jmp    db5 <gsl_stats_long_minmax+0x35>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_minmax (long * min_out, long * max_out,
                             const long data[], const size_t stride,
                             const size_t n)
{
  long min = data[0 * stride];
  long max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      long xi = data[i * stride];
      if (xi < min)
        min = xi;
      if (xi > max)
        max = xi;
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 8
2 5
3 8
4 8
5 6
6 8
7 8
8 10
9 10
10 10
11 10
12 10
13 8
14 8
15 8
16 8
17 16
18 17
19 17
20 6
21 6
22 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 946 <yy_grecsget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecsget_leng (void)
{
        return yy_grecsleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 188 <named_function+0x8>
je     1e7 <named_function+0x67>
push   %r12
xor    %eax,%eax
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
jmp    1b7 <named_function+0x37>
nopw   0x0(%rax,%rax,1)
add    $0x1,%ebx
movslq %ebx,%rax
mov    %rax,%rdx
shl    $0x5,%rdx
cmpq   $0x0,0x0(%rdx)
je     1e0 <named_function+0x60>
shl    $0x5,%rax
mov    %r12,%rsi
mov    0x0(%rax),%rdi
mov    %rax,%rbp
callq  1cd <named_function+0x4d>
test   %eax,%eax
jne    1a0 <named_function+0x20>
pop    %rbx
lea    0x0(%rbp),%rax
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
named_function (char *name)
{
  register int i;
  for (i = 0; function_doc_array[i].func; i++)
    if (strcmp (function_doc_array[i].func_name, name) == 0)
      break;
  if (!function_doc_array[i].func)
    return 0;
  else
    return &function_doc_array[i];
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 11
25 10
26 11
27 11
28 11
29 11
30 11
31 11
32 8
33 11
34 11
35 8
36 11
37 11
<<<sep_out_sample>>>
push   %r12
lea    0x58(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  9c <osip_message_get_alert_info+0x1c>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    b5 <osip_message_get_alert_info+0x35>
mov    %ebx,%esi
mov    %r12,%rdi
callq  af <osip_message_get_alert_info+0x2f>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_alert_info (const osip_message_t * sip, int pos, osip_alert_info_t ** dest)
{
  osip_alert_info_t *alert_info;
  *dest = ((void *)0);
  if (osip_list_size (&sip->alert_infos) <= pos)
    return -1;
  alert_info = (osip_alert_info_t *) osip_list_get (&sip->alert_infos, pos);
  *dest = alert_info;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 9
17 8
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  69 <xcalloc+0x9>
test   %rax,%rax
je     73 <xcalloc+0x13>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  7d <xcalloc+0x1d>
mov    $0x1,%edi
callq  87 <xcalloc+0x27>
<<<sep_in_sample>>>
xcalloc (size_t nmemb, size_t size)
{
  void * p;
  p = (void *) calloc (nmemb, size);
  if (p == (void *) ((void *)0))
    {
      perror ("out of memory");
      exit (1);
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 11
6 11
7 7
8 7
9 8
10 8
<<<sep_out_sample>>>
jmpq   755 <_clone_action+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_clone_action (void *item, void *cbdata)
{
  struct mu_cfg_cont *cont = item;
  return mu_config_clone_container (cont);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%r11
cmp    0x8(%rdi),%r11
je     fa0 <gsl_matrix_complex_float_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f96 <gsl_matrix_complex_float_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %r11,%r11
je     102e <gsl_matrix_complex_float_transpose+0xbe>
xor    %edx,%edx
lea    0x1(%rdx),%r8
cmp    %r11,%r8
je     102e <gsl_matrix_complex_float_transpose+0xbe>
nopl   0x0(%rax)
mov    0x10(%rdi),%r10
mov    %rdx,%r9
mov    0x18(%rdi),%rcx
imul   %r10,%r9
lea    0x0(,%r10,8),%rsi
lea    (%r8,%r9,1),%rax
add    %r9,%r10
add    %r11,%r9
add    %r10,%rdx
lea    0x4(%rcx,%rax,8),%rax
lea    0x4(%rcx,%rdx,8),%rdx
lea    0x4(%rcx,%r9,8),%rcx
nopl   0x0(%rax,%rax,1)
movss  -0x4(%rdx),%xmm1
add    $0x8,%rax
movss  -0xc(%rax),%xmm0
movss  %xmm1,-0xc(%rax)
movss  %xmm0,-0x4(%rdx)
movss  (%rdx),%xmm1
movss  -0x8(%rax),%xmm0
movss  %xmm1,-0x8(%rax)
movss  %xmm0,(%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    ff0 <gsl_matrix_complex_float_transpose+0x80>
mov    %r8,%rdx
lea    0x1(%rdx),%r8
cmp    %r11,%r8
jne    fb8 <gsl_matrix_complex_float_transpose+0x48>
xor    %eax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_transpose (gsl_matrix_complex_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 2; k++)
            {
              size_t e1 = (i * m->tda + j) * 2 + k ;
              size_t e2 = (j * m->tda + i) * 2 + k ;
              {
                float tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 20
34 20
35 19
36 20
37 21
38 20
39 19
40 20
41 21
42 21
43 12
44 12
45 12
46 12
47 12
48 12
49 26
50 27
51 27
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%r12        # 4169 <reduceunit+0x9>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    (%r12),%rdi
test   %rdi,%rdi
je     417c <reduceunit+0x1c>
callq  417c <reduceunit+0x1c>
movq   $0x0,(%r12)
nopl   0x0(%rax)
xor    %esi,%esi
mov    %rbp,%rdi
callq  4192 <reduceunit+0x32>
test   $0x4,%al
mov    %eax,%ebx
je     41b0 <reduceunit+0x50>
cmpq   $0x1,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
sbb    %eax,%eax
and    $0xfffffffc,%eax
add    $0x7,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%esi
mov    %rbp,%rdi
callq  41bd <reduceunit+0x5d>
or     %ebx,%eax
test   $0x4,%al
jne    4198 <reduceunit+0x38>
and    $0x1,%eax
jne    4188 <reduceunit+0x28>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
reduceunit(struct unittype *theunit)
{
   int ret;
   if (irreducible)
     free(irreducible);
   irreducible=0;
   ret = (1<<0);
   while (ret & (1<<0)) {
      ret = reduceproduct(theunit, 0);
      if (!(ret & (1<<2)))
        ret |= reduceproduct(theunit, 1);
      if (ret & (1<<2)){
         if (irreducible)
           return 7;
         else
           return 3;
      }
   }
   return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 6
11 6
12 9
13 9
14 9
15 10
16 9
17 10
18 16
19 20
20 20
21 20
22 16
23 16
24 16
25 20
26 20
27 11
28 11
29 11
30 11
31 12
32 12
33 8
34 8
35 20
36 20
37 20
38 20
39 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 2f67 <flush_write+0x7>
mov    0x0(%rip),%rax        # 2f6e <flush_write+0xe>
jmpq   *%rax
<<<sep_in_sample>>>
flush_write (void)
{
  flush_write_ptr (record_size);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_suggest_mechanism (Gsasl * ctx, const char *mechlist)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r11
push   %rbx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3a9d <gsl_matrix_uchar_scale+0x5d>
xor    %r8d,%r8d
xor    %r9d,%r9d
nopw   0x0(%rax,%rax,1)
test   %r10,%r10
je     3a91 <gsl_matrix_uchar_scale+0x51>
lea    (%r8,%r10,1),%rsi
mov    %r8,%rax
nopl   0x0(%rax)
mov    %rax,%rdx
add    0x18(%rdi),%rdx
add    $0x1,%rax
cmp    %rax,%rsi
movzbl (%rdx),%ecx
cvtsi2sd %ecx,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cl,(%rdx)
jne    3a70 <gsl_matrix_uchar_scale+0x30>
add    $0x1,%r9
add    %rbx,%r8
cmp    %r11,%r9
jne    3a60 <gsl_matrix_uchar_scale+0x20>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_scale (gsl_matrix_uchar * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 11
16 11
17 11
18 9
19 11
20 11
21 11
22 11
23 11
24 9
25 7
26 7
27 7
28 7
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    (%rsi),%rdi
push   %rbx
mov    %rsi,%rbx
test   %rdi,%rdi
je     3ef3 <copyproduct+0x53>
mov    0x0(%rip),%r12        # 3eb9 <copyproduct+0x19>
jmp    3ed9 <copyproduct+0x39>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rbx
add    $0x8,%rbp
callq  3ecd <copyproduct+0x2d>
mov    %rax,-0x8(%rbp)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     3ef3 <copyproduct+0x53>
cmp    (%r12),%rdi
jne    3ec0 <copyproduct+0x20>
add    $0x8,%rbx
mov    %rdi,0x0(%rbp)
add    $0x8,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    3ed9 <copyproduct+0x39>
movq   $0x0,0x0(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
copyproduct(char **dest, char **source)
{
   for(;*source;source++,dest++) {
     if (*source==NULLUNIT)
       *dest = NULLUNIT;
     else
       *dest=dupstr(*source);
   }
   *dest=0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 7
15 7
16 3
17 3
18 3
19 4
20 4
21 3
22 5
23 3
24 3
25 3
26 3
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_uri (osip_authorization_t * authorization, char *uri)
{
  authorization->uri = (char *) uri;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x4,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_special (sig)
     int sig;
{
  return (sigmodes[sig] & 0x4);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%rcx
mov    %rsi,%r12
mov    $0x1,%esi
push   %rbp
mov    %rdx,%rbp
mov    $0x1f,%edx
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  2744 <Write_R_Roots+0x24>
mov    %rbx,%rcx
mov    $0x2b,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  275b <Write_R_Roots+0x3b>
mov    %rbx,%rcx
mov    $0x2d,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2772 <Write_R_Roots+0x52>
mov    %rbx,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2789 <Write_R_Roots+0x69>
mov    %r12,%rsi
mov    %rbx,%rdi
xor    %r8d,%r8d
mov    $0x70600,%ecx
mov    $0x0,%edx
callq  27a1 <Write_R_Roots+0x81>
mov    %rbp,%rsi
mov    %rbx,%rdi
xor    %ecx,%ecx
mov    $0x0,%edx
mov    $0x9,%r8d
callq  27b9 <Write_R_Roots+0x99>
mov    %rbx,%rcx
mov    $0xf,%edx
mov    $0x1,%esi
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x0,%edi
jmpq   27d4 <Write_R_Roots+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Write_R_Roots (PFILE pfile, PVMMAPSTRCT pvmGlo, PVMMAPSTRCT pvmRoots)
{
  fprintf (pfile, "/*----- Roots calculations: */\n");
  fprintf (pfile, "void root (int *neq, double *t, double *y, ");
  fprintf (pfile, "int *ng, double *gout, double *out, int *ip)\n");
  fprintf (pfile, "{\n");
  ForAllVar (pfile, pvmGlo, &WriteOneDecl, 0x70600, ((void *)0));
  ForAllVar (pfile, pvmRoots, &WriteOneEquation, (0), (PVOID) 9);
  fprintf (pfile, "\n} /* root */\n\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 2
9 2
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 8
36 8
37 8
38 8
39 9
40 9
41 9
42 10
43 10
44 10
45 9
46 9
47 9
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    4c98 <gsl_matrix_complex_float_const_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,8),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  4cba <gsl_matrix_complex_float_const_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_const_superdiagonal (const gsl_matrix_complex_float * m,
                                      const size_t k)
{
  _gsl_vector_complex_float_const_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_float v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 2;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 18 <close_stdin+0x8>
mov    %rbx,%rdi
callq  20 <close_stdin+0x10>
test   %rax,%rax
mov    %rbx,%rdi
jne    80 <close_stdin+0x70>
callq  2d <close_stdin+0x1d>
test   %eax,%eax
je     b2 <close_stdin+0xa2>
nopl   (%rax)
mov    0x0(%rip),%rdi        # 3f <close_stdin+0x2f>
test   %rdi,%rdi
je     c0 <close_stdin+0xb0>
callq  49 <close_stdin+0x39>
mov    %rax,%rbx
callq  51 <close_stdin+0x41>
mov    (%rax),%esi
mov    $0x0,%r8d
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  6a <close_stdin+0x5a>
callq  6f <close_stdin+0x5f>
mov    0x0(%rip),%edi        # 75 <close_stdin+0x65>
callq  7a <close_stdin+0x6a>
nopw   0x0(%rax,%rax,1)
xor    %esi,%esi
mov    $0x1,%edx
callq  8c <close_stdin+0x7c>
test   %eax,%eax
mov    0x0(%rip),%rdi        # 95 <close_stdin+0x85>
jne    28 <close_stdin+0x18>
callq  9c <close_stdin+0x8c>
mov    0x0(%rip),%rdi        # a3 <close_stdin+0x93>
mov    %eax,%ebx
callq  aa <close_stdin+0x9a>
test   %eax,%eax
jne    38 <close_stdin+0x28>
test   %ebx,%ebx
jne    38 <close_stdin+0x28>
pop    %rbx
jmpq   b8 <close_stdin+0xa8>
nopl   0x0(%rax,%rax,1)
callq  c5 <close_stdin+0xb5>
mov    (%rax),%esi
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  da <close_stdin+0xca>
jmp    6a <close_stdin+0x5a>
<<<sep_in_sample>>>
close_stdin (void)
{
  _Bool fail = 0;
  if (freadahead (stdin) > 0)
    {
      if (rpl_fseeko (stdin, 0, 1) == 0 && rpl_fflush (stdin) != 0)
        fail = 1;
    }
  if (close_stream (stdin) != 0)
    fail = 1;
  if (fail)
    {
      char const *close_error = ((const char *) ("error closing file"));
      if (file_name)
        error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
               close_error);
      else
        error (0, (*__errno_location ()), "%s", close_error);
    }
  close_stdout ();
  if (fail)
    _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 14
13 14
14 14
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 15
25 20
26 22
27 22
28 22
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 9
37 6
38 9
39 9
40 9
41 11
42 11
43 23
44 20
45 20
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 18
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     3e50 <gsl_block_short_raw_fscanf+0x80>
mov    %rdi,%r13
lea    (%rcx,%rcx,1),%r14
mov    %rsi,%rbx
xor    %ebp,%ebp
jmp    3e04 <gsl_block_short_raw_fscanf+0x34>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     3e50 <gsl_block_short_raw_fscanf+0x80>
lea    0xe(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  3e18 <gsl_block_short_raw_fscanf+0x48>
movzwl 0xe(%rsp),%edx
cmp    $0x1,%eax
mov    %dx,(%rbx)
je     3df8 <gsl_block_short_raw_fscanf+0x28>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3e3e <gsl_block_short_raw_fscanf+0x6e>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
gsl_block_short_raw_fscanf (FILE * stream,
                                  short * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          short tmp;
          int status = fscanf (stream, "%hd", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 13
21 13
22 13
23 13
24 13
25 14
26 15
27 14
28 15
29 17
30 17
31 17
32 17
33 17
34 22
35 17
36 22
37 22
38 22
39 22
40 22
41 22
42 22
43 21
44 22
45 22
46 22
47 22
48 22
49 22
50 22
<<<sep_out_sample>>>
xor    %esi,%esi
jmpq   df0 <expint_E2_impl>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_expint_E2_e(const double x, gsl_sf_result * result)
{
  return expint_E2_impl(x, result, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
cmp    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
push   %rbp
mov    %rsi,%rbp
mov    %rdi,%rsi
mov    $0x1,%edi
push   %rbx
mov    $0x0,%ebx
cmovne %rax,%rbx
callq  166 <argmatch_invalid+0x26>
mov    %rbp,%rdx
mov    $0x6,%esi
xor    %edi,%edi
mov    %rax,%r12
callq  178 <argmatch_invalid+0x38>
mov    %rbx,%rdx
mov    %r12,%r8
mov    %rax,%rcx
pop    %rbx
pop    %rbp
pop    %r12
xor    %esi,%esi
xor    %edi,%edi
xor    %eax,%eax
jmpq   190 <argmatch_valid>
<<<sep_in_sample>>>
argmatch_invalid (const char *context, const char *value, ptrdiff_t problem)
{
  char const *format = (problem == -1
                        ? ((const char *) ("invalid argument %s for %s"))
                        : ((const char *) ("ambiguous argument %s for %s")));
  error (0, 0, format, quotearg_n_style (0, locale_quoting_style, value),
         quote_n (1, context));
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 6
7 6
8 2
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
sub    $0x18,%rsp
movq   $0x0,0x8(%rsp)
movl   $0x0,(%rsp)
movl   $0x0,0x4(%rsp)
callq  300e <swlib_shcmd_output_strob+0x2e>
mov    %rbx,%rdi
callq  3016 <swlib_shcmd_output_strob+0x36>
test   %eax,%eax
mov    %eax,%ebx
js     3058 <swlib_shcmd_output_strob+0x78>
lea    0x4(%rsp),%rdx
lea    0x8(%rsp),%rsi
mov    %rsp,%rcx
mov    %eax,%edi
callq  3030 <swlib_shcmd_output_strob+0x50>
test   %eax,%eax
js     3058 <swlib_shcmd_output_strob+0x78>
movslq (%rsp),%rdx
mov    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  3045 <swlib_shcmd_output_strob+0x65>
mov    %ebx,%edi
callq  304c <swlib_shcmd_output_strob+0x6c>
xor    %eax,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    $0xffffffff,%eax
jmp    304e <swlib_shcmd_output_strob+0x6e>
nop
<<<sep_in_sample>>>
swlib_shcmd_output_strob(STROB * output, SHCMD ** cmdvec)
{
 char * base = (char*)((void *)0);
 int data_len = 0;
 int buffer_len = 0;
 int fd;
 strob_strcpy(output, "");
 fd = swlib_shcmd_output_fd(cmdvec);
 if (fd < 0) return -1;
 if (uxfio_get_dynamic_buffer(fd, &base, &buffer_len, &data_len) < 0)
  return -1;
 strob_strncat(output, base, data_len);
 uxfio_close(fd);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 2
7 3
8 4
9 5
10 7
11 8
12 8
13 9
14 8
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 12
26 12
27 13
28 13
29 14
30 15
31 15
32 15
33 15
34 15
35 9
36 9
37 9
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0x0,%esi
jmpq   b33 <mu_mailcap_entry_get_composetyped+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailcap_entry_get_composetyped (mu_mailcap_entry_t entry, char *buffer,
       size_t buflen, size_t *pn)
{
  return mu_mailcap_entry_get_value (entry, "composetyped", buffer, buflen, pn);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  eb9 <username+0x9>
mov    %eax,%edi
callq  ec0 <username+0x10>
test   %rax,%rax
je     ecd <username+0x1d>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
callq  ed2 <username+0x22>
mov    $0x0,%edi
mov    %eax,%esi
xor    %eax,%eax
callq  ee0 <do_clean>
<<<sep_in_sample>>>
username (void)
{
  const struct passwd *pw;
  pw = getpwuid (getuid ());
  if (pw == ((void *)0))
    {
      syserr ("Who are you?\n"
              "You don't seem to have an entry in the user database "
              "(/etc/passwd) (uid=%d)", (int)getuid ());
      exit (71);
    }
  return (pw->pw_name);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 12
8 13
9 13
10 9
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
xor    %eax,%eax
testb  $0x3,0x0(%rip)        # 1789 <update_ext_api+0x9>
setne  %al
mov    %eax,0x0(%rip)        # 1792 <update_ext_api+0x12>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
update_ext_api()
{
 api_impl.do_flags[0] = ((do_flags & (DO_LINT_INVALID|DO_LINT_ALL)) ? 1 : 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%eax
cmp    $0x1,%eax
jl     20 <matherr+0x20>
cmp    $0x2,%eax
jle    30 <matherr+0x30>
cmp    $0x6,%eax
jg     20 <matherr+0x20>
callq  1a <matherr+0x1a>
movl   $0x22,(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
callq  35 <matherr+0x35>
movl   $0x21,(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
matherr(exc)
struct exception *exc;
{
  switch (exc->type) {
  case 2:
  case 1:
    (*__errno_location ()) = 33;
    break;
  case 3:
  case 4:
  case 5:
  case 6:
    (*__errno_location ()) = 34;
    break;
  }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 13
10 13
11 17
12 17
13 17
14 17
15 7
16 7
17 17
18 17
19 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
lea    -0x1(%rsi),%ebx
test   %ebx,%ebx
jle    1da <hassubscript+0x4a>
mov    0x0(%rip),%rdx        # 1a2 <hassubscript+0x12>
movslq %ebx,%rax
movsbl (%rdi,%rax,1),%esi
lea    -0x1(%rdi,%rax,1),%rbp
mov    (%rdx),%r12
jmp    1cd <hassubscript+0x3d>
nopl   0x0(%rax,%rax,1)
movsbl 0x0(%rbp),%esi
sub    $0x1,%ebx
cmp    $0x5f,%sil
je     1e8 <hassubscript+0x58>
sub    $0x1,%rbp
test   %ebx,%ebx
je     1da <hassubscript+0x4a>
mov    %r12,%rdi
callq  1d5 <hassubscript+0x45>
test   %rax,%rax
jne    1b8 <hassubscript+0x28>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hassubscript(const char *str, int length)
{
  length--;
  while(length>0){
    if (!strchr(digits, str[length]))
      return 0;
    length--;
    if (str[length]=='_')
      return 1;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 8
15 7
16 8
17 8
18 8
19 4
20 4
21 5
22 5
23 5
24 5
25 12
26 12
27 11
28 12
29 12
30 12
31 12
32 12
33 9
34 12
35 12
36 12
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %r9,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %r8,%rbx
sub    $0x8,%rsp
mov    0x10(%r8),%r8
test   %r8,%r8
je     a4e <gsl_multilarge_nlinear_eval_fvv+0x2e>
mov    0x28(%rbx),%rdx
mov    %r9,%rcx
callq  *%r8
addq   $0x1,0x48(%rbx)
mov    %eax,%r13d
test   %rbp,%rbp
je     a5e <gsl_multilarge_nlinear_eval_fvv+0x3e>
mov    %rbp,%rsi
mov    %r12,%rdi
callq  a5e <gsl_multilarge_nlinear_eval_fvv+0x3e>
add    $0x8,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_multilarge_nlinear_eval_fvv(const double h,
                                const gsl_vector *x,
                                const gsl_vector *v,
                                const gsl_vector *f,
                                const gsl_vector *swts,
                                gsl_multilarge_nlinear_fdf *fdf,
                                gsl_vector *yvv,
                                gsl_vector *work)
{
  int status;
  if (fdf->fvv != ((void *)0))
    {
      status = ((*((fdf)->fvv)) (x, v, fdf->params, yvv));
      ++(fdf->nevalfvv);
    }
  else
    {
    }
  if (swts)
    gsl_vector_mul(yvv, swts);
  return status;
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 11
10 11
11 11
12 13
13 13
14 13
15 14
16 13
17 19
18 19
19 20
20 20
21 20
22 22
23 22
24 22
25 22
26 22
27 22
28 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <initialise+0xe>
test   %rax,%rax
je     2a <initialise+0x2a>
cmpb   $0x0,(%rax)
je     2a <initialise+0x2a>
xor    %edx,%edx
xor    %esi,%esi
mov    %rax,%rdi
callq  24 <initialise+0x24>
mov    %eax,0x0(%rip)        # 2a <initialise+0x2a>
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
initialise (void)
{
  const char * p = getenv("GSL_TEST_VERBOSE");
  if (p == 0)
    return ;
  if (*p == '\0')
    return ;
  verbose = strtoul (p, 0, 0);
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 10
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
mov    %rdi,%rbx
je     4528 <swlib_umaxtostr+0x38>
mov    %rsi,0x0(%rip)        # 4500 <swlib_umaxtostr+0x10>
mov    %rsi,%rdi
mov    $0x16,%esi
callq  450d <swlib_umaxtostr+0x1d>
mov    0x0(%rip),%rdi        # 4514 <swlib_umaxtostr+0x24>
callq  4519 <swlib_umaxtostr+0x29>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   4525 <swlib_umaxtostr+0x35>
nopl   (%rax)
mov    0x0(%rip),%rdi        # 452f <swlib_umaxtostr+0x3f>
test   %rdi,%rdi
jne    4503 <swlib_umaxtostr+0x13>
mov    $0x20,%dil
callq  453c <swlib_umaxtostr+0x4c>
mov    %rax,0x0(%rip)        # 4543 <swlib_umaxtostr+0x53>
mov    %rax,%rdi
jmp    4503 <swlib_umaxtostr+0x13>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_umaxtostr(uintmax_t i, STROB * pbuf)
{
 static STROB * buf;
 char * ret;
 if (pbuf == ((void *)0)) {
  if (buf == ((void *)0))
   buf = strob_open(32);
 } else {
  buf = pbuf;
 }
 strob_setlen(buf, (((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)) + 1) + 1)+1);
 ret = umaxtostr(i, strob_str(buf));
 return ret;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 9
6 9
7 11
8 11
9 12
10 12
11 12
12 12
13 14
14 12
15 12
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1fc1 <gsl_matrix_ushort_fwrite+0x91>
lea    (%r15,%r15,1),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    1f7e <gsl_matrix_ushort_fwrite+0x4e>
jmp    1fb0 <gsl_matrix_ushort_fwrite+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1fb0 <gsl_matrix_ushort_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1f95 <gsl_matrix_ushort_fwrite+0x65>
test   %eax,%eax
je     1f70 <gsl_matrix_ushort_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1fe4 <gsl_matrix_ushort_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_fwrite (FILE * stream, const gsl_matrix_ushort * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_ushort_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_ushort_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
movl   $0x5,0x0(%rip)        # 9aa <verbatim+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
verbatim (void)
{
  (yy_start) = 1 + 2 * (2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
cmpq   $0x0,0x670(%rdi)
jle    625f <WriteMCVars+0x4f>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x678(%rbp),%rax
mov    $0x0,%esi
mov    %r12,%rdi
mov    (%rax,%rbx,8),%rax
add    $0x1,%rbx
movsd  0x10(%rax),%xmm0
mov    $0x1,%eax
callq  6256 <WriteMCVars+0x46>
cmp    %rbx,0x670(%rbp)
jg     6230 <WriteMCVars+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
WriteMCVars (PLEVEL plevel, PFILE pOutFile)
{
  long n;
  PMCVAR pMCVar;
  for (n = 0; n < plevel->nMCVars; n++) {
    pMCVar = plevel->rgpMCVars[n];
    fprintf(pOutFile, "%5g\t", pMCVar->dVal);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 5
15 7
16 7
17 7
18 5
19 5
20 9
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xstrndup+0x9>
test   %rax,%rax
je     13 <xstrndup+0x13>
add    $0x8,%rsp
retq   
callq  18 <xstrndup+0x18>
<<<sep_in_sample>>>
xstrndup (const char *string, size_t n)
{
  char *s = strndup (string, n);
  if (! s)
    xalloc_die ();
  return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 7
6 7
7 5
<<<sep_out_sample>>>
push   %r12
movzbl %dil,%edi
mov    $0x0,%esi
xor    %eax,%eax
mov    %r8,%r12
push   %rbp
mov    %rcx,%rbp
mov    0x0(,%rdi,8),%rcx
mov    0x0(%rip),%rdi        # 23 <_dico_stderr_log_printer+0x23>
push   %rbx
mov    %edx,%ebx
mov    0x0(%rip),%rdx        # 2d <_dico_stderr_log_printer+0x2d>
callq  32 <_dico_stderr_log_printer+0x32>
mov    0x0(%rip),%rdi        # 39 <_dico_stderr_log_printer+0x39>
mov    %r12,%rdx
mov    %rbp,%rsi
callq  44 <_dico_stderr_log_printer+0x44>
test   %ebx,%ebx
je     65 <_dico_stderr_log_printer+0x65>
mov    %ebx,%edi
callq  4f <_dico_stderr_log_printer+0x4f>
mov    0x0(%rip),%rdi        # 56 <_dico_stderr_log_printer+0x56>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  65 <_dico_stderr_log_printer+0x65>
pop    %rbx
pop    %rbp
pop    %r12
mov    0x0(%rip),%rsi        # 70 <_dico_stderr_log_printer+0x70>
mov    $0xa,%edi
jmpq   7a <_dico_stderr_log_printer+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_dico_stderr_log_printer(int lvl, int exitcode, int errcode,
    const char *fmt, va_list ap)
{
    fprintf(stderr, "%s: %s: ", dico_program_name, prefix[lvl & 0xff]);
    vfprintf(stderr, fmt, ap);
    if (errcode)
 fprintf(stderr, ": %s", strerror(errcode));
    fprintf(stderr, "\n");
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 3
6 3
7 3
8 4
9 4
10 3
11 3
12 4
13 4
14 5
15 5
16 5
17 5
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 9
28 9
29 9
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 14e7 <bucket_print_lines+0x7>
mov    0x20(%rax),%rax
mov    0x1c(%rax),%edx
mov    (%rdi),%eax
lea    0x9(%rdx,%rax,1),%eax
cltq   
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bucket_print_lines (hash_bucket *bucket)
{
  return 6 + gdbm_file->header->bucket_elems + 3 + bucket->av_count;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    $0x2,%esi
jmpq   2400 <asort_actual>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_asort(int nargs)
{
 return asort_actual(nargs, ASORT);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 7ca <seekline+0xa>
test   %rdi,%rdi
je     808 <seekline+0x48>
callq  7d4 <seekline+0x14>
movl   $0x1,0x0(%rip)        # 7de <seekline+0x1e>
mov    $0x1,%eax
jmp    804 <seekline+0x44>
nopl   (%rax)
mov    0x0(%rip),%rdi        # 7ef <seekline+0x2f>
callq  7f4 <seekline+0x34>
cmp    $0xffffffff,%eax
je     808 <seekline+0x48>
cmp    $0xa,%eax
mov    0x0(%rip),%eax        # 802 <seekline+0x42>
je     810 <seekline+0x50>
cmp    %eax,%ebx
ja     7e8 <seekline+0x28>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 819 <seekline+0x59>
jmp    804 <seekline+0x44>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
seekline(unsigned int line)
{
 int c;
 if (refsfound == ((void *)0)) {
  return;
 }
 rewind(refsfound);
 nextline = 1;
 while (nextline < line && (c = _IO_getc (refsfound)) != (-1)) {
  if (c == '\n') {
   nextline++;
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 7
7 8
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 10
16 11
17 10
18 9
19 9
20 14
21 14
22 14
23 11
24 11
25 11
26 11
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_ptr (Buffer *buffer)
{
  return buffer->data;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
movslq %edx,%rdx
push   %rbp
mov    %rsi,%rbp
xor    %esi,%esi
push   %rbx
mov    %rdi,%rbx
mov    %rbp,%rdi
callq  8ea <get_homedir+0x1a>
test   %rbx,%rbx
je     920 <get_homedir+0x50>
mov    %rbx,%rdi
callq  8f7 <get_homedir+0x27>
test   %rax,%rax
je     928 <get_homedir+0x58>
pop    %rbx
sub    $0x1,%r12d
mov    %rbp,%rdi
mov    0x20(%rax),%rsi
pop    %rbp
movslq %r12d,%rdx
pop    %r12
jmpq   913 <get_homedir+0x43>
nopl   0x0(%rax,%rax,1)
movb   $0x0,0x0(%rbp)
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    $0x0,%edi
callq  932 <get_homedir+0x62>
test   %rax,%rax
je     918 <get_homedir+0x48>
pop    %rbx
sub    $0x1,%r12d
mov    %rbp,%rdi
mov    %rax,%rsi
pop    %rbp
movslq %r12d,%rdx
pop    %r12
jmpq   94d <get_homedir+0x7d>
nopl   (%rax)
<<<sep_in_sample>>>
get_homedir (char *user, char *buf, int maxsize)
{
  struct passwd *pwd;
  memset (buf, 0, maxsize);
  if (user == 0)
    return;
  pwd = getpwnam (user);
  if (pwd)
    strncpy (buf, (char *) pwd->pw_dir, maxsize - 1);
  else
    {
      char *p = getenv ("HOME");
      if (p)
 strncpy (buf, p, maxsize - 1);
      else
 strncpy (buf, "", 1);
    }
  return;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 2
8 2
9 4
10 4
11 5
12 5
13 7
14 7
15 8
16 8
17 19
18 9
19 14
20 9
21 19
22 9
23 19
24 14
25 14
26 16
27 16
28 19
29 19
30 19
31 19
32 19
33 12
34 12
35 13
36 13
37 19
38 14
39 14
40 14
41 19
42 14
43 19
44 14
45 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x20(%rsi),%rax
mov    %rsp,%rdx
mov    %rax,(%rsp)
mov    (%rsi),%rax
mov    0x20(%rsi,%rax,8),%rax
mov    0x18(%rsi),%rsi
add    $0x2,%rax
mov    %rax,0x8(%rsp)
callq  879 <atat_put+0x29>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
atat_put (FILE *to, struct atat const *atat)
{
  struct range range =
    {
      .beg = atat->beg,
      .end = (((atat)->holes[(atat)->count - 1]) + 2)
    };
  fro_spew_partial (to, atat->from, &range);
}
<<<sep_in_sample>>>
1 2
2 3
3 8
4 3
5 6
6 6
7 8
8 6
9 3
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 686 <rl_pending_signal+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_pending_signal ()
{
  return (_rl_caught_signal);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%r13d        # 715 <removeCopyDir+0x15>
test   %r13d,%r13d
jne    730 <removeCopyDir+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rbp
mov    %rbp,%rdi
callq  743 <removeCopyDir+0x43>
mov    0x0(%rip),%r15        # 74a <removeCopyDir+0x4a>
mov    %rax,%r14
mov    %r15,%rdi
callq  755 <removeCopyDir+0x55>
lea    0x2(%r14,%rax,1),%rdi
mov    %rax,%rbx
callq  762 <removeCopyDir+0x62>
test   %rax,%rax
mov    %rax,%r12
je     820 <removeCopyDir+0x120>
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %rax,%rdi
callq  77c <removeCopyDir+0x7c>
lea    0x1(%r12,%rbx,1),%rdi
lea    0x1(%r14),%rdx
mov    %rbp,%rsi
movb   $0x2f,(%r12,%rbx,1)
callq  792 <removeCopyDir+0x92>
test   %r13d,%r13d
jle    805 <removeCopyDir+0x105>
sub    $0x1,%r13d
xor    %ebx,%ebx
mov    %r13d,%r14d
add    $0x1,%r14
jmp    7b9 <removeCopyDir+0xb9>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r14,%rbx
je     805 <removeCopyDir+0x105>
mov    0x0(,%rbx,8),%rsi
mov    %r12,%rdi
movslq %ebx,%rbp
callq  7cc <removeCopyDir+0xcc>
test   %eax,%eax
jne    7b0 <removeCopyDir+0xb0>
cmp    %r13d,%ebp
jl     7e3 <removeCopyDir+0xe3>
jmp    7fe <removeCopyDir+0xfe>
nopw   0x0(%rax,%rax,1)
movslq %edx,%rbp
lea    0x1(%rbp),%edx
movslq %edx,%rax
cmp    %r13d,%edx
mov    0x0(,%rax,8),%rax
mov    %rax,0x0(,%rbp,8)
jne    7e0 <removeCopyDir+0xe0>
mov    %r13d,0x0(%rip)        # 805 <removeCopyDir+0x105>
add    $0x8,%rsp
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   81b <removeCopyDir+0x11b>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x1,%edx
mov    $0x1,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
mov    $0x0,%edi
jmpq   842 <removeCopyDir+0x142>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
removeCopyDir(int i)
{
  if(numCopyDirs == 0) return;
  int j, k;
  char *str = (char *) malloc(strlen(dirs[i])+strlen(cwd)+2);
  if(!str) { msgBox("Insufficient memory", 1, ERROR); return; }
  strcpy(str, cwd);
  strcat(str, "/");
  strcat(str, dirs[i]);
  strcat(str, "\0");
  for(j = 0; j < numCopyDirs; j++)
  {
    if(strcmp(str, copyDirs[j]) == 0)
    {
      for(k = j; k < numCopyDirs-1; k++)
      {
 copyDirs[k] = copyDirs[k+1];
      }
      numCopyDirs--;
      free(str);
      return;
    }
  }
  free(str);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 25
12 25
13 25
14 25
15 25
16 25
17 25
18 25
19 25
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 5
33 6
34 7
35 7
36 7
37 7
38 9
39 9
40 9
41 8
42 9
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 13
55 13
56 13
57 13
58 13
59 13
60 15
61 15
62 15
63 15
64 15
65 17
66 17
67 15
68 17
69 17
70 15
71 19
72 25
73 24
74 25
75 25
76 25
77 25
78 25
79 25
80 24
81 24
82 25
83 6
84 6
85 25
86 25
87 25
88 25
89 25
90 25
91 6
92 6
93 6
<<<sep_out_sample>>>
cmpq   $0x2,0x8(%rsp)
mov    $0xffffffff,%eax
jne    79 <haar_centered_init+0x39>
movq   $0x0,(%rdi)
xor    %eax,%eax
movq   $0x0,(%rsi)
movq   $0x0,(%rdx)
movq   $0x0,(%rcx)
movq   $0x2,(%r8)
movq   $0x1,(%r9)
repz retq 
<<<sep_in_sample>>>
haar_centered_init (const double **h1, const double **g1, const double **h2,
                    const double **g2, size_t * nc, size_t * offset,
                    const size_t member)
{
  if (member != 2)
    {
      return GSL_FAILURE;
    }
  *h1 = ch_2;
  *g1 = cg_2;
  *h2 = ch_2;
  *g2 = cg_2;
  *nc = 2;
  *offset = 1;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 9
5 15
6 10
7 11
8 12
9 13
10 14
11 16
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9a6 <_rl_release_sigint+0x6>
test   %eax,%eax
je     9be <_rl_release_sigint+0x1e>
mov    0x0(%rip),%eax        # 9b0 <_rl_release_sigint+0x10>
movl   $0x0,0x0(%rip)        # 9ba <_rl_release_sigint+0x1a>
test   %eax,%eax
jne    9c0 <_rl_release_sigint+0x20>
repz retq 
mov    0x0(%rip),%edi        # 9c6 <_rl_release_sigint+0x26>
jmpq   9cb <_rl_release_sigint+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_release_sigint ()
{
  if (sigint_blocked == 0)
    return;
  sigint_blocked = 0;
  do { if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 5
6 6
7 6
8 6
9 6
10 6
11 6
<<<sep_out_sample>>>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   21b <stcmp+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stcmp(char **s1, char **s2)
{
  return strcmp(*s1, *s2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
sub    $0x40,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
callq  1e2f <set_prompt+0x1f>
mov    0x0(%rip),%rdi        # 1e36 <set_prompt+0x26>
mov    %rax,%rbx
callq  1e3e <set_prompt+0x2e>
mov    $0x33,%edx
mov    %rsp,%rsi
mov    %rax,%rdi
sub    %ebx,%edx
callq  1e50 <set_prompt+0x40>
mov    $0x0,%esi
mov    %rax,%rdi
callq  1e5d <set_prompt+0x4d>
mov    %rax,%rdi
callq  1e65 <set_prompt+0x55>
mov    0x38(%rsp),%rax
xor    %fs:0x28,%rax
jne    1e7b <set_prompt+0x6b>
add    $0x40,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  1e85 <set_prompt+0x75>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_prompt()
{
    char temp[50 + 1];
    il_set_static_text(strcat(truncate_string(panel_get_path(src_panel), temp,
           50 -strlen(PS1)+1),
         PS1));
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 5
8 4
9 5
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    %esi,%edx
mov    %rdx,0x10(%rax)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahs_set_mode(AHS * xhs, mode_t mode) {
      ;
      ahs_vfile_hdr(xhs)->c_mode = (unsigned long)(mode);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
movss  (%rdi),%xmm0
movsd  0x0(%rip),%xmm1        # 87c <DIStoACMVelocity+0xc>
cvtps2pd %xmm0,%xmm0
mulsd  %xmm1,%xmm0
movsd  %xmm0,(%rsi)
movss  0x4(%rdi),%xmm0
cvtps2pd %xmm0,%xmm0
mulsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rsi)
movss  0x8(%rdi),%xmm0
cvtps2pd %xmm0,%xmm0
mulsd  %xmm1,%xmm0
movsd  %xmm0,0x10(%rsi)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
DIStoACMVelocity(dis_float_vector * in, VPoint * out)
{
 out->x = ((in->x) * 3.2808399);
 out->y = ((in->y) * 3.2808399);
 out->z = ((in->z) * 3.2808399);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  13e <register_regex+0xe>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   14c <register_regex+0x1c>
<<<sep_in_sample>>>
register_regex()
{
    dico_strategy_add(&re_strat);
    dico_strategy_add(&regex_strat);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
movq   $0x0,(%rsp)
callq  bb9 <grecs_print_node+0x19>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_print_node(struct grecs_node *node, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 return grecs_format_node(node, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     e1 <pair_free+0x11>
callq  e1 <pair_free+0x11>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     ef <pair_free+0x1f>
callq  ef <pair_free+0x1f>
mov    %rbx,%rdi
pop    %rbx
jmpq   f8 <pair_free+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pair_free (struct pair * pair)
{
  do { if (pair->key) free (pair->key); } while (0);
  do { if (pair->value) free (pair->value); } while (0);
  do { if (pair) free (pair); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 6
13 5
14 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
movzbl (%rsi),%esi
test   %sil,%sil
je     16c5 <string_WX+0x35>
mov    %rdi,%r12
xor    %ebp,%ebp
nopl   0x0(%rax)
add    $0x1,%rbx
mov    %r12,%rdi
callq  16b4 <string_WX+0x24>
movzbl (%rbx),%esi
add    %eax,%ebp
test   %sil,%sil
jne    16a8 <string_WX+0x18>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
xor    %ebp,%ebp
jmp    16be <string_WX+0x2e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
string_WX (a2ps_job * job, unsigned char * string)
{
  unsigned int result=0;
  for ( ; *string ; string ++)
    result += char_WX(job, *string);
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 3
10 3
11 4
12 5
13 5
14 4
15 5
16 4
17 4
18 7
19 7
20 7
21 7
22 7
23 3
24 3
25 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  19 <nettle_aes128_set_decrypt_key+0x9>
mov    %rbx,%rsi
mov    %rbx,%rdi
pop    %rbx
jmpq   25 <nettle_aes128_set_decrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes128_set_decrypt_key(struct aes128_ctx *ctx, const uint8_t *key)
{
  nettle_aes128_set_encrypt_key (ctx, key);
  nettle_aes128_invert_key (ctx, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
<<<sep_out_sample>>>
push   %r13
mov    %ecx,%r8d
mov    %edx,%r13d
push   %r12
mov    %ecx,%r12d
mov    %edx,%ecx
mov    %esi,%edx
push   %rbp
mov    %esi,%ebp
xor    %esi,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12d,%ecx
mov    %r13d,%r8d
xor    %r9d,%r9d
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x8b,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   ad0 <_rx.isra.34>
nop
<<<sep_in_sample>>>
_ldxr_ui(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 0, r0, r1, r2);
    *_jit->pc.uc++ = 0x8b;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 2
9 2
10 3
11 2
12 2
13 2
14 3
15 4
16 5
17 5
18 5
19 5
20 5
21 4
22 4
23 4
24 6
25 6
26 6
27 6
28 6
29 5
30 5
31 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
callq  350 <hybridj_iterate_impl>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hybridj_iterate (void *vstate, gsl_multiroot_function_fdf * fdf, gsl_vector * x, gsl_vector * f, gsl_matrix * J, gsl_vector * dx)
{
  int status = hybridj_iterate_impl (vstate, fdf, x, f, J, dx, 0);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
<<<sep_out_sample>>>
movl   $0x14,0x90(%rdi)
movq   $0x0,0x228(%rdi)
movq   $0x0,0x230(%rdi)
movq   $0x0,0x238(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
CDB___txn_dbenv_create(dbenv)
 DB_ENV *dbenv;
{
 dbenv->tx_max = 20;
 dbenv->set_tx_max = __txn_set_tx_max;
 dbenv->set_tx_recover = __txn_set_tx_recover;
 dbenv->set_tx_timestamp = __txn_set_tx_timestamp;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 7
6 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 686 <rl_pending_signal+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_pending_signal ()
{
  return (_rl_caught_signal);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
lea    0x1(%rsi),%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  85 <stndup+0x15>
test   %rax,%rax
mov    %rax,%rcx
je     a2 <stndup+0x32>
movb   $0x0,(%rax,%rbx,1)
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  9f <stndup+0x2f>
mov    %rax,%rcx
add    $0x8,%rsp
mov    %rcx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
stndup (const char *str, size_t n)
{
  char *tmp;
  if (((void *)0) == (tmp = malloc (n + 1)))
    return ((void *)0);
  tmp[n] = '\0';
  memcpy (tmp, str, n);
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 6
12 7
13 7
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
test   %rsi,%rsi
mov    %rsi,(%rax)
setne  %al
movzbl %al,%edx
movzbl %al,%eax
mov    %edx,0x4(%rdi)
mov    %rax,0x8(%rdi)
retq   
<<<sep_in_sample>>>
__gmpf_set_ui (mpf_ptr f, unsigned long val)
{
  mp_size_t size;
  f->_mp_d[0] = val & ((~ ((mp_limb_t) (0))) >> 0);
  size = val != 0;
  f->_mp_exp = f->_mp_size = size;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 6
6 6
7 6
8 6
9 6
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
test   %r10,%r10
je     3314 <gsl_matrix_ushort_add_constant+0x64>
push   %rbx
lea    (%r9,%r9,1),%rbx
add    %r11,%r11
xor    %esi,%esi
xor    %r8d,%r8d
nopl   (%rax)
test   %r9,%r9
je     3304 <gsl_matrix_ushort_add_constant+0x54>
mov    0x18(%rdi),%rdx
lea    (%rsi,%rbx,1),%rcx
lea    (%rdx,%rsi,1),%rax
add    %rdx,%rcx
nopl   0x0(%rax)
movzwl (%rax),%edx
add    $0x2,%rax
cvtsi2sd %edx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%edx
mov    %dx,-0x2(%rax)
cmp    %rcx,%rax
jne    32e8 <gsl_matrix_ushort_add_constant+0x38>
add    $0x1,%r8
add    %r11,%rsi
cmp    %r10,%r8
jne    32d0 <gsl_matrix_ushort_add_constant+0x20>
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_add_constant (gsl_matrix_ushort * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 2
7 2
8 2
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 7
28 7
29 7
30 7
31 15
32 15
33 15
34 15
35 15
36 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b3 <keys_init+0x13>
test   %eax,%eax
jne    4cc <keys_init+0x2c>
xor    %esi,%esi
mov    $0x0,%edi
callq  4c3 <keys_init+0x23>
test   %eax,%eax
jne    4cc <keys_init+0x2c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
callq  4d5 <keys_init+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
keys_init (void)
{
  do { if (((pthread_cancel != ((void *)0)) ? pthread_key_create (&(&buffer_key)->key, free) : ((&buffer_key)->singlethread_value = ((void *)0), 0))) abort (); } while (0);
  do { if (((pthread_cancel != ((void *)0)) ? pthread_key_create (&(&bufmax_key)->key, ((void *)0)) : ((&bufmax_key)->singlethread_value = ((void *)0), 0))) abort (); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 3
16 3
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0x1,0x0(%rip)        # 319 <in_terminal_mode+0x9>
sete   %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
in_terminal_mode()
{
    return (current_mode == 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     5ad6 <_jit_get_code+0x16>
mov    0x38(%rdi),%rax
testb  $0x4,0x10(%rax)
jne    5ae0 <_jit_get_code+0x20>
mov    0x10(%rdi),%rax
mov    %rax,(%rsi)
mov    0x8(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rdi),%rax
mov    (%rdi),%rdx
sub    %rax,%rdx
mov    %rdx,(%rsi)
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
_jit_get_code(jit_state_t *_jit, jit_word_t *length)
{
    ((void) (0));
    if (length) {
 if (_jit->comp->done)
     *length = _jit->pc.uc - _jit->code.ptr;
 else
     *length = _jit->code.length;
    }
    return (_jit->code.ptr);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 8
7 8
8 8
9 11
10 11
11 6
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 16a6 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %esi,%esi
callq  6eb <parse_nogroup+0xb>
movl   $0x38d1b717,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
parse_nogroup (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) &argv;
  (void) &arg_ptr;
  our_pred = insert_primary (entry, ((void *)0));
  our_pred->est_success_rate = 1e-4;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 9
6 9
7 9
8 9
<<<sep_out_sample>>>
push   %r12
xor    %r12d,%r12d
test   %rdi,%rdi
push   %rbp
mov    %rdi,%rbp
push   %rbx
je     8c00 <word_list_split+0x60>
mov    0x8(%rdi),%rdi
mov    0x0(%rip),%rsi        # 8bba <word_list_split+0x1a>
callq  8bbf <word_list_split+0x1f>
mov    %rax,%r12
mov    %rax,%rbx
nopl   (%rax)
mov    0x0(%rbp),%rbp
test   %rbp,%rbp
je     8c00 <word_list_split+0x60>
mov    0x8(%rbp),%rdi
mov    0x0(%rip),%rsi        # 8bdc <word_list_split+0x3c>
callq  8be1 <word_list_split+0x41>
test   %r12,%r12
je     8c08 <word_list_split+0x68>
mov    %rax,(%rbx)
nopl   0x0(%rax)
test   %rax,%rax
je     8bc8 <word_list_split+0x28>
mov    %rax,%rbx
mov    (%rax),%rax
jmp    8bf0 <word_list_split+0x50>
nopl   (%rax)
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
retq   
mov    %rax,%rbx
mov    %rax,%r12
jmp    8bc8 <word_list_split+0x28>
<<<sep_in_sample>>>
word_list_split (list)
     WORD_LIST *list;
{
  WORD_LIST *result, *t, *tresult, *e;
  for (t = list, result = (WORD_LIST *)((void *)0); t; t = t->next)
    {
      tresult = word_split (t->word, ifs_value);
      if (result == 0)
        result = e = tresult;
      else
 {
   e->next = tresult;
   while (e->next)
     e = e->next;
 }
    }
  return (result);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 3
6 3
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 5
15 5
16 5
17 7
18 7
19 7
20 8
21 8
22 12
23 12
24 13
25 13
26 13
27 13
28 13
29 13
30 18
31 18
32 18
33 18
34 18
35 7
36 7
37 7
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   358 <getParent+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getParent(direntry_t *entry)
{
 return getDirentry(entry->Dir);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
sub    $0x10,%rsp
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
callq  1510 <smtp_session+0x20>
mov    $0x2,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  151f <smtp_session+0x2f>
callq  1524 <smtp_session+0x34>
mov    $0x0,%edi
callq  152e <smtp_session+0x3e>
mov    $0x2,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  153d <smtp_session+0x4d>
callq  1542 <smtp_session+0x52>
mov    %rax,%rbx
nopl   (%rax)
mov    0x0(%rip),%rsi        # 154f <smtp_session+0x5f>
lea    0x8(%rsp),%rcx
mov    %rsp,%rdx
mov    $0x1,%edi
callq  1561 <smtp_session+0x71>
test   %eax,%eax
je     158a <smtp_session+0x9a>
mov    (%rsp),%rdi
callq  156e <smtp_session+0x7e>
mov    (%rsp),%rsi
mov    %rbx,%rdi
callq  170 <process_command>
test   %eax,%eax
jne    1548 <smtp_session+0x58>
mov    %rbx,%rdi
callq  e90 <transfer_command>
test   %eax,%eax
jne    1548 <smtp_session+0x58>
mov    (%rsp),%rdi
callq  1593 <smtp_session+0xa3>
mov    %rbx,%rdi
callq  159b <smtp_session+0xab>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
smtp_session (void)
{
  char *command = ((void *)0);
  size_t size = 0;
  MESSAGE msg;
  info (2, gettext("Starting SMTP session..."));
  smtp_begin ();
  info (2, gettext("Transferring messages..."));
  msg = message_new ();
  while (recvline (1, remote_client, &command, &size))
    {
      remcrlf (command);
      if (process_command (msg, command))
 continue;
      if (transfer_command (msg) == 0)
 break;
    }
  free (command);
  message_free (msg);
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 3
5 4
6 6
7 6
8 6
9 6
10 6
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 13
31 13
32 13
33 13
34 13
35 15
36 15
37 15
38 15
39 18
40 18
41 19
42 19
43 20
44 20
45 20
<<<sep_out_sample>>>
test   %esi,%esi
je     325 <send_dont+0x35>
movslq %edi,%rax
movzbl 0x0(%rax),%ecx
movzbl 0x0(%rax),%edx
test   %cl,%cl
jne    30e <send_dont+0x1e>
test   $0x4,%dl
je     330 <send_dont+0x40>
test   $0x8,%dl
je     330 <send_dont+0x40>
and    $0xfffffff7,%edx
add    $0x1,%ecx
mov    %dl,0x0(%rax)
mov    %cl,0x0(%rax)
jmpq   f0 <send_dont.part.1>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
send_dont (register int c, register int init)
{
  if (init)
    {
      if (((do_dont_resp[c] == 0) && (!(options[c]&0x04))) ||
   (!(options[c]&0x08)))
 return;
      {options[c] &= ~0x08;};
      do_dont_resp[c]++;
    }
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 254; ring_supplied(&netoring, 1); }; };
  { *netoring.supply = c; ring_supplied(&netoring, 1); };
  printoption ("SENT", 254, c);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 8
13 9
14 8
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edx
mov    $0x100,%esi
mov    $0x180,%edi
callq  15 <utmp_init+0x15>
mov    %rax,0x0(%rip)        # 1c <utmp_init+0x1c>
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
utmp_init(int backwards)
{
  utmp_info = file_reader_init(sizeof (struct utmp), 256,
                               backwards);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x16,%eax
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     65c <mu_string_to_flags+0x6c>
mov    $0x7,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  615 <mu_string_to_flags+0x25>
test   %eax,%eax
je     671 <mu_string_to_flags+0x81>
movzbl (%rbx),%ecx
test   %cl,%cl
je     65a <mu_string_to_flags+0x6a>
mov    0x0(%rip),%edx        # 626 <mu_string_to_flags+0x36>
test   %edx,%edx
je     64f <mu_string_to_flags+0x5f>
cmp    0x0(%rip),%cl        # 630 <mu_string_to_flags+0x40>
je     668 <mu_string_to_flags+0x78>
mov    $0x0,%eax
jmp    645 <mu_string_to_flags+0x55>
nopl   0x0(%rax)
cmp    0x4(%rax),%cl
je     668 <mu_string_to_flags+0x78>
add    $0x8,%rax
mov    (%rax),%edx
test   %edx,%edx
jne    640 <mu_string_to_flags+0x50>
add    $0x1,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    620 <mu_string_to_flags+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
or     %edx,0x0(%rbp)
add    $0x1,%rbx
jmp    653 <mu_string_to_flags+0x63>
mov    %rbx,%rdi
mov    $0x3a,%esi
callq  67e <mu_string_to_flags+0x8e>
lea    0x1(%rax),%rbx
jmp    619 <mu_string_to_flags+0x29>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_string_to_flags (const char *buffer, int *pflags)
{
  const char *sep;
  if (pflags == ((void *)0))
    return 22;
  if (mu_c_strncasecmp (buffer, "Status:", 7) == 0)
    {
      sep = strchr(buffer, ':');
      sep++;
    }
  else
    sep = buffer;
  for (; *sep; sep++)
    {
      struct flagtrans *ft;
      for (ft = flagtrans; ft->flag; ft++)
 if (ft->letter == *sep)
   {
     *pflags |= ft->flag;
     break;
   }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 13
15 13
16 13
17 16
18 16
19 16
20 17
21 17
22 17
23 17
24 17
25 17
26 17
27 16
28 16
29 16
30 16
31 13
32 13
33 13
34 13
35 23
36 24
37 24
38 24
39 24
40 24
41 19
42 13
43 13
44 8
45 8
46 8
47 9
48 9
49 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     360 <csv_get_buffer_size+0x10>
mov    0x20(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_get_buffer_size(struct csv_parser *p)
{
  if (p)
    return p->entry_size;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 6
8 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     858 <reset_clixpath+0x28>
mov    %rdi,%rsi
mov    $0x1,%edx
mov    $0x0,%edi
callq  84b <reset_clixpath+0x1b>
mov    %rbx,%rdi
pop    %rbx
jmpq   854 <reset_clixpath+0x24>
nopl   0x0(%rax)
pop    %rbx
mov    $0x0,%edi
jmpq   863 <reset_clixpath+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reset_clixpath (char *old_classpath)
{
  if (old_classpath != ((void *)0))
    {
      xsetenv ("LD_LIBRARY_PATH", old_classpath, 1);
      free (old_classpath);
    }
  else
    unsetenv ("LD_LIBRARY_PATH");
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 6
10 10
11 6
12 6
13 10
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
mov    %rdx,%rsi
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
callq  28c5 <text_buffer_fill+0x15>
mov    0x10(%rbx),%rax
mov    %rax,%rcx
add    (%rbx),%rcx
test   %rbp,%rbp
je     28f1 <text_buffer_fill+0x41>
lea    (%rcx,%rbp,1),%r8
mov    %r12d,%r9d
nopl   0x0(%rax,%rax,1)
add    $0x1,%rcx
mov    %r9b,-0x1(%rcx)
cmp    %r8,%rcx
jne    28e0 <text_buffer_fill+0x30>
mov    0x10(%rbx),%rax
add    %rbp,%rax
mov    %rax,0x10(%rbx)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
text_buffer_fill (struct text_buffer *buf, int c, size_t len)
{
  char *p;
  int i;
  text_buffer_alloc (buf, len);
  for (i = 0, p = buf->base + buf->off; i < len; i++)
    *p++ = c;
  buf->off += len;
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 2
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 6
20 6
21 6
22 8
23 8
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
test   %edi,%edi
jne    b30 <_rl_control_keypad+0x20>
mov    0x0(%rip),%rdi        # b1b <_rl_control_keypad+0xb>
test   %rdi,%rdi
je     b3c <_rl_control_keypad+0x2c>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   b2f <_rl_control_keypad+0x1f>
nop
mov    0x0(%rip),%rdi        # b37 <_rl_control_keypad+0x27>
test   %rdi,%rdi
jne    b20 <_rl_control_keypad+0x10>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
_rl_control_keypad (on)
     int on;
{
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 7
7 7
8 7
9 7
10 4
11 4
12 4
13 4
14 4
<<<sep_out_sample>>>
movzbl 0x30(%rdi),%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_parser_eof (rec_parser_t parser)
{
  return parser->eof;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    18 <umaxtostr+0x18>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 15
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 16
14 15
15 16
16 16
17 19
18 19
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     44a <reply+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rbx
mov    $0x0,%edi
mov    %ebp,%esi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  482 <reply+0x92>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  48f <reply+0x9f>
mov    $0x0,%edi
callq  499 <reply+0xa9>
mov    0x0(%rip),%rdi        # 4a0 <reply+0xb0>
callq  4a5 <reply+0xb5>
mov    0x0(%rip),%eax        # 4ab <reply+0xbb>
test   %eax,%eax
je     4fb <reply+0x10b>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  4c2 <reply+0xd2>
lea    0xf0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    $0x7,%edi
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  4fb <reply+0x10b>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reply (int n, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  printf ("%d ", n);
  vprintf (fmt, ap);
  __builtin_va_end(ap);
  printf ("\r\n");
  fflush (stdout);
  if (debug)
    {
      syslog (7, "<--- %d ", n);
      __builtin_va_start(ap,fmt);
      vsyslog (7, fmt, ap);
      __builtin_va_end(ap);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 2
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 5
29 5
30 6
31 6
32 6
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 12
41 12
42 12
43 12
44 12
45 13
46 14
47 14
48 14
49 13
50 13
51 13
52 13
53 13
54 14
55 17
56 17
57 17
58 17
59 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 4b <disk_fill_input_buffer+0xb>
cmp    $0x200,%rsi
mov    $0x200,%edx
cmovle %rsi,%rdx
mov    %rax,%rsi
mov    %rax,0x0(%rip)        # 65 <disk_fill_input_buffer+0x25>
callq  6a <disk_fill_input_buffer+0x2a>
cmp    $0xffffffffffffffff,%rax
mov    %rax,%rdx
mov    %rax,0x0(%rip)        # 78 <disk_fill_input_buffer+0x38>
je     98 <disk_fill_input_buffer+0x58>
test   %rdx,%rdx
mov    $0x1,%eax
je     8d <disk_fill_input_buffer+0x4d>
add    %rdx,0x0(%rip)        # 8b <disk_fill_input_buffer+0x4b>
xor    %al,%al
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movq   $0x0,0x0(%rip)        # a3 <disk_fill_input_buffer+0x63>
jmp    8d <disk_fill_input_buffer+0x4d>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
disk_fill_input_buffer (int in_des, off_t num_bytes)
{
  in_buff = input_buffer;
  num_bytes = (num_bytes < 512) ? num_bytes : 512;
  input_size = read (in_des, input_buffer, num_bytes);
  if (input_size == ((size_t) -1))
    {
      input_size = 0;
      return (-1);
    }
  else if (input_size == 0)
    return (1);
  input_bytes += input_size;
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 3
8 5
9 6
10 5
11 5
12 6
13 11
14 12
15 11
16 13
17 14
18 15
19 15
20 15
21 8
22 9
23 9
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    $0x16,%eax
mov    %rdi,%rbx
je     bb <mu_ticket_unref+0x4b>
mov    0x8(%rdi),%eax
test   %eax,%eax
jne    c0 <mu_ticket_unref+0x50>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     93 <mu_ticket_unref+0x23>
callq  93 <mu_ticket_unref+0x23>
cmpq   $0x0,0x18(%rbx)
je     a3 <mu_ticket_unref+0x33>
lea    0x18(%rbx),%rdi
callq  a3 <mu_ticket_unref+0x33>
mov    0x20(%rbx),%rax
test   %rax,%rax
je     b1 <mu_ticket_unref+0x41>
mov    %rbx,%rdi
callq  *%rax
mov    %rbx,%rdi
callq  b9 <mu_ticket_unref+0x49>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,0x8(%rdi)
je     85 <mu_ticket_unref+0x15>
mov    $0x1029,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ticket_unref (mu_ticket_t ticket)
{
  if (!ticket)
    return 22;
  if (ticket->refcnt)
    ticket->refcnt--;
  if (ticket->refcnt == 0)
    {
      if (ticket->plain)
 free (ticket->plain);
      if (ticket->secret)
 mu_secret_destroy (&ticket->secret);
      if (ticket->_destroy)
 ticket->_destroy (ticket);
      free (ticket);
      return 0;
    }
  return (0x1000 +41);
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 2
5 3
6 5
7 5
8 5
9 9
10 9
11 9
12 10
13 11
14 11
15 12
16 12
17 13
18 13
19 13
20 14
21 14
22 15
23 15
24 16
25 19
26 19
27 19
28 6
29 7
30 6
31 7
32 18
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   65a <buffer_write_global_xheader+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_write_global_xheader (void)
{
  xheader_write_global (&dummy.xhdr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
jmpq   65 <rec_rset_record_disp_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_record_disp_fn (void *data)
{
  rec_record_t record = (rec_record_t) data;
  rec_record_destroy (record);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_authorization_id_set (Gsasl * ctx,
         Gsasl_client_callback_authorization_id
         cb)
{
  ctx->cbc_authorization_id = cb;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
test   %r10,%r10
movzbl (%rdi),%r8d
je     17be <gsl_vector_uchar_minmax_index+0x4e>
mov    %r8d,%r9d
xor    %eax,%eax
xor    %ebx,%ebx
xor    %ebp,%ebp
nop
movzbl (%rdi),%ecx
cmp    %r9b,%cl
jae    179e <gsl_vector_uchar_minmax_index+0x2e>
mov    %ecx,%r9d
mov    %rax,%rbp
cmp    %r8b,%cl
jbe    17a9 <gsl_vector_uchar_minmax_index+0x39>
mov    %ecx,%r8d
mov    %rax,%rbx
add    $0x1,%rax
add    %r11,%rdi
cmp    %r10,%rax
jne    1790 <gsl_vector_uchar_minmax_index+0x20>
mov    %rbp,(%rsi)
mov    %rbx,(%rdx)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    17b5 <gsl_vector_uchar_minmax_index+0x45>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_minmax_index (const gsl_vector_uchar * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  unsigned char max = v->data[0 * stride];
  unsigned char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 11
7 8
8 11
9 9
10 11
11 7
12 7
13 7
14 13
15 14
16 14
17 14
18 14
19 19
20 19
21 19
22 19
23 11
24 11
25 11
26 11
27 25
28 26
29 27
30 27
31 27
32 7
33 7
34 7
35 7
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  705 <gsl_stats_uint_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  718 <gsl_stats_uint_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  735 <gsl_stats_uint_ttest+0x55>
test   %rbp,%rbp
js     798 <gsl_stats_uint_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 747 <gsl_stats_uint_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     7b8 <gsl_stats_uint_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     7d2 <gsl_stats_uint_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    73f <gsl_stats_uint_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    759 <gsl_stats_uint_ttest+0x79>
test   %rbp,%rbp
js     80c <gsl_stats_uint_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     823 <gsl_stats_uint_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  803 <gsl_stats_uint_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   777 <gsl_stats_uint_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    7dc <gsl_stats_uint_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    7ee <gsl_stats_uint_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uint_ttest (const unsigned int data1[],
                           const size_t stride1, const size_t n1,
                           const unsigned int data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_uint_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_uint_mean (data2, stride2, n2);
  const double pv = gsl_stats_uint_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x1020(%rdi),%rdi
movzbl %sil,%esi
jmpq   7d0 <eject_media_linux>
<<<sep_in_sample>>>
get_track_isrc_linux (const void *p_user_data, track_t i_track) {
  const _img_private_t *p_env = p_user_data;
  return mmc_get_track_isrc( p_env->gen.cdio, i_track );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  e3c <gsl_sf_legendre_Q1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    e50 <gsl_sf_legendre_Q1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x168,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e66 <gsl_sf_legendre_Q1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_Q1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_legendre_Q1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_legendre_Q1_e(x, &result)", "legendre_Qn.c", 360, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9d6 <meta1_line_begin+0x6>
test   %eax,%eax
je     9e0 <meta1_line_begin+0x10>
repz retq 
nopl   0x0(%rax)
jmpq   1f0 <meta1_line_begin.part.1>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1_line_begin ()
{
  if (!meta1_stk_init)
    {
      _obstack_begin ((&meta1_stk), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
      meta1_stk_init = 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
mov    (%rdi),%rax
cmp    0x8(%rsi),%rax
je     258 <gsl_multiroot_fsolver_set+0x38>
mov    $0x13,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  24a <gsl_multiroot_fsolver_set+0x2a>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
cmp    (%rdx),%rax
je     280 <gsl_multiroot_fsolver_set+0x60>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  276 <gsl_multiroot_fsolver_set+0x56>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   (%rax)
mov    %rsi,0x8(%rbx)
mov    %rdx,%rsi
callq  28c <gsl_multiroot_fsolver_set+0x6c>
mov    (%rbx),%rax
mov    0x18(%rbx),%rcx
mov    0x10(%rbx),%rdx
mov    0x8(%rbx),%rsi
mov    0x28(%rbx),%rdi
mov    0x20(%rbx),%r8
pop    %rbx
mov    0x18(%rax),%rax
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fsolver_set (gsl_multiroot_fsolver * s,
                           gsl_multiroot_function * f,
                           const gsl_vector * x)
{
  if (s->x->size != f->n)
    {
      do { gsl_error ("function incompatible with solver size", "fsolver.c", 110, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  if (x->size != f->n)
    {
      do { gsl_error ("vector length not compatible with function", "fsolver.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  s->function = f;
  gsl_vector_memcpy(s->x,x);
  return (s->type->set) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 16
13 16
14 16
15 16
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 16
24 16
25 16
26 16
27 13
28 14
29 14
30 15
31 15
32 15
33 15
34 15
35 15
36 16
37 15
38 15
39 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  86c <gsl_sf_bessel_In_scaled+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    880 <gsl_sf_bessel_In_scaled+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  896 <gsl_sf_bessel_In_scaled+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_In_scaled(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_In_scaled_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_In_scaled_e(n, x, &result)", "bessel_In.c", 219, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  47aa <set_ppid+0x1a>
mov    $0xc,%edx
movslq %eax,%rdi
mov    %rsp,%rsi
callq  47ba <set_ppid+0x2a>
mov    $0x0,%edi
mov    %rax,%rbx
callq  47c7 <set_ppid+0x37>
test   %rax,%rax
je     47d0 <set_ppid+0x40>
andl   $0xfffffffc,0x28(%rax)
xor    %edx,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  47df <set_ppid+0x4f>
orl    $0x12,0x28(%rax)
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
jne    47f9 <set_ppid+0x69>
add    $0x20,%rsp
pop    %rbx
retq   
callq  47fe <set_ppid+0x6e>
xchg   %ax,%ax
<<<sep_in_sample>>>
set_ppid ()
{
  char namebuf[((sizeof (pid_t) * 8 - (! ((pid_t) 0 < (pid_t) -1))) * 302 / 1000 + 1 + (! ((pid_t) 0 < (pid_t) -1))) + 1], *name;
  SHELL_VAR *temp_var;
  name = inttostr (getppid (), namebuf, sizeof(namebuf));
  temp_var = find_variable ("PPID");
  if (temp_var)
    ((temp_var)->attributes &= ~((0x0000002 | 0x0000001)));
  temp_var = bind_variable ("PPID", name, 0);
  ((temp_var)->attributes |= ((0x0000002 | 0x0000010)));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 6
12 5
13 6
14 7
15 7
16 8
17 9
18 9
19 9
20 9
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
movsd  %xmm0,-0x8(%rsp)
test   %r10,%r10
fldl   -0x8(%rsp)
je     1642 <gsl_matrix_long_double_add_constant+0x72>
mov    %r9,%rbx
shl    $0x4,%r11
xor    %ecx,%ecx
shl    $0x4,%rbx
xor    %esi,%esi
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     1632 <gsl_matrix_long_double_add_constant+0x62>
mov    0x18(%rdi),%rdx
lea    (%rcx,%rbx,1),%r8
fld    %st(0)
lea    (%rdx,%rcx,1),%rax
add    %r8,%rdx
nopw   %cs:0x0(%rax,%rax,1)
fldt   (%rax)
add    $0x10,%rax
fadd   %st(1),%st
fstpt  -0x10(%rax)
cmp    %rdx,%rax
jne    1620 <gsl_matrix_long_double_add_constant+0x50>
fstp   %st(0)
add    $0x1,%rsi
add    %r11,%rcx
cmp    %r10,%rsi
jne    1600 <gsl_matrix_long_double_add_constant+0x30>
fstp   %st(0)
jmp    1644 <gsl_matrix_long_double_add_constant+0x74>
fstp   %st(0)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_add_constant (gsl_matrix_long_double * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 2
6 7
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 9
28 9
29 9
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 15
38 15
39 15
40 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  189 <xzalloc+0x9>
mov    %rbx,%rdx
xor    %esi,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   197 <xzalloc+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x50(%rsi),%rsi
mov    0x50(%rdi),%rdi
callq  2b1 <compare_directory_canonical_names+0x11>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
compare_directory_canonical_names (void const *entry1, void const *entry2)
{
  struct directory const *directory1 = entry1;
  struct directory const *directory2 = entry2;
  return strcmp (directory1->caname, directory2->caname) == 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4c0 <gsasl_client_callback_passcode_get+0x10>
mov    0x48(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_passcode_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_passcode : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  e <next_char+0xe>
cmp    $0xa,%eax
mov    %eax,%ebx
je     30 <next_char+0x30>
addl   $0x1,0x0(%rip)        # 1c <next_char+0x1c>
cmp    $0x5c,%eax
je     50 <next_char+0x50>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
addl   $0x1,0x0(%rip)        # 37 <next_char+0x37>
movl   $0x0,0x0(%rip)        # 41 <next_char+0x41>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  58 <next_char+0x58>
cmp    $0xa,%eax
je     70 <next_char+0x70>
mov    %rbp,%rsi
mov    %eax,%edi
callq  67 <next_char+0x67>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
mov    %rbp,%rdi
addl   $0x1,0x0(%rip)        # 7a <next_char+0x7a>
movl   $0x0,0x0(%rip)        # 84 <next_char+0x84>
callq  89 <next_char+0x89>
addl   $0x1,0x0(%rip)        # 90 <next_char+0x90>
mov    %eax,%ebx
jmp    21 <next_char+0x21>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_char(FILE *infile)
{
 int c = fgetc(infile);
 if (c == '\n')
  do { (grecs_current_locus_point).line++; (grecs_current_locus_point).col = 0; } while (0);
 else {
  grecs_current_locus_point.col++;
  if (c == '\\') {
   int nc = fgetc(infile);
   if (nc == '\n') {
    do { (grecs_current_locus_point).line++; (grecs_current_locus_point).col = 0; } while (0);
    c = fgetc(infile);
    grecs_current_locus_point.col++;
   } else
    ungetc(nc, infile);
  }
 }
 return c;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 7
10 8
11 8
12 19
13 19
14 19
15 19
16 19
17 19
18 5
19 5
20 19
21 19
22 19
23 19
24 19
25 19
26 9
27 9
28 10
29 10
30 15
31 15
32 15
33 19
34 19
35 19
36 19
37 19
38 12
39 11
40 11
41 12
42 13
43 12
44 12
45 12
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    (%rsi),%rdi
cmp    %rdx,%rdi
jbe    3df0 <gsl_matrix_char_subdiagonal+0x50>
mov    0x10(%rsi),%r8
mov    %rdx,%rcx
sub    %rdx,%rdi
mov    0x8(%rsi),%rdx
mov    0x20(%rsi),%r9
movl   $0x0,0x20(%rax)
imul   %r8,%rcx
add    0x18(%rsi),%rcx
cmp    %rdx,%rdi
mov    %r9,0x18(%rax)
cmova  %rdx,%rdi
add    $0x1,%r8
mov    %rdi,(%rax)
mov    %r8,0x8(%rax)
mov    %rcx,0x10(%rax)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x5c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
callq  3e12 <gsl_matrix_char_subdiagonal+0x72>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_subdiagonal (gsl_matrix_char * m,
                                    const size_t k)
{
  _gsl_vector_char_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size1)
    {
      do { gsl_error ("subdiagonal index is out of range", "rowcol_source.c", 92, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_char v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1 * m->tda;
    v.size = ((m->size1 - k) < (m->size2) ? (m->size1 - k) : (m->size2));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 11
6 11
7 12
8 12
9 14
10 17
11 11
12 11
13 12
14 17
15 12
16 13
17 17
18 13
19 17
20 17
21 17
22 3
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 19
36 19
37 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     908 <dico_list_remove+0x18>
mov    %rdx,%rcx
mov    0x28(%rdi),%rdx
jmpq   901 <dico_list_remove+0x11>
nopl   0x0(%rax)
sub    $0x8,%rsp
callq  911 <dico_list_remove+0x21>
movl   $0x16,(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_list_remove(struct dico_list *list, void *data, void **pret)
{
    if (!list) {
 (*__errno_location ()) = 22;
 return 1;
    }
    return _dico_list_remove(list, data, list->comp, pret);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 7
6 7
7 2
8 4
9 4
10 8
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
lea    0xe8(%rdi),%rbp
push   %rbx
xor    %ebx,%ebx
jmp    d72 <mu_m_server_restore_signals+0x22>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    $0x41,%rbx
je     d99 <mu_m_server_restore_signals+0x49>
mov    %ebx,%esi
mov    %rbp,%rdi
callq  d7c <mu_m_server_restore_signals+0x2c>
test   %eax,%eax
je     d68 <mu_m_server_restore_signals+0x18>
mov    0x168(%r12,%rbx,8),%rsi
mov    %ebx,%edi
add    $0x1,%rbx
callq  240 <set_signal>
cmp    $0x41,%rbx
jne    d72 <mu_m_server_restore_signals+0x22>
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_m_server_restore_signals (mu_m_server_t msrv)
{
  int i;
  for (i = 0; i < 65; i++)
    if (sigismember (&msrv->sigmask, i))
      set_signal (i, msrv->sigtab[i]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 4
22 4
23 7
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  16be <component_create+0xe>
test   %rax,%rax
mov    %rax,%rbx
je     16d0 <component_create+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
mov    $0x140,%edi
callq  16da <component_create+0x2a>
mov    %rax,%rbx
mov    0x0(%rip),%eax        # 16e3 <component_create+0x33>
mov    %rbp,%rdi
movl   $0x0,0xe8(%rbx)
movl   $0x0,0xd8(%rbx)
mov    %eax,0xd0(%rbx)
callq  1705 <component_create+0x55>
movl   $0x1,0x90(%rbx)
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
component_create (const char *name)
{
  struct component *comp = progman_lookup_component (name);
  if (!comp)
    {
      comp = xzalloc (sizeof (*comp));
      comp->facility = log_facility;
      comp->redir[0].type = comp->redir[1].type = redir_null;
      comp->tag = xstrdup (name);
      comp->socket_type = SOCK_STREAM;
    }
  return comp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 13
10 13
11 13
12 13
13 13
14 6
15 6
16 6
17 7
18 9
19 8
20 8
21 7
22 9
23 10
24 9
25 13
26 13
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 8d6 <_rl_fix_point+0x6>
mov    0x0(%rip),%eax        # 8dc <_rl_fix_point+0xc>
cmp    %eax,%edx
jle    900 <_rl_fix_point+0x30>
mov    %eax,0x0(%rip)        # 8e6 <_rl_fix_point+0x16>
test   %edi,%edi
je     8f8 <_rl_fix_point+0x28>
mov    0x0(%rip),%edx        # 8f0 <_rl_fix_point+0x20>
cmp    %edx,%eax
jl     910 <_rl_fix_point+0x40>
test   %edx,%edx
js     920 <_rl_fix_point+0x50>
repz retq 
nopw   0x0(%rax,%rax,1)
test   %edx,%edx
jns    8e6 <_rl_fix_point+0x16>
movl   $0x0,0x0(%rip)        # 90e <_rl_fix_point+0x3e>
jmp    8e6 <_rl_fix_point+0x16>
mov    %eax,0x0(%rip)        # 916 <_rl_fix_point+0x46>
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 92a <_rl_fix_point+0x5a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  do { if (rl_point > rl_end) rl_point = rl_end; else if (rl_point < 0) rl_point = 0; } while (0);
  if (fix_mark_too)
    do { if (rl_mark > rl_end) rl_mark = rl_end; else if (rl_mark < 0) rl_mark = 0; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 4
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  479 <c_reserved_yacc+0x9>
test   %rax,%rax
je     498 <c_reserved_yacc+0x28>
mov    0x8(%rax),%edx
xor    %eax,%eax
cmp    $0xfa0,%edx
cmovg  %edx,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
c_reserved_yacc(const char *str, int len)
{
 struct keyword *keyword;
 keyword = c_lookup(str, len);
 return (keyword && ((keyword->token) >= 4001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 6
14 6
15 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b7 <oldgnu_fixup_header+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0xc,%esi
lea    0x1e3(%rax),%rdi
callq  cc <oldgnu_fixup_header+0x1c>
mov    0x18(%rbx),%rdx
mov    0x88(%rdx),%rcx
mov    %rcx,0x118(%rdx)
xor    %ecx,%ecx
test   %rax,%rax
cmovns %rax,%rcx
not    %rax
mov    %rcx,0x88(%rdx)
shr    $0x3f,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
oldgnu_fixup_header (struct tar_sparse_file *file)
{
  off_t realsize = off_from_header (current_header->oldgnu_header.realsize, sizeof (current_header->oldgnu_header.realsize));
  file->stat_info->archive_file_size = file->stat_info->stat.st_size;
  file->stat_info->stat.st_size = ((0) < (realsize) ? (realsize) : (0));
  return 0 <= realsize;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 5
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
xor    %esi,%esi
jmpq   30 <__gmpz_legendre>
<<<sep_in_sample>>>
__gmpn_divmod_1 (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)
{
  return __gmpn_divrem_1 (dst, ((mp_size_t) (0)), src, size, divisor);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <printer_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <printer_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
printer_hash_1 (struct printer *printer)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((printer->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     16b0 <gsl_vector_ulong_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  16cf <gsl_vector_ulong_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_ulong_const_view_array (const unsigned long * base, size_t n)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = (unsigned long *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  15be <font_info_table_free+0xe>
mov    %rbx,%rdi
pop    %rbx
jmpq   15c7 <font_info_table_free+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
font_info_table_free (struct hash_table_s * table)
{
  hash_free (table, (hash_map_func_t) hash_free_font_info);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  735 <afm_init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%r12
mov    (%rax),%r13d
callq  743 <afm_init_buffer+0x23>
mov    0x0(%rip),%rax        # 74a <afm_init_buffer+0x2a>
mov    %rbp,(%rbx)
movl   $0x1,0x34(%rbx)
test   %rax,%rax
je     766 <afm_init_buffer+0x46>
mov    0x0(%rip),%rdx        # 760 <afm_init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     774 <afm_init_buffer+0x54>
movl   $0x1,0x2c(%rbx)
movl   $0x0,0x30(%rbx)
xor    %eax,%eax
test   %rbp,%rbp
je     792 <afm_init_buffer+0x72>
mov    %rbp,%rdi
callq  783 <afm_init_buffer+0x63>
mov    %eax,%edi
callq  78a <afm_init_buffer+0x6a>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x24(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afm_init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 afm_flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # aa <swssh_reset_module+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swssh_reset_module(void)
{
 g_did_get_command = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  cec <clone_quoting_options+0xc>
mov    (%rax),%r12d
test   %rbp,%rbp
mov    $0x0,%edi
mov    %rax,%rbx
cmovne %rbp,%rdi
mov    $0x28,%esi
callq  d08 <clone_quoting_options+0x28>
mov    %r12d,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
clone_quoting_options (struct quoting_options *o)
{
  int e = (*__errno_location ());
  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,
           sizeof *o);
  (*__errno_location ()) = e;
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 3
10 4
11 4
12 4
13 6
14 8
15 8
16 8
17 8