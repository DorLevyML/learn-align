push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%eax
cmp    %edx,(%rsi)
jge    497 <resize_buffer+0x98>
mov    %rdi,%rbp
mov    $0x200,%r12d
cmp    $0x1ff,%edx
jle    43a <resize_buffer+0x3b>
lea    0x1ff(%rdx),%r12d
test   %edx,%edx
cmovs  %r12d,%edx
sar    $0x9,%edx
shl    $0xa,%edx
mov    %edx,%r12d
callq  43f <resize_buffer+0x40>
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     452 <resize_buffer+0x53>
movslq %r12d,%rsi
callq  450 <resize_buffer+0x51>
jmp    45a <resize_buffer+0x5b>
movslq %r12d,%rdi
callq  45a <resize_buffer+0x5b>
test   %rax,%rax
jne    486 <resize_buffer+0x87>
callq  464 <resize_buffer+0x65>
mov    (%rax),%esi
mov    $0x0,%edi
callq  470 <resize_buffer+0x71>
mov    $0x0,%edi
callq  47a <resize_buffer+0x7b>
callq  47f <resize_buffer+0x80>
mov    $0x0,%eax
jmp    497 <resize_buffer+0x98>
mov    %r12d,(%rbx)
mov    %rax,0x0(%rbp)
callq  492 <resize_buffer+0x93>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
resize_buffer( char ** const buf, int * const size, const int min_size )
  {
  if( *size < min_size )
    {
    const int new_size = ( min_size < 512 ? 512 : ( min_size / 512 ) * 1024 );
    void * new_buf = 0;
    disable_interrupts();
    if( *buf ) new_buf = realloc( *buf, new_size );
    else new_buf = malloc( new_size );
    if( !new_buf )
      {
      show_strerror( 0, (*__errno_location ()) );
      set_error_msg( "Memory exhausted" );
      enable_interrupts();
      return false;
      }
    *size = new_size;
    *buf = (char *)new_buf;
    enable_interrupts();
    }
  return true;
  }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 21
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 9
27 10
28 10
29 12
30 12
31 12
32 12
33 13
34 13
35 14
36 15
37 15
38 17
39 18
40 19
41 21
42 22
43 22
44 22
45 22
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%rbp
mov    %edx,%r12d
cmpl   $0x0,(%rsi)
js     4c <matchmark+0x2b>
mov    $0x1,%eax
test   %edx,%edx
jle    103 <matchmark+0xe2>
jmp    60 <matchmark+0x3f>
mov    %edx,%esi
callq  53 <matchmark+0x32>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmpq   106 <matchmark+0xe5>
mov    0x0(%rip),%r14        # 67 <matchmark+0x46>
mov    $0x0,%ebx
mov    $0x1,%r15d
movslq %ebx,%rdx
movslq 0x0(%r13,%rdx,4),%rax
mov    (%r14,%rax,4),%ecx
test   %ecx,%ecx
jle    a4 <matchmark+0x83>
movslq 0x0(%rbp,%rdx,4),%rcx
mov    0x0(%rip),%rdx        # 8e <matchmark+0x6d>
mov    (%rdx,%rcx,8),%rsi
mov    0x0(%rip),%rdx        # 99 <matchmark+0x78>
mov    (%rdx,%rax,8),%rdi
callq  a2 <matchmark+0x81>
jmp    f0 <matchmark+0xcf>
test   %ecx,%ecx
jne    c9 <matchmark+0xa8>
movslq 0x0(%rbp,%rdx,4),%rcx
mov    0x0(%rip),%rdx        # b4 <matchmark+0x93>
mov    0x0(%rip),%rsi        # bb <matchmark+0x9a>
mov    (%rdx,%rcx,4),%edi
cmp    %edi,(%rsi,%rax,4)
setne  %al
movzbl %al,%eax
jmp    f0 <matchmark+0xcf>
movslq 0x0(%rbp,%rdx,4),%rcx
mov    0x0(%rip),%rdx        # d5 <matchmark+0xb4>
mov    0x0(%rip),%rsi        # dc <matchmark+0xbb>
movsd  (%rsi,%rax,8),%xmm0
ucomisd (%rdx,%rcx,8),%xmm0
setp   %al
movzbl %al,%eax
cmovne %r15d,%eax
add    $0x1,%ebx
test   %eax,%eax
sete   %al
jne    103 <matchmark+0xe2>
cmp    %ebx,%r12d
jg     72 <matchmark+0x51>
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
matchmark(int *markv, int *xmarkv, int nmark, double level)
{
  int i;
  int diff;
  if (xmarkv[0] < 0)
    return !dap_newpart(markv, nmark);
  for (diff = 0, i = 0; !diff && i < nmark; i++)
    {
      if (dap_obs[0].do_len[markv[i]] > 0)
 diff = strcmp(dap_obs[0].do_str[markv[i]], dap_obs[1].do_str[xmarkv[i]]);
      else if (dap_obs[0].do_len[markv[i]] == 0)
 diff = (dap_obs[0].do_int[markv[i]] != dap_obs[1].do_int[xmarkv[i]]);
      else
 diff = (dap_obs[0].do_dbl[markv[i]] != dap_obs[1].do_dbl[xmarkv[i]]);
    }
  return !diff;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 7
14 7
15 7
16 7
17 6
18 6
19 6
20 6
21 6
22 6
23 9
24 9
25 14
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 11
39 11
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 14
49 14
50 14
51 14
52 14
53 14
54 14
55 14
56 7
57 7
58 7
59 7
60 7
61 7
62 16
63 17
64 17
65 17
66 17
67 17
68 17
69 17
70 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x58(%rax),%rdi
callq  1cf <dict_entry_remove>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
delpagedevice (a2ps_job * job, const char * key)
{
  dict_entry_remove (job->status->pagedevice, key);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    (%rdi),%rax
mov    (%rax),%rdi
callq  241 <anubis_url_destroy+0x12>
mov    (%r12),%rax
mov    0x8(%rax),%rdi
callq  24e <anubis_url_destroy+0x1f>
mov    (%r12),%rax
mov    0x10(%rax),%rdi
callq  25b <anubis_url_destroy+0x2c>
mov    (%r12),%rax
mov    0x18(%rax),%rdi
callq  268 <anubis_url_destroy+0x39>
mov    (%r12),%rax
mov    0x20(%rax),%rdi
callq  275 <anubis_url_destroy+0x46>
mov    (%r12),%rax
cmpl   $0x0,0x28(%rax)
jle    2b6 <anubis_url_destroy+0x87>
mov    $0x0,%ebx
movslq %ebx,%rbp
shl    $0x4,%rbp
mov    0x30(%rax),%rax
mov    (%rax,%rbp,1),%rdi
callq  298 <anubis_url_destroy+0x69>
mov    (%r12),%rax
mov    0x30(%rax),%rax
mov    0x8(%rax,%rbp,1),%rdi
callq  2aa <anubis_url_destroy+0x7b>
add    $0x1,%ebx
mov    (%r12),%rax
cmp    %ebx,0x28(%rax)
jg     284 <anubis_url_destroy+0x55>
mov    0x30(%rax),%rdi
callq  2bf <anubis_url_destroy+0x90>
mov    (%r12),%rdi
callq  2c8 <anubis_url_destroy+0x99>
movq   $0x0,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
anubis_url_destroy (ANUBIS_URL ** url)
{
  int i;
  free ((*url)->method);
  free ((*url)->host);
  free ((*url)->path);
  free ((*url)->user);
  free ((*url)->passwd);
  for (i = 0; i < (*url)->argc; i++)
    {
      free ((*url)->argv[i].key);
      free ((*url)->argv[i].value);
    }
  free ((*url)->argv);
  free (*url);
  *url = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 12
32 12
33 9
34 9
35 9
36 9
37 14
38 14
39 15
40 15
41 16
42 17
43 17
44 17
45 17
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 169b <yyset_lineno+0x6>
retq   
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r9d
mov    $0x0,%r8d
callq  936 <gen_href_begin+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gen_href_begin(const char *dir, const char *file, const char *suffix, const char *key)
{
 return gen_href_begin_with_title_target(dir, file, suffix, key, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x50,%edi
callq  a6 <new_dict_entry_table+0xe>
mov    %rax,0x0(%rip)        # ad <new_dict_entry_table+0x15>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
mov    %rax,%rdi
callq  ca <new_dict_entry_table+0x32>
mov    0x0(%rip),%rax        # d1 <new_dict_entry_table+0x39>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
new_dict_entry_table (void)
{
  static struct hash_table_s * res;
  res = ((hash_table *) xmalloc (sizeof (hash_table) * (1)));
  hash_init (res, 8,
      key_hash_1, key_hash_2, key_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 8
13 8
<<<sep_out_sample>>>
sub    $0x10,%edi
cmp    $0x40,%edi
ja     b0 <is_scalar+0x17>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
is_scalar(int type)
{
 switch (type) {
 case Op_push_lhs:
 case Op_push_param:
 case Op_push_array:
 case Op_push:
 case Op_push_i:
 case Op_push_re:
 case Op_subscript:
 case Op_subscript_lhs:
 case Op_func_call:
 case Op_builtin:
 case Op_field_spec:
 case Op_field_spec_lhs:
 case Op_preincrement:
 case Op_predecrement:
 case Op_postincrement:
 case Op_postdecrement:
 case Op_unary_minus:
 case Op_not:
  return 1;
 default:
  return 0;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 22
7 22
8 24
9 26
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
rec_rset_comment_equal_fn (void *data1,
                           void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
test   %r8,%r8
je     3c0e <gsl_matrix_uchar_set_identity+0x43>
mov    $0x0,%edx
jmp    3c02 <gsl_matrix_uchar_set_identity+0x37>
cmp    %rax,%rdx
sete   (%rcx,%rax,1)
add    $0x1,%rax
cmp    %rsi,%rax
jne    3be6 <gsl_matrix_uchar_set_identity+0x1b>
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
je     3c0e <gsl_matrix_uchar_set_identity+0x43>
test   %rsi,%rsi
je     3bf6 <gsl_matrix_uchar_set_identity+0x2b>
mov    $0x0,%eax
jmp    3be6 <gsl_matrix_uchar_set_identity+0x1b>
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
gsl_matrix_uchar_set_identity (gsl_matrix_uchar * m)
{
  size_t i, j;
  unsigned char * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const unsigned char zero = 0U;
  const unsigned char one = 1U;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(unsigned char *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 10
6 10
7 10
8 10
9 14
10 14
11 12
12 12
13 12
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rdx,%rbp
test   %rdi,%rdi
jle    38 <LogTransformArray+0x38>
mov    %rsi,%r13
mov    $0x0,%ebx
movsd  0x0(%r13,%rbx,8),%xmm0
callq  29 <LogTransformArray+0x29>
movsd  %xmm0,0x0(%rbp,%rbx,8)
add    $0x1,%rbx
cmp    %r12,%rbx
jne    1d <LogTransformArray+0x1d>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
LogTransformArray (long nElems, double *rgdSrc, double *rgdDes)
{
  register long l;
  for (l = 0; l < nElems; l++)
    rgdDes[l] = log(rgdSrc[l]);
  return rgdDes;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 4
16 4
17 4
18 7
19 7
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rsi),%rax
test   %rax,%rax
je     ba2 <dap_putc+0x17>
mov    %rax,%rsi
callq  ba0 <dap_putc+0x15>
jmp    bf2 <dap_putc+0x67>
mov    0x10(%rsi),%rdx
mov    0x8(%rdx),%rax
movslq 0x0(%rip),%rcx        # bb1 <dap_putc+0x26>
add    (%rdx),%rcx
cmp    %rcx,%rax
jae    bcf <dap_putc+0x44>
lea    0x1(%rax),%rcx
mov    %rcx,0x8(%rdx)
mov    %dil,(%rax)
mov    0x10(%rsi),%rax
addq   $0x1,0x10(%rax)
jmp    bf2 <dap_putc+0x67>
mov    (%rsi),%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # bde <dap_putc+0x53>
mov    $0x0,%eax
callq  be8 <dap_putc+0x5d>
mov    $0x1,%edi
callq  bf2 <dap_putc+0x67>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dap_putc(int c, DFILE *fp)
{
  if (fp->dfile_disk)
    _IO_putc (c, fp->dfile_disk);
  else if (fp->dfile_ram->rfile_pos < fp->dfile_ram->rfile_str + dap_rfilesize)
    {
      *fp->dfile_ram->rfile_pos++ = c;
      fp->dfile_ram->rfile_end++;
    }
  else
    {
      fprintf(dap_err, "(dap_putc) too many characters: %s\n",
       fp->dfile_name);
      exit(1);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 7
17 8
18 8
19 8
20 12
21 12
22 12
23 12
24 12
25 14
26 14
27 16
28 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
callq  bb <read_2_bytes>
cmp    $0x1,%eax
ja     1a7 <process_COM+0x33>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 193 <process_COM+0x1f>
mov    $0x0,%eax
callq  19d <process_COM+0x29>
mov    $0x1,%edi
callq  1a7 <process_COM+0x33>
sub    $0x2,%eax
mov    %eax,%ebp
je     23d <process_COM+0xc9>
mov    $0x0,%r12d
callq  7c <read_1_byte>
mov    %eax,%ebx
cmp    $0xd,%eax
jne    1d0 <process_COM+0x5c>
mov    $0xa,%edi
callq  1ce <process_COM+0x5a>
jmp    230 <process_COM+0xbc>
cmp    $0xa,%eax
jne    1e7 <process_COM+0x73>
cmp    $0xd,%r12d
je     230 <process_COM+0xbc>
mov    $0xa,%edi
callq  1e5 <process_COM+0x71>
jmp    230 <process_COM+0xbc>
cmp    $0x5c,%eax
jne    1fd <process_COM+0x89>
mov    $0x0,%edi
mov    $0x0,%eax
callq  1fb <process_COM+0x87>
jmp    230 <process_COM+0xbc>
callq  202 <process_COM+0x8e>
movslq %ebx,%rdx
mov    (%rax),%rax
testb  $0x40,0x1(%rax,%rdx,2)
je     21f <process_COM+0xab>
mov    0x0(%rip),%rsi        # 216 <process_COM+0xa2>
mov    %ebx,%edi
callq  21d <process_COM+0xa9>
jmp    230 <process_COM+0xbc>
mov    %ebx,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  230 <process_COM+0xbc>
sub    $0x1,%ebp
je     23d <process_COM+0xc9>
mov    %ebx,%r12d
jmpq   1b8 <process_COM+0x44>
mov    $0xa,%edi
callq  247 <process_COM+0xd3>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
process_COM (void)
{
  unsigned int length;
  int ch;
  int lastch = 0;
  length = read_2_bytes();
  if (length < 2)
    (fprintf(stderr, "%s\n", "Erroneous JPEG marker length"), exit(1));
  length -= 2;
  while (length > 0) {
    ch = read_1_byte();
    if (ch == '\r') {
      printf("\n");
    } else if (ch == '\n') {
      if (lastch != '\r')
 printf("\n");
    } else if (ch == '\\') {
      printf("\\\\");
    } else if (((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISprint)) {
      _IO_putc (ch, stdout);
    } else {
      printf("\\%03o", ch);
    }
    lastch = ch;
    length--;
  }
  printf("\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 7
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 10
15 10
16 10
17 5
18 11
19 11
20 12
21 12
22 13
23 13
24 13
25 14
26 14
27 15
28 15
29 16
30 16
31 16
32 17
33 17
34 18
35 18
36 18
37 18
38 19
39 19
40 19
41 19
42 19
43 20
44 20
45 20
46 20
47 22
48 22
49 22
50 22
51 10
52 10
53 24
54 24
55 27
56 27
57 28
58 28
59 28
60 28
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lstatat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lstatat (int fd, char const *name, struct stat *st)
{
  return fstatat (fd, name, st, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     76f <mu_message_set_header+0x40>
mov    %rsi,%rbp
mov    $0xd,%al
cmp    %rdx,(%rdi)
jne    76f <mu_message_set_header+0x40>
cmpq   $0x0,0x10(%rdi)
je     75f <mu_message_set_header+0x30>
lea    0x10(%rdi),%rdi
mov    %rbx,%rsi
callq  75f <mu_message_set_header+0x30>
mov    %rbp,0x10(%rbx)
orl    $0x10000,0x20(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_message_set_header (mu_message_t msg, mu_header_t hdr, void *owner)
{
  if (msg == ((void *)0) )
    return 22;
  if (msg->owner != owner)
     return 13;
  if (msg->header)
    mu_header_destroy (&(msg->header), msg);
  msg->header = hdr;
  msg->flags |= 0x10000;;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 6
10 5
11 5
12 7
13 7
14 8
15 8
16 8
17 9
18 10
19 11
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     51d <gsasl_server_callback_cipher_get+0xd>
mov    0xd0(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_cipher_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cipher : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
test   %rdx,%rdx
je     98 <gsl_stats_median_from_sorted_data+0x44>
lea    -0x1(%rdx),%rax
shr    %rax
shr    %rdx
cmp    %rdx,%rax
jne    7a <gsl_stats_median_from_sorted_data+0x26>
shl    $0x3,%rsi
imul   %rsi,%rax
movsd  (%rdi,%rax,1),%xmm0
retq   
shl    $0x3,%rsi
imul   %rsi,%rax
imul   %rsi,%rdx
movsd  (%rdi,%rax,1),%xmm0
addsd  (%rdi,%rdx,1),%xmm0
mulsd  0x0(%rip),%xmm0        # 98 <gsl_stats_median_from_sorted_data+0x44>
repz retq 
<<<sep_in_sample>>>
gsl_stats_median_from_sorted_data (const double sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 9
2 8
3 8
4 6
5 6
6 7
7 10
8 10
9 12
10 12
11 12
12 12
13 16
14 16
15 16
16 16
17 16
18 16
19 19
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r12
test   %r12,%r12
je     2f8 <argmatch_to_argument+0x3f>
mov    %rdi,%r14
mov    %rcx,%r13
mov    %rdx,%rbx
lea    0x8(%rsi),%rbp
mov    %r13,%rdx
mov    %rbx,%rsi
mov    %r14,%rdi
callq  2e4 <argmatch_to_argument+0x2b>
test   %eax,%eax
je     2f8 <argmatch_to_argument+0x3f>
mov    0x0(%rbp),%r12
add    %r13,%rbx
add    $0x8,%rbp
test   %r12,%r12
jne    2d6 <argmatch_to_argument+0x1d>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
argmatch_to_argument (const char *value,
                      const char *const *arglist,
                      const char *vallist, size_t valsize)
{
  size_t i;
  for (i = 0; arglist[i]; i++)
    if (!memcmp (value, vallist + valsize * i, valsize))
      return arglist[i];
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 6
20 6
21 6
22 6
23 6
24 10
25 10
26 10
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
cmp    $0x4,%edi
je     12cf <realDateFormat+0x5c>
mov    $0xf,%edi
callq  129c <realDateFormat+0x29>
mov    %rax,%rdi
test   %rax,%rax
jne    12ac <realDateFormat+0x39>
callq  12a9 <realDateFormat+0x36>
mov    %rax,%rdi
movabs $0x6e206120746f6e28,%rax
mov    %rax,(%rdi)
movl   $0x65626d75,0x8(%rdi)
movw   $0x2972,0xc(%rdi)
movb   $0x0,0xe(%rdi)
mov    %rdi,%rbx
jmp    134b <realDateFormat+0xd8>
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %r9,%r12
add    $0x32,%ecx
movslq %ecx,%rdi
callq  12e3 <realDateFormat+0x70>
mov    %rax,%rbx
test   %rax,%rax
jne    12f3 <realDateFormat+0x80>
callq  12f0 <realDateFormat+0x7d>
mov    %rax,%rbx
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x73,-0x1(%rbp,%rcx,1)
movslq 0x0(%r13),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rsp),%rdi
callq  1321 <realDateFormat+0xae>
mov    %rax,%rcx
mov    %r12,%rdx
mov    $0x31,%esi
lea    0x10(%rsp),%rdi
callq  1336 <realDateFormat+0xc3>
lea    0x10(%rsp),%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  134b <realDateFormat+0xd8>
mov    %rbx,%rax
mov    0x48(%rsp),%rdx
xor    %fs:0x28,%rdx
je     1363 <realDateFormat+0xf0>
callq  1363 <realDateFormat+0xf0>
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
realDateFormat(int_32 type, const void * data,
  char * formatPrefix, int padding, int element,
  char * strftimeFormat)
{
    char * val;
    struct tm * tstruct;
    char buf[50];
    if (type != 4) {
 val = (strcpy((malloc(strlen("(not a number)")+1) ? : vmefail()), ("(not a number)")));
    } else {
 val = (malloc(50 + padding) ? : vmefail());
 strcat(formatPrefix, "s");
 { time_t dateint = *((int_32 *) data);
     tstruct = localtime(&dateint);
 }
 (void)strftime(buf, sizeof(buf) - 1, strftimeFormat, tstruct);
 sprintf(val, formatPrefix, buf);
    }
    return val;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 8
10 8
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 12
37 12
38 12
39 12
40 12
41 12
42 13
43 13
44 14
45 14
46 16
47 16
48 16
49 16
50 16
51 17
52 17
53 17
54 17
55 17
56 20
57 20
58 20
59 20
60 20
61 20
62 20
63 20
64 20
65 20
66 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x60(%rax),%rdi
callq  f5 <dict_entry_table_dump>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
list_statusdict (a2ps_job * job, FILE * stream)
{
  dict_entry_table_dump (job->status->statusdict, stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1e9d <asm_get_out+0x7>
retq   
<<<sep_in_sample>>>
asm_get_out (void)
{
        return asm_out;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,%rax
mov    %edi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  55f <smtp_reply_get+0x1f>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
smtp_reply_get (int method, NET_STREAM sd, ANUBIS_SMTP_REPLY reply)
{
  struct net_reader_closure clos;
  clos.method = method;
  clos.stream = sd;
  smtp_reply_read (reply, _net_reader, &clos);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 6
6 6
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
movzbl (%rsi),%eax
cmp    %al,(%rdi)
jne    1f2 <mc_mac_equal+0x23>
mov    $0x0,%eax
movzbl 0x1(%rsi,%rax,1),%edx
cmp    %dl,0x1(%rdi,%rax,1)
jne    1f8 <mc_mac_equal+0x29>
add    $0x1,%rax
cmp    $0x5,%rax
jne    1db <mc_mac_equal+0xc>
jmp    1fe <mc_mac_equal+0x2f>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
mc_mac_equal (const mac_t *mac1, const mac_t *mac2)
{
 int i;
 for (i=0; i<6; i++) {
  if (mac1->byte[i] != mac2->byte[i]) {
   return 0;
  }
 }
 return 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 9
17 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rsi),%rax
cmp    %rdx,%rax
ja     2e48 <gsl_matrix_ushort_superdiagonal+0x4e>
mov    $0x4,%ecx
mov    $0x76,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2e20 <gsl_matrix_ushort_superdiagonal+0x26>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    2e7f <gsl_matrix_ushort_superdiagonal+0x85>
mov    0x18(%rsi),%rcx
lea    (%rcx,%rdx,2),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
sub    %rdx,%rax
mov    (%rsi),%rdx
cmp    %rdx,%rax
cmova  %rdx,%rax
mov    %rax,(%rbx)
mov    %r8,0x8(%rbx)
mov    %rdi,0x10(%rbx)
mov    %rcx,0x18(%rbx)
movl   $0x0,0x20(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_superdiagonal (gsl_matrix_ushort * m,
                                      const size_t k)
{
  _gsl_vector_ushort_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ushort v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 13
20 13
21 14
22 12
23 12
24 12
25 12
26 17
27 17
28 17
29 17
30 17
31 19
32 19
33 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x5f8(%rdi),%rax
mov    0x58(%rax),%rdi
mov    $0x0,%ecx
callq  17f <dict_entry_add>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
setpagedevice (a2ps_job * job, const char * key, const char * value)
{
  dict_entry_add (job->status->pagedevice, key, value, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 431 <mc_maclist_free+0xb>
callq  29b <free_list>
mov    0x0(%rip),%rdi        # 43d <mc_maclist_free+0x17>
callq  29b <free_list>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mc_maclist_free (void)
{
 free_list (list_others);
 free_list (list_wireless);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
movzbl (%rsi),%eax
cmp    $0x6c,%al
jne    19cc <swvarfs_set_stat_syscall+0x13>
movq   $0x0,0x138(%rdi)
retq   
cmp    $0x73,%al
jne    19db <swvarfs_set_stat_syscall+0x22>
movq   $0x0,0x138(%rdi)
repz retq 
<<<sep_in_sample>>>
swvarfs_set_stat_syscall(SWVARFS * swvarfs, char * s)
{
 if (*s == 'l') {
  swvarfs->f_statM = (int (*)(char *, struct stat *))lstat;
 } else if (*s == 's') {
  swvarfs->f_statM = (int (*)(char *, struct stat *))stat;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d0 <sdp_message_s_name_get+0xa>
mov    0x38(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
sdp_message_s_name_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->s_name;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lstatat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lstatat (int fd, char const *name, struct stat *st)
{
  return fstatat (fd, name, st, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
mov    $0x0,%r9d
movabs $0x7fffffffffffffff,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
callq  b4 <from_header>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
off_from_header (const char *p, size_t s)
{
  return from_header (p, s, "off_t",
        0, ((off_t) (! (! ((off_t) 0 < (off_t) -1)) ? (off_t) -1 : ((((off_t) 1 << (sizeof (off_t) * 8 - 2)) - 1) * 2 + 1))),
        0, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 6
9 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     125 <QueueListItem+0x60>
mov    %rsi,%r12
mov    $0x10,%edi
callq  de <QueueListItem+0x19>
mov    %rax,%rbp
test   %rax,%rax
jne    ff <QueueListItem+0x3a>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8004,%esi
mov    $0x0,%edi
callq  ff <QueueListItem+0x3a>
mov    %r12,0x0(%rbp)
movq   $0x0,0x8(%rbp)
mov    0x8(%rbx),%rax
test   %rax,%rax
je     11a <QueueListItem+0x55>
mov    %rbp,0x8(%rax)
jmp    11d <QueueListItem+0x58>
mov    %rbp,(%rbx)
mov    %rbp,0x8(%rbx)
addl   $0x1,0x10(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
QueueListItem (PLIST plist, PVOID pData)
{
  PLISTELEM pNewElem;
  if (!plist)
    return;
  if (!(pNewElem = (PLISTELEM) malloc (sizeof(LISTELEM))))
    ReportError (((void *)0), 0x0004 | 0x8000, "QueueListItem", ((void *)0));
  pNewElem->pData = pData;
  pNewElem->pleNext = ((void *)0);
  if (plist->pleTail)
    plist->pleTail->pleNext = pNewElem;
  else
    plist->pleHead = pNewElem;
  plist->pleTail = pNewElem;
  plist->iSize++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 8
19 9
20 10
21 10
22 10
23 11
24 11
25 13
26 14
27 15
28 16
29 16
30 16
31 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
callq  3b9 <_rl_arg_callback+0xd>
mov    %eax,%ebx
test   %eax,%eax
js     40e <_rl_arg_callback+0x62>
mov    0x0(%rip),%eax        # 3c5 <_rl_arg_callback+0x19>
test   $0x4,%al
je     3f5 <_rl_arg_callback+0x49>
and    $0xfffffffb,%eax
mov    %eax,0x0(%rip)        # 3d2 <_rl_arg_callback+0x26>
callq  3d7 <_rl_arg_callback+0x2b>
callq  3dc <_rl_arg_callback+0x30>
andq   $0xfffffffffffffbff,0x0(%rip)        # 3e7 <_rl_arg_callback+0x3b>
mov    %ebx,%edi
callq  3ee <_rl_arg_callback+0x42>
mov    $0x0,%eax
jmp    413 <_rl_arg_callback+0x67>
mov    %ebx,%esi
mov    %ebp,%edi
mov    $0x0,%eax
callq  403 <_rl_arg_callback+0x57>
cmp    $0x1,%eax
setne  %al
movzbl %al,%eax
jmp    413 <_rl_arg_callback+0x67>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_arg_callback (cxt)
     _rl_arg_cxt cxt;
{
  int c, r;
  c = _rl_arg_getchar ();
  if (c < 0)
    return (1);
  if (_rl_argcxt & 0x04)
    {
      _rl_argcxt &= ~0x04;
      rl_restore_prompt ();
      rl_clear_message ();
      (rl_readline_state &= ~(0x0000400));
      rl_execute_next (c);
      return 0;
    }
  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 6
8 6
9 8
10 8
11 8
12 10
13 10
14 11
15 12
16 13
17 14
18 14
19 15
20 15
21 17
22 17
23 17
24 17
25 18
26 18
27 18
28 18
29 7
30 19
31 19
32 19
33 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fd_ostream_free (fd_ostream_t first_arg)
{
  const struct fd_ostream_implementation *vtable =
    ((struct fd_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->free (first_arg);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x38(%rdi),%rdi
callq  31a <gsl_rstat_median+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_rstat_median(gsl_rstat_workspace *w)
{
  return gsl_rstat_quantile_get(w->median_workspace_p);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %edx,%r12d
mov    %r8d,%r13d
lea    0x8(%rsp),%rsi
mov    %rcx,%rdi
callq  1ce <resolve_hostname>
test   %eax,%eax
jne    5e8 <mu_tcp_stream_create_with_source_host+0x3d>
mov    %r13d,%r8d
mov    0x8(%rsp),%rcx
mov    %r12d,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  5e8 <mu_tcp_stream_create_with_source_host+0x3d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_tcp_stream_create_with_source_host (mu_stream_t *stream,
           const char *host, int port,
           const char *source_host,
           int flags)
{
  unsigned long source_addr;
  int ret = resolve_hostname (source_host, &source_addr);
  if (ret == 0)
    ret = mu_tcp_stream_create_with_source_ip (stream, host, port,
            source_addr, flags);
  return ret;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 9
21 12
22 12
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # 6ec1 <us_oh_hdy+0xf>
movl   $0x3,0x0(%rip)        # 6ecb <us_oh_hdy+0x19>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  6ed7 <us_oh_hdy+0x25>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
us_oh_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_OH";
  observe_us_hdy = 3;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 10
3 11
4 12
5 12
6 12
7 13
8 13
<<<sep_out_sample>>>
cmp    $0x19,%edi
ja     de2 <gsl_sf_doublefact_e+0x26>
mov    %edi,%edi
lea    (%rdi,%rdi,2),%rax
movsd  0x0(,%rax,8),%xmm0
movsd  %xmm0,(%rsi)
movq   $0x0,0x8(%rsi)
mov    $0x0,%eax
retq   
cmp    $0x129,%edi
ja     e1c <gsl_sf_doublefact_e+0x60>
mov    %edi,%edi
lea    (%rdi,%rdi,2),%rax
movsd  0x0(,%rax,8),%xmm0
movsd  %xmm0,(%rsi)
movsd  0x0(%rip),%xmm1        # e05 <gsl_sf_doublefact_e+0x49>
andpd  %xmm1,%xmm0
mulsd  0x0(%rip),%xmm0        # e11 <gsl_sf_doublefact_e+0x55>
movsd  %xmm0,0x8(%rsi)
mov    $0x0,%eax
retq   
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm0        # e28 <gsl_sf_doublefact_e+0x6c>
movsd  %xmm0,(%rsi)
movsd  %xmm0,0x8(%rsi)
mov    $0x10,%ecx
mov    $0x5e5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e4a <gsl_sf_doublefact_e+0x8e>
mov    $0x10,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_doublefact_e(const unsigned int n, gsl_sf_result * result)
{
  if(n < 26) {
    result->val = doub_fact_table[n].f;
    result->err = 0.0;
    return GSL_SUCCESS;
  }
  else if(n <= 297){
    result->val = doub_fact_table[n].f;
    result->err = 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
  else {
    do { (result)->val = (__builtin_inff()); (result)->err = (__builtin_inff()); do { gsl_error ("overflow", "gamma.c", 1509, GSL_EOVRFLW) ; return GSL_EOVRFLW ; } while (0); } while(0);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 6
9 16
10 8
11 8
12 9
13 9
14 9
15 9
16 10
17 10
18 10
19 10
20 11
21 11
22 2
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 16
33 16
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rsi        # ed <cut_to_eol+0x8>
mov    0x20(%rsi),%rdx
mov    (%rdx),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r9
mov    0x30(%rsi),%rcx
cmp    %rcx,%r9
jbe    126 <cut_to_eol+0x41>
mov    %rdx,%r8
mov    $0x0,%esi
mov    $0x0,%edi
callq  124 <cut_to_eol+0x3f>
jmp    155 <cut_to_eol+0x70>
cmp    0x10(%rsi),%rdx
je     155 <cut_to_eol+0x70>
mov    $0x0,%r9d
mov    0x10(%rdx),%r8
mov    $0x0,%esi
mov    $0x0,%edi
callq  145 <cut_to_eol+0x60>
mov    0x0(%rip),%rbx        # 14c <cut_to_eol+0x67>
callq  151 <cut_to_eol+0x6c>
mov    %rax,0x38(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
cut_to_eol(void)
{
    size_t data_len = strlen(openfile->current->data);
    ((void) (0));
    if (openfile->current_x < data_len)
 move_to_filestruct(&cutbuffer, &cutbottom, openfile->current,
  openfile->current_x, openfile->current, data_len);
    else if (openfile->current != openfile->filebot) {
 move_to_filestruct(&cutbuffer, &cutbottom, openfile->current,
  openfile->current_x, openfile->current->next, 0);
 openfile->placewewant = xplustabs();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 13
29 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  4d <nettle_gcm_camellia256_set_iv+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_camellia256_set_iv (struct gcm_camellia256_ctx *ctx,
   size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 2130 <terminate_stopped_jobs+0x7>
jle    218c <terminate_stopped_jobs+0x63>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x0,%ebx
movslq %ebx,%rbp
mov    0x0(%rip),%rax        # 2147 <terminate_stopped_jobs+0x1e>
mov    (%rax,%rbp,8),%rax
test   %rax,%rax
je     217b <terminate_stopped_jobs+0x52>
cmpl   $0x2,0x14(%rax)
jne    217b <terminate_stopped_jobs+0x52>
mov    0x10(%rax),%edi
mov    $0xf,%esi
callq  2163 <terminate_stopped_jobs+0x3a>
mov    0x0(%rip),%rax        # 216a <terminate_stopped_jobs+0x41>
mov    (%rax,%rbp,8),%rax
mov    0x10(%rax),%edi
mov    $0x12,%esi
callq  217b <terminate_stopped_jobs+0x52>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # 2184 <terminate_stopped_jobs+0x5b>
jg     213d <terminate_stopped_jobs+0x14>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
terminate_stopped_jobs ()
{
  register int i;
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i] && (jobs[(i)]->state == JSTOPPED))
 {
   killpg (jobs[i]->pgrp, 15);
   killpg (jobs[i]->pgrp, 18);
 }
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 4
23 4
24 4
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
push   %rbx
sub    $0x50,%rsp
mov    %rsi,%rbx
lea    0x10(%rsi),%rcx
lea    0x20(%rsi),%rdx
lea    0xa8(%rsi),%rax
mov    %rax,0x40(%rsp)
lea    0x68(%rsi),%rax
mov    %rax,0x38(%rsp)
lea    0xb0(%rsi),%rax
mov    %rax,0x30(%rsp)
lea    0x48(%rsi),%rax
mov    %rax,0x28(%rsp)
lea    0x38(%rsi),%rax
mov    %rax,0x20(%rsp)
lea    0x18(%rsi),%rax
mov    %rax,0x18(%rsp)
lea    0x28(%rsi),%rax
mov    %rax,0x10(%rsp)
lea    0x88(%rsi),%rax
mov    %rax,0x8(%rsp)
lea    0x90(%rsi),%rax
mov    %rax,(%rsp)
lea    0x40(%rsi),%r9
lea    0x30(%rsi),%r8
mov    $0x0,%esi
mov    $0x0,%eax
callq  2fa <procnet_parse_fields_v2+0x83>
movq   $0x0,0x50(%rbx)
cmp    $0xd,%eax
sete   %al
movzbl %al,%eax
add    $0x50,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
procnet_parse_fields_v2 (char *buf, struct pnd_stats *stats)
{
  int n = sscanf (buf,
    "%llu %llu %lu %lu %lu %lu %llu %llu %lu %lu %lu %lu %lu",
    &stats->rx_bytes,
    &stats->rx_packets,
    &stats->rx_errors,
    &stats->rx_dropped,
    &stats->rx_fifo_errors,
    &stats->rx_frame_errors,
    &stats->tx_bytes,
    &stats->tx_packets,
    &stats->tx_errors,
    &stats->tx_dropped,
    &stats->tx_fifo_errors,
    &stats->collisions,
    &stats->tx_carrier_errors);
  stats->rx_multicast = 0;
  return n == 13;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 18
30 19
31 19
32 19
33 20
34 20
35 20
<<<sep_out_sample>>>
mov    $0x1,%eax
cmp    $0x2,%edx
je     129a <rec_rset_record_compare_fn+0x3d>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  1278 <rec_rset_record_compare_fn+0x1b>
mov    0x20(%rax),%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1172 <rec_rset_compare_typed_records>
test   %eax,%eax
mov    $0xffffffff,%edx
cmove  %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
rec_rset_record_compare_fn (void *data1,
                            void *data2,
                            int type2)
{
  rec_rset_t rset = ((void *)0);
  rec_record_t record1 = ((void *)0);
  rec_record_t record2 = ((void *)0);
  int type_comparison = 0;
  if (type2 == 2)
    {
      return 1;
    }
  record1 = (rec_record_t) data1;
  record2 = (rec_record_t) data2;
  rset = (rec_rset_t) rec_record_container (record1);
  type_comparison = rec_rset_compare_typed_records (rset,
                                                    record1,
                                                    record2,
                                                    rset->order_by_fields);
  if (type_comparison == 0)
    {
      type_comparison = -1;
    }
  return type_comparison;
}
<<<sep_in_sample>>>
1 11
2 9
3 9
4 4
5 4
6 4
7 4
8 4
9 15
10 16
11 16
12 16
13 16
14 16
15 20
16 16
17 16
18 25
19 25
20 25
21 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    $0x1,%eax
cmp    $0x74,%edi
je     2221 <swlib_is_ansi_escape+0x58>
mov    %edi,%eax
and    $0xfffffffb,%eax
cmp    $0x72,%eax
je     2210 <swlib_is_ansi_escape+0x47>
mov    %edi,%eax
and    $0xfffffff7,%eax
cmp    $0x66,%eax
je     2210 <swlib_is_ansi_escape+0x47>
cmp    $0x78,%edi
je     2216 <swlib_is_ansi_escape+0x4d>
lea    -0x61(%rdi),%eax
cmp    $0x1,%eax
jbe    2216 <swlib_is_ansi_escape+0x4d>
cmp    $0x5c,%edi
je     221c <swlib_is_ansi_escape+0x53>
cmp    $0x3f,%edi
je     221c <swlib_is_ansi_escape+0x53>
cmp    $0x27,%edi
sete   %dl
cmp    $0x22,%edi
sete   %al
or     %edx,%eax
movzbl %al,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
repz retq 
<<<sep_in_sample>>>
swlib_is_ansi_escape(int c) {
     if ( (c == 'n') ||
          (c == 't') ||
          (c == 'v') ||
          (c == 'b') ||
          (c == 'r') ||
          (c == 'f') ||
          (c == 'x') ||
          (c == 'a') ||
          (c == '\\') ||
          (c == '?') ||
          (c == '\'') ||
          (c == '\"')
        ) return 1;
     else
          return 0;
}
<<<sep_in_sample>>>
1 14
2 2
3 2
4 6
5 6
6 6
7 6
8 7
9 7
10 6
11 6
12 8
13 8
14 9
15 8
16 8
17 10
18 10
19 10
20 10
21 12
22 12
23 13
24 13
25 12
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1278 <quotearg_custom_mem+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     66 <osip_mutex_destroy+0x29>
callq  4b <osip_mutex_destroy+0xe>
mov    0x0(%rip),%rax        # 52 <osip_mutex_destroy+0x15>
test   %rax,%rax
je     5e <osip_mutex_destroy+0x21>
mov    %rbx,%rdi
callq  *%rax
jmp    66 <osip_mutex_destroy+0x29>
mov    %rbx,%rdi
callq  66 <osip_mutex_destroy+0x29>
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_mutex_destroy (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return;
  pthread_mutex_destroy (mut);
  { if (mut!=((void *)0)) { if (osip_free_func) osip_free_func(mut); else free(mut);} };
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 8
15 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  e47c <gsl_fft_halfcomplex_float_backward+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_halfcomplex_float_backward (float data[], const size_t stride,
                                        const size_t n,
                                        const gsl_fft_halfcomplex_wavetable_float * wavetable,
                                        gsl_fft_real_workspace_float * work)
{
  int status = gsl_fft_halfcomplex_float_transform (data, stride, n, wavetable, work) ;
  return status ;
}
<<<sep_in_sample>>>
1 5
2 6
3 8
4 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x22,%edi
callq  14 <xgetdomainname+0x14>
mov    %rax,%rbp
callq  1c <xgetdomainname+0x1c>
mov    %rax,%r13
mov    $0x22,%ebx
movl   $0x0,0x0(%r13)
lea    -0x1(%rbx),%r12d
movslq %r12d,%r12
add    %rbp,%r12
movb   $0x0,(%r12)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  46 <xgetdomainname+0x46>
test   %eax,%eax
js     53 <xgetdomainname+0x53>
cmpb   $0x0,(%r12)
jne    70 <xgetdomainname+0x70>
jmp    83 <xgetdomainname+0x83>
mov    0x0(%r13),%r12d
cmp    $0x16,%r12d
je     70 <xgetdomainname+0x70>
mov    %rbp,%rdi
callq  65 <xgetdomainname+0x65>
mov    %r12d,0x0(%r13)
mov    $0x0,%eax
jmp    86 <xgetdomainname+0x86>
add    %rbx,%rbx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  7e <xgetdomainname+0x7e>
mov    %rax,%rbp
jmp    24 <xgetdomainname+0x24>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xgetdomainname (void)
{
  char *domainname;
  size_t size;
  size = 34;
  domainname = xmalloc (size);
  while (1)
    {
      int k = size - 1;
      int err;
      (*__errno_location ()) = 0;
      domainname[k] = '\0';
      err = getdomainname (domainname, size);
      if (err >= 0 && domainname[k] == '\0')
        break;
      else if (err < 0 && (*__errno_location ()) != 22)
        {
          int saved_errno = (*__errno_location ());
          free (domainname);
          (*__errno_location ()) = saved_errno;
          return ((void *)0);
        }
      size *= 2;
      domainname = xrealloc (domainname, size);
    }
  return domainname;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 11
10 11
11 5
12 11
13 9
14 12
15 12
16 12
17 13
18 13
19 13
20 14
21 14
22 14
23 14
24 14
25 16
26 16
27 16
28 19
29 19
30 20
31 21
32 21
33 23
34 24
35 24
36 24
37 24
38 25
39 25
40 27
41 27
42 27
43 27
44 27
45 27
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x98,%rsp
mov    %rsi,%rbp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
callq  710 <rec_record_get_field_index_by_name+0x18>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
mov    $0x0,%ebx
jmp    784 <rec_record_get_field_index_by_name+0x8c>
mov    0x48(%rsp),%rsi
cmp    %rsi,%rbp
je     7a1 <rec_record_get_field_index_by_name+0xa9>
mov    %rbp,%rdi
callq  77e <rec_record_get_field_index_by_name+0x86>
cmp    $0x1,%al
sbb    $0xffffffffffffffff,%rbx
mov    $0x0,%ecx
lea    0x48(%rsp),%rdx
mov    $0x1,%esi
lea    0x50(%rsp),%rdi
callq  79d <rec_record_get_field_index_by_name+0xa5>
test   %al,%al
jne    76c <rec_record_get_field_index_by_name+0x74>
lea    0x50(%rsp),%rdi
callq  7ab <rec_record_get_field_index_by_name+0xb3>
mov    %rbx,%rax
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_record_get_field_index_by_name (rec_record_t record,
                                    rec_field_t field)
{
  size_t res = 0;
  rec_mset_iterator_t iter;
  rec_field_t list_field;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &list_field, ((void *)0)))
    {
      if (field == list_field)
        {
          break;
        }
      if (rec_field_equal_p (field, list_field))
        {
          res++;
        }
    }
  rec_mset_iterator_free (&iter);
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 4
25 8
26 10
27 10
28 10
29 14
30 14
31 16
32 16
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 19
41 19
42 21
43 21
44 21
45 21
46 21
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r13d
test   %edi,%edi
js     63b <replace_history_entry+0xb8>
mov    %rsi,%rbp
mov    %rdx,%r15
mov    $0x0,%eax
cmp    0x0(%rip),%edi        # 5ad <replace_history_entry+0x2a>
jge    640 <replace_history_entry+0xbd>
mov    $0x18,%edi
callq  5bd <replace_history_entry+0x3a>
mov    %rax,%rbx
movslq %r13d,%r13
mov    0x0(%rip),%rax        # 5ca <replace_history_entry+0x47>
mov    (%rax,%r13,8),%r12
mov    $0xffffffffffffffff,%r14
mov    %rbp,%rdi
mov    %r14,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  5ed <replace_history_entry+0x6a>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  5f8 <replace_history_entry+0x75>
mov    %rax,(%rbx)
mov    %r15,0x10(%rbx)
mov    0x8(%r12),%rbp
mov    %rbp,%rdi
mov    %r14,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  61c <replace_history_entry+0x99>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  627 <replace_history_entry+0xa4>
mov    %rax,0x8(%rbx)
mov    0x0(%rip),%rax        # 632 <replace_history_entry+0xaf>
mov    %rbx,(%rax,%r13,8)
mov    %r12,%rax
jmp    640 <replace_history_entry+0xbd>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
replace_history_entry (which, line, data)
     int which;
     const char *line;
     histdata_t data;
{
  HIST_ENTRY *temp, *old_value;
  if (which < 0 || which >= history_length)
    return ((HIST_ENTRY *)((void *)0));
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  old_value = the_history[which];
  temp->line = strcpy (xmalloc (1 + strlen (line)), (line));
  temp->data = data;
  temp->timestamp = strcpy (xmalloc (1 + strlen (old_value->timestamp)), (old_value->timestamp));
  the_history[which] = temp;
  return (old_value);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 7
15 7
16 9
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 14
48 14
49 15
50 15
51 8
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 13 <osip_call_id_init+0xb>
test   %rax,%rax
je     21 <osip_call_id_init+0x19>
mov    $0x10,%edi
callq  *%rax
jmp    2b <osip_call_id_init+0x23>
mov    $0x10,%edi
callq  2b <osip_call_id_init+0x23>
mov    %rax,(%rbx)
test   %rax,%rax
je     4c <osip_call_id_init+0x44>
movq   $0x0,(%rax)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    $0x0,%eax
jmp    51 <osip_call_id_init+0x49>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_call_id_init (osip_call_id_t ** callid)
{
  *callid = (osip_call_id_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_call_id_t)):malloc(sizeof (osip_call_id_t)));
  if (*callid == ((void *)0))
    return -4;
  (*callid)->number = ((void *)0);
  (*callid)->host = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 7
16 7
17 8
18 8
19 5
20 9
21 9
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    $0x26,%eax
test   %rdi,%rdi
je     4bc <mu_mailer_open+0x1d>
mov    0x48(%rdi),%rdx
test   %rdx,%rdx
je     4bc <mu_mailer_open+0x1d>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailer_open (mu_mailer_t mailer, int flag)
{
  if (mailer == ((void *)0) || mailer->_open == ((void *)0))
    return 38;
  return mailer->_open (mailer, flag);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 2
8 5
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  15b5 <quote+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote (char const *arg)
{
  return quote_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # fea <pch_first+0x7>
retq   
<<<sep_in_sample>>>
pch_first (void)
{
    return p_first;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     3b09 <sortunit+0x21>
mov    %rdi,%rax
mov    $0x0,%esi
add    $0x8,%rax
add    $0x1,%esi
cmpq   $0x0,(%rax)
jne    3afa <sortunit+0x12>
jmp    3b0e <sortunit+0x26>
mov    $0x0,%esi
movslq %esi,%rsi
mov    0x0(%rip),%rcx        # 3b18 <sortunit+0x30>
mov    $0x8,%edx
mov    %rbx,%rdi
callq  3b25 <sortunit+0x3d>
lea    0x320(%rbx),%rdi
cmpq   $0x0,0x320(%rbx)
je     3b4d <sortunit+0x65>
mov    %rdi,%rax
mov    $0x0,%esi
add    $0x8,%rax
add    $0x1,%esi
cmpq   $0x0,(%rax)
jne    3b3e <sortunit+0x56>
jmp    3b52 <sortunit+0x6a>
mov    $0x0,%esi
movslq %esi,%rsi
mov    0x0(%rip),%rcx        # 3b5c <sortunit+0x74>
mov    $0x8,%edx
callq  3b66 <sortunit+0x7e>
pop    %rbx
retq   
<<<sep_in_sample>>>
sortunit(struct unittype *theunit)
{
   char **ptr;
   int count;
   for (count = 0, ptr = theunit->numerator; *ptr; ptr++, count++);
   qsort(theunit->numerator, count, sizeof(char *), compare);
   for (count = 0, ptr = theunit->denominator; *ptr; ptr++, count++);
   qsort(theunit->denominator, count, sizeof(char *), compare);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 9
34 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 254 <min_id+0x7>
mov    (%rdx),%rax
add    $0x8,%rdx
mov    %rdx,0x0(%rip)        # 262 <min_id+0x15>
retq   
<<<sep_in_sample>>>
min_id(void)
{
  char *x;
  memmove (&x,mpointer,sizeof(char *));
  mpointer += sizeof(char *);
  return(x);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     70 <osip_message_set_allow+0x70>
mov    %rdi,%rbp
mov    $0x0,%eax
cmpb   $0x0,(%rsi)
je     75 <osip_message_set_allow+0x75>
lea    0x8(%rsp),%rdi
callq  25 <osip_message_set_allow+0x25>
mov    %eax,%edx
test   %edx,%edx
jne    75 <osip_message_set_allow+0x75>
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  38 <osip_message_set_allow+0x38>
mov    %eax,%ebx
test   %eax,%eax
je     4c <osip_message_set_allow+0x4c>
mov    0x8(%rsp),%rdi
callq  48 <osip_message_set_allow+0x48>
mov    %ebx,%eax
jmp    75 <osip_message_set_allow+0x75>
movl   $0x2,0x1a0(%rbp)
lea    0x68(%rbp),%rdi
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
callq  69 <osip_message_set_allow+0x69>
mov    $0x0,%eax
jmp    75 <osip_message_set_allow+0x75>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_message_set_allow (osip_message_t * sip, const char *hvalue)
{
  osip_allow_t *allow;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_content_length_init(&allow);
  if (i != 0)
    return i;
  i = osip_content_length_parse(allow, hvalue);
  if (i != 0) {
    osip_content_length_free (allow);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->allows, allow, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 5
10 5
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 10
20 11
21 11
22 12
23 12
24 13
25 13
26 15
27 16
28 16
29 16
30 16
31 17
32 17
33 6
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%rbx
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r10
movzwl (%r10),%edi
test   %rbp,%rbp
je     1d69 <gsl_matrix_ushort_minmax+0x64>
add    %r12,%r12
lea    (%rbx,%rbx,1),%r13
mov    %edi,%r8d
mov    $0x0,%r11d
jmp    1d5b <gsl_matrix_ushort_minmax+0x56>
movzwl (%rcx),%eax
cmp    %ax,%r8w
cmova  %eax,%r8d
cmp    %ax,%di
cmovb  %eax,%edi
add    $0x2,%rcx
cmp    %r9,%rcx
jne    1d35 <gsl_matrix_ushort_minmax+0x30>
add    $0x1,%r11
add    %r12,%r10
cmp    %rbp,%r11
je     1d6c <gsl_matrix_ushort_minmax+0x67>
test   %rbx,%rbx
je     1d4f <gsl_matrix_ushort_minmax+0x4a>
lea    (%r10,%r13,1),%r9
mov    %r10,%rcx
jmp    1d35 <gsl_matrix_ushort_minmax+0x30>
mov    %edi,%r8d
mov    %r8w,(%rsi)
mov    %di,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_minmax (const gsl_matrix_ushort * m,
                               unsigned short * min_out,
                               unsigned short * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned short max = m->data[0 * tda + 0];
  unsigned short min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned short x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 7
8 8
9 8
10 11
11 11
12 11
13 11
14 9
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 15
23 13
24 13
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 9
35 26
36 27
37 28
38 28
39 28
40 28
41 28
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    0x14(%rsi),%r13d
movslq %r13d,%rbp
movslq (%rdi),%rax
cmp    %rax,%rbp
jle    2c <__gmpq_get_den+0x2c>
mov    %rbp,%rsi
callq  27 <__gmpq_get_den+0x27>
mov    %rax,%rdi
jmp    30 <__gmpq_get_den+0x30>
mov    0x8(%rdi),%rdi
mov    %r13d,0x4(%rbx)
mov    0x18(%r12),%rsi
mov    %rbp,%rdx
callq  41 <__gmpq_get_den+0x41>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__gmpq_get_den (mpz_ptr den, mpq_srcptr src)
{
  mp_size_t size = (((&((src)->_mp_den)))->_mp_size);
  mp_ptr dp;
  dp = (__builtin_expect (((size) > ((den)->_mp_alloc)) != 0, 0) ? (mp_ptr) __gmpz_realloc(den,size) : ((den)->_mp_d));
  ((den)->_mp_size) = size;
  do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (dp, (((&((src)->_mp_den)))->_mp_d), size); } while (0); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rsi
testb  $0x40,0x240(%rdi)
je     91 <CDB___os_r_detach+0x2a>
mov    0x88(%rsi),%esi
mov    0x18(%rax),%rdi
callq  8a <CDB___os_r_detach+0x23>
mov    $0x0,%eax
jmp    b3 <CDB___os_r_detach+0x4c>
mov    0x0(%rip),%rcx        # 98 <CDB___os_r_detach+0x31>
test   %rcx,%rcx
je     ab <CDB___os_r_detach+0x44>
mov    0x88(%rsi),%esi
mov    0x18(%rax),%rdi
callq  *%rcx
jmp    b3 <CDB___os_r_detach+0x4c>
mov    %rax,%rsi
callq  b3 <CDB___os_r_detach+0x4c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___os_r_detach(dbenv, infop, destroy)
 DB_ENV *dbenv;
 REGINFO *infop;
 int destroy;
{
 REGION *rp;
 rp = infop->rp;
 if (((dbenv)->flags & (0x00040))) {
  CDB___os_free(infop->addr, rp->size);
  return (0);
 }
 if (CDB___db_jump.j_unmap != ((void *)0))
  return (CDB___db_jump.j_unmap(infop->addr, rp->size));
 return (CDB___os_r_sysdetach(dbenv, infop, destroy));
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 8
5 8
6 9
7 9
8 9
9 10
10 10
11 12
12 12
13 12
14 13
15 13
16 13
17 13
18 14
19 14
20 15
21 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x110,%rsp
mov    %rsi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x108(%rsp)
xor    %eax,%eax
lea    0x8(%rdi),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x100,%esi
mov    %rsp,%rdi
callq  c4 <add_session_cookie+0x39>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  d4 <add_session_cookie+0x49>
test   %eax,%eax
jne    f3 <add_session_cookie+0x68>
mov    0x0(%rip),%rcx        # df <add_session_cookie+0x54>
mov    $0x25,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  f3 <add_session_cookie+0x68>
mov    0x108(%rsp),%rax
xor    %fs:0x28,%rax
je     10b <add_session_cookie+0x80>
callq  10b <add_session_cookie+0x80>
add    $0x110,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
add_session_cookie (struct Session *session,
      struct MHD_Response *response)
{
  char cstr[256];
  snprintf (cstr,
     sizeof (cstr),
     "%s=%s",
     "session",
     session->sid);
  if (0 ==
      MHD_add_response_header (response,
          "Set-Cookie",
          cstr))
    {
      fprintf (stderr,
        "Failed to set session cookie header!\n");
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 11
14 11
15 11
16 11
17 10
18 10
19 15
20 15
21 15
22 15
23 15
24 18
25 18
26 18
27 18
28 18
29 18
30 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a59 <strob_catstr+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strob_catstr(STROB * strb, char *str)
{
 return strob_strcat(strb, str);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3f8 <psi_x>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_psi_e(const double x, gsl_sf_result * result)
{
  return psi_x(x, result);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0xd8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsasl_client_application_data_get (Gsasl_session * sctx)
{
  return gsasl_appinfo_get (sctx);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rsi
test   %rsi,%rsi
jg     14 <__gmpz_perfect_square_p+0x14>
mov    %rsi,%rax
not    %rax
shr    $0x3f,%rax
retq   
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  21 <__gmpz_perfect_square_p+0x21>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;
  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}
<<<sep_in_sample>>>
1 5
2 7
3 7
4 6
5 6
6 6
7 10
8 2
9 8
10 8
11 10
12 10
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  c7 <gsl_multiset_calloc+0x9>
test   %rax,%rax
je     ed <gsl_multiset_calloc+0x2f>
test   %rbx,%rbx
je     f2 <gsl_multiset_calloc+0x34>
mov    $0x0,%edx
mov    0x10(%rax),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    d6 <gsl_multiset_calloc+0x18>
jmp    f2 <gsl_multiset_calloc+0x34>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multiset_calloc (const size_t n, const size_t k)
{
  size_t i;
  gsl_multiset * c = gsl_multiset_alloc (n, k);
  if (c == 0)
    return 0;
  for (i = 0; i < k; i++)
    {
      c->data[i] = 0;
    }
  return c;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 7
8 7
9 9
10 9
11 7
12 7
13 7
14 7
15 6
16 12
17 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    $0x28,%esi
mov    $0x1,%edi
callq  cb7 <wsnode_new+0x1b>
test   %rax,%rax
jne    cc6 <wsnode_new+0x2a>
mov    %rbp,%rdi
callq  c4b <_wsplt_nomem>
jmp    cce <wsnode_new+0x32>
mov    %rax,(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
wsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)
{
  struct wordsplit_node *node = calloc (1, sizeof (*node));
  if (!node)
    return _wsplt_nomem (wsp);
  *pnode = node;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 6
15 7
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
test   %rsi,%rsi
je     28f <_gsasl_openid20_server_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  28b <_gsasl_openid20_server_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_openid20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct openid20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x14,%edi
callq  d3e <cmdline_parser_params_create+0xb>
mov    %rax,%rbx
mov    %rax,%rdi
callq  d49 <cmdline_parser_params_create+0x16>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params =
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);
  return params;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
cmpb   $0x2f,(%rdi)
jne    1e76 <stripped_prefix_len+0x38>
mov    %rdi,%rax
add    $0x1,%rax
cmpb   $0x2f,(%rax)
je     1e46 <stripped_prefix_len+0x8>
jmp    1e79 <stripped_prefix_len+0x3b>
add    $0x1,%rax
cmp    $0x2f,%dl
jne    1e79 <stripped_prefix_len+0x3b>
sub    $0x1,%rsi
je     1e67 <stripped_prefix_len+0x29>
cmpb   $0x2f,(%rax)
je     1e6b <stripped_prefix_len+0x2d>
jmp    1e79 <stripped_prefix_len+0x3b>
sub    %rdi,%rax
retq   
add    $0x1,%rax
cmpb   $0x2f,(%rax)
je     1e6b <stripped_prefix_len+0x2d>
jmp    1e79 <stripped_prefix_len+0x3b>
mov    %rdi,%rax
movzbl (%rax),%edx
test   %dl,%dl
jne    1e51 <stripped_prefix_len+0x13>
mov    $0xffffffffffffffff,%rax
retq   
<<<sep_in_sample>>>
stripped_prefix_len (char const *file_name, size_t num)
{
  char const *p = file_name + 0;
  while (((*p) == '/'))
    p++;
  while (*p)
    {
      _Bool slash = ((*p) == '/');
      p++;
      if (slash)
 {
   if (--num == 0)
     return p - file_name;
   while (((*p) == '/'))
     p++;
 }
    }
  return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 5
5 4
6 4
7 4
8 9
9 10
10 10
11 12
12 12
13 14
14 14
15 14
16 13
17 13
18 15
19 14
20 14
21 14
22 3
23 6
24 6
25 6
26 18
27 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    0x8(%rdi),%rdi
callq  8eb <term_styled_ostream__free+0x12>
mov    0x10(%rbp),%rdi
callq  8f4 <term_styled_ostream__free+0x1b>
mov    0x18(%rbp),%rdi
callq  8fd <term_styled_ostream__free+0x24>
mov    0x20(%rbp),%rdi
callq  906 <term_styled_ostream__free+0x2d>
movq   $0x0,(%rsp)
jmp    91a <term_styled_ostream__free+0x41>
mov    0x18(%rsp),%rdi
callq  91a <term_styled_ostream__free+0x41>
lea    0x38(%rbp),%rbx
lea    0x18(%rsp),%r8
lea    0x10(%rsp),%rcx
lea    0x8(%rsp),%rdx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  938 <term_styled_ostream__free+0x5f>
test   %eax,%eax
je     910 <term_styled_ostream__free+0x37>
mov    %rbx,%rdi
callq  944 <term_styled_ostream__free+0x6b>
mov    %rbp,%rdi
callq  94c <term_styled_ostream__free+0x73>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
term_styled_ostream__free (term_styled_ostream_t stream)
{
  term_ostream_free (stream->destination);
  cr_cascade_destroy (stream->css_document);
  cr_sel_eng_destroy (stream->css_engine);
  free (stream->curr_classes);
  {
    void *ptr = ((void *)0);
    const void *key;
    size_t keylen;
    void *data;
    while (hash_iterate (&stream->cache, &ptr, &key, &keylen, &data) == 0)
      {
        free (data);
      }
  }
  hash_destroy (&stream->cache);
  free (stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 5
10 5
11 6
12 6
13 8
14 12
15 14
16 14
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 17
27 17
28 18
29 18
30 19
31 19
32 19
33 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  14 <string_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_free (void *data)
{
  free (data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 45d <tty_tspeed+0xa>
cmp    $0xffffffff,%eax
je     489 <tty_tspeed+0x36>
cmp    %eax,%edi
jle    494 <tty_tspeed+0x41>
mov    $0x0,%eax
add    $0x8,%rax
mov    (%rax),%edx
cmp    $0xffffffff,%edx
je     48e <tty_tspeed+0x3b>
cmp    %edi,%edx
jl     46b <tty_tspeed+0x18>
mov    0x4(%rax),%esi
mov    $0x0,%edi
callq  487 <tty_tspeed+0x34>
jmp    49b <tty_tspeed+0x48>
mov    $0x0,%eax
sub    $0x8,%rax
jmp    47a <tty_tspeed+0x27>
mov    $0x0,%eax
jmp    47a <tty_tspeed+0x27>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
tty_tspeed (int val)
{
  struct termspeeds *tp;
  for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
    ;
  if (tp->speed == -1)
    --tp;
  val = tp->value;
  cfsetospeed (&termbuf, val);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 9
15 9
16 9
17 9
18 4
19 7
20 7
21 4
22 4
23 10
24 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  a10 <cdio_open+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cdio_open (const char *orig_source_name, driver_id_t driver_id)
{
  return cdio_open_am(orig_source_name, driver_id, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rdi,%rax
test   %rsi,%rsi
jle    17 <__rtsetpos+0x17>
movzwl 0x8(%rdi),%edx
lea    0x1(%rdx),%rcx
mov    %esi,%edx
cmp    %rcx,%rsi
jle    1e <__rtsetpos+0x1e>
movzwl 0x8(%rax),%edi
lea    0x1(%rdi),%edx
mov    %dx,0xa(%rax)
retq   
<<<sep_in_sample>>>
__rtsetpos (__txtvp t, long i)
{
  t->pos = ((i < 1 || i > t->length + 1) ? t->length + 1 : i);
  return (t);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
<<<sep_out_sample>>>
mov    %rsi,0xe0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_gssapi_set (Gsasl * ctx,
      Gsasl_server_callback_gssapi cb)
{
  ctx->cbs_gssapi = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %esi,%edx
mov    0x0(%rip),%rcx        # 1164 <missing_left+0xd>
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1176 <missing_left+0x1f>
cmpl   $0x0,0x0(%rip)        # 117d <missing_left+0x26>
je     1189 <missing_left+0x32>
movl   $0x1,0x0(%rip)        # 1189 <missing_left+0x32>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
missing_left(const char *word, int lineno)
{
 warning("missing left '%s'. [+%d %s]", word, lineno, curpfile);
 if (colorize_warned_line)
  warned = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     46d8 <gsl_matrix_complex_float_const_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  46b0 <gsl_matrix_complex_float_const_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    470a <gsl_matrix_complex_float_const_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x3,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_const_row (const gsl_matrix_complex_float * m, const size_t i)
{
  _gsl_vector_complex_float_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 2 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     69e0 <info_menu_item+0x33>
mov    (%rax),%rdx
test   %rdx,%rdx
je     69e0 <info_menu_item+0x33>
cmpl   $0x1,0x28(%rdx)
jne    69d4 <info_menu_item+0x27>
jmp    69f8 <info_menu_item+0x4b>
cmpl   $0x1,0x28(%rdx)
je     69f8 <info_menu_item+0x4b>
add    $0x8,%rax
mov    (%rax),%rdx
test   %rdx,%rdx
jne    69ce <info_menu_item+0x21>
mov    0x0(%rip),%rsi        # 69e7 <info_menu_item+0x3a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  69f6 <info_menu_item+0x49>
jmp    6a0c <info_menu_item+0x5f>
mov    $0x1,%ecx
mov    $0x0,%edx
mov    $0x1,%esi
callq  65c6 <info_menu_or_ref_item>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_menu_item (WINDOW *window, int count)
{
  if (window->node->references)
    {
      REFERENCE **r;
      for (r = window->node->references; *r; r++)
        if ((*r)->type == 1)
          break;
      if (*r)
        {
          info_menu_or_ref_item (window, 1, 0, 1);
          return;
        }
    }
  info_error ("%s", msg_no_menu_node);
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 6
18 15
19 15
20 15
21 15
22 16
23 11
24 11
25 11
26 11
27 17
28 17
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     5b8 <swverid_ver_id_set_object_qualifier+0x1c>
movzbl (%rsi),%edx
mov    %dl,0x5(%rax)
movb   $0x0,0x6(%rax)
mov    0x18(%rax),%rax
test   %rax,%rax
jne    5a5 <swverid_ver_id_set_object_qualifier+0x9>
repz retq 
<<<sep_in_sample>>>
swverid_ver_id_set_object_qualifier(SWVERID * swverid, char * objkeyword)
{
 struct VER_ID *last;
 last = swverid->ver_id_listM;
 while (last) {
  last->vqM[0] = *objkeyword;
  last->vqM[1] = '\0';
  last = last->nextM;
 }
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 7
7 8
8 5
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
movzbl %dil,%ebp
cmp    %edi,%ebp
jne    27 <rl_alphabetic+0x27>
callq  15 <rl_alphabetic+0x15>
movzbl %bpl,%ebp
mov    (%rax),%rdx
mov    $0x1,%eax
testb  $0x8,(%rdx,%rbp,2)
jne    4a <rl_alphabetic+0x4a>
mov    $0x0,%eax
cmpl   $0x0,0x0(%rip)        # 33 <rl_alphabetic+0x33>
je     4a <rl_alphabetic+0x4a>
mov    %ebx,%esi
mov    $0x0,%edi
callq  41 <rl_alphabetic+0x41>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rl_alphabetic (c)
     int c;
{
  if ((((unsigned char)(c) == (c)) && (1 && ((*__ctype_b_loc ())[(int) (((unsigned char)c))] & (unsigned short int) _ISalnum))))
    return (1);
  return (_rl_allow_pathname_alphabetic_chars &&
     strchr (pathname_alphabetic_chars, c) != ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 6
15 6
16 6
17 7
18 7
19 7
20 6
21 6
22 6
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     1183 <shcmd_cmdvec_debug_show_to_file+0x28>
mov    %rbp,%rsi
callq  1177 <shcmd_cmdvec_debug_show_to_file+0x1c>
add    $0x8,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    116f <shcmd_cmdvec_debug_show_to_file+0x14>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
shcmd_cmdvec_debug_show_to_file(SHCMD ** vec, FILE * file)
{
 SHCMD ** pv = vec;
 while(*pv) {
  shcmd_debug_show_to_file(*pv, file);
  pv++;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 6
12 4
13 4
14 4
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x18,%edi
callq  85a <gl_linked_nx_add_last+0x16>
test   %rax,%rax
je     87e <gl_linked_nx_add_last+0x3a>
mov    %rbp,0x10(%rax)
lea    0x28(%rbx),%rdx
mov    %rdx,(%rax)
mov    0x30(%rbx),%rdx
mov    %rdx,0x8(%rax)
mov    %rax,(%rdx)
mov    %rax,0x30(%rbx)
addq   $0x1,0x40(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gl_linked_nx_add_last (gl_list_t list, const void *elt)
{
  gl_list_node_t node =
    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));
  if (node == ((void *)0))
    return ((void *)0);
  node->value = elt;
  node->next = &list->root;
  node->prev = list->root.prev;
  node->prev->next = node;
  list->root.prev = node;
  list->count++;
  return node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 7
11 8
12 8
13 9
14 9
15 10
16 11
17 12
18 14
19 14
20 14
21 14
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     739 <mu_acl_set_debug+0xf>
mov    %rsi,(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_acl_set_debug (mu_acl_t acl, mu_debug_t debug)
{
  if (!acl)
    return 22;
  acl->debug = debug;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
and    $0x80000,%esi
cmp    $0x1,%esi
sbb    %esi,%esi
not    %esi
and    $0x406,%esi
mov    $0x3,%edx
mov    $0x0,%eax
callq  26 <dup_safer_flag+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer_flag (int fd, int flag)
{
  return rpl_fcntl (fd, (flag & 02000000) ? 1030 : 0,
                2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%ecx
test   %rdi,%rdi
je     1d6b <rl_bind_keyseq_if_unbound_in_map+0x4e>
mov    %rsi,%r12
mov    %rdx,%rbp
mov    $0x0,%edx
mov    %rbp,%rsi
callq  1d41 <rl_bind_keyseq_if_unbound_in_map+0x24>
test   %rax,%rax
je     1d5b <rl_bind_keyseq_if_unbound_in_map+0x3e>
cmp    $0x0,%rax
je     1d5b <rl_bind_keyseq_if_unbound_in_map+0x3e>
mov    $0x1,%ecx
cmp    $0x0,%rax
jne    1d6b <rl_bind_keyseq_if_unbound_in_map+0x4e>
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1d69 <rl_bind_keyseq_if_unbound_in_map+0x4c>
mov    %eax,%ecx
mov    %ecx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
     const char *keyseq;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  rl_command_func_t *func;
  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)((void *)0));
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
 return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
 return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 15
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 13
18 10
19 10
20 11
21 11
22 11
23 11
24 11
25 16
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     33cd <gsl_vector_uchar_free+0x20>
cmpl   $0x0,0x20(%rdi)
je     33c5 <gsl_vector_uchar_free+0x18>
mov    0x18(%rdi),%rdi
callq  33c5 <gsl_vector_uchar_free+0x18>
mov    %rbx,%rdi
callq  33cd <gsl_vector_uchar_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_free (gsl_vector_uchar * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_uchar_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
test   %r8,%r8
je     1c11 <gsl_matrix_float_set_identity+0x5a>
shl    $0x2,%rdi
mov    $0x0,%edx
xorps  %xmm1,%xmm1
jmp    1c05 <gsl_matrix_float_set_identity+0x4e>
cmp    %rax,%rdx
jne    1be8 <gsl_matrix_float_set_identity+0x31>
movss  0x0(%rip),%xmm0        # 1be6 <gsl_matrix_float_set_identity+0x2f>
jmp    1beb <gsl_matrix_float_set_identity+0x34>
movaps %xmm1,%xmm0
movss  %xmm0,(%rcx,%rax,4)
add    $0x1,%rax
cmp    %rsi,%rax
jne    1bd9 <gsl_matrix_float_set_identity+0x22>
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
je     1c11 <gsl_matrix_float_set_identity+0x5a>
test   %rsi,%rsi
je     1bf9 <gsl_matrix_float_set_identity+0x42>
mov    $0x0,%eax
jmp    1bd9 <gsl_matrix_float_set_identity+0x22>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_float_set_identity (gsl_matrix_float * m)
{
  size_t i, j;
  float * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const float zero = 0.0F;
  const float one = 1.0F;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(float *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 10
6 10
7 10
8 10
9 14
10 14
11 14
12 14
13 14
14 14
15 14
16 14
17 12
18 12
19 12
20 10
21 10
22 10
23 10
24 12
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
callq  11 <_memory_get_transport2+0x11>
mov    0x8(%rax),%rdx
mov    %rdx,0x0(%rbp)
test   %rbx,%rbx
je     25 <_memory_get_transport2+0x25>
mov    0x8(%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_memory_get_transport2 (mu_stream_t stream,
   mu_transport_t *pin, mu_transport_t *pout)
{
  struct _memory_stream *mfs = mu_stream_get_owner (stream);
  *pin = mfs->ptr;
  if (pout)
    *pout = mfs->ptr;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 9
14 9
15 9
16 9
17 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2032 <cpp_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cpp_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
callq  55d <il_insert_char+0xd>
movslq %ebx,%rdx
mov    (%rax),%rax
testb  $0x40,0x1(%rax,%rdx,2)
je     5ef <il_insert_char+0x9f>
mov    0x0(%rip),%rbp        # 575 <il_insert_char+0x25>
mov    0x38(%rbp),%rsi
lea    0x1(%rsi),%rax
cmp    0x50(%rbp),%rax
jb     598 <il_insert_char+0x48>
add    $0x21,%rsi
mov    %rsi,0x50(%rbp)
mov    0x58(%rbp),%rdi
callq  594 <il_insert_char+0x44>
mov    %rax,0x58(%rbp)
mov    0x0(%rip),%rdx        # 59f <il_insert_char+0x4f>
mov    0x18(%rdx),%rax
mov    0x58(%rdx),%rcx
mov    0x38(%rdx),%rdx
add    $0x1,%rdx
sub    %rax,%rdx
lea    (%rcx,%rax,1),%rsi
lea    0x1(%rcx,%rax,1),%rdi
callq  5c0 <il_insert_char+0x70>
mov    0x0(%rip),%rax        # 5c7 <il_insert_char+0x77>
mov    0x58(%rax),%rdx
mov    0x18(%rax),%rax
mov    %bl,(%rdx,%rax,1)
mov    0x0(%rip),%rax        # 5d9 <il_insert_char+0x89>
addq   $0x1,0x18(%rax)
addq   $0x1,0x38(%rax)
addq   $0x1,0x48(%rax)
movl   $0x7,0x10(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
il_insert_char(c)
    int c;
{
    if (!((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISprint))
 return;
    if (il->length + 1 >= il->size)
 { il->size = il->length + 1 + 32; il->buffer = xrealloc(il->buffer, il->size); };
    memmove(il->buffer + il->point + 1,
     il->buffer + il->point,
     il->length - il->point + 1);
    il->buffer[il->point] = c;
    il->point++;
    il->length++;
    il->dynamic_length++;
    il->last_operation = 7;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 10
21 10
22 9
23 10
24 10
25 8
26 8
27 8
28 8
29 11
30 11
31 11
32 11
33 12
34 12
35 13
36 14
37 15
38 16
39 16
40 16
41 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  706 <gfind_close+0xc>
mov    0x8(%rbx),%rdi
callq  70f <gfind_close+0x15>
mov    %rbx,%rdi
callq  717 <gfind_close+0x1d>
pop    %rbx
retq   
<<<sep_in_sample>>>
gfind_close(GFIND *gfind)
{
 dbop_close(gfind->dbop);
 free((void *)gfind->prefix);
 free(gfind);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     8d5 <mu_stream_printf+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rcx
callq  906 <mu_stream_printf+0x82>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mu_stream_printf (mu_stream_t os, mu_off_t *poff, const char *fmt, ...)
{
  va_list ap;
  int rc;
  __builtin_va_start(ap,fmt);
  rc = mu_stream_vprintf (os, poff, fmt, ap);
  __builtin_va_end(ap);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 9
24 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f9 <_body_flush+0x9>
mov    0x18(%rax),%rdi
callq  102 <_body_flush+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_body_flush (mu_stream_t stream)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_flush (body->fstream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  c1d <safe_xstat>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
safe_stat (const char *pathname, struct stat *buf)
{
  return safe_xstat (pathname, buf, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 73e <rl_clear_pending_input+0xa>
andq   $0xfffffffffffdffff,0x0(%rip)        # 749 <rl_clear_pending_input+0x15>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_clear_pending_input ()
{
  rl_pending_input = 0;
  (rl_readline_state &= ~(0x0020000));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x1,%eax
test   %rdi,%rdi
je     28f <mu_iterator_is_done+0x1c>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  *0x48(%rdx)
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_iterator_is_done (mu_iterator_t iterator)
{
  if (iterator == ((void *)0))
    return 1;
  return iterator->finished_p (iterator->owner);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 3
5 2
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  12a1 <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 19a <salloc_reinit+0xb>
cmp    0x0(%rip),%rsi        # 1a1 <salloc_reinit+0x12>
jbe    1bc <salloc_reinit+0x2d>
cmp    0x0(%rip),%rsi        # 1aa <salloc_reinit+0x1b>
jae    1bc <salloc_reinit+0x2d>
mov    %rsi,0x0(%rip)        # 1b3 <salloc_reinit+0x24>
mov    %rsi,0x0(%rip)        # 1ba <salloc_reinit+0x2b>
jmp    1c6 <salloc_reinit+0x37>
mov    $0x0,%edi
callq  1c6 <salloc_reinit+0x37>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
salloc_reinit (void)
{
  __extension__ ({ struct obstack *__o = (&os_salloc); void *__obj = (first_object_allocated_ptr_salloc); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
movl   $0x0,0x18(%rsp)
mov    0x40(%rsp),%eax
mov    %eax,0x10(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    0x30(%rsp),%eax
mov    %eax,(%rsp)
callq  c8e3 <re_search_2_stub>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
re_search_2 (struct re_pattern_buffer *bufp, const char *string1, int length1,
      const char *string2, int length2, int start, int range,
      struct re_registers *regs, int stop)
{
  return re_search_2_stub (bufp, string1, length1, string2, length2,
      start, range, regs, stop, 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
11 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rbx
mov    0x10(%rdi),%rsi
mov    %rbp,%rdi
callq  *0x30(%r12)
shl    $0x4,%rax
add    %rax,%rbx
cmp    0x8(%r12),%rbx
jb     5e9 <hash_lookup+0x2c>
callq  5e9 <hash_lookup+0x2c>
mov    (%rbx),%rsi
test   %rsi,%rsi
je     630 <hash_lookup+0x73>
test   %rbx,%rbx
je     62b <hash_lookup+0x6e>
cmp    %rsi,%rbp
jne    60a <hash_lookup+0x4d>
nopl   0x0(%rax,%rax,1)
jmp    616 <hash_lookup+0x59>
mov    (%rbx),%rsi
cmp    %rbp,%rsi
je     616 <hash_lookup+0x59>
mov    %rbp,%rdi
callq  *0x38(%r12)
test   %al,%al
je     61b <hash_lookup+0x5e>
mov    (%rbx),%rsi
jmp    630 <hash_lookup+0x73>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    602 <hash_lookup+0x45>
mov    $0x0,%esi
jmp    630 <hash_lookup+0x73>
mov    $0x0,%esi
mov    %rsi,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
hash_lookup (const Hash_table *table, const void *entry)
{
  struct hash_entry const *bucket
    = table->bucket + table->hasher (entry, table->n_buckets);
  struct hash_entry const *cursor;
  if (! (bucket < table->bucket_limit))
    abort ();
  if (bucket->data == ((void *)0))
    return ((void *)0);
  for (cursor = bucket; cursor; cursor = cursor->next)
    if (entry == cursor->data || table->comparator (entry, cursor->data))
      return cursor->data;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 3
12 6
13 6
14 7
15 8
16 8
17 8
18 10
19 10
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 12
32 12
33 10
34 10
35 10
36 13
37 13
38 13
39 14
40 14
41 14
42 14
43 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbp
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%r12
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x18(%rsp)
ucomisd %xmm3,%xmm2
jae    10f4 <TruncLogNormalRandom+0x37>
mov    $0x1,%ebx
jmp    115d <TruncLogNormalRandom+0xa0>
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x2,%eax
callq  110f <TruncLogNormalRandom+0x52>
xorpd  %xmm0,%xmm0
jmp    118c <TruncLogNormalRandom+0xcf>
add    $0x1,%ebx
cmp    $0x19,%ebx
jne    115d <TruncLogNormalRandom+0xa0>
mov    $0x0,%edi
mov    $0x0,%eax
callq  112c <TruncLogNormalRandom+0x6f>
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm3
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm2
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm0
mov    $0x0,%edi
mov    $0x4,%eax
callq  115d <TruncLogNormalRandom+0xa0>
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  1178 <TruncLogNormalRandom+0xbb>
movsd  0x10(%rsp),%xmm4
ucomisd %xmm0,%xmm4
ja     1115 <TruncLogNormalRandom+0x58>
ucomisd 0x18(%rsp),%xmm0
ja     1115 <TruncLogNormalRandom+0x58>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
TruncLogNormalRandom (double dMean, double dStdDev, double a, double b)
{
  double X = 0.0;
  int iter = 0;
  if (a >= b)
    printf ("TruncLogNormalRandom: min >= max  [%g %g]\n", a, b);
  else do {
    if(++iter == 25) {
      printf("TruncLogNormalRandom: problem with range: ");
      printf("min %g, max %g, ave %g, sd %g\n", a, b, dMean, dStdDev);
    }
    X = LogNormalRandom(dMean, dStdDev);
  }
  while (X < a || X > b);
  return X;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 8
14 8
15 6
16 6
17 6
18 6
19 6
20 3
21 3
22 8
23 8
24 8
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 12
38 12
39 12
40 12
41 12
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
movsbl 0x0(%rip),%eax        # 709 <wordsplit_c_quote_char+0x7>
cmp    %edi,%eax
jne    722 <wordsplit_c_quote_char+0x20>
jmp    718 <wordsplit_c_quote_char+0x16>
movsbl (%rax),%edx
cmp    %edi,%edx
jne    727 <wordsplit_c_quote_char+0x25>
jmp    71d <wordsplit_c_quote_char+0x1b>
mov    $0x0,%eax
movsbl -0x1(%rax),%eax
retq   
mov    $0x0,%eax
sub    $0x2,%rax
cmp    $0x0,%rax
ja     70f <wordsplit_c_quote_char+0xd>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
wordsplit_c_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof (quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 4
10 8
11 8
12 4
13 5
14 4
15 4
16 10
17 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # d0 <free_resources+0xd>
movq   $0x0,0x0(%rip)        # db <free_resources+0x18>
test   %rdi,%rdi
je     10f <free_resources+0x4c>
mov    (%rdi),%rbx
callq  e8 <free_resources+0x25>
test   %rbx,%rbx
je     10f <free_resources+0x4c>
mov    %rbx,%rdi
jmp    e0 <free_resources+0x1d>
mov    (%rbx),%edi
cmp    $0xffffffff,%edi
je     104 <free_resources+0x41>
callq  fe <free_resources+0x3b>
movl   $0xffffffff,(%rbx)
add    $0x4,%rbx
cmp    %rbp,%rbx
jne    f2 <free_resources+0x2f>
jmp    11b <free_resources+0x58>
mov    $0x0,%ebx
mov    $0x0,%ebp
jmp    f2 <free_resources+0x2f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
free_resources ()
{
  struct map *clean = garpd_list;
  int i;
  garpd_list = ((void *)0);
  while (clean)
    {
      struct map *old;
      old = clean;
      clean = clean->next;
      free (old);
    }
  for (i = 0; i < 64; i++)
    {
      if (iface_sock_map[i] != -1)
 {
   close (iface_sock_map[i]);
   iface_sock_map[i] = -1;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 6
7 6
8 10
9 11
10 6
11 6
12 10
13 10
14 15
15 15
16 15
17 17
18 18
19 18
20 13
21 13
22 13
23 13
24 13
25 13
26 21
27 21
28 21
29 21
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r14
mov    $0x2e,%esi
callq  18 <find_compression_suffix+0x18>
test   %rax,%rax
je     91 <find_compression_suffix+0x91>
lea    0x1(%rax),%r12
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbp
mov    0x0(%rip),%rdi        # 40 <find_compression_suffix+0x40>
test   %rdi,%rdi
je     98 <find_compression_suffix+0x98>
mov    $0x0,%ebx
cmp    %rbp,0x8(%rbx)
jne    83 <find_compression_suffix+0x83>
mov    %rbp,%rdx
mov    %r12,%rsi
callq  5b <find_compression_suffix+0x5b>
test   %eax,%eax
jne    83 <find_compression_suffix+0x83>
test   %r14,%r14
je     9f <find_compression_suffix+0x9f>
mov    %r13,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
not    %rbp
lea    -0x1(%rcx,%rbp,1),%rax
mov    %rax,(%r14)
mov    %rbx,%rax
jmp    a9 <find_compression_suffix+0xa9>
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    4a <find_compression_suffix+0x4a>
jmp    a4 <find_compression_suffix+0xa4>
mov    $0x0,%eax
jmp    a9 <find_compression_suffix+0xa9>
mov    $0x0,%eax
jmp    a9 <find_compression_suffix+0xa9>
mov    %rbx,%rax
jmp    a9 <find_compression_suffix+0xa9>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
find_compression_suffix (const char *name, size_t *ret_len)
{
  char *suf = strrchr (name, '.');
  if (suf)
    {
      size_t len;
      struct compression_suffix *p;
      suf++;
      len = strlen (suf);
      for (p = compression_suffixes; p->suffix; p++)
 {
   if (p->length == len && memcmp (p->suffix, suf, len) == 0)
     {
       if (ret_len)
  *ret_len = strlen (name) - len - 1;
       return p;
     }
 }
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 14
31 14
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 10
42 10
43 10
44 10
45 10
46 20
47 20
48 20
49 20
50 20
51 20
52 20
53 21
54 21
55 21
56 21
57 21
58 21
<<<sep_out_sample>>>
movzbl (%rdi),%edi
callq  fe <is_cntrl_mbchar+0x8>
repz retq 
<<<sep_in_sample>>>
is_cntrl_mbchar(const char *c)
{
    ((void) (0));
 return is_cntrl_char((unsigned char)*c);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     3516 <d_error+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    $0x0,%edi
callq  354a <d_error+0x90>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 3554 <d_error+0x9a>
mov    $0x0,%eax
callq  355e <d_error+0xa4>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 356d <d_error+0xb3>
callq  3572 <d_error+0xb8>
mov    0x0(%rip),%rsi        # 3579 <d_error+0xbf>
mov    $0xa,%edi
callq  3583 <d_error+0xc9>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
d_error(const char *mesg, ...)
{
 va_list args;
 __builtin_va_start(args,mesg);
 fprintf(out_fp, gettext("error: "));
 vfprintf(out_fp, mesg, args);
 fprintf(out_fp, "\n");
 __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 6
33 6
34 6
35 7
36 7
37 7
38 9
39 9
40 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
test   %rdi,%rdi
je     1a <concat+0x14>
test   %rsi,%rsi
jne    24 <concat+0x1e>
mov    $0x0,%edi
callq  24 <concat+0x1e>
cmpq   $0x0,0x18(%rbx)
je     52 <concat+0x4c>
mov    $0x1,%ebp
jmp    47 <concat+0x41>
add    $0x1,%ebp
cmp    $0x2710,%ebp
jle    47 <concat+0x41>
mov    $0x0,%edi
callq  47 <concat+0x41>
mov    0x18(%rbx),%rbx
cmpq   $0x0,0x18(%rbx)
jne    32 <concat+0x2c>
mov    %r12,0x18(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
concat (struct expr *e0, struct expr *e1)
{
  int count;
  if (e0 == ((void *)0) || e1 == ((void *)0))
    panic ("NULL expression queue");
  for (count = 0; e0->ex_next != ((void *)0); e0 = e0->ex_next)
    if (++count > 10000)
      panic ("circular expression queue");
  e0->ex_next = e1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 6
22 6
23 6
24 9
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1afa <java_set_out+0x7>
retq   
<<<sep_in_sample>>>
java_set_out (FILE * out_str )
{
        java_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
jne    8a <_cdio_strfreev+0x38>
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x42,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  8a <_cdio_strfreev+0x38>
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     ad <_cdio_strfreev+0x5b>
mov    $0x0,%ebx
callq  9d <_cdio_strfreev+0x4b>
add    $0x1,%ebx
movslq %ebx,%rax
mov    0x0(%rbp,%rax,8),%rdi
test   %rdi,%rdi
jne    98 <_cdio_strfreev+0x46>
mov    %rbp,%rdi
callq  b5 <_cdio_strfreev+0x63>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_cdio_strfreev(char **strv)
{
  int n;
  { if (__builtin_expect((!(strv != ((void *)0))),0)) cdio_log (CDIO_LOG_ASSERT, "file %s: line %d (%s): assertion failed: (%s)", "util.c", 66, __PRETTY_FUNCTION__, "strv != NULL"); };
  for(n = 0; strv[n]; n++)
    free(strv[n]);
  free(strv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 6
20 5
21 5
22 5
23 5
24 5
25 7
26 7
27 8
28 8
29 8
30 8
<<<sep_out_sample>>>
mov    $0x16,%eax
cmpl   $0x0,0x0(%rip)        # c <__db_join_put+0xc>
je     3a <__db_join_put+0x3a>
mov    (%rdi),%rax
mov    0x28(%rax),%rax
mov    0xe0(%rax),%rdx
mov    $0x16,%eax
test   %rdx,%rdx
je     3a <__db_join_put+0x3a>
mov    0x20(%rdx),%rax
cmpl   $0x1,0x74(%rax)
sbb    %eax,%eax
and    $0x7923,%eax
sub    $0x790d,%eax
repz retq 
<<<sep_in_sample>>>
__db_join_put(dbc, key, data, flags)
 DBC *dbc;
 DBT *key;
 DBT *data;
 u_int32_t flags;
{
 if(key||data||flags){}
 if (CDB___db_global_values.db_panic && (dbc->dbp->dbenv)->reginfo != ((void *)0) && ((REGENV *) ((REGINFO *)(dbc->dbp->dbenv)->reginfo)->primary)->panic != 0) return ((-30989));;
 (key) = (((void *)0));
 (data) = (((void *)0));
 (flags) = (0);
 return (22);
}
<<<sep_in_sample>>>
1 12
2 8
3 8
4 8
5 8
6 8
7 12
8 8
9 8
10 8
11 12
12 12
13 12
14 12
15 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdx,%rdx
jne    8df <gsl_vector_uint_view_array+0x47>
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  8b7 <gsl_vector_uint_view_array+0x1f>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    8fd <gsl_vector_uint_view_array+0x65>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_uint_view_array ( unsigned int * base, size_t n)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = (unsigned int *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 10
11 10
12 10
13 10
14 10
15 10
16 21
17 21
18 21
19 21
20 21
21 23
22 23
23 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %esi,%esi
je     85c <window_goto_percentage+0x36>
cvtsi2ssq 0x88(%rdi),%xmm1
unpcklps %xmm1,%xmm1
cvtps2pd %xmm1,%xmm1
cvtsi2ss %esi,%xmm0
unpcklps %xmm0,%xmm0
cvtps2pd %xmm0,%xmm0
divsd  0x0(%rip),%xmm0        # 854 <window_goto_percentage+0x2e>
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
mov    %rax,0x38(%rdi)
mov    0x78(%rdi),%rdx
mov    (%rdx,%rax,8),%rax
mov    %rax,0x40(%rdi)
orl    $0x1,0x98(%rdi)
callq  87a <window_goto_percentage+0x54>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
window_goto_percentage (WINDOW *window, int percent)
{
  int desired_line;
  if (!percent)
    desired_line = 0;
  else
    desired_line =
      (int) ((float)window->line_count * ((float)percent / 100.0));
  window->pagetop = desired_line;
  window->point =
    window->line_starts[window->pagetop];
  window->flags |= 0x01;
  window_make_modeline (window);
}
<<<sep_in_sample>>>
1 2
2 5
3 4
4 4
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 7
14 9
15 9
16 11
17 11
18 10
19 12
20 13
21 14
22 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  524 <gsl_vector_short_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_short_fwrite (FILE * stream, const gsl_vector_short * v)
{
  int status = gsl_block_short_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
callq  36 <xstr_cd_iconveh+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    4d <xstr_cd_iconveh+0x1d>
callq  43 <xstr_cd_iconveh+0x13>
cmpl   $0xc,(%rax)
jne    4d <xstr_cd_iconveh+0x1d>
callq  4d <xstr_cd_iconveh+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstr_cd_iconveh (const char *src,
                 const iconveh_t *cd,
                 enum iconv_ilseq_handler handler)
{
  char *result = str_cd_iconveh (src, cd, handler);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 7
10 9
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
mov    0x70(%rbp),%rdi
test   %rdi,%rdi
je     3835 <free_workarea_compile+0x24>
mov    (%rdi),%rbx
callq  382b <free_workarea_compile+0x1a>
test   %rbx,%rbx
je     3835 <free_workarea_compile+0x24>
mov    %rbx,%rdi
jmp    3823 <free_workarea_compile+0x12>
movq   $0x0,0x70(%rbp)
movl   $0xf,0x80(%rbp)
movq   $0x0,0x68(%rbp)
mov    0x20(%rbp),%rdi
callq  3858 <free_workarea_compile+0x47>
movq   $0x0,0x20(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
free_workarea_compile (regex_t *preg)
{
  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
  bin_tree_storage_t *storage, *next;
  for (storage = dfa->str_tree_storage; storage; storage = next)
    {
      next = storage->next;
      free (storage);
    }
  dfa->str_tree_storage = ((void *)0);
  dfa->str_tree_storage_idx = ((1024 - sizeof (void *)) / sizeof (bin_tree_t));
  dfa->str_tree = ((void *)0);
  free (dfa->org_indices);
  dfa->org_indices = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 5
7 5
8 7
9 8
10 5
11 5
12 5
13 5
14 10
15 11
16 12
17 13
18 13
19 14
20 15
21 15
22 15
23 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  795 <gsl_sf_bessel_In+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     7bb <gsl_sf_bessel_In+0x32>
mov    %eax,%ecx
mov    $0xe0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7b4 <gsl_sf_bessel_In+0x2b>
movsd  (%rsp),%xmm0
jmp    7bb <gsl_sf_bessel_In+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_In(const int n, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_In_e(n, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_In_e(n, x, &result)", "bessel_In.c", 224, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdx
mov    $0x5413,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3e <getScreenSize+0x1b>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 48 <getScreenSize+0x25>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 53 <getScreenSize+0x30>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cgst_init(const void *vtrust_state, void *vstate)
{
  (void)vtrust_state;
  (void)vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 31d <delete_invite+0xb>
test   %rax,%rax
je     34f <delete_invite+0x3d>
mov    0x14(%rax),%edx
cmp    %rdi,%rdx
jne    343 <delete_invite+0x31>
jmp    334 <delete_invite+0x22>
mov    0x14(%rax),%edx
cmp    %rdi,%rdx
jne    343 <delete_invite+0x31>
mov    %rax,%rdi
callq  ab <table_delete>
mov    $0x0,%eax
jmp    354 <delete_invite+0x42>
mov    (%rax),%rax
test   %rax,%rax
jne    32c <delete_invite+0x1a>
mov    $0x1,%al
jmp    354 <delete_invite+0x42>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
delete_invite (unsigned long id_num)
{
  table_t *ptr;
  for (ptr = table; ptr; ptr = ptr->next)
    if (ptr->request.id_num == id_num)
      {
 table_delete (ptr);
 return 0;
      }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 8
15 8
16 4
17 4
18 4
19 10
20 10
21 10
22 11
23 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     b9 <cache_close+0x24>
callq  b2 <cache_close+0x1d>
movq   $0x0,(%rbx)
add    $0x8,%rbx
cmp    %rbp,%rbx
jne    a5 <cache_close+0x10>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cache_close(void)
{
 int i;
 for (i = 1; i < 4; i++) {
  if (assoc[i]) {
   assoc_close(assoc[i]);
   assoc[i] = ((void *)0);
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 7
11 7
12 4
13 4
14 10
15 10
16 10
17 10
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  1d7 <swacfl_get_archive_name+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swacfl_get_archive_name(swacfl_entry * en)
{
 return strob_str(en->archiveNameM);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
jne    a9 <_auth_lb_grow+0x34>
mov    %rdx,%rdi
callq  98 <_auth_lb_grow+0x23>
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jmp    d2 <_auth_lb_grow+0x5d>
mov    0x8(%rbx),%rax
mov    %rax,%rdx
sub    0x10(%rbx),%rdx
cmp    %rdx,%rbp
jbe    da <_auth_lb_grow+0x65>
lea    0x0(%rbp,%rax,1),%r13
mov    %r13,%rsi
callq  c6 <_auth_lb_grow+0x51>
mov    %rax,(%rbx)
test   %rax,%rax
je     f4 <_auth_lb_grow+0x7f>
mov    %r13,0x8(%rbx)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     fb <_auth_lb_grow+0x86>
add    0x10(%rbx),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
callq  e9 <_auth_lb_grow+0x74>
add    %rbp,0x10(%rbx)
mov    $0x0,%eax
jmp    100 <_auth_lb_grow+0x8b>
mov    $0xc,%eax
jmp    100 <_auth_lb_grow+0x8b>
mov    $0xc,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 5
13 5
14 5
15 6
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 11
24 12
25 12
26 12
27 13
28 13
29 14
30 16
31 16
32 16
33 18
34 18
35 18
36 18
37 19
38 20
39 20
40 17
41 17
42 17
43 21
44 21
45 21
46 21
47 21
48 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  695 <dstrcspn+0x9>
sub    $0x1,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dstrcspn (string, charset)
     DStr_string_descriptor *string;
     DStr_string_descriptor *charset;
{
  return dstrpbrk (string, charset) - 1;
  }
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x9,%edx
callq  1578 <ea_tab_insert+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ea_tab_insert (WINDOW *window, int count)
{
  ea_insert (window, count, '\t');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1cdc <unmessage_in_echo_area+0x9>
mov    0x0(%rip),%rax        # 1ce3 <unmessage_in_echo_area+0x10>
test   %rax,%rax
je     1d05 <unmessage_in_echo_area+0x32>
sub    $0x1,%rax
mov    %rax,0x0(%rip)        # 1cf3 <unmessage_in_echo_area+0x20>
mov    0x0(%rip),%rdx        # 1cfa <unmessage_in_echo_area+0x27>
mov    (%rdx,%rax,8),%rax
mov    %rax,0x0(%rip)        # 1d05 <unmessage_in_echo_area+0x32>
mov    0x0(%rip),%rsi        # 1d0c <unmessage_in_echo_area+0x39>
mov    0x0(%rip),%rdi        # 1d13 <unmessage_in_echo_area+0x40>
callq  1d18 <unmessage_in_echo_area+0x45>
mov    0x0(%rip),%rdi        # 1d1f <unmessage_in_echo_area+0x4c>
callq  1d24 <unmessage_in_echo_area+0x51>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
unmessage_in_echo_area (void)
{
  free_echo_area ();
  if (old_echo_area_nodes_index)
    echo_area_node = old_echo_area_nodes[--old_echo_area_nodes_index];
  window_set_node_of_window (the_echo_area, echo_area_node);
  display_update_one_window (the_echo_area);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     14b <report_difference+0x57>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%rbx
test   %rsi,%rsi
je     1c1 <report_difference+0xcd>
mov    0x8(%rdi),%rdi
callq  15c <report_difference+0x68>
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 16b <report_difference+0x77>
mov    $0x0,%eax
callq  175 <report_difference+0x81>
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 1ab <report_difference+0xb7>
callq  1b0 <report_difference+0xbc>
mov    0x0(%rip),%rsi        # 1b7 <report_difference+0xc3>
mov    $0xa,%edi
callq  1c1 <report_difference+0xcd>
mov    $0x1,%edi
callq  1cb <report_difference+0xd7>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
report_difference (struct tar_stat_info *st, const char *fmt, ...)
{
  if (fmt)
    {
      va_list ap;
      fprintf (stdlis, "%s: ", quotearg_colon (st->file_name));
      __builtin_va_start(ap,fmt);
      vfprintf (stdlis, fmt, ap);
      __builtin_va_end(ap);
      fprintf (stdlis, "\n");
    }
  set_exit_status (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 3
19 3
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 8
36 8
37 10
38 10
39 10
40 12
41 12
42 13
43 13
44 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     502 <gsasl_server_callback_maxbuf_get+0xd>
mov    0xc8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_maxbuf_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_maxbuf : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1,%eax
cmove  %rax,%rsi
mov    %rsi,0x8(%rdi)
mov    $0x8,%ecx
movabs $0x9c4e3aa71ae25487,%r8
mov    %rsi,%rax
mul    %r8
shr    $0xf,%rdx
imul   $0xffffffffffff2e5c,%rdx,%rax
add    %rax,%rsi
imul   $0x9c4e,%rsi,%rsi
imul   $0xffffffffffffd04d,%rdx,%rax
add    %rax,%rsi
lea    0x7fffffab(%rsi),%rax
test   %rsi,%rsi
cmovs  %rax,%rsi
sub    $0x1,%ecx
jne    e1 <ran2_set+0x1f>
mov    $0x0,%ecx
movabs $0x9c4e3aa71ae25487,%r8
mov    %rsi,%rax
mul    %r8
shr    $0xf,%rdx
imul   $0xffffffffffff2e5c,%rdx,%rax
add    %rax,%rsi
imul   $0x9c4e,%rsi,%rsi
imul   $0xffffffffffffd04d,%rdx,%rax
add    %rax,%rsi
mov    %rsi,%rdx
lea    0x7fffffab(%rsi),%rax
test   %rsi,%rsi
cmovs  %rax,%rdx
mov    %rdx,%rsi
mov    %rdx,0x110(%rdi,%rcx,1)
sub    $0x8,%rcx
cmp    $0xffffffffffffff00,%rcx
jne    128 <ran2_set+0x66>
mov    %rdx,(%rdi)
mov    %rdx,0x10(%rdi)
retq   
<<<sep_in_sample>>>
ran2_set (void *vstate, unsigned long int s)
{
  ran2_state_t *state = (ran2_state_t *) vstate;
  int i;
  if (s == 0)
    s = 1;
  state->y = s;
  for (i = 0; i < 8; i++)
    {
      long int h = s / q1;
      long int t = a1 * (s - h * q1) - h * r1;
      if (t < 0)
        t += m1;
      s = t;
    }
  for (i = 32 - 1; i >= 0; i--)
    {
      long int h = s / q1;
      long int t = a1 * (s - h * q1) - h * r1;
      if (t < 0)
        t += m1;
      s = t;
      state->shuffle[i] = s;
    }
  state->x = s;
  state->n = s;
  return;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 10
7 10
8 10
9 10
10 11
11 11
12 11
13 11
14 12
15 13
16 13
17 14
18 8
19 8
20 8
21 18
22 18
23 18
24 18
25 19
26 19
27 19
28 19
29 20
30 20
31 21
32 21
33 21
34 22
35 23
36 23
37 16
38 16
39 25
40 26
41 26
<<<sep_out_sample>>>
jmp    43 <job_next_command+0x43>
mov    0x30(%rdi),%eax
mov    0x8(%rdi),%rdx
mov    0x20(%rdx),%rcx
movzwl 0x30(%rcx),%ecx
cmp    %ecx,%eax
jne    2f <job_next_command+0x2f>
movq   $0x0,0x28(%rdi)
mov    0x20(%rdx),%rax
movq   $0x0,0x10(%rax)
mov    $0x0,%eax
retq   
mov    0x20(%rdi),%rdx
lea    0x1(%rax),%ecx
mov    %ecx,0x30(%rdi)
mov    %eax,%eax
mov    (%rdx,%rax,8),%rax
mov    %rax,0x28(%rdi)
mov    0x28(%rdi),%rax
test   %rax,%rax
je     2 <job_next_command+0x2>
cmpb   $0x0,(%rax)
je     2 <job_next_command+0x2>
mov    0x8(%rdi),%rax
mov    0x20(%rax),%rax
mov    0x30(%rdi),%edx
sub    $0x1,%edx
mov    %edx,%esi
mov    %rsi,0x10(%rax)
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
job_next_command (struct child *child)
{
  while (child->command_ptr == 0 || *child->command_ptr == '\0')
    {
      if (child->command_line == child->file->cmds->ncommand_lines)
        {
          child->command_ptr = 0;
          child->file->cmds->fileinfo.offset = 0;
          return 0;
        }
      else
        child->command_ptr = child->command_lines[child->command_line++];
    }
  child->file->cmds->fileinfo.offset = child->command_line - 1;
  return 1;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 8
10 8
11 9
12 9
13 12
14 12
15 12
16 12
17 12
18 12
19 3
20 3
21 3
22 3
23 3
24 14
25 14
26 14
27 14
28 14
29 14
30 15
31 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
callq  abea <gsl_fft_halfcomplex_inverse+0x12>
test   %eax,%eax
jne    ac4b <gsl_fft_halfcomplex_inverse+0x73>
test   %rbx,%rbx
js     abfa <gsl_fft_halfcomplex_inverse+0x22>
cvtsi2sd %rbx,%xmm0
jmp    ac12 <gsl_fft_halfcomplex_inverse+0x3a>
mov    %rbx,%rdx
shr    %rdx
mov    %rbx,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
movsd  0x0(%rip),%xmm1        # ac1a <gsl_fft_halfcomplex_inverse+0x42>
divsd  %xmm0,%xmm1
test   %rbx,%rbx
je     ac4b <gsl_fft_halfcomplex_inverse+0x73>
lea    0x0(,%r12,8),%rsi
mov    %rbp,%rdi
mov    $0x0,%ecx
movapd %xmm1,%xmm0
mulsd  (%rdi),%xmm0
movsd  %xmm0,(%rdi)
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    ac33 <gsl_fft_halfcomplex_inverse+0x5b>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_fft_halfcomplex_inverse (double data[], const size_t stride,
                                       const size_t n,
                                       const gsl_fft_halfcomplex_wavetable * wavetable,
                                       gsl_fft_real_workspace * work)
{
  int status = gsl_fft_halfcomplex_transform (data, stride, n, wavetable, work);
  if (status)
    {
      return status;
    }
  {
    const double norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        data[stride*i] *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 7
9 7
10 12
11 12
12 12
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 14
24 14
25 16
26 16
27 14
28 16
29 16
30 16
31 14
32 14
33 14
34 14
35 20
36 20
37 20
38 20
<<<sep_out_sample>>>
mov    %esi,0x60(%rdi)
retq   
<<<sep_in_sample>>>
swicol_set_task_debug(SWICOL * swicol, int do_debug)
{
 swicol->debug_task_scriptsM = do_debug;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 3c <removeViewer+0x7>
test   %rdx,%rdx
je     b2 <removeViewer+0x7d>
cmp    %rdi,%rdx
jne    a6 <removeViewer+0x71>
jmp    66 <removeViewer+0x31>
cmp    %rax,%rdi
nopl   0x0(%rax,%rax,1)
je     57 <removeViewer+0x22>
mov    %rax,%rdx
jmp    a6 <removeViewer+0x71>
test   %rdx,%rdx
je     6d <removeViewer+0x38>
mov    0x10(%rax),%rcx
mov    %rcx,0x10(%rdx)
jmp    83 <removeViewer+0x4e>
mov    $0x0,%ecx
jmp    73 <removeViewer+0x3e>
mov    %rdx,%rcx
mov    %rax,%rdx
mov    (%rdx),%rax
mov    %rax,0x0(%rip)        # 7d <removeViewer+0x48>
mov    %rdx,%rax
mov    %rcx,%rdx
mov    0x10(%rax),%rax
test   %rax,%rax
je     92 <removeViewer+0x5d>
mov    %rdx,0x18(%rax)
jmp    99 <removeViewer+0x64>
mov    %rdx,0x0(%rip)        # 99 <removeViewer+0x64>
subl   $0x1,0x0(%rip)        # a0 <removeViewer+0x6b>
mov    $0x0,%eax
retq   
mov    0x10(%rdx),%rax
test   %rax,%rax
jne    48 <removeViewer+0x13>
mov    $0x1,%al
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
removeViewer ( viewer *v )
{
 viewer *cur, *last = ((void *)0);
 for (cur=vl_head; cur != ((void *)0); cur=cur->vl_next) {
  if (cur == v) {
   if (last) {
    last->vl_next = cur->vl_next;
   }
   else {
    vl_head = cur->next;
   }
   if (cur->vl_next) {
    cur->vl_next->vl_prev = last;
   }
   else {
    vl_tail = last;
   }
   -- vl_count;
   return 0;
  }
  last = cur;
 }
 return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 4
11 4
12 6
13 6
14 7
15 7
16 7
17 3
18 3
19 3
20 4
21 10
22 10
23 10
24 10
25 12
26 12
27 12
28 13
29 13
30 16
31 18
32 19
33 19
34 4
35 4
36 4
37 23
38 23
39 23
40 24
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%ebp
mov    %r12,%rdi
callq  29b <skip_whitespace+0x14>
mov    %eax,%ebx
cmp    $0xa,%eax
jne    2a7 <skip_whitespace+0x20>
add    $0x1,%ebp
jmp    2ac <skip_whitespace+0x25>
cmp    $0xffffffff,%eax
je     2dc <skip_whitespace+0x55>
nopl   0x0(%rax)
callq  2b5 <skip_whitespace+0x2e>
movzbl %bl,%edx
mov    (%rax),%rax
testb  $0x20,0x1(%rax,%rdx,2)
je     2c7 <skip_whitespace+0x40>
cmp    $0x1,%ebp
jle    293 <skip_whitespace+0xc>
mov    %r12,%rsi
mov    %ebx,%edi
callq  2d1 <skip_whitespace+0x4a>
cmp    $0x2,%ebp
sete   %al
movzbl %al,%eax
jmp    2e1 <skip_whitespace+0x5a>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
skip_whitespace (FILE *stream)
{
  int lookahead;
  int nlcount = 0;
  do
    {
      lookahead = _IO_getc (stream);
      if (lookahead == (int)'\n')
   nlcount++;
    }
  while (lookahead != (-1)
  && ((*__ctype_b_loc ())[(int) (((unsigned char)lookahead))] & (unsigned short int) _ISspace)
  && nlcount < 2);
  if (lookahead == (-1))
    return false;
  ungetc (lookahead, stream);
  return (nlcount == 2 ? true : false);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 7
7 7
8 7
9 8
10 8
11 9
12 9
13 13
14 13
15 13
16 12
17 12
18 12
19 12
20 12
21 13
22 13
23 16
24 16
25 16
26 17
27 17
28 17
29 17
30 15
31 18
32 18
33 18
34 18
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %esi,%ebp
mov    0x40(%rdi),%rdi
test   %rdi,%rdi
je     b5 <CDB___ram_ca_delete+0x1d>
testb  $0x1,0x68(%rdi)
jne    b5 <CDB___ram_ca_delete+0x1d>
callq  b5 <CDB___ram_ca_delete+0x1d>
mov    0xa0(%r12),%rbx
test   %rbx,%rbx
je     e5 <CDB___ram_ca_delete+0x4d>
mov    0xe8(%rbx),%rax
cmp    %ebp,0x10(%rax)
jne    dc <CDB___ram_ca_delete+0x44>
jmp    e5 <CDB___ram_ca_delete+0x4d>
mov    0xe8(%rbx),%rax
cmp    %ebp,0x10(%rax)
je     e5 <CDB___ram_ca_delete+0x4d>
mov    0x10(%rbx),%rbx
test   %rbx,%rbx
jne    d0 <CDB___ram_ca_delete+0x38>
mov    0x40(%r12),%rdi
test   %rdi,%rdi
je     fa <CDB___ram_ca_delete+0x62>
testb  $0x1,0x68(%rdi)
jne    fa <CDB___ram_ca_delete+0x62>
callq  fa <CDB___ram_ca_delete+0x62>
test   %rbx,%rbx
setne  %al
movzbl %al,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
CDB___ram_ca_delete(dbp, root_pgno)
 DB *dbp;
 db_pgno_t root_pgno;
{
 DBC *dbc;
 if (dbp->mutexp != ((void *)0)) if (!(((MUTEX *)(dbp->mutexp))->flags & (0x001))) (void)__db_pthread_mutex_lock(dbp->mutexp);;
 for (dbc = ((&dbp->active_queue)->tqh_first);
     dbc != ((void *)0); dbc = ((dbc)->links.tqe_next))
  if (dbc->internal->root == root_pgno)
   break;
 if (dbp->mutexp != ((void *)0)) if (!(((MUTEX *)(dbp->mutexp))->flags & (0x001))) (void)__db_pthread_mutex_unlock(dbp->mutexp);;
 return (dbc == ((void *)0) ? 0 : 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 8
23 7
24 7
25 11
26 11
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 13
35 13
36 13
37 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %esi,%ebx
test   %esi,%esi
js     5104 <info_global_next_node+0x15>
test   %esi,%esi
jne    5112 <info_global_next_node+0x23>
jmp    5128 <info_global_next_node+0x39>
neg    %esi
callq  510b <info_global_next_node+0x1c>
nopl   0x0(%rax,%rax,1)
jmp    5128 <info_global_next_node+0x39>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  397d <forward_move_node_structure>
test   %eax,%eax
jne    5128 <info_global_next_node+0x39>
sub    $0x1,%ebx
jne    5112 <info_global_next_node+0x23>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
info_global_next_node (WINDOW *window, int count)
{
  if (count < 0)
    info_global_prev_node (window, -count);
  else
    {
      while (count)
        {
          if (forward_move_node_structure (window, 0))
            break;
          count--;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 7
9 7
10 7
11 4
12 4
13 4
14 4
15 9
16 9
17 9
18 9
19 9
20 7
21 7
22 14
23 14
24 14
25 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rdx,%rbx
movq   $0x0,(%rdi)
cmpq   $0x0,0xe0(%rdx)
je     e9f <osip_dialog_init_as_uas+0x6a>
mov    0x158(%rdx),%rcx
mov    %rsi,%r9
mov    0xf8(%rdx),%r8
callq  89c <__osip_dialog_init>
test   %eax,%eax
je     e76 <osip_dialog_init_as_uas+0x41>
movq   $0x0,0x0(%rbp)
jmp    ea4 <osip_dialog_init_as_uas+0x6f>
mov    0x0(%rbp),%rax
movl   $0x1,0x54(%rax)
mov    0x0(%rbp),%rbp
mov    0xe0(%rbx),%rax
mov    0x8(%rax),%rdi
callq  e95 <osip_dialog_init_as_uas+0x60>
mov    %eax,0x34(%rbp)
mov    $0x0,%eax
jmp    ea4 <osip_dialog_init_as_uas+0x6f>
mov    $0xfffffffb,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_dialog_init_as_uas (osip_dialog_t ** dialog, osip_message_t * invite, osip_message_t * response)
{
  int i;
  *dialog = ((void *)0);
  if (response->cseq == ((void *)0))
    return -5;
  i = __osip_dialog_init (dialog, invite, response, response->to, response->from, invite);
  if (i != 0) {
    *dialog = ((void *)0);
    return i;
  }
  (*dialog)->type = CALLEE;
  (*dialog)->remote_cseq = osip_atoi (response->cseq->number);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 9
16 10
17 12
18 12
19 13
20 13
21 13
22 13
23 13
24 14
25 14
26 6
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
jmpq   6cc <print_name_with_quoting+0x11a>
cmp    $0xc,%sil
je     674 <print_name_with_quoting+0xc2>
cmp    $0xc,%sil
ja     5e7 <print_name_with_quoting+0x35>
cmp    $0x9,%sil
je     663 <print_name_with_quoting+0xb1>
cmp    $0xa,%sil
je     62d <print_name_with_quoting+0x7b>
cmp    $0x8,%sil
jne    6a7 <print_name_with_quoting+0xf5>
jmp    641 <print_name_with_quoting+0x8f>
cmp    $0x20,%sil
je     685 <print_name_with_quoting+0xd3>
cmp    $0x20,%sil
ja     605 <print_name_with_quoting+0x53>
cmp    $0xd,%sil
je     652 <print_name_with_quoting+0xa0>
nopl   (%rax)
jmpq   6a7 <print_name_with_quoting+0xf5>
cmp    $0x22,%sil
je     696 <print_name_with_quoting+0xe4>
cmp    $0x5c,%sil
jne    6a7 <print_name_with_quoting+0xf5>
mov    $0x0,%edi
mov    $0x0,%eax
callq  628 <print_name_with_quoting+0x76>
jmpq   6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  63c <print_name_with_quoting+0x8a>
jmpq   6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  650 <print_name_with_quoting+0x9e>
jmp    6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  661 <print_name_with_quoting+0xaf>
jmp    6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  672 <print_name_with_quoting+0xc0>
jmp    6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  683 <print_name_with_quoting+0xd1>
jmp    6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  694 <print_name_with_quoting+0xe2>
jmp    6cc <print_name_with_quoting+0x11a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  6a5 <print_name_with_quoting+0xf3>
jmp    6cc <print_name_with_quoting+0x11a>
lea    -0x21(%rsi),%eax
cmp    $0x5d,%al
ja     6b9 <print_name_with_quoting+0x107>
movzbl %sil,%edi
callq  6b7 <print_name_with_quoting+0x105>
jmp    6cc <print_name_with_quoting+0x11a>
movzbl %sil,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  6cc <print_name_with_quoting+0x11a>
add    $0x1,%rbx
movzbl -0x1(%rbx),%esi
test   %sil,%sil
jne    5bb <print_name_with_quoting+0x9>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_name_with_quoting (register char *p)
{
  register unsigned char c;
  while ( (c = *p++) )
    {
      switch (c)
 {
 case '\\':
   printf ("\\\\");
   break;
 case '\n':
   printf ("\\n");
   break;
 case '\b':
   printf ("\\b");
   break;
 case '\r':
   printf ("\\r");
   break;
 case '\t':
   printf ("\\t");
   break;
 case '\f':
   printf ("\\f");
   break;
 case ' ':
   printf ("\\ ");
   break;
 case '"':
   printf ("\\\"");
   break;
 default:
   if (c > 040 && c < 0177)
     putchar_unlocked (c);
   else
     printf ("\\%03o", (unsigned int) c);
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 9
28 9
29 9
30 10
31 12
32 12
33 12
34 13
35 15
36 15
37 15
38 16
39 18
40 18
41 18
42 19
43 21
44 21
45 21
46 22
47 24
48 24
49 24
50 25
51 27
52 27
53 27
54 28
55 30
56 30
57 30
58 31
59 33
60 33
61 33
62 34
63 34
64 34
65 36
66 36
67 36
68 36
69 4
70 4
71 4
72 4
73 39
74 39
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     258 <canon_doc_option+0x61>
callq  206 <canon_doc_option+0xf>
mov    %rax,%r8
jmp    212 <canon_doc_option+0x1b>
add    $0x1,%rdx
mov    %rdx,(%rbx)
mov    (%r8),%rsi
mov    (%rbx),%rdx
movzbl (%rdx),%ecx
movzbl %cl,%edi
testb  $0x20,0x1(%rsi,%rdi,2)
jne    20b <canon_doc_option+0x14>
cmp    $0x2d,%cl
setne  %al
movzbl %al,%eax
test   %cl,%cl
je     25d <canon_doc_option+0x66>
testb  $0x8,(%rsi,%rdi,2)
jne    25d <canon_doc_option+0x66>
add    $0x1,%rdx
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
je     25d <canon_doc_option+0x66>
add    $0x1,%rdx
movzbl %cl,%ecx
mov    (%r8),%rsi
testb  $0x8,(%rsi,%rcx,2)
je     23c <canon_doc_option+0x45>
jmp    25d <canon_doc_option+0x66>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 8
6 8
7 8
8 9
9 9
10 8
11 8
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 12
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 5
35 15
36 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %edx,%r12d
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdi
mov    $0x2,%edx
callq  14f <send_page+0x2c>
mov    %rax,%rbx
mov    $0x0,%eax
test   %rbx,%rbx
je     188 <send_page+0x65>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  16e <send_page+0x4b>
mov    %rbx,%rdx
mov    %r12d,%esi
mov    %rbp,%rdi
callq  17c <send_page+0x59>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  186 <send_page+0x63>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
send_page (struct MHD_Connection *connection,
           const char *page,
           int status_code)
{
  int ret;
  struct MHD_Response *response;
  response =
    MHD_create_response_from_buffer (strlen (page),
                                     (void *) page,
         MHD_RESPMEM_MUST_COPY);
  if (!response)
    return 0;
  MHD_add_response_header (response,
                           "Content-Type",
                           "text/html");
  ret = MHD_queue_response (connection,
                            status_code,
                            response);
  MHD_destroy_response (response);
  return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 7
13 7
14 7
15 12
16 11
17 11
18 13
19 13
20 13
21 13
22 16
23 16
24 16
25 16
26 16
27 19
28 19
29 20
30 21
31 21
32 21
33 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x2,%edi
callq  1a7 <signal_setup+0x13>
mov    $0x0,%esi
mov    $0xf,%edi
callq  1b6 <signal_setup+0x22>
mov    $0x0,%esi
mov    $0x1,%edi
callq  1c5 <signal_setup+0x31>
mov    $0x0,%esi
mov    $0x3,%edi
callq  1d4 <signal_setup+0x40>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
signal_setup(void)
{
        signal(2, suddenly);
        signal(15, suddenly);
        signal(1, suddenly);
        signal(3, suddenly);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
test   %rcx,%rcx
je     1496 <gsl_permute_int_inverse+0x71>
lea    0x0(,%rdx,4),%r11
mov    $0x0,%edx
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    1449 <gsl_permute_int_inverse+0x24>
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     1440 <gsl_permute_int_inverse+0x1b>
cmp    %rax,%rdx
ja     1477 <gsl_permute_int_inverse+0x52>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
jne    1482 <gsl_permute_int_inverse+0x5d>
jmp    1477 <gsl_permute_int_inverse+0x52>
mov    %r9d,%r10d
mov    %r11,%rax
imul   %r8,%rax
add    %rsi,%rax
mov    (%rax),%r9d
mov    %r10d,(%rax)
mov    (%rdi,%r8,8),%r8
cmp    %rdx,%r8
jne    1459 <gsl_permute_int_inverse+0x34>
jmp    148c <gsl_permute_int_inverse+0x67>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    1437 <gsl_permute_int_inverse+0x12>
jmp    1496 <gsl_permute_int_inverse+0x71>
imul   %r11,%rax
mov    (%rsi,%rax,1),%r10d
jmp    145c <gsl_permute_int_inverse+0x37>
imul   %r11,%r8
mov    %r9d,(%rsi,%r8,1)
jmp    1477 <gsl_permute_int_inverse+0x52>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_int_inverse (const size_t * p, int * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        int t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                int r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 18
4 4
5 6
6 7
7 7
8 8
9 7
10 7
11 9
12 9
13 11
14 12
15 12
16 12
17 23
18 23
19 23
20 23
21 23
22 24
23 28
24 19
25 19
26 19
27 4
28 4
29 4
30 4
31 18
32 18
33 18
34 31
35 31
36 31
37 35
38 35
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  12a1 <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
mov    0x48(%rsi),%rbp
sub    0x38(%rsi),%rbp
sar    $0x3,%rbp
movabs $0xcccccccccccccccd,%rax
imul   %rax,%rbp
lea    0x0(%rbp,%rbp,1),%rsi
lea    0x8(%rsp),%rcx
mov    $0x28,%edx
callq  139 <CDB___bam_stkgrow+0x37>
mov    %eax,%edx
test   %edx,%edx
jne    18a <CDB___bam_stkgrow+0x88>
lea    0x0(%rbp,%rbp,4),%rbp
shl    $0x3,%rbp
mov    0x38(%rbx),%rsi
mov    %rbp,%rdx
mov    0x8(%rsp),%rdi
callq  159 <CDB___bam_stkgrow+0x57>
mov    0x38(%rbx),%rdi
lea    0x50(%rbx),%rax
cmp    %rax,%rdi
je     16e <CDB___bam_stkgrow+0x6c>
mov    %rbp,%rsi
callq  16e <CDB___bam_stkgrow+0x6c>
mov    0x8(%rsp),%rax
mov    %rax,0x38(%rbx)
add    %rbp,%rax
mov    %rax,0x40(%rbx)
add    %rax,%rbp
mov    %rbp,0x48(%rbx)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
CDB___bam_stkgrow(dbenv, cp)
 DB_ENV *dbenv;
 BTREE_CURSOR *cp;
{
 EPG *p;
 size_t entries;
 int ret;
 entries = cp->esp - cp->sp;
 if ((ret = CDB___os_calloc(dbenv, entries * 2, sizeof(EPG), &p)) != 0)
  return (ret);
 memcpy(p, cp->sp, entries * sizeof(EPG));
 if (cp->sp != cp->stack)
  CDB___os_free(cp->sp, entries * sizeof(EPG));
 cp->sp = p;
 cp->csp = p + entries;
 cp->esp = p + entries * 2;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 8
6 8
7 8
8 8
9 8
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 12
25 12
26 12
27 13
28 13
29 14
30 14
31 15
32 15
33 16
34 16
35 17
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x78,%rdi
mov    $0xffffffff,%edx
callq  0 <ahsStaticSetTarname_i>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahsStaticSetPaxLinkname(struct new_cpio_header * file_hdr, char * name)
{
 ;
 ahsStaticSetTarname_i((STROB**)&(file_hdr->c_tar_linkname), name, -1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,(%rsp)
mov    %rdx,%r13
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
test   %r13,%r13
je     4c <mkfilename+0x4c>
mov    %r13,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
mov    %rax,0x8(%rsp)
jmp    55 <mkfilename+0x55>
movq   $0x0,0x8(%rsp)
mov    (%rsp),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r14
test   %rdx,%rdx
je     95 <mkfilename+0x95>
lea    -0x1(%rdx),%rbx
cmpb   $0x2f,-0x1(%rbp,%rdx,1)
je     8e <mkfilename+0x8e>
jmp    9a <mkfilename+0x9a>
lea    -0x1(%rbx),%rax
cmpb   $0x2f,-0x1(%rbp,%rbx,1)
jne    9d <mkfilename+0x9d>
mov    %rax,%rbx
test   %rbx,%rbx
jne    80 <mkfilename+0x80>
jmp    9d <mkfilename+0x9d>
mov    %rdx,%rbx
jmp    9d <mkfilename+0x9d>
mov    %rdx,%rbx
mov    0x8(%rsp),%rax
lea    (%rax,%r14,1),%r15
cmpb   $0x0,0x0(%rbp)
setne  %al
movzbl %al,%eax
add    %rax,%r15
add    %rbx,%r15
lea    0x1(%r15),%rdi
callq  bf <mkfilename+0xbf>
mov    %rax,%r12
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  d0 <mkfilename+0xd0>
cmpb   $0x0,0x0(%rbp)
je     df <mkfilename+0xdf>
movb   $0x2f,(%r12,%rbx,1)
lea    0x1(%rbx),%rbx
lea    (%r12,%rbx,1),%rdi
mov    %r14,%rdx
mov    (%rsp),%rsi
callq  ef <mkfilename+0xef>
test   %r13,%r13
je     108 <mkfilename+0x108>
add    %r14,%rbx
lea    (%r12,%rbx,1),%rdi
mov    0x8(%rsp),%rdx
mov    %r13,%rsi
callq  108 <mkfilename+0x108>
movb   $0x0,(%r12,%r15,1)
mov    %r12,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
mkfilename (const char *dir, const char *file, const char *suf)
{
  char *tmp;
  size_t dirlen = strlen (dir);
  size_t suflen = suf ? strlen (suf) : 0;
  size_t fillen = strlen (file);
  size_t len;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  len = dirlen + (dir[0] ? 1 : 0) + fillen + suflen;
  tmp = emalloc (len + 1);
  memcpy (tmp, dir, dirlen);
  if (dir[0])
    tmp[dirlen++] = '/';
  memcpy (tmp + dirlen, file, fillen);
  if (suf)
    memcpy (tmp + dirlen + fillen, suf, suflen);
  tmp[len] = 0;
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 6
31 6
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 4
46 4
47 4
48 10
49 10
50 10
51 10
52 10
53 10
54 10
55 11
56 11
57 11
58 12
59 12
60 12
61 12
62 13
63 13
64 14
65 14
66 15
67 15
68 15
69 15
70 16
71 16
72 17
73 17
74 17
75 17
76 17
77 18
78 20
79 20
80 20
81 20
82 20
83 20
84 20
85 20
86 20
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
add    $0x28,%rdi
mov    0x40(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x0(%rip),%rsi        # 105 <nettle_ccm_aes256_encrypt_message+0x3d>
callq  10a <nettle_ccm_aes256_encrypt_message+0x42>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,
      size_t nlength, const uint8_t *nonce,
      size_t alength, const uint8_t *adata,
      size_t tlength,
      size_t clength, uint8_t *dst, const uint8_t *src)
{
  nettle_ccm_encrypt_message(&ctx->cipher, (nettle_cipher_func *) nettle_aes256_encrypt,
        nlength, nonce, alength, adata,
        tlength, clength, dst, src);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  5be1 <close_pgrp_pipe+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
close_pgrp_pipe ()
{
  sh_closepipe (pgrp_pipe);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 32e <gsl_vector_ptr+0x7>
je     359 <gsl_vector_ptr+0x32>
cmp    %rsi,(%rdi)
ja     359 <gsl_vector_ptr+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  352 <gsl_vector_ptr+0x2b>
mov    $0x0,%eax
jmp    36d <gsl_vector_ptr+0x46>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rax,%rsi
mov    %rsi,%rax
add    0x10(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_ptr (gsl_vector * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_double.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (double *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2881 <info_namelist_free+0x19>
push   %rbx
mov    (%rdi),%rbx
callq  2876 <info_namelist_free+0xe>
test   %rbx,%rbx
je     2880 <info_namelist_free+0x18>
mov    %rbx,%rdi
jmp    286e <info_namelist_free+0x6>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
info_namelist_free (struct info_namelist_entry *top)
{
  while (top)
    {
      struct info_namelist_entry *next = top->next;
      free (top);
      top = next;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 6
6 3
7 3
8 7
9 7
10 9
11 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rcx,%r12
mov    %r8,%rbp
lea    0x8(%rsp),%r8
mov    %rsp,%rcx
callq  1d <_gsasl_step+0x1d>
mov    %eax,%ebx
cmp    $0x1,%ebx
ja     62 <_gsasl_step+0x62>
mov    0x8(%rsp),%r13
cmp    %r13,0x0(%rbp)
ja     3f <_gsasl_step+0x3f>
mov    (%rsp),%rdi
callq  38 <_gsasl_step+0x38>
mov    $0x4,%eax
jmp    62 <_gsasl_step+0x62>
test   %r12,%r12
je     53 <_gsasl_step+0x53>
mov    %r13,%rdx
mov    (%rsp),%rsi
mov    %r12,%rdi
callq  53 <_gsasl_step+0x53>
mov    %r13,0x0(%rbp)
mov    (%rsp),%rdi
callq  60 <_gsasl_step+0x60>
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_gsasl_step (Gsasl_session * sctx,
      const char *input, size_t input_len,
      char *output, size_t * output_len)
{
  char *tmp;
  size_t tmplen;
  int rc;
  rc = gsasl_step (sctx, input, input_len, &tmp, &tmplen);
  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)
    {
      if (tmplen >= *output_len)
 {
   free (tmp);
   return GSASL_TOO_SMALL_BUFFER;
 }
      if (output)
 memcpy (output, tmp, tmplen);
      *output_len = tmplen;
      free (tmp);
    }
  return rc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 8
11 8
12 9
13 9
14 11
15 11
16 11
17 13
18 13
19 14
20 14
21 16
22 16
23 17
24 17
25 17
26 17
27 18
28 19
29 19
30 21
31 22
32 22
33 22
34 22
35 22
36 22
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
mov    %rsp,%rsi
callq  870 <mu_url_is_same_port+0x21>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  87d <mu_url_is_same_port+0x2e>
mov    0x8(%rsp),%rax
cmp    %rax,(%rsp)
sete   %al
movzbl %al,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_url_is_same_port (mu_url_t url1, mu_url_t url2)
{
  long p1 = 0, p2 = 0;
  mu_url_get_port (url1, &p1);
  mu_url_get_port (url2, &p2);
  return (p1 == p2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 7
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
mov    $0xffffffff,%eax
cmpl   $0x0,0x0(%rip)        # 2f2 <tteightbit+0x20>
je     35e <tteightbit+0x8c>
mov    0x0(%rip),%rax        # 2fb <tteightbit+0x29>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 306 <tteightbit+0x34>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 312 <tteightbit+0x40>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 31e <tteightbit+0x4c>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 32a <tteightbit+0x58>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 336 <tteightbit+0x64>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 342 <tteightbit+0x70>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%eax        # 34d <tteightbit+0x7b>
mov    %eax,0x38(%rsp)
mov    %rsp,%rsi
mov    $0x0,%edi
callq  35e <tteightbit+0x8c>
mov    0x48(%rsp),%rdx
xor    %fs:0x28,%rdx
je     373 <tteightbit+0xa1>
callq  373 <tteightbit+0xa1>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
tteightbit ()
{
  struct termios tt;
  if (ttsaved == 0)
    return -1;
  tt = ttin;
  return (ttfd_eightbit (0, &tt));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 8
28 8
29 8
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
cmpb   $0x0,(%rdx)
jne    49c <revstrpbrk+0x1b>
cmp    %rdi,%rdx
je     4bc <revstrpbrk+0x3b>
sub    $0x1,%rbx
cmp    %rbx,%rbp
ja     4c3 <revstrpbrk+0x42>
movsbl (%rbx),%esi
mov    %r12,%rdi
callq  4ac <revstrpbrk+0x2b>
test   %rax,%rax
jne    4ca <revstrpbrk+0x49>
sub    $0x1,%rbx
cmp    %rbx,%rbp
jbe    4a1 <revstrpbrk+0x20>
jmp    4cd <revstrpbrk+0x4c>
mov    $0x0,%eax
jmp    4cd <revstrpbrk+0x4c>
mov    $0x0,%eax
jmp    4cd <revstrpbrk+0x4c>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
revstrpbrk(const char *s, const char *accept, const char
 *rev_start)
{
    ((void) (0));
    if (*rev_start == '\0') {
 if (rev_start == s)
    return ((void *)0);
 rev_start--;
    }
    for (; rev_start >= s; rev_start--) {
 if (strchr(accept, *rev_start) != ((void *)0))
     return (char *)rev_start;
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 6
10 6
11 8
12 10
13 10
14 11
15 11
16 11
17 11
18 11
19 10
20 10
21 10
22 10
23 7
24 7
25 14
26 14
27 14
28 15
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     1d3 <gsl_eigen_symmv_free+0x35>
mov    0x20(%rdi),%rdi
callq  1b0 <gsl_eigen_symmv_free+0x12>
mov    0x18(%rbx),%rdi
callq  1b9 <gsl_eigen_symmv_free+0x1b>
mov    0x10(%rbx),%rdi
callq  1c2 <gsl_eigen_symmv_free+0x24>
mov    0x8(%rbx),%rdi
callq  1cb <gsl_eigen_symmv_free+0x2d>
mov    %rbx,%rdi
callq  1d3 <gsl_eigen_symmv_free+0x35>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_eigen_symmv_free (gsl_eigen_symmv_workspace * w)
{
  if (!w) { return ; };
  free(w->gs);
  free(w->gc);
  free(w->sd);
  free(w->d);
  free(w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     2bfd <gsl_vector_ushort_free+0x20>
cmpl   $0x0,0x20(%rdi)
je     2bf5 <gsl_vector_ushort_free+0x18>
mov    0x18(%rdi),%rdi
callq  2bf5 <gsl_vector_ushort_free+0x18>
mov    %rbx,%rdi
callq  2bfd <gsl_vector_ushort_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_ushort_free (gsl_vector_ushort * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_ushort_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     185 <gsl_combination_free+0x21>
cmpq   $0x0,0x8(%rdi)
je     17d <gsl_combination_free+0x19>
mov    0x10(%rdi),%rdi
callq  17d <gsl_combination_free+0x19>
mov    %rbx,%rdi
callq  185 <gsl_combination_free+0x21>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_combination_free (gsl_combination * c)
{
  if (!c) { return ; };
  if (c->k > 0) free (c->data);
  free (c);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
movsd  0x0(%rip),%xmm1        # 118 <timeDoubleToDIS+0xb>
callq  11d <timeDoubleToDIS+0x10>
mulsd  0x0(%rip),%xmm0        # 125 <timeDoubleToDIS+0x18>
ucomisd 0x0(%rip),%xmm0        # 12d <timeDoubleToDIS+0x20>
jae    136 <timeDoubleToDIS+0x29>
cvttsd2si %xmm0,%rdx
jmp    150 <timeDoubleToDIS+0x43>
subsd  0x0(%rip),%xmm0        # 13e <timeDoubleToDIS+0x31>
cvttsd2si %xmm0,%rdx
movabs $0x8000000000000000,%rax
xor    %rax,%rdx
mov    %edx,%ecx
and    $0x7fffffff,%ecx
cmp    $0x7fffffff,%rdx
mov    $0x7fffffff,%eax
cmovbe %ecx,%eax
shl    $0x1f,%ebx
or     %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
timeDoubleToDIS(double time, int reference)
{
 unsigned long tmp;
 dis_timestamp res;
 tmp = (unsigned long) (fmod(time, 3600.0) * timeFactor);
 if (tmp > 2147483647L)
  res.time = 2147483647L;
 else
  res.time = tmp;
 res.type = reference;
 return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 12
22 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpb   $0x0,(%rsi)
je     1d5 <strbuf_puts+0x44>
mov    0x10(%rbx),%rax
cmp    %rax,0x18(%rbx)
jb     1b9 <strbuf_puts+0x28>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1b9 <strbuf_puts+0x28>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
add    $0x1,%rbp
movzbl -0x1(%rbp),%edx
mov    %dl,(%rax)
cmpb   $0x0,0x0(%rbp)
jne    1a2 <strbuf_puts+0x11>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
strbuf_puts(STRBUF *sb, const char *s)
{
 while (*s) {
  if (sb->curp >= sb->endp)
   __strbuf_expandbuf(sb, 0);
  *sb->curp++ = *s++;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 3
21 3
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
test   %edi,%edi
je     278 <gsasl_randomize+0x18>
mov    %rdx,%rsi
mov    %rax,%rdi
callq  276 <gsasl_randomize+0x16>
jmp    283 <gsasl_randomize+0x23>
mov    %rdx,%rsi
mov    %rax,%rdi
callq  283 <gsasl_randomize+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_randomize (int strong, char *data, size_t datalen)
{
  if (strong)
    return gsasl_random (data, datalen);
  return gsasl_nonce (data, datalen);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x8(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  da <compare_tags+0x19>
mov    %eax,%edx
test   %edx,%edx
jne    e6 <compare_tags+0x25>
mov    0x18(%rbp),%eax
sub    0x18(%rbx),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
compare_tags(const void *v1, const void *v2)
{
 const GTP *e1 = v1, *e2 = v2;
 int ret;
 if ((ret = strcmp(e1->path, e2->path)) != 0)
  return ret;
 return e1->lineno - e2->lineno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
mov    %rsi,0x78(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
msbdf_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msbdf_state_t *state = (msbdf_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     41b <genmodulemark+0x24>
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 40f <genmodulemark+0x18>
mov    $0x0,%eax
callq  419 <genmodulemark+0x22>
jmp    45e <genmodulemark+0x67>
cmpb   $0x0,0x0(%rip)        # 422 <genmodulemark+0x2b>
je     443 <genmodulemark+0x4c>
mov    0x0(%rip),%rdx        # 42b <genmodulemark+0x34>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 437 <genmodulemark+0x40>
mov    $0x0,%eax
callq  441 <genmodulemark+0x4a>
jmp    45e <genmodulemark+0x67>
mov    0x0(%rip),%rcx        # 44a <genmodulemark+0x53>
mov    $0x6,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  45e <genmodulemark+0x67>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
genmodulemark(char *maintimestamp)
{
  if (maintimestamp)
    fprintf (ccode, "__m_%s", maintimestamp);
  else if (separat_comp)
    fprintf (ccode, "__m_%s", timestamp);
  else fprintf (ccode, "__NULL");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 8
24 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    (%rdi),%rbx
mov    %rbx,%rdi
callq  59 <gmp_sprintf_format+0x14>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
movslq %eax,%rdx
add    %rdx,%rbx
mov    %rbx,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gmp_sprintf_format (char **bufp, const char *fmt, va_list ap)
{
  char *buf = *bufp;
  int ret;
  vsprintf (buf, fmt, ap);
  ret = strlen (buf);
  *bufp = buf + ret;
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rcx,%r12
mov    %r8,%rbp
lea    0x8(%rsp),%r8
mov    %rsp,%rcx
callq  1d <_gsasl_step+0x1d>
mov    %eax,%ebx
cmp    $0x1,%ebx
ja     62 <_gsasl_step+0x62>
mov    0x8(%rsp),%r13
cmp    %r13,0x0(%rbp)
ja     3f <_gsasl_step+0x3f>
mov    (%rsp),%rdi
callq  38 <_gsasl_step+0x38>
mov    $0x4,%eax
jmp    62 <_gsasl_step+0x62>
test   %r12,%r12
je     53 <_gsasl_step+0x53>
mov    %r13,%rdx
mov    (%rsp),%rsi
mov    %r12,%rdi
callq  53 <_gsasl_step+0x53>
mov    %r13,0x0(%rbp)
mov    (%rsp),%rdi
callq  60 <_gsasl_step+0x60>
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_gsasl_step (Gsasl_session * sctx,
      const char *input, size_t input_len,
      char *output, size_t * output_len)
{
  char *tmp;
  size_t tmplen;
  int rc;
  rc = gsasl_step (sctx, input, input_len, &tmp, &tmplen);
  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)
    {
      if (tmplen >= *output_len)
 {
   free (tmp);
   return GSASL_TOO_SMALL_BUFFER;
 }
      if (output)
 memcpy (output, tmp, tmplen);
      *output_len = tmplen;
      free (tmp);
    }
  return rc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 8
11 8
12 9
13 9
14 11
15 11
16 11
17 13
18 13
19 14
20 14
21 16
22 16
23 17
24 17
25 17
26 17
27 18
28 19
29 19
30 21
31 22
32 22
33 22
34 22
35 22
36 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  49a <mu_opool_finish+0x9>
mov    $0x0,%edx
test   %eax,%eax
jne    4b3 <mu_opool_finish+0x22>
mov    %rbx,%rdi
callq  4ab <mu_opool_finish+0x1a>
mov    0x28(%rbx),%rax
mov    0x8(%rax),%rdx
mov    %rdx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_opool_finish (mu_opool_t opool, size_t *psize)
{
  if (mu_opool_coalesce (opool, psize))
    return ((void *)0);
  mu_opool_clear (opool);
  return opool->free->buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 3
6 3
7 5
8 5
9 6
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
callq  27 <xstr_cd_iconv+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    3e <xstr_cd_iconv+0x1d>
callq  34 <xstr_cd_iconv+0x13>
cmpl   $0xc,(%rax)
jne    3e <xstr_cd_iconv+0x1d>
callq  3e <xstr_cd_iconv+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstr_cd_iconv (const char *src, iconv_t cd)
{
  char *result = str_cd_iconv (src, cd);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x21e0,%edi
callq  e <keymap_make_keymap+0xe>
mov    $0x0,%edx
movb   $0x0,(%rax,%rdx,1)
movq   $0x0,0x8(%rax,%rdx,1)
add    $0x10,%rdx
cmp    $0x21e0,%rdx
jne    13 <keymap_make_keymap+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
keymap_make_keymap (void)
{
  int i;
  Keymap keymap;
  keymap = (Keymap)xmalloc ((271 * 2) * sizeof (KEYMAP_ENTRY));
  for (i = 0; i < (271 * 2); i++)
    {
      keymap[i].type = 0;
      keymap[i].value.function = ((void *)0);
    }
  return keymap;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 8
6 9
7 9
8 6
9 6
10 12
11 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  fc1 <xdr_dis_repair_type+0x9>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdr_dis_repair_type(xdrs, objp)
	XDR *xdrs;
	dis_repair_type *objp;
{
	if (!xdr_byte_u_short(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 9
7 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 265 <nettle_sha224_init+0x7>
mov    %rax,(%rdi)
mov    0x0(%rip),%rax        # 26f <nettle_sha224_init+0x11>
mov    %rax,0x8(%rdi)
mov    0x0(%rip),%rax        # 27a <nettle_sha224_init+0x1c>
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 285 <nettle_sha224_init+0x27>
mov    %rax,0x18(%rdi)
movq   $0x0,0x20(%rdi)
movl   $0x0,0x68(%rdi)
retq   
<<<sep_in_sample>>>
nettle_sha224_init(struct sha256_ctx *ctx)
{
  static const uint32_t H0[8] =
  {
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
  };
  memcpy(ctx->state, H0, sizeof(H0));
  ctx->count = 0;
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 9
10 10
11 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
jne    8e <InitiVector+0x1d>
mov    $0x0,%edi
callq  84 <InitiVector+0x13>
mov    $0x0,%edi
callq  8e <InitiVector+0x1d>
shl    $0x2,%rdi
callq  97 <InitiVector+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
InitiVector (long cVectors)
{
  if (cVectors == 0) {
    printf ("Error: zero length array allocation in InitiVector - Exiting\n");
    exit (0);
  }
  else
   return (int *) malloc (cVectors * sizeof(int));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_www_authenticate_get_qop_options (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->qop_options;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1278 <quotearg_custom_mem+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
cmp    $0x100,%edi
je     11d <parse_opt+0x4d>
cmp    $0x1000007,%edi
je     16e <parse_opt+0x9e>
mov    $0x7,%eax
cmp    $0x64,%edi
jne    1bb <parse_opt+0xeb>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  10d <parse_opt+0x3d>
mov    %eax,0x0(%rip)        # 113 <parse_opt+0x43>
mov    $0x0,%eax
jmpq   1bb <parse_opt+0xeb>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  12a <parse_opt+0x5a>
mov    %rax,%rdx
mov    %rax,0x0(%rip)        # 134 <parse_opt+0x64>
mov    $0x0,%eax
test   %rdx,%rdx
jne    1bb <parse_opt+0xeb>
mov    $0x0,%edi
callq  148 <parse_opt+0x78>
mov    %rax,%rbp
callq  150 <parse_opt+0x80>
mov    %rbx,%rcx
mov    %rbp,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  167 <parse_opt+0x97>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
cmpl   $0x0,0x0(%rip)        # 175 <parse_opt+0xa5>
je     19b <parse_opt+0xcb>
mov    $0x0,%eax
cmpq   $0x0,0x0(%rip)        # 184 <parse_opt+0xb4>
jne    1bb <parse_opt+0xeb>
mov    0x0(%rip),%rax        # 18d <parse_opt+0xbd>
mov    %rax,0x0(%rip)        # 194 <parse_opt+0xc4>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
cmpq   $0x0,0x0(%rip)        # 1a3 <parse_opt+0xd3>
je     1b6 <parse_opt+0xe6>
movl   $0x1,0x0(%rip)        # 1af <parse_opt+0xdf>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_opt (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'd':
      dbglev = strtol (arg, ((void *)0), 0);
      break;
    case DEBUG_FILE_OPTION:
      dbgout = fopen (arg, "w");
      if (!dbgout)
 error (1, (*__errno_location ()), gettext ("cannot open %s"), arg);
      break;
    case 0x1000007:
      if (dbglev)
 {
   if (!dbgout)
     dbgout = stderr;
 }
      else if (dbgout)
 dbglev = 1;
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 23
10 3
11 3
12 6
13 6
14 6
15 6
16 6
17 25
18 7
19 9
20 9
21 9
22 9
23 9
24 25
25 10
26 10
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 25
38 25
39 14
40 14
41 25
42 16
43 16
44 17
45 17
46 25
47 25
48 19
49 19
50 20
51 25
52 25
53 25
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    0x8(%rdi),%rax
je     326 <gsl_linalg_R_svx+0x2d>
mov    $0x14,%ecx
mov    $0x136,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  31f <gsl_linalg_R_svx+0x26>
mov    $0x14,%eax
jmp    36a <gsl_linalg_R_svx+0x71>
cmp    (%rsi),%rax
je     34b <gsl_linalg_R_svx+0x52>
mov    $0x13,%ecx
mov    $0x13a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  344 <gsl_linalg_R_svx+0x4b>
mov    $0x13,%eax
jmp    36a <gsl_linalg_R_svx+0x71>
mov    %rsi,%r8
mov    %rdi,%rcx
mov    $0x83,%edx
mov    $0x6f,%esi
mov    $0x79,%edi
callq  365 <gsl_linalg_R_svx+0x6c>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_linalg_R_svx (const gsl_matrix * R, gsl_vector * x)
{
  if (R->size1 != R->size2)
    {
      do { gsl_error ("R matrix must be square", "qr.c", 310, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (R->size2 != x->size)
    {
      do { gsl_error ("matrix size must match solution size", "qr.c", 314, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, R, x);
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 16
29 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
cmp    $0x10,%edi
jbe    6129 <regerror+0xe>
callq  6129 <regerror+0xe>
mov    %rdx,%r12
mov    %rcx,%rbx
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rsi
add    $0x0,%rsi
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rbp
test   %rbx,%rbx
je     6181 <regerror+0x66>
cmp    %rbx,%rcx
jbe    6176 <regerror+0x5b>
lea    -0x1(%rbx),%rdx
mov    %r12,%rdi
callq  616e <regerror+0x53>
movb   $0x0,-0x1(%r12,%rbx,1)
jmp    6181 <regerror+0x66>
mov    %rcx,%rdx
mov    %r12,%rdi
callq  6181 <regerror+0x66>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
regerror (errcode, preg, errbuf, errbuf_size)
    int errcode;
    const regex_t *preg;
    char *errbuf;
    size_t errbuf_size;
{
  const char *msg;
  size_t msg_size;
  if (errcode < 0
      || errcode >= (int) (sizeof (re_error_msgid_idx)
      / sizeof (re_error_msgid_idx[0])))
    abort ();
  msg = (re_error_msgid + re_error_msgid_idx[errcode]);
  msg_size = strlen (msg) + 1;
  if (errbuf_size != 0)
    {
      if (msg_size > errbuf_size)
        {
          memcpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
        }
      else
        memcpy (errbuf, msg, msg_size);
    }
  return msg_size;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 9
5 9
6 12
7 12
8 12
9 13
10 13
11 13
12 14
13 14
14 14
15 14
16 14
17 14
18 15
19 15
20 17
21 17
22 19
23 19
24 19
25 20
26 20
27 23
28 23
29 23
30 26
31 26
32 26
33 26
34 26
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_complex_long_double_size (const gsl_block_complex_long_double * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  51d <internal_malloc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
malloc (size)
     size_t size;
{
  return internal_malloc (size, (char *)((void *)0), 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1c17 <cmdline_parser_params_init+0x27>
movl   $0x0,(%rdi)
movl   $0x1,0x4(%rdi)
movl   $0x1,0x8(%rdi)
movl   $0x0,0xc(%rdi)
movl   $0x1,0x10(%rdi)
repz retq 
<<<sep_in_sample>>>
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    {
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 7
6 8
7 9
8 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # 882 <dicod_add_command+0xc>
jne    89d <dicod_add_command+0x27>
callq  889 <dicod_add_command+0x13>
mov    %rax,0x0(%rip)        # 890 <dicod_add_command+0x1a>
mov    $0x0,%esi
mov    %rax,%rdi
callq  89d <dicod_add_command+0x27>
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 8a7 <dicod_add_command+0x31>
callq  8ac <dicod_add_command+0x36>
pop    %rbx
retq   
<<<sep_in_sample>>>
dicod_add_command(struct dicod_command *cmd)
{
    if (!command_list) {
 command_list = xdico_list_create();
 dico_list_set_comparator(command_list, _cmd_arg_cmp);
    }
    xdico_list_append(command_list, cmd);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 7
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     51d <gsasl_server_callback_cipher_get+0xd>
mov    0xd0(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_cipher_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cipher : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     435 <grecs_print_statement_array+0x68>
mov    %esi,%ebp
mov    %edx,%r13d
mov    %rcx,%r12
cmpq   $0x0,(%rdi)
je     435 <grecs_print_statement_array+0x68>
testb  $0x10,0x1c(%rbx)
jne    428 <grecs_print_statement_array+0x5b>
test   %ebp,%ebp
je     404 <grecs_print_statement_array+0x37>
mov    %r12,%rsi
mov    $0xa,%edi
callq  404 <grecs_print_statement_array+0x37>
cmpl   $0xf,0x18(%rbx)
jne    41a <grecs_print_statement_array+0x4d>
mov    %r12,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  418 <grecs_print_statement_array+0x4b>
jmp    428 <grecs_print_statement_array+0x5b>
mov    %r12,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  428 <grecs_print_statement_array+0x5b>
add    $0x48,%rbx
add    $0x1,%ebp
cmpq   $0x0,(%rbx)
jne    3ed <grecs_print_statement_array+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
grecs_print_statement_array(struct grecs_keyword *kwp,
       unsigned n,
       unsigned level,
       FILE *stream)
{
 if (!kwp) {
  return;
 }
 for (; kwp->ident; kwp++, n++) {
  if (kwp->flags & 0x10)
   continue;
  if (n)
   fputc('\n', stream);
  if (kwp->type == grecs_type_section)
   grecs_print_block_statement(kwp, level, stream);
  else
   grecs_print_simple_statement(kwp, level, stream);
 }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 9
13 9
14 10
15 10
16 12
17 12
18 13
19 13
20 13
21 14
22 14
23 15
24 15
25 15
26 15
27 15
28 17
29 17
30 17
31 17
32 9
33 9
34 9
35 9
36 19
37 19
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rdx,%r12
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
neg    %rcx
mov    %rcx,%rdi
callq  72 <rl_quote_filename+0x23>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 7c <rl_quote_filename+0x2d>
movzbl (%rax),%eax
mov    %al,(%rbx)
lea    0x1(%rbx),%rdi
mov    %rbp,%rsi
callq  8d <rl_quote_filename+0x3e>
test   %r12,%r12
je     a0 <rl_quote_filename+0x51>
mov    0x0(%rip),%rax        # 99 <rl_quote_filename+0x4a>
movzbl (%rax),%eax
mov    %al,(%r12)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rl_quote_filename (s, rtype, qcp)
     char *s;
     int rtype;
     char *qcp;
{
  char *r;
  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 10
20 10
21 11
22 11
23 11
24 13
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rdx,%rbx
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rsi        # f01 <pred_context+0x18>
mov    0x0(%rip),%edi        # f07 <pred_context+0x1e>
callq  *0x0(%rip)        # f0d <pred_context+0x24>
test   %eax,%eax
jns    f51 <pred_context+0x68>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  f1e <pred_context+0x35>
mov    %rax,%rbp
mov    $0x0,%edi
callq  f2b <pred_context+0x42>
mov    %rax,%rbx
callq  f33 <pred_context+0x4a>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  f4a <pred_context+0x61>
mov    $0x0,%eax
jmp    f69 <pred_context+0x80>
mov    0x38(%rbx),%rdi
mov    $0x0,%edx
mov    0x8(%rsp),%rsi
callq  f64 <pred_context+0x7b>
test   %eax,%eax
sete   %al
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pred_context (const char *pathname, struct stat *stat_buf,
       struct predicate *pred_ptr)
{
  security_context_t scontext;
  int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,
        &scontext);
  (void) stat_buf;
  if (rv < 0)
    {
      error (0, (*__errno_location ()), gettext ("getfilecon failed: %s"),
      safely_quote_err_filename (0, pathname));
      return 0;
    }
  rv = (fnmatch (pred_ptr->args.scontext, scontext, 0) == 0);
  freecon (scontext);
  return rv;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 5
10 8
11 8
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 12
27 12
28 14
29 14
30 14
31 14
32 14
33 14
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%r8
mov    %rsi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rbx,%rdx
mov    %r8,%rdi
callq  162 <_rl_get_char_len+0x27>
cmp    $0xfffffffffffffffe,%rax
jne    176 <_rl_get_char_len+0x3b>
test   %rbx,%rbx
je     195 <_rl_get_char_len+0x5a>
movq   $0x0,(%rbx)
jmp    195 <_rl_get_char_len+0x5a>
cmp    $0xffffffffffffffff,%rax
jne    18a <_rl_get_char_len+0x4f>
test   %rbx,%rbx
je     195 <_rl_get_char_len+0x5a>
movq   $0x0,(%rbx)
jmp    195 <_rl_get_char_len+0x5a>
test   %rax,%rax
mov    $0x0,%edx
cmove  %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_get_char_len (src, ps)
     char *src;
     mbstate_t *ps;
{
  size_t tmp;
  tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
  if (tmp == (size_t)(-2))
    {
      if (ps)
 memset (ps, 0, sizeof(mbstate_t));
      return -2;
    }
  else if (tmp == (size_t)(-1))
    {
      if (ps)
 memset (ps, 0, sizeof(mbstate_t));
      return -1;
    }
  else if (tmp == (size_t)0)
    return 0;
  else
    return (int)tmp;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 9
15 9
16 10
17 10
18 13
19 13
20 15
21 15
22 16
23 16
24 19
25 22
26 22
27 23
28 23
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %esi,%r12d
mov    %rdx,%r13
mov    $0x1,%esi
mov    $0x158,%edi
callq  160 <gc_hash_open+0x21>
mov    %rax,%rbx
test   %rax,%rax
je     1c7 <gc_hash_open+0x88>
mov    %ebp,(%rax)
mov    %r12d,0x4(%rax)
cmp    $0x1,%ebp
je     17a <gc_hash_open+0x3b>
cmp    $0x2,%ebp
je     18a <gc_hash_open+0x4b>
jmp    19d <gc_hash_open+0x5e>
lea    0x1c(%rax),%rdi
callq  183 <gc_hash_open+0x44>
mov    $0x0,%ebp
jmp    1a2 <gc_hash_open+0x63>
lea    0xb8(%rax),%rdi
callq  196 <gc_hash_open+0x57>
mov    $0x0,%ebp
jmp    1a2 <gc_hash_open+0x63>
mov    $0x5,%ebp
test   %r12d,%r12d
jne    1b6 <gc_hash_open+0x77>
test   %ebp,%ebp
jne    1bb <gc_hash_open+0x7c>
mov    %rbx,0x0(%r13)
mov    $0x0,%eax
jmp    1cc <gc_hash_open+0x8d>
mov    $0x5,%ebp
mov    %rbx,%rdi
callq  1c3 <gc_hash_open+0x84>
mov    %ebp,%eax
jmp    1cc <gc_hash_open+0x8d>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gc_hash_open (Gc_hash hash, Gc_hash_mode mode, gc_hash_handle * outhandle)
{
  _gc_hash_ctx *ctx;
  Gc_rc rc = GC_OK;
  ctx = calloc (sizeof (*ctx), 1);
  if (!ctx)
    return GC_MALLOC_ERROR;
  ctx->alg = hash;
  ctx->mode = mode;
  switch (hash)
    {
    case GC_MD5:
      md5_init_ctx (&ctx->md5Context);
      break;
    case GC_SHA1:
      sha1_init_ctx (&ctx->sha1Context);
      break;
    default:
      rc = GC_INVALID_HASH;
      break;
    }
  switch (mode)
    {
    case 0:
      break;
    default:
      rc = GC_INVALID_HASH;
      break;
    }
  if (rc == GC_OK)
    *outhandle = ctx;
  else
    free (ctx);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 6
14 6
15 8
16 9
17 10
18 10
19 10
20 10
21 10
22 13
23 13
24 4
25 14
26 16
27 16
28 4
29 17
30 19
31 22
32 22
33 30
34 30
35 31
36 34
37 34
38 27
39 33
40 33
41 33
42 33
43 7
44 35
45 35
46 35
47 35
48 35
49 35
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r8
movzwl (%r8),%edi
test   %rbp,%rbp
je     2137 <gsl_matrix_short_min_index+0x65>
add    %r12,%r12
mov    $0x0,%r10d
mov    $0x0,%r11d
mov    $0x0,%ebx
jmp    212b <gsl_matrix_short_min_index+0x59>
movzwl (%r8,%rax,2),%ecx
cmp    %di,%cx
jge    2116 <gsl_matrix_short_min_index+0x44>
mov    %rax,%r11
mov    %r10,%rbx
mov    %ecx,%edi
add    $0x1,%rax
cmp    %r9,%rax
jne    2104 <gsl_matrix_short_min_index+0x32>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
je     2142 <gsl_matrix_short_min_index+0x70>
test   %r9,%r9
je     211f <gsl_matrix_short_min_index+0x4d>
mov    $0x0,%eax
jmp    2104 <gsl_matrix_short_min_index+0x32>
mov    $0x0,%r11d
mov    $0x0,%ebx
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_matrix_short_min_index (const gsl_matrix_short * m, size_t * imin_out, size_t *jmin_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  short min = m->data[0 * tda + 0];
  size_t imin = 0, jmin = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          short x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 5
7 6
8 6
9 9
10 9
11 9
12 9
13 7
14 7
15 7
16 13
17 14
18 14
19 14
20 14
21 16
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 7
34 7
35 22
36 23
37 24
38 24
39 24
40 24
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     178a <gsl_vector_char_ispos+0x2c>
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorpd  %xmm1,%xmm1
movsbl (%rax),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm0,%xmm1
jb     1796 <gsl_vector_char_ispos+0x38>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    %r8,%rax
cmp    %rsi,%rdx
jne    1777 <gsl_vector_char_ispos+0x19>
jmp    1790 <gsl_vector_char_ispos+0x32>
<<<sep_in_sample>>>
gsl_vector_char_ispos (const gsl_vector_char * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 11
8 11
9 11
10 11
11 11
12 13
13 13
14 17
15 17
16 17
17 17
18 6
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 19c7 <do_gotolinecolumn_void+0xb>
mov    0x38(%rax),%rdx
lea    0x1(%rdx),%rsi
mov    0x20(%rax),%rax
mov    0x8(%rax),%rdi
mov    $0x1,%ecx
mov    $0x0,%edx
callq  19e6 <do_gotolinecolumn_void+0x2a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_gotolinecolumn_void(void)
{
    do_gotolinecolumn(openfile->current->lineno,
 openfile->placewewant + 1, 0, 1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     180 <ForAllList+0x56>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r12
mov    %rdx,%r13
mov    $0x0,%eax
test   %rsi,%rsi
je     175 <ForAllList+0x4b>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     16c <ForAllList+0x42>
mov    $0x0,%ebp
mov    %r13,%rsi
mov    (%rbx),%rdi
callq  *%r12
add    %eax,%ebp
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    156 <ForAllList+0x2c>
jmp    173 <ForAllList+0x49>
mov    $0x0,%eax
jmp    175 <ForAllList+0x4b>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
ForAllList (PLIST plist, PFI_FORLISTCALLBACK pfiCallback, PVOID pUserInfo)
{
  int iTotal = 0;
  PLISTELEM ple;
  if (!plist || !pfiCallback)
    return 0;
  ple = plist->pleHead;
  while (ple) {
    iTotal += (*pfiCallback) (ple->pData, pUserInfo);
    ple = ple->pleNext;
  }
  return (iTotal);
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 5
12 5
13 7
14 8
15 8
16 3
17 9
18 9
19 9
20 9
21 10
22 8
23 8
24 8
25 3
26 3
27 9
28 13
29 13
30 13
31 13
32 13
33 13
34 6
35 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%r8        # b <version_etc_hook+0xb>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    0x0(%rip),%rsi        # 1c <version_etc_hook+0x1c>
callq  21 <version_etc_hook+0x21>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU inetutils", "1.9.4",
                  program_authors);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0x1,%edx
callq  1c9b <info_read_completing_in_echo_area_with_exclusions+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_read_completing_in_echo_area_with_exclusions (const char *prompt,
     REFERENCE **completions, reference_bool_fn exclude)
{
  return info_read_completing_internal (prompt, completions, 1, exclude);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
callq  1010 <quotearg_char+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2322 <swi_fl_get_type+0x9>
test   %rax,%rax
je     232c <swi_fl_get_type+0x13>
movsbl (%rax),%eax
jmp    2331 <swi_fl_get_type+0x18>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swi_fl_get_type(SWI_FILELIST * fl, int index) {
 STRAR * ar = (STRAR*)fl;
 char * s;
 s = strar_get(ar, index);
 if (s == ((void *)0)) return 0;
 return (int)(*(s + 0));
}
<<<sep_in_sample>>>
1 1
2 4
3 5
4 5
5 6
6 6
7 5
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %esi,%esi
jns    16bc <ea_backward_kill_line+0x1b>
mov    0x0(%rip),%esi        # 16af <ea_backward_kill_line+0xe>
mov    0x0(%rip),%edi        # 16b5 <ea_backward_kill_line+0x14>
callq  59a <ea_kill_text>
jmp    16d9 <ea_backward_kill_line+0x38>
mov    0x0(%rip),%esi        # 16c2 <ea_backward_kill_line+0x21>
mov    0x0(%rip),%edi        # 16c8 <ea_backward_kill_line+0x27>
callq  59a <ea_kill_text>
mov    0x0(%rip),%eax        # 16d3 <ea_backward_kill_line+0x32>
mov    %eax,0x0(%rip)        # 16d9 <ea_backward_kill_line+0x38>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ea_backward_kill_line (WINDOW *window, int count)
{
  if (count < 0)
    ea_kill_text (input_line_point, input_line_end);
  else
    {
      ea_kill_text (input_line_point, input_line_beg);
      input_line_point = input_line_beg;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 7
9 7
10 7
11 8
12 8
13 10
14 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  205 <__gmp_randinit_mt+0x9>
movq   $0x0,0x18(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmp_randinit_mt (gmp_randstate_t rstate)
{
  __gmp_randinit_mt_noseed (rstate);
  ((rstate)->_mp_algdata._mp_lc) = (void *) &Mersenne_Twister_Generator;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r14
push   %rbp
push   %rbx
mov    (%rsi),%r11
cmp    (%rdi),%r11
je     1e77 <gsl_vector_int_div+0x2c>
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e70 <gsl_vector_int_div+0x25>
mov    $0x13,%eax
jmp    1ed0 <gsl_vector_int_div+0x85>
mov    0x8(%rdi),%rbp
mov    0x8(%rsi),%rbx
test   %r11,%r11
je     1ec4 <gsl_vector_int_div+0x79>
shl    $0x2,%rbp
shl    $0x2,%rbx
mov    $0x0,%ecx
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    %r9,%r10
add    0x10(%rdi),%r10
mov    0x10(%rsi),%r14
mov    (%r10),%eax
cltd   
idivl  (%r14,%rcx,1)
mov    %eax,(%r10)
add    $0x1,%r8
add    %rbp,%r9
add    %rbx,%rcx
cmp    %r11,%r8
jne    1e9d <gsl_vector_int_div+0x52>
jmp    1ecb <gsl_vector_int_div+0x80>
mov    $0x0,%eax
jmp    1ed0 <gsl_vector_int_div+0x85>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_vector_int_div (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 10
15 11
16 13
17 13
18 15
19 15
20 15
21 15
22 13
23 15
24 15
25 15
26 15
27 15
28 15
29 15
30 13
31 13
32 13
33 13
34 13
35 13
36 17
37 17
38 17
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_uint_data (const gsl_block_uint * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  312 <build_aliasvar>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
get_aliasvar (self)
     SHELL_VAR *self;
{
  build_aliasvar (self);
  return (self);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x10,%edi
callq  42 <_assoc_dup+0x14>
mov    %rax,%rbx
mov    0x0(%rbp),%rdi
callq  4e <_assoc_dup+0x20>
mov    %rax,(%rbx)
mov    0x8(%rbp),%rdi
callq  5a <_assoc_dup+0x2c>
mov    %rax,0x8(%rbx)
mov    %rbx,%rsi
mov    %r12,%rdi
callq  69 <_assoc_dup+0x3b>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_assoc_dup (void *item, void *data)
{
  ASSOC *elt = item;
  ASSOC *newelt = xmalloc (sizeof (*newelt));
  newelt->key = xstrdup (elt->key);
  newelt->value = xstrdup (elt->value);
  list_append (data, newelt);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r13d
mov    %ecx,%r12d
test   %ecx,%ecx
je     1cd4 <_x87_eqr_d+0x90>
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
test   %r13d,%r13d
jne    1c81 <_x87_eqr_d+0x3d>
mov    %r12d,%r13d
mov    %r13d,%edx
mov    $0x1d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
jmp    1ca3 <_x87_eqr_d+0x5f>
mov    %r13d,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
lea    0x1(%r12),%edx
mov    $0x3d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
mov    $0x0,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  850 <_jccs>
mov    (%rbx),%r12
mov    %ebp,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  2c2 <_cc>
mov    (%rbx),%rax
sub    %r12d,%eax
mov    %al,-0x1(%r12)
jmp    1ce4 <_x87_eqr_d+0xa0>
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
jmp    1c6f <_x87_eqr_d+0x2b>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_x87_eqr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_bool_t rc;
    jit_word_t jp_code;
    jit_int32_t reg, f1, f2;
    if (r2 == 0) f1 = r2, f2 = r1;
    else f1 = r1, f2 = r2;
    if ((rc = 1))
 reg = r0;
    else {
 reg = 0;
 _movr(_jit, r0, reg);
    }
    _alur(_jit, 6 << 3, reg, reg);
    if (f1 == 0)
 _x87ri(_jit,035,f2);
    else {
 _x87ri(_jit,010,f1);
 _x87ri(_jit,075,f2 + 1);
    }
    _jccs(_jit, 0xa, 0);
    jp_code = _jit->pc.w;
    _cc(_jit, 0x4, reg);
    *(jit_int8_t *)(jp_code - 1) = _jit->pc.w - jp_code;
    if (!rc)
 _xchgr(_jit, r0, reg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 14
12 14
13 14
14 14
15 15
16 15
17 7
18 16
19 16
20 16
21 16
22 16
23 18
24 18
25 18
26 18
27 19
28 19
29 19
30 19
31 21
32 21
33 21
34 21
35 22
36 23
37 23
38 23
39 23
40 24
41 24
42 24
43 24
44 14
45 14
46 14
47 14
48 14
49 27
50 27
51 27
52 27
53 27
<<<sep_out_sample>>>
push   %rbx
callq  27 <xstr_cd_iconv+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    3e <xstr_cd_iconv+0x1d>
callq  34 <xstr_cd_iconv+0x13>
cmpl   $0xc,(%rax)
jne    3e <xstr_cd_iconv+0x1d>
callq  3e <xstr_cd_iconv+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstr_cd_iconv (const char *src, iconv_t cd)
{
  char *result = str_cd_iconv (src, cd);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsasl_callback_hook_get (Gsasl * ctx)
{
  return ctx->application_hook;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %r12,%rbp
mov    %r12,%rbx
mov    0x10(%rbx),%rax
test   %rax,%rax
je     7a3f <cleanAttributeList+0x1e>
mov    %rbx,%rbp
mov    %rax,%rbx
jmp    7a2e <cleanAttributeList+0xd>
cmp    %r12,%rbx
je     7a54 <cleanAttributeList+0x33>
mov    (%rbx),%rdi
callq  7a4c <cleanAttributeList+0x2b>
mov    %rbx,%rdi
callq  7a54 <cleanAttributeList+0x33>
movq   $0x0,0x10(%rbp)
cmpq   $0x0,0x10(%r12)
jne    7a28 <cleanAttributeList+0x7>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cleanAttributeList( AttributeList *list)
{
 AttributeList *actualatt=list;
 do{
  actualatt=list;
  AttributeList *prev=list;
  AttributeList *prev2=list;
  do{
   prev2=prev;
   prev=actualatt;
   actualatt=actualatt->next;
  }while(actualatt!=((void *)0));
  if (prev!=list){
   free(prev->word);
   free(prev);
  }
  prev2->next=((void *)0);
 }while(list->next!=((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 5
7 11
8 12
9 12
10 11
11 11
12 11
13 13
14 13
15 14
16 14
17 15
18 15
19 17
20 18
21 18
22 19
23 19
24 19
25 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  13a <xzalloc+0x9>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  14a <xzalloc+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
test   %edx,%edx
jle    60 <cblas_scasum+0x60>
test   %edi,%edi
jle    64 <cblas_scasum+0x64>
mov    $0x0,%ecx
mov    $0x0,%eax
xorps  %xmm0,%xmm0
movss  0x0(%rip),%xmm1        # 1d <cblas_scasum+0x1d>
movslq %ecx,%r8
unpcklps %xmm0,%xmm0
cvtps2pd %xmm0,%xmm2
movss  (%rsi,%r8,8),%xmm3
andps  %xmm1,%xmm3
unpcklps %xmm3,%xmm3
cvtps2pd %xmm3,%xmm3
movss  0x4(%rsi,%r8,8),%xmm0
andps  %xmm1,%xmm0
unpcklps %xmm0,%xmm0
cvtps2pd %xmm0,%xmm0
addsd  %xmm3,%xmm0
addsd  %xmm2,%xmm0
unpcklpd %xmm0,%xmm0
cvtpd2ps %xmm0,%xmm0
add    %edx,%ecx
add    $0x1,%eax
cmp    %edi,%eax
jne    1d <cblas_scasum+0x1d>
repz retq 
xorps  %xmm0,%xmm0
retq   
xorps  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
cblas_scasum (const int N, const void *X, const int incX)
{
{
  float r = 0.0;
  int i;
  int ix = 0;
  if (incX <= 0) {
    return 0;
  }
  for (i = 0; i < N; i++) {
    r += fabs((((const float *) X)[2*(ix)])) + fabs((((const float *) X)[2*(ix)+1]));
    ix += incX;
  }
  return r;
}
}
<<<sep_in_sample>>>
1 7
2 7
3 10
4 10
5 10
6 10
7 10
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 12
25 10
26 10
27 10
28 10
29 8
30 8
31 10
32 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x148(%rdi),%rdi
callq  410 <VdbeAllocColor+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
VdbeAllocColor(Viewport *v, Colormap colormap, XColor *c)
{
  int result;
  result = XAllocColor (v->dpy, colormap, c);
  return result;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 18f <cleanup_quote_opts+0xb>
callq  194 <cleanup_quote_opts+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cleanup_quote_opts (void)
{
  free (quote_opts);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x140,%rsp
mov    %edi,%ebx
mov    %rsi,(%rsp)
lea    0x8(%rsp),%rdi
callq  85 <bsd_signal+0x18>
movl   $0x40000000,0x88(%rsp)
lea    0xa0(%rsp),%rdx
mov    %rsp,%rsi
mov    %ebx,%edi
callq  a2 <bsd_signal+0x35>
test   %eax,%eax
mov    $0xffffffffffffffff,%rax
cmovns 0xa0(%rsp),%rax
add    $0x140,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
bsd_signal(int signo, Sigfunc *func)
{
  struct sigaction act, oact;
  act.__sigaction_handler.sa_handler=func;
  sigemptyset(&act.sa_mask);
  act.sa_flags=0x40000000;
  if (sigaction(signo,&act,&oact) < 0)
    return ((__sighandler_t) -1);
  else
    return oact.__sigaction_handler.sa_handler;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 5
7 6
8 7
9 7
10 7
11 7
12 7
13 10
14 10
15 11
16 11
17 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 220 <env_help+0x7>
test   %rsi,%rsi
je     261 <env_help+0x48>
push   %rbx
mov    $0x0,%ebx
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     254 <env_help+0x3b>
cmpb   $0x0,(%rdx)
je     24a <env_help+0x31>
mov    $0x0,%edi
mov    $0x0,%eax
callq  248 <env_help+0x2f>
jmp    254 <env_help+0x3b>
mov    $0xa,%edi
callq  254 <env_help+0x3b>
add    $0x20,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    22b <env_help+0x12>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
env_help (void)
{
  struct envlist *c;
  for (c = EnvList; c->name; c++)
    {
      if (c->help)
 {
   if (*c->help)
     printf ("%-15s %s\n", c->name, c->help);
   else
     printf ("\n");
 }
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 4
6 6
7 6
8 6
9 8
10 8
11 9
12 9
13 9
14 9
15 11
16 11
17 4
18 4
19 4
20 4
21 14
22 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  79 <_mapfile_flush+0x9>
mov    0x8(%rax),%rdi
lea    -0x1(%rdi),%rcx
mov    $0x0,%edx
cmp    $0xfffffffffffffffd,%rcx
ja     a4 <_mapfile_flush+0x34>
mov    0x4(%rax),%edx
and    $0x2,%edx
je     a4 <_mapfile_flush+0x34>
mov    0x10(%rax),%rsi
mov    $0x4,%edx
callq  a2 <_mapfile_flush+0x32>
mov    %eax,%edx
mov    %edx,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_mapfile_flush (mu_stream_t stream)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  if (mfs->ptr != ((void *) -1) && mfs->ptr != ((void *)0) && (mfs->flags & 0x2))
    return msync (mfs->ptr, mfs->size, 4);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 7
16 7
17 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%esi
callq  c4c <quotearg_colon+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon (char const *arg)
{
  return quotearg_char (arg, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  174 <gsl_spmatrix_compcol+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spmatrix_compcol(const gsl_spmatrix *T)
{
  return gsl_spmatrix_ccs(T);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%r8
callq  1343 <gsl_sort_vector2_uint+0x1b>
repz retq 
<<<sep_in_sample>>>
gsl_sort_vector2_uint (gsl_vector_uint * v1, gsl_vector_uint * v2)
{
  gsl_sort2_uint (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %rbx
movq   %xmm0,-0x8(%rsp)
mov    -0x8(%rsp),%rax
mov    (%rdi),%r11
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rbx
mov    %eax,-0x8(%rsp)
movss  -0x8(%rsp),%xmm2
shr    $0x20,%rax
mov    %eax,-0x8(%rsp)
movss  -0x8(%rsp),%xmm3
test   %r11,%r11
je     10ff <gsl_matrix_complex_float_scale+0xac>
shl    $0x3,%rbx
mov    $0x0,%r10d
mov    $0x0,%r9d
jmp    10f0 <gsl_matrix_complex_float_scale+0x9d>
mov    0x18(%rdi),%rsi
lea    (%rsi,%rax,1),%rcx
movss  (%rcx),%xmm1
movss  0x4(%rsi,%rax,1),%xmm0
movaps %xmm1,%xmm4
mulss  %xmm2,%xmm4
movaps %xmm0,%xmm5
mulss  %xmm3,%xmm5
subss  %xmm5,%xmm4
movss  %xmm4,(%rcx)
mov    0x18(%rdi),%rcx
mulss  %xmm3,%xmm1
mulss  %xmm2,%xmm0
addss  %xmm1,%xmm0
movss  %xmm0,0x4(%rcx,%rax,1)
add    $0x1,%rdx
add    $0x8,%rax
cmp    %r8,%rdx
jne    1099 <gsl_matrix_complex_float_scale+0x46>
add    $0x1,%r9
add    %rbx,%r10
cmp    %r11,%r9
je     10ff <gsl_matrix_complex_float_scale+0xac>
test   %r8,%r8
je     10e4 <gsl_matrix_complex_float_scale+0x91>
mov    %r10,%rax
mov    $0x0,%edx
jmp    1099 <gsl_matrix_complex_float_scale+0x46>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_scale (gsl_matrix_complex_float * a, const gsl_complex_float x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  float xr = ((x).dat[0]);
  float xi = ((x).dat[1]);
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          const size_t aij = 2 * (i * tda + j);
          float ar = a->data[aij];
          float ai = a->data[aij + 1];
          a->data[aij] = ar * xr - ai * xi;
          a->data[aij + 1] = ar * xi + ai * xr;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 5
7 7
8 7
9 8
10 8
11 8
12 9
13 9
14 9
15 9
16 9
17 9
18 14
19 14
20 14
21 15
22 16
23 16
24 16
25 16
26 16
27 16
28 17
29 17
30 17
31 17
32 17
33 11
34 11
35 11
36 11
37 9
38 9
39 9
40 9
41 11
42 11
43 11
44 11
45 11
46 21
47 21
48 21
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x38(%rdi),%rbp
mov    $0x0,%edx
mov    0x0(%rbp),%rdi
callq  67f <__bt_dnpage+0x18>
mov    %rax,%rbx
test   %rax,%rax
je     6a0 <__bt_dnpage+0x39>
mov    %rax,%rdi
callq  68f <__bt_dnpage+0x28>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    0x0(%rbp),%rdi
callq  6a0 <__bt_dnpage+0x39>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__bt_dnpage(dbp, pgno)
 DB *dbp;
 u_int32_t pgno;
{
 BTREE *t;
 PAGE *h;
 t = dbp->internal;
 if ((h = mpool_get(t->bt_mp, pgno, 0)) != ((void *)0)) {
  __bt_dpage(h);
  (void)mpool_put(t->bt_mp, h, 0);
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 8
6 8
7 8
8 8
9 8
10 8
11 9
12 9
13 10
14 10
15 10
16 10
17 12
18 12
19 12
20 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
mov    %rdx,%r12
mov    %rcx,%rbp
mov    $0x0,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  6 <scan_for_driver>
mov    %rax,%rbx
test   %rax,%rax
je     655 <cdio_get_drive_cap_dev+0x48>
mov    %rbp,%rcx
mov    %r12,%rdx
mov    %r13,%rsi
mov    %rax,%rdi
callq  64b <cdio_get_drive_cap_dev+0x3e>
mov    %rbx,%rdi
callq  653 <cdio_get_drive_cap_dev+0x46>
jmp    66c <cdio_get_drive_cap_dev+0x5f>
movl   $0x80000,0x0(%r13)
movl   $0x80000,(%r12)
movl   $0x80000,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cdio_get_drive_cap_dev (const char *device,
   cdio_drive_read_cap_t *p_read_cap,
   cdio_drive_write_cap_t *p_write_cap,
   cdio_drive_misc_cap_t *p_misc_cap)
{
  CdIo_t *cdio=scan_for_driver(cdio_drivers, device, ((void *)0));
  if (cdio) {
    cdio_get_drive_cap(cdio, p_read_cap, p_write_cap, p_misc_cap);
    cdio_destroy(cdio);
  } else {
    *p_read_cap = CDIO_DRIVE_CAP_UNKNOWN;
    *p_write_cap = CDIO_DRIVE_CAP_UNKNOWN;
    *p_misc_cap = CDIO_DRIVE_CAP_UNKNOWN;
  }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 11
25 12
26 13
27 15
28 15
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
test   %rdx,%rdx
je     5bb <gsl_stats_ushort_skew_m_sd+0x5a>
add    %rsi,%rsi
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 576 <gsl_stats_ushort_skew_m_sd+0x15>
movzwl (%rdi),%ecx
cvtsi2sd %ecx,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fld    %st(0)
fmul   %st(1),%st
fmulp  %st,%st(1)
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    5ab <gsl_stats_ushort_skew_m_sd+0x4a>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    576 <gsl_stats_ushort_skew_m_sd+0x15>
fstp   %st(0)
jmp    5bd <gsl_stats_ushort_skew_m_sd+0x5c>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_ushort_skew_m_sd (const unsigned short data[],
                               const size_t stride, const size_t n,
                               const double mean, const double sd)
{
  long double skew = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      skew += (x * x * x - skew) / (i + 1);
    }
  return skew;
}
<<<sep_in_sample>>>
1 7
2 7
3 9
4 7
5 5
6 10
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 7
27 7
28 7
29 7
30 5
31 12
32 12
33 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # dfb <history_list+0x7>
retq   
<<<sep_in_sample>>>
history_list ()
{
  return (the_history);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1c0,%esi
callq  44 <try_dir+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
try_dir (char *tmpl, void *flags)
{
  return mkdir (tmpl, 0400 | 0200 | 0100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
movl   $0x1,0x48(%rax)
retq   
<<<sep_in_sample>>>
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  src->start_of_file = 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
callq  5a <editMenu_DeleteLine+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
editMenu_DeleteLine()
{
  deleteLine();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  95 <do_dns+0x9>
test   %rax,%rax
jne    b8 <do_dns+0x2c>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  a7 <do_dns+0x1b>
mov    $0x0,%edi
callq  b1 <do_dns+0x25>
mov    $0x0,%eax
jmp    c1 <do_dns+0x35>
mov    0x18(%rax),%rax
mov    (%rax),%rax
mov    (%rax),%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
do_dns (char *name)
{
  struct hostent *he;
  struct in_addr in;
  he = gethostbyname (name);
  if (!he) {
    printf ("Resolving %s ...", name);
    printf ("Failed!\n");
    return 0;
  }
  in.s_addr = *(unsigned long *) he->h_addr_list[0];
  return ((unsigned long) in.s_addr);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 6
5 6
6 7
7 7
8 7
9 8
10 8
11 9
12 9
13 11
14 11
15 12
16 13
17 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1b <pop_stack>
<<<sep_in_sample>>>
go_to(struct label x)
{
      longjmp(x.jump, x.kase);
}
<<<sep_in_sample>>>
1 2
2 3
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
movslq %eax,%rdx
test   %rsi,%rsi
setg   %cl
movzbl %cl,%ecx
mov    %rsi,%r8
shr    $0x3f,%r8
sub    %r8d,%ecx
movslq %ecx,%r8
cmp    %r8,%rdx
jne    26 <__gmpz_cmp_si+0x26>
test   %rdx,%rdx
jne    29 <__gmpz_cmp_si+0x29>
sub    %ecx,%eax
retq   
mov    0x8(%rdi),%rdx
mov    (%rdx),%rcx
mov    %rsi,%rdx
sar    $0x3f,%rdx
xor    %rdx,%rsi
sub    %rdx,%rsi
cmp    %rcx,%rsi
je     4d <__gmpz_cmp_si+0x4d>
mov    %eax,%edx
neg    %edx
cmp    %rcx,%rsi
cmovae %edx,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
__gmpz_cmp_si (mpz_srcptr u, signed long int v_digit)
{
  mp_size_t vsize, usize;
  usize = ((u)->_mp_size);
  vsize = (v_digit > 0) - (v_digit < 0);
  if ((usize == 0) | (usize != vsize))
    return usize - vsize;
  else {
    mp_limb_t u_digit, absv_digit;
    u_digit = ((u)->_mp_d)[0];
    absv_digit = ((v_digit) >= 0 ? ((unsigned long) (v_digit)) : (- (((unsigned long) ((v_digit) + 1)) - 1)));
    if (u_digit == absv_digit)
      return 0;
    if (u_digit > absv_digit)
      return usize;
    else
      return -usize;
  }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 10
17 10
18 11
19 11
20 11
21 11
22 12
23 12
24 17
25 17
26 17
27 17
28 17
29 13
30 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r8
mov    %esi,%edx
mov    (%rdi),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %r8,%rdi
callq  69b <strob_chr+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strob_chr(STROB * strb, int ch)
{
 strob_chr_index(strb, strlen((char*)(strb->str_)), ch);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0xc8,%esi
mov    $0x1,%edi
callq  369 <mu_server_create+0x13>
mov    $0xc,%edx
test   %rax,%rax
je     378 <mu_server_create+0x22>
mov    %rax,(%rbx)
mov    $0x0,%dl
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_server_create (mu_server_t *psrv)
{
  mu_server_t srv = calloc (1, sizeof (*srv));
  if (!srv)
    return 12;
  *psrv = srv;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 4
8 4
9 6
10 7
11 8
12 8
13 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     6ae <cdio_get_driver_id+0x8>
mov    (%rdi),%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cdio_get_driver_id (const CdIo_t *p_cdio)
{
  if (!p_cdio) return DRIVER_UNKNOWN;
  return p_cdio->driver_id;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 3
6 5
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
lea    0x8(%rsp),%rdi
callq  7bd <mu_aget_user_email_domain+0x12>
mov    %eax,%edx
test   %eax,%eax
jne    7ec <mu_aget_user_email_domain+0x41>
mov    0x8(%rsp),%rdi
test   %rdi,%rdi
jne    7db <mu_aget_user_email_domain+0x30>
movq   $0x0,(%rbx)
mov    $0x0,%edx
jmp    7ec <mu_aget_user_email_domain+0x41>
callq  7e0 <mu_aget_user_email_domain+0x35>
mov    %rax,(%rbx)
cmp    $0x1,%rax
sbb    %edx,%edx
and    $0xc,%edx
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_aget_user_email_domain (char **pdomain)
{
  const char *domain;
  int status = mu_get_user_email_domain (&domain);
  if (status)
    return status;
  if (domain == ((void *)0))
    *pdomain = ((void *)0);
  else
    {
      *pdomain = strdup (domain);
      if (*pdomain == ((void *)0))
 return 12;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 6
7 5
8 5
9 7
10 7
11 7
12 8
13 15
14 15
15 11
16 11
17 13
18 13
19 13
20 16
21 16
22 16
23 16
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     de5 <gsl_vector_long_isnull+0x38>
shl    $0x3,%rsi
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
cvtsi2sdq (%rax),%xmm0
ucomisd %xmm1,%xmm0
jp     ddf <gsl_vector_long_isnull+0x32>
ucomisd %xmm2,%xmm0
je     df1 <gsl_vector_long_isnull+0x44>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
jne    dce <gsl_vector_long_isnull+0x21>
jmp    deb <gsl_vector_long_isnull+0x3e>
<<<sep_in_sample>>>
gsl_vector_long_isnull (const gsl_vector_long * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 13
16 13
17 17
18 17
19 17
20 17
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 2b <ttsave+0x7>
jne    5d <ttsave+0x39>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  40 <ttsave+0x1c>
mov    $0x0,%esi
mov    $0x1,%edi
callq  4f <ttsave+0x2b>
movl   $0x1,0x0(%rip)        # 59 <ttsave+0x35>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
ttsave()
{
  if (ttsaved)
   return;
  ttgetattr (0, &ttin);
  ttgetattr (1, &ttout);
  ttsaved = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 8
12 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x820,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x818(%rsp)
xor    %eax,%eax
movl   $0x0,0xc(%rsp)
mov    0x30(%rdi),%rax
movl   $0x2,(%rax)
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x22,(%rax)
jne    1365 <ReadFunction+0x30>
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
callq  1383 <ReadFunction+0x4e>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x3e,(%rax)
jne    1383 <ReadFunction+0x4e>
mov    $0x3e,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  13a6 <ReadFunction+0x71>
lea    0x410(%rsp),%rdx
lea    0xc(%rsp),%rsi
mov    %rbx,%rdi
callq  13bb <ReadFunction+0x86>
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  13d7 <ReadFunction+0xa2>
mov    $0x14,%ecx
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
callq  13f1 <ReadFunction+0xbc>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
cmpb   $0x3e,(%rax)
jne    13f1 <ReadFunction+0xbc>
mov    0x818(%rsp),%rax
xor    %fs:0x28,%rax
je     141a <ReadFunction+0xe5>
callq  141a <ReadFunction+0xe5>
add    $0x820,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
ReadFunction (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  int bInited = 0;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 62);
  ReadApply (pibIn, &bInited, szEqn);
  printf ("rate for %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 20);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 6
9 7
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 13
32 13
33 13
34 13
35 13
36 14
37 14
38 14
39 14
40 14
41 15
42 15
43 15
44 15
45 15
46 16
47 16
48 16
49 16
50 16
51 16
52 16
<<<sep_out_sample>>>
mov    %rsi,0xa0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_digest_md5_set (Gsasl * ctx,
          Gsasl_server_callback_digest_md5 cb)
{
  ctx->cbs_digest_md5 = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdi        # 7d7 <cd_eject+0x8>
mov    $0x1,%ebx
test   %rdi,%rdi
je     829 <cd_eject+0x5a>
callq  772 <cd_stop>
mov    $0x0,%edi
callq  b <action>
mov    $0x0,%edi
callq  7fa <cd_eject+0x2b>
test   %eax,%eax
sete   %bl
je     80b <cd_eject+0x3c>
mov    $0x0,%edi
callq  5e4 <xperror>
movb   $0x0,0x0(%rip)        # 812 <cd_eject+0x43>
mov    0x0(%rip),%rdi        # 819 <cd_eject+0x4a>
callq  81e <cd_eject+0x4f>
movq   $0x0,0x0(%rip)        # 829 <cd_eject+0x5a>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
cd_eject(void)
{
  _Bool b_ok = 1;
  if (p_cdio) {
    cd_stop(p_cdio);
    action("eject...");
    b_ok = DRIVER_OP_SUCCESS == cdio_eject_media(&p_cdio);
    if (!b_ok)
      xperror("eject");
    b_cd = 0;
    cdio_destroy (p_cdio);
    p_cdio = ((void *)0);
  }
  return b_ok;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 4
5 4
6 5
7 6
8 6
9 7
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 11
18 11
19 12
20 15
21 15
22 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%rbx
mov    %rsp,%rdi
callq  a2 <tar_sparse_init>
mov    $0x3,%edx
test   %al,%al
je     1f82 <sparse_skip_file+0x5c>
mov    %rbx,0x18(%rsp)
movl   $0xffffffff,(%rsp)
mov    %rsp,%rdi
callq  3c <tar_sparse_decode_header>
mov    %eax,%ebx
mov    0x18(%rsp),%rcx
mov    0x118(%rcx),%rdi
sub    0x10(%rsp),%rdi
callq  1f6b <sparse_skip_file+0x45>
mov    %rsp,%rdi
callq  0 <tar_sparse_done>
mov    $0x1,%edx
test   %al,%al
je     1f82 <sparse_skip_file+0x5c>
xor    $0x1,%ebx
movzbl %bl,%edx
mov    %edx,%eax
add    $0x30,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
sparse_skip_file (struct tar_stat_info *st)
{
  _Bool rc = 1;
  struct tar_sparse_file file;
  if (!tar_sparse_init (&file))
    return dump_status_not_implemented;
  file.stat_info = st;
  file.fd = -1;
  rc = tar_sparse_decode_header (&file);
  skip_file (file.stat_info->archive_file_size - file.dumped_size);
  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 6
7 5
8 5
9 7
10 8
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 12
<<<sep_out_sample>>>
mov    $0x2200,%eax
retq   
<<<sep_in_sample>>>
taruib_get_bufferlen(void)
{
 return sizeof(g_taruib_gst_bufferM);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x1c(%rdi),%edi
callq  1ab8 <gtags_show_statistics+0xc>
mov    0x12a4(%rbx),%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1acd <gtags_show_statistics+0x21>
mov    $0x0,%eax
callq  1ad7 <gtags_show_statistics+0x2b>
mov    0x1c(%rbx),%edi
callq  1adf <gtags_show_statistics+0x33>
mov    (%rbx),%rdx
mov    0x306c(%rdx),%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1af7 <gtags_show_statistics+0x4b>
mov    $0x0,%eax
callq  1b01 <gtags_show_statistics+0x55>
pop    %rbx
retq   
<<<sep_in_sample>>>
gtags_show_statistics(GTOP *gtop)
{
 fprintf(stderr, "Numbers of gtags (%s): %d\n", dbname(gtop->db), gtop->readcount);
 fprintf(stderr, "Numbers of dbop  (%s): %d\n", dbname(gtop->db), gtop->dbop->readcount);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 5
21 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 577 <do_statusbar_delete+0x7>
add    0x0(%rip),%rdi        # 57e <do_statusbar_delete+0xe>
cmpb   $0x0,(%rdi)
je     5e8 <do_statusbar_delete+0x78>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x0,%esi
callq  596 <do_statusbar_delete+0x26>
mov    %eax,%esi
mov    0x0(%rip),%r8        # 59f <do_statusbar_delete+0x2f>
mov    %r8,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    0x0(%rip),%rdi        # 5ba <do_statusbar_delete+0x4a>
movslq %esi,%rax
mov    %rcx,%rdx
sub    %rdi,%rdx
sub    %rax,%rdx
add    %rdi,%rax
lea    (%r8,%rax,1),%rsi
add    %r8,%rdi
callq  5d5 <do_statusbar_delete+0x65>
mov    $0x0,%edi
callq  5df <do_statusbar_delete+0x6f>
callq  5e4 <do_statusbar_delete+0x74>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
do_statusbar_delete(void)
{
    if (answer[statusbar_x] != '\0') {
 int char_len = parse_mbchar(answer + statusbar_x, ((void *)0), ((void *)0));
 memmove(answer + statusbar_x, answer + statusbar_x + char_len, (strlen(answer) - statusbar_x - char_len + 1) * sizeof(char))
                                               ;
 align(&answer);
 update_the_statusbar();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 7
26 7
27 8
28 10
29 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # b <__gmpf_init+0xb>
movl   $0x0,0x4(%rdi)
movq   $0x0,0x8(%rdi)
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 2a <__gmpf_init+0x2a>
mov    %rax,0x10(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmpf_init (mpf_ptr r)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  r->_mp_size = 0;
  r->_mp_exp = 0;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 6
7 7
8 7
9 7
10 8
11 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 8a5 <rl_crlf+0xb>
mov    $0xa,%edi
callq  8af <rl_crlf+0x15>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_crlf ()
{
  _IO_putc ('\n', _rl_out_stream);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
callq  a1e <yywrap+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yywrap ()
{
  return context_pop ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rcx,%rcx
je     596 <gsl_permute_complex_float+0xa6>
push   %rbp
push   %rbx
lea    (%rdx,%rdx,1),%r10
lea    0x0(,%rdx,8),%rbx
mov    %rsi,%r11
mov    $0x0,%edx
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    521 <gsl_permute_complex_float+0x31>
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     518 <gsl_permute_complex_float+0x28>
cmp    %rax,%rdx
ja     582 <gsl_permute_complex_float+0x92>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     582 <gsl_permute_complex_float+0x92>
mov    0x4(%r11),%r9d
shl    $0x20,%r9
mov    (%r11),%ebp
or     %r9,%rbp
jmp    545 <gsl_permute_complex_float+0x55>
mov    %r8,%rax
mov    %r9,%r8
mov    %r8,%r9
imul   %r10,%r9
imul   %r10,%rax
movss  (%rsi,%r9,4),%xmm0
movss  %xmm0,(%rsi,%rax,4)
movss  0x4(%rsi,%r9,4),%xmm0
movss  %xmm0,0x4(%rsi,%rax,4)
mov    (%rdi,%r8,8),%r9
cmp    %rdx,%r9
jne    53f <gsl_permute_complex_float+0x4f>
imul   %r10,%r8
mov    %ebp,(%rsi,%r8,4)
shr    $0x20,%rbp
mov    %ebp,0x4(%rsi,%r8,4)
add    $0x1,%rdx
add    %rbx,%r11
cmp    %rcx,%rdx
jne    50f <gsl_permute_complex_float+0x1f>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_complex_float (const size_t * p, float * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        float t[2];
        for (a = 0; a < 2; a++)
          t[a] = data[i*stride*2 + a];
        while (pk != i)
          {
            for (a = 0; a < 2; a++)
              {
                float r1 = data[pk*stride*2 + a];
                data[k*stride*2 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 2; a++)
          data[k*stride*2 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 23
6 23
7 23
8 4
9 6
10 7
11 7
12 8
13 7
14 7
15 9
16 9
17 11
18 12
19 12
20 18
21 18
22 18
23 18
24 18
25 18
26 27
27 23
28 23
29 24
30 23
31 24
32 23
33 24
34 27
35 19
36 19
37 30
38 30
39 30
40 30
41 4
42 4
43 4
44 4
45 34
46 34
47 34
48 34
49 34
50 34
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1c44 <asm_get_in+0x7>
retq   
<<<sep_in_sample>>>
asm_get_in (void)
{
        return asm_in;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    (%rdx),%r12
mov    0x18(%rsi),%rdi
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  *(%rsi)
movsd  %xmm0,0x0(%rbp)
mov    0x18(%rbx),%rdi
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  *0x8(%rbx)
movsd  %xmm0,0x8(%rbp)
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
newton_init (void * vstate, gsl_function_fdf * fdf, double * root)
{
  newton_state_t * state = (newton_state_t *) vstate;
  const double x = *root ;
  state->f = (*((fdf)->f))(x,(fdf)->params);
  state->df = (*((fdf)->df))(x,(fdf)->params) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  62 <etar_close+0xd>
mov    %rbx,%rdi
callq  6a <etar_close+0x15>
pop    %rbx
retq   
<<<sep_in_sample>>>
etar_close (ETAR * etar)
{
 free(etar->tar_hdrM);
 free(etar);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %edx,%r12d
mov    %ecx,%r13d
mov    %r8,%r14
mov    $0x0,%esi
callq  ddb <gdbm_load+0x21>
mov    %rax,%rbx
test   %rax,%rax
jne    df4 <gdbm_load+0x3a>
movl   $0x3,0x0(%rip)        # ded <gdbm_load+0x33>
mov    $0xffffffff,%eax
jmp    e14 <gdbm_load+0x5a>
mov    %r14,%r8
mov    %r13d,%ecx
mov    %r12d,%edx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  e08 <gdbm_load+0x4e>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  e12 <gdbm_load+0x58>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gdbm_load (GDBM_FILE *pdbf, const char *filename, int replace,
    int meta_mask,
    unsigned long *line)
{
  FILE *fp;
  int rc;
  fp = fopen (filename, "r");
  if (!fp)
    {
      gdbm_errno = 3;
      return -1;
    }
  rc = gdbm_load_from_file (pdbf, fp, replace, meta_mask, line);
  fclose (fp);
  return rc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 7
12 7
13 7
14 8
15 8
16 10
17 11
18 11
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 14
27 14
28 15
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r13d
test   %edi,%edi
js     63b <replace_history_entry+0xb8>
mov    %rsi,%rbp
mov    %rdx,%r15
mov    $0x0,%eax
cmp    0x0(%rip),%edi        # 5ad <replace_history_entry+0x2a>
jge    640 <replace_history_entry+0xbd>
mov    $0x18,%edi
callq  5bd <replace_history_entry+0x3a>
mov    %rax,%rbx
movslq %r13d,%r13
mov    0x0(%rip),%rax        # 5ca <replace_history_entry+0x47>
mov    (%rax,%r13,8),%r12
mov    $0xffffffffffffffff,%r14
mov    %rbp,%rdi
mov    %r14,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  5ed <replace_history_entry+0x6a>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  5f8 <replace_history_entry+0x75>
mov    %rax,(%rbx)
mov    %r15,0x10(%rbx)
mov    0x8(%r12),%rbp
mov    %rbp,%rdi
mov    %r14,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  61c <replace_history_entry+0x99>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  627 <replace_history_entry+0xa4>
mov    %rax,0x8(%rbx)
mov    0x0(%rip),%rax        # 632 <replace_history_entry+0xaf>
mov    %rbx,(%rax,%r13,8)
mov    %r12,%rax
jmp    640 <replace_history_entry+0xbd>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
replace_history_entry (which, line, data)
     int which;
     const char *line;
     histdata_t data;
{
  HIST_ENTRY *temp, *old_value;
  if (which < 0 || which >= history_length)
    return ((HIST_ENTRY *)((void *)0));
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  old_value = the_history[which];
  temp->line = strcpy (xmalloc (1 + strlen (line)), (line));
  temp->data = data;
  temp->timestamp = strcpy (xmalloc (1 + strlen (old_value->timestamp)), (old_value->timestamp));
  the_history[which] = temp;
  return (old_value);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 7
15 7
16 9
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 14
48 14
49 15
50 15
51 8
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 19a8 <ppdset_out+0x7>
retq   
<<<sep_in_sample>>>
ppdset_out (FILE * out_str )
{
        ppdout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movzbl %sil,%esi
movzbl 0x1c(%rdi),%eax
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
mov    0x163c(%rdi,%rax,8),%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
retq   
<<<sep_in_sample>>>
get_track_channels_image(const void *p_user_data, track_t i_track)
{
  const _img_private_t *p_env = p_user_data;
  return ( p_env->tocent[i_track-p_env->gen.i_first_track].flags
   & FOUR_CHANNEL_AUDIO ) ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     6737 <dequote_list+0x5c>
mov    %rdi,%rbx
mov    0x8(%rbx),%rax
mov    (%rax),%rdi
callq  66f6 <dequote_list+0x1b>
mov    %rax,%rbp
mov    0x8(%rbx),%rdx
mov    (%rdx),%rcx
cmpb   $0x7f,(%rcx)
jne    6712 <dequote_list+0x37>
cmpb   $0x0,0x1(%rcx)
jne    6712 <dequote_list+0x37>
andl   $0xfffbffff,0x8(%rdx)
mov    0x8(%rbx),%rcx
mov    $0xfe8,%edx
mov    $0x0,%esi
mov    (%rcx),%rdi
callq  6728 <dequote_list+0x4d>
mov    0x8(%rbx),%rax
mov    %rbp,(%rax)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    66ea <dequote_list+0xf>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dequote_list (list)
     WORD_LIST *list;
{
  register char *s;
  register WORD_LIST *tlist;
  for (tlist = list; tlist; tlist = tlist->next)
    {
      s = dequote_string (tlist->word->word);
      if (((tlist->word->word)[0] == '\177' && (tlist->word->word)[1] == '\0'))
 tlist->word->flags &= ~0x040000;
      sh_xfree((tlist->word->word), "subst.c", 4072);
      tlist->word->word = s;
    }
  return list;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 11
20 11
21 11
22 11
23 11
24 12
25 12
26 6
27 6
28 6
29 15
30 15
31 15
32 15
33 15
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gc_done (void)
{
  return;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     351 <hash_delete_at+0x1d>
mov    0x0(%rip),%rdx        # 343 <hash_delete_at+0xf>
cmp    %rdx,%rax
je     357 <hash_delete_at+0x23>
mov    %rdx,(%rsi)
subq   $0x1,0x18(%rdi)
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
hash_delete_at (struct hash_table* ht, void const *slot)
{
  void *item = *(void **) slot;
  if (!((item) == 0 || (void *) (item) == hash_deleted_item))
    {
      *(void const **) slot = hash_deleted_item;
      ht->ht_fill--;
      return item;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 6
8 7
9 8
10 11
11 11
12 11
13 12
<<<sep_out_sample>>>
test   %rsi,%rsi
je     10ac <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jae    10b2 <_argp_input+0x3e>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
jmp    1098 <_argp_input+0x24>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
mov    0x30(%rax),%rax
retq   
add    $0x48,%rax
cmp    %rdx,%rax
jb     1092 <_argp_input+0x1e>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
        if (group->argp == argp)
          return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 7
16 7
17 7
18 11
19 11
20 11
21 11
22 11
23 12
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x30(%rdi),%rdx
movslq 0xc(%rsi),%rax
mov    0x0(,%rax,8),%rsi
mov    %rsp,%rdi
callq  1f36 <coerce_k2d+0x20>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    1f4d <coerce_k2d+0x37>
lea    0x10(%rbx),%rsi
mov    %rsp,%rdi
callq  1f4d <coerce_k2d+0x37>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
coerce_k2d (struct gdbmarg *arg, struct argdef *def)
{
  datum d;
  if (datum_scan (&d, dsdef[def->ds], arg->v.kvpair))
    return ((void *)0);
  return gdbmarg_datum (&d, &arg->loc);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 4
12 4
13 6
14 6
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %rsi,%rbx
movq   $0x0,0x8(%rsp)
movq   $0x0,0x18(%rsp)
mov    %rdx,(%rsp)
mov    %rcx,0x10(%rsp)
mov    %rsp,%rdx
callq  185a <set_file_times+0x2b>
test   %eax,%eax
jns    1870 <set_file_times+0x41>
callq  1863 <set_file_times+0x34>
cmpl   $0x1e,(%rax)
je     1870 <set_file_times+0x41>
mov    %rbx,%rdi
callq  1870 <set_file_times+0x41>
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
set_file_times (int fd,
  const char *name, unsigned long atime, unsigned long mtime)
{
  struct timespec ts[2];
  memset (&ts, 0, sizeof ts);
  ts[0].tv_sec = atime;
  ts[1].tv_sec = mtime;
  if (fdutimens (fd, name, ts) < 0 && (*__errno_location ()) != 30)
    utime_error (name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 6
7 7
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 10
18 10
19 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x88,%rsp
mov    %rdi,%rbp
mov    %edx,%ebx
mov    %rsp,%rdi
callq  1aef <delay_set_stat+0x16>
mov    %rbp,0x68(%rsp)
mov    %ebx,%esi
mov    %rsp,%rdi
callq  1afe <delay_set_stat+0x25>
add    $0x88,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
delay_set_stat (char const *file_name, struct stat *st,
  mode_t invert_permissions)
{
  struct cpio_file_stat fs;
  stat_to_cpio (&fs, st);
  fs.c_name = (char*) file_name;
  delay_cpio_set_stat (&fs, invert_permissions);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 7
10 7
11 7
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  18 <free_ref+0xd>
mov    %rbx,%rdi
callq  20 <free_ref+0x15>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
free_ref(void *a, void *b)
{
    struct gcide_ref *ref = a;
    free(ref->ref_headword);
    free(ref);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
mov    $0x0,%eax
cmove  %rax,%rdi
movl   $0x8,(%rdi)
test   %rsi,%rsi
je     dbf <set_custom_quoting+0x20>
test   %rdx,%rdx
jne    dc4 <set_custom_quoting+0x25>
callq  dc4 <set_custom_quoting+0x25>
mov    %rsi,0x28(%rdi)
mov    %rdx,0x30(%rdi)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_custom_quoting (struct quoting_options *o,
                    char const *left_quote, char const *right_quote)
{
  if (!o)
    o = &default_quoting_options;
  o->style = custom_quoting_style;
  if (!left_quote || !right_quote)
    abort ();
  o->left_quote = left_quote;
  o->right_quote = right_quote;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 6
6 7
7 7
8 7
9 7
10 8
11 9
12 10
13 11
14 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1419 <set_modified+0x7>
cmpb   $0x0,0x48(%rax)
jne    149a <set_modified+0x88>
push   %rbx
movb   $0x1,0x48(%rax)
mov    $0x0,%edi
callq  142e <set_modified+0x1c>
testb  $0x8,0x0(%rip)        # 1435 <set_modified+0x23>
je     1499 <set_modified+0x87>
mov    0x0(%rip),%rax        # 143e <set_modified+0x2c>
mov    (%rax),%rdi
cmpb   $0x0,(%rdi)
je     1499 <set_modified+0x87>
cmpq   $0x0,0x90(%rax)
jne    146e <set_modified+0x5c>
mov    $0x0,%edi
callq  145a <set_modified+0x48>
mov    %rax,%rsi
mov    $0x2,%edi
mov    $0x0,%eax
callq  146c <set_modified+0x5a>
jmp    1499 <set_modified+0x87>
callq  1473 <set_modified+0x61>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 147d <set_modified+0x6b>
mov    0x90(%rax),%rdi
mov    $0x1,%edx
mov    %rbx,%rsi
callq  1491 <set_modified+0x7f>
mov    %rbx,%rdi
callq  1499 <set_modified+0x87>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
set_modified(void)
{
    if (openfile->modified)
 return;
    openfile->modified = 1;
    titlebar(((void *)0));
    if (!((flags[((LOCKING) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((LOCKING) % (sizeof(unsigned) * 8)))) != 0) || openfile->filename[0] == '\0')
 return;
    if (openfile->lock_filename == ((void *)0)) {
 statusline(ALERT, gettext("Warning: Modifying a file which is not locked," " check directory permission?")
                                  );
    } else {
 char *fullname = get_full_path(openfile->filename);
 write_lockfile(openfile->lock_filename, fullname, 1);
 free(fullname);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 13
24 13
25 14
26 14
27 14
28 14
29 14
30 15
31 15
32 17
33 17
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_int_data (const gsl_block_int * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    %rsi,0xb0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_anonymous_set (Gsasl * ctx,
         Gsasl_server_callback_anonymous cb)
{
  ctx->cbs_anonymous = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  b75 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
je     1299 <shcmd_get_last_command+0x19>
add    $0x8,%rdi
mov    (%rdi),%rdx
test   %rdx,%rdx
je     1299 <shcmd_get_last_command+0x19>
mov    %rdx,%rax
jmp    1288 <shcmd_get_last_command+0x8>
repz retq 
<<<sep_in_sample>>>
shcmd_get_last_command(SHCMD ** cmdvec)
{
 SHCMD ** v;
 SHCMD * last;
 last = ((void *)0);
 v = cmdvec;
 while (*v) {
  last = *v;
  v++;
 }
 return last;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 9
5 7
6 7
7 7
8 7
9 7
10 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 6b6 <dispinit+0xa>
lea    -0xd(%rax),%edx
mov    %edx,0x0(%rip)        # 6bf <dispinit+0x13>
sub    $0xf,%eax
mov    %eax,0x0(%rip)        # 6c8 <dispinit+0x1c>
test   %eax,%eax
jne    6dd <dispinit+0x31>
mov    0x0(%rip),%rsi        # 6d3 <dispinit+0x27>
mov    $0x0,%edi
callq  6dd <dispinit+0x31>
cmpl   $0x0,0x0(%rip)        # 6e4 <dispinit+0x38>
jne    6f9 <dispinit+0x4d>
cmpl   $0x3e,0x0(%rip)        # 6ed <dispinit+0x41>
jbe    6f9 <dispinit+0x4d>
movl   $0x3e,0x0(%rip)        # 6f9 <dispinit+0x4d>
mov    0x0(%rip),%edi        # 6ff <dispinit+0x53>
shl    $0x2,%rdi
callq  708 <dispinit+0x5c>
mov    %rax,0x0(%rip)        # 70f <dispinit+0x63>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dispinit(void)
{
 lastdispline = (LINES - 9 - 1) - 3;
 mdisprefs = lastdispline - 3 + 1;
 if (mdisprefs <= 0) {
  postfatal("%s: screen too small\n", argv0);
 }
 if (mouse == NO && mdisprefs > strlen(dispchars))
  mdisprefs = strlen(dispchars);
 displine = mymalloc(mdisprefs * sizeof(int));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 9
17 10
18 10
19 10
20 10
21 11
22 11
<<<sep_out_sample>>>
push   %rbx
mov    $0x58,%edi
callq  bc4 <create_new_variable_set+0xb>
mov    %rax,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0xd,%esi
mov    %rax,%rdi
callq  be4 <create_new_variable_set+0x2b>
mov    $0x18,%edi
callq  bee <create_new_variable_set+0x35>
mov    %rbx,0x8(%rax)
mov    0x0(%rip),%rdx        # bf9 <create_new_variable_set+0x40>
mov    %rdx,(%rax)
movl   $0x0,0x10(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
create_new_variable_set (void)
{
  register struct variable_set_list *setlist;
  register struct variable_set *set;
  set = xmalloc (sizeof (struct variable_set));
  hash_init (&set->table, 13,
             variable_hash_1, variable_hash_2, variable_hash_cmp);
  setlist = (struct variable_set_list *)
    xmalloc (sizeof (struct variable_set_list));
  setlist->set = set;
  setlist->next = current_variable_set_list;
  setlist->next_is_parent = 0;
  return setlist;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 6
11 8
12 8
13 10
14 11
15 11
16 12
17 14
18 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     12 <gsasl_mechanism_name+0x12>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     18 <gsasl_mechanism_name+0x18>
mov    (%rax),%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_mechanism_name (Gsasl_session * sctx)
{
  if (!sctx || !sctx->mech)
    return ((void *)0);
  return sctx->mech->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 4
9 4
10 4
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  86a <check_bash_input+0x8>
test   %eax,%eax
je     8a9 <check_bash_input+0x47>
test   %ebx,%ebx
jle    88b <check_bash_input+0x29>
mov    $0xffffffff,%esi
mov    %ebx,%edi
callq  87e <check_bash_input+0x1c>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
jmp    8a9 <check_bash_input+0x47>
mov    $0x0,%eax
test   %ebx,%ebx
jne    8a9 <check_bash_input+0x47>
mov    $0x0,%edi
callq  89e <check_bash_input+0x3c>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
pop    %rbx
retq   
<<<sep_in_sample>>>
check_bash_input (fd)
     int fd;
{
  if (fd_is_bash_input (fd))
    {
      if (fd > 0)
 return ((save_bash_input (fd, -1) == -1) ? -1 : 0);
      else if (fd == 0)
        return ((sync_buffered_stream (fd) == -1) ? -1 : 0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 11
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 12
26 12
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2cd <swlib_set_swbis_verbose_threshold+0x6>
retq   
<<<sep_in_sample>>>
swlib_set_swbis_verbose_threshold(int s)
{
 verbose_swbis_event_thresholdG = s;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # 99 <nettle_gcm_aes_encrypt+0x26>
mov    %rax,%rsi
callq  a1 <nettle_gcm_aes_encrypt+0x2e>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes_encrypt(struct gcm_aes_ctx *ctx,
  size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_encrypt(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
cmpl   $0x9,0x8(%rsi)
jne    5047 <_jit_arg_register_p+0x12>
cmpq   $0x5,0x10(%rsi)
setbe  %al
movzbl %al,%eax
retq   
cmpq   $0x7,0x10(%rsi)
setbe  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
_jit_arg_register_p(jit_state_t *_jit, jit_node_t *u)
{
    if (u->code == jit_code_arg)
 return (((u->u.w) >= 0 && (u->u.w) < 6));
    ((void) (0));
    return (((u->u.w) >= 0 && (u->u.w) < 8));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%rbx
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbp
movsd  %xmm1,0x8(%rsp)
mov    0x8(%rsp),%r12
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,0x10(%rsp)
movl   $0x454e494c,0x4(%rdi)
movb   $0x0,0x8(%rdi)
mov    %rbp,0x18(%rsp)
callq  b42 <pict_rectangle+0x42>
mov    %rbp,0x18(%rsp)
movsd  0x18(%rsp),%xmm4
addsd  0x8(%rsp),%xmm4
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
movsd  %xmm4,0x8(%rsp)
movapd %xmm4,%xmm0
mov    %rbx,%rdi
callq  b70 <pict_rectangle+0x70>
mov    %r12,0x18(%rsp)
movsd  0x18(%rsp),%xmm5
addsd  0x10(%rsp),%xmm5
movsd  %xmm5,0x10(%rsp)
movapd %xmm5,%xmm1
movsd  0x8(%rsp),%xmm0
mov    %rbx,%rdi
callq  b99 <pict_rectangle+0x99>
movsd  0x10(%rsp),%xmm1
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %rbx,%rdi
callq  bb2 <pict_rectangle+0xb2>
mov    %r12,0x8(%rsp)
movsd  0x8(%rsp),%xmm1
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %rbx,%rdi
callq  bd0 <pict_rectangle+0xd0>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
pict_rectangle(pict *p, double llx, double lly, double sx, double sy)
{
  strcpy(p->pict_type, "LINE");
  pict_point(p, llx, lly);
  pict_point(p, llx + sx, lly);
  pict_point(p, llx + sx, lly + sy);
  pict_point(p, llx, lly + sy);
  pict_point(p, llx, lly);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 3
13 3
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 7
34 7
35 7
36 7
37 7
38 8
39 8
40 8
41 8
42 8
43 8
44 9
45 9
46 9
47 9
48 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  558 <gsl_stats_int_kurtosis+0x18>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  571 <gsl_stats_int_kurtosis+0x31>
movapd %xmm0,%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  58e <gsl_stats_int_kurtosis+0x4e>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_int_kurtosis (const int data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_int_mean(data, stride, n);
  const double est_sd = gsl_stats_int_sd_m(data, stride, n, mean);
  return gsl_stats_int_kurtosis_m_sd(data, stride, n, mean, est_sd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # f1 <_rl_arg_getchar+0xa>
imul   0x0(%rip),%esi        # f8 <_rl_arg_getchar+0x11>
mov    $0x0,%edi
mov    $0x0,%eax
callq  107 <_rl_arg_getchar+0x20>
orq    $0x40,0x0(%rip)        # 10f <_rl_arg_getchar+0x28>
callq  114 <_rl_arg_getchar+0x2d>
andq   $0xffffffffffffffbf,0x0(%rip)        # 11c <_rl_arg_getchar+0x35>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_arg_getchar ()
{
  int c;
  rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 7
10 9
11 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  b75 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rsp,%rsi
mov    $0x1,%edi
callq  b4 <osip_gettimeofday+0x19>
test   %eax,%eax
jns    c5 <osip_gettimeofday+0x2a>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  c3 <osip_gettimeofday+0x28>
jmp    f0 <osip_gettimeofday+0x55>
mov    (%rsp),%rax
mov    %rax,(%rbx)
mov    0x8(%rsp),%rcx
movabs $0x20c49ba5e353f7cf,%rdx
mov    %rcx,%rax
imul   %rdx
sar    $0x7,%rdx
sar    $0x3f,%rcx
sub    %rcx,%rdx
mov    %rdx,0x8(%rbx)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_gettimeofday (struct timeval *tp, void *tz)
{
  struct timespec ts;
  if (clock_gettime (1, &ts) < 0) {
    gettimeofday (tp, tz);
    return 0;
  }
  tp->tv_sec = ts.tv_sec + offset.tv_sec;
  tp->tv_usec = ts.tv_nsec / 1000;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     74 <anubis_keyword_lookup_ci+0x2e>
mov    %rbp,%rsi
callq  62 <anubis_keyword_lookup_ci+0x1c>
test   %eax,%eax
je     7b <anubis_keyword_lookup_ci+0x35>
add    $0x10,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    5a <anubis_keyword_lookup_ci+0x14>
jmp    82 <anubis_keyword_lookup_ci+0x3c>
mov    $0x0,%eax
jmp    87 <anubis_keyword_lookup_ci+0x41>
mov    %rbx,%rax
xchg   %ax,%ax
jmp    87 <anubis_keyword_lookup_ci+0x41>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
anubis_keyword_lookup_ci (struct anubis_keyword *tab, const char *name)
{
  for (; tab->name; tab++)
    if (strcasecmp (tab->name, name) == 0)
      return tab;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 3
14 3
15 3
16 3
17 3
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     d6 <osip_dialog_update_osip_cseq_as_uas+0x32>
test   %rsi,%rsi
je     dd <osip_dialog_update_osip_cseq_as_uas+0x39>
mov    0xe0(%rsi),%rax
test   %rax,%rax
je     e4 <osip_dialog_update_osip_cseq_as_uas+0x40>
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     eb <osip_dialog_update_osip_cseq_as_uas+0x47>
callq  cc <osip_dialog_update_osip_cseq_as_uas+0x28>
mov    %eax,0x34(%rbx)
mov    $0x0,%eax
jmp    f0 <osip_dialog_update_osip_cseq_as_uas+0x4c>
mov    $0xfffffffe,%eax
jmp    f0 <osip_dialog_update_osip_cseq_as_uas+0x4c>
mov    $0xfffffffe,%eax
jmp    f0 <osip_dialog_update_osip_cseq_as_uas+0x4c>
mov    $0xfffffffe,%eax
jmp    f0 <osip_dialog_update_osip_cseq_as_uas+0x4c>
mov    $0xfffffffe,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_dialog_update_osip_cseq_as_uas (osip_dialog_t * dialog, osip_message_t * invite)
{
  if (dialog == ((void *)0))
    return -2;
  if (invite == ((void *)0) || invite->cseq == ((void *)0) || invite->cseq->number == ((void *)0))
    return -2;
  dialog->remote_cseq = osip_atoi (invite->cseq->number);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 8
16 8
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 9
25 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
movzbl %dil,%eax
retq   
<<<sep_in_sample>>>
__rrank (char c)
{
  return ((unsigned char) c);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r9d
mov    $0x1,%r8d
mov    $0x0,%ecx
callq  234c <cmdline_parser_string+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cmdline_parser_string(const char *cmdline, struct gengetopt_args_info *args_info, const char *prog_name)
{
  return cmdline_parser_string2(cmdline, args_info, prog_name, 0, 1, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  65 <_mimepart_body_size+0x9>
mov    %rax,%rdi
callq  6d <_mimepart_body_size+0x11>
mov    $0x16,%edx
test   %rax,%rax
je     8c <_mimepart_body_size+0x30>
test   %rbx,%rbx
je     87 <_mimepart_body_size+0x2b>
mov    0x18(%rax),%rax
mov    %rax,(%rbx)
mov    $0x0,%dl
jmp    8c <_mimepart_body_size+0x30>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_mimepart_body_size (mu_body_t body, size_t *psize)
{
  mu_message_t msg = mu_body_get_owner (body);
  struct _mime_part *mime_part = mu_message_get_owner (msg);
  if (mime_part == ((void *)0))
    return 22;
  if (psize)
    *psize = mime_part->len;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 5
8 5
9 7
10 7
11 8
12 8
13 9
14 9
15 9
16 10
17 10
18 10
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
movb   $0x0,0xf(%rsp)
mov    0x0(%rip),%eax        # 309d <shadow_funcs+0x10>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # 30a6 <shadow_funcs+0x19>
test   %eax,%eax
je     30d0 <shadow_funcs+0x43>
mov    $0x1098,%esi
mov    $0x0,%edi
callq  30b9 <shadow_funcs+0x2c>
mov    $0x0,%edi
callq  30c3 <shadow_funcs+0x36>
mov    %rax,%rdi
mov    $0x0,%eax
callq  30d0 <shadow_funcs+0x43>
mov    $0x1,%edi
callq  30da <shadow_funcs+0x4d>
mov    %rax,%rbx
lea    0xf(%rsp),%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  30ef <shadow_funcs+0x62>
mov    %rbx,%rdi
callq  30f7 <shadow_funcs+0x6a>
cmpb   $0x0,0xf(%rsp)
je     3135 <shadow_funcs+0xa8>
cmpq   $0x0,0x0(%rip)        # 3109 <shadow_funcs+0x7c>
jne    3135 <shadow_funcs+0xa8>
mov    $0x10a0,%esi
mov    $0x0,%edi
callq  311a <shadow_funcs+0x8d>
mov    0x0(%rip),%rbx        # 3121 <shadow_funcs+0x94>
mov    $0x0,%edi
callq  312b <shadow_funcs+0x9e>
mov    %rax,%rdi
mov    $0x0,%eax
callq  *%rbx
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
shadow_funcs()
{
 static int calls = 0;
 _Bool shadow = 0;
 NODE **funcs;
 if (calls++ != 0)
  (*(set_loc("awkgram.y", 4248), r_fatal))(gettext("shadow_funcs() called twice!"));
 funcs = function_list(1);
 (void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) parms_shadow, & shadow);
 free(funcs);
 if (shadow && lintfunc == r_fatal)
  (*(set_loc("awkgram.y", 4256),lintfunc))(gettext("there were shadowed variables."));
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 6
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 10
25 10
26 11
27 11
28 11
29 11
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 13
40 13
41 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     726 <putabranch+0x2d>
mov    %rsi,%rbp
mov    0x60(%rdi),%rdi
callq  6f9 <putabranch>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    %rbx,%rsi
mov    %rbx,%rdi
callq  39e <putadelta>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
putabranch (struct delta const *root, const char *insDelFormat)
{
  if (!root)
    return;
  putabranch (root->ilk, insDelFormat);
  putadelta (root, root, 0, insDelFormat);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
jne    818 <ck_realloc+0x15>
callq  811 <ck_realloc+0xe>
mov    $0x0,%eax
jmp    83c <ck_realloc+0x39>
test   %rdi,%rdi
jne    827 <ck_realloc+0x24>
mov    %rsi,%rdi
callq  825 <ck_realloc+0x22>
jmp    83c <ck_realloc+0x39>
callq  82c <ck_realloc+0x29>
test   %rax,%rax
nop
jne    83c <ck_realloc+0x39>
mov    $0x0,%edi
callq  83c <ck_realloc+0x39>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ck_realloc(ptr, size)
  void *ptr;
  size_t size;
{
  void *ret;
  if (size == 0)
    {
      (ck_free(ptr));
      return ((void *)0);
    }
  if (!ptr)
    return ck_malloc(size);
  ret = realloc(ptr, size);
  if (!ret)
    panic("couldn't re-allocate memory");
  return ret;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 9
6 9
7 11
8 11
9 12
10 12
11 12
12 13
13 14
14 14
15 14
16 15
17 15
18 17
19 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
movb   $0x0,0x0(%rip)        # 4b9 <parse_depth+0xb>
movb   $0x1,0x0(%rip)        # 4c0 <parse_depth+0x12>
callq  3dc <parse_noop>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_depth (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  (void) entry;
  (void) argv;
  options.do_dir_first = 0;
  options.explicit_depth = 1;
  return parse_noop (entry, argv, arg_ptr);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 7
5 8
6 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1270 <quotearg_custom+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom (char const *left_quote, char const *right_quote,
   char const *arg)
{
  return quotearg_n_custom (0, left_quote, right_quote, arg);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rdx,%r13
callq  22 <read_text_integer>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
je     173 <read_scan_integer+0xb6>
mov    0x0(%r13),%ebx
cmp    $0xffffffff,%ebx
je     15f <read_scan_integer+0xa2>
callq  ef <read_scan_integer+0x32>
mov    %rax,%r12
jmp    103 <read_scan_integer+0x46>
mov    %rbp,%rdi
callq  0 <text_getc>
mov    %eax,%ebx
cmp    $0xffffffff,%eax
je     15f <read_scan_integer+0xa2>
movslq %ebx,%r8
mov    (%r12),%rcx
testb  $0x20,0x1(%rcx,%r8,2)
jne    f4 <read_scan_integer+0x37>
callq  117 <read_scan_integer+0x5a>
movslq %ebx,%rdx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rdx,2)
je     13a <read_scan_integer+0x7d>
mov    %rbp,%rsi
mov    %ebx,%edi
callq  12e <read_scan_integer+0x71>
cmp    $0xffffffff,%eax
je     158 <read_scan_integer+0x9b>
mov    $0x20,%ebx
jmp    14d <read_scan_integer+0x90>
cmp    $0xffffffff,%ebx
je     14d <read_scan_integer+0x90>
lea    -0x3a(%rbx),%eax
cmp    $0x2,%eax
mov    $0x20,%eax
cmovae %eax,%ebx
mov    %ebx,0x0(%r13)
mov    $0x1,%eax
jmp    173 <read_scan_integer+0xb6>
mov    $0x0,%eax
jmp    173 <read_scan_integer+0xb6>
callq  164 <read_scan_integer+0xa7>
movslq %ebx,%rdx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rdx,2)
je     14d <read_scan_integer+0x90>
jmp    124 <read_scan_integer+0x67>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
read_scan_integer (FILE * file, long * result, int * termchar)
{
  register int ch;
  if (! read_text_integer(file, result, termchar))
    return 0;
  ch = *termchar;
  while (ch != (-1) && ((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISspace))
    ch = text_getc(file);
  if (((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISdigit)) {
    if (ungetc(ch, file) == (-1))
      return 0;
    ch = ' ';
  } else {
    if (ch != (-1) && ch != ';' && ch != ':')
      ch = ' ';
  }
  *termchar = ch;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 4
12 4
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 12
39 12
40 14
41 14
42 14
43 15
44 15
45 15
46 17
47 18
48 18
49 11
50 11
51 9
52 9
53 9
54 9
55 9
56 9
57 19
58 19
59 19
60 19
61 19
62 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    %rsi,0x68(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
msadams_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msadams_state_t *state = (msadams_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,0xc(%rsp)
mov    $0x0,%ecx
mov    $0x0,%edx
lea    0xc(%rsp),%rsi
callq  40e <command_recurse>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
shcmd_command(SHCMD ** cmd_vector)
{
 int pids = 0;
 return command_recurse(cmd_vector, &pids, 0, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     2d0 <list_prepend+0x39>
mov    %rsi,%rbp
mov    $0x10,%edi
callq  2b2 <list_prepend+0x1b>
mov    %rbp,0x8(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,0x8(%rbx)
cmpq   $0x0,0x10(%rbx)
jne    2cc <list_prepend+0x35>
mov    %rax,0x10(%rbx)
addq   $0x1,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
list_prepend (struct list *list, void *data)
{
  struct list_entry *ep;
  if (!list)
    return;
  ep = xmalloc (sizeof (*ep));
  ep->data = data;
  ep->next = list->head;
  list->head = ep;
  if (!list->tail)
    list->tail = list->head;
  list->count++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 7
11 8
12 8
13 9
14 10
15 10
16 11
17 12
18 13
19 13
20 13
21 13
<<<sep_out_sample>>>
cmpb   $0xff,(%rdi)
je     623 <nextitem+0xa>
lea    0x1(%rdi),%rax
retq   
movzbl 0x1(%rdi),%eax
cmp    $0xfa,%eax
je     641 <nextitem+0x28>
cmp    $0xfa,%eax
jl     662 <nextitem+0x49>
cmp    $0xfe,%eax
jg     662 <nextitem+0x49>
lea    0x3(%rdi),%rax
retq   
lea    0x2(%rdi),%rdx
lea    0x1(%rdx),%rax
cmpb   $0xff,(%rdx)
je     653 <nextitem+0x3a>
mov    %rax,%rdx
jmp    645 <nextitem+0x2c>
lea    0x2(%rdx),%rax
cmpb   $0xf0,0x1(%rdx)
je     666 <nextitem+0x4d>
mov    %rax,%rdx
jmp    645 <nextitem+0x2c>
lea    0x2(%rdi),%rax
repz retq 
<<<sep_in_sample>>>
nextitem (char *current)
{
  if ((*current & 0xff) != 255)
    return current + 1;
  switch (*(current + 1) & 0xff)
    {
    case 253:
    case 254:
    case 251:
    case 252:
      return current + 3;
    case 250:
      {
 char *look = current + 2;
 for (;;)
   if ((*look++ & 0xff) == 255 && (*look++ & 0xff) == 240)
     return look;
      default:
 return current + 2;
      }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 11
13 11
14 14
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 19
26 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  59c <space+0x11>
add    %rax,%rbp
cmp    0x10(%rbx),%rbp
jb     5b4 <space+0x29>
mov    $0xa,%esi
mov    %rbx,%rdi
callq  5b2 <space+0x27>
jmp    5c1 <space+0x36>
mov    $0x20,%esi
mov    %rbx,%rdi
callq  5c1 <space+0x36>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
space (argp_fmtstream_t stream, size_t ensure)
{
  if (argp_fmtstream_point (stream) + ensure
      >= ((stream)->rmargin))
    argp_fmtstream_putc (stream, '\n');
  else
    argp_fmtstream_putc (stream, ' ');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 7
15 7
16 7
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     b61 <net_output_data+0x5f>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbp
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    $0x0,%r12d
mov    %r12,%rbx
sub    0x0(%rip),%rbx        # b9b <net_output_data+0x99>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %rcx,%rbx
jb     bbe <net_output_data+0xbc>
cmp    $0x7ff,%rbx
ja     bcd <net_output_data+0xcb>
callq  bc3 <net_output_data+0xc1>
mov    %r12,%rbx
sub    0x0(%rip),%rbx        # bcd <net_output_data+0xcb>
lea    0x8(%rsp),%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # bdf <net_output_data+0xdd>
callq  be4 <net_output_data+0xe2>
sub    $0x1,%rbx
movslq %eax,%rdx
cmp    %rdx,%rbx
cmova  %rdx,%rbx
add    %rbx,0x0(%rip)        # bf9 <net_output_data+0xf7>
add    $0xd0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
net_output_data (const char *format, ...)
{
  va_list args;
  size_t remaining, ret;
  __builtin_va_start(args,format);
  remaining = 8192 - (nfrontp - netobuf);
  if (strlen (format) > remaining || 8192 / 4 > remaining)
    {
      netflush ();
      remaining = 8192 - (nfrontp - netobuf);
    }
  ret = vsnprintf (nfrontp, remaining, format, args);
  nfrontp += ((ret < remaining - 1) ? ret : remaining - 1);
  __builtin_va_end(args);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 5
22 5
23 5
24 5
25 5
26 5
27 6
28 6
29 6
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 9
40 10
41 10
42 12
43 12
44 12
45 12
46 12
47 13
48 12
49 13
50 13
51 13
52 16
53 16
54 16
55 16
56 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r12
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  104a <print_opt_full+0x1f>
mov    %rbp,%rdi
callq  1052 <print_opt_full+0x27>
cmp    $0x7,%rax
ja     1062 <print_opt_full+0x37>
mov    $0x9,%edi
callq  1062 <print_opt_full+0x37>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1074 <print_opt_full+0x49>
mov    %rbx,%rdi
callq  107c <print_opt_full+0x51>
cmp    $0x7,%rax
ja     1093 <print_opt_full+0x68>
mov    $0x0,%edi
mov    $0x0,%eax
callq  1091 <print_opt_full+0x66>
jmp    10ab <print_opt_full+0x80>
mov    %rbx,%rdi
callq  109b <print_opt_full+0x70>
cmp    $0xf,%rax
ja     10ab <print_opt_full+0x80>
mov    $0x9,%edi
callq  10ab <print_opt_full+0x80>
test   %r12,%r12
je     10ca <print_opt_full+0x9f>
mov    %r12,%rdi
callq  10b8 <print_opt_full+0x8d>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  10ca <print_opt_full+0x9f>
mov    $0xa,%edi
callq  10d4 <print_opt_full+0xa9>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_opt_full(const char *shortflag
 , const char *longflag
 , const char *desc)
{
    printf(" %s\t", shortflag);
    if (strlenpt(shortflag) < 8)
 printf("\t");
    printf("%s\t", longflag);
    if (strlenpt(longflag) < 8)
 printf("\t\t");
    else if (strlenpt(longflag) < 16)
 printf("\t");
    if (desc != ((void *)0))
 printf("%s", gettext(desc));
    printf("\n");
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 12
34 12
35 13
36 13
37 14
38 14
39 14
40 14
41 14
42 14
43 15
44 15
45 16
46 16
47 16
48 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x160,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %rsp,%rdi
callq  42fa <sha512_buffer+0x1c>
mov    %rsp,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  4308 <sha512_buffer+0x2a>
mov    %rbx,%rsi
mov    %rsp,%rdi
callq  4313 <sha512_buffer+0x35>
add    $0x160,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
sha512_buffer (const char *buffer, size_t len, void *resblock)
{
  struct sha512_ctx ctx;
  sha512_init_ctx (&ctx);
  sha512_process_bytes (buffer, len, &ctx);
  return sha512_finish_ctx (&ctx, resblock);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 82 <grecs_text_table+0x7>
movq   $0x0,0x0(%rip)        # 8d <grecs_text_table+0x12>
retq   
<<<sep_in_sample>>>
grecs_text_table()
{
 struct grecs_symtab *tmp = text_table;
 text_table = ((void *)0);
 return tmp;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
mov    %rsi,0x10(%rdi)
retq   
<<<sep_in_sample>>>
osip_authorization_set_realm (osip_authorization_t * authorization, char *realm)
{
  authorization->realm = (char *) realm;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     479 <gsl_matrix_complex_long_double_set_zero+0x5b>
shl    $0x5,%rdi
add    $0x10,%rcx
mov    %r8,%r10
shl    $0x5,%r10
mov    $0x0,%esi
fldz   
jmp    469 <gsl_matrix_complex_long_double_set_zero+0x4b>
fstpt  -0x10(%rax)
fldt   -0x10(%rax)
fstpt  (%rax)
fldt   (%rax)
add    $0x20,%rax
cmp    %rdx,%rax
jne    44a <gsl_matrix_complex_long_double_set_zero+0x2c>
add    $0x1,%rsi
add    %rdi,%rcx
cmp    %r9,%rsi
je     477 <gsl_matrix_complex_long_double_set_zero+0x59>
test   %r8,%r8
je     45d <gsl_matrix_complex_long_double_set_zero+0x3f>
lea    (%rcx,%r10,1),%rdx
mov    %rcx,%rax
jmp    44a <gsl_matrix_complex_long_double_set_zero+0x2c>
fstp   %st(0)
repz retq 
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_set_zero (gsl_matrix_complex_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex_long_double zero = {{0.0L,0.0L}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex_long_double *) (data + 2 * (i * tda + j)) = zero;
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 11
20 11
21 9
22 9
23 9
24 9
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  4ae <__gmpz_addmul_ui+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmpz_addmul_ui (mpz_ptr w, mpz_srcptr x, unsigned long y)
{
  __gmpz_aorsmul_1 (w,x,(mp_limb_t) y,(mp_size_t) 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1288 <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x100,%rsp
mov    %rsp,%rdi
callq  1bbf <cleanup_the_pipeline+0x10>
mov    $0x11,%esi
mov    %rsp,%rdi
callq  1bcc <cleanup_the_pipeline+0x1d>
lea    0x80(%rsp),%rdi
callq  1bd9 <cleanup_the_pipeline+0x2a>
lea    0x80(%rsp),%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
callq  1bee <cleanup_the_pipeline+0x3f>
mov    0x0(%rip),%rbx        # 1bf5 <cleanup_the_pipeline+0x46>
movq   $0x0,0x0(%rip)        # 1c00 <cleanup_the_pipeline+0x51>
mov    $0x0,%edx
lea    0x80(%rsp),%rsi
mov    $0x2,%edi
callq  1c17 <cleanup_the_pipeline+0x68>
test   %rbx,%rbx
je     1c24 <cleanup_the_pipeline+0x75>
mov    %rbx,%rdi
callq  1c24 <cleanup_the_pipeline+0x75>
add    $0x100,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
cleanup_the_pipeline ()
{
  PROCESS *disposer;
  sigset_t set, oset;
  do { sigemptyset (&set); sigaddset (&set, 17); sigemptyset (&oset); sigprocmask (0, &set, &oset); } while (0);
  disposer = the_pipeline;
  the_pipeline = (PROCESS *)((void *)0);
  sigprocmask (2, &oset, (sigset_t *) ((void *)0));
  if (disposer)
    discard_pipeline (disposer);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 8
17 8
18 8
19 8
20 9
21 9
22 10
23 10
24 11
25 11
26 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
cmpb   $0x22,(%rdi)
jne    73c <osip_dequote+0x7c>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
lea    -0x2(%rcx),%rbp
lea    0x1(%rbx),%rsi
mov    %r12,%rdx
mov    %rbx,%rdi
callq  6f4 <osip_dequote+0x34>
test   %rbp,%rbp
je     70c <osip_dequote+0x4c>
sub    $0x2,%r12
lea    (%rbx,%r12,1),%rax
cmpb   $0x22,(%rax)
jne    70c <osip_dequote+0x4c>
movb   $0x0,(%rax)
mov    %r12,%rbp
movzbl (%rbx),%eax
test   %al,%al
je     73c <osip_dequote+0x7c>
cmp    $0x5c,%al
jne    72d <osip_dequote+0x6d>
lea    -0x1(%rbp),%r12
lea    0x1(%rbx),%rsi
mov    %rbp,%rdx
mov    %rbx,%rdi
callq  72a <osip_dequote+0x6a>
mov    %r12,%rbp
add    $0x1,%rbx
sub    $0x1,%rbp
movzbl (%rbx),%eax
test   %al,%al
jne    713 <osip_dequote+0x53>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_dequote (char *s)
{
  size_t len;
  if (*s == '\0')
    return;
  if (*s != '"')
    return;
  len = strlen (s);
  memmove (s, s + 1, len--);
  if (len > 0 && s[len - 1] == '"')
    s[--len] = '\0';
  for (; *s != '\0'; s++, len--) {
    if (*s == '\\')
      memmove (s, s + 1, len--);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 8
8 8
9 8
10 8
11 8
12 9
13 9
14 9
15 9
16 9
17 10
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 12
26 12
27 12
28 13
29 13
30 14
31 14
32 14
33 14
34 14
35 14
36 12
37 12
38 12
39 12
40 12
41 16
42 16
43 16
44 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r10
cmp    (%rdi),%r10
jne    3e78 <gsl_matrix_char_sub+0x1f>
mov    0x8(%rsi),%rbx
cmp    %rax,%rbx
je     3e98 <gsl_matrix_char_sub+0x3f>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3e91 <gsl_matrix_char_sub+0x38>
mov    $0x13,%eax
jmp    3f02 <gsl_matrix_char_sub+0xa9>
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%r13
test   %r10,%r10
je     3ef6 <gsl_matrix_char_sub+0x9d>
sub    %r12,%r13
mov    $0x0,%r8d
mov    $0x0,%r11d
mov    $0x0,%ebp
jmp    3ee8 <gsl_matrix_char_sub+0x8f>
mov    %rax,%rdx
add    0x18(%rdi),%rdx
mov    %rax,%rcx
add    0x18(%rsi),%rcx
movzbl (%rcx,%r8,1),%ecx
sub    %cl,(%rdx)
add    $0x1,%rax
cmp    %r9,%rax
jne    3ebb <gsl_matrix_char_sub+0x62>
add    $0x1,%rbp
add    %r12,%r11
add    %r13,%r8
cmp    %r10,%rbp
je     3efd <gsl_matrix_char_sub+0xa4>
test   %rbx,%rbx
je     3ed9 <gsl_matrix_char_sub+0x80>
lea    (%r11,%rbx,1),%r9
mov    %r11,%rax
jmp    3ebb <gsl_matrix_char_sub+0x62>
mov    $0x0,%eax
jmp    3f02 <gsl_matrix_char_sub+0xa9>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_char_sub (gsl_matrix_char * a, const gsl_matrix_char * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 18
30 18
31 18
32 18
33 18
34 18
35 18
36 16
37 16
38 14
39 14
40 14
41 14
42 14
43 16
44 16
45 16
46 16
47 16
48 21
49 21
50 21
51 23
52 23
53 23
54 23
55 23
56 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  eb0 <write_fatal_details+0x9>
mov    0x0(%rip),%edi        # eb6 <write_fatal_details+0xf>
cmp    $0x3fffffff,%edi
jle    ed0 <write_fatal_details+0x29>
sub    $0x40000000,%edi
callq  ec9 <write_fatal_details+0x22>
test   %eax,%eax
setne  %al
jmp    eda <write_fatal_details+0x33>
callq  ed5 <write_fatal_details+0x2e>
test   %eax,%eax
setne  %al
test   %al,%al
je     eed <write_fatal_details+0x46>
mov    0x0(%rip),%rax        # ee5 <write_fatal_details+0x3e>
mov    (%rax),%rdi
callq  eed <write_fatal_details+0x46>
mov    $0x0,%esi
mov    0x0(%rip),%edi        # ef8 <write_fatal_details+0x51>
callq  efd <write_fatal_details+0x56>
callq  f02 <archive_write_error>
<<<sep_in_sample>>>
write_fatal_details (char const *name, ssize_t status, size_t size)
{
  write_error_details (name, status, size);
  if ((((archive) >= (1 << 30)) ? rmt_close__ (archive - (1 << 30)) : close (archive)) != 0)
    close_error (*archive_name_cursor);
  sys_wait_for_child (child_pid, 0);
  fatal_exit ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 6
20 6
21 6
22 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  b40 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  b49 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
mov    %rbx,%rdi
callq  b59 <wordsplit_free+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
  wordsplit_free_envbuf (ws);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
cmp    $0x1f,%esi
je     7a27 <_jit_retval_f+0x1f>
sub    $0x8,%rsp
movslq %esi,%rdx
mov    $0x1f,%ecx
mov    $0xdc,%esi
callq  7a23 <_jit_retval_f+0x1b>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_jit_retval_f(jit_state_t *_jit, jit_int32_t r0)
{
    if (r0 != _XMM0)
 _jit_new_node_ww(_jit,jit_code_movr_f,r0,_XMM0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 107 <yy_fatal_error+0x13>
mov    $0x0,%eax
callq  111 <yy_fatal_error+0x1d>
mov    $0x2,%edi
callq  11b <yyunput>
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
cmpb   $0x0,0x1(%rdi)
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
nettle_base16_decode_final(struct base16_decode_ctx *ctx)
{
  return ctx->bits == 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <file_name_concat+0x9>
test   %rax,%rax
jne    13 <file_name_concat+0x13>
callq  13 <file_name_concat+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
file_name_concat (char const *dir, char const *abase, char **base_in_result)
{
  char *p = mfile_name_concat (dir, abase, base_in_result);
  if (p == ((void *)0))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 7
7 7
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
get_current_dir(void)
{
 return current_dir;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <_locate>
test   %rax,%rax
jne    4c5 <mu_authentication_add_module+0x20>
callq  4b8 <mu_authentication_add_module+0x13>
movl   $0x1028,(%rax)
mov    $0x1,%eax
jmp    4d7 <mu_authentication_add_module+0x32>
mov    %rax,%rsi
mov    $0x0,%edi
callq  4d2 <mu_authentication_add_module+0x2d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_authentication_add_module (const char *name)
{
  struct _module_handler *mod = _locate (name);
  if (!mod)
    {
      (*__errno_location ()) = (0x1000 +40);
      return 1;
    }
  mu_insert_stack_entry (&_tmp_authenticate_list, &mod->authenticate);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 6
7 7
8 7
9 9
10 9
11 9
12 10
13 11
14 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rdi
callq  3a1 <xformat_set_groupname+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_set_groupname (XFORMAT * xux, char * name)
{
 ;
        ahs_set_tar_groupname(xux->ahsM, name);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x58,%rsp
mov    %rsi,0x30(%rsp)
mov    %rdx,0x38(%rsp)
mov    (%rdi),%rax
mov    %rax,%rcx
mov    %rax,0x40(%rsp)
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%rdx
mov    0x18(%rdi),%rax
fldt   (%rax)
fstpt  0x10(%rsp)
test   %rcx,%rcx
je     40b <gsl_matrix_long_double_min_index+0xc8>
shl    $0x4,%rdx
mov    %rdx,0x48(%rsp)
mov    %rax,0x28(%rsp)
mov    $0x0,%r13d
mov    $0x0,%r14d
mov    $0x0,%r15d
jmp    3fa <gsl_matrix_long_double_min_index+0xb7>
fldt   0x0(%rbp)
fldt   0x10(%rsp)
fucomip %st(1),%st
jbe    3ba <gsl_matrix_long_double_min_index+0x77>
mov    %rbx,%r14
mov    %r13,%r15
fld    %st(0)
fstpt  0x10(%rsp)
fstpt  (%rsp)
callq  3c2 <gsl_matrix_long_double_min_index+0x7f>
test   %eax,%eax
je     3d8 <gsl_matrix_long_double_min_index+0x95>
mov    0x30(%rsp),%rax
mov    %r13,(%rax)
mov    0x38(%rsp),%rax
mov    %rbx,(%rax)
jmp    427 <gsl_matrix_long_double_min_index+0xe4>
add    $0x1,%rbx
add    $0x10,%rbp
cmp    %r12,%rbx
jne    3a3 <gsl_matrix_long_double_min_index+0x60>
add    $0x1,%r13
mov    0x48(%rsp),%rax
add    %rax,0x28(%rsp)
cmp    0x40(%rsp),%r13
je     417 <gsl_matrix_long_double_min_index+0xd4>
test   %r12,%r12
je     3e5 <gsl_matrix_long_double_min_index+0xa2>
mov    0x28(%rsp),%rbp
mov    $0x0,%ebx
jmp    3a3 <gsl_matrix_long_double_min_index+0x60>
mov    $0x0,%r14d
mov    $0x0,%r15d
mov    0x30(%rsp),%rax
mov    %r15,(%rax)
mov    0x38(%rsp),%rax
mov    %r14,(%rax)
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_min_index (const gsl_matrix_long_double * m, size_t * imin_out, size_t *jmin_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long double min = m->data[0 * tda + 0];
  size_t imin = 0, jmin = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long double x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            {
              *imin_out = i;
              *jmin_out = j;
              return;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 4
14 5
15 6
16 6
17 6
18 9
19 9
20 9
21 9
22 9
23 9
24 7
25 7
26 7
27 13
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 20
36 20
37 20
38 20
39 22
40 22
41 23
42 23
43 24
44 11
45 11
46 11
47 11
48 9
49 9
50 9
51 9
52 9
53 11
54 11
55 11
56 11
57 11
58 7
59 7
60 28
61 28
62 29
63 29
64 30
65 30
66 30
67 30
68 30
69 30
70 30
71 30
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
cmp    %si,(%rdi)
jne    c7 <udf_checktag+0x31>
mov    $0x0,%eax
mov    $0x0,%edx
add    (%rdi,%rax,1),%dl
add    $0x1,%rax
cmp    $0xf,%rax
jne    aa <udf_checktag+0x14>
movzbl 0x4(%rdi),%eax
sub    %eax,%edx
cmp    %dl,%al
setne  %al
movzbl %al,%eax
neg    %eax
repz retq 
<<<sep_in_sample>>>
udf_checktag(const udf_tag_t *p_tag, udf_Uint16_t tag_id)
{
  uint8_t *itag;
  uint8_t i;
  uint8_t cksum = 0;
  itag = (uint8_t *)p_tag;
  if (p_tag->id != tag_id)
    return -1;
  for (i = 0; i < 15; i++)
    cksum = cksum + itag[i];
  cksum = cksum - itag[4];
  if (cksum == p_tag->cksum)
    return 0;
  return -1;
}
<<<sep_in_sample>>>
1 8
2 7
3 7
4 7
5 7
6 10
7 10
8 9
9 9
10 11
11 11
12 12
13 12
14 12
15 12
16 15
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
ap_error( const struct Arg_parser * const ap )
  { return ap->error; }
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x818,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
mov    $0x1,%al
cmpq   $0x0,0x0(%rip)        # 8ef <terminaltypeok+0x24>
je     904 <terminaltypeok+0x39>
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  8fc <terminaltypeok+0x31>
test   %eax,%eax
setne  %al
movzbl %al,%eax
mov    0x808(%rsp),%rdx
xor    %fs:0x28,%rdx
je     91c <terminaltypeok+0x51>
callq  91c <terminaltypeok+0x51>
add    $0x818,%rsp
retq   
<<<sep_in_sample>>>
terminaltypeok (char *s)
{
  char buf[2048];
  if (terminaltype == ((void *)0))
    return 1;
  if (tgetent (buf, s) == 0)
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 9
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     96b <gsl_matrix_complex_set_zero+0x5a>
shl    $0x4,%rdi
add    $0x8,%rcx
mov    %r8,%r10
shl    $0x4,%r10
mov    $0x0,%esi
xorpd  %xmm0,%xmm0
jmp    95d <gsl_matrix_complex_set_zero+0x4c>
movsd  %xmm0,-0x8(%rax)
movsd  %xmm0,(%rax)
add    $0x10,%rax
cmp    %rdx,%rax
jne    93f <gsl_matrix_complex_set_zero+0x2e>
add    $0x1,%rsi
add    %rdi,%rcx
cmp    %r9,%rsi
je     96b <gsl_matrix_complex_set_zero+0x5a>
test   %r8,%r8
je     951 <gsl_matrix_complex_set_zero+0x40>
lea    (%rcx,%r10,1),%rdx
mov    %rcx,%rax
jmp    93f <gsl_matrix_complex_set_zero+0x2e>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_complex_set_zero (gsl_matrix_complex * m)
{
  size_t i, j;
  double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex zero = {{0.0,0.0}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex *) (data + 2 * (i * tda + j)) = zero;
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 13
13 13
14 13
15 13
16 13
17 11
18 11
19 9
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    0x30(%rdi),%rbp
lea    -0x1(%rsi),%rdx
cmp    %rdx,%rbp
ja     2d4 <gl_array_remove_node+0x22>
callq  2d4 <gl_array_remove_node+0x22>
mov    0x28(%rdi),%r13
mov    0x18(%rdi),%rax
test   %rax,%rax
je     2e8 <gl_array_remove_node+0x36>
mov    0x0(%r13,%rdx,8),%rdi
callq  *%rax
cmp    %r12,%rbp
jbe    307 <gl_array_remove_node+0x55>
lea    0x0(%r13,%r12,8),%rax
lea    0x0(%r13,%rbp,8),%rcx
mov    (%rax),%rdx
mov    %rdx,-0x8(%rax)
add    $0x8,%rax
cmp    %rcx,%rax
jne    2f7 <gl_array_remove_node+0x45>
sub    $0x1,%rbp
mov    %rbp,0x30(%rbx)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gl_array_remove_node (gl_list_t list, gl_list_node_t node)
{
  size_t count = list->count;
  unsigned long index = ((unsigned long)(node) - 1);
  size_t position;
  const void **elements;
  size_t i;
  if (!(index < count))
    abort ();
  position = index;
  elements = list->elements;
  if (list->base.dispose_fn != ((void *)0))
    list->base.dispose_fn (elements[position]);
  for (i = position + 1; i < count; i++)
    elements[i - 1] = elements[i];
  list->count = count - 1;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 8
11 8
12 9
13 11
14 12
15 12
16 12
17 13
18 13
19 14
20 14
21 14
22 14
23 15
24 15
25 15
26 14
27 14
28 16
29 16
30 18
31 18
32 18
33 18
34 18
35 18
36 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     435 <grecs_print_statement_array+0x68>
mov    %esi,%ebp
mov    %edx,%r13d
mov    %rcx,%r12
cmpq   $0x0,(%rdi)
je     435 <grecs_print_statement_array+0x68>
testb  $0x10,0x1c(%rbx)
jne    428 <grecs_print_statement_array+0x5b>
test   %ebp,%ebp
je     404 <grecs_print_statement_array+0x37>
mov    %r12,%rsi
mov    $0xa,%edi
callq  404 <grecs_print_statement_array+0x37>
cmpl   $0xf,0x18(%rbx)
jne    41a <grecs_print_statement_array+0x4d>
mov    %r12,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  418 <grecs_print_statement_array+0x4b>
jmp    428 <grecs_print_statement_array+0x5b>
mov    %r12,%rdx
mov    %r13d,%esi
mov    %rbx,%rdi
callq  428 <grecs_print_statement_array+0x5b>
add    $0x48,%rbx
add    $0x1,%ebp
cmpq   $0x0,(%rbx)
jne    3ed <grecs_print_statement_array+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
grecs_print_statement_array(struct grecs_keyword *kwp,
       unsigned n,
       unsigned level,
       FILE *stream)
{
 if (!kwp) {
  return;
 }
 for (; kwp->ident; kwp++, n++) {
  if (kwp->flags & 0x10)
   continue;
  if (n)
   fputc('\n', stream);
  if (kwp->type == grecs_type_section)
   grecs_print_block_statement(kwp, level, stream);
  else
   grecs_print_simple_statement(kwp, level, stream);
 }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 9
13 9
14 10
15 10
16 12
17 12
18 13
19 13
20 13
21 14
22 14
23 15
24 15
25 15
26 15
27 15
28 17
29 17
30 17
31 17
32 9
33 9
34 9
35 9
36 19
37 19
38 19
39 19
40 19
41 19
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    0x10(%rdi),%r13
add    (%rdi),%r13
mov    $0x8,%esi
mov    %r13,%rdi
callq  304b <wordsplit_string+0x25>
mov    %rax,%r14
test   %r13,%r13
je     30f2 <wordsplit_string+0xcc>
mov    $0x0,%ebp
mov    $0x0,%ebx
mov    $0xffffffffffffffff,%r15
mov    0x8(%r12),%rax
mov    (%rax,%rbx,8),%rsi
mov    %ebx,%edi
callq  3078 <wordsplit_string+0x52>
mov    %rax,(%r14,%rbx,8)
mov    %rax,%rdi
mov    $0x0,%eax
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbp,%rcx,1),%rbp
add    $0x1,%rbx
cmp    %r13,%rbx
jne    3068 <wordsplit_string+0x42>
jmp    30d2 <wordsplit_string+0xac>
mov    (%r14,%rbx,8),%r12
mov    %r12,%rsi
mov    %rbp,%rdi
callq  30ab <wordsplit_string+0x85>
mov    %r12,%rdi
mov    $0x0,%eax
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbp,%rcx,1),%rax
lea    0x1(%rax),%rbp
movb   $0x20,(%rax)
add    $0x1,%rbx
cmp    %r13,%rbx
jne    309c <wordsplit_string+0x76>
jmp    3104 <wordsplit_string+0xde>
lea    0x0(%rbp,%r13,1),%rdi
callq  30dc <wordsplit_string+0xb6>
mov    %rax,0x8(%rsp)
mov    %rax,%rbp
mov    $0x0,%ebx
mov    $0xffffffffffffffff,%r15
jmp    309c <wordsplit_string+0x76>
mov    $0x0,%edi
callq  30fc <wordsplit_string+0xd6>
mov    %rax,0x8(%rsp)
mov    %rax,%rbp
movb   $0x0,-0x1(%rbp)
mov    %r14,%rdi
callq  3110 <wordsplit_string+0xea>
mov    0x8(%rsp),%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
wordsplit_string (struct wordsplit const *ws)
{
  char *ret, *p;
  size_t count = ws->ws_wordc + ws->ws_offs;
  char **argv = xcalloc (count, sizeof (argv[0]));
  size_t i;
  size_t len = 0;
  for (i = 0; i < count; i++)
    {
      argv[i] = quotearg_n (i, ws->ws_wordv[i]);
      len += strlen (argv[i]);
    }
  len += count;
  ret = xmalloc (len);
  for (i = 0, p = ret; i < count; i++)
    {
      strcpy (p, argv[i]);
      p += strlen (argv[i]);
      *p++ = ' ';
    }
  p[-1] = 0;
  free (argv);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 5
12 5
13 5
14 5
15 8
16 8
17 7
18 8
19 11
20 10
21 10
22 10
23 10
24 10
25 11
26 11
27 11
28 11
29 11
30 11
31 8
32 8
33 8
34 8
35 17
36 17
37 17
38 17
39 18
40 18
41 18
42 18
43 18
44 18
45 19
46 19
47 15
48 15
49 15
50 15
51 13
52 14
53 14
54 14
55 15
56 18
57 18
58 14
59 14
60 14
61 14
62 21
63 22
64 22
65 24
66 24
67 24
68 24
69 24
70 24
71 24
72 24
73 24
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    0x8(%rsi),%rdx
cmp    %rdx,0x8(%rdi)
jne    a9 <triple_compare_ino_str+0x38>
mov    0x10(%rsi),%rcx
cmp    %rcx,0x10(%rdi)
jne    a9 <triple_compare_ino_str+0x38>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  99 <triple_compare_ino_str+0x28>
test   %eax,%eax
sete   %al
movzbl %al,%eax
and    $0x1,%eax
add    $0x8,%rsp
retq   
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
triple_compare_ino_str (void const *x, void const *y)
{
  struct F_triple const *a = x;
  struct F_triple const *b = y;
  return (((*a).st_ino == (*b).st_ino && (*a).st_dev == (*b).st_dev) && (strcmp (a->name, b->name) == 0)) ? 1 : 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 5
19 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <FillPolygon+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
FillPolygon(AWindow * w, Point * pts, int npts, ZInfo * zinfo)
{
 MakeET(w, pts, npts, zinfo);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <str_dispose+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
str_dispose (const void *elt)
{
  free ((void*)elt);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 59 <findLocalEntity+0x7>
mov    0x0(%rip),%ecx        # 5f <findLocalEntity+0xd>
mov    $0xffffffff,%eax
test   %ecx,%ecx
js     a2 <findLocalEntity+0x50>
mov    $0x0,%eax
cmpl   $0x1,(%rdx)
jne    8f <findLocalEntity+0x3d>
movzwl 0x4(%rdi),%esi
cmp    %si,0x36(%rdx)
jne    8f <findLocalEntity+0x3d>
movzwl 0x2(%rdi),%esi
cmp    %si,0x34(%rdx)
jne    8f <findLocalEntity+0x3d>
movzwl (%rdi),%esi
cmp    %si,0x32(%rdx)
je     a2 <findLocalEntity+0x50>
add    $0x3a8,%rdx
add    $0x1,%eax
cmp    %ecx,%eax
jle    6d <findLocalEntity+0x1b>
mov    $0xffffffff,%eax
repz retq 
<<<sep_in_sample>>>
findLocalEntity( const dis_entity_id * id )
{
 int i;
 Entity_t *p = entities;
 for (i = 0; i <= entity_top; i++) {
  if (p->local == 1 &&
   p->entityId.entity_id == id->entity_id &&
   p->entityId.sim_id.application_id == id->sim_id.application_id &&
   p->entityId.sim_id.site_id == id->sim_id.site_id) {
   return i;
  }
  ++p;
 }
 return -1;
}
<<<sep_in_sample>>>
1 4
2 5
3 14
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 8
18 12
19 5
20 5
21 5
22 14
23 15
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # ae <set_defaults_after+0x7>
jne    bc <set_defaults_after+0x15>
mov    0x0(%rip),%eax        # b6 <set_defaults_after+0xf>
mov    %eax,0x0(%rip)        # bc <set_defaults_after+0x15>
repz retq 
<<<sep_in_sample>>>
set_defaults_after (void)
{
    if (!exp_lc)
    {
        settings.comment_max_col = settings.max_col;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  1a8 <font_entry_free+0xc>
mov    %rbx,%rdi
callq  1b0 <font_entry_free+0x14>
pop    %rbx
retq   
<<<sep_in_sample>>>
font_entry_free (struct font_entry * item)
{
  free (item->key);
  free (item);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <init_noninteractive+0xe>
movl   $0x0,0x0(%rip)        # 18 <init_noninteractive+0x18>
movl   $0x0,0x0(%rip)        # 22 <init_noninteractive+0x22>
movl   $0x0,0x0(%rip)        # 2c <init_noninteractive+0x2c>
mov    0x0(%rip),%eax        # 32 <init_noninteractive+0x32>
mov    %eax,0x0(%rip)        # 38 <init_noninteractive+0x38>
movl   $0x1,0x0(%rip)        # 42 <init_noninteractive+0x42>
mov    $0x1,%edi
cmpl   $0x0,0x0(%rip)        # 4e <init_noninteractive+0x4e>
jne    5f <init_noninteractive+0x5f>
cmpl   $0x0,0x0(%rip)        # 57 <init_noninteractive+0x57>
setne  %dil
movzbl %dil,%edi
callq  64 <init_noninteractive+0x64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_noninteractive ()
{
  bash_history_reinit (0);
  interactive_shell = startup_state = interactive = 0;
  expand_aliases = posixly_correct;
  no_line_editing = 1;
  set_job_control (forced_interactive||jobs_m_flag);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
<<<sep_out_sample>>>
cmp    %edx,%esi
je     ff3 <_sse_movr_d+0x18>
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x10,%edx
mov    $0xf2,%esi
callq  9d0 <_ssexr>
repz retq 
<<<sep_in_sample>>>
_sse_movr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    if (r0 != r1)
 _ssexr(_jit,0xf2,0x10,r0,r1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm2        # c <Tfun+0xc>
movsd  %xmm2,0x8(%rsp)
ucomisd 0x0(%rip),%xmm2        # 1a <Tfun+0x1a>
jp     26 <Tfun+0x26>
movsd  0x0(%rip),%xmm1        # 24 <Tfun+0x24>
je     42 <Tfun+0x42>
callq  2b <Tfun+0x2b>
movsd  0x8(%rsp),%xmm1
subsd  0x0(%rip),%xmm1        # 39 <Tfun+0x39>
callq  3e <Tfun+0x3e>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
Tfun(double x)
{
  if (dddi == 0.0)
    return 1.0;
  return pow(cos(x), dddi - 1.0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 3
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r9
mov    %rsi,%r12
mov    %rdx,%rbp
movq   $0x0,(%rdx)
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r13
lea    0x8(%rsp),%rcx
mov    $0x0,%edx
mov    %r13,%rsi
mov    %r9,%rdi
callq  f7 <CDB___os_strdup+0x46>
mov    %eax,%ebx
test   %eax,%eax
jne    116 <CDB___os_strdup+0x65>
mov    %r13,%rdx
mov    %r12,%rsi
mov    0x8(%rsp),%rdi
callq  10d <CDB___os_strdup+0x5c>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
CDB___os_strdup(dbenv, str, storep)
 DB_ENV *dbenv;
 const char *str;
 void *storep;
{
 size_t size;
 int ret;
 void *p;
 *(void **)storep = ((void *)0);
 size = strlen(str) + 1;
 if ((ret = CDB___os_malloc(dbenv, size, ((void *)0), &p)) != 0)
  return (ret);
 memcpy(p, str, size);
 *(void **)storep = p;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 9
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 13
27 13
28 14
29 14
30 16
31 16
32 16
33 16
34 16
35 16
36 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %esi,%r12d
mov    %rdx,%r13
mov    $0x1,%esi
mov    $0x158,%edi
callq  160 <gc_hash_open+0x21>
mov    %rax,%rbx
test   %rax,%rax
je     1c7 <gc_hash_open+0x88>
mov    %ebp,(%rax)
mov    %r12d,0x4(%rax)
cmp    $0x1,%ebp
je     17a <gc_hash_open+0x3b>
cmp    $0x2,%ebp
je     18a <gc_hash_open+0x4b>
jmp    19d <gc_hash_open+0x5e>
lea    0x1c(%rax),%rdi
callq  183 <gc_hash_open+0x44>
mov    $0x0,%ebp
jmp    1a2 <gc_hash_open+0x63>
lea    0xb8(%rax),%rdi
callq  196 <gc_hash_open+0x57>
mov    $0x0,%ebp
jmp    1a2 <gc_hash_open+0x63>
mov    $0x5,%ebp
test   %r12d,%r12d
jne    1b6 <gc_hash_open+0x77>
test   %ebp,%ebp
jne    1bb <gc_hash_open+0x7c>
mov    %rbx,0x0(%r13)
mov    $0x0,%eax
jmp    1cc <gc_hash_open+0x8d>
mov    $0x5,%ebp
mov    %rbx,%rdi
callq  1c3 <gc_hash_open+0x84>
mov    %ebp,%eax
jmp    1cc <gc_hash_open+0x8d>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gc_hash_open (Gc_hash hash, Gc_hash_mode mode, gc_hash_handle * outhandle)
{
  _gc_hash_ctx *ctx;
  Gc_rc rc = GC_OK;
  ctx = calloc (sizeof (*ctx), 1);
  if (!ctx)
    return GC_MALLOC_ERROR;
  ctx->alg = hash;
  ctx->mode = mode;
  switch (hash)
    {
    case GC_MD5:
      md5_init_ctx (&ctx->md5Context);
      break;
    case GC_SHA1:
      sha1_init_ctx (&ctx->sha1Context);
      break;
    default:
      rc = GC_INVALID_HASH;
      break;
    }
  switch (mode)
    {
    case 0:
      break;
    default:
      rc = GC_INVALID_HASH;
      break;
    }
  if (rc == GC_OK)
    *outhandle = ctx;
  else
    free (ctx);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 6
14 6
15 8
16 9
17 10
18 10
19 10
20 10
21 10
22 13
23 13
24 4
25 14
26 16
27 16
28 4
29 17
30 19
31 22
32 22
33 30
34 30
35 31
36 34
37 34
38 27
39 33
40 33
41 33
42 33
43 7
44 35
45 35
46 35
47 35
48 35
49 35
<<<sep_out_sample>>>
push   %rbx
callq  12f1 <call+0x6>
mov    %rax,%rbx
test   %rax,%rax
je     1365 <call+0x7a>
cmpl   $0x0,0x74(%rax)
jns    1306 <call+0x1b>
movl   $0x0,0x74(%rax)
mov    0x0(%rip),%rdi        # 130d <call+0x22>
test   %rdi,%rdi
je     1365 <call+0x7a>
mov    0x88(%rbx),%rsi
callq  131e <call+0x33>
test   %eax,%eax
jne    1335 <call+0x4a>
lea    0x88(%rbx),%rdi
mov    0x0(%rip),%rsi        # 1330 <call+0x45>
callq  1335 <call+0x4a>
mov    0x0(%rip),%rax        # 133c <call+0x51>
mov    0x90(%rax),%rsi
mov    %rbx,%rdi
callq  134b <call+0x60>
test   %eax,%eax
jne    1365 <call+0x7a>
mov    0x0(%rip),%rax        # 1356 <call+0x6b>
lea    0x90(%rax),%rdi
mov    %rbx,%rsi
callq  1365 <call+0x7a>
pop    %rbx
retq   
<<<sep_in_sample>>>
call(char *name, int line)
{
     Symbol *sp;
     sp = add_reference(name, line);
     if (!sp)
   return;
     if (sp->arity < 0)
   sp->arity = 0;
     if (caller) {
   if (!data_in_list(caller, sp->caller))
        linked_list_append(&sp->caller, caller);
   if (!data_in_list(sp, caller->callee))
        linked_list_append(&caller->callee, sp);
     }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 7
8 8
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 11
18 11
19 12
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 15
30 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  8e7 <gsl_ran_binomial_tpe+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_binomial_tpe (const gsl_rng * rng, double p, unsigned int n)
{
  return gsl_ran_binomial (rng, p, n);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2780 <php_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
php_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  b75 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rsi),%r8
cmp    0x8(%rdi),%r8
jne    1e4 <gsl_multiset_memcpy+0x22>
mov    (%rdi),%rax
cmp    %rax,(%rsi)
jne    1e4 <gsl_multiset_memcpy+0x22>
mov    $0x0,%eax
test   %r8,%r8
jne    204 <gsl_multiset_memcpy+0x42>
jmp    222 <gsl_multiset_memcpy+0x60>
mov    $0x13,%ecx
mov    $0xa4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1fd <gsl_multiset_memcpy+0x3b>
mov    $0x13,%eax
jmp    222 <gsl_multiset_memcpy+0x60>
mov    0x10(%rsi),%rdx
mov    (%rdx,%rax,8),%rcx
mov    0x10(%rdi),%rdx
mov    %rcx,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r8,%rax
jne    204 <gsl_multiset_memcpy+0x42>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multiset_memcpy (gsl_multiset * dest, const gsl_multiset * src)
{
   const size_t src_n = src->n;
   const size_t src_k = src->k;
   const size_t dest_n = dest->n;
   const size_t dest_k = dest->k;
   if (src_n != dest_n || src_k != dest_k)
     {
       do { gsl_error ("multiset lengths are not equal", "multiset.c", 164, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
     }
   {
     size_t j;
     for (j = 0; j < src_k; j++)
       {
         dest->data[j] = src->data[j];
       }
   }
   return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 7
4 7
5 7
6 7
7 7
8 13
9 13
10 13
11 13
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 15
20 15
21 15
22 15
23 13
24 13
25 13
26 18
27 19
28 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x50(%rdi),%rbp
mov    $0x16,%eax
test   %rbp,%rbp
je     33b <mbox_messages_count+0x50>
mov    %rsi,%r12
callq  3b <mbox_is_updated>
test   %eax,%eax
jne    322 <mbox_messages_count+0x37>
mov    0x10(%rbp),%rsi
mov    $0x0,%ecx
mov    %r12,%rdx
mov    %rbx,%rdi
callq  320 <mbox_messages_count+0x35>
jmp    33b <mbox_messages_count+0x50>
test   %r12,%r12
je     336 <mbox_messages_count+0x4b>
mov    0x10(%rbp),%rax
mov    %rax,(%r12)
mov    $0x0,%eax
jmp    33b <mbox_messages_count+0x50>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mbox_messages_count (mu_mailbox_t mailbox, size_t *pcount)
{
  mbox_data_t mud = mailbox->data;
  if (mud == ((void *)0))
    return 22;
  if (! mbox_is_updated (mailbox))
    return mbox_scan0 (mailbox, mud->messages_count, pcount, 0);
  if (pcount)
    *pcount = mud->messages_count;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 4
8 4
9 4
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 9
22 9
23 10
24 10
25 10
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x0,%eax
callq  0 <findbrk>
mov    %rax,%rbx
mov    %rax,0x0(%rip)        # 5c <allocerr+0x1e>
mov    $0x0,%edi
callq  66 <allocerr+0x28>
mov    %rbx,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  7c <allocerr+0x3e>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
allocerr (func, bytes)
     const char *func;
     size_t bytes;
{
      allocated = findbrk ();
      fatal_error (gettext("%s: cannot allocate %lu bytes (%lu bytes allocated)"), func, (unsigned long)bytes, (unsigned long)allocated);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    0x0(%rip),%rdx        # 317 <panic+0xe>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 323 <panic+0x1a>
mov    $0x0,%eax
callq  32d <panic+0x24>
mov    $0x1,%edi
callq  337 <panicn>
<<<sep_in_sample>>>
panic (const char *s)
{
  fprintf (stderr, "%s panic: %s\n", progname, s);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,(%rsp)
mov    %esi,0xc(%rsp)
callq  58f <susystem+0x15>
mov    %eax,%ebx
cmp    $0xffffffff,%eax
je     635 <susystem+0xbb>
test   %eax,%eax
jne    5d4 <susystem+0x5a>
mov    0xc(%rsp),%edi
callq  5a7 <susystem+0x2d>
mov    $0x0,%r8d
mov    (%rsp),%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  5ca <susystem+0x50>
mov    $0x7f,%edi
callq  5d4 <susystem+0x5a>
mov    $0x1,%esi
mov    $0x2,%edi
callq  5e3 <susystem+0x69>
mov    %rax,%r12
mov    $0x1,%esi
mov    $0x3,%edi
callq  5f5 <susystem+0x7b>
mov    %rax,%rbp
mov    $0x0,%edx
lea    0x1c(%rsp),%rsi
mov    %ebx,%edi
callq  609 <susystem+0x8f>
test   %eax,%eax
jns    615 <susystem+0x9b>
movl   $0xffffffff,0x1c(%rsp)
mov    %r12,%rsi
mov    $0x2,%edi
callq  622 <susystem+0xa8>
mov    %rbp,%rsi
mov    $0x3,%edi
callq  62f <susystem+0xb5>
mov    0x1c(%rsp),%eax
jmp    63a <susystem+0xc0>
mov    $0x7f,%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
susystem (char *s, int userid)
{
  sighandler_t istat, qstat;
  int status;
  pid_t pid;
  pid = vfork ();
  switch (pid)
    {
    case -1:
      return (127);
    case 0:
      setuid (userid);
      execl ("/bin/sh", "sh", "-c", s, ((void *)0));
      _exit (127);
    }
  istat = signal (2, ((__sighandler_t) 1));
  qstat = signal (3, ((__sighandler_t) 1));
  if (waitpid (pid, &status, 0) < 0)
    status = -1;
  signal (2, istat);
  signal (3, qstat);
  return (status);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 7
10 7
11 7
12 7
13 12
14 12
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 14
23 14
24 16
25 16
26 16
27 16
28 17
29 17
30 17
31 17
32 18
33 18
34 18
35 18
36 18
37 18
38 19
39 20
40 20
41 20
42 21
43 21
44 21
45 22
46 22
47 10
48 23
49 23
50 23
51 23
52 23
<<<sep_out_sample>>>
mov    $0x0,%eax
cmpl   $0x0,0x0(%rip)        # 275b <canceled+0xc>
je     27c3 <canceled+0x74>
push   %rbp
push   %rbx
sub    $0x8,%rsp
movl   $0x0,0x0(%rip)        # 276d <canceled+0x1e>
callq  2772 <canceled+0x23>
mov    %rax,%rbp
mov    $0x4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2789 <canceled+0x3a>
mov    %eax,%ebx
mov    %rbp,%rdi
callq  2793 <canceled+0x44>
mov    $0x0,%eax
callq  279d <canceled+0x4e>
mov    $0x0,%eax
callq  27a7 <canceled+0x58>
mov    $0x0,%eax
callq  27b1 <canceled+0x62>
and    $0xffffffdf,%ebx
cmp    $0x4e,%bl
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
canceled()
{
    int key;
    if (user_heart_attack)
    {
 input_line_t *saved_il;
 user_heart_attack = 0;
 saved_il = il_save();
 key = il_read_char("Abort current operation? ", "yn",
          0 | 4);
 il_restore(saved_il);
 il_update();
 il_update_point();
 tty_update();
 return (key == 'n' || key == 'N') ? 0 : 1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 17
2 4
3 4
4 2
5 2
6 2
7 7
8 8
9 8
10 9
11 9
12 9
13 9
14 9
15 11
16 11
17 12
18 12
19 13
20 13
21 14
22 14
23 15
24 15
25 15
26 15
27 18
28 18
29 18
30 18
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     540 <mu_mailcap_get_entry+0x30>
mov    $0x1005,%ax
test   %rdx,%rdx
je     540 <mu_mailcap_get_entry+0x30>
mov    $0x28,%al
test   %rsi,%rsi
je     540 <mu_mailcap_get_entry+0x30>
cmp    0x8(%rdi),%rsi
ja     540 <mu_mailcap_get_entry+0x30>
mov    (%rdi),%rax
mov    -0x8(%rax,%rsi,8),%rax
mov    %rax,(%rdx)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_mailcap_get_entry (mu_mailcap_t mailcap, size_t no,
        mu_mailcap_entry_t *pentry)
{
  int status = 0;
  if (mailcap == ((void *)0))
    status = 22;
  else if (pentry == ((void *)0))
    status = (0x1000 +5);
  else if (no == 0 || no > mailcap->entries_count)
    {
      status = (0x1000 +40);
    }
  else
    {
      *pentry = mailcap->entries[no - 1];
    }
  return status;
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 8
5 7
6 7
7 11
8 9
9 9
10 9
11 9
12 15
13 15
14 15
15 4
16 18
<<<sep_out_sample>>>
mov    %rsi,0xb0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_anonymous_set (Gsasl * ctx,
         Gsasl_server_callback_anonymous cb)
{
  ctx->cbs_anonymous = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  401 <open_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
open_error (char const *name)
{
  call_arg_error ("open", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  872 <stat_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
stat_error (char const *name)
{
  call_arg_error ("stat", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 556 <rl_maybe_save_line+0x8>
jne    5c9 <rl_maybe_save_line+0x7b>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x18,%edi
callq  568 <rl_maybe_save_line+0x1a>
mov    %rax,%rbx
mov    %rax,0x0(%rip)        # 572 <rl_maybe_save_line+0x24>
mov    0x0(%rip),%rbp        # 579 <rl_maybe_save_line+0x2b>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  595 <rl_maybe_save_line+0x47>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  5a0 <rl_maybe_save_line+0x52>
mov    %rax,(%rbx)
mov    0x0(%rip),%rax        # 5aa <rl_maybe_save_line+0x5c>
movq   $0x0,0x8(%rax)
mov    0x0(%rip),%rdx        # 5b9 <rl_maybe_save_line+0x6b>
mov    %rdx,0x10(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_maybe_save_line ()
{
  if (_rl_saved_line_for_history == 0)
    {
      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
      _rl_saved_line_for_history->line = strcpy ((char *)xmalloc (1 + strlen (rl_line_buffer)), (rl_line_buffer));
      _rl_saved_line_for_history->timestamp = (char *)((void *)0);
      _rl_saved_line_for_history->data = (char *)rl_undo_list;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 8
25 8
26 11
27 11
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    %rdx,%r9
shr    %r9
je     bd5 <gsl_vector_long_reverse+0x42>
shl    $0x3,%rsi
sub    $0x1,%rdx
imul   %rsi,%rdx
add    %rax,%rdx
mov    $0x0,%ecx
mov    (%rdx),%rdi
mov    (%rax),%r8
mov    %r8,(%rdx)
mov    %rdi,(%rax)
add    $0x1,%rcx
sub    %rsi,%rdx
add    %rsi,%rax
cmp    %r9,%rcx
jne    bba <gsl_vector_long_reverse+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_long_reverse (gsl_vector_long * v)
{
  long * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          long tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 8
6 8
7 14
8 14
9 14
10 14
11 8
12 14
13 15
14 15
15 16
16 8
17 8
18 8
19 8
20 8
21 20
22 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xb8,%edi
callq  977 <make_new_opennode+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_new_opennode(void)
{
    return (openfilestruct *)nmalloc(sizeof(openfilestruct));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %ecx,%edi
not    %edi
lea    0x0(%rip),%rsi        # 586 <dupstr+0x22>
callq  58b <dupstr+0x27>
mov    %rax,%rbx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  599 <dupstr+0x35>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dupstr(const char *str)
{
   char *ret;
   ret = mymalloc(strlen(str) + 1,"(dupstr)");
   strcpy(ret, str);
   return (ret);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     b67 <gsl_matrix_long_double_isneg+0x4f>
shl    $0x4,%rax
mov    %rax,%r10
mov    $0x0,%esi
mov    $0x0,%r9d
jmp    b60 <gsl_matrix_long_double_isneg+0x48>
mov    %rsi,%rax
add    0x18(%rdi),%rax
mov    $0x0,%edx
fldz   
fldt   (%rax)
fucomip %st(1),%st
jb     b79 <gsl_matrix_long_double_isneg+0x61>
fstp   %st(0)
jmp    b6d <gsl_matrix_long_double_isneg+0x55>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     b73 <gsl_matrix_long_double_isneg+0x5b>
test   %rcx,%rcx
jne    b3c <gsl_matrix_long_double_isneg+0x24>
jmp    b54 <gsl_matrix_long_double_isneg+0x3c>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    $0x10,%rax
cmp    %rcx,%rdx
jne    b4a <gsl_matrix_long_double_isneg+0x32>
fstp   %st(0)
jmp    b54 <gsl_matrix_long_double_isneg+0x3c>
<<<sep_in_sample>>>
gsl_matrix_long_double_isneg (const gsl_matrix_long_double * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 20
28 20
29 15
30 15
31 20
32 20
33 9
34 9
35 9
36 9
37 9
38 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%esi
sbb    %edi,%edi
and    $0xfffffffc,%edi
add    $0x7,%edi
mov    $0x0,%esi
mov    $0x0,%eax
callq  1e <mu_debug_syslog_printer+0x1e>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_debug_syslog_printer (void *unused, mu_log_level_t level, const char *str)
{
  syslog ((level == 0) ? 3 : 7, "%s", str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %r9,%rdi
callq  16a <grecs_txtacc_grow_string+0x27>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_txtacc_grow_string(struct grecs_txtacc *acc, const char *buf)
{
 grecs_txtacc_grow(acc, buf, strlen(buf));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  0 <_url_remote_init>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_url_remote_smtp_init (mu_url_t url)
{
  return _url_remote_init (url, "smtp");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %rdx,%rsi
lea    0x8(%rsp),%rdx
callq  b0 <collect_arg>
mov    %eax,%ebx
test   %al,%al
je     cea <parse_ilname+0x5d>
mov    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  cb9 <parse_ilname+0x2c>
mov    %rax,%rbp
mov    0x8(%rsp),%rdi
mov    %rdi,0x38(%rax)
mov    $0x0,%esi
callq  830 <estimate_pattern_match_rate>
unpcklps %xmm0,%xmm0
cvtps2pd %xmm0,%xmm0
mulsd  0x0(%rip),%xmm0        # cdd <parse_ilname+0x50>
unpcklpd %xmm0,%xmm0
cvtpd2ps %xmm0,%xmm1
movss  %xmm1,0x24(%rbp)
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_ilname (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  const char *name;
  if (collect_arg (argv, arg_ptr, &name))
    {
      struct predicate *our_pred = insert_primary (entry, name);
      our_pred->args.str = name;
      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate (name, 0);
      return 1;
    }
  else
    {
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 15
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     149 <varray_close+0x1e>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     141 <varray_close+0x16>
callq  141 <varray_close+0x16>
mov    %rbx,%rdi
callq  149 <varray_close+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
varray_close(VARRAY *vb)
{
 if (vb) {
  if (vb->vbuf)
   (void)free(vb->vbuf);
  (void)free(vb);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 8
12 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rdi
callq  c8 <dumpdir_free+0xd>
mov    %rbx,%rdi
callq  d0 <dumpdir_free+0x15>
pop    %rbx
retq   
<<<sep_in_sample>>>
dumpdir_free (struct dumpdir *dump)
{
  free (dump->elv);
  free (dump);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
test   %esi,%esi
je     153 <send_do+0x45>
movslq %edi,%rax
movzbl 0x0(%rax),%eax
test   %al,%al
jne    12f <send_do+0x21>
movslq %edi,%rdx
testb  $0x4,0x0(%rdx)
jne    1ae <send_do+0xa0>
movslq %ebx,%rdx
movzbl 0x0(%rdx),%edx
test   $0x8,%dl
jne    1ae <send_do+0xa0>
movslq %ebx,%rcx
or     $0x8,%edx
mov    %dl,0x0(%rcx)
add    $0x1,%eax
mov    %al,0x0(%rcx)
mov    0x0(%rip),%rax        # 15a <send_do+0x4c>
movb   $0xff,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  16c <send_do+0x5e>
mov    0x0(%rip),%rax        # 173 <send_do+0x65>
movb   $0xfd,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  185 <send_do+0x77>
mov    0x0(%rip),%rax        # 18c <send_do+0x7e>
mov    %bl,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  19d <send_do+0x8f>
mov    %ebx,%edx
mov    $0xfd,%esi
mov    $0x0,%edi
callq  1ae <send_do+0xa0>
pop    %rbx
retq   
<<<sep_in_sample>>>
send_do (register int c, register int init)
{
  if (init)
    {
      if (((do_dont_resp[c] == 0) && (options[c]&0x04)) ||
   (options[c]&0x08))
 return;
      {options[c] |= 0x08;};
      do_dont_resp[c]++;
    }
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 253; ring_supplied(&netoring, 1); }; };
  { *netoring.supply = c; ring_supplied(&netoring, 1); };
  printoption ("SENT", 253, c);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 5
15 5
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 12
36 13
37 13
38 13
39 13
40 14
41 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d6 <free_filestruct+0x32>
push   %rbx
mov    0x10(%rdi),%rbx
test   %rbx,%rbx
je     1ca <free_filestruct+0x26>
mov    0x18(%rbx),%rdi
callq  1bc <free_filestruct+0x18>
mov    0x10(%rbx),%rax
test   %rax,%rax
je     1cd <free_filestruct+0x29>
mov    %rax,%rbx
jmp    1b3 <free_filestruct+0xf>
mov    %rdi,%rbx
mov    %rbx,%rdi
callq  1d5 <free_filestruct+0x31>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
free_filestruct(filestruct *src)
{
    if (src == ((void *)0))
 return;
    while (src->next != ((void *)0)) {
 src = src->next;
 delete_node(src->prev);
    }
    delete_node(src);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 5
7 7
8 7
9 5
10 5
11 5
12 5
13 5
14 5
15 9
16 9
17 10
18 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    $0x0,%edx
callq  943 <gsl_multifit_linear_stdform1+0x1b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_linear_stdform1 (const gsl_vector * L,
                              const gsl_matrix * X,
                              const gsl_vector * y,
                              gsl_matrix * Xs,
                              gsl_vector * ys,
                              gsl_multifit_linear_workspace * work)
{
  int status;
  status = gsl_multifit_linear_wstdform1(L, X, ((void *)0), y, Xs, ys, work);
  return status;
}
<<<sep_in_sample>>>
1 7
2 9
3 9
4 9
5 9
6 9
7 9
8 11
9 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
mov    $0x8927,%esi
mov    $0x0,%eax
callq  eaf <system_fh_hwaddr_query+0x22>
test   %eax,%eax
jns    ec5 <system_fh_hwaddr_query+0x38>
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  ec5 <system_fh_hwaddr_query+0x38>
mov    0x8(%rbx),%rax
movzwl 0x10(%rax),%edi
callq  ed2 <system_fh_hwaddr_query+0x45>
test   %rax,%rax
je     ee4 <system_fh_hwaddr_query+0x57>
cmpq   $0x0,0x18(%rax)
sete   %cl
movzbl %cl,%ecx
jmp    ee9 <system_fh_hwaddr_query+0x5c>
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  ef6 <system_fh_hwaddr_query+0x69>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_hwaddr_query (format_data_t form, int argc, char *argv[])
{
  struct arphrd_symbol *arp;
  if (rpl_ioctl (form->sfd, 0x8927, form->ifr) < 0)
    select_arg (form, argc, argv, 1);
  arp = arphrd_findvalue (form->ifr->ifr_ifru.ifru_hwaddr.sa_family);
  select_arg (form, argc, argv, (arp && arp->print_hwaddr) ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 8
35 8
36 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  43e <read_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
read_error (char const *name)
{
  call_arg_error ("read", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  447 <gsl_sf_bessel_J0+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     46d <gsl_sf_bessel_J0+0x32>
mov    %eax,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  466 <gsl_sf_bessel_J0+0x2b>
movsd  (%rsp),%xmm0
jmp    46d <gsl_sf_bessel_J0+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_J0(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_J0_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_J0_e(x, &result)", "bessel_J0.c", 110, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
cmp    $0x56,%edi
jne    14f <argp_version_parser+0x68>
push   %rbx
mov    %rdx,%rbx
mov    0x0(%rip),%rax        # f7 <argp_version_parser+0x10>
test   %rax,%rax
je     107 <argp_version_parser+0x20>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
jmp    13f <argp_version_parser+0x58>
mov    0x0(%rip),%rdx        # 10e <argp_version_parser+0x27>
test   %rdx,%rdx
je     128 <argp_version_parser+0x41>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  126 <argp_version_parser+0x3f>
jmp    13f <argp_version_parser+0x58>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  13f <argp_version_parser+0x58>
testb  $0x20,0x1c(%rbx)
jne    155 <argp_version_parser+0x6e>
mov    $0x0,%edi
callq  14f <argp_version_parser+0x68>
mov    $0x7,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
        (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
        fprintf (state->out_stream, "%s\n", argp_program_version);
      else
        argp_error (state, "%s",
                      ((void) (state->root_argp->argp_domain), ((const char *) ("(PROGRAM ERROR) No version known!?")))
                                                                     );
      if (! (state->flags & 0x20))
        exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 14
26 14
27 15
28 15
29 18
30 21
31 20
32 21
33 21
<<<sep_out_sample>>>
mov    $0xfffffff9,%eax
retq   
<<<sep_in_sample>>>
close_tray_solaris (const char *psz_device)
{
  return DRIVER_OP_NO_DRIVER;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
cmp    $0x2,%rax
je     1c87 <ewset_+0x5f>
cmp    $0x2,%rax
jg     1c45 <ewset_+0x1d>
cmp    $0x1,%rax
je     1c9f <ewset_+0x77>
nopl   (%rax)
jmpq   1d44 <ewset_+0x11c>
cmp    $0x3,%rax
je     1c6f <ewset_+0x47>
cmp    $0x4,%rax
nop
jne    1d44 <ewset_+0x11c>
mov    $0x0,%al
movsd  0x0(%rip),%xmm1        # 1c60 <ewset_+0x38>
cmpq   $0x0,(%rdi)
jg     1d21 <ewset_+0xf9>
jmpq   1d44 <ewset_+0x11c>
mov    $0x0,%eax
movsd  0x0(%rip),%xmm1        # 1c7c <ewset_+0x54>
cmpq   $0x0,(%rdi)
jg     1cfd <ewset_+0xd5>
jmpq   1d44 <ewset_+0x11c>
mov    $0x0,%eax
movsd  0x0(%rip),%xmm1        # 1c94 <ewset_+0x6c>
cmpq   $0x0,(%rdi)
jg     1cd9 <ewset_+0xb1>
jmpq   1d44 <ewset_+0x11c>
cmpq   $0x0,(%rdi)
jle    1d44 <ewset_+0x11c>
mov    $0x0,%eax
movsd  0x0(%rip),%xmm1        # 1cb6 <ewset_+0x8e>
movsd  (%r8,%rax,8),%xmm0
andpd  %xmm1,%xmm0
mulsd  (%rdx),%xmm0
addsd  (%rcx),%xmm0
movsd  %xmm0,(%r9,%rax,8)
add    $0x1,%rax
cmp    %rax,(%rdi)
jg     1cb6 <ewset_+0x8e>
jmp    1d44 <ewset_+0x11c>
movsd  (%r8,%rax,8),%xmm0
andpd  %xmm1,%xmm0
mulsd  (%rdx),%xmm0
addsd  (%rcx,%rax,8),%xmm0
movsd  %xmm0,(%r9,%rax,8)
add    $0x1,%rax
cmp    %rax,(%rdi)
jg     1cd9 <ewset_+0xb1>
jmp    1d44 <ewset_+0x11c>
movsd  (%r8,%rax,8),%xmm0
andpd  %xmm1,%xmm0
mulsd  (%rdx,%rax,8),%xmm0
addsd  (%rcx),%xmm0
movsd  %xmm0,(%r9,%rax,8)
add    $0x1,%rax
cmp    %rax,(%rdi)
jg     1cfd <ewset_+0xd5>
jmp    1d44 <ewset_+0x11c>
movsd  (%r8,%rax,8),%xmm0
andpd  %xmm1,%xmm0
mulsd  (%rdx,%rax,8),%xmm0
addsd  (%rcx,%rax,8),%xmm0
movsd  %xmm0,(%r9,%rax,8)
add    $0x1,%rax
cmp    %rax,(%rdi)
jg     1d21 <ewset_+0xf9>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
ewset_(long *n, long *itol, double *rtol,
           double *atol, double *ycur, double *ewt)
{
  long i;
  switch (*itol) {
    case 1:
      for (i = 0; i < *n; ++i)
        ewt[i] = rtol[0] * fabs(ycur[i]) + atol[0];
      break;
    case 2:
      for (i = 0; i < *n; ++i)
        ewt[i] = rtol[0] * fabs(ycur[i]) + atol[i];
      break;
    case 3:
      for (i = 0; i < *n; ++i)
        ewt[i] = rtol[i] * fabs(ycur[i]) + atol[0];
      break;
    case 4:
      for (i = 0; i < *n; ++i)
        ewt[i] = rtol[i] * fabs(ycur[i]) + atol[i];
      break;
  }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 19
16 20
17 19
18 19
19 19
20 15
21 16
22 15
23 15
24 15
25 11
26 12
27 11
28 11
29 11
30 7
31 7
32 7
33 8
34 8
35 8
36 8
37 8
38 8
39 7
40 7
41 7
42 7
43 12
44 12
45 12
46 12
47 12
48 11
49 11
50 11
51 11
52 16
53 16
54 16
55 16
56 16
57 15
58 15
59 15
60 15
61 20
62 20
63 20
64 20
65 20
66 19
67 19
68 19
69 24
70 24
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
mov    %rdx,0x10(%rdi)
orb    $0x1,0x40(%rdi)
retq   
<<<sep_in_sample>>>
_jit_set_code(jit_state_t *_jit, jit_pointer_t ptr, jit_word_t length)
{
    ((void) (0));
    _jit->code.ptr = ptr;
    _jit->code.length = length;
    _jit->user_code = 1;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
mov    0x20(%rsi),%eax
lea    0x1(%rax),%edx
mov    %edx,0x20(%rsi)
cltq   
mov    0x18(%rdi),%rcx
mov    0x78(%rsi),%rdx
mov    %rcx,(%rdx,%rax,8)
mov    0x70(%rsi),%rdx
mov    0x10(%rdi),%rcx
mov    %ecx,(%rdx,%rax,4)
mov    0x8(%rdi),%rcx
mov    0x38(%rsi),%rdx
mov    %rcx,(%rdx,%rax,8)
mov    (%rdi),%rcx
mov    0x30(%rsi),%rdx
mov    %rcx,(%rdx,%rax,8)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
InitOneDataVar (PVOID pData, PVOID pInfo)
{
  PDATAREC pda = (PDATAREC) pData;
  POUTSPEC pos = (POUTSPEC) pInfo;
  int i = pos->nData++;
  pos->prgdDataVals[i] = pda->pdData;
  pos->pcData[i] = pda->cData;
  pos->phvar_dat[i] = pda->hvar;
  pos->pszDataNames[i] = pda->szDataName;
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 7
9 7
10 7
11 8
12 8
13 8
14 9
15 9
16 9
17 11
18 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
callq  e <_auth_lb_create+0xe>
mov    %rax,%rdx
mov    %rax,(%rbx)
mov    $0xc,%eax
test   %rdx,%rdx
je     40 <_auth_lb_create+0x40>
movq   $0x0,(%rdx)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    (%rbx),%rax
movq   $0x0,0x10(%rax)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_auth_lb_create (struct _line_buffer **s)
{
  *s = malloc (sizeof (**s));
  if (!*s)
    return 12;
  (*s)->buffer = ((void *)0);
  (*s)->size = 0;
  (*s)->level = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 4
9 4
10 6
11 7
12 7
13 8
14 8
15 9
16 10
17 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  344 <settftpmode+0x11>
cmpl   $0x0,0x0(%rip)        # 34b <settftpmode+0x18>
je     361 <settftpmode+0x2e>
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  361 <settftpmode+0x2e>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
settftpmode (char *newmode)
{
  strcpy (mode, newmode);
  if (verbose)
    printf ("mode set to %s\n", mode);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r14
mov    %rdx,%rbx
mov    %rcx,%rbp
mov    %rdx,%rdi
callq  226f <patsubst_expand+0x1c>
mov    %rax,%r12
mov    %rbp,%rdi
callq  227a <patsubst_expand+0x27>
mov    %rax,%r9
cmp    $0x1,%rax
sbb    $0xffffffffffffffff,%r9
cmp    $0x1,%r12
mov    %r12,%r8
sbb    $0xffffffffffffffff,%r8
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %r14,%rsi
mov    %r13,%rdi
callq  22a1 <patsubst_expand+0x4e>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
patsubst_expand (char *o, const char *text, char *pattern, char *replace)
{
  const char *pattern_percent = find_percent (pattern);
  const char *replace_percent = find_percent (replace);
  if (replace_percent)
    ++replace_percent;
  if (pattern_percent)
    ++pattern_percent;
  return patsubst_expand_pat (o, text, pattern, replace,
                              pattern_percent, replace_percent);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 4
14 4
15 4
16 6
17 6
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     16b <xfprintf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  19c <xfprintf+0x87>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
xfprintf (FILE *__restrict stream, char const *__restrict format, ...)
{
  va_list args;
  int retval;
  __builtin_va_start(args,format);
  retval = xvfprintf (stream, format, args);
  __builtin_va_end(args);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 9
25 9
<<<sep_out_sample>>>
movb   $0x1,0x6d(%rdi)
retq   
<<<sep_in_sample>>>
panel_activate(this)
    panel_t *this;
{
    this->visible = 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xa3,%esi
mov    $0x0,%eax
callq  0 <_evalfile>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fc_execute_file (filename)
     const char *filename;
{
  int flags;
  flags = 0x001|0x020|0x080|0x002;
  return (_evalfile (filename, flags));
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 6
5 7
6 7
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
mov    0x4(%rdi),%edx
sar    $0x1f,%edx
mov    %edx,%eax
xor    0x4(%rdi),%eax
sub    %edx,%eax
cltq   
retq   
<<<sep_in_sample>>>
__gmpz_size (mpz_srcptr __gmp_z)
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
callq  b75 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 14aa <stat_pointers+0x7>
jne    1563 <stat_pointers+0xc0>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 14bb <stat_pointers+0x18>
mov    $0x35,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14cf <stat_pointers+0x2c>
mov    0x0(%rip),%rcx        # 14d6 <stat_pointers+0x33>
mov    $0x4a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14ea <stat_pointers+0x47>
mov    0x0(%rip),%rdi        # 14f1 <stat_pointers+0x4e>
callq  494 <do_for_each_stat_pointer>
mov    0x0(%rip),%rcx        # 14fd <stat_pointers+0x5a>
mov    $0x21,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1511 <stat_pointers+0x6e>
mov    0x0(%rip),%rdi        # 1518 <stat_pointers+0x75>
callq  523 <update_gl_obj>
mov    0x0(%rip),%rcx        # 1524 <stat_pointers+0x81>
mov    $0x1d,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1538 <stat_pointers+0x95>
mov    0x0(%rip),%rdi        # 153f <stat_pointers+0x9c>
callq  5bf <update_gl_null>
mov    0x0(%rip),%rcx        # 154b <stat_pointers+0xa8>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  155f <stat_pointers+0xbc>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
stat_pointers (void)
{
  block_t *block;
  struct stamp *st;
  if (!separat_comp)
    {
      fprintf (ccode, "\nvoid __init(void){__init_FILE();__init_SIMENVIR();}\n");
      fprintf
 (ccode,
  "__do_for_each_stat_pointer(void(*doit)(),void(*doit_notest)(),int force){\n");
      do_for_each_stat_pointer (sblock);
      fprintf (ccode, "}\nvoid __update_gl_to_obj(void){\n");
      update_gl_obj (sblock);
      fprintf (ccode, "}\n__update_gl_to_null(void){\n");
      update_gl_null (sblock);
      fprintf (ccode, "}\n");
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 7
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 11
15 11
16 12
17 12
18 12
19 12
20 12
21 13
22 13
23 14
24 14
25 14
26 14
27 14
28 15
29 15
30 16
31 16
32 16
33 16
34 16
35 18
36 18
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
cmpq   $0x0,0x28(%rdi)
je     1041 <da_map+0x2b>
mov    %rsi,%r12
mov    $0x0,%ebx
mov    0x30(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
callq  *%r12
add    $0x1,%rbx
cmp    %rbx,0x28(%rbp)
ja     102c <da_map+0x16>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
da_map (struct darray * arr, da_map_func_t fn)
{
  size_t i;
  for (i = 0 ; i < arr->len ; i++)
    (*fn) (arr->content [i]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 4
13 4
14 4
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%esi
mov    $0x4,%edi
callq  13 <_gsasl_openid20_client_start+0x13>
mov    $0x7,%edx
test   %rax,%rax
je     22 <_gsasl_openid20_client_start+0x22>
mov    %rax,(%rbx)
mov    $0x0,%dl
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_gsasl_openid20_client_start (Gsasl_session * sctx, void **mech_data)
{
  struct openid20_client_state *state;
  state = (struct openid20_client_state *) calloc (sizeof (*state), 1);
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 5
8 5
9 7
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    $0x1,%ecx
callq  0 <multifit_wlinear_svd>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_wlinear_svd (const gsl_matrix * X,
                          const gsl_vector * w,
                          const gsl_vector * y,
                          double tol,
                          size_t * rank,
                          gsl_vector * c,
                          gsl_matrix * cov,
                          double *chisq, gsl_multifit_linear_workspace * work)
{
  int status = multifit_wlinear_svd (X, w, y, tol, 1, rank, c,
                                      cov, chisq, work);
  return status;
}
<<<sep_in_sample>>>
1 9
2 10
3 10
4 10
5 10
6 10
7 10
8 10
9 10
10 10
11 13
12 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  8f5 <gsl_block_long_calloc+0xe>
mov    %rax,%rbp
test   %rax,%rax
je     934 <gsl_block_long_calloc+0x4d>
lea    0x0(,%rbx,8),%rdx
mov    0x8(%rax),%rdi
mov    $0x0,%esi
callq  913 <gsl_block_long_calloc+0x2c>
test   %rbx,%rbx
je     93b <gsl_block_long_calloc+0x54>
mov    $0x0,%edx
mov    0x8(%rbp),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    91d <gsl_block_long_calloc+0x36>
jmp    942 <gsl_block_long_calloc+0x5b>
mov    $0x0,%eax
jmp    945 <gsl_block_long_calloc+0x5e>
mov    %rbp,%rax
xchg   %ax,%ax
jmp    945 <gsl_block_long_calloc+0x5e>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_block_long_calloc (const size_t n)
{
  size_t i;
  gsl_block_long * b = gsl_block_long_alloc (n);
  if (b == 0)
    return 0;
  memset(b->data, 0, 1 * n * sizeof(long));
  for (i = 0; i < 1 * n; i++)
    {
      b->data[i] = 0;
    }
  return b;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 6
24 12
25 12
26 12
27 12
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    0x0(%rip),%esi        # c88 <safely_quote_err_filename+0xd>
callq  c8d <safely_quote_err_filename+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
safely_quote_err_filename (int n, char const *arg)
{
  return quotearg_n_style (n, options.err_quoting_style, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <xalloc_die+0xe>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  2a <xalloc_die+0x2a>
callq  2f <main>
<<<sep_in_sample>>>
xalloc_die ()
{
  anubis_error (1, 0, "%s", gettext("Not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0xc,%esi
callq  11 <gcm_camellia256_set_nonce_wrapper+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gcm_camellia256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)
{
  nettle_gcm_camellia256_set_iv (ctx, (16 - 4), nonce);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    %rcx,%r13
mov    (%rcx),%rbx
test   %rbx,%rbx
je     22a <wsp_getvar+0x7b>
mov    %rsi,%r15
mov    %rdx,%r12
mov    $0x0,%ebp
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1e5 <wsp_getvar+0x36>
cmp    %r12,%rax
jne    218 <wsp_getvar+0x69>
mov    %r12,%rdx
mov    %r15,%rsi
mov    %rbx,%rdi
callq  1f8 <wsp_getvar+0x49>
mov    %eax,%r14d
test   %eax,%eax
jne    218 <wsp_getvar+0x69>
lea    0x1(%rbx,%r12,1),%rdi
callq  209 <wsp_getvar+0x5a>
test   %rax,%rax
je     232 <wsp_getvar+0x83>
mov    0x8(%rsp),%rcx
mov    %rax,(%rcx)
jmp    240 <wsp_getvar+0x91>
add    $0x1,%ebp
movslq %ebp,%rax
mov    0x0(%r13,%rax,8),%rbx
test   %rbx,%rbx
jne    1d8 <wsp_getvar+0x29>
jmp    23a <wsp_getvar+0x8b>
mov    $0x5,%r14d
jmp    240 <wsp_getvar+0x91>
mov    $0x2,%r14d
jmp    240 <wsp_getvar+0x91>
mov    $0x5,%r14d
mov    %r14d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
wsp_getvar (char **ret, const char *vptr, size_t vlen, void *data)
{
  char **base = data;
  int i;
  for (i = 0; base[i]; i++)
    {
      size_t l = strcspn (base[i], "=");
      if (l == vlen && memcmp (base[i], vptr, vlen) == 0)
 {
   char *p = strdup (base[i] + vlen + 1);
   if (p == ((void *)0))
     return 2;
   *ret = p;
   return 0;
 }
    }
  return 5;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 10
29 10
30 11
31 11
32 13
33 13
34 14
35 5
36 5
37 5
38 5
39 5
40 5
41 17
42 17
43 12
44 12
45 17
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 18
54 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  82 <wctomb_reset+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
wctomb_reset(void)
{
    do { if (wctomb(((void *)0), 0)) {} } while(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rsi,0xa0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_digest_md5_set (Gsasl * ctx,
          Gsasl_server_callback_digest_md5 cb)
{
  ctx->cbs_digest_md5 = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  15b5 <quote+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote (char const *arg)
{
  return quote_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  48d0 <sv_tz+0x9>
test   %eax,%eax
je     48d9 <sv_tz+0x12>
callq  48d9 <sv_tz+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sv_tz (name)
     char *name;
{
  if (chkexport (name))
    tzset ();
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     9e8 <osip_remove_transaction+0x4b>
mov    0x80(%rsi),%edx
test   %edx,%edx
jne    9b7 <osip_remove_transaction+0x1a>
callq  9b5 <osip_remove_transaction+0x18>
jmp    9ed <osip_remove_transaction+0x50>
cmp    $0x1,%edx
jne    9c7 <osip_remove_transaction+0x2a>
nopl   0x0(%rax)
callq  9c5 <osip_remove_transaction+0x28>
jmp    9ed <osip_remove_transaction+0x50>
cmp    $0x2,%edx
jne    9d7 <osip_remove_transaction+0x3a>
nopl   0x0(%rax)
callq  9d5 <osip_remove_transaction+0x38>
jmp    9ed <osip_remove_transaction+0x50>
mov    $0xfffffffe,%eax
cmp    $0x3,%edx
jne    9ed <osip_remove_transaction+0x50>
callq  9e6 <osip_remove_transaction+0x49>
jmp    9ed <osip_remove_transaction+0x50>
mov    $0xfffffffe,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_remove_transaction (osip_t * osip, osip_transaction_t * tr)
{
  int i = -1;
  if (tr == ((void *)0))
    return -2;
  if (tr->ctx_type == ICT)
    i = __osip_remove_ict_transaction (osip, tr);
  else if (tr->ctx_type == IST)
    i = __osip_remove_ist_transaction (osip, tr);
  else if (tr->ctx_type == NICT)
    i = __osip_remove_nict_transaction (osip, tr);
  else if (tr->ctx_type == NIST)
    i = __osip_remove_nist_transaction (osip, tr);
  else
    return -2;
  return i;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 7
8 7
9 8
10 8
11 8
12 9
13 9
14 10
15 10
16 10
17 11
18 11
19 15
20 12
21 12
22 13
23 13
24 5
25 17
26 17
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    0x18(%rdi),%r12
mov    0x28(%rdi),%rbx
lea    0x28(%rdi),%r13
cmp    %r13,%rbx
je     5cc <gl_linked_list_free+0x3d>
mov    (%rbx),%rbp
test   %r12,%r12
je     5ba <gl_linked_list_free+0x2b>
mov    0x10(%rbx),%rdi
callq  *%r12
mov    %rbx,%rdi
callq  5c2 <gl_linked_list_free+0x33>
cmp    %r13,%rbp
je     5cc <gl_linked_list_free+0x3d>
mov    %rbp,%rbx
jmp    5ab <gl_linked_list_free+0x1c>
mov    %r14,%rdi
callq  5d4 <gl_linked_list_free+0x45>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gl_linked_list_free (gl_list_t list)
{
  gl_listelement_dispose_fn dispose = list->base.dispose_fn;
  gl_list_node_t node;
  for (node = list->root.next; node != &list->root; )
    {
      gl_list_node_t next = node->next;
      if (dispose != ((void *)0))
        dispose (node->value);
      free (node);
      node = next;
    }
  free (list);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 5
9 5
10 5
11 5
12 7
13 8
14 8
15 9
16 9
17 10
18 10
19 5
20 5
21 11
22 11
23 13
24 13
25 14
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 3af <sshrestart+0x10>
test   %rax,%rax
je     3c2 <sshrestart+0x23>
mov    0x0(%rip),%rdx        # 3bb <sshrestart+0x1c>
cmpq   $0x0,(%rax,%rdx,8)
jne    3ff <sshrestart+0x60>
callq  11a <sshensure_buffer_stack>
mov    0x0(%rip),%rax        # 3ce <sshrestart+0x2f>
mov    0x0(%rip),%rdx        # 3d5 <sshrestart+0x36>
lea    (%rax,%rdx,8),%rbp
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 3e5 <sshrestart+0x46>
callq  3ea <sshrestart+0x4b>
mov    %rax,0x0(%rbp)
mov    0x0(%rip),%rax        # 3f5 <sshrestart+0x56>
mov    $0x0,%edi
test   %rax,%rax
je     40a <sshrestart+0x6b>
mov    0x0(%rip),%rdx        # 406 <sshrestart+0x67>
mov    (%rax,%rdx,8),%rdi
mov    %rbx,%rsi
callq  2b1 <ssh_init_buffer>
callq  af <ssh_load_buffer_state>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
sshrestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        sshensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            ssh_create_buffer(sshin,16384 );
 }
 ssh_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 ssh_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     7b6 <node_free+0x87>
mov    0x4(%rdi),%eax
sub    $0x1,%eax
mov    %eax,0x4(%rdi)
test   %eax,%eax
jne    7b6 <node_free+0x87>
mov    (%rdi),%eax
cmp    $0x1,%eax
je     76f <node_free+0x40>
cmp    $0x1,%eax
jb     7b6 <node_free+0x87>
cmp    $0x2,%eax
je     77a <node_free+0x4b>
cmp    $0x6,%eax
xchg   %ax,%ax
jne    7ae <node_free+0x7f>
mov    $0x0,%ebp
cmpl   $0x0,0x20(%rdi)
jne    78e <node_free+0x5f>
jmp    7a5 <node_free+0x76>
mov    0x18(%rdi),%rdi
callq  778 <node_free+0x49>
jmp    7ae <node_free+0x7f>
mov    0x18(%rdi),%rdi
callq  783 <node_free+0x54>
mov    0x48(%rbx),%rdi
callq  78c <node_free+0x5d>
jmp    7ae <node_free+0x7f>
mov    %ebp,%edx
mov    0x18(%rbx),%rax
mov    (%rax,%rdx,8),%rdi
callq  79d <node_free+0x6e>
add    $0x1,%ebp
cmp    %ebp,0x20(%rbx)
ja     78e <node_free+0x5f>
mov    0x18(%rbx),%rdi
callq  7ae <node_free+0x7f>
mov    %rbx,%rdi
callq  7b6 <node_free+0x87>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
node_free (node)
     Node *node;
{
  unsigned int i;
  if (node == ((void *)0))
    return;
  if (--node->refcount > 0)
    return;
  switch (node->type)
    {
    case nVOID:
      return;
      break;
    case nSTRING:
      xfree (node->u.str.data);
      break;
    case nREGEXP:
      free (node->u.re.data);
      xfree (node->u.re.compiled.fastmap);
      break;
    case nINTEGER:
    case nREAL:
    case nSYMBOL:
      break;
    case nARRAY:
      for (i = 0; i < node->u.array.len; i++)
 node_free (node->u.array.array[i]);
      xfree (node->u.array.array);
      break;
    }
  xfree (node);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 26
23 26
24 26
25 26
26 15
27 15
28 16
29 18
30 18
31 19
32 19
33 20
34 27
35 27
36 27
37 27
38 26
39 26
40 26
41 28
42 28
43 31
44 31
45 32
46 32
47 32
48 32
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  1469 <gsl_sort_vector_uchar_smallest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_uchar_smallest (unsigned char * dest, const size_t k,
                                     const gsl_vector_uchar * v)
{
  return gsl_sort_uchar_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
movzbl (%rdi),%r8d
mov    $0x0,%ebp
mov    $0x0,%ebx
test   %r10,%r10
je     18a6 <gsl_vector_char_minmax_index+0x47>
jmp    18ae <gsl_vector_char_minmax_index+0x4f>
movzbl (%rdi),%ecx
cmp    %cl,%r8b
jle    188f <gsl_vector_char_minmax_index+0x30>
mov    %ecx,%r8d
mov    %rax,%rbx
add    %r11,%rdi
cmp    %r9b,%cl
jle    189d <gsl_vector_char_minmax_index+0x3e>
mov    %ecx,%r9d
mov    %rax,%rbp
add    $0x1,%rax
cmp    %r10,%rax
jne    1881 <gsl_vector_char_minmax_index+0x22>
mov    %rbx,(%rsi)
mov    %rbp,(%rdx)
jmp    18c8 <gsl_vector_char_minmax_index+0x69>
add    %r11,%rdi
mov    %r8d,%r9d
mov    %r8d,%ecx
mov    $0x0,%eax
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    1892 <gsl_vector_char_minmax_index+0x33>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_char_minmax_index (const gsl_vector_char * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  char max = v->data[0 * stride];
  char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 8
7 7
8 7
9 11
10 11
11 11
12 13
13 14
14 14
15 13
16 11
17 11
18 19
19 19
20 19
21 19
22 11
23 11
24 11
25 25
26 26
27 26
28 26
29 8
30 13
31 11
32 7
33 7
34 7
35 27
36 27
37 27
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  1a <_is_ws+0x8>
movslq %ebx,%rbx
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
and    $0x2000,%ax
movzwl %ax,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_is_ws(int c)
{
    return ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
cmp    $0x75bd924,%rsi
jne    df <ran0_set+0x28>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x53,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  dd <ran0_set+0x26>
jmp    ea <ran0_set+0x33>
xor    $0x75bd924,%rsi
mov    %rsi,(%rdi)
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ran0_set (void *vstate, unsigned long int s)
{
  ran0_state_t *state = (ran0_state_t *) vstate;
  if (s == mask)
    {
      do { gsl_error ("ran0 should not use seed == mask",
 "ran0.c"
      ,
 83
      , GSL_EINVAL) ; return ; } while (0)
                                           ;
    }
  state->x = s ^ mask;
  return;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 6
7 6
8 6
9 10
10 13
11 13
12 14
13 15
14 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
neg    %esi
callq  4380 <info_scroll_backward_set_window+0xb>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_scroll_backward_set_window (WINDOW *window, int count)
{
  info_scroll_forward_set_window (window, -count);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %rdx,%rbp
movabs $0xffffffff00000000,%rax
test   %rax,%rdx
jne    665 <_imovi+0x5c>
mov    %esi,%r9d
mov    $0x28,%r8d
mov    $0x28,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
and    $0x7,%r12d
or     $0xffffffb8,%r12d
mov    %r12b,(%rax)
mov    (%rbx),%rax
lea    0x4(%rax),%rdx
mov    %rdx,(%rbx)
mov    %ebp,(%rax)
jmp    6a4 <_imovi+0x9b>
mov    %esi,%r9d
mov    $0x28,%r8d
mov    $0x28,%ecx
mov    $0x1,%edx
mov    $0x0,%esi
callq  15d <_rex>
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
and    $0x7,%r12d
or     $0xffffffb8,%r12d
mov    %r12b,(%rax)
mov    (%rbx),%rax
lea    0x8(%rax),%rdx
mov    %rdx,(%rbx)
mov    %rbp,(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_imovi(jit_state_t *_jit, jit_int32_t r0, jit_word_t i0)
{
    if ((((i0) & 0xffffffff00000000LL) == 0)) {
 _rex(_jit, 0, 0, _NOREG, _NOREG, r0);
 *_jit->pc.uc++ = 0xb8 | ((r0) & 7);
 *_jit->pc.ui++ = i0;
    }
    else {
 _rex(_jit, 0, 1, _NOREG, _NOREG, r0);
 *_jit->pc.uc++ = 0xb8 | ((r0) & 7);
 *_jit->pc.ul++ = i0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 9
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 11
42 11
43 13
44 13
45 13
46 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0xb1,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  75a <copy_for_command+0x1d>
mov    %rax,%rbx
mov    0x0(%rbp),%eax
mov    %eax,(%rbx)
mov    0x4(%rbp),%eax
mov    %eax,0x4(%rbx)
mov    0x8(%rbp),%rdi
callq  771 <copy_for_command+0x34>
mov    %rax,0x8(%rbx)
mov    0x10(%rbp),%rdi
callq  77e <copy_for_command+0x41>
mov    %rax,0x10(%rbx)
mov    0x18(%rbp),%rdi
callq  78b <copy_for_command+0x4e>
mov    %rax,0x18(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
copy_for_command (com)
     FOR_COM *com;
{
  FOR_COM *new_for;
  new_for = (FOR_COM *)sh_xmalloc((sizeof (FOR_COM)), "copy_cmd.c", 177);
  new_for->flags = com->flags;
  new_for->line = com->line;
  new_for->name = copy_word (com->name);
  new_for->map_list = copy_word_list (com->map_list);
  new_for->action = copy_command (com->action);
  return (new_for);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 8
15 8
16 8
17 9
18 9
19 9
20 10
21 10
22 10
23 12
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r11
test   %r10,%r10
je     1ec5 <gsl_matrix_float_add_constant+0x68>
shl    $0x2,%r11
mov    $0x0,%r9d
mov    $0x0,%r8d
jmp    1eb6 <gsl_matrix_float_add_constant+0x59>
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
movss  (%rcx),%xmm1
cvtps2pd %xmm1,%xmm1
addsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,(%rcx)
add    $0x1,%rax
add    $0x4,%rdx
cmp    %rsi,%rax
jne    1e7f <gsl_matrix_float_add_constant+0x22>
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
je     1ec5 <gsl_matrix_float_add_constant+0x68>
test   %rsi,%rsi
je     1eaa <gsl_matrix_float_add_constant+0x4d>
mov    %r9,%rdx
mov    $0x0,%eax
jmp    1e7f <gsl_matrix_float_add_constant+0x22>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_float_add_constant (gsl_matrix_float * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 9
31 15
32 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0x0,%edi
mov    $0x2,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    cab <grecs_match_first+0x36>
movq   $0x0,(%r12)
mov    %r13,%rax
jmp    d09 <grecs_match_first+0x94>
mov    $0x30,%edi
callq  cb5 <grecs_match_first+0x40>
mov    %rax,%rbp
lea    0x18(%rax),%rcx
lea    0x8(%rax),%rdx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  1f2 <split_cfg_path>
test   %eax,%eax
je     cde <grecs_match_first+0x69>
mov    %rbp,%rdi
callq  cd7 <grecs_match_first+0x62>
mov    $0x0,%eax
jmp    d09 <grecs_match_first+0x94>
mov    %r13,%rsi
mov    %rbp,%rdi
callq  ce9 <grecs_match_first+0x74>
test   %rax,%rax
je     cf4 <grecs_match_first+0x7f>
mov    %rbp,(%r12)
jmp    d09 <grecs_match_first+0x94>
mov    %rbp,%rdi
callq  cfc <grecs_match_first+0x87>
movq   $0x0,(%r12)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
grecs_match_first(struct grecs_node *tree, const char *pattern,
    struct grecs_match_buf **pbuf)
{
 struct grecs_node *node;
 struct grecs_match_buf *buf;
 if (strcmp(pattern, ".") == 0) {
  *pbuf = ((void *)0);
  return tree;
 }
 buf = grecs_zalloc(sizeof(*buf));
 if (split_cfg_path(pattern, &buf->argc, &buf->argv, &buf->labelv)) {
  free(buf);
  return ((void *)0);
 }
 node = grecs_match_buf_first(buf, tree);
 if (node)
  *pbuf = buf;
 else {
  grecs_match_buf_free(buf);
  *pbuf = ((void *)0);
 }
 return node;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 8
18 8
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 13
32 13
33 15
34 15
35 15
36 16
37 16
38 17
39 17
40 19
41 19
42 20
43 22
44 23
45 23
46 23
47 23
48 23
49 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  b40 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  b49 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
mov    %rbx,%rdi
callq  b59 <wordsplit_free+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
  wordsplit_free_envbuf (ws);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 1ea2 <xmitEC+0xb>
movb   $0xff,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  1eb4 <xmitEC+0x1d>
mov    0x0(%rip),%rax        # 1ebb <xmitEC+0x24>
movb   $0xf7,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  1ecd <xmitEC+0x36>
mov    $0xf7,%edx
mov    $0xff,%esi
mov    $0x0,%edi
callq  1ee1 <xmitEC+0x4a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xmitEC (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 247; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 247);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,0x8(%rsp)
movl   $0x0,(%rsp)
mov    $0x0,%r9d
callq  36 <_getopt_long_r+0x1b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
_getopt_long_r (int argc, char **argv, const char *options,
  const struct option *long_options, int *opt_index,
  struct _getopt_data *d)
{
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
        0, 0, d);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 7
7 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
callq  11 <_icvt_get_transport2+0x11>
test   %rbp,%rbp
je     1d <_icvt_get_transport2+0x1d>
mov    (%rax),%rax
mov    %rax,0x0(%rbp)
cmpq   $0x0,(%rbx)
je     2a <_icvt_get_transport2+0x2a>
movq   $0x0,(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_icvt_get_transport2 (mu_stream_t stream,
       mu_transport_t *pt, mu_transport_t *pt2)
{
  struct icvt_stream *s = mu_stream_get_owner (stream);
  if (pt)
    *pt = s->stream;
  if (*pt2)
    *pt2 = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 10
15 10
16 10
17 10
18 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  31f <gl_array_indexof_from_to>
add    $0x1,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_array_search_from_to (gl_list_t list, size_t start_index, size_t end_index,
                         const void *elt)
{
  size_t index = gl_array_indexof_from_to (list, start_index, end_index, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
get_current_file(void)
{
 return current_file;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     488 <swrite+0x32>
mov    %edi,%r9d
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
je     488 <swrite+0x32>
sub    $0x8,%rsp
mov    %r9d,%edi
callq  484 <swrite+0x2e>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
swrite (int method, NET_STREAM sd, const char *ptr)
{
  size_t nleft;
  if (ptr == ((void *)0) || (nleft = strlen (ptr)) == 0)
    return;
  swrite_n (method, sd, ptr, nleft);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 2
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xconcatenated_filename+0x9>
test   %rax,%rax
jne    13 <xconcatenated_filename+0x13>
callq  13 <xconcatenated_filename+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xconcatenated_filename (const char *directory, const char *filename,
                        const char *suffix)
{
  char *result;
  result = concatenated_filename (directory, filename, suffix);
  if (result == ((void *)0))
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 7
6 9
7 9
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1ea <is_wlower+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
is_wlower(wchar_t c)
{
 return iswlower(c);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x60,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x58(%rsp)
xor    %eax,%eax
cmpb   $0x0,0x0(%rip)        # 603 <xperror+0x1f>
jne    63a <xperror+0x56>
cmpb   $0x0,0x0(%rip)        # 60c <xperror+0x28>
je     6e5 <xperror+0x101>
mov    0x0(%rip),%rcx        # 619 <xperror+0x35>
mov    $0x7,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  62d <xperror+0x49>
mov    %rbx,%rdi
callq  635 <xperror+0x51>
jmpq   6e5 <xperror+0x101>
cmpb   $0x0,0x0(%rip)        # 641 <xperror+0x5d>
je     6e5 <xperror+0x101>
callq  64c <xperror+0x68>
mov    (%rax),%edi
callq  653 <xperror+0x6f>
mov    %rax,%r8
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x50,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  670 <xperror+0x8c>
mov    $0x0,%edx
mov    $0x10000,%esi
mov    0x0(%rip),%rdi        # 681 <xperror+0x9d>
callq  686 <xperror+0xa2>
mov    %rsp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%edi        # 699 <xperror+0xb5>
mov    $0x0,%eax
callq  6a3 <xperror+0xbf>
mov    $0x0,%edx
mov    $0x10000,%esi
mov    0x0(%rip),%rdi        # 6b4 <xperror+0xd0>
callq  6b9 <xperror+0xd5>
mov    0x0(%rip),%rdi        # 6c0 <xperror+0xdc>
callq  6c5 <xperror+0xe1>
mov    0x0(%rip),%rdi        # 6cc <xperror+0xe8>
callq  6d1 <xperror+0xed>
mov    $0x3,%edi
callq  590 <select_wait>
mov    $0x0,%edi
callq  b <action>
mov    0x58(%rsp),%rax
xor    %fs:0x28,%rax
je     6fa <xperror+0x116>
callq  6fa <xperror+0x116>
add    $0x60,%rsp
pop    %rbx
nop
retq   
<<<sep_in_sample>>>
xperror(const char *psz_msg)
{
  char line[80];
  if (!b_interactive) {
    if (b_verbose) {
      fprintf(stderr, "error: ");
      perror(psz_msg);
    }
    return;
  }
  if (b_verbose) {
    snprintf(line, sizeof(line), "%s: %s", psz_msg, strerror((*__errno_location ())));
    wattr_on(stdscr, (attr_t)((((chtype)((1UL)) << ((8) + 8)))), ((void *)0));
    mvprintw(LINE_ACTION, 0, (char *) "error  : %s", line);
    wattr_off(stdscr, (attr_t)((((chtype)((1UL)) << ((8) + 8)))), ((void *)0));
    wclrtoeol(stdscr);
    wrefresh(stdscr);
    select_wait(3);
    action("");
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 11
20 11
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 13
32 13
33 13
34 13
35 14
36 14
37 14
38 14
39 14
40 14
41 15
42 15
43 15
44 15
45 16
46 16
47 17
48 17
49 18
50 18
51 19
52 19
53 21
54 21
55 21
56 21
57 21
58 21
59 21
60 21
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  115 <string_htable_add+0x11>
test   %rax,%rax
jne    12d <string_htable_add+0x29>
mov    %rbp,%rdi
callq  122 <string_htable_add+0x1e>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  12d <string_htable_add+0x29>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
string_htable_add (struct string_htable * table, const char * key)
{
  if (!hash_find_item (table, key))
    hash_insert (table, xstrdup(key));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     85 <die+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
cmpl   $0x0,0x0(%rip)        # 8f <die+0x66>
jne    fa <die+0xd1>
mov    0x0(%rip),%rdx        # 98 <die+0x6f>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # a4 <die+0x7b>
mov    $0x0,%eax
callq  ae <die+0x85>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # e4 <die+0xbb>
callq  e9 <die+0xc0>
mov    0x0(%rip),%rsi        # f0 <die+0xc7>
mov    $0xa,%edi
callq  fa <die+0xd1>
mov    0x0(%rip),%rax        # 101 <die+0xd8>
test   %rax,%rax
je     108 <die+0xdf>
callq  *%rax
cmpl   $0x0,0x0(%rip)        # 10f <die+0xe6>
je     116 <die+0xed>
callq  116 <die+0xed>
mov    $0x1,%edi
callq  120 <die_with_code>
<<<sep_in_sample>>>
die(const char *s, ...)
{
 va_list ap;
 if (!quiet) {
  fprintf(stderr, "%s: ", progname);
  __builtin_va_start(ap,s);
  (void)vfprintf(stderr, s, ap);
  __builtin_va_end(ap);
  fputs("\n", stderr);
 }
 if (exit_proc)
  (*exit_proc)();
 if (debug)
  abort();
 exit(1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 6
31 6
32 7
33 7
34 7
35 7
36 9
37 9
38 9
39 11
40 11
41 11
42 12
43 13
44 13
45 14
46 15
47 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  5ba <alog_pid+0x9>
movslq %eax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  5cf <alog_pid+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
alog_pid(FILE *fp, struct alog_instr *instr, int argc, char **argv)
{
    fprintf(fp, "%lu", (unsigned long) getpid());
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  12f <register_regex+0xe>
mov    $0x0,%edi
callq  139 <register_regex+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
register_regex()
{
    dico_strategy_add(&re_strat);
    dico_strategy_add(&regex_strat);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%r8
mov    %edx,%ebx
test   %edx,%edx
jns    417 <etar_set_size_from_buffer+0x21>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%ebx
mov    %ebx,%esi
mov    %r8,%rdi
callq  421 <etar_set_size_from_buffer+0x2b>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
etar_set_size_from_buffer(ETAR * etar, char * buf, int bufsize)
{
 int len;
 if (bufsize < 0)
  len = strlen(buf);
 else
  len = bufsize;
 etar_set_size(etar, (unsigned int)(len));
 return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 8
13 8
14 8
15 10
16 10
17 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 687 <make_array+0xb>
test   %rdx,%rdx
je     699 <make_array+0x1d>
mov    0x8(%rdx),%rax
mov    %rax,0x0(%rip)        # 697 <make_array+0x1b>
jmp    6a6 <make_array+0x2a>
mov    $0x1,%edi
callq  6a3 <make_array+0x27>
mov    %rax,%rdx
mov    %rdx,%rdi
mov    $0x48,%esi
test   $0x1,%dl
je     6bd <make_array+0x41>
movb   $0x0,(%rdx)
lea    0x1(%rdx),%rdi
mov    $0x47,%sil
test   $0x2,%dil
je     6cf <make_array+0x53>
movw   $0x0,(%rdi)
add    $0x2,%rdi
sub    $0x2,%esi
test   $0x4,%dil
je     6e2 <make_array+0x66>
movl   $0x0,(%rdi)
add    $0x4,%rdi
sub    $0x4,%esi
mov    %esi,%ecx
shr    $0x3,%ecx
mov    %ecx,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
test   $0x4,%sil
je     701 <make_array+0x85>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     710 <make_array+0x94>
movw   $0x0,(%rdi)
add    $0x2,%rdi
test   $0x1,%sil
je     719 <make_array+0x9d>
movb   $0x0,(%rdi)
movl   $0x5,0x40(%rdx)
movq   $0x0,(%rdx)
mov    %rdx,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_array()
{
 NODE *array;
 (void) ((array = (NODE *) nextfree[BLOCK_NODE].freep) ? (NODE *) (nextfree[BLOCK_NODE].freep = ((BLOCK *) array)->freep) : (array = (NODE *) more_blocks(BLOCK_NODE)));
 memset(array, '\0', sizeof(NODE));
 array->type = Node_var_array;
 array->sub.nodep.l.lp = null_array_func;
 return array;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 6
45 7
46 9
47 9
48 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     46b <gsasl_server_callback_cram_md5_get+0xd>
mov    0x98(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_cram_md5_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cram_md5 : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %r9,%rdi
callq  16a <grecs_txtacc_grow_string+0x27>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_txtacc_grow_string(struct grecs_txtacc *acc, const char *buf)
{
 grecs_txtacc_grow(acc, buf, strlen(buf));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     258 <canon_doc_option+0x61>
callq  206 <canon_doc_option+0xf>
mov    %rax,%r8
jmp    212 <canon_doc_option+0x1b>
add    $0x1,%rdx
mov    %rdx,(%rbx)
mov    (%r8),%rsi
mov    (%rbx),%rdx
movzbl (%rdx),%ecx
movzbl %cl,%edi
testb  $0x20,0x1(%rsi,%rdi,2)
jne    20b <canon_doc_option+0x14>
cmp    $0x2d,%cl
setne  %al
movzbl %al,%eax
test   %cl,%cl
je     25d <canon_doc_option+0x66>
testb  $0x8,(%rsi,%rdi,2)
jne    25d <canon_doc_option+0x66>
add    $0x1,%rdx
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
je     25d <canon_doc_option+0x66>
add    $0x1,%rdx
movzbl %cl,%ecx
mov    (%r8),%rsi
testb  $0x8,(%rsi,%rcx,2)
je     23c <canon_doc_option+0x45>
jmp    25d <canon_doc_option+0x66>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 8
6 8
7 8
8 9
9 9
10 8
11 8
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 12
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 5
35 15
36 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     1d6a <gsl_vector_int_sub+0x29>
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d63 <gsl_vector_int_sub+0x22>
mov    $0x13,%eax
jmp    1dbd <gsl_vector_int_sub+0x7c>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     1db1 <gsl_vector_int_sub+0x70>
shl    $0x2,%rbx
shl    $0x2,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
mov    (%r9,%rcx,1),%r9d
sub    %r9d,(%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    1d8e <gsl_vector_int_sub+0x4d>
jmp    1db8 <gsl_vector_int_sub+0x77>
mov    $0x0,%eax
jmp    1dbd <gsl_vector_int_sub+0x7c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_int_sub (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 13
27 13
28 13
29 13
30 13
31 13
32 17
33 17
34 17
35 19
36 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xe8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_remove (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x28,%rsp
add    $0x28,%rdi
mov    0x40(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x0(%rip),%rsi        # 14c <nettle_ccm_aes128_decrypt_message+0x3d>
callq  151 <nettle_ccm_aes128_decrypt_message+0x42>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,
      size_t nlength, const uint8_t *nonce,
      size_t alength, const uint8_t *adata,
      size_t tlength,
      size_t mlength, uint8_t *dst, const uint8_t *src)
{
  return nettle_ccm_decrypt_message(&ctx->cipher,
        (nettle_cipher_func *) nettle_aes128_encrypt,
        nlength, nonce, alength, adata,
        tlength, mlength, dst, src);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 11
17 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  67 <compare_path+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
compare_path(const void *s1, const void *s2)
{
 return strcmp(*(char **)s1, *(char **)s2);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x8,%esi
callq  59 <gsl_permutation_fwrite+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     7e <gsl_permutation_fwrite+0x3d>
mov    $0x5,%ecx
mov    $0x37,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  79 <gsl_permutation_fwrite+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_permutation_fwrite (FILE * stream, const gsl_permutation * p)
{
  size_t n = p->size ;
  size_t * data = p->data ;
  size_t items = fwrite (data, sizeof (size_t), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "file.c", 55, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
mov    (%rdi),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
retq   
<<<sep_in_sample>>>
strob_strlen(STROB * strb)
{
 return strlen((char*)(strb->str_));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     8c <mu_envelope_destroy+0x4b>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     8c <mu_envelope_destroy+0x4b>
cmp    %rsi,0x0(%rbp)
jne    85 <mu_envelope_destroy+0x44>
mov    0x18(%rbp),%rax
test   %rax,%rax
je     6b <mu_envelope_destroy+0x2a>
mov    %rbp,%rdi
callq  *%rax
mov    0x8(%rbp),%rdi
callq  74 <mu_envelope_destroy+0x33>
mov    0x10(%rbp),%rdi
callq  7d <mu_envelope_destroy+0x3c>
mov    %rbp,%rdi
callq  85 <mu_envelope_destroy+0x44>
movq   $0x0,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_envelope_destroy (mu_envelope_t *penvelope, void *owner)
{
  if (penvelope && *penvelope)
    {
      mu_envelope_t envelope = *penvelope;
      if (envelope->owner == owner)
 {
   if (envelope->_destroy)
     envelope->_destroy (envelope);
   free (envelope->date);
   free (envelope->sender);
   free (envelope);
 }
      *penvelope = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 8
13 8
14 8
15 9
16 9
17 10
18 10
19 11
20 11
21 12
22 12
23 14
24 16
25 16
26 16
27 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
subsd  0x0(%rip),%xmm0        # 12c <lngamma_lanczos+0x10>
movsd  %xmm0,0x8(%rsp)
mov    $0x0,%edx
movsd  0x0(%rip),%xmm5        # 13f <lngamma_lanczos+0x23>
movsd  %xmm5,(%rsp)
mov    $0x1,%eax
cvtsi2sd %eax,%xmm1
addsd  0x8(%rsp),%xmm1
movsd  (%rdx),%xmm0
divsd  %xmm1,%xmm0
addsd  (%rsp),%xmm0
movsd  %xmm0,(%rsp)
add    $0x1,%eax
add    $0x8,%rdx
cmp    $0x9,%eax
jne    149 <lngamma_lanczos+0x2d>
movsd  0x8(%rsp),%xmm0
addsd  0x0(%rip),%xmm0        # 17f <lngamma_lanczos+0x63>
divsd  0x0(%rip),%xmm0        # 187 <lngamma_lanczos+0x6b>
callq  18c <lngamma_lanczos+0x70>
movsd  0x8(%rsp),%xmm1
addsd  0x0(%rip),%xmm1        # 19a <lngamma_lanczos+0x7e>
mulsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
movsd  (%rsp),%xmm0
callq  1ae <lngamma_lanczos+0x92>
addsd  0x0(%rip),%xmm0        # 1b6 <lngamma_lanczos+0x9a>
movsd  0x0(%rip),%xmm3        # 1be <lngamma_lanczos+0xa2>
movapd %xmm0,%xmm2
subsd  %xmm3,%xmm2
movsd  0x8(%rsp),%xmm4
addsd  %xmm4,%xmm2
movsd  %xmm2,(%rbx)
movsd  0x0(%rip),%xmm1        # 1dc <lngamma_lanczos+0xc0>
andpd  %xmm1,%xmm4
andpd  %xmm1,%xmm0
addsd  %xmm4,%xmm0
addsd  %xmm0,%xmm3
mulsd  0x0(%rip),%xmm3        # 1f4 <lngamma_lanczos+0xd8>
andpd  %xmm2,%xmm1
mulsd  0x0(%rip),%xmm1        # 200 <lngamma_lanczos+0xe4>
addsd  %xmm1,%xmm3
movsd  %xmm3,0x8(%rbx)
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
lngamma_lanczos(double x, gsl_sf_result * result)
{
  int k;
  double Ag;
  double term1, term2;
  x -= 1.0;
  Ag = lanczos_7_c[0];
  for(k=1; k<=8; k++) { Ag += lanczos_7_c[k]/(x+k); }
  term1 = (x+0.5)*log((x+7.5)/2.7182818284590452354);
  term2 = 0.9189385332046727418 + log(Ag);
  result->val = term1 + (term2 - 7.0);
  result->err = 2.0 * 2.2204460492503131e-16 * (fabs(term1) + fabs(term2) + 7.0);
  result->err += 2.2204460492503131e-16 * fabs(result->val);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 6
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 11
37 12
38 12
39 12
40 12
41 12
42 12
43 13
44 13
45 13
46 13
47 15
48 15
49 15
50 15
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdx
mov    0x8(%rsi),%rdi
lea    (%rdi,%rdi,1),%rcx
mov    (%rsi),%rsi
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_real (gsl_vector_complex_long_double * v)
{
  gsl_vector_long_double s = {0, 0, 0, 0, 0};
  s.data = v->data;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 14
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
mov    0x8(%rsi),%rdx
mov    $0xffffffff,%eax
cmp    %rdx,%rcx
jb     4d <directory_contents_hash_cmp+0x36>
cmp    %rdx,%rcx
setne  %al
movzbl %al,%eax
jne    4d <directory_contents_hash_cmp+0x36>
mov    (%rdi),%rcx
mov    (%rsi),%rdx
mov    $0xffffffff,%eax
cmp    %rdx,%rcx
jb     4d <directory_contents_hash_cmp+0x36>
cmp    %rdx,%rcx
setne  %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
directory_contents_hash_cmp (const void *xv, const void *yv)
{
  const struct directory_contents *x = xv;
  const struct directory_contents *y = yv;
  int result;
  result = ((x->ino)<(y->ino)?-1:((x->ino)==(y->ino)?0:1));
  if (result)
    return result;
  return ((x->dev)<(y->dev)?-1:((x->dev)==(y->dev)?0:1));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
callq  e8c6 <gsl_fft_halfcomplex_float_radix2_inverse+0x12>
test   %eax,%eax
jne    e92e <gsl_fft_halfcomplex_float_radix2_inverse+0x7a>
test   %rbx,%rbx
js     e8d6 <gsl_fft_halfcomplex_float_radix2_inverse+0x22>
cvtsi2sd %rbx,%xmm0
jmp    e8ee <gsl_fft_halfcomplex_float_radix2_inverse+0x3a>
mov    %rbx,%rdx
shr    %rdx
mov    %rbx,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
movsd  0x0(%rip),%xmm1        # e8f6 <gsl_fft_halfcomplex_float_radix2_inverse+0x42>
divsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm1
test   %rbx,%rbx
je     e92e <gsl_fft_halfcomplex_float_radix2_inverse+0x7a>
lea    0x0(,%r12,4),%rsi
mov    %rbp,%rdi
mov    $0x0,%ecx
movaps %xmm1,%xmm0
mulss  (%rdi),%xmm0
movss  %xmm0,(%rdi)
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    e917 <gsl_fft_halfcomplex_float_radix2_inverse+0x63>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_fft_halfcomplex_float_radix2_inverse (float data[],
                                              const size_t stride,
                                              const size_t n)
{
  int status = gsl_fft_halfcomplex_float_radix2_transform (data, stride, n);
  if (status)
    {
      return status;
    }
  {
    const float norm = 1.0 / n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        data[stride*i] *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 13
26 13
27 15
28 15
29 13
30 15
31 15
32 15
33 13
34 13
35 13
36 13
37 19
38 19
39 19
40 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  1c22 <gsl_stats_char_variance+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1c30 <gsl_stats_char_variance+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_char_variance (const char data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_char_mean (data, stride, n);
  return gsl_stats_char_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
bilinear_init(void * state, const double xa[], const double ya[],
              const double za[], size_t xsize, size_t ysize)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
mov    $0x1003,%eax
test   %rdi,%rdi
je     51d <mu_mailbox_message_unseen+0x28>
mov    0x90(%rdi),%rdx
test   %rdx,%rdx
je     51d <mu_mailbox_message_unseen+0x28>
mov    $0x33,%al
testb  $0x8,0x31(%rdi)
jne    51d <mu_mailbox_message_unseen+0x28>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailbox_message_unseen (mu_mailbox_t mbox, size_t *num)
{
  if (mbox == ((void *)0) || mbox->_message_unseen == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_message_unseen (mbox, num);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 6
8 5
9 5
10 2
11 7
12 8
13 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
mov    %rsi,0x98(%rdi)
retq   
<<<sep_in_sample>>>
topsf_set_mtime(TOPSF * topsf, time_t tm)
{
 topsf->mtimeM = tm;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    (%rsi),%rdx
lea    0x48(%rdx),%rdi
mov    %rax,%rsi
callq  7c <mbx_destroy+0x16>
mov    %rbx,%rdi
callq  84 <mbx_destroy+0x1e>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mbx_destroy (mu_iterator_t iterator, void *data)
{
  struct mailbox_iterator *itr = data;
  mu_iterator_detach (&itr->mbx->iterator, iterator);
  free (data);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%esi
mov    $0x20,%ecx
mov    $0x0,%eax
mov    %rsi,%rdi
rep stos %rax,%es:(%rdi)
test   %rdx,%rdx
je     2483 <set_filename_bstab+0x3c>
movzbl (%rdx),%eax
test   %al,%al
je     2483 <set_filename_bstab+0x3c>
movsbq %al,%rax
movb   $0x1,0x0(%rax)
add    $0x1,%rdx
je     2483 <set_filename_bstab+0x3c>
movzbl (%rdx),%eax
test   %al,%al
jne    246b <set_filename_bstab+0x24>
repz retq 
<<<sep_in_sample>>>
set_filename_bstab (string)
     const char *string;
{
  const char *s;
  memset (filename_bstab, 0, sizeof (filename_bstab));
  for (s = string; s && *s; s++)
    filename_bstab[*s] = 1;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 6
15 6
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdx),%rdx
cmp    $0x5,%rdx
ja     5346 <_jit_putargr_f+0x28>
movslq %esi,%rcx
mov    $0x1f,%eax
sub    %rdx,%rax
mov    %rax,%rdx
mov    $0xdc,%esi
callq  5344 <_jit_putargr_f+0x26>
jmp    5358 <_jit_putargr_f+0x3a>
movslq %esi,%r8
mov    $0xf,%ecx
mov    $0xe5,%esi
callq  5358 <_jit_putargr_f+0x3a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_jit_putargr_f(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_movr_f,_XMM0 - v->u.w,u);
    else
 _jit_new_node_www(_jit,jit_code_stxi_f,v->u.w,_RBP,u);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %edx,%ebp
mov    %rcx,%r13
mov    %r8d,%r12d
callq  141d <findEntry>
mov    %rax,%rbx
test   %rax,%rax
je     3372 <headerAppendEntry+0x80>
cmp    $0x6,%ebp
je     3372 <headerAppendEntry+0x80>
cmp    $0x9,%ebp
je     3372 <headerAppendEntry+0x80>
mov    $0x0,%ecx
mov    %r12d,%edx
mov    %r13,%rsi
mov    %ebp,%edi
callq  219 <dataLength>
mov    %eax,%r14d
mov    %eax,%esi
add    0x18(%rbx),%esi
movslq %esi,%rsi
mov    0x10(%rbx),%rdi
callq  333f <headerAppendEntry+0x4d>
mov    %rax,%rsi
test   %rax,%rax
jne    334f <headerAppendEntry+0x5d>
callq  334c <headerAppendEntry+0x5a>
mov    %rax,%rsi
mov    %rsi,0x10(%rbx)
movslq 0x18(%rbx),%rax
add    %rax,%rsi
mov    %r14d,%r8d
mov    %r12d,%ecx
mov    %r13,%rdx
mov    %ebp,%edi
callq  19f <copyData>
add    %r14d,0x18(%rbx)
add    %r12d,0xc(%rbx)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
headerAppendEntry(Header h, int_32 tag, int_32 type, void * p, int_32 c)
{
    struct indexEntry *entry;
    int length;
    entry = findEntry(h, tag, type);
    if (!entry) {
 return 0;
    }
    if (type == 6 || type == 9) {
 return 0;
    }
    length = dataLength(type, p, c, 0);
    entry->data = (realloc((entry->data), (entry->length + length)) ? : vmefail());
    copyData(type, ((char *) entry->data) + entry->length, p, c, length);
    entry->length += length;
    entry->info.count += c;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 6
12 6
13 9
14 9
15 9
16 9
17 12
18 12
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 15
42 16
43 18
44 18
45 18
46 18
47 18
48 18
49 18
<<<sep_out_sample>>>
push   %rbx
callq  1ec <pop+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    20f <pop+0x29>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x2,%edi
mov    $0x0,%eax
callq  20d <pop+0x27>
jmp    217 <pop+0x31>
mov    %rax,%rdi
callq  217 <pop+0x31>
mov    %rbx,%rdi
callq  21f <pop+0x39>
pop    %rbx
retq   
<<<sep_in_sample>>>
pop(void *object, int argc, char **argv)
{
    dico_list_t list = object;
    char *p = dico_list_pop(list);
    if (!p)
 dico_log(2, 0, "nothing to pop");
    else
 printf("%s\n", p);
    free(p);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 9
15 9
16 10
17 10
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
<<<sep_in_sample>>>
ping_set_count (PING * ping, size_t count)
{
  ping->ping_count = count;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %rdi,%rax
movsd  0x18(%rdi),%xmm0
addsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x18(%rdi)
movsd  0x38(%rdi),%xmm0
addsd  0x10(%rsp),%xmm0
movsd  %xmm0,0x38(%rdi)
movsd  0x58(%rdi),%xmm0
addsd  0x18(%rsp),%xmm0
movsd  %xmm0,0x58(%rdi)
retq   
<<<sep_in_sample>>>
VTranslatePoint(VMatrix * Mt, VPoint loc)
{
 Mt->m[0][3] += loc.x;
 Mt->m[1][3] += loc.y;
 Mt->m[2][3] += loc.z;
 return Mt;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 7
<<<sep_out_sample>>>
movsd  (%rdi),%xmm1
movsd  (%rsi),%xmm0
ucomisd %xmm1,%xmm0
ja     130 <compare_double+0x19>
ucomisd %xmm0,%xmm1
seta   %al
movzbl %al,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
compare_double(const void *ap, const void *bp)
{
  double a = *(const double *) ap;
  double b = *(const double *) bp;
  if (a < b)
    return -1;
  else if (a > b)
    return 1;
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 7
8 7
9 6
10 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <gsl_rstat_quantile_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_rstat_quantile_free(gsl_rstat_quantile_workspace *w)
{
  free(w);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    (%rdi),%rdi
callq  1078 <gtags_delete+0x23>
test   %rax,%rax
je     10ad <gtags_delete+0x58>
mov    %rax,%rdi
callq  1085 <gtags_delete+0x30>
mov    %eax,%esi
mov    %rbp,%rdi
callq  108f <gtags_delete+0x3a>
test   %eax,%eax
je     10a0 <gtags_delete+0x4b>
mov    $0x0,%esi
mov    (%rbx),%rdi
callq  10a0 <gtags_delete+0x4b>
mov    (%rbx),%rdi
callq  10a8 <gtags_delete+0x53>
test   %rax,%rax
jne    107d <gtags_delete+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gtags_delete(GTOP *gtop, IDSET *deleteset)
{
 const char *tagline;
 int fid;
 long id;
 for (tagline = dbop_first(gtop->dbop, ((void *)0), ((void *)0), 0); tagline; tagline = dbop_next(gtop->dbop)) {
  fid = atoi(tagline);
  if (idset_contains(deleteset, fid))
   dbop_delete(gtop->dbop, ((void *)0));
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 6
24 6
25 6
26 6
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
testb  $0x3,0x8(%rdi)
jne    5e1 <check_identifier+0x1f>
mov    %esi,%r12d
mov    (%rdi),%rbp
mov    %rbp,%rdi
callq  5dd <check_identifier+0x1b>
test   %eax,%eax
je     605 <check_identifier+0x43>
mov    (%rbx),%rbx
mov    $0x0,%edi
callq  5ee <check_identifier+0x2c>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  5fe <check_identifier+0x3c>
mov    $0x0,%ebx
jmp    63e <check_identifier+0x7c>
mov    $0x1,%ebx
test   %r12d,%r12d
je     63e <check_identifier+0x7c>
mov    %rbp,%rdi
callq  617 <check_identifier+0x55>
mov    %eax,%ebx
test   %eax,%eax
jne    639 <check_identifier+0x77>
mov    $0x0,%edi
callq  627 <check_identifier+0x65>
mov    %rbp,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  637 <check_identifier+0x75>
jmp    63e <check_identifier+0x7c>
mov    $0x1,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
check_identifier (word, check_word)
     WORD_DESC *word;
     int check_word;
{
  if ((word->flags & (0x000001|0x000002)) || all_digits (word->word))
    {
      internal_error (gettext("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else if (check_word && legal_identifier (word->word) == 0)
    {
      internal_error (gettext("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else
    return (1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 16
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 12
34 12
35 12
36 13
37 16
38 17
39 17
40 17
41 17
42 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # 284b <progman_dump_prereq+0xd>
test   %rbp,%rbp
je     28b0 <progman_dump_prereq+0x72>
cmpq   $0x0,0x20(%rbp)
je     28a7 <progman_dump_prereq+0x69>
mov    0x18(%rbp),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  286a <progman_dump_prereq+0x2c>
mov    0x20(%rbp),%rax
mov    (%rax),%rsi
test   %rsi,%rsi
je     289d <progman_dump_prereq+0x5f>
mov    $0x0,%ebx
mov    $0x0,%edi
mov    $0x0,%eax
callq  288a <progman_dump_prereq+0x4c>
add    $0x1,%ebx
movslq %ebx,%rdx
mov    0x20(%rbp),%rax
mov    (%rax,%rdx,8),%rsi
test   %rsi,%rsi
jne    287b <progman_dump_prereq+0x3d>
mov    $0xa,%edi
callq  28a7 <progman_dump_prereq+0x69>
mov    0x0(%rbp),%rbp
test   %rbp,%rbp
jne    2850 <progman_dump_prereq+0x12>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
progman_dump_prereq ()
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (prog->prereq)
      {
 int i;
 printf ("%s:", prog->tag);
 for (i = 0; prog->prereq[i]; i++)
   printf (" %s", prog->prereq[i]);
 printf ("\n");
      }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 9
22 9
23 9
24 9
25 9
26 9
27 11
28 11
29 4
30 4
31 4
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %edi,%ebp
mov    %rsi,%r12
lea    0x1(%rdi),%edi
movslq %edi,%rdi
shl    $0x3,%rdi
callq  7b <dappprun+0x1c>
mov    %rax,%rbx
test   %rax,%rax
jne    97 <dappprun+0x38>
mov    $0x0,%edi
callq  8d <dappprun+0x2e>
mov    $0x1,%edi
callq  97 <dappprun+0x38>
mov    0x0(%rip),%rax        # 9e <dappprun+0x3f>
mov    %rax,(%rbx)
cmp    $0x1,%ebp
jle    109 <dappprun+0xaa>
mov    $0x0,%r8d
mov    $0x1,%eax
mov    $0x3,%r9d
mov    $0x7,%r10d
jmp    cf <dappprun+0x70>
mov    %rdx,0x8(%rbx,%r8,1)
add    $0x1,%eax
add    $0x8,%r8
cmp    %ebp,%eax
je     10e <dappprun+0xaf>
mov    0x8(%r12,%r8,1),%rdx
mov    $0x0,%edi
mov    %rdx,%rsi
mov    %r9,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dil
setb   %sil
cmp    %sil,%dil
je     10e <dappprun+0xaf>
mov    $0x0,%edi
mov    %rdx,%rsi
mov    %r10,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    bf <dappprun+0x60>
jmp    10e <dappprun+0xaf>
mov    $0x1,%eax
cltq   
movq   $0x0,(%rbx,%rax,8)
callq  11d <dappprun+0xbe>
test   %eax,%eax
jne    159 <dappprun+0xfa>
mov    0x0(%rip),%rcx        # 128 <dappprun+0xc9>
mov    $0x11,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  13c <dappprun+0xdd>
mov    %rbx,%rsi
mov    (%rbx),%rdi
callq  147 <dappprun+0xe8>
mov    (%rbx),%rdi
callq  14f <dappprun+0xf0>
mov    $0x1,%edi
callq  159 <dappprun+0xfa>
cmp    $0xffffffff,%eax
jne    172 <dappprun+0x113>
mov    $0x0,%edi
callq  168 <dappprun+0x109>
mov    $0x1,%edi
callq  172 <dappprun+0x113>
mov    $0x0,%edx
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  183 <dappprun+0x124>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dappprun(int argc, char **argv)
{
  char **arg;
  int a;
  int status;
  pid_t pid;
  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))
    {
      perror("dap");
      exit(1);
    }
  arg[0] = dappp;
  for (a = 1; a < argc && strcmp(argv[a], "-a") && strcmp(argv[a], "--args"); a++)
    arg[a] = argv[a];
  arg[a] = ((void *)0);
  if (!(pid = fork()))
    {
      fputs("Preprocessing...\n", stderr);
      execv(arg[0], arg);
      perror(arg[0]);
      exit(1);
    }
  else if (pid == -1)
    {
      perror("dap");
      exit(1);
    }
  waitpid(pid, &status, 0);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 12
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 15
52 15
53 16
54 16
55 16
56 18
57 18
58 18
59 18
60 18
61 19
62 19
63 19
64 20
65 20
66 21
67 21
68 23
69 23
70 25
71 25
72 26
73 26
74 28
75 28
76 28
77 28
78 30
79 30
80 30
81 30
82 30
83 30
<<<sep_out_sample>>>
lea    0x1(%rsi),%rdx
jmp    478 <linecpy+0x15>
test   %rdi,%rdi
je     474 <linecpy+0x11>
mov    %cl,(%rdi)
lea    0x1(%rdi),%rdi
add    $0x1,%rdx
lea    -0x1(%rdx),%rax
movzbl -0x1(%rdx),%ecx
cmp    $0xa,%cl
je     489 <linecpy+0x26>
test   %cl,%cl
jne    469 <linecpy+0x6>
test   %rdi,%rdi
je     491 <linecpy+0x2e>
movb   $0x0,(%rdi)
sub    %rsi,%rax
retq   
<<<sep_in_sample>>>
linecpy(char *l1, char *l2)
{
  char *start;
  start = l2;
  while (*l2 && *l2 != '\n')
    {
      if (l1)
 *l1++ = *l2++;
      else
 l2++;
    }
  if (l1)
    *l1 = '\0';
  return l2 - start;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 8
7 8
8 8
9 5
10 5
11 5
12 5
13 5
14 12
15 12
16 13
17 14
18 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  e <gsl_interp_accel_alloc+0xe>
test   %rax,%rax
jne    33 <gsl_interp_accel_alloc+0x33>
mov    $0x8,%ecx
mov    $0x21,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c <gsl_interp_accel_alloc+0x2c>
mov    $0x0,%eax
jmp    4a <gsl_interp_accel_alloc+0x4a>
movq   $0x0,(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_interp_accel_alloc (void)
{
  gsl_interp_accel *a = (gsl_interp_accel *) malloc (sizeof (gsl_interp_accel));
  if (a == 0)
    {
      do { gsl_error ("could not allocate space for gsl_interp_accel", "accel.c", 33, GSL_ENOMEM) ; return 0 ; } while (0);
    }
  a->cache = 0;
  a->hit_count = 0;
  a->miss_count = 0;
  return a;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 9
15 10
16 12
17 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%eax
lea    0x1(%rax),%esi
movslq %esi,%rsi
shl    $0x3,%rsi
mov    0x10(%rdi),%rdi
callq  *0x0(%rip)        # 1a <__gmpf_clear+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmpf_clear (mpf_ptr x)
{
  (*__gmp_free_func) (((x)->_mp_d), (((x)->_mp_prec) + 1) * sizeof (mp_limb_t));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
mov    %rdx,%rsi
shr    $0x3,%rsi
mov    %esi,%ecx
test   %esi,%esi
jle    55 <masklen_to_netmask+0x55>
mov    $0x0,%eax
movb   $0xff,(%rdi,%rax,1)
add    $0x1,%rax
cmp    %eax,%ecx
jg     12 <masklen_to_netmask+0x12>
cmp    $0x10,%esi
je     71 <masklen_to_netmask+0x71>
and    $0x7,%edx
mov    $0x8,%ecx
sub    %edx,%ecx
lea    0x1(%rsi),%eax
movslq %esi,%rsi
mov    $0xff,%edx
sar    %cl,%edx
shl    %cl,%edx
mov    %dl,(%rdi,%rsi,1)
cmp    $0xf,%eax
jg     71 <masklen_to_netmask+0x71>
movslq %eax,%rdx
movb   $0x0,(%rdi,%rdx,1)
add    $0x1,%eax
cmp    $0x10,%eax
jne    44 <masklen_to_netmask+0x44>
repz retq 
and    $0x7,%edx
mov    $0x8,%ecx
sub    %edx,%ecx
mov    $0xff,%eax
sar    %cl,%eax
shl    %cl,%eax
mov    %al,(%rdi)
mov    $0x1,%eax
jmp    44 <masklen_to_netmask+0x44>
repz retq 
<<<sep_in_sample>>>
masklen_to_netmask(unsigned char *buf, size_t len, size_t masklen)
{
 int i, cnt;
 cnt = masklen / 8;
 for (i = 0; i < cnt; i++)
  buf[i] = 0xff;
 if (i == 16)
  return;
 cnt = 8 - masklen % 8;
 buf[i++] = (0xff >> cnt) << cnt;
 for (; i < 16; i++)
  buf[i] = 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 5
10 5
11 7
12 7
13 9
14 9
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 12
26 11
27 11
28 11
29 11
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdi,0x0(%rip)        # 447 <prepare_record_buffer+0xb>
jae    466 <prepare_record_buffer+0x2a>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 453 <prepare_record_buffer+0x17>
callq  458 <prepare_record_buffer+0x1c>
mov    %rax,0x0(%rip)        # 45f <prepare_record_buffer+0x23>
mov    %rbx,0x0(%rip)        # 466 <prepare_record_buffer+0x2a>
pop    %rbx
retq   
<<<sep_in_sample>>>
prepare_record_buffer (size_t size)
{
  if (size > record_buffer_size)
    {
      record_buffer_ptr = xrealloc (record_buffer_ptr, size);
      record_buffer_size = size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 6
10 8
11 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     32d <parseopts+0x130>
mov    %rsi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
movslq 0x0(%rip),%rax        # 22c <parseopts+0x2f>
cmp    %rax,%rdx
jbe    28b <parseopts+0x8e>
mov    0x0(%rip),%rdi        # 238 <parseopts+0x3b>
test   %rdi,%rdi
je     242 <parseopts+0x45>
callq  242 <parseopts+0x45>
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
mov    %eax,0x0(%rip)        # 260 <parseopts+0x63>
add    $0x1,%eax
movslq %eax,%rdi
callq  26b <parseopts+0x6e>
mov    %rax,0x0(%rip)        # 272 <parseopts+0x75>
test   %rax,%rax
jne    28b <parseopts+0x8e>
mov    $0x0,%edi
callq  281 <parseopts+0x84>
mov    $0x1,%edi
callq  28b <parseopts+0x8e>
mov    0x0(%rip),%rbx        # 292 <parseopts+0x95>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  29d <parseopts+0xa0>
cmpb   $0x20,(%rbx)
jne    2b5 <parseopts+0xb8>
mov    $0x0,%edx
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rbx,%rax,1)
je     2a7 <parseopts+0xaa>
jmp    2ba <parseopts+0xbd>
mov    $0x0,%edx
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
je     334 <parseopts+0x137>
mov    $0x0,%eax
test   %rbp,%rbp
je     2d7 <parseopts+0xda>
movslq %eax,%rsi
mov    %rcx,0x0(%rbp,%rsi,8)
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
je     2f8 <parseopts+0xfb>
add    $0x1,%edx
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
jne    2e6 <parseopts+0xe9>
test   %cl,%cl
je     31d <parseopts+0x120>
test   %rbp,%rbp
je     305 <parseopts+0x108>
movb   $0x0,(%r8)
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
jne    31d <parseopts+0x120>
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
je     311 <parseopts+0x114>
add    $0x1,%eax
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
jne    2ca <parseopts+0xcd>
jmp    339 <parseopts+0x13c>
mov    $0x0,%eax
jmp    339 <parseopts+0x13c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parseopts(char *opts, char **arg)
{
  static char *optcpy = ((void *)0);
  static int optlen = 0;
  int i;
  int a;
  if (!opts)
    return 0;
  if (strlen(opts) > optlen)
    {
      if (optcpy)
 free(optcpy);
      optlen = strlen(opts);
      if (!(optcpy = malloc(optlen + 1)))
 {
   perror("dap");
   exit(1);
 }
    }
  strcpy(optcpy, opts);
  for (i = 0; optcpy[i] == ' '; i++)
    ;
  for (a = 0; optcpy[i]; a++)
    {
      if (arg)
 arg[a] = optcpy + i;
      while (optcpy[i] && optcpy[i] != ' ')
 i++;
      if (optcpy[i])
 {
   if (arg)
     optcpy[i] = '\0';
   for (i++; optcpy[i] == ' '; i++)
     ;
 }
    }
  return a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 17
36 17
37 20
38 20
39 20
40 20
41 21
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 21
50 23
51 23
52 23
53 23
54 23
55 25
56 25
57 26
58 26
59 27
60 27
61 27
62 27
63 27
64 28
65 27
66 27
67 27
68 27
69 27
70 29
71 29
72 31
73 31
74 32
75 33
76 33
77 33
78 33
79 33
80 33
81 33
82 33
83 23
84 23
85 23
86 23
87 23
88 23
89 8
90 8
91 23
92 38
93 38
94 38
95 38
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  16b4 <gsl_sf_zetam1_int+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     16d8 <gsl_sf_zetam1_int+0x30>
mov    %eax,%ecx
mov    $0x40f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16d3 <gsl_sf_zetam1_int+0x2b>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_zetam1_int(const int s)
{
  gsl_sf_result result; int status = gsl_sf_zetam1_int_e(s, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_zetam1_int_e(s, &result)", "zeta.c", 1039, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rcx
mov    %rdx,%r8
lea    0x28(%rdi),%rsi
mov    0x0(%rip),%rdx        # 55 <nettle_ccm_aes128_update+0x15>
callq  5a <nettle_ccm_aes128_update+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes128_update(struct ccm_aes128_ctx *ctx,
    size_t length, const uint8_t *data)
{
  nettle_ccm_update(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) nettle_aes128_encrypt,
      length, data);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rax
mov    0x38(%rsi),%rcx
mov    0x28(%rsi),%rsi
mov    0x20(%rax),%rdi
lea    0x8(%rsp),%rdx
callq  402 <normal_rcond+0x22>
mov    %eax,%ebx
test   %eax,%eax
jne    424 <normal_rcond+0x44>
sqrtsd 0x8(%rsp),%xmm0
ucomisd %xmm0,%xmm0
jnp    41f <normal_rcond+0x3f>
movsd  0x8(%rsp),%xmm0
callq  41f <normal_rcond+0x3f>
movsd  %xmm0,0x0(%rbp)
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
normal_rcond(double * rcond, void * vstate)
{
  normal_state_t *state = (normal_state_t *) vstate;
  int status = GSL_SUCCESS;
  double rcond_ATA;
  status = gsl_linalg_pcholesky_rcond(state->work_ATA, state->perm, &rcond_ATA, state->work3p);
  if (status == GSL_SUCCESS)
    *rcond = sqrt(rcond_ATA);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
movsbl %dil,%eax
not    %eax
shr    $0x1f,%eax
retq   
<<<sep_in_sample>>>
mu_parse822_is_char (char c)
{
  return (((unsigned)c) < 128);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     188 <grecs_list_add+0x4e>
mov    0x8(%rdi),%rdx
mov    %rdx,0x8(%rax)
mov    0x8(%rdi),%rax
test   %rax,%rax
je     15b <grecs_list_add+0x21>
mov    (%rsi),%rdx
mov    %rdx,(%rax)
jmp    161 <grecs_list_add+0x27>
mov    (%rsi),%rax
mov    %rax,(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x8(%rdi)
mov    0x10(%rsi),%rax
add    %rax,0x10(%rdi)
movq   $0x0,0x8(%rsi)
movq   $0x0,(%rsi)
movq   $0x0,0x10(%rsi)
repz retq 
<<<sep_in_sample>>>
grecs_list_add(struct grecs_list *dst, struct grecs_list *src)
{
 if (!src->head)
  return;
 src->head->prev = dst->tail;
 if (dst->tail)
  dst->tail->next = src->head;
 else
  dst->head = src->head;
 dst->tail = src->tail;
 dst->count += src->count;
 src->head = src->tail = ((void *)0);
 src->count = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 9
13 9
14 10
15 10
16 11
17 11
18 12
19 12
20 13
21 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%r8
cmp    %r8,0x8(%rdi)
cmovbe 0x8(%rdi),%r8
test   %r8,%r8
je     28af <gsl_matrix_long_add_diagonal+0x4b>
lea    0x8(,%rax,8),%r9
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdq (%rcx),%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%rsi
mov    %rsi,(%rcx)
add    $0x1,%rax
add    %r9,%rdx
cmp    %r8,%rax
jne    288b <gsl_matrix_long_add_diagonal+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_long_add_diagonal (gsl_matrix_long * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 8
6 8
7 10
8 10
9 8
10 10
11 10
12 10
13 10
14 10
15 10
16 8
17 8
18 8
19 8
20 13
21 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # ffa <pch_newfirst+0x7>
retq   
<<<sep_in_sample>>>
pch_newfirst (void)
{
    return p_newfirst;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
mov    $0x0,%eax
callq  592 <print_dst_unreach+0x13>
movzbl 0x1(%rbx),%esi
mov    $0x0,%eax
cmp    %esi,0x0(%rip)        # 5a1 <print_dst_unreach+0x22>
jne    5c2 <print_dst_unreach+0x43>
jmp    5b2 <print_dst_unreach+0x33>
cmp    %esi,(%rax)
jne    5c2 <print_dst_unreach+0x43>
nopl   0x0(%rax)
jmp    5b7 <print_dst_unreach+0x38>
mov    $0x0,%eax
mov    0x8(%rax),%rdi
callq  5c0 <print_dst_unreach+0x41>
jmp    5dd <print_dst_unreach+0x5e>
add    $0x10,%rax
cmp    $0x0,%rax
jb     5a5 <print_dst_unreach+0x26>
mov    $0x0,%edi
mov    $0x0,%eax
callq  5dd <print_dst_unreach+0x5e>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_dst_unreach (struct icmp6_hdr *icmp6)
{
  struct icmp_code_descr *p;
  printf ("Destination unreachable: ");
  for (p = icmp_dest_unreach_desc;
       p < icmp_dest_unreach_desc + sizeof(icmp_dest_unreach_desc)/sizeof((icmp_dest_unreach_desc)[0]); p++)
    {
      if (p->code == icmp6->icmp6_code)
 {
   puts (p->diag);
   return;
 }
    }
  printf ("Unknown code %d\n", icmp6->icmp6_code);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 8
7 5
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 5
16 10
17 10
18 11
19 6
20 5
21 5
22 14
23 14
24 14
25 15
26 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  48 <node_ident_cmp+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
node_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)
{
 return strcmp(a->ident, b->ident);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
test   %rsi,%rsi
je     57d <api_sym_lookup_scalar+0x37>
mov    %edx,%r12d
mov    %rcx,%rbp
test   %rcx,%rcx
je     57d <api_sym_lookup_scalar+0x37>
mov    $0x0,%eax
cmpl   $0x4,0x40(%rsi)
jne    582 <api_sym_lookup_scalar+0x3c>
callq  56d <api_sym_lookup_scalar+0x27>
mov    %r12d,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  6c <node_to_awk_value>
jmp    582 <api_sym_lookup_scalar+0x3c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
api_sym_lookup_scalar(awk_ext_id_t id,
   awk_scalar_t cookie,
   awk_valtype_t wanted,
   awk_value_t *result)
{
 NODE *node = (NODE *) cookie;
 if (node == ((void *)0)
     || result == ((void *)0)
     || node->type != Node_var)
  return awk_false;
 update_global_values();
 return node_to_awk_value(node, result, wanted);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 10
12 9
13 9
14 11
15 12
16 12
17 12
18 12
19 12
20 10
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     c15 <gsl_vector_complex_float_set_zero+0x31>
shl    $0x3,%rsi
mov    $0x0,%edx
xorps  %xmm0,%xmm0
movss  %xmm0,(%rax)
movss  %xmm0,0x4(%rax)
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
jne    c00 <gsl_vector_complex_float_set_zero+0x1c>
repz retq 
<<<sep_in_sample>>>
gsl_vector_complex_float_set_zero (gsl_vector_complex_float * v)
{
  float * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const gsl_complex_float zero = {{0.0F,0.0F}} ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(gsl_complex_float *) (data + 2 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 8
6 10
7 8
8 10
9 10
10 10
11 8
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
sub    $0xb,%esi
cmp    $0x1,%esi
setbe  %al
movzbl %al,%eax
lea    0x20(%rdi),%rsi
mov    $0x4,%r8d
mov    %edx,%ecx
mov    %eax,%edx
callq  4ca <__osip_nict_need_timer_f_event+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__osip_nict_need_timer_f_event (osip_nict_t * nict, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (nict, &nict->timer_f_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_F);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x0(%rip)        # 10c7 <dir_history_reset+0x9>
je     110c <dir_history_reset+0x4e>
cmpl   $0x0,0x0(%rip)        # 10d0 <dir_history_reset+0x12>
jle    10f5 <dir_history_reset+0x37>
mov    $0x0,%ebx
movslq %ebx,%rdx
mov    0x0(%rip),%rax        # 10e1 <dir_history_reset+0x23>
mov    (%rax,%rdx,8),%rdi
callq  10ea <dir_history_reset+0x2c>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # 10f3 <dir_history_reset+0x35>
jg     10d7 <dir_history_reset+0x19>
mov    0x0(%rip),%rdi        # 10fc <dir_history_reset+0x3e>
callq  1101 <dir_history_reset+0x43>
movq   $0x0,0x0(%rip)        # 110c <dir_history_reset+0x4e>
movl   $0x0,0x0(%rip)        # 1116 <dir_history_reset+0x58>
movl   $0x0,0x0(%rip)        # 1120 <dir_history_reset+0x62>
pop    %rbx
retq   
<<<sep_in_sample>>>
dir_history_reset()
{
    if (dir_history)
    {
 int i;
 for (i = 0; i < dir_history_count; i++)
     xfree(dir_history[i]);
 xfree(dir_history);
 dir_history = ((void *)0);
    }
    dir_history_count = 0;
    dir_history_point = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 6
12 6
13 6
14 8
15 8
16 9
17 11
18 12
19 13
20 13
<<<sep_out_sample>>>
mov    %rdi,%r8
mov    $0x0,%al
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    $0x0,%eax
cmp    $0xfffffffffffffff6,%rcx
jne    c6d <is_dos_date+0x42>
mov    0x2(%r8),%sil
cmp    0x5(%r8),%sil
jne    c6d <is_dos_date+0x42>
sub    $0x8,%rsp
movsbl %sil,%esi
mov    $0x0,%edi
callq  c60 <is_dos_date+0x35>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
is_dos_date(char *str)
{
    if (strlen(str) == 8 && str[2] == str[5] && strchr("\\-/", (int)str[2]) != ((void *)0))
 return (1);
    return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 3
7 3
8 3
9 3
10 3
11 2
12 3
13 3
14 3
15 3
16 3
17 3
18 6
19 6
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
retq   
<<<sep_in_sample>>>
window_y(window)
    window_t *window;
{
    return window->y;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rec_encrypt_record (rec_rset_t rset,
                    rec_record_t record,
                    const char *password)
{
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %dil,0xf(%rsp)
mov    $0x1,%edx
lea    0xf(%rsp),%rsi
mov    0x0(%rip),%edi        # cb1 <out_char+0x19>
callq  cb6 <out_char+0x1e>
test   %rax,%rax
jne    cc0 <out_char+0x28>
callq  c5b <out_error>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
out_char (int c)
{
  char bytes[1];
  bytes[0] = (char)c;
  if (full_write (out_fd, bytes, 1) < 1)
    out_error ();
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 8
11 8
12 8
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 1d0d <editMenu_Cut+0xb>
jne    1d18 <editMenu_Cut+0x16>
cmpl   $0x0,0x0(%rip)        # 1d16 <editMenu_Cut+0x14>
je     1d2c <editMenu_Cut+0x2a>
mov    $0x0,%eax
callq  1d22 <editMenu_Cut+0x20>
mov    $0x1,%edi
callq  1d2c <editMenu_Cut+0x2a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
editMenu_Cut()
{
  if(SELECTING || SELECTED)
  {
    editMenu_Copy();
    remove_selected_text(1);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 8
11 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  16b <revstatcmp+0x9>
neg    %eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
revstatcmp (const FTSENT *a, const FTSENT *b)
{
  return (- statcmp (a, b));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  86c <rename_file+0x9>
test   %rbx,%rbx
je     881 <rename_file+0x1e>
mov    0x8(%rbx),%rax
mov    %rax,(%rbx)
mov    0x38(%rbx),%rbx
test   %rbx,%rbx
jne    871 <rename_file+0xe>
pop    %rbx
retq   
<<<sep_in_sample>>>
rename_file (struct file *from_file, const char *to_hname)
{
  rehash_file (from_file, to_hname);
  while (from_file)
    {
      from_file->name = from_file->hname;
      from_file = from_file->prev;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 6
7 6
8 7
9 4
10 4
11 9
12 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %ecx,%r12d
cmp    %edx,%esi
jne    c5b <_sse_mulr_f+0x26>
mov    %ecx,%r8d
mov    %esi,%ecx
mov    $0x59,%edx
mov    $0xf3,%esi
callq  9d0 <_ssexr>
jmp    c91 <_sse_mulr_f+0x5c>
cmp    %ecx,%esi
jne    c75 <_sse_mulr_f+0x40>
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x59,%edx
mov    $0xf3,%esi
callq  9d0 <_ssexr>
jmp    c91 <_sse_mulr_f+0x5c>
callq  bba <_sse_movr_f>
mov    %r12d,%r8d
mov    %ebx,%ecx
mov    $0x59,%edx
mov    $0xf3,%esi
mov    %rbp,%rdi
callq  9d0 <_ssexr>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_sse_mulr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf3,0x59,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf3,0x59,r0,r1);
    else {
 _sse_movr_f(_jit,r0,r1);
 _ssexr(_jit,0xf3,0x59,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    0x50(%rsi),%rdx
mov    0x8(%rsi),%rdi
mov    %rcx,%rsi
callq  ae <qr_rcond+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
qr_rcond(double * rcond, void * vstate)
{
  int status;
  qr_state_t *state = (qr_state_t *) vstate;
  status = gsl_linalg_QRPT_rcond(state->QR, rcond, state->work3p);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 7
8 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     166c <gsl_matrix_float_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1644 <gsl_matrix_float_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    169e <gsl_matrix_float_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x2,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_float_row (gsl_matrix_float * m, const size_t i)
{
  _gsl_vector_float_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    %rcx,%r12
mov    %r8,%r13
callq  18b <_body_write+0x1b>
mov    0x18(%rax),%rdi
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  1a0 <_body_write+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_body_write (mu_stream_t stream, const char *buf, size_t n, mu_off_t off, size_t *pn)
{
  mu_body_t body = mu_stream_get_owner (stream);
  return mu_stream_write (body->fstream, buf, n, off, pn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x600(%rdi),%rdi
mov    $0x0,%esi
callq  105c <page_flush+0x15>
cmpl   $0x0,0x90(%rbx)
je     106d <page_flush+0x26>
mov    %rbx,%rdi
callq  b2d <page_end>
pop    %rbx
retq   
<<<sep_in_sample>>>
page_flush (a2ps_job * job)
{
  output_to_void (job->divertion, 0);
  if (job->virtual != 0)
    page_end (job);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
cmp    %rsi,0x30(%rdi)
ja     42f <gl_array_get_at+0xf>
sub    $0x8,%rsp
callq  42f <gl_array_get_at+0xf>
mov    0x28(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
<<<sep_in_sample>>>
gl_array_get_at (gl_list_t list, size_t position)
{
  size_t count = list->count;
  if (!(position < count))
    abort ();
  return list->elements[position];
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 6
6 6
7 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x3,%edi
callq  3c2 <rl_end_undo_group+0x1d>
subl   $0x1,0x0(%rip)        # 3c9 <rl_end_undo_group+0x24>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_end_undo_group ()
{
  rl_add_undo (UNDO_END, 0, 0, 0);
  _rl_undo_group_level--;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
linear_init (void * vstate,
             const double x_array[],
             const double y_array[],
             size_t size)
{
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 7
2 7
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1a6 <_gsasl_saml20_server_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  1a2 <_gsasl_saml20_server_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
test   %rdx,%rdx
je     614 <gsl_stats_ushort_quantile_from_sorted_data+0xb4>
sub    $0x1,%rdx
js     576 <gsl_stats_ushort_quantile_from_sorted_data+0x16>
cvtsi2sd %rdx,%xmm1
jmp    58e <gsl_stats_ushort_quantile_from_sorted_data+0x2e>
mov    %rdx,%rax
shr    %rax
mov    %rdx,%rcx
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    5ad <gsl_stats_ushort_quantile_from_sorted_data+0x4d>
add    %rsi,%rsi
imul   %rsi,%rdx
movzwl (%rdi,%rdx,1),%eax
cvtsi2sd %eax,%xmm0
retq   
test   %rax,%rax
js     5b9 <gsl_stats_ushort_quantile_from_sorted_data+0x59>
cvtsi2sd %rax,%xmm1
jmp    5d1 <gsl_stats_ushort_quantile_from_sorted_data+0x71>
mov    %rax,%rdx
shr    %rdx
mov    %rax,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
subsd  %xmm1,%xmm0
movapd %xmm0,%xmm1
add    %rsi,%rsi
movsd  0x0(%rip),%xmm0        # 5e4 <gsl_stats_ushort_quantile_from_sorted_data+0x84>
subsd  %xmm1,%xmm0
mov    %rsi,%rdx
imul   %rax,%rdx
movzwl (%rdi,%rdx,1),%edx
cvtsi2sd %edx,%xmm2
mulsd  %xmm2,%xmm0
add    $0x1,%rax
imul   %rax,%rsi
movzwl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_ushort_quantile_from_sorted_data (const unsigned short sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 12
18 12
19 14
20 14
21 14
22 14
23 14
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 18
38 18
39 18
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 18
51 18
52 11
53 21
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 293a <sshget_leng+0x6>
retq   
<<<sep_in_sample>>>
sshget_leng (void)
{
        return sshleng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rsi
lea    -0x1(%rsi),%rdx
movzbl 0x10(%rdi),%edi
movzbl %dil,%ecx
mov    $0x0,%eax
test   %ecx,%ecx
je     65 <function_table_entry_hash_1+0x65>
cmp    $0x1,%ecx
je     56 <function_table_entry_hash_1+0x56>
movzbl (%rsi),%ecx
test   %cl,%cl
je     5d <function_table_entry_hash_1+0x5d>
movzbl %dil,%edi
lea    -0x2(%rdi),%edi
add    %rsi,%rdi
mov    %rsi,%rdx
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
cmp    %rdi,%rdx
je     65 <function_table_entry_hash_1+0x65>
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    32 <function_table_entry_hash_1+0x32>
jmp    65 <function_table_entry_hash_1+0x65>
mov    $0x0,%eax
jmp    65 <function_table_entry_hash_1+0x65>
mov    %rsi,%rdx
mov    $0x0,%eax
movzbl 0x1(%rdx),%edx
add    %rdx,%rax
retq   
<<<sep_in_sample>>>
function_table_entry_hash_1 (const void *keyv)
{
  const struct function_table_entry *key = keyv;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((key->name)) - 1; int _n_ = ((key->len)); if (_n_) while (--_n_ && *++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); (_result_) += *++_key_; } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  31f <gl_array_indexof_from_to>
add    $0x1,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_array_search_from_to (gl_list_t list, size_t start_index, size_t end_index,
                         const void *elt)
{
  size_t index = gl_array_indexof_from_to (list, start_index, end_index, elt);
  return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 7 <close_dribble_file+0x7>
test   %rdi,%rdi
je     30 <close_dribble_file+0x30>
sub    $0x8,%rsp
callq  15 <close_dribble_file+0x15>
mov    0x0(%rip),%rdi        # 1c <close_dribble_file+0x1c>
callq  21 <close_dribble_file+0x21>
movq   $0x0,0x0(%rip)        # 2c <close_dribble_file+0x2c>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
close_dribble_file (void)
{
  if (info_dribble_file)
    {
      fflush (info_dribble_file);
      fclose (info_dribble_file);
      info_dribble_file = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 6
7 6
8 7
9 9
10 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
fstpt  (%rsp)
lea    0x1c(%rsp),%rdi
callq  31 <printf_frexpl+0x31>
fadd   %st(0),%st
mov    0x1c(%rsp),%edx
lea    -0x1(%rdx),%eax
mov    %eax,0x1c(%rsp)
cmp    $0xffffc002,%eax
jge    5b <printf_frexpl+0x5b>
lea    0x3ffd(%rdx),%edi
fstpt  (%rsp)
callq  53 <printf_frexpl+0x53>
movl   $0xffffc002,0x1c(%rsp)
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    0x1c(%rsp),%eax
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 15
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # ef5 <savedir_diag+0xb>
je     efe <savedir_diag+0x14>
callq  efc <savedir_diag+0x12>
jmp    f05 <savedir_diag+0x1b>
xchg   %ax,%ax
callq  f05 <savedir_diag+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
savedir_diag (char const *name)
{
  if (ignore_failed_read_option)
    savedir_warn (name);
  else
    savedir_error (name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 7
9 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
cmpq   $0x0,0x670(%rdi)
jle    59b1 <WriteMCVars+0x48>
mov    %rsi,%r12
mov    $0x0,%ebx
mov    0x678(%rbp),%rax
mov    (%rax,%rbx,8),%rax
movsd  0x10(%rax),%xmm0
mov    $0x0,%esi
mov    %r12,%rdi
mov    $0x1,%eax
callq  59a4 <WriteMCVars+0x3b>
add    $0x1,%rbx
cmp    %rbx,0x670(%rbp)
jg     5982 <WriteMCVars+0x19>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
WriteMCVars (PLEVEL plevel, PFILE pOutFile)
{
  long n;
  PMCVAR pMCVar;
  for (n = 0; n < plevel->nMCVars; n++) {
    pMCVar = plevel->rgpMCVars[n];
    fprintf(pOutFile, "%5g\t", pMCVar->dVal);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 5
17 5
18 5
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     56e <gsasl_server_callback_service_get+0xd>
mov    0xd8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_service_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_service : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%edi        # 20f9 <terminate_current_pipeline+0x6>
test   %edi,%edi
je     2127 <terminate_current_pipeline+0x34>
cmp    0x0(%rip),%edi        # 2103 <terminate_current_pipeline+0x10>
je     2127 <terminate_current_pipeline+0x34>
sub    $0x8,%rsp
mov    $0xf,%esi
callq  2113 <terminate_current_pipeline+0x20>
mov    $0x12,%esi
mov    0x0(%rip),%edi        # 211e <terminate_current_pipeline+0x2b>
callq  2123 <terminate_current_pipeline+0x30>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
terminate_current_pipeline ()
{
  if (pipeline_pgrp && pipeline_pgrp != shell_pgrp)
    {
      killpg (pipeline_pgrp, 15);
      killpg (pipeline_pgrp, 18);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 5
8 5
9 6
10 6
11 6
12 8
13 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x2a,%edi
callq  19e <jobserver_get_auth+0xb>
mov    %rax,%rbx
mov    0x0(%rip),%ecx        # 1a7 <jobserver_get_auth+0x14>
mov    0x0(%rip),%edx        # 1ad <jobserver_get_auth+0x1a>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  1bf <jobserver_get_auth+0x2c>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
jobserver_get_auth (void)
{
  char *auth = xmalloc (((sizeof ("18446744073709551616")-1) * 2) + 2);
  sprintf (auth, "%d,%d", job_fds[0], job_fds[1]);
  return auth;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,0xc(%rsp)
mov    %rsi,(%rsp)
cmp    $0x1,%edi
jg     11ba <delete+0x49>
mov    $0x0,%edx
mov    %rsp,%rsi
lea    0xc(%rsp),%rdi
callq  1194 <delete+0x23>
test   %eax,%eax
jne    11ba <delete+0x49>
mov    (%rsp),%rax
mov    (%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  11ae <delete+0x3d>
movl   $0xffffffff,0x0(%rip)        # 11b8 <delete+0x47>
jmp    11d1 <delete+0x60>
mov    (%rsp),%rax
mov    0x8(%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  11d1 <delete+0x60>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
delete (int argc, char **argv)
{
  if (argc < 2 && !another (&argc, &argv, "remote-file"))
    {
      printf ("usage: %s remote-file\n", argv[0]);
      code = -1;
      return;
    }
  command ("DELE %s", argv[1]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 5
15 5
16 5
17 6
18 7
19 9
20 9
21 9
22 9
23 9
24 10
25 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x5,%esi
mov    $0x47,%edi
mov    $0x0,%eax
callq  22 <xalloc_die+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xalloc_die()
{
    dico_die(71, 5, 0, "Not enough memory");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    (%rsi),%r8
mov    0x8(%rsi),%rcx
cmpq   $0x0,0x670(%rdi)
jle    f0 <SetMCVars+0x80>
mov    $0x0,%edx
mov    (%rcx),%rax
lea    0x1(%rax),%rsi
mov    %rsi,(%rcx)
movsd  (%r8,%rax,8),%xmm0
mov    0x678(%rdi),%rax
mov    (%rax,%rdx,8),%rax
cmpl   $0x1,0x24(%rax)
ja     c1 <SetMCVars+0x51>
mov    0x68(%rax),%rsi
movsd  (%rsi),%xmm1
ucomisd %xmm0,%xmm1
ja     f6 <SetMCVars+0x86>
mov    0x70(%rax),%rsi
ucomisd (%rsi),%xmm0
jbe    dc <SetMCVars+0x6c>
jmp    fc <SetMCVars+0x8c>
mov    0x78(%rax),%rsi
movsd  (%rsi),%xmm1
ucomisd %xmm0,%xmm1
ja     102 <SetMCVars+0x92>
mov    0x80(%rax),%rsi
ucomisd (%rsi),%xmm0
ja     108 <SetMCVars+0x98>
movsd  %xmm0,0x10(%rax)
add    $0x1,%rdx
cmp    %rdx,0x670(%rdi)
jg     86 <SetMCVars+0x16>
jmp    10e <SetMCVars+0x9e>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
SetMCVars (PLEVEL plevel, char **args)
{
  double *pdMCVarVals = (double *) args[0];
  long *nThetas = (long *) args[1];
  PMCVAR pMCVar;
  double dVar;
  long n;
  for (n = 0; n < plevel->nMCVars; n++) {
    dVar = pdMCVarVals[(*nThetas)++];
    pMCVar = plevel->rgpMCVars[n];
    if ((pMCVar->iType == 0) || (pMCVar->iType == 1)) {
      if ((dVar < *(pMCVar->pdParm[0])) || (dVar > *(pMCVar->pdParm[1]))) {
        return (0);
      }
    }
    else {
      if ((dVar < *(pMCVar->pdParm[2])) || (dVar > *(pMCVar->pdParm[3]))) {
        return (0);
      }
    }
    pMCVar->dVal = dVar;
  }
  return (1);
}
<<<sep_in_sample>>>
1 3
2 4
3 8
4 8
5 8
6 9
7 9
8 9
9 9
10 10
11 10
12 11
13 11
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 21
30 8
31 8
32 8
33 8
34 23
35 23
36 13
37 13
38 13
39 13
40 18
41 18
42 18
43 18
44 23
45 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffff,%ecx
callq  78f6 <gsl_fft_complex_float_radix2_dif_forward+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_complex_float_radix2_dif_forward (gsl_complex_packed_array_float data,
                                              const size_t stride,
                                              const size_t n)
{
  gsl_fft_direction sign = gsl_fft_forward;
  int status = gsl_fft_complex_float_radix2_dif_transform (data, stride, n, sign);
  return status;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
lea    0x8(%rsp),%rdx
mov    $0x5,%esi
callq  c39 <dico_stream_bytes_in+0x17>
test   %eax,%eax
jne    c44 <dico_stream_bytes_in+0x22>
mov    0x8(%rsp),%rax
jmp    c48 <dico_stream_bytes_in+0x26>
mov    0x30(%rbx),%rax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
dico_stream_bytes_in(dico_stream_t stream)
{
    off_t val;
    if (dico_stream_ioctl(stream, 5, &val) == 0)
 return val;
    return stream->bytes_in;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1291 <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_multiset_k (const gsl_multiset * c)
{
  return c->k ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b6 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2c0 <a2ps_get_medium_name+0x9>
mov    (%rax),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
a2ps_get_medium_name (a2ps_job * job, const char * name)
{
  struct medium * medium;
  medium = a2ps_get_medium (job, name);
  return medium->name;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  14 <string_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_free (void *data)
{
  free (data);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  2ad <gsl_vector_float_fscanf+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_float_fscanf (FILE * stream, gsl_vector_float * v)
{
  int status = gsl_block_float_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
callq  489 <print_help_common>
mov    0x0(%rip),%rdi        # 520 <cmdline_parser_print_detailed_help+0xd>
test   %rdi,%rdi
je     53c <cmdline_parser_print_detailed_help+0x29>
mov    $0x0,%ebx
callq  52f <cmdline_parser_print_detailed_help+0x1c>
add    $0x8,%rbx
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    52a <cmdline_parser_print_detailed_help+0x17>
pop    %rbx
retq   
<<<sep_in_sample>>>
cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 6
8 6
9 5
10 5
11 5
12 7
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  19a <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     1d5 <gsl_qrng_free+0x1f>
mov    0x18(%rdi),%rdi
test   %rdi,%rdi
je     1cd <gsl_qrng_free+0x17>
callq  1cd <gsl_qrng_free+0x17>
mov    %rbx,%rdi
callq  1d5 <gsl_qrng_free+0x1f>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_qrng_free (gsl_qrng * q)
{
  if (!q) { return ; };
  if(q->state != 0) free (q->state);
  free (q);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
movslq 0x28(%rdi),%rax
lea    (%rax,%rax,4),%rax
shl    $0x4,%rax
add    0x38(%rdi),%rax
mov    0x10(%rax),%eax
retq   
<<<sep_in_sample>>>
panel_get_current_file_mode(this)
    panel_t *this;
{
    return this->dir_entry[this->current_entry].mode;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
<<<sep_out_sample>>>
testb  $0x1,0x0(%rip)        # 784 <any_signals_trapped+0x7>
jne    7a3 <any_signals_trapped+0x26>
mov    $0x0,%edx
mov    $0x2,%eax
testb  $0x1,(%rdx)
jne    7ae <any_signals_trapped+0x31>
add    $0x1,%eax
add    $0x4,%rdx
cmp    $0x41,%eax
jne    790 <any_signals_trapped+0x13>
jmp    7a9 <any_signals_trapped+0x2c>
mov    $0x1,%eax
retq   
mov    $0xffffffff,%eax
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
any_signals_trapped ()
{
  register int i;
  for (i = 1; i < 65; i++)
    if (sigmodes[i] & 0x1)
      return i;
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 4
5 5
6 5
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 7
15 7
16 8
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rsp,%rax
lea    0x40(%rsi),%r8
movzbl 0x3(%rsi),%ecx
shl    $0x18,%ecx
movzbl 0x2(%rsi),%edx
shl    $0x10,%edx
or     %ecx,%edx
movzbl (%rsi),%ecx
or     %ecx,%edx
movzbl 0x1(%rsi),%ecx
shl    $0x8,%ecx
or     %ecx,%edx
mov    %edx,(%rax)
add    $0x4,%rsi
add    $0x4,%rax
cmp    %r8,%rsi
jne    5cd <md4_compress+0xb>
mov    %rsp,%rsi
callq  0 <md4_transform>
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
md4_compress(struct md4_ctx *ctx, const uint8_t *block)
{
  uint32_t data[16];
  unsigned i;
  for (i = 0; i<16; i++, block += 4)
    data[i] = ( (((uint32_t) (block)[3]) << 24) | (((uint32_t) (block)[2]) << 16) | (((uint32_t) (block)[1]) << 8) | ((uint32_t) (block)[0]));
  md4_transform(ctx->state, data);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 5
16 5
17 5
18 5
19 7
20 7
21 8
22 8
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_message_get_version (const osip_message_t * sip)
{
  return sip->sip_version;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     25 <gsasl_check_version+0x25>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <gsasl_check_version+0x13>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovle %rdx,%rax
jmp    2b <gsasl_check_version+0x2b>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.8.0") <= 0)
    return "1.8.0";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    (%rdi),%ebx
test   %ebx,%ebx
je     f56 <add_deny_word+0x36>
mov    $0x0,%edi
callq  f39 <add_deny_word+0x19>
lea    0x8(%rbp),%rdi
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  f4f <add_deny_word+0x2f>
mov    $0x1,%ebx
jmp    f65 <add_deny_word+0x45>
mov    %rsi,%rax
mov    0x28(%rdi),%rsi
mov    (%rax),%rdi
callq  f65 <add_deny_word+0x45>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
add_deny_word(grecs_value_t *val, void *data)
{
    struct compile_pattern_closure *cpc = data;
    if (val->type != 0) {
 grecs_error(&val->locus, 0, gettext("Expected string value"));
 return 1;
    }
    stratcl_add_word(cpc->list, val->v.string);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 8
19 8
20 8
21 10
22 10
23 10
24 10
25 10
<<<sep_out_sample>>>
mov    $0x1006,%eax
test   %rdi,%rdi
je     84d <mu_mailbox_get_flags+0x1b>
mov    $0x4,%al
cmpl   $0x0,(%rsi)
je     84d <mu_mailbox_get_flags+0x1b>
mov    0x30(%rdi),%eax
mov    %eax,(%rsi)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_mailbox_get_flags (mu_mailbox_t mbox, int *flags)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (!*flags)
    return (0x1000 +4);
  *flags = mbox->flags;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 7
9 8
10 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x20,0x240(%rdi)
je     54 <__log_set_lg_max+0x1e>
mov    $0x1,%edx
mov    $0x0,%esi
callq  52 <__log_set_lg_max+0x1c>
jmp    7c <__log_set_lg_max+0x46>
mov    0x4c(%rdi),%eax
shl    $0x2,%eax
cmp    %esi,%eax
jbe    74 <__log_set_lg_max+0x3e>
mov    $0x0,%esi
mov    $0x0,%eax
callq  6d <__log_set_lg_max+0x37>
mov    $0x16,%eax
jmp    7c <__log_set_lg_max+0x46>
mov    %esi,0x50(%rdi)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__log_set_lg_max(dbenv, lg_max)
 DB_ENV *dbenv;
 u_int32_t lg_max;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_lg_max", 1));;
 if (lg_max < dbenv->lg_bsize * 4) {
  CDB___db_err(dbenv, "log file size must be >= log buffer size * 4");
  return (22);
 }
 dbenv->lg_max = lg_max;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 10
18 11
19 12
20 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
test   %rcx,%rcx
je     e87 <gsl_permute_ulong_inverse+0x71>
lea    0x0(,%rdx,8),%r11
mov    $0x0,%edx
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    e3a <gsl_permute_ulong_inverse+0x24>
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     e31 <gsl_permute_ulong_inverse+0x1b>
cmp    %rax,%rdx
ja     e68 <gsl_permute_ulong_inverse+0x52>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
jne    e73 <gsl_permute_ulong_inverse+0x5d>
jmp    e68 <gsl_permute_ulong_inverse+0x52>
mov    %r9,%r10
mov    %r11,%rax
imul   %r8,%rax
add    %rsi,%rax
mov    (%rax),%r9
mov    %r10,(%rax)
mov    (%rdi,%r8,8),%r8
cmp    %rdx,%r8
jne    e4a <gsl_permute_ulong_inverse+0x34>
jmp    e7d <gsl_permute_ulong_inverse+0x67>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    e28 <gsl_permute_ulong_inverse+0x12>
jmp    e87 <gsl_permute_ulong_inverse+0x71>
imul   %r11,%rax
mov    (%rsi,%rax,1),%r10
jmp    e4d <gsl_permute_ulong_inverse+0x37>
imul   %r11,%r8
mov    %r9,(%rsi,%r8,1)
jmp    e68 <gsl_permute_ulong_inverse+0x52>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_permute_ulong_inverse (const size_t * p, unsigned long * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned long t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned long r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 18
4 4
5 6
6 7
7 7
8 8
9 7
10 7
11 9
12 9
13 11
14 12
15 12
16 12
17 23
18 23
19 23
20 23
21 23
22 24
23 28
24 19
25 19
26 19
27 4
28 4
29 4
30 4
31 18
32 18
33 18
34 31
35 31
36 31
37 35
38 35
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  12 <ostream__free>
<<<sep_in_sample>>>
ostream__flush (ostream_t first_arg)
{
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x2040,%edi
callq  b43 <create_index_chunk+0xb>
mov    %rax,%rbx
test   %rax,%rax
je     b79 <create_index_chunk+0x41>
mov    $0x2040,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  b5d <create_index_chunk+0x25>
lea    0x18(%rbx),%rcx
mov    $0x0,%edx
mov    %dl,(%rcx)
add    $0x1,%edx
add    $0x20,%rcx
cmp    $0x100,%edx
jne    b66 <create_index_chunk+0x2e>
jmp    b80 <create_index_chunk+0x48>
mov    $0x0,%eax
jmp    b83 <create_index_chunk+0x4b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
create_index_chunk ()
{
  df_index_base *return_array;
  int i;
  return_array = malloc (258 * sizeof (df_index_base));
  if (return_array == ((void *)0))
    return ((void *)0);
  bzero (return_array, 258 * sizeof (df_index_base));
  for (i = 0; i < 256; i++)
    return_array[i].byte_value = i;
  return return_array;
  }
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
7 8
8 8
9 8
10 8
11 8
12 9
13 10
14 9
15 9
16 9
17 9
18 9
19 7
20 7
21 11
22 12
23 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
rec_field_name (rec_field_t field)
{
  return field->name;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
lea    0x50(%rdi),%rax
test   %rsi,%rsi
cmove  %rax,%rsi
mov    0x40(%rdi),%rax
mov    %rax,(%rsi)
mov    0x48(%rdi),%eax
mov    %eax,0x8(%rsi)
mov    0x40(%rdi),%rax
test   %rax,%rax
je     1c9 <swheader_store_state+0x27>
mov    (%rax),%eax
mov    %eax,0xc(%rsi)
retq   
movl   $0x0,0xc(%rsi)
retq   
<<<sep_in_sample>>>
swheader_store_state(SWHEADER * header, SWHEADER_STATE * fp_state)
{
 SWHEADER_STATE * state;
 if (fp_state)
  state = fp_state;
 else
  state = &(header->saved_);
 state->save_current_offset_pM = header->current_offset_p_;
 state->save_current_offsetM = header->current_offset_;
 if (header->current_offset_p_) {
  state->save_current_offset_vM = *(header->current_offset_p_);
 } else {
  state->save_current_offset_vM = 0;
 }
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 8
5 8
6 9
7 9
8 10
9 10
10 10
11 11
12 11
13 11
14 13
15 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x8,%r8d
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0xa,%esi
callq  103 <uinttostr+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
uinttostr (i, buf, len)
     uintmax_t i;
     char *buf;
     size_t len;
{
  return (fmtumax (i, 10, buf, len, 0x08));
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 6
6 6
7 7
8 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  225 <gsasl_client_finish+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_client_finish (Gsasl_session * sctx)
{
  gsasl_finish (sctx);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
<<<sep_in_sample>>>
gsl_odeiv_step_name(const gsl_odeiv_step * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 100 <get_alias_value+0x8>
je     116 <get_alias_value+0x1e>
sub    $0x8,%rsp
callq  10b <get_alias_value+0x13>
test   %rax,%rax
je     11c <get_alias_value+0x24>
mov    0x8(%rax),%rax
jmp    121 <get_alias_value+0x29>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_alias_value (name)
     char *name;
{
  alias_t *alias;
  if (aliases == 0)
    return ((char *)((void *)0));
  alias = find_alias (name);
  return (alias ? alias->value : (char *)((void *)0));
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 8
6 8
7 8
8 8
9 6
10 9
11 8
12 9
13 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%ecx
mov    $0x5,%edx
mov    $0xfffffffffffffff8,%rsi
callq  910b <_stxi_l>
mov    $0x0,%r9d
mov    $0x28,%r8d
mov    $0x5,%ecx
mov    $0xfffffff8,%edx
mov    $0x3d,%esi
mov    %rbx,%rdi
callq  264d <_x87rx>
lea    0x1(%rbp),%edx
mov    $0x2b,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_x87_extr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    _stxi_l(_jit, -8, 5, r1);
    _x87rx(_jit, 075, -8, 5, _NOREG, 0x00);
    _x87ri(_jit,053,r0 + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  313 <fclosepipe+0x9>
mov    %eax,%edi
callq  31a <fclosepipe+0x10>
mov    %rbx,%rdi
callq  322 <fclosepipe+0x18>
cmp    $0xffffffff,%eax
je     331 <fclosepipe+0x27>
mov    $0x0,%edi
callq  331 <fclosepipe+0x27>
pop    %rbx
retq   
<<<sep_in_sample>>>
fclosepipe(FILE *fp)
{
  closepipe(fileno(fp));
  if (fclose(fp) != (-1))
    perror("trueprint" ": could not close diff stream");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     926 <gsl_matrix_complex_float_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8fe <gsl_matrix_complex_float_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    958 <gsl_matrix_complex_float_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x3,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_row (gsl_matrix_complex_float * m, const size_t i)
{
  _gsl_vector_complex_float_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_float v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 2 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rbx
mov    0x10(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x8,%esi
callq  5b <gsl_multiset_fwrite+0x19>
mov    $0x0,%edx
cmp    %rbx,%rax
je     80 <gsl_multiset_fwrite+0x3e>
mov    $0x5,%ecx
mov    $0x3a,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  7b <gsl_multiset_fwrite+0x39>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multiset_fwrite (FILE * stream, const gsl_multiset * c)
{
  size_t k = c->k ;
  size_t * data = c->data ;
  size_t items = fwrite (data, sizeof (size_t), k, stream);
  if (items != k)
    {
      do { gsl_error ("fwrite failed", "file.c", 58, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rbx
mov    $0x18,%edi
callq  4af <faced_string_new+0x16>
mov    %r12,(%rax)
mov    %ebp,0x8(%rax)
mov    %rbx,0xc(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
faced_string_new (unsigned char * string, int reg_ref, struct fface_s face)
{
  struct faced_string * res = ((struct faced_string *) xmalloc (sizeof (struct faced_string) * (1)));
  res->string = string;
  res->reg_ref = reg_ref;
  res->face = face;
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 5
11 6
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,%rdi
callq  aee <prefix_match+0x14>
mov    0x50(%rbp),%rdi
mov    %rax,%rdx
mov    %rbx,%rsi
callq  afd <prefix_match+0x23>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
prefix_match(struct gcide_db *db, const char *hw)
{
    return gcide_idx_locate(db->idx, (char*)hw, utf8_strlen(hw));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 6 <set_gpath_flags+0x6>
retq   
<<<sep_in_sample>>>
set_gpath_flags(int flags) {
 openflags = flags;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    %rcx,%r13
mov    (%rcx),%rbx
test   %rbx,%rbx
je     22a <wsp_getvar+0x7b>
mov    %rsi,%r15
mov    %rdx,%r12
mov    $0x0,%ebp
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1e5 <wsp_getvar+0x36>
cmp    %r12,%rax
jne    218 <wsp_getvar+0x69>
mov    %r12,%rdx
mov    %r15,%rsi
mov    %rbx,%rdi
callq  1f8 <wsp_getvar+0x49>
mov    %eax,%r14d
test   %eax,%eax
jne    218 <wsp_getvar+0x69>
lea    0x1(%rbx,%r12,1),%rdi
callq  209 <wsp_getvar+0x5a>
test   %rax,%rax
je     232 <wsp_getvar+0x83>
mov    0x8(%rsp),%rcx
mov    %rax,(%rcx)
jmp    240 <wsp_getvar+0x91>
add    $0x1,%ebp
movslq %ebp,%rax
mov    0x0(%r13,%rax,8),%rbx
test   %rbx,%rbx
jne    1d8 <wsp_getvar+0x29>
jmp    23a <wsp_getvar+0x8b>
mov    $0x5,%r14d
jmp    240 <wsp_getvar+0x91>
mov    $0x2,%r14d
jmp    240 <wsp_getvar+0x91>
mov    $0x5,%r14d
mov    %r14d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
wsp_getvar (char **ret, const char *vptr, size_t vlen, void *data)
{
  char **base = data;
  int i;
  for (i = 0; base[i]; i++)
    {
      size_t l = strcspn (base[i], "=");
      if (l == vlen && memcmp (base[i], vptr, vlen) == 0)
 {
   char *p = strdup (base[i] + vlen + 1);
   if (p == ((void *)0))
     return 2;
   *ret = p;
   return 0;
 }
    }
  return 5;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 10
29 10
30 11
31 11
32 13
33 13
34 14
35 5
36 5
37 5
38 5
39 5
40 5
41 17
42 17
43 12
44 12
45 17
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 18
54 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%r13
mov    %rdx,%r12
mov    0x28(%rdi),%rbx
lea    0x28(%rdi),%rbp
cmp    %rbp,%rbx
je     6d6 <gl_linked_sortedlist_remove+0x47>
mov    0x10(%rbx),%rdi
mov    %r12,%rsi
callq  *%r13
test   %eax,%eax
jg     6dd <gl_linked_sortedlist_remove+0x4e>
test   %eax,%eax
jne    6cc <gl_linked_sortedlist_remove+0x3d>
mov    %rbx,%rsi
mov    %r14,%rdi
callq  65a <gl_linked_remove_node>
jmp    6e9 <gl_linked_sortedlist_remove+0x5a>
mov    (%rbx),%rbx
cmp    %rbp,%rbx
jne    6ad <gl_linked_sortedlist_remove+0x1e>
jmp    6e4 <gl_linked_sortedlist_remove+0x55>
mov    $0x0,%eax
jmp    6e9 <gl_linked_sortedlist_remove+0x5a>
mov    $0x0,%eax
jmp    6e9 <gl_linked_sortedlist_remove+0x5a>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gl_linked_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,
        const void *elt)
{
  gl_list_node_t node;
  for (node = list->root.next; node != &list->root; node = node->next)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
 break;
      if (cmp == 0)
 return gl_linked_remove_node (list, node);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 10
19 10
20 11
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 13
29 13
30 13
31 13
32 13
33 14
34 14
35 14
36 14
37 14
38 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    (%rbx),%rsi
test   %rsi,%rsi
je     1f1 <lookupCraft+0x37>
mov    %r12,%rdi
callq  1db <lookupCraft+0x21>
test   %eax,%eax
jne    1f1 <lookupCraft+0x37>
movslq %ebp,%rax
imul   $0x5a0,%rax,%rax
add    $0x0,%rax
jmp    208 <lookupCraft+0x4e>
add    $0x1,%ebp
add    $0x5a0,%rbx
cmp    $0x80,%ebp
jne    1cb <lookupCraft+0x11>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
lookupCraft(const char *name)
{
 int i;
 craftType *c = ((void *)0);
 for (i = 0; i < 128; ++i) {
  if (ctype[i].name != (char *) ((void *)0)) {
   if (strcmp(name, ctype[i].name) == 0)
    return &ctype[i];
  }
 }
 return c;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 5
19 5
20 5
21 5
22 11
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
push   %rbx
callq  1da <findcalling+0x6>
mov    %rax,%rbx
callq  0 <common>
mov    $0x0,%r9d
mov    %rbx,%r8
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x400,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  207 <findcalling+0x33>
mov    $0x0,%edi
callq  211 <findcalling+0x3d>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
findcalling(char *pattern)
{
 snprintf(comline, sizeof(comline), "%s -r %s > %s", common(), quote_shell(pattern), temp1);
 if (system(comline) != 0)
  return "global command failed";
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 5
17 5
18 5
19 7
20 7
<<<sep_out_sample>>>
movl   $0x1,(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x8(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
dwname_copy(void *a, void *b)
{
 struct dwref *syma = a;
 struct dwref *symb = b;
 syma->used = 1;
 syma->dw = symb->dw;
 return 0;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 8
5 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 59a <usage+0xb>
mov    $0x0,%esi
mov    $0x0,%eax
callq  5a9 <usage+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
usage(FILE *fp)
{
    fprintf(fp, "usage: %s [op] [args]\n", dico_program_name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 4d9 <gsl_vector_complex_const_ptr+0x7>
je     504 <gsl_vector_complex_const_ptr+0x32>
cmp    %rsi,(%rdi)
ja     504 <gsl_vector_complex_const_ptr+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xf0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4fd <gsl_vector_complex_const_ptr+0x2b>
mov    $0x0,%eax
jmp    518 <gsl_vector_complex_const_ptr+0x46>
mov    0x8(%rdi),%rax
shl    $0x4,%rax
imul   %rax,%rsi
mov    %rsi,%rax
add    0x10(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_const_ptr (const gsl_vector_complex * v,
                                    const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_double.h", 240, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return ((gsl_complex*)&((v)->data[2*(i)*(v)->stride]));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
<<<sep_out_sample>>>
movb   $0x0,0x1(%rdi)
movb   $0x0,(%rdi)
retq   
<<<sep_in_sample>>>
nettle_base16_decode_init(struct base16_decode_ctx *ctx)
{
  ctx->word = ctx->bits = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xa0,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %rsp,%rdi
callq  ae9 <md5_buffer+0x1c>
mov    %rsp,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  af7 <md5_buffer+0x2a>
mov    %rbx,%rsi
mov    %rsp,%rdi
callq  b02 <md5_buffer+0x35>
add    $0xa0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
md5_buffer (const char *buffer, size_t len, void *resblock)
{
  struct md5_ctx ctx;
  md5_init_ctx (&ctx);
  md5_process_bytes (buffer, len, &ctx);
  return md5_finish_ctx (&ctx, resblock);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rdi,%rdx
mov    %rsp,%rdi
mov    $0x7,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
cmp    $0x8,%esi
jne    21 <quoting_options_from_style+0x21>
callq  21 <quoting_options_from_style+0x21>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0 };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 37a <gsl_matrix_complex_const_ptr+0xb>
je     3c7 <gsl_matrix_complex_const_ptr+0x58>
cmp    %rsi,(%rdi)
ja     3a1 <gsl_matrix_complex_const_ptr+0x32>
mov    $0x4,%ecx
mov    $0x152,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  39a <gsl_matrix_complex_const_ptr+0x2b>
mov    $0x0,%eax
jmp    3da <gsl_matrix_complex_const_ptr+0x6b>
cmp    %rdx,0x8(%rdi)
ja     3c7 <gsl_matrix_complex_const_ptr+0x58>
mov    $0x4,%ecx
mov    $0x156,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3c0 <gsl_matrix_complex_const_ptr+0x51>
mov    $0x0,%eax
jmp    3da <gsl_matrix_complex_const_ptr+0x6b>
mov    %rsi,%rax
imul   0x10(%rdi),%rax
add    %rdx,%rax
shl    $0x4,%rax
add    0x18(%rdi),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_const_ptr(const gsl_matrix_complex * m,
                                   const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_double.h", 338, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_double.h", 342, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 15
23 15
24 15
25 15
26 15
27 16
28 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  19a <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     332 <hash_load+0x39>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rcx,%r13
mov    %rdx,%rbp
mov    %rbx,%rsi
mov    %r12,%rdi
callq  31f <hash_load+0x26>
add    %r13,%rbx
sub    $0x1,%rbp
jne    314 <hash_load+0x1b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
hash_load (struct hash_table *ht, void *item_table,
           unsigned long cardinality, unsigned long size)
{
  char *items = (char *) item_table;
  while (cardinality--)
    {
      hash_insert (ht, items);
      items += size;
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 7
13 7
14 7
15 8
16 5
17 5
18 10
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
push   %rbx
test   %edi,%edi
je     622 <sh_ttyerror+0x30>
callq  5fc <sh_ttyerror+0xa>
mov    (%rax),%edi
callq  603 <sh_ttyerror+0x11>
mov    %rax,%rbx
mov    $0x0,%edi
callq  610 <sh_ttyerror+0x1e>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  620 <sh_ttyerror+0x2e>
jmp    64b <sh_ttyerror+0x59>
callq  627 <sh_ttyerror+0x35>
mov    (%rax),%edi
callq  62e <sh_ttyerror+0x3c>
mov    %rax,%rbx
mov    $0x0,%edi
callq  63b <sh_ttyerror+0x49>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  64b <sh_ttyerror+0x59>
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_ttyerror (set)
     int set;
{
  if (set)
    builtin_error (gettext("error setting terminal attributes: %s"), strerror ((*__errno_location ())));
  else
    builtin_error (gettext("error getting terminal attributes: %s"), strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
<<<sep_out_sample>>>
movslq %edx,%rax
shl    $0x4,%rax
mov    0x0(%rax),%ecx
mov    $0x0,%eax
test   $0x8000000,%ecx
je     5571 <_jit_regarg_p+0x5c>
test   $0x20000000,%ecx
je     554e <_jit_regarg_p+0x39>
mov    $0xd,%ecx
sub    %edx,%ecx
js     5571 <_jit_regarg_p+0x5c>
movslq %ecx,%rcx
cmp    0x18(%rsi),%rcx
setl   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
test   $0x40000000,%ecx
je     5571 <_jit_regarg_p+0x5c>
mov    $0x1f,%ecx
sub    %edx,%ecx
js     5571 <_jit_regarg_p+0x5c>
movslq %ecx,%rcx
cmp    0x20(%rsi),%rcx
setl   %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
_jit_regarg_p(jit_state_t *_jit, jit_node_t *node, jit_int32_t regno)
{
    jit_int32_t spec;
    spec = ((_rvs[regno].spec) & 0xffff0000);
    if (spec & 0x08000000) {
 if (spec & 0x20000000) {
     regno = _RDI - regno;
     if (regno >= 0 && regno < node->v.w)
  return (1);
 }
 else if (spec & 0x40000000) {
     regno = _XMM0 - regno;
     if (regno >= 0 && regno < node->w.w)
  return (1);
 }
    }
    return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 17
5 5
6 5
7 6
8 6
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 17
18 11
19 11
20 12
21 13
22 13
23 13
24 13
25 13
26 13
27 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x1,%ecx
callq  2bb <dico_assoc_append+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dico_assoc_append(dico_assoc_list_t assoc, const char *key, const char *value)
{
    return dico_assoc_add(assoc, key, value, 1, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cmp    %edi,%esi
mov    %edi,%eax
cmovle %esi,%eax
retq   
<<<sep_in_sample>>>
GSL_MIN_INT (int a, int b)
{
  return ((a) < (b) ? (a) : (b));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    $0x1,%esi
mov    0x0(%rip),%rdi        # 1870 <check_db_visibility+0x12>
callq  1875 <check_db_visibility+0x17>
mov    %eax,%ebp
mov    0x0(%rip),%rdi        # 187e <check_db_visibility+0x20>
callq  1883 <check_db_visibility+0x25>
mov    %rax,0x8(%rsp)
mov    %rax,%rdi
callq  1890 <check_db_visibility+0x32>
mov    %rax,%rbx
test   %rax,%rax
je     18dc <check_db_visibility+0x7e>
mov    0x30(%rbx),%rdi
mov    %ebp,%esi
callq  18a3 <check_db_visibility+0x45>
test   %eax,%eax
jne    18b0 <check_db_visibility+0x52>
movl   $0x0,0x38(%rbx)
jmp    18ca <check_db_visibility+0x6c>
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
callq  18bd <check_db_visibility+0x5f>
lea    0x10(%rsp),%rdi
callq  18c7 <check_db_visibility+0x69>
mov    %eax,0x38(%rbx)
mov    0x8(%rsp),%rdi
callq  18d4 <check_db_visibility+0x76>
mov    %rax,%rbx
test   %rax,%rax
jne    1898 <check_db_visibility+0x3a>
lea    0x8(%rsp),%rdi
callq  18e6 <check_db_visibility+0x88>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
check_db_visibility()
{
    dicod_database_t *db;
    dico_iterator_t itr;
    int global = dicod_acl_check(global_acl, 1);
    itr = xdico_list_iterator(database_list);
    for (db = dico_iterator_first(itr); db; db = dico_iterator_next(itr)) {
 if (!dicod_acl_check(db->acl, global))
     db->visible = 0;
 else {
     dico_list_t list[2];
     dicod_get_database_languages(db, list);
     db->visible = dicod_lang_check(list);
 }
    }
    dico_iterator_destroy(&itr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 12
24 12
25 12
26 13
27 13
28 13
29 7
30 7
31 7
32 7
33 7
34 16
35 16
36 17
37 17
38 17
39 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
callq  3aa <gsl_blas_icamax+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_icamax (const gsl_vector_complex_float * X)
{
  return cblas_icamax (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %edi,%ebx
mov    %esi,%ebp
movsd  %xmm0,0x8(%rsp)
movsd  %xmm1,0x18(%rsp)
movsd  %xmm2,0x20(%rsp)
ucomisd %xmm2,%xmm1
jbe    1aa1 <dap_mdpt+0x46>
movapd %xmm0,%xmm7
addsd  %xmm0,%xmm7
movsd  %xmm7,(%rsp)
movsd  0x0(%rip),%xmm0        # 1a92 <dap_mdpt+0x37>
xorpd  %xmm7,%xmm7
movsd  %xmm7,0x10(%rsp)
jmpq   1bd7 <dap_mdpt+0x17c>
movsd  0x8(%rsp),%xmm7
mulsd  0x0(%rip),%xmm7        # 1aaf <dap_mdpt+0x54>
movsd  %xmm7,(%rsp)
jmp    1a8a <dap_mdpt+0x2f>
movsd  (%rsp),%xmm0
mov    %ebp,%esi
mov    %ebx,%edi
callq  1ac4 <dap_mdpt+0x69>
movapd %xmm0,%xmm6
movsd  %xmm0,0x28(%rsp)
movsd  0x20(%rsp),%xmm0
movsd  0x18(%rsp),%xmm5
subsd  %xmm5,%xmm0
movsd  (%rsp),%xmm1
movsd  0x8(%rsp),%xmm7
subsd  %xmm7,%xmm1
mulsd  %xmm1,%xmm0
movapd %xmm6,%xmm1
subsd  %xmm5,%xmm1
divsd  %xmm1,%xmm0
addsd  %xmm7,%xmm0
movsd  %xmm0,0x10(%rsp)
xorpd  %xmm6,%xmm6
ucomisd %xmm0,%xmm6
jbe    1b3f <dap_mdpt+0xe4>
movsd  (%rsp),%xmm6
ucomisd %xmm7,%xmm6
jbe    1b2c <dap_mdpt+0xd1>
mulsd  0x0(%rip),%xmm7        # 1b24 <dap_mdpt+0xc9>
movsd  %xmm7,0x10(%rsp)
jmp    1b3f <dap_mdpt+0xe4>
movsd  (%rsp),%xmm7
mulsd  0x0(%rip),%xmm7        # 1b39 <dap_mdpt+0xde>
movsd  %xmm7,0x10(%rsp)
movsd  0x10(%rsp),%xmm0
mov    %ebp,%esi
mov    %ebx,%edi
callq  1b4e <dap_mdpt+0xf3>
movapd %xmm0,%xmm2
movsd  0x18(%rsp),%xmm4
subsd  %xmm4,%xmm2
andpd  0x0(%rip),%xmm2        # 1b64 <dap_mdpt+0x109>
movapd %xmm0,%xmm1
subsd  0x28(%rsp),%xmm1
andpd  0x0(%rip),%xmm1        # 1b76 <dap_mdpt+0x11b>
movapd %xmm2,%xmm3
cmpltsd %xmm1,%xmm3
andpd  %xmm3,%xmm4
andnpd %xmm0,%xmm3
orpd   %xmm4,%xmm3
movsd  %xmm3,0x18(%rsp)
movapd %xmm2,%xmm3
cmpltsd %xmm1,%xmm3
movsd  0x8(%rsp),%xmm4
andpd  %xmm3,%xmm4
movsd  0x10(%rsp),%xmm5
andnpd %xmm5,%xmm3
orpd   %xmm4,%xmm3
movsd  %xmm3,0x8(%rsp)
cmpltsd %xmm1,%xmm2
movapd %xmm5,%xmm1
andpd  %xmm2,%xmm1
movsd  (%rsp),%xmm7
andnpd %xmm7,%xmm2
orpd   %xmm1,%xmm2
movsd  %xmm2,(%rsp)
subsd  0x20(%rsp),%xmm0
andpd  0x0(%rip),%xmm0        # 1be5 <dap_mdpt+0x18a>
ucomisd 0x0(%rip),%xmm0        # 1bed <dap_mdpt+0x192>
ja     1ab6 <dap_mdpt+0x5b>
movsd  0x10(%rsp),%xmm0
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dap_mdpt(int numdf, int dendf, double pt0, double pr0, double alpha)
{
  double pt1, pr1;
  double pt2, pr2;
  pt2 = 0.0;
  if (alpha < pr0)
    pt1 = 2.0 * pt0;
  else
    pt1 = 0.5 * pt0;
  pr2 = 1.0;
  while (fabs(pr2 - alpha) > dap_prtol)
    {
      pr1 = dap_md(numdf, dendf, pt1);
      pt2 = pt0 + (pt1 - pt0) * (alpha - pr0) / (pr1 - pr0);
      if (pt2 < 0.0)
 {
   if (pt0 < pt1)
     pt2 = 0.5 * pt0;
   else
     pt2 = 0.5 * pt1;
 }
      pr2 = dap_md(numdf, dendf, pt2);
      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))
 {
   pr1 = pr2;
   pt1 = pt2;
 }
      else
 {
   pr0 = pr2;
   pt0 = pt2;
 }
    }
  return pt2;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 26
15 26
16 26
17 26
18 9
19 9
20 9
21 9
22 13
23 13
24 13
25 13
26 13
27 13
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
43 17
44 17
45 17
46 18
47 18
48 18
49 20
50 20
51 20
52 22
53 22
54 22
55 22
56 23
57 23
58 23
59 23
60 23
61 23
62 23
63 30
64 30
65 30
66 30
67 30
68 30
69 30
70 30
71 30
72 30
73 30
74 30
75 30
76 30
77 30
78 30
79 30
80 30
81 30
82 30
83 30
84 11
85 11
86 11
87 11
88 35
89 35
90 35
91 35
92 35
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    0x0(%rip),%rdi        # 181 <handle_signal+0xf>
callq  186 <handle_signal+0x14>
mov    0x0(%rip),%rbx        # 18d <handle_signal+0x1b>
mov    $0x0,%edi
callq  197 <handle_signal+0x25>
mov    %ebp,%ecx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 1a6 <handle_signal+0x34>
mov    $0x0,%eax
callq  1b0 <handle_signal+0x3e>
mov    $0x3,%edi
callq  1ba <my_malloc>
<<<sep_in_sample>>>
handle_signal (the_signal)
     int the_signal;
{
  rpl_fflush (stdout);
  fprintf (stderr, gettext("\n%s: program aborted by signal %d\n"), prgr_name,
    the_signal);
  exit (3);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r12d
mov    %ecx,%r13d
mov    %r8,%r14
mov    %r9d,%r15d
movq   $0x0,0x0(%rip)        # 67c2 <us_nd_hdy+0x2a>
movl   $0x0,0x0(%rip)        # 67cc <us_nd_hdy+0x34>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  67d8 <us_nd_hdy+0x40>
mov    0x0(%rip),%rax        # 67df <us_nd_hdy+0x47>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 67eb <us_nd_hdy+0x53>
callq  67f0 <us_nd_hdy+0x58>
mov    0x70(%rsp),%edx
mov    %edx,0x20(%rsp)
mov    %r15d,0x18(%rsp)
mov    %r14,0x10(%rsp)
mov    %r13d,0x8(%rsp)
movl   $0x0,(%rsp)
lea    -0x2(%r12),%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    (%rbx),%edi
callq  682a <us_nd_hdy+0x92>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
us_nd_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_ND";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[117].ht_text),
    ptr_cc_id, "+", easter - 2, 0, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 10
15 11
16 12
17 12
18 12
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %rcx,%r14
mov    %r8,%r15
mov    %r9,%rbx
callq  179 <gsl_stats_ttest+0x25>
movsd  %xmm0,(%rsp)
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  18c <gsl_stats_ttest+0x38>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  1a9 <gsl_stats_ttest+0x55>
test   %rbp,%rbp
js     1b5 <gsl_stats_ttest+0x61>
cvtsi2sd %rbp,%xmm3
jmp    1cd <gsl_stats_ttest+0x79>
mov    %rbp,%rax
shr    %rax
mov    %rbp,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # 1d5 <gsl_stats_ttest+0x81>
divsd  %xmm3,%xmm2
test   %rbx,%rbx
js     1e5 <gsl_stats_ttest+0x91>
cvtsi2sd %rbx,%xmm3
jmp    1fd <gsl_stats_ttest+0xa9>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm1        # 205 <gsl_stats_ttest+0xb1>
divsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    28a <gsl_stats_ttest+0x136>
test   %rbp,%rbp
js     227 <gsl_stats_ttest+0xd3>
cvtsi2sd %rbp,%xmm1
jmp    23c <gsl_stats_ttest+0xe8>
mov    %rbp,%rax
shr    %rax
and    $0x1,%ebp
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm2        # 244 <gsl_stats_ttest+0xf0>
divsd  %xmm1,%xmm2
test   %rbx,%rbx
js     254 <gsl_stats_ttest+0x100>
cvtsi2sd %rbx,%xmm1
jmp    269 <gsl_stats_ttest+0x115>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 271 <gsl_stats_ttest+0x11d>
divsd  %xmm1,%xmm3
movapd %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
callq  286 <gsl_stats_ttest+0x132>
movapd %xmm0,%xmm1
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
divsd  %xmm1,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_ttest (const double data1[],
                           const size_t stride1, const size_t n1,
                           const double data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_mean (data2, stride2, n2);
  const double pv = gsl_stats_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 11
92 11
93 11
94 11
95 11
96 11
97 11
98 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d4 <cdio_audio_play_msf+0x1d>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     da <cdio_audio_play_msf+0x23>
sub    $0x8,%rsp
mov    0x180(%rdi),%rdi
callq  *%rax
jmp    e1 <cdio_audio_play_msf+0x2a>
mov    $0xfffffffd,%eax
retq   
mov    $0xfffffffe,%eax
nop
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cdio_audio_play_msf (CdIo_t *p_cdio, msf_t *p_start_msf, msf_t *p_end_msf)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_play_msf) {
    return p_cdio->op.audio_play_msf (p_cdio->env, p_start_msf, p_end_msf);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 2
7 5
8 5
9 5
10 3
11 3
12 7
13 7
14 7
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 65d <xplustabs+0xb>
mov    0x30(%rax),%rsi
mov    0x20(%rax),%rax
mov    (%rax),%rdi
callq  66d <xplustabs+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xplustabs(void)
{
    ((void) (0));
    return strnlenpt(openfile->current->data, openfile->current_x);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rdx,%r13
test   %rdi,%rdi
je     2916 <rpmpsf_list_iterate+0x77>
mov    %rsi,%rbp
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  28d3 <rpmpsf_list_iterate+0x34>
mov    %rax,%rbx
mov    %rax,(%r12)
test   %rax,%rax
je     2942 <rpmpsf_list_iterate+0xa3>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2901 <rpmpsf_list_iterate+0x62>
mov    %r13,%rsi
mov    %rbx,%rdi
callq  290c <rpmpsf_list_iterate+0x6d>
mov    %rax,%rdx
test   %rdx,%rdx
jne    2947 <rpmpsf_list_iterate+0xa8>
jmp    2925 <rpmpsf_list_iterate+0x86>
mov    %rdx,%rsi
mov    $0x0,%edi
callq  2923 <rpmpsf_list_iterate+0x84>
jmp    2947 <rpmpsf_list_iterate+0xa8>
mov    (%r12),%rdi
test   %rdi,%rdi
je     2933 <rpmpsf_list_iterate+0x94>
callq  2933 <rpmpsf_list_iterate+0x94>
movq   $0x0,(%r12)
mov    $0x0,%eax
jmp    2947 <rpmpsf_list_iterate+0xa8>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
rpmpsf_list_iterate(char **buf, char *str, char *delim)
{
 char *p, *p1;
 if (buf) {
  (*buf) = (char *) malloc((size_t) (strlen(str) + 1));
  if (!(*buf))
   return (char *) (((void *)0));
  p = *buf;
  strncpy(p, str, strlen(str) + 1);
  p1 = strtok(p, delim);
 } else {
  p1 = strtok(((void *)0), delim);
 }
 if (p1) {
  return p1;
 } else {
  if (buf) {
   if (*buf)
    free(*buf);
   *buf = ((void *)0);
  }
  return ((void *)0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 6
21 6
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 14
36 14
37 14
38 12
39 12
40 12
41 12
42 18
43 18
44 18
45 19
46 20
47 22
48 22
49 7
50 24
51 24
52 24
53 24
54 24
55 24
<<<sep_out_sample>>>
cmp    $0xc,%edi
ja     16d <get_regex_type_flags+0x12>
mov    %edi,%edi
shl    $0x4,%rdi
mov    0x0(%rdi),%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
get_regex_type_flags (unsigned int ix)
{
  if (ix < N_REGEX_MAP_ENTRIES)
    return regex_map[ix].option_val;
  else
    return -1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 6
8 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x1,0x0(%rip)        # 1d9c <do_continue+0xb>
je     1da3 <do_continue+0x12>
callq  1da3 <do_continue+0x12>
callq  1da8 <do_continue+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_continue(int signal)
{
    if (((flags[((USE_MOUSE) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((USE_MOUSE) % (sizeof(unsigned) * 8)))) != 0))
 enable_mouse_support();
    regenerate_screen();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d94 <asm_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
asm_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  43e <read_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
read_error (char const *name)
{
  call_arg_error ("read", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 1603 <editFormToolText+0x7>
jle    172a <editFormToolText+0x12e>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 161a <editFormToolText+0x1e>
mov    0x0(,%rax,8),%rbp
mov    $0xffffffffffffffff,%r13
mov    %rbp,%rdi
mov    $0x0,%r12d
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x3f(%rcx),%rdi
callq  1646 <editFormToolText+0x4a>
mov    %rax,%rbx
movabs $0x6c6f6f7420646c4f,%rax
mov    %rax,(%rbx)
movabs $0x7369207478657420,%rax
mov    %rax,0x8(%rbx)
movw   $0xa3a,0x10(%rbx)
movb   $0x0,0x12(%rbx)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1679 <editFormToolText+0x7d>
mov    %rbx,%rdi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rax
movabs $0x6e207265746e450a,%rdx
mov    %rdx,(%rax)
movabs $0x2074786574207765,%rsi
mov    %rsi,0x8(%rax)
movabs $0x204c45434e414328,%rdx
mov    %rdx,0x10(%rax)
movabs $0x6961746572206f74,%rsi
mov    %rsi,0x18(%rax)
movabs $0x657420646c6f206e,%rdx
mov    %rdx,0x20(%rax)
movl   $0x3a297478,0x28(%rax)
movb   $0x0,0x2c(%rax)
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  16ec <editFormToolText+0xf0>
mov    %rbx,%rdi
callq  16f4 <editFormToolText+0xf8>
cmpb   $0x0,0x0(%rip)        # 16fb <editFormToolText+0xff>
je     1716 <editFormToolText+0x11a>
movslq 0x0(%rip),%rax        # 1704 <editFormToolText+0x108>
mov    0x0(,%rax,8),%rdi
mov    $0x0,%esi
callq  1716 <editFormToolText+0x11a>
movl   $0x3,0x0(%rip)        # 1720 <editFormToolText+0x124>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
editFormToolText()
{
   if(total_form_tools <= 0) return;
   char *msg = (char *)
        malloc(strlen(form_tool_text[selected_form_tool])+64);
   strcpy(msg, "Old tool text is:\n");
   strcat(msg, form_tool_text[selected_form_tool]);
   strcat(msg, "\nEnter new text (CANCEL to retain old text):\0");
   inputBoxI(msg, form_tool_text[selected_form_tool],
      "Change tool text");
   free(msg);
   if(strlen(input))
     strcpy(form_tool_text[selected_form_tool], input);
   FILE_STATE = MODIFIED;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 9
48 9
49 9
50 9
51 11
52 11
53 12
54 12
55 13
56 13
57 13
58 13
59 14
60 15
61 15
62 15
63 15
64 15
65 15
<<<sep_out_sample>>>
cmpb   $0x20,(%rdi)
jne    10e6 <taru_otoumax+0xe>
add    $0x1,%rdi
cmpb   $0x20,(%rdi)
je     10dd <taru_otoumax+0x5>
movzbl (%rdi),%eax
lea    -0x30(%rax),%edx
cmp    $0x7,%dl
ja     1110 <taru_otoumax+0x38>
mov    $0x0,%edx
add    $0x1,%rdi
movsbq %al,%rax
lea    -0x30(%rax,%rdx,8),%rdx
movzbl (%rdi),%eax
lea    -0x30(%rax),%ecx
cmp    $0x7,%cl
jbe    10f6 <taru_otoumax+0x1e>
jmp    1115 <taru_otoumax+0x3d>
mov    $0x0,%edx
cmpb   $0x20,(%rdi)
jne    1123 <taru_otoumax+0x4b>
add    $0x1,%rdi
cmpb   $0x20,(%rdi)
je     111a <taru_otoumax+0x42>
mov    %rdx,(%rsi)
cmpb   $0x0,(%rdi)
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
taru_otoumax (char * s, uintmax_t *n)
{
  uintmax_t val = 0;
  while (*s == ' ')
    ++s;
  while (*s >= '0' && *s <= '7')
    val = 8 * val + *s++ - '0';
  while (*s == ' ')
    ++s;
  *n = val;
  return *s == '\0';
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 9
23 8
24 8
25 10
26 11
27 11
28 11
29 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
callq  e <filter_destroy+0xe>
mov    %rax,%rbx
testb  $0x1,0x11(%rbp)
jne    2a <filter_destroy+0x2a>
mov    (%rax),%rdi
callq  1f <filter_destroy+0x1f>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  2a <filter_destroy+0x2a>
mov    0x40(%rbx),%rax
test   %rax,%rax
je     38 <filter_destroy+0x38>
mov    %rbx,%rdi
callq  *%rax
cmpq   $0x0,0x10(%rbx)
je     4b <filter_destroy+0x4b>
lea    0x10(%rbx),%rdi
mov    %rbx,%rsi
callq  4b <filter_destroy+0x4b>
mov    %rbx,%rdi
callq  53 <filter_destroy+0x53>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
filter_destroy (mu_stream_t stream)
{
  mu_filter_t filter = mu_stream_get_owner (stream);
  if (!(stream->flags & 0x00000100))
    mu_stream_destroy (&filter->stream, mu_stream_get_owner (filter->stream));
  if (filter->_destroy)
    filter->_destroy (filter);
  if (filter->property)
    mu_property_destroy (&(filter->property), filter);
  free (filter);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 8
20 8
21 9
22 9
23 9
24 10
25 10
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x20,0x240(%rdi)
je     9f <__log_set_lg_bsize+0x1e>
mov    $0x1,%edx
mov    $0x0,%esi
callq  9d <__log_set_lg_bsize+0x1c>
jmp    c7 <__log_set_lg_bsize+0x46>
mov    0x50(%rdi),%eax
shr    $0x2,%eax
cmp    %esi,%eax
jae    bf <__log_set_lg_bsize+0x3e>
mov    $0x0,%esi
mov    $0x0,%eax
callq  b8 <__log_set_lg_bsize+0x37>
mov    $0x16,%eax
jmp    c7 <__log_set_lg_bsize+0x46>
mov    %esi,0x4c(%rdi)
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__log_set_lg_bsize(dbenv, lg_bsize)
 DB_ENV *dbenv;
 u_int32_t lg_bsize;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_lg_bsize", 1));;
 if (lg_bsize > dbenv->lg_max / 4) {
  CDB___db_err(dbenv, "log buffer size must be <= log file size / 4");
  return (22);
 }
 dbenv->lg_bsize = lg_bsize;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 10
18 11
19 12
20 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rdi
mov    %rcx,%rbp
mov    $0x0,%edx
mov    %rcx,%rsi
callq  c90 <_cb_include_meta1+0x19>
mov    %eax,%ebx
test   %eax,%eax
jne    ca1 <_cb_include_meta1+0x2a>
mov    0x8(%rbp),%rdi
callq  c9f <_cb_include_meta1+0x28>
jmp    ca6 <_cb_include_meta1+0x2f>
mov    $0x1,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_cb_include_meta1 (enum grecs_callback_command cmd,
     grecs_locus_t *locus,
     void *varptr, grecs_value_t *value, void *cb_data)
{
  if (assert_grecs_value_type (locus, value, 0))
    return 1;
  meta1_config_parse (value->v.string);
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 8
15 6
16 9
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
text_buffer_init (struct text_buffer *buf)
{
  memset (buf, 0, sizeof *buf);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x14,%ecx
mov    $0x1,%edx
mov    $0xc8,%esi
mov    $0x0,%edi
callq  e7 <sheets_map_new+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sheets_map_new (void)
{
  return da_new ("Sheets map", 200,
   da_linear, 20,
   (da_print_func_t) pattern_rule_self_print, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
callq  b31 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 11de <terminal_new_terminal+0xb>
test   %rdx,%rdx
je     11ec <terminal_new_terminal+0x19>
mov    $0x0,%eax
callq  *%rdx
jmp    11f5 <terminal_new_terminal+0x22>
nopl   0x0(%rax)
callq  11f5 <terminal_new_terminal+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_new_terminal (char *terminal_name)
{
  if (terminal_new_terminal_hook)
    (*terminal_new_terminal_hook) (terminal_name);
  else
    {
      terminal_initialize_terminal (terminal_name);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 7
10 9
11 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  778 <seek_warn_details+0x23>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 781 <seek_warn_details+0x2c>
test   %rax,%rax
je     788 <seek_warn_details+0x33>
callq  *%rax
mov    %rsp,%rsi
mov    %r12,%rdi
callq  793 <seek_warn_details+0x3e>
mov    %rax,%r12
mov    %rbp,%rdi
callq  79e <seek_warn_details+0x49>
mov    %rax,%rbp
mov    $0x0,%edi
callq  7ab <seek_warn_details+0x56>
mov    %r12,%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  7c5 <seek_warn_details+0x70>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
je     7da <seek_warn_details+0x85>
callq  7da <seek_warn_details+0x85>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
seek_warn_details (char const *name, off_t offset)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot seek to %s"), quotearg_colon (name), umaxtostr (offset, buf)); } while (0)
                                  ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
testb  $0x20,0x240(%rdi)
je     2b <__txn_set_tx_timestamp+0x1e>
sub    $0x8,%rsp
mov    $0x1,%edx
mov    $0x0,%esi
callq  29 <__txn_set_tx_timestamp+0x1c>
jmp    3b <__txn_set_tx_timestamp+0x2e>
mov    (%rsi),%rax
mov    %rax,0x98(%rdi)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__txn_set_tx_timestamp(dbenv, timestamp)
 DB_ENV *dbenv;
 time_t *timestamp;
{
 if ((((dbenv))->flags & (0x00020))) return (CDB___db_mi_open(dbenv, "set_tx_timestamp", 1));;
 dbenv->tx_timestamp = *timestamp;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 5
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 8
13 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%rdi
mov    %rdx,%r12
mov    %rcx,%r13
cmp    $0x1,%rcx
je     3b1c <gsl_block_uchar_raw_fread+0x32>
mov    %rsi,%rbx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %rdx,%rdx
je     3ba2 <gsl_block_uchar_raw_fread+0xb8>
jmp    3b56 <gsl_block_uchar_raw_fread+0x6c>
mov    %r14,%rcx
mov    $0x1,%esi
callq  3b29 <gsl_block_uchar_raw_fread+0x3f>
mov    %rax,%rdx
mov    $0x0,%eax
cmp    %r12,%rdx
je     3ba2 <gsl_block_uchar_raw_fread+0xb8>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b4f <gsl_block_uchar_raw_fread+0x65>
mov    $0x5,%eax
jmp    3ba2 <gsl_block_uchar_raw_fread+0xb8>
mov    %r14,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  3b6b <gsl_block_uchar_raw_fread+0x81>
cmp    $0x1,%rax
je     3b91 <gsl_block_uchar_raw_fread+0xa7>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3b8a <gsl_block_uchar_raw_fread+0xa0>
mov    $0x5,%eax
jmp    3ba2 <gsl_block_uchar_raw_fread+0xb8>
add    $0x1,%rbp
add    %r13,%rbx
cmp    %r12,%rbp
jne    3b56 <gsl_block_uchar_raw_fread+0x6c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_block_uchar_raw_fread (FILE * stream, unsigned char * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (unsigned char), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (unsigned char), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 15
14 25
15 15
16 15
17 15
18 6
19 6
20 6
21 6
22 25
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 17
33 17
34 17
35 17
36 17
37 19
38 19
39 21
40 21
41 21
42 21
43 21
44 21
45 21
46 15
47 15
48 15
49 15
50 25
51 26
52 26
53 26
54 26
55 26
56 26
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0xf0(%rdi),%esi
lea    0x1(%rsi),%r12d
mov    %r12d,0xf0(%rdi)
add    $0x2,%esi
shl    $0x5,%esi
mov    0xf8(%rdi),%rdi
callq  88d <add_dir_context+0x2d>
mov    0xf8(%rbp),%rdi
callq  899 <add_dir_context+0x39>
movslq %r12d,%r12
shl    $0x5,%r12
add    %r12,%rax
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,0x8(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x18(%rbx),%rdx
mov    %rdx,0x18(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
add_dir_context(SWVARFS * swvarfs, struct dirContext * dirx)
{
 int i = ++(swvarfs->stackixM);
 unsigned char * s;
 struct dirContext *ds;
 strob_set_memlength(swvarfs->stackM,
    ((i+1) * sizeof(struct dirContext)));
 s = (unsigned char*)strob_str(swvarfs->stackM);
 ds = (struct dirContext*)(s + (i * sizeof(struct dirContext)));
 *ds = *dirx;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 7
10 6
11 6
12 6
13 8
14 8
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    (%rdi),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rdi)
movzbl (%rax),%r12d
sub    $0x1,%esi
je     23f <skip_hits+0x46>
mov    %esi,%r14d
mov    $0x8,%ebp
mov    $0x1,%ebx
movzbl %r12b,%r12d
test   %r12d,%ebx
je     238 <skip_hits+0x3f>
mov    %r14d,%esi
mov    %r13,%rdi
callq  238 <skip_hits+0x3f>
add    %ebx,%ebx
sub    $0x1,%ebp
jne    228 <skip_hits+0x2f>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
skip_hits (unsigned char const **hits, int level)
{
  int hit = *(*hits)++;
  int bit;
  if (--level == 0)
    return;
  for (bit = 1; bit & 0xff; bit <<= 1)
    {
      if (hit & bit)
 skip_hits (hits, level);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 5
12 5
13 5
14 5
15 5
16 3
17 9
18 9
19 10
20 10
21 10
22 7
23 7
24 7
25 12
26 12
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     a85 <mu_stream_get_property+0x3c>
mov    %rsi,%rbp
cmpq   $0x0,0x8(%rdi)
jne    a78 <mu_stream_get_property+0x2f>
lea    0x8(%rdi),%rdi
mov    %rbx,%rsi
callq  a72 <mu_stream_get_property+0x29>
mov    %eax,%edx
test   %edx,%edx
jne    a85 <mu_stream_get_property+0x3c>
mov    0x8(%rbx),%rax
mov    %rax,0x0(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_stream_get_property (mu_stream_t stream, mu_property_t *pp)
{
  if (stream == ((void *)0))
    return 22;
  if (stream->property == ((void *)0))
    {
      int status = mu_property_create (&(stream->property), stream);
      if (status != 0)
 return status;
    }
  *pp = stream->property;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 7
14 7
15 8
16 8
17 11
18 11
19 12
20 13
21 13
22 13
23 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     25 <gsl_spmatrix_cumsum+0x25>
mov    %rsi,%rax
lea    (%rsi,%rdi,8),%r8
mov    $0x0,%edx
mov    (%rax),%rcx
mov    %rdx,(%rax)
add    %rcx,%rdx
add    $0x8,%rax
cmp    %r8,%rax
jne    11 <gsl_spmatrix_cumsum+0x11>
jmp    2a <gsl_spmatrix_cumsum+0x2a>
mov    $0x0,%edx
mov    %rdx,(%rsi,%rdi,8)
retq   
<<<sep_in_sample>>>
gsl_spmatrix_cumsum(const size_t n, size_t *c)
{
  size_t sum = 0;
  size_t k;
  for (k = 0; k < n; ++k)
    {
      size_t ck = c[k];
      c[k] = sum;
      sum += ck;
    }
  c[n] = sum;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 3
6 7
7 8
8 9
9 9
10 5
11 5
12 5
13 3
14 11
15 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 236 <freeAllNavaids+0x7>
test   %rdi,%rdi
je     24f <freeAllNavaids+0x20>
push   %rbx
mov    (%rdi),%rbx
callq  244 <freeAllNavaids+0x15>
test   %rbx,%rbx
je     24e <freeAllNavaids+0x1f>
mov    %rbx,%rdi
jmp    23c <freeAllNavaids+0xd>
pop    %rbx
nop
repz retq 
<<<sep_in_sample>>>
freeAllNavaids (void)
{
 navaid_t *n = test_navaid, *p;
 while (n) {
  p = n;
  n = n->next;
  free (p);
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 2
5 6
6 7
7 4
8 4
9 6
10 6
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %edx,%r15d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 9de9 <ca_pe_hdy+0x2a>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  9df5 <ca_pe_hdy+0x36>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
mov    %r14d,%r9d
mov    %r13,%r8
mov    %ebx,%ecx
mov    %r15d,%edx
mov    %r12d,%esi
mov    %rbp,%rdi
callq  0 <ca_base_hdy>
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %ebx,%edx
mov    $0x8,%esi
mov    $0x1,%edi
callq  9e2e <ca_pe_hdy+0x6f>
mov    %eax,%r15d
mov    0x0(%rip),%rax        # 9e38 <ca_pe_hdy+0x79>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 9e44 <ca_pe_hdy+0x85>
callq  9e49 <ca_pe_hdy+0x8a>
mov    0x70(%rsp),%edx
mov    %edx,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0x8,(%rsp)
mov    %r15d,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  9e82 <ca_pe_hdy+0xc3>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
ca_pe_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "CA_PE";
  ca_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  ca_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (1, 8, year, 1, (0==0));
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "*", day, 8, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 11
15 12
16 12
17 12
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 17
52 17
53 17
54 17
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  109 <is_punct_mbchar+0x9>
movzbl (%rbx),%edx
mov    (%rax),%rax
movzwl (%rax,%rdx,2),%eax
shr    $0x2,%ax
and    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
is_punct_mbchar(const char *c)
{
    ((void) (0));
 return ((*__ctype_b_loc ())[(int) (((unsigned char)*c))] & (unsigned short int) _ISpunct);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1536 <gsl_matrix_long_isnull+0x60>
lea    0x0(,%rax,8),%r10
mov    $0x0,%esi
mov    $0x0,%r9d
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
jmp    152f <gsl_matrix_long_isnull+0x59>
mov    $0x0,%eax
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdq (%rcx,%rax,8),%xmm0
ucomisd %xmm1,%xmm0
jp     153c <gsl_matrix_long_isnull+0x66>
ucomisd %xmm2,%xmm0
je     1548 <gsl_matrix_long_isnull+0x72>
jmp    153c <gsl_matrix_long_isnull+0x66>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     1542 <gsl_matrix_long_isnull+0x6c>
test   %rdx,%rdx
jne    1503 <gsl_matrix_long_isnull+0x2d>
jmp    1523 <gsl_matrix_long_isnull+0x4d>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rdx,%rax
jne    150f <gsl_matrix_long_isnull+0x39>
jmp    1523 <gsl_matrix_long_isnull+0x4d>
<<<sep_in_sample>>>
gsl_matrix_long_isnull (const gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 20
29 20
30 15
31 15
32 20
33 20
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     fa <osip_uri_set_username+0x9>
mov    %rsi,0x8(%rdi)
repz retq 
<<<sep_in_sample>>>
osip_uri_set_username (osip_uri_t * url, char *username)
{
  if (url == ((void *)0))
    return;
  url->username = username;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
<<<sep_out_sample>>>
test   %edi,%edi
je     1fc <print_spaces+0x17>
push   %rbx
mov    %edi,%ebx
mov    $0x20,%edi
callq  1f6 <print_spaces+0x11>
sub    $0x1,%ebx
jne    1ec <print_spaces+0x7>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
print_spaces (unsigned int n)
{
  while (n-- > 0)
    putchar (' ');
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 4
6 4
7 3
8 3
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  6a7 <gsl_sort_vector_float_largest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_float_largest (float * dest, const size_t k,
                                    const gsl_vector_float * v)
{
  return gsl_sort_float_largest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
movsd  %xmm0,0x18(%rsp)
mov    %rdx,%r12
mov    %rcx,%r15
mov    0x30(%rsi),%r14
mov    0x20(%rsi),%r13
mov    0x28(%rsi),%rbx
movl   $0x3,0x14(%rsp)
addsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
mov    0x18(%r15),%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
movsd  0x8(%rsp),%xmm0
callq  *(%r15)
test   %eax,%eax
jne    af <gear2_step+0xaf>
test   %r12,%r12
je     a3 <gear2_step+0xa3>
movsd  0x18(%rsp),%xmm3
movapd %xmm3,%xmm2
addsd  %xmm3,%xmm2
mov    $0x0,%eax
movsd  (%r14,%rax,8),%xmm0
mulsd  0x0(%rip),%xmm0        # 78 <gear2_step+0x78>
subsd  0x0(%r13,%rax,8),%xmm0
movapd %xmm2,%xmm1
mulsd  (%rbx,%rax,8),%xmm1
addsd  %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 94 <gear2_step+0x94>
movsd  %xmm0,0x0(%rbp,%rax,8)
add    $0x1,%rax
cmp    %r12,%rax
jne    6a <gear2_step+0x6a>
subl   $0x1,0x14(%rsp)
jne    3b <gear2_step+0x3b>
mov    $0x0,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gear2_step (double *y, gear2_state_t * state,
            const double h, const double t,
            const size_t dim, const gsl_odeiv_system * sys)
{
  const int iter_steps = 3;
  int nu;
  size_t i;
  double *y0 = state->y0;
  double *yim1 = state->yim1;
  double *k = state->k;
  for (nu = 0; nu < iter_steps; nu++)
    {
      int s = (*((sys)->function))(t + h,y,k,(sys)->params);
      if (s != GSL_SUCCESS)
        {
          return s;
        }
      for (i = 0; i < dim; i++)
        {
          y[i] = ((4.0 * y0[i] - yim1[i]) + 2.0 * h * k[i]) / 3.0;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 8
13 9
14 10
15 10
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 14
24 14
25 18
26 18
27 20
28 20
29 20
30 20
31 20
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 18
40 18
41 18
42 11
43 11
44 23
45 24
46 24
47 24
48 24
49 24
50 24
51 24
52 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  682 <gsl_linalg_mcholesky_solve+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_linalg_mcholesky_solve(const gsl_matrix * LDLT,
                           const gsl_permutation * p,
                           const gsl_vector * b,
                           gsl_vector * x)
{
  int status = gsl_linalg_pcholesky_solve(LDLT, p, b, x);
  return status;
}
<<<sep_in_sample>>>
1 5
2 6
3 8
4 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%r10
mov    (%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %r10,%rdx
callq  *0x18(%rax)
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_step_apply (gsl_odeiv2_step * s,
                       double t,
                       double h,
                       double y[],
                       double yerr[],
                       const double dydt_in[],
                       double dydt_out[], const gsl_odeiv2_system * dydt)
{
  return s->type->apply (s->state, s->dimension, t, h, y, yerr, dydt_in,
                         dydt_out, dydt);
}
<<<sep_in_sample>>>
1 8
2 8
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 11
13 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %esi,0xc(%rsp)
mov    0x0(%rip),%r13        # 53c <find_env+0x19>
test   %r13,%r13
je     5a5 <find_env+0x82>
mov    %rdi,%r15
mov    $0x0,%esi
callq  54e <find_env+0x2b>
mov    0x0(%r13),%rbx
test   %rbx,%rbx
je     5aa <find_env+0x87>
mov    $0x0,%ebp
movslq %eax,%r12
mov    $0x0,%esi
mov    %rbx,%rdi
callq  56c <find_env+0x49>
cmp    %rax,%r12
jne    593 <find_env+0x70>
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %r15,%rdi
callq  57f <find_env+0x5c>
test   %eax,%eax
jne    593 <find_env+0x70>
cmpl   $0x0,0xc(%rsp)
lea    0x1(%rbx,%r12,1),%rax
cmovne %rax,%rbx
jmp    5aa <find_env+0x87>
add    $0x1,%ebp
movslq %ebp,%rax
mov    0x0(%r13,%rax,8),%rbx
test   %rbx,%rbx
jne    55f <find_env+0x3c>
jmp    5aa <find_env+0x87>
mov    $0x0,%ebx
mov    %rbx,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
find_env (const char *name, int val)
{
  if (environ)
    {
      int nlen = strcspn (name, "+=");
      int i;
      for (i = 0; environ[i]; i++)
 {
   size_t elen = strcspn (environ[i], "=");
   if (elen == nlen && memcmp (name, environ[i], nlen) == 0)
     return val ? environ[i] + elen + 1 : environ[i];
 }
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 5
14 5
15 7
16 7
17 7
18 7
19 10
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 7
36 7
37 7
38 7
39 7
40 7
41 14
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 15
<<<sep_out_sample>>>
test   %rsi,%rsi
je     10ac <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jae    10b2 <_argp_input+0x3e>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
jmp    1098 <_argp_input+0x24>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
mov    0x30(%rax),%rax
retq   
add    $0x48,%rax
cmp    %rdx,%rax
jb     1092 <_argp_input+0x1e>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
        if (group->argp == argp)
          return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 7
16 7
17 7
18 11
19 11
20 11
21 11
22 11
23 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 35b <write_rest+0xb>
mov    $0xc,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  36f <write_rest+0x1f>
mov    0x0(%rip),%rcx        # 376 <write_rest+0x26>
mov    $0x2e,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  38a <write_rest+0x3a>
mov    0x0(%rip),%rcx        # 391 <write_rest+0x41>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3a5 <write_rest+0x55>
mov    0x0(%rip),%rcx        # 3ac <write_rest+0x5c>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3c0 <write_rest+0x70>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
write_rest()
{
 (void) fprintf(fout, "\tsvc_run();\n");
  (void) fprintf(fout, "\t(void)fprintf(stderr, \"svc_run returned\\n\");\n");
 (void) fprintf(fout, "\texit(1);\n");
 (void) fprintf(fout, "}\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 7
23 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1081 <name_term+0xb>
callq  1086 <name_term+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
name_term (void)
{
  free (name_buffer);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     12 <gsasl_mechanism_name+0x12>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     18 <gsasl_mechanism_name+0x18>
mov    (%rax),%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_mechanism_name (Gsasl_session * sctx)
{
  if (!sctx || !sctx->mech)
    return ((void *)0);
  return sctx->mech->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 4
9 4
10 4
11 6
<<<sep_out_sample>>>
movzbl (%rdi),%eax
test   %al,%al
je     66b <uhash+0x27>
mov    $0x0,%ecx
mov    %ecx,%edx
shl    $0x5,%edx
sub    %ecx,%edx
mov    %edx,%ecx
movsbl %al,%eax
add    %eax,%ecx
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
jne    650 <uhash+0xc>
jmp    670 <uhash+0x2c>
mov    $0x0,%ecx
mov    $0x446f8657,%edx
mov    %ecx,%eax
mul    %edx
mov    %ecx,%eax
sub    %edx,%eax
shr    %eax
add    %edx,%eax
shr    $0x6,%eax
imul   $0x65,%eax,%eax
sub    %eax,%ecx
mov    %ecx,%eax
retq   
<<<sep_in_sample>>>
uhash(const char *str)
{
   unsigned hashval;
   for (hashval = 0; *str; str++)
      hashval = *str + 31 * hashval;
   return (hashval % 101);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 4
12 4
13 4
14 4
15 4
16 4
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 7
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    $0x0,%ecx
callq  15f1 <gsl_multifit_linear_genform2+0x2c>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_linear_genform2 (const gsl_matrix * LQR,
                              const gsl_vector * Ltau,
                              const gsl_matrix * X,
                              const gsl_vector * y,
                              const gsl_vector * cs,
                              const gsl_matrix * M,
                              gsl_vector * c,
                              gsl_multifit_linear_workspace * work)
{
  int status;
  status = gsl_multifit_linear_wgenform2(LQR, Ltau, X, ((void *)0), y, cs, M, c, work);
  return status;
}
<<<sep_in_sample>>>
1 9
2 11
3 11
4 11
5 11
6 11
7 11
8 11
9 11
10 11
11 13
12 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rdi
callq  455 <xformat_set_name+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_set_name (XFORMAT * xux, char *name)
{
 ;
        ahs_set_name(xux->ahsM, name);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x40,%ecx
mov    $0x8,%esi
callq  550 <nettle_arctwo64_set_key+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_arctwo64_set_key (struct arctwo_ctx *ctx, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, 8, key, 64);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # f63 <quotearg_free+0xd>
cmpl   $0x1,0x0(%rip)        # f6a <quotearg_free+0x14>
jbe    f8c <quotearg_free+0x36>
mov    $0x1,%ebx
mov    %ebx,%eax
shl    $0x4,%rax
mov    0x8(%rbp,%rax,1),%rdi
callq  f81 <quotearg_free+0x2b>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # f8a <quotearg_free+0x34>
ja     f71 <quotearg_free+0x1b>
mov    0x8(%rbp),%rdi
cmp    $0x0,%rdi
je     fb4 <quotearg_free+0x5e>
callq  f9e <quotearg_free+0x48>
movq   $0x100,0x0(%rip)        # fa9 <quotearg_free+0x53>
movq   $0x0,0x0(%rip)        # fb4 <quotearg_free+0x5e>
cmp    $0x0,%rbp
je     fd0 <quotearg_free+0x7a>
mov    %rbp,%rdi
callq  fc5 <quotearg_free+0x6f>
movq   $0x0,0x0(%rip)        # fd0 <quotearg_free+0x7a>
movl   $0x1,0x0(%rip)        # fda <quotearg_free+0x84>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 5
13 5
14 5
15 7
16 7
17 7
18 9
19 10
20 11
21 13
22 13
23 15
24 15
25 16
26 18
27 19
28 19
29 19
30 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     bbe <path_dot_or_dotdot+0x36>
mov    $0x0,%eax
cmpb   $0x2e,(%rdi)
jne    bc9 <path_dot_or_dotdot+0x41>
movzbl 0x1(%rdi),%edx
test   %dl,%dl
je     bc4 <path_dot_or_dotdot+0x3c>
cmp    $0x2f,%dl
je     bc4 <path_dot_or_dotdot+0x3c>
cmp    $0x2e,%dl
jne    bc9 <path_dot_or_dotdot+0x41>
movzbl 0x2(%rdi),%edx
test   %dl,%dl
sete   %cl
cmp    $0x2f,%dl
sete   %al
or     %ecx,%eax
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
repz retq 
<<<sep_in_sample>>>
path_dot_or_dotdot (string)
     const char *string;
{
  if (string == 0 || *string == '\0' || *string != '.')
    return (0);
  if ((((string[1]) == '/') || (string[1]) == 0) || (string[1] == '.' && (((string[2]) == '/') || (string[2]) == 0)))
    return (1);
  return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 5
22 5
23 7
24 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 3da <yyrestart+0x10>
test   %rax,%rax
je     3ed <yyrestart+0x23>
mov    0x0(%rip),%rdx        # 3e6 <yyrestart+0x1c>
cmpq   $0x0,(%rax,%rdx,8)
jne    42a <yyrestart+0x60>
callq  145 <yyensure_buffer_stack>
mov    0x0(%rip),%rax        # 3f9 <yyrestart+0x2f>
mov    0x0(%rip),%rdx        # 400 <yyrestart+0x36>
lea    (%rax,%rdx,8),%rbp
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 410 <yyrestart+0x46>
callq  415 <yyrestart+0x4b>
mov    %rax,0x0(%rbp)
mov    0x0(%rip),%rax        # 420 <yyrestart+0x56>
mov    $0x0,%edi
test   %rax,%rax
je     435 <yyrestart+0x6b>
mov    0x0(%rip),%rdx        # 431 <yyrestart+0x67>
mov    (%rax,%rdx,8),%rdi
mov    %rbx,%rsi
callq  2dc <yy_init_buffer>
callq  d7 <yy_load_buffer_state>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
yyrestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        yyensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            yy_create_buffer(yyin,16384 );
 }
 yy_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %ecx,%r12d
mov    %r8,%r13
mov    %r9d,%r14d
mov    0x70(%rsp),%r15d
movq   $0x0,0x0(%rip)        # 6294 <us_mo_hdy+0x2c>
movl   $0x0,0x0(%rip)        # 629e <us_mo_hdy+0x36>
mov    %r15d,(%rsp)
callq  62a7 <us_mo_hdy+0x3f>
mov    0x0(%rip),%rax        # 62ae <us_mo_hdy+0x46>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 62ba <us_mo_hdy+0x52>
callq  62bf <us_mo_hdy+0x57>
mov    %r15d,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
movl   $0x2,(%rsp)
mov    $0xc,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    (%rbx),%edi
callq  62f7 <us_mo_hdy+0x8f>
mov    0x0(%rip),%rax        # 62fe <us_mo_hdy+0x96>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 630a <us_mo_hdy+0xa2>
callq  630f <us_mo_hdy+0xa7>
mov    %r15d,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
movl   $0x5,(%rsp)
mov    $0x8,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    (%rbx),%edi
callq  6347 <us_mo_hdy+0xdf>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
us_mo_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_MO";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected,
    gettext(hd_text[221].ht_text), ptr_cc_id, "+",
    12, 2, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[540].ht_text), ptr_cc_id,
    "+", 8, 5, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 10
15 11
16 12
17 12
18 13
19 13
20 14
21 14
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 16
50 18
51 18
52 18
53 18
54 18
55 18
56 18
57 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 86be <helpmsg+0xb>
mov    (%rax),%rdx
lea    0x0(%rip),%rsi        # 86c8 <helpmsg+0x15>
mov    0x0(%rip),%rax        # 86cf <helpmsg+0x1c>
mov    (%rax),%rdi
mov    $0x0,%eax
callq  86dc <helpmsg+0x29>
mov    $0x1,%edi
callq  86e6 <printversion>
<<<sep_in_sample>>>
helpmsg()
{
  fprintf(stderr,"\nTry '%s --help' for more information.\n",progname);
  exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
test   %edi,%edi
je     278 <gsasl_randomize+0x18>
mov    %rdx,%rsi
mov    %rax,%rdi
callq  276 <gsasl_randomize+0x16>
jmp    283 <gsasl_randomize+0x23>
mov    %rdx,%rsi
mov    %rax,%rdi
callq  283 <gsasl_randomize+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_randomize (int strong, char *data, size_t datalen)
{
  if (strong)
    return gsasl_random (data, datalen);
  return gsasl_nonce (data, datalen);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  871 <cmd_comp+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cmd_comp(const void *a, void *b)
{
    const struct dicod_command *ca = a;
    const struct dicod_command *cb = b;
    return c_strcasecmp (ca->keyword, cb->keyword);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%r8
callq  1523 <quotearg_n_custom+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n_custom (int n, char const *left_quote,
                   char const *right_quote, char const *arg)
{
  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,
                                ((size_t) -1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
gc_cipher_decrypt_inline (gc_cipher_handle handle, size_t len, char *data)
{
  _gc_cipher_ctx *ctx = handle;
  switch (ctx->alg)
    {
    default:
      return GC_INVALID_CIPHER;
    }
  return GC_OK;
}
<<<sep_in_sample>>>
1 10
2 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1a32 <smapget_debug+0x6>
retq   
<<<sep_in_sample>>>
smapget_debug (void)
{
        return smap_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rdx,%r10
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %r10,%rcx
mov    %r9,%rdi
callq  133 <strtotok+0x2d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strtotok (struct tokendef *tab, const char *str, int *pres)
{
  return strtotok_len (tab, str, strlen (str), pres);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1a4f <gsl_sf_cos+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1a75 <gsl_sf_cos+0x32>
mov    %eax,%ecx
mov    $0x2db,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a6e <gsl_sf_cos+0x2b>
movsd  (%rsp),%xmm0
jmp    1a75 <gsl_sf_cos+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_cos(const double x)
{
  gsl_sf_result result; int status = gsl_sf_cos_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_cos_e(x, &result)", "trig.c", 731, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # b9f <dump_dbpath+0x15>
mov    $0x0,%eax
callq  ba9 <dump_dbpath+0x1f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # bba <dump_dbpath+0x30>
mov    $0x0,%eax
callq  bc4 <dump_dbpath+0x3a>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # bd5 <dump_dbpath+0x4b>
mov    $0x0,%eax
callq  bdf <dump_dbpath+0x55>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # bf0 <dump_dbpath+0x66>
mov    $0x0,%eax
callq  bfa <dump_dbpath+0x70>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dump_dbpath(void)
{
 fprintf(stderr, "db path: %s\n", dbpath);
 fprintf(stderr, "root path: %s\n", root);
 fprintf(stderr, "current directory: %s\n", cwd);
 fprintf(stderr, "nearbase: %s\n", nearbase);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 7
23 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpq   $0x0,0x0(%rip)        # 86 <shell_quote_copy+0x14>
jne    92 <shell_quote_copy+0x20>
mov    $0x0,%eax
callq  0 <init_sh_quoting_options>
mov    $0xffffffffffffffff,%rsi
mov    %rbp,%rdi
mov    $0x0,%eax
mov    %rsi,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
add    %rsi,%rcx
mov    0x0(%rip),%r8        # b3 <shell_quote_copy+0x41>
mov    %rbp,%rdx
mov    %rbx,%rdi
callq  be <shell_quote_copy+0x4c>
add    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
shell_quote_copy (char *p, const char *string)
{
  if (sh_quoting_options == ((void *)0))
    init_sh_quoting_options ();
  return p + quotearg_buffer (p, (size_t)(-1), string, strlen (string),
                              sh_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 7
23 7
24 7
25 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 64d <skip_whitespace+0xd>
jne    65c <skip_whitespace+0x1c>
mov    %rdi,%rbx
callq  657 <skip_whitespace+0x17>
mov    %rax,%rbp
jmp    677 <skip_whitespace+0x37>
mov    $0x1,%esi
mov    $0x0,%edi
callq  66b <skip_whitespace+0x2b>
mov    0x8(%rbx),%rdi
callq  674 <skip_whitespace+0x34>
mov    %eax,0x14(%rbx)
movslq 0x14(%rbx),%rcx
mov    0x0(%rbp),%rdx
testb  $0x20,0x1(%rdx,%rcx,2)
jne    66b <skip_whitespace+0x2b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
skip_whitespace (SIDE * side)
{
  if (interrupted)
    longjmp (signal_label, 1);
  while (((*__ctype_b_loc ())[(int) ((side->character))] & (unsigned short int) _ISspace))
    side->character = _IO_getc (side->file);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 5
8 5
9 5
10 4
11 4
12 4
13 6
14 6
15 6
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x46,%edi
callq  1851 <changeFormWidth+0x10>
mov    %rax,%rbx
mov    $0x5,%edi
callq  185e <changeFormWidth+0x1d>
mov    %rax,%rbp
mov    0x0(%rip),%edx        # 1867 <changeFormWidth+0x26>
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  1879 <changeFormWidth+0x38>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rdx
movabs $0x656e207265746e45,%rax
mov    %rax,(%rdx)
movabs $0x2068746469772077,%rax
mov    %rax,0x8(%rdx)
movabs $0x204c45434e414328,%rax
mov    %rax,0x10(%rdx)
movabs $0x6961746572206f74,%rax
mov    %rax,0x18(%rdx)
movabs $0x697720646c6f206e,%rax
mov    %rax,0x20(%rdx)
movl   $0x29687464,0x28(%rdx)
movw   $0x3a,0x2c(%rdx)
mov    0x0(%rip),%edx        # 18ea <changeFormWidth+0xa9>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  18fc <changeFormWidth+0xbb>
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  190c <changeFormWidth+0xcb>
mov    %rbx,%rdi
callq  1914 <changeFormWidth+0xd3>
mov    %rbp,%rdi
callq  191c <changeFormWidth+0xdb>
cmpb   $0x0,0x0(%rip)        # 1923 <changeFormWidth+0xe2>
je     1935 <changeFormWidth+0xf4>
mov    $0x0,%edi
callq  192f <changeFormWidth+0xee>
mov    %eax,0x0(%rip)        # 1935 <changeFormWidth+0xf4>
movl   $0x3,0x0(%rip)        # 193f <changeFormWidth+0xfe>
mov    0x0(%rip),%eax        # 1945 <changeFormWidth+0x104>
lea    -0x1(%rax),%edx
mov    $0x2,%r9d
mov    $0x0,%r8d
mov    0x0(%rip),%ecx        # 195a <changeFormWidth+0x119>
mov    $0x1,%esi
mov    $0x2,%edi
callq  1969 <changeFormWidth+0x128>
mov    $0x0,%eax
callq  1973 <changeFormWidth+0x132>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
changeFormWidth()
{
   char *msg = (char *) malloc(70);
   char *fw = (char *) malloc(5);
   sprintf(msg, "Old form width is: %d\n", FORM_WIDTH);
   strcat(msg, "Enter new width (CANCEL to retain old width):\0");
   sprintf(fw, "%d", FORM_WIDTH);
   inputBoxI(msg, fw, "Change form width");
   free(msg);
   free(fw);
   if(strlen(input))
     FORM_WIDTH = atoi(input);
   FILE_STATE = MODIFIED;
   drawBox(2, 1, SCREEN_H-1, SCREEN_W, " FOG: The console Form Designer ", 2);
   drawToolBox();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 7
34 7
35 7
36 7
37 7
38 8
39 8
40 8
41 8
42 9
43 9
44 10
45 10
46 11
47 11
48 12
49 12
50 12
51 13
52 14
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 15
61 15
62 16
63 16
64 16
65 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm3
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm3,%xmm2
mulsd  %xmm1,%xmm2
divsd  %xmm0,%xmm2
addsd  %xmm3,%xmm2
movapd %xmm2,%xmm4
movsd  %xmm2,0x8(%rsp)
movsd  0x0(%rip),%xmm2        # 1ac0 <BinomialBetaRandom+0x32>
ucomisd %xmm4,%xmm2
ja     1ae3 <BinomialBetaRandom+0x55>
movapd %xmm4,%xmm0
mov    $0x0,%edi
mov    $0x1,%eax
callq  1ad9 <BinomialBetaRandom+0x4b>
mov    $0x0,%edi
callq  1ae3 <BinomialBetaRandom+0x55>
movsd  0x0(%rip),%xmm3        # 1aeb <BinomialBetaRandom+0x5d>
xorpd  %xmm2,%xmm2
callq  1af4 <BinomialBetaRandom+0x66>
cvttsd2si 0x8(%rsp),%rdi
callq  1b00 <BinomialBetaRandom+0x72>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
BinomialBetaRandom (double Expectation, double alpha, double beta)
{
  double dTmp = Expectation + Expectation * beta / alpha;
  if (dTmp < 9223372036854775807L)
    return BinomialRandom (BetaRandom (alpha, beta, 0, 1), (long) dTmp);
  else {
      printf("BinomialBetaRandom: N (= %g) too large - Exiting...", dTmp);
      exit (0);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 7
15 7
16 7
17 7
18 8
19 8
20 5
21 5
22 5
23 5
24 5
25 10
26 10
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
mov    $0xffffffff,%eax
cmpl   $0x0,0x0(%rip)        # 146 <ttonechar+0x20>
je     1b2 <ttonechar+0x8c>
mov    0x0(%rip),%rax        # 14f <ttonechar+0x29>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 15a <ttonechar+0x34>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 166 <ttonechar+0x40>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 172 <ttonechar+0x4c>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 17e <ttonechar+0x58>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 18a <ttonechar+0x64>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 196 <ttonechar+0x70>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%eax        # 1a1 <ttonechar+0x7b>
mov    %eax,0x38(%rsp)
mov    %rsp,%rsi
mov    $0x0,%edi
callq  1b2 <ttonechar+0x8c>
mov    0x48(%rsp),%rdx
xor    %fs:0x28,%rdx
je     1c7 <ttonechar+0xa1>
callq  1c7 <ttonechar+0xa1>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
ttonechar ()
{
  struct termios tt;
  if (ttsaved == 0)
    return -1;
  tt = ttin;
  return (ttfd_onechar (0, &tt));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 8
28 8
29 8
30 8
31 8
32 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  1fb1 <savetty+0x13>
mov    0x0(%rip),%r10        # 1fb8 <savetty+0x1a>
mov    %r10,0x0(%rip)        # 1fbf <savetty+0x21>
mov    0x0(%rip),%rax        # 1fc6 <savetty+0x28>
mov    %rax,0x0(%rip)        # 1fcd <savetty+0x2f>
mov    0x0(%rip),%r9        # 1fd4 <savetty+0x36>
mov    %r9,0x0(%rip)        # 1fdb <savetty+0x3d>
mov    0x0(%rip),%r8        # 1fe2 <savetty+0x44>
mov    %r8,0x0(%rip)        # 1fe9 <savetty+0x4b>
mov    0x0(%rip),%rdi        # 1ff0 <savetty+0x52>
mov    %rdi,0x0(%rip)        # 1ff7 <savetty+0x59>
mov    0x0(%rip),%rsi        # 1ffe <savetty+0x60>
mov    %rsi,0x0(%rip)        # 2005 <savetty+0x67>
mov    0x0(%rip),%rcx        # 200c <savetty+0x6e>
mov    %rcx,0x0(%rip)        # 2013 <savetty+0x75>
mov    0x0(%rip),%edx        # 2019 <savetty+0x7b>
mov    %edx,0x0(%rip)        # 201f <savetty+0x81>
mov    %r10,0x0(%rip)        # 2026 <savetty+0x88>
mov    %rax,0x0(%rip)        # 202d <savetty+0x8f>
mov    %r9,0x0(%rip)        # 2034 <savetty+0x96>
mov    %r8,0x0(%rip)        # 203b <savetty+0x9d>
mov    %rdi,0x0(%rip)        # 2042 <savetty+0xa4>
mov    %rsi,0x0(%rip)        # 2049 <savetty+0xab>
mov    %rcx,0x0(%rip)        # 2050 <savetty+0xb2>
mov    %edx,0x0(%rip)        # 2056 <savetty+0xb8>
mov    %rax,%rcx
shr    $0x20,%rcx
mov    %rcx,%rdx
and    $0xfffffff4,%edx
mov    %edx,0x0(%rip)        # 2069 <savetty+0xcb>
movb   $0x1,0x0(%rip)        # 2070 <savetty+0xd2>
movb   $0x0,0x0(%rip)        # 2077 <savetty+0xd9>
mov    %rcx,%rax
or     $0xb,%eax
mov    %eax,0x0(%rip)        # 2083 <savetty+0xe5>
movb   $0x4,0x0(%rip)        # 208a <savetty+0xec>
movb   $0xff,0x0(%rip)        # 2091 <savetty+0xf3>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
savetty (void)
{
  tcgetattr (0, (&savemode));
  charmode = linemode = savemode;
  charmode.c_lflag &= ~(0000010 | 0000002 | 0000001);
  charmode.c_cc[6] = 1;
  charmode.c_cc[5] = 0;
  linemode.c_lflag |= (0000010 | 0000002 | 0000001);
  linemode.c_cc[4] = 'd' & 037;
  linemode.c_cc[11] = 0377;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 5
30 5
31 5
32 5
33 5
34 6
35 7
36 8
37 8
38 8
39 9
40 10
41 11
42 11
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
jne    5fe <hash_iterate_modify+0x13>
mov    0x10(%rdi),%rax
test   %rax,%rax
jne    604 <hash_iterate_modify+0x19>
jmp    626 <hash_iterate_modify+0x3b>
cmp    0x10(%rdi),%rax
je     62c <hash_iterate_modify+0x41>
mov    0x20(%rax),%rax
mov    %rax,(%rsi)
mov    0x8(%rax),%rsi
mov    %rsi,(%rdx)
mov    0x10(%rax),%rdx
mov    %rdx,(%rcx)
add    $0x18,%rax
mov    %rax,(%r8)
mov    $0x0,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
hash_iterate_modify (hash_table *htab, void **ptr,
                     const void **key, size_t *keylen,
                     void ***datap)
{
  hash_entry *curr;
  if (*ptr == ((void *)0))
    {
      if (htab->first == ((void *)0))
        return -1;
      curr = htab->first;
    }
  else
    {
      if (*ptr == htab->first)
        return -1;
      curr = (hash_entry *) *ptr;
    }
  curr = curr->next;
  *ptr = (void *) curr;
  *key = curr->key;
  *keylen = curr->keylen;
  *datap = &curr->data;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 8
5 8
6 8
7 8
8 14
9 14
10 18
11 19
12 20
13 20
14 21
15 21
16 22
17 22
18 23
19 23
20 9
21 9
22 15
23 24
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x98,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rsi,%rsi
je     2d81 <dap_name+0x19>
cmpb   $0x0,(%rsi)
jne    2d99 <dap_name+0x31>
movabs $0x6c756e2f7665642f,%rax
mov    %rax,(%rbx)
movw   $0x6c,0x8(%rbx)
jmpq   2e32 <dap_name+0xca>
mov    0x0(%rip),%rsi        # 2da0 <dap_name+0x38>
callq  2da5 <dap_name+0x3d>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  2db0 <dap_name+0x48>
test   %eax,%eax
jns    2ddb <dap_name+0x73>
mov    $0x1c0,%esi
mov    %rbx,%rdi
callq  2dc1 <dap_name+0x59>
test   %eax,%eax
jns    2e0c <dap_name+0xa4>
mov    0x0(%rip),%rdi        # 2dcc <dap_name+0x64>
callq  2dd1 <dap_name+0x69>
mov    $0x1,%edi
callq  2ddb <dap_name+0x73>
testb  $0x40,0x19(%rsp)
jne    2e0c <dap_name+0xa4>
mov    %rbx,%rcx
mov    0x0(%rip),%rdx        # 2dec <dap_name+0x84>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2df8 <dap_name+0x90>
mov    $0x0,%eax
callq  2e02 <dap_name+0x9a>
mov    $0x1,%edi
callq  2e0c <dap_name+0xa4>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbx,%rcx,1)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2e32 <dap_name+0xca>
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
dap_name(char dname[], char *fname)
{
  struct stat statbuf;
  if (!fname || !fname[0])
    {
      strcpy(dname, "/dev/null");
      return;
    }
  strcpy(dname, dap_setdir);
  if (stat(dname, &statbuf) < 0)
    {
      if (mkdir(dname, (mode_t) 0700) < 0)
 {
   perror(dap_dapname);
   exit(1);
 }
    }
  else if (!(statbuf.st_mode & 0040000))
    {
      fprintf(dap_err, "%s: non-directory file exists: %s\n", dap_dapname, dname);
      exit(1);
    }
  strcat(dname, "/");
  strcat(dname, fname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 9
15 9
16 10
17 10
18 10
19 10
20 10
21 12
22 12
23 12
24 12
25 12
26 14
27 14
28 15
29 15
30 18
31 18
32 20
33 20
34 20
35 20
36 20
37 20
38 21
39 21
40 23
41 23
42 23
43 23
44 23
45 23
46 24
47 24
48 24
49 25
50 25
51 25
52 25
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # bef <sv_globignore+0x7>
jne    bfe <sv_globignore+0x16>
sub    $0x8,%rsp
callq  bfa <sv_globignore+0x12>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
sv_globignore (name)
     char *name;
{
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 5
5 6
6 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
lea    0x58(%rdi),%r12
mov    %r12,%rdi
callq  98 <osip_message_get_alert_info+0x1c>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    b1 <osip_message_get_alert_info+0x35>
mov    %ebx,%esi
mov    %r12,%rdi
callq  ab <osip_message_get_alert_info+0x2f>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_alert_info (const osip_message_t * sip, int pos, osip_alert_info_t ** dest)
{
  osip_alert_info_t *alert_info;
  *dest = ((void *)0);
  if (osip_list_size (&sip->alert_infos) <= pos)
    return -1;
  alert_info = (osip_alert_info_t *) osip_list_get (&sip->alert_infos, pos);
  *dest = alert_info;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 6
11 5
12 5
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,0x8(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,(%rsp)
callq  0 <qagp>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_integration_qagp (const gsl_function *f,
                      double * pts, size_t npts,
                      double epsabs, double epsrel, size_t limit,
                      gsl_integration_workspace * workspace,
                      double * result, double * abserr)
{
  int status = qagp (f, pts, npts,
                     epsabs, epsrel, limit,
                     workspace,
                     result, abserr,
                     &gsl_integration_qk21) ;
  return status ;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 13
7 13
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm0
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_pow_9(const double x) { double x3 = x*x*x; return x3*x3*x3; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xa0,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %rsp,%rdi
callq  ae9 <md5_buffer+0x1c>
mov    %rsp,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  af7 <md5_buffer+0x2a>
mov    %rbx,%rsi
mov    %rsp,%rdi
callq  b02 <md5_buffer+0x35>
add    $0xa0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
md5_buffer (const char *buffer, size_t len, void *resblock)
{
  struct md5_ctx ctx;
  md5_init_ctx (&ctx);
  md5_process_bytes (buffer, len, &ctx);
  return md5_finish_ctx (&ctx, resblock);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # cb1 <checkaccesslist+0xd>
mov    0x170(%rdi),%rax
mov    0x18(%rax),%rbx
mov    $0x1,%ebp
test   %rbx,%rbx
je     d24 <checkaccesslist+0x80>
add    $0xe0,%rdi
callq  cd2 <checkaccesslist+0x2e>
mov    %eax,%ebp
test   %al,%al
jne    d24 <checkaccesslist+0x80>
mov    $0x0,%edi
callq  ce2 <checkaccesslist+0x3e>
mov    %eax,%ebp
test   %al,%al
jne    d24 <checkaccesslist+0x80>
mov    (%rbx),%rdi
callq  cf0 <checkaccesslist+0x4c>
mov    %eax,%ebp
test   %al,%al
jne    d24 <checkaccesslist+0x80>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    ce8 <checkaccesslist+0x44>
callq  d04 <checkaccesslist+0x60>
mov    0x0(%rip),%rdx        # d0b <checkaccesslist+0x67>
mov    0xd0(%rdx),%rdi
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  d24 <checkaccesslist+0x80>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
checkaccesslist (void)
{
  struct link *ls = ((top->repository. r)-> access);
  if (!ls || stat_mine_p (&(top->repository. stat)) || caller_login_p ("root"))
    return 1;
  for (; ls; ls = ls->next)
    if (caller_login_p (ls->entry))
      return 1;
  generic_error ((top->repository. filename), "user %s not on the access list", getcaller ());
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 5
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 7
21 7
22 7
23 7
24 7
25 6
26 6
27 6
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  0 <_print_word_list>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
command_print_word_list (list, separator)
     WORD_LIST *list;
     char *separator;
{
  _print_word_list (list, separator, cprintf);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
callq  1054 <input_data>
mov    %rax,%rbx
mov    $0xa,%edx
lea    0x8(%rsp),%rsi
mov    %rax,%rdi
callq  119f <ininteger+0x1f>
mov    0x8(%rsp),%rdx
cmpb   $0x0,(%rdx)
je     11bb <ininteger+0x3b>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  11bb <ininteger+0x3b>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
ininteger(int channel)
{
      int x;
      char *str, *ptr;
      str = input_data(channel);
      x = strtol(str, &ptr, 10);
      if (*ptr != '\0')
         fault("unable to convert `%s' to integer number", str);
      return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 10
17 10
18 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %edx,%r13d
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
movzbl (%rsi),%ebx
test   %bl,%bl
je     5c6 <wordsplit_quote_copy+0xfe>
cmp    $0x22,%bl
jne    510 <wordsplit_quote_copy+0x48>
movb   $0x5c,0x0(%rbp)
movzbl (%r12),%eax
mov    %al,0x1(%rbp)
lea    0x2(%rbp),%rbp
jmpq   5b5 <wordsplit_quote_copy+0xed>
cmp    $0x5c,%bl
je     536 <wordsplit_quote_copy+0x6e>
cmp    $0x9,%bl
je     536 <wordsplit_quote_copy+0x6e>
callq  51f <wordsplit_quote_copy+0x57>
movsbq %bl,%rdx
mov    (%rax),%rax
testb  $0x40,0x1(%rax,%rdx,2)
je     536 <wordsplit_quote_copy+0x6e>
mov    %bl,0x0(%rbp)
lea    0x1(%rbp),%rbp
jmp    5b5 <wordsplit_quote_copy+0xed>
test   %r13d,%r13d
je     56b <wordsplit_quote_copy+0xa3>
movzbl %bl,%ecx
mov    $0x0,%edx
mov    $0x4,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  555 <wordsplit_quote_copy+0x8d>
movzwl (%rsp),%eax
mov    %ax,0x0(%rbp)
movzbl 0x2(%rsp),%eax
mov    %al,0x2(%rbp)
add    $0x3,%rbp
jmp    5b5 <wordsplit_quote_copy+0xed>
movsbl %bl,%edi
callq  573 <wordsplit_quote_copy+0xab>
movb   $0x5c,0x0(%rbp)
cmp    $0xffffffff,%eax
je     585 <wordsplit_quote_copy+0xbd>
mov    %al,0x1(%rbp)
lea    0x2(%rbp),%rbp
jmp    5b5 <wordsplit_quote_copy+0xed>
movzbl (%r12),%ecx
mov    $0x0,%edx
mov    $0x4,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  5a1 <wordsplit_quote_copy+0xd9>
movzwl (%rsp),%eax
mov    %ax,0x1(%rbp)
movzbl 0x2(%rsp),%eax
mov    %al,0x3(%rbp)
add    $0x4,%rbp
add    $0x1,%r12
movzbl (%r12),%ebx
test   %bl,%bl
jne    4f6 <wordsplit_quote_copy+0x2e>
mov    0x8(%rsp),%rax
xor    %fs:0x28,%rax
je     5db <wordsplit_quote_copy+0x113>
callq  5db <wordsplit_quote_copy+0x113>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
wordsplit_quote_copy (char *dst, const char *src, int quote_hex)
{
  for (; *src; src++)
    {
      if (*src == '"')
 {
   *dst++ = '\\';
   *dst++ = *src;
 }
      else if (*src != '\t' && *src != '\\' && ((*__ctype_b_loc ())[(int) ((*src))] & (unsigned short int) _ISprint))
 *dst++ = *src;
      else
 {
   char tmp[4];
   if (quote_hex)
     {
       snprintf (tmp, sizeof tmp, "%%%02X", *(unsigned char*)src);
       memcpy (dst, tmp, 3);
       dst += 3;
     }
   else
     {
       int c = wordsplit_quote_char (*src);
       *dst++ = '\\';
       if (c != -1)
  *dst++ = c;
       else
  {
    snprintf (tmp, sizeof tmp, "%03o", *(unsigned char*)src);
    memcpy (dst, tmp, 3);
    dst += 3;
  }
     }
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 3
13 3
14 3
15 5
16 5
17 7
18 8
19 8
20 8
21 8
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 15
35 15
36 17
37 17
38 17
39 17
40 17
41 17
42 18
43 18
44 18
45 18
46 19
47 19
48 23
49 23
50 24
51 25
52 25
53 26
54 26
55 26
56 29
57 29
58 29
59 29
60 29
61 29
62 30
63 30
64 30
65 30
66 31
67 3
68 3
69 3
70 3
71 36
72 36
73 36
74 36
75 36
76 36
77 36
78 36
79 36
80 36
<<<sep_out_sample>>>
sub    $0x28,%rsp
movsd  %xmm0,0x10(%rsp)
movsd  %xmm1,0x18(%rsp)
movsd  %xmm2,0x8(%rsp)
xorpd  %xmm0,%xmm0
ucomisd %xmm2,%xmm0
jb     15a7 <lnDFNormal+0x34>
mov    $0x0,%edi
callq  159d <lnDFNormal+0x2a>
mov    $0x0,%edi
callq  15a7 <lnDFNormal+0x34>
movsd  0x8(%rsp),%xmm0
callq  15b2 <lnDFNormal+0x3f>
movsd  0x18(%rsp),%xmm1
subsd  0x10(%rsp),%xmm1
divsd  0x8(%rsp),%xmm1
movsd  0x0(%rip),%xmm2        # 15cc <lnDFNormal+0x59>
subsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
mulsd  %xmm1,%xmm1
mulsd  0x0(%rip),%xmm1        # 15e0 <lnDFNormal+0x6d>
subsd  %xmm1,%xmm0
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
lnDFNormal (double x, double mu, double sd)
{
  if (sd <= 0.0) {
    printf ("Error: negative or null SD in lnDFNormal\n");
    exit (0);
  }
  return ( -0.9189385332046 - log (sd) - 0.5 * pow ((mu - x)/sd, 2) );
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
test   %rcx,%rcx
je     117 <gsl_multiset_init_first+0x23>
mov    $0x0,%eax
mov    0x10(%rdi),%rdx
movq   $0x0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    102 <gsl_multiset_init_first+0xe>
repz retq 
<<<sep_in_sample>>>
gsl_multiset_init_first (gsl_multiset * c)
{
  const size_t k = c->k ;
  size_t i;
  for (i = 0; i < k; i++)
    {
      c->data[i] = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 7
6 7
7 5
8 5
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xb0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
                       const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x4(%rax),%edx
mov    0x0(,%rdx,4),%esi
test   %esi,%esi
je     4a <first+0x4a>
mov    0x10(%rax),%rdx
mov    0x8(%rax),%rcx
add    $0xf,%rcx
and    $0xfffffffffffffff8,%rcx
cmpq   $0x0,(%rdx)
jne    51 <first+0x51>
add    %rcx,%rdx
mov    $0x0,%eax
mov    %rcx,%r8
neg    %r8
jmp    41 <first+0x41>
add    %rcx,%rdx
cmpq   $0x0,(%rdx,%r8,1)
jne    56 <first+0x56>
add    $0x1,%eax
cmp    %esi,%eax
jne    37 <first+0x37>
jmp    56 <first+0x56>
mov    $0x0,%eax
jmp    56 <first+0x56>
mov    $0x0,%eax
mov    %eax,0xc(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
first (void *owner)
{
  struct assoc_iterator *itr = owner;
  mu_assoc_t assoc = itr->assoc;
  unsigned hash_max = hash_size[assoc->hash_num];
  unsigned i;
  for (i = 0; i < hash_max; i++)
    if ((((struct _mu_assoc_elem*) ((char*) ((assoc)->tab) + (((((assoc)->elsize + ((size_t)&((struct _mu_assoc_elem*)0)->data))) + ((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1) & ~(((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1)) * i)))->name)
      break;
  itr->index = i;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 7
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 10
28 12
29 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,0x8(%rsi)
ja     9a8 <gsl_matrix_complex_float_column+0x4b>
mov    $0x4,%ecx
mov    $0x33,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  980 <gsl_matrix_complex_float_column+0x23>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    9d1 <gsl_matrix_complex_float_column+0x74>
mov    0x18(%rsi),%rax
lea    (%rax,%rdx,8),%rdx
mov    0x10(%rsi),%rcx
mov    0x20(%rsi),%rax
mov    (%rsi),%rsi
mov    %rsi,(%rdi)
mov    %rcx,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_float_column (gsl_matrix_complex_float * m, const size_t j)
{
  _gsl_vector_complex_float_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex_float v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 2;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 12
19 13
20 16
21 16
22 16
23 16
24 16
25 16
26 18
27 18
28 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%eax
mov    %rsi,%rdi
mov    %eax,%esi
callq  ef7 <swextopt_is_option_false+0x10>
mov    %rax,%rdi
callq  eff <swextopt_is_option_false+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swextopt_is_option_false(enum eOpts nopt, struct extendedOptions * options)
{
 char * val;
 val = get_opta(options, nopt);
 return swextopt_is_value_false(val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
_stdio_stat(void *p_user_data)
{
  const _UserData *const ud = p_user_data;
  return ud->st_size;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r12d
cmp    $0x9,%edi
jbe    1b0 <optloc_save+0x17>
callq  1b0 <optloc_save+0x17>
mov    %rsi,%rbp
mov    0x8(%rsi),%rdi
test   %rdi,%rdi
je     1d3 <optloc_save+0x3a>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x20(%rcx),%rdi
jmp    1d8 <optloc_save+0x3f>
mov    $0x20,%edi
callq  1dd <optloc_save+0x44>
mov    %rax,%rbx
mov    0x8(%rbp),%rsi
test   %rsi,%rsi
je     1fb <optloc_save+0x62>
lea    0x20(%rax),%r13
mov    %r13,%rdi
callq  1f5 <optloc_save+0x5c>
mov    %r13,0x8(%rbx)
jmp    203 <optloc_save+0x6a>
movq   $0x0,0x8(%rax)
mov    0x0(%rbp),%eax
mov    %eax,(%rbx)
mov    0x10(%rbp),%rax
mov    %rax,0x10(%rbx)
mov    %r12d,%r12d
mov    0x0(,%r12,8),%rax
mov    %rax,0x18(%rbx)
mov    %rbx,0x0(,%r12,8)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
optloc_save (unsigned int id, struct option_locus *loc)
{
  struct option_locus *optloc;
  char *p;
  size_t s;
  if (id >= sizeof (option_class) / sizeof (option_class[0]))
    abort ();
  s = sizeof (*loc);
  if (loc->name)
    s += strlen (loc->name) + 1;
  optloc = xmalloc (s);
  if (loc->name)
    {
      p = (char*) optloc + sizeof (*loc);
      strcpy (p, loc->name);
      optloc->name = p;
    }
  else
    optloc->name = ((void *)0);
  optloc->source = loc->source;
  optloc->line = loc->line;
  optloc->prev = option_class[id];
  option_class[id] = optloc;
  return optloc->prev;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 7
10 7
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 10
19 10
20 8
21 11
22 11
23 12
24 12
25 12
26 14
27 15
28 15
29 16
30 16
31 19
32 20
33 20
34 21
35 21
36 22
37 22
38 22
39 23
40 25
41 25
42 25
43 25
44 25
45 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
and    $0x80000,%esi
cmp    $0x1,%esi
sbb    %esi,%esi
not    %esi
and    $0x406,%esi
mov    $0x3,%edx
mov    $0x0,%eax
callq  26 <dup_safer_flag+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer_flag (int fd, int flag)
{
  return rpl_fcntl (fd, (flag & 02000000) ? 1030 : 0,
                2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 147d <unexpected_EOF+0xb>
mov    0xd0(%rax),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  1493 <initdiffcmd>
<<<sep_in_sample>>>
unexpected_EOF (void)
{
  generic_fatal ((top->repository. filename), "unexpected EOF in diff output");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  225 <gsasl_client_finish+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_client_finish (Gsasl_session * sctx)
{
  gsasl_finish (sctx);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1a26 <gsl_complex_sech+0x9>
callq  1a2b <gsl_complex_sech+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_sech (gsl_complex a)
{
  gsl_complex z = gsl_complex_cosh (a);
  return gsl_complex_inverse (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movq   $0x0,(%rsp)
mov    0x18(%rdi),%rax
cmp    $0x40,%rsi
mov    $0x40,%edx
cmovbe %rsi,%rdx
mov    %rsp,%rsi
callq  *0x8(%rax)
mov    (%rsp),%rax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_urandomb_ui (gmp_randstate_ptr rstate, unsigned long bits)
{
  mp_limb_t a[1];
  a[0] = 0;
  do { gmp_randstate_ptr __rstate = (rstate); (*((gmp_randfnptr_t *) ((__rstate)->_mp_algdata._mp_lc))->randget_fn) (__rstate, a, ((bits) < ((8 * 8)) ? (bits) : ((8 * 8)))); } while (0);
  return a[0];
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6d <_gsasl_step64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_server_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  482 <gsl_stats_ushort_absdev+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  490 <gsl_stats_ushort_absdev+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_ushort_absdev (const unsigned short data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_ushort_mean(data, stride, n);
  return gsl_stats_ushort_absdev_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rsi
mov    0x28(%rdi),%rdi
callq  268 <open_archive_init+0x11>
mov    0x28(%rbx),%rdi
callq  271 <open_archive_init+0x1a>
mov    %eax,%esi
mov    %rbx,%rdi
callq  27b <open_archive_init+0x24>
mov    0x8(%rbx),%esi
mov    %rbx,%rdi
callq  286 <open_archive_init+0x2f>
mov    0x28(%rbx),%rdi
callq  28f <open_archive_init+0x38>
mov    %eax,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
open_archive_init(XFORMAT * xux)
{
 swvarfs_set_ahs(xux->swvarfsM, xux->ahsM);
 xformat_set_format(xux, swvarfs_get_format(xux->swvarfsM));
 xformat_set_output_format(xux, xux->format_codeM);
 xux->ifdM = swvarfs_fd(xux->swvarfsM);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movl   $0x1,0x0(%rip)        # 27a5 <yacc_parser_init+0xe>
mov    %rdi,0x0(%rip)        # 27ac <yacc_parser_init+0x15>
callq  27b1 <yacc_parser_init+0x1a>
movl   $0x1,0x0(%rip)        # 27bb <yacc_parser_init+0x24>
movl   $0x1,0x0(%rip)        # 27c5 <yacc_parser_init+0x2e>
movl   $0x0,0x0(%rip)        # 27cf <yacc_parser_init+0x38>
movl   $0x0,0x0(%rip)        # 27d9 <yacc_parser_init+0x42>
movl   $0x11,0x0(%rip)        # 27e3 <yacc_parser_init+0x4c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yacc_parser_init(FILE *ip)
{
 newline_terminate_string = 1;
 { c_in = ip; c_restart(c_in); lexcommon_lineno = 1; begin_line = 1; dest_column = 0; left_spaces = 0; }
 (yy_start) = 1 + 2 * 8;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x40,%rsp
mov    %edi,%ebx
mov    %rcx,%rbp
mov    %r8,%r12
mov    0x0(%rip),%rax        # 11ae <quotearg_n_custom_mem+0x17>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 11b9 <quotearg_n_custom_mem+0x22>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 11c5 <quotearg_n_custom_mem+0x2e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 11d1 <quotearg_n_custom_mem+0x3a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 11dd <quotearg_n_custom_mem+0x46>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 11e9 <quotearg_n_custom_mem+0x52>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 11f5 <quotearg_n_custom_mem+0x5e>
mov    %rax,0x30(%rsp)
mov    %rsp,%rdi
callq  1202 <quotearg_n_custom_mem+0x6b>
mov    %rsp,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  b66 <quotearg_n_options>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotearg_n_custom_mem (int n, char const *left_quote,
                       char const *right_quote,
                       char const *arg, size_t argsize)
{
  struct quoting_options o = default_quoting_options;
  set_custom_quoting (&o, left_quote, right_quote);
  return quotearg_n_options (n, arg, argsize, &o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
mov    %rdx,%r12
mov    %rcx,%rbp
mov    %edi,%esi
mov    %rbx,%rdi
callq  f9e <_cb_mode+0x1d>
mov    $0x1,%r8d
test   %eax,%eax
jne    1012 <_cb_mode+0x91>
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  fb8 <_cb_mode+0x37>
mov    %eax,%r13d
mov    $0x1,%r8d
test   %eax,%eax
jne    1012 <_cb_mode+0x91>
mov    0x8(%rbp),%rsi
lea    0xc(%rsp),%rdx
mov    $0x0,%edi
callq  fd8 <_cb_mode+0x57>
mov    %eax,%r8d
test   %eax,%eax
je     100a <_cb_mode+0x89>
mov    0x8(%rbp),%rbp
mov    $0x0,%edi
callq  fed <_cb_mode+0x6c>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  1005 <_cb_mode+0x84>
mov    %r13d,%r8d
jmp    1012 <_cb_mode+0x91>
mov    0xc(%rsp),%eax
mov    %eax,(%r12)
mov    %r8d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_cb_mode (enum grecs_callback_command cmd,
   grecs_locus_t *locus,
   void *varptr, grecs_value_t *value, void *cb_data)
{
  int res;
  if (assert_scalar_stmt (locus, cmd)
      || assert_grecs_value_type (locus, value, 0))
    return 1;
  if (strtotok (modetab, value->v.string, &res))
    grecs_error (locus, 0, gettext("%s: unrecognised mode"), value->v.string);
  else
    *(enum pies_comp_mode *) varptr = res;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 8
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 8
21 7
22 7
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 13
40 13
41 12
42 12
43 14
44 14
45 14
46 14
47 14
48 14
49 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
divsd  %xmm1,%xmm0
movapd %xmm2,%xmm1
callq  11 <gsl_cdf_weibull_P+0x11>
xorpd  0x0(%rip),%xmm0        # 19 <gsl_cdf_weibull_P+0x19>
callq  1e <gsl_cdf_weibull_P+0x1e>
xorpd  0x0(%rip),%xmm0        # 26 <gsl_cdf_weibull_P+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_weibull_P (const double x, const double a, const double b)
{
  double P = -expm1 (-pow(x/a, b));
  return P;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x22,%esi
callq  568 <__osip_quote_find+0x13>
cmp    %rbp,%rax
je     607 <__osip_quote_find+0xb2>
test   %rax,%rax
je     5f4 <__osip_quote_find+0x9f>
mov    $0x1,%edx
lea    -0x1(%rbp),%rbx
movslq %edx,%rcx
mov    %rax,%rsi
sub    %rcx,%rsi
cmpb   $0x5c,(%rsi)
jne    592 <__osip_quote_find+0x3d>
add    $0x1,%edx
jmp    5bb <__osip_quote_find+0x66>
mov    %edx,%ecx
shr    $0x1f,%ecx
add    %ecx,%edx
and    $0x1,%edx
sub    %ecx,%edx
cmp    $0x1,%edx
je     607 <__osip_quote_find+0xb2>
lea    0x1(%rax),%rdi
mov    $0x22,%esi
callq  5b1 <__osip_quote_find+0x5c>
test   %rax,%rax
je     5fb <__osip_quote_find+0xa6>
mov    $0x1,%edx
movslq %edx,%rcx
mov    %rax,%rdi
sub    %rcx,%rdi
cmp    %rbx,%rdi
jne    57f <__osip_quote_find+0x2a>
cmpb   $0x5c,0x0(%rbp)
sete   %sil
movzbl %sil,%esi
add    %esi,%edx
test   $0x1,%dl
je     607 <__osip_quote_find+0xb2>
lea    0x1(%rax),%rbp
mov    $0x22,%esi
mov    %rbp,%rdi
callq  5ed <__osip_quote_find+0x98>
test   %rax,%rax
jne    576 <__osip_quote_find+0x21>
jmp    602 <__osip_quote_find+0xad>
mov    $0x0,%eax
jmp    607 <__osip_quote_find+0xb2>
mov    $0x0,%eax
jmp    607 <__osip_quote_find+0xb2>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__osip_quote_find (const char *qstring)
{
  const char *quote;
  quote = strchr (qstring, '"');
  if (quote == qstring)
    return quote;
  if (quote == ((void *)0))
    return ((void *)0);
  {
    int i = 1;
    for (;;) {
      if (0 == strncmp (quote - i, "\\", 1))
        i++;
      else {
        if (i % 2 == 1)
          return quote;
        quote = strchr (quote + 1, '"');
        if (quote == ((void *)0))
          return ((void *)0);
        i = 1;
      }
      if (quote - i == qstring - 1)
      {
        if (*qstring == '\\')
          i++;
        if (i % 2 == 0)
          return quote;
        else {
          qstring = quote + 1;
          quote = strchr (quote + 1, '"');
          if (quote == ((void *)0))
            return ((void *)0);
          i = 1;
        }
      }
    }
    return ((void *)0);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 2
12 22
13 12
14 12
15 12
16 12
17 12
18 13
19 13
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 17
28 17
29 17
30 18
31 18
32 20
33 22
34 22
35 22
36 22
37 22
38 25
39 25
40 25
41 25
42 26
43 26
44 29
45 30
46 30
47 30
48 31
49 31
50 31
51 8
52 8
53 19
54 19
55 32
56 39
57 39
58 39
59 39
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x88,%rsp
mov    %edi,%ebp
mov    %rsi,%rbx
mov    %rsp,%rdi
callq  cde <swgp_signal_block+0x16>
mov    %ebp,%esi
mov    %rsp,%rdi
callq  ce8 <swgp_signal_block+0x20>
mov    %rbx,%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
callq  cf8 <swgp_signal_block+0x30>
mov    %eax,%ebx
test   %eax,%eax
jns    d25 <swgp_signal_block+0x5d>
callq  d03 <swgp_signal_block+0x3b>
mov    (%rax),%edi
callq  d0a <swgp_signal_block+0x42>
mov    %rax,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # d1b <swgp_signal_block+0x53>
mov    $0x0,%eax
callq  d25 <swgp_signal_block+0x5d>
mov    %ebx,%eax
add    $0x88,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swgp_signal_block(int signo, sigset_t * oset)
{
 int ret;
 sigset_t newmask;
 sigemptyset(&newmask);
 sigaddset(&newmask, signo);
 if ((ret=sigprocmask(0, &newmask, oset)) < 0)
  fprintf(stderr,
   "swgp_signal_block error, signal=%d: %s\n",
    signo, strerror((*__errno_location ())));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 10
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 12
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    (%rdi),%rdi
test   %rdi,%rdi
jne    a9 <_auth_lb_grow+0x34>
mov    %rdx,%rdi
callq  98 <_auth_lb_grow+0x23>
mov    %rax,(%rbx)
mov    %rbp,0x8(%rbx)
movq   $0x0,0x10(%rbx)
jmp    d2 <_auth_lb_grow+0x5d>
mov    0x8(%rbx),%rax
mov    %rax,%rdx
sub    0x10(%rbx),%rdx
cmp    %rdx,%rbp
jbe    da <_auth_lb_grow+0x65>
lea    0x0(%rbp,%rax,1),%r13
mov    %r13,%rsi
callq  c6 <_auth_lb_grow+0x51>
mov    %rax,(%rbx)
test   %rax,%rax
je     f4 <_auth_lb_grow+0x7f>
mov    %r13,0x8(%rbx)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     fb <_auth_lb_grow+0x86>
add    0x10(%rbx),%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
callq  e9 <_auth_lb_grow+0x74>
add    %rbp,0x10(%rbx)
mov    $0x0,%eax
jmp    100 <_auth_lb_grow+0x8b>
mov    $0xc,%eax
jmp    100 <_auth_lb_grow+0x8b>
mov    $0xc,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_auth_lb_grow (struct _line_buffer *s, const char *ptr, size_t size)
{
  if (!s->buffer)
    {
      s->buffer = malloc (size);
      s->size = size;
      s->level = 0;
    }
  else if (s->size - s->level < size)
    {
      size_t newsize = s->size + size;
      s->buffer = realloc (s->buffer, newsize);
      if (s->buffer)
 s->size = newsize;
    }
  if (!s->buffer)
    return 12;
  memcpy (s->buffer + s->level, ptr, size);
  s->level += size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 5
13 5
14 5
15 6
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 11
24 12
25 12
26 12
27 13
28 13
29 14
30 16
31 16
32 16
33 18
34 18
35 18
36 18
37 19
38 20
39 20
40 17
41 17
42 17
43 21
44 21
45 21
46 21
47 21
48 21
<<<sep_out_sample>>>
push   %rbx
test   %rsi,%rsi
jne    25 <nettle_arcfour_set_key+0x25>
lea    0x0(%rip),%rcx        # d <nettle_arcfour_set_key+0xd>
mov    $0x32,%edx
lea    0x0(%rip),%rsi        # 19 <nettle_arcfour_set_key+0x19>
lea    0x0(%rip),%rdi        # 20 <nettle_arcfour_set_key+0x20>
callq  25 <nettle_arcfour_set_key+0x25>
mov    %rdx,%r11
cmp    $0x100,%rsi
jbe    50 <nettle_arcfour_set_key+0x50>
lea    0x0(%rip),%rcx        # 38 <nettle_arcfour_set_key+0x38>
mov    $0x33,%edx
lea    0x0(%rip),%rsi        # 44 <nettle_arcfour_set_key+0x44>
lea    0x0(%rip),%rdi        # 4b <nettle_arcfour_set_key+0x4b>
callq  50 <nettle_arcfour_set_key+0x50>
mov    $0x0,%eax
mov    %al,(%rdi,%rax,1)
add    $0x1,%rax
cmp    $0x100,%rax
jne    55 <nettle_arcfour_set_key+0x55>
mov    %rdi,%rcx
lea    0x100(%rdi),%rbx
mov    $0x0,%edx
mov    $0x0,%r8d
movzbl (%rcx),%r9d
movzbl %r9b,%r10d
mov    %edx,%eax
movzbl (%r11,%rax,1),%eax
add    %r10d,%eax
add    %eax,%r8d
movzbl %r8b,%r8d
mov    %r8d,%eax
movzbl (%rdi,%rax,1),%r10d
mov    %r10b,(%rcx)
mov    %r9b,(%rdi,%rax,1)
lea    0x1(%rdx),%eax
mov    $0x0,%edx
div    %rsi
add    $0x1,%rcx
cmp    %rbx,%rcx
jne    79 <nettle_arcfour_set_key+0x79>
movb   $0x0,0x101(%rdi)
movb   $0x0,0x100(%rdi)
pop    %rbx
retq   
<<<sep_in_sample>>>
nettle_arcfour_set_key(struct arcfour_ctx *ctx,
  size_t length, const uint8_t *key)
{
  unsigned i, j, k;
  ((length >= 1) ? (void) (0) : __assert_fail ("length >= 1", "arcfour.c", 50, __PRETTY_FUNCTION__));
  ((length <= 256) ? (void) (0) : __assert_fail ("length <= 256", "arcfour.c", 51, __PRETTY_FUNCTION__));
  for (i = 0; i<256; i++)
    ctx->S[i] = i;
  for (i = j = k = 0; i<256; i++)
    {
      j += ctx->S[i] + key[k]; j &= 0xff;
      do { int _t = ctx->S[i]; ctx->S[i] = ctx->S[j]; ctx->S[j] = _t; } while(0);
      k = (k + 1) % length;
    }
  ctx->i = ctx->j = 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 7
21 7
22 7
23 7
24 7
25 7
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 12
34 12
35 12
36 12
37 13
38 13
39 13
40 13
41 9
42 9
43 15
44 15
45 16
46 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
callq  118 <dicod_show_databases+0xd>
test   %rax,%rax
jne    12c <dicod_show_databases+0x21>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  12a <dicod_show_databases+0x1f>
jmp    18e <dicod_show_databases+0x83>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  141 <dicod_show_databases+0x36>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  14e <dicod_show_databases+0x43>
mov    %rax,0x8(%rsp)
mov    %rax,%rsi
mov    $0x0,%edi
callq  160 <dicod_show_databases+0x55>
mov    0x8(%rsp),%rdi
callq  16a <dicod_show_databases+0x5f>
lea    0x8(%rsp),%rdi
callq  174 <dicod_show_databases+0x69>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  181 <dicod_show_databases+0x76>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  18e <dicod_show_databases+0x83>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
dicod_show_databases(dico_stream_t str, int argc, char **argv)
{
    size_t count = database_count();
    if (count == 0)
 stream_printf(str, "554 No databases present\n");
    else {
 dico_stream_t ostr;
 stream_printf(str, "110 %lu databases present\n",
        (unsigned long) count);
 ostr = dicod_ostream_create(str, ((void *)0));
 database_iterate(_show_database, ostr);
 dico_stream_close(ostr);
 dico_stream_destroy(&ostr);
 stream_writez(str, ".\n");
 stream_writez(str, "250 ok\n");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 8
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 10
20 11
21 11
22 11
23 12
24 12
25 13
26 13
27 14
28 14
29 14
30 15
31 15
32 15
33 17
34 17
35 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     b6d <array_to_word_list+0x61>
cmpl   $0x0,0x10(%rdi)
je     b74 <array_to_word_list+0x68>
mov    0x18(%rdi),%rax
mov    0x10(%rax),%rbx
cmp    %rbx,%rax
je     b7b <array_to_word_list+0x6f>
mov    $0x0,%ebp
mov    0x8(%rbx),%rdi
callq  b39 <array_to_word_list+0x2d>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  b44 <array_to_word_list+0x38>
mov    %rax,%rbp
mov    0x10(%rbx),%rbx
cmp    %rbx,0x18(%r12)
jne    b30 <array_to_word_list+0x24>
mov    %rax,%rdi
test   %rax,%rax
je     b82 <array_to_word_list+0x76>
cmpq   $0x0,0x0(%rbp)
je     b82 <array_to_word_list+0x76>
mov    $0x0,%eax
callq  b6b <array_to_word_list+0x5f>
jmp    b82 <array_to_word_list+0x76>
mov    $0x0,%eax
jmp    b82 <array_to_word_list+0x76>
mov    $0x0,%eax
jmp    b82 <array_to_word_list+0x76>
mov    $0x0,%eax
jmp    b82 <array_to_word_list+0x76>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
array_to_word_list(a)
ARRAY *a;
{
 WORD_LIST *list;
 ARRAY_ELEMENT *ae;
 if (a == 0 || ((a)->num_elements == 0))
  return((WORD_LIST *)((void *)0));
 list = (WORD_LIST *)((void *)0);
 for (ae = ((a->head)->next); ae != a->head; ae = ((ae)->next))
  list = make_word_list (make_bare_word(((ae)->value)), list);
 return (((list && list->next) ? (WORD_LIST *)list_reverse ((GENERIC_LIST *)list) : (WORD_LIST *)(list)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 9
10 9
11 9
12 9
13 8
14 10
15 10
16 10
17 10
18 10
19 10
20 9
21 9
22 9
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 7
32 7
33 7
34 7
35 8
36 8
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %rsi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0xc8(%rsp)
xor    %eax,%eax
cmpb   $0x2f,(%rsi)
je     192a <form_abspath+0x8a>
mov    %rdi,%rbp
mov    %rdx,%rsi
test   %rdx,%rdx
jne    18f8 <form_abspath+0x58>
mov    $0xc6,%sil
mov    %rsp,%rdi
callq  18da <form_abspath+0x3a>
test   %rax,%rax
jne    1905 <form_abspath+0x65>
mov    $0x0,%ecx
mov    $0x16e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  18f8 <form_abspath+0x58>
mov    $0xc6,%edx
mov    %rsp,%rdi
callq  1905 <form_abspath+0x65>
movb   $0x0,0xc7(%rsp)
mov    %rsp,%rsi
mov    %rbp,%rdi
callq  1918 <form_abspath+0x78>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1923 <form_abspath+0x83>
mov    $0x0,%eax
jmp    192f <form_abspath+0x8f>
mov    $0x1,%eax
mov    0xc8(%rsp),%rcx
xor    %fs:0x28,%rcx
je     1947 <form_abspath+0xa7>
callq  1947 <form_abspath+0xa7>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
form_abspath(STROB * sb1, char * s1, char * pcwd)
{
 char cwd[200];
 if (*s1 == '/') return 1;
 if (pcwd == ((void *)0)) {
  if (getcwd(cwd, sizeof(cwd) - 2) == ((void *)0)) {
   swlib_fatal("path too long", (char*)"swlib.c", 366, (char*)__FUNCTION__);;
  }
 } else {
  strncpy(cwd, pcwd, sizeof(cwd) - 2);
 }
 cwd[sizeof(cwd) - 1] = '\0';
 strob_strcpy(sb1, cwd);
 swlib_unix_dircat(sb1, s1);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 10
25 10
26 10
27 12
28 13
29 13
30 13
31 14
32 14
33 14
34 15
35 15
36 4
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  13a <xzalloc+0x9>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  14a <xzalloc+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %esi,%esi
jle    2787 <swlib_kill_all_pids+0xae>
mov    %edx,%ebp
mov    %ecx,%r14d
mov    %rdi,%rbx
lea    -0x1(%rsi),%eax
lea    0x4(%rdi,%rax,4),%r12
mov    $0x0,%r15d
mov    (%rbx),%r9d
test   %r9d,%r9d
jle    277c <swlib_kill_all_pids+0xa3>
mov    %ebp,(%rsp)
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x0,%edx
mov    $0x5,%esi
mov    %r14d,%edi
mov    $0x0,%eax
callq  2732 <swlib_kill_all_pids+0x59>
mov    %ebp,%esi
mov    (%rbx),%edi
callq  273b <swlib_kill_all_pids+0x62>
test   %eax,%eax
jns    277c <swlib_kill_all_pids+0xa3>
callq  2744 <swlib_kill_all_pids+0x6b>
mov    (%rax),%edi
callq  274b <swlib_kill_all_pids+0x72>
mov    %rax,0x8(%rsp)
mov    %ebp,(%rsp)
mov    (%rbx),%r9d
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x0,%edx
mov    $0x5,%esi
mov    %r14d,%edi
mov    $0x0,%eax
callq  2778 <swlib_kill_all_pids+0x9f>
add    $0x1,%r15d
add    $0x4,%rbx
cmp    %r12,%rbx
jne    2705 <swlib_kill_all_pids+0x2c>
jmp    278d <swlib_kill_all_pids+0xb4>
mov    $0x0,%r15d
mov    %r15d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
swlib_kill_all_pids(pid_t * pid, int num, int signo, int verbose_level)
{
 int i;
 int ret = 0;
 for(i=0; i<num; i++) {
  if (pid[i] > 0) {
   swutil_doif_writef(verbose_level, 5,
                               (((void *)0)), 2,
    "swlib_kill_all_pids: kill[%d] signo=%d\n",
       (int)pid[i], signo);
   ;
   if (kill(pid[i], signo) < 0) {
    swutil_doif_writef(verbose_level, 5,
                                (((void *)0)), 2,
     "kill[%d] signo=%d : error : %s\n",
      (int)pid[i],
      signo, strerror((*__errno_location ())));
    ret++;
   }
  }
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 12
28 12
29 12
30 12
31 12
32 17
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 18
46 18
47 5
48 5
49 5
50 4
51 23
52 23
53 23
54 23
55 23
56 23
57 23
58 23
59 23
<<<sep_out_sample>>>
mov    0x4c(%rdi),%edx
test   %edx,%edx
jle    139 <trim_bottom_edge+0x33>
mov    0x58(%rdi),%rax
lea    -0x1(%rdx),%edx
lea    (%rdx,%rdx,2),%rdx
shl    $0x5,%rdx
lea    0x60(%rax,%rdx,1),%rsi
mov    $0x1,%edx
mov    0xc(%rax),%ecx
cmp    %ecx,%edx
cmovl  %ecx,%edx
add    $0x60,%rax
cmp    %rsi,%rax
jne    126 <trim_bottom_edge+0x20>
jmp    13e <trim_bottom_edge+0x38>
mov    $0x1,%edx
lea    0x0(,%rdx,8),%ecx
mov    0x34(%rdi),%eax
mov    $0x0,%edx
div    %ecx
test   %eax,%eax
je     159 <trim_bottom_edge+0x53>
imul   %ecx,%eax
mov    %eax,0x34(%rdi)
repz retq 
<<<sep_in_sample>>>
trim_bottom_edge (j_compress_ptr dstinfo)
{
  int ci, max_v_samp_factor;
  JDIMENSION MCU_rows;
  max_v_samp_factor = 1;
  for (ci = 0; ci < dstinfo->num_components; ci++) {
    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
    max_v_samp_factor = ((max_v_samp_factor) > (v_samp_factor) ? (max_v_samp_factor) : (v_samp_factor));
  }
  MCU_rows = dstinfo->image_height / (max_v_samp_factor * 8);
  if (MCU_rows > 0)
    dstinfo->image_height = MCU_rows * (max_v_samp_factor * 8);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 5
10 8
11 8
12 8
13 8
14 6
15 6
16 6
17 5
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 12
26 12
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %edx,%r12d
mov    %ecx,%r13d
cmp    %edx,%esi
jne    aaf0 <_sse_divr_f+0x30>
mov    %ecx,%r8d
mov    %esi,%ecx
mov    $0x5e,%edx
mov    $0xf3,%esi
callq  9d0 <_ssexr>
jmpq   ab7e <_sse_divr_f+0xbe>
cmp    %ecx,%esi
jne    ab62 <_sse_divr_f+0xa2>
mov    $0xc0000000,%esi
callq  aafe <_sse_divr_f+0x3e>
mov    %eax,%r13d
mov    %eax,%r14d
and    $0x7fff,%r14d
shl    $0x4,%r14
mov    0x0(%r14),%esi
and    $0x7fff,%esi
mov    %ebx,%edx
mov    %rbp,%rdi
callq  bba <_sse_movr_f>
mov    %r12d,%edx
mov    %ebx,%esi
mov    %rbp,%rdi
callq  bba <_sse_movr_f>
mov    0x0(%r14),%r8d
and    $0x7fff,%r8d
mov    %ebx,%ecx
mov    $0x5e,%edx
mov    $0xf3,%esi
mov    %rbp,%rdi
callq  9d0 <_ssexr>
mov    %r13d,%esi
mov    %rbp,%rdi
callq  ab60 <_sse_divr_f+0xa0>
jmp    ab7e <_sse_divr_f+0xbe>
callq  bba <_sse_movr_f>
mov    %r13d,%r8d
mov    %ebx,%ecx
mov    $0x5e,%edx
mov    $0xf3,%esi
mov    %rbp,%rdi
callq  9d0 <_ssexr>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
_sse_divr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_int32_t reg;
    if (r0 == r1)
 _ssexr(_jit,0xf3,0x5e,r0,r2);
    else if (r0 == r2) {
 reg = _jit_get_reg(_jit,0x40000000|0x80000000);
 _sse_movr_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),r0);
 _sse_movr_f(_jit,r0,r1);
 _ssexr(_jit,0xf3,0x5e,r0,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)));
 _jit_unget_reg(_jit,reg);
    }
    else {
 _sse_movr_f(_jit,r0,r1);
 _ssexr(_jit,0xf3,0x5e,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 7
21 7
22 7
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 9
32 9
33 9
34 9
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 11
43 11
44 11
45 11
46 14
47 15
48 15
49 15
50 15
51 15
52 15
53 17
54 17
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r13
mov    0x8(%rdi),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     56b <hol_find_entry+0x7d>
mov    %rsi,%r12
mov    %edx,%eax
add    $0x1,%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
lea    0x0(%r13,%rax,1),%r14
mov    0x0(%r13),%rbx
mov    0x8(%r13),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     560 <hol_find_entry+0x72>
mov    %edx,%eax
lea    0x3(%rax,%rax,2),%rbp
shl    $0x4,%rbp
add    %rbx,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     557 <hol_find_entry+0x69>
testb  $0x2,0x18(%rbx)
jne    557 <hol_find_entry+0x69>
mov    %r12,%rsi
callq  553 <hol_find_entry+0x65>
test   %eax,%eax
je     572 <hol_find_entry+0x84>
add    $0x30,%rbx
cmp    %rbp,%rbx
jne    53d <hol_find_entry+0x4f>
add    $0x38,%r13
cmp    %r14,%r13
jne    520 <hol_find_entry+0x32>
jmp    577 <hol_find_entry+0x89>
mov    $0x0,%eax
jmp    57c <hol_find_entry+0x8e>
mov    %r13,%rax
jmp    57c <hol_find_entry+0x8e>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
hol_find_entry (struct hol *hol, const char *name)
{
  struct hol_entry *entry = hol->entries;
  unsigned num_entries = hol->num_entries;
  while (num_entries-- > 0)
    {
      const struct argp_option *opt = entry->opt;
      unsigned num_opts = entry->num;
      while (num_opts-- > 0)
        if (opt->name && (! ((opt)->flags & 0x2)) && strcmp (opt->name, name) == 0)
          return entry;
        else
          opt++;
      entry++;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 13
37 9
38 9
39 14
40 5
41 5
42 5
43 16
44 16
45 16
46 16
47 16
48 17
49 17
50 17
51 17
52 17
53 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%ebx        # 28a <newlab+0xc>
cmp    0x0(%rip),%ebx        # 290 <newlab+0x12>
jne    2b5 <newlab+0x37>
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2a1 <newlab+0x23>
mov    $0x0,%eax
callq  2ab <newlab+0x2d>
mov    $0x1,%edi
callq  2b5 <newlab+0x37>
movslq %ebx,%rax
lea    (%rax,%rax,2),%rdx
mov    0x0(%rip),%rax        # 2c3 <newlab+0x45>
lea    (%rax,%rdx,8),%rbp
mov    %rdi,%rsi
mov    0x0(%rbp),%rdi
callq  2d3 <newlab+0x55>
movl   $0xffffffff,0x8(%rbp)
movl   $0xffffffff,0xc(%rbp)
movl   $0xffffffff,0x10(%rbp)
lea    0x1(%rbx),%eax
mov    %eax,0x0(%rip)        # 2f1 <newlab+0x73>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
newlab(char lname[])
{
  if (nextclab == dap_maxclab)
    {
      fprintf(dap_err, "(newlab) too many column labels: %s\n", lname);
      exit(1);
    }
  strcpy(collabel[nextclab].lab, lname);
  collabel[nextclab].labd = -1;
  collabel[nextclab].laba = -1;
  collabel[nextclab].labc = -1;
  return nextclab++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 10
23 11
24 12
25 12
26 13
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
test   %rcx,%rcx
jne    123d6 <gsl_fft_real_unpack+0x26>
sub    $0x8,%rsp
mov    $0x1,%cl
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  123cf <gsl_fft_real_unpack+0x1f>
mov    $0x1,%eax
jmp    1240d <gsl_fft_real_unpack+0x5d>
lea    0x0(,%rdx,8),%r8
shl    $0x4,%rdx
mov    $0x0,%eax
xorpd  %xmm1,%xmm1
movsd  (%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  %xmm1,0x8(%rsi)
add    $0x1,%rax
add    %r8,%rdi
add    %rdx,%rsi
cmp    %rcx,%rax
jne    123eb <gsl_fft_real_unpack+0x3b>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_real_unpack (const double real_coefficient[],
                               double complex_coefficient[],
                               const size_t stride, const size_t n)
{
  size_t i;
  if (n == 0)
    {
      do { gsl_error ("length n must be positive integer", "real_unpack.c", 31, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  for (i = 0; i < n; i++)
    {
      ((complex_coefficient)[2*(stride)*(i)]) = real_coefficient[i * stride];
      ((complex_coefficient)[2*(stride)*(i)+1]) = 0.0;
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 6
14 13
15 12
16 12
17 13
18 10
19 10
20 10
21 10
22 10
23 15
24 15
25 16
26 16
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x48,%rsp
movsd  %xmm0,0x28(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x30(%rsp)
movq   %xmm1,0x38(%rsp)
mov    0x8(%rdx),%rcx
mov    (%rdi),%rax
cmp    (%rdx),%rax
jne    15aa <gsl_blas_zgeru+0x72>
mov    (%rsi),%r10
cmp    %rcx,%r10
jne    15aa <gsl_blas_zgeru+0x72>
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r8
mov    0x10(%rdx),%rcx
mov    %ecx,0x18(%rsp)
mov    0x18(%rdx),%rdx
mov    %rdx,0x10(%rsp)
mov    0x8(%rsi),%rdx
mov    %edx,0x8(%rsp)
mov    0x10(%rsi),%rdx
mov    %rdx,(%rsp)
lea    0x30(%rsp),%rcx
mov    %r10d,%edx
mov    %eax,%esi
mov    $0x65,%edi
callq  15a3 <gsl_blas_zgeru+0x6b>
mov    $0x0,%eax
jmp    15c8 <gsl_blas_zgeru+0x90>
mov    $0x13,%ecx
mov    $0x422,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15c3 <gsl_blas_zgeru+0x8b>
mov    $0x13,%eax
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (X->size == M && Y->size == N)
    {
      cblas_zgeru (CblasRowMajor, ((int)(M)), ((int)(N)), ((&alpha)->dat),
                   X->data, ((int)(X->stride)), Y->data, ((int)(Y->stride)),
                   A->data, ((int)(A->tda)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 1058, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 15
31 15
32 15
33 15
34 15
35 15
36 17
37 17
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     496b <sw_l_msg+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdx,%r8
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x220(%rdi),%ecx
lea    0x45c(%rdi),%rdx
mov    0x14(%rdi),%edi
lea    0x8(%rsp),%r9
callq  49af <sw_l_msg+0x95>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
sw_l_msg(GB * G, int at_level, char * format, ...)
{
        int ret;
        va_list ap;
        __builtin_va_start(ap,format);
        ret = doif_i_writef(G->g_verboseG, at_level,
                        &(G->g_logspec), swc_get_stderr_fd(G), format, &ap);
        __builtin_va_end(ap);
        return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 10
28 10
<<<sep_out_sample>>>
mov    %rdi,%rax
movzbl (%rdi),%edx
testb  $0x7,0x0(%rdx,%rdx,1)
jne    4ea <end_of_token+0x21>
add    $0x1,%rax
movzbl (%rax),%edx
testb  $0x7,0x0(%rdx,%rdx,1)
je     4d9 <end_of_token+0x10>
repz retq 
<<<sep_in_sample>>>
end_of_token (const char *s)
{
  while (! (((stopchar_map[(unsigned char)(*(s))])&(((0x0002|0x0004)|0x0001))) != 0)) ++(s);
  return (char *)s;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rsi        # b <my_bug_report_address+0xb>
callq  10 <my_bug_report_address+0x10>
mov    $0x0,%edi
callq  1a <my_bug_report_address+0x1a>
mov    $0x0,%edx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 29 <my_bug_report_address+0x29>
mov    $0x0,%eax
callq  33 <my_bug_report_address+0x33>
mov    0x0(%rip),%rsi        # 3a <my_bug_report_address+0x3a>
mov    %rbx,%rdi
callq  42 <my_bug_report_address+0x42>
mov    $0x0,%edi
callq  4c <my_bug_report_address+0x4c>
mov    $0x0,%edx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 5b <my_bug_report_address+0x5b>
mov    $0x0,%eax
callq  65 <my_bug_report_address+0x65>
mov    0x0(%rip),%rsi        # 6c <my_bug_report_address+0x6c>
mov    %rbx,%rdi
callq  74 <my_bug_report_address+0x74>
mov    $0x0,%edi
callq  7e <my_bug_report_address+0x7e>
mov    $0x0,%edx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 8d <my_bug_report_address+0x8d>
mov    $0x0,%eax
callq  97 <my_bug_report_address+0x97>
mov    0x0(%rip),%rsi        # 9e <my_bug_report_address+0x9e>
mov    %rbx,%rdi
callq  a6 <my_bug_report_address+0xa6>
pop    %rbx
retq   
<<<sep_in_sample>>>
my_bug_report_address (fp)
     FILE *fp;
{
  print_text (fp, s1);
  sprintf (s1, gettext("Email bug reports to <%s>"), "bug-gcal@gnu.org");
  print_text (fp, s1);
  sprintf (s1, gettext("GNU gcal home page: <%s>"), "http://www.gnu.org/software/gcal");
  print_text (fp, s1);
  sprintf (s1, gettext("General help using GNU software: <%s>"), "http://www.gnu.org/gethelp/");
  print_text (fp, s1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 10
33 10
34 10
35 11
36 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  18d1 <main+0xe>
test   %rax,%rax
mov    $0x0,%edx
cmove  %rdx,%rax
mov    %rax,0x0(%rip)        # 18e4 <main+0x21>
callq  18e9 <main+0x26>
mov    %eax,0x0(%rip)        # 18ef <main+0x2c>
callq  18f4 <main+0x31>
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    0x0(%rip),%rdx        # 190c <main+0x49>
mov    0x0(%rip),%rsi        # 1913 <main+0x50>
mov    0x0(%rip),%rdi        # 191a <main+0x57>
callq  191f <main+0x5c>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
main ()
{
  if (!(tmpdir = getenv("TMPDIR")))
    tmpdir = "/tmp";
  pid = (int) getpid ();
  yylex();
  reassemble(adobe, font, body, adobefname, fontfname, bodyfname);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %rdx,%r13
mov    %r8d,%ebp
test   %r8d,%r8d
je     1b9e <_x87jcc2+0x1e>
test   %ecx,%ecx
jne    1baf <_x87jcc2+0x2f>
mov    %r8d,%ecx
mov    %ecx,%edx
mov    $0x1d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
jmp    1bcb <_x87jcc2+0x4b>
mov    %ecx,%edx
mov    $0x8,%esi
callq  13ec <_x87ri>
lea    0x1(%rbp),%edx
mov    $0x3d,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
mov    %r13,%rdx
mov    %r12d,%esi
mov    %rbx,%rdi
callq  876 <_jcc>
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_x87jcc2(jit_state_t *_jit, jit_int32_t code,
  jit_word_t i0, jit_int32_t r0, jit_int32_t r1)
{
    jit_int32_t f0, f1;
    if (r1 == 0) f0 = r1, f1 = r0;
    else f0 = r0, f1 = r1;
    if (f0 == 0)
 _x87ri(_jit,035,f1);
    else {
 _x87ri(_jit,010,f0);
 _x87ri(_jit,075,f1 + 1);
    }
    _jcc(_jit, code, i0);
    return (_jit->pc.w);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 6
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 13
27 13
28 13
29 13
30 14
31 15
32 15
33 15
34 15
35 15
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rsi),%rbp
mov    0x10(%rsi),%r12
test   %rbp,%rbp
je     e7 <gsl_combination_fprintf+0x63>
mov    %rdi,%r13
mov    %rdx,%r14
mov    $0x0,%ebx
mov    (%r12,%rbx,8),%rdx
mov    %r14,%rsi
mov    %r13,%rdi
mov    $0x0,%eax
callq  b8 <gsl_combination_fprintf+0x34>
test   %eax,%eax
jns    dc <gsl_combination_fprintf+0x58>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d5 <gsl_combination_fprintf+0x51>
mov    $0x5,%eax
jmp    f3 <gsl_combination_fprintf+0x6f>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    a4 <gsl_combination_fprintf+0x20>
jmp    ee <gsl_combination_fprintf+0x6a>
mov    $0x0,%eax
jmp    f3 <gsl_combination_fprintf+0x6f>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_combination_fprintf (FILE * stream, const gsl_combination * c, const char *format)
{
  size_t k = c->k ;
  size_t * data = c->data ;
  size_t i;
  for (i = 0; i < k; i++)
    {
      int status = fprintf (stream, format, data[i]);
      if (status < 0)
        {
          do { gsl_error ("fprintf failed", "file.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 6
28 6
29 6
30 6
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 15
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     405 <gsl_vector_complex_add+0x29>
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3fe <gsl_vector_complex_add+0x22>
mov    $0x13,%eax
jmp    47f <gsl_vector_complex_add+0xa3>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     473 <gsl_vector_complex_add+0x97>
shl    $0x4,%rbx
shl    $0x4,%r11
mov    $0x0,%edx
mov    $0x0,%eax
mov    $0x0,%ecx
mov    %rax,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
movsd  (%r8),%xmm0
addsd  (%r9,%rdx,1),%xmm0
movsd  %xmm0,(%r8)
mov    0x10(%rdi),%r8
lea    0x8(%r8,%rax,1),%r8
mov    0x10(%rsi),%r9
movsd  (%r8),%xmm0
addsd  0x8(%r9,%rdx,1),%xmm0
movsd  %xmm0,(%r8)
add    $0x1,%rcx
add    %rbx,%rax
add    %r11,%rdx
cmp    %r10,%rcx
jne    429 <gsl_vector_complex_add+0x4d>
jmp    47a <gsl_vector_complex_add+0x9e>
mov    $0x0,%eax
jmp    47f <gsl_vector_complex_add+0xa3>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_complex_add (gsl_vector_complex * a, const gsl_vector_complex * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_complex_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[2 * i * stride_a] += b->data[2 * i * stride_b];
          a->data[2 * i * stride_a + 1] += b->data[2 * i * stride_b + 1];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 16
28 16
29 16
30 16
31 16
32 16
33 13
34 13
35 13
36 13
37 13
38 13
39 18
40 18
41 18
42 20
43 20
<<<sep_out_sample>>>
push   %rbx
sub    $0x30,%rsp
mov    %edi,%ebx
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
movl   $0x10,0x4(%rsp)
lea    0x4(%rsp),%r9
lea    0x10(%rsp),%r8
mov    $0x0,%ecx
mov    $0x8,%edx
lea    0x8(%rsp),%rsi
callq  9bf <time_dg+0x3d>
test   %rax,%rax
js     9ef <time_dg+0x6d>
callq  92e <time_since_1900>
mov    %rax,0x8(%rsp)
mov    $0x10,%r9d
lea    0x10(%rsp),%r8
mov    $0x0,%ecx
mov    $0x8,%edx
lea    0x8(%rsp),%rsi
mov    %ebx,%edi
callq  9ef <time_dg+0x6d>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
je     a04 <time_dg+0x82>
callq  a04 <time_dg+0x82>
add    $0x30,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
time_dg (int fd, struct component const *comp)
{
  unsigned long result;
  struct sockaddr sa;
  socklen_t size = sizeof sa;
  if (recvfrom (fd, (char *) &result, sizeof result, 0, &sa, &size) < 0)
    return;
  result = time_since_1900 ();
  sendto (fd, (char *) &result, sizeof result, 0, &sa, sizeof sa);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x1(%rcx,%rcx,1),%rdi
mov    $0x8e,%edx
mov    $0x0,%esi
callq  bc <sh_double_quote+0x29>
lea    0x1(%rax),%rcx
movb   $0x22,(%rax)
test   %rbx,%rbx
je     106 <sh_double_quote+0x73>
movzbl (%rbx),%edx
mov    %edx,%esi
test   %dl,%dl
je     10b <sh_double_quote+0x78>
movzbl %sil,%edi
testb  $0x40,0x0(,%rdi,4)
je     ec <sh_double_quote+0x59>
cmp    $0xa,%sil
je     ec <sh_double_quote+0x59>
movb   $0x5c,(%rcx)
lea    0x1(%rcx),%rcx
lea    0x1(%rcx),%rdi
mov    %dl,(%rcx)
add    $0x1,%rbx
je     10e <sh_double_quote+0x7b>
movzbl (%rbx),%edx
mov    %edx,%esi
test   %dl,%dl
je     10e <sh_double_quote+0x7b>
mov    %rdi,%rcx
jmp    d1 <sh_double_quote+0x3e>
mov    %rcx,%rdi
jmp    10e <sh_double_quote+0x7b>
mov    %rcx,%rdi
movb   $0x22,(%rdi)
movb   $0x0,0x1(%rdi)
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_double_quote (string)
     const char *string;
{
  register unsigned char c;
  char *result, *r;
  const char *s;
  result = (char *)sh_xmalloc((3 + (2 * strlen (string))), "shquote.c", 142);
  r = result;
  *r++ = '"';
  for (s = string; s && (c = *s); s++)
    {
      if ((sh_syntaxtab[c] & 0x0040) && c != '\n')
 *r++ = '\\';
      *r++ = c;
    }
  *r++ = '"';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 12
24 13
25 13
26 14
27 14
28 10
29 10
30 10
31 10
32 10
33 10
34 14
35 14
36 9
37 9
38 9
39 16
40 17
41 19
42 19
<<<sep_out_sample>>>
and    $0x7,%edi
shl    $0x3,%edi
movzbl 0x0(%rip),%eax        # 9e4 <tty_background+0xd>
and    $0xffffffc7,%eax
or     %eax,%edi
mov    %dil,0x0(%rip)        # 9f0 <tty_background+0x19>
retq   
<<<sep_in_sample>>>
tty_background(color)
    int color;
{
    ((tty_current_attribute) = ((tty_current_attribute) & ~0x38) | ((((color)) & 7) << 3));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
and    $0x80000,%esi
cmp    $0x1,%esi
sbb    %esi,%esi
not    %esi
and    $0x406,%esi
mov    $0x3,%edx
mov    $0x0,%eax
callq  26 <dup_safer_flag+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer_flag (int fd, int flag)
{
  return rpl_fcntl (fd, (flag & 02000000) ? 1030 : 0,
                2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %esi,%r13d
mov    %edx,%ebp
mov    %rcx,%r12
mov    %r8,%rbx
mov    %edi,%r14d
cmp    $0x7cf,%di
jle    3b <add_char+0x3b>
mov    $0x0,%edi
callq  27 <add_char+0x27>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 31 <add_char+0x31>
mov    $0x0,%eax
callq  3b <add_char+0x3b>
movswq %r14w,%rax
mov    %r13b,(%r12,%rax,1)
mov    %ebp,(%rbx,%rax,4)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
add_char(short position,char character,char_status status,char *line,char_status line_status[])
{
  if (position >= 2000)
    fprintf(stderr, gettext("trueprint" ": line too long!  Are you sure this is a program listing?\n"));
  line[position] = character;
  line_status[position] = status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 6
22 7
23 7
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
sub    $0x28,%rsp
movsd  %xmm1,0x8(%rsp)
movsd  %xmm2,(%rsp)
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
ja     130 <gsl_ran_weibull_pdf+0xd8>
ucomisd %xmm1,%xmm0
jp     a4 <gsl_ran_weibull_pdf+0x4c>
jne    a4 <gsl_ran_weibull_pdf+0x4c>
ucomisd 0x0(%rip),%xmm2        # 85 <gsl_ran_weibull_pdf+0x2d>
jp     136 <gsl_ran_weibull_pdf+0xde>
jne    136 <gsl_ran_weibull_pdf+0xde>
movsd  0x0(%rip),%xmm0        # 99 <gsl_ran_weibull_pdf+0x41>
divsd  0x8(%rsp),%xmm0
jmpq   13a <gsl_ran_weibull_pdf+0xe2>
movsd  (%rsp),%xmm4
ucomisd 0x0(%rip),%xmm4        # b1 <gsl_ran_weibull_pdf+0x59>
jp     d4 <gsl_ran_weibull_pdf+0x7c>
jne    d4 <gsl_ran_weibull_pdf+0x7c>
movsd  0x0(%rip),%xmm1        # bd <gsl_ran_weibull_pdf+0x65>
xorpd  %xmm1,%xmm0
divsd  0x8(%rsp),%xmm0
callq  cc <gsl_ran_weibull_pdf+0x74>
divsd  0x8(%rsp),%xmm0
jmp    13a <gsl_ran_weibull_pdf+0xe2>
divsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x10(%rsp)
callq  e5 <gsl_ran_weibull_pdf+0x8d>
movsd  %xmm0,0x18(%rsp)
movsd  (%rsp),%xmm1
movsd  0x10(%rsp),%xmm0
callq  fb <gsl_ran_weibull_pdf+0xa3>
movsd  (%rsp),%xmm1
subsd  0x0(%rip),%xmm1        # 108 <gsl_ran_weibull_pdf+0xb0>
mulsd  0x18(%rsp),%xmm1
movapd %xmm1,%xmm5
subsd  %xmm0,%xmm5
movapd %xmm5,%xmm0
callq  11f <gsl_ran_weibull_pdf+0xc7>
movsd  (%rsp),%xmm1
divsd  0x8(%rsp),%xmm1
mulsd  %xmm1,%xmm0
jmp    13a <gsl_ran_weibull_pdf+0xe2>
xorpd  %xmm0,%xmm0
jmp    13a <gsl_ran_weibull_pdf+0xe2>
xorpd  %xmm0,%xmm0
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_weibull_pdf (const double x, const double a, const double b)
{
  if (x < 0)
    {
      return 0 ;
    }
  else if (x == 0)
    {
      if (b == 1)
        return 1/a ;
      else
        return 0 ;
    }
  else if (b == 1)
    {
      return exp(-x/a)/a ;
    }
  else
    {
      double p = (b/a) * exp (-pow (x/a, b) + (b - 1) * log (x/a));
      return p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 7
8 7
9 7
10 9
11 9
12 9
13 10
14 10
15 10
16 14
17 14
18 14
19 14
20 16
21 16
22 16
23 16
24 16
25 16
26 20
27 20
28 20
29 20
30 20
31 20
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 21
44 5
45 5
46 12
47 23
48 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
callq  d0 <_print_malloc_stats>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fprint_malloc_stats (s, fp)
     char *s;
     FILE *fp;
{
  _print_malloc_stats (s, fp);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
movzbl (%rdi),%ebx
test   %bl,%bl
je     59 <putname+0x59>
callq  19 <putname+0x19>
mov    %rax,%r13
mov    $0x0,%r12d
movsbq %bl,%rax
mov    0x0(%r13),%rdx
testb  $0x40,0x1(%rdx,%rax,2)
jne    3f <putname+0x3f>
mov    $0x3f,%edi
cmpl   $0x0,0x0(%rip)        # 3d <putname+0x3d>
jne    42 <putname+0x42>
movsbl %bl,%edi
callq  47 <putname+0x47>
add    $0x1,%r12d
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
jne    22 <putname+0x22>
jmp    5f <putname+0x5f>
mov    $0x0,%r12d
mov    %r12d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
putname (char *name)
{
  int len;
  for (len = 0; *name; len++, name++)
    putchar ((!((*__ctype_b_loc ())[(int) ((*name))] & (unsigned short int) _ISprint) && f_nonprint) ? '?' : *name);
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 7
30 7
31 7
32 7
33 7
34 7
35 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2174 <php_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
php_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4eb <dico_list_get_flags+0x9>
mov    0x18(%rdi),%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
dico_list_get_flags(struct dico_list *list)
{
   if (list)
       return list->flags;
   return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xe7,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  29f <sh_getopt_alloc_istate+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sh_getopt_alloc_istate ()
{
  sh_getopt_state_t *ret;
  ret = (sh_getopt_state_t *)sh_xmalloc((sizeof (sh_getopt_state_t)), "getopt.c", 231);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  61b <it_init_joblist>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
it_init_running (itp)
     ITEMLIST *itp;
{
  return (it_init_joblist (itp, 0));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,(%rsp)
movsd  %xmm1,0x8(%rsp)
movapd %xmm2,%xmm0
callq  18 <gsl_cdf_gumbel1_P+0x18>
movsd  0x8(%rsp),%xmm1
mulsd  (%rsp),%xmm1
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
xorpd  0x0(%rip),%xmm0        # 33 <gsl_cdf_gumbel1_P+0x33>
callq  38 <gsl_cdf_gumbel1_P+0x38>
xorpd  0x0(%rip),%xmm0        # 40 <gsl_cdf_gumbel1_P+0x40>
callq  45 <gsl_cdf_gumbel1_P+0x45>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel1_P (const double x, const double a, const double b)
{
  double u = a * x - log (b);
  double P = exp (-exp (-u));
  return P;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 6
15 6
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gc_done (void)
{
  return;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 6b5 <exclude_vcs_ignores+0x7>
test   %rdi,%rdi
je     6d7 <exclude_vcs_ignores+0x29>
push   %rbx
mov    $0x0,%ebx
mov    $0x0,%esi
callq  6ca <exclude_vcs_ignores+0x1c>
add    $0x28,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    6c0 <exclude_vcs_ignores+0x12>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
exclude_vcs_ignores (void)
{
  struct vcs_ignore_file *p;
  for (p = vcs_ignore_files; p->filename; p++)
    excfile_add (p->filename, 0x00);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 4
6 5
7 5
8 4
9 4
10 4
11 4
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    (%rsi),%eax
add    $0x3e8,%eax
mov    %eax,(%rsi)
mov    %eax,%eax
imul   %rdx,%rax
mov    %rax,%rbp
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x3,%esi
mov    $0x69,%edi
mov    $0x0,%eax
callq  7d <grow_array+0x37>
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    92 <grow_array+0x4c>
mov    %rbp,%rdi
callq  8d <grow_array+0x47>
mov    %rax,(%rbx)
jmp    9d <grow_array+0x57>
mov    %rbp,%rsi
callq  9a <grow_array+0x54>
mov    %rax,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grow_array(void *list_ptr_ptr, unsigned int *list_size_ptr, size_t list_entry_size)
{
  size_t size_needed;
  *list_size_ptr += 1000;
  size_needed = *list_size_ptr * list_entry_size;
  dm('i',3,"index.c:grow_array() Growing array by %d bytes\n", size_needed);
  if (*(void **)list_ptr_ptr == ((void *)0))
    *(void **)list_ptr_ptr = xmalloc(size_needed);
  else
    *(void **)list_ptr_ptr = xrealloc(*(void **)list_ptr_ptr, size_needed);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 10
25 10
26 10
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
lea    0x8(%rdi),%rsi
mov    $0x0,%r8d
mov    $0x0,%edx
mov    $0x2,%edi
callq  148d <set_supp_group>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_supp_group_iter(grecs_value_t *value, void *data)
{
    return set_supp_group(grecs_callback_set_value,
     &value->locus, ((void *)0), value, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1f3c <init_time+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_time (void)
{
  gettime (&initial_time);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmpb   $0x0,(%rdi)
je     23e <ifdef_name+0xe>
add    $0x1,%rdi
cmpb   $0x0,(%rdi)
jne    235 <ifdef_name+0x5>
movzbl 0x1(%rdi),%eax
retq   
<<<sep_in_sample>>>
ifdef_name (char *t)
{
  while (*t != 0) t++;
  t++;
  return *t;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
cmpb   $0x0,(%rdi)
je     e0c <Barcode_128raw_verify+0x45>
je     e13 <Barcode_128raw_verify+0x4c>
lea    0x8(%rsp),%rcx
lea    0xc(%rsp),%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  df2 <Barcode_128raw_verify+0x2b>
test   %eax,%eax
jle    e1a <Barcode_128raw_verify+0x53>
cmpl   $0x69,0xc(%rsp)
ja     e21 <Barcode_128raw_verify+0x5a>
movslq 0x8(%rsp),%rax
add    %rax,%rbx
cmpb   $0x0,(%rbx)
jne    dd6 <Barcode_128raw_verify+0xf>
jmp    e28 <Barcode_128raw_verify+0x61>
mov    $0xffffffff,%eax
jmp    e2d <Barcode_128raw_verify+0x66>
mov    $0x0,%eax
jmp    e2d <Barcode_128raw_verify+0x66>
mov    $0xffffffff,%eax
jmp    e2d <Barcode_128raw_verify+0x66>
mov    $0xffffffff,%eax
jmp    e2d <Barcode_128raw_verify+0x66>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
Barcode_128raw_verify(char *text)
{
    int n;
    unsigned val;
    if (!strlen(text))
 return -1;
    while (*text) {
 if (sscanf(text, "%u%n", &val, &n) < 1)
     return -1;
 if (val > 105)
     return -1;
 text += n;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 12
18 12
19 7
20 7
21 7
22 6
23 6
24 14
25 14
26 9
27 9
28 11
29 11
30 14
31 15
32 15
33 15
<<<sep_out_sample>>>
mov    0x260(%rdi),%rax
movl   $0x0,0x48(%rax)
mov    0x8c(%rdi),%edx
mov    %edx,0x50(%rax)
retq   
<<<sep_in_sample>>>
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  upsample->spare_full = 0;
  upsample->rows_to_go = cinfo->output_height;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
mov    %rcx,%r12
mov    %r8,%r13
callq  2dc2 <mbox_header_fill+0x1b>
mov    %rax,%rdi
callq  2dca <mbox_header_fill+0x23>
mov    0x10(%rax),%rdx
mov    %rdx,0x8(%rsp)
mov    0x8(%rax),%rdx
mov    %rdx,(%rsp)
mov    $0x0,%r9d
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  2b6c <mbox_readstream>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mbox_header_fill (mu_header_t header, char *buffer, size_t len,
    mu_off_t off, size_t *pnread)
{
  mu_message_t msg = mu_header_get_owner (header);
  mbox_message_t mum = mu_message_get_owner (msg);
  return mbox_readstream (mum, buffer, len, off, pnread, 0,
     mum->header_from_end, mum->body);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 8
25 8
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x64,0x24(%rdi)
je     44a <jpeg_write_tables+0x22>
mov    (%rdi),%rax
movl   $0x14,0x28(%rax)
mov    (%rdi),%rax
mov    0x24(%rdi),%edx
mov    %edx,0x2c(%rax)
mov    (%rdi),%rax
callq  *(%rax)
mov    (%rbx),%rax
mov    %rbx,%rdi
callq  *0x20(%rax)
mov    0x28(%rbx),%rax
mov    %rbx,%rdi
callq  *0x10(%rax)
mov    %rbx,%rdi
callq  465 <jpeg_write_tables+0x3d>
mov    0x1d0(%rbx),%rax
mov    %rbx,%rdi
callq  *0x20(%rax)
mov    0x28(%rbx),%rax
mov    %rbx,%rdi
callq  *0x20(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
jpeg_write_tables (j_compress_ptr cinfo)
{
  if (cinfo->global_state != 100)
    ((cinfo)->err->msg_code = (JERR_BAD_STATE), (cinfo)->err->msg_parm.i[0] = (cinfo->global_state), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  jinit_marker_writer(cinfo);
  (*cinfo->marker->write_tables_only) (cinfo);
  (*cinfo->dest->term_destination) (cinfo);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 10
27 10
<<<sep_out_sample>>>
mov    %rsi,0x38(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_client_callback_authentication_id_set (Gsasl * ctx,
          Gsasl_client_callback_authentication_id
          cb)
{
  ctx->cbc_authentication_id = cb;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     3c9 <sv_combegin+0x59>
mov    $0x1,%eax
cmpb   $0x0,(%rdi)
je     3ce <sv_combegin+0x5e>
mov    0x0(%rip),%rdi        # 38a <sv_combegin+0x1a>
test   %rdi,%rdi
je     394 <sv_combegin+0x24>
callq  394 <sv_combegin+0x24>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  3b0 <sv_combegin+0x40>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3bb <sv_combegin+0x4b>
mov    %rax,0x0(%rip)        # 3c2 <sv_combegin+0x52>
mov    $0x0,%eax
jmp    3ce <sv_combegin+0x5e>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sv_combegin (value)
     const char *value;
{
  if (value && *value)
    {
      if (_rl_comment_begin) free (_rl_comment_begin);
      _rl_comment_begin = strcpy ((char *)xmalloc (1 + strlen (value)), (value));
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 10
6 4
7 4
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 10
26 11
27 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b6 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rdi,%rax
jmp    8 <sha1_says_nonexistent+0x8>
inc    %rax
mov    (%rax),%dl
cmp    $0x30,%dl
je     5 <sha1_says_nonexistent+0x5>
mov    $0x2,%eax
test   %dl,%dl
je     37 <sha1_says_nonexistent+0x37>
mov    $0x0,%edx
jmp    29 <sha1_says_nonexistent+0x29>
cmp    (%rdx),%al
jne    2f <sha1_says_nonexistent+0x2f>
inc    %rdi
inc    %rdx
mov    (%rdi),%al
test   %al,%al
jne    1f <sha1_says_nonexistent+0x1f>
test   %al,%al
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
sha1_says_nonexistent(char const *sha1)
{
  char const *empty_sha1 = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
  char const *s;
  for (s = sha1; *s; s++)
    if (*s != '0')
      break;
  if (! *s)
    return 2;
  for (s = sha1; *s; s++, empty_sha1++)
    if (*s != *empty_sha1)
      break;
  return ! *s;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 6
6 6
7 9
8 8
9 8
10 8
11 8
12 11
13 11
14 10
15 10
16 10
17 10
18 10
19 13
20 13
21 13
22 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4f <crlf+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  48 <node_ident_cmp+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
node_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)
{
 return strcmp(a->ident, b->ident);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rdx
mov    %r9,%rbp
mov    0x8(%rdi),%rdi
mov    0x10(%rbx),%r8
mov    (%rbx),%rsi
callq  81 <polynomial_deriv2+0x1f>
mov    0x8(%rbx),%rax
movsd  0x10(%rax),%xmm0
addsd  %xmm0,%xmm0
movsd  %xmm0,0x0(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
polynomial_deriv2 (const void *vstate,
                   const double xa[], const double ya[], size_t size,
                   double x, gsl_interp_accel * acc, double *y)
{
  const polynomial_state_t *state = (const polynomial_state_t *) vstate;
  gsl_poly_dd_taylor (state->coeff, x, state->d, xa, size, state->work);
  *y = 2.0 * state->coeff[2];
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 10d <malloc_set_trace+0x6>
mov    %edi,0x0(%rip)        # 113 <malloc_set_trace+0xc>
cmp    $0x1,%edi
setg   %dl
movzbl %dl,%edx
mov    %edx,0x0(%rip)        # 122 <malloc_set_trace+0x1b>
retq   
<<<sep_in_sample>>>
malloc_set_trace (n)
     int n;
{
  int old;
  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 7
6 7
7 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  1bd <gsl_spline_min_size+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline_min_size(const gsl_spline * spline)
{
  return gsl_interp_min_size(spline->interp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rdx,%r12
mov    $0x0,%edi
mov    $0x2,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    cab <grecs_match_first+0x36>
movq   $0x0,(%r12)
mov    %r13,%rax
jmp    d09 <grecs_match_first+0x94>
mov    $0x30,%edi
callq  cb5 <grecs_match_first+0x40>
mov    %rax,%rbp
lea    0x18(%rax),%rcx
lea    0x8(%rax),%rdx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  1f2 <split_cfg_path>
test   %eax,%eax
je     cde <grecs_match_first+0x69>
mov    %rbp,%rdi
callq  cd7 <grecs_match_first+0x62>
mov    $0x0,%eax
jmp    d09 <grecs_match_first+0x94>
mov    %r13,%rsi
mov    %rbp,%rdi
callq  ce9 <grecs_match_first+0x74>
test   %rax,%rax
je     cf4 <grecs_match_first+0x7f>
mov    %rbp,(%r12)
jmp    d09 <grecs_match_first+0x94>
mov    %rbp,%rdi
callq  cfc <grecs_match_first+0x87>
movq   $0x0,(%r12)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
grecs_match_first(struct grecs_node *tree, const char *pattern,
    struct grecs_match_buf **pbuf)
{
 struct grecs_node *node;
 struct grecs_match_buf *buf;
 if (strcmp(pattern, ".") == 0) {
  *pbuf = ((void *)0);
  return tree;
 }
 buf = grecs_zalloc(sizeof(*buf));
 if (split_cfg_path(pattern, &buf->argc, &buf->argv, &buf->labelv)) {
  free(buf);
  return ((void *)0);
 }
 node = grecs_match_buf_first(buf, tree);
 if (node)
  *pbuf = buf;
 else {
  grecs_match_buf_free(buf);
  *pbuf = ((void *)0);
 }
 return node;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 8
18 8
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 13
32 13
33 15
34 15
35 15
36 16
37 16
38 17
39 17
40 19
41 19
42 20
43 22
44 23
45 23
46 23
47 23
48 23
49 23
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
cmp    $0x773593ff,%edi
jle    162a <uxfio_decr_use_count+0x43>
sub    $0x18,%rsp
mov    $0x1,%edx
lea    0x8(%rsp),%rsi
callq  b7 <table_find>
test   %eax,%eax
jne    1621 <uxfio_decr_use_count+0x3a>
mov    0x8(%rsp),%rdx
mov    0x98(%rdx),%eax
sub    $0x1,%eax
mov    %eax,0x98(%rdx)
jmp    1626 <uxfio_decr_use_count+0x3f>
mov    $0xffffffff,%eax
add    $0x18,%rsp
repz retq 
<<<sep_in_sample>>>
uxfio_decr_use_count(int fd)
{
 UXFIO *uxfio;
 ;
 if (fd < 2000000000 ){
  return -1;
 }
 if (table_find(fd, &uxfio, 1)) {
  return -1;
 }
 return --(uxfio->use_countM);
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 2
5 8
6 8
7 8
8 8
9 8
10 11
11 11
12 11
13 11
14 11
15 9
16 12
17 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x18(%rsi),%rcx
mov    0x40(%rsi),%rdx
mov    0x30(%rsi),%rdi
mov    $0x1,%esi
callq  6f3 <get_raw_row+0x22>
cmp    0x40(%rbx),%rax
je     70d <get_raw_row+0x3c>
mov    0x0(%rbp),%rax
movl   $0x2b,0x28(%rax)
mov    0x0(%rbp),%rax
mov    %rbp,%rdi
callq  *(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
get_raw_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  ppm_source_ptr source = (ppm_source_ptr) sinfo;
  if (! (((size_t) fread((void *) (source->iobuffer), (size_t) 1, (size_t) (source->buffer_width), (source->pub.input_file))) == ((size_t) (source->buffer_width))))
    ((cinfo)->err->msg_code = (JERR_INPUT_EOF), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <__db_vrfy_pgset_iinc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
CDB___db_vrfy_pgset_inc(dbp, pgno)
 DB *dbp;
 db_pgno_t pgno;
{
 return (__db_vrfy_pgset_iinc(dbp, pgno, 1));
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     222 <mu_opool_clear+0x2d>
mov    0x20(%rdi),%rax
test   %rax,%rax
je     222 <mu_opool_clear+0x2d>
mov    0x28(%rdi),%rdx
mov    %rdx,(%rax)
mov    0x18(%rdi),%rax
mov    %rax,0x28(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x18(%rdi)
repz retq 
<<<sep_in_sample>>>
mu_opool_clear (mu_opool_t opool)
{
  if (!opool)
    return;
  if (opool->tail)
    {
      opool->tail->next = opool->free;
      opool->free = opool->head;
      opool->head = opool->tail = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 8
9 8
10 9
11 9
12 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r13d
mov    %esi,%r12d
mov    %rdx,%rbp
test   %rdx,%rdx
jle    127e <copy_files_tape_to_disk+0x96>
cmpq   $0x0,0x0(%rip)        # 1208 <copy_files_tape_to_disk+0x20>
jne    1218 <copy_files_tape_to_disk+0x30>
mov    0x0(%rip),%esi        # 1210 <copy_files_tape_to_disk+0x28>
mov    %r13d,%edi
callq  fb7 <tape_fill_input_buffer>
mov    0x0(%rip),%rbx        # 121f <copy_files_tape_to_disk+0x37>
cmp    %rbx,%rbp
cmovbe %rbp,%rbx
mov    %rbx,%rdx
cmpl   $0x0,0x0(%rip)        # 1230 <copy_files_tape_to_disk+0x48>
je     1256 <copy_files_tape_to_disk+0x6e>
test   %rbx,%rbx
jle    1256 <copy_files_tape_to_disk+0x6e>
mov    0x0(%rip),%rsi        # 123e <copy_files_tape_to_disk+0x56>
mov    $0x0,%eax
movzbl (%rsi,%rax,1),%ecx
add    %ecx,0x0(%rip)        # 124d <copy_files_tape_to_disk+0x65>
add    $0x1,%rax
cmp    %rax,%rdx
jne    1243 <copy_files_tape_to_disk+0x5b>
mov    %rbx,%rdx
mov    %r12d,%esi
mov    0x0(%rip),%rdi        # 1263 <copy_files_tape_to_disk+0x7b>
callq  1268 <copy_files_tape_to_disk+0x80>
sub    %rbx,%rbp
sub    %rbx,0x0(%rip)        # 1272 <copy_files_tape_to_disk+0x8a>
add    %rbx,0x0(%rip)        # 1279 <copy_files_tape_to_disk+0x91>
test   %rbp,%rbp
jg     1200 <copy_files_tape_to_disk+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
copy_files_tape_to_disk (int in_des, int out_des, off_t num_bytes)
{
  off_t size;
  off_t k;
  while (num_bytes > 0)
    {
      if (input_size == 0)
 tape_fill_input_buffer (in_des, io_block_size);
      size = (input_size < num_bytes) ? input_size : num_bytes;
      if (crc_i_flag)
 {
   for (k = 0; k < size; ++k)
     crc += in_buff[k] & 0xff;
 }
      disk_buffered_write (in_buff, out_des, size);
      num_bytes -= size;
      input_size -= size;
      in_buff += size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 10
21 10
22 12
23 12
24 13
25 13
26 13
27 13
28 12
29 12
30 12
31 15
32 15
33 15
34 15
35 16
36 17
37 18
38 5
39 5
40 20
41 20
42 20
43 20
44 20
45 20
<<<sep_out_sample>>>
sub    $0xe8,%rsp
mov    %rdi,0x8(%rsp)
mov    %rdx,0x40(%rsp)
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
test   %al,%al
je     5e <__gmp_sscanf+0x5e>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
mov    %rsi,%rdx
movl   $0x10,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
mov    %rax,0x28(%rsp)
lea    0x18(%rsp),%rcx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  9c <__gmp_sscanf+0x9c>
add    $0xe8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_sscanf (const char *s, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_doscan (&__gmp_sscanf_funs, (void *) &s, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 9
29 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x4,0x44(%rdi)
je     1a <force_string+0x1a>
mov    0x20(%rdi),%eax
cmp    $0xffffffff,%eax
je     32 <force_string+0x32>
cmp    0x0(%rip),%eax        # 18 <force_string+0x18>
je     37 <force_string+0x37>
mov    %rdi,%rdx
mov    0x0(%rip),%esi        # 23 <force_string+0x23>
mov    0x0(%rip),%rdi        # 2a <force_string+0x2a>
callq  *0x0(%rip)        # 30 <force_string+0x30>
jmp    3a <force_string+0x3a>
mov    %rdi,%rax
jmp    3a <force_string+0x3a>
mov    %rdi,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
force_string(NODE *s)
{
 if ((s->flags & 0x0004) != 0
      && (s->sub.val.idx == -1 || s->sub.val.idx == CONVFMTidx)
 )
  return s;
 return format_val(CONVFMT, CONVFMTidx, s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 7
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 8
18 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %edi,%ebp
mov    %rsi,%r12
lea    0x1(%rdi),%edi
movslq %edi,%rdi
shl    $0x3,%rdi
callq  7b <dappprun+0x1c>
mov    %rax,%rbx
test   %rax,%rax
jne    97 <dappprun+0x38>
mov    $0x0,%edi
callq  8d <dappprun+0x2e>
mov    $0x1,%edi
callq  97 <dappprun+0x38>
mov    0x0(%rip),%rax        # 9e <dappprun+0x3f>
mov    %rax,(%rbx)
cmp    $0x1,%ebp
jle    109 <dappprun+0xaa>
mov    $0x0,%r8d
mov    $0x1,%eax
mov    $0x3,%r9d
mov    $0x7,%r10d
jmp    cf <dappprun+0x70>
mov    %rdx,0x8(%rbx,%r8,1)
add    $0x1,%eax
add    $0x8,%r8
cmp    %ebp,%eax
je     10e <dappprun+0xaf>
mov    0x8(%r12,%r8,1),%rdx
mov    $0x0,%edi
mov    %rdx,%rsi
mov    %r9,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dil
setb   %sil
cmp    %sil,%dil
je     10e <dappprun+0xaf>
mov    $0x0,%edi
mov    %rdx,%rsi
mov    %r10,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %sil
setb   %cl
cmp    %cl,%sil
jne    bf <dappprun+0x60>
jmp    10e <dappprun+0xaf>
mov    $0x1,%eax
cltq   
movq   $0x0,(%rbx,%rax,8)
callq  11d <dappprun+0xbe>
test   %eax,%eax
jne    159 <dappprun+0xfa>
mov    0x0(%rip),%rcx        # 128 <dappprun+0xc9>
mov    $0x11,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  13c <dappprun+0xdd>
mov    %rbx,%rsi
mov    (%rbx),%rdi
callq  147 <dappprun+0xe8>
mov    (%rbx),%rdi
callq  14f <dappprun+0xf0>
mov    $0x1,%edi
callq  159 <dappprun+0xfa>
cmp    $0xffffffff,%eax
jne    172 <dappprun+0x113>
mov    $0x0,%edi
callq  168 <dappprun+0x109>
mov    $0x1,%edi
callq  172 <dappprun+0x113>
mov    $0x0,%edx
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  183 <dappprun+0x124>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dappprun(int argc, char **argv)
{
  char **arg;
  int a;
  int status;
  pid_t pid;
  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))
    {
      perror("dap");
      exit(1);
    }
  arg[0] = dappp;
  for (a = 1; a < argc && strcmp(argv[a], "-a") && strcmp(argv[a], "--args"); a++)
    arg[a] = argv[a];
  arg[a] = ((void *)0);
  if (!(pid = fork()))
    {
      fputs("Preprocessing...\n", stderr);
      execv(arg[0], arg);
      perror(arg[0]);
      exit(1);
    }
  else if (pid == -1)
    {
      perror("dap");
      exit(1);
    }
  waitpid(pid, &status, 0);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 12
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 15
52 15
53 16
54 16
55 16
56 18
57 18
58 18
59 18
60 18
61 19
62 19
63 19
64 20
65 20
66 21
67 21
68 23
69 23
70 25
71 25
72 26
73 26
74 28
75 28
76 28
77 28
78 30
79 30
80 30
81 30
82 30
83 30
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdx
mov    $0x5413,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3e <getScreenSize+0x1b>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 48 <getScreenSize+0x25>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 53 <getScreenSize+0x30>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsp,%rdi
movsd  (%rbx),%xmm0
callq  170d <gsl_sf_angle_restrict_pos_e+0x14>
movsd  (%rsp),%xmm0
movsd  %xmm0,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sf_angle_restrict_pos_e(double * theta)
{
  gsl_sf_result r;
  int stat = gsl_sf_angle_restrict_pos_err_e(*theta, &r);
  *theta = r.val;
  return stat;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    -0x33(%rdx),%eax
cmp    $0x1,%eax
ja     502 <print_size_rdev+0x2a>
mov    0x50(%rsi),%rcx
mov    0x58(%rsi),%r8
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x0,%eax
callq  500 <print_size_rdev+0x28>
jmp    537 <print_size_rdev+0x5f>
sub    $0x31,%edx
mov    $0x0,%edi
cmp    $0x1,%edx
jbe    513 <print_size_rdev+0x3b>
mov    0x38(%rsi),%rdi
mov    $0x0,%esi
callq  51d <print_size_rdev+0x45>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  537 <print_size_rdev+0x5f>
pop    %rbx
retq   
<<<sep_in_sample>>>
print_size_rdev(STROB * fp, struct new_cpio_header * file_hdr, int type)
{
 intmax_t sizeme;
 if ((type == '3') || (type == '4')) {
  strob_sprintf(fp, 1, "%4lu,%4lu", (unsigned long)(file_hdr->c_rdev_maj), (unsigned long)(file_hdr->c_rdev_min));
 } else {
  if ((type == '2') || (type == '1')) {
   sizeme = 0;
  } else {
   sizeme = (intmax_t)(file_hdr->c_filesize);
  }
  strob_sprintf(fp, 1, "%s", swlib_imaxtostr(sizeme, ((void *)0)));
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 8
15 7
16 7
17 10
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 14
27 14
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     3b0 <error+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    $0x0,%edi
callq  3e4 <error+0x90>
lea    0x8(%rsp),%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
callq  3f9 <error+0xa5>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
error(const char *mesg, ...)
{
 va_list args;
 __builtin_va_start(args,mesg);
 err(0, gettext("error: "), mesg, args);
 __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x2,%edi
callq  249 <get_symbols>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
variable_list()
{
 return get_symbols(VARIABLE, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %edx,%ebx
mov    0x0(%rip),%eax        # 2d6 <writeit+0x11>
movslq %eax,%rdx
mov    %rdx,%r8
shl    $0x9,%r8
mov    %ebx,0x0(%r8,%rdx,8)
test   %eax,%eax
sete   %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 2f6 <writeit+0x31>
cltq   
mov    %rax,%rdx
shl    $0x9,%rdx
cmpl   $0xfffffffe,0x0(%rdx,%rax,8)
je     310 <writeit+0x4b>
mov    %ecx,%esi
callq  310 <writeit+0x4b>
movslq 0x0(%rip),%rax        # 317 <writeit+0x52>
mov    %rax,%rdx
shl    $0x9,%rdx
lea    (%rdx,%rax,8),%rax
movl   $0xfffffffd,0x0(%rax)
add    $0x0,%rax
mov    %rax,0x0(%rbp)
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
writeit (FILE * file, struct tftphdr **dpp, int ct, int convert)
{
  bfs[current].counter = ct;
  current = !current;
  if (bfs[current].counter != -2)
    write_behind (file, convert);
  bfs[current].counter = -3;
  *dpp = (struct tftphdr *) bfs[current].buf;
  return ct;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 8
28 8
29 10
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     323 <recutl_warning+0x5d>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rsi        # 354 <recutl_warning+0x8e>
mov    0x0(%rip),%rdi        # 35b <recutl_warning+0x95>
callq  360 <recutl_warning+0x9a>
mov    0x0(%rip),%rbp        # 367 <recutl_warning+0xa1>
mov    $0x0,%edi
callq  371 <recutl_warning+0xab>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  37c <recutl_warning+0xb6>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 38b <recutl_warning+0xc5>
callq  390 <recutl_warning+0xca>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
recutl_warning (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  fputs (program_name, stderr);
  fputs (gettext (": warning: "), stderr);
  rpl_vfprintf (stderr, fmt, ap);
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 4
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 6
30 6
31 6
32 6
33 6
34 6
35 7
36 7
37 7
38 7
39 9
40 9
41 9
42 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_uint_size (const gsl_block_uint * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
mov    0x8(%rsi),%rbx
mov    $0xffffffff,%eax
test   %rbx,%rbx
je     13c <i_getEnumFromName+0x6c>
mov    %rdi,%r12
mov    %rsi,%rbp
jmp    100 <i_getEnumFromName+0x30>
add    $0x28,%rbp
mov    0x8(%rbp),%rbx
test   %rbx,%rbx
je     130 <i_getEnumFromName+0x60>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  10b <i_getEnumFromName+0x3b>
test   %eax,%eax
jne    f3 <i_getEnumFromName+0x23>
test   %rbx,%rbx
je     137 <i_getEnumFromName+0x67>
sub    %r13,%rbp
movabs $0xcccccccccccccccd,%rdx
mov    %rbp,%rax
mul    %rdx
shr    $0x5,%rdx
mov    %rdx,%rax
jmp    13c <i_getEnumFromName+0x6c>
mov    $0xffffffff,%eax
jmp    13c <i_getEnumFromName+0x6c>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
i_getEnumFromName(char * optionname, struct extendedOptions * peop)
{
 struct extendedOptions * eop;
 eop = peop;
 while (eop->optionNameM && strcmp(eop->optionNameM, optionname)) {
  eop ++;
 }
 if (eop->optionNameM == ((void *)0)) return -1;
 return (((char*)eop) - (char*)peop) / sizeof(struct extendedOptions);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 8
9 5
10 5
11 5
12 4
13 4
14 6
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 8
24 8
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 8
33 8
34 8
35 10
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <str_eq+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
str_eq (const void *elt1, const void *elt2)
{
  return strcmp (elt1, elt2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
cmpb   $0x0,(%rdi)
je     9f <putback+0x5f>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rsi
lea    -0x1(%rcx),%rbp
cmp    0x0(%rip),%rcx        # 6d <putback+0x2d>
jbe    89 <putback+0x49>
mov    %rcx,0x0(%rip)        # 76 <putback+0x36>
mov    0x0(%rip),%rdi        # 7d <putback+0x3d>
callq  82 <putback+0x42>
mov    %rax,0x0(%rip)        # 89 <putback+0x49>
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 93 <putback+0x53>
callq  98 <putback+0x58>
mov    %rbp,0x0(%rip)        # 9f <putback+0x5f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
putback (const char *str)
{
  size_t len;
  if (!*str)
    return;
  len = strlen (str) + 1;
  if (len > putback_max)
    {
      putback_max = len;
      putback_buffer = xrealloc (putback_buffer, putback_max);
    }
  strcpy (putback_buffer, str);
  putback_size = len - 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 10
17 10
18 10
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  114e <input>
lea    -0x30(%rax),%edx
cmp    $0x48,%edx
ja     154b <backslash+0x64>
mov    %edx,%edx
jmpq   *0x0(,%rdx,8)
mov    $0x7,%eax
jmp    154b <backslash+0x64>
mov    $0xc,%eax
jmp    154b <backslash+0x64>
mov    $0xa,%eax
jmp    154b <backslash+0x64>
mov    $0xd,%eax
jmp    154b <backslash+0x64>
mov    $0x9,%eax
jmp    154b <backslash+0x64>
mov    $0x2,%esi
mov    $0x10,%edi
callq  124a <getnum>
jmp    154b <backslash+0x64>
mov    $0x3,%esi
mov    $0x8,%edi
callq  124a <getnum>
jmp    154b <backslash+0x64>
mov    $0x8,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
backslash()
{
     int c;
     switch (c = input()) {
     case 'a': return '\a';
     case 'b': return '\b';
     case 'f': return '\f';
     case 'n': return '\n';
     case 'r': return '\r';
     case 't': return '\t';
     case 'x': return getnum(16,2);
     case '0': return getnum(8,3);
     }
     return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 11
19 11
20 11
21 11
22 12
23 12
24 12
25 12
26 6
27 15
28 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     155 <mu_ticket_set_secret+0x35>
mov    %rsi,%rbp
mov    0x18(%rdi),%rdi
test   %rdi,%rdi
je     144 <mu_ticket_set_secret+0x24>
callq  144 <mu_ticket_set_secret+0x24>
mov    %rbp,%rdi
callq  14c <mu_ticket_set_secret+0x2c>
mov    %rbp,0x18(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_ticket_set_secret (mu_ticket_t ticket, mu_secret_t secret)
{
  if (ticket == ((void *)0))
    return 22;
  if (ticket->secret)
    mu_secret_unref (ticket->secret);
  mu_secret_ref (secret);
  ticket->secret = secret;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 5
12 6
13 7
14 7
15 8
16 9
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    $0x1,%edi
jle    284 <helpFlag+0x28>
mov    0x8(%rsi),%rsi
mov    $0x0,%edi
mov    $0x7,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
sete   %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
helpFlag(int argc, char **argv) {
 return (argc > 1 && !strcmp(argv[1], "--help"));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    %rsi,%r8
test   %rsi,%rsi
je     29 <print_str+0x29>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
jmp    34 <print_str+0x34>
mov    $0x1,%esi
mov    $0x0,%r8d
mov    %rdx,%rcx
mov    $0x1,%edx
mov    %r8,%rdi
callq  44 <print_str+0x44>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_str(FILE *fp, const char *arg)
{
    size_t len;
    if (!arg) {
 arg = "-";
 len = 1;
    } else
 len = strlen(arg);
    fwrite(arg, len, 1, fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 6
14 5
15 9
16 9
17 9
18 9
19 10
20 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
mov    %rsi,0x88(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_securid_set (Gsasl * ctx,
       Gsasl_server_callback_securid cb)
{
  ctx->cbs_securid = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 261a <c_set_lineno+0x6>
retq   
<<<sep_in_sample>>>
c_set_lineno (int line_number )
{
    c_lineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,%r12
mov    %rdx,%r15
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     1b4f <gsl_matrix_short_fprintf+0x46>
add    %rax,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     1b9b <gsl_matrix_short_fprintf+0x92>
jmp    1b6d <gsl_matrix_short_fprintf+0x64>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    %r15,%r8
mov    $0x1,%ecx
mov    (%rsp),%rdi
callq  1b6b <gsl_matrix_short_fprintf+0x62>
jmp    1b9b <gsl_matrix_short_fprintf+0x92>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    %r15,%r8
mov    $0x1,%ecx
mov    %r13,%rdx
mov    (%rsp),%rdi
callq  1b89 <gsl_matrix_short_fprintf+0x80>
test   %eax,%eax
jne    1b9b <gsl_matrix_short_fprintf+0x92>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    1b6d <gsl_matrix_short_fprintf+0x64>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_short_fprintf (FILE * stream, const gsl_matrix_short * m,
                                const char *format)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_short_raw_fprintf (stream,
                                                  m->data,
                                                  size1 * size2, 1,
                                                  format);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_short_raw_fprintf (stream,
                                                      m->data + i * 1 * tda,
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 6
13 7
14 8
15 8
16 21
17 21
18 21
19 21
20 18
21 18
22 18
23 18
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 24
40 24
41 18
42 18
43 18
44 18
45 29
46 29
47 29
48 29
49 29
50 29
51 29
52 29
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     35 <enqueue+0x35>
mov    %rsi,%rbp
mov    (%rdi),%rdi
callq  0 <enqueue>
mov    0x8(%rbx),%rdi
mov    %rbp,%rsi
callq  0 <enqueue>
mov    0x0(%rbp),%rdx
mov    0x10(%rbx),%rax
mov    %rax,0x18(%rdx)
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
enqueue (struct tree *tree, struct trie **last)
{
  if (!tree)
    return;
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  (*last) = (*last)->next = tree->trie;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  c0b <message_add_command+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
message_add_command (MESSAGE msg, ASSOC *p)
{
  list_append (msg->commands, p);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rdi
mov    %rdx,%rbx
mov    %rax,%rdx
mov    %rbx,%rsi
callq  f8c <insert_num>
test   %rax,%rax
je     10d0 <parse_uid+0x3d>
movss  0x0(%rip),%xmm0        # 10b5 <parse_uid+0x22>
cmpq   $0x63,0x40(%rax)
ja     10c4 <parse_uid+0x31>
movss  0x0(%rip),%xmm0        # 10c4 <parse_uid+0x31>
movss  %xmm0,0x24(%rax)
mov    $0x1,%eax
jmp    10d8 <parse_uid+0x45>
subl   $0x1,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *p = insert_num (argv, arg_ptr, entry);
  if (p)
    {
      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
      return 1;
    }
  else
    {
      --*arg_ptr;
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 11
18 12
19 14
20 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
mov    $0x1,%r9d
callq  51 <rpl_getopt_long_only+0x16>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
rpl_getopt_long_only (int argc, char * *argv,
    const char *options,
    const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
      opt_index, 1, 0);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 7
6 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  6e <html_styled_ostream__write_mem+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
html_styled_ostream__write_mem (html_styled_ostream_t stream,
                                const void *data, size_t len)
{
  html_ostream_write_mem (stream->html_destination, data, len);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    0x30(%rdi),%rbp
lea    -0x1(%rsi),%rdx
cmp    %rdx,%rbp
ja     2d4 <gl_array_remove_node+0x22>
callq  2d4 <gl_array_remove_node+0x22>
mov    0x28(%rdi),%r13
mov    0x18(%rdi),%rax
test   %rax,%rax
je     2e8 <gl_array_remove_node+0x36>
mov    0x0(%r13,%rdx,8),%rdi
callq  *%rax
cmp    %r12,%rbp
jbe    307 <gl_array_remove_node+0x55>
lea    0x0(%r13,%r12,8),%rax
lea    0x0(%r13,%rbp,8),%rcx
mov    (%rax),%rdx
mov    %rdx,-0x8(%rax)
add    $0x8,%rax
cmp    %rcx,%rax
jne    2f7 <gl_array_remove_node+0x45>
sub    $0x1,%rbp
mov    %rbp,0x30(%rbx)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gl_array_remove_node (gl_list_t list, gl_list_node_t node)
{
  size_t count = list->count;
  unsigned long index = ((unsigned long)(node) - 1);
  size_t position;
  const void **elements;
  size_t i;
  if (!(index < count))
    abort ();
  position = index;
  elements = list->elements;
  if (list->base.dispose_fn != ((void *)0))
    list->base.dispose_fn (elements[position]);
  for (i = position + 1; i < count; i++)
    elements[i - 1] = elements[i];
  list->count = count - 1;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 8
11 8
12 9
13 11
14 12
15 12
16 12
17 13
18 13
19 14
20 14
21 14
22 14
23 15
24 15
25 15
26 14
27 14
28 16
29 16
30 18
31 18
32 18
33 18
34 18
35 18
36 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1a4c <gsl_complex_coth+0x9>
callq  1a51 <gsl_complex_coth+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_coth (gsl_complex a)
{
  gsl_complex z = gsl_complex_tanh (a);
  return gsl_complex_inverse (z);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
lea    0xc(%rsp),%rdx
mov    $0x0,%esi
callq  2f8 <print_qword+0x1d>
test   %r12d,%r12d
je     314 <print_qword+0x39>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  30f <print_qword+0x34>
jmpq   3af <print_qword+0xd4>
mov    %rax,%rbp
cmpb   $0x0,(%rbx)
jne    324 <print_qword+0x49>
movl   $0x1,0xc(%rsp)
cmp    0x0(%rip),%rbp        # 32b <print_qword+0x50>
jb     369 <print_qword+0x8e>
lea    0x1(%rbp),%rsi
mov    %rsi,0x0(%rip)        # 338 <print_qword+0x5d>
mov    0x0(%rip),%rdi        # 33f <print_qword+0x64>
callq  344 <print_qword+0x69>
mov    %rax,0x0(%rip)        # 34b <print_qword+0x70>
test   %rax,%rax
jne    369 <print_qword+0x8e>
mov    $0x0,%ecx
mov    $0x8f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  369 <print_qword+0x8e>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 378 <print_qword+0x9d>
callq  37d <print_qword+0xa2>
mov    0x0(%rip),%rsi        # 384 <print_qword+0xa9>
movb   $0x0,(%rsi,%rbp,1)
cmpl   $0x0,0xc(%rsp)
je     3a0 <print_qword+0xc5>
mov    $0x0,%edi
mov    $0x0,%eax
callq  39e <print_qword+0xc3>
jmp    3af <print_qword+0xd4>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3af <print_qword+0xd4>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_qword (const char *word, int plaintext)
{
  static char *qbuf = ((void *)0);
  static size_t qlen = 0;
  int quote;
  size_t size = wordsplit_c_quoted_length (word, 0, &quote);
  if (plaintext)
    {
      printf ("%s", word);
      return;
    }
  if (*word == 0)
    quote = 1;
  if (size >= qlen)
    {
      qlen = size + 1;
      qbuf = realloc (qbuf, qlen);
      ((qbuf != ((void *)0)) ? (void) (0) : __assert_fail ("qbuf != ((void *)0)", "wsp.c", 143, __PRETTY_FUNCTION__));
    }
  wordsplit_c_quote_copy (qbuf, word, 0);
  qbuf[size] = 0;
  if (quote)
    printf ("\"%s\"", qbuf);
  else
    printf ("%s", qbuf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 12
19 12
20 13
21 14
22 14
23 16
24 16
25 17
26 17
27 17
28 18
29 18
30 18
31 18
32 18
33 18
34 18
35 20
36 20
37 20
38 20
39 21
40 21
41 22
42 22
43 23
44 23
45 23
46 23
47 25
48 25
49 25
50 26
51 26
52 26
53 26
54 26
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r12
test   %rdi,%rdi
jne    335 <localtime_rz+0x28>
mov    %rdx,%rsi
mov    %rbx,%rdi
callq  330 <localtime_rz+0x23>
mov    %rax,%rbx
jmp    391 <localtime_rz+0x84>
callq  1fd <set_tz>
mov    %rax,%r13
test   %rax,%rax
je     37b <localtime_rz+0x6e>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  34d <localtime_rz+0x40>
mov    %rax,%rbx
test   %rax,%rax
je     389 <localtime_rz+0x7c>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  b0 <save_abbr>
mov    %eax,%ebx
mov    %r13,%rdi
callq  2a5 <revert_tz>
test   %al,%al
je     382 <localtime_rz+0x75>
test   %bl,%bl
mov    $0x0,%ebx
cmovne %r12,%rbx
jmp    391 <localtime_rz+0x84>
mov    $0x0,%ebx
jmp    391 <localtime_rz+0x84>
mov    $0x0,%ebx
jmp    391 <localtime_rz+0x84>
mov    %r13,%rdi
callq  2a5 <revert_tz>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
{
  if (!tz)
    return gmtime_r (t, tm);
  else
    {
      timezone_t old_tz = set_tz (tz);
      if (old_tz)
        {
          _Bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);
          if (revert_tz (old_tz) && abbr_saved)
            return tm;
        }
      return ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 7
17 7
18 8
19 8
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 11
43 11
44 16
45 16
46 16
47 16
48 16
49 16
50 16
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
mov    $0x1003,%eax
test   %rdi,%rdi
je     7b1 <mu_mailbox_uidvalidity+0x28>
mov    0xa8(%rdi),%rdx
test   %rdx,%rdx
je     7b1 <mu_mailbox_uidvalidity+0x28>
mov    $0x33,%al
testb  $0x8,0x31(%rdi)
jne    7b1 <mu_mailbox_uidvalidity+0x28>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailbox_uidvalidity (mu_mailbox_t mbox, unsigned long *pvalid)
{
  if (mbox == ((void *)0) || mbox->_uidvalidity == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_uidvalidity (mbox, pvalid);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 6
8 5
9 5
10 2
11 7
12 8
13 8
<<<sep_out_sample>>>
mov    0x320(%rdi),%rax
movsd  0x288(%rdi),%xmm0
addsd  0x1c0(%rax),%xmm0
movsd  %xmm0,0x288(%rdi)
movsd  0x1a8(%rax),%xmm1
ucomisd %xmm1,%xmm0
jbe    4a2 <speedBrakeExtend+0x35>
movsd  %xmm1,0x288(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
speedBrakeExtend(craft * c)
{
 c->speedBrakeSetting += c->cinfo->speedBrakeIncr;
 if (c->speedBrakeSetting > c->cinfo->maxSpeedBrake)
  c->speedBrakeSetting = c->cinfo->maxSpeedBrake;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 7
10 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rcx,%rbp
mov    0x40(%rdi),%rcx
lea    0x8(%rsp),%r8
callq  cd4 <mu_stream_sequential_read+0x1a>
test   %eax,%eax
jne    cea <mu_stream_sequential_read+0x30>
mov    0x8(%rsp),%rdx
add    %rdx,0x40(%rbx)
test   %rbp,%rbp
je     cea <mu_stream_sequential_read+0x30>
mov    %rdx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_stream_sequential_read (mu_stream_t stream, char *buf, size_t size,
      size_t *nbytes)
{
  size_t rdbytes;
  int rc = mu_stream_read (stream, buf, size, stream->offset, &rdbytes);
  if (!rc)
    {
      stream->offset += rdbytes;
      if (nbytes)
 *nbytes = rdbytes;
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 8
12 8
13 9
14 9
15 10
16 13
17 13
18 13
19 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %ecx,%r8d
mov    %edx,%ecx
mov    $0x2e,%edx
mov    $0x66,%esi
callq  9d0 <_ssexr>
mov    %rbp,%rdx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  876 <_jcc>
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_sse_bunordr_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_int32_t r1)
{
    _ssexr(_jit,0x66,0x2e,r0,r1);
    _jcc(_jit, 0xa, i0);
    return (_jit->pc.w);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 6
16 6
17 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm0        # 12 <init_diag_levenberg+0xc>
mov    %rsi,%rdi
callq  1a <init_diag_levenberg+0x14>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_diag_levenberg(const gsl_matrix * J, gsl_vector * diag)
{
  (void)J;
  gsl_vector_set_all(diag, 1.0);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
a2ps_printers_flag_output_name_get (struct a2ps_printers_s * printers)
{
  return (const char *) printers->flag_output_name;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
callq  b8 <_tcp_destroy+0x6>
mov    %rax,%rbx
mov    0x8(%rax),%rdi
test   %rdi,%rdi
je     c9 <_tcp_destroy+0x17>
callq  c9 <_tcp_destroy+0x17>
mov    (%rbx),%edi
cmp    $0xffffffff,%edi
je     d5 <_tcp_destroy+0x23>
callq  d5 <_tcp_destroy+0x23>
mov    %rbx,%rdi
callq  dd <_tcp_destroy+0x2b>
pop    %rbx
retq   
<<<sep_in_sample>>>
_tcp_destroy (mu_stream_t stream)
{
  struct _tcp_instance *tcp = mu_stream_get_owner (stream);
  if (tcp->host)
    free (tcp->host);
  if (tcp->fd != -1)
    close (tcp->fd);
  free (tcp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 6
9 6
10 6
11 7
12 8
13 8
14 9
15 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%r13
mov    %rdx,%r12
mov    %rcx,%rbp
mov    $0x48,%edi
callq  1e <argp_make_fmtstream+0x1e>
mov    %rax,%rbx
test   %rax,%rax
je     75 <argp_make_fmtstream+0x75>
mov    %r14,(%rax)
mov    %r13,0x8(%rax)
mov    %r12,0x10(%rax)
mov    %rbp,0x18(%rax)
movq   $0x0,0x28(%rax)
movq   $0x0,0x20(%rax)
mov    $0xc8,%edi
callq  4f <argp_make_fmtstream+0x4f>
mov    %rax,0x30(%rbx)
test   %rax,%rax
jne    67 <argp_make_fmtstream+0x67>
mov    %rbx,%rdi
callq  60 <argp_make_fmtstream+0x60>
mov    $0x0,%ebx
jmp    75 <argp_make_fmtstream+0x75>
mov    %rax,0x38(%rbx)
add    $0xc8,%rax
mov    %rax,0x40(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
argp_make_fmtstream (FILE *stream,
         size_t lmargin, size_t rmargin, ssize_t wmargin)
{
  argp_fmtstream_t fs;
  fs = (struct argp_fmtstream *) malloc (sizeof (struct argp_fmtstream));
  if (fs != ((void *)0))
    {
      fs->stream = stream;
      fs->lmargin = lmargin;
      fs->rmargin = rmargin;
      fs->wmargin = wmargin;
      fs->point_col = 0;
      fs->point_offs = 0;
      fs->buf = (char *) malloc (200);
      if (! fs->buf)
 {
   free (fs);
   fs = 0;
 }
      else
 {
   fs->p = fs->buf;
   fs->end = fs->buf + 200;
 }
    }
  return fs;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 6
14 6
15 8
16 9
17 10
18 11
19 12
20 13
21 14
22 14
23 14
24 15
25 15
26 17
27 17
28 18
29 18
30 22
31 23
32 23
33 27
34 27
35 27
36 27
37 27
38 27
39 27
<<<sep_out_sample>>>
movsd  %xmm1,-0x28(%rsp)
test   %rdx,%rdx
je     60 <gsl_stats_long_double_skew_m_sd+0x60>
shl    $0x4,%rsi
mov    $0x0,%eax
fldz   
movsd  %xmm0,-0x20(%rsp)
fldl   -0x20(%rsp)
fldl   -0x28(%rsp)
flds   0x0(%rip)        # 2a <gsl_stats_long_double_skew_m_sd+0x2a>
fldt   (%rdi)
fsub   %st(3),%st
fdiv   %st(2),%st
add    $0x1,%rax
fld    %st(0)
fmul   %st(1),%st
fmulp  %st,%st(1)
fsub   %st(4),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    4c <gsl_stats_long_double_skew_m_sd+0x4c>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(4)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    2a <gsl_stats_long_double_skew_m_sd+0x2a>
fstp   %st(0)
fstp   %st(0)
fstp   %st(0)
jmp    62 <gsl_stats_long_double_skew_m_sd+0x62>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_skew_m_sd (const long double data[],
                               const size_t stride, const size_t n,
                               const double mean, const double sd)
{
  long double skew = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      skew += (x * x * x - skew) / (i + 1);
    }
  return skew;
}
<<<sep_in_sample>>>
1 4
2 7
3 7
4 9
5 7
6 5
7 9
8 9
9 9
10 10
11 9
12 9
13 9
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 7
28 7
29 7
30 7
31 7
32 7
33 5
34 12
35 12
36 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
movslq %esi,%rsi
lea    (%rdi,%rsi,8),%rbx
mov    0xb8(%rbx),%rdi
test   %rdi,%rdi
je     26a <face_set_font+0x21>
callq  26a <face_set_font+0x21>
mov    %rbp,%rdi
callq  272 <face_set_font+0x29>
mov    %rax,0xb8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
face_set_font (struct a2ps_job * job, enum face_e face, const char * font_name)
{
  do { if (job->face_eo_font [face]) free (job->face_eo_font [face]); } while (0);
  job->face_eo_font [face] = xstrdup (font_name);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 5
15 5
16 5
17 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    (%rdi),%rdi
callq  260 <gsl_spline_eval_deriv+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline_eval_deriv (const gsl_spline * spline,
                       double x,
                       gsl_interp_accel * a)
{
  return gsl_interp_eval_deriv (spline->interp,
                                spline->x, spline->y,
                                x, a);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 8
8 8
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # b <outchar+0xb>
callq  10 <outchar+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
outchar (ch)
     int ch;
{
  return (fputc (ch, fp_outchar));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # b6 <init_data_buffer+0x10>
test   %rdi,%rdi
je     12c <init_data_buffer+0x86>
mov    %rsi,%rbp
callq  c3 <init_data_buffer+0x1d>
mov    %rax,0x0(%rip)        # ca <init_data_buffer+0x24>
test   %rbx,%rbx
jne    e0 <init_data_buffer+0x3a>
mov    $0x0,%eax
cmpq   $0x0,0x0(%rip)        # dc <init_data_buffer+0x36>
jne    115 <init_data_buffer+0x6f>
jmp    12c <init_data_buffer+0x86>
mov    %rax,%rsi
add    0x0(%rip),%rsi        # ea <init_data_buffer+0x44>
cmp    %rsi,%rax
jae    12c <init_data_buffer+0x86>
mov    $0x0,%edx
mov    $0x0,%edi
movzbl (%rbx,%rdx,1),%ecx
mov    %cl,(%rax)
add    $0x1,%rdx
cmp    %rbp,%rdx
cmovae %rdi,%rdx
add    $0x1,%rax
cmp    %rsi,%rax
jb     f9 <init_data_buffer+0x53>
jmp    12c <init_data_buffer+0x86>
mov    0x0(%rip),%rdx        # 11c <init_data_buffer+0x76>
mov    %al,(%rdx,%rax,1)
add    $0x1,%rax
cmp    %rax,0x0(%rip)        # 12a <init_data_buffer+0x84>
ja     115 <init_data_buffer+0x6f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
init_data_buffer (unsigned char * pat, size_t len)
{
  size_t i = 0;
  unsigned char *p;
  if (data_length == 0)
    return;
  data_buffer = xmalloc (data_length);
  if (pat)
    {
      for (p = data_buffer; p < data_buffer + data_length; p++)
 {
   *p = pat[i];
   if (++i >= len)
     i = 0;
 }
    }
  else
    {
      for (i = 0; i < data_length; i++)
 data_buffer[i] = i;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 19
14 19
15 19
16 19
17 10
18 10
19 10
20 10
21 10
22 14
23 12
24 12
25 13
26 14
27 14
28 10
29 10
30 10
31 10
32 20
33 20
34 19
35 19
36 19
37 22
38 22
39 22
40 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0x0,%esi
callq  547 <gsl_multifit_nlinear_init+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_nlinear_init (const gsl_vector * x,
                           gsl_multifit_nlinear_fdf * fdf,
                           gsl_multifit_nlinear_workspace * w)
{
  return gsl_multifit_nlinear_winit(x, ((void *)0), fdf, w);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x62,0x14(%rsp)
jne    3f7 <get_bool+0x1f>
mov    0x18(%rsp),%eax
cmpl   $0x0,0x10(%rsp)
je     406 <get_bool+0x2e>
mov    0x18(%rsp),%rax
mov    (%rax),%eax
jmp    406 <get_bool+0x2e>
mov    $0x0,%edi
mov    $0x0,%eax
callq  406 <get_bool+0x2e>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_bool(struct desc x)
{
      bool val;
      switch (x.type)
      { case 'b':
            val = (x.lval ? *x.u.bool_ptr : x.u.bool_val);
            break;
         default:
            fault("evaluation of a Boolean formal parameter not possibl"
               "e because final actual parameter is not of Boolean type"
               );
      }
      return val;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 9
11 9
12 9
13 14
14 14
<<<sep_out_sample>>>
test   %rdx,%rdx
je     17e <dico_assoc_remove_n+0x27>
sub    $0x18,%rsp
mov    %rdx,(%rsp)
mov    %rsi,0x8(%rsp)
mov    0x8(%rdi),%rdi
mov    $0x0,%edx
mov    %rsp,%rsi
callq  17a <dico_assoc_remove_n+0x23>
add    $0x18,%rsp
repz retq 
<<<sep_in_sample>>>
dico_assoc_remove_n(dico_assoc_list_t assoc, const char *key, size_t n)
{
    struct find_closure clos;
    if (n == 0)
 return;
    clos.count = n;
    clos.str = key;
    dico_list_remove(assoc->list, &clos, ((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 7
6 8
7 8
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <scram_start>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_scram_sha1_plus_server_start (Gsasl_session * sctx, void **mech_data)
{
  return scram_start (sctx, mech_data, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movslq 0xc(%rdi),%rsi
mov    $0x0,%ecx
mov    $0x8,%edx
mov    (%rdi),%rdi
callq  2eb <sortMacroTable+0x1a>
mov    0xc(%rbx),%ecx
test   %ecx,%ecx
jg     312 <sortMacroTable+0x41>
jmp    326 <sortMacroTable+0x55>
add    $0x8,%rdx
cmpq   $0x0,-0x8(%rdx)
je     30d <sortMacroTable+0x3c>
add    $0x1,%eax
cmp    %ecx,%eax
jne    2f4 <sortMacroTable+0x23>
jmp    326 <sortMacroTable+0x55>
mov    $0x0,%eax
mov    %eax,0xc(%rbx)
jmp    326 <sortMacroTable+0x55>
mov    (%rbx),%rdx
cmpq   $0x0,(%rdx)
je     308 <sortMacroTable+0x37>
add    $0x8,%rdx
mov    $0x0,%eax
jmp    2ff <sortMacroTable+0x2e>
pop    %rbx
retq   
<<<sep_in_sample>>>
sortMacroTable(MacroContext *mc)
{
 int i;
 qsort(mc->macroTable, mc->firstFree, sizeof(*(mc->macroTable)),
  compareMacroName);
 for (i = 0; i < mc->firstFree; i++) {
  if (mc->macroTable[i] != ((void *)0))
   continue;
  mc->firstFree = i;
  break;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 6
16 6
17 6
18 6
19 6
20 9
21 10
22 7
23 7
24 7
25 7
26 6
27 6
28 12
29 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x0(%rip),%eax        # 3b <add_unwind_protect_internal+0x12>
test   %eax,%eax
jle    57 <add_unwind_protect_internal+0x2e>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 48 <add_unwind_protect_internal+0x1f>
cltq   
mov    0x0(%rip),%rdx        # 51 <add_unwind_protect_internal+0x28>
mov    (%rdx,%rax,8),%rax
jmp    6b <add_unwind_protect_internal+0x42>
mov    $0xe7,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  6b <add_unwind_protect_internal+0x42>
mov    0x0(%rip),%rdx        # 72 <add_unwind_protect_internal+0x49>
mov    %rdx,(%rax)
mov    %rbp,0x8(%rax)
mov    %rbx,0x10(%rax)
mov    %rax,0x0(%rip)        # 84 <add_unwind_protect_internal+0x5b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
add_unwind_protect_internal (cleanup, arg)
     Function *cleanup;
     char *arg;
{
  UNWIND_ELT *elt;
  do { if ((uwcache).nc > 0) { (elt) = (UNWIND_ELT *)((UNWIND_ELT **)((uwcache).data))[--(uwcache).nc]; } else (elt) = (UNWIND_ELT *)sh_xmalloc((sizeof (UNWIND_ELT)), "unwind_prot.c", 231); } while (0);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = cleanup;
  elt->arg.v = arg;
  unwind_protect_list = elt;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 8
22 9
23 10
24 11
25 11
26 11
27 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
testb  $0x10,0x23d(%rdi)
je     27 <__ham_set_h_nelem+0x27>
mov    0x28(%rdi),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  25 <__ham_set_h_nelem+0x25>
jmp    45 <__ham_set_h_nelem+0x45>
mov    %esi,%ebp
mov    $0x2,%esi
callq  33 <__ham_set_h_nelem+0x33>
mov    %eax,%edx
test   %edx,%edx
jne    45 <__ham_set_h_nelem+0x45>
mov    0xd0(%rbx),%rax
mov    %ebp,0x8(%rax)
mov    %edx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__ham_set_h_nelem(dbp, h_nelem)
 DB *dbp;
 u_int32_t h_nelem;
{
 HASH *hashp;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_h_nelem", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x02)) != 0) return (__ret); };
 hashp = dbp->h_internal;
 hashp->h_nelem = h_nelem;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 8
19 9
20 10
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
movzwl (%rdi),%eax
test   %rdx,%rdx
je     1177 <gsl_stats_ushort_min+0x28>
add    %rsi,%rsi
mov    $0x0,%ecx
movzwl (%rdi),%r8d
cmp    %r8w,%ax
cmova  %r8d,%eax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    115f <gsl_stats_ushort_min+0x10>
repz retq 
<<<sep_in_sample>>>
gsl_stats_ushort_min (const unsigned short data[], const size_t stride,
                          const size_t n)
{
  unsigned short min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned short xi = data[i * stride];
      if (xi < min)
        min = xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 8
5 6
6 8
7 8
8 8
9 6
10 6
11 6
12 6
13 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x8,%edx
callq  227 <size_t_cmp+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
size_t_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(size_t)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
cmpl   $0x3,0x8(%rdi)
jne    11e1 <rec_type_max+0xe>
mov    0x24(%rdi),%eax
repz retq 
<<<sep_in_sample>>>
rec_type_max (rec_type_t type)
{
  int res;
  if (type->kind != REC_TYPE_RANGE)
    {
      res = -1;
    }
  else
    {
      res = type->data.range[1];
    }
  return res;
}
<<<sep_in_sample>>>
1 6
2 4
3 4
4 10
5 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%eax
and    $0x400ff,%eax
cmp    $0x6,%eax
jne    2c45 <free_token+0x1b>
mov    (%rdi),%rdi
callq  2c0b <free_charset>
jmp    2c55 <free_token+0x2b>
cmp    $0x3,%eax
jne    2c55 <free_token+0x2b>
mov    (%rdi),%rdi
nopl   (%rax)
callq  2c55 <free_token+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
free_token (re_token_t *node)
{
  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)
    free_charset (node->opr.mbcset);
  else
    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)
      free (node->opr.sbcset);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 7
12 7
13 7
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %esi,%ebx
mov    $0x1,%esi
mov    $0x18,%edi
callq  19 <varray_open+0x19>
test   %ebp,%ebp
jg     2c <varray_open+0x2c>
mov    $0x0,%edi
mov    $0x0,%eax
callq  2c <varray_open+0x2c>
test   %ebx,%ebx
jns    3f <varray_open+0x3f>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3f <varray_open+0x3f>
mov    %ebp,0x8(%rax)
movl   $0x0,0xc(%rax)
movl   $0x0,0x10(%rax)
test   %ebx,%ebx
mov    $0x64,%edx
cmove  %edx,%ebx
mov    %ebx,0x14(%rax)
movq   $0x0,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
varray_open(int size, int expand)
{
 VARRAY *vb = (VARRAY *)check_calloc(sizeof(VARRAY), 1);
 if (size < 1)
  die("varray_open: size < 1.");
 if (expand < 0)
  die("varray_open: expand < 0.");
 vb->size = size;
 vb->alloced = vb->length = 0;
 vb->expand = (expand == 0) ? 100 : expand;
 vb->vbuf = ((void *)0);
 return vb;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 8
20 9
21 9
22 10
23 10
24 10
25 10
26 11
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_pow_6(const double x) { double x2 = x*x; return x2*x2*x2; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x4(%rsi),%r12d
movzbl 0x1(%rsi),%edi
mov    $0x4,%edx
mov    $0x0,%esi
callq  0 <_xlat_num>
lea    0x44(%rbx),%rdx
mov    %rdx,0x8(%rsp)
lea    0x38(%rbx),%rdx
mov    %rdx,(%rsp)
lea    0x2c(%rbx),%r9
mov    %r12d,%r8d
mov    %rax,%rcx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    $0x7,%edi
mov    $0x0,%eax
callq  8e <print_request+0x57>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_request (const char *cp, CTL_MSG * mp)
{
  syslog (7, "%s: %s: id %d, l_user %s, r_user %s, r_tty %s",
   cp, _xlat_num (mp->type, message_types, (sizeof (message_types) / sizeof ((message_types)[0]))),
   mp->id_num, mp->l_name, mp->r_name, mp->r_tty);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 5
13 5
14 5
15 5
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 7
25 7
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
movsd  0x230(%rdi),%xmm0
addsd  0x248(%rdi),%xmm0
ucomisd 0x0(%rip),%xmm0        # f3e <aileronSetting+0x18>
ja     f62 <aileronSetting+0x3c>
movapd %xmm0,%xmm1
cmpnltsd 0x0(%rip),%xmm1        # f4d <aileronSetting+0x27>
andpd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm2        # f59 <aileronSetting+0x33>
andnpd %xmm2,%xmm1
orpd   %xmm1,%xmm0
retq   
movsd  0x0(%rip),%xmm0        # f6a <aileronSetting+0x44>
retq   
<<<sep_in_sample>>>
aileronSetting(craft * c)
{
 double Sa = c->Sa + c->SaTrim;
 if (Sa > 1.0) {
  Sa = 1.0;
 }
 else if (Sa < -1.0) {
  Sa = -1.0;
 }
 return Sa;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 5
13 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x2238(%rdi),%rax
cmp    0x2230(%rdi),%rax
jne    107 <AlibFillRectangle+0x20>
mov    $0x0,%edi
callq  105 <AlibFillRectangle+0x1e>
jmp    13c <AlibFillRectangle+0x55>
lea    0x1(%rax),%r10
mov    %r10,0x2238(%rdi)
shl    $0x5,%rax
add    0x2228(%rdi),%rax
mov    0x8(%rdi),%r11
lea    -0x1(%r11),%r10
mov    %r10,0x8(%rdi)
mov    %r10,0x8(%rax)
mov    %r9w,(%rax)
mov    %rax,%r9
mov    (%rdi),%rdi
callq  13c <AlibFillRectangle+0x55>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
AlibFillRectangle(Viewport *v,
    int x, int y, int w, int h, Color color)
{
  ZInfo *z;
  if (v->ztop == v->zsize) {
    printf("Z-information pool overflow\n");
    return;
  }
  z = &(v->zpool[(v->ztop)++]);
  z->depth = --v->depth;
  z->color = color;
  FillRectangle(v->w, x, y, w, h, z);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 6
6 6
7 7
8 9
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 11
17 12
18 12
19 12
20 13
21 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edx,%edx
jne    3bb <check_addr_range+0x14>
mov    %edi,0x0(%rip)        # 3b5 <check_addr_range+0xe>
mov    %esi,0x0(%rip)        # 3bb <check_addr_range+0x14>
mov    0x0(%rip),%eax        # 3c1 <check_addr_range+0x1a>
test   %eax,%eax
jle    3e1 <check_addr_range+0x3a>
cmp    0x0(%rip),%eax        # 3cb <check_addr_range+0x24>
jg     3e1 <check_addr_range+0x3a>
callq  3d2 <check_addr_range+0x2b>
mov    %eax,%edx
mov    $0x1,%eax
cmp    0x0(%rip),%edx        # 3df <check_addr_range+0x38>
jge    3eb <check_addr_range+0x44>
callq  a3 <invalid_address>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
check_addr_range( const int n, const int m, const int addr_cnt )
  {
  if( addr_cnt == 0 )
    {
    first_addr = n;
    second_addr = m;
    }
  if( first_addr < 1 || first_addr > second_addr || second_addr > last_addr() )
    { invalid_address(); return false; }
  return true;
  }
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 8
15 8
16 9
17 9
18 11
19 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
divsd  %xmm1,%xmm0
movapd %xmm2,%xmm1
callq  3c <gsl_cdf_weibull_Q+0x11>
movsd  0x0(%rip),%xmm1        # 44 <gsl_cdf_weibull_Q+0x19>
xorpd  %xmm1,%xmm0
callq  4d <gsl_cdf_weibull_Q+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_weibull_Q (const double x, const double a, const double b)
{
  double Q = exp (-pow(x/a, b));
  return Q;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm3        # 3dc <gsl_odeiv2_control_yp_new+0xc>
xorpd  %xmm2,%xmm2
callq  3e5 <gsl_odeiv2_control_yp_new+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_control_yp_new (double eps_abs, double eps_rel)
{
  return gsl_odeiv2_control_standard_new (eps_abs, eps_rel, 0.0, 1.0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%r8
callq  1523 <quotearg_n_custom+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n_custom (int n, char const *left_quote,
                   char const *right_quote, char const *arg)
{
  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,
                                ((size_t) -1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12d
cmpb   $0x0,(%rbx)
je     47 <strcasestr2+0x47>
movslq %r12d,%r12
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  38 <strcasestr2+0x38>
test   %eax,%eax
je     4e <strcasestr2+0x4e>
add    $0x1,%rbx
cmpb   $0x0,(%rbx)
jne    2a <strcasestr2+0x2a>
jmp    53 <strcasestr2+0x53>
mov    $0x0,%eax
jmp    58 <strcasestr2+0x58>
mov    %rbx,%rax
jmp    58 <strcasestr2+0x58>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
strcasestr2(const char *s, const char *pattern)
{
    int length = strlen(pattern);
    while (*s)
    {
 if (strncasecmp(s, pattern, length) == 0)
     return s;
 s++;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 8
22 4
23 4
24 4
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
movq   $0x0,0x0(%rip)        # 15d0 <find_variable+0xf>
mov    $0x0,%esi
cmpl   $0x0,0x0(%rip)        # 15dc <find_variable+0x1b>
jne    15f9 <find_variable+0x38>
mov    $0x1,%sil
cmpl   $0x0,0x0(%rip)        # 15e8 <find_variable+0x27>
jne    15f9 <find_variable+0x38>
cmpl   $0x0,0x0(%rip)        # 15f1 <find_variable+0x30>
setne  %sil
movzbl %sil,%esi
callq  126a <find_variable_internal>
test   %rax,%rax
je     1611 <find_variable+0x50>
testb  $0x8,0x29(%rax)
je     1611 <find_variable+0x50>
mov    %rax,%rdi
callq  1611 <find_variable+0x50>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_variable (name)
     const char *name;
{
  SHELL_VAR *v;
  int flags;
  last_table_searched = 0;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= 0x01;
  v = find_variable_internal (name, flags);
  if (v && ((((v)->attributes) & (0x0000800))))
    v = find_variable_nameref (v);
  return v;
}
<<<sep_in_sample>>>
1 3
2 6
3 7
4 8
5 8
6 9
7 8
8 8
9 8
10 8
11 8
12 10
13 11
14 11
15 11
16 11
17 12
18 12
19 14
20 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    177 <gsl_blas_cdotu+0x33>
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  170 <gsl_blas_cdotu+0x2c>
mov    $0x0,%eax
jmp    195 <gsl_blas_cdotu+0x51>
mov    $0x13,%ecx
mov    $0x7c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  190 <gsl_blas_cdotu+0x4c>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_cdotu (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
{
  if (X->size == Y->size)
    {
      cblas_cdotu_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotu)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 12
22 14
23 14
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    $0x0,%eax
callq  1c63 <open_readfd+0x10>
mov    %eax,%ebx
test   %eax,%eax
js     1c8d <open_readfd+0x3a>
mov    %eax,%edi
callq  1c70 <open_readfd+0x1d>
test   %eax,%eax
je     1c94 <open_readfd+0x41>
mov    %ebx,%edi
callq  1c7b <open_readfd+0x28>
callq  1c80 <open_readfd+0x2d>
movl   $0x15,(%rax)
mov    $0xffffffff,%eax
jmp    1c96 <open_readfd+0x43>
mov    $0xffffffff,%eax
jmp    1c96 <open_readfd+0x43>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
open_readfd(const char *file)
{
 int fd;
 fd = open(file, 00);
 if (fd <= (-1))
  return (-1);
 else if (os_isdir(fd)) {
  (void) close(fd);
  (*__errno_location ()) = 21;
  return (-1);
 }
 return fd;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 6
19 6
20 12
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     402 <xget_version+0x18>
cmpb   $0x0,(%rsi)
je     402 <xget_version+0x18>
callq  3fd <xget_version+0x13>
nopl   (%rax)
jmp    419 <xget_version+0x2f>
mov    $0x0,%edi
callq  40c <xget_version+0x22>
mov    %rax,%rsi
mov    $0x0,%edi
callq  419 <xget_version+0x2f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xget_version (char const *context, char const *version)
{
  if (version && *version)
    return get_version (context, version);
  else
    return get_version ("$VERSION_CONTROL", getenv ("VERSION_CONTROL"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
swverid_get_object_name(SWVERID * swverid)
{
 return swverid->object_nameM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  1d9c <gsl_vector_long_calloc+0xe>
mov    %rax,%rbp
test   %rax,%rax
je     1ddb <gsl_vector_long_calloc+0x4d>
lea    0x0(,%rbx,8),%rdx
mov    0x10(%rax),%rdi
mov    $0x0,%esi
callq  1dba <gsl_vector_long_calloc+0x2c>
test   %rbx,%rbx
je     1de2 <gsl_vector_long_calloc+0x54>
mov    $0x0,%edx
mov    0x10(%rbp),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    1dc4 <gsl_vector_long_calloc+0x36>
jmp    1de7 <gsl_vector_long_calloc+0x59>
mov    $0x0,%eax
jmp    1dea <gsl_vector_long_calloc+0x5c>
mov    %rbp,%rax
jmp    1dea <gsl_vector_long_calloc+0x5c>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_long_calloc (const size_t n)
{
  size_t i;
  gsl_vector_long * v = gsl_vector_long_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 1 * n * sizeof(long));
  for (i = 0; i < 1 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 6
24 12
25 12
26 12
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 9dc <in_local_domain+0xa>
callq  9e1 <in_local_domain+0xf>
test   %rax,%rax
je     9ff <in_local_domain+0x2d>
mov    0x0(%rip),%rsi        # 9ed <in_local_domain+0x1b>
mov    %rax,%rdi
callq  9f5 <in_local_domain+0x23>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    a04 <in_local_domain+0x32>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
in_local_domain (char *hostname)
{
  char *p = topdomain (hostname, local_dot_count);
  return p && strcasecmp (p, local_domain_name) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rcx
mov    (%rsi),%rbx
mov    0x8(%rsi),%rdi
mov    %rbx,%rdx
mov    $0x4,%esi
callq  2868 <gsl_block_uint_fwrite+0x18>
mov    $0x0,%edx
cmp    %rbx,%rax
je     288d <gsl_block_uint_fwrite+0x3d>
mov    $0x5,%ecx
mov    $0x30,%dl
mov    $0x0,%esi
mov    $0x0,%edi
callq  2888 <gsl_block_uint_fwrite+0x38>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_block_uint_fwrite (FILE * stream, const gsl_block_uint * b)
{
  size_t n = b->size ;
  unsigned int * data = b->data ;
  size_t items = fwrite (data, 1 * sizeof (unsigned int), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "fwrite_source.c", 48, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
lea    -0x1(%rsi),%ebp
mov    $0x4,%eax
cmp    $0xb,%ebp
ja     342 <nied2_init+0x49>
mov    %rdi,%r12
callq  6 <calculate_cj>
test   %ebx,%ebx
je     335 <nied2_init+0x3c>
mov    %r12,%rax
mov    %ebp,%ebp
lea    0x4(%r12,%rbp,4),%rdx
movl   $0x0,0x5d4(%rax)
add    $0x4,%rax
cmp    %rdx,%rax
jne    322 <nied2_init+0x29>
movl   $0x0,(%r12)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
nied2_init(void * state, unsigned int dimension)
{
  nied2_state_t * n_state = (nied2_state_t *) state;
  unsigned int i_dim;
  if(dimension < 1 || dimension > 12) return GSL_EINVAL;
  calculate_cj(n_state, dimension);
  for(i_dim=0; i_dim<dimension; i_dim++) n_state->nextq[i_dim] = 0;
  n_state->sequence_count = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 9
22 10
23 10
24 10
25 10
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     4ee <mu_debug_get_function+0x16>
mov    0x28(%rdi),%rax
mov    %rax,(%rsi)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_debug_get_function (mu_debug_t debug, const char **pfunction)
{
  if (!debug)
    return 22;
  *pfunction = debug->function;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 5
6 6
7 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rax
test   %rax,%rax
je     e4 <mu_progmailer_destroy+0x24>
mov    0x18(%rax),%rdi
callq  d5 <mu_progmailer_destroy+0x15>
mov    (%rbx),%rdi
callq  dd <mu_progmailer_destroy+0x1d>
movq   $0x0,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_progmailer_destroy (struct _mu_progmailer **ppm)
{
  if (*ppm)
    {
      free ((*ppm)->command);
      free (*ppm);
      *ppm = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 7
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rdi,%rdi
jne    26d <parse_opt_set_dstaddr+0x32>
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  26d <parse_opt_set_dstaddr+0x32>
testb  $0x20,0x8(%rbx)
je     294 <parse_opt_set_dstaddr+0x59>
mov    (%rbx),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  294 <parse_opt_set_dstaddr+0x59>
mov    %rbp,0x38(%rbx)
orl    $0x20,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_opt_set_dstaddr (struct ifconfig *ifp, char *addr) { if (!ifp) error (1, 0, "no interface specified for %s `%s'", "destination / peer address", addr); if (ifp->valid & 0x020) error (1, 0, "only one %s allowed for interface `%s'", "destination / peer address", ifp->name); ifp->dstaddr = addr; ifp->valid |= 0x020; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   $0xf,%sil
je     be <nettle_aes192_decrypt+0x29>
lea    0x0(%rip),%rcx        # a6 <nettle_aes192_decrypt+0x11>
mov    $0x174,%edx
lea    0x0(%rip),%rsi        # b2 <nettle_aes192_decrypt+0x1d>
lea    0x0(%rip),%rdi        # b9 <nettle_aes192_decrypt+0x24>
callq  be <nettle_aes192_decrypt+0x29>
mov    %rdx,%r8
mov    %rcx,%r9
mov    %rsi,%rcx
lea    0x0(%rip),%rdx        # ce <nettle_aes192_decrypt+0x39>
mov    %rdi,%rsi
mov    $0xc,%edi
callq  db <nettle_aes192_decrypt+0x46>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_aes192_decrypt(const struct aes192_ctx *ctx,
        size_t length, uint8_t *dst,
        const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "aes-decrypt.c", 372, __PRETTY_FUNCTION__));
  _nettle_aes_decrypt(12, ctx->keys, &_aes_decrypt_table,
        length, dst, src);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 8
17 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x1000,%rcx
jbe    1d2 <path2fid_readonly+0x2f>
mov    $0x0,%edi
callq  1d2 <path2fid_readonly+0x2f>
cmpb   $0x2e,(%rsi)
jne    1e3 <path2fid_readonly+0x40>
lea    0x2(%rsi),%rax
cmpb   $0x2f,0x1(%rsi)
cmove  %rax,%rsi
mov    0x0(%rip),%rdi        # 1ea <path2fid_readonly+0x47>
callq  1ef <path2fid_readonly+0x4c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
path2fid_readonly(const char *path)
{
 if (strlen(path) > 4096)
  die("path name too long. '%s'", path);
 if (*path == '.' && *(path + 1) == '/')
  path += 2;
 return assoc_get(assoc, path);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     6772 <remove_quoted_escapes+0x33>
callq  6752 <remove_quoted_escapes+0x13>
mov    %rax,%rbp
mov    %rax,%rsi
mov    %rbx,%rdi
callq  6760 <remove_quoted_escapes+0x21>
mov    $0xffa,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  6772 <remove_quoted_escapes+0x33>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
remove_quoted_escapes (string)
     char *string;
{
  char *t;
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      sh_xfree((t), "subst.c", 4090);
    }
  return (string);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 8
10 8
11 8
12 9
13 9
14 9
15 9
16 12
17 12
18 12
19 12
20 12
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     729 <script_warning+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rdx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rcx
mov    $0x0,%esi
mov    $0x3,%edi
callq  767 <script_warning+0x99>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
script_warning(const char *fmt, ...)
{
    va_list ap;
    __builtin_va_start(ap,fmt);
    script_diag(3, 0, fmt, ap);
    __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 7
29 7
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
test   %rdx,%rdx
je     2d8 <gsl_stats_short_median_from_sorted_data+0x49>
lea    -0x1(%rdx),%rax
shr    %rax
shr    %rdx
cmp    %rdx,%rax
jne    2b7 <gsl_stats_short_median_from_sorted_data+0x28>
add    %rsi,%rsi
imul   %rsi,%rax
movswl (%rdi,%rax,1),%eax
cvtsi2sd %eax,%xmm0
retq   
add    %rsi,%rsi
imul   %rsi,%rax
movswl (%rdi,%rax,1),%ecx
imul   %rsi,%rdx
movswl (%rdi,%rdx,1),%eax
add    %ecx,%eax
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 2d8 <gsl_stats_short_median_from_sorted_data+0x49>
repz retq 
<<<sep_in_sample>>>
gsl_stats_short_median_from_sorted_data (const short sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 9
2 8
3 8
4 6
5 6
6 7
7 10
8 10
9 12
10 12
11 12
12 12
13 12
14 16
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 19
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%r11
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rbx
test   %r11,%r11
je     3907 <gsl_matrix_short_scale+0x63>
add    %rbx,%rbx
mov    $0x0,%r10d
mov    $0x0,%r9d
jmp    38f8 <gsl_matrix_short_scale+0x54>
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
movswl (%rcx),%esi
cvtsi2sd %esi,%xmm1
mulsd  %xmm0,%xmm1
cvttsd2si %xmm1,%esi
mov    %si,(%rcx)
add    $0x1,%rax
add    $0x2,%rdx
cmp    %r8,%rax
jne    38c6 <gsl_matrix_short_scale+0x22>
add    $0x1,%r9
add    %rbx,%r10
cmp    %r11,%r9
je     3907 <gsl_matrix_short_scale+0x63>
test   %r8,%r8
je     38ec <gsl_matrix_short_scale+0x48>
mov    %r10,%rdx
mov    $0x0,%eax
jmp    38c6 <gsl_matrix_short_scale+0x22>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_short_scale (gsl_matrix_short * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 9
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 9
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  58e <swverid_add_tag+0xc>
mov    0x20(%rbx),%rdi
mov    %rax,%rsi
callq  59a <swverid_add_tag+0x18>
pop    %rbx
retq   
<<<sep_in_sample>>>
swverid_add_tag(SWVERID * swverid, char * tag)
{
 cplob_add_nta(swverid->taglistM, strdup(tag));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r9d
callq  1653 <hybrid_set_impl>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
hybrids_set (void *vstate, gsl_multiroot_function * func, gsl_vector * x,
             gsl_vector * f, gsl_vector * dx)
{
  int status = hybrid_set_impl (vstate, func, x, f, dx, 1);
  return status;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     1ae <fdGetFdno+0x12>
cmpl   $0xbeefdead,0x8(%rdi)
je     1c7 <fdGetFdno+0x2b>
mov    $0x0,%ecx
mov    $0xc4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c7 <fdGetFdno+0x2b>
movslq 0xc(%rdi),%rax
lea    (%rax,%rax,2),%rax
mov    0x20(%rdi,%rax,8),%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fdGetFdno(FD_t fd) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 196, __PRETTY_FUNCTION__));
    return fd->fps[fd->nfps].fdno;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
callq  1c85 <info_read_maybe_completing+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_read_maybe_completing (const char *prompt, REFERENCE **completions)
{
  return info_read_completing_internal (prompt, completions, 0, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 5e9 <yy_grecsrestart+0x10>
test   %rax,%rax
je     5fc <yy_grecsrestart+0x23>
mov    0x0(%rip),%rdx        # 5f5 <yy_grecsrestart+0x1c>
cmpq   $0x0,(%rax,%rdx,8)
jne    639 <yy_grecsrestart+0x60>
callq  32d <yy_grecsensure_buffer_stack>
mov    0x0(%rip),%rax        # 608 <yy_grecsrestart+0x2f>
mov    0x0(%rip),%rdx        # 60f <yy_grecsrestart+0x36>
lea    (%rax,%rdx,8),%rbp
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 61f <yy_grecsrestart+0x46>
callq  624 <yy_grecsrestart+0x4b>
mov    %rax,0x0(%rbp)
mov    0x0(%rip),%rax        # 62f <yy_grecsrestart+0x56>
mov    $0x0,%edi
test   %rax,%rax
je     644 <yy_grecsrestart+0x6b>
mov    0x0(%rip),%rdx        # 640 <yy_grecsrestart+0x67>
mov    (%rax,%rdx,8),%rdi
mov    %rbx,%rsi
callq  4e5 <yy_grecs_init_buffer>
callq  d7 <yy_grecs_load_buffer_state>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
yy_grecsrestart (FILE * input_file )
{
 if ( ! ( (yy_grecs_buffer_stack) ? (yy_grecs_buffer_stack)[(yy_grecs_buffer_stack_top)] : ((void *)0)) ){
        yy_grecsensure_buffer_stack ();
  (yy_grecs_buffer_stack)[(yy_grecs_buffer_stack_top)] =
            yy_grecs_create_buffer(yy_grecsin,16384 );
 }
 yy_grecs_init_buffer(( (yy_grecs_buffer_stack) ? (yy_grecs_buffer_stack)[(yy_grecs_buffer_stack_top)] : ((void *)0)),input_file );
 yy_grecs_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
cmpb   $0x2f,(%rdi)
sete   %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
isfullpath(char *path)
{
  return ((*path) == '/');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsp,%rsi
mov    $0x0,%edi
callq  13ee <file_timestamp_now+0x15>
test   %eax,%eax
jne    13fe <file_timestamp_now+0x25>
mov    (%rsp),%rsi
mov    0x8(%rsp),%edx
mov    $0x1,%al
jmp    1438 <file_timestamp_now+0x5f>
mov    $0x0,%esi
mov    %rsp,%rdi
callq  140b <file_timestamp_now+0x32>
test   %eax,%eax
jne    1421 <file_timestamp_now+0x48>
mov    (%rsp),%rsi
imul   $0x3e8,0x8(%rsp),%edx
mov    $0x3e8,%ax
jmp    1438 <file_timestamp_now+0x5f>
mov    $0x0,%edi
callq  142b <file_timestamp_now+0x52>
mov    %rax,%rsi
mov    $0x0,%edx
mov    $0x3b9aca00,%eax
mov    %eax,(%rbx)
movslq %edx,%rdx
mov    $0x0,%edi
callq  1447 <file_timestamp_now+0x6e>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
file_timestamp_now (int *resolution)
{
  int r;
  time_t s;
  int ns;
  {
    struct timespec timespec;
    if (clock_gettime (0, &timespec) == 0)
      {
        r = 1;
        s = timespec.tv_sec;
        ns = timespec.tv_nsec;
        goto got_time;
      }
  }
  {
    struct timeval timeval;
    if (gettimeofday (&timeval, 0) == 0)
      {
        r = 1000;
        s = timeval.tv_sec;
        ns = timeval.tv_usec * 1000;
        goto got_time;
      }
  }
  r = 1000000000;
  s = time ((time_t *) 0);
  ns = 0;
 got_time:
  *resolution = r;
  return file_timestamp_cons (0, s, ns);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 8
5 8
6 8
7 8
8 8
9 11
10 12
11 10
12 10
13 18
14 18
15 18
16 18
17 18
18 21
19 22
20 20
21 20
22 27
23 27
24 27
25 28
26 26
27 30
28 31
29 31
30 31
31 32
32 32
33 32
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rdx,0x30(%rsp)
movl   $0x10,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    %esi,%esi
mov    $0x0,%eax
callq  31 <rpl_ioctl+0x31>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
rpl_ioctl (int fd, int request, ... )
{
  void *buf;
  va_list args;
  __builtin_va_start(args,request);
  buf = __builtin_va_arg(args,void *);
  __builtin_va_end(args);
  return ioctl (fd, (unsigned int) request, buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 8
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  d711 <_x87_bltgti_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c747 <_x87_movi_d>
mov    0x0(%r12),%r8d
and    $0x7fff,%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    $0x5,%esi
mov    %rbx,%rdi
callq  1b80 <_x87jcc2>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d769 <_x87_bltgti_d+0x7c>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_bltgti_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc2(_jit, 0x5, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
mov    $0x1,%edx
mov    $0x2f,%esi
callq  dfb <swlib_squash_trailing_slash+0xf>
repz retq 
<<<sep_in_sample>>>
swlib_squash_trailing_slash(char *path)
{
 squash_trailing_char(path, '/', 1);
 return;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%ecx
callq  0 <domd5>
movb   $0x0,0x20(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
swlib_md5(int uxfio_fd, unsigned char *bindigest, int do_ascii) {
    int ret;
    ret = domd5(uxfio_fd, bindigest, do_ascii, 0);
    bindigest[32] = '\0';
    return ret;
}
<<<sep_in_sample>>>
1 1
2 1
3 3
4 3
5 4
6 6
7 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  130e <swlib_slashclean+0x9>
mov    %rbx,%rdi
callq  1316 <swlib_slashclean+0x11>
mov    %rbx,%rdi
callq  131e <swlib_slashclean+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
swlib_slashclean(char *path)
{
 swlib_squash_double_slash(path);
 swlib_squash_leading_dot_slash(path);
 swlib_squash_trailing_slash(path);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  135 <gc_cipher_close+0x9>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_cipher_close (gc_cipher_handle handle)
{
  _gc_cipher_ctx *ctx = handle;
  free (ctx);
  return GC_OK;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
callq  eaf <quotearg_style+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_style (enum quoting_style s, char const *arg)
{
  return quotearg_n_style (0, s, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
cmp    $0x100,%edi
je     11d <parse_opt+0x4d>
cmp    $0x1000007,%edi
je     16e <parse_opt+0x9e>
mov    $0x7,%eax
cmp    $0x64,%edi
jne    1bb <parse_opt+0xeb>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  10d <parse_opt+0x3d>
mov    %eax,0x0(%rip)        # 113 <parse_opt+0x43>
mov    $0x0,%eax
jmpq   1bb <parse_opt+0xeb>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  12a <parse_opt+0x5a>
mov    %rax,%rdx
mov    %rax,0x0(%rip)        # 134 <parse_opt+0x64>
mov    $0x0,%eax
test   %rdx,%rdx
jne    1bb <parse_opt+0xeb>
mov    $0x0,%edi
callq  148 <parse_opt+0x78>
mov    %rax,%rbp
callq  150 <parse_opt+0x80>
mov    %rbx,%rcx
mov    %rbp,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  167 <parse_opt+0x97>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
cmpl   $0x0,0x0(%rip)        # 175 <parse_opt+0xa5>
je     19b <parse_opt+0xcb>
mov    $0x0,%eax
cmpq   $0x0,0x0(%rip)        # 184 <parse_opt+0xb4>
jne    1bb <parse_opt+0xeb>
mov    0x0(%rip),%rax        # 18d <parse_opt+0xbd>
mov    %rax,0x0(%rip)        # 194 <parse_opt+0xc4>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
cmpq   $0x0,0x0(%rip)        # 1a3 <parse_opt+0xd3>
je     1b6 <parse_opt+0xe6>
movl   $0x1,0x0(%rip)        # 1af <parse_opt+0xdf>
mov    $0x0,%eax
jmp    1bb <parse_opt+0xeb>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_opt (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'd':
      dbglev = strtol (arg, ((void *)0), 0);
      break;
    case DEBUG_FILE_OPTION:
      dbgout = fopen (arg, "w");
      if (!dbgout)
 error (1, (*__errno_location ()), gettext ("cannot open %s"), arg);
      break;
    case 0x1000007:
      if (dbglev)
 {
   if (!dbgout)
     dbgout = stderr;
 }
      else if (dbgout)
 dbglev = 1;
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 23
10 3
11 3
12 6
13 6
14 6
15 6
16 6
17 25
18 7
19 9
20 9
21 9
22 9
23 9
24 25
25 10
26 10
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 25
38 25
39 14
40 14
41 25
42 16
43 16
44 17
45 17
46 25
47 25
48 19
49 19
50 20
51 25
52 25
53 25
54 26
55 26
56 26
57 26
<<<sep_out_sample>>>
mov    0x84(%rdi),%eax
retq   
<<<sep_in_sample>>>
uinfile_get_has_leading_slash(UINFORMAT * uinformat)
{
 return uinformat->has_leading_slashM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x2f,%esi
callq  172 <gzip_base_name+0xe>
lea    0x1(%rax),%rdx
test   %rax,%rax
cmovne %rdx,%rbx
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gzip_base_name (fname)
    char *fname;
{
    char *p;
    if ((p = strrchr(fname, '/')) != ((void *)0)) fname = p+1;
    if (('A') == 'a') strlwr(fname);
    return fname;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 8
9 8
10 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdx
mov    $0x5413,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3e <getScreenSize+0x1b>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 48 <getScreenSize+0x25>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 53 <getScreenSize+0x30>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
cmpl   $0x0,0xf4(%rdi)
js     79f <shcmd_add_close_fd+0x3a>
mov    %rdi,%rdx
mov    $0x0,%eax
add    $0x1,%eax
mov    0xf8(%rdx),%ecx
not    %ecx
shr    $0x1f,%ecx
cmp    $0x9,%eax
setle  %r8b
add    $0x4,%rdx
test   %cl,%r8b
jne    776 <shcmd_add_close_fd+0x11>
cmp    $0x9,%eax
jle    7a4 <shcmd_add_close_fd+0x3f>
sub    $0x8,%rsp
jmp    7ae <shcmd_add_close_fd+0x49>
mov    $0x0,%eax
cltq   
mov    %esi,0xf4(%rdi,%rax,4)
retq   
mov    0x0(%rip),%rcx        # 7b5 <shcmd_add_close_fd+0x50>
mov    $0x24,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  7c9 <shcmd_add_close_fd+0x64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
shcmd_add_close_fd(SHCMD * shcmd, int ifd)
{
 int fd;
 int i = 0;
 fd = shcmd->close_list_[i];
 while (fd >= 0 && i < ((int)(sizeof(shcmd->close_list_) / sizeof(int)))) {
  fd = shcmd->close_list_[++i];
 }
 if (i < ((int)(sizeof(shcmd->close_list_) / sizeof(int)))) {
  shcmd->close_list_[i] = ifd;
 } else {
  fprintf(stderr, "shcmd_add_close_fd() internal error\n");
 }
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 4
5 7
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 9
15 9
16 2
17 2
18 4
19 10
20 10
21 10
22 12
23 12
24 12
25 12
26 12
27 14
28 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  304 <file_error+0x9>
mov    (%rax),%edi
callq  30b <file_error+0x10>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  320 <file_error+0x25>
pop    %rbx
retq   
<<<sep_in_sample>>>
file_error (filename)
     const char *filename;
{
  report_error ("%s: %s", filename, strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%r8
mov    (%rdi),%rcx
mov    0x8(%rdi),%r9
cmp    %rsi,%rcx
jbe    3065 <gsl_vector_short_set_basis+0x23>
lea    (%r9,%r9,1),%rdi
mov    %r8,%rdx
mov    $0x0,%eax
test   %rcx,%rcx
jne    3089 <gsl_vector_short_set_basis+0x47>
jmp    309a <gsl_vector_short_set_basis+0x58>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3082 <gsl_vector_short_set_basis+0x40>
mov    $0x4,%eax
jmp    30ae <gsl_vector_short_set_basis+0x6c>
movw   $0x0,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    3089 <gsl_vector_short_set_basis+0x47>
add    %r9,%r9
imul   %r9,%rsi
movw   $0x1,(%r8,%rsi,1)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_short_set_basis (gsl_vector_short * v, size_t i)
{
  short * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const short zero = 0 ;
  const short one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(short *) (data + 1 * k * stride) = zero;
    }
  *(short *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 9
5 9
6 15
7 15
8 15
9 13
10 13
11 13
12 2
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 15
21 13
22 13
23 13
24 13
25 17
26 17
27 17
28 18
29 18
30 19
31 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     958 <grecs_match_buf_free+0x16>
callq  0 <grecs_match_buf_free_contents>
mov    %rbx,%rdi
callq  958 <grecs_match_buf_free+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_match_buf_free(struct grecs_match_buf *buf)
{
 if (buf) {
  grecs_match_buf_free_contents(buf);
  free(buf);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    0x30(%rdi),%rbp
cmp    %rsi,%rbp
jae    58e <gl_array_nx_add_at+0x1e>
callq  58e <gl_array_nx_add_at+0x1e>
mov    %rdx,%r13
cmp    %rbp,0x38(%rdi)
jne    5a0 <gl_array_nx_add_at+0x30>
callq  506 <grow>
test   %eax,%eax
js     5d7 <gl_array_nx_add_at+0x67>
mov    0x28(%r12),%rdx
cmp    %rbx,%rbp
jbe    5c4 <gl_array_nx_add_at+0x54>
lea    -0x8(%rdx,%rbp,8),%rcx
lea    -0x8(%rdx,%rbx,8),%rax
mov    (%rcx),%r8
mov    %r8,0x8(%rcx)
sub    $0x8,%rcx
cmp    %rax,%rcx
jne    5b4 <gl_array_nx_add_at+0x44>
mov    %r13,(%rdx,%rbx,8)
add    $0x1,%rbp
mov    %rbp,0x30(%r12)
lea    0x1(%rbx),%rax
jmp    5dc <gl_array_nx_add_at+0x6c>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gl_array_nx_add_at (gl_list_t list, size_t position, const void *elt)
{
  size_t count = list->count;
  const void **elements;
  size_t i;
  if (!(position <= count))
    abort ();
  if (count == list->allocated)
    if (grow (list) < 0)
      return ((void *)0);
  elements = list->elements;
  for (i = count; i > position; i--)
    elements[i] = elements[i - 1];
  elements[position] = elt;
  list->count = count + 1;
  return (gl_list_node_t)(unsigned long)(size_t)((position) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 9
18 11
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 12
27 12
28 14
29 15
30 15
31 16
32 16
33 10
34 17
35 17
36 17
37 17
38 17
39 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    (%rdi),%rbp
mov    $0x0,%edi
callq  19f <da_print_stats+0x1d>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    %r13,%rdi
mov    $0x0,%eax
callq  1b2 <da_print_stats+0x30>
mov    0x28(%rbx),%rbp
mov    0x8(%rbx),%r12
mov    $0x0,%edi
callq  1c4 <da_print_stats+0x42>
test   %rbp,%rbp
js     1d0 <da_print_stats+0x4e>
cvtsi2sd %rbp,%xmm0
jmp    1e8 <da_print_stats+0x66>
mov    %rbp,%rdx
shr    %rdx
mov    %rbp,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
mulsd  0x0(%rip),%xmm0        # 1f0 <da_print_stats+0x6e>
test   %r12,%r12
js     1fc <da_print_stats+0x7a>
cvtsi2sd %r12,%xmm1
jmp    214 <da_print_stats+0x92>
mov    %r12,%rdx
shr    %rdx
mov    %r12,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %rax,%rsi
mov    %r13,%rdi
mov    $0x1,%eax
callq  22e <da_print_stats+0xac>
mov    0x18(%rbx),%eax
cmp    $0x1,%eax
je     251 <da_print_stats+0xcf>
cmp    $0x1,%eax
jb     24a <da_print_stats+0xc8>
mov    $0x0,%ebp
cmp    $0x2,%eax
je     256 <da_print_stats+0xd4>
callq  24a <da_print_stats+0xc8>
mov    $0x0,%ebp
jmp    256 <da_print_stats+0xd4>
mov    $0x0,%ebp
mov    0x20(%rbx),%r12
mov    0x10(%rbx),%rbx
mov    $0x0,%edi
callq  268 <da_print_stats+0xe6>
mov    %r12,%r8
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    %r13,%rdi
mov    $0x0,%eax
callq  281 <da_print_stats+0xff>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
da_print_stats (struct darray * arr, FILE * stream)
{
  const char * cp = ((void *)0);
  fprintf (stream, gettext ("Dynamic array `%s':\n"), arr->name);
  fprintf (stream, gettext ("\tload: %d/%d (%2.1f%%)\n"),
    arr->len, arr->size, 100.0 * arr->len / arr->size);
  switch (arr->growth) {
  case da_steady:
    cp = "[const]";
    break;
  case da_linear:
    cp = "+=";
    break;
  case da_geometrical:
    cp = "*=";
    break;
  default:
    abort ();
  }
  fprintf (stream, gettext ("\toriginal size: %d, growth: %s %d\n"),
    arr->original_size, cp, arr->increment);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 5
45 5
46 5
47 5
48 5
49 5
50 7
51 7
52 7
53 7
54 7
55 15
56 7
57 7
58 18
59 9
60 9
61 12
62 20
63 20
64 20
65 20
66 20
67 20
68 20
69 20
70 20
71 20
72 20
73 22
74 22
75 22
76 22
77 22
78 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %rdx,%rsi
callq  e1c <pw_lister_on_suffix+0x14>
mov    %rax,%rbx
mov    0x28(%rax),%rcx
mov    0x30(%rax),%rdx
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    %rbp,%rsi
mov    $0x0,%edi
callq  e40 <pw_lister_on_suffix+0x38>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  e4d <pw_lister_on_suffix+0x45>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pw_lister_on_suffix (FILE * stream, char * const * path, const char * suffix)
{
  struct darray * entries;
  entries = pw_glob_on_suffix (path, suffix);
  lister_fprint_vertical (((void *)0), stream,
     (void *) entries->content, entries->len,
     (lister_width_t) strlen,
     (lister_print_t) fputs);
  da_free (entries, (da_map_func_t) free);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 9
17 9
18 9
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  586 <gsl_sf_bessel_Knu_scaled+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     5ac <gsl_sf_bessel_Knu_scaled+0x32>
mov    %eax,%ecx
mov    $0xb2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5a5 <gsl_sf_bessel_Knu_scaled+0x2b>
movsd  (%rsp),%xmm0
jmp    5ac <gsl_sf_bessel_Knu_scaled+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Knu_scaled(const double nu, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Knu_scaled_e(nu, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Knu_scaled_e(nu, x, &result)", "bessel_Knu.c", 178, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x18(%rdi),%rdx
mov    (%rsi),%rcx
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 1fc <cholesky_init+0x17>
mov    $0x70,%esi
mov    $0x7a,%edi
callq  20b <cholesky_init+0x26>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cholesky_init(const void * vtrust_state, void * vstate)
{
  const gsl_multifit_nlinear_trust_state *trust_state =
    (const gsl_multifit_nlinear_trust_state *) vtrust_state;
  cholesky_state_t *state = (cholesky_state_t *) vstate;
  gsl_blas_dsyrk(CblasLower, CblasTrans, 1.0, trust_state->J, 0.0, state->JTJ);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 8
11 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 67 <gsl_set_error_handler+0x7>
mov    %rdi,0x0(%rip)        # 6e <gsl_set_error_handler+0xe>
retq   
<<<sep_in_sample>>>
gsl_set_error_handler (gsl_error_handler_t * new_handler)
{
  gsl_error_handler_t * previous_handler = gsl_error_handler;
  gsl_error_handler = new_handler;
  return previous_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%edx
test   %rsi,%rsi
je     d16 <parse_rock_ridge_stat+0x36>
mov    %rdi,%rbp
callq  99 <parse_rock_ridge_stat_internal>
mov    %eax,%edx
cmpb   $0xff,0x14(%rbx)
jne    d16 <parse_rock_ridge_stat+0x36>
cmpl   $0x0,(%rbx)
je     d16 <parse_rock_ridge_stat+0x36>
mov    $0xe,%edx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  99 <parse_rock_ridge_stat_internal>
mov    %eax,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_rock_ridge_stat(iso9660_dir_t *p_iso9660_dir,
                iso9660_stat_t *p_stat)
{
  int result;
  if (!p_stat) return 0;
  result = parse_rock_ridge_stat_internal(p_iso9660_dir, p_stat, 0);
  if (0xFF == p_stat->rr.s_rock_offset && nope != p_stat->rr.b3_rock) {
    result = parse_rock_ridge_stat_internal(p_iso9660_dir, p_stat, 14);
  }
  return result;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
movzbl (%rdi),%eax
cmp    $0x3a,%al
je     175 <findcalledby+0x25>
test   %al,%al
je     175 <findcalledby+0x25>
mov    %rdi,%rbx
add    $0x1,%rbx
movzbl (%rbx),%eax
cmp    $0x3a,%al
je     178 <findcalledby+0x28>
test   %al,%al
jne    164 <findcalledby+0x14>
jmp    178 <findcalledby+0x28>
mov    %rdi,%rbx
movb   $0x0,(%rbx)
callq  180 <findcalledby+0x30>
mov    %rax,%rbp
callq  0 <common>
movq   $0x0,(%rsp)
mov    %rbp,%r9
lea    0x1(%rbx),%r8
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x400,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1b3 <findcalledby+0x63>
mov    $0x0,%edi
callq  1bd <findcalledby+0x6d>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
findcalledby(char *pattern)
{
 char *p;
 for (p = pattern; *p && *p != ':'; p++)
  ;
 *p++ = '\0';
 snprintf(comline, sizeof(comline), "%s --from-here=\"%s\" %s > %s", common(), p, quote_shell(pattern), temp1);
 if (system(comline) != 0)
  return "global command failed";
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 8
32 8
33 9
34 9
35 9
36 9
37 11
38 11
39 11
40 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e4b <block_sigs+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
block_sigs (void)
{
  (void) sigprocmask (0, &fatal_signal_set, (sigset_t *) 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%eax
mov    %rsi,%rdi
mov    %eax,%esi
callq  f14 <swextopt_is_option_true+0x10>
mov    %rax,%rdi
callq  f1c <swextopt_is_option_true+0x18>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swextopt_is_option_true(enum eOpts nopt, struct extendedOptions * options)
{
 char * val;
 val = get_opta(options, nopt);
 return swextopt_is_value_true(val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x1c1,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  84d <make_arith_command+0x1d>
mov    %rax,%rbx
mov    $0x1c2,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  864 <make_arith_command+0x34>
mov    %rax,0x18(%rbx)
movl   $0x0,(%rax)
mov    0x0(%rip),%edx        # 874 <make_arith_command+0x44>
mov    %edx,0x4(%rax)
mov    %rbp,0x8(%rax)
movl   $0xa,(%rbx)
movq   $0x0,0x10(%rbx)
movl   $0x0,0x4(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
make_arith_command (exp)
     WORD_LIST *exp;
{
  COMMAND *command;
  ARITH_COM *temp;
  command = (COMMAND *)sh_xmalloc((sizeof (COMMAND)), "make_cmd.c", 449);
  command->value.Arith = temp = (ARITH_COM *)sh_xmalloc((sizeof (ARITH_COM)), "make_cmd.c", 450);
  temp->flags = 0;
  temp->line = line_number;
  temp->exp = exp;
  command->type = cm_arith;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  return (command);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 7
13 7
14 7
15 8
16 9
17 9
18 10
19 11
20 12
21 13
22 15
23 15
24 15
25 15
26 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
test   %edx,%edx
jle    28f <GetNNumbers+0x6f>
mov    %rdi,%r13
mov    %rsi,%r12
mov    %rcx,%r15
mov    $0x0,%ebx
jmp    25a <GetNNumbers+0x3a>
test   %ebx,%ebx
je     25a <GetNNumbers+0x3a>
mov    $0x2c,%edx
mov    %r12,%rsi
mov    %r13,%rdi
callq  25a <GetNNumbers+0x3a>
mov    $0x6,%edx
mov    %r12,%rsi
mov    %r13,%rdi
callq  26a <GetNNumbers+0x4a>
mov    %eax,%ebp
test   %eax,%eax
jne    294 <GetNNumbers+0x74>
movslq %ebx,%rax
lea    (%r15,%rax,8),%r14
mov    %r12,%rdi
callq  27f <GetNNumbers+0x5f>
movsd  %xmm0,(%r14)
add    $0x1,%ebx
cmp    %ebx,0xc(%rsp)
jg     246 <GetNNumbers+0x26>
jmp    294 <GetNNumbers+0x74>
mov    $0x0,%ebp
mov    %ebp,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
GetNNumbers (PINPUTBUF pibIn, PSTR szLex, int nNumbers, PDOUBLE rgd)
{
  BOOL bErr = 0;
  int i;
  for (i = 0; i < nNumbers && !bErr; i++) {
    if (i)
      GetOptPunct (pibIn, szLex, ',');
    if (!(bErr = ENextLex (pibIn, szLex, (0x0002 | 0x0004))))
      rgd[i] = atof(szLex);
  }
  return bErr;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 9
30 9
31 9
32 9
33 9
34 5
35 5
36 5
37 5
38 3
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%edi
callq  e <exact_sel>
<<<sep_in_sample>>>
sig_alarm(int sig)
{
    exit(2);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%r12
callq  1cb <xlstat+0x15>
mov    %rax,%rbx
mov    (%rax),%ebp
mov    %ebp,(%rbx)
mov    %r12,%rsi
mov    %r13,%rdi
callq  1dd <xlstat+0x27>
test   %eax,%eax
jns    1e6 <xlstat+0x30>
cmpl   $0x4,(%rbx)
je     1d0 <xlstat+0x1a>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xlstat(filename, buf)
    const char *filename;
    struct stat *buf;
{
    int result;
    int old_errno = (*__errno_location ());
    do
    {
 (*__errno_location ()) = old_errno;
 result = lstat(filename, buf);
    }
    while (result < 0 && (*__errno_location ()) == 4);
    return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 9
12 10
13 10
14 10
15 12
16 12
17 12
18 12
19 14
20 14
21 14
22 14
23 14
24 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1288 <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     dc7 <fdSetIo+0x12>
cmpl   $0xbeefdead,0x8(%rdi)
je     de0 <fdSetIo+0x2b>
mov    $0x0,%ecx
mov    $0xa8,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  de0 <fdSetIo+0x2b>
movslq 0xc(%rdi),%rax
lea    (%rax,%rax,2),%rax
mov    %rsi,0x10(%rdi,%rax,8)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fdSetIo(FD_t fd, FDIO_t io) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 168, __PRETTY_FUNCTION__));
    fd->fps[fd->nfps].io = io;
    return;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <gmk_alloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gmk_alloc (unsigned int len)
{
  return xmalloc (len);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
test   %esi,%esi
je     104 <sigsegv_handler+0x7e>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 94 <sigsegv_handler+0xe>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 9d <sigsegv_handler+0x17>
mov    0x0(%rip),%eax        # a3 <sigsegv_handler+0x1d>
cmp    $0x2,%eax
jg     c7 <sigsegv_handler+0x41>
mov    0x0(%rip),%esi        # ae <sigsegv_handler+0x28>
mov    $0x0,%edi
mov    $0x0,%eax
callq  bd <sigsegv_handler+0x37>
mov    $0x1,%edi
callq  c7 <sigsegv_handler+0x41>
mov    $0x0,%edi
callq  d1 <sigsegv_handler+0x4b>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x2,%edi
callq  e5 <sigsegv_handler+0x5f>
mov    0x0(%rip),%esi        # eb <sigsegv_handler+0x65>
movslq %esi,%rsi
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%edi
callq  102 <sigsegv_handler+0x7c>
jmp    10a <sigsegv_handler+0x84>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
xchg   %ax,%ax
retq   
<<<sep_in_sample>>>
sigsegv_handler (void *address, int emergency)
{
  if (!emergency)
    return 0;
  pass++;
  if (pass <= 2)
    {
      printf ("Stack overflow %d missed.\n", pass);
      exit (1);
    }
  else
    printf ("Segmentation violation correctly detected.\n");
  sigprocmask (2, &mainsigset, ((void *)0));
  return sigsegv_leave_handler (stackoverflow_handler_continuation,
                                (void *) (long) pass, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 5
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 9
15 9
16 12
17 12
18 13
19 13
20 13
21 13
22 15
23 15
24 14
25 14
26 14
27 14
28 14
29 4
30 4
31 16
32 16
33 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     677 <mu_mailbox_is_updated+0x24>
mov    0xc8(%rdi),%rdx
test   %rdx,%rdx
je     67d <mu_mailbox_is_updated+0x2a>
mov    $0x1,%eax
testb  $0x8,0x31(%rdi)
jne    687 <mu_mailbox_is_updated+0x34>
sub    $0x8,%rsp
callq  *%rdx
jmp    683 <mu_mailbox_is_updated+0x30>
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_mailbox_is_updated (mu_mailbox_t mbox)
{
  if (mbox == ((void *)0) || mbox->_is_updated == ((void *)0))
    return 1;
  if (mbox->flags & 0x00000800)
    return 1;
  return mbox->_is_updated (mbox);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 5
8 5
9 2
10 7
11 7
12 4
13 4
14 4
15 4
16 8
17 8
<<<sep_out_sample>>>
mov    0x10(%rdi),%r8
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    3809 <gsl_vector_char_set_basis+0x1f>
mov    %r8,%rdx
mov    $0x0,%eax
test   %rcx,%rcx
jne    382d <gsl_vector_char_set_basis+0x43>
jmp    383c <gsl_vector_char_set_basis+0x52>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3826 <gsl_vector_char_set_basis+0x3c>
mov    $0x4,%eax
jmp    384b <gsl_vector_char_set_basis+0x61>
movb   $0x0,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    382d <gsl_vector_char_set_basis+0x43>
imul   %rsi,%rdi
movb   $0x1,(%r8,%rdi,1)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_char_set_basis (gsl_vector_char * v, size_t i)
{
  char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const char zero = 0 ;
  const char one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(char *) (data + 1 * k * stride) = zero;
    }
  *(char *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 2
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 15
20 13
21 13
22 13
23 13
24 17
25 17
26 18
27 18
28 19
29 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1a82 <window_clear_echo_area+0x9>
mov    0x0(%rip),%rdi        # 1a89 <window_clear_echo_area+0x10>
callq  1a8e <window_clear_echo_area+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
window_clear_echo_area (void)
{
  free_echo_area ();
  display_update_one_window (the_echo_area);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xc,%edi
callq  14 <nettle_aes192_invert_key+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_aes192_invert_key (struct aes192_ctx *dst, const struct aes192_ctx *src)
{
  _nettle_aes_invert (12, dst->keys, src->keys);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
callq  877 <lostpeer+0xe>
mov    0x0(%rip),%rcx        # 87e <lostpeer+0x15>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  897 <lostpeer+0x2e>
mov    $0x1,%edi
callq  8a1 <stop>
<<<sep_in_sample>>>
lostpeer (int signo)
{
  setsig (signo, ((__sighandler_t) 1));
  error (0, 0, "\007Connection to %s lost.\r", host);
  done (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%rbx
mov    (%rdi),%edi
callq  ae <fd_write+0xb>
cmp    $0xffffffff,%eax
jne    bc <fd_write+0x19>
callq  b8 <fd_write+0x15>
mov    (%rax),%eax
jmp    c6 <fd_write+0x23>
cltq   
mov    %rax,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
fd_write(void *data, const char *buf, size_t size, size_t *pret)
{
    struct _stream *p = data;
    int n = write(p->fd, (char*) buf, size);
    if (n == -1)
 return (*__errno_location ());
    *pret = n;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 7
11 7
12 8
13 9
14 9
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%rbx
mov    %rdx,%rdi
callq  1a7 <CDB___db_reclaim_callback+0xc>
test   %eax,%eax
jne    1b1 <CDB___db_reclaim_callback+0x16>
movl   $0x1,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___db_reclaim_callback(dbp, p, cookie, putp)
 DB *dbp;
 PAGE *p;
 void *cookie;
 int *putp;
{ if (dbp) {}
 int ret;
 (dbp) = (((void *)0));
 if ((ret = CDB___db_free(cookie, p)) != 0)
  return (ret);
 *putp = 1;
 return (0);
}
<<<sep_in_sample>>>
1 6
2 6
3 9
4 9
5 9
6 9
7 11
8 13
9 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  600 <osip_ict_unlock+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_ict_unlock (osip_t * osip)
{
  return osip_mutex_unlock (osip->ict_fastmutex);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # bf1 <append_symbol+0xb>
test   %rax,%rax
je     c03 <append_symbol+0x1d>
mov    0x8(%rax),%rdx
mov    %rdx,0x0(%rip)        # c01 <append_symbol+0x1b>
jmp    c0d <append_symbol+0x27>
mov    $0x1,%edi
callq  c0d <append_symbol+0x27>
mov    %rbx,(%rax)
mov    0x0(%rip),%rdx        # c17 <append_symbol+0x31>
mov    0x8(%rdx),%rcx
mov    %rcx,0x8(%rax)
mov    %rax,0x8(%rdx)
pop    %rbx
retq   
<<<sep_in_sample>>>
append_symbol(NODE *r)
{
 NODE *p;
 (void) ((p = (NODE *) nextfree[BLOCK_NODE].freep) ? (NODE *) (nextfree[BLOCK_NODE].freep = ((BLOCK *) p)->freep) : (p = (NODE *) more_blocks(BLOCK_NODE)));
 p->sub.nodep.l.lptr = r;
 p->sub.nodep.r.rptr = symbol_list->sub.nodep.r.rptr;
 symbol_list->sub.nodep.r.rptr = p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 6
13 6
14 6
15 7
16 8
17 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     258 <canon_doc_option+0x61>
callq  206 <canon_doc_option+0xf>
mov    %rax,%r8
jmp    212 <canon_doc_option+0x1b>
add    $0x1,%rdx
mov    %rdx,(%rbx)
mov    (%r8),%rsi
mov    (%rbx),%rdx
movzbl (%rdx),%ecx
movzbl %cl,%edi
testb  $0x20,0x1(%rsi,%rdi,2)
jne    20b <canon_doc_option+0x14>
cmp    $0x2d,%cl
setne  %al
movzbl %al,%eax
test   %cl,%cl
je     25d <canon_doc_option+0x66>
testb  $0x8,(%rsi,%rdi,2)
jne    25d <canon_doc_option+0x66>
add    $0x1,%rdx
mov    %rdx,(%rbx)
movzbl (%rdx),%ecx
test   %cl,%cl
je     25d <canon_doc_option+0x66>
add    $0x1,%rdx
movzbl %cl,%ecx
mov    (%r8),%rsi
testb  $0x8,(%rsi,%rcx,2)
je     23c <canon_doc_option+0x45>
jmp    25d <canon_doc_option+0x66>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
canon_doc_option (const char **name)
{
  int non_opt;
  if (!*name)
    non_opt = 1;
  else
    {
      while (((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISspace))
        (*name)++;
      non_opt = (**name != '-');
      while (**name && !((*__ctype_b_loc ())[(int) (((unsigned char) **name))] & (unsigned short int) _ISalnum))
        (*name)++;
    }
  return non_opt;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 8
6 8
7 8
8 9
9 9
10 8
11 8
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 12
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 5
35 15
36 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # f1 <_rl_arg_getchar+0xa>
imul   0x0(%rip),%esi        # f8 <_rl_arg_getchar+0x11>
mov    $0x0,%edi
mov    $0x0,%eax
callq  107 <_rl_arg_getchar+0x20>
orq    $0x40,0x0(%rip)        # 10f <_rl_arg_getchar+0x28>
callq  114 <_rl_arg_getchar+0x2d>
andq   $0xffffffffffffffbf,0x0(%rip)        # 11c <_rl_arg_getchar+0x35>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_arg_getchar ()
{
  int c;
  rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 7
10 9
11 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
callq  49 <is_clean_relative_path+0xe>
mov    %eax,%ebx
test   %eax,%eax
jne    7f <is_clean_relative_path+0x44>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  5c <is_clean_relative_path+0x21>
test   %rax,%rax
jne    84 <is_clean_relative_path+0x49>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  6e <is_clean_relative_path+0x33>
test   %rax,%rax
jne    84 <is_clean_relative_path+0x49>
cmpb   $0x2f,0x0(%rbp)
setne  %bl
movzbl %bl,%ebx
jmp    84 <is_clean_relative_path+0x49>
mov    $0x0,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
is_clean_relative_path(char * name)
{
 if (
  swlib_is_sh_tainted_string(name) ||
  strstr(name, "../") ||
  strstr(name, "/..") ||
  *name == '/'
 ) {
  return 0;
 } else {
  return 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 3
8 3
9 5
10 5
11 5
12 4
13 4
14 6
15 6
16 6
17 5
18 5
19 6
20 6
21 6
22 6
23 9
24 13
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # a <swfdio_init+0xa>
movl   $0x1,0x0(%rip)        # 14 <swfdio_init+0x14>
movl   $0x2,0x0(%rip)        # 1e <swfdio_init+0x1e>
retq   
<<<sep_in_sample>>>
swfdio_init(void)
{
 swfdM[0] = 0;
 swfdM[1] = 1;
 swfdM[2] = 2;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
mov    %rdx,%r14
callq  5f6 <mu_parse822_atom+0x1c>
mov    0x0(%rbp),%r15
mov    $0x1007,%r12d
jmp    61f <mu_parse822_atom+0x45>
movsbl %bl,%esi
mov    %r14,%rdi
callq  cf <str_append_char>
mov    %eax,%r12d
addq   $0x1,0x0(%rbp)
test   %eax,%eax
je     61f <mu_parse822_atom+0x45>
mov    %r15,0x0(%rbp)
jmp    63c <mu_parse822_atom+0x62>
mov    0x0(%rbp),%rax
cmp    %r13,%rax
je     63c <mu_parse822_atom+0x62>
movzbl (%rax),%ebx
cmp    $0x2e,%bl
je     602 <mu_parse822_atom+0x28>
movsbl %bl,%edi
callq  638 <mu_parse822_atom+0x5e>
test   %eax,%eax
jne    602 <mu_parse822_atom+0x28>
mov    %r12d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
mu_parse822_atom (const char **p, const char *e, char **atom)
{
  const char *save = *p;
  int rc = (0x1000 +7);
  mu_parse822_skip_comments (p, e);
  save = *p;
  while ((*p != e) && (**p == '.' || mu_parse822_is_atom_char (**p)))
    {
      rc = str_append_char (atom, **p);
      *p += 1;
      if (rc != 0)
 {
   *p = save;
   break;
 }
    }
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 6
13 4
14 7
15 9
16 9
17 9
18 9
19 10
20 11
21 11
22 13
23 14
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 63f5 <dispose_used_env_vars+0x8>
je     640e <dispose_used_env_vars+0x21>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  631e <dispose_temporary_env>
callq  640a <dispose_used_env_vars+0x1d>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
dispose_used_env_vars ()
{
  if (temporary_env)
    {
      dispose_temporary_env (propagate_temp_var);
      maybe_make_export_env ();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 6
7 8
8 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x1,0x118(%rdi)
jne    14 <a2ps_print_char+0x14>
callq  12 <a2ps_print_char+0x12>
jmp    19 <a2ps_print_char+0x19>
callq  19 <a2ps_print_char+0x19>
add    $0x8,%rsp
nopl   (%rax)
retq   
<<<sep_in_sample>>>
a2ps_print_char (a2ps_job * job, int c, enum face_e new_face)
{
  switch (job->output_format)
    {
    case ps:
      ps_print_char (job, c, new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 6
5 6
6 9
7 11
8 11
9 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r13
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    $0x0,%eax
test   %ecx,%ecx
je     a23 <iso9660_name_translate_ext+0x111>
mov    %rsi,%r14
mov    %edx,%r15d
test   %ecx,%ecx
jle    a0f <iso9660_name_translate_ext+0xfd>
movzbl 0x0(%r13),%ebx
test   %bl,%bl
je     a16 <iso9660_name_translate_ext+0x104>
lea    -0x1(%rcx),%eax
mov    %rax,(%rsp)
mov    $0x0,%ebp
mov    $0x0,%r12d
lea    -0x2(%rcx),%eax
mov    %eax,0x8(%rsp)
lea    -0x3(%rcx),%eax
mov    %eax,0xc(%rsp)
jmp    997 <iso9660_name_translate_ext+0x85>
lea    0x1(%rbp),%r12
movzbl 0x1(%r13,%rbp,1),%ebx
test   %bl,%bl
je     a1b <iso9660_name_translate_ext+0x109>
mov    %r12,%rbp
test   %r15b,%r15b
jne    9b8 <iso9660_name_translate_ext+0xa6>
callq  9a1 <iso9660_name_translate_ext+0x8f>
movzbl %bl,%edx
mov    (%rax),%rax
testb  $0x1,0x1(%rax,%rdx,2)
je     9b8 <iso9660_name_translate_ext+0xa6>
movzbl %bl,%edi
callq  9b6 <iso9660_name_translate_ext+0xa4>
mov    %eax,%ebx
cmp    $0x2e,%bl
jne    9d9 <iso9660_name_translate_ext+0xc7>
mov    0xc(%rsp),%esi
mov    %esi,%eax
cmp    %ebp,%esi
jne    9fc <iso9660_name_translate_ext+0xea>
cmpb   $0x3b,0x1(%r13,%r12,1)
jne    9fc <iso9660_name_translate_ext+0xea>
cmpb   $0x31,0x2(%r13,%r12,1)
jne    9fc <iso9660_name_translate_ext+0xea>
jmp    a1b <iso9660_name_translate_ext+0x109>
cmp    $0x3b,%bl
jne    9fc <iso9660_name_translate_ext+0xea>
mov    0x8(%rsp),%ecx
mov    %ecx,%eax
cmp    %ebp,%ecx
jne    9f7 <iso9660_name_translate_ext+0xe5>
cmpb   $0x31,0x1(%r13,%r12,1)
je     a1b <iso9660_name_translate_ext+0x109>
mov    $0x2e,%ebx
jmp    9fc <iso9660_name_translate_ext+0xea>
mov    $0x2e,%ebx
mov    %bl,(%r14,%r12,1)
lea    0x1(%rbp),%eax
cmp    (%rsp),%rbp
jne    982 <iso9660_name_translate_ext+0x70>
jmp    a1b <iso9660_name_translate_ext+0x109>
mov    $0x0,%eax
jmp    a1b <iso9660_name_translate_ext+0x109>
mov    $0x0,%eax
movslq %eax,%rdx
movb   $0x0,(%r14,%rdx,1)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
iso9660_name_translate_ext(const char *psz_oldname, char *psz_newname,
                           uint8_t u_joliet_level)
{
  int len = strlen(psz_oldname);
  int i;
  if (0 == len) return 0;
  for (i = 0; i < len; i++) {
    unsigned char c = psz_oldname[i];
    if (!c)
      break;
    if (!u_joliet_level && ((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISupper)) c = tolower(c);
    if (c == '.' && i == len - 3
        && psz_oldname[i + 1] == ';' && psz_oldname[i + 2] == '1')
      break;
    if (c == ';' && i == len - 2 && psz_oldname[i + 1] == '1')
      break;
    if (c == ';')
      c = '.';
    psz_newname[i] = c;
  }
  psz_newname[i] = '\0';
  return i;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 8
22 9
23 9
24 9
25 9
26 9
27 8
28 15
29 15
30 12
31 12
32 12
33 12
34 8
35 9
36 9
37 9
38 11
39 11
40 11
41 11
42 11
43 11
44 11
45 11
46 11
47 11
48 12
49 12
50 12
51 12
52 12
53 12
54 13
55 13
56 13
57 13
58 13
59 15
60 15
61 15
62 15
63 15
64 15
65 15
66 15
67 18
68 18
69 18
70 19
71 19
72 7
73 7
74 7
75 7
76 7
77 9
78 21
79 21
80 23
81 23
82 23
83 23
84 23
85 23
86 23
87 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  cb <safe_write+0x9>
test   %rax,%rax
jns    eb <safe_write+0x29>
callq  d5 <safe_write+0x13>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  eb <safe_write+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
safe_write (int socket, const char *str, size_t len)
{
  if (write (socket, str, len) < 0)
    error (1, (*__errno_location ()), "error sending data");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rsi,0x8(%rbp)
mov    0x30(%rsi),%rdi
callq  2f5 <debpsf_open+0x17>
mov    $0xffffffff,%edx
cmp    $0xb,%eax
jne    377 <debpsf_open+0x99>
callq  304 <debpsf_open+0x26>
mov    %eax,%r12d
test   %eax,%eax
js     364 <debpsf_open+0x86>
mov    0x48(%rbx),%esi
mov    %eax,%edi
callq  315 <debpsf_open+0x37>
test   %eax,%eax
js     36b <debpsf_open+0x8d>
mov    %r12d,0x14(%rbp)
mov    $0x0,%edx
mov    $0x0,%esi
mov    %r12d,%edi
callq  32f <debpsf_open+0x51>
lea    0x30(%rbx),%rdx
mov    0x30(%rbx),%rax
mov    0x19c(%rax),%edi
mov    $0x40000,%ecx
mov    $0x0,%esi
callq  34c <debpsf_open+0x6e>
mov    %eax,%ebx
test   %eax,%eax
js     372 <debpsf_open+0x94>
callq  357 <debpsf_open+0x79>
mov    %eax,0x18(%rbp)
mov    %ebx,0x1c(%rbp)
mov    $0x0,%edx
jmp    377 <debpsf_open+0x99>
mov    $0xfffffffe,%edx
jmp    377 <debpsf_open+0x99>
mov    $0xfffffffd,%edx
jmp    377 <debpsf_open+0x99>
mov    $0xfffffffc,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
debpsf_open(DEBPSF * dp, void * v_topsf)
{
 int ret;
 int fd;
 TOPSF * topsf = (TOPSF*)v_topsf;
 dp->topsfM = topsf;
 if (uinfile_get_type(topsf->format_desc_) != 11) {
  return -1;
 }
 fd = swlib_open_memfd();
 if (fd < 0) return -2;
 ret = swlib_pipe_pump(fd, topsf->fd_);
 if (ret < 0) return -3;
 dp->control_fdM = fd;
 uxfio_lseek(fd, 0, 0);
 ret = uinfile_opendup(topsf->format_desc_->deb_file_fd_, 0,
   &(topsf->format_desc_), (1 << 18));
 if (ret < 0) return -4;
 dp->data_fdM = swlib_open_memfd();
 dp->source_data_fdM = ret;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 7
8 7
9 8
10 7
11 7
12 10
13 10
14 11
15 11
16 12
17 12
18 12
19 13
20 13
21 14
22 15
23 15
24 15
25 15
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 18
34 18
35 19
36 19
37 20
38 21
39 21
40 11
41 11
42 13
43 13
44 18
45 22
46 22
47 22
48 22
49 22
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # d87 <gsl_vector_short_set+0x7>
je     dad <gsl_vector_short_set+0x2d>
cmp    %rsi,(%rdi)
ja     dad <gsl_vector_short_set+0x2d>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  dab <gsl_vector_short_set+0x2b>
jmp    dc1 <gsl_vector_short_set+0x41>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rax,%rsi
mov    0x10(%rdi),%rax
mov    %dx,(%rax,%rsi,1)
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_short_set (gsl_vector_short * v, const size_t i, short x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
movsd  0x0(%rip),%xmm0        # 1c <decimal_point_char+0x1c>
mov    $0x0,%esi
mov    %rsp,%rdi
mov    $0x1,%eax
callq  2e <decimal_point_char+0x2e>
movzbl 0x1(%rsp),%eax
test   %al,%al
mov    $0x2e,%edx
cmove  %edx,%eax
mov    0x8(%rsp),%rcx
xor    %fs:0x28,%rcx
je     52 <decimal_point_char+0x52>
callq  52 <decimal_point_char+0x52>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
decimal_point_char (void)
{
  const char *point;
  char pointbuf[5];
  sprintf (pointbuf, "%#.0f", 1.0);
  point = &pointbuf[1];
  return (point[0] != '\0' ? point[0] : '.');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %rcx,%r14
mov    %r8,%r15
mov    %r9,%rbx
callq  6c9 <gsl_stats_uint_ttest+0x25>
movsd  %xmm0,(%rsp)
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  6dc <gsl_stats_uint_ttest+0x38>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  6f9 <gsl_stats_uint_ttest+0x55>
test   %rbp,%rbp
js     705 <gsl_stats_uint_ttest+0x61>
cvtsi2sd %rbp,%xmm3
jmp    71d <gsl_stats_uint_ttest+0x79>
mov    %rbp,%rax
shr    %rax
mov    %rbp,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # 725 <gsl_stats_uint_ttest+0x81>
divsd  %xmm3,%xmm2
test   %rbx,%rbx
js     735 <gsl_stats_uint_ttest+0x91>
cvtsi2sd %rbx,%xmm3
jmp    74d <gsl_stats_uint_ttest+0xa9>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm1        # 755 <gsl_stats_uint_ttest+0xb1>
divsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    7da <gsl_stats_uint_ttest+0x136>
test   %rbp,%rbp
js     777 <gsl_stats_uint_ttest+0xd3>
cvtsi2sd %rbp,%xmm1
jmp    78c <gsl_stats_uint_ttest+0xe8>
mov    %rbp,%rax
shr    %rax
and    $0x1,%ebp
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm2        # 794 <gsl_stats_uint_ttest+0xf0>
divsd  %xmm1,%xmm2
test   %rbx,%rbx
js     7a4 <gsl_stats_uint_ttest+0x100>
cvtsi2sd %rbx,%xmm1
jmp    7b9 <gsl_stats_uint_ttest+0x115>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 7c1 <gsl_stats_uint_ttest+0x11d>
divsd  %xmm1,%xmm3
movapd %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
callq  7d6 <gsl_stats_uint_ttest+0x132>
movapd %xmm0,%xmm1
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
divsd  %xmm1,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_uint_ttest (const unsigned int data1[],
                           const size_t stride1, const size_t n1,
                           const unsigned int data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_uint_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_uint_mean (data2, stride2, n2);
  const double pv = gsl_stats_uint_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 11
92 11
93 11
94 11
95 11
96 11
97 11
98 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x40(%rdi),%r12
cmp    %r12,0x58(%rdi)
cmovbe 0x58(%rdi),%r12
mov    0x30(%rdi),%rbx
cmp    %rbx,%r12
jbe    257d <build_upper_buffer+0x7b>
callq  252a <build_upper_buffer+0x28>
mov    %rax,%r13
mov    %rbx,%rax
add    0x0(%rbp),%rax
add    0x28(%rbp),%rax
movzbl (%rax),%eax
movzbl %al,%edi
mov    0x78(%rbp),%rdx
test   %rdx,%rdx
je     254e <build_upper_buffer+0x4c>
movzbl %al,%eax
movzbl (%rdx,%rax,1),%edi
movslq %edi,%rdx
mov    0x0(%r13),%rax
testb  $0x2,0x1(%rax,%rdx,2)
je     256a <build_upper_buffer+0x68>
callq  2561 <build_upper_buffer+0x5f>
mov    0x8(%rbp),%rdx
mov    %al,(%rdx,%rbx,1)
jmp    2572 <build_upper_buffer+0x70>
mov    0x8(%rbp),%rax
mov    %dil,(%rax,%rbx,1)
add    $0x1,%rbx
cmp    %r12,%rbx
jne    252d <build_upper_buffer+0x2b>
jmp    2580 <build_upper_buffer+0x7e>
mov    %rbx,%r12
mov    %r12,0x30(%rbp)
mov    %r12,0x38(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
build_upper_buffer (re_string_t *pstr)
{
  Idx char_idx, end_idx;
  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)
    {
      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];
      if (__builtin_expect (pstr->trans != ((void *)0), 0))
 ch = pstr->trans[ch];
      if (((*__ctype_b_loc ())[(int) ((ch))] & (unsigned short int) _ISlower))
 pstr->mbs[char_idx] = toupper (ch);
      else
 pstr->mbs[char_idx] = ch;
    }
  pstr->valid_len = char_idx;
  pstr->valid_raw_len = char_idx;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 10
14 10
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 13
34 13
35 5
36 5
37 5
38 5
39 5
40 15
41 16
42 17
43 17
44 17
45 17
46 17
47 17
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 8b78 <getifs+0x7>
retq   
<<<sep_in_sample>>>
getifs ()
{
  return ifs_value;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
test   %esi,%esi
js     388 <cplob_remove_index+0x52>
push   %rbx
mov    %rdi,%rbx
mov    0xc(%rdi),%eax
cmp    %eax,%esi
jge    38e <cplob_remove_index+0x58>
test   %eax,%eax
je     397 <cplob_remove_index+0x61>
mov    0x8(%rdi),%edx
test   %edx,%edx
je     395 <cplob_remove_index+0x5f>
mov    (%rdi),%rdi
movslq %esi,%rdx
lea    0x8(,%rdx,8),%rcx
sub    %esi,%eax
lea    -0x1(%rax),%edx
movslq %edx,%rdx
imul   0x10(%rbx),%rdx
lea    (%rdi,%rcx,1),%rsi
lea    -0x8(%rdi,%rcx,1),%rdi
callq  379 <cplob_remove_index+0x43>
subl   $0x1,0xc(%rbx)
subl   $0x1,0x8(%rbx)
mov    $0x0,%eax
jmp    397 <cplob_remove_index+0x61>
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
jmp    397 <cplob_remove_index+0x61>
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
cplob_remove_index(CPLOB * lob, int i)
{
 if (i < 0 || i >= lob->nused) return -1;
 if (lob->nused == 0 || lob->nlen == 0) return 0;
 memmove (lob->list+i, lob->list+i+1,
  lob->width * (lob->nused - i - 1));
 lob->nused--;
 lob->nlen--;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 5
19 5
20 5
21 5
22 5
23 7
24 8
25 9
26 9
27 3
28 10
29 3
30 3
31 4
32 10
33 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdx),%rax
mov    0x8(%rdx),%rdx
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multilarge_linear_accumulate(gsl_matrix * X, gsl_vector * y,
                                 gsl_multilarge_linear_workspace * w)
{
  int status = w->type->accumulate(X, y, w->state);
  return status;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1c75 <hide+0xe>
mov    $0x0,%eax
callq  1c7f <hide+0x18>
mov    0x0(%rip),%rdi        # 1c86 <hide+0x1f>
callq  1c8b <hide+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
hide()
{
    tty_set_mode(0);
    tty_defaults();
    tty_put_screen(screen);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,0x8(%rsp)
mov    %rcx,%r14
mov    %r8d,%r15d
mov    (%rdi),%r13
movq   $0x0,0x10(%rsp)
movq   $0x0,0x18(%rsp)
lea    0x10(%rsp),%rdx
callq  1a7a <mu_parse822_addr_spec+0x3e>
mov    %eax,%ebp
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1a87 <mu_parse822_addr_spec+0x4b>
test   %ebp,%ebp
jne    1ae2 <mu_parse822_addr_spec+0xa6>
mov    $0x40,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1a9b <mu_parse822_addr_spec+0x5f>
mov    %eax,%ebp
test   %eax,%eax
jne    1ae2 <mu_parse822_addr_spec+0xa6>
lea    0x18(%rsp),%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1ab1 <mu_parse822_addr_spec+0x75>
mov    %eax,%ebp
test   %eax,%eax
jne    1ae2 <mu_parse822_addr_spec+0xa6>
mov    %r15d,(%rsp)
mov    %r14,%r9
mov    0x18(%rsp),%r8
mov    0x10(%rsp),%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  1822 <fill_mb>
mov    %eax,%ebp
test   %eax,%eax
je     1af9 <mu_parse822_addr_spec+0xbd>
mov    %r13,(%rbx)
lea    0x10(%rsp),%rdi
callq  11e <str_free>
lea    0x18(%rsp),%rdi
callq  11e <str_free>
mov    %ebp,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
mu_parse822_addr_spec (const char **p, const char *e, mu_address_t *a,
         mu_address_t hint, int hflags)
{
  const char *save = *p;
  char *local_part = 0;
  char *domain = 0;
  int rc;
  rc = mu_parse822_local_part (p, e, &local_part);
  mu_parse822_skip_comments (p, e);
  if (!rc)
    {
      rc = mu_parse822_special (p, e, '@');
      if (!rc)
 {
   rc = mu_parse822_domain (p, e, &domain);
   if (!rc)
     rc = fill_mb (a, 0, 0, local_part, domain, hint, hflags);
 }
    }
  if (rc)
    {
      *p = save;
      str_free (&local_part);
      str_free (&domain);
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 5
15 6
16 8
17 8
18 8
19 9
20 9
21 9
22 10
23 10
24 12
25 12
26 12
27 12
28 12
29 13
30 13
31 15
32 15
33 15
34 15
35 15
36 16
37 16
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 17
46 17
47 20
48 20
49 22
50 23
51 23
52 24
53 24
54 27
55 27
56 27
57 27
58 27
59 27
60 27
61 27
62 27
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rsi        # 120d <put_brace+0xb>
mov    $0x0,%edi
callq  1217 <put_brace+0x15>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1224 <put_brace+0x22>
mov    0x0(%rip),%rsi        # 122b <put_brace+0x29>
mov    $0x0,%edi
callq  1235 <put_brace+0x33>
pop    %rbx
retq   
<<<sep_in_sample>>>
put_brace(const char *text)
{
 strbuf_puts(outbuf, brace_begin);
 strbuf_puts(outbuf, text);
 strbuf_puts(outbuf, brace_end);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    4e5 <gsl_blas_zswap+0x2d>
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  4de <gsl_blas_zswap+0x26>
mov    $0x0,%eax
jmp    503 <gsl_blas_zswap+0x4b>
mov    $0x13,%ecx
mov    $0x13c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4fe <gsl_blas_zswap+0x46>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_zswap (gsl_vector_complex * X, gsl_vector_complex * Y)
{
  if (X->size == Y->size)
    {
      cblas_zswap (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                   ((int)(Y->stride)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 316, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 11
15 11
16 11
17 11
18 11
19 11
20 13
21 13
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%eax        # f2 <mark+0x7>
lea    -0x1(%rdi,%rax,1),%ebx
cmp    0x0(%rip),%ebx        # fc <mark+0x11>
jae    15d <mark+0x72>
mov    %edi,%edi
mov    0x0(%rip),%rax        # 107 <mark+0x1c>
mov    (%rax,%rdi,4),%esi
mov    $0x1,%edx
mov    0x0(%rip),%rdi        # 116 <mark+0x2b>
callq  11b <mark+0x30>
mov    %ebx,%ebx
mov    0x0(%rip),%rax        # 124 <mark+0x39>
lea    (%rax,%rbx,4),%rax
cmpl   $0x0,(%rax)
jne    146 <mark+0x5b>
movl   $0x1,(%rax)
mov    $0x3e,%esi
mov    0x0(%rip),%rdi        # 13f <mark+0x54>
callq  144 <mark+0x59>
jmp    15d <mark+0x72>
movl   $0x0,(%rax)
mov    $0x20,%esi
mov    0x0(%rip),%rdi        # 158 <mark+0x6d>
callq  15d <mark+0x72>
pop    %rbx
retq   
<<<sep_in_sample>>>
mark(unsigned int i)
{
    unsigned int j;
    j = i + topline - 1;
    if (j < totallines) {
 wmove(stdscr,(displine[i]),(1));
 if (change[j] == NO) {
     change[j] = YES;
     waddch(stdscr,('>'));
 } else {
     change[j] = NO;
     waddch(stdscr,(' '));
 }
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 8
18 9
19 9
20 9
21 9
22 11
23 12
24 12
25 12
26 15
27 15
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %rsi,%rax
mov    %edx,0x20(%rsp)
movl   $0x0,0x24(%rsp)
mov    %rdi,0x28(%rsp)
movq   $0x0,0x30(%rsp)
movq   $0x0,0x38(%rsp)
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
lea    0x20(%rsp),%rdx
mov    %rdx,0x10(%rsp)
mov    %rsp,%rsi
mov    (%rax),%rdi
callq  3c0 <mu_cfg_format_parse_tree+0x50>
mov    0x30(%rsp),%rdi
callq  3ca <mu_cfg_format_parse_tree+0x5a>
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
mu_cfg_format_parse_tree (mu_stream_t stream, mu_cfg_tree_t *tree, int flags)
{
  struct mu_cfg_iter_closure clos;
  struct tree_print t;
  t.flags = flags;
  t.level = 0;
  t.stream = stream;
  t.buf = ((void *)0);
  t.bufsize = 0;
  clos.beg = format_node;
  clos.end = format_node_end;
  clos.data = &t;
  mu_cfg_preorder (tree->nodes, &clos);
  free (t.buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 6
5 7
6 8
7 9
8 10
9 11
10 12
11 12
12 13
13 13
14 13
15 14
16 14
17 15
18 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <scram_start>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_gsasl_scram_sha1_plus_server_start (Gsasl_session * sctx, void **mech_data)
{
  return scram_start (sctx, mech_data, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     eb9 <gsl_permute_vector_ulong+0x2c>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  eb2 <gsl_permute_vector_ulong+0x25>
mov    $0x13,%eax
jmp    ecf <gsl_permute_vector_ulong+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  eca <gsl_permute_vector_ulong+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_ulong (const gsl_permutation * p, gsl_vector_ulong * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_ulong (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9da <sexalloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sexalloc (yy_size_t size , yyscan_t yyscanner)
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rsi
test   %rsi,%rsi
je     69 <fd_ostream__flush+0x69>
mov    0x20(%rdi),%rax
cmp    $0xfff,%rax
ja     69 <fd_ostream__flush+0x69>
mov    $0x1000,%ebp
sub    %rax,%rbp
mov    0x8(%rdi),%edi
mov    %rbp,%rdx
callq  2f <fd_ostream__flush+0x2f>
cmp    %rax,%rbp
jbe    61 <fd_ostream__flush+0x61>
mov    0x10(%rbx),%r12
mov    $0x0,%edi
callq  42 <fd_ostream__flush+0x42>
mov    %rax,%rbp
callq  4a <fd_ostream__flush+0x4a>
mov    %r12,%rcx
mov    %rbp,%rdx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  61 <fd_ostream__flush+0x61>
movq   $0x1000,0x20(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fd_ostream__flush (fd_ostream_t stream)
{
  if (stream->buffer != ((void *)0) && stream->avail < 4096)
    {
      size_t filled = 4096 - stream->avail;
      if (full_write (stream->fd, stream->buffer, filled) < filled)
        error (1, (*__errno_location ()), gettext ("error writing to %s"), stream->filename);
      stream->avail = 4096;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 8
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
mov    %esi,0x8(%rdi)
retq   
<<<sep_in_sample>>>
swacfl_set_type(swacfl_entry * en, int type)
{
 en->source_code_=type;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 9c2 <yyset_lineno+0x6>
retq   
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmpl   $0x4,0x0(%rip)        # 3af <guess_seekable_archive+0x7>
jne    3b8 <guess_seekable_archive+0x10>
movb   $0x0,0x0(%rip)        # 3b8 <guess_seekable_archive+0x10>
mov    0x0(%rip),%eax        # 3be <guess_seekable_archive+0x16>
cmp    $0xffffffff,%eax
je     3cd <guess_seekable_archive+0x25>
test   %eax,%eax
setne  0x0(%rip)        # 3cc <guess_seekable_archive+0x24>
retq   
cmpb   $0x0,0x0(%rip)        # 3d4 <guess_seekable_archive+0x2c>
jne    41f <guess_seekable_archive+0x77>
cmpq   $0x0,0x0(%rip)        # 3de <guess_seekable_archive+0x36>
jne    41f <guess_seekable_archive+0x77>
sub    $0x98,%rsp
mov    %rsp,%rsi
mov    0x0(%rip),%edi        # 3f0 <guess_seekable_archive+0x48>
callq  3f5 <guess_seekable_archive+0x4d>
test   %eax,%eax
jne    410 <guess_seekable_archive+0x68>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x8000,%eax
sete   0x0(%rip)        # 40e <guess_seekable_archive+0x66>
jmp    417 <guess_seekable_archive+0x6f>
movb   $0x0,0x0(%rip)        # 417 <guess_seekable_archive+0x6f>
add    $0x98,%rsp
retq   
movb   $0x0,0x0(%rip)        # 426 <guess_seekable_archive+0x7e>
retq   
<<<sep_in_sample>>>
guess_seekable_archive (void)
{
  struct stat st;
  if (subcommand_option == DELETE_SUBCOMMAND)
    {
      seekable_archive = 0;
    }
  if (seek_option != -1)
    {
      seekable_archive = !!seek_option;
      return;
    }
  if (!multi_volume_option && !use_compress_program_option
      && fstat (archive, &st) == 0)
    seekable_archive = ((((st.st_mode)) & 0170000) == (0100000));
  else
    seekable_archive = 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 8
5 8
6 8
7 10
8 10
9 10
10 13
11 13
12 13
13 13
14 2
15 14
16 14
17 14
18 14
19 14
20 15
21 15
22 15
23 15
24 15
25 17
26 18
27 18
28 17
29 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %ecx,%ebp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
movabs $0x2020202020202020,%rax
mov    %rax,(%rsp)
cmp    $0x8,%edx
jg     39 <swdef_write_keyword_to_buffer+0x39>
test   %edx,%edx
je     4c <swdef_write_keyword_to_buffer+0x4c>
jmp    3e <swdef_write_keyword_to_buffer+0x3e>
mov    $0x1,%edx
movslq %edx,%rdx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  4c <swdef_write_keyword_to_buffer+0x4c>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  57 <swdef_write_keyword_to_buffer+0x57>
cmp    $0x4f,%ebp
jne    6b <swdef_write_keyword_to_buffer+0x6b>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  69 <swdef_write_keyword_to_buffer+0x69>
jmp    78 <swdef_write_keyword_to_buffer+0x78>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  78 <swdef_write_keyword_to_buffer+0x78>
mov    %rbx,%rdi
callq  80 <swdef_write_keyword_to_buffer+0x80>
mov    0x8(%rsp),%rcx
xor    %fs:0x28,%rcx
je     95 <swdef_write_keyword_to_buffer+0x95>
callq  95 <swdef_write_keyword_to_buffer+0x95>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swdef_write_keyword_to_buffer(STROB * ob, char *keyword, int level,
  int attribute_type)
{
 char sp[8];
 memset(sp, 040, sizeof(sp));
 if (level > (int)sizeof(sp)) level = 1;
 if (level)
  strob_strncat(ob, sp, level);
 strob_strcat(ob, keyword);
 if (attribute_type == 'O') {
  strob_strcat(ob, "\n");
 } else {
  strob_strcat(ob, " ");
 }
 return strob_strlen(ob);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 6
14 6
15 7
16 7
17 7
18 6
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 10
27 10
28 11
29 11
30 11
31 11
32 13
33 13
34 13
35 15
36 15
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 16
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x4018,%rsp
mov    %rdi,%r13
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x4008(%rsp)
xor    %eax,%eax
mov    %rbx,%rcx
mov    $0x4000,%edx
mov    $0x1,%esi
mov    %rsp,%rdi
callq  3e <hash_file+0x3e>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  49 <hash_file+0x49>
test   %eax,%eax
jne    68 <hash_file+0x68>
mov    %rsp,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  *0x20(%r13)
mov    %rbx,%rdi
callq  62 <hash_file+0x62>
test   %eax,%eax
je     29 <hash_file+0x29>
jmp    72 <hash_file+0x72>
mov    $0x0,%eax
nopl   (%rax)
jmp    77 <hash_file+0x77>
mov    $0x1,%eax
mov    0x4008(%rsp),%rcx
xor    %fs:0x28,%rcx
je     8f <hash_file+0x8f>
callq  8f <hash_file+0x8f>
add    $0x4018,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
hash_file(const struct nettle_hash *hash, void *ctx, FILE *f)
{
  for (;;)
    {
      char buffer[16384];
      size_t res = fread(buffer, 1, sizeof(buffer), f);
      if (ferror(f))
 return 0;
      hash->update(ctx, res, buffer);
      if (feof(f))
 return 1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 10
27 10
28 10
29 10
30 10
31 8
32 8
33 8
34 11
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 21ff <sctofunc+0x7>
test   %rax,%rax
je     221b <sctofunc+0x23>
mov    0x18(%rdi),%rdx
cmp    %rdx,(%rax)
je     221b <sctofunc+0x23>
mov    0x30(%rax),%rax
test   %rax,%rax
je     221b <sctofunc+0x23>
cmp    %rdx,(%rax)
jne    220d <sctofunc+0x15>
repz retq 
<<<sep_in_sample>>>
sctofunc(const sc *s)
{
    subnfunc *f = allfuncs;
    while (f != ((void *)0) && f->scfunc != s->scfunc)
 f = f->next;
    return f;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 4
9 4
10 4
11 4
12 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     15d3 <swverid_disconnect_alternates+0x1b>
mov    0x40(%rdi),%rax
movq   $0x0,0x40(%rdi)
test   %rax,%rax
je     15d3 <swverid_disconnect_alternates+0x1b>
mov    %rax,%rdi
jmp    15bd <swverid_disconnect_alternates+0x5>
repz retq 
<<<sep_in_sample>>>
swverid_disconnect_alternates(SWVERID * swverid) {
 SWVERID * oldparent;
 SWVERID * parent;
 parent = swverid;
 while (parent) {
  oldparent = parent;
  parent = parent->altM;
  oldparent->altM = ((void *)0);
 }
}
<<<sep_in_sample>>>
1 5
2 5
3 7
4 8
5 5
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x1,%esi
mov    $0x838,%edi
callq  5f8 <qp_init+0x18>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     666 <qp_init+0x86>
movq   $0x4c,0x8(%rbx)
mov    $0x1,%esi
mov    $0x4c,%edi
callq  61c <qp_init+0x3c>
mov    %rax,0x18(%rbx)
test   %rax,%rax
jne    634 <qp_init+0x54>
mov    %rbx,%rdi
callq  62d <qp_init+0x4d>
mov    $0xc,%eax
jmp    666 <qp_init+0x86>
cmpl   $0x0,0x1c(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
cmovne %rdx,%rax
mov    %rax,0x830(%rbx)
movq   $0x0,0x28(%rbp)
movq   $0x0,0x40(%rbp)
mov    %rbx,0x20(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
qp_init (mu_filter_t filter)
{
  struct _trans_stream *ts;
  ts = calloc (sizeof (*ts), 1);
  if (ts == ((void *)0))
    return 12;
  ts->min_size = 76;
  ts->s_buf = calloc (ts->min_size, 1);
  if (ts->s_buf == ((void *)0))
    {
      free (ts);
      return 12;
    }
  ts->transcoder = (filter->type == 0) ? qp_decode : qp_encode;
  filter->_read = trans_read;
  filter->_destroy = trans_destroy;
  filter->data = ts;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 5
11 5
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 11
20 11
21 12
22 12
23 14
24 14
25 14
26 14
27 14
28 15
29 16
30 17
31 18
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # 4db <include_languages+0xc>
je     4f6 <include_languages+0x27>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  4f6 <include_languages+0x27>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 505 <include_languages+0x36>
callq  50a <include_languages+0x3b>
mov    %rax,0x0(%rip)        # 511 <include_languages+0x42>
pop    %rbx
retq   
<<<sep_in_sample>>>
include_languages (char *lang_names)
{
  if (langs_excluded)
    error (1, 0, "can't mix --include and --exclude options");
  langs_included = append_strings_to_vector (langs_included, lang_names, white_space);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%r12d
mov    %rdi,%rsi
mov    $0x0,%edi
callq  14 <set_is_ieee_control_script+0x14>
mov    %rax,%rbp
mov    $0x70,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  29 <set_is_ieee_control_script+0x29>
mov    0x0(%rip),%rsi        # 30 <set_is_ieee_control_script+0x30>
test   %rsi,%rsi
je     64 <set_is_ieee_control_script+0x64>
mov    $0x0,%ebx
mov    %rbp,%rdi
callq  42 <set_is_ieee_control_script+0x42>
test   %eax,%eax
jne    55 <set_is_ieee_control_script+0x55>
mov    $0x1,%al
test   %r12d,%r12d
je     70 <set_is_ieee_control_script+0x70>
movl   $0x1,(%rbx)
jmp    70 <set_is_ieee_control_script+0x70>
add    $0x10,%rbx
mov    0x8(%rbx),%rsi
test   %rsi,%rsi
jne    3a <set_is_ieee_control_script+0x3a>
jmp    6b <set_is_ieee_control_script+0x6b>
mov    $0x0,%eax
jmp    70 <set_is_ieee_control_script+0x70>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
set_is_ieee_control_script(char * pathname, int do_set)
{
 char * base;
 G_CONTROL_SCRIPT * script_ent;
 base = swlib_basename(((void *)0), pathname);
 swi_com_assert_pointer((void*)base, "swi_afile.c", 112);
 script_ent = pp_g_scripts;
 while ((script_ent)->tagM) {
  if (strcmp(base, (script_ent)->tagM) == 0) {
   if (do_set) {
    (script_ent)->did_itM = 1;
   }
   return 1;
  }
  script_ent++;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 7
17 9
18 9
19 9
20 9
21 13
22 10
23 10
24 11
25 11
26 15
27 8
28 8
29 8
30 8
31 17
32 17
33 17
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
mov    (%rdi),%rcx
lea    0x1(%rcx),%rax
cmp    %rdx,%rax
je     346 <gsl_histogram_set_ranges+0x30>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xb4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  33f <gsl_histogram_set_ranges+0x29>
mov    $0x4,%eax
jmp    391 <gsl_histogram_set_ranges+0x7b>
mov    $0x0,%eax
movsd  (%rsi,%rax,8),%xmm0
mov    0x8(%rdi),%rdx
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rax,%rcx
jae    34b <gsl_histogram_set_ranges+0x35>
test   %rcx,%rcx
je     384 <gsl_histogram_set_ranges+0x6e>
mov    $0x0,%eax
xorpd  %xmm0,%xmm0
mov    0x10(%rdi),%rdx
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    370 <gsl_histogram_set_ranges+0x5a>
jmp    38a <gsl_histogram_set_ranges+0x74>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
nop
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_histogram_set_ranges (gsl_histogram * h, const double range[], size_t size)
{
  size_t i;
  const size_t n = h->n;
  if (size != (n+1))
    {
      do { gsl_error ("size of range must match size of histogram", "init.c", 180, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i <= n; i++)
    {
      h->range[i] = range[i];
    }
  for (i = 0; i < n; i++)
    {
      h->bin[i] = 0;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 2
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 11
15 11
16 11
17 9
18 9
19 9
20 13
21 13
22 13
23 15
24 15
25 15
26 13
27 13
28 13
29 13
30 17
31 17
32 17
33 17
34 17
35 18
36 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <_add_load_dir+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_add_load_dir (void *item, void *unused)
{
    char *str = item;
    return lt_dladdsearchdir(str);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     7fc <mu_address_set_domain+0x56>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
callq  7be <mu_address_set_domain+0x18>
mov    %rax,%rbx
mov    $0x1028,%eax
test   %rbx,%rbx
je     7f6 <mu_address_set_domain+0x50>
mov    %rbp,%rdi
callq  7d3 <mu_address_set_domain+0x2d>
mov    %rax,%rbp
test   %rax,%rax
jne    7e4 <mu_address_set_domain+0x3e>
callq  7e0 <mu_address_set_domain+0x3a>
mov    (%rax),%eax
jmp    7f6 <mu_address_set_domain+0x50>
mov    0x28(%rbx),%rdi
callq  7ed <mu_address_set_domain+0x47>
mov    %rbp,0x28(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
mu_address_set_domain (mu_address_t addr, size_t no, const char *buf) { char *s; mu_address_t subaddr; if (addr == ((void *)0)) return 22; subaddr = _address_get_nth (addr, no); if (!subaddr) return (0x1000 +40); s = strdup (buf); if (!s) return (*__errno_location ()); free (subaddr->domain); subaddr->domain = s; return 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  134 <process_all_hex_escapes>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swlib_process_hex_escapes(char * s1)
{
 process_all_hex_escapes(s1);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rax
mov    0x10(%rax),%edx
cmp    $0x1,%edx
je     10ec <destroy_prog+0x16>
cmp    $0x2,%edx
je     1110 <destroy_prog+0x3a>
jmp    1119 <destroy_prog+0x43>
mov    0x30(%rax),%rdx
cmp    %rax,0x48(%rdx)
jne    1100 <destroy_prog+0x2a>
movq   $0x0,0x48(%rdx)
jmp    1119 <destroy_prog+0x43>
cmp    %rax,0x50(%rdx)
jne    1119 <destroy_prog+0x43>
movq   $0x0,0x50(%rdx)
jmp    1119 <destroy_prog+0x43>
mov    0x30(%rax),%rdi
callq  1119 <destroy_prog+0x43>
mov    (%rbx),%rdi
callq  1121 <destroy_prog+0x4b>
mov    (%rbx),%rdi
callq  1129 <destroy_prog+0x53>
movq   $0x0,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
destroy_prog (struct prog **pp)
{
  struct prog *p = *pp;
  switch (p->type)
    {
    case TYPE_COMPONENT:
      break;
    case TYPE_REDIRECTOR:
      {
 struct prog *master = p->v.r.master;
 if (p == master->v.p.redir[0])
   master->v.p.redir[0] = ((void *)0);
 else if (p == master->v.p.redir[1])
   master->v.p.redir[1] = ((void *)0);
      }
      break;
    case TYPE_COMMAND:
      free (p->v.c.command);
    }
  unlink_prog (*pp);
  free (*pp);
  *pp = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 10
11 11
12 11
13 12
14 12
15 13
16 13
17 14
18 14
19 18
20 18
21 20
22 20
23 21
24 21
25 22
26 23
27 23
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_pow_2(const double x) { return x*x; }
<<<sep_in_sample>>>
1 1
2 1
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     56 <__gmp_asprintf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  87 <__gmp_asprintf+0x87>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_asprintf (char **result, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  ret = __gmp_vasprintf (result, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 9
25 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xalloc+0x9>
test   %rax,%rax
jne    2e <xalloc+0x2e>
mov    0x0(%rip),%rcx        # 15 <xalloc+0x15>
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  29 <xalloc+0x29>
callq  2e <xalloc+0x2e>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xalloc(size_t size)
{
  void *p = malloc(size);
  if (!p)
    {
      fprintf(stderr, "Virtual memory exhausted.\n");
      abort();
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 7
11 10
12 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%ecx
callq  5d <_osip_message_to_str>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_message_to_str_sipfrag (osip_message_t * sip, char **dest, size_t * message_length)
{
  return _osip_message_to_str (sip, dest, message_length, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xconcatenated_filename+0x9>
test   %rax,%rax
jne    13 <xconcatenated_filename+0x13>
callq  13 <xconcatenated_filename+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xconcatenated_filename (const char *directory, const char *filename,
                        const char *suffix)
{
  char *result;
  result = concatenated_filename (directory, filename, suffix);
  if (result == ((void *)0))
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 7
6 9
7 9
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1112 <gsl_vector_int_isnull+0x37>
shl    $0x2,%rsi
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm2
cvtsi2sdl (%rax),%xmm0
ucomisd %xmm1,%xmm0
jp     110c <gsl_vector_int_isnull+0x31>
ucomisd %xmm2,%xmm0
je     111e <gsl_vector_int_isnull+0x43>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
jne    10fc <gsl_vector_int_isnull+0x21>
jmp    1118 <gsl_vector_int_isnull+0x3d>
<<<sep_in_sample>>>
gsl_vector_int_isnull (const gsl_vector_int * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 13
16 13
17 17
18 17
19 17
20 17
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6d <_gsasl_step64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_client_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  5bb <parse_opt_set_point_to_point+0x9>
mov    $0x0,%edx
mov    $0x10,%esi
mov    %rbx,%rdi
callq  5cd <parse_opt_set_point_to_point+0x1b>
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_opt_set_point_to_point (struct ifconfig *ifp, char *addr)
{
  parse_opt_set_dstaddr (ifp, addr);
  parse_opt_set_flag (ifp, IFF_POINTOPOINT, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r15
mov    %rdx,%rbx
mov    %rcx,%r12
movzwl %di,%edi
callq  a91 <makerequest+0x1f>
mov    %ax,(%rbx)
lea    0x2(%rbx),%r13
mov    $0xffffffffffffffff,%rbp
mov    %r15,%rdi
mov    %rbp,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rcx,%rbp,1),%r14
mov    $0x1f6,%edx
mov    %r15,%rsi
mov    %r13,%rdi
callq  ac3 <makerequest+0x51>
cmp    $0x1f6,%r14
mov    $0x1f6,%eax
cmova  %rax,%r14
add    %r14,%r13
lea    0x1(%r13),%r15
movb   $0x0,0x0(%r13)
mov    %r12,%rsi
mov    %r15,%rdi
callq  aea <makerequest+0x78>
mov    %r12,%rdi
mov    %rbp,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%r15,%rcx,1),%rax
movb   $0x0,(%rax)
add    $0x1,%rax
sub    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
makerequest (int request, const char *name, struct tftphdr *tp,
      const char *mode)
{
  register char *cp;
  size_t arglen, len;
  tp->th_opcode = htons ((unsigned short) request);
  cp = (char *) &(tp->th_u1.tu_stuff);
  len = 512 +4 - sizeof (struct tftphdr) - sizeof ("netascii");
  arglen = strlen (name);
  strncpy (cp, name, len);
  cp += (arglen < len) ? arglen : len;
  *cp++ = '\0';
  strcpy (cp, mode);
  cp += strlen (mode);
  *cp++ = '\0';
  return cp - (char *) tp;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 6
12 6
13 6
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 11
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 13
35 14
36 14
37 14
38 14
39 14
40 14
41 15
42 15
43 16
44 17
45 17
46 17
47 17
48 17
49 17
50 17
51 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  12a1 <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     130 <encoding_hash_2+0x2e>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    111 <encoding_hash_2+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
encoding_hash_2 (struct encoding * entry)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((entry->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3fdd <_jit_new_node_pw+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_jit_new_node_pw(jit_state_t *_jit, jit_code_t code,
   jit_pointer_t u, jit_word_t v)
{
    return (_jit_new_node_ww(_jit,code,(jit_word_t)u,v));
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x88(%rdi),%rsi
mov    %rsi,%rdx
mov    (%rdi),%rdi
callq  53d <mv_begin_read+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mv_begin_read (struct tar_stat_info *st)
{
  mv_begin_write (st->orig_file_name, st->stat.st_size, st->stat.st_size);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0xa0,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
mov    %rsp,%rdi
callq  ae9 <md5_buffer+0x1c>
mov    %rsp,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  af7 <md5_buffer+0x2a>
mov    %rbx,%rsi
mov    %rsp,%rdi
callq  b02 <md5_buffer+0x35>
add    $0xa0,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
md5_buffer (const char *buffer, size_t len, void *resblock)
{
  struct md5_ctx ctx;
  md5_init_ctx (&ctx);
  md5_process_bytes (buffer, len, &ctx);
  return md5_finish_ctx (&ctx, resblock);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
push   %rbx
movslq (%rdi),%rbx
movl   $0x0,0x0(,%rbx,4)
mov    $0x0,%esi
callq  2b <select_mk82+0x19>
mov    %eax,0x0(,%rbx,4)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
select_mk82( craft * c )
{
 hasFired[c->pIndex] = 0;
 count[c->pIndex] = countOrdinance(c, "mk82");
 return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%r12
jmp    535 <linecmp+0x18>
add    $0x1,%r13
add    $0x1,%r12
movzbl 0x0(%r13),%ebp
movsbl %bpl,%edi
callq  543 <linecmp+0x26>
mov    %eax,%r14d
movzbl (%r12),%ebx
movsbl %bl,%edi
callq  553 <linecmp+0x36>
cmp    %eax,%r14d
jne    574 <linecmp+0x57>
test   %bpl,%bpl
je     584 <linecmp+0x67>
test   %bl,%bl
nop
je     574 <linecmp+0x57>
cmp    $0xa,%bpl
je     584 <linecmp+0x67>
cmp    $0xa,%bl
jne    52d <linecmp+0x10>
mov    $0x1,%eax
jmp    594 <linecmp+0x77>
cmp    $0xa,%bpl
je     584 <linecmp+0x67>
mov    $0x1,%eax
test   %bpl,%bpl
jne    594 <linecmp+0x77>
cmp    $0xa,%bl
setne  %al
test   %bl,%bl
setne  %dl
movzbl %dl,%edx
and    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
linecmp(char *l1, char *l2)
{
  while (lower(*l1) == lower(*l2) &&
  *l1 && *l2 && *l1 != '\n' && *l2 != '\n')
    {
      l1++;
      l2++;
    }
  return (*l1 && *l1 != '\n') || (*l2 && *l2 != '\n');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 7
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 10
43 10
44 10
45 10
46 10
47 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rsi,%rbx
mov    %rcx,%rsi
mov    0x28(%rsp),%rdx
mov    $0x0,%edi
mov    $0x4,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %r8b
setb   %cl
mov    $0x0,%eax
cmp    %cl,%r8b
jne    90 <ahc_echo+0x90>
cmpq   $0x0,(%rdx)
je     45 <ahc_echo+0x45>
movq   $0x0,(%rdx)
mov    $0x1,%al
jmp    90 <ahc_echo+0x90>
movq   $0x0,(%rdx)
mov    %r9,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdi
mov    $0x0,%edx
mov    %r9,%rsi
callq  71 <ahc_echo+0x71>
mov    %rax,%rbp
mov    %rax,%rdx
mov    $0xc8,%esi
mov    %rbx,%rdi
callq  84 <ahc_echo+0x84>
mov    %eax,%ebx
mov    %rbp,%rdi
callq  8e <ahc_echo+0x8e>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ahc_echo (void *cls,
          struct MHD_Connection *connection,
          const char *url,
          const char *method,
          const char *version,
          const char *upload_data, size_t *upload_data_size, void **ptr)
{
  static int aptr;
  const char *me = cls;
  struct MHD_Response *response;
  int ret;
  if (0 != strcmp (method, "GET"))
    return 0;
  if (&aptr != *ptr)
    {
      *ptr = &aptr;
      return 1;
    }
  *ptr = ((void *)0);
  response = MHD_create_response_from_buffer (strlen (me),
           (void *) me,
           MHD_RESPMEM_PERSISTENT);
  ret = MHD_queue_response (connection, 200, response);
  MHD_destroy_response (response);
  return ret;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 12
9 12
10 12
11 12
12 12
13 13
14 12
15 12
16 14
17 14
18 16
19 17
20 17
21 19
22 20
23 20
24 20
25 20
26 20
27 20
28 20
29 20
30 20
31 20
32 23
33 23
34 23
35 23
36 23
37 24
38 24
39 25
40 26
41 26
42 26
43 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
lea    0x1(%rsi),%rdi
callq  13 <stndup+0x13>
mov    %rax,%rbx
test   %rax,%rax
je     2d <stndup+0x2d>
movb   $0x0,(%rax,%rbp,1)
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  2d <stndup+0x2d>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
stndup (const char *str, size_t n)
{
  char *tmp;
  if (((void *)0) == (tmp = malloc (n + 1)))
    return ((void *)0);
  tmp[n] = '\0';
  memcpy (tmp, str, n);
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 6
12 7
13 7
14 7
15 7
16 9
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  5d00 <iopflags2str+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
iopflags2str(int flag)
{
 static const struct flagtab values[] = {
  { 1, "IOP_IS_TTY" },
  { 2, "IOP_AT_EOF" },
  { 4, "IOP_CLOSED" },
  { 8, "IOP_AT_START" },
  { 0, ((void *)0) }
 };
 return genflags2str(flag, values);
}
<<<sep_in_sample>>>
1 2
2 10
3 10
4 11
5 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%esi
callq  2b72 <create_pidfile+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    2bb5 <create_pidfile+0x56>
callq  2b7f <create_pidfile+0x20>
mov    (%rax),%edi
callq  2b86 <create_pidfile+0x27>
mov    %rax,%rbx
mov    $0x0,%edi
callq  2b93 <create_pidfile+0x34>
mov    %rbx,%rcx
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x3,%edi
mov    $0x0,%eax
callq  2bab <create_pidfile+0x4c>
mov    $0x4b,%edi
callq  2bb5 <create_pidfile+0x56>
callq  2bba <create_pidfile+0x5b>
movslq %eax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  2bcf <create_pidfile+0x70>
mov    %rbx,%rdi
callq  2bd7 <create_pidfile+0x78>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
create_pidfile (char *name)
{
  FILE *fp = fopen (name, "w");
  if (!fp)
    {
      logmsg (3, gettext("cannot create pidfile `%s': %s"),
       name, strerror ((*__errno_location ())));
      exit (75);
    }
  fprintf (fp, "%lu", (unsigned long) getpid ());
  fclose (fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 7
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 8
23 8
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 12
33 12
34 12
35 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x188,%esi
mov    $0x1,%edi
callq  49 <cdio_new+0x1b>
test   %rax,%rax
je     6b <cdio_new+0x3d>
mov    %rbx,0x180(%rax)
lea    0x8(%rax),%rdi
mov    $0x2f,%ecx
mov    %rbp,%rsi
rep movsq %ds:(%rsi),%es:(%rdi)
mov    %rax,0x1020(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cdio_new (generic_img_private_t *p_env, cdio_funcs_t *p_funcs)
{
  CdIo_t *p_new_cdio = calloc(1, sizeof (CdIo_t));
  if (((void *)0) == p_new_cdio) return ((void *)0);
  p_new_cdio->env = p_env;
  p_new_cdio->op = *p_funcs;
  p_env->cdio = p_new_cdio;
  return p_new_cdio;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 6
13 6
14 6
15 6
16 7
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
cmpl   $0x0,0x0(%rip)        # 1a56 <find_variable_noref+0x10>
jne    1a73 <find_variable_noref+0x2d>
mov    $0x1,%sil
cmpl   $0x0,0x0(%rip)        # 1a62 <find_variable_noref+0x1c>
jne    1a73 <find_variable_noref+0x2d>
cmpl   $0x0,0x0(%rip)        # 1a6b <find_variable_noref+0x25>
setne  %sil
movzbl %sil,%esi
callq  126a <find_variable_internal>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_variable_noref (name)
     const char *name;
{
  SHELL_VAR *v;
  int flags;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= 0x01;
  v = find_variable_internal (name, flags);
  return v;
}
<<<sep_in_sample>>>
1 3
2 6
3 7
4 7
5 8
6 7
7 7
8 7
9 7
10 7
11 9
12 11
13 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # 99 <nettle_gcm_aes128_encrypt+0x26>
mov    %rax,%rsi
callq  a1 <nettle_gcm_aes128_encrypt+0x2e>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes128_encrypt(struct gcm_aes128_ctx *ctx,
  size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes128_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_encrypt(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rdi,%rdi
je     1b3d <print_code+0x2d>
movzbl 0x8(%rbp),%ecx
mov    0x10(%rbp),%rdx
mov    0x0(%rbp),%rsi
mov    %rbx,%rdi
callq  12eb <print_instruction>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    1b21 <print_code+0x11>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
print_code(INSTRUCTION *pc, void *x)
{
 struct pf_data *data = (struct pf_data *) x;
 for (; pc != ((void *)0); pc = pc->nexti)
  print_instruction(pc, data->print_func, data->fp, data->defn );
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 7
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%r9        # 156 <pict_newstr+0xb>
mov    0x0(%rip),%r8d        # 15d <pict_newstr+0x12>
movslq %r8d,%rax
add    %r9,%rax
test   %rdi,%rdi
je     1d6 <pict_newstr+0x8b>
movzbl (%rdi),%ecx
test   %cl,%cl
jne    1c8 <pict_newstr+0x7d>
jmp    1d6 <pict_newstr+0x8b>
cmp    %edx,0x0(%rip)        # 177 <pict_newstr+0x2c>
jle    19d <pict_newstr+0x52>
mov    %edx,%esi
lea    0x1(%rsi),%edx
movslq %esi,%rsi
mov    %cl,(%r9,%rsi,1)
mov    %edx,%ecx
sub    %r8d,%ecx
movslq %ecx,%rcx
movzbl (%rdi,%rcx,1),%ecx
test   %cl,%cl
jne    171 <pict_newstr+0x26>
mov    %edx,0x0(%rip)        # 19b <pict_newstr+0x50>
jmp    1d6 <pict_newstr+0x8b>
mov    %edx,0x0(%rip)        # 1a3 <pict_newstr+0x58>
mov    0x0(%rip),%rcx        # 1aa <pict_newstr+0x5f>
mov    $0x23,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1be <pict_newstr+0x73>
mov    $0x1,%edi
callq  1c8 <pict_newstr+0x7d>
cmp    0x0(%rip),%r8d        # 1cf <pict_newstr+0x84>
jge    1a3 <pict_newstr+0x58>
mov    %r8d,%esi
jmp    17b <pict_newstr+0x30>
mov    0x0(%rip),%edx        # 1dc <pict_newstr+0x91>
lea    0x1(%rdx),%ecx
mov    %ecx,0x0(%rip)        # 1e5 <pict_newstr+0x9a>
movslq %edx,%rdx
movb   $0x0,(%r9,%rdx,1)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pict_newstr(char *str)
{
  int s;
  char *s0;
  s0 = charbuf + charnext;
  if (str)
    {
      for (s = 0; str[s]; s++)
 {
   if (charnext < dap_maxchar)
     charbuf[charnext++] = str[s];
   else
     {
       fputs("(pict_newstr) Too many characters.\n", dap_err);
       exit(1);
     }
 }
    }
  charbuf[charnext++] = '\0';
  return s0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 8
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 11
17 11
18 11
19 11
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 14
28 14
29 14
30 14
31 14
32 15
33 15
34 10
35 10
36 10
37 10
38 19
39 19
40 19
41 19
42 19
43 21
44 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %esi,%edx
mov    0x0(%rip),%rcx        # 1ef <db_generator+0x10>
mov    0xa8(%rcx),%rdi
mov    %rax,%rsi
callq  14c <result_generator>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
db_generator(const char *text, int state)
{
    return result_generator(conn->db_result, text, state);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%rax
mov    (%rsi),%rbx
cmp    (%rdi),%rbx
jne    32e6 <gsl_matrix_ushort_mul_elements+0x1d>
mov    0x8(%rsi),%r10
cmp    %rax,%r10
je     3306 <gsl_matrix_ushort_mul_elements+0x3d>
mov    $0x13,%ecx
mov    $0x56,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  32ff <gsl_matrix_ushort_mul_elements+0x36>
mov    $0x13,%eax
jmp    3383 <gsl_matrix_ushort_mul_elements+0xba>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r13
test   %rbx,%rbx
je     3377 <gsl_matrix_ushort_mul_elements+0xae>
lea    (%rax,%rax,1),%r14
sub    %rax,%r13
add    %r13,%r13
mov    $0x0,%r11d
mov    $0x0,%r12d
mov    $0x0,%ebp
jmp    3368 <gsl_matrix_ushort_mul_elements+0x9f>
mov    %rax,%rcx
add    0x18(%rdi),%rcx
mov    %rax,%r9
add    0x18(%rsi),%r9
movzwl (%rcx),%r8d
imul   (%r9,%r11,1),%r8w
mov    %r8w,(%rcx)
add    $0x1,%rdx
add    $0x2,%rax
cmp    %r10,%rdx
jne    3330 <gsl_matrix_ushort_mul_elements+0x67>
add    $0x1,%rbp
add    %r14,%r12
add    %r13,%r11
cmp    %rbx,%rbp
je     337e <gsl_matrix_ushort_mul_elements+0xb5>
test   %r10,%r10
je     3359 <gsl_matrix_ushort_mul_elements+0x90>
mov    %r12,%rax
mov    $0x0,%edx
jmp    3330 <gsl_matrix_ushort_mul_elements+0x67>
mov    $0x0,%eax
jmp    3383 <gsl_matrix_ushort_mul_elements+0xba>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_mul_elements (gsl_matrix_ushort * a, const gsl_matrix_ushort * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 86, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
37 18
38 16
39 16
40 16
41 16
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
52 21
53 21
54 21
55 23
56 23
57 23
58 23
59 23
60 23
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # f4c <days_of_february+0x7>
mov    (%rdx),%eax
cmp    %edi,%eax
jl     f75 <days_of_february+0x30>
cmp    %edi,%eax
jne    102f <days_of_february+0xea>
mov    0x4(%rdx),%eax
cmp    $0x1,%eax
je     f75 <days_of_february+0x30>
cmp    $0x2,%eax
jne    102f <days_of_february+0xea>
cmpl   $0x1b,0xc(%rdx)
jle    102f <days_of_february+0xea>
cmpl   $0x0,0x0(%rip)        # f7c <days_of_february+0x37>
je     fdc <days_of_february+0x97>
mov    $0x1c,%eax
test   $0x3,%dil
jne    103e <days_of_february+0xf9>
mov    $0x51eb851f,%edx
mov    %edi,%eax
imul   %edx
sar    $0x5,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
imul   $0x64,%edx,%edx
mov    $0x1d,%eax
cmp    %edx,%edi
jne    103e <days_of_february+0xf9>
mov    $0x38e38e39,%edx
mov    %edi,%eax
imul   %edx
sar    %edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,8),%eax
mov    %edi,%ecx
sub    %eax,%ecx
mov    %ecx,%eax
and    $0xfffffffb,%eax
cmp    $0x2,%eax
sete   %al
movzbl %al,%eax
add    $0x1c,%eax
jmp    103e <days_of_february+0xf9>
mov    $0x1c,%eax
test   $0x3,%dil
jne    103e <days_of_february+0xf9>
mov    $0x51eb851f,%edx
mov    %edi,%eax
imul   %edx
sar    $0x5,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
imul   $0x64,%edx,%edx
mov    $0x1d,%eax
cmp    %edx,%edi
jne    103e <days_of_february+0xf9>
mov    $0x51eb851f,%edx
mov    %edi,%eax
imul   %edx
sar    $0x7,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
imul   $0x190,%edx,%edx
mov    %edi,%eax
sub    %edx,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
not    %eax
add    $0x1d,%eax
jmp    103e <days_of_february+0xf9>
mov    %edi,%eax
and    $0x3,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
not    %eax
add    $0x1d,%eax
cmp    $0x4,%edi
sete   %dl
movzbl %dl,%edx
sub    %edx,%eax
retq   
<<<sep_in_sample>>>
days_of_february (year)
     const int year;
{
  register int day;
  if ((year > greg->year)
      || ((year == greg->year)
   && (greg->month == 1
       || ((greg->month == 2) && (greg->last_day >= 28)))))
    {
      if (orthodox_calendar)
 day =
   (year & 3) ? 28 : ((!(year % 100))
        ? (((year % 9) == 2
     || (year % 9) == 6) ? 29 : 28) : 29);
      else
 day = (year & 3) ? 28 : ((!(year % 100) && (year % 400)) ? 28 : 29);
    }
  else
    day = (year & 3) ? 28 : 29;
  if (year == 4)
    day--;
  return (day);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 6
6 6
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 14
28 14
29 14
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 14
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 16
66 16
67 16
68 16
69 16
70 16
71 16
72 16
73 16
74 16
75 16
76 19
77 19
78 19
79 19
80 19
81 19
82 21
83 21
84 21
85 21
86 23
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     946 <strbuf_sprintf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
callq  977 <strbuf_sprintf+0x87>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
strbuf_sprintf(STRBUF *sb, const char *s, ...)
{
 va_list ap;
 __builtin_va_start(ap,s);
 strbuf_vsprintf(sb, s, ap);
 __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 4
18 4
19 4
20 4
21 4
22 5
23 5
24 7
25 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  39d <sh_invalidoptname+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  3ad <sh_invalidoptname+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_invalidoptname (s)
     char *s;
{
  builtin_error (gettext("%s: invalid option name"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rdi        # 277 <datadef_lookup+0x10>
test   %rdi,%rdi
je     29b <datadef_lookup+0x34>
mov    $0x0,%ebx
mov    %rbp,%rsi
callq  289 <datadef_lookup+0x22>
test   %eax,%eax
je     2a2 <datadef_lookup+0x3b>
add    $0x20,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    281 <datadef_lookup+0x1a>
jmp    2a7 <datadef_lookup+0x40>
mov    $0x0,%eax
jmp    2ac <datadef_lookup+0x45>
mov    %rbx,%rax
jmp    2ac <datadef_lookup+0x45>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
datadef_lookup (const char *name)
{
  struct datadef *p;
  for (p = datatab; p->name; p++)
    if (strcmp (p->name, name) == 0)
      return p;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 4
17 4
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     c9b <gsl_vector_long_double_add+0x29>
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c94 <gsl_vector_long_double_add+0x22>
mov    $0x13,%eax
jmp    cf3 <gsl_vector_long_double_add+0x81>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     ce7 <gsl_vector_long_double_add+0x75>
shl    $0x4,%rbx
shl    $0x4,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
fldt   (%r8)
fldt   (%r9,%rcx,1)
faddp  %st,%st(1)
fstpt  (%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    cbf <gsl_vector_long_double_add+0x4d>
jmp    cee <gsl_vector_long_double_add+0x7c>
mov    $0x0,%eax
jmp    cf3 <gsl_vector_long_double_add+0x81>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_long_double_add (gsl_vector_long_double * a, const gsl_vector_long_double * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 13
29 13
30 13
31 13
32 13
33 13
34 17
35 17
36 17
37 19
38 19
<<<sep_out_sample>>>
mov    0xe0(%rdi),%eax
retq   
<<<sep_in_sample>>>
nettle_yarrow256_is_seeded(struct yarrow256_ctx *ctx)
{
  return ctx->seeded;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     2e <mu_pop3_get_timeout+0x1d>
mov    $0x1005,%ax
test   %rsi,%rsi
je     2e <mu_pop3_get_timeout+0x1d>
mov    0x50(%rdi),%eax
mov    %eax,(%rsi)
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
mu_pop3_get_timeout (mu_pop3_t pop3, int *ptimeout)
{
  if (pop3 == ((void *)0))
    return 22;
  if (ptimeout == ((void *)0))
    return (0x1000 +5);
  *ptimeout = pop3->timeout;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 5
6 5
7 7
8 7
9 8
10 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
callq  b5 <compare+0x11>
test   %eax,%eax
jne    d0 <compare+0x2c>
mov    0x48(%rbp),%rcx
mov    0x48(%rbx),%rdx
mov    $0x1,%al
cmp    %rdx,%rcx
jg     d0 <compare+0x2c>
setl   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
compare(const void *p1, const void *p2)
{
  int r;
  r = strcmp(((function_entry *)p1)->name,((function_entry *)p2)->name);
  if (r == 0)
    {
      if (((function_entry *)p1)->name_start_char > ((function_entry *)p2)->name_start_char)
 r = 1;
      else
 if (((function_entry *)p1)->name_start_char < ((function_entry *)p2)->name_start_char)
   r = -1;
 else
   r = 0;
    }
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 7
10 7
11 8
12 7
13 7
14 10
15 10
16 10
17 16
18 16
19 16
20 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rbx        # e4a <prog_lookup_by_tag+0x10>
test   %rbx,%rbx
je     e67 <prog_lookup_by_tag+0x2d>
mov    0x18(%rbx),%rdi
mov    %rbp,%rsi
callq  e5b <prog_lookup_by_tag+0x21>
test   %eax,%eax
je     e67 <prog_lookup_by_tag+0x2d>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    e4f <prog_lookup_by_tag+0x15>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
prog_lookup_by_tag (const char *tag)
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (strcmp (prog->tag, tag) == 0)
      break;
  return prog;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 8
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
movl   $0xffffffff,0x0(%rip)        # 1e <color_cap_rv_fct+0xa>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
color_cap_rv_fct(void)
{
  color_option = -1;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %dil,0xf(%rsp)
mov    $0x1,%edx
lea    0xf(%rsp),%rsi
mov    0x0(%rip),%rdi        # 4f <grecs_line_acc_grow_char+0x1a>
callq  54 <grecs_line_acc_grow_char+0x1f>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_line_acc_grow_char(int c)
{
 char t = c;
 grecs_txtacc_grow(line_acc, &t, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %ecx,%r8d
cmp    %ecx,%edx
jne    12c4 <_sse_buneqr_d+0x16>
callq  942 <_jmpi>
jmp    12e5 <_sse_buneqr_d+0x37>
mov    %edx,%ecx
mov    $0x2e,%edx
mov    $0x66,%esi
callq  9d0 <_ssexr>
mov    %rbp,%rdx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  876 <_jcc>
mov    (%rbx),%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_sse_buneqr_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_int32_t r1)
{
    if (r0 == r1)
 _jmpi(_jit, i0);
    else {
 _ssexr(_jit,0x66,0x2e,r0,r1);
 _jcc(_jit, 0x4, i0);
    }
    return (_jit->pc.w);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 9
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 24 <scribble_deinit+0xd>
callq  29 <scribble_deinit+0x12>
test   %rbx,%rbx
je     43 <scribble_deinit+0x2c>
mov    (%rbx),%rbp
mov    %rbx,%rdi
callq  39 <scribble_deinit+0x22>
test   %rbp,%rbp
je     43 <scribble_deinit+0x2c>
mov    %rbp,%rbx
jmp    2e <scribble_deinit+0x17>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
scribble_deinit(void)
{
    scrib_buf_t * sb = bufs;
    scribble_init();
    while (sb != ((void *)0)) {
        scrib_buf_t * nxt = sb->sb_next;
        free(sb);
        sb = nxt;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 5
7 5
8 6
9 7
10 7
11 5
12 5
13 8
14 8
15 10
16 10
17 10
18 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2fe <mu_body_clear_modified+0xc>
andl   $0xfffeffff,0x20(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_body_clear_modified (mu_body_t body)
{
  if (body)
    body->flags &= ~0x10000;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x1,%edi
jne    8dc <ds_strategy+0x17>
mov    0x0(%rip),%rdi        # 8d5 <ds_strategy+0x10>
callq  8da <ds_strategy+0x15>
jmp    8ea <ds_strategy+0x25>
mov    0x8(%rsi),%rsi
mov    $0x0,%edi
callq  8ea <ds_strategy+0x25>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ds_strategy(int argc, char **argv)
{
    if (argc == 1) {
 printf("%s\n", dico_url.req.strategy);
    } else
 xdico_assign_string(&dico_url.req.strategy, argv[1]);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 6
8 6
9 6
10 7
11 7
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1b3d <gsl_matrix_int_isneg+0x55>
lea    0x0(,%rax,4),%r10
mov    $0x0,%esi
mov    $0x0,%r9d
xorpd  %xmm1,%xmm1
jmp    1b36 <gsl_matrix_int_isneg+0x4e>
mov    $0x0,%eax
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm1,%xmm0
jb     1b4f <gsl_matrix_int_isneg+0x67>
jmp    1b43 <gsl_matrix_int_isneg+0x5b>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     1b49 <gsl_matrix_int_isneg+0x61>
test   %rdx,%rdx
jne    1b11 <gsl_matrix_int_isneg+0x29>
jmp    1b2a <gsl_matrix_int_isneg+0x42>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rdx,%rax
jne    1b1d <gsl_matrix_int_isneg+0x35>
jmp    1b2a <gsl_matrix_int_isneg+0x42>
<<<sep_in_sample>>>
gsl_matrix_int_isneg (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 20
26 20
27 15
28 15
29 20
30 20
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  167d <gsl_sf_zetam1+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     16a3 <gsl_sf_zetam1+0x32>
mov    %eax,%ecx
mov    $0x40a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  169c <gsl_sf_zetam1+0x2b>
movsd  (%rsp),%xmm0
jmp    16a3 <gsl_sf_zetam1+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_zetam1(const double s)
{
  gsl_sf_result result; int status = gsl_sf_zetam1_e(s, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_zetam1_e(s, &result)", "zeta.c", 1034, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edx,%r12d
test   %edx,%edx
jle    18c <strbuf_nputc+0x46>
mov    %rdi,%rbx
mov    %esi,%ebp
movslq %edx,%rax
add    0x18(%rdi),%rax
cmp    %rax,0x10(%rdi)
jae    185 <strbuf_nputc+0x3f>
mov    %edx,%esi
callq  16a <strbuf_nputc+0x24>
jmp    185 <strbuf_nputc+0x3f>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rcx
mov    %rcx,0x18(%rbx)
mov    %bpl,(%rax)
sub    $0x1,%edx
cmp    $0xffffffff,%edx
jne    16c <strbuf_nputc+0x26>
jmp    18c <strbuf_nputc+0x46>
lea    -0x1(%r12),%edx
jmp    16c <strbuf_nputc+0x26>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
strbuf_nputc(STRBUF *sb, int c, int len)
{
 if (len > 0) {
  if (sb->curp + len > sb->endp)
   __strbuf_expandbuf(sb, len);
  while (len-- > 0)
   *sb->curp++ = c;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 6
21 6
22 6
23 6
24 6
25 6
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdi,0x0(%rip)        # 447 <prepare_record_buffer+0xb>
jae    466 <prepare_record_buffer+0x2a>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 453 <prepare_record_buffer+0x17>
callq  458 <prepare_record_buffer+0x1c>
mov    %rax,0x0(%rip)        # 45f <prepare_record_buffer+0x23>
mov    %rbx,0x0(%rip)        # 466 <prepare_record_buffer+0x2a>
pop    %rbx
retq   
<<<sep_in_sample>>>
prepare_record_buffer (size_t size)
{
  if (size > record_buffer_size)
    {
      record_buffer_ptr = xrealloc (record_buffer_ptr, size);
      record_buffer_size = size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 6
10 8
11 8
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x0,%eax
cmovne %rsi,%rax
retq   
<<<sep_in_sample>>>
xformat_get_header_buffer(XFORMAT * xux, char * buf)
{
     if (buf) {
         return buf;
     } else {
         static char a[512];
         return a;
     }
}
<<<sep_in_sample>>>
1 3
2 7
3 7
4 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
mov    $0x8913,%esi
mov    $0x0,%eax
callq  1329 <fh_flags_query+0x22>
test   %eax,%eax
js     1341 <fh_flags_query+0x3a>
mov    $0x0,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  133f <fh_flags_query+0x38>
jmp    1353 <fh_flags_query+0x4c>
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  1353 <fh_flags_query+0x4c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_flags_query (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x8913, form->ifr) >= 0)
    select_arg (form, argc, argv, 0);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
movsbl 0x0(%rip),%eax        # 709 <wordsplit_c_quote_char+0x7>
cmp    %edi,%eax
jne    722 <wordsplit_c_quote_char+0x20>
jmp    718 <wordsplit_c_quote_char+0x16>
movsbl (%rax),%edx
cmp    %edi,%edx
jne    727 <wordsplit_c_quote_char+0x25>
jmp    71d <wordsplit_c_quote_char+0x1b>
mov    $0x0,%eax
movsbl -0x1(%rax),%eax
retq   
mov    $0x0,%eax
sub    $0x2,%rax
cmp    $0x0,%rax
ja     70f <wordsplit_c_quote_char+0xd>
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
wordsplit_c_quote_char (int c)
{
  char *p;
  for (p = quote_transtab + sizeof (quote_transtab) - 2;
       p > quote_transtab; p -= 2)
    {
      if (*p == c)
 return p[-1];
    }
  return -1;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 4
10 8
11 8
12 4
13 5
14 4
15 4
16 10
17 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
cmp    $0xa,%edi
je     194 <unescape_to_line+0x4d>
callq  159 <unescape_to_line+0x12>
movsbl %al,%ebp
cmp    %ebx,%ebp
jne    186 <unescape_to_line+0x3f>
cmp    $0x5c,%al
je     186 <unescape_to_line+0x3f>
cmp    $0x22,%al
je     186 <unescape_to_line+0x3f>
mov    $0x0,%esi
mov    $0x0,%edi
callq  177 <unescape_to_line+0x30>
mov    %ebp,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  186 <unescape_to_line+0x3f>
mov    %ebp,%esi
mov    0x0(%rip),%rdi        # 18f <unescape_to_line+0x48>
callq  194 <unescape_to_line+0x4d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
unescape_to_line (int c)
{
  if (c != '\n')
    {
      char t = mu_argcv_unquote_char (c);
      if (t == c && t != '\\' && t != '\"')
 mu_cfg_parse_error (dgettext ("mailutils", "unknown escape sequence '\\%c'"), c);
      mu_opool_append_char (pool, t);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rsi),%rdx
mov    $0x0,%esi
callq  3f6 <strob_cpy+0x11>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
strob_cpy(STROB * s, STROB * ct)
{
 strob_strcpy_at_offset(s, 0, (char*)(ct->str_));
 return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <__rdunlock+0x9>
cmpb   $0x0,0x89(%rbx)
je     19 <__rdunlock+0x19>
movb   $0x0,0x89(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__rdunlock (__bs5FILE *p)
{
  char c;
  c = __rdcheckpoint (p);
  if (p->locked)
    {
      p->locked = 0;
    }
  return (c);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 10
8 10
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
retq   
<<<sep_in_sample>>>
ap_arguments( const struct Arg_parser * const ap )
  { return ap->data_size; }
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x45f,%r9d
mov    $0x461,%r8d
mov    $0x460,%ecx
callq  31 <doBuildFileList>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
buildOrigFileList(Header h, const char *** fileListPtr, int * fileCountPtr)
{
    doBuildFileList(h, fileListPtr, fileCountPtr, 1120,
   1121, 1119);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 5
7 5
<<<sep_out_sample>>>
sub    $0x28,%rsp
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 10 <gsl_log1p+0x10>
movsd  %xmm1,0x8(%rsp)
addsd  %xmm0,%xmm1
movsd  %xmm1,0x10(%rsp)
movsd  0x10(%rsp),%xmm1
movapd %xmm1,%xmm3
subsd  %xmm0,%xmm3
movsd  %xmm3,0x18(%rsp)
movsd  0x10(%rsp),%xmm0
callq  3f <gsl_log1p+0x3f>
movsd  0x18(%rsp),%xmm1
movsd  0x10(%rsp),%xmm2
subsd  0x8(%rsp),%xmm1
divsd  %xmm2,%xmm1
subsd  %xmm1,%xmm0
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_log1p (const double x)
{
  volatile double y, z;
  y = 1 + x;
  z = y - 1;
  return log(y) - (z-x)/y ;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 1d <__gmpz_init_set_ui+0x1d>
mov    %rax,0x8(%rbx)
mov    %rbp,(%rax)
test   %rbp,%rbp
setne  %al
movzbl %al,%eax
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmpz_init_set_ui (mpz_ptr dest, unsigned long int val)
{
  mp_size_t size;
    {
      ((dest)->_mp_alloc) = 1;
      ((dest)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
      size = val != 0;
    }
  ((dest)->_mp_d)[0] = val & ((~ ((mp_limb_t) (0))) >> 0);
  ((dest)->_mp_size) = size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 6
8 6
9 6
10 9
11 7
12 7
13 7
14 10
15 11
16 11
17 11
18 11
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  12c <gc_hash_close+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_hash_close (gc_hash_handle handle)
{
  _gc_hash_ctx *ctx = handle;
  free (ctx);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
movss  %xmm0,-0x4(%rsp)
movss  -0x4(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_coerce_float (const float x)
{
  volatile float y;
  y = x;
  return y;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
callq  3b9 <_rl_arg_callback+0xd>
mov    %eax,%ebx
test   %eax,%eax
js     40e <_rl_arg_callback+0x62>
mov    0x0(%rip),%eax        # 3c5 <_rl_arg_callback+0x19>
test   $0x4,%al
je     3f5 <_rl_arg_callback+0x49>
and    $0xfffffffb,%eax
mov    %eax,0x0(%rip)        # 3d2 <_rl_arg_callback+0x26>
callq  3d7 <_rl_arg_callback+0x2b>
callq  3dc <_rl_arg_callback+0x30>
andq   $0xfffffffffffffbff,0x0(%rip)        # 3e7 <_rl_arg_callback+0x3b>
mov    %ebx,%edi
callq  3ee <_rl_arg_callback+0x42>
mov    $0x0,%eax
jmp    413 <_rl_arg_callback+0x67>
mov    %ebx,%esi
mov    %ebp,%edi
mov    $0x0,%eax
callq  403 <_rl_arg_callback+0x57>
cmp    $0x1,%eax
setne  %al
movzbl %al,%eax
jmp    413 <_rl_arg_callback+0x67>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_rl_arg_callback (cxt)
     _rl_arg_cxt cxt;
{
  int c, r;
  c = _rl_arg_getchar ();
  if (c < 0)
    return (1);
  if (_rl_argcxt & 0x04)
    {
      _rl_argcxt &= ~0x04;
      rl_restore_prompt ();
      rl_clear_message ();
      (rl_readline_state &= ~(0x0000400));
      rl_execute_next (c);
      return 0;
    }
  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 6
8 6
9 8
10 8
11 8
12 10
13 10
14 11
15 12
16 13
17 14
18 14
19 15
20 15
21 17
22 17
23 17
24 17
25 18
26 18
27 18
28 18
29 7
30 19
31 19
32 19
33 19
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsasl_callback_hook_get (Gsasl * ctx)
{
  return ctx->application_hook;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  7a4 <yy_scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x20(%rdi)
jne    5c6 <alloc_multidata_if_needed+0x65>
mov    0x0(%rip),%rax        # 573 <alloc_multidata_if_needed+0x12>
mov    0x98(%rax),%rax
movslq 0x40(%rax),%rdi
add    %rdi,%rdi
callq  586 <alloc_multidata_if_needed+0x25>
mov    %rax,0x20(%rbx)
mov    0x0(%rip),%rax        # 591 <alloc_multidata_if_needed+0x30>
mov    0x98(%rax),%rax
cmpl   $0x0,0x40(%rax)
jle    5c6 <alloc_multidata_if_needed+0x65>
mov    $0x0,%eax
movslq %eax,%rcx
mov    0x20(%rbx),%rdx
movw   $0xffff,(%rdx,%rcx,2)
add    $0x1,%eax
mov    0x0(%rip),%rdx        # 5ba <alloc_multidata_if_needed+0x59>
mov    0x98(%rdx),%rdx
cmp    %eax,0x40(%rdx)
jg     5a3 <alloc_multidata_if_needed+0x42>
pop    %rbx
retq   
<<<sep_in_sample>>>
alloc_multidata_if_needed(filestruct *fileptr)
{
    int i;
    if (fileptr->multidata == ((void *)0)) {
 fileptr->multidata = (short *)nmalloc(openfile->syntax->nmultis * sizeof(short));
 for (i = 0; i < openfile->syntax->nmultis; i++)
     fileptr->multidata[i] = -1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 6
20 6
21 6
22 6
23 6
24 9
25 9
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    $0x0,%eax
cmp    $0xffffffffffffff78,%rcx
je     5f <rec_mset_elem_compare_fn+0x31>
sub    $0x8,%rsp
mov    %rsi,%rdx
movslq (%rdi),%rax
mov    0x8(%rsi),%rsi
mov    0x8(%rdi),%rdi
mov    (%rdx),%edx
callq  *0x88(%rcx,%rax,8)
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
rec_mset_elem_compare_fn (const void *e1,
                          const void *e2)
{
  int result = 0;
  rec_mset_elem_t elem1;
  rec_mset_elem_t elem2;
  elem1 = (rec_mset_elem_t) e1;
  elem2 = (rec_mset_elem_t) e2;
  if (elem1->mset->compare_fn)
    {
      result = (elem1->mset->compare_fn[elem1->type]) (elem1->data,
                                                       elem2->data,
                                                       elem2->type);
    }
  return result;
}
<<<sep_in_sample>>>
1 9
2 4
3 9
4 9
5 3
6 3
7 11
8 11
9 11
10 11
11 11
12 16
13 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    0x28(%rsi),%rax
add    0x28(%rdi),%rax
cmp    0x8(%rdi),%rax
jbe    6f4 <da_prefix+0x37>
add    $0x1,%rax
mov    %rax,0x8(%rdi)
lea    0x0(,%rax,8),%rsi
mov    0x30(%rdi),%rdi
callq  6f0 <da_prefix+0x33>
mov    %rax,0x30(%rbp)
mov    0x28(%rbp),%eax
sub    $0x1,%eax
js     717 <da_prefix+0x5a>
mov    0x30(%rbp),%rdx
movslq %eax,%rcx
mov    (%rdx,%rcx,8),%rsi
add    0x28(%rbx),%rcx
mov    %rsi,(%rdx,%rcx,8)
sub    $0x1,%eax
cmp    $0xffffffff,%eax
jne    6fc <da_prefix+0x3f>
mov    0x28(%rbx),%rdx
test   %edx,%edx
jle    742 <da_prefix+0x85>
mov    $0x0,%eax
movslq %eax,%rdx
mov    0x30(%rbx),%rcx
mov    (%rcx,%rdx,8),%rsi
mov    0x30(%rbp),%rcx
mov    %rsi,(%rcx,%rdx,8)
add    $0x1,%eax
mov    0x28(%rbx),%rdx
cmp    %edx,%eax
jl     724 <da_prefix+0x67>
add    %rdx,0x28(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
da_prefix (struct darray * arr, struct darray * arr2)
{
  int i;
  size_t len = arr->len + arr2->len;
  if (len > arr->size) {
    arr->size = len + 1;
    arr->content = ((void * *) xrealloc ((void *) (arr->content), sizeof (void *) * (arr->size)));
  }
  for (i = (int) arr->len - 1 ; i >= 0 ; i--)
    arr->content [ i + arr2->len ] = arr->content [ i ];
  for (i = 0 ; i < (int) arr2->len ; i++)
    arr->content [ i ] = arr2->content[ i ];
  arr->len += arr2->len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 7
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 9
25 9
26 9
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 12
36 11
37 11
38 11
39 11
40 13
41 14
42 14
43 14
44 14
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%r8
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
cmpl   $0x0,0x0(%rip)        # 392 <_rl_char_value+0x1f>
je     39d <_rl_char_value+0x2a>
movslq %esi,%rsi
movsbl (%rdi,%rsi,1),%eax
jmp    3fc <_rl_char_value+0x89>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
lea    -0x1(%rcx),%eax
cmp    %eax,%esi
jl     3c3 <_rl_char_value+0x50>
movslq %esi,%rsi
movsbl (%r8,%rsi,1),%eax
jmp    3fc <_rl_char_value+0x89>
movq   $0x0,0x10(%rsp)
movslq %esi,%rbx
add    %r8,%rbx
sub    %esi,%ecx
movslq %ecx,%rdx
lea    0x10(%rsp),%rcx
mov    %rbx,%rsi
lea    0xc(%rsp),%rdi
callq  3e9 <_rl_char_value+0x76>
sub    $0x1,%rax
cmp    $0xfffffffffffffffc,%rax
jbe    3f8 <_rl_char_value+0x85>
movsbl (%rbx),%eax
jmp    3fc <_rl_char_value+0x89>
mov    0xc(%rsp),%eax
mov    0x18(%rsp),%rdx
xor    %fs:0x28,%rdx
je     411 <_rl_char_value+0x9e>
callq  411 <_rl_char_value+0x9e>
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_char_value (buf, ind)
     char *buf;
     int ind;
{
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;
  if (16 == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (((tmp) == (size_t)-1 || (tmp) == (size_t)-2) || ((tmp) == 0))
    return ((wchar_t) buf[ind]);
  return wc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 9
8 9
9 10
10 10
11 10
12 11
13 11
14 11
15 11
16 11
17 12
18 12
19 12
20 13
21 13
22 13
23 14
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 16
33 16
34 16
35 17
36 17
37 18
38 19
39 19
40 19
41 19
42 19
43 19
44 19
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # d7b <current_history+0x6>
cmp    0x0(%rip),%eax        # d81 <current_history+0xc>
je     d96 <current_history+0x21>
mov    0x0(%rip),%rdx        # d8a <current_history+0x15>
test   %rdx,%rdx
je     d9c <current_history+0x27>
cltq   
mov    (%rdx,%rax,8),%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
current_history ()
{
  if ((history_offset == history_length) || !the_history)
    return ((HIST_ENTRY *)((void *)0));
  else
    return (the_history[history_offset]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 4
11 4
12 4
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
mov    (%rax),%r8
callq  0 <force_io>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
force_read(Stream_t *Stream, char *buf, mt_off_t start, size_t len)
{
 return force_io(Stream, buf, start, len,
     Stream->Class->read);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  19c2 <add_to_environment+0x12>
test   %rax,%rax
jne    19f1 <add_to_environment+0x41>
test   %rbp,%rbp
je     19e6 <add_to_environment+0x36>
mov    %rbp,%rdi
callq  19d4 <add_to_environment+0x24>
test   %rax,%rax
je     19e6 <add_to_environment+0x36>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  19e4 <add_to_environment+0x34>
jmp    19f1 <add_to_environment+0x41>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  19f1 <add_to_environment+0x41>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
add_to_environment(variable, alternate_variable, value)
    char *variable;
    char *alternate_variable;
    char *value;
{
    char *alternate_value;
    if (getenv(variable) == ((void *)0))
    {
 if (alternate_variable && (alternate_value=getenv(alternate_variable)))
     xsetenv(variable, alternate_value);
 else
     xsetenv(variable, value);
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 10
19 10
20 12
21 12
22 12
23 14
24 14
25 14
26 14
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
add    $0x4,%rax
cmp    $0x18,%rax
jne    4c <saveOldColors+0x5>
repz retq 
<<<sep_in_sample>>>
saveOldColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    oldFGColors[i] = FG_COLOR[i];
    oldBGColors[i] = BG_COLOR[i];
  }
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 7
6 7
7 4
8 4
9 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%edi
movl   $0x0,0x0(%rip)        # 10 <add_undo_close_redirect+0x10>
mov    $0x0,%ecx
mov    0x0(%rip),%rdx        # 1c <add_undo_close_redirect+0x1c>
mov    $0x9,%esi
callq  26 <add_undo_close_redirect+0x26>
orl    $0x8,0x14(%rax)
mov    0x0(%rip),%rdx        # 31 <add_undo_close_redirect+0x31>
mov    %rdx,(%rax)
mov    %rax,0x0(%rip)        # 3b <add_undo_close_redirect+0x3b>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
add_undo_close_redirect (fd)
     int fd;
{
  REDIRECT *closer;
  REDIRECTEE sd;
  sd.dest = fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= 0x08;
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 6
3 7
4 8
5 8
6 8
7 8
8 9
9 10
10 10
11 11
12 13
13 13
14 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,%edx
lea    0x8(%rsp),%rsi
callq  514 <il_history_view_entry+0x10>
test   %rax,%rax
je     520 <il_history_view_entry+0x1c>
mov    0x8(%rsp),%rax
jmp    525 <il_history_view_entry+0x21>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
il_history_view_entry(history, offset)
    xstack_t *history;
    int offset;
{
    char *history_text;
    return xstack_preview(history, &history_text, offset) ?
    history_text : ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 7
7 7
8 7
9 7
10 8
11 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r8
mov    (%r8),%rdi
test   %rbp,%rbp
je     154e <gsl_matrix_long_max_index+0x65>
shl    $0x3,%r12
mov    $0x0,%r10d
mov    $0x0,%r11d
mov    $0x0,%ebx
jmp    1542 <gsl_matrix_long_max_index+0x59>
mov    (%r8,%rax,8),%rcx
cmp    %rdi,%rcx
jle    152d <gsl_matrix_long_max_index+0x44>
mov    %rax,%r11
mov    %r10,%rbx
mov    %rcx,%rdi
add    $0x1,%rax
cmp    %r9,%rax
jne    151b <gsl_matrix_long_max_index+0x32>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
je     1559 <gsl_matrix_long_max_index+0x70>
test   %r9,%r9
je     1536 <gsl_matrix_long_max_index+0x4d>
mov    $0x0,%eax
jmp    151b <gsl_matrix_long_max_index+0x32>
mov    $0x0,%r11d
mov    $0x0,%ebx
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_matrix_long_max_index (const gsl_matrix_long * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 5
7 6
8 6
9 9
10 9
11 9
12 9
13 7
14 7
15 7
16 13
17 14
18 14
19 14
20 14
21 16
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 7
34 7
35 22
36 23
37 24
38 24
39 24
40 24
<<<sep_out_sample>>>
push   %rbx
mov    (%rdx),%rbx
test   %rbx,%rbx
je     2b <request_completed_callback+0x2b>
mov    (%rbx),%rax
test   %rax,%rax
je     15 <request_completed_callback+0x15>
subl   $0x1,0x2c(%rax)
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     23 <request_completed_callback+0x23>
callq  23 <request_completed_callback+0x23>
mov    %rbx,%rdi
callq  2b <request_completed_callback+0x2b>
pop    %rbx
retq   
<<<sep_in_sample>>>
request_completed_callback (void *cls,
       struct MHD_Connection *connection,
       void **con_cls,
       enum MHD_RequestTerminationCode toe)
{
  struct Request *request = *con_cls;
  if (((void *)0) == request)
    return;
  if (((void *)0) != request->session)
    request->session->rc--;
  if (((void *)0) != request->pp)
    MHD_destroy_post_processor (request->pp);
  free (request);
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 9
6 9
7 9
8 10
9 11
10 11
11 11
12 12
13 13
14 13
15 14
16 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    0x0(%rip),%rcx        # fb <nettle_gcm_aes192_digest+0x22>
mov    %rax,%rsi
callq  103 <nettle_gcm_aes192_digest+0x2a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes192_digest(struct gcm_aes192_ctx *ctx,
    size_t length, uint8_t *digest)
{
  (0 ? (nettle_aes192_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_digest(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes192_encrypt), (length), (digest)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %dil,%esi
mov    0x0(%rip),%rax        # b36 <isdecimal+0xf>
mov    (%rax),%rdi
callq  b3e <isdecimal+0x17>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
isdecimal(char c)
{
  return strchr(digits, c) != ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    0x10(%rdi),%ecx
mov    (%rdi),%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 19 <ParseError+0x19>
mov    $0x0,%eax
callq  23 <ParseError+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ParseError(p, s)
struct lex_record *p;
char *s;
{
 fprintf(stderr, "error in file %s (line %d):\n\t%s\n", p->name,
   p->lineno, s);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     165 <grecs_version_info_free+0x1f>
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     15d <grecs_version_info_free+0x17>
callq  15d <grecs_version_info_free+0x17>
mov    %rbx,%rdi
callq  165 <grecs_version_info_free+0x1f>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_version_info_free(struct grecs_version_info *pv)
{
 if (pv) {
  if (pv->buffer)
   grecs_free(pv->buffer);
  free(pv);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 8
12 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    $0x38,%edi
callq  176 <grecs_version+0xf>
mov    %rax,%rbx
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rax)
lea    0x30(%rax),%rdi
mov    $0x0,%r8d
mov    $0x1,%ecx
mov    $0x0,%edx
lea    0x8(%rsp),%rsi
mov    $0x0,%eax
callq  1ac <grecs_version+0x45>
mov    0x30(%rbx),%rax
mov    %rax,0x8(%rbx)
movl   $0x1,0x18(%rbx)
movl   $0x0,0x1c(%rbx)
movq   $0x0,0x10(%rbx)
mov    %rbx,%rax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_version(void)
{
 struct grecs_version_info *pv = grecs_zalloc(sizeof(*pv));
 size_t size = 0;
 pv->package = "GNU dico";
 grecs_asprintf(&pv->buffer, &size,
         "%d.%d",
         1, 0);
 pv->version = pv->buffer;
 pv->major = 1;
 pv->minor = 0;
 pv->id = "102d1b9c1a94548dfa0c498845c77933db6a7738-1470396055-gray@gnu.org.ua";
 return pv;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 9
16 9
17 10
18 11
19 12
20 14
21 14
22 14
23 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1af <iterator_first+0x1f>
mov    0x8(%rdi),%rax
mov    0x8(%rax),%rax
mov    %rax,0x10(%rdi)
movl   $0x0,0x18(%rdi)
callq  1ad <iterator_first+0x1d>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
iterator_first (ITERATOR ip)
{
  if (!ip)
    return ((void *)0);
  ip->cur = ip->list->head;
  ip->advanced = 0;
  return iterator_current (ip);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 7
8 7
9 4
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  34e <gc_hmac_sha1+0x9>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_hmac_sha1 (const void *key, size_t keylen,
              const void *in, size_t inlen, char *resbuf)
{
  hmac_sha1 (key, keylen, in, inlen, resbuf);
  return GC_OK;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
test   %rdx,%rdx
je     9e <compute_long_double_factor+0x36>
shl    $0x4,%rsi
mov    $0x0,%eax
fldz   
fld    %st(0)
fld    %st(1)
fldt   (%rdi)
fucomi %st(1),%st
jbe    8a <compute_long_double_factor+0x22>
fadd   %st,%st(3)
fmul   %st(0),%st
faddp  %st,%st(2)
jmp    8c <compute_long_double_factor+0x24>
fstp   %st(0)
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
jne    7c <compute_long_double_factor+0x14>
fstp   %st(0)
fxch   %st(1)
jmp    a2 <compute_long_double_factor+0x3a>
fldz   
fld    %st(0)
fmul   %st(0),%st
fsub   %st,%st(1)
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
compute_long_double_factor (const long double w[], const size_t wstride, const size_t n)
{
  long double a = 0 ;
  long double b = 0;
  long double factor;
  size_t i;
  for (i = 0; i < n; i++)
    {
      long double wi = w[i * wstride];
      if (wi > 0)
        {
          a += wi ;
          b += wi * wi ;
        }
    }
  factor = (a*a) / ((a*a) - b);
  return factor ;
}
<<<sep_in_sample>>>
1 7
2 7
3 9
4 7
5 4
6 4
7 10
8 9
9 10
10 10
11 12
12 13
13 13
14 13
15 13
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 4
24 4
25 16
26 16
27 16
28 17
29 17
30 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
mov    $0x0,%eax
callq  fbf <write_fatal>
<<<sep_in_sample>>>
read_fatal (void)
{
  pfatal ("read error");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
sub    $0x1,%rcx
mov    (%rsi),%rdx
sub    $0x1,%rdx
add    $0x1,%rcx
movzbl (%rcx),%eax
test   %al,%al
jne    233 <font_info_hash_cmp+0x1f>
add    $0x1,%rdx
jmp    23b <font_info_hash_cmp+0x27>
add    $0x1,%rdx
cmp    (%rdx),%al
je     222 <font_info_hash_cmp+0xe>
movzbl %al,%eax
movzbl (%rdx),%edx
sub    %edx,%eax
retq   
<<<sep_in_sample>>>
font_info_hash_cmp (struct font_info *x, struct font_info *y)
{
  do { int result; do { unsigned char const *xx = (unsigned char const *) (x->key) - 1; unsigned char const *yy = (unsigned char const *) (y->key) - 1; do { if (*++xx == '\0') { yy++; break; } } while (*xx == *++yy); (result) = *xx - *yy; } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x20(%rdi),%rdi
callq  8ae <tsqr_reset+0xd>
mov    0x28(%rbx),%rdi
callq  8b7 <tsqr_reset+0x16>
movl   $0x0,0x8(%rbx)
movl   $0x0,0xc(%rbx)
movq   $0x0,0x10(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
tsqr_reset(void *vstate)
{
  tsqr_state_t *state = (tsqr_state_t *) vstate;
  gsl_matrix_set_zero(state->R);
  gsl_vector_set_zero(state->QTb);
  state->init = 0;
  state->svd = 0;
  state->normb = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 7
9 8
10 10
11 10
12 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
test   %rdi,%rdi
je     4ee <assoc_dequote_escapes+0x79>
cmpl   $0x0,0xc(%rdi)
je     4f5 <assoc_dequote_escapes+0x80>
mov    0x8(%rdi),%edx
test   %edx,%edx
jle    4fc <assoc_dequote_escapes+0x87>
mov    $0x0,%r12d
cmp    %edx,%r12d
jge    4df <assoc_dequote_escapes+0x6a>
movslq %r12d,%rdx
mov    0x0(%r13),%rax
mov    (%rax,%rdx,8),%rbx
test   %rbx,%rbx
je     4df <assoc_dequote_escapes+0x6a>
mov    0x10(%rbx),%rdi
callq  4b8 <assoc_dequote_escapes+0x43>
mov    %rax,%rbp
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     4d3 <assoc_dequote_escapes+0x5e>
mov    $0xe4,%edx
mov    $0x0,%esi
callq  4d3 <assoc_dequote_escapes+0x5e>
mov    %rbp,0x10(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    4af <assoc_dequote_escapes+0x3a>
add    $0x1,%r12d
mov    0x8(%r13),%edx
cmp    %r12d,%edx
jg     49a <assoc_dequote_escapes+0x25>
jmp    501 <assoc_dequote_escapes+0x8c>
mov    $0x0,%eax
jmp    504 <assoc_dequote_escapes+0x8f>
mov    $0x0,%eax
jmp    504 <assoc_dequote_escapes+0x8f>
mov    %rdi,%rax
jmp    504 <assoc_dequote_escapes+0x8f>
mov    %r13,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
assoc_dequote_escapes (h)
     HASH_TABLE *h;
{
  int i;
  BUCKET_CONTENTS *tlist;
  char *t;
  if (h == 0 || ((h)->nentries == 0))
    return ((HASH_TABLE *)((void *)0));
  for (i = 0; i < h->nbuckets; i++)
    for (tlist = ((h && (i < h->nbuckets)) ? h->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); tlist; tlist = tlist->next)
      {
 t = dequote_escapes ((char *)tlist->data);
 do { if (tlist->data) sh_xfree((tlist->data), "assoc.c", 228); } while (0);
 tlist->data = t;
      }
  return h;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 14
32 10
33 10
34 10
35 9
36 9
37 9
38 9
39 9
40 8
41 8
42 8
43 8
44 16
45 16
46 16
47 17
48 17
49 17
50 17
51 17
52 17
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 5bec <save_pgrp_pipe+0x6>
mov    %eax,(%rdi)
mov    0x0(%rip),%eax        # 5bf4 <save_pgrp_pipe+0xe>
mov    %eax,0x4(%rdi)
test   %esi,%esi
je     5c0f <save_pgrp_pipe+0x29>
movl   $0xffffffff,0x0(%rip)        # 5c05 <save_pgrp_pipe+0x1f>
movl   $0xffffffff,0x0(%rip)        # 5c0f <save_pgrp_pipe+0x29>
repz retq 
<<<sep_in_sample>>>
save_pgrp_pipe (p, clear)
     int *p;
     int clear;
{
  p[0] = pgrp_pipe[0];
  p[1] = pgrp_pipe[1];
  if (clear)
    pgrp_pipe[0] = pgrp_pipe[1] = -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 7
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%r8
cmp    %r8,0x8(%rdi)
cmovbe 0x8(%rdi),%r8
test   %r8,%r8
je     3141 <gsl_matrix_int_add_diagonal+0x48>
lea    0x4(,%rax,4),%r9
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
cvtsi2sdl (%rcx),%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%esi
mov    %esi,(%rcx)
add    $0x1,%rax
add    %r9,%rdx
cmp    %r8,%rax
jne    3120 <gsl_matrix_int_add_diagonal+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_int_add_diagonal (gsl_matrix_int * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 8
6 8
7 10
8 10
9 8
10 10
11 10
12 10
13 10
14 10
15 10
16 8
17 8
18 8
19 8
20 13
21 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6c9 <gsl_eigen_gensymmv_sort+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_eigen_gensymmv_sort (gsl_vector * eval, gsl_matrix * evec,
                         gsl_eigen_sort_t sort_type)
{
  int s;
  s = gsl_eigen_symmv_sort(eval, evec, sort_type);
  return s;
}
<<<sep_in_sample>>>
1 3
2 5
3 7
4 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2a98 <env_unexport+0x9>
test   %rax,%rax
je     2aa4 <env_unexport+0x15>
movl   $0x0,0x20(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
env_unexport (const char *var)
{
  register struct env_lst *ep = env_find (var);
  if (ep)
    ep->export = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2bc <yy_flush_buffer+0x4f>
movl   $0x0,0x1c(%rdi)
mov    0x8(%rdi),%rax
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
mov    %rax,0x10(%rdi)
movl   $0x1,0x28(%rdi)
movl   $0x0,0x38(%rdi)
mov    0x0(%rip),%rax        # 2a5 <yy_flush_buffer+0x38>
test   %rax,%rax
je     2bc <yy_flush_buffer+0x4f>
mov    0x0(%rip),%rdx        # 2b1 <yy_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
jne    2bc <yy_flush_buffer+0x4f>
callq  b9 <yy_load_buffer_state>
repz retq 
<<<sep_in_sample>>>
yy_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 7
8 8
9 8
10 9
11 10
12 11
13 11
14 11
15 11
16 11
17 11
18 12
19 12
<<<sep_out_sample>>>
sub    $0x1,%rdi
je     145 <ceil_log_8+0x19>
mov    $0x0,%eax
add    $0x1,%eax
shr    $0x3,%rdi
test   %rdi,%rdi
jne    137 <ceil_log_8+0xb>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
ceil_log_8 (unsigned long n)
{
  int log_8 = 0;
  n--;
  while (n)
    {
      log_8++;
      n >>= 3;
    }
  return log_8;
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 8
6 5
7 5
8 5
9 3
10 11
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 6c <recutl_print_help_common+0x8>
mov    $0x0,%edi
callq  76 <recutl_print_help_common+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  81 <recutl_print_help_common+0x1d>
pop    %rbx
retq   
<<<sep_in_sample>>>
recutl_print_help_common (void)
{
  fputs (gettext ("      --help                          print a help message and exit.\n      --version                       show version and exit.\n")
                                                                ,
         stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 6
9 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x1,%eax
test   %rsi,%rsi
je     16d <hasevery+0x66>
mov    %rdi,%rbx
mov    (%rsi),%rsi
callq  107 <hasevery>
test   %eax,%eax
je     16d <hasevery+0x66>
mov    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  107 <hasevery>
test   %eax,%eax
je     16d <hasevery+0x66>
test   %rbx,%rbx
je     164 <hasevery+0x5d>
movzbl 0x18(%rbp),%edx
movzbl 0x18(%rbx),%eax
cmp    %al,%dl
je     164 <hasevery+0x5d>
cmp    %al,%dl
jae    153 <hasevery+0x4c>
mov    (%rbx),%rbx
jmp    157 <hasevery+0x50>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     164 <hasevery+0x5d>
movzbl 0x18(%rbx),%eax
cmp    %dl,%al
jne    14a <hasevery+0x43>
test   %rbx,%rbx
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
hasevery (register struct tree const *a, register struct tree const *b)
{
  if (!b)
    return 1;
  if (!hasevery (a, b->llink))
    return 0;
  if (!hasevery (a, b->rlink))
    return 0;
  while (a && b->label != a->label)
    if (b->label < a->label)
      a = a->llink;
    else
      a = a->rlink;
  return !!a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 11
27 11
28 13
29 9
30 9
31 9
32 9
33 9
34 14
35 14
36 14
37 15
38 15
39 15
40 15
<<<sep_out_sample>>>
cmp    $0x4,%esi
ja     4d13 <_jit_allocai+0x30>
mov    %esi,%eax
jmpq   *0x0(,%rax,8)
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
andl   $0xfffffffe,0xc(%rax)
jmp    4d22 <_jit_allocai+0x3f>
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
andl   $0xfffffffc,0xc(%rax)
jmp    4d22 <_jit_allocai+0x3f>
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
andl   $0xfffffff8,0xc(%rax)
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
sub    %esi,0xc(%rax)
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
mov    0xc(%rax),%eax
retq   
<<<sep_in_sample>>>
_jit_allocai(jit_state_t *_jit, jit_int32_t length)
{
    ((void) (0));
    switch (length) {
 case 0: case 1: break;
 case 2: _jit->comp->function->self.aoff &= -2; break;
 case 3: case 4: _jit->comp->function->self.aoff &= -4; break;
 default: _jit->comp->function->self.aoff &= -8; break;
    }
    _jit->comp->function->self.aoff -= length;
    return (_jit->comp->function->self.aoff);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 12
<<<sep_out_sample>>>
mov    $0x26,%eax
test   %rdi,%rdi
je     4a9 <mu_folder_close+0x1d>
mov    0x58(%rdi),%rdx
test   %rdx,%rdx
je     4a9 <mu_folder_close+0x1d>
sub    $0x8,%rsp
callq  *%rdx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_folder_close (mu_folder_t folder)
{
  if (folder == ((void *)0) || folder->_close == ((void *)0))
    return 38;
  return folder->_close (folder);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 2
8 5
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
movabs $0x5555555555555555,%rcx
callq  19 <__gmpn_divexact_by3+0x19>
and    $0x3,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmpn_divexact_by3 (mp_ptr dst, mp_srcptr src, mp_size_t size)
{
  return (3 & __gmpn_bdiv_dbm1c (dst, src, size, ((mp_limb_t) (((~ ((mp_limb_t) (0))) >> 0) / 3)), ((mp_limb_t) (0))));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    $0x4,%edi
ja     23e <gc_hash_digest_length+0x24>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x14,%eax
retq   
mov    $0x14,%eax
retq   
mov    $0x10,%eax
repz retq 
<<<sep_in_sample>>>
gc_hash_digest_length (Gc_hash hash)
{
  size_t len;
  switch (hash)
    {
    case GC_MD2:
      len = 16;
      break;
    case GC_MD4:
      len = 16;
      break;
    case GC_MD5:
      len = 16;
      break;
    case GC_RMD160:
      len = 20;
      break;
    case GC_SHA1:
      len = 20;
      break;
    default:
      return 0;
    }
  return len;
}
<<<sep_in_sample>>>
1 22
2 4
3 4
4 4
5 4
6 16
7 17
8 19
9 20
10 7
11 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x20000,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  69b <mlocation_table_init+0x18>
movq   $0x0,0x0(%rip)        # 6a6 <mlocation_table_init+0x23>
movl   $0x1,0x0(%rip)        # 6b0 <mlocation_table_init+0x2d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mlocation_table_init ()
{
  memset (mlocation_table, 0, sizeof (ma_table_t) * 8192);
  mlocation_table[0].file = "";
  mlocation_table[0].line = 0;
  mlocation_table[0].nalloc = 0;
  location_table_count = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 7
8 8
9 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x11,%edi
callq  5bce <set_sigchld_handler+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_sigchld_handler ()
{
  set_signal_handler (17, sigchld_handler);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %esi,0x470(%rdi)
retq   
<<<sep_in_sample>>>
swi_set_utility_id(SWI * swi, int swc_u_id)
{
 swi->swc_idM = swc_u_id;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%r8
callq  102b <gsl_sort_vector2_long+0x1b>
repz retq 
<<<sep_in_sample>>>
gsl_sort_vector2_long (gsl_vector_long * v1, gsl_vector_long * v2)
{
  gsl_sort2_long (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpb   $0x0,0x50(%rdi)
jne    14 <__rdmaxloc+0x14>
mov    $0x0,%edi
callq  14 <__rdmaxloc+0x14>
mov    0x70(%rbx),%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
__rdmaxloc (__bs5FILE *p)
{
  if (!((__bs1FILE *) p)->open)
    __rerror ("Maxloc: File not open");
  return (p->maxloc);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  db <register_lev+0xe>
mov    $0x0,%edi
callq  e5 <register_lev+0x18>
mov    $0x0,%edi
callq  ef <register_lev+0x22>
mov    $0x0,%edi
callq  f9 <register_lev+0x2c>
mov    $0x0,%edi
callq  103 <register_lev+0x36>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11c <register_lev+0x4f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
register_lev()
{
    int i;
    static struct dicod_command cmd[] = {
 { "XLEV", 2, 2, "distance", "Set Levenshtein distance",
   dicod_xlevdist },
 { ((void *)0) }
    };
    for (i = 0; i < (sizeof(levstrat)/sizeof((levstrat)[0])); i++)
 dico_strategy_add(&levstrat[i]);
    dico_set_default_strategy("nlev");
    dicod_capa_register("xlev", cmd, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 10
3 10
4 10
5 10
6 10
7 10
8 10
9 10
10 11
11 11
12 12
13 12
14 12
15 12
16 12
17 13
18 13
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
test   %eax,%eax
jle    20 <isRedrawRequired+0x13>
sub    $0x1,%eax
mov    %eax,0x8(%rdi)
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
isRedrawRequired(drawnItem * p)
{
 _BOOL result = (0);
 if (p->redraw > 0) {
  --p->redraw;
  result = (1);
 }
 return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 6
8 3
9 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  4e2 <grecs_grecs_error+0x20>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_grecs_error(char const *s)
{
 grecs_error(&grecs_grecs_lloc, 0, "%s", s);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     18d1 <gsl_matrix_uint_isneg+0x59>
lea    0x0(,%rax,4),%r11
mov    $0x0,%r8d
mov    $0x0,%r10d
xorpd  %xmm1,%xmm1
jmp    18ca <gsl_matrix_uint_isneg+0x52>
mov    $0x0,%eax
mov    %r8,%rsi
add    0x18(%rdi),%rsi
mov    (%rsi,%rax,4),%edx
cvtsi2sd %rdx,%xmm0
ucomisd %xmm1,%xmm0
jb     18e3 <gsl_matrix_uint_isneg+0x6b>
jmp    18d7 <gsl_matrix_uint_isneg+0x5f>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
je     18dd <gsl_matrix_uint_isneg+0x65>
test   %rcx,%rcx
jne    18a2 <gsl_matrix_uint_isneg+0x2a>
jmp    18be <gsl_matrix_uint_isneg+0x46>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rax
cmp    %rcx,%rax
jne    18ae <gsl_matrix_uint_isneg+0x36>
jmp    18be <gsl_matrix_uint_isneg+0x46>
<<<sep_in_sample>>>
gsl_matrix_uint_isneg (const gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 13
10 13
11 13
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 20
27 20
28 15
29 15
30 20
31 20
32 9
33 9
34 9
35 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x2,%esi
mov    $0x0,%edi
callq  320f <put_command_name_into_env+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
put_command_name_into_env (command_name)
     char *command_name;
{
  update_export_env_inplace ("_=", 2, command_name);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movl   $0x0,0x0(%rip)        # 2159 <make_command_string+0xe>
movl   $0x0,0x0(%rip)        # 2163 <make_command_string+0x18>
movq   $0x0,0x0(%rip)        # 216e <make_command_string+0x23>
callq  18e3 <make_command_string_internal>
mov    0x0(%rip),%rax        # 217a <make_command_string+0x2f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
make_command_string (command)
     COMMAND *command;
{
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 6
6 8
7 8
8 8
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%dil
setbe  %al
retq   
<<<sep_in_sample>>>
__rdigit (char c)
{
  return (c >= '0' && c <= '9');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <cdio_log_set_handler+0x7>
mov    %rdi,0x0(%rip)        # e <cdio_log_set_handler+0xe>
retq   
<<<sep_in_sample>>>
cdio_log_set_handler(cdio_log_handler_t new_handler)
{
  cdio_log_handler_t old_handler = _handler;
  _handler = new_handler;
  return old_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  273 <TerminalSaveState+0x13>
mov    0x0(%rip),%rax        # 27a <TerminalSaveState+0x1a>
mov    %rax,0x0(%rip)        # 281 <TerminalSaveState+0x21>
mov    0x0(%rip),%rax        # 288 <TerminalSaveState+0x28>
mov    %rax,0x0(%rip)        # 28f <TerminalSaveState+0x2f>
mov    0x0(%rip),%rax        # 296 <TerminalSaveState+0x36>
mov    %rax,0x0(%rip)        # 29d <TerminalSaveState+0x3d>
mov    0x0(%rip),%rax        # 2a4 <TerminalSaveState+0x44>
mov    %rax,0x0(%rip)        # 2ab <TerminalSaveState+0x4b>
mov    0x0(%rip),%rax        # 2b2 <TerminalSaveState+0x52>
mov    %rax,0x0(%rip)        # 2b9 <TerminalSaveState+0x59>
mov    0x0(%rip),%rax        # 2c0 <TerminalSaveState+0x60>
mov    %rax,0x0(%rip)        # 2c7 <TerminalSaveState+0x67>
mov    0x0(%rip),%rax        # 2ce <TerminalSaveState+0x6e>
mov    %rax,0x0(%rip)        # 2d5 <TerminalSaveState+0x75>
mov    0x0(%rip),%eax        # 2db <TerminalSaveState+0x7b>
mov    %eax,0x0(%rip)        # 2e1 <TerminalSaveState+0x81>
movb   $0x14,0x0(%rip)        # 2e8 <TerminalSaveState+0x88>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
TerminalSaveState (void)
{
  tcgetattr (0, &old_tc);
  new_tc = old_tc;
  termAytChar = (('T')&0x1f);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 6
23 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
lea    0x1040(%rdi),%rbp
mov    %rbp,%rdi
callq  18 <nettle_gcm_camellia128_set_key+0x18>
mov    0x0(%rip),%rdx        # 1f <nettle_gcm_camellia128_set_key+0x1f>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2a <nettle_gcm_camellia128_set_key+0x2a>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nettle_gcm_camellia128_set_key(struct gcm_camellia128_ctx *ctx, const uint8_t *key)
{
  do { (nettle_camellia128_set_encrypt_key)(&(ctx)->cipher, (key)); if (0) (nettle_camellia128_crypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0); nettle_gcm_set_key(&(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_camellia128_crypt)); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d90 <swi_fl_delete+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swi_fl_delete(SWI_FILELIST * fl) {
 strar_close((STRAR*)fl);
}
<<<sep_in_sample>>>
1 1
2 2
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%eax
cmpl   $0x0,0x0(%rip)        # ff5 <gsl_test_summary+0x10>
jne    104e <gsl_test_summary+0x69>
mov    0x0(%rip),%edi        # ffd <gsl_test_summary+0x18>
mov    0x0(%rip),%esi        # 1003 <gsl_test_summary+0x1e>
cmp    %esi,%edi
je     102d <gsl_test_summary+0x48>
cmpl   $0x0,0x0(%rip)        # 100e <gsl_test_summary+0x29>
je     104e <gsl_test_summary+0x69>
mov    $0x0,%ecx
mov    %edi,%edx
mov    $0x0,%edi
mov    $0x0,%eax
callq  1026 <gsl_test_summary+0x41>
mov    $0x1,%eax
jmp    104e <gsl_test_summary+0x69>
mov    $0x0,%eax
cmpl   $0x0,0x0(%rip)        # 1039 <gsl_test_summary+0x54>
jne    104e <gsl_test_summary+0x69>
mov    %edi,%edx
mov    %edi,%esi
mov    $0x0,%edi
callq  1049 <gsl_test_summary+0x64>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_test_summary (void)
{
  if (verbose && 0)
    printf ("%d tests, passed %d, failed %d.\n", tests, passed, failed);
  if (failed != 0)
    {
      return 1;
    }
  if (tests != passed + failed)
    {
      if (verbose)
        printf ("TEST RESULTS DO NOT ADD UP %d != %d + %d\n",
                tests, passed, failed);
      return 1;
    }
  if (passed == tests)
    {
      if (!verbose)
        printf ("Completed [%d/%d]\n", passed, tests);
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 7
3 5
4 5
5 9
6 9
7 9
8 9
9 11
10 11
11 12
12 12
13 12
14 12
15 12
16 14
17 14
18 20
19 18
20 18
21 19
22 19
23 19
24 19
25 20
26 23
27 23
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
mov    %rcx,%r12
test   %rcx,%rcx
je     186 <nettle_base64_decode_update+0x95>
mov    %rdi,%r13
mov    %rdx,%r14
mov    %r8,%rbx
lea    (%r8,%rcx,1),%r15
mov    $0x0,%ebp
movzbl (%rbx),%edx
lea    (%r14,%rbp,1),%rsi
mov    %r13,%rdi
callq  12d <nettle_base64_decode_update+0x3c>
test   %eax,%eax
je     14d <nettle_base64_decode_update+0x5c>
cmp    $0x1,%eax
je     142 <nettle_base64_decode_update+0x51>
cmp    $0xffffffff,%eax
jne    148 <nettle_base64_decode_update+0x57>
nopl   0x0(%rax,%rax,1)
jmp    19a <nettle_base64_decode_update+0xa9>
add    $0x1,%rbp
jmp    14d <nettle_base64_decode_update+0x5c>
callq  14d <nettle_base64_decode_update+0x5c>
add    $0x1,%rbx
cmp    %r15,%rbx
jne    11e <nettle_base64_decode_update+0x2d>
lea    0x3(%r12,%r12,2),%rax
add    %rax,%rax
shr    $0x3,%rax
cmp    %rax,%rbp
jbe    18b <nettle_base64_decode_update+0x9a>
lea    0x0(%rip),%rcx        # 16e <nettle_base64_decode_update+0x7d>
mov    $0x90,%edx
lea    0x0(%rip),%rsi        # 17a <nettle_base64_decode_update+0x89>
lea    0x0(%rip),%rdi        # 181 <nettle_base64_decode_update+0x90>
callq  186 <nettle_base64_decode_update+0x95>
mov    $0x0,%ebp
mov    0x8(%rsp),%rax
mov    %rbp,(%rax)
mov    $0x1,%eax
jmp    19f <nettle_base64_decode_update+0xae>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
nettle_base64_decode_update(struct base64_decode_ctx *ctx,
       size_t *dst_length,
       uint8_t *dst,
       size_t src_length,
       const uint8_t *src)
{
  size_t done;
  size_t i;
  for (i = 0, done = 0; i<src_length; i++)
    switch(nettle_base64_decode_single(ctx, dst + done, src[i]))
      {
      case -1:
 return 0;
      case 1:
 done++;
      case 0:
 break;
      default:
 abort();
      }
  ((done <= ((((src_length) + 1) * 6) / 8)) ? (void) (0) : __assert_fail ("done <= ((((src_length) + 1) * 6) / 8)", "base64-decode.c", 144, __PRETTY_FUNCTION__));
  *dst_length = done;
  return 1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 15
30 15
31 19
32 19
33 9
34 9
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 21
43 21
44 21
45 9
46 22
47 22
48 23
49 23
50 13
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     18d <mperror+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rcx
mov    %rcx,0x10(%rsp)
lea    0x20(%rsp),%rdx
mov    %rdx,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %edi,%esi
mov    %rax,%rdi
callq  0 <vmsg>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
mperror (int err_num, const char *fmt, ...)
{
  va_list args;
  __builtin_va_start(args,fmt);
  vmsg (fmt, err_num, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 5
27 7
28 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%esi
callq  236 <mu_attribute_set_flagged+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_attribute_set_flagged (mu_attribute_t attr)
{
  return mu_attribute_set_flags (attr, 0x02);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edx,%ebx
mov    %edx,%ebp
xor    0x0(%rip),%ebp        # 4f <doJoystickEvent+0xe>
je     7f <doJoystickEvent+0x3e>
mov    %rdi,%r12
test   $0x1,%bpl
je     6b <doJoystickEvent+0x2a>
test   $0x1,%dl
je     66 <doJoystickEvent+0x25>
callq  64 <doJoystickEvent+0x23>
jmp    6b <doJoystickEvent+0x2a>
callq  6b <doJoystickEvent+0x2a>
test   $0x2,%bpl
nop
je     7f <doJoystickEvent+0x3e>
test   $0x2,%bl
je     7f <doJoystickEvent+0x3e>
mov    %r12,%rdi
callq  7f <doJoystickEvent+0x3e>
mov    %ebx,0x0(%rip)        # 85 <doJoystickEvent+0x44>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
doJoystickEvent(craft * c, viewer * u, double throttle, int switches)
{
 int switch_xor = switches ^ last_switches;
 if (switch_xor != 0) {
  if (switch_xor & 1) {
   if (switches & 1) {
    fireWeapon(c);
   }
   else {
    ceaseFireWeapon(c);
   }
  }
  if (switch_xor & 2) {
   if (switches & 2) {
    selectWeapon(c);
   }
  }
 }
 last_switches = switches;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
13 7
14 7
15 10
16 13
17 13
18 13
19 14
20 14
21 15
22 15
23 19
24 21
25 21
26 21
27 21
28 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x3,%edi
callq  3c2 <rl_end_undo_group+0x1d>
subl   $0x1,0x0(%rip)        # 3c9 <rl_end_undo_group+0x24>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_end_undo_group ()
{
  rl_add_undo (UNDO_END, 0, 0, 0);
  _rl_undo_group_level--;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x4,0x44(%rdi)
je     1a <force_string+0x1a>
mov    0x20(%rdi),%eax
cmp    $0xffffffff,%eax
je     32 <force_string+0x32>
cmp    0x0(%rip),%eax        # 18 <force_string+0x18>
je     37 <force_string+0x37>
mov    %rdi,%rdx
mov    0x0(%rip),%esi        # 23 <force_string+0x23>
mov    0x0(%rip),%rdi        # 2a <force_string+0x2a>
callq  *0x0(%rip)        # 30 <force_string+0x30>
jmp    3a <force_string+0x3a>
mov    %rdi,%rax
jmp    3a <force_string+0x3a>
mov    %rdi,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
force_string(NODE *s)
{
 if ((s->flags & 0x0004) != 0
      && (s->sub.val.idx == -1 || s->sub.val.idx == CONVFMTidx)
 )
  return s;
 return format_val(CONVFMT, CONVFMTidx, s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 7
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 8
18 8
<<<sep_out_sample>>>
movzwl 0xc(%rdi),%eax
sub    $0x1,%eax
cltq   
mov    (%rdi),%rdx
lea    0x18(%rdx,%rax,1),%rcx
movzwl 0x8(%rdi),%edx
test   %rsi,%rsi
jle    51 <__rleftshift+0x51>
cmp    %rsi,%rdx
jle    39 <__rleftshift+0x39>
mov    %rsi,%rax
mov    %rcx,%r8
sub    %rsi,%r8
movzbl (%rcx,%rax,1),%edi
mov    %dil,(%r8,%rax,1)
add    $0x1,%rax
cmp    %rax,%rdx
jg     28 <__rleftshift+0x28>
mov    %rdx,%rax
sub    %rsi,%rax
cmp    %rax,%rdx
jle    51 <__rleftshift+0x51>
movb   $0x20,(%rcx,%rax,1)
add    $0x1,%rax
cmp    %rax,%rdx
jg     44 <__rleftshift+0x44>
repz retq 
<<<sep_in_sample>>>
__rleftshift (__txtvp t, long j)
{
  long i,
    l;
  char *to;
  to = &(t->obj->string[t->start - 1]);
  l = t->length;
  if (j > 0)
    {
      for (i = j; i < l; i++)
 to[i - j] = to[i];
      for (i = l - j; i < l; i++)
 to[i] = ' ';
    }
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 7
7 8
8 8
9 10
10 10
11 10
12 10
13 10
14 11
15 11
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 13
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %rsi,%r12
mov    %rdx,%rbx
test   %ecx,%ecx
je     409 <mu_diag_funcall+0x55>
mov    %ecx,%edi
callq  3d1 <mu_diag_funcall+0x1d>
mov    %rax,%r13
test   %rbx,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3ef <mu_diag_funcall+0x3b>
mov    %r13,%r8
mov    %rbx,%rcx
mov    %r12,%rdx
mov    %rax,%rsi
mov    %ebp,%edi
mov    $0x0,%eax
callq  407 <mu_diag_funcall+0x53>
jmp    439 <mu_diag_funcall+0x85>
test   %rdx,%rdx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    $0x0,%esi
mov    $0x0,%edi
callq  424 <mu_diag_funcall+0x70>
mov    %rbx,%rcx
mov    %r12,%rdx
mov    %rax,%rsi
mov    %ebp,%edi
mov    $0x0,%eax
callq  439 <mu_diag_funcall+0x85>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_diag_funcall (mu_log_level_t level, const char *func,
   const char *arg, int err)
{
  if (err)
    mu_diag_output (level, dgettext ("mailutils", "%s(%s) failed: %s"), func, arg ? arg : "",
      mu_strerror (err));
  else
    mu_diag_output (level, dgettext ("mailutils", "%s(%s) failed"), func, arg ? arg : "");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 9
41 9
42 9
43 9
44 9
45 9
<<<sep_out_sample>>>
push   %rbx
test   %rdi,%rdi
jne    6fa <debug_set_output+0x19>
mov    0x0(%rip),%rdi        # 6ee <debug_set_output+0xd>
callq  0 <debug_set_file>
mov    $0x1,%eax
jmp    768 <debug_set_output+0x87>
cmpb   $0x0,(%rdi)
jne    710 <debug_set_output+0x2f>
mov    $0x0,%edi
callq  0 <debug_set_file>
mov    $0x1,%eax
jmp    768 <debug_set_output+0x87>
mov    $0x0,%esi
callq  71a <debug_set_output+0x39>
mov    %rax,%rbx
mov    $0x0,%eax
test   %rbx,%rbx
je     768 <debug_set_output+0x87>
mov    %rbx,%rdi
callq  72f <debug_set_output+0x4e>
mov    $0x1,%esi
mov    %eax,%edi
callq  73b <debug_set_output+0x5a>
test   %eax,%eax
je     75b <debug_set_output+0x7a>
callq  744 <debug_set_output+0x63>
mov    $0x0,%edx
mov    (%rax),%esi
mov    0x0(%rip),%edi        # 751 <debug_set_output+0x70>
mov    $0x0,%eax
callq  75b <debug_set_output+0x7a>
mov    %rbx,%rdi
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
debug_set_output (const char *name)
{
  FILE *fp;
  if (name == ((void *)0))
    debug_set_file (stderr);
  else if (*name == '\0')
    debug_set_file (((void *)0));
  else
    {
      fp = fopen_safer (name, "a");
      if (fp == ((void *)0))
        return 0;
      if (set_cloexec_flag (fileno (fp), 1) != 0)
        (m4_error (warning_status, (*__errno_location ()), "Warning: cannot protect debug file across forks"))
                                                                     ;
      debug_set_file (fp);
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 18
7 18
8 6
9 6
10 7
11 7
12 18
13 18
14 10
15 10
16 10
17 12
18 11
19 11
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 18
36 19
37 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
addl   $0x1,0x0(%rip)        # 485 <myalarm+0xb>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0xe,%edi
callq  499 <myalarm+0x1f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
myalarm(int s)
{
 doUpdate++;
 sigvec (14, &alrm, (struct sigvec *) 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
movzbl (%rdi),%eax
test   %rdx,%rdx
je     1465 <gsl_stats_uchar_min+0x24>
mov    $0x0,%ecx
movzbl (%rdi),%r8d
cmp    %r8b,%al
cmova  %r8d,%eax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    144e <gsl_stats_uchar_min+0xd>
repz retq 
<<<sep_in_sample>>>
gsl_stats_uchar_min (const unsigned char data[], const size_t stride,
                          const size_t n)
{
  unsigned char min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned char xi = data[i * stride];
      if (xi < min)
        min = xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 8
6 8
7 8
8 6
9 6
10 6
11 6
12 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  90 <_rl_abort_internal+0x9>
callq  95 <_rl_abort_internal+0xe>
callq  9a <_rl_abort_internal+0x13>
callq  9f <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # aa <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # b2 <_rl_abort_internal+0x2b>
je     c3 <_rl_abort_internal+0x3c>
callq  b9 <_rl_abort_internal+0x32>
cmpq   $0x0,0x0(%rip)        # c1 <_rl_abort_internal+0x3a>
jne    b4 <_rl_abort_internal+0x2d>
andq   $0xffffffffffdfffff,0x0(%rip)        # ce <_rl_abort_internal+0x47>
movq   $0x0,0x0(%rip)        # d9 <_rl_abort_internal+0x52>
mov    $0x1,%esi
mov    $0x0,%edi
callq  e8 <rl_abort>
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 9
10 8
11 8
12 10
13 11
14 12
15 12
16 12
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gc_done (void)
{
  return;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     3bf <ltrim+0x83>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  363 <ltrim+0x27>
mov    %rax,%rbx
test   %rax,%rax
je     3c6 <ltrim+0x8a>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  376 <ltrim+0x3a>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    $0x0,%esi
jmp    3a9 <ltrim+0x6d>
movzbl (%rbx,%rdx,1),%eax
lea    -0x9(%rax),%edi
cmp    $0x1,%dil
jbe    3a6 <ltrim+0x6a>
cmp    $0x20,%al
jne    3b1 <ltrim+0x75>
add    $0x1,%esi
movslq %esi,%rdx
cmp    %rcx,%rdx
jb     395 <ltrim+0x59>
add    %rbx,%rdx
test   %esi,%esi
mov    %rdx,%rax
cmove  %rbx,%rax
jmp    3cb <ltrim+0x8f>
mov    $0x0,%eax
jmp    3cb <ltrim+0x8f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ltrim(str string)
{
  if(!string) return ((void *)0);
  str _s = (str) malloc(strlen(string)+1);
  if(!_s) return ((void *)0);
  strcpy(_s, string);
  int i;
  for(i = 0; i < strlen(_s); i++)
    if(_s[i] == ' ' || _s[i] == '\t' || _s[i] == '\n') continue;
    else break;
  if(i == 0) return _s;
  else return _s+i;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 6
17 6
18 6
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 9
31 9
32 9
33 8
34 8
35 8
36 8
37 12
38 12
39 12
40 12
41 12
42 3
43 3
44 5
45 13
46 13
47 13
48 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%r9
lea    0xd0(%rdi),%rdx
lea    0x68(%rdi),%rsi
mov    0x0(%rip),%rcx        # 1c <nettle_hmac_ripemd160_set_key+0x1c>
callq  21 <nettle_hmac_ripemd160_set_key+0x21>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_hmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,
         size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_ripemd160), (key_length), (key) );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4f <crlf+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
crlf ()
{
  return rl_crlf ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  13a7 <gsl_sf_expint_E2_scaled+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     13cd <gsl_sf_expint_E2_scaled+0x32>
mov    %eax,%ecx
mov    $0x230,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  13c6 <gsl_sf_expint_E2_scaled+0x2b>
movsd  (%rsp),%xmm0
jmp    13cd <gsl_sf_expint_E2_scaled+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expint_E2_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_expint_E2_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_expint_E2_scaled_e(x, &result)", "expint.c", 560, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x218,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
mov    $0x0,%edi
callq  5f <a2ps_common_finalize+0x2c>
test   %rax,%rax
jne    87 <a2ps_common_finalize+0x54>
mov    $0x2f,%ecx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rsp,%rdi
callq  79 <a2ps_common_finalize+0x46>
mov    %rsp,%rsi
mov    (%rbx),%rdi
callq  84 <a2ps_common_finalize+0x51>
mov    %rax,(%rbx)
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
je     9f <a2ps_common_finalize+0x6c>
callq  9f <a2ps_common_finalize+0x6c>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
a2ps_common_finalize (struct a2ps_common_s * common, const char * home)
{
  char buf [512];
  if (! getenv ("NO_HOME_CONF"))
    {
      sprintf (buf, "%s%c.a2ps", home, '/');
      common->path = pw_prepend_string_to_path (common->path, buf);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # e0a <sdp_key_init+0xb>
test   %rax,%rax
je     e18 <sdp_key_init+0x19>
mov    $0x10,%edi
callq  *%rax
jmp    e22 <sdp_key_init+0x23>
mov    $0x10,%edi
callq  e22 <sdp_key_init+0x23>
mov    %rax,(%rbx)
test   %rax,%rax
je     e43 <sdp_key_init+0x44>
movq   $0x0,(%rax)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    $0x0,%eax
jmp    e48 <sdp_key_init+0x49>
mov    $0xfffffffc,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sdp_key_init (sdp_key_t ** key)
{
  *key = (sdp_key_t *) (osip_malloc_func?osip_malloc_func(sizeof (sdp_key_t)):malloc(sizeof (sdp_key_t)));
  if (*key == ((void *)0))
    return -4;
  (*key)->k_keytype = ((void *)0);
  (*key)->k_keydata = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 7
16 7
17 8
18 8
19 5
20 9
21 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rcx
mov    0x40(%rdx),%rax
mov    %rax,0x8(%rsp)
movzbl 0x28(%rdx),%eax
mov    %eax,(%rsp)
mov    0x0(%rip),%r9d        # 6f0 <pred_fls+0x1e>
mov    0x0(%rip),%r8        # 6f7 <pred_fls+0x25>
mov    0x0(%rip),%rdx        # 6fe <pred_fls+0x2c>
mov    0x0(%rip),%esi        # 704 <pred_fls+0x32>
callq  709 <pred_fls+0x37>
mov    $0x1,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
pred_fls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  FILE * stream = pred_ptr->args.printf_vec.stream;
  list_file (pathname, state.cwd_dir_fd, state.rel_pathname, stat_buf,
      options.start_time.tv_sec,
      options.output_block_size,
      pred_ptr->literal_control_chars, stream);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%ecx
test   %rdi,%rdi
je     1d6b <rl_bind_keyseq_if_unbound_in_map+0x4e>
mov    %rsi,%r12
mov    %rdx,%rbp
mov    $0x0,%edx
mov    %rbp,%rsi
callq  1d41 <rl_bind_keyseq_if_unbound_in_map+0x24>
test   %rax,%rax
je     1d5b <rl_bind_keyseq_if_unbound_in_map+0x3e>
cmp    $0x0,%rax
je     1d5b <rl_bind_keyseq_if_unbound_in_map+0x3e>
mov    $0x1,%ecx
cmp    $0x0,%rax
jne    1d6b <rl_bind_keyseq_if_unbound_in_map+0x4e>
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  1d69 <rl_bind_keyseq_if_unbound_in_map+0x4c>
mov    %eax,%ecx
mov    %ecx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
     const char *keyseq;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  rl_command_func_t *func;
  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)((void *)0));
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
 return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
 return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 15
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 10
14 10
15 10
16 10
17 13
18 10
19 10
20 11
21 11
22 11
23 11
24 11
25 16
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 7254 <unlink_fifo_list+0x7>
je     728b <unlink_fifo_list+0x3e>
cmpl   $0x0,0x0(%rip)        # 725d <unlink_fifo_list+0x10>
jle    728d <unlink_fifo_list+0x40>
push   %rbx
mov    $0x0,%ebx
mov    %ebx,%edi
callq  726c <unlink_fifo_list+0x1f>
add    $0x1,%ebx
cmpl   $0x0,0x0(%rip)        # 7276 <unlink_fifo_list+0x29>
je     7280 <unlink_fifo_list+0x33>
cmp    %ebx,0x0(%rip)        # 727e <unlink_fifo_list+0x31>
jg     7265 <unlink_fifo_list+0x18>
movl   $0x0,0x0(%rip)        # 728a <unlink_fifo_list+0x3d>
pop    %rbx
repz retq 
movl   $0x0,0x0(%rip)        # 7297 <unlink_fifo_list+0x4a>
retq   
<<<sep_in_sample>>>
unlink_fifo_list ()
{
  register int i;
  if (nfds == 0)
    return;
  for (i = 0; nfds && i < totfds; i++)
    unlink_fifo (i);
  nfds = 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 2
6 6
7 7
8 7
9 6
10 6
11 6
12 6
13 6
14 8
15 9
16 9
17 8
18 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xeb8(%rdi),%rdi
callq  4d9 <CloseMCFiles+0x10>
mov    0xeb0(%rbx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  4ef <CloseMCFiles+0x26>
pop    %rbx
retq   
<<<sep_in_sample>>>
CloseMCFiles (PANALYSIS panal)
{
  fclose (panal->mc.pfileMCOut);
  printf ("\nWrote results to \"%s\"\n", panal->mc.szMCOutfilename);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
<<<sep_in_sample>>>
buffer_len (Buffer *buffer)
{
  return buffer->len;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     45b <gsl_permute_vector_complex_inverse+0x2c>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  454 <gsl_permute_vector_complex_inverse+0x25>
mov    $0x13,%eax
jmp    471 <gsl_permute_vector_complex_inverse+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  46c <gsl_permute_vector_complex_inverse+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_complex_inverse (const gsl_permutation * p, gsl_vector_complex * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%r10
mov    0x18(%rsi),%rsi
mov    %rdx,(%rsp)
mov    $0xffffffff,%r9d
mov    (%rax),%rcx
mov    %r10,%rdx
callq  7eb <gsl_wavelet2d_transform_matrix_inverse+0x28>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_wavelet2d_transform_matrix_inverse (const gsl_wavelet * w,
                                        gsl_matrix * a,
                                        gsl_wavelet_workspace * work)
{
  return gsl_wavelet2d_transform (w, a->data,
                                  a->tda, a->size1, a->size2,
                                  gsl_wavelet_backward, work);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x60(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
term_ostream_set_weight (term_ostream_t first_arg, term_weight_t weight)
{
  const struct term_ostream_implementation *vtable =
    ((struct term_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->set_weight (first_arg,weight);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %edi,%edi
je     538 <_rl_vi_textmod_command+0x26>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  52b <_rl_vi_textmod_command+0x19>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_rl_vi_textmod_command (c)
     int c;
{
  return (((c) ? (char *)strchr ((vi_textmod), (c)) != (char *)((void *)0) : 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rax        # ce4 <slc_end_reply+0x8>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # cef <slc_end_reply+0x13>
movb   $0xff,(%rax)
mov    0x0(%rip),%rax        # cf9 <slc_end_reply+0x1d>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # d04 <slc_end_reply+0x28>
movb   $0xf0,(%rax)
mov    0x0(%rip),%rbx        # d0e <slc_end_reply+0x32>
sub    $0x0,%rbx
cmp    $0x6,%ebx
jle    d70 <slc_end_reply+0x94>
mov    $0x0,%edi
callq  d24 <slc_end_reply+0x48>
cmp    %eax,%ebx
jge    d66 <slc_end_reply+0x8a>
mov    0x0(%rip),%rdx        # d2f <slc_end_reply+0x53>
sub    $0x0,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d45 <slc_end_reply+0x69>
mov    $0x0,%eax
mov    0x0(%rip),%edx        # d50 <slc_end_reply+0x74>
sub    %eax,%edx
sub    $0x2,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
callq  d64 <slc_end_reply+0x88>
jmp    d70 <slc_end_reply+0x94>
mov    $0x0,%edi
callq  d70 <slc_end_reply+0x94>
pop    %rbx
retq   
<<<sep_in_sample>>>
slc_end_reply (void)
{
  register int len;
  *slc_replyp++ = 255;
  *slc_replyp++ = 240;
  len = slc_replyp - slc_reply;
  if (len <= 6)
    return;
  if ((ring_empty_count(&netoring)) > len)
    {
      ring_supply_data (&netoring, slc_reply, slc_replyp - slc_reply);
      printsub ('>', &slc_reply[2], slc_replyp - slc_reply - 2);
    }
  else
    printf ("slc_end_reply: not enough room\n");
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 15
32 15
33 16
34 16
<<<sep_out_sample>>>
cmpq   $0x0,0x30(%rdi)
jne    11 <_url_pop_init+0xf>
movq   $0x6e,0x30(%rdi)
movq   $0x0,0x68(%rdi)
mov    $0x16,%eax
cmpq   $0x0,0x38(%rdi)
jne    3f <_url_pop_init+0x3d>
mov    0x58(%rdi),%eax
test   %eax,%eax
jne    3a <_url_pop_init+0x38>
cmpq   $0x0,0x28(%rdi)
mov    $0x16,%edx
cmove  %edx,%eax
retq   
mov    $0x16,%eax
repz retq 
<<<sep_in_sample>>>
_url_pop_init (mu_url_t url)
{
  if (url->port == 0)
    url->port = 110;
  url->_destroy = url_pop_destroy;
  if (url->path || url->qargc || !url->host)
    return 22;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 7
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  40d <anubis_assoc_cmp+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
anubis_assoc_cmp (void *item, void *data)
{
  ASSOC *p = item;
  return strcmp (p->key, data);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    d <find_frame+0xd>
mov    0x0(%rip),%rax        # c <find_frame+0xc>
retq   
mov    0x0(%rip),%rax        # 14 <find_frame+0x14>
mov    (%rax,%rdi,8),%rax
retq   
<<<sep_in_sample>>>
find_frame(long num)
{
 ((void) (0));
 if (num == 0)
  return frame_ptr;
 ((void) (0));
 ((void) (0));
 ((void) (0));
 return fcall_list[num];
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 9
6 9
7 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5b <compute_variance>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_variance_with_fixed_mean (const double data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_variance (data, stride, n, mean);
  return variance;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     405 <gsasl_client_callback_maxbuf_get+0xa>
mov    0x68(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_maxbuf_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_maxbuf : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rsp,%rdi
callq  d4d <dico_shell+0xc>
cmpl   $0x0,0x0(%rip)        # d54 <dico_shell+0x13>
je     d73 <dico_shell+0x32>
mov    $0x0,%esi
mov    $0x0,%edi
callq  d65 <dico_shell+0x24>
cmpl   $0x0,0x0(%rip)        # d6c <dico_shell+0x2b>
jne    d73 <dico_shell+0x32>
callq  d73 <dico_shell+0x32>
cmpl   $0x0,0x0(%rip)        # d7a <dico_shell+0x39>
jne    d86 <dico_shell+0x45>
movl   $0x2e,0x0(%rip)        # d86 <dico_shell+0x45>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d98 <dico_shell+0x57>
mov    %rsp,%rdi
callq  da0 <dico_shell+0x5f>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
dico_shell()
{
    struct init_script dat;
    shell_init(&dat);
    if (interactive) {
 xdico_assign_string(&prompt, "dico> ");
 if (!quiet_option)
     shell_banner();
    }
    if (!cmdprefix)
 cmdprefix = '.';
    parse_script_file(((void *)0), shell_getline, &dat);
    shell_finish(&dat);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 6
9 7
10 7
11 8
12 10
13 10
14 11
15 12
16 12
17 12
18 12
19 13
20 13
21 14
22 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x128(%rdi),%edi
callq  1037 <code_num>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sparse_minor_coder (struct tar_stat_info const *st, char const *keyword,
        struct xheader *xhdr, void const *data)
{
  code_num (st->sparse_minor, keyword, xhdr);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 237 <compare_names_found+0x7>
test   %rax,%rax
jne    254 <compare_names_found+0x24>
cmpq   $0x0,0x30(%rsi)
setne  %dl
movzbl %dl,%edx
cmpq   $0x0,0x30(%rdi)
setne  %al
movzbl %al,%eax
jmp    268 <compare_names_found+0x38>
cmp    0x30(%rsi),%rax
setbe  %dl
movzbl %dl,%edx
cmp    0x30(%rdi),%rax
setbe  %al
movzbl %al,%eax
sub    %eax,%edx
mov    %edx,%eax
test   %edx,%edx
jne    285 <compare_names_found+0x55>
sub    $0x8,%rsp
mov    0x10(%rsi),%rsi
mov    0x10(%rdi),%rdi
callq  281 <compare_names_found+0x51>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
compare_names_found (struct name const *n1, struct name const *n2)
{
  int found_diff = (occurrence_option == 0 ? (n2)->found_count != 0 : (n2)->found_count >= occurrence_option) - (occurrence_option == 0 ? (n1)->found_count != 0 : (n1)->found_count >= occurrence_option);
  return found_diff ? found_diff : strcmp (n1->name, n2->name);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
19 4
20 4
21 2
22 4
23 4
24 4
25 5
26 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
mov    %rsi,%rbp
mov    $0x18,%edi
callq  8b0 <add_config+0x14>
mov    %rax,%rbx
movq   $0x0,(%rax)
mov    %r12d,0x8(%rax)
mov    %rbp,%rdi
callq  8c6 <add_config+0x2a>
mov    %rax,0x10(%rbx)
mov    0x0(%rip),%rax        # 8d1 <add_config+0x35>
test   %rax,%rax
je     8db <add_config+0x3f>
mov    %rbx,(%rax)
jmp    8e2 <add_config+0x46>
mov    %rbx,0x0(%rip)        # 8e2 <add_config+0x46>
mov    %rbx,0x0(%rip)        # 8e9 <add_config+0x4d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
add_config (enum config_syntax syntax, const char *name)
{
  struct config_file *file = xmalloc (sizeof (file[0]));
  file->next = ((void *)0);
  file->syntax = syntax;
  file->name = xstrdup (name);
  if (conf_tail)
    conf_tail->next = file;
  else
    conf_head = file;
  conf_tail = file;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 10
20 11
21 12
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
movl   $0x0,0xc(%rsp)
mov    $0x16,%eax
test   %rdi,%rdi
je     19f <mu_attribute_unset_flags+0x5c>
mov    %esi,%ebp
lea    0xc(%rsp),%rsi
callq  16a <mu_attribute_unset_flags+0x27>
mov    %ebp,%eax
and    0xc(%rsp),%eax
je     19f <mu_attribute_unset_flags+0x5c>
mov    0x20(%rbx),%rax
test   %rax,%rax
je     18d <mu_attribute_unset_flags+0x4a>
mov    %ebp,%esi
mov    %rbx,%rdi
callq  *%rax
test   %eax,%eax
je     192 <mu_attribute_unset_flags+0x4f>
mov    $0x0,%eax
jmp    19f <mu_attribute_unset_flags+0x5c>
not    %ebp
and    %ebp,0x8(%rbx)
mov    %rbx,%rdi
callq  19a <mu_attribute_unset_flags+0x57>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_attribute_unset_flags (mu_attribute_t attr, int flags)
{
  int status = 0;
  int oflags = 0;
  if (attr == ((void *)0))
    return 22;
  mu_attribute_get_flags (attr, &oflags);
  if ((oflags & flags) == 0)
    return 0;
  if (attr->_unset_flags)
    status = attr->_unset_flags (attr, flags);
  else
    attr->flags &= ~flags;
  if (status == 0)
    mu_attribute_set_modified (attr);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 6
7 5
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 10
16 10
17 10
18 11
19 11
20 11
21 14
22 14
23 16
24 16
25 13
26 13
27 15
28 15
29 16
30 17
31 17
32 17
33 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rdx,%rdi
callq  17c5 <yy_scan_string+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x20,%esi
callq  443 <mu_attribute_unset_read+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_attribute_unset_read (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x20);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%r10
cmp    0x8(%rdi),%r10
je     3b2a <gsl_matrix_ushort_transpose+0x78>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3ad8 <gsl_matrix_ushort_transpose+0x26>
mov    $0x14,%eax
jmp    3b43 <gsl_matrix_ushort_transpose+0x91>
mov    %r11,%r8
lea    0x1(%r8),%r11
cmp    %r10,%r11
je     3b37 <gsl_matrix_ushort_transpose+0x85>
mov    %r11,%rax
mov    0x10(%rdi),%rdx
mov    0x18(%rdi),%rsi
mov    %r8,%rcx
imul   %rdx,%rcx
add    %rax,%rcx
lea    (%rsi,%rcx,2),%rcx
movzwl (%rcx),%r9d
imul   %rax,%rdx
add    %r8,%rdx
movzwl (%rsi,%rdx,2),%esi
mov    %si,(%rcx)
mov    0x18(%rdi),%rcx
mov    %r9w,(%rcx,%rdx,2)
add    $0x1,%rax
cmp    %r10,%rax
jne    3aee <gsl_matrix_ushort_transpose+0x3c>
jmp    3adf <gsl_matrix_ushort_transpose+0x2d>
test   %r10,%r10
je     3b3d <gsl_matrix_ushort_transpose+0x8b>
mov    $0x0,%r8d
jmp    3ae2 <gsl_matrix_ushort_transpose+0x30>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_transpose (gsl_matrix_ushort * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned short tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 10
13 12
14 12
15 12
16 12
17 16
18 19
19 16
20 16
21 16
22 19
23 19
24 17
25 17
26 20
27 20
28 21
29 21
30 12
31 12
32 12
33 12
34 10
35 10
36 10
37 10
38 26
39 26
40 26
41 26
42 27
43 27
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rdx,%rcx
mov    %rsi,%rdx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  1d <rpl_vasprintf+0x1d>
test   %rax,%rax
je     51 <rpl_vasprintf+0x51>
mov    0x8(%rsp),%rdx
cmp    $0x7fffffff,%rdx
jbe    4a <rpl_vasprintf+0x4a>
mov    %rax,%rdi
callq  38 <rpl_vasprintf+0x38>
callq  3d <rpl_vasprintf+0x3d>
movl   $0x4b,(%rax)
mov    $0xffffffff,%eax
jmp    56 <rpl_vasprintf+0x56>
mov    %rax,(%rbx)
mov    %edx,%eax
jmp    56 <rpl_vasprintf+0x56>
mov    $0xffffffff,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
rpl_vasprintf (char **resultp, const char *format, va_list args)
{
  size_t length;
  char *result = vasnprintf (((void *)0), &length, format, args);
  if (result == ((void *)0))
    return -1;
  if (length > 2147483647)
    {
      free (result);
      (*__errno_location ()) = 75;
      return -1;
    }
  *resultp = result;
  return length;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 11
19 11
20 13
21 14
22 14
23 6
24 15
25 15
26 15
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm0        # 8 <flapsDown+0x8>
addsd  0x278(%rdi),%xmm0
movsd  %xmm0,0x278(%rdi)
mov    0x320(%rdi),%rax
movsd  0x178(%rax),%xmm1
ucomisd %xmm1,%xmm0
jbe    35 <flapsDown+0x35>
movsd  %xmm1,0x278(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
flapsDown(craft * c)
{
 c->flapSetting += 10.0 * 3.14159265358979323846 / 180.0;
 if (c->flapSetting > c->cinfo->maxFlap)
  c->flapSetting = c->cinfo->maxFlap;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 7
10 7
<<<sep_out_sample>>>
mov    0xe8(%rdi),%rax
mov    %rax,(%rsi)
mov    0xf0(%rdi),%rax
mov    %rax,0x8(%rsi)
mov    0xf8(%rdi),%rax
mov    %rax,0x10(%rsi)
mov    0x100(%rdi),%rax
mov    %rax,0x18(%rsi)
mov    0x108(%rdi),%rax
mov    %rax,0x20(%rsi)
mov    0x110(%rdi),%rax
mov    %rax,0x28(%rsi)
mov    0x118(%rdi),%rax
mov    %rax,0x30(%rsi)
mov    0x120(%rdi),%rax
mov    %rax,0x38(%rsi)
mov    0x128(%rdi),%rax
mov    %rax,0x40(%rsi)
mov    0x130(%rdi),%rax
mov    %rax,0x48(%rsi)
mov    0x138(%rdi),%rax
mov    %rax,0x50(%rsi)
mov    0x140(%rdi),%rax
mov    %rax,0x58(%rsi)
mov    0x148(%rdi),%rax
mov    %rax,0x60(%rsi)
mov    0x150(%rdi),%rax
mov    %rax,0x68(%rsi)
mov    0x158(%rdi),%rax
mov    %rax,0x70(%rsi)
mov    0x160(%rdi),%rax
mov    %rax,0x78(%rsi)
retq   
<<<sep_in_sample>>>
mu_m_server_get_sigset (mu_m_server_t srv, sigset_t *sigset)
{
  *sigset = srv->sigmask;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %r9,0x48(%rsp)
test   %al,%al
je     485 <swutil_doif_writef+0x47>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x28,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r9
callq  4b6 <swutil_doif_writef+0x78>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
swutil_doif_writef(int verbose_level, int write_at_level,
   struct sw_logspec * logspec, int fd, char * format, ...)
{
 int ret;
 va_list ap;
 __builtin_va_start(ap,format);
 ret = doif_i_writef(verbose_level,
   write_at_level,
   logspec,
   fd, format, &ap);
 __builtin_va_end(ap);
 return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  4ac <killed+0xe>
mov    $0x2,%esi
mov    0x0(%rip),%edi        # 4b7 <killed+0x19>
callq  4bc <killed+0x1e>
mov    0x0(%rip),%edi        # 4c2 <killed+0x24>
callq  4c7 <killed+0x29>
callq  4cc <killed+0x2e>
mov    $0x0,%edi
callq  4d6 <disInit>
<<<sep_in_sample>>>
killed(int i)
{
 printf("\ninterrupt\n");
 shutdown(listen_socket, 2);
 close(listen_socket);
 dis_close();
 exit(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 6
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %esi,%r9d
mov    %rcx,%rbx
test   %edx,%edx
je     70d <maildir_new_message_name+0x1d>
test   $0x4,%sil
je     70d <maildir_new_message_name+0x1d>
movq   $0x0,(%rcx)
jmp    765 <maildir_new_message_name+0x75>
mov    0x48(%rax),%r8
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
jne    74b <maildir_new_message_name+0x5b>
mov    0x50(%rax),%rdx
mov    0x40(%rax),%rax
mov    0x90(%rax),%rdi
mov    %r9d,%ecx
mov    $0x0,%esi
callq  7d <mk_info_filename>
mov    %rax,(%rbx)
jmp    765 <maildir_new_message_name+0x75>
mov    0x50(%rax),%rdx
mov    0x40(%rax),%rax
mov    0x90(%rax),%rdi
mov    %r8,%rsi
callq  762 <maildir_new_message_name+0x72>
mov    %rax,(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
maildir_new_message_name (struct _amd_message *amsg, int flags, int expunge,
     char **pname)
{
  struct _maildir_message *msg = (struct _maildir_message *) amsg;
  if (expunge && (flags & 0x04))
    {
      *pname = ((void *)0);
    }
  else if (strcmp (msg->dir, "cur") == 0)
    *pname = mk_info_filename (amsg->amd->name, "cur", msg->file_name, flags);
  else
    *pname = maildir_mkfilename (amsg->amd->name, msg->dir, msg->file_name);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
xorpd  %xmm2,%xmm2
ucomisd %xmm0,%xmm2
jae    a22 <gsl_sf_lnpoch_e+0x20>
movapd %xmm2,%xmm3
movapd %xmm0,%xmm2
addsd  %xmm1,%xmm2
ucomisd %xmm2,%xmm3
jb     a53 <gsl_sf_lnpoch_e+0x51>
movsd  0x0(%rip),%xmm0        # a2a <gsl_sf_lnpoch_e+0x28>
movsd  %xmm0,(%rdi)
movsd  %xmm0,0x8(%rdi)
mov    $0x1,%ecx
mov    $0x11f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a4c <gsl_sf_lnpoch_e+0x4a>
mov    $0x1,%eax
jmp    a78 <gsl_sf_lnpoch_e+0x76>
ucomisd 0x0(%rip),%xmm1        # a5b <gsl_sf_lnpoch_e+0x59>
jp     a73 <gsl_sf_lnpoch_e+0x71>
jne    a73 <gsl_sf_lnpoch_e+0x71>
xorpd  %xmm0,%xmm0
movsd  %xmm0,(%rdi)
movsd  %xmm0,0x8(%rdi)
mov    $0x0,%eax
jmp    a78 <gsl_sf_lnpoch_e+0x76>
callq  47d <lnpoch_pos>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_lnpoch_e(const double a, const double x, gsl_sf_result * result)
{
  if(a <= 0.0 || a+x <= 0.0) {
    do { (result)->val = (__builtin_nanf ("")); (result)->err = (__builtin_nanf ("")); do { gsl_error ("domain error", "poch.c", 287, GSL_EDOM) ; return GSL_EDOM ; } while (0); } while(0);
  }
  else if(x == 0.0) {
    result->val = 0.0;
    result->err = 0.0;
    return GSL_SUCCESS;
  }
  else {
    return lnpoch_pos(a, x, result);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 7
24 7
25 8
26 9
27 9
28 12
29 14
30 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 143f <ORCSerror+0xb>
mov    0xd8(%rax),%edi
test   %edi,%edi
js     144e <ORCSerror+0x1a>
callq  144e <ORCSerror+0x1a>
mov    0x0(%rip),%rax        # 1455 <ORCSerror+0x21>
mov    0x198(%rax),%rdi
test   %rdi,%rdi
je     146d <ORCSerror+0x39>
callq  1466 <ORCSerror+0x32>
mov    %eax,%edi
callq  146d <ORCSerror+0x39>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ORCSerror (void)
{
  int repo_fd_lock = (top->repository. fd_lock);
  if (0 <= repo_fd_lock)
    close (repo_fd_lock);
  if ((top->flow. rewr))
    close (fileno ((top->flow. rewr)));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 8
15 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
test   %rdi,%rdi
je     6ea <sdp_message_k_key_set+0x84>
mov    %esi,%ebx
mov    %rdx,%r13
mov    %rcx,%r12
cmp    $0xffffffff,%esi
je     698 <sdp_message_k_key_set+0x32>
lea    0xb8(%rdi),%rdi
callq  691 <sdp_message_k_key_set+0x2b>
lea    0x1(%rbx),%edx
cmp    %edx,%eax
jl     6f1 <sdp_message_k_key_set+0x8b>
lea    0x8(%rsp),%rdi
callq  6a2 <sdp_message_k_key_set+0x3c>
mov    %eax,%esi
test   %esi,%esi
jne    6f6 <sdp_message_k_key_set+0x90>
mov    0x8(%rsp),%rax
mov    %r13,(%rax)
mov    0x8(%rsp),%rax
mov    %r12,0x8(%rax)
cmp    $0xffffffff,%ebx
jne    6cc <sdp_message_k_key_set+0x66>
mov    %rax,0xa0(%rbp)
mov    $0x0,%eax
jmp    6f6 <sdp_message_k_key_set+0x90>
lea    0xb8(%rbp),%rdi
mov    %ebx,%esi
callq  6da <sdp_message_k_key_set+0x74>
mov    0x8(%rsp),%rdx
mov    %rdx,0x68(%rax)
mov    $0x0,%eax
jmp    6f6 <sdp_message_k_key_set+0x90>
mov    $0xfffffffe,%eax
jmp    6f6 <sdp_message_k_key_set+0x90>
mov    $0xffffffff,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
sdp_message_k_key_set (sdp_message_t * sdp, int pos_media, char *keytype, char *keydata)
{
  sdp_key_t *key;
  sdp_media_t *med;
  int i;
  if (sdp == ((void *)0))
    return -2;
  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))
    return -1;
  i = sdp_key_init (&key);
  if (i != 0)
    return i;
  key->k_keytype = keytype;
  key->k_keydata = keydata;
  if (pos_media == -1) {
    sdp->k_key = key;
    return 0;
  }
  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);
  med->k_key = key;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 10
22 11
23 11
24 13
25 13
26 14
27 14
28 15
29 15
30 16
31 17
32 17
33 19
34 19
35 19
36 20
37 20
38 21
39 21
40 7
41 7
42 9
43 22
44 22
45 22
46 22
47 22
48 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
fstpt  (%rsp)
lea    0x1c(%rsp),%rdi
callq  31 <printf_frexpl+0x31>
fadd   %st(0),%st
mov    0x1c(%rsp),%edx
lea    -0x1(%rdx),%eax
mov    %eax,0x1c(%rsp)
cmp    $0xffffc002,%eax
jge    5b <printf_frexpl+0x5b>
lea    0x3ffd(%rdx),%edi
fstpt  (%rsp)
callq  53 <printf_frexpl+0x53>
movl   $0xffffc002,0x1c(%rsp)
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    0x1c(%rsp),%eax
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 15
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     3ba <osip_message_set_call_info+0x73>
mov    %rdi,%rbp
mov    $0x0,%eax
cmpb   $0x0,(%rsi)
je     3bf <osip_message_set_call_info+0x78>
lea    0x8(%rsp),%rdi
callq  36c <osip_message_set_call_info+0x25>
mov    %eax,%edx
test   %edx,%edx
jne    3bf <osip_message_set_call_info+0x78>
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
callq  37f <osip_message_set_call_info+0x38>
mov    %eax,%ebx
test   %eax,%eax
je     393 <osip_message_set_call_info+0x4c>
mov    0x8(%rsp),%rdi
callq  38f <osip_message_set_call_info+0x48>
mov    %ebx,%eax
jmp    3bf <osip_message_set_call_info+0x78>
movl   $0x2,0x1a0(%rbp)
lea    0xa0(%rbp),%rdi
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
callq  3b3 <osip_message_set_call_info+0x6c>
mov    $0x0,%eax
jmp    3bf <osip_message_set_call_info+0x78>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_message_set_call_info (osip_message_t * sip, const char *hvalue)
{
  osip_call_info_t *call_info;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_call_info_init (&call_info);
  if (i != 0)
    return i;
  i = osip_call_info_parse (call_info, hvalue);
  if (i != 0) {
    osip_call_info_free (call_info);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->call_infos, call_info, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 5
10 5
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 10
20 11
21 11
22 12
23 12
24 13
25 13
26 15
27 16
28 16
29 16
30 16
31 17
32 17
33 6
34 18
35 18
36 18
37 18
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8 <osip_dialog_set_state+0x8>
mov    %esi,0x58(%rdi)
repz retq 
<<<sep_in_sample>>>
osip_dialog_set_state (osip_dialog_t * dialog, state_t state)
{
  if (dialog == ((void *)0))
    return;
  dialog->state = state;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
movslq (%rsi),%rdx
movslq %edi,%r8
mov    $0xf,%ecx
mov    $0x7f,%esi
mov    0x0(%rip),%rdi        # 1b <stack_push+0x1b>
callq  20 <stack_push+0x20>
addl   $0x4,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
stack_push(int reg, int *sp)
{
  _jit_new_node_www(_jit,jit_code_stxi_i,*sp,_RBP,reg);
  *sp += sizeof (int);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
<<<sep_out_sample>>>
movq   $0x0,(%rsi)
mov    %rdx,0x8(%rsi)
mov    %rdx,0x18(%rsi)
movl   $0x0,0x20(%rsi)
movl   $0x0,0x24(%rsi)
test   %rdi,%rdi
je     649 <MakeStringBuffer+0x38>
mov    0x30(%rdi),%rax
mov    %rax,0x30(%rsi)
mov    0x20(%rdi),%eax
mov    %eax,0x20(%rsi)
movl   $0x1,0x24(%rsi)
retq   
movq   $0x0,0x30(%rsi)
retq   
<<<sep_in_sample>>>
MakeStringBuffer (PINPUTBUF pBuf, PINPUTBUF pbufStr, PSTR sz)
{
  pbufStr->pfileIn = ((void *)0);
  pbufStr->pbufCur = pbufStr->pbufOrg = sz;
  pbufStr->iLineNum = 0;
  pbufStr->iLNPrev = 0;
  pbufStr->pInfo = (pBuf ? pBuf->pInfo : ((void *)0));
  if (pBuf) {
    pbufStr->iLineNum = pBuf->iLineNum;
    pbufStr->iLNPrev = 1;
  }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 6
6 7
7 7
8 7
9 7
10 9
11 9
12 10
13 10
14 7
15 7
<<<sep_out_sample>>>
mov    $0x1,%eax
test   $0x60,%dil
je     f2 <is_cntrl_char+0x14>
cmp    $0x7f,%edi
sete   %al
movzbl %al,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
is_cntrl_char(int c)
{
    return ((c & 0x60) == 0 || c == 127);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     247 <__dbenv_err+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdx,%r8
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r9
mov    $0x1,%ecx
mov    $0x1,%edx
callq  285 <__dbenv_err+0x8f>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__dbenv_err(const DB_ENV *dbenv, int error, const char *fmt, ...)
{
 va_list ap;
 __builtin_va_start(ap,fmt);
 CDB___db_real_err(dbenv, error, 1, 1, fmt, ap);
 __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 4
18 4
19 4
20 4
21 4
22 5
23 5
24 5
25 5
26 7
27 7
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
add    $0x4,%rax
cmp    $0x18,%rax
jne    4c <saveOldColors+0x5>
repz retq 
<<<sep_in_sample>>>
saveOldColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    oldFGColors[i] = FG_COLOR[i];
    oldBGColors[i] = BG_COLOR[i];
  }
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 7
6 7
7 4
8 4
9 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
mov    0x0(%rip),%r12d        # 42a <get_third_addr+0x14>
mov    0x0(%rip),%ebp        # 430 <get_third_addr+0x1a>
callq  b6 <extract_addr_range>
mov    %eax,%ebx
mov    $0x0,%eax
test   %ebx,%ebx
js     498 <get_third_addr+0x82>
callq  445 <get_third_addr+0x2f>
test   %eax,%eax
je     45e <get_third_addr+0x48>
test   %ebx,%ebx
jne    45e <get_third_addr+0x48>
mov    $0x0,%edi
callq  457 <get_third_addr+0x41>
mov    $0x0,%eax
jmp    498 <get_third_addr+0x82>
cmpl   $0x0,0x0(%rip)        # 465 <get_third_addr+0x4f>
js     476 <get_third_addr+0x60>
callq  46c <get_third_addr+0x56>
mov    0x0(%rip),%edx        # 472 <get_third_addr+0x5c>
cmp    %edx,%eax
jge    482 <get_third_addr+0x6c>
callq  a3 <invalid_address>
mov    $0x0,%eax
jmp    498 <get_third_addr+0x82>
mov    %edx,0x0(%r13)
mov    %r12d,0x0(%rip)        # 48d <get_third_addr+0x77>
mov    %ebp,0x0(%rip)        # 493 <get_third_addr+0x7d>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
get_third_addr( const char ** const ibufpp, int * const addr )
  {
  const int old1 = first_addr;
  const int old2 = second_addr;
  int addr_cnt = extract_addr_range( ibufpp );
  if( addr_cnt < 0 ) return false;
  if( traditional() && addr_cnt == 0 )
    { set_error_msg( "Destination expected" ); return false; }
  if( second_addr < 0 || second_addr > last_addr() )
    { invalid_address(); return false; }
  *addr = second_addr;
  first_addr = old1; second_addr = old2;
  return true;
  }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 10
30 10
31 10
32 11
33 12
34 12
35 13
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # dcf <next_history+0x6>
cmp    0x0(%rip),%eax        # dd5 <next_history+0xc>
je     dee <next_history+0x25>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # de0 <next_history+0x17>
cltq   
mov    0x0(%rip),%rdx        # de9 <next_history+0x20>
mov    (%rdx,%rax,8),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
next_history ()
{
  if (history_offset == history_length)
    return ((HIST_ENTRY *)((void *)0));
  else
    return (the_history[++history_offset]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 6
7 6
8 6
9 6
10 4
11 7
<<<sep_out_sample>>>
movq   $0x0,0x30(%rdi)
movq   $0x0,0x38(%rdi)
movq   $0x0,0x28(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_odeiv2_evolve_reset (gsl_odeiv2_evolve * e)
{
  e->count = 0;
  e->failed_steps = 0;
  e->last_step = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1c54 <asm_get_leng+0x7>
retq   
<<<sep_in_sample>>>
asm_get_leng (void)
{
        return asm_leng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    %rdx,%rbp
mov    %rsp,%rsi
callq  345 <_attachment_setup+0x17>
mov    %eax,%ecx
test   %ecx,%ecx
jne    3b9 <_attachment_setup+0x8b>
mov    %rbp,%rsi
mov    (%rsp),%rdi
callq  357 <_attachment_setup+0x29>
mov    %eax,%edx
test   %edx,%edx
jne    3b9 <_attachment_setup+0x8b>
mov    (%rbx),%rax
test   %rax,%rax
je     36f <_attachment_setup+0x41>
mov    %rax,0x8(%rsp)
addl   $0x1,(%rax)
jmp    37f <_attachment_setup+0x51>
lea    0x8(%rsp),%rdi
callq  379 <_attachment_setup+0x4b>
mov    %eax,%edx
test   %edx,%edx
jne    3b9 <_attachment_setup+0x8b>
mov    0x8(%rsp),%rbp
cmpq   $0x0,0x8(%rbp)
jne    3b1 <_attachment_setup+0x83>
mov    0x10(%rbp),%rdi
callq  394 <_attachment_setup+0x66>
mov    %rax,0x8(%rbp)
test   %rax,%rax
jne    3b1 <_attachment_setup+0x83>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  0 <_attachment_free>
mov    $0xc,%eax
jmp    3b9 <_attachment_setup+0x8b>
mov    %rbp,(%rbx)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_attachment_setup (mu_mime_io_buffer_t *pinfo, mu_message_t msg,
     mu_stream_t *stream)
{
  int ret;
  mu_body_t body;
  mu_mime_io_buffer_t info;
  if ((ret = mu_message_get_body (msg, &body)) != 0 ||
      (ret = mu_body_get_stream (body, stream)) != 0)
    return ret;
  if (*pinfo)
    {
      info = *pinfo;
      info->refcnt++;
    }
  else
    {
      ret = mu_mime_io_buffer_create (&info);
      if (ret)
 return ret;
    }
  if (!info->buf && ((info->buf = malloc (info->bufsize)) == ((void *)0)))
    {
      _attachment_free (info, 0);
      return 12;
    }
  *pinfo = info;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 10
19 10
20 10
21 12
22 13
23 13
24 17
25 17
26 17
27 18
28 18
29 21
30 21
31 21
32 21
33 21
34 21
35 21
36 21
37 23
38 23
39 23
40 24
41 24
42 26
43 27
44 28
45 28
46 28
47 28
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rdi        # 1588 <find_component_keyword+0x10>
test   %rdi,%rdi
je     15ac <find_component_keyword+0x34>
mov    $0x0,%ebx
mov    %rbp,%rsi
callq  159a <find_component_keyword+0x22>
test   %eax,%eax
je     15b3 <find_component_keyword+0x3b>
add    $0x48,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    1592 <find_component_keyword+0x1a>
jmp    15b8 <find_component_keyword+0x40>
mov    $0x0,%eax
jmp    15bd <find_component_keyword+0x45>
mov    %rbx,%rax
jmp    15bd <find_component_keyword+0x45>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
find_component_keyword (const char *ident)
{
  struct grecs_keyword *kwp;
  for (kwp = component_keywords; kwp->ident; kwp++)
    if (strcmp (kwp->ident, ident) == 0)
      return kwp;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 4
17 4
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rcx
movzwl (%rcx),%eax
test   %r8,%r8
je     12bb <gsl_vector_ushort_min+0x31>
lea    (%rdx,%rdx,1),%rdi
mov    $0x0,%edx
movzwl (%rcx),%esi
cmp    %si,%ax
cmova  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    12a6 <gsl_vector_ushort_min+0x1c>
repz retq 
<<<sep_in_sample>>>
gsl_vector_ushort_min (const gsl_vector_ushort * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned short min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned short x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 9
8 7
9 9
10 9
11 9
12 7
13 7
14 7
15 7
16 14
<<<sep_out_sample>>>
mov    (%rdi),%rdi
movslq 0x0(%rip),%rax        # 206 <linecmp+0xa>
lea    -0x1(%rdi,%rax,1),%rax
mov    (%rsi),%rcx
cmp    %rax,%rdi
jae    235 <linecmp+0x39>
movzbl (%rcx),%esi
cmp    %sil,(%rdi)
jne    23a <linecmp+0x3e>
mov    %rdi,%rdx
add    $0x1,%rdx
add    $0x1,%rcx
cmp    %rax,%rdx
je     23d <linecmp+0x41>
movzbl (%rcx),%esi
cmp    %sil,(%rdx)
je     21e <linecmp+0x22>
jmp    23d <linecmp+0x41>
mov    %rdi,%rdx
jmp    23d <linecmp+0x41>
mov    %rdi,%rdx
mov    %rdx,%rsi
sub    %rdi,%rsi
mov    0x0(%rip),%rax        # 24a <linecmp+0x4e>
cmpl   $0x0,(%rax,%rsi,4)
je     259 <linecmp+0x5d>
movsbl (%rdx),%eax
movsbl (%rcx),%edx
sub    %edx,%eax
retq   
movsbl (%rcx),%eax
movsbl (%rdx),%edx
sub    %edx,%eax
retq   
<<<sep_in_sample>>>
linecmp(char **s1, char **s2)
{
  char *t1, *t2;
  char *e1;
  for (e1 = *s1 + keylen - 1, t1 = *s1, t2 = *s2; t1 < e1 && *t1 == *t2; t1++, t2++)
    ;
  return (keymap[t1 - *s1] ? *t1 - *t2 : *t2 - *t1);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 8
<<<sep_out_sample>>>
mov    %rdi,%rdx
cmpq   $0x0,(%rdi)
je     92 <digest_md5_validate_response+0x68>
cmpq   $0x0,0x10(%rdi)
je     98 <digest_md5_validate_response+0x6e>
cmpq   $0x0,0x18(%rdi)
je     9e <digest_md5_validate_response+0x74>
cmpq   $0x0,0x20(%rdi)
je     a4 <digest_md5_validate_response+0x7a>
cmpq   $0x0,0x30(%rdi)
je     aa <digest_md5_validate_response+0x80>
cmpb   $0x0,0x50(%rdi)
je     b0 <digest_md5_validate_response+0x86>
lea    0x50(%rdi),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    $0xffffffff,%eax
cmp    $0xffffffffffffffde,%rcx
jne    b5 <digest_md5_validate_response+0x8b>
cmpl   $0x4,0x28(%rdx)
jne    85 <digest_md5_validate_response+0x5b>
cmpl   $0x0,0x44(%rdx)
sete   %al
movzbl %al,%eax
neg    %eax
retq   
cmpl   $0x0,0x44(%rdx)
setne  %al
movzbl %al,%eax
neg    %eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
repz retq 
<<<sep_in_sample>>>
digest_md5_validate_response (digest_md5_response * r)
{
  if (!r->username)
    return -1;
  if (!r->nonce)
    return -1;
  if (!r->cnonce)
    return -1;
  if (!r->nc)
    return -1;
  if (!r->digesturi)
    return -1;
  if (!*r->response)
    return -1;
  if (strlen (r->response) != 32)
    return -1;
  if (r->qop == DIGEST_MD5_QOP_AUTH_CONF && !r->cipher)
    return -1;
  if (r->qop != DIGEST_MD5_QOP_AUTH_CONF && r->cipher)
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 9
9 9
10 11
11 11
12 13
13 13
14 15
15 15
16 15
17 15
18 16
19 15
20 15
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 19
29 19
30 19
31 19
32 19
33 4
34 4
35 6
36 6
37 8
38 8
39 10
40 10
41 12
42 12
43 14
44 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
test   %edi,%edi
je     38e6 <posix_readline_initialize+0x21>
mov    $0x0,%esi
mov    $0x0,%edi
callq  38e1 <posix_readline_initialize+0x1c>
mov    $0x0,%esi
mov    $0x0,%edx
mov    $0x9,%edi
callq  38f5 <posix_readline_initialize+0x30>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
posix_readline_initialize (on_or_off)
     int on_or_off;
{
  if (on_or_off)
    rl_variable_bind ("comment-begin", "#");
  rl_bind_key_in_map ((('I') & 0x1f), on_or_off ? rl_insert : rl_complete, vi_insertion_keymap);
}
<<<sep_in_sample>>>
1 3
2 6
3 4
4 4
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
mov    0x20(%rdi),%rcx
mov    0x0(%rip),%rax        # 2690 <body+0xb>
cmpw   $0x0,0x6c(%rax)
jle    26bf <body+0x3a>
movzbl 0x5d(%rax),%edx
cmp    $0x46,%dl
je     26a5 <body+0x20>
cmp    $0x4f,%dl
jne    26ad <body+0x28>
mov    0x28(%rax),%rax
mov    0x20(%rax),%rax
cmp    %rcx,%rax
je     26c5 <body+0x40>
mov    0x18(%rax),%rax
cmpw   $0x0,0x6c(%rax)
jg     2697 <body+0x12>
jmp    26cb <body+0x46>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
body (decl_t *rd)
{
  block_t *rb, *rbx;
  rbx = cblock;
  rb = rd->descr;
  for (rbx= cblock; rbx->blev > 0; rbx= rbx->quant.encl)
    {
      if (rbx->quant.kind == 'O' || rbx->quant.kind == 'F')
 rbx= rbx->quant.match->descr;
      if (rbx == rb)
 return (1);
    }
  return (0);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 9
11 9
12 10
13 10
14 6
15 6
16 6
17 6
18 13
19 13
20 11
21 11
22 13
23 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c2ff <rpl_re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # c306 <rpl_re_set_syntax+0xe>
retq   
<<<sep_in_sample>>>
rpl_re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = rpl_re_syntax_options;
  rpl_re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
styled_ostream_free (styled_ostream_t first_arg)
{
  const struct styled_ostream_implementation *vtable =
    ((struct styled_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->free (first_arg);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 55f <swlib_get_io_req+0x7>
retq   
<<<sep_in_sample>>>
swlib_get_io_req(void)
{
 return io_req;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    0x10(%rdi),%eax
cmp    $0x2,%eax
jne    5970 <srcopen+0x19>
mov    0x0(%rip),%rdi        # 5967 <srcopen+0x10>
callq  596c <srcopen+0x15>
mov    %eax,%ebx
jmp    598d <srcopen+0x36>
sub    $0x3,%eax
mov    $0xffffffff,%ebx
cmp    $0x1,%eax
ja     599e <srcopen+0x47>
mov    0x20(%rdi),%rdi
mov    $0x0,%esi
callq  598b <srcopen+0x34>
mov    %eax,%ebx
cmp    $0xffffffff,%ebx
je     599e <srcopen+0x47>
mov    $0x0,%esi
mov    %ebx,%edi
callq  599e <srcopen+0x47>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
srcopen(SRCFILE *s)
{
 int fd = (-1);
 if (s->stype == SRC_STDIN)
  fd = fileno(stdin);
 else if (s->stype == SRC_FILE || s->stype == SRC_INC)
  fd = devopen(s->fullpath, "r");
 if (fd != (-1))
  os_setbinmode(fd, 0);
 return fd;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 6
10 3
11 6
12 6
13 7
14 7
15 7
16 7
17 8
18 8
19 9
20 9
21 9
22 11
23 11
24 11
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
debug_printf (const char *format, ...)
{
  va_list args;
  if (progcomp_debug == 0)
    return;
  __builtin_va_start(args,format);
  fprintf (stdout, "DEBUG: ");
  vfprintf (stdout, format, args);
  fprintf (stdout, "\n");
  rl_on_new_line ();
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 8a5 <rl_crlf+0xb>
mov    $0xa,%edi
callq  8af <rl_crlf+0x15>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_crlf ()
{
  _IO_putc ('\n', _rl_out_stream);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
push   %rbx
callq  389 <os_is_setuid+0x6>
mov    %eax,%ebx
callq  390 <os_is_setuid+0xd>
mov    %eax,%edx
mov    %ebx,%ebx
cmp    %rbx,%rdx
setne  %al
test   %rdx,%rdx
sete   %dl
movzbl %dl,%edx
and    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
os_is_setuid()
{
 long uid, euid;
 uid = getuid();
 euid = geteuid();
 return (euid == 0 && euid != uid);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3f0 <gsasl_client_callback_qop_get+0xa>
mov    0x60(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_qop_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_qop : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    %rdx,%rsi
mov    %ecx,%edx
mov    (%rdi),%rax
mov    0x28(%rax),%rcx
mov    %rbx,%rdi
callq  36c <swi_xfile_add_file_member+0x18>
mov    0x88(%rbx),%rdi
mov    %rax,%rsi
callq  37b <swi_xfile_add_file_member+0x27>
pop    %rbx
retq   
<<<sep_in_sample>>>
swi_xfile_add_file_member(SWI * swi, SWI_XFILE * xfile, char * name, int fd)
{
 SWI_FILE_MEMBER * s;
 s = swi_xfile_construct_file_member(xfile, name, fd,
     swi->xformatM->swvarfsM);
 cplob_add_nta(xfile->archive_filesM, (char*)s);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 8
13 8
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%rcx
mov    $0x83,%edx
mov    %edi,%esi
mov    $0x7a,%edi
callq  1b <condest_invtril+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
condest_invtril(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
{
  gsl_matrix * A = (gsl_matrix *) params;
  return gsl_blas_dtrsv(CblasLower, TransA, CblasNonUnit, A, x);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
mov    %rdi,%rax
cmp    %esi,0x18(%rdi)
jge    1a0 <strob_reopen_if+0x1c>
sub    $0x8,%rsp
movslq 0x14(%rdi),%rax
add    %rax,%rsi
callq  19c <strob_reopen_if+0x18>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
strob_reopen_if(STROB * strb, size_t reqd_length)
{
 if ((int)reqd_length > strb->reserve_){
  return strob_reopen(strb, reqd_length + strb->extra_);
 }
 return strb;
}
<<<sep_in_sample>>>
1 6
2 3
3 3
4 2
5 4
6 4
7 4
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    145 <argp_fmtstream_set_wmargin+0x1f>
callq  145 <argp_fmtstream_set_wmargin+0x1f>
mov    0x18(%rbx),%rax
mov    %rbp,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->wmargin;
  __fs->wmargin = __wmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3730 <finish_jit+0x9>
callq  3735 <finish_jit+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
finish_jit(void)
{
    jit_finish_debug();
    jit_finish_size();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_complex_float_data (const gsl_block_complex_float * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     d2d <needs_quotes+0x6b>
mov    %rdi,%rbp
callq  cd8 <needs_quotes+0x16>
mov    (%rax),%r8
mov    %rbp,%rax
lea    0x0(%rbp,%rbx,1),%rsi
movzbl (%rax),%edx
movsbq %dl,%rcx
testb  $0x8,(%r8,%rcx,2)
jne    d22 <needs_quotes+0x60>
lea    -0x2b(%rdx),%ecx
cmp    $0x4,%cl
jbe    d22 <needs_quotes+0x60>
cmp    $0x3d,%dl
je     d22 <needs_quotes+0x60>
lea    -0x5e(%rdx),%ecx
cmp    $0x1,%cl
jbe    d22 <needs_quotes+0x60>
cmp    $0x25,%dl
je     d22 <needs_quotes+0x60>
cmp    $0x40,%dl
je     d22 <needs_quotes+0x60>
cmp    $0x3a,%dl
je     d22 <needs_quotes+0x60>
cmp    $0x7b,%dl
je     d22 <needs_quotes+0x60>
sub    $0x7d,%edx
cmp    $0x1,%dl
ja     d34 <needs_quotes+0x72>
add    $0x1,%rax
cmp    %rsi,%rax
jne    ce3 <needs_quotes+0x21>
jmp    d3b <needs_quotes+0x79>
mov    $0x0,%eax
jmp    d40 <needs_quotes+0x7e>
mov    $0x1,%eax
jmp    d40 <needs_quotes+0x7e>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
needs_quotes(string, length)
    char *string;
    size_t length;
{
    size_t i;
    for (i = 0; i < length; i++)
 if (!((*__ctype_b_loc ())[(int) (((int)string[i]))] & (unsigned short int) _ISalnum) &&
     string[i] != '.' && string[i] != '-' &&
     string[i] != '+' && string[i] != '=' &&
     string[i] != '~' && string[i] != '^' &&
     string[i] != '%' && string[i] != '@' &&
     string[i] != '/' && string[i] != ':' &&
     string[i] != '{' && string[i] != '}' &&
     string[i] != ',' && string[i] != '_')
     return 1;
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 11
27 11
28 12
29 12
30 12
31 12
32 13
33 13
34 13
35 13
36 6
37 6
38 6
39 16
40 16
41 15
42 15
43 16
44 17
45 17
46 17
47 17
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmp    %rsi,(%rdi)
ja     6d0 <gsl_vector_complex_alloc_row_from_matrix+0x31>
mov    $0x4,%ecx
mov    $0xb5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6c9 <gsl_vector_complex_alloc_row_from_matrix+0x2a>
mov    $0x0,%eax
jmp    72a <gsl_vector_complex_alloc_row_from_matrix+0x8b>
mov    $0x28,%edi
callq  6da <gsl_vector_complex_alloc_row_from_matrix+0x3b>
test   %rax,%rax
jne    6ff <gsl_vector_complex_alloc_row_from_matrix+0x60>
mov    $0x8,%ecx
mov    $0xbd,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6f8 <gsl_vector_complex_alloc_row_from_matrix+0x59>
mov    $0x0,%eax
jmp    72a <gsl_vector_complex_alloc_row_from_matrix+0x8b>
mov    0x10(%rbx),%rdx
shl    $0x4,%rdx
imul   %rdx,%rbp
add    0x18(%rbx),%rbp
mov    %rbp,0x10(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,(%rax)
movq   $0x1,0x8(%rax)
movq   $0x0,0x18(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_alloc_row_from_matrix (gsl_matrix_complex * m,
                                              const size_t i)
{
  gsl_vector_complex * v;
  const size_t M = m->size1;
  if (i >= M)
    {
      do { gsl_error ("row index is out of range", "getset_source.c", 181, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_complex *) malloc (sizeof (gsl_vector_complex));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 189
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 2 * i * m->tda ;
  v->size = m->size2;
  v->stride = 1;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 11
18 11
19 13
20 13
21 13
22 13
23 13
24 17
25 17
26 20
27 20
28 20
29 20
30 20
31 21
32 21
33 22
34 23
35 25
36 25
37 25
38 25
<<<sep_out_sample>>>
push   %rbx
mov    $0x8,%edi
callq  b <assoc_open+0xb>
mov    %rax,%rbx
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x180,%edx
mov    $0x242,%esi
mov    $0x0,%edi
callq  2d <assoc_open+0x2d>
mov    %rax,(%rbx)
test   %rax,%rax
jne    3f <assoc_open+0x3f>
mov    $0x0,%edi
callq  3f <assoc_open+0x3f>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
assoc_open(void)
{
 ASSOC *assoc = (ASSOC *)check_malloc(sizeof(ASSOC));
 assoc->db = dbopen(((void *)0), 02|0100|01000, 0600, DB_BTREE, ((void *)0));
 if (assoc->db == ((void *)0))
  die("cannot make associate array.");
 return assoc;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
cmpl   $0x4,0x0(%rip)        # 1ee9 <print_header+0x14>
jne    1f0a <print_header+0x35>
cmpb   $0x0,0x0(%rip)        # 1ef2 <print_header+0x1d>
jne    1f0a <print_header+0x35>
cmpq   $0x0,0x0(%rip)        # 1efc <print_header+0x27>
je     1f0a <print_header+0x35>
callq  1dee <print_volume_label>
movb   $0x1,0x0(%rip)        # 1f0a <print_header+0x35>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1826 <simple_print_header>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_header (struct tar_stat_info *st, union block *blk,
       off_t block_ordinal)
{
  if (current_format == POSIX_FORMAT && !volume_label_printed && volume_label)
    {
      print_volume_label ();
      volume_label_printed = 1;
    }
  simple_print_header (st, blk, block_ordinal);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 7
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
fstpt  (%rsp)
lea    0x1c(%rsp),%rdi
callq  31 <printf_frexpl+0x31>
fadd   %st(0),%st
mov    0x1c(%rsp),%edx
lea    -0x1(%rdx),%eax
mov    %eax,0x1c(%rsp)
cmp    $0xffffc002,%eax
jge    5b <printf_frexpl+0x5b>
lea    0x3ffd(%rdx),%edi
fstpt  (%rsp)
callq  53 <printf_frexpl+0x53>
movl   $0xffffc002,0x1c(%rsp)
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    0x1c(%rsp),%eax
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 15
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  d91 <gsl_block_short_calloc+0xe>
mov    %rax,%rbp
test   %rax,%rax
je     dca <gsl_block_short_calloc+0x47>
lea    (%rbx,%rbx,1),%rdx
mov    0x8(%rax),%rdi
mov    $0x0,%esi
callq  dab <gsl_block_short_calloc+0x28>
test   %rbx,%rbx
je     dd1 <gsl_block_short_calloc+0x4e>
mov    $0x0,%edx
mov    0x8(%rbp),%rcx
movw   $0x0,(%rcx,%rdx,2)
add    $0x1,%rdx
cmp    %rbx,%rdx
jne    db5 <gsl_block_short_calloc+0x32>
jmp    dd6 <gsl_block_short_calloc+0x53>
mov    $0x0,%eax
jmp    dd9 <gsl_block_short_calloc+0x56>
mov    %rbp,%rax
jmp    dd9 <gsl_block_short_calloc+0x56>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_block_short_calloc (const size_t n)
{
  size_t i;
  gsl_block_short * b = gsl_block_short_alloc (n);
  if (b == 0)
    return 0;
  memset(b->data, 0, 1 * n * sizeof(short));
  for (i = 0; i < 1 * n; i++)
    {
      b->data[i] = 0;
    }
  return b;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 10
17 10
18 8
19 8
20 8
21 8
22 6
23 6
24 12
25 12
26 12
27 13
28 13
29 13
30 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
movzwl (%rdi),%r8d
mov    $0x0,%ebp
mov    $0x0,%ebx
test   %r10,%r10
je     13d8 <gsl_vector_ushort_minmax_index+0x49>
jmp    13e0 <gsl_vector_ushort_minmax_index+0x51>
movzwl (%rdi),%ecx
cmp    %cx,%r8w
jbe    13c0 <gsl_vector_ushort_minmax_index+0x31>
mov    %ecx,%r8d
mov    %rax,%rbx
add    %r11,%rdi
cmp    %r9w,%cx
jbe    13cf <gsl_vector_ushort_minmax_index+0x40>
mov    %ecx,%r9d
mov    %rax,%rbp
add    $0x1,%rax
cmp    %r10,%rax
jne    13b1 <gsl_vector_ushort_minmax_index+0x22>
mov    %rbx,(%rsi)
mov    %rbp,(%rdx)
jmp    13fd <gsl_vector_ushort_minmax_index+0x6e>
add    %r11,%r11
add    %r11,%rdi
mov    %r8d,%r9d
mov    %r8d,%ecx
mov    $0x0,%eax
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    13c3 <gsl_vector_ushort_minmax_index+0x34>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_ushort_minmax_index (const gsl_vector_ushort * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  unsigned short max = v->data[0 * stride];
  unsigned short min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned short x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 8
7 7
8 7
9 11
10 11
11 11
12 13
13 14
14 14
15 13
16 11
17 11
18 19
19 19
20 19
21 19
22 11
23 11
24 11
25 25
26 26
27 26
28 13
29 13
30 8
31 13
32 11
33 7
34 7
35 7
36 27
37 27
38 27
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  401 <open_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
open_error (char const *name)
{
  call_arg_error ("open", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rdi),%r12
mov    0x8(%rdi),%r13
mov    0x10(%rdi),%rbp
movss  0x0(%rbp),%xmm3
movss  %xmm3,0xc(%rsp)
test   %r12,%r12
jne    81b <gsl_vector_float_max+0x71>
movss  %xmm3,0x8(%rsp)
jmp    835 <gsl_vector_float_max+0x8b>
movss  0x0(%rbp),%xmm1
movss  %xmm1,0x8(%rsp)
movss  0xc(%rsp),%xmm2
maxss  %xmm2,%xmm1
movss  %xmm1,0xc(%rsp)
add    %r13,%rbp
movss  0x8(%rsp),%xmm0
callq  800 <gsl_vector_float_max+0x56>
test   %eax,%eax
jne    835 <gsl_vector_float_max+0x8b>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    7d7 <gsl_vector_float_max+0x2d>
movss  0xc(%rsp),%xmm5
movss  %xmm5,0x8(%rsp)
jmp    835 <gsl_vector_float_max+0x8b>
shl    $0x2,%r13
add    %r13,%rbp
movss  0xc(%rsp),%xmm4
movss  %xmm4,0x8(%rsp)
mov    $0x0,%ebx
jmp    7f5 <gsl_vector_float_max+0x4b>
movss  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_vector_float_max (const gsl_vector_float * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  float max = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      float x = v->data[i*stride];
      if (x > max)
        max = x;
      if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
        return x;
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 7
12 7
13 5
14 5
15 9
16 9
17 10
18 9
19 9
20 9
21 12
22 12
23 12
24 12
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 9
34 9
35 7
36 7
37 16
38 16
39 16
40 16
41 16
42 16
43 16
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0xc0800000,%esi
callq  d233 <_sse_bunlti_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c657 <_sse_movi_d>
mov    0x0(%r12),%ecx
and    $0x7fff,%ecx
mov    %r14d,%edx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  123f <_sse_bunltr_d>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d285 <_sse_bunlti_d+0x76>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_sse_bunlti_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_bunltr_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
callq  4c5 <dicod_status+0xe>
cmpl   $0x0,0x0(%rip)        # 4cc <dicod_status+0x15>
je     4ea <dicod_status+0x33>
mov    $0x0,%edi
callq  4d8 <dicod_status+0x21>
mov    $0x0,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  4e8 <dicod_status+0x31>
jmp    4f7 <dicod_status+0x40>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  4f7 <dicod_status+0x40>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  504 <dicod_status+0x4d>
pop    %rbx
retq   
<<<sep_in_sample>>>
dicod_status(dico_stream_t str, int argc, char **argv)
{
    stream_writez(str, "210");
    if (timing_option)
 report_timing(str, timer_stop("dicod"), &total_stat);
    else
 stream_writez(str, " No timing data available");
    stream_writez(str, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # b <do_first_file+0xb>
retq   
<<<sep_in_sample>>>
do_first_file(void)
{
    selected = 0;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    $0x0,%esi
callq  f21 <cmdline_parser_file_save+0x14>
mov    %rax,%rbx
test   %rax,%rax
jne    f4e <cmdline_parser_file_save+0x41>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # f3d <cmdline_parser_file_save+0x30>
mov    $0x0,%eax
callq  f47 <cmdline_parser_file_save+0x3a>
mov    $0x1,%eax
jmp    f65 <cmdline_parser_file_save+0x58>
mov    %r12,%rsi
mov    %rax,%rdi
callq  f59 <cmdline_parser_file_save+0x4c>
mov    %eax,%ebp
mov    %rbx,%rdi
callq  f63 <cmdline_parser_file_save+0x56>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;
  outfile = fopen(filename, "w");
  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", "gengen", filename);
      return 1;
    }
  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);
  return i;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 9
18 9
19 11
20 11
21 11
22 11
23 12
24 12
25 13
26 14
27 14
28 14
29 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 5f1 <do_statusbar_backspace+0x7>
test   %rsi,%rsi
je     616 <do_statusbar_backspace+0x2c>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 601 <do_statusbar_backspace+0x17>
callq  606 <do_statusbar_backspace+0x1c>
mov    %rax,0x0(%rip)        # 60d <do_statusbar_backspace+0x23>
callq  612 <do_statusbar_backspace+0x28>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
do_statusbar_backspace(void)
{
    if (statusbar_x > 0) {
 statusbar_x = move_mbleft(answer, statusbar_x);
 do_statusbar_delete();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 5
9 7
10 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rdi
callq  2a9 <xformat_vfile_hdr+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_vfile_hdr(XFORMAT * xux)
{
 ;
 return ahs_vfile_hdr(xux->ahsM);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 46 <pushback+0x7>
jle    61 <pushback+0x22>
mov    0x0(%rip),%eax        # 4e <pushback+0xf>
lea    -0x1(%rax),%edx
test   %eax,%eax
mov    $0x7f,%eax
cmovne %edx,%eax
mov    %eax,0x0(%rip)        # 61 <pushback+0x22>
cmpb   $0x0,0x0(%rip)        # 68 <pushback+0x29>
jne    8a <pushback+0x4b>
mov    0x0(%rip),%rax        # 71 <pushback+0x32>
test   %rax,%rax
je     8a <pushback+0x4b>
cmp    0x0(%rip),%rax        # 7d <pushback+0x3e>
jbe    8a <pushback+0x4b>
sub    $0x1,%rax
mov    %rax,0x0(%rip)        # 8a <pushback+0x4b>
repz retq 
<<<sep_in_sample>>>
pushback(void)
{
 if (gawk_mb_cur_max > 1)
  cur_ring_idx = (cur_ring_idx == 0)? (8 * 16) - 1 :
   cur_ring_idx - 1;
 (! lexeof && lexptr && lexptr > lexptr_begin ? lexptr-- : lexptr);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
test   %rdx,%rdx
je     bc <_gdbm_full_write+0x5b>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  81 <_gdbm_full_write+0x20>
cmp    $0xffffffffffffffff,%rax
jne    98 <_gdbm_full_write+0x37>
callq  8c <_gdbm_full_write+0x2b>
cmpl   $0x4,(%rax)
je     b5 <_gdbm_full_write+0x54>
mov    $0x4,%eax
jmp    c8 <_gdbm_full_write+0x67>
test   %rax,%rax
jne    af <_gdbm_full_write+0x4e>
callq  a2 <_gdbm_full_write+0x41>
movl   $0x1c,(%rax)
mov    $0x4,%eax
jmp    c8 <_gdbm_full_write+0x67>
add    %rax,%rbp
sub    %rax,%rbx
test   %rbx,%rbx
jne    73 <_gdbm_full_write+0x12>
jmp    c3 <_gdbm_full_write+0x62>
mov    $0x0,%eax
jmp    c8 <_gdbm_full_write+0x67>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_gdbm_full_write (GDBM_FILE dbf, void *buffer, size_t size)
{
  char *ptr = buffer;
  while (size)
    {
      ssize_t wrbytes = _gdbm_mapped_write(dbf, ptr, size);
      if (wrbytes == -1)
 {
   if ((*__errno_location ()) == 4)
     continue;
   return 4;
 }
      if (wrbytes == 0)
 {
   (*__errno_location ()) = 28;
   return 4;
 }
      ptr += wrbytes;
      size -= wrbytes;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 13
21 13
22 15
23 15
24 16
25 16
26 18
27 19
28 4
29 4
30 4
31 21
32 21
33 21
34 22
35 22
36 22
37 22
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x8(%rsp)
mov    (%rdi),%rbp
mov    0x8(%rdi),%r12
ucomisd %xmm1,%xmm0
jb     5a7 <gsl_histogram2d_set_ranges_uniform+0x3e>
mov    $0x4,%ecx
mov    $0xee,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5a5 <gsl_histogram2d_set_ranges_uniform+0x3c>
jmp    619 <gsl_histogram2d_set_ranges_uniform+0xb0>
movsd  (%rsp),%xmm4
ucomisd 0x8(%rsp),%xmm4
jb     5cf <gsl_histogram2d_set_ranges_uniform+0x66>
mov    $0x4,%ecx
mov    $0xf3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5cd <gsl_histogram2d_set_ranges_uniform+0x64>
jmp    619 <gsl_histogram2d_set_ranges_uniform+0xb0>
mov    0x10(%rdi),%rdi
mov    %rbp,%rsi
callq  0 <make_uniform>
mov    0x18(%rbx),%rdi
movsd  0x8(%rsp),%xmm1
movsd  (%rsp),%xmm0
mov    %r12,%rsi
callq  0 <make_uniform>
mov    %r12,%rsi
imul   %rbp,%rsi
test   %rsi,%rsi
je     619 <gsl_histogram2d_set_ranges_uniform+0xb0>
mov    $0x0,%eax
xorpd  %xmm0,%xmm0
mov    0x20(%rbx),%rdx
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rsi,%rax
jne    607 <gsl_histogram2d_set_ranges_uniform+0x9e>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_histogram2d_set_ranges_uniform (gsl_histogram2d * h,
                                    double xmin, double xmax,
                                    double ymin, double ymax)
{
  size_t i;
  const size_t nx = h->nx, ny = h->ny;
  if (xmin >= xmax)
    {
      do { gsl_error ("xmin must be less than xmax", "init2d.c", 238, GSL_EINVAL) ; return 0 ; } while (0);
    }
  if (ymin >= ymax)
    {
      do { gsl_error ("ymin must be less than ymax", "init2d.c", 243, GSL_EINVAL) ; return 0 ; } while (0);
    }
  make_uniform (h->xrange, nx, xmin, xmax);
  make_uniform (h->yrange, ny, ymin, ymax);
  for (i = 0; i < nx * ny; i++)
    {
      h->bin[i] = 0;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 13
27 15
28 15
29 15
30 16
31 16
32 16
33 16
34 16
35 17
36 17
37 17
38 17
39 17
40 19
41 19
42 19
43 17
44 17
45 17
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,0x8(%rsp)
ucomisd 0x0(%rip),%xmm0        # 396 <gsl_cdf_ugaussian_Pinv+0x12>
jp     3a6 <gsl_cdf_ugaussian_Pinv+0x22>
movsd  0x0(%rip),%xmm0        # 3a0 <gsl_cdf_ugaussian_Pinv+0x1c>
je     488 <gsl_cdf_ugaussian_Pinv+0x104>
movsd  0x8(%rsp),%xmm4
ucomisd 0x0(%rip),%xmm4        # 3b4 <gsl_cdf_ugaussian_Pinv+0x30>
jp     3c4 <gsl_cdf_ugaussian_Pinv+0x40>
movsd  0x0(%rip),%xmm0        # 3be <gsl_cdf_ugaussian_Pinv+0x3a>
je     488 <gsl_cdf_ugaussian_Pinv+0x104>
movsd  0x8(%rsp),%xmm0
subsd  0x0(%rip),%xmm0        # 3d2 <gsl_cdf_ugaussian_Pinv+0x4e>
movsd  0x0(%rip),%xmm1        # 3da <gsl_cdf_ugaussian_Pinv+0x56>
andpd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm2        # 3e6 <gsl_cdf_ugaussian_Pinv+0x62>
ucomisd %xmm1,%xmm2
jb     3f6 <gsl_cdf_ugaussian_Pinv+0x72>
callq  41 <small>
jmpq   488 <gsl_cdf_ugaussian_Pinv+0x104>
movsd  0x8(%rsp),%xmm6
movapd %xmm6,%xmm0
movsd  0x0(%rip),%xmm1        # 408 <gsl_cdf_ugaussian_Pinv+0x84>
ucomisd %xmm6,%xmm1
ja     41a <gsl_cdf_ugaussian_Pinv+0x96>
movsd  0x0(%rip),%xmm0        # 416 <gsl_cdf_ugaussian_Pinv+0x92>
subsd  %xmm6,%xmm0
callq  41f <gsl_cdf_ugaussian_Pinv+0x9b>
movsd  0x0(%rip),%xmm1        # 427 <gsl_cdf_ugaussian_Pinv+0xa3>
xorpd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    44a <gsl_cdf_ugaussian_Pinv+0xc6>
movsd  0x0(%rip),%xmm1        # 43d <gsl_cdf_ugaussian_Pinv+0xb9>
xorpd  %xmm1,%xmm0
callq  446 <gsl_cdf_ugaussian_Pinv+0xc2>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 452 <gsl_cdf_ugaussian_Pinv+0xce>
ucomisd %xmm1,%xmm0
jb     463 <gsl_cdf_ugaussian_Pinv+0xdf>
movapd %xmm1,%xmm0
callq  16a <intermediate>
jmp    46c <gsl_cdf_ugaussian_Pinv+0xe8>
movapd %xmm1,%xmm0
callq  277 <tail>
movsd  0x0(%rip),%xmm1        # 474 <gsl_cdf_ugaussian_Pinv+0xf0>
ucomisd 0x8(%rsp),%xmm1
jbe    488 <gsl_cdf_ugaussian_Pinv+0x104>
movsd  0x0(%rip),%xmm1        # 484 <gsl_cdf_ugaussian_Pinv+0x100>
xorpd  %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_ugaussian_Pinv (const double P)
{
  double r, x, pp;
  double dP = P - 0.5;
  if (P == 1.0)
    {
      return (__builtin_inff());
    }
  else if (P == 0.0)
    {
      return (-(__builtin_inff()));
    }
  if (fabs (dP) <= 0.425)
    {
      x = small (dP);
      return x;
    }
  pp = (P < 0.5) ? P : 1.0 - P;
  r = sqrt (-log (pp));
  if (r <= 5.0)
    {
      x = intermediate (r);
    }
  else
    {
      x = tail (r);
    }
  if (P < 0.5)
    {
      return -x;
    }
  else
    {
      return x;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 7
6 5
7 9
8 9
9 9
10 11
11 9
12 4
13 4
14 13
15 13
16 13
17 13
18 13
19 15
20 16
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 19
29 19
30 19
31 19
32 19
33 19
34 19
35 19
36 19
37 19
38 20
39 20
40 20
41 22
42 22
43 22
44 26
45 26
46 28
47 28
48 28
49 30
50 30
51 36
52 36
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 5a4 <terminal_begin_underline+0xb>
test   %rdx,%rdx
je     5b2 <terminal_begin_underline+0x19>
mov    $0x0,%eax
callq  *%rdx
jmp    5cd <terminal_begin_underline+0x34>
mov    0x0(%rip),%rdi        # 5b9 <terminal_begin_underline+0x20>
test   %rdi,%rdi
je     5cd <terminal_begin_underline+0x34>
mov    $0x0,%edx
mov    $0x1,%esi
callq  5cd <terminal_begin_underline+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_begin_underline (void)
{
  if (terminal_begin_underline_hook)
    (*terminal_begin_underline_hook) ();
  else
    {
      do { if (term_us) tputs (term_us, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
lea    0x8(%rsp),%rdi
callq  a47 <osip_message_set_body+0x1b>
mov    %eax,%ecx
test   %ecx,%ecx
jne    a96 <osip_message_set_body+0x6a>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    0x8(%rsp),%rdi
callq  a5d <osip_message_set_body+0x31>
mov    %eax,%ebp
test   %eax,%eax
je     a71 <osip_message_set_body+0x45>
mov    0x8(%rsp),%rdi
callq  a6d <osip_message_set_body+0x41>
mov    %ebp,%eax
jmp    a96 <osip_message_set_body+0x6a>
movl   $0x2,0x1a0(%rbx)
lea    0x190(%rbx),%rdi
mov    $0xffffffff,%edx
mov    0x8(%rsp),%rsi
callq  a91 <osip_message_set_body+0x65>
mov    $0x0,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_set_body (osip_message_t * sip, const char *buf, size_t length)
{
  osip_body_t *body;
  int i;
  i = osip_body_init (&body);
  if (i != 0)
    return i;
  i = osip_body_parse (body, buf, length);
  if (i != 0) {
    osip_body_free (body);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->bodies, body, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 10
21 10
22 11
23 11
24 13
25 14
26 14
27 14
28 14
29 15
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
movq   %xmm0,-0x8(%rsp)
mov    -0x8(%rsp),%rsi
mov    0x10(%rdi),%rdx
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdi
test   %rcx,%rcx
je     be2 <gsl_vector_complex_float_set_all+0x33>
shl    $0x3,%rdi
mov    $0x0,%eax
mov    %rsi,(%rdx)
add    $0x1,%rax
add    %rdi,%rdx
cmp    %rcx,%rax
jne    bd3 <gsl_vector_complex_float_set_all+0x24>
repz retq 
<<<sep_in_sample>>>
gsl_vector_complex_float_set_all (gsl_vector_complex_float * v, gsl_complex_float x)
{
  float * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(gsl_complex_float *) (data + 2 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 5
6 7
7 7
8 9
9 7
10 9
11 7
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm4
movsd  %xmm0,0x8(%rsp)
ucomisd 0x0(%rip),%xmm0        # 1b41 <gsl_complex_arctanh_real+0x16>
jbe    1b60 <gsl_complex_arctanh_real+0x35>
movsd  0x0(%rip),%xmm0        # 1b4b <gsl_complex_arctanh_real+0x20>
ucomisd %xmm4,%xmm0
jbe    1b60 <gsl_complex_arctanh_real+0x35>
movapd %xmm4,%xmm0
callq  1b5a <gsl_complex_arctanh_real+0x2f>
xorpd  %xmm1,%xmm1
jmp    1b9e <gsl_complex_arctanh_real+0x73>
movsd  0x0(%rip),%xmm0        # 1b68 <gsl_complex_arctanh_real+0x3d>
divsd  0x8(%rsp),%xmm0
callq  1b73 <gsl_complex_arctanh_real+0x48>
movsd  0x8(%rsp),%xmm2
cmpltsd 0x0(%rip),%xmm2        # 1b82 <gsl_complex_arctanh_real+0x57>
movsd  0x0(%rip),%xmm1        # 1b8a <gsl_complex_arctanh_real+0x5f>
andpd  %xmm2,%xmm1
movsd  0x0(%rip),%xmm3        # 1b96 <gsl_complex_arctanh_real+0x6b>
andnpd %xmm3,%xmm2
orpd   %xmm2,%xmm1
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_arctanh_real (double a)
{
  gsl_complex z;
  if (a > -1.0 && a < 1.0)
    {
      do {(&z)->dat[0]=(atanh (a)); (&z)->dat[1]=(0);} while(0);
    }
  else
    {
      do {(&z)->dat[0]=(atanh (1 / a)); (&z)->dat[1]=((a < 0) ? 1.57079632679489661923 : -1.57079632679489661923);} while(0);
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 13
24 13
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%r8
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
cmpl   $0x0,0x0(%rip)        # 392 <_rl_char_value+0x1f>
je     39d <_rl_char_value+0x2a>
movslq %esi,%rsi
movsbl (%rdi,%rsi,1),%eax
jmp    3fc <_rl_char_value+0x89>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
lea    -0x1(%rcx),%eax
cmp    %eax,%esi
jl     3c3 <_rl_char_value+0x50>
movslq %esi,%rsi
movsbl (%r8,%rsi,1),%eax
jmp    3fc <_rl_char_value+0x89>
movq   $0x0,0x10(%rsp)
movslq %esi,%rbx
add    %r8,%rbx
sub    %esi,%ecx
movslq %ecx,%rdx
lea    0x10(%rsp),%rcx
mov    %rbx,%rsi
lea    0xc(%rsp),%rdi
callq  3e9 <_rl_char_value+0x76>
sub    $0x1,%rax
cmp    $0xfffffffffffffffc,%rax
jbe    3f8 <_rl_char_value+0x85>
movsbl (%rbx),%eax
jmp    3fc <_rl_char_value+0x89>
mov    0xc(%rsp),%eax
mov    0x18(%rsp),%rdx
xor    %fs:0x28,%rdx
je     411 <_rl_char_value+0x9e>
callq  411 <_rl_char_value+0x9e>
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_char_value (buf, ind)
     char *buf;
     int ind;
{
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;
  if (16 == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (((tmp) == (size_t)-1 || (tmp) == (size_t)-2) || ((tmp) == 0))
    return ((wchar_t) buf[ind]);
  return wc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 9
8 9
9 10
10 10
11 10
12 11
13 11
14 11
15 11
16 11
17 12
18 12
19 12
20 13
21 13
22 13
23 14
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 16
33 16
34 16
35 17
36 17
37 18
38 19
39 19
40 19
41 19
42 19
43 19
44 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rbp        # 10 <usage+0x10>
mov    $0x0,%edi
callq  1a <usage+0x1a>
mov    %rbp,%rcx
mov    %rbp,%rdx
mov    %rax,%rsi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  30 <usage+0x30>
mov    $0x0,%edi
callq  3a <usage+0x3a>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  45 <usage+0x45>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
usage (FILE *stream)
{
  fprintf (stream, gettext ("Usage: %s [--version | --help]\nor     %s most_common_bigrams < file-list > locate-database\n")
                                                               ,
    program_name, program_name);
  fputs (gettext ("\nReport bugs to <bug-findutils@gnu.org>.\n"), stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xe8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
test   %al,%al
je     20e <grecs_warning+0x5b>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,0x10(%rsp)
movl   $0x18,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
lea    0x100(%rsp),%rax
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
mov    %rax,0x28(%rsp)
lea    0x18(%rsp),%rcx
lea    0x10(%rsp),%rsi
lea    0x8(%rsp),%rdi
callq  25b <grecs_warning+0xa8>
test   %eax,%eax
je     264 <grecs_warning+0xb1>
callq  264 <grecs_warning+0xb1>
mov    0x8(%rsp),%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x0(%rip)        # 279 <grecs_warning+0xc6>
mov    0x8(%rsp),%rdi
callq  283 <grecs_warning+0xd0>
add    $0xe8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_warning(grecs_locus_t const *locus, int errcode, const char *fmt, ...)
{
 va_list ap;
 char *buf = ((void *)0);
 size_t size = 0;
 __builtin_va_start(ap,fmt);
 if (grecs_vasprintf(&buf, &size, fmt, ap))
  grecs_alloc_die();
 __builtin_va_end(ap);
 grecs_print_diag_fun(locus, 0, errcode, buf);
 free(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 5
21 6
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 12
42 12
43 12
44 12
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x58,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
movl   $0x8,0x8(%rsp)
lea    0x90(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    %edi,%ebp
mov    $0x0,%r13d
mov    $0xffffffffffffffff,%r14
jmpq   3d1 <concat+0xf8>
mov    0x8(%rsp),%eax
cmp    $0x30,%eax
jae    34c <concat+0x73>
mov    %eax,%edx
add    0x18(%rsp),%rdx
add    $0x8,%eax
mov    %eax,0x8(%rsp)
jmp    35a <concat+0x81>
mov    0x10(%rsp),%rdx
lea    0x8(%rdx),%rax
mov    %rax,0x10(%rsp)
mov    (%rdx),%rbx
test   %rbx,%rbx
je     3ce <concat+0xf5>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
test   %r12d,%r12d
je     3ce <concat+0xf5>
lea    0x0(%r13,%r12,1),%r15d
mov    0x0(%rip),%eax        # 386 <concat+0xad>
cmp    %eax,%r15d
jbe    3b3 <concat+0xda>
test   %eax,%eax
mov    $0x3c,%esi
cmovne %eax,%esi
add    %r12d,%esi
add    %esi,%esi
mov    %esi,0x0(%rip)        # 3a0 <concat+0xc7>
mov    0x0(%rip),%rdi        # 3a7 <concat+0xce>
callq  3ac <concat+0xd3>
mov    %rax,0x0(%rip)        # 3b3 <concat+0xda>
mov    %r13d,%r13d
mov    %r13,%rdi
add    0x0(%rip),%rdi        # 3c0 <concat+0xe7>
mov    %r12d,%edx
mov    %rbx,%rsi
callq  3cb <concat+0xf2>
mov    %r15d,%r13d
sub    $0x1,%ebp
test   %ebp,%ebp
jne    333 <concat+0x5a>
cmp    0x0(%rip),%r13d        # 3e0 <concat+0x107>
jne    40b <concat+0x132>
lea    0x0(%r13,%r13,1),%esi
test   %r13d,%r13d
mov    $0x78,%eax
cmove  %eax,%esi
mov    %esi,0x0(%rip)        # 3f8 <concat+0x11f>
mov    0x0(%rip),%rdi        # 3ff <concat+0x126>
callq  404 <concat+0x12b>
mov    %rax,0x0(%rip)        # 40b <concat+0x132>
mov    0x0(%rip),%rax        # 412 <concat+0x139>
mov    %r13d,%r13d
movb   $0x0,(%rax,%r13,1)
add    $0x58,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
concat (unsigned int num, ...)
{
  static unsigned int rlen = 0;
  static char *result = ((void *)0);
  unsigned int ri = 0;
  va_list args;
  __builtin_va_start(args,num);
  while (num-- > 0)
    {
      const char *s = __builtin_va_arg(args,const char *);
      unsigned int l = ((s)==((void *)0) ? 0 : strlen (s));
      if (l == 0)
        continue;
      if (ri + l > rlen)
        {
          rlen = ((rlen ? rlen : 60) + l) * 2;
          result = xrealloc (result, rlen);
        }
      memcpy (result + ri, s, l);
      ri += l;
    }
  __builtin_va_end(args);
  if (ri == rlen)
    {
      rlen = (rlen ? rlen : 60) * 2;
      result = xrealloc (result, rlen);
    }
  result[ri] = '\0';
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 7
14 7
15 7
16 7
17 7
18 8
19 5
20 11
21 8
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 11
42 12
43 12
44 14
45 14
46 14
47 14
48 16
49 16
50 16
51 16
52 16
53 16
54 17
55 17
56 17
57 19
58 19
59 19
60 19
61 19
62 19
63 20
64 20
65 8
66 8
67 23
68 23
69 25
70 25
71 25
72 25
73 25
74 26
75 26
76 26
77 28
78 28
79 28
80 30
81 30
82 30
83 30
84 30
85 30
86 30
87 30
<<<sep_out_sample>>>
movslq %edi,%rdi
imul   $0x3a8,%rdi,%rdi
add    0x0(%rip),%rdi        # b5 <setPosData+0x11>
mov    $0x0,%eax
movsd  (%rsi,%rax,1),%xmm0
movsd  %xmm0,0x2a8(%rdi)
movsd  (%rdx,%rax,1),%xmm0
movsd  %xmm0,0x2c0(%rdi)
movsd  (%rcx,%rax,1),%xmm0
movsd  %xmm0,0x2d8(%rdi)
movsd  (%r8,%rax,1),%xmm0
movsd  %xmm0,0x2f0(%rdi)
movsd  (%r9,%rax,1),%xmm0
movsd  %xmm0,0x308(%rdi)
add    $0x8,%rax
add    $0x8,%rdi
cmp    $0x18,%rax
jne    ba <setPosData+0x16>
repz retq 
<<<sep_in_sample>>>
setPosData(int eid, double loc[3], double vel[3], double linAcc[3],
     double ori[3], double angVel[3])
{
 int i;
 for (i = 0; i < 3; i++) {
  entities[eid].location[i] = loc[i];
  entities[eid].velocity[i] = vel[i];
  entities[eid].linearAcceleration[i] = linAcc[i];
  entities[eid].orientation[i] = ori[i];
  entities[eid].angularVelocity[i] = angVel[i];
 }
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 7
8 7
9 8
10 8
11 9
12 9
13 10
14 10
15 10
16 10
17 5
18 5
19 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
mov    $0x20,%edi
callq  10d6 <debpsf_write_psf+0x14>
mov    %rax,%rbx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  10e4 <debpsf_write_psf+0x22>
mov    %eax,%edx
test   %edx,%edx
js     111a <debpsf_write_psf+0x58>
mov    (%rbx),%rsi
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %r12d,%edi
callq  110d <debpsf_write_psf+0x4b>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  1118 <debpsf_write_psf+0x56>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
debpsf_write_psf(void * v_topsf, int ofd)
{
 int ret;
 STROB * psf;
 psf = strob_open(32);
 ret = debpsf_write_psf_buf(v_topsf, psf);
 if (ret < 0) return ret;
 ret = uxfio_write(ofd, psf->str_, strlen((char*)(psf->str_)));
 strob_close(psf);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 9
27 10
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
mov    %r9,%rdi
callq  c13 <s_stringz+0x26>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
s_stringz (struct xdatum *xd, char *str)
{
  xd_store (xd, str, strlen (str) + 1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
mov    $0x8970,%esi
mov    $0x0,%eax
callq  13a0 <fh_map_query+0x22>
test   %eax,%eax
js     13b8 <fh_map_query+0x3a>
mov    $0x0,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  13b6 <fh_map_query+0x38>
jmp    13ca <fh_map_query+0x4c>
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  13ca <fh_map_query+0x4c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_map_query (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x8970, form->ifr) >= 0)
    select_arg (form, argc, argv, 0);
  else
    select_arg (form, argc, argv, 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 7
26 7
27 7
28 7
<<<sep_out_sample>>>
push   %rbx
callq  127 <_mu_rfc822_destroy+0x6>
mov    %rax,%rbx
mov    0x8(%rax),%rdi
callq  133 <_mu_rfc822_destroy+0x12>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     14b <_mu_rfc822_destroy+0x2a>
callq  140 <_mu_rfc822_destroy+0x1f>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  14b <_mu_rfc822_destroy+0x2a>
mov    %rbx,%rdi
callq  153 <_mu_rfc822_destroy+0x32>
pop    %rbx
retq   
<<<sep_in_sample>>>
_mu_rfc822_destroy (mu_stream_t stream)
{
  struct _mu_rfc822_stream *s = mu_stream_get_owner (stream);
  free (s->envelope);
  if (s->stream)
    mu_stream_destroy (&s->stream, mu_stream_get_owner (s->stream));
  free (s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 8
16 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    0xc(%rdi),%esi
callq  259 <cplob_add+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cplob_add(CPLOB * lob, char *addr)
{
 cplob_additem(lob, lob->nused, addr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     24e <defer_close+0x25>
mov    0x8(%rdi),%rbx
callq  47 <def_free_deferment>
test   %rbx,%rbx
je     24e <defer_close+0x25>
mov    %rbx,%rdi
jmp    23b <defer_close+0x12>
mov    %rbp,%rdi
callq  256 <defer_close+0x2d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
defer_close(DEFER * def)
{
        struct deferment *oldd;
        struct deferment *d=def->deferoutsM;
 while (d) {
  oldd=d;
  d=d->nextP;
  def_free_deferment(oldd);
 }
 free(def);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 7
9 8
10 5
11 5
12 7
13 7
14 10
15 10
16 12
17 12
18 12
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xd,%edi
jne    1f <sig_usr+0x1f>
mov    0x0(%rip),%rdi        # 10 <sig_usr+0x10>
callq  15 <sig_usr+0x15>
mov    $0x0,%edi
callq  1f <sig_usr+0x1f>
mov    $0x1,%edi
callq  29 <main>
<<<sep_in_sample>>>
sig_usr (int signo)
{
 if (signo == 13){
  topsf_close(gl_topsf);
  exit(0);
 }
 exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
mov    (%rsi),%rax
add    $0x28,%rdi
cmp    %rdi,%rax
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
<<<sep_in_sample>>>
gl_linked_next_node (gl_list_t list, gl_list_node_t node)
{
  return (node->next != &list->root ? node->next : ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     2c8 <unsetenv+0x1d>
cmpb   $0x0,(%rdi)
je     2c8 <unsetenv+0x1d>
mov    $0x3d,%esi
callq  2c3 <unsetenv+0x18>
test   %rax,%rax
je     2da <unsetenv+0x2f>
callq  2cd <unsetenv+0x22>
movl   $0x16,(%rax)
mov    $0xffffffff,%eax
jmp    2e7 <unsetenv+0x3c>
mov    %rbx,%rdi
callq  2e2 <unsetenv+0x37>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
unsetenv (name)
     const char *name;
{
  if (name == 0 || *name == '\0' || strchr (name, '=') != 0)
    {
      (*__errno_location ()) = 22;
      return(-1);
    }
  unbind_variable (name);
  return(0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 7
14 7
15 9
16 9
17 10
18 11
19 11
<<<sep_out_sample>>>
lea    -0x1(%rsi),%rax
cmp    0x30(%rdi),%rax
jb     44b <gl_array_previous_node+0x13>
sub    $0x8,%rsp
callq  44b <gl_array_previous_node+0x13>
repz retq 
<<<sep_in_sample>>>
gl_array_previous_node (gl_list_t list, gl_list_node_t node)
{
  unsigned long index = ((unsigned long)(node) - 1);
  if (!(index < list->count))
    abort ();
  if (index > 0)
    return (gl_list_node_t)(unsigned long)(size_t)((index - 1) + 1);
  else
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 2
5 5
6 10
<<<sep_out_sample>>>
mov    %esi,0x68(%rdi)
retq   
<<<sep_in_sample>>>
swicol_set_event_fd(SWICOL * swicol, int fd)
{
 swicol->event_fdM = fd;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%rbp
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %bl
setb   %dl
sub    %edx,%ebx
movsbl %bl,%ebx
test   %ebx,%ebx
jne    e9 <decode_debug_level+0x33>
movl   $0x0,0x0(%rbp)
jmp    15f <decode_debug_level+0xa9>
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %bl
setb   %dl
sub    %edx,%ebx
movsbl %bl,%ebx
test   %ebx,%ebx
jne    133 <decode_debug_level+0x7d>
movzbl 0x5(%rax),%edx
test   %dl,%dl
js     133 <decode_debug_level+0x7d>
movsbl %dl,%edx
testb  $0x2,0x0(,%rdx,4)
je     133 <decode_debug_level+0x7d>
cmpb   $0x0,0x6(%rax)
jne    133 <decode_debug_level+0x7d>
lea    0x5(%rax),%rdi
callq  12b <decode_debug_level+0x75>
add    $0x1,%eax
mov    %eax,0x0(%rbp)
jmp    15f <decode_debug_level+0xa9>
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %bl
setb   %al
sub    %eax,%ebx
movsbl %bl,%ebx
test   %ebx,%ebx
jne    15a <decode_debug_level+0xa4>
movl   $0x9,0x0(%rbp)
jmp    15f <decode_debug_level+0xa9>
mov    $0x1,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
decode_debug_level (const char *p, int *lev)
{
  if (strcmp (p, "error") == 0)
    *lev = 0;
  else if (strncmp (p, "trace", 5) == 0 && (((unsigned)(p[5])) < 128 && mu_c_tab[(unsigned)(p[5])] & (0x002)) && p[6] == 0)
    *lev = 1 + atoi (p + 5);
  else if (strcmp (p, "proto") == 0)
    *lev = 9;
  else
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 6
37 6
38 6
39 6
40 6
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 8
52 8
53 10
54 12
55 12
56 12
57 12
58 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edx,%r12d
mov    $0xffffffff,%eax
test   %edx,%edx
jle    288 <findparam+0x48>
mov    %rdi,%r13
mov    %rsi,%rbp
mov    $0x0,%ebx
mov    0x0(%rbp),%rsi
mov    %r13,%rdi
callq  26d <findparam+0x2d>
test   %eax,%eax
je     27f <findparam+0x3f>
add    $0x1,%ebx
add    $0x8,%rbp
cmp    %r12d,%ebx
jne    261 <findparam+0x21>
jmp    283 <findparam+0x43>
mov    %ebx,%eax
jmp    288 <findparam+0x48>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
findparam(char *pname, char *param[], int nparam)
{
  int p;
  for (p = 0; p < nparam; p++)
    {
      if (!strcmp(pname, param[p]))
 return p;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 9
8 4
9 4
10 4
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 9
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0xffffff9c,%edi
callq  27 <areadlink+0x27>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
areadlink (char const *filename)
{
  return careadlinkat (-100, filename, ((void *)0), 0, ((void *)0), careadlinkatcwd);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    (%rdi),%r8
test   %r8,%r8
jne    85 <assoc_put+0x1b>
mov    $0x0,%edi
mov    $0x0,%eax
callq  85 <assoc_put+0x1b>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
test   %ecx,%ecx
jne    ab <assoc_put+0x41>
mov    $0x0,%edi
callq  ab <assoc_put+0x41>
mov    %rsi,(%rsp)
add    $0x1,%ecx
movslq %ecx,%rcx
mov    %rcx,0x8(%rsp)
mov    %rdx,0x10(%rsp)
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,0x18(%rsp)
mov    $0x0,%ecx
lea    0x10(%rsp),%rdx
mov    %rsp,%rsi
mov    %r8,%rdi
callq  *0x20(%r8)
cmp    $0xffffffff,%eax
je     f6 <assoc_put+0x8c>
cmp    $0x1,%eax
jne    105 <assoc_put+0x9b>
mov    $0x0,%edi
mov    $0x0,%eax
callq  105 <assoc_put+0x9b>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
assoc_put(ASSOC *assoc, const char *name, const char *value)
{
 DB *db = assoc->db;
 DBT key, dat;
 int status;
 int length;
 if (db == ((void *)0))
  die("associate array is not prepared.");
 if ((length = strlen(name)) == 0)
  die("primary key size == 0.");
 key.data = (char *)name;
 key.size = length+1;
 dat.data = (char *)value;
 dat.size = strlen(value)+1;
 status = (*db->put)(db, &key, &dat, 0);
 switch (status) {
 case 0:
  break;
 case -1:
 case 1:
  die("cannot write to the associate array. (assoc_put)");
 }
}
<<<sep_in_sample>>>
1 2
2 3
3 7
4 7
5 8
6 8
7 8
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 14
27 14
28 14
29 15
30 15
31 15
32 15
33 15
34 16
35 16
36 16
37 16
38 21
39 21
40 21
41 23
42 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x2,%edi
callq  394 <rl_begin_undo_group+0x1d>
addl   $0x1,0x0(%rip)        # 39b <rl_begin_undo_group+0x24>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_begin_undo_group ()
{
  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
  _rl_undo_group_level++;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
test   %edi,%edi
js     35c <_rl_vi_arg_dispatch+0x32>
movslq %edi,%rax
shl    $0x4,%rax
add    0x0(%rip),%rax        # 33f <_rl_vi_arg_dispatch+0x15>
cmpb   $0x0,(%rax)
jne    35c <_rl_vi_arg_dispatch+0x32>
cmpq   $0x0,0x8(%rax)
jne    35c <_rl_vi_arg_dispatch+0x32>
shll   $0x2,0x0(%rip)        # 355 <_rl_vi_arg_dispatch+0x2b>
mov    $0x1,%eax
jmp    3b1 <_rl_vi_arg_dispatch+0x87>
mov    %ebx,%eax
and    $0x7f,%al
lea    -0x30(%rax),%edx
cmp    $0x9,%edx
ja     3a0 <_rl_vi_arg_dispatch+0x76>
cmpl   $0x0,0x0(%rip)        # 36f <_rl_vi_arg_dispatch+0x45>
je     386 <_rl_vi_arg_dispatch+0x5c>
mov    0x0(%rip),%edx        # 377 <_rl_vi_arg_dispatch+0x4d>
lea    (%rdx,%rdx,4),%edx
lea    -0x30(%rax,%rdx,2),%eax
mov    %eax,0x0(%rip)        # 384 <_rl_vi_arg_dispatch+0x5a>
jmp    38f <_rl_vi_arg_dispatch+0x65>
sub    $0x30,%eax
mov    %eax,0x0(%rip)        # 38f <_rl_vi_arg_dispatch+0x65>
movl   $0x1,0x0(%rip)        # 399 <_rl_vi_arg_dispatch+0x6f>
mov    $0x1,%eax
jmp    3b1 <_rl_vi_arg_dispatch+0x87>
callq  3a5 <_rl_vi_arg_dispatch+0x7b>
mov    %ebx,%edi
callq  3ac <_rl_vi_arg_dispatch+0x82>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_vi_arg_dispatch (c)
     int c;
{
  int key;
  key = c;
  if (c >= 0 && _rl_keymap[c].type == 0 && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }
  c = ((c) & (~0x080));
  if (((c) >= '0' && (c) <= '9'))
    {
      if (rl_explicit_arg)
 rl_numeric_arg = (rl_numeric_arg * 10) + ((c) - '0');
      else
 rl_numeric_arg = ((c) - '0');
      rl_explicit_arg = 1;
      return 1;
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 9
14 9
15 11
16 11
17 12
18 12
19 12
20 14
21 14
22 15
23 15
24 15
25 15
26 15
27 17
28 17
29 18
30 19
31 19
32 23
33 24
34 24
35 25
36 27
37 27
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    145 <argp_fmtstream_set_wmargin+0x1f>
callq  145 <argp_fmtstream_set_wmargin+0x1f>
mov    0x18(%rbx),%rax
mov    %rbp,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->wmargin;
  __fs->wmargin = __wmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
lea    -0x1(%rsi),%rax
cmp    0x30(%rdi),%rax
jb     44b <gl_array_previous_node+0x13>
sub    $0x8,%rsp
callq  44b <gl_array_previous_node+0x13>
repz retq 
<<<sep_in_sample>>>
gl_array_previous_node (gl_list_t list, gl_list_node_t node)
{
  unsigned long index = ((unsigned long)(node) - 1);
  if (!(index < list->count))
    abort ();
  if (index > 0)
    return (gl_list_node_t)(unsigned long)(size_t)((index - 1) + 1);
  else
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 2
5 5
6 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    17a <argp_fmtstream_set_wmargin+0x1f>
callq  17a <argp_fmtstream_set_wmargin+0x1f>
mov    0x18(%rbx),%rax
mov    %rbp,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->wmargin;
  __fs->wmargin = __wmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2067 <php_get_text+0x7>
retq   
<<<sep_in_sample>>>
php_get_text (void)
{
        return php_text;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
lea    0x8(%rsp),%rsi
mov    0x0(%rip),%rdi        # 4a9 <do_statusbar_verbatim_input+0x14>
callq  4ae <do_statusbar_verbatim_input+0x19>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    0x8(%rsp),%rsi
mov    %rax,%rdi
callq  4c3 <do_statusbar_verbatim_input+0x2e>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
do_statusbar_verbatim_input(_Bool *got_newline)
{
    int *kbinput;
    size_t kbinput_len;
    kbinput = get_verbatim_kbinput(bottomwin, &kbinput_len);
    do_statusbar_output(kbinput, kbinput_len, 0, got_newline);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    %rdi,%rdx
cmpq   $0x0,(%rdi)
je     92 <digest_md5_validate_response+0x68>
cmpq   $0x0,0x10(%rdi)
je     98 <digest_md5_validate_response+0x6e>
cmpq   $0x0,0x18(%rdi)
je     9e <digest_md5_validate_response+0x74>
cmpq   $0x0,0x20(%rdi)
je     a4 <digest_md5_validate_response+0x7a>
cmpq   $0x0,0x30(%rdi)
je     aa <digest_md5_validate_response+0x80>
cmpb   $0x0,0x50(%rdi)
je     b0 <digest_md5_validate_response+0x86>
lea    0x50(%rdi),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    $0xffffffff,%eax
cmp    $0xffffffffffffffde,%rcx
jne    b5 <digest_md5_validate_response+0x8b>
cmpl   $0x4,0x28(%rdx)
jne    85 <digest_md5_validate_response+0x5b>
cmpl   $0x0,0x44(%rdx)
sete   %al
movzbl %al,%eax
neg    %eax
retq   
cmpl   $0x0,0x44(%rdx)
setne  %al
movzbl %al,%eax
neg    %eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
repz retq 
<<<sep_in_sample>>>
digest_md5_validate_response (digest_md5_response * r)
{
  if (!r->username)
    return -1;
  if (!r->nonce)
    return -1;
  if (!r->cnonce)
    return -1;
  if (!r->nc)
    return -1;
  if (!r->digesturi)
    return -1;
  if (!*r->response)
    return -1;
  if (strlen (r->response) != 32)
    return -1;
  if (r->qop == DIGEST_MD5_QOP_AUTH_CONF && !r->cipher)
    return -1;
  if (r->qop != DIGEST_MD5_QOP_AUTH_CONF && r->cipher)
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 9
9 9
10 11
11 11
12 13
13 13
14 15
15 15
16 15
17 15
18 16
19 15
20 15
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 19
29 19
30 19
31 19
32 19
33 4
34 4
35 6
36 6
37 8
38 8
39 10
40 10
41 12
42 12
43 14
44 22
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r8
mov    %rdx,%rbx
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0x64,%rcx
seta   %bpl
movzbl %bpl,%ebp
neg    %ebp
test   %rsi,%rsi
jne    96b <taru_set_new_linkname+0x43>
mov    0x8(%r8),%rdi
callq  968 <taru_set_new_linkname+0x40>
mov    %rax,%rsi
lea    0x9d(%rsi),%r10
mov    %r10,%rdi
mov    $0x64,%r9d
test   $0x1,%r10b
je     98f <taru_set_new_linkname+0x67>
movb   $0x0,0x9d(%rsi)
lea    0x1(%r10),%rdi
mov    $0x63,%r9b
test   $0x2,%dil
je     9a2 <taru_set_new_linkname+0x7a>
movw   $0x0,(%rdi)
add    $0x2,%rdi
sub    $0x2,%r9d
test   $0x4,%dil
je     9b6 <taru_set_new_linkname+0x8e>
movl   $0x0,(%rdi)
add    $0x4,%rdi
sub    $0x4,%r9d
mov    %r9d,%ecx
shr    $0x3,%ecx
mov    %ecx,%ecx
mov    $0x0,%eax
rep stos %rax,%es:(%rdi)
test   $0x4,%r9b
je     9d6 <taru_set_new_linkname+0xae>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r9b
je     9e5 <taru_set_new_linkname+0xbd>
movw   $0x0,(%rdi)
add    $0x2,%rdi
test   $0x1,%r9b
je     9ee <taru_set_new_linkname+0xc6>
movb   $0x0,(%rdi)
mov    $0x64,%edx
mov    %rbx,%rsi
mov    %r10,%rdi
callq  9fe <taru_set_new_linkname+0xd6>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
taru_set_new_linkname(TARU * taru, struct tar_header * fp_tar_hdr, char * name)
{
 int retval = 0;
 struct tar_header * tar_hdr;
 if (strlen(name) > sizeof(tar_hdr->linkname)) {
  retval = -1;
 }
 if (fp_tar_hdr)
  tar_hdr = fp_tar_hdr;
 else
  tar_hdr = (struct tar_header *)(strob_str(taru->headerM));
 memset(tar_hdr->linkname, '\0', sizeof(tar_hdr->linkname));
 strncpy(tar_hdr->linkname, name, sizeof(tar_hdr->linkname));
 return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 8
17 8
18 11
19 11
20 11
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 13
56 13
57 13
58 13
59 15
60 15
61 15
62 15
63 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xe8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_remove (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 44 <putuchar+0xa>
movb   $0x0,0x0(%rip)        # 4b <putuchar+0x11>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rdx
movslq %esi,%rsi
movzbl (%rdx,%rsi,1),%eax
mov    %al,0x0(%rip)        # 63 <putuchar+0x29>
cmp    $0xa,%al
je     d9 <putuchar+0x9f>
sub    $0x8,%rsp
movsbl %al,%eax
movzwl 0x0(%rip),%ecx        # 75 <putuchar+0x3b>
mov    %eax,%edi
and    %ecx,%edi
cmp    %edi,%ecx
jne    88 <putuchar+0x4e>
movzbl 0x1(%rdx,%rsi,1),%ecx
mov    %cl,0x0(%rip)        # 88 <putuchar+0x4e>
movzwl 0x0(%rip),%ecx        # 8f <putuchar+0x55>
mov    %eax,%edi
and    %ecx,%edi
cmp    %edi,%ecx
jne    a2 <putuchar+0x68>
movzbl 0x2(%rdx,%rsi,1),%ecx
mov    %cl,0x0(%rip)        # a2 <putuchar+0x68>
movzwl 0x0(%rip),%ecx        # a9 <putuchar+0x6f>
and    %ecx,%eax
cmp    %eax,%ecx
jne    ba <putuchar+0x80>
movzbl 0x3(%rdx,%rsi,1),%eax
mov    %al,0x0(%rip)        # ba <putuchar+0x80>
movb   $0x30,0x0(%rip)        # c1 <putuchar+0x87>
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  d5 <putuchar+0x9b>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
putuchar(int pos, int index)
{
  static char c[5];
  memset(c, 0, 5);
  c[0] = lines[pos][index];
  if(c[0] == '\n') return;
  if ((c[0] & mask[0]) == mask[0]) c[1] = lines[pos][index+1];
  if ((c[0] & mask[1]) == mask[1]) c[2] = lines[pos][index+2];
  if ((c[0] & mask[2]) == mask[2]) c[3] = lines[pos][index+3];
  c[4] = '0';
  printf("%s", c);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 2
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 9
31 9
32 10
33 11
34 11
35 11
36 11
37 12
38 12
<<<sep_out_sample>>>
mov    %rsi,0x38(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_client_callback_authentication_id_set (Gsasl * ctx,
          Gsasl_client_callback_authentication_id
          cb)
{
  ctx->cbc_authentication_id = cb;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
no_output (j_common_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  15b5 <quote+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote (char const *arg)
{
  return quote_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%edi
callq  e36 <createErrorCode+0xe>
movl   $0x0,(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
createErrorCode(void)
{
 ERRORCODE * ec = (ERRORCODE *)malloc(sizeof(ERRORCODE));
 ec->codeM = 0;
 return ec;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%r12d
callq  234 <replacenode+0xf>
mov    %rax,%rbx
mov    0x0(%rbp),%rax
mov    0x30(%rax),%rdx
cmpl   $0x52,(%rdx)
jne    2a2 <replacenode+0x7d>
cmp    0x28(%rdx),%rax
jne    2a2 <replacenode+0x7d>
mov    (%rdx),%rax
mov    %rax,(%rbx)
mov    0x8(%rdx),%rax
mov    %rax,0x8(%rbx)
mov    0x10(%rdx),%rax
mov    %rax,0x10(%rbx)
mov    0x18(%rdx),%rax
mov    %rax,0x18(%rbx)
mov    0x20(%rdx),%rax
mov    %rax,0x20(%rbx)
mov    0x28(%rdx),%rax
mov    %rax,0x28(%rbx)
mov    0x30(%rdx),%rax
mov    %rax,0x30(%rbx)
mov    0x38(%rdx),%rax
mov    %rax,0x38(%rbx)
mov    0x40(%rdx),%rax
mov    %rax,0x40(%rbx)
mov    0x48(%rdx),%rax
mov    %rax,0x48(%rbx)
mov    0x50(%rdx),%rax
mov    %rax,0x50(%rbx)
jmp    2f8 <replacenode+0xd3>
mov    (%rax),%rdx
mov    %rdx,(%rbx)
mov    0x8(%rax),%rdx
mov    %rdx,0x8(%rbx)
mov    0x10(%rax),%rdx
mov    %rdx,0x10(%rbx)
mov    0x18(%rax),%rdx
mov    %rdx,0x18(%rbx)
mov    0x20(%rax),%rdx
mov    %rdx,0x20(%rbx)
mov    0x28(%rax),%rdx
mov    %rdx,0x28(%rbx)
mov    0x30(%rax),%rdx
mov    %rdx,0x30(%rbx)
mov    0x38(%rax),%rdx
mov    %rdx,0x38(%rbx)
mov    0x40(%rax),%rdx
mov    %rdx,0x40(%rbx)
mov    0x48(%rax),%rdx
mov    %rdx,0x48(%rbx)
mov    0x50(%rax),%rax
mov    %rax,0x50(%rbx)
mov    %rbp,%rdi
callq  300 <replacenode+0xdb>
mov    0x28(%rbx),%rax
test   %rax,%rax
je     30d <replacenode+0xe8>
mov    %rbx,0x30(%rax)
mov    0x20(%rbx),%rax
test   %rax,%rax
je     31a <replacenode+0xf5>
mov    %rbx,0x30(%rax)
mov    0x0(%rbp),%rax
movq   $0x0,0x20(%rax)
movq   $0x0,0x28(%rax)
mov    0x0(%rbp),%rax
mov    %r12d,(%rax)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
replacenode (exp_t **rep, int token)
{
  exp_t *rex;
  rex= newexp ();
  if (((*rep)->up->token==MDOT && (*rep)->up->right==(*rep))) *rex= *(*rep)->up;
  else
    *rex= **rep;
  remove_dot (rep);
  if (rex->right) rex->right->up=rex;
  if (rex->left) rex->left->up=rex;
  (*rep)->right= (*rep)->left= ((void *)0);
  (*rep)->token= token;
  return (rex);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
58 7
59 8
60 8
61 9
62 9
63 9
64 9
65 10
66 10
67 10
68 10
69 11
70 11
71 11
72 12
73 12
74 14
75 14
76 14
77 14
78 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  21c7 <env_export+0x9>
test   %rax,%rax
je     21d3 <env_export+0x15>
movl   $0x1,0x20(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
env_export (const char *var)
{
  register struct env_lst *ep = env_find (var);
  if (ep)
    ep->export = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     95c <gsl_vector_isneg+0x2d>
shl    $0x3,%rsi
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorpd  %xmm1,%xmm1
movsd  (%rax),%xmm0
ucomisd %xmm1,%xmm0
jb     968 <gsl_vector_isneg+0x39>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
jne    94c <gsl_vector_isneg+0x1d>
jmp    962 <gsl_vector_isneg+0x33>
<<<sep_in_sample>>>
gsl_vector_isneg (const gsl_vector * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 13
13 13
14 17
15 17
16 17
17 17
18 6
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  a48 <gsl_sf_mathieu_se+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     a6e <gsl_sf_mathieu_se+0x32>
mov    %eax,%ecx
mov    $0x16c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a67 <gsl_sf_mathieu_se+0x2b>
movsd  (%rsp),%xmm0
jmp    a6e <gsl_sf_mathieu_se+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_mathieu_se(int order, double qq, double zz)
{
 gsl_sf_result result; int status = gsl_sf_mathieu_se_e(order, qq, zz, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_mathieu_se_e(order, qq, zz, &result)", "mathieu_angfunc.c", 364, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
mov    $0x0,%eax
callq  5e3 <_print_stars+0x13>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_print_stars (void *item, void *data)
{
  printf (" ***");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
<<<sep_out_sample>>>
movq   $0xffffffffffffffff,0x0(%rip)        # 1d7 <init_input+0xb>
retq   
<<<sep_in_sample>>>
init_input(void)
{
  char_number = -1;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1078 <run_return_trap+0x6>
and    $0x51,%eax
cmp    $0x1,%eax
jne    109d <run_return_trap+0x2b>
push   %rbx
mov    0x0(%rip),%ebx        # 1087 <run_return_trap+0x15>
mov    $0x0,%esi
mov    $0x43,%edi
callq  374 <_run_trap_internal>
mov    %ebx,0x0(%rip)        # 109c <run_return_trap+0x2a>
pop    %rbx
repz retq 
<<<sep_in_sample>>>
run_return_trap ()
{
  int old_exit_value;
  if ((sigmodes[65 +2] & 0x1) && ((sigmodes[65 +2] & 0x40) == 0) && (sigmodes[65 +2] & 0x10) == 0)
    {
      old_exit_value = last_command_exit_value;
      _run_trap_internal (65 +2, "return trap");
      last_command_exit_value = old_exit_value;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 2
6 6
7 7
8 7
9 7
10 8
11 10
12 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 69f <meta1get_text+0x7>
retq   
<<<sep_in_sample>>>
meta1get_text (void)
{
        return meta1text;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbx
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
mov    %eax,%ebp
test   %eax,%eax
jle    14c <mu_diag_syslog_printer+0x46>
movslq %eax,%rdx
cmpb   $0xa,-0x1(%rbx,%rdx,1)
jne    14c <mu_diag_syslog_printer+0x46>
lea    -0x1(%rax),%ebp
test   %ebp,%ebp
jle    14c <mu_diag_syslog_printer+0x46>
movslq %ebp,%rdx
sub    $0x2,%eax
cmpb   $0xd,-0x1(%rbx,%rdx,1)
cmove  %eax,%ebp
mov    %esi,%edi
callq  153 <mu_diag_syslog_printer+0x4d>
mov    %rbx,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    %eax,%edi
mov    $0x0,%eax
callq  169 <mu_diag_syslog_printer+0x63>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_diag_syslog_printer (void *data, mu_log_level_t level, const char *buf)
{
  int len = strlen (buf);
  if (len > 0 && buf[len-1] == '\n')
    {
      len--;
      if (len > 0 && buf[len-1] == '\r')
 len--;
    }
  syslog (mu_diag_level_to_syslog (level), "%-.*s", len, buf);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 6
18 7
19 7
20 7
21 8
22 8
23 8
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 12
33 12
34 12
35 12
36 12
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x10(%rdi),%r14
mov    %r14,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r15
mov    0x0(%rip),%r8        # 2c5 <find_argument+0x31>
mov    $0xffffffff,%eax
test   %r8,%r8
je     34a <find_argument+0xb6>
movslq 0x0(%rip),%rax        # 2d6 <find_argument+0x42>
lea    (%rax,%rax,4),%rax
mov    0x0(,%rax,8),%r12d
mov    $0x0,%ebx
mov    %rbx,%rbp
shl    $0x4,%rbp
cmp    0x0(%rbp),%r12d
jne    32f <find_argument+0x9b>
movzbl (%r14),%eax
cmp    %al,(%r8)
jne    32f <find_argument+0x9b>
mov    %r8,%rdi
mov    $0xffffffffffffffff,%rcx
mov    $0x0,%eax
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    %r15,%rcx
jne    32f <find_argument+0x9b>
mov    %r15,%rdx
mov    %r14,%rsi
mov    %r8,%rdi
callq  32b <find_argument+0x97>
test   %eax,%eax
je     341 <find_argument+0xad>
add    $0x1,%rbx
mov    0x0(%rbp),%r8
test   %r8,%r8
jne    2e7 <find_argument+0x53>
jmp    345 <find_argument+0xb1>
mov    %ebx,%eax
jmp    34a <find_argument+0xb6>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
find_argument(CMDARG *arg)
{
 int idx;
 char *name, *p;
 size_t len;
 ((void) (0));
 name = arg->value.sval;
 len = strlen(name);
 for (idx = 0; (p = (char *) zz_debug_argtab[idx].name) != ((void *)0); idx++) {
  if (zz_debug_cmdtab[cmd_idx].type == zz_debug_argtab[idx].cmd
    && *p == *name
    && strlen(p) == len
    && strncmp(p, name, len) == 0
  )
   return idx;
 }
 return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 7
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 17
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 9
46 9
47 9
48 9
49 9
50 9
51 17
52 18
53 18
54 18
55 18
56 18
57 18
58 18
59 18
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rec_encrypt (char *in,
             size_t in_size,
             const char *password,
             char **out,
             size_t *out_size)
{
  return 0;
}
<<<sep_in_sample>>>
1 8
2 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rdx,%r13
cmpb   $0x0,0x5e1(%rdi)
jne    946 <copytoks+0x2b>
lea    0x0(,%rsi,8),%r12
mov    $0x0,%ebp
test   %rdx,%rdx
jne    991 <copytoks+0x76>
jmp    9b6 <copytoks+0x9b>
test   %rdx,%rdx
je     9b6 <copytoks+0x9b>
lea    0x0(,%rsi,4),%r14
lea    0x0(,%rsi,8),%r12
mov    $0x0,%ebp
mov    0x620(%rbx),%rax
mov    (%rax,%r14,1),%edx
mov    0x5b0(%rbx),%rax
mov    (%rax,%r12,1),%rsi
mov    %rbx,%rdi
callq  7e6 <addtok_mb>
add    $0x1,%rbp
add    $0x4,%r14
add    $0x8,%r12
cmp    %r13,%rbp
jne    960 <copytoks+0x45>
jmp    9b6 <copytoks+0x9b>
mov    0x5b0(%rbx),%rax
mov    (%rax,%r12,1),%rsi
mov    $0x3,%edx
mov    %rbx,%rdi
callq  7e6 <addtok_mb>
add    $0x1,%rbp
add    $0x8,%r12
cmp    %r13,%rbp
jne    991 <copytoks+0x76>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
copytoks (struct dfa *dfa, size_t tindex, size_t ntokens)
{
  size_t i;
  if (dfa->multibyte)
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa, dfa->tokens[tindex + i], dfa->multibyte_prop[tindex + i]);
  else
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa, dfa->tokens[tindex + i], 3);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 8
12 8
13 8
14 8
15 5
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 6
26 5
27 5
28 5
29 5
30 5
31 5
32 9
33 9
34 9
35 9
36 9
37 8
38 8
39 8
40 8
41 10
42 10
43 10
44 10
45 10
46 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  2fa <ahs_copy+0xf>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahs_copy(AHS * ahs_to, AHS * ahs_from)
{
 ;
 taru_filehdr2filehdr(ahs_to->file_hdrM, ahs_from->file_hdrM);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 1e53 <xmitEL+0xb>
movb   $0xff,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  1e65 <xmitEL+0x1d>
mov    0x0(%rip),%rax        # 1e6c <xmitEL+0x24>
movb   $0xf8,(%rax)
mov    $0x1,%esi
mov    $0x0,%edi
callq  1e7e <xmitEL+0x36>
mov    $0xf8,%edx
mov    $0xff,%esi
mov    $0x0,%edi
callq  1e92 <xmitEL+0x4a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xmitEL (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 248; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 248);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 76a <mu_cfg_yyset_lineno+0x6>
retq   
<<<sep_in_sample>>>
mu_cfg_yyset_lineno (int line_number )
{
    mu_cfg_yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r11
cmp    (%rdi),%r11
jne    1ba4 <gsl_matrix_float_sub+0x1f>
mov    0x8(%rsi),%r9
cmp    %rax,%r9
je     1bc7 <gsl_matrix_float_sub+0x42>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1bbd <gsl_matrix_float_sub+0x38>
mov    $0x13,%eax
jmpq   1c48 <gsl_matrix_float_sub+0xc3>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%r12
test   %r11,%r11
je     1c3c <gsl_matrix_float_sub+0xb7>
lea    0x0(,%rax,4),%r13
sub    %rax,%r12
shl    $0x2,%r12
mov    $0x0,%r10d
mov    $0x0,%ebp
mov    $0x0,%ebx
jmp    1c2d <gsl_matrix_float_sub+0xa8>
mov    %rax,%rcx
add    0x18(%rdi),%rcx
mov    %rax,%r8
add    0x18(%rsi),%r8
movss  (%rcx),%xmm0
subss  (%r8,%r10,1),%xmm0
movss  %xmm0,(%rcx)
add    $0x1,%rdx
add    $0x4,%rax
cmp    %r9,%rdx
jne    1bf5 <gsl_matrix_float_sub+0x70>
add    $0x1,%rbx
add    %r13,%rbp
add    %r12,%r10
cmp    %r11,%rbx
je     1c43 <gsl_matrix_float_sub+0xbe>
test   %r9,%r9
je     1c1e <gsl_matrix_float_sub+0x99>
mov    %rbp,%rax
mov    $0x0,%edx
jmp    1bf5 <gsl_matrix_float_sub+0x70>
mov    $0x0,%eax
jmp    1c48 <gsl_matrix_float_sub+0xc3>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_float_sub (gsl_matrix_float * a, const gsl_matrix_float * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
37 18
38 16
39 16
40 16
41 16
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
52 21
53 21
54 21
55 23
56 23
57 23
58 23
59 23
60 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  b <pbm_getc+0x9>
cmp    $0x23,%eax
jne    22 <pbm_getc+0x20>
mov    %rbx,%rdi
callq  18 <pbm_getc+0x16>
cmp    $0xffffffff,%eax
je     22 <pbm_getc+0x20>
cmp    $0xa,%eax
jne    10 <pbm_getc+0xe>
pop    %rbx
retq   
<<<sep_in_sample>>>
pbm_getc (FILE * infile)
{
  register int ch;
  ch = _IO_getc (infile);
  if (ch == '#') {
    do {
      ch = _IO_getc (infile);
    } while (ch != '\n' && ch != (-1));
  }
  return ch;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 7
7 7
8 8
9 8
10 8
11 8
12 11
13 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
mov    0x8(%rdi),%rdi
callq  *0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv_control_init(gsl_odeiv_control * c,
                       double eps_abs, double eps_rel,
                       double a_y, double a_dydt)
{
  return c->type->init (c->state, eps_abs, eps_rel, a_y, a_dydt);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebx
mov    %edx,%ebp
test   %edx,%edx
je     30 <get_key_len+0x30>
test   %esi,%esi
jne    1c <get_key_len+0x1c>
mov    $0x0,%edi
callq  1c <get_key_len+0x1c>
mov    %ebx,%eax
cmp    %ebx,%ebp
je     65 <get_key_len+0x65>
mov    $0x0,%edi
callq  2c <get_key_len+0x2c>
mov    %ebx,%eax
jmp    65 <get_key_len+0x65>
test   %esi,%esi
je     3d <get_key_len+0x3d>
mov    %esi,%eax
cmpb   $0x0,(%rdi)
jne    53 <get_key_len+0x53>
jmp    61 <get_key_len+0x61>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%eax
jmp    65 <get_key_len+0x65>
add    $0x1,%rdi
sub    $0x1,%eax
je     61 <get_key_len+0x61>
cmpb   $0x0,(%rdi)
jne    53 <get_key_len+0x53>
sub    %eax,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
get_key_len(char *s, unsigned int len, int numeric)
{
  if (numeric)
    {
      if (len == 0)
        fatal ("hashtab.c (get_key_len): hashing a num with len == 0");
      if (len != numeric)
        fatal ("hashtab.c (get_key_len): hashing a num with len != numeric");
      return len;
    }
  else
    {
      if (!len)
        return strlen (s);
      else
        {
          unsigned int i;
          for (i = len; i && (*s != '\0'); s++, i--)
            ;
          return len - i;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 6
11 6
12 9
13 7
14 7
15 8
16 8
17 9
18 9
19 13
20 13
21 18
22 18
23 18
24 18
25 14
26 14
27 14
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 20
37 20
38 23
39 23
40 23
41 23
<<<sep_out_sample>>>
lea    -0x1(%rdi),%eax
cmp    $0x1,%eax
jbe    24 <log_handler+0x24>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  20 <log_handler+0x20>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
log_handler (cdio_log_level_t level, const char *message)
{
  switch(level) {
  case CDIO_LOG_DEBUG:
  case CDIO_LOG_INFO:
    return;
  default:
    printf("cdio %d message: %s\n", level, message);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 8
6 8
7 8
8 8
9 8
10 10
11 10
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r11
test   %r10,%r10
je     1a02 <gsl_matrix_scale+0x5d>
shl    $0x3,%r11
mov    $0x0,%r9d
mov    $0x0,%r8d
jmp    19f3 <gsl_matrix_scale+0x4e>
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
movapd %xmm0,%xmm1
mulsd  (%rcx),%xmm1
movsd  %xmm1,(%rcx)
add    $0x1,%rax
add    $0x8,%rdx
cmp    %rsi,%rax
jne    19c7 <gsl_matrix_scale+0x22>
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
je     1a02 <gsl_matrix_scale+0x5d>
test   %rsi,%rsi
je     19e7 <gsl_matrix_scale+0x42>
mov    %r9,%rdx
mov    $0x0,%eax
jmp    19c7 <gsl_matrix_scale+0x22>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_scale (gsl_matrix * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] *= x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 11
11 11
12 11
13 11
14 11
15 9
16 9
17 9
18 9
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 9
27 9
28 15
29 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    0x0(%rip),%rdi        # 181 <handle_signal+0xf>
callq  186 <handle_signal+0x14>
mov    0x0(%rip),%rbx        # 18d <handle_signal+0x1b>
mov    $0x0,%edi
callq  197 <handle_signal+0x25>
mov    %ebp,%ecx
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 1a6 <handle_signal+0x34>
mov    $0x0,%eax
callq  1b0 <handle_signal+0x3e>
mov    $0x3,%edi
callq  1ba <my_malloc>
<<<sep_in_sample>>>
handle_signal (the_signal)
     int the_signal;
{
  rpl_fflush (stdout);
  fprintf (stderr, gettext("\n%s: program aborted by signal %d\n"), prgr_name,
    the_signal);
  exit (3);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  58a <set_start_time+0xe>
mov    0x0(%rip),%rax        # 591 <set_start_time+0x15>
mov    0x0(%rip),%rdx        # 598 <set_start_time+0x1c>
mov    %rax,0x0(%rip)        # 59f <set_start_time+0x23>
mov    %rdx,0x0(%rip)        # 5a6 <set_start_time+0x2a>
mov    %rax,0x0(%rip)        # 5ad <set_start_time+0x31>
mov    %rdx,0x0(%rip)        # 5b4 <set_start_time+0x38>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
set_start_time (void)
{
  gettime (&start_time);
  volume_start_time = start_time;
  last_stat_time = start_time;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    $0x0,%eax
test   %edi,%edi
js     3ce <swlib_doif_writeap+0x6e>
mov    %rsi,%rbx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  385 <swlib_doif_writeap+0x25>
test   %eax,%eax
js     3c9 <swlib_doif_writeap+0x69>
mov    %rbx,%rdi
callq  391 <swlib_doif_writeap+0x31>
mov    %rax,%r12
mov    %rbx,%rdi
callq  39c <swlib_doif_writeap+0x3c>
mov    %rax,%r13
mov    %rbx,%rdi
callq  3a7 <swlib_doif_writeap+0x47>
mov    %r13,%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    $0x0,%edi
callq  3b9 <swlib_doif_writeap+0x59>
mov    %rax,%rdx
cmp    %r12d,%eax
mov    $0xffffffff,%eax
cmove  %edx,%eax
jmp    3ce <swlib_doif_writeap+0x6e>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
swlib_doif_writeap(int fd, STROB * buffer, char * format, va_list * pap)
{
 int ret;
 int aret;
 if (fd < 0) return 0;
 ret = strob_vsprintf(buffer, 1, format, *pap);
 if (ret < 0) {
  return -1;
 }
 ret = strob_strlen(buffer);
 aret = atomicio(uxfio_write, fd,
  (void*)strob_str(buffer), strob_strlen(buffer));
 if (aret != ret) return -1;
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 10
17 10
18 10
19 11
20 11
21 11
22 12
23 12
24 11
25 11
26 11
27 11
28 11
29 11
30 13
31 13
32 13
33 13
34 8
35 15
36 15
37 15
38 15
39 15
40 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r9
mov    %rsi,%rbx
mov    %rcx,%rsi
mov    0x28(%rsp),%rdx
mov    $0x0,%edi
mov    $0x4,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %r8b
setb   %cl
mov    $0x0,%eax
cmp    %cl,%r8b
jne    90 <ahc_echo+0x90>
cmpq   $0x0,(%rdx)
je     45 <ahc_echo+0x45>
movq   $0x0,(%rdx)
mov    $0x1,%al
jmp    90 <ahc_echo+0x90>
movq   $0x0,(%rdx)
mov    %r9,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdi
mov    $0x0,%edx
mov    %r9,%rsi
callq  71 <ahc_echo+0x71>
mov    %rax,%rbp
mov    %rax,%rdx
mov    $0xc8,%esi
mov    %rbx,%rdi
callq  84 <ahc_echo+0x84>
mov    %eax,%ebx
mov    %rbp,%rdi
callq  8e <ahc_echo+0x8e>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ahc_echo (void *cls,
          struct MHD_Connection *connection,
          const char *url,
          const char *method,
          const char *version,
          const char *upload_data, size_t *upload_data_size, void **ptr)
{
  static int aptr;
  const char *me = cls;
  struct MHD_Response *response;
  int ret;
  if (0 != strcmp (method, "GET"))
    return 0;
  if (&aptr != *ptr)
    {
      *ptr = &aptr;
      return 1;
    }
  *ptr = ((void *)0);
  response = MHD_create_response_from_buffer (strlen (me),
           (void *) me,
           MHD_RESPMEM_PERSISTENT);
  ret = MHD_queue_response (connection, 200, response);
  MHD_destroy_response (response);
  return ret;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 12
9 12
10 12
11 12
12 12
13 13
14 12
15 12
16 14
17 14
18 16
19 17
20 17
21 19
22 20
23 20
24 20
25 20
26 20
27 20
28 20
29 20
30 20
31 20
32 23
33 23
34 23
35 23
36 23
37 24
38 24
39 25
40 26
41 26
42 26
43 26
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 933 <gsl_vector_long_ptr+0x7>
je     95e <gsl_vector_long_ptr+0x32>
cmp    %rsi,(%rdi)
ja     95e <gsl_vector_long_ptr+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  957 <gsl_vector_long_ptr+0x2b>
mov    $0x0,%eax
jmp    972 <gsl_vector_long_ptr+0x46>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rax,%rsi
mov    %rsi,%rax
add    0x10(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_long_ptr (gsl_vector_long * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (long *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %rdx,%r12
callq  12c <fh_tab+0x11>
movl   $0x0,(%rax)
test   %ebx,%ebx
jle    151 <fh_tab+0x36>
mov    $0x0,%edx
mov    $0x0,%esi
mov    (%r12),%rdi
callq  149 <fh_tab+0x2e>
mov    %rax,%rbx
test   %rax,%rax
jg     16f <fh_tab+0x54>
mov    0x0(%rip),%rax        # 158 <fh_tab+0x3d>
mov    (%rax),%eax
lea    0x7(%rax),%edx
test   %eax,%eax
cmovs  %edx,%eax
sar    $0x3,%eax
lea    0x8(,%rax,8),%ebx
movslq %ebx,%rbx
mov    0x0(%rip),%rax        # 176 <fh_tab+0x5b>
movslq (%rax),%rax
cmp    %rax,%rbx
jle    19a <fh_tab+0x7f>
mov    $0x20,%esi
mov    %rbp,%rdi
callq  18b <fh_tab+0x70>
mov    0x0(%rip),%rdx        # 192 <fh_tab+0x77>
movslq (%rdx),%rdx
cmp    %rdx,%rbx
jg     17e <fh_tab+0x63>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
fh_tab (format_data_t form, int argc, char *argv[])
{
  long goal = 0;
  (*__errno_location ()) = 0;
  if (argc >= 1)
    goal = strtol (argv[0], ((void *)0), 0);
  if (goal <= 0)
    goal = ((*column / 8) + 1) * 8;
  while (*column < goal)
    put_char (form, ' ');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 9
34 9
35 9
36 9
37 11
38 11
39 11
40 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    %edx,%ebp
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     20f <__bt_setcur+0x2a>
callq  1ff <__bt_setcur+0x1a>
movq   $0x0,0x38(%rbx)
movq   $0x0,0x30(%rbx)
movzbl 0x44(%rbx),%eax
and    $0xfffffff8,%eax
mov    %r12d,0x28(%rbx)
mov    %bp,0x2c(%rbx)
or     $0x8,%eax
mov    %al,0x44(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
__bt_setcur(t, pgno, index)
 BTREE *t;
 u_int32_t pgno;
 u_int index;
{
 if (t->bt_cursor.key.data != ((void *)0)) {
  free(t->bt_cursor.key.data);
  t->bt_cursor.key.size = 0;
  t->bt_cursor.key.data = ((void *)0);
 }
 (&t->bt_cursor)->flags &= ~(0x01 | 0x02 | 0x04);
 t->bt_cursor.pg.pgno = pgno;
 t->bt_cursor.pg.index = index;
 (&t->bt_cursor)->flags |= (0x08);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
9 6
10 7
11 8
12 9
13 11
14 11
15 12
16 13
17 14
18 14
19 15
20 15
21 15
22 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1fdb <asm_free+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
asm_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
mov    %rsi,%rbp
mov    $0x0,%edi
callq  6dd <main+0x15>
mov    %rbp,%rsi
mov    %ebx,%edi
callq  6e7 <main+0x1f>
mov    0x0(%rip),%rdi        # 6ee <main+0x26>
callq  6f3 <main+0x2b>
mov    %rax,%rbx
test   %rax,%rax
jne    703 <main+0x3b>
callq  700 <main+0x38>
mov    %rax,%rbx
mov    %rbx,%rdi
callq  70b <main+0x43>
mov    0x0(%rip),%rdi        # 712 <main+0x4a>
callq  717 <main+0x4f>
test   %al,%al
jne    743 <main+0x7b>
mov    0x0(%rip),%rbx        # 722 <main+0x5a>
mov    $0x0,%edi
callq  72c <main+0x64>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  73c <main+0x74>
mov    $0x1,%eax
jmp    757 <main+0x8f>
mov    0x0(%rip),%rsi        # 74a <main+0x82>
mov    %rbx,%rdi
callq  752 <main+0x8a>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
main (int argc, char *argv[])
{
  rec_db_t db;
  recutl_init ("recins");
  recins_parse_args (argc, argv);
  db = recutl_read_db_from_file (recins_file);
  if (!db)
    {
      db = rec_db_new ();
    }
  recins_add_new_record (db);
  if (!recutl_file_is_writable (recins_file))
    {
      recutl_error (gettext ("file %s is not writable.\n"), recins_file);
      return 1;
    }
  recutl_write_db_to_file (db, recins_file);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 7
15 7
16 9
17 9
18 11
19 11
20 12
21 12
22 12
23 12
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 15
32 15
33 17
34 17
35 17
36 18
37 19
38 19
39 19
40 19
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
forcefindlib (void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %edi,%edi
je     538 <_rl_vi_textmod_command+0x26>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x0,%edi
callq  52b <_rl_vi_textmod_command+0x19>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_rl_vi_textmod_command (c)
     int c;
{
  return (((c) ? (char *)strchr ((vi_textmod), (c)) != (char *)((void *)0) : 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_thread_set_priority (struct osip_thread *thread, int priority)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_fdiv (const double x, const double y)
{
  return x / y;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <jobserver_setup+0xd>
cmp    $0xffffffff,%eax
jne    22 <jobserver_setup+0x22>
callq  17 <jobserver_setup+0x17>
cmpl   $0x4,(%rax)
je     3 <jobserver_setup+0x3>
nopl   0x0(%rax)
jmp    26 <jobserver_setup+0x26>
test   %eax,%eax
jns    7c <jobserver_setup+0x7c>
mov    $0x0,%edi
callq  30 <jobserver_setup+0x30>
mov    %rax,%rdi
callq  38 <jobserver_setup+0x38>
mov    $0x1,%edx
mov    $0x0,%esi
mov    0x0(%rip),%edi        # 48 <jobserver_setup+0x48>
callq  4d <jobserver_setup+0x4d>
cmp    $0xffffffff,%eax
jne    62 <jobserver_setup+0x62>
callq  57 <jobserver_setup+0x57>
cmpl   $0x4,(%rax)
je     38 <jobserver_setup+0x38>
nopl   0x0(%rax)
jmp    6a <jobserver_setup+0x6a>
sub    $0x1,%ebx
cmp    $0x1,%eax
je     7c <jobserver_setup+0x7c>
mov    $0x0,%edi
callq  74 <jobserver_setup+0x74>
mov    %rax,%rdi
callq  7c <jobserver_setup+0x7c>
test   %ebx,%ebx
jne    38 <jobserver_setup+0x38>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
jobserver_setup (int slots)
{
  int r;
  while (((r)=pipe (job_fds))==-1 && (*__errno_location ())==4);
  if (r < 0)
    pfatal_with_name (gettext ("creating jobs pipe"));
  if (make_job_rfd () < 0)
    pfatal_with_name (gettext ("duping jobs pipe"));
  while (slots--)
    {
      while (((r)=write (job_fds[1], &token, 1))==-1 && (*__errno_location ())==4);
      if (r != 1)
        pfatal_with_name (gettext ("init jobserver pipe"));
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 6
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 12
31 12
32 13
33 13
34 13
35 13
36 9
37 9
38 16
39 16
40 16
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
strob_get_str(STROB * strb)
{
 return (char*)(strb->str_);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rcx
mov    0x60(%rdi),%rdx
mov    $0x0,%esi
callq  642 <gl_linked_search_from_to>
mov    %rax,%rsi
mov    $0x0,%eax
test   %rsi,%rsi
je     bcc <gl_linked_remove+0x2a>
mov    %rbx,%rdi
callq  af5 <gl_linked_remove_node>
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_linked_remove (gl_list_t list, const void *elt)
{
  gl_list_node_t node = gl_linked_search_from_to (list, 0, list->count, elt);
  if (node != ((void *)0))
    return gl_linked_remove_node (list, node);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 7
9 4
10 4
11 5
12 5
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  135 <gc_cipher_close+0x9>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_cipher_close (gc_cipher_handle handle)
{
  _gc_cipher_ctx *ctx = handle;
  free (ctx);
  return GC_OK;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%edx
callq  1b7 <in_addr_cmp+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
in_addr_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(struct in_addr)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
movsd  %xmm0,0x10(%rsp)
mov    %rdi,%r12
ucomisd 0x0(%rip),%xmm0        # 130 <integral+0x19>
jp     141 <integral+0x2a>
jne    141 <integral+0x2a>
xorpd  %xmm0,%xmm0
movsd  %xmm0,(%rdi)
jmpq   216 <integral+0xff>
xorpd  %xmm0,%xmm0
ucomisd 0x10(%rsp),%xmm0
jbe    165 <integral+0x4e>
movsd  0x0(%rip),%xmm0        # 155 <integral+0x3e>
movsd  0x10(%rsp),%xmm7
xorpd  %xmm0,%xmm7
movsd  %xmm7,0x10(%rsp)
movsd  0x0(%rip),%xmm0        # 16d <integral+0x56>
ucomisd 0x10(%rsp),%xmm0
jbe    188 <integral+0x71>
movq   $0x0,(%r12)
movsd  0x10(%rsp),%xmm0
jmpq   216 <integral+0xff>
movsd  0x10(%rsp),%xmm0
callq  a8 <log_10>
mov    %eax,%ebx
test   %eax,%eax
js     1f8 <integral+0xe1>
xorpd  %xmm7,%xmm7
movsd  %xmm7,(%rsp)
mov    $0x0,%ebp
mov    %ebx,%edi
callq  0 <pow_10>
movsd  0x10(%rsp),%xmm3
subsd  (%rsp),%xmm3
divsd  %xmm0,%xmm3
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm2
movsd  0x0(%rip),%xmm1        # 1d0 <integral+0xb9>
addsd  %xmm2,%xmm1
ucomisd %xmm1,%xmm3
jb     1e0 <integral+0xc9>
movapd %xmm1,%xmm2
jmp    1c8 <integral+0xb1>
mulsd  %xmm0,%xmm2
addsd  (%rsp),%xmm2
movsd  %xmm2,(%rsp)
sub    $0x1,%ebx
cmp    $0xffffffff,%ebx
jne    1a7 <integral+0x90>
jmp    201 <integral+0xea>
xorpd  %xmm6,%xmm6
movsd  %xmm6,(%rsp)
movsd  (%rsp),%xmm5
movsd  %xmm5,(%r12)
movsd  0x10(%rsp),%xmm0
subsd  %xmm5,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
integral(real, ip)
     double real;
     double *ip;
{
  int j;
  double i, s, p;
  double real_integral = 0.;
  if (real == 0.)
    {
      *ip = 0.;
      return (0.);
    }
  if (real < 0.)
    real = -real;
  if ( real < 1.)
    {
      *ip = 0.;
      return real;
    }
  for (j = log_10(real); j >= 0; j--)
    {
      p = pow_10(j);
      s = (real - real_integral)/p;
      i = 0.;
      while (i + 1. <= s)
 i++;
      real_integral += i*p;
    }
  *ip = real_integral;
  return (real - real_integral);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 8
8 8
9 8
10 10
11 10
12 11
13 13
14 13
15 13
16 14
17 14
18 14
19 14
20 15
21 15
22 15
23 17
24 18
25 18
26 20
27 20
28 20
29 20
30 20
31 7
32 7
33 24
34 22
35 22
36 23
37 23
38 23
39 24
40 24
41 25
42 25
43 25
44 25
45 26
46 26
47 27
48 27
49 27
50 20
51 20
52 20
53 20
54 7
55 7
56 29
57 29
58 30
59 30
60 31
61 31
62 31
63 31
64 31
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebp
cmp    %esi,%ecx
jb     11e <_nettle_sha3_pad+0x29>
lea    0x0(%rip),%rcx        # 106 <_nettle_sha3_pad+0x11>
mov    $0x60,%edx
lea    0x0(%rip),%rsi        # 112 <_nettle_sha3_pad+0x1d>
lea    0x0(%rip),%rdi        # 119 <_nettle_sha3_pad+0x24>
callq  11e <_nettle_sha3_pad+0x29>
mov    %rdi,%r12
mov    %rdx,%rbx
lea    0x1(%rcx),%eax
mov    %ecx,%ecx
movb   $0x6,(%rdx,%rcx,1)
mov    %esi,%edx
sub    %eax,%edx
mov    %eax,%eax
lea    (%rbx,%rax,1),%rdi
mov    $0x0,%esi
callq  141 <_nettle_sha3_pad+0x4c>
lea    -0x1(%rbp),%eax
orb    $0x80,(%rbx,%rax,1)
mov    %rbx,%rdx
mov    %ebp,%esi
mov    %r12,%rdi
callq  0 <sha3_absorb>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_nettle_sha3_pad (struct sha3_state *state,
    unsigned block_size, uint8_t *block, unsigned pos)
{
  ((pos < block_size) ? (void) (0) : __assert_fail ("pos < block_size", "sha3.c", 96, __PRETTY_FUNCTION__));
  block[pos++] = 6;
  memset (block + pos, 0, block_size - pos);
  block[block_size - 1] |= 0x80;
  sha3_absorb (state, block_size, block);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 8
26 8
27 8
28 8
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x2,%eax
test   %rdi,%rdi
je     46f <tld_check_4z+0x3c>
mov    %rsi,%r8
cmpl   $0x0,(%rdi)
je     457 <tld_check_4z+0x24>
mov    %rdi,%rax
add    $0x4,%rax
cmpl   $0x0,(%rax)
jne    44c <tld_check_4z+0x19>
jmp    45a <tld_check_4z+0x27>
mov    %rdi,%rax
sub    %rdi,%rax
sar    $0x2,%rax
mov    %rax,%rsi
mov    %rdx,%rcx
mov    %r8,%rdx
callq  46f <tld_check_4z+0x3c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
tld_check_4z (const uint32_t * in, size_t * errpos,
       const Tld_table ** overrides)
{
  const uint32_t *ipos = in;
  if (!ipos)
    return TLD_NODATA;
  while (*ipos)
    ipos++;
  return tld_check_4 (in, ipos - in, errpos, overrides);
}
<<<sep_in_sample>>>
1 3
2 6
3 5
4 5
5 5
6 7
7 7
8 7
9 8
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0xc0(%rdi),%rbx
mov    0x58(%rbx),%rsi
test   %rsi,%rsi
je     3d7 <CDB___bam_db_close+0x26>
mov    0x68(%rbx),%rdx
mov    0x28(%rdi),%rdi
callq  3d7 <CDB___bam_db_close+0x26>
testb  $0x2,0x48(%rbx)
je     3e6 <CDB___bam_db_close+0x35>
lea    0x40(%rbx),%rdi
callq  3e6 <CDB___bam_db_close+0x35>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     3f4 <CDB___bam_db_close+0x43>
callq  3f4 <CDB___bam_db_close+0x43>
mov    $0x80,%esi
mov    %rbx,%rdi
callq  401 <CDB___bam_db_close+0x50>
movq   $0x0,0xc0(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
CDB___bam_db_close(dbp)
 DB *dbp;
{
 BTREE *t;
 t = dbp->bt_internal;
 if (t->re_smap != ((void *)0))
  (void)CDB___os_unmapfile(dbp->dbenv, t->re_smap, t->re_msize);
 if (((&t->re_fh)->flags & (0x02)))
  (void)CDB___os_closehandle(&t->re_fh);
 if (t->re_source != ((void *)0))
  CDB___os_freestr(t->re_source);
 CDB___os_free(t, sizeof(BTREE));
 dbp->bt_internal = ((void *)0);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 10
19 11
20 12
21 12
22 12
23 13
24 15
25 15
26 15
27 15
28 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     b08 <urlIsURL+0x6c>
mov    $0x0,%eax
cmpb   $0x0,(%rdi)
je     b1e <urlIsURL+0x82>
mov    0x0(%rip),%rsi        # abf <urlIsURL+0x23>
test   %rsi,%rsi
je     b12 <urlIsURL+0x76>
mov    $0x0,%ebp
mov    $0xffffffffffffffff,%r13
mov    $0x0,%r12d
mov    %rsi,%rdi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %rbx,%rdi
callq  af0 <urlIsURL+0x54>
test   %eax,%eax
je     b03 <urlIsURL+0x67>
add    $0x10,%rbp
mov    0x0(%rbp),%rsi
test   %rsi,%rsi
jne    ad6 <urlIsURL+0x3a>
jmp    b19 <urlIsURL+0x7d>
mov    0x8(%rbp),%eax
jmp    b1e <urlIsURL+0x82>
mov    $0x0,%eax
nopl   (%rax)
jmp    b1e <urlIsURL+0x82>
mov    $0x0,%eax
jmp    b1e <urlIsURL+0x82>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
urlIsURL(const char * url) {
    struct urlstring *us;
    if (url && *url) {
 for (us = urlstrings; us->leadin != ((void *)0); us++) {
     if (strncmp(url, us->leadin, strlen(us->leadin)))
  continue;
     return us->ret;
 }
    }
    return URL_IS_UNKNOWN;
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 3
8 3
9 10
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 4
29 4
30 4
31 4
32 4
33 7
34 7
35 10
36 10
37 10
38 10
39 10
40 10
41 11
42 11
43 11
44 11
45 11
46 11
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     2d2 <cdio_debug+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    $0x1,%edi
callq  1cb <cdio_logv>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
cdio_debug (const char format[], ...) { va_list args; __builtin_va_start(args,format); cdio_logv (CDIO_LOG_DEBUG, format, args); __builtin_va_end(args); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x1,0x10(%rdi)
jne    5d5 <free_node_item+0x13>
lea    0x28(%rdi),%rdi
callq  5d5 <free_node_item+0x13>
mov    %rbx,%rdi
callq  5dd <free_node_item+0x1b>
pop    %rbx
retq   
<<<sep_in_sample>>>
free_node_item (void *item)
{
  mu_cfg_node_t *node = item;
  switch (node->type)
    {
    case mu_cfg_node_statement:
      mu_list_destroy (&node->nodes);
      break;
    case mu_cfg_node_undefined:
    case mu_cfg_node_param:
      break;
    }
  mu_cfg_free_node (node);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 7
6 7
7 13
8 13
9 14
10 14
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
extract_failure (char *file_name, int typeflag)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
js     15 <__rpspacing+0x15>
cmp    0x70(%rdi),%rsi
jg     15 <__rpspacing+0x15>
mov    %rsi,0x78(%rdi)
jmp    1f <__rpspacing+0x1f>
mov    $0x0,%edi
callq  1f <__rpspacing+0x1f>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
__rpspacing (__bs6FILE *p, long n)
{
  if (0 <= n && n <= p->lines_per_page)
    p->spacing = n;
  else
    __rerror ("Spacing: Parameter out of range");
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 6
10 6
11 8
12 8
13 8
<<<sep_out_sample>>>
test   %rdx,%rdx
je     32 <fwrite_uppcase+0x32>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rdx,%rbp
movzbl (%rbx),%edi
callq  1a <fwrite_uppcase+0x1a>
mov    %r12,%rsi
mov    %eax,%edi
callq  24 <fwrite_uppcase+0x24>
add    $0x1,%rbx
sub    $0x1,%rbp
jne    12 <fwrite_uppcase+0x12>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
fwrite_uppcase (FILE *fp, const char *src, size_t len)
{
  while (len-- > 0)
    {
      fputc (toupper ((unsigned char) *src), fp);
      ++src;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 3
16 3
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  c8 <xdico_assoc_create+0x9>
test   %rax,%rax
jne    d2 <xdico_assoc_create+0x13>
callq  d2 <xdico_assoc_create+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdico_assoc_create(int flags)
{
    dico_assoc_list_t p = dico_assoc_create(flags);
    if (!p)
 xalloc_die();
    return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 7
7 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
movsd  %xmm2,0x8(%rsp)
mov    0x8(%rsp),%rbp
movl   $0x1,(%rdi)
movl   $0x43524943,0x4(%rdi)
movb   $0x0,0x8(%rdi)
callq  6f <pict_newpoint>
mov    %rax,0x18(%rbx)
mov    %rbp,0x80(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pict_circle(pict *p, double cx, double cy, double r)
{
  p->pict_npts = 1;
  strcpy(p->pict_type, "CIRC");
  p->pict_pt = pict_newpoint(cx, cy);
  p->pict_r = r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 5
11 5
12 6
13 7
14 7
15 7
16 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1b0(%rdi),%rdx
lea    0xd8(%rdi),%rsi
mov    0x0(%rip),%rcx        # 48 <nettle_hmac_sha384_digest+0x1f>
callq  4d <nettle_hmac_sha384_digest+0x24>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_hmac_sha384_digest(struct hmac_sha512_ctx *ctx,
     size_t length, uint8_t *digest)
{
  nettle_hmac_digest( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_sha384), (length), (digest) );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    %rsi,%rdi
mov    $0x80,%esi
callq  12f <openssl_aes128_set_encrypt_key+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
openssl_aes128_set_encrypt_key(void *ctx, const uint8_t *key)
{
  AES_set_encrypt_key(key, 128, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%rdi)
jne    5c37 <info_quit+0x11>
cmpq   $0x0,0x8(%rdi)
je     5c3e <info_quit+0x18>
callq  5c3c <info_quit+0x16>
jmp    5c48 <info_quit+0x22>
movl   $0x1,0x0(%rip)        # 5c48 <info_quit+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_quit (WINDOW *window, int count)
{
  if (window->next || window->prev)
    info_delete_window (window, count);
  else
    quit_info_immediately = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 6
9 7
10 7
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdx        # 8 <license+0x8>
mov    0x0(%rip),%rsi        # f <license+0xf>
mov    $0x0,%edi
mov    $0x0,%eax
callq  1e <license+0x1e>
mov    $0x0,%edi
mov    $0x0,%ebx
add    $0x8,%rbx
callq  31 <license+0x31>
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    28 <license+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
license()
{
    char const *const *p = license_msg;
    printf ("%s %s\n", program_name, Version);
    while (*p) printf ("%s\n", *p++);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%rbx
jmp    233 <check_version+0x78>
callq  1cc <check_version+0x11>
mov    (%rax),%rax
movsbq 0x0(%rbp),%rdx
testb  $0x8,0x1(%rax,%rdx,2)
je     254 <check_version+0x99>
movsbq (%rbx),%rdx
testb  $0x8,0x1(%rax,%rdx,2)
je     25b <check_version+0xa0>
mov    %rbp,%rdi
callq  1ee <check_version+0x33>
mov    %eax,%r12d
mov    %rbx,%rdi
callq  1f9 <check_version+0x3e>
sub    %eax,%r12d
js     262 <check_version+0xa7>
test   %r12d,%r12d
jg     269 <check_version+0xae>
mov    $0x2e,%esi
mov    %rbp,%rdi
callq  210 <check_version+0x55>
mov    %rax,%rbp
cmp    $0x1,%rax
sbb    $0xffffffffffffffff,%rbp
mov    $0x2e,%esi
mov    %rbx,%rdi
callq  228 <check_version+0x6d>
mov    %rax,%rbx
cmp    $0x1,%rax
sbb    $0xffffffffffffffff,%rbx
test   %rbx,%rbx
je     23d <check_version+0x82>
test   %rbp,%rbp
jne    1c7 <check_version+0xc>
test   %rbx,%rbx
sete   %dl
jne    24f <check_version+0x94>
mov    $0x1,%eax
test   %rbp,%rbp
je     26e <check_version+0xb3>
movzbl %dl,%eax
jmp    26e <check_version+0xb3>
mov    $0xffffffff,%eax
jmp    26e <check_version+0xb3>
mov    $0xffffffff,%eax
jmp    26e <check_version+0xb3>
mov    $0x0,%eax
jmp    26e <check_version+0xb3>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
check_version(const char *target_version, const char *required_version)
{
 int result = 0;
 const char *tp = target_version;
 const char *rp = required_version;
 while (tp && rp) {
  if (!((*__ctype_b_loc ())[(int) ((*tp))] & (unsigned short int) _ISdigit) || !((*__ctype_b_loc ())[(int) ((*rp))] & (unsigned short int) _ISdigit))
   return -1;
  result = atoi(tp) - atoi(rp);
  if (result < 0)
   return 0;
  else if (result > 0)
   return 1;
  else {
   if ((tp = strchr(tp, '.')) != 0)
    tp++;
   if ((rp = strchr(rp, '.')) != 0)
    rp++;
  }
 }
 if (tp == 0 && rp == 0)
  return 1;
 else if (rp == 0)
  return 1;
 else
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 12
23 12
24 15
25 15
26 15
27 15
28 16
29 16
30 17
31 17
32 17
33 17
34 18
35 18
36 6
37 6
38 6
39 6
40 21
41 21
42 21
43 22
44 21
45 21
46 8
47 8
48 8
49 8
50 8
51 8
52 11
53 11
54 13
55 27
56 27
57 27
58 27
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
movq   $0x0,0x0(%rip)        # 778e <us_va_hdy+0x27>
movl   $0x3,0x0(%rip)        # 7798 <us_va_hdy+0x31>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  77a4 <us_va_hdy+0x3d>
cmp    $0x7ac,%ebx
jle    7828 <us_va_hdy+0xc1>
mov    $0x7ad,%eax
sub    %ebx,%eax
test   $0x3,%al
jne    7828 <us_va_hdy+0xc1>
mov    %ebx,%edx
mov    $0x1,%esi
mov    $0x14,%edi
callq  77c8 <us_va_hdy+0x61>
cmp    $0x7,%eax
sete   %r15b
movzbl %r15b,%r15d
add    $0x14,%r15d
mov    0x0(%rip),%rax        # 77de <us_va_hdy+0x77>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rdi        # 77ea <us_va_hdy+0x83>
callq  77ef <us_va_hdy+0x88>
mov    0x70(%rsp),%esi
mov    %esi,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0x1,(%rsp)
mov    %r15d,%r9d
mov    $0x0,%r8d
mov    0x28(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  7828 <us_va_hdy+0xc1>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
us_va_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "US_VA";
  observe_us_hdy = 3;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  if ((year > 1964) && !((1965 - year) & 3))
    {
      register int day;
      day = 20;
      if (weekday_of_date (day, 1, year) == 7)
 day++;
      holiday (*init_data, detected,
        gettext(hd_text[218].ht_text), ptr_cc_id,
        "*", day, 1, year, hd_elems, fday, count);
    }
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 12
16 12
17 12
18 13
19 13
20 13
21 13
22 13
23 13
24 17
25 17
26 17
27 17
28 16
29 16
30 16
31 16
32 19
33 19
34 20
35 20
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 19
49 23
50 23
51 23
52 23
53 23
54 23
55 23
56 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
test   %rax,%rax
je     435 <grecs_node_unlink+0x13>
mov    0x38(%rdi),%rdx
mov    %rdx,0x38(%rax)
jmp    446 <grecs_node_unlink+0x24>
mov    0x28(%rdi),%rax
test   %rax,%rax
je     45d <grecs_node_unlink+0x3b>
mov    0x38(%rdi),%rdx
mov    %rdx,0x30(%rax)
mov    0x38(%rdi),%rax
test   %rax,%rax
je     463 <grecs_node_unlink+0x41>
mov    0x40(%rdi),%rdx
mov    %rdx,0x40(%rax)
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
grecs_node_unlink(struct grecs_node *node)
{
 if (node->prev)
  node->prev->next = node->next;
 else if (node->up)
  node->up->down = node->next;
 else
  return 1;
 if (node->next)
  node->next->prev = node->prev;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 9
13 9
14 9
15 10
16 10
17 11
18 11
19 8
20 8
21 11
22 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x18(%rax),%rax
mov    %rax,0x8(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
opitr_first (void *owner)
{
  struct opool_iterator *itr = owner;
  itr->cur = itr->opool->head;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    $0x60,%edx
mov    0x0(%rip),%rax        # 13a <readLead+0x18>
callq  *(%rax)
cmp    $0x60,%rax
je     171 <readLead+0x4f>
callq  147 <readLead+0x25>
mov    (%rax),%ebx
mov    %rbp,%rdi
callq  151 <readLead+0x2f>
mov    %ebx,%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0xffffff91,%edi
mov    $0x0,%eax
callq  16a <readLead+0x48>
mov    $0x1,%eax
jmp    1b7 <readLead+0x95>
movzwl 0x6(%rbx),%edi
callq  17a <readLead+0x58>
mov    %ax,0x6(%rbx)
movzwl 0x8(%rbx),%edi
callq  187 <readLead+0x65>
mov    %ax,0x8(%rbx)
movzwl 0x4c(%rbx),%edi
callq  194 <readLead+0x72>
mov    %ax,0x4c(%rbx)
cmpb   $0x1,0x4(%rbx)
jbe    1b2 <readLead+0x90>
movzwl 0x4e(%rbx),%edi
callq  1a7 <readLead+0x85>
mov    %ax,0x4e(%rbx)
mov    $0x0,%eax
jmp    1b7 <readLead+0x95>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
readLead(FD_t fd, struct rpmlead *lead)
{
    if (ufdio->read(fd, (char *)lead, sizeof(*lead)) != sizeof(*lead)) {
 rpmError(-111, "read failed: %s (%d)", Fstrerror(fd),
       (*__errno_location ()));
 return 1;
    }
    lead->type = ntohs(lead->type);
    lead->archnum = ntohs(lead->archnum);
    lead->osnum = ntohs(lead->osnum);
    if (lead->major >= 2)
 lead->signature_type = ntohs(lead->signature_type);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 5
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 6
22 6
23 8
24 8
25 8
26 9
27 9
28 9
29 10
30 10
31 10
32 11
33 11
34 12
35 12
36 12
37 13
38 13
39 13
40 14
41 14
42 14
43 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm1        # c <zero_f+0xc>
movsd  %xmm0,0x8(%rsp)
callq  17 <zero_f+0x17>
movsd  0x8(%rsp),%xmm5
movapd %xmm5,%xmm1
mulsd  %xmm5,%xmm1
movsd  0x0(%rip),%xmm3        # 2d <zero_f+0x2d>
movapd %xmm3,%xmm2
divsd  %xmm1,%xmm2
movapd %xmm2,%xmm1
mulsd  %xmm2,%xmm1
movapd %xmm2,%xmm4
mulsd  0x0(%rip),%xmm4        # 49 <zero_f+0x49>
addsd  %xmm4,%xmm3
movapd %xmm1,%xmm4
mulsd  0x0(%rip),%xmm4        # 59 <zero_f+0x59>
addsd  %xmm4,%xmm3
movapd %xmm1,%xmm4
mulsd  0x0(%rip),%xmm4        # 69 <zero_f+0x69>
mulsd  %xmm4,%xmm2
addsd  %xmm3,%xmm2
movapd %xmm1,%xmm3
mulsd  0x0(%rip),%xmm3        # 7d <zero_f+0x7d>
mulsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
zero_f(double z)
{
  const double pre = pow(z, 2.0/3.0);
  const double zi2 = 1.0/(z*z);
  const double zi4 = zi2 * zi2;
  const double t1 = 5.0/48.0 * zi2;
  const double t2 = -5.0/36.0 * zi4;
  const double t3 = 77125.0/82944.0 * zi4 * zi2;
  const double t4 = -108056875.0/6967296.0 * zi4 * zi4;
  return pre * (1.0 + t1 + t2 + t3 + t4);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 6
14 6
15 10
16 7
17 7
18 10
19 8
20 8
21 8
22 10
23 9
24 9
25 9
26 10
27 10
28 11
29 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     402 <xget_version+0x18>
cmpb   $0x0,(%rsi)
je     402 <xget_version+0x18>
callq  3fd <xget_version+0x13>
nopl   (%rax)
jmp    419 <xget_version+0x2f>
mov    $0x0,%edi
callq  40c <xget_version+0x22>
mov    %rax,%rsi
mov    $0x0,%edi
callq  419 <xget_version+0x2f>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xget_version (char const *context, char const *version)
{
  if (version && *version)
    return get_version (context, version);
  else
    return get_version ("$VERSION_CONTROL", getenv ("VERSION_CONTROL"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r14
mov    %rcx,%r15
mov    %r8,%r12
mov    %r9d,%r13d
test   %rsi,%rsi
jne    5a7 <erealloc_real+0x49>
mov    $0x72c,%esi
mov    $0x0,%edi
callq  592 <erealloc_real+0x34>
mov    %r13d,%edx
mov    %r12,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  5a7 <erealloc_real+0x49>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  5b2 <erealloc_real+0x54>
mov    %rax,%rbp
test   %rax,%rax
jne    609 <erealloc_real+0xab>
mov    $0x730,%esi
mov    $0x0,%edi
callq  5c9 <erealloc_real+0x6b>
callq  5ce <erealloc_real+0x70>
mov    (%rax),%edi
callq  5d5 <erealloc_real+0x77>
mov    %rax,0x8(%rsp)
mov    $0x0,%edi
callq  5e4 <erealloc_real+0x86>
mov    0x8(%rsp),%rcx
mov    %rcx,(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  609 <erealloc_real+0xab>
mov    %rbp,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
erealloc_real(void *ptr, size_t count, const char *where, const char *var, const char *file, int line)
{
 void *ret;
 if (count == 0)
  (*(set_loc("awk.h", 1836), r_fatal))("%s:%d: erealloc called with zero bytes", file, line);
 ret = (void *) realloc(ptr, count);
 if (ret == ((void *)0))
  (*(set_loc("awk.h", 1840), r_fatal))(gettext("%s:%d:%s: %s: can't reallocate %ld bytes of memory (%s)"),
   file, line, where, var, (long) count, strerror((*__errno_location ())));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 7
29 7
30 8
31 8
32 8
33 9
34 8
35 8
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 11
50 11
51 11
52 11
53 11
54 11
55 11
56 11
57 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  3ca <compute_char_variance>
test   %rbx,%rbx
js     1b64 <gsl_stats_char_sd_m+0x15>
cvtsi2sd %rbx,%xmm1
jmp    1b7c <gsl_stats_char_sd_m+0x2d>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     1b8c <gsl_stats_char_sd_m+0x3d>
cvtsi2sd %rax,%xmm2
jmp    1ba1 <gsl_stats_char_sd_m+0x52>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    1c0a <gsl_stats_char_sd_m+0xbb>
test   %rbx,%rbx
js     1bbf <gsl_stats_char_sd_m+0x70>
cvtsi2sd %rbx,%xmm2
jmp    1bd7 <gsl_stats_char_sd_m+0x88>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm2
addsd  %xmm2,%xmm2
sub    $0x1,%rbx
js     1be4 <gsl_stats_char_sd_m+0x95>
cvtsi2sd %rbx,%xmm1
jmp    1bf9 <gsl_stats_char_sd_m+0xaa>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
callq  1c06 <gsl_stats_char_sd_m+0xb7>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_stats_char_sd_m (const char data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_char_variance (data, stride, n, mean);
  const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
  return sd;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 6
57 6
58 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%rbx
lea    0xc(%rsp),%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  b7e <mu_acl_string_to_action+0x1a>
test   %eax,%eax
jne    b88 <mu_acl_string_to_action+0x24>
mov    0xc(%rsp),%edx
mov    %edx,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_acl_string_to_action (const char *str, mu_acl_action_t *pres)
{
  int x;
  int rc = mu_kwd_xlat_name (action_tab, str, &x);
  if (rc == 0)
    *pres = x;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %esi,%esi
je     221 <CDB___ham_func4+0xe9>
lea    0x7(%rsi),%edx
shr    $0x3,%edx
and    $0x7,%esi
jmpq   *0x0(,%rsi,8)
mov    $0x0,%esi
mov    %esi,%eax
shl    $0x5,%eax
add    %eax,%esi
movzbl (%rdi),%ecx
add    %ecx,%esi
lea    0x1(%rdi),%rdi
jmp    171 <CDB___ham_func4+0x39>
mov    $0x0,%esi
mov    %esi,%eax
shl    $0x5,%eax
add    %esi,%eax
movzbl (%rdi),%ecx
add    %ecx,%eax
lea    0x1(%rdi),%rdi
jmp    188 <CDB___ham_func4+0x50>
mov    $0x0,%eax
mov    %eax,%ecx
shl    $0x5,%ecx
add    %ecx,%eax
lea    0x1(%rdi),%rcx
movzbl (%rdi),%esi
add    %esi,%eax
jmp    1a2 <CDB___ham_func4+0x6a>
mov    %rdi,%rcx
mov    $0x0,%eax
mov    %eax,%esi
shl    $0x5,%esi
add    %esi,%eax
lea    0x1(%rcx),%rdi
movzbl (%rcx),%ecx
add    %ecx,%eax
jmp    1b9 <CDB___ham_func4+0x81>
mov    $0x0,%eax
mov    %eax,%ecx
shl    $0x5,%ecx
add    %ecx,%eax
lea    0x1(%rdi),%rcx
movzbl (%rdi),%esi
add    %esi,%eax
jmp    1d3 <CDB___ham_func4+0x9b>
mov    %rdi,%rcx
mov    $0x0,%eax
mov    %eax,%esi
shl    $0x5,%esi
add    %esi,%eax
lea    0x1(%rcx),%rdi
movzbl (%rcx),%ecx
add    %ecx,%eax
jmp    1ea <CDB___ham_func4+0xb2>
mov    $0x0,%eax
mov    %eax,%ecx
shl    $0x5,%ecx
add    %ecx,%eax
lea    0x1(%rdi),%rcx
movzbl (%rdi),%esi
add    %esi,%eax
jmp    204 <CDB___ham_func4+0xcc>
mov    %rdi,%rcx
mov    $0x0,%eax
mov    %eax,%esi
shl    $0x5,%esi
add    %esi,%eax
movzbl (%rcx),%edi
lea    (%rax,%rdi,1),%esi
mov    %esi,%eax
sub    $0x1,%edx
je     221 <CDB___ham_func4+0xe9>
lea    0x1(%rcx),%rdi
jmpq   15a <CDB___ham_func4+0x22>
repz retq 
<<<sep_in_sample>>>
CDB___ham_func4(key, len)
 const void *key;
 u_int32_t len;
{
 const u_int8_t *k;
 u_int32_t h, loop;
 if (len == 0)
  return (0);
 h = 0;
 k = key;
 loop = (len + 8 - 1) >> 3;
 switch (len & (8 - 1)) {
 case 0:
  do {
   h = (h << 5) + h + *k++;;
 case 7:
   h = (h << 5) + h + *k++;;
 case 6:
   h = (h << 5) + h + *k++;;
 case 5:
   h = (h << 5) + h + *k++;;
 case 4:
   h = (h << 5) + h + *k++;;
 case 3:
   h = (h << 5) + h + *k++;;
 case 2:
   h = (h << 5) + h + *k++;;
 case 1:
   h = (h << 5) + h + *k++;;
  } while (--loop);
 }
 return (h);
}
<<<sep_in_sample>>>
1 8
2 7
3 7
4 11
5 11
6 12
7 12
8 9
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 9
17 17
18 17
19 17
20 17
21 17
22 17
23 17
24 9
25 19
26 19
27 19
28 19
29 19
30 19
31 19
32 10
33 9
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 9
42 23
43 23
44 23
45 23
46 23
47 23
48 23
49 10
50 9
51 25
52 25
53 25
54 25
55 25
56 25
57 25
58 9
59 27
60 27
61 27
62 27
63 27
64 27
65 27
66 10
67 9
68 29
69 29
70 29
71 29
72 29
73 29
74 30
75 30
76 29
77 29
78 33
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    47d <dico_list_set_free_item+0x1b>
sub    $0x8,%rsp
callq  470 <dico_list_set_free_item+0xe>
movl   $0x16,(%rax)
mov    $0x1,%eax
jmp    48b <dico_list_set_free_item+0x29>
mov    %rsi,0x30(%rdi)
mov    %rdx,0x38(%rdi)
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dico_list_set_free_item(struct dico_list *list,
   dico_list_iterator_t free_item, void *data)
{
    if (!list) {
 (*__errno_location ()) = 22;
 return 1;
    }
    list->free_item = free_item;
    list->free_data = data;
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 5
5 5
6 6
7 6
8 8
9 9
10 10
11 10
12 11
13 11
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
panel_window(this)
    panel_t *this;
{
    return this->window;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
movzbl 0x2f(%rdi),%eax
and    $0x1c,%eax
cmp    $0x18,%al
jne    4eb <print_auto_variable+0x18>
sub    $0x8,%rsp
callq  2c5 <print_variable>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
print_auto_variable (const void *item, void *arg)
{
  const struct variable *v = item;
  if (v->origin == o_automatic)
    print_variable (item, arg);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 2
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x1000,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  3a3 <save_current_path+0x16>
mov    $0x1000,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  3b5 <save_current_path+0x28>
mov    $0x0,%edi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
add    $0x0,%rcx
cmp    $0x0,%rcx
jbe    419 <save_current_path+0x8c>
lea    -0x1(%rcx),%rsi
cmpb   $0x2f,-0x1(%rcx)
jne    410 <save_current_path+0x83>
jmp    3f6 <save_current_path+0x69>
lea    -0x1(%rsi),%rdx
cmpb   $0x2f,-0x1(%rsi)
je     3fc <save_current_path+0x6f>
mov    %rdx,%rsi
jmp    410 <save_current_path+0x83>
mov    %rsi,%rdx
mov    %rcx,%rsi
movb   $0x0,(%rdx)
mov    $0x1000,%edx
mov    $0x0,%edi
callq  40e <save_current_path+0x81>
jmp    42b <save_current_path+0x9e>
cmp    $0x0,%rsi
jne    3e7 <save_current_path+0x5a>
mov    $0x1000,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  42b <save_current_path+0x9e>
pop    %rbx
retq   
<<<sep_in_sample>>>
save_current_path(const char *path)
{
 char *startp, *p;
 strlimcpy(current_path, path, sizeof(current_path));
 strlimcpy(current_dir, path, sizeof(current_path));
 startp = current_dir;
 p = startp + strlen(current_dir);
 while (p > startp) {
  if (*--p == '/') {
   *p = '\0';
   strlimcpy(current_file, p + 1, sizeof(current_file));
   return;
  }
 }
 strlimcpy(current_file, path, sizeof(current_file));
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 7
30 10
31 11
32 11
33 11
34 12
35 8
36 8
37 15
38 15
39 15
40 15
41 16
42 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xb0(%rdi),%rdi
callq  5b5b <info_clear_search+0x10>
movq   $0x0,0xb0(%rbx)
orl    $0x1,0x98(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
info_clear_search (WINDOW *window, int count)
{
  free (window->matches);
  window->matches = 0;
  window->flags |= 0x01;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
movq   $0x0,(%rdx)
lea    0x0(%rip),%rsi        # aa0 <splitline+0x1a>
callq  aa5 <splitline+0x1f>
mov    %rax,0x0(%rbp)
test   %rax,%rax
je     ade <splitline+0x58>
lea    0x0(%rip),%rsi        # ab5 <splitline+0x2f>
mov    $0x0,%edi
callq  abf <splitline+0x39>
mov    %rax,(%rbx)
test   %rax,%rax
je     ade <splitline+0x58>
mov    %rax,%rdi
callq  acf <splitline+0x49>
mov    %rax,(%rbx)
cmpb   $0x0,(%rax)
jne    ade <splitline+0x58>
movq   $0x0,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
splitline(char *line, char **first, char **second)
{
  *second = 0;
  *first = strtok(line, " \t\n");
  if (*first){
    *second = strtok(0, "\n");
    if (*second){
      *second = removepadding(*second);
      if (!**second)
        *second = 0;
    }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 7
17 7
18 8
19 8
20 8
21 9
22 9
23 10
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
test   %esi,%esi
js     51b <valprint+0xbc>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
movslq %edi,%rbp
shl    $0x3,%rbp
movslq %esi,%rsi
lea    (%rsi,%rsi,2),%rbx
shl    $0x3,%rbx
mov    %rbx,%rax
add    0x0(%rip),%rax        # 48a <valprint+0x2b>
mov    0x8(%rax),%esi
test   %esi,%esi
js     49b <valprint+0x3c>
mov    %r12d,%edi
callq  45f <valprint>
jmp    504 <valprint+0xa5>
movslq 0x10(%rax),%rax
mov    0x0(%rip),%rdx        # 4a6 <valprint+0x47>
mov    (%rdx,%rbp,1),%rdx
cmpl   $0x0,(%rdx,%rax,4)
je     4d8 <valprint+0x79>
mov    0x0(%rip),%rdx        # 4b7 <valprint+0x58>
mov    (%rdx,%rbp,1),%rdx
movsd  (%rdx,%rax,8),%xmm0
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 4cc <valprint+0x6d>
mov    $0x1,%eax
callq  4d6 <valprint+0x77>
jmp    4f3 <valprint+0x94>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 4e9 <valprint+0x8a>
mov    $0x0,%eax
callq  4f3 <valprint+0x94>
mov    0x0(%rip),%rsi        # 4fa <valprint+0x9b>
mov    $0x7c,%edi
callq  504 <valprint+0xa5>
mov    0x0(%rip),%rax        # 50b <valprint+0xac>
mov    0xc(%rax,%rbx,1),%esi
test   %esi,%esi
jns    475 <valprint+0x16>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
valprint(int row, int node)
{
  while (node >= 0)
    {
      if (collabel[node].labd >= 0)
 valprint(row, collabel[node].labd);
      else
 {
   if (valset[row][collabel[node].labc])
     fprintf(dap_lst, tabform, tableval[row][collabel[node].labc]);
   else
     fprintf(dap_lst, emptyform, "");
   _IO_putc ('|', dap_lst);
 }
      node = collabel[node].laba;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 9
8 9
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 12
34 12
35 12
36 12
37 12
38 13
39 13
40 13
41 15
42 15
43 3
44 3
45 17
46 17
47 17
48 17
<<<sep_out_sample>>>
mov    %rdi,%rax
test   %edx,%edx
jne    56d <__gmpn_mu_divappr_q_choose_in+0x48>
cmp    %rsi,%rdi
jle    54e <__gmpn_mu_divappr_q_choose_in+0x29>
lea    -0x1(%rdi),%rcx
mov    %rcx,%rax
cqto   
idiv   %rsi
lea    0x1(%rax),%rsi
mov    %rcx,%rax
cqto   
idiv   %rsi
add    $0x1,%rax
retq   
lea    (%rdi,%rdi,2),%rdx
cmp    %rdx,%rsi
jge    584 <__gmpn_mu_divappr_q_choose_in+0x5f>
sub    $0x1,%rax
mov    %rax,%rdx
shr    $0x3f,%rdx
add    %rdx,%rax
sar    %rax
add    $0x1,%rax
retq   
cmp    %rsi,%rdi
cmovg  %rsi,%rax
sub    $0x1,%rax
movslq %edx,%rcx
cqto   
idiv   %rcx
add    $0x1,%rax
repz retq 
<<<sep_in_sample>>>
__gmpn_mu_divappr_q_choose_in (mp_size_t qn, mp_size_t dn, int k)
{
  mp_size_t in;
  if (k == 0)
    {
      mp_size_t b;
      if (qn > dn)
 {
   b = (qn - 1) / dn + 1;
   in = (qn - 1) / b + 1;
 }
      else if (3 * qn > dn)
 {
   in = (qn - 1) / 2 + 1;
 }
      else
 {
   in = (qn - 1) / 1 + 1;
 }
    }
  else
    {
      mp_size_t xn;
      xn = ((dn) < (qn) ? (dn) : (qn));
      in = (xn - 1) / k + 1;
    }
  return in;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 7
5 7
6 9
7 9
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 12
17 12
18 12
19 14
20 14
21 14
22 14
23 14
24 14
25 14
26 24
27 24
28 25
29 25
30 25
31 25
32 25
33 28
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rsi,%r13
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
test   %rsi,%rsi
je     599 <substitute+0xc1>
test   %rdi,%rdi
je     599 <substitute+0xc1>
callq  50e <substitute+0x36>
mov    %rax,%r12
cmpq   $0x0,0x8(%r13)
je     5a0 <substitute+0xc8>
mov    $0x0,%ebx
mov    $0xffffffffffffffff,%r14
lea    0x1(%rbx),%ecx
mov    $0x0,%edx
mov    $0x4,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  542 <substitute+0x6a>
mov    0x8(%r13,%rbx,8),%rdx
mov    %rsp,%rsi
mov    %r12,%rdi
callq  d9 <insert>
mov    %rax,%rbp
test   %rax,%rax
je     58b <substitute+0xb3>
mov    %rax,%rdi
mov    $0x0,%eax
mov    %r14,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %r12,%rdi
callq  575 <substitute+0x9d>
mov    %rax,%r12
mov    %rbp,%rsi
mov    %rax,%rdi
callq  583 <substitute+0xab>
mov    %rbp,%rdi
callq  58b <substitute+0xb3>
add    $0x1,%rbx
cmpq   $0x0,0x8(%r13,%rbx,8)
jne    528 <substitute+0x50>
jmp    5a2 <substitute+0xca>
mov    $0x0,%eax
jmp    5a5 <substitute+0xcd>
jmp    5a5 <substitute+0xcd>
mov    %r12,%rax
mov    0x8(%rsp),%rdx
xor    %fs:0x28,%rdx
je     5ba <substitute+0xe2>
callq  5ba <substitute+0xe2>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
substitute (char *inbuf, char **subbuf)
{
  char **tmp = subbuf;
  char *tmpout = ((void *)0);
  char *tmpbuf = ((void *)0);
  char sign[5];
  int i = 0;
  if (!inbuf || !subbuf)
    return ((void *)0);
  tmpbuf = xstrdup (inbuf);
  tmp++;
  while (*tmp)
    {
      snprintf (sign, 4, "\\%d", i + 1);
      tmpout = insert (tmpbuf, sign, *tmp);
      if (tmpout)
 {
   tmpbuf = (char *) xrealloc ((char *) tmpbuf, strlen (tmpout) + 1);
   strcpy (tmpbuf, tmpout);
   free (tmpout);
 }
      tmp++;
      i++;
    }
  return tmpbuf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 8
12 8
13 8
14 8
15 10
16 10
17 12
18 12
19 12
20 18
21 18
22 14
23 14
24 14
25 14
26 14
27 15
28 15
29 15
30 15
31 15
32 16
33 16
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 19
44 19
45 19
46 20
47 20
48 20
49 12
50 12
51 12
52 9
53 9
54 9
55 9
56 26
57 26
58 26
59 26
60 26
61 26
62 26
63 26
64 26
65 26
66 26
<<<sep_out_sample>>>
test   %rdi,%rdi
je     56e <gsasl_server_callback_service_get+0xd>
mov    0xd8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_service_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_service : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
movsd  %xmm0,0x0(%rip)        # 63a <dis_setBandwidth+0x8>
retq   
<<<sep_in_sample>>>
dis_setBandwidth(double bps)
{
 bandwidth_bps = bps;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 5eb <do_prev_word_void+0xa>
shr    $0x1d,%edi
and    $0x1,%edi
mov    $0x1,%esi
callq  5fb <do_prev_word_void+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_prev_word_void(void)
{
    do_prev_word(((flags[((WORD_BOUNDS) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((WORD_BOUNDS) % (sizeof(unsigned) * 8)))) != 0), 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x1c(%rdi),%esi
mov    0x18(%rdi),%edi
callq  3cd <debpsf_close+0xf>
mov    0x14(%rbx),%edi
callq  3d5 <debpsf_close+0x17>
mov    0x18(%rbx),%edi
callq  3dd <debpsf_close+0x1f>
movl   $0xffffffff,0x14(%rbx)
movl   $0xffffffff,0x18(%rbx)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
debpsf_close(DEBPSF * dp)
{
 swlib_pipe_pump(dp->data_fdM, dp->source_data_fdM);
 uxfio_close(dp->control_fdM);
 uxfio_close(dp->data_fdM);
 dp->control_fdM = -1;
 dp->data_fdM = -1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 6
11 7
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rdx,%rcx
mov    %rsi,%rdx
lea    0x8(%rsp),%rsi
mov    $0x0,%edi
callq  1d <rpl_vasprintf+0x1d>
test   %rax,%rax
je     51 <rpl_vasprintf+0x51>
mov    0x8(%rsp),%rdx
cmp    $0x7fffffff,%rdx
jbe    4a <rpl_vasprintf+0x4a>
mov    %rax,%rdi
callq  38 <rpl_vasprintf+0x38>
callq  3d <rpl_vasprintf+0x3d>
movl   $0x4b,(%rax)
mov    $0xffffffff,%eax
jmp    56 <rpl_vasprintf+0x56>
mov    %rax,(%rbx)
mov    %edx,%eax
jmp    56 <rpl_vasprintf+0x56>
mov    $0xffffffff,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
rpl_vasprintf (char **resultp, const char *format, va_list args)
{
  size_t length;
  char *result = vasnprintf (((void *)0), &length, format, args);
  if (result == ((void *)0))
    return -1;
  if (length > 2147483647)
    {
      free (result);
      (*__errno_location ()) = 75;
      return -1;
    }
  *resultp = result;
  return length;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 9
15 9
16 10
17 10
18 11
19 11
20 13
21 14
22 14
23 6
24 15
25 15
26 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  22a3 <closure>
mov    0x5a0(%rbx),%rax
mov    %rax,%rdx
and    $0xfffffffffffffffd,%rdx
cmp    $0x10d,%rdx
je     26c1 <branch+0x56>
test   %rax,%rax
js     26c1 <branch+0x56>
mov    %rbx,%rdi
callq  22a3 <closure>
mov    $0x10c,%esi
mov    %rbx,%rdi
callq  a95 <addtok>
mov    0x5a0(%rbx),%rax
mov    %rax,%rdx
and    $0xfffffffffffffffd,%rdx
cmp    $0x10d,%rdx
je     26c1 <branch+0x56>
test   %rax,%rax
jns    2690 <branch+0x25>
pop    %rbx
retq   
<<<sep_in_sample>>>
branch (struct dfa* dfa)
{
  closure (dfa);
  while (dfa->parsestate.tok != RPAREN && dfa->parsestate.tok != OR
         && dfa->parsestate.tok >= 0)
    {
      closure (dfa);
      addtok (dfa, CAT);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 8
14 8
15 8
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 10
24 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  7bc <gsl_stats_variance+0x12>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  7ca <gsl_stats_variance+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_variance (const double data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_mean (data, stride, n);
  return gsl_stats_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
<<<sep_out_sample>>>
mov    %rdi,%r8
cmpb   $0x2f,(%rdi)
jne    11e9 <swlib_squash_leading_slash+0x31>
sub    $0x8,%rsp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
lea    0x1(%r8),%rsi
mov    %r8,%rdi
callq  11e5 <swlib_squash_leading_slash+0x2d>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
swlib_squash_leading_slash(char * name)
{
 if (*name == '/') {
  memmove(name, name+1, strlen(name));
 }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
test   %rdx,%rdx
je     292 <write_to_buf+0x7e>
mov    $0x20,%edi
callq  230 <write_to_buf+0x1c>
mov    %rax,(%rbx)
mov    %rbp,%rsi
mov    %r12,%rdi
callq  23e <write_to_buf+0x2a>
mov    %eax,%ebp
test   %eax,%eax
js     284 <write_to_buf+0x70>
mov    %eax,%esi
mov    (%rbx),%rdi
callq  24e <write_to_buf+0x3a>
mov    %eax,%ebx
jmp    276 <write_to_buf+0x62>
mov    $0x20,%edi
callq  25c <write_to_buf+0x48>
mov    %rax,%rbx
mov    %ebp,%esi
mov    %rax,%rdi
callq  269 <write_to_buf+0x55>
mov    %rbx,%rdi
callq  271 <write_to_buf+0x5d>
mov    $0x0,%ebx
mov    %ebp,%esi
mov    %r12,%rdi
callq  280 <write_to_buf+0x6c>
mov    %ebx,%eax
jmp    2a2 <write_to_buf+0x8e>
mov    $0xffffffff,%eax
jmp    2a2 <write_to_buf+0x8e>
mov    $0xffffffff,%eax
jmp    2a2 <write_to_buf+0x8e>
callq  297 <write_to_buf+0x83>
mov    %eax,%ebp
test   %eax,%eax
jns    252 <write_to_buf+0x3e>
nopl   (%rax)
jmp    28b <write_to_buf+0x77>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
write_to_buf(XFORMAT * xformat, char * name, STROB ** buf)
{
 int ufd;
 int ret;
 if (buf) *buf = strob_open(32);
 ufd = xformat_u_open_file(xformat, name);
 if (ufd < 0) return -1;
 if (buf) {
  ret = swlib_ascii_text_fd_to_buf(*buf, ufd);
 } else {
  STROB * tmp = strob_open(32);
  ret = swlib_ascii_text_fd_to_buf(tmp, ufd);
  strob_close(tmp);
  ret = 0;
 }
 xformat_u_close_file(xformat, ufd);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 11
24 11
25 11
26 12
27 12
28 12
29 13
30 13
31 14
32 16
33 16
34 16
35 17
36 17
37 7
38 7
39 7
40 7
41 6
42 6
43 7
44 7
45 7
46 7
47 18
48 18
49 18
50 18
<<<sep_out_sample>>>
test   %rdx,%rdx
je     32 <fwrite_uppcase+0x32>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rdx,%rbp
movzbl (%rbx),%edi
callq  1a <fwrite_uppcase+0x1a>
mov    %r12,%rsi
mov    %eax,%edi
callq  24 <fwrite_uppcase+0x24>
add    $0x1,%rbx
sub    $0x1,%rbp
jne    12 <fwrite_uppcase+0x12>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
fwrite_uppcase (FILE *fp, const char *src, size_t len)
{
  while (len-- > 0)
    {
      fputc (toupper ((unsigned char) *src), fp);
      ++src;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 3
16 3
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  22 <xstrdup+0x22>
mov    %rax,%rbx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  30 <xstrdup+0x30>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xstrdup (const char *s)
{
  char *t = (char *)xmalloc (strlen (s) + 1);
  strcpy (t, s);
  return t;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 6
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rdi
cmp    %rdi,%rsi
jae    486 <hash_get_max_bucket_length+0x4b>
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     47b <hash_get_max_bucket_length+0x40>
mov    0x8(%rsi),%rdx
test   %rdx,%rdx
je     46f <hash_get_max_bucket_length+0x34>
mov    $0x1,%ecx
add    $0x1,%rcx
mov    0x8(%rdx),%rdx
test   %rdx,%rdx
jne    460 <hash_get_max_bucket_length+0x25>
jmp    474 <hash_get_max_bucket_length+0x39>
mov    $0x1,%ecx
cmp    %rcx,%rax
cmovb  %rcx,%rax
add    $0x10,%rsi
cmp    %rdi,%rsi
jb     44c <hash_get_max_bucket_length+0x11>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
hash_get_max_bucket_length (const Hash_table *table)
{
  struct hash_entry const *bucket;
  size_t max_bucket_length = 0;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
 {
   struct hash_entry const *cursor = bucket;
   size_t bucket_length = 1;
   while (cursor = cursor->next, cursor)
     bucket_length++;
   if (bucket_length > max_bucket_length)
     max_bucket_length = bucket_length;
 }
    }
  return max_bucket_length;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 4
6 7
7 7
8 11
9 11
10 11
11 11
12 12
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 5
21 5
22 5
23 5
24 4
25 18
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 7dd <yyset_in+0x7>
retq   
<<<sep_in_sample>>>
yyset_in (FILE * in_str )
{
        yyin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%rbp
mov    %rdi,%rbx
lea    0x10(%rsp),%rdi
callq  13e7 <gamma_inc_a_gt_0+0x20>
mov    %eax,%r12d
lea    0x20(%rsp),%rdi
mov    %rbp,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
callq  13ff <gamma_inc_a_gt_0+0x38>
movsd  0x20(%rsp),%xmm0
movsd  0x10(%rsp),%xmm2
movapd %xmm0,%xmm1
mulsd  %xmm2,%xmm1
movsd  %xmm1,(%rbx)
movapd %xmm0,%xmm3
mulsd  0x18(%rsp),%xmm3
movsd  0x0(%rip),%xmm0        # 1429 <gamma_inc_a_gt_0+0x62>
andpd  %xmm0,%xmm3
mulsd  0x28(%rsp),%xmm2
andpd  %xmm0,%xmm2
addsd  %xmm3,%xmm2
andpd  %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 1447 <gamma_inc_a_gt_0+0x80>
addsd  %xmm1,%xmm2
movsd  %xmm2,0x8(%rbx)
test   %eax,%eax
cmove  %r12d,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gamma_inc_a_gt_0(double a, double x, gsl_sf_result * result)
{
  gsl_sf_result Q;
  gsl_sf_result G;
  const int stat_Q = gsl_sf_gamma_inc_Q_e(a, x, &Q);
  const int stat_G = gsl_sf_gamma_e(a, &G);
  result->val = G.val * Q.val;
  result->err = fabs(G.val * Q.err) + fabs(G.err * Q.val);
  result->err += 2.0*2.2204460492503131e-16 * fabs(result->val);
  return ((stat_G) != GSL_SUCCESS ? (stat_G) : ((stat_Q) != GSL_SUCCESS ? (stat_Q) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 9
31 10
32 10
33 11
34 11
35 11
36 11
37 11
<<<sep_out_sample>>>
mov    0x18(%rdi),%rcx
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     3c53 <gsl_matrix_uchar_set_zero+0x41>
mov    $0x0,%esi
jmp    3c45 <gsl_matrix_uchar_set_zero+0x33>
movb   $0x0,(%rax)
add    $0x1,%rax
cmp    %rax,%rdx
jne    3c2d <gsl_matrix_uchar_set_zero+0x1b>
add    $0x1,%rsi
add    %rdi,%rcx
cmp    %r9,%rsi
je     3c53 <gsl_matrix_uchar_set_zero+0x41>
test   %r8,%r8
je     3c39 <gsl_matrix_uchar_set_zero+0x27>
lea    (%rcx,%r8,1),%rdx
mov    %rcx,%rax
jmp    3c2d <gsl_matrix_uchar_set_zero+0x1b>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_uchar_set_zero (gsl_matrix_uchar * m)
{
  size_t i, j;
  unsigned char * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const unsigned char zero = 0U;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(unsigned char *) (data + 1 * (i * tda + j)) = zero;
        }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 9
6 9
7 9
8 9
9 13
10 13
11 11
12 11
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edx,%eax
movslq %ecx,%rdx
cltq   
add    %rax,%rsi
callq  244 <strsub+0x13>
movb   $0x0,(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strsub (char * dest, const char * string, int start, int length)
{
  char * end = stpncpy (dest, string + start, length);
  *end = '\0';
  return end;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     4fb <internal_warning+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    $0x1,%edi
callq  70 <error_prolog>
mov    $0x0,%edi
callq  512 <internal_warning+0x73>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 51c <internal_warning+0x7d>
mov    $0x0,%eax
callq  526 <internal_warning+0x87>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 55c <internal_warning+0xbd>
callq  561 <internal_warning+0xc2>
mov    0x0(%rip),%rsi        # 568 <internal_warning+0xc9>
mov    $0xa,%edi
callq  572 <internal_warning+0xd3>
add    $0xd0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
internal_warning (const char *format, ...)
{
  va_list args;
  error_prolog (1);
  fprintf (stderr, gettext("warning: "));
  __builtin_va_start(args,format);
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 5
27 6
28 6
29 6
30 6
31 6
32 6
33 7
34 7
35 7
36 7
37 8
38 8
39 8
40 10
41 10
42 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
callq  14d2 <coproc_fdclose+0x10>
mov    %ebp,%esi
mov    %rbx,%rdi
callq  14dc <coproc_fdclose+0x1a>
mov    %rbx,%rdi
callq  14e4 <coproc_fdclose+0x22>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
coproc_fdclose (cp, fd)
     struct coproc *cp;
     int fd;
{
  coproc_rclose (cp, fd);
  coproc_wclose (cp, fd);
  coproc_setvars (cp);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 7
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    0x8(%rsi),%rdx
cmp    %rdx,(%rsi)
cmovbe (%rsi),%rdx
mov    %rdx,(%rax)
mov    %r8,0x8(%rax)
mov    %rdi,0x10(%rax)
mov    %rcx,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_const_diagonal (const gsl_matrix_complex_long_double * m)
{
  _gsl_vector_complex_long_double_const_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1163 <sigquit+0x9>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x3,%edi
mov    $0x0,%eax
callq  117a <sigquit+0x20>
mov    $0xffffffff,%edi
callq  1184 <fatal>
<<<sep_in_sample>>>
sigquit (int signo)
{
  syslog (3, "got signal %s", strsignal (signo));
  dologout (-1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rax),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  10b <cprintf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_case_command_head (case_command)
     CASE_COM *case_command;
{
  cprintf ("case %s in ", case_command->word->word);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
test   %rcx,%rcx
jne    15d2c <gsl_fft_real_float_unpack+0x26>
sub    $0x8,%rsp
mov    $0x1,%cl
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15d25 <gsl_fft_real_float_unpack+0x1f>
mov    $0x1,%eax
jmp    15d62 <gsl_fft_real_float_unpack+0x5c>
lea    0x0(,%rdx,4),%r8
shl    $0x3,%rdx
mov    $0x0,%eax
xorps  %xmm1,%xmm1
movss  (%rdi),%xmm0
movss  %xmm0,(%rsi)
movss  %xmm1,0x4(%rsi)
add    $0x1,%rax
add    %r8,%rdi
add    %rdx,%rsi
cmp    %rcx,%rax
jne    15d40 <gsl_fft_real_float_unpack+0x3a>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_fft_real_float_unpack (const float real_coefficient[],
                               float complex_coefficient[],
                               const size_t stride, const size_t n)
{
  size_t i;
  if (n == 0)
    {
      do { gsl_error ("length n must be positive integer", "real_unpack.c", 31, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  for (i = 0; i < n; i++)
    {
      ((complex_coefficient)[2*(stride)*(i)]) = real_coefficient[i * stride];
      ((complex_coefficient)[2*(stride)*(i)+1]) = 0.0;
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 6
14 13
15 12
16 12
17 13
18 10
19 10
20 10
21 10
22 10
23 15
24 15
25 16
26 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %ecx,%ebx
mov    %r8,%r13
mov    %ecx,%edx
mov    %rdi,%rsi
lea    0x8(%rsp),%rdi
callq  18e5 <mu_get_config+0x24>
test   %eax,%eax
jne    191e <mu_get_config+0x5d>
mov    %ebx,%esi
mov    0x8(%rsp),%rdi
callq  18f5 <mu_get_config+0x34>
test   %eax,%eax
jne    192c <mu_get_config+0x6b>
mov    %r13,%r8
mov    %ebx,%ecx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    0x8(%rsp),%rdi
callq  190e <mu_get_config+0x4d>
mov    %eax,%ebx
lea    0x8(%rsp),%rdi
callq  191a <mu_get_config+0x59>
test   %ebx,%ebx
je     1925 <mu_get_config+0x64>
mov    $0x1000,%eax
jmp    1938 <mu_get_config+0x77>
mov    $0x0,%eax
jmp    1938 <mu_get_config+0x77>
lea    0x8(%rsp),%rdi
callq  1936 <mu_get_config+0x75>
jmp    191e <mu_get_config+0x5d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_get_config (const char *file, const char *progname,
               struct mu_cfg_param *progparam, int flags, void *target_ptr)
{
  mu_cfg_tree_t *parse_tree;
  int rc = mu_cfg_parse_file (&parse_tree, file, flags);
  if (rc == 0)
    {
      rc = mu_cfg_tree_postprocess (parse_tree, flags);
      if (rc == 0)
 rc = mu_cfg_tree_reduce (parse_tree, progname, progparam, flags,
     target_ptr);
      mu_cfg_destroy_tree (&parse_tree);
    }
  return rc == 0 ? 0 : (0x1000 +0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 6
15 6
16 8
17 8
18 8
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 14
31 14
32 14
33 14
34 14
35 14
36 12
37 12
38 12
39 15
40 15
41 15
42 15
43 15
44 15
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12 <gsasl_strerror+0x12>
cmp    $0x44,%ebx
jbe    28 <gsasl_strerror+0x28>
mov    $0x0,%esi
mov    $0x0,%edi
callq  26 <gsasl_strerror+0x26>
jmp    4d <gsasl_strerror+0x4d>
movslq %ebx,%rbx
lea    (%rbx,%rbx,2),%rax
mov    0x0(,%rax,8),%rsi
test   %rsi,%rsi
mov    $0x0,%eax
cmove  %rax,%rsi
mov    $0x0,%edi
callq  4d <gsasl_strerror+0x4d>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsasl_strerror (int err)
{
  static const char *unknown = "Libgsasl unknown error";
  const char *p;
  bindtextdomain ("libgsasl", "/usr/local/share/locale");
  if (err < 0 || err >= (sizeof (errors) / sizeof (errors[0])))
    return dgettext ("libgsasl", unknown);
  p = errors[err].description;
  if (!p)
    p = unknown;
  return dgettext ("libgsasl", p);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 10
16 10
17 10
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # f1 <closetoken+0xb>
callq  f6 <closetoken+0x10>
mov    0x0(%rip),%rdi        # fd <closetoken+0x17>
callq  102 <closetoken+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
closetoken(void)
{
 strbuf_close(ib);
 fclose(ip);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4b <tty_restartany+0x6>
shr    $0xb,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
tty_restartany (void)
{
  return (termbuf.c_iflag & 0004000) ? 1 : 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x0,%rdi
je     17a <get_line_node_addr+0x58>
mov    0x0(%rip),%rdx        # 136 <get_line_node_addr+0x14>
cmp    $0x0,%rdx
je     181 <get_line_node_addr+0x5f>
mov    $0x0,%ecx
add    $0x1,%ecx
cmp    %rdx,%rdi
je     15a <get_line_node_addr+0x38>
mov    (%rdx),%rdx
cmp    $0x0,%rdx
jne    144 <get_line_node_addr+0x22>
jmp    18c <get_line_node_addr+0x6a>
mov    %ecx,%eax
test   %ecx,%ecx
je     194 <get_line_node_addr+0x72>
cmp    $0x0,%rdx
jne    188 <get_line_node_addr+0x66>
mov    $0x0,%edi
callq  173 <get_line_node_addr+0x51>
mov    $0xffffffff,%eax
jmp    194 <get_line_node_addr+0x72>
mov    $0x0,%eax
jmp    194 <get_line_node_addr+0x72>
mov    $0x0,%eax
jmp    194 <get_line_node_addr+0x72>
mov    %ecx,%eax
jmp    194 <get_line_node_addr+0x72>
test   %ecx,%ecx
xchg   %ax,%ax
jne    169 <get_line_node_addr+0x47>
mov    %ecx,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
get_line_node_addr( const line_t * const lp )
  {
  const line_t * p = &buffer_head;
  int addr = 0;
  while( p != lp && ( p = p->q_forw ) != &buffer_head ) ++addr;
  if( addr && p == &buffer_head )
    { set_error_msg( "Invalid address" ); return -1; }
  return addr;
  }
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 5
25 5
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 5
34 9
35 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b6 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r13
mov    0x8(%rdi),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     517 <hol_find_entry+0x7d>
mov    %rsi,%r12
mov    %edx,%eax
add    $0x1,%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
lea    0x0(%r13,%rax,1),%r14
mov    0x0(%r13),%rbx
mov    0x8(%r13),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     50c <hol_find_entry+0x72>
mov    %edx,%eax
lea    0x3(%rax,%rax,2),%rbp
shl    $0x4,%rbp
add    %rbx,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     503 <hol_find_entry+0x69>
testb  $0x2,0x18(%rbx)
jne    503 <hol_find_entry+0x69>
mov    %r12,%rsi
callq  4ff <hol_find_entry+0x65>
test   %eax,%eax
je     51e <hol_find_entry+0x84>
add    $0x30,%rbx
cmp    %rbp,%rbx
jne    4e9 <hol_find_entry+0x4f>
add    $0x38,%r13
cmp    %r14,%r13
jne    4cc <hol_find_entry+0x32>
jmp    523 <hol_find_entry+0x89>
mov    $0x0,%eax
jmp    528 <hol_find_entry+0x8e>
mov    %r13,%rax
jmp    528 <hol_find_entry+0x8e>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
hol_find_entry (struct hol *hol, const char *name)
{
  struct hol_entry *entry = hol->entries;
  unsigned num_entries = hol->num_entries;
  while (num_entries-- > 0)
    {
      const struct argp_option *opt = entry->opt;
      unsigned num_opts = entry->num;
      while (num_opts-- > 0)
 if (opt->name && (! ((opt)->flags & 0x2)) && strcmp (opt->name, name) == 0)
   return entry;
 else
   opt++;
      entry++;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 13
37 9
38 9
39 14
40 5
41 5
42 5
43 16
44 16
45 16
46 16
47 16
48 17
49 17
50 17
51 17
52 17
53 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
mov    %rsi,%rbp
test   %edi,%edi
jle    bb2 <_prog_wait+0x2e>
mov    $0x0,%edx
mov    %rbp,%rsi
mov    %ebx,%edi
callq  ba2 <_prog_wait+0x1e>
cmp    $0xffffffff,%eax
jne    bb2 <_prog_wait+0x2e>
callq  bac <_prog_wait+0x28>
cmpl   $0x4,(%rax)
nop
je     b93 <_prog_wait+0xf>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_prog_wait (pid_t pid, int *pstatus)
{
  if (pid > 0)
    {
      pid_t t;
      do
 t = waitpid (pid, pstatus, 0);
      while (t == -1 && (*__errno_location ()) == 4);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 10
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %rbx
sub    $0x50,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
mov    %rdi,%rbx
movl   $0x8,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
test   %rdi,%rdi
je     94 <__gmpq_clears+0x94>
movslq (%rbx),%rsi
shl    $0x3,%rsi
mov    0x8(%rbx),%rdi
callq  *0x0(%rip)        # 53 <__gmpq_clears+0x53>
movslq 0x10(%rbx),%rsi
shl    $0x3,%rsi
mov    0x18(%rbx),%rdi
callq  *0x0(%rip)        # 65 <__gmpq_clears+0x65>
mov    0x8(%rsp),%eax
cmp    $0x30,%eax
jae    7e <__gmpq_clears+0x7e>
mov    %eax,%edx
add    0x18(%rsp),%rdx
add    $0x8,%eax
mov    %eax,0x8(%rsp)
jmp    8c <__gmpq_clears+0x8c>
mov    0x10(%rsp),%rdx
lea    0x8(%rdx),%rax
mov    %rax,0x10(%rsp)
mov    (%rdx),%rbx
test   %rbx,%rbx
jne    42 <__gmpq_clears+0x42>
add    $0x50,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmpq_clears (mpq_ptr x, ...)
{
  va_list ap;
  __builtin_va_start(ap,x);
  while (x != ((void *)0))
    {
      (*__gmp_free_func) ((((&((x)->_mp_num)))->_mp_d), ((((&((x)->_mp_num)))->_mp_alloc)) * sizeof (mp_limb_t));
      (*__gmp_free_func) ((((&((x)->_mp_den)))->_mp_d), ((((&((x)->_mp_den)))->_mp_alloc)) * sizeof (mp_limb_t));
      x = __builtin_va_arg(ap,mpq_ptr);
    }
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 5
37 5
38 12
39 12
40 12
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%ecx
xorpd  %xmm0,%xmm0
mov    $0xaaaaaaab,%r8d
add    $0x1,%ecx
mov    %ecx,%eax
mul    %r8d
shr    $0x3,%edx
lea    (%rdx,%rdx,2),%eax
shl    $0x2,%eax
mov    %ecx,%edx
sub    %eax,%edx
movslq (%rdi,%rdx,4),%rdx
movslq (%rsi),%rax
lea    (%rax,%rax,2),%rax
lea    (%rdx,%rax,4),%rax
addsd  0x0(,%rax,8),%xmm0
add    $0x4,%rsi
cmp    $0xc,%ecx
jne    12 <Etsp+0x12>
repz retq 
<<<sep_in_sample>>>
Etsp(void *xp)
{
  int *route = (int *) xp;
  double E = 0;
  unsigned int i;
  for (i = 0; i < (sizeof(cities)/sizeof(Stsp_city)); ++i) {
    E += distance_matrix[route[i]][route[(i + 1) % (sizeof(cities)/sizeof(Stsp_city))]];
  }
  return E;
}
<<<sep_in_sample>>>
1 2
2 6
3 4
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 6
20 6
21 10
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    0x88(%rdi),%rdx
mov    0x80(%rdi),%rsi
cmp    %rsi,%rdx
jbe    9f9 <imap_send+0x71>
movq   $0x0,0x8(%rsp)
sub    %rsi,%rdx
mov    %rdx,%r12
mov    (%rdi),%rax
mov    0x18(%rax),%rdi
lea    0x8(%rsp),%r8
mov    $0x0,%ecx
callq  9cb <imap_send+0x43>
mov    %eax,%ebp
test   %eax,%eax
jne    a05 <imap_send+0x7d>
mov    0x8(%rsp),%rsi
mov    0x80(%rbx),%rdi
mov    %r12,%rdx
sub    %rsi,%rdx
add    %rdi,%rsi
callq  9eb <imap_send+0x63>
mov    0x8(%rsp),%rax
sub    %rax,0x88(%rbx)
jmp    a05 <imap_send+0x7d>
mov    %rsi,0x88(%rdi)
mov    $0x0,%ebp
mov    %ebp,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
imap_send (f_imap_t f_imap)
{
  int status = 0;
  if (f_imap->ptr > f_imap->buffer)
    {
      size_t len;
      size_t n = 0;
      len = f_imap->ptr - f_imap->buffer;
      status = mu_stream_write (f_imap->folder->stream, f_imap->buffer, len,
        0, &n);
      if (status == 0)
        {
          memmove (f_imap->buffer, f_imap->buffer + n, len - n);
          f_imap->ptr -= n;
        }
    }
  else
    f_imap->ptr = f_imap->buffer;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 7
11 8
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 18
31 3
32 20
33 20
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
cmp    $0x0,%rdi
je     2a43 <rl_get_keymap_name+0x24>
mov    $0x0,%edx
jmp    2a39 <rl_get_keymap_name+0x1a>
add    $0x10,%rdx
cmp    %rdi,-0x8(%rdx)
je     2a48 <rl_get_keymap_name+0x29>
mov    (%rdx),%rax
test   %rax,%rax
jne    2a2f <rl_get_keymap_name+0x10>
repz retq 
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
rl_get_keymap_name (map)
     Keymap map;
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (map == keymap_names[i].map)
      return ((char *)keymap_names[i].name);
  return ((char *)((void *)0));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 5
9 5
10 5
11 5
12 5
13 9
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
ppdwrap (void)
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %esi,%esi
jne    5ab <command_generator+0x6b>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,0x0(%rip)        # 567 <command_generator+0x27>
movl   $0x0,0x0(%rip)        # 571 <command_generator+0x31>
jmp    5ab <command_generator+0x6b>
add    $0x1,%ecx
mov    %ecx,0x0(%rip)        # 57c <command_generator+0x3c>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  58a <command_generator+0x4a>
test   %eax,%eax
jne    5b2 <command_generator+0x72>
mov    %rbx,%rdi
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rbx,%rdi
callq  5a9 <command_generator+0x69>
jmp    5d1 <command_generator+0x91>
mov    0x0(%rip),%r12        # 5b2 <command_generator+0x72>
mov    0x0(%rip),%ecx        # 5b8 <command_generator+0x78>
movslq %ecx,%rax
lea    (%rax,%rax,4),%rax
mov    0x0(,%rax,8),%rbx
test   %rbx,%rbx
jne    573 <command_generator+0x33>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
command_generator(const char *text, int state)
{
 static size_t textlen;
 static int idx = 0;
 char *name;
 if (! state) {
  textlen = strlen(text);
  idx = 0;
 }
 while ((name = (char *) zz_debug_cmdtab[idx].name) != ((void *)0)) {
  idx++;
  if (strncmp(name, text, textlen) == 0)
   return estrdup(name, strlen(name));
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 12
32 10
33 10
34 10
35 10
36 10
37 10
38 15
39 16
40 16
41 16
42 16
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
<<<sep_in_sample>>>
swicol_get_setvxk(SWICOL * swicol)
{
 return swicol->setvxM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <yywrap+0x7>
cmp    %rax,0x0(%rip)        # e <yywrap+0xe>
je     32 <yywrap+0x32>
mov    %rax,0x0(%rip)        # 17 <yywrap+0x17>
movq   $0x0,0x0(%rip)        # 22 <yywrap+0x22>
movl   $0x1,0x0(%rip)        # 2c <yywrap+0x2c>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
yywrap (void)
{
  if (yyin != stdin)
    {
      yyin = stdin;
      filename = "";
      curline = 1;
      return 0;
    }
  else
    return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 6
6 7
7 8
8 8
9 11
10 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    0x0(%rip),%rbx        # f40 <get_internal_info_window+0xe>
test   %rbx,%rbx
je     f6d <get_internal_info_window+0x3b>
mov    0x30(%rbx),%rbp
mov    %rbp,%rdi
callq  f51 <get_internal_info_window+0x1f>
test   %eax,%eax
je     f65 <get_internal_info_window+0x33>
mov    0x10(%rbp),%rdi
mov    %r12,%rsi
callq  f61 <get_internal_info_window+0x2f>
test   %eax,%eax
je     f6d <get_internal_info_window+0x3b>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    f45 <get_internal_info_window+0x13>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
get_internal_info_window (char *name)
{
  WINDOW *win;
  for (win = windows; win; win = win->next)
    if (internal_info_node_p (win->node) &&
        (strcmp (win->node->nodename, name) == 0))
      break;
  return win;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 4
19 4
20 4
21 9
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r14
mov    0x20(%rdi),%r13
mov    $0x3,%edi
callq  19c9 <swverid_u_parse_swspec+0x1c>
mov    %rax,%rbp
mov    %rax,0x20(%rbx)
mov    0x8(%rbx),%r12
mov    %r14,%rdi
callq  19dc <swverid_u_parse_swspec+0x2f>
mov    %rax,0x8(%rbx)
mov    %rbx,%rdi
callq  e9e <parse_swspec_string>
mov    0x8(%rbx),%rdi
callq  19f1 <swverid_u_parse_swspec+0x44>
mov    %r13,0x20(%rbx)
mov    %r12,0x8(%rbx)
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
swverid_u_parse_swspec(SWVERID * swverid, char * swspec)
{
 CPLOB * list;
 CPLOB * savecplob;
 char * savesource;
 savecplob = swverid->taglistM;
 list = cplob_open(3);
 swverid->taglistM = list;
 savesource = swverid->source_copyM;
 swverid->source_copyM = strdup(swspec);
 parse_swspec_string(swverid);
 free(swverid->source_copyM);
 swverid->taglistM = savecplob;
 swverid->source_copyM = savesource;
 return list;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 7
10 7
11 7
12 8
13 9
14 10
15 10
16 10
17 11
18 11
19 12
20 12
21 13
22 14
23 16
24 16
25 16
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    17a <argp_fmtstream_set_wmargin+0x1f>
callq  17a <argp_fmtstream_set_wmargin+0x1f>
mov    0x18(%rbx),%rax
mov    %rbp,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->wmargin;
  __fs->wmargin = __wmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     165 <grecs_version_info_free+0x1f>
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     15d <grecs_version_info_free+0x17>
callq  15d <grecs_version_info_free+0x17>
mov    %rbx,%rdi
callq  165 <grecs_version_info_free+0x1f>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_version_info_free(struct grecs_version_info *pv)
{
 if (pv) {
  if (pv->buffer)
   grecs_free(pv->buffer);
  free(pv);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 8
12 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x30(%rdi),%rdi
callq  19c4 <xformat_get_tar_groupname+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_get_tar_groupname (XFORMAT * xux)
{
 ;
 return ahs_get_tar_groupname(xux->ahsM);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xf30(%rdi),%rdi
test   %rdi,%rdi
je     1278 <CloseMarkovFiles+0x2b>
callq  1262 <CloseMarkovFiles+0x15>
mov    0xf28(%rbx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1278 <CloseMarkovFiles+0x2b>
pop    %rbx
retq   
<<<sep_in_sample>>>
CloseMarkovFiles (PANALYSIS panal)
{
  if (panal->gd.pfileOut) {
    fclose (panal->gd.pfileOut);
    printf ("\nWrote results to \"%s\"\n", panal->gd.szGout);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
test   %rdx,%rdx
je     16d <gsl_stats_quantile_from_sorted_data+0xa5>
sub    $0x1,%rdx
js     de <gsl_stats_quantile_from_sorted_data+0x16>
cvtsi2sd %rdx,%xmm1
jmp    f6 <gsl_stats_quantile_from_sorted_data+0x2e>
mov    %rdx,%rax
shr    %rax
mov    %rdx,%rcx
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    113 <gsl_stats_quantile_from_sorted_data+0x4b>
shl    $0x3,%rsi
imul   %rsi,%rdx
movsd  (%rdi,%rdx,1),%xmm0
retq   
test   %rax,%rax
js     11f <gsl_stats_quantile_from_sorted_data+0x57>
cvtsi2sd %rax,%xmm1
jmp    137 <gsl_stats_quantile_from_sorted_data+0x6f>
mov    %rax,%rdx
shr    %rdx
mov    %rax,%rcx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
subsd  %xmm1,%xmm0
movapd %xmm0,%xmm1
shl    $0x3,%rsi
movsd  0x0(%rip),%xmm0        # 14b <gsl_stats_quantile_from_sorted_data+0x83>
subsd  %xmm1,%xmm0
mov    %rsi,%rdx
imul   %rax,%rdx
mulsd  (%rdi,%rdx,1),%xmm0
add    $0x1,%rax
imul   %rax,%rsi
mulsd  (%rdi,%rsi,1),%xmm1
addsd  %xmm1,%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_quantile_from_sorted_data (const double sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 12
18 12
19 14
20 14
21 14
22 14
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 18
37 18
38 18
39 18
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 11
48 21
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %rdi,%rdi
je     42fb <free_fail_stack_return+0x50>
cmpq   $0x0,(%rdi)
je     42f2 <free_fail_stack_return+0x47>
mov    $0x0,%ebx
mov    $0x0,%r12d
mov    0x10(%rbp),%rax
mov    0x28(%rax,%rbx,1),%rdi
callq  42d6 <free_fail_stack_return+0x2b>
mov    0x10(%rbp),%rax
mov    0x10(%rax,%rbx,1),%rdi
callq  42e4 <free_fail_stack_return+0x39>
add    $0x1,%r12
add    $0x30,%rbx
cmp    %r12,0x0(%rbp)
ja     42c8 <free_fail_stack_return+0x1d>
mov    0x10(%rbp),%rdi
callq  42fb <free_fail_stack_return+0x50>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
free_fail_stack_return (struct re_fail_stack_t *fs)
{
  if (fs)
    {
      Idx fs_idx;
      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
 {
   free ((&fs->stack[fs_idx].eps_via_nodes)->elems);
   free (fs->stack[fs_idx].regs);
 }
      free (fs->stack);
    }
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 6
8 6
9 6
10 6
11 8
12 8
13 8
14 9
15 9
16 9
17 6
18 6
19 6
20 6
21 11
22 11
23 14
24 14
25 14
26 14
27 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edx,%r12d
mov    %edx,%edx
mov    0x0(%rip),%rax        # 59 <print_bibtex+0x16>
cmpl   $0x1,(%rax,%rdx,4)
jne    b1 <print_bibtex+0x6e>
mov    %r9,%r13
cmp    $0x1,%ecx
jne    b1 <print_bibtex+0x6e>
cmp    $0x1a,%r12d
je     7e <print_bibtex+0x3b>
mov    $0x0,%ebx
cmpq   $0x0,0x0(%rip)        # 7a <print_bibtex+0x37>
jne    8f <print_bibtex+0x4c>
jmp    b1 <print_bibtex+0x6e>
mov    %r9,%rdi
callq  86 <print_bibtex+0x43>
mov    %rax,0x0(%rip)        # 8d <print_bibtex+0x4a>
jmp    b1 <print_bibtex+0x6e>
cmpq   $0x0,(%rbx)
jne    a6 <print_bibtex+0x63>
cmp    %r12d,-0x8(%rbx)
jne    a6 <print_bibtex+0x63>
mov    %r13,%rdi
callq  a3 <print_bibtex+0x60>
mov    %rax,(%rbx)
add    $0x18,%rbx
cmpq   $0x0,-0x10(%rbx)
jne    8f <print_bibtex+0x4c>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
print_bibtex (void *cls,
       const char *plugin_name,
       enum EXTRACTOR_MetaType type,
       enum EXTRACTOR_MetaFormat format,
       const char *data_mime_type,
       const char *data,
       size_t data_len)
{
  unsigned int i;
  if (1 != print[type])
    return 0;
  if (EXTRACTOR_METAFORMAT_UTF8 != format)
    return 0;
  if (EXTRACTOR_METATYPE_BIBTEX_ENTRY_TYPE == type)
    {
      entry_type = strdup (data);
      return 0;
    }
  for (i = 0; ((void *)0) != btm[i].bibTexName; i++)
    if ( (((void *)0) == btm[i].value) &&
  (btm[i].le_type == type) )
      btm[i].value = strdup (data);
  return 0;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
7 10
8 10
9 10
10 10
11 10
12 12
13 12
14 14
15 14
16 14
17 19
18 19
19 19
20 16
21 16
22 16
23 17
24 20
25 20
26 20
27 20
28 22
29 22
30 22
31 22
32 19
33 19
34 24
35 24
36 24
37 24
38 24
39 24
40 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # e84 <ORCSclose+0xb>
mov    0xd8(%rax),%edi
test   %edi,%edi
js     ebb <ORCSclose+0x42>
callq  e93 <ORCSclose+0x1a>
test   %eax,%eax
jns    eaa <ORCSclose+0x31>
mov    0x0(%rip),%rax        # e9e <ORCSclose+0x25>
mov    0x70(%rax),%rax
mov    (%rax),%rdi
callq  eaa <ORCSclose+0x31>
mov    0x0(%rip),%rax        # eb1 <ORCSclose+0x38>
movl   $0xffffffff,0xd8(%rax)
mov    0x0(%rip),%rax        # ec2 <ORCSclose+0x49>
lea    0x198(%rax),%rdi
callq  ece <ORCSclose+0x55>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ORCSclose (void)
{
  int repo_fd_lock = (top->repository. fd_lock);
  if (0 <= repo_fd_lock)
    {
      if ((0 > (close (repo_fd_lock))))
        fatal_sys (((top->behavior. sff)[0].filename));
      (top->repository. fd_lock) = -1;
    }
  Ozclose (&(top->flow. rewr));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 8
15 10
16 10
17 10
18 11
19 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,(%rdi)
je     d56 <rec_rset_type+0x3b>
mov    $0x5,%edi
callq  d2f <rec_rset_type+0x14>
mov    $0x0,%edx
mov    %rax,%rsi
mov    (%rbx),%rdi
callq  d3f <rec_rset_type+0x24>
test   %rax,%rax
je     d5d <rec_rset_type+0x42>
mov    %rax,%rdi
callq  d4c <rec_rset_type+0x31>
mov    %rax,%rdi
callq  d54 <rec_rset_type+0x39>
jmp    d62 <rec_rset_type+0x47>
mov    $0x0,%eax
jmp    d62 <rec_rset_type+0x47>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
rec_rset_type (rec_rset_t rset)
{
  char *res;
  rec_field_t field;
  res = ((void *)0);
  if (rset->descriptor)
    {
      field = rec_record_get_field_by_name (rset->descriptor,
                                            rec_std_field_name ((REC_FIELD_REC)),
                                            0);
      if (field)
        {
          res = rec_extract_type (rec_field_value (field));
        }
    }
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 11
12 11
13 13
14 13
15 13
16 13
17 13
18 5
19 5
20 5
21 17
22 17
<<<sep_out_sample>>>
movapd %xmm1,%xmm5
subsd  %xmm4,%xmm5
movapd %xmm5,%xmm4
subsd  %xmm0,%xmm1
divsd  %xmm1,%xmm4
mulsd  %xmm4,%xmm2
movsd  0x0(%rip),%xmm0        # 4b61 <linearinterp+0x20>
subsd  %xmm4,%xmm0
mulsd  %xmm0,%xmm3
addsd  %xmm3,%xmm2
movapd %xmm2,%xmm0
retq   
<<<sep_in_sample>>>
linearinterp(double a, double b, double aval, double bval, double c)
{
  double lambda;
  lambda = (b-c)/(b-a);
  return lambda*aval + (1-lambda)*bval;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
<<<sep_out_sample>>>
test   %rsi,%rsi
je     10ac <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jae    10b2 <_argp_input+0x3e>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
jmp    1098 <_argp_input+0x24>
cmp    %rdi,0x8(%rax)
jne    109d <_argp_input+0x29>
mov    0x30(%rax),%rax
retq   
add    $0x48,%rax
cmp    %rdx,%rax
jb     1092 <_argp_input+0x1e>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
        if (group->argp == argp)
          return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 7
16 7
17 7
18 11
19 11
20 11
21 11
22 11
23 12
<<<sep_out_sample>>>
movslq (%rdi),%rax
cmp    %rsi,%rax
jbe    8c5 <rec_fex_get+0xe>
mov    0x10(%rdi,%rsi,8),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rec_fex_get (rec_fex_t fex,
             size_t position)
{
  if ((position < 0) || (position >= fex->num_elems))
    {
      return ((void *)0);
    }
  return fex->elems[position];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 8
5 8
6 6
7 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %rdi,%rdi
je     de1 <il_insert_text+0xc9>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    0x0(%rip),%r12        # d40 <il_insert_text+0x28>
mov    0x50(%r12),%rax
lea    -0x1(%rcx),%rbx
add    0x38(%r12),%rcx
cmp    %rax,%rcx
jbe    d6c <il_insert_text+0x54>
lea    0x21(%rbx,%rax,1),%rsi
mov    %rsi,0x50(%r12)
mov    0x58(%r12),%rdi
callq  d67 <il_insert_text+0x4f>
mov    %rax,0x58(%r12)
mov    0x0(%rip),%rdx        # d73 <il_insert_text+0x5b>
mov    0x18(%rdx),%rax
mov    0x58(%rdx),%rcx
mov    0x38(%rdx),%rdx
add    $0x1,%rdx
sub    %rax,%rdx
lea    (%rcx,%rax,1),%rsi
add    %rbx,%rax
lea    (%rcx,%rax,1),%rdi
callq  d96 <il_insert_text+0x7e>
mov    0x0(%rip),%rax        # d9d <il_insert_text+0x85>
mov    0x58(%rax),%rdi
add    0x18(%rax),%rdi
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  db0 <il_insert_text+0x98>
mov    0x0(%rip),%rax        # db7 <il_insert_text+0x9f>
mov    0x58(%rax),%rdi
add    0x18(%rax),%rdi
mov    %rbx,%rsi
callq  dc7 <il_insert_text+0xaf>
mov    0x0(%rip),%rax        # dce <il_insert_text+0xb6>
add    %rbx,0x18(%rax)
add    %rbx,0x38(%rax)
add    %rbx,0x48(%rax)
movl   $0x16,0x10(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
il_insert_text(text)
    char *text;
{
    size_t len;
    if (text == ((void *)0))
 return;
    len = strlen(text);
    if (il->length + len + 1 > il->size)
 { il->size = il->size + len + 1 + 32; il->buffer = xrealloc(il->buffer, il->size); };
    memmove(il->buffer + il->point + len,
     il->buffer + il->point,
     il->length - il->point + 1);
    memcpy(il->buffer + il->point, text, len);
    toprintable(il->buffer + il->point, len);
    il->point += len;
    il->length += len;
    il->dynamic_length += len;
    il->last_operation = 22;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 12
23 12
24 11
25 12
26 12
27 10
28 10
29 10
30 10
31 10
32 13
33 13
34 13
35 13
36 13
37 13
38 14
39 14
40 14
41 14
42 14
43 15
44 15
45 16
46 17
47 18
48 19
49 19
50 19
51 19
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1a6 <_gsasl_saml20_server_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  1a2 <_gsasl_saml20_server_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x20e8,%rsp
mov    %rsi,0x2038(%rsp)
mov    %rdx,0x2040(%rsp)
mov    %rcx,0x2048(%rsp)
mov    %r8,0x2050(%rsp)
mov    %r9,0x2058(%rsp)
test   %al,%al
je     dc <rshd_error+0x75>
movaps %xmm0,0x2060(%rsp)
movaps %xmm1,0x2070(%rsp)
movaps %xmm2,0x2080(%rsp)
movaps %xmm3,0x2090(%rsp)
movaps %xmm4,0x20a0(%rsp)
movaps %xmm5,0x20b0(%rsp)
movaps %xmm6,0x20c0(%rsp)
movaps %xmm7,0x20d0(%rsp)
mov    %rdi,%rdx
mov    %fs:0x28,%rax
mov    %rax,0x2028(%rsp)
xor    %eax,%eax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0x2100(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x2030(%rsp),%rax
mov    %rax,0x18(%rsp)
cmpl   $0x0,0x0(%rip)        # 123 <rshd_error+0xbc>
jne    136 <rshd_error+0xcf>
movb   $0x1,0x20(%rsp)
lea    0x21(%rsp),%rbx
mov    $0x1,%ebp
jmp    140 <rshd_error+0xd9>
lea    0x20(%rsp),%rbx
mov    $0x0,%ebp
lea    0x8(%rsp),%rcx
mov    $0x1fff,%esi
mov    %rbx,%rdi
callq  152 <rshd_error+0xeb>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movslq %ebp,%rbp
lea    -0x1(%rcx,%rbp,1),%rdx
lea    0x20(%rsp),%rsi
mov    $0x2,%edi
callq  17d <rshd_error+0x116>
mov    0x2028(%rsp),%rax
xor    %fs:0x28,%rax
je     195 <rshd_error+0x12e>
callq  195 <rshd_error+0x12e>
add    $0x20e8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rshd_error (const char *fmt, ...)
{
  va_list ap;
  int len;
  char *bp, buf[8192];
  __builtin_va_start(ap,fmt);
  bp = buf;
  if (sent_null == 0)
    {
      *bp++ = 1;
      len = 1;
    }
  else
    len = 0;
  vsnprintf (bp, sizeof (buf) - 1, fmt, ap);
  __builtin_va_end(ap);
  write (2, buf, len + strlen (bp));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 2
23 6
24 6
25 6
26 6
27 6
28 6
29 8
30 8
31 10
32 10
33 11
34 11
35 7
36 14
37 15
38 15
39 15
40 15
41 17
42 17
43 17
44 17
45 17
46 17
47 17
48 17
49 17
50 17
51 18
52 18
53 18
54 18
55 18
56 18
57 18
58 18
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r13
mov    0x8(%rdi),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     56b <hol_find_entry+0x7d>
mov    %rsi,%r12
mov    %edx,%eax
add    $0x1,%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
lea    0x0(%r13,%rax,1),%r14
mov    0x0(%r13),%rbx
mov    0x8(%r13),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     560 <hol_find_entry+0x72>
mov    %edx,%eax
lea    0x3(%rax,%rax,2),%rbp
shl    $0x4,%rbp
add    %rbx,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     557 <hol_find_entry+0x69>
testb  $0x2,0x18(%rbx)
jne    557 <hol_find_entry+0x69>
mov    %r12,%rsi
callq  553 <hol_find_entry+0x65>
test   %eax,%eax
je     572 <hol_find_entry+0x84>
add    $0x30,%rbx
cmp    %rbp,%rbx
jne    53d <hol_find_entry+0x4f>
add    $0x38,%r13
cmp    %r14,%r13
jne    520 <hol_find_entry+0x32>
jmp    577 <hol_find_entry+0x89>
mov    $0x0,%eax
jmp    57c <hol_find_entry+0x8e>
mov    %r13,%rax
jmp    57c <hol_find_entry+0x8e>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
hol_find_entry (struct hol *hol, const char *name)
{
  struct hol_entry *entry = hol->entries;
  unsigned num_entries = hol->num_entries;
  while (num_entries-- > 0)
    {
      const struct argp_option *opt = entry->opt;
      unsigned num_opts = entry->num;
      while (num_opts-- > 0)
        if (opt->name && (! ((opt)->flags & 0x2)) && strcmp (opt->name, name) == 0)
          return entry;
        else
          opt++;
      entry++;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 13
37 9
38 9
39 14
40 5
41 5
42 5
43 16
44 16
45 16
46 16
47 16
48 17
49 17
50 17
51 17
52 17
53 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  960 <term_styled_ostream__flush+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
term_styled_ostream__flush (term_styled_ostream_t stream)
{
  term_ostream_flush (stream->destination);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
movzbl (%rdi),%ebp
test   %bpl,%bpl
jle    b7 <skipws+0x32>
callq  9b <skipws+0x16>
mov    (%rax),%rax
jmp    ac <skipws+0x27>
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
jle    b7 <skipws+0x32>
movsbq %bpl,%rbp
testb  $0x20,0x1(%rax,%rbp,2)
jne    a0 <skipws+0x1b>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
skipws(char *buf)
{
    while (*buf && (((*buf) & ~0x7f) == 0) && ((*__ctype_b_loc ())[(int) ((*buf))] & (unsigned short int) _ISspace))
 buf++;
    return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 3
13 3
14 3
15 3
16 3
17 3
18 6
19 6
20 6
21 6
22 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    (%rdi),%rdx
mov    %rdx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
je     244 <ensure_slash+0x48>
lea    -0x1(%rcx),%rbx
cmpb   $0x2f,-0x1(%rdx,%rcx,1)
je     23d <ensure_slash+0x41>
jmp    249 <ensure_slash+0x4d>
lea    -0x1(%rbx),%rax
cmpb   $0x2f,-0x1(%rdx,%rbx,1)
jne    24c <ensure_slash+0x50>
mov    %rax,%rbx
test   %rbx,%rbx
jne    22f <ensure_slash+0x33>
jmp    24c <ensure_slash+0x50>
mov    %rcx,%rbx
jmp    24c <ensure_slash+0x50>
mov    %rcx,%rbx
cmpb   $0x2f,(%rdx,%rbx,1)
je     262 <ensure_slash+0x66>
lea    0x2(%rbx),%rsi
mov    %rdx,%rdi
callq  25e <ensure_slash+0x62>
mov    %rax,0x0(%rbp)
mov    0x0(%rbp),%rax
movb   $0x2f,(%rax,%rbx,1)
mov    0x0(%rbp),%rax
movb   $0x0,0x1(%rax,%rbx,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ensure_slash (char **pstr)
{
  size_t len = strlen (*pstr);
  while (len >= 1 && (((*pstr)[len - 1]) == '/'))
    len--;
  if (!(((*pstr)[len]) == '/'))
    *pstr = xrealloc (*pstr, len + 2);
  (*pstr)[len++] = '/';
  (*pstr)[len] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 3
25 3
26 3
27 6
28 6
29 7
30 7
31 7
32 7
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x23,%edi
callq  13 <_gsasl_cram_md5_server_start+0x13>
mov    %rax,%rbx
mov    $0x7,%eax
test   %rbx,%rbx
je     39 <_gsasl_cram_md5_server_start+0x39>
mov    %rbx,%rdi
callq  28 <_gsasl_cram_md5_server_start+0x28>
mov    %eax,%edx
mov    $0x9,%eax
test   %edx,%edx
jne    39 <_gsasl_cram_md5_server_start+0x39>
mov    %rbx,0x0(%rbp)
mov    $0x0,%al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_gsasl_cram_md5_server_start (Gsasl_session * sctx, void **mech_data)
{
  char *challenge;
  int rc;
  challenge = malloc (35);
  if (challenge == ((void *)0))
    return GSASL_MALLOC_ERROR;
  rc = cram_md5_challenge (challenge);
  if (rc)
    return GSASL_CRYPTO_ERROR;
  *mech_data = challenge;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 6
10 6
11 8
12 8
13 8
14 10
15 9
16 9
17 11
18 12
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  3bf <mu_cfg_yy_init_buffer+0x15>
mov    %rax,%r12
mov    (%rax),%r13d
mov    %rbx,%rdi
callq  3cd <mu_cfg_yy_init_buffer+0x23>
mov    %rbp,(%rbx)
movl   $0x1,0x38(%rbx)
mov    0x0(%rip),%rax        # 3de <mu_cfg_yy_init_buffer+0x34>
test   %rax,%rax
je     3f0 <mu_cfg_yy_init_buffer+0x46>
mov    0x0(%rip),%rdx        # 3ea <mu_cfg_yy_init_buffer+0x40>
mov    (%rax,%rdx,8),%rax
jmp    3f5 <mu_cfg_yy_init_buffer+0x4b>
mov    $0x0,%eax
cmp    %rbx,%rax
je     408 <mu_cfg_yy_init_buffer+0x5e>
movl   $0x1,0x30(%rbx)
movl   $0x0,0x34(%rbx)
mov    $0x0,%eax
test   %rbp,%rbp
je     429 <mu_cfg_yy_init_buffer+0x7f>
mov    %rbp,%rdi
callq  41a <mu_cfg_yy_init_buffer+0x70>
mov    %eax,%edi
callq  421 <mu_cfg_yy_init_buffer+0x77>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x28(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_cfg_yy_init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 mu_cfg_yy_flush_buffer(b );
 b->mu_cfg_yy_input_file = file;
 b->mu_cfg_yy_fill_buffer = 1;
    if (b != ( (mu_cfg_yy_buffer_stack) ? (mu_cfg_yy_buffer_stack)[(mu_cfg_yy_buffer_stack_top)] : ((void *)0))){
        b->mu_cfg_yy_bs_lineno = 1;
        b->mu_cfg_yy_bs_column = 0;
    }
        b->mu_cfg_yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 4
12 4
13 5
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 9
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 12
38 13
39 13
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r8
mov    %edx,%ecx
mov    $0x0,%edx
callq  1029 <gen_input_radio+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gen_input_radio(const char *name, const char *value, int checked, const char *title)
{
 return gen_input_with_title_checked(name, value, "radio", checked, title);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  26d <varcmp+0xf>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
varcmp (const void *a, const void *b)
{
  return strcmp (((struct variable const *)a)->name,
   ((struct variable const *)b)->name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  5b <compute_variance>
test   %rbx,%rbx
js     6fe <gsl_stats_sd_m+0x15>
cvtsi2sd %rbx,%xmm1
jmp    716 <gsl_stats_sd_m+0x2d>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     726 <gsl_stats_sd_m+0x3d>
cvtsi2sd %rax,%xmm2
jmp    73b <gsl_stats_sd_m+0x52>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    7a4 <gsl_stats_sd_m+0xbb>
test   %rbx,%rbx
js     759 <gsl_stats_sd_m+0x70>
cvtsi2sd %rbx,%xmm2
jmp    771 <gsl_stats_sd_m+0x88>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm2
addsd  %xmm2,%xmm2
sub    $0x1,%rbx
js     77e <gsl_stats_sd_m+0x95>
cvtsi2sd %rbx,%xmm1
jmp    793 <gsl_stats_sd_m+0xaa>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
callq  7a0 <gsl_stats_sd_m+0xb7>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_stats_sd_m (const double data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_variance (data, stride, n, mean);
  const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
  return sd;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 6
57 6
58 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x14(%rdi)
sete   %cl
movzbl %cl,%ecx
callq  e70 <fh_first+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fh_first (format_data_t form, int argc, char *argv[])
{
  select_arg (form, argc, argv, form->first ? 0 : 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
callq  6db <xformat_write_file_data+0x15>
mov    %rax,%r13
mov    0xc(%rbx),%r9d
mov    0x4(%rbx),%edx
mov    0x68(%rbx),%rdi
movq   $0x0,0x8(%rsp)
movl   $0xffffffff,(%rsp)
mov    $0x0,%r8d
mov    %r12d,%ecx
mov    %rax,%rsi
callq  70a <xformat_write_file_data+0x44>
mov    %rax,%rbp
test   %rax,%rax
js     729 <xformat_write_file_data+0x63>
mov    (%rbx),%edi
cmp    %r12d,%edi
jne    725 <xformat_write_file_data+0x5f>
mov    0xc(%rbx),%edx
mov    0x38(%r13),%rsi
callq  725 <xformat_write_file_data+0x5f>
add    %rbp,0x18(%rbx)
mov    %rbp,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xformat_write_file_data(XFORMAT * xux, int source_fd)
{
 intmax_t ret;
 struct new_cpio_header *file_hdr0;
 ;
 file_hdr0 = (struct new_cpio_header *)(xformat_vfile_hdr(xux));
 ret = taru_write_archive_member_data(xux->taruM, file_hdr0,
    xux->ofdM, source_fd, (int(*)(int))((void *)0),
     xux->output_format_codeM, -1, ((void *)0));
 if (ret < 0) return ret;
 if (source_fd == xux->ifdM ) {
  taru_tape_skip_padding(xux->ifdM, file_hdr0->c_filesize,
      xux->output_format_codeM);
 }
 xux->bytes_writtenM += ret;
 ;
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 10
21 10
22 11
23 11
24 11
25 12
26 12
27 12
28 15
29 18
30 18
31 18
32 18
33 18
34 18
35 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  15b6 <c_reserved_word+0x9>
test   %rax,%rax
je     15cd <c_reserved_word+0x20>
mov    0x8(%rax),%eax
cmp    $0x7d0,%eax
mov    $0x0,%edx
cmovle %edx,%eax
jmp    15d2 <c_reserved_word+0x25>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
c_reserved_word(const char *str, int len)
{
 struct keyword *keyword;
 keyword = c_lookup(str, len);
 return (keyword && ((keyword->token) >= 2001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x0(%rip),%rsi        # f25 <uname_to_uid+0x13>
test   %rsi,%rsi
je     f33 <uname_to_uid+0x21>
callq  f2f <uname_to_uid+0x1d>
test   %eax,%eax
je     f99 <uname_to_uid+0x87>
mov    0x0(%rip),%rsi        # f3a <uname_to_uid+0x28>
test   %rsi,%rsi
je     f52 <uname_to_uid+0x40>
movzbl (%rsi),%eax
cmp    %al,(%rbx)
jne    f52 <uname_to_uid+0x40>
mov    %rbx,%rdi
callq  f4e <uname_to_uid+0x3c>
test   %eax,%eax
je     f8b <uname_to_uid+0x79>
mov    %rbx,%rdi
callq  f5a <uname_to_uid+0x48>
test   %rax,%rax
je     f77 <uname_to_uid+0x65>
mov    0x10(%rax),%edx
mov    %edx,0x0(%rip)        # f68 <uname_to_uid+0x56>
mov    (%rax),%rsi
mov    $0x0,%edi
callq  f75 <uname_to_uid+0x63>
jmp    f8b <uname_to_uid+0x79>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  f84 <uname_to_uid+0x72>
mov    $0x0,%eax
jmp    f99 <uname_to_uid+0x87>
mov    0x0(%rip),%eax        # f91 <uname_to_uid+0x7f>
mov    %eax,0x0(%rbp)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
uname_to_uid (char const *uname, uid_t *uidp)
{
  struct passwd *passwd;
  if (cached_no_such_uname
      && strcmp (uname, cached_no_such_uname) == 0)
    return 0;
  if (!cached_uname
      || uname[0] != cached_uname[0]
      || strcmp (uname, cached_uname) != 0)
    {
      passwd = getpwnam (uname);
      if (passwd)
 {
   cached_uid = passwd->pw_uid;
   assign_string (&cached_uname, passwd->pw_name);
 }
      else
 {
   assign_string (&cached_no_such_uname, uname);
   return 0;
 }
    }
  *uidp = cached_uid;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 7
13 7
14 7
15 8
16 8
17 8
18 9
19 9
20 9
21 9
22 11
23 11
24 12
25 12
26 14
27 14
28 15
29 15
30 15
31 15
32 19
33 19
34 19
35 20
36 20
37 23
38 23
39 24
40 25
41 25
42 25
43 25
<<<sep_out_sample>>>
mov    (%rsi),%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
cmp    (%rdi),%r8
jne    2c <gsl_vector_complex_long_double_equal+0x2c>
test   %r8,%r8
je     89 <gsl_vector_complex_long_double_equal+0x89>
shl    $0x5,%r10
mov    0x10(%rdi),%rdx
shl    $0x5,%r9
mov    0x10(%rsi),%rax
mov    $0x0,%edi
jmp    6f <gsl_vector_complex_long_double_equal+0x6f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  49 <gsl_vector_complex_long_double_equal+0x49>
mov    $0x0,%eax
jmp    9d <gsl_vector_complex_long_double_equal+0x9d>
fldt   0x10(%rcx)
fldt   0x10(%rsi)
fxch   %st(1)
fucomip %st(1),%st
fstp   %st(0)
jp     91 <gsl_vector_complex_long_double_equal+0x91>
jne    91 <gsl_vector_complex_long_double_equal+0x91>
add    $0x1,%rdi
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rdi
je     97 <gsl_vector_complex_long_double_equal+0x97>
mov    %rdx,%rcx
mov    %rax,%rsi
fldt   (%rdx)
fldt   (%rax)
fxch   %st(1)
fucomip %st(1),%st
fstp   %st(0)
jp     83 <gsl_vector_complex_long_double_equal+0x83>
je     50 <gsl_vector_complex_long_double_equal+0x50>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
xchg   %ax,%ax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_equal (const gsl_vector_complex_long_double * u, const gsl_vector_complex_long_double * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (u->data[2 * stride_u * j + k] != v->data[2 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 11
7 11
8 11
9 11
10 11
11 11
12 16
13 16
14 2
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 16
23 16
24 16
25 16
26 16
27 16
28 16
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 18
44 18
45 22
46 22
47 23
48 18
49 18
50 22
51 22
52 23
53 23
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
callq  8b8 <gcide_create_result_list+0xd>
mov    %rax,%rbx
test   %rax,%rax
jne    8e0 <gcide_create_result_list+0x35>
mov    $0x0,%edx
mov    $0xc,%esi
mov    $0x4,%edi
mov    $0x0,%eax
callq  8d9 <gcide_create_result_list+0x2e>
mov    $0x0,%eax
jmp    913 <gcide_create_result_list+0x68>
test   %ebp,%ebp
je     8fe <gcide_create_result_list+0x53>
mov    $0x0,%esi
mov    %rax,%rdi
callq  8f1 <gcide_create_result_list+0x46>
mov    $0x2,%esi
mov    %rbx,%rdi
callq  8fe <gcide_create_result_list+0x53>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  910 <gcide_create_result_list+0x65>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gcide_create_result_list(int unique)
{
    dico_list_t list;
    list = dico_list_create();
    if (!list) {
 dico_log(4, 12, "gcide_create_result_list");
 return ((void *)0);
    }
    if (unique) {
 dico_list_set_comparator(list,
     (int (*)(const void *, void *)) compare_ref);
 dico_list_set_flags(list, 0x02);
    }
    dico_list_set_free_item(list, free_ref, ((void *)0));
    return list;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 9
17 9
18 10
19 10
20 10
21 12
22 12
23 12
24 14
25 14
26 14
27 14
28 15
29 16
30 16
31 16
32 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbx
mov    %ecx,%edx
mov    $0x0,%r8d
mov    $0x0,%ecx
callq  598 <completion_tags+0x1b>
mov    %rax,%rbp
cmpl   $0x1,0x0(%rip)        # 5a2 <completion_tags+0x25>
sbb    %edx,%edx
and    $0xfffffff0,%edx
add    $0x1d,%edx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  5b5 <completion_tags+0x38>
test   %rax,%rax
je     5f2 <completion_tags+0x75>
mov    $0x0,%ebx
mov    0x10(%rax),%rdi
mov    0x0(%rip),%rsi        # 5ca <completion_tags+0x4d>
callq  5cf <completion_tags+0x52>
mov    0x0(%rip),%rsi        # 5d6 <completion_tags+0x59>
mov    $0xa,%edi
callq  5e0 <completion_tags+0x63>
add    $0x1,%ebx
mov    %rbp,%rdi
callq  5eb <completion_tags+0x6e>
test   %rax,%rax
jne    5bf <completion_tags+0x42>
jmp    5f7 <completion_tags+0x7a>
mov    $0x0,%ebx
cmpl   $0x0,0x0(%rip)        # 5fe <completion_tags+0x81>
je     608 <completion_tags+0x8b>
mov    %rbp,%rdi
callq  608 <completion_tags+0x8b>
mov    %rbp,%rdi
callq  610 <completion_tags+0x93>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
completion_tags(const char *dbpath, const char *root, const char *prefix, int db)
{
 int flags = 1 | 8 | 4;
 GTOP *gtop = gtags_open(dbpath, root, db, 0, 0);
 GTP *gtp;
 int count = 0;
 if (iflag)
  flags |= 16;
 for (gtp = gtags_first(gtop, prefix, flags); gtp; gtp = gtags_next(gtop)) {
  fputs(gtp->tag, stdout);
  fputc('\n', stdout);
  count++;
 }
 if (debug)
  gtags_show_statistics(gtop);
 gtags_close(gtop);
 return count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 9
15 9
16 9
17 9
18 9
19 6
20 10
21 10
22 10
23 11
24 11
25 11
26 12
27 9
28 9
29 9
30 9
31 9
32 6
33 14
34 14
35 15
36 15
37 16
38 16
39 18
40 18
41 18
42 18
43 18
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
<<<sep_in_sample>>>
gss_inquire_context (OM_uint32 * minor_status,
       const gss_ctx_id_t context_handle,
       gss_name_t * src_name,
       gss_name_t * targ_name,
       OM_uint32 * lifetime_rec,
       gss_OID * mech_type,
       OM_uint32 * ctx_flags, int *locally_initiated, int *open)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 10
2 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %edx,%ecx
and    $0x7fffffff,%ecx
test   %edx,%edx
js     2a5 <ping_cvt_time+0x21>
mov    $0x0,%edx
mov    $0x0,%eax
callq  2a3 <ping_cvt_time+0x1f>
jmp    2b4 <ping_cvt_time+0x30>
mov    $0x0,%edx
mov    $0x0,%eax
callq  2b4 <ping_cvt_time+0x30>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
ping_cvt_time (char *buf, size_t buflen, n_time t)
{
  n_time t_red;
  t_red = t & ((1UL << 31) - 1);
  if (is_normed_time (t))
    snprintf (buf, buflen, "%u", t_red);
  else
    snprintf (buf, buflen, "<%u>", t_red);
  return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 8
12 8
13 8
14 10
15 10
16 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
jne    b9 <InitlVector+0x1d>
mov    $0x0,%edi
callq  af <InitlVector+0x13>
mov    $0x0,%edi
callq  b9 <InitlVector+0x1d>
shl    $0x3,%rdi
callq  c2 <InitlVector+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
InitlVector (long cVectors)
{
  if (cVectors == 0) {
    printf ("Error: zero length array allocation in InitlVector - Exiting\n");
    exit (0);
  }
  else
    return (long *) malloc (cVectors * sizeof(long));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 8
9 8
10 9
11 9
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rdi,%rdx
mov    %rsi,%rcx
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
mov    $0x80,%esi
mov    %rsp,%rdi
callq  23b <mu_syslog_error_printer+0x2d>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    $0x2,%edi
mov    $0x0,%eax
callq  252 <mu_syslog_error_printer+0x44>
mov    $0x0,%eax
mov    0x88(%rsp),%rcx
xor    %fs:0x28,%rcx
je     26f <mu_syslog_error_printer+0x61>
callq  26f <mu_syslog_error_printer+0x61>
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
mu_syslog_error_printer (const char *fmt, va_list ap)
{
  char buf[128];
  vsnprintf (buf, sizeof buf, fmt, ap);
  syslog (2, "%s", buf);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x200,%esi
callq  e <mu_str_stripws+0xe>
mov    $0x200,%esi
mov    %rbx,%rdi
callq  1b <mu_str_stripws+0x1b>
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_str_stripws (char *string)
{
  mu_rtrim_class (string, 0x200);
  return mu_str_skip_class (string, 0x200);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %rdx,%r8
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  5b6 <gsl_vector_uchar_fprintf+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_uchar_fprintf (FILE * stream, const gsl_vector_uchar * v,
                                const char *format)
{
  int status = gsl_block_uchar_raw_fprintf (stream,
                                                  v->data,
                                                  v->size,
                                                  v->stride,
                                                  format);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 10
9 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  182 <modehelp+0xb>
mov    0x0(%rip),%rsi        # 189 <modehelp+0x12>
test   %rsi,%rsi
je     1c8 <modehelp+0x51>
mov    $0x0,%ebx
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     1bc <modehelp+0x45>
cmpb   $0x0,(%rdx)
je     1b2 <modehelp+0x3b>
mov    $0x0,%edi
mov    $0x0,%eax
callq  1b0 <modehelp+0x39>
jmp    1bc <modehelp+0x45>
mov    $0xa,%edi
callq  1bc <modehelp+0x45>
add    $0x20,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    193 <modehelp+0x1c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
modehelp (void)
{
  struct modelist *mt;
  printf ("format is:  'mode Mode', where 'Mode' is one of:\n\n");
  for (mt = ModeList; mt->name; mt++)
    {
      if (mt->help)
 {
   if (*mt->help)
     printf ("%-15s %s\n", mt->name, mt->help);
   else
     printf ("\n");
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 9
12 9
13 10
14 10
15 10
16 10
17 12
18 12
19 5
20 5
21 5
22 5
23 16
24 16
25 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  1ac <gsl_spline_name+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_spline_name(const gsl_spline * spline)
{
  return gsl_interp_name(spline->interp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x2,%eax
retq   
<<<sep_in_sample>>>
nettle_version_minor (void)
{
  return 2;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     fea <print_var_value+0xc5>
test   %esi,%esi
je     fc6 <print_var_value+0xa1>
cmpl   $0x0,0x0(%rip)        # f45 <print_var_value+0x20>
jne    fdb <print_var_value+0xb6>
callq  f50 <print_var_value+0x2b>
test   %eax,%eax
je     fdb <print_var_value+0xb6>
mov    0x8(%rbx),%rdi
mov    $0x0,%edx
mov    $0x0,%esi
callq  f6b <print_var_value+0x46>
mov    %rax,%rbx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  f80 <print_var_value+0x5b>
mov    $0x43c,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  f92 <print_var_value+0x6d>
jmp    fea <print_var_value+0xc5>
mov    0x8(%rbx),%rdi
callq  f9d <print_var_value+0x78>
mov    %rax,%rbx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  fb2 <print_var_value+0x8d>
mov    $0x442,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  fc4 <print_var_value+0x9f>
jmp    fea <print_var_value+0xc5>
mov    0x8(%rbx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  fd9 <print_var_value+0xb4>
jmp    fea <print_var_value+0xc5>
mov    0x8(%rbx),%rdi
callq  fe4 <print_var_value+0xbf>
test   %eax,%eax
je     fc6 <print_var_value+0xa1>
jmp    f94 <print_var_value+0x6f>
pop    %rbx
nopl   0x0(%rax,%rax,1)
retq   
<<<sep_in_sample>>>
print_var_value (var, quote)
     SHELL_VAR *var;
     int quote;
{
  char *t;
  if (((var)->value != 0) == 0)
    return;
  if (quote && posixly_correct == 0 && ansic_shouldquote (((var)->value)))
    {
      t = ansic_quote (((var)->value), 0, (int *)0);
      printf ("%s", t);
      sh_xfree((t), "variables.c", 1084);
    }
  else if (quote && sh_contains_shell_metas (((var)->value)))
    {
      t = sh_single_quote (((var)->value));
      printf ("%s", t);
      sh_xfree((t), "variables.c", 1090);
    }
  else
    printf ("%s", ((var)->value));
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 11
19 11
20 11
21 11
22 12
23 12
24 12
25 12
26 12
27 16
28 16
29 16
30 17
31 17
32 17
33 17
34 18
35 18
36 18
37 18
38 18
39 21
40 21
41 21
42 21
43 21
44 14
45 14
46 14
47 14
48 14
49 22
50 22
51 22
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
<<<sep_in_sample>>>
osip_authentication_info_set_opaque (osip_authentication_info_t *
       authentication_info, char *opaque)
{
  authentication_info->opaque = (char *) opaque;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1278 <quotearg_custom_mem+0x1a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rdx,%rdi
callq  19a <xstrdup+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r15
mov    0x8(%rdi),%r12
mov    %r12,0x0(%rip)        # 4ca <Barcode_39ext_encode+0x1c>
test   %r12,%r12
jne    4e0 <Barcode_39ext_encode+0x32>
movl   $0x16,0x48(%rdi)
mov    $0xffffffff,%eax
jmpq   5a4 <Barcode_39ext_encode+0xf6>
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx,%rcx,1),%rdi
callq  4fe <Barcode_39ext_encode+0x50>
mov    %rax,%r14
mov    %rax,0x0(%rip)        # 508 <Barcode_39ext_encode+0x5a>
test   %rax,%rax
je     52b <Barcode_39ext_encode+0x7d>
movzbl (%r12),%eax
test   %al,%al
je     590 <Barcode_39ext_encode+0xe2>
mov    %r14,%rbx
mov    $0x0,%ebp
mov    $0xffffffffffffffff,%r13
test   %al,%al
jns    558 <Barcode_39ext_encode+0xaa>
jmp    541 <Barcode_39ext_encode+0x93>
callq  530 <Barcode_39ext_encode+0x82>
mov    (%rax),%eax
mov    %eax,0x48(%r15)
mov    $0xffffffff,%eax
jmp    5a4 <Barcode_39ext_encode+0xf6>
test   %al,%al
jns    558 <Barcode_39ext_encode+0xaa>
movl   $0x16,0x48(%r15)
mov    %r14,%rdi
callq  551 <Barcode_39ext_encode+0xa3>
mov    $0xffffffff,%eax
jmp    5a4 <Barcode_39ext_encode+0xf6>
movsbq %al,%rax
mov    0x0(,%rax,8),%rsi
mov    %rbx,%rdi
callq  56c <Barcode_39ext_encode+0xbe>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    %r13,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rbx
add    $0x1,%ebp
movslq %ebp,%rax
movzbl (%r12,%rax,1),%eax
test   %al,%al
jne    53d <Barcode_39ext_encode+0x8f>
mov    %r14,0x8(%r15)
mov    %r12,%rdi
callq  59c <Barcode_39ext_encode+0xee>
mov    %r15,%rdi
callq  5a4 <Barcode_39ext_encode+0xf6>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
Barcode_39ext_encode(struct Barcode_Item *bc)
{
    static char *eascii;
    static char *text;
    char c, *ptr;
    int i;
    text = bc->ascii;
    if (!text) {
        bc->error = 22;
        return -1;
    }
    eascii = malloc( strlen(text)*2 +1 );
    if (!eascii) {
 bc->error = (*__errno_location ());
 return -1;
    }
    ptr = eascii;
    for (i=0; text[i]; i++) {
 c = text[i];
 if (c<0) {
     bc->error = 22;
     free(eascii);
     return -1;
 }
 strcpy(ptr, code39ext[(int)c]);
 ptr += strlen(ptr);
    }
    bc->ascii = eascii;
    free(text);
    return Barcode_39_encode(bc);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 7
10 7
11 8
12 8
13 9
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 18
28 18
29 18
30 20
31 20
32 26
33 20
34 20
35 20
36 14
37 14
38 14
39 15
40 15
41 20
42 20
43 21
44 22
45 22
46 23
47 23
48 25
49 25
50 25
51 25
52 26
53 26
54 26
55 26
56 26
57 26
58 18
59 18
60 18
61 18
62 18
63 28
64 29
65 29
66 30
67 30
68 31
69 31
70 31
71 31
72 31
73 31
74 31
75 31
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2f7 <timer_reset+0x9>
xorpd  %xmm0,%xmm0
movsd  %xmm0,0x8(%rax)
movsd  %xmm0,0x10(%rax)
movsd  %xmm0,0x18(%rax)
movsd  %xmm0,0x20(%rax)
movsd  %xmm0,0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
timer_reset(const char *name)
{
    xdico_timer_t t = timer_get(name);
    t->real = 0.0;
    t->self_user = 0.0;
    t->self_system = 0.0;
    t->children_user = 0.0;
    t->children_system = 0.0;
    return t;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 6
7 7
8 8
9 10
10 10
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
gc_cipher_decrypt_inline (gc_cipher_handle handle, size_t len, char *data)
{
  _gc_cipher_ctx *ctx = handle;
  switch (ctx->alg)
    {
    default:
      return GC_INVALID_CIPHER;
    }
  return GC_OK;
}
<<<sep_in_sample>>>
1 10
2 10
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
test   %r8,%r8
je     21f1 <gsl_vector_ushort_add_constant+0x3e>
add    %r9,%r9
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%rcx
add    0x10(%rdi),%rcx
movzwl (%rcx),%esi
cvtsi2sd %esi,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%esi
mov    %si,(%rcx)
add    $0x1,%rax
add    %r9,%rdx
cmp    %r8,%rax
jne    21cc <gsl_vector_ushort_add_constant+0x19>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_ushort_add_constant (gsl_vector_ushort * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 6
16 6
17 6
18 6
19 11
20 11
<<<sep_out_sample>>>
cmp    %edi,%esi
mov    %edi,%eax
cmovge %esi,%eax
retq   
<<<sep_in_sample>>>
max (int a, int b)
{
  return a > b ? a : b;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    $0x0,%eax
testb  $0x1,0x28(%rdi)
je     4b <export_environment_candidate+0x1e>
mov    0x28(%rdi),%eax
and    $0x9000,%eax
cmp    $0x1000,%eax
setne  %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
export_environment_candidate (var)
     SHELL_VAR *var;
{
  return (((((var)->attributes) & (0x0000001))) && (((((var)->attributes) & (0x0001000))) == 0 || ((((var)->attributes) & (0x0008000)))));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0xa0(%rdi)
je     5889 <info_tree_search_next+0x18>
mov    0x30(%rdi),%rax
cmpl   $0x0,0x60(%rax)
jne    58a2 <info_tree_search_next+0x31>
mov    $0x0,%edi
callq  5893 <info_tree_search_next+0x22>
mov    %rax,%rdi
mov    $0x0,%eax
callq  58a0 <info_tree_search_next+0x2f>
jmp    58a7 <info_tree_search_next+0x36>
callq  4518 <tree_search_check_node>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
info_tree_search_next (WINDOW *window, int count)
{
  if (!window->search_string || window->node->active_menu == 0)
    {
      info_error (gettext ("No active search"));
      return;
    }
  tree_search_check_node (window);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 6
13 8
14 9
15 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    (%rdi),%r8
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rcx
cmp    (%rsi),%r8
jne    6aa <gsl_vector_swap+0x23>
test   %r8,%r8
jne    6ce <gsl_vector_swap+0x47>
mov    $0x0,%eax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6c7 <gsl_vector_swap+0x40>
mov    $0x4,%eax
jmp    704 <gsl_vector_swap+0x7d>
shl    $0x3,%rdi
lea    0x0(,%rcx,8),%rsi
mov    $0x0,%ecx
movsd  (%rdx),%xmm1
movsd  (%rax),%xmm0
movsd  %xmm0,(%rdx)
movsd  %xmm1,(%rax)
add    $0x1,%rcx
add    %rdi,%rdx
add    %rsi,%rax
cmp    %r8,%rcx
jne    6df <gsl_vector_swap+0x58>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_swap (gsl_vector * v, gsl_vector * w)
{
  double * d1 = v->data ;
  double * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          double tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 7
6 9
7 9
8 13
9 13
10 22
11 23
12 2
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 17
21 18
22 18
23 17
24 18
25 18
26 19
27 13
28 13
29 13
30 13
31 13
32 22
33 22
34 23
35 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
lea    0x28(%rsi),%rdi
callq  3294 <free_token>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
free_tree (void *extra, bin_tree_t *node)
{
  free_token (&node->token);
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x1010,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x1008(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%rdi        # f74 <user_rcfile_name+0x25>
test   %rdi,%rdi
je     f80 <user_rcfile_name+0x31>
callq  f7e <user_rcfile_name+0x2f>
jmp    ffe <user_rcfile_name+0xaf>
mov    $0x1001,%edx
mov    %rsp,%rsi
mov    0x0(%rip),%rdi        # f8f <user_rcfile_name+0x40>
callq  f94 <user_rcfile_name+0x45>
mov    $0xffffffffffffffff,%r12
mov    %rsp,%rdi
mov    $0x0,%ebp
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    0xa(%rcx),%rdi
callq  fb6 <user_rcfile_name+0x67>
mov    %rax,%rbx
mov    %rsp,%rsi
mov    %rax,%rdi
callq  fc4 <user_rcfile_name+0x75>
mov    %rbx,%rdi
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
movw   $0x2f,-0x1(%rbx,%rcx,1)
mov    %rbx,%rdi
mov    %r12,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rax
movabs $0x72736962756e612e,%rsi
mov    %rsi,(%rax)
movw   $0x63,0x8(%rax)
mov    %rbx,%rax
mov    0x1008(%rsp),%rdx
xor    %fs:0x28,%rdx
je     1016 <user_rcfile_name+0xc7>
callq  1016 <user_rcfile_name+0xc7>
add    $0x1010,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
user_rcfile_name (void)
{
  if (session.rcfile_name)
    {
      return strdup (session.rcfile_name);
    }
  else
    {
      char homedir[4096 + 1];
      char *buf;
      size_t len;
      get_homedir (session.clientname, homedir, sizeof (homedir));
      len = strlen (homedir) + 1 + sizeof ".anubisrc";
      buf = xmalloc (len);
      strcpy (buf, homedir);
      strcat (buf, "/");
      strcat (buf, ".anubisrc");
      return buf;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 5
12 5
13 12
14 12
15 12
16 12
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 14
26 14
27 15
28 15
29 15
30 16
31 16
32 16
33 16
34 16
35 16
36 17
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 18
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 20
53 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
xorpd  %xmm0,%xmm0
cmpq   $0x0,0xc0(%rdi)
jle    2794 <LnLike+0x75>
mov    %rsi,%r12
xorpd  %xmm1,%xmm1
movsd  %xmm1,0x8(%rsp)
mov    $0x0,%ebx
mov    0xc8(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
mov    %r12,%rsi
callq  275d <LnLike+0x3e>
ucomisd 0x0(%rip),%xmm0        # 2765 <LnLike+0x46>
jp     2769 <LnLike+0x4a>
je     2784 <LnLike+0x65>
addsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x8(%rsp)
add    $0x1,%rbx
cmp    %rbx,0xc0(%rbp)
jg     274a <LnLike+0x2b>
jmp    278e <LnLike+0x6f>
movsd  0x0(%rip),%xmm0        # 278c <LnLike+0x6d>
jmp    2794 <LnLike+0x75>
movsd  0x8(%rsp),%xmm0
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
LnLike (PMCVAR pMCVar, PANALYSIS panal)
{
  long n;
  double dDensity, dLnLike = 0.0;
  for (n = 0; n < pMCVar->nDependents; n++) {
    dDensity = LnDensity(pMCVar->rgpDependents[n], panal);
    if (dDensity == -1.0E+100)
      return -1.0E+100;
    else
      dLnLike += dDensity;
  }
  return dLnLike;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 4
11 4
12 5
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 10
21 10
22 5
23 5
24 5
25 5
26 8
27 8
28 10
29 13
30 13
31 13
32 13
33 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1714 <gsl_permute_vector_ushort_inverse+0x2c>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  170d <gsl_permute_vector_ushort_inverse+0x25>
mov    $0x13,%eax
jmp    172a <gsl_permute_vector_ushort_inverse+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  1725 <gsl_permute_vector_ushort_inverse+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_ushort_inverse (const gsl_permutation * p, gsl_vector_ushort * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_ushort_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
mov    0xd8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsasl_client_application_data_get (Gsasl_session * sctx)
{
  return gsasl_appinfo_get (sctx);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%rdx
mov    %rsi,%rbx
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
lea    0x28(%rsp),%r9
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%esi
mov    $0x1,%edi
callq  37b <get_pwent>
mov    0x28(%rsp),%rdx
mov    %edx,(%rbx)
add    $0x30,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
taru_get_gid_by_name(char *groupname, gid_t *guid)
{
 int ret;
 long pid;
 ;
 ret = get_pwent(1, 0, groupname, ((void *)0), ((void *)0),
   &pid,
   l_getgidbyname,
   l_tar_sysdata_getgroup,
   &dbpair_group_nset,
   groupCacheM
  );
 *guid = (gid_t)(pid);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 13
16 13
17 15
18 15
19 15
<<<sep_out_sample>>>
mov    %edi,%eax
shr    $0x6,%eax
mov    %eax,%eax
mov    (%rsi,%rax,8),%rax
mov    %edi,%ecx
shr    %cl,%rax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
tstbit (unsigned int b, charclass const c)
{
  return c[b / CHARCLASS_WORD_BITS] >> b % CHARCLASS_WORD_BITS & 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     754 <gsl_matrix_long_double_fread+0x43>
shl    $0x4,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     795 <gsl_matrix_long_double_fread+0x84>
jmp    76b <gsl_matrix_long_double_fread+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  769 <gsl_matrix_long_double_fread+0x58>
jmp    795 <gsl_matrix_long_double_fread+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  783 <gsl_matrix_long_double_fread+0x72>
test   %eax,%eax
jne    795 <gsl_matrix_long_double_fread+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    76b <gsl_matrix_long_double_fread+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_fread (FILE * stream, gsl_matrix_long_double * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_double_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_double_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
test   %edi,%edi
js     35c <_rl_vi_arg_dispatch+0x32>
movslq %edi,%rax
shl    $0x4,%rax
add    0x0(%rip),%rax        # 33f <_rl_vi_arg_dispatch+0x15>
cmpb   $0x0,(%rax)
jne    35c <_rl_vi_arg_dispatch+0x32>
cmpq   $0x0,0x8(%rax)
jne    35c <_rl_vi_arg_dispatch+0x32>
shll   $0x2,0x0(%rip)        # 355 <_rl_vi_arg_dispatch+0x2b>
mov    $0x1,%eax
jmp    3b1 <_rl_vi_arg_dispatch+0x87>
mov    %ebx,%eax
and    $0x7f,%al
lea    -0x30(%rax),%edx
cmp    $0x9,%edx
ja     3a0 <_rl_vi_arg_dispatch+0x76>
cmpl   $0x0,0x0(%rip)        # 36f <_rl_vi_arg_dispatch+0x45>
je     386 <_rl_vi_arg_dispatch+0x5c>
mov    0x0(%rip),%edx        # 377 <_rl_vi_arg_dispatch+0x4d>
lea    (%rdx,%rdx,4),%edx
lea    -0x30(%rax,%rdx,2),%eax
mov    %eax,0x0(%rip)        # 384 <_rl_vi_arg_dispatch+0x5a>
jmp    38f <_rl_vi_arg_dispatch+0x65>
sub    $0x30,%eax
mov    %eax,0x0(%rip)        # 38f <_rl_vi_arg_dispatch+0x65>
movl   $0x1,0x0(%rip)        # 399 <_rl_vi_arg_dispatch+0x6f>
mov    $0x1,%eax
jmp    3b1 <_rl_vi_arg_dispatch+0x87>
callq  3a5 <_rl_vi_arg_dispatch+0x7b>
mov    %ebx,%edi
callq  3ac <_rl_vi_arg_dispatch+0x82>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_vi_arg_dispatch (c)
     int c;
{
  int key;
  key = c;
  if (c >= 0 && _rl_keymap[c].type == 0 && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }
  c = ((c) & (~0x080));
  if (((c) >= '0' && (c) <= '9'))
    {
      if (rl_explicit_arg)
 rl_numeric_arg = (rl_numeric_arg * 10) + ((c) - '0');
      else
 rl_numeric_arg = ((c) - '0');
      rl_explicit_arg = 1;
      return 1;
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 9
14 9
15 11
16 11
17 12
18 12
19 12
20 14
21 14
22 15
23 15
24 15
25 15
26 15
27 17
28 17
29 18
30 19
31 19
32 23
33 24
34 24
35 25
36 27
37 27
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
lea    0xc0(%rdi),%r12
mov    %r12,%rdi
callq  9e <osip_message_get_content_encoding+0x1f>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    b7 <osip_message_get_content_encoding+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  b1 <osip_message_get_content_encoding+0x32>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_content_encoding (const osip_message_t * sip, int pos, osip_content_encoding_t ** dest)
{
  osip_content_encoding_t *ce;
  *dest = ((void *)0);
  if (osip_list_size (&sip->content_encodings) <= pos)
    return -1;
  ce = (osip_content_encoding_t *) osip_list_get (&sip->content_encodings, pos);
  *dest = ce;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 6
11 5
12 5
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
callq  10f3 <quotearg_style_mem+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)
{
  return quotearg_n_style_mem (0, s, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 3d64 <do_savefile+0xb>
mov    (%rax),%rdi
cmpb   $0x0,(%rdi)
je     3d88 <do_savefile+0x2f>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  3d86 <do_savefile+0x2d>
jmp    3d8d <do_savefile+0x34>
callq  3d8d <do_savefile+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_savefile(void)
{
    if (openfile->filename[0] != '\0')
 write_file(openfile->filename, ((void *)0), 0, OVERWRITE, 0);
    else
 do_writeout_void();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x98,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
test   %rsi,%rsi
jne    3f7 <strbuf_putn64+0x63>
mov    0x10(%rdi),%rax
cmp    %rax,0x18(%rdi)
jb     3c7 <strbuf_putn64+0x33>
callq  3c7 <strbuf_putn64+0x33>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
movb   $0x30,(%rax)
jmpq   46d <strbuf_putn64+0xd9>
add    $0x1,%rcx
cmp    $0x80,%rcx
jne    406 <strbuf_putn64+0x72>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3f7 <strbuf_putn64+0x63>
mov    $0x0,%ecx
movabs $0x6666666666666667,%rdi
mov    %ecx,%ebp
mov    %rsi,%rax
imul   %rdi
sar    $0x2,%rdx
mov    %rsi,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rsi
add    $0x30,%esi
mov    %sil,(%rsp,%rcx,1)
mov    %rdx,%rsi
test   %rdx,%rdx
jne    3db <strbuf_putn64+0x47>
test   %ecx,%ecx
js     46d <strbuf_putn64+0xd9>
mov    0x10(%rbx),%rax
cmp    %rax,0x18(%rbx)
jb     450 <strbuf_putn64+0xbc>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  450 <strbuf_putn64+0xbc>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
movslq %ebp,%rdx
movzbl (%rsp,%rdx,1),%edx
mov    %dl,(%rax)
sub    $0x1,%ebp
cmp    $0xffffffff,%ebp
jne    439 <strbuf_putn64+0xa5>
mov    0x88(%rsp),%rax
xor    %fs:0x28,%rax
je     485 <strbuf_putn64+0xf1>
callq  485 <strbuf_putn64+0xf1>
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
strbuf_putn64(STRBUF *sb, long long n)
{
 if (n == 0) {
  do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = '0';} while (0);
 } else {
  char num[128];
  int i = 0;
  while (n) {
   if (i >= sizeof(num))
    die("Too big integer value.");
   num[i++] = n % 10 + '0';
   n = n / 10;
  }
  while (--i >= 0)
   do { if (sb->curp >= sb->endp) __strbuf_expandbuf(sb, 0); *sb->curp++ = num[i];} while (0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 9
21 9
22 10
23 10
24 10
25 3
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 12
40 8
41 8
42 14
43 14
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 15
55 15
56 14
57 14
58 14
59 17
60 17
61 17
62 17
63 17
64 17
65 17
66 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1a <cdio_get_default_device_bsdi+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cdio_get_default_device_bsdi(void)
{
  return strdup("/dev/rsr0c");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  3b0e <bool_primary>
mov    %rax,%rbp
jmpq   3c43 <bool_factor+0xb2>
cmpl   $0x0,0x0(%rip)        # 3bab <bool_factor+0x1a>
je     3bc9 <bool_factor+0x38>
cmpl   $0x4,0x4(%rbp)
je     3bc9 <bool_factor+0x38>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3fd <error>
movl   $0x4,0x4(%rbp)
callq  1e59 <get_token>
callq  3b0e <bool_primary>
mov    %rax,%rbx
cmpl   $0x0,0x0(%rip)        # 3bdd <bool_factor+0x4c>
je     3c43 <bool_factor+0xb2>
cmpl   $0x4,0x4(%rax)
je     3bfb <bool_factor+0x6a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3fd <error>
movl   $0x4,0x4(%rbx)
movl   $0x0,0x0(%rbp)
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2012 <prepend>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2142 <append>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  2a44 <catenate>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2142 <append>
cmpl   $0x7,0x0(%rip)        # 3c4a <bool_factor+0xb9>
jne    3c59 <bool_factor+0xc8>
cmpl   $0x12,0x0(%rip)        # 3c53 <bool_factor+0xc2>
je     3ba4 <bool_factor+0x13>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
bool_factor(void)
{ CODE *x, *y;
      x = bool_primary();
      while (((token[1].code) == 7 && token[1].delim == 18))
      { if (second_pass)
         { if (x->type != 0x0004)
            { error("operand preceding `&' is not of Boolean type");
               x->type = 0x0004;
            }
         }
         get_token( );
         y = bool_primary();
         if (second_pass)
         { if (y->type != 0x0004)
            { error("operand following `&' is not of Boolean type");
               y->type = 0x0004;
            }
            x->lval = 0;
            prepend(x, "and" "(");
            append(x, ", ");
            catenate(x, y);
            append(x, ")");
         }
      }
      return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 8
15 11
16 12
17 12
18 13
19 13
20 14
21 14
22 15
23 15
24 15
25 16
26 18
27 19
28 19
29 19
30 19
31 20
32 20
33 20
34 20
35 21
36 21
37 21
38 22
39 22
40 22
41 22
42 4
43 4
44 4
45 4
46 26
47 26
48 26
49 26
50 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     2c <gsl_rng_memcpy+0x2c>
mov    $0x4,%ecx
mov    $0x3d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  25 <gsl_rng_memcpy+0x25>
mov    $0x4,%eax
jmp    42 <gsl_rng_memcpy+0x42>
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rsi
mov    0x18(%rax),%rdx
callq  3d <gsl_rng_memcpy+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_rng_memcpy (gsl_rng * dest, const gsl_rng * src)
{
  if (dest->type != src->type)
    {
      do { gsl_error ("generators must be of the same type", "rng.c", 61, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  memcpy (dest->state, src->state, src->type->size);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 2937 <kill_all_local_variables+0x8>
test   %rbx,%rbx
je     2982 <kill_all_local_variables+0x53>
mov    0x0(%rip),%eax        # 2942 <kill_all_local_variables+0x13>
testb  $0x4,0xc(%rbx)
je     294d <kill_all_local_variables+0x1e>
cmp    %eax,0x8(%rbx)
je     2958 <kill_all_local_variables+0x29>
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    2942 <kill_all_local_variables+0x13>
jmp    2982 <kill_all_local_variables+0x53>
test   %rbx,%rbx
je     2982 <kill_all_local_variables+0x53>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     297a <kill_all_local_variables+0x4b>
testb  $0x1,0xc(%rbx)
je     297a <kill_all_local_variables+0x4b>
callq  2971 <kill_all_local_variables+0x42>
mov    0x20(%rbx),%rdi
callq  297a <kill_all_local_variables+0x4b>
movq   $0x0,0x20(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
kill_all_local_variables ()
{
  VAR_CONTEXT *vc;
  for (vc = shell_variables; vc; vc = vc->down)
    if ((((vc)->flags & 0x04) != 0) && vc->scope == variable_context)
      break;
  if (vc == 0)
    return;
  if (vc->table && (((vc)->flags & 0x01) != 0))
    {
      delete_all_variables (vc->table);
      hash_dispose (vc->table);
    }
  vc->table = (HASH_TABLE *)((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 4
11 4
12 4
13 4
14 7
15 7
16 9
17 9
18 9
19 9
20 9
21 11
22 12
23 12
24 14
25 15
26 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmp    $0x1,%edi
jne    85c <ds_sasl+0x32>
callq  838 <ds_sasl+0xe>
test   %eax,%eax
je     848 <ds_sasl+0x1e>
mov    $0x0,%edi
callq  846 <ds_sasl+0x1c>
jmp    852 <ds_sasl+0x28>
mov    $0x0,%edi
callq  852 <ds_sasl+0x28>
mov    %rax,%rdi
callq  85a <ds_sasl+0x30>
jmp    877 <ds_sasl+0x4d>
mov    0x8(%rsi),%rsi
lea    0xc(%rsp),%rdi
callq  86a <ds_sasl+0x40>
test   %eax,%eax
jne    877 <ds_sasl+0x4d>
mov    0xc(%rsp),%edi
callq  877 <ds_sasl+0x4d>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
ds_sasl(int argc, char **argv)
{
    if (argc == 1) {
 printf("%s\n", sasl_enabled_p() ? gettext ("on") : gettext ("off"));
    } else {
 int val;
 if (set_bool(&val, argv[1]) == 0)
     sasl_enable(val);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 7
16 7
17 7
18 7
19 7
20 8
21 8
22 10
23 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x10,%edi
callq  d4 <file_reader_add_file+0x16>
mov    %rbp,(%rax)
movq   $0x0,0x8(%rax)
mov    (%rbx),%rdx
test   %rdx,%rdx
je     fe <file_reader_add_file+0x40>
mov    0x8(%rdx),%rcx
test   %rcx,%rcx
je     103 <file_reader_add_file+0x45>
mov    0x8(%rcx),%rdx
test   %rdx,%rdx
je     106 <file_reader_add_file+0x48>
mov    %rdx,%rcx
jmp    f0 <file_reader_add_file+0x32>
mov    %rax,(%rbx)
jmp    10a <file_reader_add_file+0x4c>
mov    %rdx,%rcx
mov    %rax,0x8(%rcx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
file_reader_add_file(struct file_rd_info *fri, char *name)
{
  struct file_list *np, *new;
  new = (struct file_list *) xmalloc (sizeof (struct file_list));
  new->name = name;
  new->next = ((void *)0);
  for (np = fri->the_files; (np != ((void *)0)) && (np->next != ((void *)0)); np = np->next)
              ;
  if (np == ((void *)0))
    {
      fri->the_files = new;
    }
  else
    {
      np->next = new;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 11
22 11
23 7
24 15
25 17
26 17
27 17
28 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r9
test   %rsi,%rsi
je     44c <mallocstrcpy+0x25>
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
jmp    451 <mallocstrcpy+0x2a>
mov    $0x1,%edx
mov    %r9,%rdi
callq  459 <mallocstrcpy+0x32>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mallocstrcpy(char *dest, const char *src)
{
    return mallocstrncpy(dest, src, (src == ((void *)0)) ? 1 : strlen(src) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 4
16 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x20(%rsi),%rsi
mov    (%rax),%rdx
callq  177 <nettle_buffer_copy+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_buffer_copy(struct nettle_buffer *dst,
     const struct nettle_buffer *src)
{
  return nettle_buffer_write(dst, src->size, src->contents);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    %rcx,%r13
mov    %rdx,%rdi
callq  3cf <headerProbeAddr+0x1e>
add    $0x1,%eax
cmp    $0x4,%eax
ja     3e0 <headerProbeAddr+0x2f>
mov    %eax,%eax
jmpq   *0x0(,%rax,8)
mov    $0x0,%edx
jmp    3fa <headerProbeAddr+0x49>
mov    $0x0,%edx
jmp    3fa <headerProbeAddr+0x49>
mov    $0x0,%edx
jmp    3fa <headerProbeAddr+0x49>
mov    $0x0,%edx
mov    %r12,%rcx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 409 <headerProbeAddr+0x58>
mov    $0x0,%eax
callq  413 <headerProbeAddr+0x62>
test   %rbx,%rbx
je     439 <headerProbeAddr+0x88>
test   %r13,%r13
je     439 <headerProbeAddr+0x88>
mov    %rbx,%rcx
mov    %r13,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 42f <headerProbeAddr+0x7e>
mov    $0x0,%eax
callq  439 <headerProbeAddr+0x88>
test   %rbp,%rbp
je     457 <headerProbeAddr+0xa6>
mov    %rbp,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 44d <headerProbeAddr+0x9c>
mov    $0x0,%eax
callq  457 <headerProbeAddr+0xa6>
mov    0x0(%rip),%rsi        # 45e <headerProbeAddr+0xad>
mov    $0xa,%edi
callq  468 <headerProbeAddr+0xb7>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
headerProbeAddr(Header h, const char * msg,
 void * p, const char * imsg)
{
    const char * mchkstr = ((void *)0);
    switch (mprobe(p)) {
    case MCHECK_DISABLED:
    case MCHECK_OK:
 return;
                  break;
    case MCHECK_HEAD:
 mchkstr = "HEAD";
 break;
    case MCHECK_TAIL:
 mchkstr = "TAIL";
 break;
    case MCHECK_FREE:
 mchkstr = "FREE";
 break;
    }
    fprintf(stderr, "*** MCHECK_%s h %p", mchkstr, h);
    if (imsg && p)
 fprintf(stderr, " %s %p", imsg, p);
    if (msg)
 fprintf(stderr, " %s", msg);
    fprintf(stderr, "\n");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 4
18 4
19 14
20 15
21 17
22 18
23 11
24 20
25 20
26 20
27 20
28 20
29 21
30 21
31 21
32 21
33 22
34 22
35 22
36 22
37 22
38 22
39 23
40 23
41 24
42 24
43 24
44 24
45 24
46 25
47 25
48 25
49 26
50 26
51 26
52 26
53 26
54 26
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdi        # 12e3 <clear_directory_table+0x8>
test   %rdi,%rdi
je     12ed <clear_directory_table+0x12>
callq  12ed <clear_directory_table+0x12>
mov    0x0(%rip),%rdi        # 12f4 <clear_directory_table+0x19>
test   %rdi,%rdi
je     12fe <clear_directory_table+0x23>
callq  12fe <clear_directory_table+0x23>
mov    0x0(%rip),%rdi        # 1305 <clear_directory_table+0x2a>
test   %rdi,%rdi
je     131c <clear_directory_table+0x41>
mov    (%rdi),%rbx
callq  9b <free_directory>
test   %rbx,%rbx
je     131c <clear_directory_table+0x41>
mov    %rbx,%rdi
jmp    130a <clear_directory_table+0x2f>
movq   $0x0,0x0(%rip)        # 1327 <clear_directory_table+0x4c>
movq   $0x0,0x0(%rip)        # 1332 <clear_directory_table+0x57>
pop    %rbx
retq   
<<<sep_in_sample>>>
clear_directory_table (void)
{
  struct directory *dp;
  if (directory_table)
    hash_clear (directory_table);
  if (directory_meta_table)
    hash_clear (directory_meta_table);
  for (dp = dirhead; dp; )
    {
      struct directory *next = dp->next;
      free_directory (dp);
      dp = next;
    }
  dirhead = dirtail = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 6
7 6
8 6
9 7
10 8
11 8
12 8
13 10
14 11
15 8
16 8
17 12
18 12
19 14
20 14
21 15
22 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbp
test   %rdx,%rdx
jne    11 <__gmpz_cdiv_r_ui+0x11>
callq  11 <__gmpz_cdiv_r_ui+0x11>
mov    %rdi,%r12
mov    %rsi,%rax
movslq 0x4(%rsi),%rbx
test   %rbx,%rbx
jne    2e <__gmpz_cdiv_r_ui+0x2e>
movl   $0x0,0x4(%rdi)
mov    $0x0,%eax
jmp    75 <__gmpz_cdiv_r_ui+0x75>
mov    %rbx,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rsi
xor    %rbx,%rsi
sub    %rdx,%rsi
mov    0x8(%rax),%rdi
mov    %rbp,%rdx
callq  4a <__gmpz_cdiv_r_ui+0x4a>
test   %rax,%rax
jne    5a <__gmpz_cdiv_r_ui+0x5a>
movl   $0x0,0x4(%r12)
jmp    75 <__gmpz_cdiv_r_ui+0x75>
sub    %rax,%rbp
test   %rbx,%rbx
cmovns %rbp,%rax
mov    0x8(%r12),%rdx
mov    %rax,(%rdx)
movl   $0xffffffff,0x4(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
__gmpz_cdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)
{
  mp_size_t ns, nn;
  mp_ptr np;
  mp_limb_t rl;
  if (__builtin_expect ((divisor == 0) != 0, 0))
    __gmp_divide_by_zero ();
  ns = ((dividend)->_mp_size);
  if (ns == 0)
    {
      ((rem)->_mp_size) = 0;
      return 0;
    }
  nn = ((ns) >= 0 ? (ns) : -(ns));
  np = ((dividend)->_mp_d);
    {
      rl = __gmpn_mod_1 (np, nn, (mp_limb_t) divisor);
      if (rl == 0)
 ((rem)->_mp_size) = 0;
      else
 {
   if (ns >= 0)
     rl = divisor - rl;
   ((rem)->_mp_d)[0] = rl;
   ((rem)->_mp_size) = -1;
 }
    }
  return rl;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 7
8 7
9 7
10 8
11 9
12 9
13 11
14 12
15 12
16 14
17 14
18 14
19 14
20 14
21 17
22 17
23 17
24 18
25 18
26 19
27 19
28 23
29 23
30 23
31 24
32 24
33 25
34 29
35 29
36 29
37 29
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
callq  fc9 <pop_body_transport+0x11>
mov    %rax,%rdi
callq  fd1 <pop_body_transport+0x19>
mov    %rax,%rdi
callq  fd9 <pop_body_transport+0x21>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  f86 <pop_get_transport2>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
pop_body_transport (mu_stream_t stream, mu_transport_t *ptr, mu_transport_t *ptr2)
{
  mu_body_t body = mu_stream_get_owner (stream);
  mu_message_t msg = mu_body_get_owner (body);
  pop_message_t mpm = mu_message_get_owner (msg);
  return pop_get_transport2 (mpm, ptr, ptr2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
and    $0x2,%esi
callq  16ee <grecs_grecs_parser+0xb>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    1754 <grecs_grecs_parser+0x71>
and    $0x1,%ebx
mov    %ebx,0x0(%rip)        # 1702 <grecs_grecs_parser+0x1f>
movq   $0x0,0x0(%rip)        # 170d <grecs_grecs_parser+0x2a>
callq  1712 <grecs_grecs_parser+0x2f>
mov    %eax,%ebx
cmpl   $0x0,0x0(%rip)        # 171b <grecs_grecs_parser+0x38>
jne    1748 <grecs_grecs_parser+0x65>
mov    %eax,%edi
callq  1724 <grecs_grecs_parser+0x41>
test   %ebx,%ebx
je     173f <grecs_grecs_parser+0x5c>
mov    0x0(%rip),%rdi        # 172f <grecs_grecs_parser+0x4c>
callq  1734 <grecs_grecs_parser+0x51>
movq   $0x0,0x0(%rip)        # 173f <grecs_grecs_parser+0x5c>
mov    0x0(%rip),%rax        # 1746 <grecs_grecs_parser+0x63>
jmp    1754 <grecs_grecs_parser+0x71>
mov    $0x1,%edi
callq  1752 <grecs_grecs_parser+0x6f>
jmp    1728 <grecs_grecs_parser+0x45>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_grecs_parser(const char *name, int traceflags)
{
 int rc;
 if (grecs_lex_begin(name, traceflags & 0x02))
  return ((void *)0);
 grecs_grecs_debug = traceflags & 0x01;
 parse_tree = ((void *)0);
 rc = grecs_grecs_parse();
 if (grecs_error_count)
  rc = 1;
 grecs_lex_end(rc);
 if (rc) {
  grecs_tree_free(parse_tree);
  parse_tree = ((void *)0);
 }
 return parse_tree;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 4
8 4
9 6
10 6
11 7
12 8
13 8
14 9
15 9
16 11
17 11
18 12
19 12
20 13
21 13
22 14
23 16
24 16
25 11
26 11
27 11
28 17
29 17
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    0x8(%rsi),%rdx
cmp    %rdx,(%rsi)
cmovbe (%rsi),%rdx
mov    %rdx,(%rax)
mov    %r8,0x8(%rax)
mov    %rdi,0x10(%rax)
mov    %rcx,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_diagonal (gsl_matrix_ushort * m)
{
  _gsl_vector_ushort_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_ushort v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 12
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     514 <mu_wicket_set_data+0x10>
mov    %rsi,0x8(%rdi)
mov    $0x0,%al
repz retq 
<<<sep_in_sample>>>
mu_wicket_set_data (mu_wicket_t wicket, void *data)
{
  if (!wicket)
    return 22;
  wicket->data = data;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 6
6 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmp    %rdx,(%rsi)
ja     4fb2 <gsl_matrix_const_row+0x4a>
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4f8a <gsl_matrix_const_row+0x22>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
movq   $0x0,0x18(%rbx)
movl   $0x0,0x20(%rbx)
jmp    4fe4 <gsl_matrix_const_row+0x7c>
mov    0x10(%rsi),%rax
shl    $0x3,%rax
imul   %rax,%rdx
add    0x18(%rsi),%rdx
mov    0x20(%rsi),%rax
mov    0x8(%rsi),%rcx
mov    %rcx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rdx,0x10(%rdi)
mov    %rax,0x18(%rdi)
movl   $0x0,0x20(%rdi)
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_matrix_const_row (const gsl_matrix * m, const size_t i)
{
  _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 10
20 13
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rcx
mov    (%rdi),%rax
mov    0x8(%rdi),%rdx
add    %rdx,%rdx
mov    %rax,%r11
shr    %r11
je     1d4 <gsl_vector_complex_long_double_reverse+0x90>
push   %rbx
mov    %rdx,%rbx
neg    %rbx
shl    $0x4,%rbx
mov    %rax,%r9
shl    $0x4,%r9
sub    $0x10,%r9
imul   %rdx,%r9
add    %rcx,%r9
mov    %rdx,%r10
shl    $0x4,%r10
neg    %rax
shl    $0x4,%rax
mov    %rax,%rdi
add    $0x10,%rdi
imul   %rdx,%rdi
mov    $0x0,%ecx
mov    $0x0,%r8d
mov    %r9,%rax
mov    $0x2,%edx
fldt   (%rax)
lea    (%rax,%rdi,1),%rsi
fldt   (%rsi,%rcx,1)
fstpt  (%rax)
fstpt  (%rsi,%rcx,1)
add    $0x10,%rax
sub    $0x1,%rdx
jne    1a3 <gsl_vector_complex_long_double_reverse+0x5f>
add    $0x1,%r8
add    %rbx,%r9
add    %r10,%rdi
add    %r10,%rcx
cmp    %r11,%r8
jne    19b <gsl_vector_complex_long_double_reverse+0x57>
mov    $0x0,%eax
pop    %rbx
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_reverse (gsl_vector_complex_long_double * v)
{
  long double * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 2 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 2; k++)
        {
          long double tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 2
23 2
24 8
25 8
26 8
27 8
28 14
29 14
30 15
31 15
32 16
33 16
34 12
35 12
36 8
37 8
38 8
39 8
40 8
41 8
42 20
43 20
44 20
45 20
46 20
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
eval_scheme_string_function (command)
     char *command;
{
  }
<<<sep_in_sample>>>
1 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x1860(%rdi),%rdi
callq  10 <CloseAWindow+0x10>
mov    0x1868(%rbx),%rdi
callq  1c <CloseAWindow+0x1c>
mov    0x1870(%rbx),%rdi
callq  28 <CloseAWindow+0x28>
mov    0x1888(%rbx),%rdi
callq  34 <CloseAWindow+0x34>
mov    0x1898(%rbx),%rdi
callq  40 <CloseAWindow+0x40>
cmpl   $0x0,0x183c(%rbx)
je     55 <CloseAWindow+0x55>
mov    0x18a8(%rbx),%rdi
callq  55 <CloseAWindow+0x55>
mov    0x1848(%rbx),%rdi
callq  61 <CloseAWindow+0x61>
mov    0x1850(%rbx),%rdi
callq  6d <CloseAWindow+0x6d>
mov    %rbx,%rdi
callq  75 <CloseAWindow+0x75>
pop    %rbx
retq   
<<<sep_in_sample>>>
CloseAWindow(AWindow * w)
{
 free((char *) w->edges);
 free((char *) w->lines);
 free((char *) w->edgePool);
 free((char *) w->csPool0);
 free((char *) w->csPool1);
 if (w->doubleBuffered) {
  free((char *) w->csPool2);
 }
 free((char *) w->scanLine);
 free((char *) w->lastScanLine);
 free((char *) w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 11
18 11
19 12
20 12
21 13
22 13
23 14
24 14
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rdi
mov    %rdx,%r12
cmp    $0x1,%rcx
je     1f89 <gsl_block_ulong_raw_fread+0x37>
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %rdx,%rdx
je     200f <gsl_block_ulong_raw_fread+0xbd>
jmp    1fc3 <gsl_block_ulong_raw_fread+0x71>
mov    %r13,%rcx
mov    $0x8,%esi
callq  1f96 <gsl_block_ulong_raw_fread+0x44>
mov    %rax,%rdx
mov    $0x0,%eax
cmp    %r12,%rdx
je     200f <gsl_block_ulong_raw_fread+0xbd>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1fbc <gsl_block_ulong_raw_fread+0x6a>
mov    $0x5,%eax
jmp    200f <gsl_block_ulong_raw_fread+0xbd>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  1fd8 <gsl_block_ulong_raw_fread+0x86>
cmp    $0x1,%rax
je     1ffe <gsl_block_ulong_raw_fread+0xac>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ff7 <gsl_block_ulong_raw_fread+0xa5>
mov    $0x5,%eax
jmp    200f <gsl_block_ulong_raw_fread+0xbd>
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
jne    1fc3 <gsl_block_ulong_raw_fread+0x71>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_block_ulong_raw_fread (FILE * stream, unsigned long * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (unsigned long), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (unsigned long), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 17
12 17
13 17
14 25
15 15
16 15
17 15
18 6
19 6
20 6
21 6
22 25
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 17
33 17
34 17
35 17
36 17
37 19
38 19
39 21
40 21
41 21
42 21
43 21
44 21
45 21
46 15
47 15
48 15
49 15
50 25
51 26
52 26
53 26
54 26
55 26
56 26
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%esi
mov    $0x4,%edi
callq  13 <_gsasl_openid20_client_start+0x13>
mov    $0x7,%edx
test   %rax,%rax
je     22 <_gsasl_openid20_client_start+0x22>
mov    %rax,(%rbx)
mov    $0x0,%dl
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_gsasl_openid20_client_start (Gsasl_session * sctx, void **mech_data)
{
  struct openid20_client_state *state;
  state = (struct openid20_client_state *) calloc (sizeof (*state), 1);
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 5
8 5
9 7
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
sub    $0x128,%rsp
mov    %edi,%edx
mov    %fs:0x28,%rax
mov    %rax,0x118(%rsp)
xor    %eax,%eax
movl   $0x0,0x0(%rip)        # 2cfd <shell_completed+0x26>
test   %esi,%esi
jne    2d12 <shell_completed+0x3b>
cmp    $0x7f,%edi
jne    2d12 <shell_completed+0x3b>
movl   $0xffffffff,0x0(%rip)        # 2d10 <shell_completed+0x39>
jmp    2d1c <shell_completed+0x45>
movl   $0x1,0x0(%rip)        # 2d1c <shell_completed+0x45>
mov    $0x0,%esi
lea    0x10(%rsp),%rdi
mov    $0x0,%eax
callq  2d30 <shell_completed+0x59>
mov    0x0(%rip),%rax        # 2d37 <shell_completed+0x60>
mov    0x8(%rax),%r9
movq   $0x0,(%rsp)
mov    $0x0,%r8d
mov    $0x5,%ecx
lea    0x10(%rsp),%rdx
mov    $0xc,%esi
mov    $0x0,%edi
callq  2d62 <shell_completed+0x8b>
mov    0x118(%rsp),%rax
xor    %fs:0x28,%rax
je     2d7a <shell_completed+0xa3>
callq  2d7a <shell_completed+0xa3>
add    $0x128,%rsp
retq   
<<<sep_in_sample>>>
shell_completed (int exit_code, int exit_sig)
{
  char buf[256];
  shell_function_pid = 0;
  if (exit_sig == 0 && exit_code == 127)
    shell_function_completed = -1;
  else
    shell_function_completed = 1;
  sprintf (buf, "%d", exit_code);
  define_variable_in_set((".SHELLSTATUS"),(sizeof (".SHELLSTATUS") - 1),(buf),(o_override),(0), current_variable_set_list->set,((floc *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 6
12 6
13 8
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
jne    8d9 <swpath_set_filename+0x1f>
mov    0x40(%rdi),%rdi
callq  8cc <swpath_set_filename+0x12>
mov    %rax,%rsi
mov    %rbx,%rdi
callq  420 <swpath__set__basename>
jmp    8de <swpath_set_filename+0x24>
callq  420 <swpath__set__basename>
pop    %rbx
nop
retq   
<<<sep_in_sample>>>
swpath_set_filename(SWPATH * swpath, char *s)
{
 if (!s)
  swpath__set__basename(swpath, strob_str(swpath->pathname_));
 else
  swpath__set__basename(swpath, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 4d8 <free_ps_list+0x7>
jle    518 <free_ps_list+0x47>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x0,%ebx
movslq %ebx,%rbp
mov    0x0(%rip),%rax        # 4ef <free_ps_list+0x1e>
mov    (%rax,%rbp,8),%rdi
callq  4f8 <free_ps_list+0x27>
mov    0x0(%rip),%rax        # 4ff <free_ps_list+0x2e>
movq   $0x0,(%rax,%rbp,8)
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # 510 <free_ps_list+0x3f>
jg     4e5 <free_ps_list+0x14>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
free_ps_list()
{
    int i;
    for (i = 0; i < processes; i++)
    {
 xfree(ps_vect[i]);
 ps_vect[i] = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 4
14 4
15 4
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
callq  62 <get_max_fd>
movq   $0x0,(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
cmp    $0x7fffffff,%eax
setne  %dl
movzbl %dl,%edx
add    %edx,%eax
mov    %rsp,%rcx
mov    $0x0,%edx
mov    %eax,%esi
mov    $0x0,%edi
callq  118 <visit_open_fds>
mov    (%rsp),%rax
mov    %rax,0x0(%rip)        # 311 <remember_non_cloexec_fds+0x4f>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rip)        # 31d <remember_non_cloexec_fds+0x5b>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
remember_non_cloexec_fds (void)
{
  int max_fd = get_max_fd ();
  struct remember_fd_context cb_data;
  cb_data.buf = ((void *)0);
  cb_data.used = cb_data.allocated = 0;
  if (max_fd < 2147483647)
    ++max_fd;
  visit_open_fds (0, max_fd, remember_fd_if_non_cloexec, &cb_data);
  non_cloexec_fds = cb_data.buf;
  num_cloexec_fds = cb_data.used;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 6
5 6
6 8
7 8
8 8
9 8
10 9
11 9
12 9
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
mov    $0x0,%r9d
mov    $0xffffffffffffffff,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
callq  b4 <from_header>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
uintmax_from_header (const char *p, size_t s)
{
  return from_header (p, s, "uintmax_t", 0, (18446744073709551615UL), 0, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %dil,0xf(%rsp)
mov    $0x1,%edx
lea    0xf(%rsp),%rsi
mov    0x0(%rip),%rdi        # 4f <grecs_line_acc_grow_char+0x1a>
callq  54 <grecs_line_acc_grow_char+0x1f>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_line_acc_grow_char(int c)
{
 char t = c;
 grecs_txtacc_grow(line_acc, &t, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
je     1972 <drop_volume_label_suffix+0x95>
lea    -0x1(%rbp,%rcx,1),%rbx
cmp    %rbx,%rbp
jae    1979 <drop_volume_label_suffix+0x9c>
callq  190a <drop_volume_label_suffix+0x2d>
mov    (%rax),%rdx
jmp    1918 <drop_volume_label_suffix+0x3b>
sub    $0x1,%rbx
cmp    %rbp,%rbx
je     1980 <drop_volume_label_suffix+0xa3>
movzbl (%rbx),%eax
testb  $0x8,0x1(%rdx,%rax,2)
jne    190f <drop_volume_label_suffix+0x32>
cmp    %rbx,%rbp
jae    1987 <drop_volume_label_suffix+0xaa>
sub    $0x7,%rbx
cmp    %rbx,%rbp
jae    198e <drop_volume_label_suffix+0xb1>
mov    $0x8,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1942 <drop_volume_label_suffix+0x65>
mov    $0x0,%ecx
test   %eax,%eax
jne    1993 <drop_volume_label_suffix+0xb6>
sub    %rbp,%rbx
lea    0x1(%rbx),%rdi
callq  1957 <drop_volume_label_suffix+0x7a>
mov    %rax,%r12
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  1968 <drop_volume_label_suffix+0x8b>
movb   $0x0,(%r12,%rbx,1)
mov    %r12,%rcx
jmp    1993 <drop_volume_label_suffix+0xb6>
mov    $0x0,%ecx
jmp    1993 <drop_volume_label_suffix+0xb6>
mov    $0x0,%ecx
jmp    1993 <drop_volume_label_suffix+0xb6>
mov    $0x0,%ecx
jmp    1993 <drop_volume_label_suffix+0xb6>
mov    $0x0,%ecx
jmp    1993 <drop_volume_label_suffix+0xb6>
mov    $0x0,%ecx
mov    %rcx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
drop_volume_label_suffix (const char *label)
{
  const char *p;
  size_t len = strlen (label);
  if (len < 1)
    return ((void *)0);
  for (p = label + len - 1; p > label && ((*__ctype_b_loc ())[(int) (((unsigned char) *p))] & (unsigned short int) _ISdigit); p--)
    ;
  if (p > label && p - ((sizeof " Volume " - 1) - 1) > label)
    {
      p -= (sizeof " Volume " - 1) - 1;
      if (memcmp (p, " Volume ", (sizeof " Volume " - 1)) == 0)
 {
   char *s = xmalloc ((len = p - label) + 1);
   memcpy (s, label, len);
   s[len] = 0;
   return s;
 }
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 9
26 9
27 9
28 12
29 12
30 12
31 12
32 20
33 12
34 12
35 14
36 14
37 14
38 14
39 15
40 15
41 15
42 15
43 16
44 17
45 17
46 6
47 6
48 20
49 20
50 20
51 20
52 20
53 20
54 20
55 21
56 21
57 21
58 21
59 21
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %edi,%esi
mov    $0x0,%edi
callq  107a <quotearg_style+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_style (enum quoting_style s, char const *arg)
{
  return quotearg_n_style (0, s, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  0 <__gmpf_ceil_or_floor>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__gmpf_ceil (mpf_ptr r, mpf_srcptr u)
{
  __gmpf_ceil_or_floor (r,u,1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     cc <rpmfd_setfd+0x2a>
mov    (%rdi),%rax
mov    0x20(%rsi),%edx
mov    %edx,0x20(%rax)
mov    (%rdi),%rax
mov    0x38(%rsi),%edx
mov    %edx,0x38(%rax)
mov    (%rdi),%rax
mov    0x50(%rsi),%edx
mov    %edx,0x50(%rax)
mov    (%rdi),%rax
mov    0x68(%rsi),%edx
mov    %edx,0x68(%rax)
retq   
mov    (%rdi),%rax
mov    %edx,0x20(%rax)
retq   
<<<sep_in_sample>>>
rpmfd_setfd(RPMFD * rpmfd, FD_t fd, int fd_fd)
{
 if (fd) {
  rpmfd->fd_t_->fps[0].fdno=fd->fps[0].fdno;
  rpmfd->fd_t_->fps[1].fdno=fd->fps[1].fdno;
  rpmfd->fd_t_->fps[2].fdno=fd->fps[2].fdno;
  rpmfd->fd_t_->fps[3].fdno=fd->fps[3].fdno;
 }
 else {
  rpmfd->fd_t_->fps[0].fdno=fd_fd;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 10
17 10
18 10
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rdx,0x30(%rsp)
movl   $0x10,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    %esi,%esi
mov    $0x0,%eax
callq  31 <rpl_ioctl+0x31>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
rpl_ioctl (int fd, int request, ... )
{
  void *buf;
  va_list args;
  __builtin_va_start(args,request);
  buf = __builtin_va_arg(args,void *);
  __builtin_va_end(args);
  return ioctl (fd, (unsigned int) request, buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 8
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # a <args_open+0xa>
mov    %rdi,0x0(%rip)        # 11 <args_open+0x11>
retq   
<<<sep_in_sample>>>
args_open(const char **args)
{
 type = 1;
 argslist = args;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     32 <printtype+0x32>
cmp    $0x4000,%eax
ja     22 <printtype+0x22>
cmp    $0x1000,%eax
je     43 <printtype+0x43>
jmp    76 <printtype+0x76>
cmp    $0xa000,%eax
je     54 <printtype+0x54>
cmp    $0xc000,%eax
je     65 <printtype+0x65>
jmp    76 <printtype+0x76>
mov    $0x2f,%edi
callq  3c <printtype+0x3c>
mov    $0x1,%eax
jmp    90 <printtype+0x90>
mov    $0x7c,%edi
callq  4d <printtype+0x4d>
mov    $0x1,%eax
jmp    90 <printtype+0x90>
mov    $0x40,%edi
callq  5e <printtype+0x5e>
mov    $0x1,%eax
jmp    90 <printtype+0x90>
mov    $0x3d,%edi
callq  6f <printtype+0x6f>
mov    $0x1,%eax
jmp    90 <printtype+0x90>
mov    $0x0,%eax
test   $0x49,%dil
je     90 <printtype+0x90>
mov    $0x2a,%edi
callq  8b <printtype+0x8b>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
printtype (u_int mode)
{
  switch (mode & 0170000)
    {
    case 0040000:
      putchar ('/');
      return (1);
    case 0010000:
      putchar ('|');
      return (1);
    case 0120000:
      putchar ('@');
      return (1);
    case 0140000:
      putchar ('=');
      return (1);
    }
  if (mode & (0100 | (0100 >> 3) | ((0100 >> 3) >> 3)))
    {
      putchar ('*');
      return (1);
    }
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 6
17 6
18 7
19 7
20 9
21 9
22 10
23 10
24 12
25 12
26 13
27 13
28 15
29 15
30 16
31 16
32 23
33 18
34 18
35 20
36 20
37 21
38 24
39 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 2be <exit_handler+0xb>
test   %rdi,%rdi
je     2c8 <exit_handler+0x15>
callq  2c8 <exit_handler+0x15>
mov    0x0(%rip),%rdi        # 2cf <exit_handler+0x1c>
test   %rdi,%rdi
je     2d9 <exit_handler+0x26>
callq  2d9 <exit_handler+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
exit_handler (void)
{
  if (job)
    a2ps_job_unlink_tmpfiles (job);
  if (sample_tmpname)
    unlink (sample_tmpname);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 6
10 7
11 7
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
test   %edi,%edi
je     6a3 <mode+0x22>
cmp    $0x1,%edi
je     6cb <mode+0x4a>
jmpq   796 <mode+0x115>
mov    $0x0,%esi
mov    $0x0,%edi
callq  6b2 <mode+0x31>
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  6c6 <mode+0x45>
jmpq   796 <mode+0x115>
mov    0x0(%rip),%rax        # 6d2 <mode+0x51>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # 6dd <mode+0x5c>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # 6e9 <mode+0x68>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # 6f5 <mode+0x74>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # 701 <mode+0x80>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # 70d <mode+0x8c>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # 719 <mode+0x98>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%eax        # 724 <mode+0xa3>
mov    %eax,0x38(%rsp)
andl   $0xfffffffe,0x4(%rsp)
andl   $0xffff7ff4,0xc(%rsp)
mov    (%rsp),%eax
mov    %eax,%edx
and    $0xfe,%dh
mov    %edx,(%rsp)
movb   $0x1,0x17(%rsp)
movb   $0x0,0x16(%rsp)
cmpl   $0x0,0x0(%rip)        # 751 <mode+0xd0>
je     78b <mode+0x10a>
and    $0xffffeadf,%eax
mov    %eax,(%rsp)
movb   $0x0,0x1a(%rsp)
movb   $0x0,0x19(%rsp)
jmp    770 <mode+0xef>
orl    $0x400,(%rsp)
jmp    777 <mode+0xf6>
andl   $0xfffffbff,(%rsp)
mov    %rsp,%rdx
mov    $0x1,%esi
mov    $0x0,%edi
callq  789 <mode+0x108>
jmp    796 <mode+0x115>
testb  $0x4,0x0(%rip)        # 792 <mode+0x111>
jne    767 <mode+0xe6>
jmp    770 <mode+0xef>
mov    0x48(%rsp),%rax
xor    %fs:0x28,%rax
je     7ab <mode+0x12a>
callq  7ab <mode+0x12a>
add    $0x58,%rsp
nop
retq   
<<<sep_in_sample>>>
mode (int f)
{
  struct termios tt;
  switch (f)
    {
    case 0:
      tcgetattr (0, &ixon_state);
      tcsetattr (0, 1, &deftt);
      break;
    case 1:
      tt = deftt;
      tt.c_oflag &= ~(0000001);
      tt.c_lflag &= ~(0000010 | 0000002 | 0100000 | 0000001);
      tt.c_iflag &= ~(0000400);
      tt.c_cc[6] = 1;
      tt.c_cc[5] = 0;
      if (eight)
 {
   tt.c_iflag &= ~(0002000 | 0010000 | 0000040);
   tt.c_cc[9] = '\0';
   tt.c_cc[8] = '\0';
 }
      if ((ixon_state.c_iflag & 0002000) && !eight)
 tt.c_iflag |= 0002000;
      else
 tt.c_iflag &= ~0002000;
      tcsetattr (0, 1, &tt);
      break;
    default:
      return;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 9
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 14
37 14
38 14
39 14
40 15
41 16
42 17
43 17
44 19
45 19
46 20
47 21
48 21
49 24
50 24
51 26
52 27
53 27
54 27
55 27
56 28
57 23
58 23
59 23
60 32
61 32
62 32
63 32
64 32
65 32
66 32
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  872 <stat_error+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
stat_error (char const *name)
{
  call_arg_error ("stat", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x1c(%rdi),%eax
cmp    $0x17,%eax
je     ad <make_assignable+0x21>
cmp    $0x48,%eax
je     a2 <make_assignable+0x16>
cmp    $0x10,%eax
jne    c3 <make_assignable+0x37>
xchg   %ax,%ax
jmp    b8 <make_assignable+0x2c>
movl   $0x4e,0x1c(%rdi)
mov    %rdi,%rax
retq   
movl   $0x50,0x1c(%rdi)
mov    %rdi,%rax
retq   
movl   $0x4f,0x1c(%rdi)
mov    %rdi,%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
make_assignable(INSTRUCTION *ip)
{
 switch (ip->opcode) {
 case Op_push:
  ip->opcode = Op_push_lhs;
  return ip;
 case Op_field_spec:
  ip->opcode = Op_field_spec_lhs;
  return ip;
 case Op_subscript:
  ip->opcode = Op_subscript_lhs;
  return ip;
 default:
  break;
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 6
12 6
13 8
14 9
15 9
16 11
17 12
18 12
19 16
20 17
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdx),%rax
cmp    0x8(%rdx),%rax
je     1714 <gsl_blas_cher+0x2d>
mov    $0x14,%ecx
mov    $0x460,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  170d <gsl_blas_cher+0x26>
mov    $0x14,%eax
jmp    175f <gsl_blas_cher+0x78>
cmp    (%rsi),%rax
je     1739 <gsl_blas_cher+0x52>
mov    $0x13,%ecx
mov    $0x464,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1732 <gsl_blas_cher+0x4b>
mov    $0x13,%eax
jmp    175f <gsl_blas_cher+0x78>
mov    0x18(%rdx),%r9
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rcx
mov    0x10(%rdx),%rdx
mov    %edx,(%rsp)
mov    %eax,%edx
mov    %edi,%esi
mov    $0x65,%edi
callq  175a <gsl_blas_cher+0x73>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
               const gsl_vector_complex_float * X,
               gsl_matrix_complex_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 1120, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (X->size != N)
    {
      do { gsl_error ("invalid length", "blas.c", 1124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_cher (CblasRowMajor, Uplo, ((int)(M)), alpha, X->data, ((int)(X->stride)),
              A->data, ((int)(A->tda)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 11
13 11
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 15
29 15
30 17
31 18
32 18
<<<sep_out_sample>>>
cmpb   $0x0,(%rdi)
je     1a <Barcode_93_verify+0x1a>
je     20 <Barcode_93_verify+0x20>
mov    $0x0,%eax
add    $0x1,%eax
movslq %eax,%rdx
cmpb   $0x0,(%rdi,%rdx,1)
jne    c <Barcode_93_verify+0xc>
jmp    26 <Barcode_93_verify+0x26>
mov    $0xffffffff,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
Barcode_93_verify(char *text)
{
    int i;
    if (!strlen(text))
 return -1;
    for (i=0; text[i]; i++) {
        if ((int)text[i] > 127)
            return -1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 5
11 5
12 10
13 10
14 10
15 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xb0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
                       const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  870 <grecs_grecs_realloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_grecs_realloc (void * ptr, grecs_grecs__size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rsi,%rcx,1),%rdx
cmp    %rdx,%rsi
ja     2cc <topdomain+0x43>
mov    $0x0,%ecx
mov    $0x0,%eax
cmpb   $0x2e,(%rdx)
jne    2c1 <topdomain+0x38>
add    $0x1,%ecx
cmp    $0x2,%ecx
je     2d2 <topdomain+0x49>
mov    %rdx,%rax
sub    $0x1,%rdx
cmp    %rdx,%rsi
jbe    2b1 <topdomain+0x28>
repz retq 
mov    $0x0,%eax
retq   
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
topdomain (const char *h)
{
  const char *p, *maybe = ((void *)0);
  int dots = 0;
  for (p = h + strlen (h); p >= h; p--)
    {
      if (*p == '.')
 {
   if (++dots == 2)
     return p;
   maybe = p;
 }
    }
  return maybe;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 3
11 7
12 7
13 9
14 9
15 9
16 9
17 5
18 5
19 5
20 5
21 3
22 3
23 3
24 15
<<<sep_out_sample>>>
push   %rbx
callq  27 <xstr_cd_iconv+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    3e <xstr_cd_iconv+0x1d>
callq  34 <xstr_cd_iconv+0x13>
cmpl   $0xc,(%rax)
jne    3e <xstr_cd_iconv+0x1d>
callq  3e <xstr_cd_iconv+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstr_cd_iconv (const char *src, iconv_t cd)
{
  char *result = str_cd_iconv (src, cd);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
cmp    $0x11,%edi
ja     5a8 <sig_handler+0x86>
mov    %edi,%eax
jmpq   *0x0(,%rax,8)
movl   $0x1,0x0(%rip)        # 53d <sig_handler+0x1b>
jmp    5a8 <sig_handler+0x86>
movl   $0x1,0x0(%rip)        # 549 <sig_handler+0x27>
mov    %edi,%edx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  55f <sig_handler+0x3d>
jmp    5a8 <sig_handler+0x86>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x5,%edi
mov    $0x0,%eax
callq  57a <sig_handler+0x58>
movl   $0x2,0x0(%rip)        # 584 <sig_handler+0x62>
jmp    5a8 <sig_handler+0x86>
movl   $0x1,0x0(%rip)        # 590 <sig_handler+0x6e>
jmp    5a8 <sig_handler+0x86>
movl   $0x3,0x0(%rip)        # 59c <sig_handler+0x7a>
jmp    5a8 <sig_handler+0x86>
movl   $0x4,0x0(%rip)        # 5a8 <sig_handler+0x86>
mov    $0x0,%esi
mov    %ebx,%edi
callq  5b4 <sig_handler+0x92>
pop    %rbx
retq   
<<<sep_in_sample>>>
sig_handler (int sig)
{
  switch (sig)
    {
    case 17:
      children_cleanup = 1;
      break;
    case 15:
    case 2:
    case 3:
      action = 1;
      logmsg (5, "received signal %d", sig);
      break;
    case 1:
      logmsg (5, "received signal %d", sig);
      action = 2;
      break;
    case 14:
      got_alarm = 1;
      break;
    case 10:
      action = 3;
      break;
    case 12:
      action = 4;
      break;
    }
  signal (sig, sig_handler);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 6
8 7
9 11
10 12
11 12
12 12
13 12
14 12
15 13
16 15
17 15
18 15
19 15
20 15
21 16
22 17
23 19
24 20
25 22
26 23
27 25
28 28
29 28
30 28
31 29
32 29
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %rdi,%rbx
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     2b5 <debugtoken+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
cmpl   $0x1,0x0(%rip)        # 2bc <debugtoken+0x62>
jle    3c8 <debugtoken+0x16e>
test   %rsi,%rsi
je     31a <debugtoken+0xc0>
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # 2fa <debugtoken+0xa0>
callq  2ff <debugtoken+0xa5>
mov    0x0(%rip),%rcx        # 306 <debugtoken+0xac>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  31a <debugtoken+0xc0>
test   %rbx,%rbx
je     347 <debugtoken+0xed>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  0 <dbgtok>
mov    0x0(%rip),%rcx        # 333 <debugtoken+0xd9>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  347 <debugtoken+0xed>
mov    0x0(%rip),%edx        # 34d <debugtoken+0xf3>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 359 <debugtoken+0xff>
mov    $0x0,%eax
callq  363 <debugtoken+0x109>
mov    0x0(%rip),%ebx        # 369 <debugtoken+0x10f>
cmp    0x0(%rip),%ebx        # 36f <debugtoken+0x115>
jge    3ad <debugtoken+0x153>
mov    $0x0,%esi
mov    $0x2c,%ebp
jmp    38b <debugtoken+0x131>
cmp    %ebx,0x0(%rip)        # 383 <debugtoken+0x129>
mov    $0x0,%esi
cmovne %ebp,%esi
movslq %ebx,%rax
lea    (%rax,%rax,2),%rdx
mov    0x0(%rip),%rax        # 399 <debugtoken+0x13f>
lea    (%rax,%rdx,8),%rdi
callq  0 <dbgtok>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # 3ab <debugtoken+0x151>
jg     37d <debugtoken+0x123>
mov    0x0(%rip),%rcx        # 3b4 <debugtoken+0x15a>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3c8 <debugtoken+0x16e>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
debugtoken(TOKSTK *t, char *fmt, ...)
{
     if (debug > 1) {
   va_list ap;
   int i;
   if (fmt) {
        __builtin_va_start(ap,fmt);
        vfprintf(stderr, fmt, ap);
        __builtin_va_end(ap);
        fprintf(stderr, ": ");
   }
   if (t) {
        dbgtok(t, 0);
        fprintf(stderr, "; ");
   }
   fprintf(stderr, "%d: {", curs);
   for (i = curs; i < tos; i++)
        dbgtok(token_stack + i, i == curs ? 0 : ',');
   fprintf(stderr, "}\n");
     }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 3
20 3
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 10
33 10
34 10
35 10
36 10
37 12
38 12
39 13
40 13
41 13
42 14
43 14
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
52 17
53 17
54 17
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 18
63 18
64 18
65 18
66 17
67 17
68 17
69 19
70 19
71 19
72 19
73 19
74 21
75 21
76 21
77 21
<<<sep_out_sample>>>
mov    0xa8(%rdi),%eax
shl    $0xe,%eax
sar    $0x17,%eax
retq   
<<<sep_in_sample>>>
term_ostream__get_bgcolor (term_ostream_t stream)
{
  return stream->curr_attr.bgcolor;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x1,%edi
callq  962 <init_profiling_signals+0x13>
mov    $0x0,%esi
mov    $0xa,%edi
callq  971 <init_profiling_signals+0x22>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
init_profiling_signals()
{
 signal(1, dump_and_exit);
 signal(10, just_dump);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r9d
callq  b1 <rfc822_read0>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rfc822_readline (mu_filter_t filter, char *buffer, size_t buflen,
   mu_off_t off, size_t *pnread)
{
  return rfc822_read0 (filter, buffer, buflen, off, pnread, 1);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
append_void(void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     148 <swi_control_script_delete+0x12>
callq  148 <swi_control_script_delete+0x12>
mov    0x50(%rbx),%rdi
test   %rdi,%rdi
je     156 <swi_control_script_delete+0x20>
callq  156 <swi_control_script_delete+0x20>
mov    %rbx,%rdi
callq  15e <swi_control_script_delete+0x28>
pop    %rbx
nop
retq   
<<<sep_in_sample>>>
swi_control_script_delete(SWI_CONTROL_SCRIPT * s)
{
 if (s->baseM.b_tagM) free(s->baseM.b_tagM);
 if (s->afileM)
  swi_file_member_delete(s->afileM);
 free(s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 6
12 6
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %edx,%ebp
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%r12
movslq %edx,%rdx
mov    %rbx,%rdi
callq  3fd <strmaxcpy+0x2c>
cmp    %r12d,%ebp
cmovge %r12d,%ebp
movslq %ebp,%rbp
movb   $0x0,(%rbx,%rbp,1)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
strmaxcpy(char *to, char *from, int n)
{
 int len = strlen(from);
 strncpy(to, from, n);
 to[(len <= n) ? len : n] = '\0';
 return to;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 7
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x2030,%rsp
mov    %edi,%ebx
mov    %fs:0x28,%rax
mov    %rax,0x2028(%rsp)
xor    %eax,%eax
movl   $0x10,0xc(%rsp)
lea    0xc(%rsp),%r9
lea    0x10(%rsp),%r8
mov    $0x0,%ecx
mov    $0x2000,%edx
lea    0x20(%rsp),%rsi
callq  401 <echo_dg+0x43>
test   %eax,%eax
js     424 <echo_dg+0x66>
movslq %eax,%rdx
mov    $0x10,%r9d
lea    0x10(%rsp),%r8
mov    $0x0,%ecx
lea    0x20(%rsp),%rsi
mov    %ebx,%edi
callq  424 <echo_dg+0x66>
mov    0x2028(%rsp),%rax
xor    %fs:0x28,%rax
je     43c <echo_dg+0x7e>
callq  43c <echo_dg+0x7e>
add    $0x2030,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
echo_dg (int fd, struct component const *comp)
{
  int rc;
  char buffer[8192];
  struct sockaddr sa;
  socklen_t size = sizeof sa;
  rc = recvfrom (fd, buffer, sizeof buffer, 0, &sa, &size);
  if (rc < 0)
    return;
  sendto (fd, buffer, rc, 0, &sa, sizeof sa);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 7
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
test   %rdx,%rdx
je     419 <compute_char_variance+0x4f>
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 3dc <compute_char_variance+0x12>
movsbl (%rdi),%ecx
cvtsi2sd %ecx,%xmm1
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fmul   %st(0),%st
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    409 <compute_char_variance+0x3f>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    3dc <compute_char_variance+0x12>
fstp   %st(0)
jmp    41b <compute_char_variance+0x51>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
compute_char_variance (const char data[], const size_t stride, const size_t n, const double mean)
{
  long double variance = 0 ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double delta = (data[i * stride] - mean);
      variance += (delta * delta - variance) / (i + 1);
    }
  return variance ;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 3
5 8
6 7
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 5
23 5
24 5
25 5
26 3
27 10
28 10
29 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 187 <pe_file_name+0x7>
test   %r8,%r8
je     1c0 <pe_file_name+0x40>
sub    $0x8,%rsp
mov    %r8,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    0x0(%rip),%rcx        # 1af <pe_file_name+0x2f>
mov    $0x1,%edx
mov    %r8,%rdi
callq  1bc <pe_file_name+0x3c>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
pe_file_name (struct prompt_exp *p)
{
  if (file_name)
    fwrite (file_name, strlen (file_name), 1, stdout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x0,%esi
callq  11 <rpl_futimens+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_futimens (int fd, struct timespec const times[2])
{
  return fdutimens (fd, ((void *)0), times);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebx
movzbl %dil,%ebp
cmp    %edi,%ebp
jne    27 <rl_alphabetic+0x27>
callq  15 <rl_alphabetic+0x15>
movzbl %bpl,%ebp
mov    (%rax),%rdx
mov    $0x1,%eax
testb  $0x8,(%rdx,%rbp,2)
jne    4a <rl_alphabetic+0x4a>
mov    $0x0,%eax
cmpl   $0x0,0x0(%rip)        # 33 <rl_alphabetic+0x33>
je     4a <rl_alphabetic+0x4a>
mov    %ebx,%esi
mov    $0x0,%edi
callq  41 <rl_alphabetic+0x41>
test   %rax,%rax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rl_alphabetic (c)
     int c;
{
  if ((((unsigned char)(c) == (c)) && (1 && ((*__ctype_b_loc ())[(int) (((unsigned char)c))] & (unsigned short int) _ISalnum))))
    return (1);
  return (_rl_allow_pathname_alphabetic_chars &&
     strchr (pathname_alphabetic_chars, c) != ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 4
14 6
15 6
16 6
17 7
18 7
19 7
20 6
21 6
22 6
23 8
24 8
25 8
26 8
<<<sep_out_sample>>>
movzbl 0xaa(%rdi),%eax
shr    $0x3,%al
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
term_ostream__get_posture (term_ostream_t stream)
{
  return stream->curr_attr.posture;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  529 <parse_nouser+0x9>
movl   $0x3a83126f,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_nouser (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = insert_primary_noarg (entry);
  our_pred->est_success_rate = 1e-3;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 9
5 9
6 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%rcx
movzbl (%rcx),%eax
test   %r8,%r8
je     1796 <gsl_vector_char_min+0x2d>
mov    $0x0,%edx
movzbl (%rcx),%esi
cmp    %sil,%al
cmovg  %esi,%eax
add    $0x1,%rdx
add    %r9,%rcx
cmp    %r8,%rdx
jne    1781 <gsl_vector_char_min+0x18>
repz retq 
<<<sep_in_sample>>>
gsl_vector_char_min (const gsl_vector_char * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      char x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 7
6 7
7 7
8 9
9 9
10 9
11 7
12 7
13 7
14 7
15 14
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 7fa <terminal_scroll_terminal+0x7>
je     867 <terminal_scroll_terminal+0x74>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%r12d
mov    %esi,%ebp
mov    %edx,%ebx
test   %edx,%edx
je     85d <terminal_scroll_terminal+0x6a>
mov    0x0(%rip),%rcx        # 818 <terminal_scroll_terminal+0x25>
test   %rcx,%rcx
je     826 <terminal_scroll_terminal+0x33>
mov    $0x0,%eax
callq  *%rcx
jmp    85d <terminal_scroll_terminal+0x6a>
test   %edx,%edx
jle    841 <terminal_scroll_terminal+0x4e>
mov    %edx,%esi
mov    %ebp,%edi
xchg   %ax,%ax
callq  267 <terminal_delete_lines>
mov    %ebx,%esi
mov    %r12d,%edi
callq  2e9 <terminal_insert_lines>
jmp    85d <terminal_scroll_terminal+0x6a>
mov    %edx,%r13d
neg    %r13d
lea    (%rdx,%rdi,1),%edi
mov    %r13d,%esi
callq  267 <terminal_delete_lines>
lea    (%rbx,%rbp,1),%edi
mov    %r13d,%esi
callq  2e9 <terminal_insert_lines>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
terminal_scroll_terminal (int start, int end, int amount)
{
  if (!terminal_can_scroll)
    return;
  if (amount == 0)
    return;
  if (terminal_scroll_terminal_hook)
    (*terminal_scroll_terminal_hook) (start, end, amount);
  else if (amount > 0)
    {
      terminal_delete_lines (end, amount);
      terminal_insert_lines (start, amount);
    }
  else
    {
      int abs_amount = -amount;
      terminal_delete_lines (start - abs_amount, abs_amount);
      terminal_insert_lines (end - abs_amount, abs_amount);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 12
29 16
30 16
31 17
32 17
33 17
34 18
35 18
36 18
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5fd <il_delete_char+0x7>
mov    0x18(%rax),%rcx
mov    0x38(%rax),%rdx
cmp    %rdx,%rcx
jae    660 <il_delete_char+0x6a>
push   %rbx
mov    0x58(%rax),%rax
lea    (%rax,%rcx,1),%rdi
add    $0x1,%rdx
sub    %rcx,%rdx
lea    0x1(%rax,%rcx,1),%rsi
callq  624 <il_delete_char+0x2e>
mov    0x0(%rip),%rbx        # 62b <il_delete_char+0x35>
mov    0x38(%rbx),%rsi
lea    -0x1(%rsi),%rax
mov    %rax,0x38(%rbx)
subq   $0x1,0x48(%rbx)
test   $0xf,%al
jne    651 <il_delete_char+0x5b>
mov    %rsi,0x50(%rbx)
mov    0x58(%rbx),%rdi
callq  64d <il_delete_char+0x57>
mov    %rax,0x58(%rbx)
mov    0x0(%rip),%rax        # 658 <il_delete_char+0x62>
movl   $0x8,0x10(%rax)
pop    %rbx
repz retq 
<<<sep_in_sample>>>
il_delete_char()
{
    if (il->point < il->length)
    {
 memcpy(il->buffer + il->point,
        il->buffer + il->point + 1,
        il->length - il->point + 1);
 il->length--;
 il->dynamic_length--;
 if (il->length % 16 == 0)
     { il->size = il->length + 1; il->buffer = xrealloc(il->buffer, il->size); };
 il->last_operation = 8;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 6
8 5
9 7
10 5
11 6
12 5
13 8
14 8
15 8
16 8
17 9
18 10
19 10
20 11
21 11
22 11
23 11
24 12
25 12
26 14
27 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
cmp    %edx,%esi
jne    1904 <_x87_absr_d+0x4f>
test   %esi,%esi
jne    18d5 <_x87_absr_d+0x20>
mov    $0x1,%edx
mov    $0xc,%esi
callq  13ec <_x87ri>
jmp    1930 <_x87_absr_d+0x7b>
mov    %esi,%edx
mov    $0x9,%esi
callq  13ec <_x87ri>
mov    $0x1,%edx
mov    $0xc,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
mov    %ebp,%edx
mov    $0x9,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
jmp    1930 <_x87_absr_d+0x7b>
mov    $0x8,%esi
callq  13ec <_x87ri>
mov    $0x1,%edx
mov    $0xc,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
lea    0x1(%rbp),%edx
mov    $0x2b,%esi
mov    %rbx,%rdi
callq  13ec <_x87ri>
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_x87_absr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1)
{
    if (r0 == r1) {
 if (r1 == 0)
     _x87ri(_jit,014,1);
 else {
     _x87ri(_jit,011,r0);
     _x87ri(_jit,014,1);
     _x87ri(_jit,011,r0);
 }
    }
    else {
 _x87ri(_jit,010,r1);
 _x87ri(_jit,014,1);
 _x87ri(_jit,053,r0 + 1);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 13
26 13
27 14
28 14
29 14
30 14
31 15
32 15
33 15
34 15
35 17
36 17
37 17
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
<<<sep_in_sample>>>
output_is_to_void (struct output * out)
{
  return out->to_void;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    0x0(%rip),%edi        # 289 <jobserver_acquire_all+0xb>
callq  28e <jobserver_acquire_all+0x10>
movl   $0xffffffff,0x0(%rip)        # 298 <jobserver_acquire_all+0x1a>
mov    $0x0,%ebx
mov    $0x1,%edx
lea    0xf(%rsp),%rsi
mov    0x0(%rip),%edi        # 2ad <jobserver_acquire_all+0x2f>
callq  2b2 <jobserver_acquire_all+0x34>
cmp    $0xffffffff,%eax
jne    2c4 <jobserver_acquire_all+0x46>
callq  2bc <jobserver_acquire_all+0x3e>
cmpl   $0x4,(%rax)
nop
jne    2d2 <jobserver_acquire_all+0x54>
jmp    29d <jobserver_acquire_all+0x1f>
cmp    $0x1,%eax
jne    2d2 <jobserver_acquire_all+0x54>
add    $0x1,%ebx
nopl   0x0(%rax)
jmp    29d <jobserver_acquire_all+0x1f>
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
jobserver_acquire_all (void)
{
  unsigned int tokens = 0;
  close (job_fds[1]);
  job_fds[1] = -1;
  while (1)
    {
      char intake;
      int r;
      while (((r)=read (job_fds[0], &intake, 1))==-1 && (*__errno_location ())==4);
      if (r != 1)
        return tokens;
      ++tokens;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 3
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 11
19 11
20 13
21 13
22 14
23 15
24 15
25 15
26 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0x40800000,%esi
callq  b4b5 <_x87_blei_f+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  aeed <_x87_movi_f>
mov    0x0(%r12),%ecx
and    $0x7fff,%ecx
mov    %r14d,%r8d
mov    %r13,%rdx
mov    $0x3,%esi
mov    %rbx,%rdi
callq  1b28 <_x87jcc>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  b50c <_x87_blei_f+0x7b>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_x87_blei_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x3, i0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), r0); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
je     49 <mu_make_file_name+0x49>
lea    -0x1(%rcx),%rbx
cmpb   $0x2f,-0x1(%rbp,%rcx,1)
je     42 <mu_make_file_name+0x42>
jmp    4e <mu_make_file_name+0x4e>
lea    -0x1(%rbx),%rax
cmpb   $0x2f,-0x1(%rbp,%rbx,1)
jne    51 <mu_make_file_name+0x51>
mov    %rax,%rbx
test   %rbx,%rbx
jne    34 <mu_make_file_name+0x34>
jmp    51 <mu_make_file_name+0x51>
mov    %rcx,%rbx
jmp    51 <mu_make_file_name+0x51>
mov    %rcx,%rbx
mov    %r13,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rbx,%rdi
sub    %rcx,%rdi
callq  6d <mu_make_file_name+0x6d>
mov    %rax,%r12
test   %rax,%rax
je     95 <mu_make_file_name+0x95>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  83 <mu_make_file_name+0x83>
movb   $0x2f,(%r12,%rbx,1)
lea    0x1(%r12,%rbx,1),%rdi
mov    %r13,%rsi
callq  95 <mu_make_file_name+0x95>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_make_file_name (const char *dir, const char *file)
{
  char *tmp;
  size_t dirlen = strlen (dir);
  size_t len;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  len = dirlen + 1 + strlen (file);
  tmp = mu_alloc (len + 1);
  if (tmp)
    {
      memcpy (tmp, dir, dirlen);
      tmp[dirlen++] = '/';
      strcpy (tmp + dirlen, file);
    }
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 4
26 4
27 4
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 10
37 10
38 12
39 12
40 12
41 12
42 13
43 14
44 14
45 14
46 17
47 17
48 17
49 17
50 17
51 17
52 17
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # a <setquiet+0xa>
retq   
<<<sep_in_sample>>>
setquiet(void)
{
 quiet = 1;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rax        # 8 <osip_mutex_init+0x8>
test   %rax,%rax
je     19 <osip_mutex_init+0x19>
mov    $0x28,%edi
callq  *%rax
mov    %rax,%rbx
jmp    26 <osip_mutex_init+0x26>
mov    $0x28,%edi
callq  23 <osip_mutex_init+0x23>
mov    %rax,%rbx
test   %rbx,%rbx
je     38 <osip_mutex_init+0x38>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  38 <osip_mutex_init+0x38>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_mutex_init ()
{
  osip_mutex_t *mut = (osip_mutex_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_mutex_t)):malloc(sizeof (osip_mutex_t)));
  if (mut == ((void *)0))
    return ((void *)0);
  pthread_mutex_init (mut, ((void *)0));
  return (struct osip_mutex *) mut;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 6
15 6
16 6
17 8
18 8
19 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 655 <restore_sigint_handler+0x7>
cmp    $0x0,%rsi
je     685 <restore_sigint_handler+0x37>
sub    $0x8,%rsp
mov    $0x2,%edi
callq  66c <restore_sigint_handler+0x1e>
movq   $0x0,0x0(%rip)        # 677 <restore_sigint_handler+0x29>
movl   $0x0,0x0(%rip)        # 681 <restore_sigint_handler+0x33>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
restore_sigint_handler ()
{
  if (old_sigint_handler != (SigHandler *)wait_for_background_pids)
    {
      set_signal_handler (2, old_sigint_handler);
      old_sigint_handler = (SigHandler *)wait_for_background_pids;
      waiting_for_child = 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 6
8 7
9 9
10 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  3a1 <gsl_stats_long_skew+0x18>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  3ba <gsl_stats_long_skew+0x31>
movapd %xmm0,%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  3d7 <gsl_stats_long_skew+0x4e>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_long_skew (const long data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_long_mean(data, stride, n);
  const double sd = gsl_stats_long_sd_m(data, stride, n, mean);
  return gsl_stats_long_skew_m_sd(data, stride, n, mean, sd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdi
callq  cd4 <system_fh_rx_fifo_errors+0x15>
test   %rax,%rax
jne    ce8 <system_fh_rx_fifo_errors+0x29>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  ce6 <system_fh_rx_fifo_errors+0x27>
jmp    cfc <system_fh_rx_fifo_errors+0x3d>
mov    0x90(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  cfc <system_fh_rx_fifo_errors+0x3d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_rx_fifo_errors (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "rx_fifo_errors" " unknown)"); else put_ulong (form, argc, argv, stats->rx_fifo_errors); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
callq  b78 <quotearg_n_options>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *name)
{
  return quotearg_n_options (n, name, ((size_t) -1), &quote_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 208c <php_set_debug+0x6>
retq   
<<<sep_in_sample>>>
php_set_debug (int bdebug )
{
        php__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x5,%r8d
mov    (%rdx),%rdx
callq  16e4 <strategy_deny_length_ge_cb+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strategy_deny_length_ge_cb(enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr,
      grecs_value_t *value,
      void *cb_data)
{
    return strategy_deny_length(cmd, locus, *(dico_list_t*) varptr,
    value, cmp_ge);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 9
6 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x1,%edx
mov    $0x2,%esi
mov    $0x0,%edi
callq  c1 <ancestors_new+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ancestors_new (void)
{
  return da_new ("Ancestors", 2,
   da_linear, 2,
   (da_print_func_t) da_str_print, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rdx
callq  12b6 <quote_n+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_n (int n, char const *arg)
{
  return quote_n_mem (n, arg, ((size_t) -1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 8ec <gsl_vector_long_set+0x7>
je     912 <gsl_vector_long_set+0x2d>
cmp    %rsi,(%rdi)
ja     912 <gsl_vector_long_set+0x2d>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  910 <gsl_vector_long_set+0x2b>
jmp    927 <gsl_vector_long_set+0x42>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rax,%rsi
mov    0x10(%rdi),%rax
mov    %rdx,(%rax,%rsi,1)
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_long_set (gsl_vector_long * v, const size_t i, long x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     48c <mu_config_clone_container+0x2a>
mov    0x8(%rdi),%rdi
callq  474 <mu_config_clone_container+0x12>
cmpl   $0x0,(%rbx)
jne    48c <mu_config_clone_container+0x2a>
mov    0x38(%rbx),%rdi
mov    $0x0,%edx
mov    $0x0,%esi
callq  48c <mu_config_clone_container+0x2a>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_config_clone_container (struct mu_cfg_cont *cont)
{
  if (!cont)
    return 0;
  mu_refcount_inc (cont->refcount);
  switch (cont->type)
    {
    case mu_cfg_cont_section:
      mu_list_do (cont->v.section.children, _clone_action, ((void *)0));
      break;
    case mu_cfg_cont_param:
      break;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 9
10 9
11 9
12 9
13 15
14 15
15 15
<<<sep_out_sample>>>
mov    %edi,%eax
not    %eax
shr    $0x1f,%eax
retq   
<<<sep_in_sample>>>
is_normed_time (n_time t)
{
  return (t & (1UL << 31)) ? 0 : 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    %edx,%r8d
mov    %ecx,%r9d
cmp    %ecx,%edx
jne    d79 <_sse_ltgtr_f+0x1a>
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
repz retq 
mov    %esi,%ecx
mov    $0x5,%edx
mov    $0x0,%esi
callq  b49 <_ssecmp>
repz retq 
<<<sep_in_sample>>>
_sse_ltgtr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r1 == r2)
 _alur(_jit, 6 << 3, r0, r0);
    else
 _ssecmp(_jit, 0, 0x5, r0, r1, r2);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1919 <gsl_permute_vector_short_inverse+0x2c>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1912 <gsl_permute_vector_short_inverse+0x25>
mov    $0x13,%eax
jmp    192f <gsl_permute_vector_short_inverse+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  192a <gsl_permute_vector_short_inverse+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_short_inverse (const gsl_permutation * p, gsl_vector_short * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_short_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    $0x1005,%eax
test   %rdi,%rdi
je     c2 <mu_monitor_create+0x70>
mov    %esi,%r12d
mov    %rdx,%r13
mov    $0x18,%esi
mov    $0x1,%edi
callq  7c <mu_monitor_create+0x2a>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     c2 <mu_monitor_create+0x70>
test   %r12d,%r12d
jne    aa <mu_monitor_create+0x58>
mov    %rbx,%rdi
callq  0 <monitor_pthread_create>
mov    %eax,%r14d
test   %eax,%eax
je     aa <mu_monitor_create+0x58>
mov    %rbx,%rdi
callq  a5 <mu_monitor_create+0x53>
mov    %r14d,%eax
jmp    c2 <mu_monitor_create+0x70>
mov    %r13,0x8(%rbx)
movl   $0x1,0x10(%rbx)
mov    %r12d,0x14(%rbx)
mov    %rbx,0x0(%rbp)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
mu_monitor_create (mu_monitor_t *pmonitor, int flags, void *owner)
{
  mu_monitor_t monitor;
  if (pmonitor == ((void *)0))
    return (0x1000 +5);
  monitor = calloc (1, sizeof (*monitor));
  if (monitor == ((void *)0))
    return 12;
  if (flags == 0)
    {
      int status = monitor_pthread_create ((p_lock_t *)&(monitor->data));
      if (status != 0)
 {
   free (monitor);
   return status;
 }
    }
  monitor->owner = owner;
  monitor->allocated = 1;
  monitor->flags = flags;
  *pmonitor = monitor;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 8
17 7
18 7
19 9
20 9
21 11
22 11
23 11
24 12
25 12
26 14
27 14
28 15
29 15
30 18
31 19
32 20
33 21
34 22
35 23
36 23
37 23
38 23
39 23
40 23
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6d <_gsasl_step64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_client_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 3d8 <get_history_file_name+0x8>
jne    46d <get_history_file_name+0x9d>
push   %r12
push   %rbp
push   %rbx
mov    $0xffffffffffffffff,%r12
mov    0x0(%rip),%rdi        # 3f0 <get_history_file_name+0x20>
mov    $0x0,%ebp
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    0x9(%rcx),%rdi
callq  408 <get_history_file_name+0x38>
mov    %rax,%rbx
movw   $0x2e,(%rax)
mov    0x0(%rip),%rsi        # 417 <get_history_file_name+0x47>
mov    %rax,%rdi
callq  41f <get_history_file_name+0x4f>
mov    %rbx,%rdi
mov    %r12,%rcx
mov    %ebp,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rax
movabs $0x79726f747369685f,%rdx
mov    %rdx,(%rax)
movb   $0x0,0x8(%rax)
callq  447 <get_history_file_name+0x77>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  452 <get_history_file_name+0x82>
mov    %rax,0x0(%rip)        # 459 <get_history_file_name+0x89>
mov    %rbx,%rdi
callq  461 <get_history_file_name+0x91>
mov    0x0(%rip),%rax        # 468 <get_history_file_name+0x98>
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    0x0(%rip),%rax        # 474 <get_history_file_name+0xa4>
retq   
<<<sep_in_sample>>>
get_history_file_name()
{
  static char *filename = ((void *)0);
  if (!filename) {
 char *hname;
 hname = xmalloc(1 +
   strlen (rl_readline_name) + sizeof "_history");
 strcpy(hname, ".");
 strcat(hname, rl_readline_name);
 strcat(hname, "_history");
 filename = dico_full_file_name(get_homedir(), hname);
 free(hname);
  }
  return filename;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 6
14 6
15 6
16 8
17 9
18 9
19 9
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 15
37 15
38 15
39 15
40 15
41 15
42 15
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %r9,0x18(%rsp)
movl   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
mov    %r8d,(%rsp)
mov    %ecx,%r9d
mov    $0x0,%r8d
mov    $0x0,%ecx
callq  180d <iso9660_dir_init_new+0x31>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
iso9660_dir_init_new (void *dir,
                      uint32_t self,
                      uint32_t ssize,
                      uint32_t parent,
                      uint32_t psize,
                      const time_t *dir_time)
{
  iso9660_dir_init_new_su (dir, self, ssize, ((void *)0), 0, parent, psize, ((void *)0),
                           0, dir_time);
}
<<<sep_in_sample>>>
1 7
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 10
11 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x30,%rsp
mov    %rdi,%r12
mov    %rsi,%rbp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
jne    735 <gsl_permute_matrix_complex_float+0x29>
mov    $0x0,%ebx
mov    $0x0,%eax
cmpq   $0x0,(%rsi)
je     77d <gsl_permute_matrix_complex_float+0x71>
jmp    755 <gsl_permute_matrix_complex_float+0x49>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  74e <gsl_permute_matrix_complex_float+0x42>
mov    $0x13,%eax
jmp    77d <gsl_permute_matrix_complex_float+0x71>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  763 <gsl_permute_matrix_complex_float+0x57>
mov    %rsp,%rsi
mov    %r12,%rdi
callq  76e <gsl_permute_matrix_complex_float+0x62>
add    $0x1,%rbx
cmp    %rbx,0x0(%rbp)
ja     755 <gsl_permute_matrix_complex_float+0x49>
mov    $0x0,%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_permute_matrix_complex_float (const gsl_permutation * p, gsl_matrix_complex_float * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_complex_float_view r = gsl_matrix_complex_float_row (A, i);
          gsl_permute_vector_complex_float (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 10
11 15
12 10
13 10
14 10
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 13
27 13
28 13
29 10
30 10
31 10
32 15
33 17
34 17
35 17
36 17
37 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
movapd %xmm1,%xmm7
movsd  %xmm1,0x8(%rsp)
mov    %rdi,%rbx
movapd %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 812 <gsl_sf_bessel_Inu_scaled_asympx_e+0x1e>
movapd %xmm1,%xmm6
mulsd  %xmm0,%xmm6
movsd  %xmm6,0x10(%rsp)
subsd  0x0(%rip),%xmm6        # 828 <gsl_sf_bessel_Inu_scaled_asympx_e+0x34>
movsd  %xmm6,0x18(%rsp)
movapd %xmm7,%xmm0
mulsd  0x0(%rip),%xmm0        # 83a <gsl_sf_bessel_Inu_scaled_asympx_e+0x46>
sqrtsd %xmm0,%xmm0
ucomisd %xmm0,%xmm0
jnp    855 <gsl_sf_bessel_Inu_scaled_asympx_e+0x61>
movapd %xmm7,%xmm0
mulsd  0x0(%rip),%xmm0        # 850 <gsl_sf_bessel_Inu_scaled_asympx_e+0x5c>
callq  855 <gsl_sf_bessel_Inu_scaled_asympx_e+0x61>
movsd  0x0(%rip),%xmm3        # 85d <gsl_sf_bessel_Inu_scaled_asympx_e+0x69>
movapd %xmm3,%xmm1
divsd  %xmm0,%xmm1
movsd  0x10(%rsp),%xmm7
movapd %xmm7,%xmm0
movsd  0x8(%rsp),%xmm5
divsd  %xmm5,%xmm0
movapd %xmm5,%xmm2
mulsd  0x0(%rip),%xmm2        # 885 <gsl_sf_bessel_Inu_scaled_asympx_e+0x91>
movsd  0x18(%rsp),%xmm4
movapd %xmm4,%xmm6
divsd  %xmm2,%xmm6
subsd  %xmm6,%xmm3
movapd %xmm7,%xmm2
subsd  0x0(%rip),%xmm2        # 8a3 <gsl_sf_bessel_Inu_scaled_asympx_e+0xaf>
mulsd  %xmm4,%xmm2
movapd %xmm5,%xmm4
mulsd  0x0(%rip),%xmm4        # 8b3 <gsl_sf_bessel_Inu_scaled_asympx_e+0xbf>
mulsd  %xmm5,%xmm4
divsd  %xmm4,%xmm2
addsd  %xmm2,%xmm3
mulsd  %xmm1,%xmm3
movsd  %xmm3,(%rbx)
movsd  0x0(%rip),%xmm2        # 8cf <gsl_sf_bessel_Inu_scaled_asympx_e+0xdb>
andpd  %xmm2,%xmm3
mulsd  0x0(%rip),%xmm3        # 8db <gsl_sf_bessel_Inu_scaled_asympx_e+0xe7>
movapd %xmm0,%xmm4
mulsd  0x0(%rip),%xmm4        # 8e7 <gsl_sf_bessel_Inu_scaled_asympx_e+0xf3>
mulsd  %xmm0,%xmm4
mulsd  %xmm4,%xmm0
andpd  %xmm0,%xmm2
mulsd  %xmm2,%xmm1
addsd  %xmm3,%xmm1
movsd  %xmm1,0x8(%rbx)
mov    $0x0,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Inu_scaled_asympx_e(const double nu, const double x, gsl_sf_result * result)
{
  double mu = 4.0*nu*nu;
  double mum1 = mu-1.0;
  double mum9 = mu-9.0;
  double pre = 1.0/sqrt(2.0*3.14159265358979323846*x);
  double r = mu/x;
  result->val = pre * (1.0 - mum1/(8.0*x) + mum1*mum9/(128.0*x*x));
  result->err = 2.0 * 2.2204460492503131e-16 * fabs(result->val) + pre * fabs(0.1*r*r*r);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 8
29 8
30 8
31 8
32 8
33 8
34 5
35 5
36 8
37 8
38 8
39 8
40 8
41 8
42 8
43 8
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 11
56 11
57 11
58 11
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1,%eax
cmove  %rax,%rsi
and    $0xffffffff,%esi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     1bf <dico_log+0x51>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r8
mov    %rdx,%rcx
mov    %esi,%edx
mov    $0x0,%esi
callq  *0x0(%rip)        # 1fb <dico_log+0x8d>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
dico_log(int lvl, int errcode, const char *fmt, ...)
{
    va_list ap;
    __builtin_va_start(ap,fmt);
    _log_printer(lvl, 0, errcode, fmt, ap);
    __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 5
24 5
25 5
26 7
27 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edx
callq  79a <s_char+0xe>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
s_char (struct xdatum *xd, char *str)
{
  xd_store (xd, str, 1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
callq  24e <new_code>
mov    %rax,%rbx
cmpl   $0x0,0x0(%rip)        # 2956 <call_by_name+0x18>
je     298b <call_by_name+0x4d>
mov    %rbp,%rdi
callq  0 <dsa_level>
mov    0x18(%rbp),%rdx
mov    (%rdx),%r8d
mov    0x0(%rbp),%rcx
mov    %r8d,0x8(%rsp)
mov    %rcx,(%rsp)
mov    %eax,%r9d
mov    %eax,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  2142 <append>
mov    %rbx,%rax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
call_by_name(IDENT *id)
{ CODE *code = new_code();
      if (second_pass)
      { append(code,
            "(" "global_dsa" " = dsa_%d->%s_%d.arg2, (*(struct desc (*)"
            "(void))dsa_%d->%s_%d.arg1)())",
             dsa_level(id), id->name, id->block->seqn,
             dsa_level(id), id->name, id->block->seqn);
      }
      return code;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 11
23 11
24 11
25 11
26 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  322d <swlib_add_trailing_slash+0x9>
mov    %rax,%rdx
cmpb   $0x0,(%rax)
jne    3244 <swlib_add_trailing_slash+0x20>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  3242 <swlib_add_trailing_slash+0x1e>
jmp    326c <swlib_add_trailing_slash+0x48>
mov    %rax,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
cmpb   $0x2f,-0x2(%rdx,%rcx,1)
je     326c <swlib_add_trailing_slash+0x48>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  326c <swlib_add_trailing_slash+0x48>
pop    %rbx
retq   
<<<sep_in_sample>>>
swlib_add_trailing_slash(STROB *path)
{
 char *p = strob_str(path);
 if (!strlen(p)) {
  strob_strcat(path,"/");
  return;
 }
 if( *(p + strlen(p) -1) != '/')
  strob_strcat(path,"/");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 9
21 10
22 10
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 842 <maybe_emit_oob_warning+0x7>
jne    873 <maybe_emit_oob_warning+0x38>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 84f <maybe_emit_oob_warning+0x14>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 85b <maybe_emit_oob_warning+0x20>
mov    $0x0,%eax
callq  865 <maybe_emit_oob_warning+0x2a>
movl   $0x1,0x0(%rip)        # 86f <maybe_emit_oob_warning+0x34>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
maybe_emit_oob_warning (void)
{
  static bool warning_written = false;
  if (!warning_written)
    {
      fprintf (stderr, "%s: one or more out-of-bounds output values are approximated\n", progname);
      warning_written = true;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 6
7 6
8 6
9 7
10 9
11 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
mov    %edx,%r9d
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rdx
mov    0x18(%rsi),%rsi
mov    %rcx,(%rsp)
mov    (%rax),%rcx
callq  812 <gsl_wavelet2d_nstransform_matrix+0x22>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_wavelet2d_nstransform_matrix (const gsl_wavelet * w,
                                gsl_matrix * a,
                                gsl_wavelet_direction dir,
                                gsl_wavelet_workspace * work)
{
  return gsl_wavelet2d_nstransform (w, a->data,
                                    a->tda, a->size1, a->size2,
                                    dir, work);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 9
11 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %ecx,%ebx
mov    %r8,%r13
mov    %r9d,%r14d
cmpl   $0x0,0x0(%rip)        # 144 <de_be_hdy+0x23>
jne    160 <de_be_hdy+0x3f>
movq   $0x0,0x0(%rip)        # 151 <de_be_hdy+0x30>
mov    0x80(%rsp),%eax
mov    %eax,(%rsp)
callq  160 <de_be_hdy+0x3f>
mov    %ebx,%edx
mov    $0xb,%esi
mov    $0x1,%edi
callq  171 <de_be_hdy+0x50>
cmp    $0x2,%eax
jg     183 <de_be_hdy+0x62>
mov    $0x12,%edx
sub    %eax,%edx
mov    %edx,0x34(%rsp)
jmp    18e <de_be_hdy+0x6d>
mov    $0x19,%edx
sub    %eax,%edx
mov    %edx,0x34(%rsp)
cmp    $0x7cb,%ebx
mov    $0x0,%eax
mov    $0x0,%r15d
cmovge %rax,%r15
mov    0x0(%rip),%rax        # 1aa <de_be_hdy+0x89>
mov    %rax,0x38(%rsp)
mov    0x0(%rip),%rdi        # 1b6 <de_be_hdy+0x95>
callq  1bb <de_be_hdy+0x9a>
mov    0x80(%rsp),%esi
mov    %esi,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
movl   $0xb,(%rsp)
mov    0x34(%rsp),%r9d
mov    %r15,%r8
mov    0x38(%rsp),%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    0x0(%rbp),%edi
callq  1f6 <de_be_hdy+0xd5>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
de_be_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  if (!use_other_cc)
    {
      ptr_cc_id = "DE_BE";
      de_hdy (init_data, detected, easter, year, hd_elems, fday, count);
    }
  day = weekday_of_date (1, 11, year);
  day = (day < 3) ? 18 - day : 25 - day;
  holiday (*init_data, detected,
    gettext(hd_text[85].ht_text), ptr_cc_id,
    (year > 1994) ? "-" : "+", day, 11, year, hd_elems, fday,
    count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 11
15 13
16 14
17 14
18 14
19 16
20 16
21 16
22 16
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 18
33 18
34 18
35 18
36 18
37 18
38 19
39 19
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 22
54 22
55 22
56 22
57 22
58 22
59 22
60 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x2,%edi
callq  394 <rl_begin_undo_group+0x1d>
addl   $0x1,0x0(%rip)        # 39b <rl_begin_undo_group+0x24>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rl_begin_undo_group ()
{
  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
  _rl_undo_group_level++;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lstatat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lstatat (int fd, char const *name, struct stat *st)
{
  return fstatat (fd, name, st, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1619 <coproc_flush+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
coproc_flush ()
{
  coproc_dispose (&sh_coproc);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x8(%rsi),%r8d
mov    0x40(%rsi),%r9d
mov    0x48(%rsi),%esi
mov    0x8(%rdi),%rdx
test   %rdx,%rdx
je     41 <def_count_defered_links_to_dev_ino+0x41>
mov    $0x0,%eax
mov    (%rdx),%rcx
cmp    0x8(%rcx),%r8d
jne    36 <def_count_defered_links_to_dev_ino+0x36>
cmp    0x40(%rcx),%r9d
jne    36 <def_count_defered_links_to_dev_ino+0x36>
mov    0x48(%rcx),%rcx
cmp    %ecx,%esi
sete   %cl
movzbl %cl,%ecx
add    %ecx,%eax
mov    0x8(%rdx),%rdx
test   %rdx,%rdx
jne    19 <def_count_defered_links_to_dev_ino+0x19>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
def_count_defered_links_to_dev_ino(DEFER * def, struct new_cpio_header *file_hdr)
{
        struct deferment *d;
        int ino;
        int maj;
        int min;
        int count;
        ino = file_hdr->c_ino;
        maj = file_hdr->c_dev_maj;
        min = file_hdr->c_dev_min;
        count = 0;
        for (d = def->deferoutsM; d != ((void *)0); d = d->nextP) {
                if (((int)(d->headerP->c_ino) == ino) && ((int)(d->headerP->c_dev_maj) == maj)
                    && ((int)(d->headerP->c_dev_min) == min))
                        ++count;
        }
        return count;
}
<<<sep_in_sample>>>
1 8
2 9
3 10
4 12
5 12
6 12
7 11
8 13
9 13
10 13
11 13
12 13
13 14
14 15
15 15
16 15
17 15
18 12
19 12
20 12
21 12
22 11
23 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rax        # 6329 <dispose_temporary_env+0xb>
test   %rax,%rax
je     6336 <dispose_temporary_env+0x18>
mov    0xc(%rax),%edi
add    $0x1,%edi
jmp    633b <dispose_temporary_env+0x1d>
mov    $0x1,%edi
callq  6340 <dispose_temporary_env+0x22>
mov    %rax,0x0(%rip)        # 6347 <dispose_temporary_env+0x29>
movl   $0x0,0x0(%rip)        # 6351 <dispose_temporary_env+0x33>
movq   $0x0,(%rax)
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 6362 <dispose_temporary_env+0x44>
callq  6367 <dispose_temporary_env+0x49>
mov    0x0(%rip),%rdi        # 636e <dispose_temporary_env+0x50>
callq  6373 <dispose_temporary_env+0x55>
movq   $0x0,0x0(%rip)        # 637e <dispose_temporary_env+0x60>
movslq 0x0(%rip),%rdx        # 6385 <dispose_temporary_env+0x67>
mov    0x0(%rip),%rax        # 638c <dispose_temporary_env+0x6e>
movq   $0x0,(%rax,%rdx,8)
movl   $0x1,0x0(%rip)        # 639e <dispose_temporary_env+0x80>
cmpl   $0x0,0x0(%rip)        # 63a5 <dispose_temporary_env+0x87>
jle    63ca <dispose_temporary_env+0xac>
mov    $0x0,%ebx
movslq %ebx,%rdx
mov    0x0(%rip),%rax        # 63b6 <dispose_temporary_env+0x98>
mov    (%rax,%rdx,8),%rdi
callq  63bf <dispose_temporary_env+0xa1>
add    $0x1,%ebx
cmp    %ebx,0x0(%rip)        # 63c8 <dispose_temporary_env+0xaa>
jg     63ac <dispose_temporary_env+0x8e>
mov    0x0(%rip),%rdi        # 63d1 <dispose_temporary_env+0xb3>
callq  63d6 <dispose_temporary_env+0xb8>
movq   $0x0,0x0(%rip)        # 63e1 <dispose_temporary_env+0xc3>
movl   $0x0,0x0(%rip)        # 63eb <dispose_temporary_env+0xcd>
pop    %rbx
retq   
<<<sep_in_sample>>>
dispose_temporary_env (pushf)
     sh_free_func_t *pushf;
{
  int i;
  tempvar_list = strvec_create (((temporary_env) ? (temporary_env)->nentries : 0) + 1);
  tempvar_list[tvlist_ind = 0] = 0;
  hash_flush (temporary_env, pushf);
  hash_dispose (temporary_env);
  temporary_env = (HASH_TABLE *)((void *)0);
  tempvar_list[tvlist_ind] = 0;
  array_needs_making = 1;
  for (i = 0; i < tvlist_ind; i++)
    stupidly_hack_special_variables (tempvar_list[i]);
  strvec_dispose (tempvar_list);
  tempvar_list = 0;
  tvlist_ind = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 9
20 10
21 10
22 10
23 11
24 12
25 12
26 12
27 13
28 13
29 13
30 13
31 12
32 12
33 12
34 14
35 14
36 15
37 16
38 17
39 17
<<<sep_out_sample>>>
mov    $0x604,%eax
retq   
<<<sep_in_sample>>>
nied2_state_size(unsigned int dimension)
{
  return sizeof(nied2_state_t);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
movzbl (%rdi),%ebp
test   %bpl,%bpl
je     3d1 <Barcode_128c_verify+0x45>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
test   $0x1,%cl
jne    3d8 <Barcode_128c_verify+0x4c>
callq  3b5 <Barcode_128c_verify+0x29>
mov    (%rax),%rax
movsbq %bpl,%rbp
testb  $0x8,0x1(%rax,%rbp,2)
je     3df <Barcode_128c_verify+0x53>
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
jne    3b8 <Barcode_128c_verify+0x2c>
jmp    3e6 <Barcode_128c_verify+0x5a>
mov    $0xffffffff,%eax
jmp    3eb <Barcode_128c_verify+0x5f>
mov    $0xffffffff,%eax
jmp    3eb <Barcode_128c_verify+0x5f>
mov    $0xffffffff,%eax
jmp    3eb <Barcode_128c_verify+0x5f>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
Barcode_128c_verify(char *text)
{
    if (text[0] == '\0')
 return -1;
    if (strlen(text)%2)
 return -1;
    for (; *text; text++)
 if (!((*__ctype_b_loc ())[(int) ((*text))] & (unsigned short int) _ISdigit))
     return -1;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 8
14 8
15 8
16 8
17 8
18 7
19 7
20 7
21 7
22 7
23 4
24 4
25 6
26 6
27 9
28 9
29 10
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  272 <gsl_vector_float_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_float_fwrite (FILE * stream, const gsl_vector_float * v)
{
  int status = gsl_block_float_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbp
mov    %esi,%r12d
mov    %rdx,%r13
mov    $0x1,%ebx
cmpl   $0x0,0x0(%rip)        # e96 <fh_ifdisplay_query+0x21>
jne    ef6 <fh_ifdisplay_query+0x81>
cmpl   $0x0,0x0(%rip)        # e9f <fh_ifdisplay_query+0x2a>
setne  %bl
movzbl %bl,%ebx
jne    ef6 <fh_ifdisplay_query+0x81>
movl   $0x0,0xc(%rsp)
lea    0xc(%rsp),%rsi
mov    $0x0,%edi
callq  ebe <fh_ifdisplay_query+0x49>
mov    %eax,%r14d
test   %eax,%eax
je     ef6 <fh_ifdisplay_query+0x81>
mov    0x8(%rbp),%rdx
mov    0x10(%rbp),%edi
mov    $0x8913,%esi
mov    $0x0,%eax
callq  edb <fh_ifdisplay_query+0x66>
test   %eax,%eax
sete   %bl
movzbl %bl,%ebx
jne    ef6 <fh_ifdisplay_query+0x81>
mov    0x8(%rbp),%rax
movzwl 0x10(%rax),%eax
test   %eax,%r14d
setne  %bl
movzbl %bl,%ebx
xor    $0x1,%ebx
mov    %ebx,%ecx
mov    %r13,%rdx
mov    %r12d,%esi
mov    %rbp,%rdi
callq  f09 <fh_ifdisplay_query+0x94>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
fh_ifdisplay_query (format_data_t form, int argc, char *argv[])
{
  int n;
  n = all_option || ifs_cmdline;
  if (!n)
    {
      int rev = 0;
      int f = if_nameztoflag ("UP", &rev);
      n = f && rpl_ioctl (form->sfd, 0x8913, form->ifr) == 0;
      if (n) {
 unsigned int uflags = (unsigned short) form->ifr->ifr_ifru.ifru_flags;
 n = n && (f & uflags);
      };
    }
  select_arg (form, argc, argv, !n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 7
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 11
34 11
35 12
36 12
37 12
38 15
39 15
40 15
41 15
42 15
43 15
44 16
45 16
46 16
47 16
48 16
49 16
50 16
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %esi,%ebp
movslq %esi,%r12
lea    0x10(%r12),%rdi
callq  a93 <string_add+0x1c>
mov    %rax,%rbx
lea    0xc(%rax),%rdi
mov    %r12,%rdx
mov    %r13,%rsi
callq  aa5 <string_add+0x2e>
mov    %ebp,0x8(%rbx)
mov    %rbx,%rdi
callq  ab0 <string_add+0x39>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
string_add (const char *s, int l)
{
  struct strseg *seg = emalloc (sizeof (*seg) + l);
  memcpy (seg->ptr, s, l);
  seg->len = l;
  strseg_attach (seg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 5
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %edx,%ebx
movsd  %xmm0,0x8(%rsp)
movapd %xmm0,%xmm1
mulsd  0x0(%rip),%xmm1        # 14f <display+0x19>
movsd  0x0(%rip),%xmm0        # 157 <display+0x21>
divsd  %xmm1,%xmm0
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x1,%eax
callq  170 <display+0x3a>
movsd  0x0(%rip),%xmm0        # 178 <display+0x42>
ucomisd 0x0(%rip),%xmm0        # 180 <display+0x4a>
jbe    1d3 <display+0x9d>
mulsd  0x8(%rsp),%xmm0
divsd  0x0(%rip),%xmm0        # 190 <display+0x5a>
mov    $0x0,%edi
mov    $0x1,%eax
callq  19f <display+0x69>
test   %ebx,%ebx
je     1d3 <display+0x9d>
movsd  0x8(%rsp),%xmm1
mulsd  0x0(%rip),%xmm1        # 1b1 <display+0x7b>
mov    %ebx,%ebx
cvtsi2sd %rbx,%xmm0
mulsd  %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 1c4 <display+0x8e>
mov    $0x0,%edi
mov    $0x1,%eax
callq  1d3 <display+0x9d>
mov    $0xa,%edi
callq  1dd <display+0xa7>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
display(const char *name, const char *mode, unsigned block_size,
 double time)
{
  printf("%18s %11s %7.2f",
  name, mode,
  10240 / (time * 1048576.0));
  if (frequency > 0.0)
    {
      printf(" %11.2f", time * frequency / 10240);
      if (block_size > 0)
 printf(" %12.2f", time * frequency * block_size / 10240);
    }
  printf("\n");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 6
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 13
34 13
35 14
36 14
37 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %rsi,%rbp
mov    %rcx,%r12
movq   $0x0,(%rcx)
movzbl (%rsi),%eax
movsbl %al,%ecx
cmp    %edx,%ecx
je     542 <__osip_set_next_token+0xf9>
test   %al,%al
je     53a <__osip_set_next_token+0xf1>
cmp    $0xd,%al
je     509 <__osip_set_next_token+0xc0>
cmp    $0xa,%al
je     510 <__osip_set_next_token+0xc7>
mov    %rsi,%rbx
add    $0x1,%rbx
movzbl (%rbx),%eax
movsbl %al,%r8d
cmp    %edx,%r8d
je     4aa <__osip_set_next_token+0x61>
test   %al,%al
je     4aa <__osip_set_next_token+0x61>
cmp    $0xd,%al
je     517 <__osip_set_next_token+0xce>
cmp    $0xa,%al
jne    48c <__osip_set_next_token+0x43>
jmp    51e <__osip_set_next_token+0xd5>
test   %al,%al
nopl   0x0(%rax)
je     525 <__osip_set_next_token+0xdc>
cmp    %rbp,%rbx
je     52c <__osip_set_next_token+0xe3>
mov    0x0(%rip),%rax        # 4be <__osip_set_next_token+0x75>
test   %rax,%rax
je     4d1 <__osip_set_next_token+0x88>
mov    %rbx,%rdi
sub    %rbp,%rdi
add    $0x1,%rdi
callq  *%rax
jmp    4e0 <__osip_set_next_token+0x97>
mov    %rbx,%rdi
sub    %rbp,%rdi
add    $0x1,%rdi
callq  4e0 <__osip_set_next_token+0x97>
mov    %rax,0x0(%r13)
test   %rax,%rax
je     533 <__osip_set_next_token+0xea>
mov    %rbx,%rdx
sub    %rbp,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  4fa <__osip_set_next_token+0xb1>
add    $0x1,%rbx
mov    %rbx,(%r12)
mov    $0x0,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xffffffff,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    $0xfffffffc,%eax
jmp    54a <__osip_set_next_token+0x101>
mov    %rsi,%rbx
jmpq   4aa <__osip_set_next_token+0x61>
mov    %rsi,%rbx
jmpq   4aa <__osip_set_next_token+0x61>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__osip_set_next_token (char **dest, char *buf, int end_separator, char **next)
{
  char *sep;
  *next = ((void *)0);
  sep = buf;
  while ((*sep != end_separator) && (*sep != '\0') && (*sep != '\r')
         && (*sep != '\n'))
    sep++;
  if ((*sep == '\r') || (*sep == '\n')) {
    if (*sep != end_separator)
      return -1;
  }
  if (*sep == '\0')
    return -1;
  if (sep == buf)
    return -1;
  *dest = (osip_malloc_func?osip_malloc_func(sep - (buf) + 1):malloc(sep - (buf) + 1));
  if (*dest == ((void *)0))
    return -4;
  osip_strncpy (*dest, buf, sep - buf);
  *next = sep + 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 5
21 8
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 7
31 7
32 7
33 13
34 13
35 13
36 15
37 15
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 17
46 17
47 17
48 17
49 17
50 17
51 18
52 18
53 20
54 20
55 20
56 20
57 20
58 21
59 21
60 22
61 22
62 11
63 11
64 11
65 11
66 11
67 11
68 11
69 11
70 14
71 14
72 16
73 16
74 19
75 19
76 5
77 5
78 5
79 5
80 23
81 23
82 23
83 23
84 23
85 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x20,%edi
callq  14 <nettle_camellia256_invert_key+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_camellia256_invert_key(struct camellia256_ctx *dst,
         const struct camellia256_ctx *src)
{
  _nettle_camellia_invert_key (32, dst->keys, src->keys);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %edx,%r13d
mov    %ecx,%r12d
mov    %esi,%ecx
mov    %esi,%edx
mov    $0x30,%esi
callq  321 <_alur>
mov    %r13d,%ecx
mov    %r12d,%edx
mov    $0x2e,%esi
mov    %rbx,%rdi
callq  966 <_sser>
mov    $0x0,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  850 <_jccs>
mov    (%rbx),%r12
mov    %ebp,%edx
mov    $0x4,%esi
mov    %rbx,%rdi
callq  2c2 <_cc>
mov    (%rbx),%rax
sub    %r12d,%eax
mov    %al,-0x1(%r12)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
_sse_eqr_f(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    jit_bool_t rc;
    jit_int32_t reg;
    jit_word_t jp_code;
    if ((rc = 1))
 reg = r0;
    else {
 reg = 0;
 _movr(_jit, r0, 0);
    }
    _alur(_jit, 6 << 3, reg, reg);
    _sser(_jit,0x2e,r2,r1);
    _jccs(_jit, 0xa, 0);
    jp_code = _jit->pc.w;
    _cc(_jit, 0x4, reg);
    *(jit_int8_t *)(jp_code - 1) = _jit->pc.w - jp_code;
    if (!rc)
 _xchgr(_jit, r0, reg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 12
10 12
11 12
12 12
13 13
14 13
15 13
16 13
17 13
18 14
19 14
20 14
21 14
22 15
23 16
24 16
25 16
26 16
27 17
28 17
29 17
30 20
31 20
32 20
33 20
34 20
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
<<<sep_in_sample>>>
get_stat_mtime_ns (struct stat const *st)
{
  return ((st)->st_mtim).tv_nsec;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
cmpb   $0x20,(%rsi)
jne    4c <varcat+0x18>
mov    $0x0,%edx
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rsi,%rax,1)
je     3e <varcat+0xa>
jmp    51 <varcat+0x1d>
mov    $0x0,%edx
cmpb   $0x0,(%rdi)
je     127 <varcat+0xf3>
mov    $0x0,%r9d
add    $0x1,%r9d
movslq %r9d,%rax
cmpb   $0x0,(%rdi,%rax,1)
jne    60 <varcat+0x2c>
jmpq   12d <varcat+0xf9>
add    $0x1,%eax
movslq %eax,%rcx
movzbl (%rsi,%rcx,1),%ecx
test   $0xdf,%cl
jne    8f <varcat+0x5b>
movslq %eax,%rcx
movzbl (%rsi,%rcx,1),%ecx
cmp    $0x20,%cl
je     9b <varcat+0x67>
jmp    aa <varcat+0x76>
cmp    $0x3e,%cl
jne    72 <varcat+0x3e>
jmpq   156 <varcat+0x122>
mov    %edx,%eax
add    $0x1,%eax
movslq %eax,%rcx
movzbl (%rsi,%rcx,1),%ecx
cmp    $0x20,%cl
je     9b <varcat+0x67>
cmp    $0x3e,%cl
je     c8 <varcat+0x94>
movslq %edx,%rax
movzbl (%rsi,%rax,1),%eax
mov    %r9d,%r8d
mov    %edx,%r10d
sub    %r9d,%r10d
mov    %r9d,%ecx
test   $0xdf,%al
je     105 <varcat+0xd1>
jmp    e2 <varcat+0xae>
lea    0x1(%rax),%edx
movslq %edx,%rax
cmpb   $0x20,(%rsi,%rax,1)
jne    af <varcat+0x7b>
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rsi,%rax,1)
je     d4 <varcat+0xa0>
jmp    af <varcat+0x7b>
lea    0x1(%r8),%ecx
lea    (%r10,%rcx,1),%r9d
mov    %r9d,%edx
movslq %r8d,%r8
mov    %al,(%rdi,%r8,1)
movslq %r9d,%r9
movzbl (%rsi,%r9,1),%eax
test   $0xdf,%al
je     105 <varcat+0xd1>
mov    %ecx,%r8d
jmp    e2 <varcat+0xae>
lea    0x1(%rcx),%r9d
movslq %ecx,%rcx
movb   $0x20,(%rdi,%rcx,1)
movslq %edx,%rax
cmpb   $0x20,(%rsi,%rax,1)
jne    12d <varcat+0xf9>
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rsi,%rax,1)
je     119 <varcat+0xe5>
jmp    12d <varcat+0xf9>
mov    $0x0,%r9d
movslq %edx,%rax
movzbl (%rsi,%rax,1),%eax
test   %al,%al
je     14b <varcat+0x117>
cmp    $0x20,%al
je     99 <varcat+0x65>
cmp    $0x3e,%al
je     154 <varcat+0x120>
mov    %edx,%eax
jmpq   72 <varcat+0x3e>
movslq %r9d,%r9
movb   $0x0,(%rdi,%r9,1)
retq   
mov    %edx,%eax
movslq %eax,%rcx
movzbl (%rsi,%rcx,1),%ecx
jmpq   aa <varcat+0x76>
<<<sep_in_sample>>>
varcat(char *to, char *from)
{
  int t, f, ff;
  for (f = 0; from[f] == ' '; f++)
    ;
  for (t = 0; to[t]; t++)
    ;
  while (from[f])
    {
      for (ff = f; from[ff] && from[ff] != ' ' && from[ff] != '>'; ff++)
 ;
      while (from[ff] == ' ')
 ff++;
      if (from[ff] == '>')
 {
   for (f = ff + 1; from[f] == ' '; f++)
     ;
 }
      while (from[f] && from[f] != ' ')
 to[t++] = from[f++];
      to[t++] = ' ';
      while (from[f] == ' ')
 f++;
    }
  to[t] = '\0';
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 12
26 12
27 12
28 10
29 10
30 10
31 10
32 13
33 12
34 12
35 12
36 12
37 14
38 14
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 16
49 16
50 16
51 16
52 16
53 16
54 16
55 16
56 16
57 20
58 20
59 20
60 20
61 20
62 19
63 19
64 19
65 19
66 20
67 20
68 21
69 21
70 21
71 22
72 22
73 22
74 23
75 22
76 22
77 22
78 22
79 6
80 8
81 8
82 8
83 8
84 10
85 10
86 10
87 10
88 10
89 10
90 25
91 25
92 25
93 10
94 12
95 12
96 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 11a9 <gsl_matrix_ushort_set+0xb>
je     11ec <gsl_matrix_ushort_set+0x4e>
cmp    %rsi,(%rdi)
ja     11cb <gsl_matrix_ushort_set+0x2d>
mov    $0x4,%ecx
mov    $0x129,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11c9 <gsl_matrix_ushort_set+0x2b>
jmp    11fc <gsl_matrix_ushort_set+0x5e>
cmp    %rdx,0x8(%rdi)
ja     11ec <gsl_matrix_ushort_set+0x4e>
mov    $0x4,%ecx
mov    $0x12d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11ea <gsl_matrix_ushort_set+0x4c>
jmp    11fc <gsl_matrix_ushort_set+0x5e>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
mov    0x18(%rdi),%rax
mov    %cx,(%rax,%rdx,2)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_ushort_set(gsl_matrix_ushort * m, const size_t i, const size_t j, const unsigned short x)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_ushort.h", 297, GSL_EINVAL) ; return ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_ushort.h", 301, GSL_EINVAL) ; return ; } while (0) ;
        }
    }
  m->data[i * m->tda + j] = x ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 11
20 14
21 14
22 14
23 14
24 15
25 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
jne    9a <nettle_umac128_set_nonce+0x2d>
lea    0x0(%rip),%rcx        # 82 <nettle_umac128_set_nonce+0x15>
mov    $0x3d,%edx
lea    0x0(%rip),%rsi        # 8e <nettle_umac128_set_nonce+0x21>
lea    0x0(%rip),%rdi        # 95 <nettle_umac128_set_nonce+0x28>
callq  9a <nettle_umac128_set_nonce+0x2d>
mov    %rdi,%rbp
mov    %rdx,%rsi
cmp    $0x10,%rbx
jbe    c5 <nettle_umac128_set_nonce+0x58>
lea    0x0(%rip),%rcx        # ad <nettle_umac128_set_nonce+0x40>
mov    $0x3e,%edx
lea    0x0(%rip),%rsi        # b9 <nettle_umac128_set_nonce+0x4c>
lea    0x0(%rip),%rdi        # c0 <nettle_umac128_set_nonce+0x53>
callq  c5 <nettle_umac128_set_nonce+0x58>
lea    0x6b0(%rdi),%rdi
mov    %rbx,%rdx
callq  d4 <nettle_umac128_set_nonce+0x67>
mov    $0x10,%edx
sub    %rbx,%rdx
lea    0x6b0(%rbp,%rbx,1),%rdi
mov    $0x0,%esi
callq  ee <nettle_umac128_set_nonce+0x81>
mov    %bx,0x6c0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nettle_umac128_set_nonce (struct umac128_ctx *ctx,
     size_t nonce_length, const uint8_t *nonce)
{
  ((nonce_length > 0) ? (void) (0) : __assert_fail ("nonce_length > 0", "umac128.c", 61, __PRETTY_FUNCTION__));
  ((nonce_length <= 16) ? (void) (0) : __assert_fail ("nonce_length <= 16", "umac128.c", 62, __PRETTY_FUNCTION__));
  memcpy (ctx->nonce, nonce, nonce_length);
  memset (ctx->nonce + nonce_length, 0, 16 - nonce_length);
  ctx->nonce_length = nonce_length;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 8
30 9
31 9
32 9
33 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  9f7 <gsl_sort_vector_ulong_largest_index+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_ulong_largest_index (size_t * p, const size_t k,
                                          const gsl_vector_ulong * v)
{
  return gsl_sort_ulong_largest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
mov    $0x1,%edx
callq  4b6c <_jit_frame+0xa>
repz retq 
<<<sep_in_sample>>>
_jit_frame(jit_state_t *_jit, jit_int32_t frame)
{
    _jit_trampoline(_jit, frame, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %esi,%edx
mov    %rdi,%rsi
mov    $0x2,%edi
callq  13 <nict_handle_transport_error+0x13>
mov    $0xe,%esi
mov    %rbx,%rdi
callq  20 <nict_handle_transport_error+0x20>
mov    %rbx,%rsi
mov    $0x2,%edi
callq  2d <nict_handle_transport_error+0x2d>
pop    %rbx
retq   
<<<sep_in_sample>>>
nict_handle_transport_error (osip_transaction_t * nict, int err)
{
  __osip_transport_error_callback (OSIP_NICT_TRANSPORT_ERROR, nict, err);
  __osip_transaction_set_state (nict, NICT_TERMINATED);
  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    (%rdi),%ebx
mov    $0x1,%eax
cmp    (%rsi),%ebx
jne    175d <grecs_node_eq+0x4e>
mov    $0x0,%al
test   %ebx,%ebx
je     175d <grecs_node_eq+0x4e>
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  1737 <grecs_node_eq+0x28>
test   %eax,%eax
jne    1758 <grecs_node_eq+0x49>
cmp    $0x2,%ebx
jne    175d <grecs_node_eq+0x4e>
mov    0x70(%r12),%rsi
mov    0x70(%rbp),%rdi
callq  174e <grecs_node_eq+0x3f>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    175d <grecs_node_eq+0x4e>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_node_eq(struct grecs_node *a, struct grecs_node *b)
{
 if (a->type != b->type)
  return 1;
 if (a->type == grecs_node_root)
  return 0;
 if (strcmp(a->ident, b->ident))
  return 1;
 if (a->type == grecs_node_block &&
     !grecs_value_eq(a->v.value, b->v.value))
  return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 3
10 6
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 10
21 10
22 10
23 9
24 9
25 9
26 9
27 8
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     204 <renumber+0x2c>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     1fd <renumber+0x25>
mov    0x8(%rax),%rax
add    $0x1,%rax
mov    %rax,0x8(%rdi)
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
jne    1ea <renumber+0x12>
repz retq 
mov    $0x0,%eax
jmp    1ea <renumber+0x12>
repz retq 
<<<sep_in_sample>>>
renumber(filestruct *fileptr)
{
    ssize_t line;
    if (fileptr == ((void *)0))
 return;
    line = (fileptr->prev == ((void *)0)) ? 0 : fileptr->prev->lineno;
    ((void) (0));
    for (; fileptr != ((void *)0); fileptr = fileptr->next)
 fileptr->lineno = ++line;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
7 9
8 9
9 8
10 8
11 8
12 8
13 6
14 6
15 6
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 239 <builtin_usage+0x8>
test   %rbx,%rbx
je     264 <builtin_usage+0x33>
cmpb   $0x0,(%rbx)
je     264 <builtin_usage+0x33>
mov    $0x0,%edi
callq  24d <builtin_usage+0x1c>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 25a <builtin_usage+0x29>
mov    $0x0,%eax
callq  264 <builtin_usage+0x33>
mov    0x0(%rip),%rax        # 26b <builtin_usage+0x3a>
mov    0x20(%rax),%rdi
callq  274 <builtin_usage+0x43>
mov    %rax,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 283 <builtin_usage+0x52>
mov    $0x0,%eax
callq  28d <builtin_usage+0x5c>
mov    0x0(%rip),%rdi        # 294 <builtin_usage+0x63>
callq  299 <builtin_usage+0x68>
pop    %rbx
retq   
<<<sep_in_sample>>>
builtin_usage ()
{
  if (this_command_name && *this_command_name)
    fprintf (stderr, gettext("%s: usage: "), this_command_name);
  fprintf (stderr, "%s\n", gettext(current_builtin->short_doc));
  fflush (stderr);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
<<<sep_out_sample>>>
sub    $0x238,%rsp
mov    %rsi,0x188(%rsp)
mov    %rdx,0x190(%rsp)
mov    %rcx,0x198(%rsp)
mov    %r8,0x1a0(%rsp)
mov    %r9,0x1a8(%rsp)
test   %al,%al
je     53a <posterr+0x73>
movaps %xmm0,0x1b0(%rsp)
movaps %xmm1,0x1c0(%rsp)
movaps %xmm2,0x1d0(%rsp)
movaps %xmm3,0x1e0(%rsp)
movaps %xmm4,0x1f0(%rsp)
movaps %xmm5,0x200(%rsp)
movaps %xmm6,0x210(%rsp)
movaps %xmm7,0x220(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x178(%rsp)
xor    %eax,%eax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0x240(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x180(%rsp),%rax
mov    %rax,0x18(%rsp)
cmpl   $0x1,0x0(%rip)        # 57e <posterr+0xb7>
je     589 <posterr+0xc2>
cmpl   $0x0,0x0(%rip)        # 587 <posterr+0xc0>
jne    5b0 <posterr+0xe9>
lea    0x8(%rsp),%rdx
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 598 <posterr+0xd1>
callq  59d <posterr+0xd6>
mov    0x0(%rip),%rsi        # 5a4 <posterr+0xdd>
mov    $0xa,%edi
callq  5ae <posterr+0xe7>
jmp    5d1 <posterr+0x10a>
lea    0x8(%rsp),%rcx
mov    %rdi,%rdx
mov    $0x14a,%esi
lea    0x20(%rsp),%rdi
callq  5c7 <posterr+0x100>
lea    0x20(%rsp),%rdi
callq  5d1 <posterr+0x10a>
mov    0x178(%rsp),%rax
xor    %fs:0x28,%rax
je     5e9 <posterr+0x122>
callq  5e9 <posterr+0x122>
add    $0x238,%rsp
retq   
<<<sep_in_sample>>>
posterr(char *msg, ...)
{
    va_list ap;
    char errbuf[((250) + 80)];
    __builtin_va_start(ap,msg);
    if (linemode == YES || incurses == NO)
    {
        (void) vfprintf(stderr, msg, ap);
 (void) fputc('\n', stderr);
    } else {
        vsnprintf(errbuf, sizeof(errbuf), msg, ap);
        postmsg2(errbuf);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 5
21 5
22 5
23 5
24 5
25 5
26 6
27 6
28 6
29 6
30 8
31 8
32 8
33 8
34 9
35 9
36 9
37 9
38 11
39 11
40 11
41 11
42 11
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r13
mov    %rsi,%rbp
mov    %rdx,%r14
callq  664 <parse822_atom_ex+0x16>
mov    0x0(%r13),%r12
cmp    %r12,%rbp
je     689 <parse822_atom_ex+0x3b>
mov    %r12,%rbx
jmp    67b <parse822_atom_ex+0x2d>
add    $0x1,%rbx
cmp    %rbx,%rbp
je     68c <parse822_atom_ex+0x3e>
movsbl (%rbx),%edi
callq  683 <parse822_atom_ex+0x35>
test   %eax,%eax
jne    672 <parse822_atom_ex+0x24>
jmp    68c <parse822_atom_ex+0x3e>
mov    %r12,%rbx
mov    $0x1007,%eax
cmp    %r12,%rbx
je     6b1 <parse822_atom_ex+0x63>
mov    %rbx,%rdx
sub    %r12,%rdx
mov    %r12,%rsi
mov    %r14,%rdi
callq  37 <str_append_n>
mov    %eax,%edx
test   %edx,%edx
jne    6b1 <parse822_atom_ex+0x63>
mov    %rbx,0x0(%r13)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
parse822_atom_ex (const char **p, const char *e, char **atom)
{
  const char *ptr;
  int rc;
  mu_parse822_skip_comments (p, e);
  for (ptr = *p; (ptr != e) && parse822_is_atom_char_ex (*ptr); ptr++)
    ;
  if (ptr - *p == 0)
    return (0x1000 +7);
  rc = str_append_n (atom, *p, ptr - *p);
  if (rc == 0)
    *p = ptr;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 9
25 8
26 8
27 10
28 10
29 10
30 10
31 10
32 10
33 11
34 11
35 12
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
test   %rsi,%rsi
je     6a <osip_message_set__header+0x6a>
mov    %rdi,%rbp
mov    %rdx,%r12
mov    %rsi,%rdi
callq  1a <osip_message_set__header+0x1a>
test   %eax,%eax
js     2d <osip_message_set__header+0x2d>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %eax,%edi
callq  2b <osip_message_set__header+0x2b>
jmp    6f <osip_message_set__header+0x6f>
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  3b <osip_message_set__header+0x3b>
test   %eax,%eax
je     6f <osip_message_set__header+0x6f>
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x3,%edx
mov    $0x1a2,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  63 <osip_message_set__header+0x63>
mov    $0x0,%eax
jmp    6f <osip_message_set__header+0x6f>
mov    $0xfffffffb,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_set__header (osip_message_t * sip, const char *hname, const char *hvalue)
{
  int my_index;
  if (hname == ((void *)0))
    return -5;
  my_index = __osip_message_is_known_header (hname);
  if (my_index >= 0) {
    int ret;
    ret = __osip_message_call_method (my_index, sip, hvalue);
    if (ret != 0)
      return ret;
    return 0;
  }
  if (osip_message_set_header (sip, hname, hvalue) != 0) {
    osip_trace ("osip_message_parse.c", 418, TRACE_LEVEL3, ((void *)0), "Could not set unknown header\n");
    return 0;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 6
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 14
19 14
20 14
21 14
22 14
23 14
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 16
32 16
33 5
34 19
35 19
36 19
37 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     347 <osip_from_get_url+0xa>
mov    0x8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_from_get_url (osip_from_t * from)
{
  if (from == ((void *)0))
    return ((void *)0);
  return from->url;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
callq  6bf <mult_term>
mov    %eax,%edx
test   %edx,%edx
jne    83b <add_term+0x77>
jmp    80d <add_term+0x49>
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
test   %eax,%eax
je     836 <add_term+0x72>
lea    0xc(%rsp),%rsi
mov    %eax,%edi
callq  6bf <mult_term>
test   %eax,%eax
jne    83b <add_term+0x77>
cmp    $0x2,%ebx
jne    806 <add_term+0x42>
mov    0xc(%rsp),%eax
add    %eax,0x0(%rbp)
jmp    80d <add_term+0x49>
mov    0xc(%rsp),%eax
sub    %eax,0x0(%rbp)
lea    0xc(%rsp),%rdi
callq  f <eval_lex>
mov    %eax,%ebx
lea    -0x2(%rax),%eax
cmp    $0x1,%eax
jbe    7da <add_term+0x16>
mov    $0x6,%eax
test   %ebx,%ebx
je     83b <add_term+0x77>
callq  0 <eval_undo>
mov    $0x0,%eax
jmp    83b <add_term+0x77>
mov    $0x6,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
add_term (eval_token et, int32_t *v1)
{
  eval_token op;
  int32_t v2;
  eval_error er;
  if ((er = mult_term (et, v1)) != NO_ERROR)
    return er;
  while ((op = eval_lex (&v2)) == PLUS || op == MINUS)
    {
      et = eval_lex (&v2);
      if (et == ERROR)
        return UNKNOWN_INPUT;
      if ((er = mult_term (et, &v2)) != NO_ERROR)
        return er;
      if (op == PLUS)
        *v1 = (int32_t) ((uint32_t) *v1 + (uint32_t) v2);
      else
        *v1 = (int32_t) ((uint32_t) *v1 - (uint32_t) v2);
    }
  if (op == ERROR)
    return UNKNOWN_INPUT;
  eval_undo ();
  return NO_ERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 6
8 6
9 6
10 10
11 10
12 11
13 11
14 13
15 13
16 13
17 13
18 13
19 15
20 15
21 16
22 16
23 16
24 18
25 18
26 8
27 8
28 8
29 8
30 8
31 8
32 21
33 20
34 20
35 22
36 23
37 23
38 12
39 24
40 24
41 24
42 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  90 <_rl_abort_internal+0x9>
callq  95 <_rl_abort_internal+0xe>
callq  9a <_rl_abort_internal+0x13>
callq  9f <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # aa <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # b2 <_rl_abort_internal+0x2b>
je     c3 <_rl_abort_internal+0x3c>
callq  b9 <_rl_abort_internal+0x32>
cmpq   $0x0,0x0(%rip)        # c1 <_rl_abort_internal+0x3a>
jne    b4 <_rl_abort_internal+0x2d>
andq   $0xffffffffffdfffff,0x0(%rip)        # ce <_rl_abort_internal+0x47>
movq   $0x0,0x0(%rip)        # d9 <_rl_abort_internal+0x52>
mov    $0x1,%esi
mov    $0x0,%edi
callq  e8 <rl_abort>
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 9
10 8
11 8
12 10
13 11
14 12
15 12
16 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x1,0x0(%rip)        # 48f <postmsg2+0xb>
jne    498 <postmsg2+0x14>
callq  496 <postmsg2+0x12>
jmp    4c5 <postmsg2+0x41>
nopl   0x0(%rax,%rax,1)
callq  4a5 <postmsg2+0x21>
mov    $0xffffffff,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 4b4 <postmsg2+0x30>
callq  4b9 <postmsg2+0x35>
mov    0x0(%rip),%rdi        # 4c0 <postmsg2+0x3c>
callq  4c5 <postmsg2+0x41>
pop    %rbx
retq   
<<<sep_in_sample>>>
postmsg2(char *msg)
{
 if (linemode == YES) {
  (void) printf("%s\n", msg);
 }
 else {
  clearmsg2();
  waddnstr(stdscr,(msg),-1);
  wrefresh(stdscr);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 7
9 8
10 8
11 8
12 8
13 9
14 9
15 11
16 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x1f40,%esi
mov    $0x0,%edi
callq  436 <strcache_init+0x23>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strcache_init (void)
{
  hash_init (&strings, 8000, str_hash_1, str_hash_2, str_hash_cmp);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
callq  f67 <mu_locker_lock+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_locker_lock (mu_locker_t lock)
{
  return _mu_locker_lock (lock, mu_lck_exc);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rsi,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rax
xor    %rsi,%rax
sub    %rdx,%rax
test   %rax,%rax
jle    31 <__gmpz_limbs_finish+0x31>
mov    0x8(%rdi),%rdx
cmpq   $0x0,-0x8(%rdx,%rax,8)
je     2b <__gmpz_limbs_finish+0x2b>
jmp    31 <__gmpz_limbs_finish+0x31>
cmpq   $0x0,-0x8(%rdx,%rax,8)
jne    31 <__gmpz_limbs_finish+0x31>
sub    $0x1,%rax
jne    23 <__gmpz_limbs_finish+0x23>
mov    %eax,%edx
neg    %edx
test   %rsi,%rsi
cmovs  %edx,%eax
mov    %eax,0x4(%rdi)
retq   
<<<sep_in_sample>>>
__gmpz_limbs_finish (mpz_ptr x, mp_size_t xs)
{
  mp_size_t xn = ((xs) >= 0 ? (xs) : -(xs));
  do { while ((xn) > 0) { if ((((x)->_mp_d))[(xn) - 1] != 0) break; (xn)--; } } while (0);
  ((x)->_mp_size) = xs < 0 ? -xn : xn;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %edx,%r14d
mov    %rcx,%r15
mov    $0xc0800000,%esi
callq  d45f <_sse_buneqi_d+0x24>
mov    %eax,%ebp
mov    %eax,%r12d
and    $0x7fff,%r12d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
mov    %r15,%rdx
mov    %rbx,%rdi
callq  c657 <_sse_movi_d>
mov    0x0(%r12),%ecx
and    $0x7fff,%ecx
mov    %r14d,%edx
mov    %r13,%rsi
mov    %rbx,%rdi
callq  12ae <_sse_buneqr_d>
mov    %rax,%r12
mov    %ebp,%esi
mov    %rbx,%rdi
callq  d4b1 <_sse_buneqi_d+0x76>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
_sse_buneqi_d(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float64_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000|0x80000000| 0x00800000); ((void) (0)); _sse_movi_d(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _sse_buneqr_d(_jit, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2e7 <sort_up_value_string>
neg    %eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sort_down_value_string(const void *p1, const void *p2)
{
 return -sort_up_value_string(p1, p2);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
<<<sep_in_sample>>>
outline_compare_count (dico_result_t rp)
{
    struct result *res = (struct result *) rp;
    return res->compare_count;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    (%rdx),%rdx
callq  16fb <strategy_deny_length_eq_cb+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
strategy_deny_length_eq_cb(enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr,
      grecs_value_t *value,
      void *cb_data)
{
    return strategy_deny_length(cmd, locus, *(dico_list_t*) varptr,
    value, cmp_eq);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 9
6 9
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
lea    0xa8(%rdi),%rbx
mov    %rbx,0x8(%rsp)
mov    %rdi,(%rsp)
mov    $0x0,%r9d
mov    $0x491,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 2d7 <uxfio__unlink_tmpfile+0x37>
mov    $0x0,%eax
callq  2e1 <uxfio__unlink_tmpfile+0x41>
mov    %rbx,%rdi
callq  2e9 <uxfio__unlink_tmpfile+0x49>
mov    $0x0,%edx
test   %eax,%eax
je     329 <uxfio__unlink_tmpfile+0x89>
callq  2f7 <uxfio__unlink_tmpfile+0x57>
mov    (%rax),%edi
mov    $0xffffffff,%edx
cmp    $0x2,%edi
je     329 <uxfio__unlink_tmpfile+0x89>
callq  308 <uxfio__unlink_tmpfile+0x68>
mov    %rax,%rcx
mov    %rbx,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 31a <uxfio__unlink_tmpfile+0x7a>
mov    $0x0,%eax
callq  324 <uxfio__unlink_tmpfile+0x84>
mov    $0xffffffff,%edx
mov    %edx,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
uxfio__unlink_tmpfile(UXFIO *uxfio)
{
 int ret=0;
 { fprintf(stderr, "Informative Message:" "[%d]: %18s:%-5d , %s : " "%p unlink tmpfile: [%s]" "\n", (int)0,
 "uxfio.c"
 ,
 1169
 , __FUNCTION__, (void*)uxfio, uxfio->buffilenameM); }
                                                               ;
 if (unlink(uxfio->buffilenameM)) {
  ret=-1;
  if ((*__errno_location ()) != 2) {
   ;
   fprintf(stderr,
    "uxfio error: error unlinking file %s: %s\n",
     uxfio->buffilenameM, strerror((*__errno_location ())));
  }
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 8
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 10
15 10
16 3
17 10
18 10
19 12
20 12
21 11
22 12
23 12
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 11
32 20
33 20
34 20
35 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x10,%esi
callq  d6 <nettle_arcfour128_set_key+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_arcfour128_set_key(struct arcfour_ctx *ctx, const uint8_t *key)
{
  nettle_arcfour_set_key (ctx, 16, key);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a07 <osip_transaction_get_reserved1+0xd>
mov    0x2c40(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
osip_transaction_get_reserved1 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved1;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 4
6 6
<<<sep_out_sample>>>
movb   $0x0,0x6d(%rdi)
retq   
<<<sep_in_sample>>>
panel_deactivate(this)
    panel_t *this;
{
    this->visible = 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %rsi,0xe0(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_gssapi_set (Gsasl * ctx,
      Gsasl_server_callback_gssapi cb)
{
  ctx->cbs_gssapi = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     15b <a_word_hash_1+0x2f>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    13c <a_word_hash_1+0x10>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
a_word_hash_1 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct a_word const *) key)->str)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
xorpd  %xmm0,%xmm0
test   %rdx,%rdx
je     362 <gsl_stats_char_median_from_sorted_data+0x43>
lea    -0x1(%rdx),%rax
shr    %rax
shr    %rdx
cmp    %rdx,%rax
jne    344 <gsl_stats_char_median_from_sorted_data+0x25>
imul   %rax,%rsi
movsbl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm0
retq   
imul   %rsi,%rax
movsbl (%rdi,%rax,1),%ecx
imul   %rsi,%rdx
movsbl (%rdi,%rdx,1),%eax
add    %ecx,%eax
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 362 <gsl_stats_char_median_from_sorted_data+0x43>
repz retq 
<<<sep_in_sample>>>
gsl_stats_char_median_from_sorted_data (const char sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 9
2 8
3 8
4 6
5 6
6 7
7 10
8 10
9 12
10 12
11 12
12 12
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 19
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # e <rpmSetVerbosity+0x6>
retq   
<<<sep_in_sample>>>
rpmSetVerbosity(int level) {
    minLevel = level;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0xffffffffffffffff,%r8
mov    %rsi,%rdi
mov    $0x0,%eax
mov    %r8,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rbp
lea    (%rcx,%r8,1),%rdx
mov    %rbx,%rdi
mov    %r8,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%r8
sub    $0x1,%r8
mov    $0x0,%eax
cmp    %r8,%rdx
ja     7e <begins_with+0x6b>
mov    %rbx,%rdi
callq  5e <begins_with+0x4b>
mov    %eax,%edx
mov    $0x0,%eax
test   %edx,%edx
jne    7e <begins_with+0x6b>
movzbl -0x1(%rbx,%rbp,1),%edx
mov    $0x1,%al
test   $0xdf,%dl
je     7e <begins_with+0x6b>
cmp    $0x9,%dl
sete   %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
begins_with(const char *str, const char *prefix)
{
    size_t len = strlen (prefix);
    return strlen (str) >= len && strncmp (str, prefix, len) == 0
    && (str[len] == 0 || str[len] == ' ' || str[len] == '\t');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 4
23 4
24 4
25 5
26 4
27 4
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 6
36 6
37 6
38 6
<<<sep_out_sample>>>
movb   $0x0,0xa(%rdi)
movw   $0x0,0x8(%rdi)
lea    0x0(%rip),%rax        # 11 <nettle_base64url_encode_init+0x11>
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
nettle_base64url_encode_init(struct base64_encode_ctx *ctx)
{
  static const uint8_t base64url_encode_table[64] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789-_";
  ctx->word = ctx->bits = 0;
  ctx->alphabet = base64url_encode_table;
}
<<<sep_in_sample>>>
1 7
2 7
3 8
4 8
5 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
fnstcw 0x1c(%rsp)
movzwl 0x1c(%rsp),%ebx
mov    %ebx,%eax
or     $0x3,%ah
mov    %ax,0x1c(%rsp)
fldcw  0x1c(%rsp)
fldt   0x40(%rsp)
fstpt  (%rsp)
lea    0x1c(%rsp),%rdi
callq  31 <printf_frexpl+0x31>
fadd   %st(0),%st
mov    0x1c(%rsp),%edx
lea    -0x1(%rdx),%eax
mov    %eax,0x1c(%rsp)
cmp    $0xffffc002,%eax
jge    5b <printf_frexpl+0x5b>
lea    0x3ffd(%rdx),%edi
fstpt  (%rsp)
callq  53 <printf_frexpl+0x53>
movl   $0xffffc002,0x1c(%rsp)
mov    %bx,0x1a(%rsp)
fldcw  0x1a(%rsp)
mov    0x1c(%rsp),%eax
mov    %eax,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
printf_frexpl (long double x, int *expptr)
{
  int exponent;
  fpucw_t oldcw;
  (void)(oldcw = ({ fpucw_t _cw; __asm__ __volatile__ ("fnstcw %0" : "=m" (*&_cw)); _cw; }), (void)({ fpucw_t _ncw = ((oldcw & ~0x0300) | 0x300); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); }));
  x = frexpl (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-16381) - 1)
    {
      x = ldexpl (x, exponent - ((-16381) - 1));
      exponent = (-16381) - 1;
    }
  (void)({ fpucw_t _ncw = (oldcw); __asm__ __volatile__ ("fldcw %0" : : "m" (*&_ncw)); });
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 11
24 12
25 14
26 14
27 15
28 15
29 17
30 17
31 17
32 17
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%r9
test   %r8,%r8
je     16f2 <gsl_vector_ulong_scale+0x8a>
shl    $0x3,%r9
mov    $0x0,%esi
mov    $0x0,%ecx
movsd  0x0(%rip),%xmm2        # 168a <gsl_vector_ulong_scale+0x22>
movapd %xmm2,%xmm3
movabs $0x8000000000000000,%r11
mov    %rsi,%rax
add    0x10(%rdi),%rax
mov    (%rax),%rdx
test   %rdx,%rdx
js     16ae <gsl_vector_ulong_scale+0x46>
cvtsi2sd %rdx,%xmm1
jmp    16c3 <gsl_vector_ulong_scale+0x5b>
mov    %rdx,%r10
shr    %r10
and    $0x1,%edx
or     %rdx,%r10
cvtsi2sd %r10,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jae    16d7 <gsl_vector_ulong_scale+0x6f>
cvttsd2si %xmm1,%rdx
mov    %rdx,(%rax)
jmp    16e6 <gsl_vector_ulong_scale+0x7e>
subsd  %xmm3,%xmm1
cvttsd2si %xmm1,%rdx
mov    %rdx,(%rax)
xor    %r11,(%rax)
add    $0x1,%rcx
add    %r9,%rsi
cmp    %r8,%rcx
jne    1698 <gsl_vector_ulong_scale+0x30>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_scale (gsl_vector_ulong * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] *= x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 6
35 6
36 6
37 6
38 11
39 11
<<<sep_out_sample>>>
mov    (%rsi),%rax
test   %rax,%rax
je     188 <grecs_list_add+0x4e>
mov    0x8(%rdi),%rdx
mov    %rdx,0x8(%rax)
mov    0x8(%rdi),%rax
test   %rax,%rax
je     15b <grecs_list_add+0x21>
mov    (%rsi),%rdx
mov    %rdx,(%rax)
jmp    161 <grecs_list_add+0x27>
mov    (%rsi),%rax
mov    %rax,(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x8(%rdi)
mov    0x10(%rsi),%rax
add    %rax,0x10(%rdi)
movq   $0x0,0x8(%rsi)
movq   $0x0,(%rsi)
movq   $0x0,0x10(%rsi)
repz retq 
<<<sep_in_sample>>>
grecs_list_add(struct grecs_list *dst, struct grecs_list *src)
{
 if (!src->head)
  return;
 src->head->prev = dst->tail;
 if (dst->tail)
  dst->tail->next = src->head;
 else
  dst->head = src->head;
 dst->tail = src->tail;
 dst->count += src->count;
 src->head = src->tail = ((void *)0);
 src->count = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 6
7 6
8 6
9 7
10 7
11 7
12 9
13 9
14 10
15 10
16 11
17 11
18 12
19 12
20 13
21 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rax
cmpq   $0x0,0xc0(%rax)
je     7914 <_jit_realize+0x17>
callq  7914 <_jit_realize+0x17>
mov    %rbx,%rdi
callq  791c <_jit_realize+0x1f>
mov    0x38(%rbx),%rax
orb    $0x1,0x10(%rax)
mov    0x38(%rbx),%rax
mov    0x70(%rax),%rcx
lea    0x7(%rcx),%rdx
and    $0xfffffffffffffff8,%rdx
mov    %rdx,0x70(%rax)
mov    %rbx,%rdi
callq  7940 <_jit_realize+0x43>
mov    %rax,0x10(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
_jit_realize(jit_state_t *_jit)
{
    ((void) (0));
    if (_jit->comp->function)
 _jit_epilog(_jit);
    _jit_optimize(_jit);
    _jit->comp->realize = 1;
    _jit->comp->data.offset = (_jit->comp->data.offset + 7) & -8;
    _jit->code.length = _jit_get_size(_jit);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 10
20 10
<<<sep_out_sample>>>
mov    0x8(%rdi),%edx
not    %edx
mov    (%rdi),%rax
shl    $0x4,%eax
xor    %edx,%eax
retq   
<<<sep_in_sample>>>
directory_contents_hash_2 (const void *key_0)
{
  const struct directory_contents *key = key_0;
  unsigned long hash;
  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) ~key->ino;
  return hash;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
movl   $0x3a353133,(%rsp)
movb   $0x0,0x4(%rsp)
mov    %rsp,%rsi
callq  700 <swevent_parse_attribute_event+0x30>
test   %rax,%rax
je     747 <swevent_parse_attribute_event+0x77>
lea    0x4(%rax),%rdi
movzbl 0x4(%rax),%eax
cmp    $0x3d,%al
je     74e <swevent_parse_attribute_event+0x7e>
test   %al,%al
je     74e <swevent_parse_attribute_event+0x7e>
mov    %rdi,%rax
add    $0x1,%rax
movzbl (%rax),%ecx
cmp    $0x3d,%cl
je     728 <swevent_parse_attribute_event+0x58>
test   %cl,%cl
jne    718 <swevent_parse_attribute_event+0x48>
cmp    %rax,%rdi
je     755 <swevent_parse_attribute_event+0x85>
test   %cl,%cl
nop
je     75c <swevent_parse_attribute_event+0x8c>
movb   $0x0,(%rax)
mov    %rdi,0x0(%rbp)
add    $0x1,%rax
mov    %rax,(%rbx)
mov    $0x0,%eax
jmp    761 <swevent_parse_attribute_event+0x91>
mov    $0xffffffff,%eax
jmp    761 <swevent_parse_attribute_event+0x91>
mov    $0xfffffffe,%eax
jmp    761 <swevent_parse_attribute_event+0x91>
mov    $0xfffffffe,%eax
jmp    761 <swevent_parse_attribute_event+0x91>
mov    $0xfffffffd,%eax
mov    0x8(%rsp),%rdx
xor    %fs:0x28,%rdx
je     776 <swevent_parse_attribute_event+0xa6>
callq  776 <swevent_parse_attribute_event+0xa6>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swevent_parse_attribute_event(char * line, char ** attribute, char ** value)
{
 char * s;
 char * s1;
 const char attribute_event[]="315:";
 s = strstr(line, attribute_event);
 if (!s) return -1;
 s += strlen(attribute_event);
 s1 = s;
 while(*s1 && *s1 != '=') s1++;
 if (s1 == s) return -2;
 if ( ! (*s1)) return -3;
 *s1 = '\0';
 s1++;
 *attribute = s;
 *value = s1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 6
12 6
13 7
14 7
15 8
16 10
17 10
18 10
19 10
20 10
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
30 12
31 12
32 12
33 13
34 15
35 14
36 14
37 17
38 17
39 7
40 7
41 11
42 11
43 11
44 11
45 12
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
mov    $0xf,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  2d5c <Write_R_Includes+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
Write_R_Includes (PFILE pfile)
{
  fprintf (pfile, "#include <R.h>\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
cmp    $0x10,%esi
mov    $0x10,%eax
cmovg  %eax,%esi
test   %esi,%esi
jle    a3 <printd+0x41>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
lea    -0x1(%rsi),%eax
lea    0x1(%rdi,%rax,1),%rbp
movzbl (%rbx),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  94 <printd+0x32>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    82 <printd+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
<<<sep_in_sample>>>
printd (unsigned char *data, int cnt)
{
  if (cnt > 16)
    cnt = 16;
  while (cnt-- > 0)
    {
      printf (" %02x", *data);
      ++data;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 2
7 2
8 2
9 2
10 2
11 2
12 7
13 7
14 7
15 7
16 8
17 5
18 5
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rsi,%rsi
je     17 <rpl_mbrtowc+0x17>
mov    $0xfffffffffffffffe,%rax
test   %rdx,%rdx
je     2b <rpl_mbrtowc+0x2b>
jmp    26 <rpl_mbrtowc+0x26>
mov    $0x1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2b <rpl_mbrtowc+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
{
  if (s == ((void *)0))
    {
      pwc = ((void *)0);
      s = "";
      n = 1;
    }
  if (n == 0)
    return (size_t) -2;
  {
    return mbrtowc (pwc, s, n, ps);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 10
5 9
6 9
7 9
8 7
9 6
10 5
11 12
12 14
13 14
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
lea    0x8(%rsp),%rsi
callq  432 <gsl_sf_lnbeta_e+0x12>
movsd  0x0(%rip),%xmm0        # 43a <gsl_sf_lnbeta_e+0x1a>
ucomisd 0x8(%rsp),%xmm0
jp     473 <gsl_sf_lnbeta_e+0x53>
jne    473 <gsl_sf_lnbeta_e+0x53>
movsd  0x0(%rip),%xmm0        # 44c <gsl_sf_lnbeta_e+0x2c>
movsd  %xmm0,(%rbx)
movsd  %xmm0,0x8(%rbx)
mov    $0x1,%ecx
mov    $0x2c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  46e <gsl_sf_lnbeta_e+0x4e>
mov    $0x1,%eax
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_sf_lnbeta_e(const double x, const double y, gsl_sf_result * result)
{
  double sgn;
  int status = gsl_sf_lnbeta_sgn_e(x,y,result,&sgn);
  if (sgn == -1) {
    do { (result)->val = (__builtin_nanf ("")); (result)->err = (__builtin_nanf ("")); do { gsl_error ("domain error", "beta.c", 44, GSL_EDOM) ; return GSL_EDOM ; } while (0); } while(0);
  }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xe8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_remove (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
mov    (%rsi),%rax
add    $0x28,%rdi
cmp    %rdi,%rax
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
<<<sep_in_sample>>>
gl_linked_next_node (gl_list_t list, gl_list_node_t node)
{
  return (node->next != &list->root ? node->next : ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    %rsi,%rbp
mov    $0x0,%ebx
mov    $0x1,%r12d
mov    $0x0,%r13d
lea    (%r14,%rbx,1),%rdi
mov    %rbp,%rsi
callq  2b <nettle_des3_set_key+0x2b>
test   %eax,%eax
cmove  %r13d,%r12d
add    $0x8,%rbp
sub    $0xffffffffffffff80,%rbx
cmp    $0x180,%rbx
jne    1f <nettle_des3_set_key+0x1f>
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
nettle_des3_set_key(struct des3_ctx *ctx, const uint8_t *key)
{
  unsigned i;
  int is_good = 1;
  for (i = 0; i<3; i++, key += 8)
    if (!nettle_des_set_key(&ctx->des[i], key))
      is_good = 0;
  return is_good;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 7
11 7
12 6
13 6
14 6
15 7
16 5
17 5
18 5
19 5
20 9
21 9
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # d5 <env_list+0x8>
test   %rbx,%rbx
je     105 <env_list+0x38>
mov    0x18(%rbx),%rcx
mov    0x10(%rbx),%rdx
cmpl   $0x1,0x20(%rbx)
sbb    %esi,%esi
and    $0xfffffff6,%esi
add    $0x2a,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  fd <env_list+0x30>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    da <env_list+0xd>
pop    %rbx
retq   
<<<sep_in_sample>>>
env_list (void)
{
  register struct env_lst *ep;
  for (ep = envlisthead.next; ep; ep = ep->next)
    {
      printf ("%c %-20s %s\n", ep->export ? '*' : ' ', ep->var, ep->value);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 4
15 4
16 4
17 8
18 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xe8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_remove (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     144c <gsl_vector_float_add_constant+0x44>
shl    $0x2,%r8
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%rcx
add    0x10(%rdi),%rcx
movss  (%rcx),%xmm1
cvtps2pd %xmm1,%xmm1
addsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,(%rcx)
add    $0x1,%rax
add    %r8,%rdx
cmp    %rsi,%rax
jne    1422 <gsl_vector_float_add_constant+0x1a>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_float_add_constant (gsl_vector_float * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 6
17 6
18 6
19 6
20 11
21 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %esi,%ebx
mov    %edx,%ebp
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  42 <print_drive_class+0x1c>
movzbl %bpl,%edx
mov    %ebx,%esi
mov    $0x0,%edi
callq  52 <print_drive_class+0x2c>
mov    %rax,%rbp
test   %rax,%rax
je     80 <print_drive_class+0x5a>
mov    (%rax),%rsi
test   %rsi,%rsi
je     80 <print_drive_class+0x5a>
mov    %rax,%rbx
mov    $0x0,%edi
mov    $0x0,%eax
callq  74 <print_drive_class+0x4e>
add    $0x8,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    65 <print_drive_class+0x3f>
mov    %rbp,%rdi
callq  88 <print_drive_class+0x62>
mov    $0x0,%edi
callq  92 <print_drive_class+0x6c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
print_drive_class(const char *psz_msg, cdio_fs_anal_t bitmask, unsigned char b_any) {
  char **ppsz_cd_drives=((void *)0), **c;
  printf("-- %s...\n", psz_msg);
  ppsz_cd_drives = cdio_get_devices_with_cap(((void *)0), bitmask, b_any);
  if (((void *)0) != ppsz_cd_drives)
    for( c = ppsz_cd_drives; *c != ((void *)0); c++ ) {
      printf("-- Drive %s\n", *c);
    }
  cdio_free_device_list(ppsz_cd_drives);
  printf("-----\n");
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 6
25 6
26 6
27 6
28 9
29 9
30 10
31 10
32 11
33 11
34 11
35 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rdi,%rdi
jne    48e <parse_opt_set_af+0x2d>
mov    %rsi,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  48e <parse_opt_set_af+0x2d>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  49b <parse_opt_set_af+0x3a>
test   %eax,%eax
jne    4a7 <parse_opt_set_af+0x46>
movw   $0x2,0x20(%rbx)
jmp    4c6 <parse_opt_set_af+0x65>
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  4c6 <parse_opt_set_af+0x65>
orl    $0x4,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_opt_set_af (struct ifconfig *ifp, char *af)
{
  if (!ifp)
    error (1, 0,
    "no interface specified for address family `%s'", af);
  if (!strcasecmp (af, "inet"))
    ifp->af = 2;
  else
    error (1, 0,
    "unknown address family `%s' for interface `%s': is not a number",
    af, ifp->name);
  ifp->valid |= 0x004;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 12
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x22,%edi
callq  14 <xgetdomainname+0x14>
mov    %rax,%rbp
callq  1c <xgetdomainname+0x1c>
mov    %rax,%r13
mov    $0x22,%ebx
movl   $0x0,0x0(%r13)
lea    -0x1(%rbx),%r12d
movslq %r12d,%r12
add    %rbp,%r12
movb   $0x0,(%r12)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  46 <xgetdomainname+0x46>
test   %eax,%eax
js     53 <xgetdomainname+0x53>
cmpb   $0x0,(%r12)
jne    70 <xgetdomainname+0x70>
jmp    83 <xgetdomainname+0x83>
mov    0x0(%r13),%r12d
cmp    $0x16,%r12d
je     70 <xgetdomainname+0x70>
mov    %rbp,%rdi
callq  65 <xgetdomainname+0x65>
mov    %r12d,0x0(%r13)
mov    $0x0,%eax
jmp    86 <xgetdomainname+0x86>
add    %rbx,%rbx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  7e <xgetdomainname+0x7e>
mov    %rax,%rbp
jmp    24 <xgetdomainname+0x24>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xgetdomainname (void)
{
  char *domainname;
  size_t size;
  size = 34;
  domainname = xmalloc (size);
  while (1)
    {
      int k = size - 1;
      int err;
      (*__errno_location ()) = 0;
      domainname[k] = '\0';
      err = getdomainname (domainname, size);
      if (err >= 0 && domainname[k] == '\0')
        break;
      else if (err < 0 && (*__errno_location ()) != 22)
        {
          int saved_errno = (*__errno_location ());
          free (domainname);
          (*__errno_location ()) = saved_errno;
          return ((void *)0);
        }
      size *= 2;
      domainname = xrealloc (domainname, size);
    }
  return domainname;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 11
10 11
11 5
12 11
13 9
14 12
15 12
16 12
17 13
18 13
19 13
20 14
21 14
22 14
23 14
24 14
25 16
26 16
27 16
28 19
29 19
30 20
31 21
32 21
33 23
34 24
35 24
36 24
37 24
38 25
39 25
40 27
41 27
42 27
43 27
44 27
45 27
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    $0x16,%esi
callq  e <__rdatetime+0xe>
mov    $0x0,%esi
lea    0x20(%rsp),%rdi
callq  1d <__rdatetime+0x1d>
lea    0x20(%rsp),%rdi
callq  27 <__rdatetime+0x27>
mov    %rax,%rsi
mov    0x8(%rax),%r9d
mov    0xc(%rax),%r8d
mov    0x10(%rax),%eax
lea    0x1(%rax),%ecx
mov    0x14(%rsi),%eax
lea    0x76c(%rax),%r11d
mov    0x0(%rip),%rax        # 49 <__rdatetime+0x49>
lea    0x18(%rax),%rdi
mov    0x28(%rsp),%r10
movabs $0x346dc5d63886594b,%rdx
mov    %r10,%rax
imul   %rdx
sar    $0xb,%rdx
sar    $0x3f,%r10
sub    %r10,%rdx
mov    %rdx,0x10(%rsp)
mov    (%rsi),%eax
mov    %eax,0x8(%rsp)
mov    0x4(%rsi),%eax
mov    %eax,(%rsp)
mov    %r11d,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  90 <__rdatetime+0x90>
mov    $0x0,%eax
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
__rdatetime (long as)
{
  struct timeval tip;
  struct tm *tmp;
  (void) __rblanks (as, 22L);
  (void) gettimeofday (&tip, (struct timezone *) 0L);
  tmp = localtime (&tip.tv_sec);
  (void) sprintf (__et.obj->string, "%4d-%02d-%02d %02d:%02d:%02d.%02d",
    tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
    tmp->tm_hour, tmp->tm_min, tmp->tm_sec
    ,tip.tv_usec / 10000
    );
  return (&__et);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 6
5 6
6 6
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 14
35 14
36 14
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_authorization_get_algorithm (osip_authorization_t * authorization)
{
  return authorization->algorithm;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    %rsi,%rdi
mov    $0x10,%esi
callq  38 <nettle_MD5Final+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_MD5Final(unsigned char *out, MD5_CTX *ctx)
{
  nettle_md5_digest(ctx, 16, out);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 15 <__gmpq_init+0x15>
mov    %rax,0x8(%rbx)
movl   $0x0,0x4(%rbx)
movl   $0x1,0x10(%rbx)
mov    $0x8,%edi
callq  *0x0(%rip)        # 32 <__gmpq_init+0x32>
mov    %rax,0x18(%rbx)
movq   $0x1,(%rax)
movl   $0x1,0x14(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmpq_init (mpq_t x)
{
  (((&((x)->_mp_num)))->_mp_alloc) = 1;
  (((&((x)->_mp_num)))->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  (((&((x)->_mp_num)))->_mp_size) = 0;
  (((&((x)->_mp_den)))->_mp_alloc) = 1;
  (((&((x)->_mp_den)))->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  (((&((x)->_mp_den)))->_mp_d)[0] = 1;
  (((&((x)->_mp_den)))->_mp_size) = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 5
8 6
9 7
10 7
11 7
12 8
13 9
14 10
15 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b70 <sdp_message_attribute_get+0x3b>
push   %rbx
mov    %edx,%ebx
cmp    $0xffffffff,%esi
jne    b52 <sdp_message_attribute_get+0x1d>
add    $0xa8,%rdi
mov    %edx,%esi
callq  b50 <sdp_message_attribute_get+0x1b>
jmp    b7b <sdp_message_attribute_get+0x46>
add    $0xb8,%rdi
callq  b5e <sdp_message_attribute_get+0x29>
test   %rax,%rax
je     b76 <sdp_message_attribute_get+0x41>
lea    0x58(%rax),%rdi
mov    %ebx,%esi
callq  b6e <sdp_message_attribute_get+0x39>
jmp    b7b <sdp_message_attribute_get+0x46>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sdp_message_attribute_get (sdp_message_t * sdp, int pos_media, int pos)
{
  sdp_media_t *med;
  if (sdp == ((void *)0))
    return ((void *)0);
  if (pos_media == -1)
    return (sdp_attribute_t *) osip_list_get (&sdp->a_attributes, pos);
  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return ((void *)0);
  return (sdp_attribute_t *) osip_list_get (&med->a_attributes, pos);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 6
6 6
7 7
8 7
9 7
10 7
11 8
12 8
13 9
14 9
15 11
16 11
17 11
18 11
19 5
20 12
21 10
22 12
23 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
cmpq   $0x0,0x28(%rdi)
je     107d <da_maparg+0x37>
mov    %rsi,%r12
mov    %rdx,%r13
mov    $0x0,%ebx
mov    0x30(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
mov    %r13,%rsi
callq  *%r12
add    $0x1,%rbx
cmp    %rbx,0x28(%rbp)
ja     1065 <da_maparg+0x1f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
da_maparg (struct darray * arr, da_maparg_func_t func, void * arg)
{
  size_t i;
  for (i = 0 ; i < arr->len ; i++)
    (*func) (arr->content [i], arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
<<<sep_out_sample>>>
cmp    $0x2,%edi
jne    10 <catchsig+0x10>
movzbl 0x0(%rip),%eax        # c <catchsig+0xc>
test   %al,%al
jne    16 <catchsig+0x16>
mov    %edi,0x0(%rip)        # 16 <catchsig+0x16>
repz retq 
<<<sep_in_sample>>>
catchsig (int s)
{
  if (! (s == 2 && ignore_SIGINT))
    signal_received = s;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r12
test   %r12,%r12
je     2e8 <argmatch_to_argument+0x3f>
mov    %rdi,%r14
mov    %rcx,%r13
mov    %rdx,%rbx
lea    0x8(%rsi),%rbp
mov    %r13,%rdx
mov    %rbx,%rsi
mov    %r14,%rdi
callq  2d4 <argmatch_to_argument+0x2b>
test   %eax,%eax
je     2e8 <argmatch_to_argument+0x3f>
mov    0x0(%rbp),%r12
add    %r13,%rbx
add    $0x8,%rbp
test   %r12,%r12
jne    2c6 <argmatch_to_argument+0x1d>
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
argmatch_to_argument (const char *value,
        const char *const *arglist,
        const char *vallist, size_t valsize)
{
  size_t i;
  for (i = 0; arglist[i]; i++)
    if (!memcmp (value, vallist + valsize * i, valsize))
      return arglist[i];
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 6
20 6
21 6
22 6
23 6
24 10
25 10
26 10
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    %esi,%r14d
mov    %edx,%r12d
mov    %rcx,%r13
mov    0x0(%rip),%eax        # 63f <tokins+0x19>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 648 <tokins+0x22>
cmp    0x0(%rip),%eax        # 64e <tokins+0x28>
jne    679 <tokins+0x53>
add    0x0(%rip),%eax        # 656 <tokins+0x30>
mov    %eax,0x0(%rip)        # 65c <tokins+0x36>
cltq   
lea    (%rax,%rax,2),%rsi
shl    $0x3,%rsi
mov    0x0(%rip),%rdi        # 66d <tokins+0x47>
callq  672 <tokins+0x4c>
mov    %rax,0x0(%rip)        # 679 <tokins+0x53>
mov    0x0(%rip),%rax        # 680 <tokins+0x5a>
movslq %ebp,%rdx
lea    (%rdx,%rdx,2),%rbx
shl    $0x3,%rbx
mov    %ebp,%edx
not    %edx
add    0x0(%rip),%edx        # 695 <tokins+0x6f>
movslq %edx,%rdx
lea    (%rdx,%rdx,2),%rdx
shl    $0x3,%rdx
lea    (%rax,%rbx,1),%rsi
lea    0x18(%rax,%rbx,1),%rdi
callq  6ae <tokins+0x88>
mov    0x0(%rip),%rax        # 6b5 <tokins+0x8f>
mov    %r14d,(%rax,%rbx,1)
add    0x0(%rip),%rbx        # 6c0 <tokins+0x9a>
mov    %rbx,%rdi
mov    %r13,0x8(%rbx)
mov    %r12d,0x10(%rbx)
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x0,%eax
callq  25a <debugtoken>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
tokins(int pos, int type, int line, char *token)
{
     if (++tos == token_stack_length) {
   token_stack_length += token_stack_increase;
   token_stack = xrealloc(token_stack,
     token_stack_length*sizeof(*token_stack));
     }
     memmove(token_stack + pos + 1, token_stack + pos,
      (tos - pos - 1) * sizeof(token_stack[0]));
     token_stack[pos].type = type;
     token_stack[pos].token = token;
     token_stack[pos].line = line;
     debugtoken(&token_stack[pos], "insert at %d", pos);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 8
31 8
32 8
33 8
34 8
35 8
36 10
37 10
38 11
39 11
40 11
41 12
42 13
43 13
44 13
45 13
46 14
47 14
48 14
49 14
50 14
51 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%edx
callq  1fc <xdr_simx_string+0xe>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdr_simx_string (XDR *xdrs, simx_string *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, 256))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 8
8 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%r9d
callq  1515 <intGetEntry>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
headerGetEntryMinMemory(Header h, int_32 tag, int_32 *type, void **p,
       int_32 *c)
{
    return intGetEntry(h, tag, type, p, c, 1);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
<<<sep_out_sample>>>
test   %rdx,%rdx
je     354 <gsl_stats_char_mean+0x45>
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 321 <gsl_stats_char_mean+0x12>
add    $0x1,%rax
movsbw (%rdi),%cx
mov    %cx,-0x12(%rsp)
fild   -0x12(%rsp)
fsub   %st(2),%st
mov    %rax,-0x20(%rsp)
fildll -0x20(%rsp)
test   %rax,%rax
jns    344 <gsl_stats_char_mean+0x35>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    321 <gsl_stats_char_mean+0x12>
fstp   %st(0)
jmp    356 <gsl_stats_char_mean+0x47>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_char_mean (const char data[], const size_t stride, const size_t size)
{
  long double mean = 0;
  size_t i;
  for (i = 0; i < size; i++)
    {
      mean += (data[i * stride] - mean) / (i + 1);
    }
  return mean;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 3
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 5
20 5
21 5
22 5
23 3
24 9
25 9
26 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  be <osip_contact_init+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_contact_init (osip_contact_t ** contact)
{
  return osip_from_init ((osip_from_t **) contact);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    (%rsi),%rdx
cmp    %rdx,(%rdi)
jne    34 <inode_val_compare+0x25>
mov    0x8(%rsi),%rcx
cmp    %rcx,0x8(%rdi)
jne    34 <inode_val_compare+0x25>
mov    0x10(%rsi),%rax
cmp    %rax,0x10(%rdi)
sete   %al
movzbl %al,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
inode_val_compare (const void *val1, const void *val2)
{
  const struct inode_val *ival1 = val1;
  const struct inode_val *ival2 = val2;
  return ival1->inode == ival2->inode
         && ival1->major_num == ival2->major_num
         && ival1->minor_num == ival2->minor_num;
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 5
13 8
<<<sep_out_sample>>>
lea    0xb(%rsi),%rcx
movb   $0x0,0xb(%rsi)
mov    $0x66666667,%esi
test   %edi,%edi
jns    4c <inttostr+0x4c>
mov    $0x66666667,%r8d
mov    $0x30,%esi
sub    $0x1,%rcx
mov    %edi,%eax
imul   %r8d
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
mov    %al,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    1c <inttostr+0x1c>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
jmp    71 <inttostr+0x71>
sub    $0x1,%rcx
mov    %edi,%eax
imul   %esi
sar    $0x2,%edx
mov    %edi,%eax
sar    $0x1f,%eax
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %edx,%edi
test   %edx,%edx
jne    4c <inttostr+0x4c>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
inttostr (int i, char *buf)
{
  char *p = buf + ((((sizeof (int) * 8 - (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (int)) 0 < (__typeof__ (int)) -1)));
  *p = 0;
  if (i < 0)
    {
      do
        *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
        *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 15
4 5
5 5
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 8
23 10
24 10
25 10
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 16
39 16
40 16
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
jne    d7e <trace_inc_ttl+0x22>
mov    $0x0,%ecx
mov    $0x2e3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d7e <trace_inc_ttl+0x22>
lea    0x2c(%rdi),%rcx
addl   $0x1,0x2c(%rdi)
cmpl   $0x0,0x8(%rdi)
jne    d91 <trace_inc_ttl+0x35>
mov    0x4(%rdi),%edi
jmp    d93 <trace_inc_ttl+0x37>
mov    (%rdi),%edi
mov    $0x4,%r8d
mov    $0x2,%edx
mov    $0x0,%esi
callq  da8 <trace_inc_ttl+0x4c>
test   %eax,%eax
jns    dc7 <trace_inc_ttl+0x6b>
callq  db1 <trace_inc_ttl+0x55>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  dc7 <trace_inc_ttl+0x6b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
trace_inc_ttl (trace_t * t)
{
  int fd;
  const int *ttlp;
  ((t) ? (void) (0) : __assert_fail ("t", "traceroute.c", 739, __PRETTY_FUNCTION__));
  ttlp = &t->ttl;
  t->ttl++;
  fd = (t->type == TRACE_UDP ? t->udpfd : t->icmpfd);
  if (setsockopt (fd, IPPROTO_IP, 2, ttlp, sizeof (*ttlp)) < 0)
    error (1, (*__errno_location ()), "setsockopt");
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 7
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 10e <send_help+0x7>
test   %rsi,%rsi
je     144 <send_help+0x3d>
push   %rbx
mov    $0x0,%ebx
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     131 <send_help+0x2a>
mov    $0x0,%edi
mov    $0x0,%eax
callq  131 <send_help+0x2a>
add    $0x28,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    119 <send_help+0x12>
mov    $0x0,%eax
pop    %rbx
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
send_help (void)
{
  struct sendlist *s;
  for (s = Sendlist; s->name; s++)
    {
      if (s->help)
 printf ("%-15s %s\n", s->name, s->help);
    }
  return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 4
6 6
7 6
8 6
9 7
10 7
11 7
12 4
13 4
14 4
15 4
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  402 <gsl_sf_bessel_Jnu+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     428 <gsl_sf_bessel_Jnu+0x32>
mov    %eax,%ecx
mov    $0xb8,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  421 <gsl_sf_bessel_Jnu+0x2b>
movsd  (%rsp),%xmm0
jmp    428 <gsl_sf_bessel_Jnu+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_Jnu(const double nu, const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_Jnu_e(nu, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_Jnu_e(nu, x, &result)", "bessel_Jnu.c", 184, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
callq  fc9 <skip_struct+0xe>
cmp    $0x104,%eax
jne    fdc <skip_struct+0x21>
mov    $0x0,%eax
callq  fda <skip_struct+0x1f>
jmp    fe9 <skip_struct+0x2e>
cmpl   $0x3b,0x0(%rip)        # fe3 <skip_struct+0x28>
je     1069 <skip_struct+0xae>
mov    0x0(%rip),%eax        # fef <skip_struct+0x34>
cmp    $0x102,%eax
je     ffb <skip_struct+0x40>
cmp    $0x7b,%eax
jne    105d <skip_struct+0xa2>
mov    $0x1,%edx
mov    $0x7d,%esi
mov    $0x7b,%edi
callq  100f <skip_struct+0x54>
cmp    $0xffffffff,%eax
jne    105d <skip_struct+0xa2>
mov    $0x0,%edi
callq  101e <skip_struct+0x63>
mov    $0x0,%esi
mov    %rax,%rdi
callq  3d2 <file_error>
jmp    1069 <skip_struct+0xae>
mov    $0x0,%edx
mov    $0x29,%esi
mov    $0x28,%edi
callq  1041 <skip_struct+0x86>
cmp    $0xffffffff,%eax
jne    105d <skip_struct+0xa2>
mov    $0x0,%edi
callq  1050 <skip_struct+0x95>
mov    $0x0,%esi
mov    %rax,%rdi
callq  3d2 <file_error>
cmpl   $0x110,0x0(%rip)        # 1067 <skip_struct+0xac>
je     102d <skip_struct+0x72>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
skip_struct()
{
     if (nexttoken() == 260) {
   nexttoken();
     } else if (tok.type == ';')
   return;
     if (tok.type == '{' || tok.type == 258) {
   if (skip_balanced('{', '}', 1) == -1) {
        file_error(gettext("unexpected end of file in struct"), ((void *)0));
        return;
   }
     }
     while (tok.type == 272) {
   if (skip_balanced('(', ')', 0) == -1)
       file_error(gettext("unexpected end of file in struct"), ((void *)0));
     }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 9
26 9
27 10
28 14
29 14
30 14
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 15
39 13
40 13
41 17
42 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
lea    0x5(%rbx),%r12
test   %eax,%eax
cmovne %rbx,%r12
mov    %r12,%rdi
callq  35 <cleanup_session+0x35>
test   %eax,%eax
je     49 <cleanup_session+0x49>
mov    $0x0,%edx
mov    %rdx,%rsi
mov    %r12,%rdi
callq  49 <cleanup_session+0x49>
mov    $0x1b6,%esi
mov    %rbx,%rdi
callq  56 <cleanup_session+0x56>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  68 <cleanup_session+0x68>
mov    $0x1b6,%esi
mov    %ebp,%edi
callq  74 <cleanup_session+0x74>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %ebp,%edi
callq  85 <cleanup_session+0x85>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cleanup_session (char *tty, int pty_fd)
{
  char *line;
  if (strncmp (tty, "/dev/", sizeof "/dev/" - 1) == 0)
    line = tty + sizeof "/dev/" - 1;
  else
    line = tty;
  if (logout (line))
    logwtmp (line, "", "");
  chmod (tty, 0666);
  chown (tty, 0, 0);
  fchmod (pty_fd, 0666);
  fchown (pty_fd, 0, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 11
29 11
30 11
31 11
32 12
33 12
34 12
35 13
36 13
37 13
38 13
39 14
40 14
41 14
42 14
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
<<<sep_in_sample>>>
topsf_get_format_desc(TOPSF * topsf)
{
 return topsf->format_desc_;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsbl %sil,%esi
mov    0x30(%rdi),%rdi
callq  2f9 <xformat_set_filetype_from_tartype+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xformat_set_filetype_from_tartype (XFORMAT * xux, char s)
{
 ;
        ahs_set_filetype_from_tartype(xux->ahsM, s);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x4(%rdi),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  316 <print_packet_too_big+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
print_packet_too_big (struct icmp6_hdr *icmp6)
{
  printf ("Packet too big, mtu=%d\n", icmp6->icmp6_dataun.icmp6_un_data32[0]);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <send_brk+0x9>
callq  e <send_brk+0xe>
mov    0x0(%rip),%rax        # 15 <send_brk+0x15>
test   %rax,%rax
je     1f <send_brk+0x1f>
movzbl (%rax),%edi
jmp    24 <send_brk+0x24>
mov    $0x1c,%edi
callq  29 <send_brk+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_brk (void)
{
  ptyflush ();
  init_termbuf ();
  pty_output_byte (slctab[7].sptr ?
     (unsigned char) *slctab[7].sptr : '\034');
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  134 <string_eq+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
string_eq (const void *elt1, const void *elt2)
{
  return strcmp ((const char *)elt1, (const char *)elt2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 1c78 <find_function+0xb>
callq  8d4 <hash_lookup>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
find_function (name)
     const char *name;
{
  return (hash_lookup (name, shell_functions));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
movzbl (%rdi),%ebx
test   %bl,%bl
je     85 <is_all_digits+0x31>
callq  69 <is_all_digits+0x15>
mov    (%rax),%rdx
jmp    7a <is_all_digits+0x26>
add    $0x1,%rbp
movzbl 0x0(%rbp),%ebx
test   %bl,%bl
je     85 <is_all_digits+0x31>
movsbq %bl,%rax
testb  $0x8,0x1(%rdx,%rax,2)
jne    6e <is_all_digits+0x1a>
test   %bl,%bl
sete   %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
is_all_digits(char * value)
{
 char * w = value;
 while (*w && ((*__ctype_b_loc ())[(int) ((*w))] & (unsigned short int) _ISdigit)) w++;
 if (*w == '\0') return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 5
20 5
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a38 <yyget_in+0x7>
retq   
<<<sep_in_sample>>>
yyget_in (void)
{
        return yyin;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # cc <nettle_gcm_aes256_decrypt+0x26>
mov    %rax,%rsi
callq  d4 <nettle_gcm_aes256_decrypt+0x2e>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
nettle_gcm_aes256_decrypt(struct gcm_aes256_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes256_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_decrypt(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes256_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
test   $0x1,%dl
jne    f90 <string_hex_to_bin+0x97>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%r13
mov    %edx,%eax
shr    $0x1f,%eax
add    %eax,%edx
sar    %edx
test   %edx,%edx
jle    f96 <string_hex_to_bin+0x9d>
mov    %rdi,%r14
lea    -0x1(%rdx),%eax
lea    0x1(%rdi,%rax,1),%r15
mov    %rdi,%rbx
mov    %ebx,%ebp
sub    %r14d,%ebp
add    %ebp,%ebp
movslq %ebp,%rbp
movzbl 0x0(%r13,%rbp,1),%esi
mov    $0x11,%edx
mov    $0x0,%edi
callq  f4d <string_hex_to_bin+0x54>
mov    %rax,%r12
test   %rax,%rax
je     f9d <string_hex_to_bin+0xa4>
movzbl 0x1(%r13,%rbp,1),%esi
mov    $0x11,%edx
mov    $0x0,%edi
callq  f6a <string_hex_to_bin+0x71>
test   %rax,%rax
je     fa4 <string_hex_to_bin+0xab>
sub    $0x0,%rax
sub    $0x0,%r12
shl    $0x4,%r12d
add    %r12d,%eax
mov    %al,(%rbx)
add    $0x1,%rbx
cmp    %r15,%rbx
jne    f2e <string_hex_to_bin+0x35>
jmp    fab <string_hex_to_bin+0xb2>
mov    $0xffffffff,%eax
retq   
mov    $0x0,%eax
jmp    fb0 <string_hex_to_bin+0xb7>
mov    $0xfffffffe,%eax
jmp    fb0 <string_hex_to_bin+0xb7>
mov    $0xfffffffe,%eax
jmp    fb0 <string_hex_to_bin+0xb7>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
string_hex_to_bin (unsigned char *output, unsigned char *input, int inlen)
{
  int i;
  unsigned char *p, *q;
  if (inlen % 2)
    return -1;
  inlen /= 2;
  p = input;
  q = output;
  for (i = 0; i < inlen; i++)
    {
      char *c1, *c2;
      if (!(c1 = memchr (xlet, p[i << 1], sizeof xlet))
   || !(c2 = memchr (xlet, p[(i << 1) + 1], sizeof xlet)))
 return -2;
      q[i] = ((c1 - xlet) << 4) + (c2 - xlet);
    }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 7
12 7
13 7
14 7
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 14
33 14
34 14
35 14
36 14
37 14
38 16
39 16
40 16
41 16
42 16
43 16
44 10
45 10
46 10
47 6
48 19
49 18
50 18
51 15
52 15
53 15
54 15
55 18
56 19
57 19
58 19
59 19
60 19
61 19
62 19
63 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdx,%rbp
mov    %rcx,%r12
mov    %r8,%r13
mov    %r9,%rbx
callq  1b <gsl_stats_long_double_pvariance+0x1b>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  2f <gsl_stats_long_double_pvariance+0x2f>
mov    %rbp,%rax
sub    $0x1,%rax
js     3f <gsl_stats_long_double_pvariance+0x3f>
cvtsi2sd %rax,%xmm1
jmp    54 <gsl_stats_long_double_pvariance+0x54>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
mulsd  0x8(%rsp),%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     6a <gsl_stats_long_double_pvariance+0x6a>
cvtsi2sd %rax,%xmm2
jmp    7f <gsl_stats_long_double_pvariance+0x7f>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
mulsd  %xmm2,%xmm0
addsd  %xmm1,%xmm0
lea    -0x2(%rbp,%rbx,1),%rax
test   %rax,%rax
js     98 <gsl_stats_long_double_pvariance+0x98>
cvtsi2sd %rax,%xmm1
jmp    ad <gsl_stats_long_double_pvariance+0xad>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_pvariance (const long double data1[],
                               const size_t stride1, const size_t n1,
                               const long double data2[],
                               const size_t stride2, const size_t n2)
{
  const double var1 = gsl_stats_long_double_variance (data1, stride1, n1);
  const double var2 = gsl_stats_long_double_variance (data2, stride2, n2);
  const double pooled_variance =
    (((n1 - 1) * var1) + ((n2 - 1) * var2)) / (n1 + n2 - 2);
  return pooled_variance;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 8
53 11
54 11
55 11
56 11
57 11
58 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <clean+0x9>
callq  e <clean+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
clean(void)
{
 unload_gpath();
 cache_close();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
retq   
<<<sep_in_sample>>>
xformat_get_format(XFORMAT * xux)
{
 ;
 return (int)(xux->format_codeM);
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  144 <xdr_dis_timestamp+0x9>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xdr_dis_timestamp(XDR * xdrs, dis_timestamp * objp)
{
 if (!xdr_u_long(xdrs, (unsigned long *) objp)) {
  return ((0));
 }
 return (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 7
7 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 816 <gsl_matrix_ptr+0xb>
je     863 <gsl_matrix_ptr+0x58>
cmp    %rsi,(%rdi)
ja     83d <gsl_matrix_ptr+0x32>
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  836 <gsl_matrix_ptr+0x2b>
mov    $0x0,%eax
jmp    873 <gsl_matrix_ptr+0x68>
cmp    %rdx,0x8(%rdi)
ja     863 <gsl_matrix_ptr+0x58>
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  85c <gsl_matrix_ptr+0x51>
mov    $0x0,%eax
jmp    873 <gsl_matrix_ptr+0x68>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
mov    0x18(%rdi),%rax
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_double.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_double.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (double *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 9
14 9
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 14
23 14
24 14
25 14
26 15
27 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  253 <compute_int_variance>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_stats_int_variance_with_fixed_mean (const int data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_int_variance (data, stride, n, mean);
  return variance;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1ca <jobserver_enabled+0x6>
not    %eax
shr    $0x1f,%eax
retq   
<<<sep_in_sample>>>
jobserver_enabled (void)
{
  return job_fds[0] >= 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
mov    $0x2b,%edx
mov    %rsp,%rsi
callq  99a <cachedir_file_p+0x21>
mov    $0x0,%edx
cmp    $0x2b,%rax
jne    9bf <cachedir_file_p+0x46>
mov    $0x2b,%edx
mov    $0x0,%esi
mov    %rsp,%rdi
callq  9b7 <cachedir_file_p+0x3e>
test   %eax,%eax
sete   %dl
movzbl %dl,%edx
mov    %edx,%eax
and    $0x1,%eax
mov    0x38(%rsp),%rcx
xor    %fs:0x28,%rcx
je     9d9 <cachedir_file_p+0x60>
callq  9d9 <cachedir_file_p+0x60>
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
cachedir_file_p (int fd)
{
  char tagbuf[(sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)];
  return
    (read (fd, tagbuf, (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)) == (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)
     && memcmp (tagbuf, "Signature: 8a477f597d28d172789f06886806bc55", (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)) == 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 4
19 4
20 7
21 7
22 7
23 7
24 7
25 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  379 <fputs_nl+0x9>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  386 <fputs_nl+0x16>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
fputs_nl(const char *s, FILE *op)
{
 fputs(s, op);
 _IO_putc ('\n', op);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 6
9 6
<<<sep_out_sample>>>
sub    $0x88,%rsp
mov    %rsp,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  54 <remove_output_file+0x19>
mov    0x0(%rip),%edi        # 5a <remove_output_file+0x1f>
test   %edi,%edi
js     77 <remove_output_file+0x3c>
movl   $0xffffffff,0x0(%rip)        # 68 <remove_output_file+0x2d>
callq  6d <remove_output_file+0x32>
mov    $0x0,%edi
callq  77 <remove_output_file+0x3c>
mov    $0x0,%edx
mov    %rsp,%rsi
mov    $0x2,%edi
callq  89 <remove_output_file+0x4e>
add    $0x88,%rsp
retq   
<<<sep_in_sample>>>
remove_output_file ()
{
  int fd;
  sigset_t oldset;
  sigprocmask (0, &caught_signals, &oldset);
  fd = remove_ofname_fd;
  if (0 <= fd)
    {
      remove_ofname_fd = -1;
      close (fd);
      xunlink (ofname);
    }
  sigprocmask (2, &oldset, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 7
8 7
9 9
10 10
11 11
12 11
13 13
14 13
15 13
16 13
17 14
18 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    $0xa,%edi
callq  e <main+0xe>
mov    %rax,%r12
callq  16 <main+0x16>
mov    %rax,%rbp
cmpq   $0x0,(%rax)
je     6d <main+0x6d>
mov    %rax,%rbx
jmp    3a <main+0x3a>
cmp    %rbx,%rbp
je     3a <main+0x3a>
mov    0x0(%rip),%rsi        # 30 <main+0x30>
mov    $0xa,%edi
callq  3a <main+0x3a>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  45 <main+0x45>
test   %rax,%rax
jne    54 <main+0x54>
mov    $0x11,%edi
callq  54 <main+0x54>
mov    0x0(%rip),%rsi        # 5b <main+0x5b>
mov    %rax,%rdi
callq  63 <main+0x63>
add    $0x20,%rbx
cmpq   $0x0,(%rbx)
jne    24 <main+0x24>
mov    $0x0,%edi
callq  77 <main+0x77>
<<<sep_in_sample>>>
main (int argc, char ** argv ) {
 STROB * buf = strob_open(10);
 char * function;
 struct shell_lib_function * farray;
 struct shell_lib_function * f;
 farray = shlib_get_function_array();
 f = farray;
 while(f->nameM) {
  if (f != farray) {
   fprintf(stdout, "\n");
  }
  function = shlib_get_function_text(f, buf);
  if (function == ((void *)0)) {
   exit(17);
  }
  fprintf(stdout, "%s", function);
  f++;
 }
 exit(0);
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 2
5 2
6 2
7 6
8 6
9 8
10 8
11 7
12 7
13 9
14 9
15 10
16 10
17 10
18 12
19 12
20 12
21 13
22 13
23 14
24 14
25 16
26 16
27 16
28 17
29 8
30 8
31 19
32 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rcx
mov    %rdx,%rsi
mov    $0xffffffffffffffff,%rdx
lea    0x8(%rsp),%rdi
callq  bbb <decode_num>
test   %al,%al
je     c45 <volume_size_decoder+0x2b>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rip)        # c45 <volume_size_decoder+0x2b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
volume_size_decoder (struct tar_stat_info *st,
       char const *keyword,
       char const *arg, size_t size)
{
  uintmax_t u;
  if (decode_num (&u, arg, ((uintmax_t) (! (! ((uintmax_t) 0 < (uintmax_t) -1)) ? (uintmax_t) -1 : ((((uintmax_t) 1 << (sizeof (uintmax_t) * 8 - 2)) - 1) * 2 + 1))), keyword))
    continued_file_size = u;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 7
10 7
11 8
12 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbp
mov    0x70(%rbp),%rdi
test   %rdi,%rdi
je     3835 <free_workarea_compile+0x24>
mov    (%rdi),%rbx
callq  382b <free_workarea_compile+0x1a>
test   %rbx,%rbx
je     3835 <free_workarea_compile+0x24>
mov    %rbx,%rdi
jmp    3823 <free_workarea_compile+0x12>
movq   $0x0,0x70(%rbp)
movl   $0xf,0x80(%rbp)
movq   $0x0,0x68(%rbp)
mov    0x20(%rbp),%rdi
callq  3858 <free_workarea_compile+0x47>
movq   $0x0,0x20(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
free_workarea_compile (regex_t *preg)
{
  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
  bin_tree_storage_t *storage, *next;
  for (storage = dfa->str_tree_storage; storage; storage = next)
    {
      next = storage->next;
      free (storage);
    }
  dfa->str_tree_storage = ((void *)0);
  dfa->str_tree_storage_idx = ((1024 - sizeof (void *)) / sizeof (bin_tree_t));
  dfa->str_tree = ((void *)0);
  free (dfa->org_indices);
  dfa->org_indices = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 5
7 5
8 7
9 8
10 5
11 5
12 5
13 5
14 10
15 11
16 12
17 13
18 13
19 14
20 15
21 15
22 15
23 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     c0a <gsl_matrix_float_fread+0x43>
shl    $0x2,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     c4b <gsl_matrix_float_fread+0x84>
jmp    c21 <gsl_matrix_float_fread+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  c1f <gsl_matrix_float_fread+0x58>
jmp    c4b <gsl_matrix_float_fread+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  c39 <gsl_matrix_float_fread+0x72>
test   %eax,%eax
jne    c4b <gsl_matrix_float_fread+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    c21 <gsl_matrix_float_fread+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_float_fread (FILE * stream, gsl_matrix_float * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_float_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_float_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  10f1 <gsl_sort_vector_int_largest_index+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_int_largest_index (size_t * p, const size_t k,
                                          const gsl_vector_int * v)
{
  return gsl_sort_int_largest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 7 <set_layout_default+0x7>
jne    13 <set_layout_default+0x13>
movl   $0x1,0x0(%rip)        # 13 <set_layout_default+0x13>
repz retq 
<<<sep_in_sample>>>
set_layout_default(void)
{
  if (layout != NO_LAYOUT) return;
  layout = ONE_ON_ONE;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0x1,%esi
callq  488 <ck_fread+0x19>
mov    %rax,%rbx
test   %rax,%rax
jne    4ae <ck_fread+0x3f>
mov    %rbp,%rdi
callq  498 <ck_fread+0x29>
test   %eax,%eax
je     4ae <ck_fread+0x3f>
mov    $0x0,%edi
callq  4a6 <ck_fread+0x37>
mov    %rax,%rdi
callq  3df <perror_fatal>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
ck_fread (char *buf, size_t size, FILE *f)
{
  size_t r = fread_unlocked (buf,sizeof (char),size,f);
  if (r == 0 && ferror_unlocked (f))
    perror_fatal (gettext ("read failed"));
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
dummy_solve(const gsl_vector * g, gsl_vector *x,
            const void * vtrust_state, void *vstate)
{
  (void) g;
  (void) x;
  (void) vtrust_state;
  (void) vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 9
2 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x20,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  778 <seek_warn_details+0x23>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 781 <seek_warn_details+0x2c>
test   %rax,%rax
je     788 <seek_warn_details+0x33>
callq  *%rax
mov    %rsp,%rsi
mov    %r12,%rdi
callq  793 <seek_warn_details+0x3e>
mov    %rax,%r12
mov    %rbp,%rdi
callq  79e <seek_warn_details+0x49>
mov    %rax,%rbp
mov    $0x0,%edi
callq  7ab <seek_warn_details+0x56>
mov    %r12,%r8
mov    %rbp,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  7c5 <seek_warn_details+0x70>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
je     7da <seek_warn_details+0x85>
callq  7da <seek_warn_details+0x85>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
seek_warn_details (char const *name, off_t offset)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot seek to %s"), quotearg_colon (name), umaxtostr (offset, buf)); } while (0)
                                  ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    %rdx,%r9
shr    %r9
je     a88 <gsl_vector_ulong_reverse+0x42>
shl    $0x3,%rsi
sub    $0x1,%rdx
imul   %rsi,%rdx
add    %rax,%rdx
mov    $0x0,%ecx
mov    (%rdx),%rdi
mov    (%rax),%r8
mov    %r8,(%rdx)
mov    %rdi,(%rax)
add    $0x1,%rcx
sub    %rsi,%rdx
add    %rsi,%rax
cmp    %r9,%rcx
jne    a6d <gsl_vector_ulong_reverse+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_reverse (gsl_vector_ulong * v)
{
  unsigned long * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          unsigned long tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 8
6 8
7 14
8 14
9 14
10 14
11 8
12 14
13 15
14 15
15 16
16 8
17 8
18 8
19 8
20 8
21 20
22 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    %rdx,%rbp
callq  140 <nettle_buffer_write+0x11>
mov    %rax,%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     15d <nettle_buffer_write+0x2e>
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  158 <nettle_buffer_write+0x29>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nettle_buffer_write(struct nettle_buffer *buffer,
      size_t length, const uint8_t *data)
{
  uint8_t *p = nettle_buffer_space(buffer, length);
  if (p)
    {
      memcpy(p, data, length);
      return 1;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 11
9 5
10 5
11 7
12 7
13 7
14 8
15 12
16 12
17 12
18 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
cmpq   $0x0,0x0(%rip)        # 624 <grecs_include_path_setup_v+0x11>
jne    637 <grecs_include_path_setup_v+0x24>
mov    $0x0,%eax
callq  630 <grecs_include_path_setup_v+0x1d>
mov    %rax,0x0(%rip)        # 637 <grecs_include_path_setup_v+0x24>
mov    $0x0,%eax
callq  641 <grecs_include_path_setup_v+0x2e>
mov    %rax,0x0(%rip)        # 648 <grecs_include_path_setup_v+0x35>
test   %rbp,%rbp
je     67f <grecs_include_path_setup_v+0x6c>
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     67f <grecs_include_path_setup_v+0x6c>
mov    $0x0,%ebx
callq  660 <grecs_include_path_setup_v+0x4d>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 66a <grecs_include_path_setup_v+0x57>
callq  66f <grecs_include_path_setup_v+0x5c>
add    $0x1,%ebx
movslq %ebx,%rax
mov    0x0(%rbp,%rax,8),%rdi
test   %rdi,%rdi
jne    65b <grecs_include_path_setup_v+0x48>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_include_path_setup_v (char **dirs)
{
  if (!include_path)
    include_path = pp_list_create ();
  std_include_path = pp_list_create ();
  if (dirs)
    {
      int i;
      for (i = 0; dirs[i]; i++)
 gl_list_add_last (std_include_path, xstrdup (dirs[i]));
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 9
24 9
25 9
26 9
27 9
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4146 <swc_is_option_true+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swc_is_option_true(char * s)
{
 return swlib_is_option_true(s);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
movsd  (%rsi),%xmm0
movsd  %xmm0,0x60(%rdi)
mov    0x8(%rsi),%rax
mov    %eax,0x70(%rdi)
mov    0x10(%rsi),%eax
mov    %eax,0x74(%rdi)
mov    0x14(%rsi),%eax
mov    %eax,0x68(%rdi)
mov    0x18(%rsi),%eax
mov    %eax,0x6c(%rdi)
mov    0x20(%rsi),%rax
mov    %rax,0xc0(%rdi)
retq   
<<<sep_in_sample>>>
gsl_monte_vegas_params_set (gsl_monte_vegas_state * s, const gsl_monte_vegas_params * p)
{
  s->alpha = p->alpha;
  s->iterations = p->iterations;
  s->stage = p->stage;
  s->mode = p->mode;
  s->verbose = p->verbose;
  s->ostream = p->ostream;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdx,%r12
test   %rdi,%rdi
jne    335 <localtime_rz+0x28>
mov    %rdx,%rsi
mov    %rbx,%rdi
callq  330 <localtime_rz+0x23>
mov    %rax,%rbx
jmp    391 <localtime_rz+0x84>
callq  1fd <set_tz>
mov    %rax,%r13
test   %rax,%rax
je     37b <localtime_rz+0x6e>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  34d <localtime_rz+0x40>
mov    %rax,%rbx
test   %rax,%rax
je     389 <localtime_rz+0x7c>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  b0 <save_abbr>
mov    %eax,%ebx
mov    %r13,%rdi
callq  2a5 <revert_tz>
test   %al,%al
je     382 <localtime_rz+0x75>
test   %bl,%bl
mov    $0x0,%ebx
cmovne %r12,%rbx
jmp    391 <localtime_rz+0x84>
mov    $0x0,%ebx
jmp    391 <localtime_rz+0x84>
mov    $0x0,%ebx
jmp    391 <localtime_rz+0x84>
mov    %r13,%rdi
callq  2a5 <revert_tz>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
{
  if (!tz)
    return gmtime_r (t, tm);
  else
    {
      timezone_t old_tz = set_tz (tz);
      if (old_tz)
        {
          _Bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);
          if (revert_tz (old_tz) && abbr_saved)
            return tm;
        }
      return ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 7
17 7
18 8
19 8
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 11
43 11
44 16
45 16
46 16
47 16
48 16
49 16
50 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rcx
mov    $0x1,%edx
mov    %edi,%esi
mov    $0x0,%edi
callq  ca2 <report_file_err>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nonfatal_target_file_error (int errno_value, const char *name)
{
  report_file_err (0, errno_value, 1, name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %esi,%ebx
mov    %rdx,%rbp
movq   $0x0,(%rdx)
lea    0xa0(%rdi),%r12
mov    %r12,%rdi
callq  1f <osip_message_get_call_info+0x1f>
mov    $0xffffffff,%edx
cmp    %ebx,%eax
jle    38 <osip_message_get_call_info+0x38>
mov    %ebx,%esi
mov    %r12,%rdi
callq  32 <osip_message_get_call_info+0x32>
mov    %rax,0x0(%rbp)
mov    %ebx,%edx
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
osip_message_get_call_info (const osip_message_t * sip, int pos, osip_call_info_t ** dest)
{
  osip_call_info_t *call_info;
  *dest = ((void *)0);
  if (osip_list_size (&sip->call_infos) <= pos)
    return -1;
  call_info = (osip_call_info_t *) osip_list_get (&sip->call_infos, pos);
  *dest = call_info;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 6
11 5
12 5
13 7
14 7
15 7
16 8
17 9
18 10
19 10
20 10
21 10
22 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  d25 <gsl_sf_bessel_i2_scaled+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     d4b <gsl_sf_bessel_i2_scaled+0x32>
mov    %eax,%ecx
mov    $0x142,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d44 <gsl_sf_bessel_i2_scaled+0x2b>
movsd  (%rsp),%xmm0
jmp    d4b <gsl_sf_bessel_i2_scaled+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_i2_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_i2_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_i2_scaled_e(x, &result)", "bessel_i.c", 322, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <__rtan+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rtan (double r)
{
  return (tan (r));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     192 <readpipe+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    $0x1,%edi
callq  0 <openpipe>
mov    $0x0,%esi
mov    %eax,%edi
callq  1d7 <readpipe+0xa0>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
readpipe (char *progname, ...)
{
  va_list ap;
  int fd;
  __builtin_va_start(ap,progname);
  fd = openpipe (1, progname, ap);
  __builtin_va_end(ap);
  return fdopen (fd, "r");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 8
28 8
29 8
30 9
31 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  99a <meta1_string+0x11>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  9a5 <meta1_string+0x1c>
mov    $0x0,%eax
callq  9af <meta1_string+0x26>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
meta1_string (const char *str, size_t len)
{
  meta1_line_begin ();
  meta1_line_add (str, len);
  return meta1_line_finish ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     46b <gsasl_server_callback_cram_md5_get+0xd>
mov    0x98(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_cram_md5_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_cram_md5 : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2659 <php_set_lineno+0x6>
retq   
<<<sep_in_sample>>>
php_set_lineno (int line_number )
{
    php_lineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
cmpq   $0x0,0x40(%rdi)
je     81 <rec_sex_ast_node_destroy+0x29>
mov    $0x0,%ebx
mov    0x28(%rbp,%rbx,8),%rdi
callq  77 <rec_sex_ast_node_destroy+0x1f>
add    $0x1,%rbx
cmp    %rbx,0x40(%rbp)
ja     6d <rec_sex_ast_node_destroy+0x15>
mov    0x0(%rbp),%eax
cmp    $0x1a,%eax
jne    94 <rec_sex_ast_node_destroy+0x3c>
mov    0x8(%rbp),%rdi
callq  92 <rec_sex_ast_node_destroy+0x3a>
jmp    ab <rec_sex_ast_node_destroy+0x53>
cmp    $0x1b,%eax
jne    ab <rec_sex_ast_node_destroy+0x53>
mov    0x8(%rbp),%rdi
callq  a2 <rec_sex_ast_node_destroy+0x4a>
mov    0x10(%rbp),%rdi
callq  ab <rec_sex_ast_node_destroy+0x53>
mov    0x20(%rbp),%rdi
callq  b4 <rec_sex_ast_node_destroy+0x5c>
mov    %rbp,%rdi
callq  bc <rec_sex_ast_node_destroy+0x64>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_sex_ast_node_destroy (rec_sex_ast_node_t node)
{
  size_t i;
  for (i = 0; i < node->num_children; i++)
    {
      rec_sex_ast_node_destroy (node->children[i]);
    }
  if (node->type == REC_SEX_STR)
    {
      free (node->val.string);
    }
  else if (node->type == REC_SEX_NAME)
    {
      free (node->val.name[0]);
      free (node->val.name[1]);
    }
  free (node->fixed_val);
  free (node);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 6
10 4
11 4
12 4
13 8
14 8
15 8
16 10
17 10
18 10
19 12
20 12
21 14
22 14
23 15
24 15
25 17
26 17
27 18
28 18
29 19
30 19
31 19
32 19
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x410,%rsp
mov    %edi,%ebx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %fs:0x28,%rax
mov    %rax,0x408(%rsp)
xor    %eax,%eax
mov    %rsp,%rdi
mov    $0x80,%ecx
rep stos %rax,%es:(%rdi)
cmpl   $0x0,0x0(%rip)        # 203 <cdio_logv+0x38>
je     221 <cdio_logv+0x56>
mov    $0x0,%r8d
mov    $0x66,%cl
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x5,%edi
callq  221 <cdio_logv+0x56>
movl   $0x1,0x0(%rip)        # 22b <cdio_logv+0x60>
mov    %r12,%rcx
mov    %rbp,%rdx
mov    $0x3ff,%esi
mov    %rsp,%rdi
callq  23e <cdio_logv+0x73>
mov    %rsp,%rsi
mov    %ebx,%edi
callq  *0x0(%rip)        # 249 <cdio_logv+0x7e>
movl   $0x0,0x0(%rip)        # 253 <cdio_logv+0x88>
mov    0x408(%rsp),%rax
xor    %fs:0x28,%rax
je     26b <cdio_logv+0xa0>
callq  26b <cdio_logv+0xa0>
add    $0x410,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cdio_logv(cdio_log_level_t level, const char format[], va_list args)
{
  char buf[1024] = { 0, };
  static int in_recursion = 0;
  if (in_recursion)
    { cdio_log (CDIO_LOG_ASSERT, "file %s: line %d (%s): should not be reached", "logging.c", 102, __PRETTY_FUNCTION__); };
  in_recursion = 1;
  vsnprintf(buf, sizeof(buf)-1, format, args);
  _handler(level, buf);
  in_recursion = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 3
14 5
15 5
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 10
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  60d <sh_get_env_value+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sh_get_env_value (const char* v)
{
  return getenv(v);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
add    (%rdi),%rax
mov    $0x0,%edx
div    %rsi
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
incl_hasher (void const *data, size_t n_buckets)
{
  const struct input_file_ident *id = data;
  return (id->i_node + id->device) % n_buckets;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%esi
mov    $0x1,%edi
callq  13 <_cdio_list_new+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_cdio_list_new (void)
{
  CdioList_t *p_new_obj = calloc (1, sizeof (CdioList_t));
  return p_new_obj;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
cmpb   $0x0,(%rdi)
je     f0 <mu_ltrim_cset+0x77>
mov    %rsi,%r12
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,%r13
je     e8 <mu_ltrim_cset+0x6f>
mov    $0x0,%ebx
jmp    b8 <mu_ltrim_cset+0x3f>
add    $0x1,%rbx
cmp    %r13,%rbx
je     cf <mu_ltrim_cset+0x56>
movsbl 0x0(%rbp,%rbx,1),%esi
mov    %r12,%rdi
callq  c5 <mu_ltrim_cset+0x4c>
test   %rax,%rax
jne    af <mu_ltrim_cset+0x36>
test   %rbx,%rbx
je     ed <mu_ltrim_cset+0x74>
sub    %rbx,%r13
lea    0x1(%r13),%rdx
lea    0x0(%rbp,%rbx,1),%rsi
mov    %rbp,%rdi
callq  e3 <mu_ltrim_cset+0x6a>
mov    %r13,%rax
jmp    f0 <mu_ltrim_cset+0x77>
mov    %rcx,%rax
jmp    f0 <mu_ltrim_cset+0x77>
mov    %r13,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_ltrim_cset (char *str, const char *cset)
{
  size_t i, len;
  if (!*str)
    return 0;
  len = strlen (str);
  for (i = 0; i < len && strchr (cset, str[i]) != ((void *)0); i++)
    ;
  if (i)
    {
      len -= i;
      memmove (str, str + i, len + 1);
    }
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 4
9 4
10 4
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 9
28 9
29 11
30 12
31 12
32 12
33 12
34 11
35 11
36 6
37 6
38 6
39 15
40 15
41 15
42 15
43 15
44 15
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 19af <ppdget_debug+0x6>
retq   
<<<sep_in_sample>>>
ppdget_debug (void)
{
        return ppd_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
<<<sep_in_sample>>>
rec_sex_ast_node_index (rec_sex_ast_node_t node)
{
  return node->index;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
jb     31 <gsl_cdf_poisson_P+0x31>
mov    $0x1,%ecx
mov    $0x38,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  27 <gsl_cdf_poisson_P+0x27>
movsd  0x0(%rip),%xmm0        # 2f <gsl_cdf_poisson_P+0x2f>
jmp    4d <gsl_cdf_poisson_P+0x4d>
mov    %edi,%edi
cvtsi2sd %rdi,%xmm3
movsd  0x0(%rip),%xmm1        # 40 <gsl_cdf_poisson_P+0x40>
movapd %xmm1,%xmm2
addsd  %xmm3,%xmm1
callq  4d <gsl_cdf_poisson_P+0x4d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_poisson_P (const unsigned int k, const double mu)
{
  double P;
  double a;
  if (mu <= 0.0)
    {
      do { gsl_error ("mu <= 0", "poisson.c", 56, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) k + 1.0;
  P = gsl_cdf_gamma_Q (mu, a, 1.0);
  return P;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 10
17 10
18 12
19 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbx
cmp    $0x2,%rbx
jbe    2b1 <smtp_reply_set+0x4b>
lea    -0x2(%rbx),%r13
lea    (%rsi,%r13,1),%rdi
mov    $0x2,%edx
mov    $0x0,%esi
callq  2ab <smtp_reply_set+0x45>
test   %eax,%eax
cmove  %r13,%rbx
lea    0x3(%rbx),%rsi
mov    %rbp,%rdi
callq  0 <smtp_reply_alloc_space>
mov    0x0(%rbp),%rdi
mov    %rbx,%rdx
mov    %r12,%rsi
callq  2cc <smtp_reply_set+0x66>
mov    %rbx,%rax
add    0x0(%rbp),%rax
movw   $0xa0d,(%rax)
lea    0x2(%rbx),%rax
mov    %rax,0x10(%rbp)
mov    0x0(%rbp),%rax
movb   $0x0,0x2(%rax,%rbx,1)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  be <smtp_reply_scan>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
smtp_reply_set (ANUBIS_SMTP_REPLY reply, const char *input)
{
  size_t len = strlen (input);
  if (len > 2 && memcmp (input + len - 2, "\r\n", 2) == 0)
    len -= 2;
  smtp_reply_alloc_space (reply, len + 3);
  memcpy (reply->buffer, input, len);
  memcpy (reply->buffer + len, "\r\n", 2);
  reply->reply_length = len + 2;
  reply->buffer[reply->reply_length] = 0;
  smtp_reply_scan (reply, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 8
31 8
32 8
33 9
34 9
35 10
36 10
37 11
38 11
39 11
40 12
41 12
42 12
43 12
44 12
45 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
sub    0x30(%rdi),%rax
cmp    0x20(%rdi),%rax
jbe    17a <argp_fmtstream_set_wmargin+0x1f>
callq  17a <argp_fmtstream_set_wmargin+0x1f>
mov    0x18(%rbx),%rax
mov    %rbp,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)
{
  size_t __old;
  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)
    _argp_fmtstream_update (__fs);
  __old = __fs->wmargin;
  __fs->wmargin = __wmargin;
  return __old;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
callq  82 <symevt_hash+0x9>
repz retq 
<<<sep_in_sample>>>
symevt_hash(void *data, unsigned long hashsize)
{
 struct symevt *sym = data;
 return hash_string(sym->name, hashsize);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
<<<sep_out_sample>>>
testb  $0x2,0x0(%rip)        # c2 <left_dir+0x7>
je     e5 <left_dir+0x2a>
mov    0x0(%rip),%edi        # ca <left_dir+0xf>
test   %edi,%edi
js     e5 <left_dir+0x2a>
sub    $0x8,%rsp
callq  d7 <left_dir+0x1c>
movl   $0xffffffff,0x0(%rip)        # e1 <left_dir+0x26>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
left_dir (void)
{
  if (ftsoptions & 0x0200)
    {
      if (curr_fd >= 0)
 {
   close (curr_fd);
   curr_fd = -1;
 }
    }
  else
    {
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 2
7 7
8 8
9 14
10 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x0,0x0(%rip)        # 30a <gsl_matrix_complex_ptr+0xb>
je     357 <gsl_matrix_complex_ptr+0x58>
cmp    %rsi,(%rdi)
ja     331 <gsl_matrix_complex_ptr+0x32>
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  32a <gsl_matrix_complex_ptr+0x2b>
mov    $0x0,%eax
jmp    36a <gsl_matrix_complex_ptr+0x6b>
cmp    %rdx,0x8(%rdi)
ja     357 <gsl_matrix_complex_ptr+0x58>
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  350 <gsl_matrix_complex_ptr+0x51>
mov    $0x0,%eax
jmp    36a <gsl_matrix_complex_ptr+0x6b>
mov    %rsi,%rax
imul   0x10(%rdi),%rax
add    %rdx,%rax
shl    $0x4,%rax
add    0x18(%rdi),%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_ptr(gsl_matrix_complex * m,
                             const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_double.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_double.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 15
23 15
24 15
25 15
26 15
27 16
28 16
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x38,%rsp
movsd  %xmm0,0x20(%rsp)
mov    %edi,%ebx
mov    %esi,%ebp
cvtsi2sd %edi,%xmm1
cvtsi2sd %esi,%xmm0
divsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
movapd %xmm1,%xmm0
callq  d50 <fpoint+0x2b>
movsd  %xmm0,0x18(%rsp)
movsd  0x8(%rsp),%xmm1
movapd %xmm1,%xmm6
addsd  %xmm1,%xmm6
movsd  %xmm6,(%rsp)
movsd  0x0(%rip),%xmm0        # d71 <fpoint+0x4c>
xorpd  %xmm6,%xmm6
movsd  %xmm6,0x10(%rsp)
jmpq   ea9 <fpoint+0x184>
mov    %ebp,%esi
mov    %ebx,%edi
movsd  (%rsp),%xmm0
callq  d8e <fpoint+0x69>
movapd %xmm0,%xmm6
movsd  %xmm0,0x28(%rsp)
movsd  0x20(%rsp),%xmm0
movsd  0x18(%rsp),%xmm5
subsd  %xmm5,%xmm0
movsd  (%rsp),%xmm1
movsd  0x8(%rsp),%xmm7
subsd  %xmm7,%xmm1
mulsd  %xmm1,%xmm0
movapd %xmm6,%xmm1
subsd  %xmm5,%xmm1
divsd  %xmm1,%xmm0
addsd  %xmm7,%xmm0
movsd  %xmm0,0x10(%rsp)
xorpd  %xmm6,%xmm6
ucomisd %xmm0,%xmm6
jbe    e11 <fpoint+0xec>
movsd  (%rsp),%xmm7
ucomisd 0x8(%rsp),%xmm7
jbe    dfe <fpoint+0xd9>
movsd  0x8(%rsp),%xmm6
mulsd  0x0(%rip),%xmm6        # df6 <fpoint+0xd1>
movsd  %xmm6,0x10(%rsp)
jmp    e11 <fpoint+0xec>
movsd  (%rsp),%xmm7
mulsd  0x0(%rip),%xmm7        # e0b <fpoint+0xe6>
movsd  %xmm7,0x10(%rsp)
mov    %ebp,%esi
mov    %ebx,%edi
movsd  0x10(%rsp),%xmm0
callq  e20 <fpoint+0xfb>
movapd %xmm0,%xmm2
movsd  0x18(%rsp),%xmm4
subsd  %xmm4,%xmm2
andpd  0x0(%rip),%xmm2        # e36 <fpoint+0x111>
movapd %xmm0,%xmm1
subsd  0x28(%rsp),%xmm1
andpd  0x0(%rip),%xmm1        # e48 <fpoint+0x123>
movapd %xmm2,%xmm3
cmpltsd %xmm1,%xmm3
andpd  %xmm3,%xmm4
andnpd %xmm0,%xmm3
orpd   %xmm4,%xmm3
movsd  %xmm3,0x18(%rsp)
movapd %xmm2,%xmm3
cmpltsd %xmm1,%xmm3
movsd  0x8(%rsp),%xmm4
andpd  %xmm3,%xmm4
movsd  0x10(%rsp),%xmm5
andnpd %xmm5,%xmm3
orpd   %xmm4,%xmm3
movsd  %xmm3,0x8(%rsp)
cmpltsd %xmm1,%xmm2
movapd %xmm5,%xmm1
andpd  %xmm2,%xmm1
movsd  (%rsp),%xmm7
andnpd %xmm7,%xmm2
orpd   %xmm1,%xmm2
movsd  %xmm2,(%rsp)
subsd  0x20(%rsp),%xmm0
andpd  0x0(%rip),%xmm0        # eb7 <fpoint+0x192>
ucomisd 0x0(%rip),%xmm0        # ebf <fpoint+0x19a>
ja     d80 <fpoint+0x5b>
movsd  0x10(%rsp),%xmm0
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
fpoint(double p, int numdf, int dendf)
{
  double pt0, pr0;
  double pt1, pr1;
  double pt2, pr2;
  pt2 = 0.0;
  pt0 = ((double) numdf) / ((double) dendf);
  pr0 = probf(pt0, numdf, dendf);
  pt1 = 2.0 * pt0;
  pr2 = 1.0;
  while (fabs(pr2 - p) > dap_prtol)
    {
      pr1 = probf(pt1, numdf, dendf);
      pt2 = pt0 + (pt1 - pt0) * (p - pr0) / (pr1 - pr0);
      if (pt2 < 0.0)
 {
   if (pt0 < pt1)
     pt2 = 0.5 * pt0;
   else
     pt2 = 0.5 * pt1;
 }
      pr2 = probf(pt2, numdf, dendf);
      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))
 {
   pr1 = pr2;
   pt1 = pt2;
 }
      else
 {
   pr0 = pr2;
   pt0 = pt2;
 }
    }
  return pt2;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 9
15 9
16 9
17 9
18 10
19 6
20 6
21 11
22 13
23 13
24 13
25 13
26 13
27 13
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
43 17
44 17
45 17
46 18
47 18
48 18
49 18
50 20
51 20
52 20
53 22
54 22
55 22
56 22
57 23
58 23
59 23
60 23
61 23
62 23
63 23
64 30
65 30
66 30
67 30
68 30
69 30
70 30
71 30
72 30
73 30
74 30
75 30
76 30
77 30
78 30
79 30
80 30
81 30
82 30
83 30
84 30
85 11
86 11
87 11
88 11
89 35
90 35
91 35
92 35
93 35
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r14
mov    %rdx,%r13
mov    %ecx,%r12d
mov    $0x18,%edi
callq  19d <dict_entry_add+0x1e>
mov    %rax,%rbx
mov    %r14,%rdi
callq  1a8 <dict_entry_add+0x29>
mov    %rax,(%rbx)
mov    %r13,%rdi
callq  1b3 <dict_entry_add+0x34>
mov    %rax,0x8(%rbx)
mov    %r12d,0x10(%rbx)
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  1c6 <dict_entry_add+0x47>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
dict_entry_add (struct hash_table_s * table,
  const char * key, const char * value, int def)
{
  dict_entry *(item) = ((dict_entry *) xmalloc (sizeof (dict_entry) * (1)));
  item->key = xstrdup (key);
  item->value = xstrdup (value);
  item->def = def;
  hash_insert (table, item);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     1f2 <initialize_input_line+0x18>
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1f0 <initialize_input_line+0x16>
jmp    1f9 <initialize_input_line+0x1f>
movb   $0x0,0x0(%rip)        # 1f9 <initialize_input_line+0x1f>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %ecx,0x0(%rip)        # 217 <initialize_input_line+0x3d>
mov    %ecx,0x0(%rip)        # 21d <initialize_input_line+0x43>
mov    %ecx,0x0(%rip)        # 223 <initialize_input_line+0x49>
pop    %rbx
retq   
<<<sep_in_sample>>>
initialize_input_line (const char *prompt)
{
  if (prompt)
    strcpy (input_line, prompt);
  else
    input_line[0] = '\0';
  input_line_beg = input_line_end = input_line_point = strlen (prompt);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 14b <yy_pop_state+0x6>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 154 <yy_pop_state+0xf>
test   %eax,%eax
jns    166 <yy_pop_state+0x21>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  11e <yy_fatal_error>
cltq   
mov    0x0(%rip),%rdx        # 16f <yy_pop_state+0x2a>
mov    (%rdx,%rax,4),%eax
lea    0x1(%rax,%rax,1),%eax
mov    %eax,0x0(%rip)        # 17c <yy_pop_state+0x37>
retq   
<<<sep_in_sample>>>
yy_pop_state (void)
{
     if ( --(yy_start_stack_ptr) < 0 )
  yy_fatal_error( "start-condition stack underflow" );
 (yy_start) = 1 + 2 *((yy_start_stack)[(yy_start_stack_ptr)]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 22a <terminal_goto_xy+0xb>
test   %rcx,%rcx
je     238 <terminal_goto_xy+0x19>
mov    $0x0,%eax
callq  *%rcx
jmp    262 <terminal_goto_xy+0x43>
mov    0x0(%rip),%rax        # 23f <terminal_goto_xy+0x20>
test   %rax,%rax
je     262 <terminal_goto_xy+0x43>
mov    %esi,%edx
mov    %edi,%esi
mov    %rax,%rdi
callq  250 <terminal_goto_xy+0x31>
mov    $0x0,%edx
mov    $0x1,%esi
mov    %rax,%rdi
callq  262 <terminal_goto_xy+0x43>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_goto_xy (int x, int y)
{
  if (terminal_goto_xy_hook)
    (*terminal_goto_xy_hook) (x, y);
  else
    {
      if (term_goto)
        tputs (tgoto (term_goto, x, y), 1, output_character_function);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 10
20 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  34e <gc_hmac_sha1+0x9>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_hmac_sha1 (const void *key, size_t keylen,
              const void *in, size_t inlen, char *resbuf)
{
  hmac_sha1 (key, keylen, in, inlen, resbuf);
  return GC_OK;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 34 <tty_isecho+0x6>
and    $0x8,%eax
retq   
<<<sep_in_sample>>>
tty_isecho (void)
{
  return termbuf.c_lflag & 0000010;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x1005,%eax
test   %rdi,%rdi
je     ff <mu_address_create_hint+0x63>
mov    %rsi,%rbp
mov    $0x16,%ax
test   %rsi,%rsi
je     ff <mu_address_create_hint+0x63>
movq   $0x0,(%rdi)
callq  c5 <mu_address_create_hint+0x29>
mov    %eax,%edx
test   %edx,%edx
jne    ff <mu_address_create_hint+0x63>
mov    (%rbx),%r12
mov    $0x1008,%eax
test   %r12,%r12
je     ff <mu_address_create_hint+0x63>
mov    %rbp,%rdi
callq  e0 <mu_address_create_hint+0x44>
mov    %rax,(%r12)
mov    (%rbx),%rdx
mov    $0x0,%eax
cmpq   $0x0,(%rdx)
jne    ff <mu_address_create_hint+0x63>
mov    %rbx,%rdi
callq  fa <mu_address_create_hint+0x5e>
mov    $0xc,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_address_create_hint (mu_address_t *a, const char *s, mu_address_t hint,
   int hflags)
{
  int status;
  if (!a)
    return (0x1000 +5);
  if (!s)
    return 22;
  *a = ((void *)0);
  status = mu_parse822_address_list (a, s, hint, hflags);
  if (status == 0)
    {
      if (!*a)
 return (0x1000 +8);
      (*a)->addr = strdup (s);
      if (!(*a)->addr)
 {
   mu_address_destroy (a);
   return 12;
 }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 5
7 5
8 5
9 8
10 7
11 7
12 9
13 10
14 10
15 11
16 11
17 13
18 14
19 13
20 13
21 15
22 15
23 15
24 16
25 22
26 16
27 16
28 18
29 18
30 19
31 23
32 23
33 23
34 23
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 2f2 <remove_alias+0x7>
test   %rsi,%rsi
je     34e <remove_alias+0x63>
push   %rbx
mov    $0x0,%edx
callq  302 <remove_alias+0x17>
mov    %rax,%rbx
test   %rax,%rax
je     354 <remove_alias+0x69>
mov    0x10(%rax),%rdi
callq  3c <free_alias_data>
mov    0x8(%rbx),%rdi
mov    $0xb6,%edx
mov    $0x0,%esi
callq  326 <remove_alias+0x3b>
mov    $0xb7,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  338 <remove_alias+0x4d>
mov    $0x0,%edi
callq  342 <remove_alias+0x57>
mov    0x0(%rip),%rax        # 349 <remove_alias+0x5e>
mov    0xc(%rax),%eax
jmp    359 <remove_alias+0x6e>
mov    $0xffffffff,%eax
retq   
mov    $0xffffffff,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
remove_alias (name)
     char *name;
{
  BUCKET_CONTENTS *elt;
  if (aliases == 0)
    return (-1);
  elt = hash_remove (name, aliases, 0);
  if (elt)
    {
      free_alias_data (elt->data);
      sh_xfree((elt->key), "alias.c", 182);
      sh_xfree((elt), "alias.c", 183);
      set_itemlist_dirty (&it_aliases);
      return (aliases->nentries);
    }
  return (-1);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 3
5 7
6 7
7 7
8 8
9 8
10 10
11 10
12 11
13 11
14 11
15 11
16 12
17 12
18 12
19 12
20 13
21 13
22 14
23 14
24 14
25 6
26 17
27 16
28 17
29 17
<<<sep_out_sample>>>
add    %rsi,0x18(%rdi)
add    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
libunistring_mbiter_multi_reloc (struct mbiter_multi *iter, ptrdiff_t ptrdiff)
{
  iter->cur.ptr += ptrdiff;
  iter->limit += ptrdiff;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpq   $0x0,0x0(%rip)        # 128 <dico_strategy_add+0xc>
jne    163 <dico_strategy_add+0x47>
callq  12f <dico_strategy_add+0x13>
mov    %rax,0x0(%rip)        # 136 <dico_strategy_add+0x1a>
mov    $0x1,%edx
test   %rax,%rax
je     19b <dico_strategy_add+0x7f>
mov    $0x0,%esi
mov    %rax,%rdi
callq  14d <dico_strategy_add+0x31>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 15e <dico_strategy_add+0x42>
callq  163 <dico_strategy_add+0x47>
mov    (%rbx),%rdi
callq  16b <dico_strategy_add+0x4f>
mov    $0x0,%edx
test   %rax,%rax
jne    19b <dico_strategy_add+0x7f>
mov    %rbx,%rdi
callq  17d <dico_strategy_add+0x61>
mov    $0x1,%edx
test   %rax,%rax
je     19b <dico_strategy_add+0x7f>
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 191 <dico_strategy_add+0x75>
callq  196 <dico_strategy_add+0x7a>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
dico_strategy_add(const dico_strategy_t strat)
{
    if (!strategy_list) {
 strategy_list = dico_list_create();
 if (!strategy_list)
     return 1;
 dico_list_set_comparator(strategy_list, dico_strat_name_cmp);
 dico_list_set_free_item(strategy_list, dico_strat_free, ((void *)0));
    }
    if (!dico_strategy_find(strat->name)) {
 dico_strategy_t new_strat = dico_strategy_dup(strat);
 if (!new_strat)
     return 1;
 dico_list_append(strategy_list, new_strat);
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 5
9 5
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 10
18 10
19 16
20 10
21 10
22 11
23 11
24 13
25 12
26 12
27 14
28 14
29 14
30 16
31 17
32 17
33 17
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r14
mov    0x18(%rdi),%r12
mov    0x28(%rdi),%rbx
lea    0x28(%rdi),%r13
cmp    %r13,%rbx
je     5c5 <gl_linked_list_free+0x3d>
mov    (%rbx),%rbp
test   %r12,%r12
je     5b3 <gl_linked_list_free+0x2b>
mov    0x10(%rbx),%rdi
callq  *%r12
mov    %rbx,%rdi
callq  5bb <gl_linked_list_free+0x33>
cmp    %r13,%rbp
je     5c5 <gl_linked_list_free+0x3d>
mov    %rbp,%rbx
jmp    5a4 <gl_linked_list_free+0x1c>
mov    %r14,%rdi
callq  5cd <gl_linked_list_free+0x45>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gl_linked_list_free (gl_list_t list)
{
  gl_listelement_dispose_fn dispose = list->base.dispose_fn;
  gl_list_node_t node;
  for (node = list->root.next; node != &list->root; )
    {
      gl_list_node_t next = node->next;
      if (dispose != ((void *)0))
 dispose (node->value);
      free (node);
      node = next;
    }
  free (list);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 5
9 5
10 5
11 5
12 7
13 8
14 8
15 9
16 9
17 10
18 10
19 5
20 5
21 11
22 11
23 13
24 13
25 14
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%r8
test   %rsi,%rsi
je     7f5 <gsl_vector_complex_add_constant+0x4e>
shl    $0x4,%r8
mov    $0x0,%eax
mov    $0x0,%edx
mov    %rax,%rcx
add    0x10(%rdi),%rcx
movapd %xmm0,%xmm2
addsd  (%rcx),%xmm2
movsd  %xmm2,(%rcx)
mov    0x10(%rdi),%rcx
lea    0x8(%rcx,%rax,1),%rcx
movapd %xmm1,%xmm2
addsd  (%rcx),%xmm2
movsd  %xmm2,(%rcx)
add    $0x1,%rdx
add    %r8,%rax
cmp    %rsi,%rdx
jne    7c1 <gsl_vector_complex_add_constant+0x1a>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_complex_add_constant (gsl_vector_complex * a, const gsl_complex x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  double xr = ((x).dat[0]);
  double xi = ((x).dat[1]);
  for (i = 0; i < N; i++)
    {
      a->data[2 * i * stride] += xr;
      a->data[2 * i * stride + 1] += xi;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 8
4 8
5 10
6 10
7 8
8 10
9 10
10 10
11 10
12 10
13 11
14 11
15 11
16 11
17 11
18 8
19 8
20 8
21 8
22 14
23 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  4f3 <anubis_child_main+0x9>
mov    0x0(%rip),%eax        # 4f9 <anubis_child_main+0xf>
test   %eax,%eax
je     504 <anubis_child_main+0x1a>
cmp    $0x3,%eax
je     512 <anubis_child_main+0x28>
jmp    51e <anubis_child_main+0x34>
mov    %rbx,%rdi
callq  50c <anubis_child_main+0x22>
mov    %eax,%ebx
xchg   %ax,%ax
jmp    523 <anubis_child_main+0x39>
mov    %rbx,%rdi
callq  51a <anubis_child_main+0x30>
mov    %eax,%ebx
jmp    523 <anubis_child_main+0x39>
callq  523 <anubis_child_main+0x39>
mov    $0x0,%edi
callq  52d <anubis_child_main+0x43>
mov    $0x0,%edi
callq  537 <anubis_child_main+0x4d>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
anubis_child_main (struct sockaddr_in *addr)
{
  int rc;
  proclist_init ();
  switch (anubis_mode)
    {
    case anubis_transparent:
      rc = anubis_transparent_mode (addr);
      break;
    case anubis_proxy:
      rc = anubis_proxy_mode (addr);
      break;
    default:
      abort();
    }
  proclist_cleanup (subprocess_report_status);
  net_close_stream (&remote_client);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 9
15 11
16 11
17 11
18 12
19 14
20 16
21 16
22 17
23 17
24 19
25 19
26 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x158,%rsp
mov    %rdi,%rbp
mov    %esi,%edi
mov    %fs:0x28,%rax
mov    %rax,0x148(%rsp)
xor    %eax,%eax
mov    0x0(%rip),%rdx        # 23e8 <set_proc_title+0x28>
mov    (%rdx),%rbx
movl   $0x80,0x1c(%rsp)
lea    0x1c(%rsp),%rdx
lea    0xc0(%rsp),%rsi
callq  2405 <set_proc_title+0x45>
test   %eax,%eax
jne    2478 <set_proc_title+0xb8>
movl   $0x1,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%r8d
mov    $0x50,%ecx
lea    0x70(%rsp),%rdx
mov    $0x80,%esi
lea    0xc0(%rsp),%rdi
callq  2438 <set_proc_title+0x78>
test   %eax,%eax
jne    245a <set_proc_title+0x9a>
lea    0x70(%rsp),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x50,%esi
lea    0x20(%rsp),%rdi
callq  2458 <set_proc_title+0x98>
jmp    2494 <set_proc_title+0xd4>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x50,%esi
lea    0x20(%rsp),%rdi
mov    $0x0,%eax
callq  2476 <set_proc_title+0xb6>
jmp    2494 <set_proc_title+0xd4>
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x50,%esi
lea    0x20(%rsp),%rdi
mov    $0x0,%eax
callq  2494 <set_proc_title+0xd4>
mov    0x0(%rip),%rdx        # 249b <set_proc_title+0xdb>
sub    %rbx,%rdx
lea    0x20(%rsp),%rsi
mov    %rbx,%rdi
callq  24ab <set_proc_title+0xeb>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rbx,%rcx,1),%rax
cmp    0x0(%rip),%rax        # 24cb <set_proc_title+0x10b>
jae    24de <set_proc_title+0x11e>
add    $0x1,%rax
movb   $0x20,-0x1(%rax)
cmp    %rax,0x0(%rip)        # 24dc <set_proc_title+0x11c>
ja     24cd <set_proc_title+0x10d>
mov    0x148(%rsp),%rax
xor    %fs:0x28,%rax
je     24f6 <set_proc_title+0x136>
callq  24f6 <set_proc_title+0x136>
add    $0x158,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
set_proc_title (char *a, int s)
{
  socklen_t size;
  char *cp;
  struct sockaddr_storage saddr;
  char buf[80];
  cp = Argv[0];
  size = sizeof saddr;
  if (getpeername (s, (struct sockaddr *) &saddr, &size) == 0)
    {
      int err;
      char buf2[80];
      err = getnameinfo ((struct sockaddr *) &saddr, sizeof (saddr), buf2,
    sizeof (buf2), ((void *)0), 0, 1);
      if (!err)
 snprintf (buf, sizeof buf, "-%s [%s]", a, buf2);
      else
 snprintf (buf, sizeof buf, "-%s", a);
    }
  else
    snprintf (buf, sizeof buf, "-%s", a);
  strncpy (cp, buf, LastArg - cp);
  cp += strlen (cp);
  while (cp < LastArg)
    *cp++ = ' ';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 7
10 7
11 8
12 9
13 9
14 9
15 9
16 9
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 18
35 18
36 18
37 18
38 18
39 18
40 18
41 21
42 21
43 21
44 21
45 21
46 21
47 22
48 22
49 22
50 22
51 22
52 23
53 23
54 23
55 23
56 23
57 23
58 24
59 24
60 25
61 25
62 24
63 24
64 26
65 26
66 26
67 26
68 26
69 26
70 26
71 26
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    0x30(%rdi),%rdi
callq  36e <xformat_set_group_systempair+0x13>
mov    %eax,%ebx
test   %eax,%eax
je     38d <xformat_set_group_systempair+0x32>
mov    %rbp,%rdi
callq  37c <xformat_set_group_systempair+0x21>
test   %eax,%eax
jne    38d <xformat_set_group_systempair+0x32>
mov    0x30(%r12),%rdi
mov    %rbp,%rsi
callq  38d <xformat_set_group_systempair+0x32>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
xformat_set_group_systempair(XFORMAT * xux, char * name)
{
 int ret;
 ret = ahs_set_group_systempair(xux->ahsM, name);
 if (ret && is_all_digits(name) == 0) {
  ahs_set_tar_groupname(xux->ahsM, name);
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 1db <mu_folder_directory+0x8>
jne    1e8 <mu_folder_directory+0x15>
movq   $0x0,0x0(%rip)        # 1e8 <mu_folder_directory+0x15>
mov    0x0(%rip),%rax        # 1ef <mu_folder_directory+0x1c>
retq   
<<<sep_in_sample>>>
mu_folder_directory ()
{
  if (!_mu_folder_dir)
    _mu_folder_dir = _default_folder_dir;
  return _mu_folder_dir;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
<<<sep_out_sample>>>
movzbl (%rdi),%eax
cmp    $0x3a,%al
je     47d <colon+0x2f>
test   %al,%al
je     483 <colon+0x35>
cmp    $0x2f,%al
jne    46c <colon+0x1e>
nopl   (%rax)
jmp    489 <colon+0x3b>
cmp    $0x3a,%dl
je     48f <colon+0x41>
cmp    $0x2f,%dl
je     493 <colon+0x45>
add    $0x1,%rdi
movzbl (%rdi),%edx
test   %dl,%dl
jne    462 <colon+0x14>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    %rdi,%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
colon (char *cp)
{
  if (*cp == ':')
    return (0);
  for (; *cp; ++cp)
    {
      if (*cp == ':')
 return (cp);
      if (*cp == '/')
 return (0);
    }
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 9
7 9
8 9
9 9
10 7
11 7
12 9
13 9
14 5
15 5
16 5
17 5
18 12
19 12
20 4
21 4
22 12
23 12
24 10
25 10
26 5
27 5
28 10
29 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x18,%edi
callq  1a0 <grecs_list_push+0x16>
mov    %rbp,0x10(%rax)
mov    $0x0,%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1b9 <grecs_list_push+0x2f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_list_push(struct grecs_list *lp, void *val)
{
 struct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));
 ep->data = val;
 grecs_list_insert_entry(lp, ((void *)0), ep, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x1005,%eax
test   %rdi,%rdi
je     43 <mu_debug_create+0x43>
mov    %rsi,%rbp
mov    $0x1,%esi
mov    $0x48,%edi
callq  25 <mu_debug_create+0x25>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     43 <mu_debug_create+0x43>
movq   $0x0,0x38(%rdx)
mov    %rbp,0x10(%rdx)
mov    %rdx,(%rbx)
mov    $0x0,%al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_debug_create (mu_debug_t *pdebug, void *owner)
{
  mu_debug_t debug;
  if (pdebug == ((void *)0))
    return (0x1000 +5);
  debug = calloc (sizeof (*debug), 1);
  if (debug == ((void *)0))
    return 12;
  debug->printer = ((void *)0);
  debug->owner = owner;
  *pdebug = debug;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 8
14 7
15 7
16 9
17 10
18 11
19 12
20 13
21 13
22 13
23 13
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdx
mov    0x8(%rsi),%rdi
lea    (%rdi,%rdi,1),%rcx
mov    (%rsi),%rsi
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_real (gsl_vector_complex * v)
{
  gsl_vector s = {0, 0, 0, 0, 0};
  s.data = v->data;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
testb  $0x2,0x8(%rdi)
jne    68e <dump_symbol+0x58>
mov    %rsi,%rbp
cmpl   $0x0,0x18(%rdi)
je     68e <dump_symbol+0x58>
mov    (%rsi),%r12
mov    0x20(%r12),%rax
sub    0x18(%r12),%rax
cmp    $0x7,%rax
jg     66c <dump_symbol+0x36>
mov    $0x8,%esi
mov    %r12,%rdi
callq  66c <dump_symbol+0x36>
addq   $0x8,0x18(%r12)
mov    0x0(%rbp),%rax
mov    0x10(%rax),%rax
mov    %rax,0x8(%rbp)
mov    0x10(%rbp),%edx
lea    0x1(%rdx),%ecx
mov    %ecx,0x10(%rbp)
movslq %edx,%rdx
mov    %rbx,(%rax,%rdx,8)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dump_symbol (symbol *sym, void *arg)
{
  struct dump_symbol_data *data = (struct dump_symbol_data *) arg;
  if (!((sym)->shadowed) && (((&(sym)->data)->type)) != TOKEN_VOID)
    {
      __extension__ ({ struct obstack *__o = (data->obs); int __len = (sizeof (symbol *)); if (__o->chunk_limit - __o->next_free < __len) _obstack_newchunk (__o, __len); ((__o)->next_free += (__len)); (void) 0; });
      data->base = (symbol **) ((void *) (data->obs)->object_base);
      data->base[data->size++] = sym;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
start_output_bmp (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     669 <mu_record_list_p+0x27>
mov    0x60(%rdi),%rcx
mov    $0x1,%al
test   %rcx,%rcx
je     669 <mu_record_list_p+0x27>
sub    $0x8,%rsp
callq  *%rcx
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_record_list_p (mu_record_t record, const char *name, int flags)
{
  if (record == ((void *)0))
    return 22;
  return record == ((void *)0)
          || !record->_list_p
          || record->_list_p (record, name, flags);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 6
5 7
6 6
7 6
8 2
9 7
10 7
11 7
12 7
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  25c5 <ylex+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ylex(void)
{
  long i;
  i=yylex();
  return(i);
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 10c <nindexof+0x8>
test   %rbx,%rbx
je     126 <nindexof+0x22>
movsbl %dil,%esi
mov    %rbx,%rdi
callq  11d <nindexof+0x19>
test   %rax,%rax
je     12d <nindexof+0x29>
sub    %ebx,%eax
jmp    132 <nindexof+0x2e>
mov    $0xffffffff,%eax
jmp    132 <nindexof+0x2e>
mov    $0xffffffff,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
nindexof(char chr)
{
  if(!_string) return -1;
  str j = strchr(_string, chr);
  if(j) { return j-_string; _string = ++j; }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 3
13 3
14 6
15 7
16 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 82 <grecs_text_table+0x7>
movq   $0x0,0x0(%rip)        # 8d <grecs_text_table+0x12>
retq   
<<<sep_in_sample>>>
grecs_text_table()
{
 struct grecs_symtab *tmp = text_table;
 text_table = ((void *)0);
 return tmp;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
mov    (%rdi),%rsi
cmp    %rsi,0x8(%rdi)
cmovbe 0x8(%rdi),%rsi
test   %rsi,%rsi
je     1f1c <gsl_matrix_float_add_diagonal+0x51>
lea    0x4(,%rax,4),%r8
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
movss  (%rcx),%xmm1
cvtps2pd %xmm1,%xmm1
addsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,(%rcx)
add    $0x1,%rax
add    %r8,%rdx
cmp    %rsi,%rax
jne    1ef2 <gsl_matrix_float_add_diagonal+0x27>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_float_add_diagonal (gsl_matrix_float * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 8
6 8
7 10
8 10
9 8
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 8
19 8
20 8
21 8
22 13
23 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     2e4 <meta1_flush_buffer+0x4f>
movl   $0x0,0x20(%rdi)
mov    0x8(%rdi),%rax
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
mov    %rax,0x10(%rdi)
movl   $0x1,0x2c(%rdi)
movl   $0x0,0x3c(%rdi)
mov    0x0(%rip),%rax        # 2cd <meta1_flush_buffer+0x38>
test   %rax,%rax
je     2e4 <meta1_flush_buffer+0x4f>
mov    0x0(%rip),%rdx        # 2d9 <meta1_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
jne    2e4 <meta1_flush_buffer+0x4f>
callq  c0 <meta1_load_buffer_state>
repz retq 
<<<sep_in_sample>>>
meta1_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  meta1_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 7
8 8
9 8
10 9
11 10
12 11
13 11
14 11
15 11
16 11
17 11
18 12
19 12
<<<sep_out_sample>>>
mov    %rsi,0x58(%rdi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rk4imp_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  rk4imp_state_t *state = (rk4imp_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x30,%edi
callq  496 <_rl_keyseq_cxt_alloc+0xe>
movl   $0x0,0x8(%rax)
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0xc(%rax)
mov    0x0(%rip),%rdx        # 4b8 <_rl_keyseq_cxt_alloc+0x30>
mov    %rdx,0x20(%rax)
movl   $0x2a,0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_keyseq_cxt_alloc ()
{
  _rl_keyseq_cxt *cxt;
  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));
  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;
  cxt->okey = 0;
  cxt->ocxt = _rl_kscxt;
  cxt->childval = 42;
  return cxt;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 6
8 7
9 7
10 8
11 10
12 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    625 <gsl_blas_zcopy+0x2d>
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  61e <gsl_blas_zcopy+0x26>
mov    $0x0,%eax
jmp    643 <gsl_blas_zcopy+0x4b>
mov    $0x13,%ecx
mov    $0x17c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  63e <gsl_blas_zcopy+0x46>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_zcopy (const gsl_vector_complex * X, gsl_vector_complex * Y)
{
  if (X->size == Y->size)
    {
      cblas_zcopy (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                   ((int)(Y->stride)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 380, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 11
15 11
16 11
17 11
18 11
19 11
20 13
21 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5c <gc_cipher_close+0x9>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gc_cipher_close (gc_cipher_handle handle)
{
  _gc_cipher_ctx *ctx = handle;
  free (ctx);
  return GC_OK;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  4d2 <ck_strdup+0x1d>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  4dd <ck_strdup+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
ck_strdup(str)
  const char *str;
{
  char *ret = (ck_malloc((strlen(str)+1)*sizeof(char)));
  return strcpy(ret, str);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    0x0(%rip),%rdi        # 85b <str_to_config_syntax+0xe>
test   %rdi,%rdi
je     88b <str_to_config_syntax+0x3e>
mov    %rsi,%r12
mov    $0x0,%ebx
mov    %rbp,%rsi
callq  870 <str_to_config_syntax+0x23>
test   %eax,%eax
jne    87d <str_to_config_syntax+0x30>
mov    0x8(%rbx),%edx
mov    %edx,(%r12)
jmp    897 <str_to_config_syntax+0x4a>
add    $0x10,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    868 <str_to_config_syntax+0x1b>
jmp    892 <str_to_config_syntax+0x45>
mov    $0x1,%eax
jmp    897 <str_to_config_syntax+0x4a>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
str_to_config_syntax (const char *str, enum config_syntax *psynt)
{
  struct config_syntax_descr *p;
  for (p = config_syntax_tab; p->name; p++)
    if (strcmp (p->name, str) == 0)
      {
 *psynt = p->type;
 return 0;
      }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 7
15 7
16 8
17 4
18 4
19 4
20 4
21 4
22 10
23 10
24 10
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  c07 <parse_nogroup+0xe>
movl   $0x38d1b717,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_nogroup (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) &argv;
  (void) &arg_ptr;
  our_pred = insert_primary (entry, ((void *)0));
  our_pred->est_success_rate = 1e-4;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 9
6 9
7 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # e <handle_sigwinch+0x6>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 17 <handle_sigwinch+0xf>
retq   
<<<sep_in_sample>>>
handle_sigwinch(int signal)
{
    sigwinch_counter++;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <do_nothing+0xe>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_nothing(const char *name)
{
  (void) name;
  printf("stdin is buffered in the default way\n");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rdx,%r12
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
neg    %rcx
mov    %rcx,%rdi
callq  72 <rl_quote_filename+0x23>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 7c <rl_quote_filename+0x2d>
movzbl (%rax),%eax
mov    %al,(%rbx)
lea    0x1(%rbx),%rdi
mov    %rbp,%rsi
callq  8d <rl_quote_filename+0x3e>
test   %r12,%r12
je     a0 <rl_quote_filename+0x51>
mov    0x0(%rip),%rax        # 99 <rl_quote_filename+0x4a>
movzbl (%rax),%eax
mov    %al,(%r12)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
rl_quote_filename (s, rtype, qcp)
     char *s;
     int rtype;
     char *qcp;
{
  char *r;
  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 10
20 10
21 11
22 11
23 11
24 13
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
callq  15e <find_absolute_program+0x10>
test   $0x1,%al
je     1a5 <find_absolute_program+0x57>
test   $0x1,%bpl
jne    172 <find_absolute_program+0x24>
test   $0x8,%bpl
je     1ac <find_absolute_program+0x5e>
test   $0x2,%al
je     1b3 <find_absolute_program+0x65>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
mov    $0x202,%edx
mov    $0x0,%esi
callq  198 <find_absolute_program+0x4a>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1a3 <find_absolute_program+0x55>
jmp    1b8 <find_absolute_program+0x6a>
mov    $0x0,%eax
jmp    1b8 <find_absolute_program+0x6a>
mov    $0x0,%eax
jmp    1b8 <find_absolute_program+0x6a>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
find_absolute_program (name, flags)
     const char *name;
     int flags;
{
  int st;
  st = file_status (name);
  if ((st & 0x1) == 0)
    return ((char *)((void *)0));
  if ((flags & 0x1) || ((flags & 0x8) && (st & 0x2)))
    return ((char *)strcpy (sh_xmalloc((1 + strlen (name)), "findcmd.c", 514), (name)));
  return (((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 9
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 8
29 8
30 11
31 11
32 11
33 12
34 12
35 12
36 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x141,%edx
mov    $0x0,%esi
mov    (%rdi),%rdi
callq  5b8 <hash_dispose+0x16>
mov    $0x142,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  5ca <hash_dispose+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
hash_dispose (table)
     HASH_TABLE *table;
{
  sh_xfree((table->bucket_array), "hashlib.c", 321);
  sh_xfree((table), "hashlib.c", 322);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x1,%ebx
cmpb   $0x0,0x0(%rip)        # 784 <cd_stop+0x12>
je     7c6 <cd_stop+0x54>
mov    %rdi,%rbp
test   %rdi,%rdi
je     7c6 <cd_stop+0x54>
mov    $0x0,%edi
callq  b <action>
movb   $0xff,0x0(%rip)        # 79f <cd_stop+0x2d>
mov    %rbp,%rdi
callq  7a7 <cd_stop+0x35>
test   %eax,%eax
sete   %bl
je     7b8 <cd_stop+0x46>
mov    $0x0,%edi
callq  5e4 <xperror>
cmpb   $0x0,0x0(%rip)        # 7bf <cd_stop+0x4d>
je     7c6 <cd_stop+0x54>
callq  878 <display_tracks>
mov    %ebx,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cd_stop(CdIo_t *p_cdio)
{
  _Bool b_ok = 1;
  if (b_cd && p_cdio) {
    action("stop...");
    i_last_audio_track = CDIO_INVALID_TRACK;
    b_ok = DRIVER_OP_SUCCESS == cdio_audio_stop(p_cdio);
    if ( !b_ok )
      xperror("stop");
    if (b_all_tracks) display_tracks();
  }
  return b_ok;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 7
14 7
15 7
16 8
17 8
18 9
19 9
20 10
21 10
22 10
23 13
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     93 <osip_mutex_unlock+0x10>
sub    $0x8,%rsp
callq  91 <osip_mutex_unlock+0xe>
jmp    99 <osip_mutex_unlock+0x16>
mov    $0xfffffffe,%eax
retq   
add    $0x8,%rsp
nopl   (%rax)
retq   
<<<sep_in_sample>>>
osip_mutex_unlock (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return -2;
  return pthread_mutex_unlock (mut);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 5
7 5
8 7
9 7
10 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 15da <yyget_debug+0x6>
retq   
<<<sep_in_sample>>>
yyget_debug (void)
{
        return yy_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%eax
shl    $0x4,%eax
xor    0x8(%rdi),%eax
retq   
<<<sep_in_sample>>>
directory_contents_hash_1 (const void *key_0)
{
  const struct directory_contents *key = key_0;
  unsigned long hash;
  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) key->ino;
  return hash;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x3,%edi
callq  10e <mu_verror+0x14>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_verror (const char *fmt, va_list ap)
{
  mu_diag_voutput (3, fmt, ap);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     513 <valid_nameref_value+0x3f>
mov    %esi,%ebp
mov    $0x0,%eax
cmpb   $0x0,(%rdi)
je     51f <valid_nameref_value+0x4b>
callq  4f3 <valid_nameref_value+0x1f>
test   %eax,%eax
jne    51a <valid_nameref_value+0x46>
cmp    $0x2,%ebp
je     51f <valid_nameref_value+0x4b>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  509 <valid_nameref_value+0x35>
test   %eax,%eax
setne  %al
movzbl %al,%eax
jmp    51f <valid_nameref_value+0x4b>
mov    $0x0,%eax
jmp    51f <valid_nameref_value+0x4b>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
valid_nameref_value (name, flags)
     char *name;
     int flags;
{
  if (name == 0 || *name == 0)
    return 0;
  if (legal_identifier (name) || (flags != 2 && valid_array_reference (name, 0)))
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 6
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 6
24 6
25 8
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
movl   $0x0,0xc(%rsp)
mov    $0x16,%eax
test   %rdi,%rdi
je     13c <mu_attribute_set_flags+0x63>
mov    %esi,%ebp
lea    0xc(%rsp),%rsi
callq  100 <mu_attribute_set_flags+0x27>
mov    %ebp,%eax
and    0xc(%rsp),%eax
cmp    %ebp,%eax
je     137 <mu_attribute_set_flags+0x5e>
mov    0x18(%rbx),%rax
test   %rax,%rax
je     125 <mu_attribute_set_flags+0x4c>
mov    %ebp,%esi
mov    %rbx,%rdi
callq  *%rax
test   %eax,%eax
je     128 <mu_attribute_set_flags+0x4f>
mov    $0x0,%eax
jmp    13c <mu_attribute_set_flags+0x63>
or     %ebp,0x8(%rbx)
mov    %rbx,%rdi
callq  130 <mu_attribute_set_flags+0x57>
mov    $0x0,%eax
jmp    13c <mu_attribute_set_flags+0x63>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_attribute_set_flags (mu_attribute_t attr, int flags)
{
  int status = 0;
  int oflags = 0;
  if (attr == ((void *)0))
    return 22;
  mu_attribute_get_flags (attr, &oflags);
  if ((oflags & flags) == flags)
    return 0;
  if (attr->_set_flags)
    status = attr->_set_flags (attr, flags);
  else
    attr->flags |= flags;
  if (status == 0)
    mu_attribute_set_modified (attr);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 6
7 5
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 14
23 14
24 16
25 16
26 13
27 15
28 15
29 16
30 16
31 9
32 17
33 17
34 17
35 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
callq  2308 <language_save_arg+0x1a>
mov    %rax,%rbp
mov    %rax,%rdi
callq  2313 <language_save_arg+0x25>
mov    %rax,%rbx
test   %rax,%rax
jne    2344 <language_save_arg+0x56>
mov    $0x0,%edi
callq  2325 <language_save_arg+0x37>
mov    %rbp,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  233f <language_save_arg+0x51>
callq  2344 <language_save_arg+0x56>
cmpl   $0x0,0x20(%rbx)
jne    235c <language_save_arg+0x6e>
movl   $0x1,0x20(%rbx)
mov    0x0(%rip),%rax        # 2358 <language_save_arg+0x6a>
mov    %rax,0x28(%rbx)
mov    0x20(%rbx),%ebp
lea    0x1(%rbp),%eax
mov    %eax,0x20(%rbx)
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
callq  2374 <language_save_arg+0x86>
movslq %ebp,%rbp
mov    %rax,0x28(%rbx,%rbp,8)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
language_save_arg (char *arg)
{
  static char horizontal_space[] = " \t";
  char *lang_name = strsep (&arg, ":");
  struct language *lang = get_language (lang_name);
  if (lang == 0)
    {
      error (0, 0, gettext ("unrecognized language: `%s'"), lang_name);
      usage ();
    }
  if (lang->lg_argc == 0)
    lang->lg_argv[lang->lg_argc++] = program_name;
  lang->lg_argv[lang->lg_argc++] = strsep (&arg, horizontal_space);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 11
24 11
25 12
26 12
27 12
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 14
37 14
38 14
39 14
<<<sep_out_sample>>>
cmp    %rsi,0x30(%rdi)
ja     42f <gl_array_get_at+0xf>
sub    $0x8,%rsp
callq  42f <gl_array_get_at+0xf>
mov    0x28(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
<<<sep_in_sample>>>
gl_array_get_at (gl_list_t list, size_t position)
{
  size_t count = list->count;
  if (!(position < count))
    abort ();
  return list->elements[position];
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 5
5 6
6 6
7 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
test   %rsi,%rsi
je     76 <osip_message_set_mime_version+0x76>
mov    %rdi,%rbp
mov    $0x0,%eax
cmpb   $0x0,(%rsi)
je     7b <osip_message_set_mime_version+0x7b>
mov    $0xfffffffb,%eax
cmpq   $0x0,0x100(%rdi)
jne    7b <osip_message_set_mime_version+0x7b>
lea    0x100(%rdi),%rdi
callq  36 <osip_message_set_mime_version+0x36>
mov    %eax,%edx
test   %edx,%edx
jne    7b <osip_message_set_mime_version+0x7b>
movl   $0x2,0x1a0(%rbp)
mov    0x100(%rbp),%rdi
mov    %rbx,%rsi
callq  55 <osip_message_set_mime_version+0x55>
mov    %eax,%ebx
test   %ebx,%ebx
je     7b <osip_message_set_mime_version+0x7b>
mov    0x100(%rbp),%rdi
callq  67 <osip_message_set_mime_version+0x67>
movq   $0x0,0x100(%rbp)
mov    %ebx,%eax
jmp    7b <osip_message_set_mime_version+0x7b>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
osip_message_set_mime_version (osip_message_t * sip, const char *hvalue)
{
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  if (sip->mime_version != ((void *)0))
    return -5;
  i = osip_content_length_init(&(sip->mime_version));
  if (i != 0)
    return i;
  sip->message_property = 2;
  i = osip_content_length_parse(sip->mime_version, hvalue);
  if (i != 0) {
    osip_content_length_free(sip->mime_version);
    sip->mime_version = ((void *)0);
    return i;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 4
10 4
11 7
12 6
13 6
14 8
15 8
16 8
17 9
18 9
19 11
20 12
21 12
22 12
23 12
24 13
25 13
26 14
27 14
28 15
29 16
30 16
31 5
32 19
33 19
34 19
35 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x30,%edi
callq  496 <_rl_keyseq_cxt_alloc+0xe>
movl   $0x0,0x8(%rax)
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0xc(%rax)
mov    0x0(%rip),%rdx        # 4b8 <_rl_keyseq_cxt_alloc+0x30>
mov    %rdx,0x20(%rax)
movl   $0x2a,0x28(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_rl_keyseq_cxt_alloc ()
{
  _rl_keyseq_cxt *cxt;
  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));
  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;
  cxt->okey = 0;
  cxt->ocxt = _rl_kscxt;
  cxt->childval = 42;
  return cxt;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 6
8 7
9 7
10 8
11 10
12 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
callq  9e8 <words_add_regex+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
words_add_regex (struct words * words, struct rule * rule)
{
  da_append (words->regexps, rule);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    $0x16,%eax
test   %rdi,%rdi
je     e62 <mu_stream_wait+0x3a>
testb  $0x1,(%rsi)
je     e47 <mu_stream_wait+0x1f>
cmpq   $0x0,0x28(%rdi)
je     e47 <mu_stream_wait+0x1f>
movl   $0x1,(%rsi)
mov    $0x0,%al
retq   
mov    0xa8(%rdi),%rcx
mov    $0x26,%eax
test   %rcx,%rcx
je     e62 <mu_stream_wait+0x3a>
sub    $0x8,%rsp
callq  *%rcx
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
mu_stream_wait (mu_stream_t stream, int *pflags, struct timeval *tvp)
{
  if (stream == ((void *)0))
    return 22;
  if ((*pflags) & 0x1)
    {
      if (stream->rbuffer.count > 0)
 {
   *pflags = 0;
   *pflags |= 0x1;
   return 0;
 }
    }
  if (stream->_wait)
    return stream->_wait (stream, pflags, tvp);
  return 38;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 5
5 5
6 7
7 7
8 10
9 11
10 17
11 14
12 16
13 14
14 14
15 2
16 15
17 17
18 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     120 <multiline_error+0x10>
addl   $0x1,0x0(%rip)        # 120 <multiline_error+0x10>
callq  125 <multiline_error+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
multiline_error (char *prefix, char *message)
{
  if (prefix != ((void *)0))
    ++error_message_count;
  multiline_warning (prefix, message);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpb   $0x0,0x50(%rdi)
jne    1c <__roboutbyte+0x1c>
mov    $0x0,%edi
callq  1c <__roboutbyte+0x1c>
cmp    $0xff,%rbp
jbe    2f <__roboutbyte+0x2f>
mov    $0x0,%edi
callq  2f <__roboutbyte+0x2f>
mov    0x48(%rbx),%rsi
mov    %ebp,%edi
callq  3a <__roboutbyte+0x3a>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__roboutbyte (__bs9FILE *p, long x)
{
  if (!((__bs1FILE *) p)->open)
    __rerror ("Outbyte: File closed");
  if ((x < 0) | (x >= 256))
    __rerror ("Outbyte: Illegal byte value");
  (void) putc ((int) x, ((__bs1FILE *) p)->file);
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 9
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    0xc0(%rdi),%rbx
test   %rbx,%rbx
je     51e <wsnode_nullelim+0x4c>
mov    0x8(%rbx),%rbp
testb  $0x40,0x10(%rbx)
je     4fb <wsnode_nullelim+0x29>
mov    (%rbx),%rax
test   %rax,%rax
je     4fb <wsnode_nullelim+0x29>
andl   $0xffffffef,0x10(%rax)
testb  $0x1,0x10(%rbx)
je     514 <wsnode_nullelim+0x42>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  c2 <wsnode_remove>
mov    %rbx,%rdi
callq  4b5 <wsnode_free>
test   %rbp,%rbp
je     51e <wsnode_nullelim+0x4c>
mov    %rbp,%rbx
jmp    4e5 <wsnode_nullelim+0x13>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
wsnode_nullelim (struct wordsplit *wsp)
{
  struct wordsplit_node *p;
  for (p = wsp->ws_head; p;)
    {
      struct wordsplit_node *next = p->next;
      if (p->flags & 0x40 && p->prev)
 p->prev->flags &= ~0x10;
      if (p->flags & 0x01)
 {
   wsnode_remove (wsp, p);
   wsnode_free (p);
 }
      p = next;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 7
10 7
11 7
12 7
13 7
14 8
15 9
16 9
17 11
18 11
19 11
20 12
21 12
22 4
23 4
24 4
25 4
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
cmp    0x0(%rip),%rdi        # 2632 <more_param+0x7>
je     2672 <more_param+0x47>
mov    0x0(%rip),%rax        # 263b <more_param+0x10>
cmp    %rdi,0x30(%rax)
je     2678 <more_param+0x4d>
test   %rdi,%rdi
je     267e <more_param+0x53>
mov    $0x2,%eax
cmpb   $0x56,0x5c(%rdi)
je     2683 <more_param+0x58>
mov    $0x1,%al
cmp    0x0(%rip),%rdi        # 265a <more_param+0x2f>
jne    2683 <more_param+0x58>
movzwl 0x58(%rdi),%edx
mov    $0x2,%al
cmp    $0xffff,%dx
je     2683 <more_param+0x58>
test   %dx,%dx
setg   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
more_param (decl_t *rd)
{
  if (rd == sluttparam)
    return (0);
  if (rd == switchparam->next)
    return (0);
  if (rd == ((void *)0))
    return (0);
  if (rd->type == 'V')
    return (2);
  if (rd == arrayparam)
    {
      if (rd->dim == -1)
 return (2);
      if (rd->dim > 0)
 return (1);
      return (0);
    }
  return (1);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 10
9 9
10 9
11 19
12 11
13 11
14 13
15 14
16 13
17 13
18 15
19 15
20 15
21 15
22 4
23 4
24 6
25 6
26 8
27 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %r8,%rbx
callq  186 <_tcp_read+0x12>
mov    $0x1004,%ecx
test   %rbx,%rbx
je     1c7 <_tcp_read+0x53>
movq   $0x0,(%rbx)
mov    $0x0,%cx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    (%rax),%edi
callq  1a8 <_tcp_read+0x34>
cmp    $0xffffffff,%eax
jne    1bd <_tcp_read+0x49>
movq   $0x0,(%rbx)
callq  1b9 <_tcp_read+0x45>
mov    (%rax),%ecx
jmp    1c7 <_tcp_read+0x53>
cltq   
mov    %rax,(%rbx)
mov    $0x0,%ecx
mov    %ecx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_tcp_read (mu_stream_t stream, char *buf, size_t buf_size,
    mu_off_t offset, size_t * br)
{
  struct _tcp_instance *tcp = mu_stream_get_owner (stream);
  int bytes;
  offset = offset;
  if (br == ((void *)0))
    return (0x1000 +4);
  *br = 0;
  if ((bytes = recv (tcp->fd, buf, buf_size, 0)) == -1)
    {
      *br = 0;
      return (*__errno_location ());
    }
  *br = bytes;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 8
9 7
10 7
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 12
20 13
21 13
22 13
23 15
24 15
25 16
26 17
27 17
28 17
29 17
30 17
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%r13d
mov    $0x0,%edi
callq  0 <__db_prinit>
mov    %rax,%rbp
mov    %r13d,%edx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  12a <CDB___db_pr+0x36>
test   %r13d,%r13d
je     1df <CDB___db_pr+0xeb>
mov    %rbp,%rcx
mov    $0x7,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  14a <CDB___db_pr+0x56>
cmp    $0x14,%r13d
mov    $0x14,%r12d
cmovbe %r13d,%r12d
test   %r12d,%r12d
jle    1ee <CDB___db_pr+0xfa>
callq  166 <CDB___db_pr+0x72>
mov    %rax,%r15
lea    -0x1(%r12),%eax
lea    0x1(%rbx,%rax,1),%r14
movzbl (%rbx),%edi
movzbl %dil,%r12d
movzbl %dil,%edx
mov    (%r15),%rax
testb  $0x40,0x1(%rax,%rdx,2)
jne    18e <CDB___db_pr+0x9a>
cmp    $0xa,%dil
jne    19c <CDB___db_pr+0xa8>
movzbl %dil,%edi
mov    %rbp,%rsi
callq  19a <CDB___db_pr+0xa6>
jmp    1b1 <CDB___db_pr+0xbd>
mov    %r12d,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  1b1 <CDB___db_pr+0xbd>
add    $0x1,%rbx
cmp    %r14,%rbx
jne    173 <CDB___db_pr+0x7f>
cmp    $0x14,%r13d
jbe    1d9 <CDB___db_pr+0xe5>
mov    %rbp,%rcx
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  1d7 <CDB___db_pr+0xe3>
jmp    1df <CDB___db_pr+0xeb>
cmp    $0xa,%r12d
je     1f6 <CDB___db_pr+0x102>
mov    %rbp,%rsi
mov    $0xa,%edi
callq  1ec <CDB___db_pr+0xf8>
jmp    1f6 <CDB___db_pr+0x102>
cmp    $0x14,%r13d
jbe    1df <CDB___db_pr+0xeb>
jmp    1c0 <CDB___db_pr+0xcc>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
CDB___db_pr(p, len)
 u_int8_t *p;
 u_int32_t len;
{
 FILE *fp;
 u_int lastch;
 int i;
 fp = __db_prinit(((void *)0));
 fprintf(fp, "len: %3lu", (u_long)len);
 lastch = '.';
 if (len != 0) {
  fprintf(fp, " data: ");
  for (i = len <= 20 ? len : 20; i > 0; --i, ++p) {
   lastch = *p;
   if (((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISprint) || *p == '\n')
    fprintf(fp, "%c", *p);
   else
    fprintf(fp, "0x%.2x", (u_int)*p);
  }
  if (len > 20) {
   fprintf(fp, "...");
   lastch = '.';
  }
 }
 if (lastch != '\n')
  fprintf(fp, "\n");
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 9
18 11
19 11
20 12
21 12
22 12
23 12
24 12
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 15
33 15
34 14
35 14
36 15
37 15
38 15
39 15
40 15
41 15
42 16
43 16
44 16
45 16
46 18
47 18
48 18
49 18
50 18
51 13
52 13
53 13
54 20
55 20
56 21
57 21
58 21
59 21
60 21
61 21
62 25
63 25
64 26
65 26
66 26
67 26
68 20
69 20
70 20
71 27
72 27
73 27
74 27
75 27
76 27
77 27
78 27
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdx,%r14
test   %rdx,%rdx
je     10c4 <gsl_block_complex_float_raw_fscanf+0x8e>
mov    %rdi,%r13
lea    0x0(,%rcx,8),%r15
lea    0x8(%rsi),%rbp
mov    $0x0,%r12d
jmp    10be <gsl_block_complex_float_raw_fscanf+0x88>
lea    0xc(%rsp),%rdx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  107a <gsl_block_complex_float_raw_fscanf+0x44>
movss  0xc(%rsp),%xmm0
movss  %xmm0,(%rbx)
cmp    $0x1,%eax
je     10a9 <gsl_block_complex_float_raw_fscanf+0x73>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10a2 <gsl_block_complex_float_raw_fscanf+0x6c>
mov    $0x5,%eax
jmp    10d0 <gsl_block_complex_float_raw_fscanf+0x9a>
add    $0x4,%rbx
cmp    %rbp,%rbx
jne    1063 <gsl_block_complex_float_raw_fscanf+0x2d>
add    $0x1,%r12
add    %r15,%rbp
cmp    %r14,%r12
je     10cb <gsl_block_complex_float_raw_fscanf+0x95>
lea    -0x8(%rbp),%rbx
jmp    1063 <gsl_block_complex_float_raw_fscanf+0x2d>
mov    $0x0,%eax
jmp    10d0 <gsl_block_complex_float_raw_fscanf+0x9a>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_block_complex_float_raw_fscanf (FILE * stream,
                                  float * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 2; k++)
        {
          float tmp;
          int status = fscanf (stream, "%g", &tmp) ;
          data [2 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 13
17 13
18 13
19 13
20 13
21 14
22 14
23 15
24 15
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 10
34 10
35 7
36 7
37 7
38 7
39 5
40 5
41 21
42 21
43 21
44 22
45 22
46 22
47 22
48 22
49 22
50 22
51 22
<<<sep_out_sample>>>
mov    0x40(%rdi),%rdx
cmp    %rsi,%rdx
ja     554 <gl_linked_get_at+0x12>
sub    $0x8,%rsp
callq  554 <gl_linked_get_at+0x12>
sub    $0x1,%rdx
mov    %rdx,%rax
shr    %rax
cmp    %rax,%rsi
ja     577 <gl_linked_get_at+0x35>
mov    0x28(%rdi),%rax
test   %rsi,%rsi
je     58a <gl_linked_get_at+0x48>
mov    (%rax),%rax
sub    $0x1,%rsi
jne    56c <gl_linked_get_at+0x2a>
jmp    58a <gl_linked_get_at+0x48>
mov    0x30(%rdi),%rax
sub    %rsi,%rdx
je     58a <gl_linked_get_at+0x48>
mov    0x8(%rax),%rax
sub    $0x1,%rdx
jne    580 <gl_linked_get_at+0x3e>
mov    0x10(%rax),%rax
retq   
<<<sep_in_sample>>>
gl_linked_get_at (gl_list_t list, size_t position)
{
  size_t count = list->count;
  gl_list_node_t node;
  if (!(position < count))
    abort ();
  if (position <= ((count - 1) / 2))
    {
      node = list->root.next;
      for (; position > 0; position--)
        node = node->next;
    }
  else
    {
      position = count - 1 - position;
      node = list->root.prev;
      for (; position > 0; position--)
        node = node->prev;
    }
  return node->value;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 2
5 6
6 7
7 7
8 7
9 7
10 7
11 9
12 10
13 10
14 11
15 10
16 10
17 10
18 16
19 17
20 17
21 18
22 17
23 17
24 20
25 21
<<<sep_out_sample>>>
mov    0x868(%rdi),%r9d
movslq %r9d,%rax
lea    0x0(,%rax,8),%r10
shl    $0x6,%rax
sub    %r10,%rax
mov    0x0(%rax),%rax
test   %rax,%rax
je     241 <doWeaponDisplay+0x47>
sub    $0x8,%rsp
movslq %r9d,%r9
shl    $0x6,%r9
sub    %r10,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x0(%r9),%rsi
callq  *%rax
jmp    25e <doWeaponDisplay+0x64>
mov    $0x0,%eax
mov    0x808(%rdi,%rax,1),%rdx
movb   $0x0,(%rdx)
add    $0x8,%rax
cmp    $0x30,%rax
jne    246 <doWeaponDisplay+0x4c>
mov    $0x0,%al
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
doWeaponDisplay(craft * c, viewer * u, int *x, int *y)
{
 int i;
 if (wtbl[c->curWeapon].display != ((void *)0))
  return (*wtbl[c->curWeapon].display) (c, wtbl[c->curWeapon].w, u, x, y);
 else {
  for (i = 0; i < 6; i++)
   strcpy(c->leftHUD[i], "");
 }
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 2
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 4
20 8
21 8
22 8
23 7
24 7
25 10
26 10
27 11
28 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
callq  3c3 <gsl_blas_izamax+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_izamax (const gsl_vector_complex * X)
{
  return cblas_izamax (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%rbx
lea    0x10(%rsp),%rdi
movsd  %xmm1,0x8(%rsp)
movsd  %xmm0,(%rsp)
callq  a6e <gamma_inc_D>
mov    %eax,%ebp
lea    0x20(%rsp),%rdi
movsd  0x8(%rsp),%xmm1
movsd  (%rsp),%xmm0
callq  0 <gamma_inc_F_CF>
movsd  0x10(%rsp),%xmm1
movsd  (%rsp),%xmm4
movapd %xmm4,%xmm2
movsd  0x8(%rsp),%xmm5
divsd  %xmm5,%xmm2
movsd  0x20(%rsp),%xmm0
movapd %xmm1,%xmm3
mulsd  %xmm2,%xmm3
mulsd  %xmm0,%xmm3
movsd  %xmm3,(%rbx)
mulsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # e73 <gamma_inc_Q_CF+0x70>
andpd  %xmm0,%xmm2
mulsd  0x18(%rsp),%xmm2
mulsd  %xmm4,%xmm1
divsd  %xmm5,%xmm1
mulsd  0x28(%rsp),%xmm1
andpd  %xmm0,%xmm1
addsd  %xmm1,%xmm2
movsd  %xmm2,0x8(%rbx)
test   %eax,%eax
cmove  %ebp,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gamma_inc_Q_CF(const double a, const double x, gsl_sf_result * result)
{
  gsl_sf_result D;
  gsl_sf_result F;
  const int stat_D = gamma_inc_D(a, x, &D);
  const int stat_F = gamma_inc_F_CF(a, x, &F);
  result->val = D.val * (a/x) * F.val;
  result->err = D.err * fabs((a/x) * F.val) + fabs(D.val * a/x * F.err);
  return ((stat_F) != GSL_SUCCESS ? (stat_F) : ((stat_D) != GSL_SUCCESS ? (stat_D) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 9
35 9
36 10
37 10
38 10
39 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %esi,%r12d
lea    0xc(%rsp),%rdx
mov    $0x0,%esi
callq  2f8 <print_qword+0x1d>
test   %r12d,%r12d
je     314 <print_qword+0x39>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  30f <print_qword+0x34>
jmpq   3af <print_qword+0xd4>
mov    %rax,%rbp
cmpb   $0x0,(%rbx)
jne    324 <print_qword+0x49>
movl   $0x1,0xc(%rsp)
cmp    0x0(%rip),%rbp        # 32b <print_qword+0x50>
jb     369 <print_qword+0x8e>
lea    0x1(%rbp),%rsi
mov    %rsi,0x0(%rip)        # 338 <print_qword+0x5d>
mov    0x0(%rip),%rdi        # 33f <print_qword+0x64>
callq  344 <print_qword+0x69>
mov    %rax,0x0(%rip)        # 34b <print_qword+0x70>
test   %rax,%rax
jne    369 <print_qword+0x8e>
mov    $0x0,%ecx
mov    $0x8f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  369 <print_qword+0x8e>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 378 <print_qword+0x9d>
callq  37d <print_qword+0xa2>
mov    0x0(%rip),%rsi        # 384 <print_qword+0xa9>
movb   $0x0,(%rsi,%rbp,1)
cmpl   $0x0,0xc(%rsp)
je     3a0 <print_qword+0xc5>
mov    $0x0,%edi
mov    $0x0,%eax
callq  39e <print_qword+0xc3>
jmp    3af <print_qword+0xd4>
mov    $0x0,%edi
mov    $0x0,%eax
callq  3af <print_qword+0xd4>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
print_qword (const char *word, int plaintext)
{
  static char *qbuf = ((void *)0);
  static size_t qlen = 0;
  int quote;
  size_t size = wordsplit_c_quoted_length (word, 0, &quote);
  if (plaintext)
    {
      printf ("%s", word);
      return;
    }
  if (*word == 0)
    quote = 1;
  if (size >= qlen)
    {
      qlen = size + 1;
      qbuf = realloc (qbuf, qlen);
      ((qbuf != ((void *)0)) ? (void) (0) : __assert_fail ("qbuf != ((void *)0)", "wsp.c", 143, __PRETTY_FUNCTION__));
    }
  wordsplit_c_quote_copy (qbuf, word, 0);
  qbuf[size] = 0;
  if (quote)
    printf ("\"%s\"", qbuf);
  else
    printf ("%s", qbuf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 12
19 12
20 13
21 14
22 14
23 16
24 16
25 17
26 17
27 17
28 18
29 18
30 18
31 18
32 18
33 18
34 18
35 20
36 20
37 20
38 20
39 21
40 21
41 22
42 22
43 23
44 23
45 23
46 23
47 25
48 25
49 25
50 26
51 26
52 26
53 26
54 26
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
retq   
<<<sep_in_sample>>>
rec_sex_ast_node_int (rec_sex_ast_node_t node)
{
  return node->val.integer;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
swlib_tty_termios(void)
{
 return(&save_termios);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  195 <compute_long_variance>
test   %rbx,%rbx
js     df8 <gsl_stats_long_sd_m+0x15>
cvtsi2sd %rbx,%xmm1
jmp    e10 <gsl_stats_long_sd_m+0x2d>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     e20 <gsl_stats_long_sd_m+0x3d>
cvtsi2sd %rax,%xmm2
jmp    e35 <gsl_stats_long_sd_m+0x52>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    e9e <gsl_stats_long_sd_m+0xbb>
test   %rbx,%rbx
js     e53 <gsl_stats_long_sd_m+0x70>
cvtsi2sd %rbx,%xmm2
jmp    e6b <gsl_stats_long_sd_m+0x88>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm2
addsd  %xmm2,%xmm2
sub    $0x1,%rbx
js     e78 <gsl_stats_long_sd_m+0x95>
cvtsi2sd %rbx,%xmm1
jmp    e8d <gsl_stats_long_sd_m+0xaa>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
callq  e9a <gsl_stats_long_sd_m+0xb7>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_stats_long_sd_m (const long data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_long_variance (data, stride, n, mean);
  const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
  return sd;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 6
57 6
58 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3f0 <gsasl_client_callback_qop_get+0xa>
mov    0x60(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_qop_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_qop : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     25 <gsasl_check_version+0x25>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <gsasl_check_version+0x13>
test   %eax,%eax
mov    $0x0,%eax
mov    $0x0,%edx
cmovle %rdx,%rax
jmp    2b <gsasl_check_version+0x2b>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.8.0") <= 0)
    return "1.8.0";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
14 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 91 <alog_remote_user+0xb>
callq  0 <print_str>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
alog_remote_user(FILE *fp, struct alog_instr *instr, int argc, char **argv)
{
    print_str(fp, user_name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0xb0(%rdi),%rdi
mov    $0x3f,%edx
callq  1263 <shcmd_set_group+0x15>
movb   $0x0,0xef(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
shcmd_set_group(SHCMD * cmd, char * name)
{
 strncpy(cmd->group_, name, sizeof(cmd->group_) - 1);
 cmd->group_[sizeof(cmd->group_) - 1] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
xorpd  %xmm0,%xmm0
ucomisd 0x28(%rsi),%xmm0
jp     12e <cholesky_rcond+0x19>
je     15c <cholesky_rcond+0x47>
mov    0x8(%rbx),%rdx
mov    (%rbx),%rcx
mov    $0x1,%esi
mov    $0x4c,%edi
callq  144 <cholesky_rcond+0x2f>
mov    0x18(%rbx),%rsi
mov    0x8(%rbx),%rdi
mov    $0x0,%edx
callq  156 <cholesky_rcond+0x41>
mov    %eax,%edx
test   %edx,%edx
jne    196 <cholesky_rcond+0x81>
mov    0x20(%rbx),%rcx
mov    0x18(%rbx),%rsi
mov    0x8(%rbx),%rdi
lea    0x8(%rsp),%rdx
callq  172 <cholesky_rcond+0x5d>
mov    %eax,%ebx
test   %ebx,%ebx
jne    196 <cholesky_rcond+0x81>
sqrtsd 0x8(%rsp),%xmm0
ucomisd %xmm0,%xmm0
jnp    18f <cholesky_rcond+0x7a>
movsd  0x8(%rsp),%xmm0
callq  18f <cholesky_rcond+0x7a>
movsd  %xmm0,0x0(%rbp)
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cholesky_rcond(double * rcond, void * vstate)
{
  int status;
  cholesky_state_t *state = (cholesky_state_t *) vstate;
  double rcond_JTJ;
  if (state->mu != 0)
    {
      gsl_matrix_tricpy('L', 1, state->work_JTJ, state->JTJ);
      status = gsl_linalg_mcholesky_decomp(state->work_JTJ, state->perm, ((void *)0));
      if (status)
        return status;
    }
  status = gsl_linalg_mcholesky_rcond(state->work_JTJ, state->perm, &rcond_JTJ, state->work3p);
  if (status == GSL_SUCCESS)
    *rcond = sqrt(rcond_JTJ);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 13
23 13
24 13
25 13
26 13
27 13
28 14
29 14
30 15
31 15
32 15
33 15
34 15
35 15
36 16
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0xcccccccccccccccd,%rsi
sub    $0x1,%rcx
mov    %rdi,%rax
mul    %rsi
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
mov    %dil,(%rcx)
mov    %rdx,%rdi
test   %rdx,%rdx
jne    12 <umaxtostr+0x12>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
umaxtostr (uintmax_t i, char *buf)
{
  char *p = buf + ((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1)) + 1);
  *p = 0;
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: ((! ((uintmax_t) 0 < (uintmax_t) -1)) == 0) ? 1 : -1; }))];
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 12
17 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  13a <xzalloc+0x9>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  14a <xzalloc+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
callq  33 <gsl_vector_complex_long_double_fwrite+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_long_double_fwrite (FILE * stream, const gsl_vector_complex_long_double * v)
{
  int status = gsl_block_complex_long_double_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
mov    0x30(%rax),%rax
mov    %rax,(%rsi)
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
imap_message_unseen (mu_mailbox_t mailbox, size_t *punseen)
{
  m_imap_t m_imap = mailbox->data;
  *punseen = m_imap->unseen;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  870 <grecs_grecs_realloc+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_grecs_realloc (void * ptr, grecs_grecs__size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    0xc0(%rdi),%rbx
test   %rbx,%rbx
je     51e <wsnode_nullelim+0x4c>
mov    0x8(%rbx),%rbp
testb  $0x40,0x10(%rbx)
je     4fb <wsnode_nullelim+0x29>
mov    (%rbx),%rax
test   %rax,%rax
je     4fb <wsnode_nullelim+0x29>
andl   $0xffffffef,0x10(%rax)
testb  $0x1,0x10(%rbx)
je     514 <wsnode_nullelim+0x42>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  c2 <wsnode_remove>
mov    %rbx,%rdi
callq  4b5 <wsnode_free>
test   %rbp,%rbp
je     51e <wsnode_nullelim+0x4c>
mov    %rbp,%rbx
jmp    4e5 <wsnode_nullelim+0x13>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
wsnode_nullelim (struct wordsplit *wsp)
{
  struct wordsplit_node *p;
  for (p = wsp->ws_head; p;)
    {
      struct wordsplit_node *next = p->next;
      if (p->flags & 0x40 && p->prev)
 p->prev->flags &= ~0x10;
      if (p->flags & 0x01)
 {
   wsnode_remove (wsp, p);
   wsnode_free (p);
 }
      p = next;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 6
9 7
10 7
11 7
12 7
13 7
14 8
15 9
16 9
17 11
18 11
19 11
20 12
21 12
22 4
23 4
24 4
25 4
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1f1 <swlib_tty_reset+0x6>
lea    -0x1(%rax),%edx
mov    $0x0,%eax
cmp    $0x1,%edx
ja     22f <swlib_tty_reset+0x44>
sub    $0x8,%rsp
mov    $0x0,%edx
mov    $0x2,%esi
callq  211 <swlib_tty_reset+0x26>
test   %eax,%eax
js     226 <swlib_tty_reset+0x3b>
movl   $0x0,0x0(%rip)        # 21f <swlib_tty_reset+0x34>
mov    $0x0,%eax
jmp    22b <swlib_tty_reset+0x40>
mov    $0xffffffff,%eax
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
swlib_tty_reset(int fd)
{
 if (ttystate != CBREAK && ttystate != RAW)
  return(0);
 if (tcsetattr(fd, 2, &save_termios) < 0)
  return(-1);
 ttystate = RESET;
 return(0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 2
7 5
8 5
9 5
10 5
11 5
12 7
13 8
14 8
15 6
16 9
17 9
<<<sep_out_sample>>>
cmpl   $0x5,0x308(%rdi)
jne    f69 <doHSI+0x16>
sub    $0x8,%rsp
callq  f65 <doHSI+0x12>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
doHSI(craft * c, viewer * u)
{
 if (c->radarMode != 5)
  return;
 doHSICompassCard(c, u);
 return;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 7
6 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
testb  $0x10,0x23d(%rdi)
je     2b4 <__bam_set_bt_maxkey+0x27>
mov    0x28(%rdi),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  2b2 <__bam_set_bt_maxkey+0x25>
jmp    2f3 <__bam_set_bt_maxkey+0x66>
mov    %esi,%ebp
mov    $0x1,%esi
callq  2c0 <__bam_set_bt_maxkey+0x33>
mov    %eax,%edx
test   %edx,%edx
jne    2f3 <__bam_set_bt_maxkey+0x66>
mov    0xc0(%rbx),%rax
test   %ebp,%ebp
jne    2eb <__bam_set_bt_maxkey+0x5e>
mov    0x28(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  2e4 <__bam_set_bt_maxkey+0x57>
mov    $0x16,%eax
jmp    2f3 <__bam_set_bt_maxkey+0x66>
mov    %ebp,0xc(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__bam_set_bt_maxkey(dbp, bt_maxkey)
 DB *dbp;
 u_int32_t bt_maxkey;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_bt_maxkey", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x01)) != 0) return (__ret); };
 t = dbp->bt_internal;
 if (bt_maxkey < 1) {
  CDB___db_err(dbp->dbenv, "minimum bt_maxkey value is 1");
  return (22);
 }
 t->bt_maxkey = bt_maxkey;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 10
22 10
23 10
24 10
25 11
26 11
27 13
28 14
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c0ee <rpl_re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # c0f5 <rpl_re_set_syntax+0xe>
retq   
<<<sep_in_sample>>>
rpl_re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = rpl_re_syntax_options;
  rpl_re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x8(%rdi),%rbx
mov    0x10(%rdi),%r12
mov    0x18(%rdi),%r10
mov    (%r10),%edi
test   %rbp,%rbp
je     1a95 <gsl_matrix_int_minmax+0x65>
shl    $0x2,%r12
lea    0x0(,%rbx,4),%r13
mov    %edi,%r8d
mov    $0x0,%r11d
jmp    1a87 <gsl_matrix_int_minmax+0x57>
mov    (%rcx),%eax
cmp    %eax,%r8d
cmovg  %eax,%r8d
cmp    %eax,%edi
cmovl  %eax,%edi
add    $0x4,%rcx
cmp    %r9,%rcx
jne    1a64 <gsl_matrix_int_minmax+0x34>
add    $0x1,%r11
add    %r12,%r10
cmp    %rbp,%r11
je     1a98 <gsl_matrix_int_minmax+0x68>
test   %rbx,%rbx
je     1a7b <gsl_matrix_int_minmax+0x4b>
lea    (%r10,%r13,1),%r9
mov    %r10,%rcx
jmp    1a64 <gsl_matrix_int_minmax+0x34>
mov    %edi,%r8d
mov    %r8d,(%rsi)
mov    %edi,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_int_minmax (const gsl_matrix_int * m,
                               int * min_out,
                               int * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  int max = m->data[0 * tda + 0];
  int min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          int x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 6
7 7
8 8
9 8
10 11
11 11
12 11
13 11
14 9
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 15
23 13
24 13
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 9
35 26
36 27
37 28
38 28
39 28
40 28
41 28
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  c81 <mu_m_server_end+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_m_server_end (mu_m_server_t msrv)
{
  mu_m_server_restore_signals (msrv);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%ebp
mov    %rsi,%rbx
mov    %edx,%r12d
mov    0x0(%rip),%r8        # 16b <pp_push+0x13>
test   %r8,%r8
je     17d <pp_push+0x25>
mov    0x8(%r8),%rax
mov    %rax,0x0(%rip)        # 17b <pp_push+0x23>
jmp    18a <pp_push+0x32>
mov    $0x1,%edi
callq  187 <pp_push+0x2f>
mov    %rax,%r8
mov    %rbx,0x18(%r8)
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,0x20(%r8)
mov    %r12d,0x44(%r8)
mov    %ebp,0x40(%r8)
mov    0x0(%rip),%rax        # 1b9 <pp_push+0x61>
mov    %rax,0x8(%r8)
mov    %r8,0x0(%rip)        # 1c4 <pp_push+0x6c>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
pp_push(int type, char *s, int flag)
{
 NODE *n;
 (void) ((n = (NODE *) nextfree[BLOCK_NODE].freep) ? (NODE *) (nextfree[BLOCK_NODE].freep = ((BLOCK *) n)->freep) : (n = (NODE *) more_blocks(BLOCK_NODE)));
 n->sub.nodep.name = s;
 n->sub.nodep.reserved = strlen(s);
 n->flags = flag;
 n->type = type;
 n->sub.nodep.r.rptr = pp_stack;
 pp_stack = n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 8
26 9
27 9
28 10
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%r8
mov    %rdx,%rax
addq   $0x1,0x58(%rdi)
test   %rcx,%rcx
je     158 <_compare+0x2d>
mov    0x8(%rdx),%rdx
cmp    %rdx,%rcx
cmovbe %rcx,%rdx
mov    0x30(%rax),%rsi
mov    %r8,%rdi
callq  156 <_compare+0x2b>
jmp    164 <_compare+0x39>
mov    0x30(%rdx),%rsi
mov    %r8,%rdi
callq  164 <_compare+0x39>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_compare(struct gcide_idx_file *file, char *hw, struct gcide_ref *ref,
  size_t hwlen)
{
    file->compare_count++;
    if (hwlen) {
 if (hwlen > ref->ref_hwlen)
     hwlen = ref->ref_hwlen;
 return utf8_strncasecmp(hw, ref->ref_headword, hwlen);
    }
    return utf8_strcasecmp(hw, ref->ref_headword);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 5
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 10
15 10
16 10
17 11
18 11
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 535 <anchor_unload+0x8>
test   %rbx,%rbx
je     568 <anchor_unload+0x3b>
cmp    0x0(%rip),%rbx        # 541 <anchor_unload+0x14>
jae    568 <anchor_unload+0x3b>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     559 <anchor_unload+0x2c>
callq  551 <anchor_unload+0x24>
movq   $0x0,0x30(%rbx)
add    $0x38,%rbx
je     568 <anchor_unload+0x3b>
cmp    %rbx,0x0(%rip)        # 566 <anchor_unload+0x39>
ja     543 <anchor_unload+0x16>
movl   $0x0,0x0(%rip)        # 572 <anchor_unload+0x45>
movl   $0x0,0x0(%rip)        # 57c <anchor_unload+0x4f>
movq   $0x0,0x0(%rip)        # 587 <anchor_unload+0x5a>
movq   $0x0,0x0(%rip)        # 592 <anchor_unload+0x65>
movq   $0x0,0x0(%rip)        # 59d <anchor_unload+0x70>
pop    %rbx
retq   
<<<sep_in_sample>>>
anchor_unload(void)
{
 struct anchor *a;
 for (a = start; a && a < end; a++) {
  if (a->reserve) {
   free(a->reserve);
   a->reserve = ((void *)0);
  }
 }
 FIRST = LAST = 0;
 start = curp = end = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 7
12 4
13 4
14 4
15 4
16 10
17 10
18 11
19 11
20 11
21 12
22 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0xc(%rdi),%esi
mov    0x38(%rdi),%rdi
callq  399 <rec_record_num_comments+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_record_num_comments (rec_record_t record)
{
  return rec_mset_count (record->mset, record->comment_type);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbp
mov    $0xa8,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 411 <isr_init+0x1a>
callq  416 <isr_init+0x1f>
mov    %rax,%rbx
mov    $0x14000,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 42a <isr_init+0x33>
callq  42f <isr_init+0x38>
mov    %rax,(%rsp)
movl   $0x0,0x8(%rsp)
movq   $0x14000,0x10(%rsp)
mov    $0x0,%esi
mov    %rsp,%rdi
callq  451 <isr_init+0x5a>
test   %eax,%eax
jns    45f <isr_init+0x68>
mov    $0x0,%edi
callq  45f <isr_init+0x68>
mov    %rbp,0xa0(%rbx)
mov    %rbx,%rax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
isr_init (_Bool *be_quiet)
{
  struct isr_scratch *scratch = (zlloc (plexus, "struct isr_scratch", sizeof (struct isr_scratch) * 1));
  stack_t ss =
    {
      .ss_sp = alloc (plexus, "sigaltstack", (10 * 8192)),
      .ss_size = (10 * 8192),
      .ss_flags = 0
    };
  if ((0 > (sigaltstack (&ss, ((void *)0)))))
    fatal_sys ("sigaltstack");
  (scratch->be_quiet) = be_quiet;
  return scratch;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 6
13 6
14 4
15 4
16 4
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 14
26 14
27 14
28 14
29 14
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
yywrap(void)
{
       return 1;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
test   %rdi,%rdi
je     a9 <mu_authority_destroy+0x3d>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     a9 <mu_authority_destroy+0x3d>
cmp    %rsi,0x0(%rbp)
jne    a2 <mu_authority_destroy+0x36>
lea    0x8(%rbp),%rdi
callq  91 <mu_authority_destroy+0x25>
lea    0x10(%rbp),%rdi
callq  9a <mu_authority_destroy+0x2e>
mov    %rbp,%rdi
callq  a2 <mu_authority_destroy+0x36>
movq   $0x0,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_authority_destroy (mu_authority_t *pauthority, void *owner)
{
  if (pauthority && *pauthority)
    {
      mu_authority_t authority = *pauthority;
      if (authority->owner == owner)
 {
   mu_ticket_destroy (&authority->ticket);
   mu_list_destroy (&authority->auth_methods);
   free (authority);
 }
      *pauthority = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 6
11 6
12 8
13 8
14 9
15 9
16 10
17 10
18 12
19 14
20 14
21 14
22 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%r13
mov    %rsi,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rbp
mov    0x10(%rbx),%rdi
lea    0x1(%rbp,%rdi,1),%rax
cmp    0x8(%rbx),%rax
jb     1149 <namebuf_name+0x58>
lea    0x8(%rbx),%r12
mov    %r12,%rsi
mov    (%rbx),%rdi
callq  1137 <namebuf_name+0x46>
mov    %rax,(%rbx)
mov    0x10(%rbx),%rdi
lea    0x1(%rbp,%rdi,1),%rax
cmp    0x8(%rbx),%rax
jae    112c <namebuf_name+0x3b>
add    (%rbx),%rdi
mov    %r13,%rsi
callq  1154 <namebuf_name+0x63>
mov    (%rbx),%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
namebuf_name (namebuf_t buf, const char *name)
{
  size_t len = strlen (name);
  while (buf->dir_length + len + 1 >= buf->buffer_size)
    buf->buffer = x2realloc (buf->buffer, &buf->buffer_size);
  strcpy (buf->buffer + buf->dir_length, name);
  return buf->buffer;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 4
17 4
18 5
19 5
20 5
21 5
22 5
23 4
24 4
25 4
26 4
27 6
28 6
29 6
30 7
31 8
32 8
33 8
34 8
35 8
36 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    %rsi,%r8
mov    %rdx,%rcx
mov    $0x83,%edx
mov    $0x6f,%esi
mov    $0x7a,%edi
callq  26 <cholesky_Ainv+0x26>
mov    %eax,%edi
test   %edi,%edi
jne    44 <cholesky_Ainv+0x44>
mov    %rbp,%r8
mov    %rbx,%rcx
mov    $0x83,%edx
mov    $0x70,%esi
mov    $0x7a,%dil
callq  44 <cholesky_Ainv+0x44>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
cholesky_Ainv(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
{
  int status;
  gsl_matrix * A = (gsl_matrix * ) params;
  (void) TransA;
  status = gsl_blas_dtrsv(CblasLower, CblasNoTrans, CblasNonUnit, A, x);
  if (status)
    return status;
  status = gsl_blas_dtrsv(CblasLower, CblasTrans, CblasNonUnit, A, x);
  if (status)
    return status;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 9
18 9
19 9
20 9
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  37fc <closure>
mov    0x0(%rip),%eax        # 3b93 <branch+0xf>
mov    %eax,%edx
and    $0xfffffffd,%edx
cmp    $0x10d,%edx
je     3bca <branch+0x46>
test   %eax,%eax
js     3bca <branch+0x46>
callq  37fc <closure>
mov    $0x10c,%edi
callq  1645 <addtok>
mov    0x0(%rip),%eax        # 3bb9 <branch+0x35>
mov    %eax,%edx
and    $0xfffffffd,%edx
cmp    $0x10d,%edx
je     3bca <branch+0x46>
test   %eax,%eax
jns    3ba4 <branch+0x20>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
branch (void)
{
  closure();
  while (tok != RPAREN && tok != OR && tok >= 0)
    {
      closure();
      addtok(CAT);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 7
12 7
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 9
21 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
test   %rdi,%rdi
je     42fb <free_fail_stack_return+0x50>
cmpq   $0x0,(%rdi)
je     42f2 <free_fail_stack_return+0x47>
mov    $0x0,%ebx
mov    $0x0,%r12d
mov    0x10(%rbp),%rax
mov    0x28(%rax,%rbx,1),%rdi
callq  42d6 <free_fail_stack_return+0x2b>
mov    0x10(%rbp),%rax
mov    0x10(%rax,%rbx,1),%rdi
callq  42e4 <free_fail_stack_return+0x39>
add    $0x1,%r12
add    $0x30,%rbx
cmp    %r12,0x0(%rbp)
ja     42c8 <free_fail_stack_return+0x1d>
mov    0x10(%rbp),%rdi
callq  42fb <free_fail_stack_return+0x50>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
free_fail_stack_return (struct re_fail_stack_t *fs)
{
  if (fs)
    {
      Idx fs_idx;
      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
 {
   free ((&fs->stack[fs_idx].eps_via_nodes)->elems);
   free (fs->stack[fs_idx].regs);
 }
      free (fs->stack);
    }
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 6
8 6
9 6
10 6
11 8
12 8
13 8
14 9
15 9
16 9
17 6
18 6
19 6
20 6
21 11
22 11
23 14
24 14
25 14
26 14
27 14
<<<sep_out_sample>>>
cmpb   $0x0,(%rdi)
je     28e <nextstring+0xe>
add    $0x1,%rdi
cmpb   $0x0,(%rdi)
jne    285 <nextstring+0x5>
lea    0x1(%rdi),%rax
retq   
<<<sep_in_sample>>>
nextstring(const char *s)
{
 while (*s)
  s++;
 return s + 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 5
7 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  13a <xzalloc+0x9>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  14a <xzalloc+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
<<<sep_in_sample>>>
gc_cipher_decrypt_inline (gc_cipher_handle handle, size_t len, char *data)
{
  _gc_cipher_ctx *ctx = handle;
  switch (ctx->alg)
    {
    default:
      return GC_INVALID_CIPHER;
    }
  return GC_OK;
}
<<<sep_in_sample>>>
1 10
2 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x18,%edi
callq  1a0 <grecs_list_push+0x16>
mov    %rbp,0x10(%rax)
mov    $0x0,%ecx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1b9 <grecs_list_push+0x2f>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_list_push(struct grecs_list *lp, void *val)
{
 struct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));
 ep->data = val;
 grecs_list_insert_entry(lp, ((void *)0), ep, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdx,%r14
test   %rdx,%rdx
je     b1e <gsl_block_complex_raw_fscanf+0x8d>
mov    %rdi,%r13
shl    $0x4,%rcx
mov    %rcx,%r15
lea    0x10(%rsi),%rbp
mov    $0x0,%r12d
jmp    b18 <gsl_block_complex_raw_fscanf+0x87>
lea    0x8(%rsp),%rdx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  ad4 <gsl_block_complex_raw_fscanf+0x43>
movsd  0x8(%rsp),%xmm0
movsd  %xmm0,(%rbx)
cmp    $0x1,%eax
je     b03 <gsl_block_complex_raw_fscanf+0x72>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  afc <gsl_block_complex_raw_fscanf+0x6b>
mov    $0x5,%eax
jmp    b2a <gsl_block_complex_raw_fscanf+0x99>
add    $0x8,%rbx
cmp    %rbp,%rbx
jne    abd <gsl_block_complex_raw_fscanf+0x2c>
add    $0x1,%r12
add    %r15,%rbp
cmp    %r14,%r12
je     b25 <gsl_block_complex_raw_fscanf+0x94>
lea    -0x10(%rbp),%rbx
jmp    abd <gsl_block_complex_raw_fscanf+0x2c>
mov    $0x0,%eax
jmp    b2a <gsl_block_complex_raw_fscanf+0x99>
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_block_complex_raw_fscanf (FILE * stream,
                                  double * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 2; k++)
        {
          double tmp;
          int status = fscanf (stream, "%lg", &tmp) ;
          data [2 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 13
18 13
19 13
20 13
21 13
22 14
23 14
24 15
25 15
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 10
35 10
36 7
37 7
38 7
39 7
40 5
41 5
42 21
43 21
44 21
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 22
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  28f <hash_init+0xc>
mov    %rax,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
lea    0x1(%rax),%rdi
mov    $0x28,%esi
callq  2b0 <hash_init+0x2d>
mov    %rax,0x18(%rbx)
lea    0x20(%rbx),%rdi
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  2d2 <hash_init+0x4f>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
hash_init (hash_table *htab, unsigned long int init_size)
{
  init_size = next_prime (init_size);
  htab->size = init_size;
  htab->filled = 0;
  htab->first = ((void *)0);
  htab->table = ((hash_entry *) xcalloc (init_size + 1, sizeof (hash_entry)));
  _obstack_begin ((&htab->mem_pool), 0, 0, (xmalloc), (free));
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 10
19 10
20 10
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cdio_is_device_os2(const char *source_name)
{
  if (!source_name)
    return 0;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     3c9 <sv_combegin+0x59>
mov    $0x1,%eax
cmpb   $0x0,(%rdi)
je     3ce <sv_combegin+0x5e>
mov    0x0(%rip),%rdi        # 38a <sv_combegin+0x1a>
test   %rdi,%rdi
je     394 <sv_combegin+0x24>
callq  394 <sv_combegin+0x24>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  3b0 <sv_combegin+0x40>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3bb <sv_combegin+0x4b>
mov    %rax,0x0(%rip)        # 3c2 <sv_combegin+0x52>
mov    $0x0,%eax
jmp    3ce <sv_combegin+0x5e>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
sv_combegin (value)
     const char *value;
{
  if (value && *value)
    {
      if (_rl_comment_begin) free (_rl_comment_begin);
      _rl_comment_begin = strcpy ((char *)xmalloc (1 + strlen (value)), (value));
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 10
6 4
7 4
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 10
26 11
27 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%r8
callq  1523 <quotearg_n_custom+0x10>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_n_custom (int n, char const *left_quote,
                   char const *right_quote, char const *arg)
{
  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,
                                ((size_t) -1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 6
5 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    31 <gsl_blas_sdsdot+0x31>
mov    %rdx,%rbx
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  26 <gsl_blas_sdsdot+0x26>
movss  %xmm0,(%rbx)
mov    $0x0,%eax
jmp    4f <gsl_blas_sdsdot+0x4f>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4a <gsl_blas_sdsdot+0x4a>
mov    $0x13,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_blas_sdsdot (float alpha, const gsl_vector_float * X,
                 const gsl_vector_float * Y, float *result)
{
  if (X->size == Y->size)
    {
      *result =
        cblas_sdsdot (((int)(X->size)), alpha, X->data, ((int)(X->stride)), Y->data,
                      ((int)(Y->stride)));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 6
14 9
15 9
16 13
17 13
18 13
19 13
20 13
21 13
22 15
23 15
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_long_data (const gsl_block_long * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
callq  bfe <grecs_node_from_path+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_node_from_path(const char *path, const char *value)
{
 return grecs_node_from_path_locus(path, value, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %dil,0x0(%rip)        # f <close_stdout_set_ignore_EPIPE+0x7>
retq   
<<<sep_in_sample>>>
close_stdout_set_ignore_EPIPE (_Bool ignore)
{
  ignore_EPIPE = ignore;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
cmp    $0x14,%rsi
je     4c3 <openssl_sha1_digest+0x20>
mov    $0x0,%ecx
mov    $0x18c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4c3 <openssl_sha1_digest+0x20>
mov    %rdi,%rbx
mov    %rdi,%rsi
mov    %rdx,%rdi
callq  4d1 <openssl_sha1_digest+0x2e>
mov    %rbx,%rdi
callq  4d9 <openssl_sha1_digest+0x36>
pop    %rbx
retq   
<<<sep_in_sample>>>
openssl_sha1_digest(void *ctx,
      size_t length, uint8_t *dst)
{
  ((length == 20) ? (void) (0) : __assert_fail ("length == 20", "nettle-openssl.c", 396, __PRETTY_FUNCTION__));
  SHA1_Final(dst, ctx);
  SHA1_Init(ctx);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 7
16 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rsi,%r15
mov    %rdx,0x10(%rsp)
mov    (%rdi),%r14
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%rax
mov    0x18(%rdi),%rbp
movss  0x0(%rbp),%xmm5
movss  %xmm5,0x4(%rsp)
test   %r14,%r14
je     d6a <gsl_matrix_float_minmax+0xc4>
shl    $0x2,%rax
mov    %rax,0x18(%rsp)
movss  %xmm5,0x8(%rsp)
mov    $0x0,%r13d
jmp    d5e <gsl_matrix_float_minmax+0xb8>
movss  0x0(%rbp,%rbx,4),%xmm1
movaps %xmm1,%xmm0
movss  %xmm1,0xc(%rsp)
movss  0x4(%rsp),%xmm3
movaps %xmm1,%xmm2
minss  %xmm3,%xmm2
movss  %xmm2,0x4(%rsp)
movss  0x8(%rsp),%xmm4
maxss  %xmm4,%xmm1
movss  %xmm1,0x8(%rsp)
callq  d2d <gsl_matrix_float_minmax+0x87>
test   %eax,%eax
je     d47 <gsl_matrix_float_minmax+0xa1>
movss  0xc(%rsp),%xmm6
movss  %xmm6,(%r15)
mov    0x10(%rsp),%rax
movss  %xmm6,(%rax)
jmp    d98 <gsl_matrix_float_minmax+0xf2>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    cf6 <gsl_matrix_float_minmax+0x50>
add    $0x1,%r13
add    0x18(%rsp),%rbp
cmp    %r14,%r13
je     d72 <gsl_matrix_float_minmax+0xcc>
test   %r12,%r12
je     d50 <gsl_matrix_float_minmax+0xaa>
mov    $0x0,%ebx
jmp    cf6 <gsl_matrix_float_minmax+0x50>
movss  0x4(%rsp),%xmm0
jmp    d84 <gsl_matrix_float_minmax+0xde>
movss  0x4(%rsp),%xmm0
movss  0x8(%rsp),%xmm7
movss  %xmm7,0x4(%rsp)
movss  %xmm0,(%r15)
mov    0x10(%rsp),%rax
movss  0x4(%rsp),%xmm7
movss  %xmm7,(%rax)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_float_minmax (const gsl_matrix_float * m,
                               float * min_out,
                               float * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  float max = m->data[0 * tda + 0];
  float min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          float x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            {
              *min_out = x;
              *max_out = x;
              return;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 6
12 7
13 8
14 8
15 8
16 11
17 11
18 11
19 11
20 8
21 11
22 11
23 15
24 15
25 15
26 16
27 15
28 15
29 15
30 20
31 15
32 15
33 24
34 24
35 24
36 26
37 26
38 27
39 27
40 28
41 13
42 13
43 13
44 11
45 11
46 11
47 11
48 13
49 13
50 13
51 13
52 9
53 9
54 9
55 9
56 9
57 32
58 33
59 33
60 33
61 34
62 34
63 34
64 34
65 34
66 34
67 34
68 34
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xe8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rcx,0x48(%rsp)
mov    %r8,0x50(%rsp)
mov    %r9,0x58(%rsp)
test   %al,%al
je     20e <grecs_warning+0x5b>
movaps %xmm0,0x60(%rsp)
movaps %xmm1,0x70(%rsp)
movaps %xmm2,0x80(%rsp)
movaps %xmm3,0x90(%rsp)
movaps %xmm4,0xa0(%rsp)
movaps %xmm5,0xb0(%rsp)
movaps %xmm6,0xc0(%rsp)
movaps %xmm7,0xd0(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,0x10(%rsp)
movl   $0x18,0x18(%rsp)
movl   $0x30,0x1c(%rsp)
lea    0x100(%rsp),%rax
mov    %rax,0x20(%rsp)
lea    0x30(%rsp),%rax
mov    %rax,0x28(%rsp)
lea    0x18(%rsp),%rcx
lea    0x10(%rsp),%rsi
lea    0x8(%rsp),%rdi
callq  25b <grecs_warning+0xa8>
test   %eax,%eax
je     264 <grecs_warning+0xb1>
callq  264 <grecs_warning+0xb1>
mov    0x8(%rsp),%rcx
mov    %ebp,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  *0x0(%rip)        # 279 <grecs_warning+0xc6>
mov    0x8(%rsp),%rdi
callq  283 <grecs_warning+0xd0>
add    $0xe8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
grecs_warning(grecs_locus_t const *locus, int errcode, const char *fmt, ...)
{
 va_list ap;
 char *buf = ((void *)0);
 size_t size = 0;
 __builtin_va_start(ap,fmt);
 if (grecs_vasprintf(&buf, &size, fmt, ap))
  grecs_alloc_die();
 __builtin_va_end(ap);
 grecs_print_diag_fun(locus, 0, errcode, buf);
 free(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 5
21 6
22 6
23 6
24 6
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 10
35 10
36 10
37 10
38 10
39 11
40 11
41 12
42 12
43 12
44 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  bae <sv_path+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sv_path (name)
     char *name;
{
  phash_flush ();
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
jmp    705 <clear_undo_stack+0x4c>
movslq %eax,%rdx
lea    (%rdx,%rdx,2),%rdx
lea    (%rcx,%rdx,8),%rdx
sub    $0x1,%eax
cmpl   $0x1,(%rdx)
jne    715 <clear_undo_stack+0x5c>
mov    %esi,0x0(%rip)        # 6d8 <clear_undo_stack+0x1f>
mov    0x10(%rdx),%rax
mov    (%rax),%r12
mov    0x8(%rdx),%rbx
cmp    %rbx,%r12
je     705 <clear_undo_stack+0x4c>
mov    (%rbx),%rbp
mov    %rbx,%rdi
callq  6f3 <clear_undo_stack+0x3a>
mov    %rbx,%rdi
callq  6fb <clear_undo_stack+0x42>
cmp    %rbp,%r12
je     705 <clear_undo_stack+0x4c>
mov    %rbp,%rbx
jmp    6e8 <clear_undo_stack+0x2f>
mov    0x0(%rip),%rcx        # 70c <clear_undo_stack+0x53>
mov    0x0(%rip),%eax        # 712 <clear_undo_stack+0x59>
sub    $0x1,%eax
mov    %eax,%esi
cmp    $0xffffffff,%eax
jne    6bf <clear_undo_stack+0x6>
movl   $0x0,0x0(%rip)        # 726 <clear_undo_stack+0x6d>
mov    0x0(%rip),%eax        # 72c <clear_undo_stack+0x73>
mov    %eax,0x0(%rip)        # 732 <clear_undo_stack+0x79>
mov    0x0(%rip),%eax        # 738 <clear_undo_stack+0x7f>
mov    %eax,0x0(%rip)        # 73e <clear_undo_stack+0x85>
mov    0x0(%rip),%eax        # 744 <clear_undo_stack+0x8b>
mov    %eax,0x0(%rip)        # 74a <clear_undo_stack+0x91>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
clear_undo_stack( void )
  {
  while( u_ptr-- )
    if( ustack[u_ptr].type == UDEL )
      {
      line_t * const ep = ustack[u_ptr].tail->q_forw;
      line_t * bp = ustack[u_ptr].head;
      while( bp != ep )
        {
        line_t * const lp = bp->q_forw;
        unmark_line_node( bp );
        free( bp );
        bp = lp;
        }
      }
  u_ptr = 0;
  u_current_addr = current_addr_;
  u_last_addr = last_addr_;
  u_modified = modified_;
  }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 7
15 8
16 8
17 10
18 11
19 11
20 12
21 12
22 8
23 8
24 13
25 13
26 4
27 4
28 4
29 3
30 3
31 3
32 16
33 17
34 17
35 18
36 18
37 19
38 19
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     4eb <info_reference_free+0x2b>
mov    (%rdi),%rdi
callq  4d1 <info_reference_free+0x11>
mov    0x8(%rbx),%rdi
callq  4da <info_reference_free+0x1a>
mov    0x10(%rbx),%rdi
callq  4e3 <info_reference_free+0x23>
mov    %rbx,%rdi
callq  4eb <info_reference_free+0x2b>
pop    %rbx
retq   
<<<sep_in_sample>>>
info_reference_free (REFERENCE *ref)
{
  if (ref)
    {
      free (ref->label);
      free (ref->filename);
      free (ref->nodename);
      free (ref);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 10
14 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
lea    0x0(,%rsi,8),%rbx
mov    (%rdi),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  145 <rk2imp_reset+0x21>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  156 <rk2imp_reset+0x32>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  167 <rk2imp_reset+0x43>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  178 <rk2imp_reset+0x54>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  189 <rk2imp_reset+0x65>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rk2imp_reset (void *vstate, size_t dim)
{
  rk2imp_state_t *state = (rk2imp_state_t *) vstate;
  memset((state->Y1),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->y_onestep),0,(dim)*sizeof(double));
  memset((state->y0_orig),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     16cd <gsl_permute_vector_ushort+0x2c>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16c6 <gsl_permute_vector_ushort+0x25>
mov    $0x13,%eax
jmp    16e3 <gsl_permute_vector_ushort+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  16de <gsl_permute_vector_ushort+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_ushort (const gsl_permutation * p, gsl_vector_ushort * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_ushort (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rdx,%r9
movslq %edi,%rax
shr    $0x1f,%edi
mov    %r8d,0x10(%rsp)
mov    %ecx,0x8(%rsp)
movq   $0x0,(%rsp)
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x4,%edx
mov    %rax,%rsi
callq  cc <to_chars>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
major_to_chars (int v, char *p, size_t s, int archive_format, int termch)
{
  to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, "major_t", archive_format, termch);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rsi
test   %rsi,%rsi
je     2b <vardefn_free+0x2b>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     1e <vardefn_free+0x1e>
mov    0x20(%rdi),%rdi
callq  *%rax
jmp    2b <vardefn_free+0x2b>
testb  $0x1,(%rdi)
jne    2b <vardefn_free+0x2b>
mov    %rsi,%rdi
callq  2b <vardefn_free+0x2b>
movq   $0x0,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
vardefn_free (struct vardefn *vd)
{
  if (vd->value)
    {
      if (vd->free)
 vd->free (vd->data, vd->value);
      else if (!(vd->flags & 0x1))
 free (vd->value);
    }
  memset (vd, 0, sizeof vd);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 8
15 8
16 10
17 11
18 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    %rsi,%rcx
mov    %rdx,%rsi
mov    0x8(%rdi),%rdi
mov    %rcx,%rdx
callq  *0x38(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_iterator_current_kv (mu_iterator_t iterator,
                        const void **pkey, void **pitem)
{
  return iterator->getitem (iterator->owner, (void**)pitem, pkey);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1fe2 <send_willcmd+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
send_willcmd (char *name)
{
  return (send_tncmd (send_will, "will", name));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 556 <rl_maybe_save_line+0x8>
jne    5c9 <rl_maybe_save_line+0x7b>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    $0x18,%edi
callq  568 <rl_maybe_save_line+0x1a>
mov    %rax,%rbx
mov    %rax,0x0(%rip)        # 572 <rl_maybe_save_line+0x24>
mov    0x0(%rip),%rbp        # 579 <rl_maybe_save_line+0x2b>
mov    %rbp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  595 <rl_maybe_save_line+0x47>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  5a0 <rl_maybe_save_line+0x52>
mov    %rax,(%rbx)
mov    0x0(%rip),%rax        # 5aa <rl_maybe_save_line+0x5c>
movq   $0x0,0x8(%rax)
mov    0x0(%rip),%rdx        # 5b9 <rl_maybe_save_line+0x6b>
mov    %rdx,0x10(%rax)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_maybe_save_line ()
{
  if (_rl_saved_line_for_history == 0)
    {
      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
      _rl_saved_line_for_history->line = strcpy ((char *)xmalloc (1 + strlen (rl_line_buffer)), (rl_line_buffer));
      _rl_saved_line_for_history->timestamp = (char *)((void *)0);
      _rl_saved_line_for_history->data = (char *)rl_undo_list;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 8
25 8
26 11
27 11
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x1001,%edi
callq  13d <sh_mktmpname+0x1e>
mov    %rax,%rbp
mov    %r12d,%edi
callq  0 <get_tmpdir>
test   %rbx,%rbx
mov    $0x0,%edx
cmove  %rdx,%rbx
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  16c <sh_mktmpname+0x4d>
mov    %rbp,%rdi
callq  174 <sh_mktmpname+0x55>
test   %rax,%rax
jne    190 <sh_mktmpname+0x71>
mov    $0x9a,%edx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  18b <sh_mktmpname+0x6c>
mov    $0x0,%ebp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
sh_mktmpname (nameroot, flags)
     char *nameroot;
     int flags;
{
  char *filename, *tdir, *lroot;
  struct stat sb;
  int r, tdlen;
  static int seeded = 0;
  filename = (char *)sh_xmalloc((4096 + 1), "tmpfile.c", 144);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);
  lroot = nameroot ? nameroot : "shtmp";
  sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  if (mktemp (filename) == 0)
    {
      sh_xfree((filename), "tmpfile.c", 154);
      filename = ((void *)0);
    }
  return filename;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 9
7 9
8 9
9 9
10 9
11 10
12 10
13 12
14 12
15 12
16 13
17 13
18 13
19 13
20 13
21 13
22 14
23 14
24 14
25 14
26 16
27 16
28 16
29 16
30 17
31 20
32 20
33 20
34 20
35 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
callq  8fd <swverid_get_tag+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swverid_get_tag(SWVERID * swverid, int n)
{
 return cplob_val(swverid->taglistM, n);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rcx
mov    0x60(%rdi),%rdx
mov    $0x0,%esi
callq  642 <gl_linked_search_from_to>
mov    %rax,%rsi
mov    $0x0,%eax
test   %rsi,%rsi
je     bcc <gl_linked_remove+0x2a>
mov    %rbx,%rdi
callq  af5 <gl_linked_remove_node>
pop    %rbx
retq   
<<<sep_in_sample>>>
gl_linked_remove (gl_list_t list, const void *elt)
{
  gl_list_node_t node = gl_linked_search_from_to (list, 0, list->count, elt);
  if (node != ((void *)0))
    return gl_linked_remove_node (list, node);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 7
9 4
10 4
11 5
12 5
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x1,0x118(%rdi)
jne    16d <a2ps_close_input_session+0x14>
callq  16b <a2ps_close_input_session+0x12>
jmp    175 <a2ps_close_input_session+0x1c>
nopl   (%rax)
callq  175 <a2ps_close_input_session+0x1c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
a2ps_close_input_session (a2ps_job * job)
{
  switch (job->output_format)
    {
    case ps:
      ps_end_file (job);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 6
5 6
6 6
7 9
8 11
9 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
movw   $0x0,0x0(%rip)        # 18d <setup_input+0xd>
movl   $0x0,0x0(%rip)        # 197 <setup_input+0x17>
mov    $0x8,%edi
callq  1a1 <setup_input+0x21>
mov    %rax,0x0(%rip)        # 1a8 <setup_input+0x28>
mov    %rax,0x0(%rip)        # 1af <setup_input+0x2f>
mov    $0x8,%edi
callq  1b9 <setup_input+0x39>
mov    %rax,0x0(%rip)        # 1c0 <setup_input+0x40>
mov    %rax,0x0(%rip)        # 1c7 <setup_input+0x47>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
setup_input(void)
{
  unget_stackdepth = 0;
  got_some_input = 0;
  unget_charstackbase = xmalloc(8);
  unget_charstackptr = unget_charstackbase;
  unget_statstackbase = xmalloc(8);
  unget_statstackptr = unget_statstackbase;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
7 6
8 7
9 7
10 7
11 8
12 9
13 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  a08 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  a11 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 8ba <output_text+0x8>
je     962 <output_text+0xb0>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %esi,%ebx
test   %esi,%esi
je     958 <output_text+0xa6>
mov    0x0(%rip),%rcx        # 8de <output_text+0x2c>
test   %rcx,%rcx
jne    8fe <output_text+0x4c>
cmp    0x0(%rip),%esi        # 8e9 <output_text+0x37>
jle    930 <output_text+0x7e>
mov    %esi,%edi
callq  26d <make_room_for>
mov    0x0(%rip),%rcx        # 8f9 <output_text+0x47>
test   %rcx,%rcx
je     930 <output_text+0x7e>
movslq %ebx,%rsi
mov    $0x1,%edx
mov    %rbp,%rdi
callq  90e <output_text+0x5c>
cmp    $0x1,%eax
je     958 <output_text+0xa6>
callq  918 <output_text+0x66>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  92e <output_text+0x7c>
jmp    958 <output_text+0xa6>
movslq %ebx,%r12
mov    0x0(%rip),%r13        # 93a <output_text+0x88>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  948 <output_text+0x96>
add    %r13,%r12
mov    %r12,0x0(%rip)        # 952 <output_text+0xa0>
sub    %ebx,0x0(%rip)        # 958 <output_text+0xa6>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
<<<sep_in_sample>>>
output_text (const char *text, int length)
{
  int count;
  if (!output_diversion || !length)
    return;
  if (!output_file && length > output_unused)
    make_room_for (length);
  if (output_file)
    {
      count = fwrite (text, length, 1, output_file);
      if (count != 1)
        (m4_error (1, (*__errno_location ()), "ERROR: copying inserted file"));
    }
  else
    {
      memcpy (output_cursor, text, (size_t) length);
      output_cursor += length;
      output_unused -= length;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 8
20 8
21 8
22 10
23 10
24 10
25 10
26 11
27 11
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 16
36 16
37 16
38 16
39 16
40 16
41 17
42 17
43 18
44 20
45 20
46 20
47 20
48 20
49 20
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_minimum (const gsl_multimin_fdfminimizer * s)
{
  return s->f;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
movsd  %xmm1,0x8(%rsp)
ucomisd 0x0(%rip),%xmm0        # ab <gsl_cdf_cauchy_Qinv+0x16>
jp     b7 <gsl_cdf_cauchy_Qinv+0x22>
movsd  0x0(%rip),%xmm0        # b5 <gsl_cdf_cauchy_Qinv+0x20>
je     115 <gsl_cdf_cauchy_Qinv+0x80>
ucomisd 0x0(%rip),%xmm2        # bf <gsl_cdf_cauchy_Qinv+0x2a>
jp     cb <gsl_cdf_cauchy_Qinv+0x36>
movsd  0x0(%rip),%xmm0        # c9 <gsl_cdf_cauchy_Qinv+0x34>
je     115 <gsl_cdf_cauchy_Qinv+0x80>
ucomisd 0x0(%rip),%xmm2        # d3 <gsl_cdf_cauchy_Qinv+0x3e>
jbe    f6 <gsl_cdf_cauchy_Qinv+0x61>
movsd  0x0(%rip),%xmm0        # dd <gsl_cdf_cauchy_Qinv+0x48>
subsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # e9 <gsl_cdf_cauchy_Qinv+0x54>
callq  ee <gsl_cdf_cauchy_Qinv+0x59>
mulsd  0x8(%rsp),%xmm0
jmp    115 <gsl_cdf_cauchy_Qinv+0x80>
mulsd  0x0(%rip),%xmm2        # fe <gsl_cdf_cauchy_Qinv+0x69>
movapd %xmm2,%xmm0
callq  107 <gsl_cdf_cauchy_Qinv+0x72>
movsd  0x8(%rsp),%xmm3
divsd  %xmm0,%xmm3
movapd %xmm3,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_cauchy_Qinv (const double Q, const double a)
{
  double x;
  if (Q == 0.0)
    {
      return (__builtin_inff());
    }
  else if (Q == 1.0)
    {
      return (-(__builtin_inff()));
    }
  if (Q > 0.5)
    {
      x = a * tan (3.14159265358979323846 * (0.5 - Q));
    }
  else
    {
      x = a / tan (3.14159265358979323846 * Q);
    }
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 6
7 4
8 8
9 8
10 10
11 8
12 12
13 12
14 14
15 14
16 14
17 14
18 14
19 14
20 18
21 18
22 18
23 18
24 18
25 18
26 21
27 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  c69 <expint_E2_impl>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_expint_E2_e(const double x, gsl_sf_result * result)
{
  return expint_E2_impl(x, result, 0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     64a <gsl_matrix_complex_isnonneg+0x67>
shl    $0x4,%rax
mov    %rax,%r10
mov    $0x8,%esi
mov    $0x0,%r8d
xorpd  %xmm1,%xmm1
movapd %xmm1,%xmm0
jmp    637 <gsl_matrix_complex_isnonneg+0x54>
ucomisd (%rax),%xmm0
ja     650 <gsl_matrix_complex_isnonneg+0x6d>
add    $0x1,%rdx
add    $0x10,%rax
cmp    %rcx,%rdx
je     62b <gsl_matrix_complex_isnonneg+0x48>
ucomisd -0x8(%rax),%xmm1
jbe    60f <gsl_matrix_complex_isnonneg+0x2c>
jmp    656 <gsl_matrix_complex_isnonneg+0x73>
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
je     65c <gsl_matrix_complex_isnonneg+0x79>
test   %rcx,%rcx
je     62b <gsl_matrix_complex_isnonneg+0x48>
mov    %rsi,%rax
add    0x18(%rdi),%rax
mov    $0x0,%edx
jmp    622 <gsl_matrix_complex_isnonneg+0x3f>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_complex_isnonneg (const gsl_matrix_complex * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 13
11 13
12 13
13 13
14 13
15 9
16 9
17 9
18 9
19 13
20 13
21 13
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 13
31 13
32 20
33 20
34 15
35 15
36 15
37 15
38 20
39 21
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 449 <cmpidx_long+0xb>
mov    (%rsi),%edx
lea    (%rdx,%rdx,4),%rdx
mov    0x8(%rax,%rdx,8),%rsi
mov    (%rdi),%edx
lea    (%rdx,%rdx,4),%rdx
mov    0x8(%rax,%rdx,8),%rdi
callq  464 <cmpidx_long+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cmpidx_long (const void *a, const void *b)
{
  unsigned const *ai = (unsigned const *)a;
  unsigned const *bi = (unsigned const *)b;
  struct gdbm_option const *ap = option_tab + *ai;
  struct gdbm_option const *bp = option_tab + *bi;
  return strcmp (ap->opt_long, bp->opt_long);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 7
5 7
6 5
7 7
8 7
9 7
10 8
11 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
callq  491 <visit_substring_match_nocasefold_narrow+0x11>
cmp    $0x1,%rax
je     4b0 <visit_substring_match_nocasefold_narrow+0x30>
mov    $0x0,%ecx
mov    $0x2c3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b0 <visit_substring_match_nocasefold_narrow+0x30>
mov    0x20(%rbp),%rdi
mov    %rbx,%rsi
callq  4bc <visit_substring_match_nocasefold_narrow+0x3c>
cmp    $0x1,%rax
sbb    %eax,%eax
and    $0x2,%eax
add    $0x2,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
visit_substring_match_nocasefold_narrow (struct process_data *procdata, void *context)
{
  const char *pattern = context;
  (((__ctype_get_mb_cur_max ()) == 1) ? (void) (0) : __assert_fail ("(__ctype_get_mb_cur_max ()) == 1", "locate.c", 707, __PRETTY_FUNCTION__));
  if (((void *)0) != strstr (procdata->munged_filename, pattern))
    return VISIT_ACCEPTED;
  else
    return VISIT_REJECTED;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 9
22 9
23 9
24 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %ecx,%r12d
cmp    %edx,%esi
jne    107c <_sse_mulr_d+0x26>
mov    %ecx,%r8d
mov    %esi,%ecx
mov    $0x59,%edx
mov    $0xf2,%esi
callq  9d0 <_ssexr>
jmp    10b2 <_sse_mulr_d+0x5c>
cmp    %ecx,%esi
jne    1096 <_sse_mulr_d+0x40>
mov    %edx,%r8d
mov    %esi,%ecx
mov    $0x59,%edx
mov    $0xf2,%esi
callq  9d0 <_ssexr>
jmp    10b2 <_sse_mulr_d+0x5c>
callq  fdb <_sse_movr_d>
mov    %r12d,%r8d
mov    %ebx,%ecx
mov    $0x59,%edx
mov    $0xf2,%esi
mov    %rbp,%rdi
callq  9d0 <_ssexr>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_sse_mulr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf2,0x59,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf2,0x59,r0,r1);
    else {
 _sse_movr_d(_jit,r0,r1);
 _ssexr(_jit,0xf2,0x59,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,0x28(%rdi)
mov    0x30(%rdi),%rdi
callq  2d3 <rec_field_set_char_location+0x11>
mov    0x28(%rbx),%rdx
lea    0x30(%rbx),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  2ea <rec_field_set_char_location+0x28>
cmp    $0xffffffff,%eax
setne  %al
pop    %rbx
retq   
<<<sep_in_sample>>>
rec_field_set_char_location (rec_field_t field,
                             size_t location)
{
  field->char_location = location;
  free (field->char_location_str);
  return (rpl_asprintf (&(field->char_location_str), "%zu", field->char_location)
          != -1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     41a <gsasl_client_callback_realm_get+0xa>
mov    0x78(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_realm_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_realm : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    $0x0,%edi
callq  200 <describe_variable+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  20b <describe_variable+0x1d>
mov    %rax,%rbx
test   %rax,%rax
je     299 <describe_variable+0xab>
cmpq   $0x0,0x18(%rax)
je     252 <describe_variable+0x64>
mov    0x8(%rax),%rdi
callq  227 <describe_variable+0x39>
mov    %rax,%r8
mov    0x10(%rbx),%rax
movslq (%rax),%rdx
mov    0x18(%rbx),%rax
mov    (%rax,%rdx,8),%rcx
mov    (%rbx),%rdx
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x0,%eax
callq  250 <describe_variable+0x62>
jmp    27b <describe_variable+0x8d>
mov    0x8(%rax),%rdi
callq  25b <describe_variable+0x6d>
mov    %rax,%r8
mov    0x10(%rbx),%rdx
mov    (%rdx),%ecx
mov    (%rbx),%rdx
mov    $0x0,%esi
lea    0x8(%rsp),%rdi
mov    $0x0,%eax
callq  27b <describe_variable+0x8d>
mov    0x8(%rsp),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  28f <describe_variable+0xa1>
mov    0x8(%rsp),%rdi
callq  299 <describe_variable+0xab>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
describe_variable (WINDOW *window, int count)
{
  VARIABLE_ALIST *var;
  char *description;
  var = read_variable_name (gettext ("Describe variable: "), window);
  if (!var)
    return;
  if (var->choices)
    asprintf (&description, "%s (%s): %s.",
             var->name, var->choices[*(int *)var->value], gettext (var->doc));
  else
    asprintf (&description, "%s (%d): %s.",
             var->name, *(int *)var->value, gettext (var->doc));
  window_message_in_echo_area ("%s", description);
  free (description);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 8
13 8
14 9
15 9
16 9
17 10
18 10
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 14
38 14
39 14
40 14
41 15
42 15
43 16
44 16
45 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%rax
mov    (%rsi),%rdx
cmp    (%rdi),%rdx
jne    eb1 <gsl_matrix_float_equal+0x19>
mov    0x8(%rsi),%rcx
cmp    %rax,%rcx
je     ed4 <gsl_matrix_float_equal+0x3c>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  eca <gsl_matrix_float_equal+0x32>
mov    $0x0,%eax
jmpq   f5e <gsl_matrix_float_equal+0xc6>
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
test   %rdx,%rdx
je     f3e <gsl_matrix_float_equal+0xa6>
lea    0x0(,%r8,4),%r12
lea    0x0(,%rax,4),%rbp
mov    $0x0,%r11d
mov    $0x0,%r10d
mov    $0x0,%ebx
jmp    f37 <gsl_matrix_float_equal+0x9f>
mov    $0x0,%eax
mov    %r10,%r9
add    0x18(%rdi),%r9
mov    %r11,%r8
add    0x18(%rsi),%r8
movss  (%r9,%rax,4),%xmm0
ucomiss (%r8,%rax,4),%xmm0
jp     f45 <gsl_matrix_float_equal+0xad>
je     f53 <gsl_matrix_float_equal+0xbb>
jmp    f45 <gsl_matrix_float_equal+0xad>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rdx,%rbx
je     f4c <gsl_matrix_float_equal+0xb4>
test   %rcx,%rcx
jne    f04 <gsl_matrix_float_equal+0x6c>
jmp    f28 <gsl_matrix_float_equal+0x90>
mov    $0x1,%eax
jmp    f5e <gsl_matrix_float_equal+0xc6>
mov    $0x0,%eax
jmp    f5e <gsl_matrix_float_equal+0xc6>
mov    $0x1,%eax
jmp    f5e <gsl_matrix_float_equal+0xc6>
add    $0x1,%rax
cmp    %rcx,%rax
jne    f17 <gsl_matrix_float_equal+0x7f>
jmp    f28 <gsl_matrix_float_equal+0x90>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_matrix_float_equal (const gsl_matrix_float * a, const gsl_matrix_float * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 11
19 12
20 14
21 14
22 14
23 14
24 14
25 14
26 14
27 14
28 21
29 21
30 21
31 21
32 21
33 20
34 20
35 20
36 20
37 20
38 14
39 14
40 14
41 14
42 14
43 16
44 16
45 16
46 29
47 29
48 23
49 23
50 29
51 29
52 16
53 16
54 16
55 16
56 30
57 30
58 30
59 30
<<<sep_out_sample>>>
mov    %rdi,%r8
mov    $0x16,%eax
test   %rdi,%rdi
je     22d <stream_write+0x20>
sub    $0x8,%rsp
mov    0x248(%rdi),%rdi
callq  *0x10(%r8)
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
stream_write (struct net_stream *str, const char *buf, size_t size,
       size_t *nbytes)
{
  if (!str)
    return 22;
  return str->write (str->data, buf, size, nbytes);
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 4
5 3
6 6
7 6
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x18(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_node_value (gl_list_t list, gl_list_node_t node)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->node_value (list, node);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    0x38(%rdi),%rax
mov    0x8(%rax),%rdx
test   %rdx,%rdx
je     4937 <_jit_patch+0x1f>
cmpl   $0x7,0x8(%rdx)
je     4942 <_jit_patch+0x2a>
mov    %rbx,%rdi
callq  493f <_jit_patch+0x27>
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  494d <_jit_patch+0x35>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_jit_patch(jit_state_t* _jit, jit_node_t *instr)
{
    jit_node_t *label;
    if (!(label = _jit->comp->tail) || label->code != jit_code_label)
 label = _jit_label(_jit);
    _jit_patch_at(_jit,instr,label);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 17e7 <gcide_markup_yyget_leng+0x6>
retq   
<<<sep_in_sample>>>
gcide_markup_yyget_leng (void)
{
        return gcide_markup_yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    %rsi,%rbx
mov    (%rsi),%rdi
callq  17 <main+0x17>
mov    %rbx,%rsi
mov    %ebp,%edi
callq  21 <main+0x21>
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x2,%edi
callq  35 <main+0x35>
mov    %eax,%r12d
test   %eax,%eax
jns    61 <main+0x61>
callq  41 <main+0x41>
mov    $0x0,%edx
mov    (%rax),%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  57 <main+0x57>
mov    $0x1,%edi
callq  61 <main+0x61>
mov    0x0(%rip),%rbx        # 68 <main+0x68>
movslq 0x0(%rip),%rax        # 6f <main+0x6f>
lea    (%rax,%rax,4),%rdx
lea    (%rax,%rdx,2),%rax
lea    (%rbx,%rax,8),%rax
cmp    %rax,%rbx
jae    114 <main+0x114>
mov    $0x0,%ebp
cmpl   $0x0,0x0(%rip)        # 90 <main+0x90>
je     c7 <main+0xc7>
mov    (%rbx),%rdi
callq  9a <main+0x9a>
test   %eax,%eax
je     d8 <main+0xd8>
lea    0x1(%rbp),%r13d
test   %ebp,%ebp
je     b0 <main+0xb0>
mov    $0x20,%edi
callq  b0 <main+0xb0>
mov    (%rbx),%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  c2 <main+0xc2>
mov    %r13d,%ebp
jmp    d8 <main+0xd8>
mov    %rbx,%rsi
mov    %r12d,%edi
callq  d2 <main+0xd2>
mov    %eax,%ebp
test   %eax,%eax
jne    11b <main+0x11b>
add    $0x58,%rbx
movslq 0x0(%rip),%rdx        # e3 <main+0xe3>
lea    (%rdx,%rdx,4),%rax
lea    (%rdx,%rax,2),%rax
mov    0x0(%rip),%rdx        # f2 <main+0xf2>
lea    (%rdx,%rax,8),%rdx
cmp    %rdx,%rbx
jb     89 <main+0x89>
cmpl   $0x0,0x0(%rip)        # 102 <main+0x102>
je     124 <main+0x124>
test   %ebp,%ebp
je     124 <main+0x124>
mov    $0xa,%edi
callq  112 <main+0x112>
jmp    124 <main+0x124>
mov    $0x0,%ebp
jmp    124 <main+0x124>
cmpl   $0x0,0x0(%rip)        # 122 <main+0x122>
jne    108 <main+0x108>
mov    %r12d,%edi
callq  12c <main+0x12c>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
main (int argc, char *argv[])
{
  int err = 0;
  int sfd;
  struct ifconfig *ifp;
  set_program_name (argv[0]);
  parse_cmdline (argc, argv);
  sfd = socket (2, SOCK_STREAM, 0);
  if (sfd < 0)
    {
      error (0, (*__errno_location ()), "socket error");
      exit (1);
    }
  for (ifp = ifs; ifp < ifs + nifs; ifp++)
    {
      if (list_mode)
 {
   if (!if_nametoindex (ifp->name))
     continue;
   if (err++)
     putchar (' ');
   printf ("%s", ifp->name);
   continue;
 }
      err = configure_if (sfd, ifp);
      if (err)
 break;
    }
  if (list_mode && err)
    putchar ('\n');
  close (sfd);
  return err;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 3
36 16
37 16
38 18
39 18
40 18
41 18
42 20
43 20
44 20
45 21
46 21
47 22
48 22
49 22
50 22
51 20
52 23
53 25
54 25
55 25
56 25
57 26
58 26
59 14
60 14
61 14
62 14
63 14
64 14
65 14
66 14
67 29
68 29
69 29
70 29
71 30
72 30
73 30
74 3
75 3
76 29
77 29
78 31
79 31
80 33
81 33
82 33
83 33
84 33
85 33
86 33
<<<sep_out_sample>>>
subsd  %xmm2,%xmm0
subsd  %xmm3,%xmm1
retq   
<<<sep_in_sample>>>
gsl_complex_sub (gsl_complex a, gsl_complex b)
{
  double ar = ((a).dat[0]), ai = ((a).dat[1]);
  double br = ((b).dat[0]), bi = ((b).dat[1]);
  gsl_complex z;
  do {(&z)->dat[0]=(ar - br); (&z)->dat[1]=(ai - bi);} while(0);
  return z;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # ed <yy_fatal_error+0x13>
mov    $0x0,%eax
callq  f7 <yy_fatal_error+0x1d>
mov    $0x2,%edi
callq  101 <sexensure_buffer_stack>
<<<sep_in_sample>>>
yy_fatal_error (const char* msg , yyscan_t yyscanner)
{
     (void) rpl_fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  447 <fileMenu_Exit+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fileMenu_Exit()
{
  exit_gracefully(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
and    $0x7,%esi
movq   $0x0,(%rdi)
shl    $0x8,%rsi
mov    %rsi,0x8(%rdi)
retq   
<<<sep_in_sample>>>
slatec_set (void *vstate, unsigned long int s)
{
  slatec_state_t *state = (slatec_state_t *) vstate;
  s = s % 8;
  s *= P / 8;
  state->x0 = s % 2048;
  state->x1 = (s - state->x0) / 2048;
}
<<<sep_in_sample>>>
1 4
2 6
3 7
4 7
5 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x0,(%rsp)
mov    $0x0,%r9d
callq  16 <groff_getopt_long+0x16>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
groff_getopt_long (int argc, char * *argv, const char *options,
      const struct option *long_options, int *opt_index)
{
  return _getopt_internal (argc, (char **) argv, options, long_options,
      opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    %rdi,%rsi
mov    %rbx,%rdi
callq  17 <__rmaxt+0x17>
cmp    $0x1,%al
jne    33 <__rmaxt+0x33>
mov    0x0(%rbp),%rax
mov    0x8(%rbp),%rdx
mov    %rax,0x0(%rip)        # 2a <__rmaxt+0x2a>
mov    %rdx,0x0(%rip)        # 31 <__rmaxt+0x31>
jmp    48 <__rmaxt+0x48>
mov    (%rbx),%rax
mov    0x8(%rbx),%rdx
mov    %rax,0x0(%rip)        # 41 <__rmaxt+0x41>
mov    %rdx,0x0(%rip)        # 48 <__rmaxt+0x48>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__rmaxt (__txtvp t1, __txtvp t2)
{
  if (__rlttext (t2, t1) == 1)
    __et = *t1;
  else
    __et = *t2;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  (%rdi),%xmm1
cmp    $0x1,%esi
jbe    297 <poly_eval+0x2a>
lea    0x8(%rdi),%rax
lea    -0x2(%rsi),%edx
lea    0x10(%rdi,%rdx,8),%rdx
addsd  (%rax),%xmm1
mulsd  %xmm0,%xmm1
add    $0x8,%rax
cmp    %rdx,%rax
jne    286 <poly_eval+0x19>
mov    %esi,%esi
movapd %xmm1,%xmm0
addsd  (%rdi,%rsi,8),%xmm0
retq   
<<<sep_in_sample>>>
poly_eval (const double c[], unsigned int n, double x)
{
  unsigned int i;
  double y = c[0] * x;
  for (i = 1; i < n; i++)
    {
      y = x * (y + c[i]);
    }
  y += c[n];
  return y;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 5
12 5
13 9
14 9
15 9
16 11
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    %esi,0xc(%rsp)
mov    0x18(%rdi),%rax
movq   $0x0,0x18(%rsp)
movq   $0x0,0x20(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x30(%rsp)
movq   $0x0,0x48(%rsp)
movq   $0x0,0x50(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x60(%rsp)
lea    0xc(%rsp),%rcx
mov    %rcx,0x10(%rsp)
movl   $0x4,0x18(%rsp)
mov    %rdx,0x40(%rsp)
movl   $0x20,0x48(%rsp)
mov    $0x15,%r8d
lea    0x40(%rsp),%rcx
lea    0x10(%rsp),%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  *0x148(%rax)
cmp    $0xffff86eb,%eax
mov    $0x0,%edx
cmove  %edx,%eax
add    $0x78,%rsp
retq   
<<<sep_in_sample>>>
CDB___db_vrfy_childput(vdp, pgno, cip)
 VRFY_DBINFO *vdp;
 db_pgno_t pgno;
 VRFY_CHILDINFO *cip;
{
 DBT key, data;
 DB *cdbp;
 int ret;
 cdbp = vdp->cdbp;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 key.data = &pgno;
 key.size = sizeof(db_pgno_t);
 data.data = cip;
 data.size = sizeof(VRFY_CHILDINFO);
 ret = cdbp->put(cdbp, ((void *)0), &key, &data, 21);
 return (ret == (-30997) ? 0 : ret);
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 10
5 10
6 10
7 10
8 11
9 11
10 11
11 11
12 12
13 12
14 13
15 14
16 15
17 16
18 16
19 16
20 16
21 16
22 16
23 17
24 17
25 17
26 18
27 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rsi,%rsi
je     11 <__rcp+0x11>
mov    %rsi,%rdi
callq  11 <__rcp+0x11>
movswq 0x4(%rbx),%rdi
callq  1b <__rcp+0x1b>
movb   $0x1,0x18(%rax)
mov    %rbx,(%rax)
mov    0x0(%rip),%rdx        # 29 <__rcp+0x29>
mov    %rdx,0x30(%rax)
movq   $0x0,0x0(%rip)        # 38 <__rcp+0x38>
mov    0x0(%rip),%rdx        # 3f <__rcp+0x3f>
mov    %rdx,0x10(%rax)
mov    %rax,0x0(%rip)        # 4a <__rcp+0x4a>
pop    %rbx
retq   
<<<sep_in_sample>>>
__rcp (__pty ppx, long as)
{
  __dhp x;
  if (as)
    __rss (as);
  x = __ralloc ((long) ppx->size);
  x->pm = 1;
  x->pp = ppx;
  x->sl = __sl;
  __sl = 0L;
  x->dl = __pb;
  __pb = x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 9
12 9
13 10
14 11
15 11
16 12
17 13
18 13
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
cmp    $0x2,%edi
jg     2f <main+0x2f>
mov    0x0(%rip),%rcx        # 11 <main+0x11>
mov    $0x25,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  25 <main+0x25>
mov    $0x1,%edi
callq  2f <main+0x2f>
mov    %rsi,%rbx
mov    0x8(%rsi),%rdi
lea    0x8(%rsp),%rdx
mov    $0x0,%esi
mov    $0x0,%eax
callq  4a <main+0x4a>
mov    0x8(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    %rax,0x18(%rsp)
mov    0x10(%rbx),%rdi
lea    0x10(%rsp),%rsi
callq  67 <main+0x67>
test   %eax,%eax
jne    75 <main+0x75>
mov    $0x0,%edi
callq  75 <main+0x75>
mov    $0x1,%edi
callq  7f <main+0x7f>
<<<sep_in_sample>>>
main (int argc, char *argv[])
{
 time_t tm;
 struct utimbuf ub;
 unsigned long create_time;
 int ret;
 if (argc < 3) {
  fprintf(stderr, "Usage : mtimetouch calendartime path\n");
  exit(1);
 }
 sscanf(argv[1], "%lu", &create_time);
 ub.actime = (time_t)create_time;
 ub.modtime = (time_t)create_time;
 ret = utime(argv[2], &ub);
 if (ret == 0) exit(0);
 exit(1);
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
5 8
6 8
7 8
8 8
9 8
10 9
11 9
12 9
13 11
14 11
15 11
16 11
17 11
18 12
19 12
20 13
21 14
22 14
23 14
24 15
25 15
26 15
27 15
28 16
29 16
<<<sep_out_sample>>>
sub    $0xd8,%rsp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     1ab <__dbenv_errx+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%r8
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xe0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%r9
mov    $0x1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  1ee <__dbenv_errx+0x99>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__dbenv_errx(const DB_ENV *dbenv, const char *fmt, ...)
{
 va_list ap;
 __builtin_va_start(ap,fmt);
 CDB___db_real_err(dbenv, 0, 0, 1, fmt, ap);
 __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 4
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 5
27 5
28 7
29 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x100,%ecx
callq  21 <lstatat+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lstatat (int fd, char const *name, struct stat *st)
{
  return fstatat (fd, name, st, 0x100);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 55 <set_requested_style+0xb>
test   %rdi,%rdi
je     5f <set_requested_style+0x15>
callq  5f <set_requested_style+0x15>
test   %rbx,%rbx
je     78 <set_requested_style+0x2e>
mov    $0x0,%eax
cmpb   $0x0,(%rbx)
je     7d <set_requested_style+0x33>
mov    %rbx,%rdi
callq  76 <set_requested_style+0x2c>
jmp    7d <set_requested_style+0x33>
mov    $0x0,%eax
mov    %rax,0x0(%rip)        # 84 <set_requested_style+0x3a>
pop    %rbx
retq   
<<<sep_in_sample>>>
set_requested_style (const char * arg)
{
  do { const char *my_s2 = (arg); do { if (style_request) free (style_request); } while (0); style_request = !(((const char *) (my_s2) == ((void *)0)) || (*(my_s2) == '\0')) ? xstrdup (my_s2) : ((void *)0); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 4
18 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdi        # c3 <read_2_bytes+0x8>
callq  c8 <read_2_bytes+0xd>
mov    %eax,%ebx
cmp    $0xffffffff,%eax
jne    f4 <read_2_bytes+0x39>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # e0 <read_2_bytes+0x25>
mov    $0x0,%eax
callq  ea <read_2_bytes+0x2f>
mov    $0x1,%edi
callq  f4 <read_2_bytes+0x39>
mov    0x0(%rip),%rdi        # fb <read_2_bytes+0x40>
callq  100 <read_2_bytes+0x45>
cmp    $0xffffffff,%eax
jne    12a <read_2_bytes+0x6f>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 116 <read_2_bytes+0x5b>
mov    $0x0,%eax
callq  120 <read_2_bytes+0x65>
mov    $0x1,%edi
callq  12a <read_2_bytes+0x6f>
shl    $0x8,%ebx
add    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
read_2_bytes (void)
{
  int c1, c2;
  c1 = _IO_getc (infile);
  if (c1 == (-1))
    (fprintf(stderr, "%s\n", "Premature EOF in JPEG file"), exit(1));
  c2 = _IO_getc (infile);
  if (c2 == (-1))
    (fprintf(stderr, "%s\n", "Premature EOF in JPEG file"), exit(1));
  return (((unsigned int) c1) << 8) + ((unsigned int) c2);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 11
28 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  33 <emalloc+0x9>
test   %rax,%rax
jne    3d <emalloc+0x13>
callq  3d <emalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
emalloc (size_t size)
{
  void *p = malloc (size);
  if (!p)
    ealloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 7
7 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # af3 <set_working_directory+0xb>
test   %rdi,%rdi
je     b07 <set_working_directory+0x1f>
mov    $0x258,%edx
mov    $0x0,%esi
callq  b07 <set_working_directory+0x1f>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
mov    $0x259,%edx
mov    $0x0,%esi
callq  b2d <set_working_directory+0x45>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  b38 <set_working_directory+0x50>
mov    %rax,0x0(%rip)        # b3f <set_working_directory+0x57>
pop    %rbx
retq   
<<<sep_in_sample>>>
set_working_directory (name)
     char *name;
{
  do { if (the_current_working_directory) sh_xfree((the_current_working_directory), "common.c", 600); } while (0);
  the_current_working_directory = (char *)strcpy (sh_xmalloc((1 + strlen (name)), "common.c", 601), (name));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
callq  e <_auth_lb_create+0xe>
mov    %rax,%rdx
mov    %rax,(%rbx)
mov    $0xc,%eax
test   %rdx,%rdx
je     40 <_auth_lb_create+0x40>
movq   $0x0,(%rdx)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    (%rbx),%rax
movq   $0x0,0x10(%rax)
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_auth_lb_create (struct _line_buffer **s)
{
  *s = malloc (sizeof (**s));
  if (!*s)
    return 12;
  (*s)->buffer = ((void *)0);
  (*s)->size = 0;
  (*s)->level = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 4
9 4
10 6
11 7
12 7
13 8
14 8
15 9
16 10
17 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %esi,%ebx
callq  1958 <rpmpsf_write_bundle+0xd>
mov    %rax,%rbp
mov    %ebx,%esi
mov    $0x0,%edi
callq  16d <write_object_keyword>
mov    %ebx,(%rsp)
mov    $0x0,%r9d
mov    %rbp,%r8
mov    $0xffffffff,%ecx
mov    $0x3f8,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  198c <rpmpsf_write_bundle+0x41>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rpmpsf_write_bundle(TOPSF * topsf, int uxfio_ofd, int filetype)
{
 Header h=topsf_get_rpmheader(topsf);
 write_object_keyword("bundle", uxfio_ofd);
 return rpmpsf_write_rpm_attribute("tag", ((void *)0), 1016, -1, h, ((void *)0), uxfio_ofd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1288 <quotearg+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg (char const *arg)
{
  return quotearg_n (0, arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%esi
mov    $0x0,%edi
callq  12 <gsasl_strerror+0x12>
cmp    $0x44,%ebx
jbe    28 <gsasl_strerror+0x28>
mov    $0x0,%esi
mov    $0x0,%edi
callq  26 <gsasl_strerror+0x26>
jmp    4d <gsasl_strerror+0x4d>
movslq %ebx,%rbx
lea    (%rbx,%rbx,2),%rax
mov    0x0(,%rax,8),%rsi
test   %rsi,%rsi
mov    $0x0,%eax
cmove  %rax,%rsi
mov    $0x0,%edi
callq  4d <gsasl_strerror+0x4d>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsasl_strerror (int err)
{
  static const char *unknown = "Libgsasl unknown error";
  const char *p;
  bindtextdomain ("libgsasl", "/usr/local/share/locale");
  if (err < 0 || err >= (sizeof (errors) / sizeof (errors[0])))
    return dgettext ("libgsasl", unknown);
  p = errors[err].description;
  if (!p)
    p = unknown;
  return dgettext ("libgsasl", p);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 10
16 10
17 10
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     38 <_asn1_find_left+0x1c>
mov    0x70(%rdi),%rax
test   %rax,%rax
je     3e <_asn1_find_left+0x22>
cmp    %rdi,0x60(%rax)
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_asn1_find_left (asn1_node node)
{
  if ((node == ((void *)0)) || (node->left == ((void *)0)) || (node->left->down == node))
    return ((void *)0);
  return node->left;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 6
<<<sep_out_sample>>>
movl   $0x1,(%rsi)
mov    $0x23,%eax
cmp    $0x23,%edi
je     2249 <swlib_c701_escaped_value+0x26>
mov    $0x5c,%al
cmp    $0x5c,%edi
je     2249 <swlib_c701_escaped_value+0x26>
mov    $0x22,%al
cmp    $0x22,%edi
je     2249 <swlib_c701_escaped_value+0x26>
movl   $0x0,(%rsi)
mov    %edi,%eax
repz retq 
<<<sep_in_sample>>>
swlib_c701_escaped_value(int src, int * is_escape) {
 *is_escape = 1;
 switch (src) {
  case '\\': return (int)'\\'; break;
  case '#': return (int)'#'; break;
  case '\"': return (int)'\"'; break;
 }
 *is_escape = 0;
 return (int)(src);
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 3
5 4
6 3
7 3
8 6
9 3
10 3
11 8
12 9
13 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  aef <gsl_sort_vector_long_largest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_long_largest (long * dest, const size_t k,
                                    const gsl_vector_long * v)
{
  return gsl_sort_long_largest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
mov    %rsp,%rsi
callq  2a5 <speed+0x1c>
mov    %eax,%edx
mov    $0xffffffff,%eax
test   %edx,%edx
jne    2bf <speed+0x36>
mov    %rsp,%rdi
callq  2b8 <speed+0x2f>
mov    %eax,%edi
callq  2bf <speed+0x36>
mov    0x48(%rsp),%rcx
xor    %fs:0x28,%rcx
je     2d4 <speed+0x4b>
callq  2d4 <speed+0x4b>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
speed (int fd)
{
  struct termios tt;
  if (tcgetattr (fd, &tt) == 0)
    {
      unsigned int sp = cfgetispeed (&tt);
      return speed_translate (sp);
    }
  return (-1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 9
9 4
10 4
11 6
12 6
13 7
14 7
15 10
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 245 <find_directory_meta+0x8>
je     28a <find_directory_meta+0x4d>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    $0x0,%esi
mov    $0x0,%edi
callq  13c <make_directory>
mov    %rax,%rbx
mov    %r12,0x18(%rax)
mov    %rbp,0x20(%rax)
mov    %rax,%rsi
mov    0x0(%rip),%rdi        # 275 <find_directory_meta+0x38>
callq  27a <find_directory_meta+0x3d>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  9b <free_directory>
mov    %rbp,%rax
jmp    290 <find_directory_meta+0x53>
mov    $0x0,%eax
retq   
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
find_directory_meta (dev_t dev, ino_t ino)
{
  if (! directory_meta_table)
    return 0;
  else
    {
      struct directory *dir = make_directory ("", ((void *)0));
      struct directory *ret;
      dir->device_number = dev;
      dir->inode_number = ino;
      ret = hash_lookup (directory_meta_table, dir);
      free_directory (dir);
      return ret;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 7
9 7
10 7
11 7
12 9
13 10
14 11
15 11
16 11
17 11
18 12
19 12
20 13
21 13
22 4
23 4
24 15
25 15
26 15
27 15
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rsi,%rbp
mov    (%rsi),%r12
test   %r12,%r12
je     2bb <gsl_histogram_fscanf+0x75>
mov    %rdi,%r13
mov    $0x0,%ebx
lea    0x0(,%rbx,8),%r8
mov    %r8,%rdx
add    0x8(%rbp),%rdx
add    0x10(%rbp),%r8
lea    0x8(%rsp),%rcx
mov    $0x0,%esi
mov    %r13,%rdi
mov    $0x0,%eax
callq  28d <gsl_histogram_fscanf+0x47>
cmp    $0x3,%eax
je     2b2 <gsl_histogram_fscanf+0x6c>
mov    $0x5,%ecx
mov    $0x78,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gsl_histogram_fscanf+0x65>
mov    $0x5,%eax
jmp    2d0 <gsl_histogram_fscanf+0x8a>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    263 <gsl_histogram_fscanf+0x1d>
mov    0x8(%rbp),%rax
movsd  0x8(%rsp),%xmm0
movsd  %xmm0,(%rax,%r12,8)
mov    $0x0,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_histogram_fscanf (FILE * stream, gsl_histogram * h)
{
  size_t i;
  const size_t n = h->n;
  double upper;
  for (i = 0; i < n; i++)
    {
      int status = fscanf (stream,
                           "%lg %lg %lg", h->range + i, &upper,
                           h->bin + i);
      if (status != 3)
        {
          do { gsl_error ("fscanf failed", "file.c", 120, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  h->range[n] = upper;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 6
31 6
32 6
33 16
34 16
35 16
36 17
37 18
38 18
39 18
40 18
41 18
42 18
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%esi        # bc <defer_terminit+0xa>
cmp    $0xffffffff,%esi
je     e5 <defer_terminit+0x33>
mov    0x0(%rip),%edx        # c7 <defer_terminit+0x15>
mov    $0x20,%edi
callq  d1 <defer_terminit+0x1f>
movl   $0x0,0x0(%rip)        # db <defer_terminit+0x29>
movl   $0x0,0x0(%rip)        # e5 <defer_terminit+0x33>
mov    0x0(%rip),%eax        # eb <defer_terminit+0x39>
test   %eax,%eax
jne    f8 <defer_terminit+0x46>
cmpl   $0x0,0x0(%rip)        # f6 <defer_terminit+0x44>
je     127 <defer_terminit+0x75>
movq   $0x0,(%rsp)
mov    %ax,0x2(%rsp)
mov    0x0(%rip),%eax        # 10b <defer_terminit+0x59>
mov    %ax,(%rsp)
mov    %rsp,%rdx
mov    $0x5414,%esi
mov    0x0(%rip),%edi        # 11d <defer_terminit+0x6b>
mov    $0x0,%eax
callq  127 <defer_terminit+0x75>
callq  12c <defer_terminit+0x7a>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
defer_terminit (void)
{
  if (def_tspeed != -1)
    {
      clientstat (32, def_tspeed, def_rspeed);
      def_tspeed = def_rspeed = 0;
    }
  if (def_col || def_row)
    {
      struct winsize ws;
      memset ((char *) &ws, 0, sizeof (ws));
      ws.ws_col = def_col;
      ws.ws_row = def_row;
      rpl_ioctl (pty, 0x5414, (char *) &ws);
    }
  deferslc ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 11
16 12
17 13
18 13
19 14
20 14
21 14
22 14
23 14
24 16
25 17
26 17
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # ff2 <pch_ptrn_lines+0x7>
retq   
<<<sep_in_sample>>>
pch_ptrn_lines (void)
{
    return p_ptrn_lines;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %esi,%ebp
mov    %rdx,%rbx
mov    0x8(%rdx),%rax
mov    0x10(%rdx),%r13
movq   $0x0,0x0(%rip)        # 68b <dicod_define+0x25>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
jne    6b1 <dicod_define+0x4b>
mov    %r13,%rsi
mov    %r12,%rdi
callq  6af <dicod_define+0x49>
jmp    701 <dicod_define+0x9b>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
jne    6d7 <dicod_define+0x71>
mov    %r13,%rsi
mov    %r12,%rdi
callq  6d5 <dicod_define+0x6f>
jmp    701 <dicod_define+0x9b>
mov    %rax,%rdi
callq  6df <dicod_define+0x79>
test   %rax,%rax
jne    6f3 <dicod_define+0x8d>
mov    $0x0,%esi
mov    %r12,%rdi
callq  6f1 <dicod_define+0x8b>
jmp    701 <dicod_define+0x9b>
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  701 <dicod_define+0x9b>
mov    %rbx,%rsi
mov    %ebp,%edi
callq  70b <dicod_define+0xa5>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dicod_define(dico_stream_t str, int argc, char **argv)
{
    char *dbname = argv[1];
    char *word = argv[2];
    total_bytes_out = 0;
    if (strcmp(dbname, "!") == 0) {
 dicod_define_word_first(str, word);
    } else if (strcmp(dbname, "*") == 0) {
 dicod_define_word_all(str, word);
    } else {
 dicod_database_t *db = find_database(dbname);
 if (!db)
     stream_writez(str,
     "550 invalid database, use SHOW DB for a list\n");
 else
     dicod_define_word_db(db, str, word);
    }
    access_log(argc, argv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 4
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 11
37 11
38 12
39 12
40 13
41 13
42 13
43 13
44 16
45 16
46 16
47 16
48 18
49 18
50 18
51 19
52 19
53 19
54 19
55 19
56 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x28(%rsi),%rax
test   %rax,%rax
je     755 <sexset_column+0x1a>
mov    0x18(%rsi),%rdx
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
jne    75f <sexset_column+0x24>
mov    $0x0,%edi
callq  da <yy_fatal_error>
mov    %edi,0x34(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sexset_column (int column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (! ( yyg->yy_buffer_stack ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] : ((void *)0)) )
           yy_fatal_error( "sexset_column called with no buffer" , yyscanner);
    (yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]->yy_bs_column) = column_no;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     990 <strbuf_close+0x11>
callq  990 <strbuf_close+0x11>
mov    0x8(%rbx),%rdi
callq  999 <strbuf_close+0x1a>
mov    %rbx,%rdi
callq  9a1 <strbuf_close+0x22>
pop    %rbx
retq   
<<<sep_in_sample>>>
strbuf_close(STRBUF *sb)
{
 if (sb->name)
  (void)free(sb->name);
 (void)free(sb->sbuf);
 (void)free(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  51 <fp_close+0xc>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fp_close(void *data)
{
    struct pfile_stream *p = data;
    pclose(p->fp);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
callq  30c <do_rmdir>
mov    %eax,%r12d
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  849 <cleanup_temp_subdir+0x1d>
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
cleanup_temp_subdir (struct temp_dir *dir,
                     const char *absolute_dir_name)
{
  int err;
  err = do_rmdir (dir, absolute_dir_name);
  unregister_temp_subdir (dir, absolute_dir_name);
  return err;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
11 8
12 8
13 8
14 8
15 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a0 <sbuilder_init+0x23>
movl   $0x79,0x0(%rip)        # aa <sbuilder_init+0x2d>
mov    $0x0,%edi
callq  42 <spush>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
sbuilder_init(void)
{
  _obstack_begin ((&os_stack), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
  module.token= MMODULE;
  spush (&module);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbp
callq  0 <xargs_open_generic>
mov    %rax,%rbx
movl   $0x3,0x24(%rax)
mov    %rbp,%rdi
callq  160 <xargs_open_with_strbuf+0x20>
mov    %rax,0x70(%rbx)
add    0x18(%rbp),%rax
sub    0x8(%rbp),%rax
mov    %rax,0x78(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
xargs_open_with_strbuf(const char *command, int max_args, STRBUF *sb)
{
 XARGS *xp = xargs_open_generic(command, max_args);
 xp->type = 3;
 xp->curp = strbuf_value(sb);
 xp->endp = xp->curp + (sb->curp - sb->sbuf);
 return xp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
movslq %esi,%rbx
mov    %rbx,%rax
add    0x0(%rip),%rax        # 9c <newstr_grow1+0x2b>
cmp    %rax,0x0(%rip)        # a3 <newstr_grow1+0x32>
jae    af <newstr_grow1+0x3e>
mov    $0x0,%edi
callq  af <newstr_grow1+0x3e>
mov    %rbx,%rdx
mov    0x0(%rip),%rsi        # b9 <newstr_grow1+0x48>
mov    %rbp,%rdi
callq  c1 <newstr_grow1+0x50>
add    %rbx,0x0(%rip)        # c8 <newstr_grow1+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
newstr_grow1(char *s1)
{
  __extension__ ({ struct obstack *__o = (&os_newstr); int __len = (strlen(s1)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); bcopy (((char *) (s1)), (__o->next_free), (__len)); __o->next_free += __len; (void) 0; });
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 4
23 4
24 4
25 4
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
add    $0x4,%rax
cmp    $0x18,%rax
jne    4c <saveOldColors+0x5>
repz retq 
<<<sep_in_sample>>>
saveOldColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    oldFGColors[i] = FG_COLOR[i];
    oldBGColors[i] = BG_COLOR[i];
  }
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 7
6 7
7 4
8 4
9 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  c3 <_linetrimstr_flush+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_linetrimstr_flush(void *data)
{
    struct _linetrimstr *s = data;
    return dico_stream_flush(s->transport);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
je     2e <key_hash_1+0x2e>
mov    $0x0,%eax
movzbl %cl,%esi
movzbl 0x1(%rdx),%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
add    $0x1,%rdx
movzbl (%rdx),%ecx
test   %cl,%cl
jne    f <key_hash_1+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
key_hash_1 (void const *key)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((((const dict_entry *)key)->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpl   $0x1,0x118(%rdi)
jne    18e <a2ps_close_output_session+0x14>
callq  18c <a2ps_close_output_session+0x12>
jmp    195 <a2ps_close_output_session+0x1b>
xchg   %ax,%ax
callq  195 <a2ps_close_output_session+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
a2ps_close_output_session (a2ps_job * job)
{
  switch (job->output_format)
    {
    case ps:
      ps_end (job);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 6
5 6
6 6
7 9
8 11
9 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %edx,%ebp
cmp    $0x3,%sil
je     12e <mc_mac_random+0xa3>
cmp    $0x6,%sil
jne    1bd <mc_mac_random+0x132>
callq  ad <mc_mac_random+0x22>
mov    %rax,%rcx
movabs $0x8080808080808081,%r12
imul   %r12
add    %rcx,%rdx
sar    $0x7,%rdx
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
add    %edx,%ecx
and    $0xfffffffc,%ecx
mov    %cl,(%rbx)
callq  da <mc_mac_random+0x4f>
mov    %rax,%rcx
imul   %r12
add    %rcx,%rdx
sar    $0x7,%rdx
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
sub    %rdx,%rax
sub    %rax,%rcx
mov    %cl,0x1(%rbx)
callq  106 <mc_mac_random+0x7b>
mov    %rax,%rcx
imul   %r12
lea    (%rdx,%rcx,1),%r12
sar    $0x7,%r12
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%r12
mov    %r12,%rax
shl    $0x8,%rax
sub    %r12,%rax
sub    %rax,%rcx
mov    %cl,0x2(%rbx)
callq  133 <mc_mac_random+0xa8>
mov    %rax,%rcx
movabs $0x8080808080808081,%r12
imul   %r12
add    %rcx,%rdx
sar    $0x7,%rdx
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
sub    %rdx,%rax
sub    %rax,%rcx
mov    %cl,0x3(%rbx)
callq  169 <mc_mac_random+0xde>
mov    %rax,%rcx
imul   %r12
add    %rcx,%rdx
sar    $0x7,%rdx
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
sub    %rdx,%rax
sub    %rax,%rcx
mov    %cl,0x4(%rbx)
callq  195 <mc_mac_random+0x10a>
mov    %rax,%rcx
imul   %r12
lea    (%rdx,%rcx,1),%r12
sar    $0x7,%r12
mov    %rcx,%rax
sar    $0x3f,%rax
sub    %rax,%r12
mov    %r12,%rax
shl    $0x8,%rax
sub    %r12,%rax
sub    %rax,%rcx
mov    %cl,0x5(%rbx)
test   %bpl,%bpl
je     1c7 <mc_mac_random+0x13c>
andb   $0xfd,(%rbx)
jmp    1ca <mc_mac_random+0x13f>
orb    $0x2,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mc_mac_random (mac_t *mac, unsigned char last_n_bytes, char set_bia)
{
 switch (last_n_bytes) {
 case 6:
  mac->byte[0] = (random()%255) & 0xFC;
  mac->byte[1] = random()%255;
  mac->byte[2] = random()%255;
 case 3:
  mac->byte[3] = random()%255;
  mac->byte[4] = random()%255;
  mac->byte[5] = random()%255;
 }
 if (set_bia) {
  mac->byte[0] &= ~2;
 } else {
  mac->byte[0] |= 2;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 10
63 10
64 10
65 10
66 10
67 10
68 10
69 10
70 10
71 10
72 10
73 10
74 10
75 11
76 11
77 11
78 11
79 11
80 11
81 11
82 11
83 11
84 11
85 11
86 11
87 11
88 13
89 13
90 14
91 14
92 16
93 18
94 18
95 18
96 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0xa0(%rdi),%rax
movl   $0xffffffff,(%rax)
mov    0xa0(%rdi),%rax
movq   $0xffffffffffffffff,0x8(%rax)
mov    $0x13,%esi
callq  2bb <osip_nist_timeout_j_event+0x2a>
mov    %rbx,%rsi
mov    $0x3,%edi
callq  2c8 <osip_nist_timeout_j_event+0x37>
pop    %rbx
retq   
<<<sep_in_sample>>>
osip_nist_timeout_j_event (osip_transaction_t * nist, osip_event_t * evt)
{
  nist->nist_context->timer_j_length = -1;
  nist->nist_context->timer_j_start.tv_sec = -1;
  __osip_transaction_set_state (nist, NIST_TERMINATED);
  __osip_kill_transaction_callback (OSIP_NIST_KILL_TRANSACTION, nist);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 7
<<<sep_out_sample>>>
movslq %esi,%rax
mov    0x0(,%rax,4),%r11d
lea    (%rsi,%rsi,1),%eax
mov    0x0(%rip),%r8d        # a9 <pqdownheap+0x15>
cmp    %r8d,%eax
jg     16f <pqdownheap+0xdb>
push   %r12
push   %rbp
push   %rbx
movslq %r11d,%rdx
movzwl (%rdi,%rdx,4),%r9d
mov    %rdx,%r10
cmp    %eax,%r8d
jle    112 <pqdownheap+0x7e>
lea    0x1(%rax),%edx
movslq %edx,%rcx
mov    0x0(,%rcx,4),%r12d
movslq %r12d,%rcx
movzwl (%rdi,%rcx,4),%ebx
movslq %eax,%rcx
mov    0x0(,%rcx,4),%ebp
movslq %ebp,%rcx
movzwl (%rdi,%rcx,4),%ecx
cmp    %cx,%bx
jb     110 <pqdownheap+0x7c>
cmp    %cx,%bx
jne    112 <pqdownheap+0x7e>
movslq %r12d,%r12
movslq %ebp,%rbp
movzbl 0x0(%r12),%ecx
cmp    0x0(%rbp),%cl
cmovbe %edx,%eax
jmp    112 <pqdownheap+0x7e>
mov    %edx,%eax
movslq %eax,%rdx
mov    0x0(,%rdx,4),%edx
movslq %edx,%rcx
movzwl (%rdi,%rcx,4),%ecx
cmp    %cx,%r9w
jb     15f <pqdownheap+0xcb>
cmp    %cx,%r9w
jne    142 <pqdownheap+0xae>
movslq %edx,%rcx
movzbl 0x0(%rcx),%ebx
cmp    %bl,0x0(%r10)
jbe    15f <pqdownheap+0xcb>
movslq %esi,%rsi
mov    %edx,0x0(,%rsi,4)
lea    (%rax,%rax,1),%edx
cmp    %r8d,%edx
jg     15d <pqdownheap+0xc9>
mov    %eax,%esi
mov    %edx,%eax
jmpq   c1 <pqdownheap+0x2d>
mov    %eax,%esi
movslq %esi,%rsi
mov    %r11d,0x0(,%rsi,4)
pop    %rbx
pop    %rbp
pop    %r12
retq   
movslq %esi,%rsi
mov    %r11d,0x0(,%rsi,4)
retq   
<<<sep_in_sample>>>
pqdownheap(tree, k)
    ct_data *tree;
    int k;
{
    int v = heap[k];
    int j = k << 1;
    while (j <= heap_len) {
        if (j < heap_len && (tree[heap[j+1]].fc.freq < tree[heap[j]].fc.freq || (tree[heap[j+1]].fc.freq == tree[heap[j]].fc.freq && depth[heap[j+1]] <= depth[heap[j]]))) j++;
        if ((tree[v].fc.freq < tree[heap[j]].fc.freq || (tree[v].fc.freq == tree[heap[j]].fc.freq && depth[v] <= depth[heap[j]]))) break;
        heap[k] = heap[j]; k = j;
        j <<= 1;
    }
    heap[k] = v;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 7
5 7
6 7
7 4
8 4
9 4
10 9
11 9
12 9
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 10
48 10
49 11
50 7
51 7
52 7
53 11
54 11
55 11
56 13
57 13
58 14
59 14
60 14
61 14
62 13
63 13
64 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %r8,%rbp
mov    %r9,%rbx
mov    0x40(%rsp),%r12
mov    0x10(%r9),%rax
test   %rax,%rax
je     7e5 <gsl_multifit_nlinear_eval_fvv+0x31>
mov    0x28(%r9),%rdx
mov    %r12,%rcx
callq  *%rax
mov    %eax,%r13d
addq   $0x1,0x40(%rbx)
jmp    7fb <gsl_multifit_nlinear_eval_fvv+0x47>
mov    0x48(%rsp),%rax
mov    %rax,0x8(%rsp)
mov    %r12,(%rsp)
callq  7f8 <gsl_multifit_nlinear_eval_fvv+0x44>
mov    %eax,%r13d
test   %rbp,%rbp
je     80b <gsl_multifit_nlinear_eval_fvv+0x57>
mov    %rbp,%rsi
mov    %r12,%rdi
callq  80b <gsl_multifit_nlinear_eval_fvv+0x57>
mov    %r13d,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_multifit_nlinear_eval_fvv(const double h,
                              const gsl_vector *x,
                              const gsl_vector *v,
                              const gsl_vector *f,
                              const gsl_matrix *J,
                              const gsl_vector *swts,
                              gsl_multifit_nlinear_fdf *fdf,
                              gsl_vector *yvv, gsl_vector *work)
{
  int status;
  if (fdf->fvv != ((void *)0))
    {
      status = ((*((fdf)->fvv)) (x, v, fdf->params, yvv));
      ++(fdf->nevalfvv);
    }
  else
    {
      status = gsl_multifit_nlinear_fdfvv(h, x, v, f, J,
                                          swts, fdf, yvv, work);
    }
  if (swts)
    gsl_vector_mul(yvv, swts);
  return status;
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 11
10 11
11 11
12 13
13 13
14 13
15 13
16 14
17 14
18 18
19 18
20 18
21 18
22 18
23 21
24 21
25 22
26 22
27 22
28 24
29 24
30 24
31 24
32 24
33 24
34 24
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rsi        # 2a9d <vapply+0x8>
callq  2aa2 <vapply+0xd>
mov    %rax,%rbx
test   %rax,%rax
je     2ab2 <vapply+0x1d>
mov    %rax,%rdi
callq  2ab2 <vapply+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
vapply (func)
     sh_var_map_func_t *func;
{
  SHELL_VAR **list;
  list = map_over (func, shell_variables);
  if (list )
    sort_variables (list);
  return (list);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 6
6 6
7 7
8 7
9 9
10 9
11 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rax
mov    (%rsi),%r10
cmp    (%rdi),%r10
jne    3a9a <gsl_matrix_uchar_sub+0x1f>
mov    0x8(%rsi),%rbx
cmp    %rax,%rbx
je     3aba <gsl_matrix_uchar_sub+0x3f>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3ab3 <gsl_matrix_uchar_sub+0x38>
mov    $0x13,%eax
jmp    3b24 <gsl_matrix_uchar_sub+0xa9>
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%r13
test   %r10,%r10
je     3b18 <gsl_matrix_uchar_sub+0x9d>
sub    %r12,%r13
mov    $0x0,%r8d
mov    $0x0,%r11d
mov    $0x0,%ebp
jmp    3b0a <gsl_matrix_uchar_sub+0x8f>
mov    %rax,%rdx
add    0x18(%rdi),%rdx
mov    %rax,%rcx
add    0x18(%rsi),%rcx
movzbl (%rcx,%r8,1),%ecx
sub    %cl,(%rdx)
add    $0x1,%rax
cmp    %r9,%rax
jne    3add <gsl_matrix_uchar_sub+0x62>
add    $0x1,%rbp
add    %r12,%r11
add    %r13,%r8
cmp    %r10,%rbp
je     3b1f <gsl_matrix_uchar_sub+0xa4>
test   %rbx,%rbx
je     3afb <gsl_matrix_uchar_sub+0x80>
lea    (%r11,%rbx,1),%r9
mov    %r11,%rax
jmp    3add <gsl_matrix_uchar_sub+0x62>
mov    $0x0,%eax
jmp    3b24 <gsl_matrix_uchar_sub+0xa9>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_sub (gsl_matrix_uchar * a, const gsl_matrix_uchar * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 11
21 12
22 14
23 14
24 14
25 14
26 14
27 14
28 14
29 18
30 18
31 18
32 18
33 18
34 18
35 18
36 16
37 16
38 14
39 14
40 14
41 14
42 14
43 16
44 16
45 16
46 16
47 16
48 21
49 21
50 21
51 23
52 23
53 23
54 23
55 23
56 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1105 <gsl_permute_vector_long_inverse+0x2c>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10fe <gsl_permute_vector_long_inverse+0x25>
mov    $0x13,%eax
jmp    111b <gsl_permute_vector_long_inverse+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  1116 <gsl_permute_vector_long_inverse+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_long_inverse (const gsl_permutation * p, gsl_vector_long * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_long_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cvtsi2sdl 0x0(%rip),%xmm0        # 7675 <rnd+0xc>
mulsd  0x0(%rip),%xmm0        # 767d <rnd+0x14>
movsd  0x0(%rip),%xmm1        # 7685 <rnd+0x1c>
callq  768a <rnd+0x21>
cvttsd2si %xmm0,%eax
mov    %eax,0x0(%rip)        # 7694 <rnd+0x2b>
cvtsi2sd %eax,%xmm0
mulsd  0x0(%rip),%xmm0        # 76a0 <rnd+0x37>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rnd(void){
  ISEED = fmod(1027.*ISEED, 1048576.);
  return (ISEED/1048576.);
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x1005,%eax
test   %rdi,%rdi
je     98 <mu_property_create+0x87>
mov    %rsi,%r12
mov    $0x18,%esi
mov    $0x1,%edi
callq  3a <mu_property_create+0x29>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     98 <mu_property_create+0x87>
mov    $0x0,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  59 <mu_property_create+0x48>
mov    %eax,%r13d
test   %eax,%eax
je     6d <mu_property_create+0x5c>
mov    %rbx,%rdi
callq  68 <mu_property_create+0x57>
mov    %r13d,%eax
jmp    98 <mu_property_create+0x87>
mov    $0x0,%esi
mov    (%rbx),%rdi
callq  7a <mu_property_create+0x69>
lea    0x10(%rbx),%rdi
mov    %rbx,%rdx
mov    $0x0,%esi
callq  8b <mu_property_create+0x7a>
mov    %r12,0x8(%rbx)
mov    %rbx,0x0(%rbp)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_property_create (mu_property_t *pp, void *owner)
{
  int rc;
  mu_property_t prop;
  if (pp == ((void *)0))
    return (0x1000 +5);
  prop = calloc (1, sizeof *prop);
  if (prop == ((void *)0))
    return 12;
  rc = mu_assoc_create (&prop->assoc, sizeof (struct property_item), 0);
  if (rc)
    {
      free (prop);
      return rc;
    }
  mu_assoc_set_free (prop->assoc, prop_free_value);
  mu_monitor_create (&prop->lock, 0, prop);
  prop->owner = owner;
  *pp = prop;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 9
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 13
26 13
27 14
28 14
29 16
30 16
31 16
32 17
33 17
34 17
35 17
36 18
37 19
38 20
39 21
40 21
41 21
42 21
43 21
44 21
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
movapd %xmm0,%xmm3
movsd  %xmm1,0x8(%rsp)
movsd  %xmm2,(%rsp)
mov    (%rsp),%rbx
xorpd  %xmm0,%xmm0
movsd  %xmm3,(%rsp)
ucomisd %xmm3,%xmm0
jae    9d <gsl_ran_erlang_pdf+0x83>
mov    %rbx,0x10(%rsp)
movapd %xmm2,%xmm0
callq  4f <gsl_ran_erlang_pdf+0x35>
movsd  %xmm0,0x10(%rsp)
movsd  (%rsp),%xmm3
divsd  0x8(%rsp),%xmm3
movsd  %xmm3,(%rsp)
movapd %xmm3,%xmm0
callq  6e <gsl_ran_erlang_pdf+0x54>
mov    %rbx,0x18(%rsp)
movsd  0x18(%rsp),%xmm1
subsd  0x0(%rip),%xmm1        # 81 <gsl_ran_erlang_pdf+0x67>
mulsd  %xmm1,%xmm0
subsd  (%rsp),%xmm0
subsd  0x10(%rsp),%xmm0
callq  95 <gsl_ran_erlang_pdf+0x7b>
divsd  0x8(%rsp),%xmm0
jmp    a1 <gsl_ran_erlang_pdf+0x87>
xorpd  %xmm0,%xmm0
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_ran_erlang_pdf (const double x, const double a, const double n)
{
  if (x <= 0)
    {
      return 0 ;
    }
  else
    {
      double p;
      double lngamma = gsl_sf_lngamma (n);
      p = exp ((n - 1) * log (x/a) - x/a - lngamma) / a;
      return p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 10
12 10
13 10
14 10
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 12
29 5
30 14
31 14
32 14
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm3        # 26a <seor+0x8>
xorpd  %xmm0,%xmm3
cvtsi2ss %edi,%xmm4
unpcklps %xmm4,%xmm4
cvtps2pd %xmm4,%xmm4
movsd  0x0(%rip),%xmm2        # 280 <seor+0x1e>
mulsd  %xmm2,%xmm4
subsd  %xmm2,%xmm4
cvttsd2si %xmm4,%edx
test   %edx,%edx
jle    2d4 <seor+0x72>
movapd %xmm0,%xmm5
mulsd  %xmm0,%xmm5
mov    $0x0,%eax
movsd  0x0(%rip),%xmm4        # 2a5 <seor+0x43>
cvtsi2sd %eax,%xmm2
addsd  %xmm2,%xmm2
addsd  %xmm4,%xmm2
mulsd  %xmm2,%xmm2
movapd %xmm1,%xmm6
subsd  %xmm2,%xmm6
movapd %xmm6,%xmm2
subsd  %xmm3,%xmm2
movapd %xmm5,%xmm3
divsd  %xmm2,%xmm3
add    $0x1,%eax
cmp    %edx,%eax
jne    2a5 <seor+0x43>
mov    %edi,%eax
imul   %edi,%eax
cvtsi2sd %eax,%xmm4
addsd  %xmm4,%xmm3
xorpd  %xmm4,%xmm4
test   %esi,%esi
jle    324 <seor+0xc2>
mulsd  %xmm0,%xmm0
xorpd  %xmm4,%xmm4
cvtsi2sd %edi,%xmm5
cvtsi2sd %esi,%xmm2
addsd  %xmm2,%xmm2
addsd  %xmm5,%xmm2
mulsd  %xmm2,%xmm2
movapd %xmm1,%xmm7
subsd  %xmm2,%xmm7
movapd %xmm7,%xmm2
subsd  %xmm4,%xmm2
movapd %xmm0,%xmm4
divsd  %xmm2,%xmm4
sub    $0x1,%esi
jne    2f5 <seor+0x93>
jmp    324 <seor+0xc2>
addsd  %xmm3,%xmm4
movapd %xmm4,%xmm0
subsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
seor(int order, double qq, double aa, int nterms)
{
  double term, term1;
  int ii, n1;
  term = -1.0*qq;
  n1 = (int)((float)order/2.0 - 0.5);
  for (ii=0; ii<n1; ii++)
      term = qq*qq/(aa - (2.0*ii + 1.0)*(2.0*ii + 1.0) - term);
  term += order*order;
  term1 = 0.0;
  for (ii=0; ii<nterms; ii++)
      term1 = qq*qq/
        (aa - (order + 2.0*(nterms - ii))*(order + 2.0*(nterms - ii)) - term1);
  return (term + term1 - aa);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 7
11 7
12 8
13 8
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 7
28 7
29 9
30 9
31 9
32 9
33 10
34 11
35 11
36 12
37 10
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 12
48 12
49 11
50 11
51 11
52 14
53 14
54 14
55 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rsi
mov    %ecx,%edx
mov    %r8,%rcx
callq  201a <asn1_der_decoding_element+0x11>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
asn1_der_decoding_element (asn1_node * structure, const char *elementName,
      const void *ider, int len, char *errorDescription)
{
  return asn1_der_decoding(structure, ider, len, errorDescription);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
movl   $0x2,0x18(%rsi)
movl   $0xff,0x3c(%rsi)
test   %rdi,%rdi
je     196 <set_geom+0x45>
movzbl 0x19(%rdi),%ecx
shl    $0x8,%ecx
movzbl 0x18(%rdi),%eax
add    %eax,%ecx
movzwl %cx,%ecx
mov    %ecx,0x1c(%rsi)
movzbl 0x14(%rdi),%edx
shl    $0x8,%edx
movzbl 0x13(%rdi),%eax
add    %dx,%ax
je     196 <set_geom+0x45>
movzwl %ax,%eax
mov    $0x0,%edx
div    %ecx
shr    %eax
mov    %eax,0x14(%rsi)
repz retq 
<<<sep_in_sample>>>
set_geom(union bootsector *boot, struct device *dev)
{
 dev->heads = 2;
 dev->use_2m = 0xff;
 if(boot) {
  dev->sectors = (((unsigned short)((unsigned char)(boot->boot.nsect)[0] + (((unsigned char)(boot->boot.nsect)[1]) << 8))));
  if((((unsigned short)((unsigned char)(boot->boot.psect)[0] + (((unsigned char)(boot->boot.psect)[1]) << 8)))))
   dev->tracks = (((unsigned short)((unsigned char)(boot->boot.psect)[0] + (((unsigned char)(boot->boot.psect)[1]) << 8)))) / dev->sectors / 2;
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     405 <gsasl_client_callback_maxbuf_get+0xa>
mov    0x68(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_maxbuf_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_maxbuf : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
cmp    %rdx,%rdi
je     3a9 <symlink_ancestry+0x2f>
testb  $0x10,0x8(%rdi)
jne    3af <symlink_ancestry+0x35>
mov    $0x0,%eax
jmp    398 <symlink_ancestry+0x1e>
testb  $0x10,0x8(%rdx)
jne    3b4 <symlink_ancestry+0x3a>
mov    %rcx,%rdx
add    $0x1,%eax
mov    (%rdx),%rcx
cmp    %rdx,%rcx
jne    38f <symlink_ancestry+0x15>
mov    $0x1000,%eax
retq   
mov    $0x1000,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
symlink_ancestry (struct file_link *flink)
{
  int ancestry = 0;
  while (!((flink)->fl_u.u_parent == (flink)))
    {
      if (flink->fl_flags & (1<<4))
 return ancestry;
      ancestry++;
      flink = flink->fl_u.u_parent;
    }
  return 4096;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 3
7 3
8 6
9 6
10 4
11 8
12 4
13 4
14 4
15 11
16 11
17 11
18 11
19 3
20 12
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%eax
callq  948 <il_kill_line+0xd>
mov    $0x0,%eax
callq  952 <il_kill_line+0x17>
mov    $0x0,%eax
callq  95c <il_kill_line+0x21>
or     $0x2,%ebx
mov    %ebx,%edi
mov    $0x0,%eax
callq  6c <il_region_command>
mov    0x0(%rip),%rax        # 972 <il_kill_line+0x37>
mov    0x18(%rax),%rdx
mov    %rdx,0x20(%rax)
movl   $0xd,0x10(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
il_kill_line(store)
    int store;
{
    il_beginning_of_line();
    il_set_mark();
    il_end_of_line();
    il_region_command(store | 2);
    il->mark = il->point;
    il->last_operation = 13;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 9
17 10
18 10
<<<sep_out_sample>>>
sub    $0x38,%rsp
divsd  0x0(%rip),%xmm0        # 10651 <c12i+0xc>
movsd  0x0(%rip),%xmm4        # 10659 <c12i+0x14>
movsd  %xmm4,0x8(%rsp)
movsd  0x0(%rip),%xmm1        # 10667 <c12i+0x22>
movsd  %xmm0,(%rsp)
callq  10671 <c12i+0x2c>
movsd  %xmm0,0x20(%rsp)
movsd  0x0(%rip),%xmm5        # 1067f <c12i+0x3a>
movsd  %xmm5,0x10(%rsp)
movsd  0x0(%rip),%xmm1        # 1068d <c12i+0x48>
movsd  (%rsp),%xmm0
callq  10697 <c12i+0x52>
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm6        # 106a5 <c12i+0x60>
movsd  %xmm6,0x18(%rsp)
movsd  0x0(%rip),%xmm1        # 106b3 <c12i+0x6e>
movsd  (%rsp),%xmm0
callq  106bd <c12i+0x78>
movsd  0x8(%rsp),%xmm2
mulsd  0x20(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
mulsd  0x28(%rsp),%xmm5
movapd %xmm5,%xmm1
addsd  %xmm2,%xmm1
mulsd  0x18(%rsp),%xmm0
addsd  %xmm1,%xmm0
movsd  (%rsp),%xmm3
movapd %xmm3,%xmm1
mulsd  %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 106fc <c12i+0xb7>
addsd  %xmm1,%xmm0
movapd %xmm3,%xmm1
mulsd  0x0(%rip),%xmm1        # 1070c <c12i+0xc7>
addsd  %xmm1,%xmm0
addsd  0x0(%rip),%xmm0        # 10718 <c12i+0xd3>
mulsd  0x0(%rip),%xmm0        # 10720 <c12i+0xdb>
divsd  0x0(%rip),%xmm0        # 10728 <c12i+0xe3>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
c12i(double t)
{
 double W=t/Q;
 return(c12[1]*pow(W,5.)+c12[2]*pow(W,4.)
  +c12[3]*pow(W,3.)+c12[4]*pow(W,2.)+c12[5]*W+c12[6])*1.e-3/Q;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 4
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 4
39 6
40 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     32 <fwrite_uppcase+0x32>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbx
mov    %rdx,%rbp
movzbl (%rbx),%edi
callq  1a <fwrite_uppcase+0x1a>
mov    %r12,%rsi
mov    %eax,%edi
callq  24 <fwrite_uppcase+0x24>
add    $0x1,%rbx
sub    $0x1,%rbp
jne    12 <fwrite_uppcase+0x12>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
fwrite_uppcase (FILE *fp, const char *src, size_t len)
{
  while (len-- > 0)
    {
      fputc (toupper ((unsigned char) *src), fp);
      ++src;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 3
16 3
17 8
18 8
19 8
20 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  ac3 <parse_lparen_in_decl+0x9>
mov    0x0(%rip),%rax        # aca <parse_lparen_in_decl+0x10>
movslq 0x38(%rax),%rdx
mov    0x10(%rax),%rax
movl   $0x20,(%rax,%rdx,4)
mov    0x0(%rip),%rax        # ae0 <parse_lparen_in_decl+0x26>
mov    0x88(%rax),%ecx
movslq 0x38(%rax),%rdx
mov    0x20(%rax),%rax
mov    %ecx,(%rax,%rdx,4)
callq  af6 <parse_lparen_in_decl+0x3c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_lparen_in_decl (void)
{
  inc_pstack ();
  parser_state_tos->p_stack[parser_state_tos->tos] = stmt;
  parser_state_tos->il[parser_state_tos->tos] = parser_state_tos->ind_level;
  reduce ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 6
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <file_name_concat+0x9>
test   %rax,%rax
jne    13 <file_name_concat+0x13>
callq  13 <file_name_concat+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
file_name_concat (char const *dir, char const *abase, char **base_in_result)
{
  char *p = mfile_name_concat (dir, abase, base_in_result);
  if (p == ((void *)0))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 5
6 7
7 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
movb   $0x0,0xf(%rsp)
mov    $0x0,%ebx
movslq %edx,%rdx
mov    %rdx,%r12
shl    $0x4,%r12
add    %rsi,%r12
lea    (%rsi,%rdx,8),%r13
jmp    8d3 <dotlines+0x71>
lea    0x0(,%rbx,8),%r14
mov    0x38(%r13),%rax
mov    (%rax,%rbx,8),%rbp
cmpb   $0x2e,0x0(%rbp)
jne    8b8 <dotlines+0x56>
mov    %r15,%rsi
mov    $0x2e,%edi
callq  8b3 <dotlines+0x51>
movb   $0x1,0xf(%rsp)
mov    0x50(%r13),%rax
mov    (%rax,%r14,1),%rdx
mov    %r15,%rcx
mov    $0x1,%esi
mov    %rbp,%rdi
callq  8d0 <dotlines+0x6e>
inc    %rbx
mov    0x10(%r12),%rax
sub    0x8(%r12),%rax
inc    %rax
cmp    %rbx,%rax
jg     890 <dotlines+0x2e>
mov    0xf(%rsp),%al
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
{
  lin i;
  _Bool leading_dot = 0;
  for (i = 0;
       i < (((b)->ranges[filenum][1]) - ((b)->ranges[filenum][0]) + 1);
       i++)
    {
      char *line = ((b)->lines[filenum][i]);
      if (line[0] == '.')
 {
   leading_dot = 1;
   fputc_unlocked ('.',outputfile);
 }
      fwrite_unlocked (line,sizeof (char),((b)->lengths[filenum][i]),outputfile)
                                            ;
    }
  return leading_dot;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 5
11 6
12 6
13 6
14 6
15 6
16 5
17 5
18 9
19 9
20 10
21 10
22 13
23 13
24 13
25 12
26 15
27 15
28 15
29 15
30 15
31 15
32 7
33 6
34 6
35 6
36 5
37 5
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%eax        # 1f4 <output_dataset_separator+0xa>
cmp    $0x2,%eax
je     20f <output_dataset_separator+0x25>
cmp    $0x3,%eax
je     25f <output_dataset_separator+0x75>
cmp    $0x1,%eax
je     23a <output_dataset_separator+0x50>
mov    $0xa,%edi
callq  20d <output_dataset_separator+0x23>
jmp    282 <output_dataset_separator+0x98>
movsd  0x0(%rip),%xmm0        # 217 <output_dataset_separator+0x2d>
movsd  %xmm0,0x8(%rsp)
mov    0x0(%rip),%rcx        # 224 <output_dataset_separator+0x3a>
mov    $0x1,%edx
mov    $0x8,%esi
lea    0x8(%rsp),%rdi
callq  238 <output_dataset_separator+0x4e>
jmp    282 <output_dataset_separator+0x98>
movl   $0x7f7fffff,0x8(%rsp)
mov    0x0(%rip),%rcx        # 249 <output_dataset_separator+0x5f>
mov    $0x1,%edx
mov    $0x4,%esi
lea    0x8(%rsp),%rdi
callq  25d <output_dataset_separator+0x73>
jmp    282 <output_dataset_separator+0x98>
movl   $0x7fffffff,0x8(%rsp)
mov    0x0(%rip),%rcx        # 26e <output_dataset_separator+0x84>
mov    $0x1,%edx
mov    $0x4,%esi
lea    0x8(%rsp),%rdi
callq  282 <output_dataset_separator+0x98>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
output_dataset_separator (void)
{
  double ddummy;
  float fdummy;
  int idummy;
  switch (output_type)
    {
    case T_ASCII:
    default:
      printf ("\n");
      break;
    case T_DOUBLE:
      ddummy = ((double)1.79769313486231570815e+308L);
      fwrite ((void *) &ddummy, sizeof(ddummy), 1, stdout);
      break;
    case T_SINGLE:
      fdummy = 3.40282346638528859812e+38F;
      fwrite ((void *) &fdummy, sizeof(fdummy), 1, stdout);
      break;
    case T_INTEGER:
      idummy = 2147483647;
      fwrite ((void *) &idummy, sizeof(idummy), 1, stdout);
      break;
    }
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 10
10 10
11 11
12 13
13 13
14 14
15 14
16 14
17 14
18 14
19 15
20 17
21 18
22 18
23 18
24 18
25 18
26 19
27 21
28 22
29 22
30 22
31 22
32 22
33 25
34 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0x78,%rdi
mov    $0x64,%edx
callq  0 <ahsStaticSetTarname_i>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ahsStaticSetTarLinkname(struct new_cpio_header * file_hdr, char * name)
{
 ;
 ahsStaticSetTarname_i((STROB**)&(file_hdr->c_tar_linkname), name, 100);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3c <gss_unseal+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gss_unseal (OM_uint32 * minor_status,
     gss_ctx_id_t context_handle,
     gss_buffer_t input_message_buffer,
     gss_buffer_t output_message_buffer,
     int *conf_state, int *qop_state)
{
  return gss_unwrap (minor_status, context_handle, input_message_buffer,
       output_message_buffer, conf_state,
       (gss_qop_t *) qop_state);
}
<<<sep_in_sample>>>
1 6
2 7
3 10
4 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x0,%esi
callq  13 <write_file+0x13>
mov    %rax,%rbx
test   %rax,%rax
jne    2c <write_file+0x2c>
mov    $0x0,%edi
callq  25 <write_file+0x25>
mov    $0xffffffff,%eax
jmp    54 <write_file+0x54>
mov    %rax,%rsi
mov    %rbp,%rdi
callq  37 <write_file+0x37>
test   %eax,%eax
jle    4f <write_file+0x4f>
mov    %rbx,%rdi
callq  43 <write_file+0x43>
test   %eax,%eax
setne  %al
movzbl %al,%eax
neg    %eax
jmp    54 <write_file+0x54>
mov    $0xffffffff,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
write_file (const char *filename, const char *data)
{
  FILE *fh;
  fh = fopen (filename, "w");
  if (!fh)
    {
      perror ("fopen");
      return -1;
    }
  if (fputs (data, fh) <= 0)
    return -1;
  if (fclose (fh) != 0)
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 11
27 15
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 245e <c_pop_buffer_state+0xb>
test   %rbx,%rbx
je     24b5 <c_pop_buffer_state+0x62>
mov    0x0(%rip),%rbp        # 246a <c_pop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     24b5 <c_pop_buffer_state+0x62>
callq  247c <c_pop_buffer_state+0x29>
movq   $0x0,(%r12)
test   %rbp,%rbp
je     24a7 <c_pop_buffer_state+0x54>
sub    $0x1,%rbp
mov    %rbp,0x0(%rip)        # 2494 <c_pop_buffer_state+0x41>
jmp    24a7 <c_pop_buffer_state+0x54>
callq  d5 <c__load_buffer_state>
movl   $0x1,0x0(%rip)        # 24a5 <c_pop_buffer_state+0x52>
jmp    24b5 <c_pop_buffer_state+0x62>
mov    0x0(%rip),%rax        # 24ae <c_pop_buffer_state+0x5b>
cmpq   $0x0,(%rbx,%rax,8)
jne    2496 <c_pop_buffer_state+0x43>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
c_pop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 c__delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  c__load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 6
14 7
15 7
16 8
17 8
18 8
19 10
20 11
21 11
22 9
23 9
24 9
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x1006,%eax
test   %rdi,%rdi
je     80c <mu_mailbox_set_locker+0x2f>
mov    %rsi,%rbp
cmpq   $0x0,0x18(%rdi)
je     803 <mu_mailbox_set_locker+0x26>
lea    0x18(%rdi),%rdi
callq  803 <mu_mailbox_set_locker+0x26>
mov    %rbp,0x18(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_mailbox_set_locker (mu_mailbox_t mbox, mu_locker_t locker)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (mbox->locker)
    mu_locker_destroy (&mbox->locker);
  mbox->locker = locker;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 5
10 5
11 6
12 6
13 7
14 8
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1ef <data_in_list+0x26>
mov    0x8(%rsi),%rax
test   %rax,%rax
je     1f5 <data_in_list+0x2c>
cmp    %rdi,0x18(%rax)
jne    1e5 <data_in_list+0x1c>
jmp    1fb <data_in_list+0x32>
cmp    %rdi,0x18(%rax)
je     201 <data_in_list+0x38>
mov    (%rax),%rax
test   %rax,%rax
jne    1df <data_in_list+0x16>
repz retq 
mov    $0x0,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
data_in_list(void *data, struct linked_list *list)
{
     struct linked_list_entry *p;
     for (p = ((list) ? (list)->head : ((void *)0)); p; p = p->next)
   if (p->data == data)
        return 1;
     return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 4
12 4
13 4
14 4
15 7
16 7
17 7
18 7
19 6
20 6
21 6
22 8
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
playContinuousSound(craft * c, int id)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
cmpb   $0x0,(%rdi)
je     7f <utf8_strlen+0x2c>
mov    $0x0,%ebp
jmp    70 <utf8_strlen+0x1d>
add    $0x1,%rbp
add    %rax,%rbx
cmpb   $0x0,(%rbx)
je     84 <utf8_strlen+0x31>
mov    %rbx,%rdi
callq  78 <utf8_strlen+0x25>
test   %rax,%rax
jne    64 <utf8_strlen+0x11>
jmp    84 <utf8_strlen+0x31>
mov    $0x0,%ebp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
utf8_strlen(const char *s)
{
    size_t len = 0;
    size_t n;
    while (*s && (n = utf8_char_width(s)) != 0) {
 len++;
 s += n;
    }
    return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 3
7 3
8 6
9 7
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 3
18 10
19 10
20 10
21 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rcx,%rbx
mov    (%rcx),%rax
mov    0x10(%rcx),%rcx
callq  *0x10(%rax)
mov    %eax,%ebp
mov    (%rbx),%rax
mov    0x10(%rbx),%rdi
callq  *0x18(%rax)
movsd  %xmm0,0x8(%rbx)
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_splinalg_itersolve_iterate(const gsl_spmatrix *A, const gsl_vector *b,
                               const double tol, gsl_vector *x,
                               gsl_splinalg_itersolve *w)
{
  int status = w->type->iterate(A, b, tol, x, w->state);
  w->normr = w->type->normr(w->state);
  return status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  daa <gsl_sf_laguerre_n+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     dd0 <gsl_sf_laguerre_n+0x32>
mov    %eax,%ecx
mov    $0x14e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  dc9 <gsl_sf_laguerre_n+0x2b>
movsd  (%rsp),%xmm0
jmp    dd0 <gsl_sf_laguerre_n+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_laguerre_n(int n, double a, double x)
{
  gsl_sf_result result; int status = gsl_sf_laguerre_n_e(n, a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_laguerre_n_e(n, a, x, &result)", "laguerre.c", 334, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r13
mov    0x8(%rdi),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     56b <hol_find_entry+0x7d>
mov    %rsi,%r12
mov    %edx,%eax
add    $0x1,%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
lea    0x0(%r13,%rax,1),%r14
mov    0x0(%r13),%rbx
mov    0x8(%r13),%eax
lea    -0x1(%rax),%edx
test   %eax,%eax
je     560 <hol_find_entry+0x72>
mov    %edx,%eax
lea    0x3(%rax,%rax,2),%rbp
shl    $0x4,%rbp
add    %rbx,%rbp
mov    (%rbx),%rdi
test   %rdi,%rdi
je     557 <hol_find_entry+0x69>
testb  $0x2,0x18(%rbx)
jne    557 <hol_find_entry+0x69>
mov    %r12,%rsi
callq  553 <hol_find_entry+0x65>
test   %eax,%eax
je     572 <hol_find_entry+0x84>
add    $0x30,%rbx
cmp    %rbp,%rbx
jne    53d <hol_find_entry+0x4f>
add    $0x38,%r13
cmp    %r14,%r13
jne    520 <hol_find_entry+0x32>
jmp    577 <hol_find_entry+0x89>
mov    $0x0,%eax
jmp    57c <hol_find_entry+0x8e>
mov    %r13,%rax
jmp    57c <hol_find_entry+0x8e>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
hol_find_entry (struct hol *hol, const char *name)
{
  struct hol_entry *entry = hol->entries;
  unsigned num_entries = hol->num_entries;
  while (num_entries-- > 0)
    {
      const struct argp_option *opt = entry->opt;
      unsigned num_opts = entry->num;
      while (num_opts-- > 0)
        if (opt->name && (! ((opt)->flags & 0x2)) && strcmp (opt->name, name) == 0)
          return entry;
        else
          opt++;
      entry++;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 13
37 9
38 9
39 14
40 5
41 5
42 5
43 16
44 16
45 16
46 16
47 16
48 17
49 17
50 17
51 17
52 17
53 17
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <__rinner+0x7>
mov    (%rax),%rax
movsbl 0x1(%rax),%edx
cmp    %edi,%edx
jle    41 <__rinner+0x41>
movslq %edi,%rdi
mov    0x30(%rax),%rax
mov    0x8(%rax,%rdi,8),%rdx
mov    0x8(%rdx),%rax
mov    0x10(%rdx),%rcx
mov    %eax,%edx
mov    %rax,0x0(%rip)        # 2f <__rinner+0x2f>
mov    %rcx,0x0(%rip)        # 36 <__rinner+0x36>
lea    0x1(%rdx),%eax
mov    %ax,0x0(%rip)        # 40 <__rinner+0x40>
retq   
mov    0x8(%rax),%rdx
mov    0x10(%rax),%rcx
mov    %edx,%eax
mov    %rdx,0x0(%rip)        # 52 <__rinner+0x52>
mov    %rcx,0x0(%rip)        # 59 <__rinner+0x59>
add    $0x2,%eax
mov    %ax,0x0(%rip)        # 63 <__rinner+0x63>
retq   
<<<sep_in_sample>>>
__rinner (int plev)
{
  if (plev <
      __pb->pp->plev)
    {
      __goto = __pb->pp->pref[plev + 1]->adr;
      __goto.ent++;
    }
  else
    {
      __goto = __pb->pp->adr;
      __goto.ent += 2;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 3
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 12
23 12
24 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    $0x0,%r13d
cmpl   $0x0,0x0(%rip)        # 8e1 <printstream+0x1a>
je     8ea <printstream+0x23>
mov    0x28(%rdi),%eax
lea    0x1(%rax),%r13d
cmpl   $0x0,0x0(%rip)        # 8f1 <printstream+0x2a>
je     8fd <printstream+0x36>
mov    0x1c(%r12),%eax
lea    0x1(%r13,%rax,1),%r13d
cmpl   $0x1,0x0(%rip)        # 904 <printstream+0x3d>
sbb    $0xffffffff,%r13d
mov    (%r12),%rbx
test   %rbx,%rbx
je     979 <printstream+0xb2>
mov    $0x0,%ebp
cmpq   $0x1,0x18(%rbx)
je     970 <printstream+0xa9>
test   %ebp,%ebp
jle    95c <printstream+0x95>
mov    $0x2c,%edi
callq  92b <printstream+0x64>
add    $0x2,%ebp
lea    0x0(%rbp,%r13,1),%edx
movzwl 0x42(%rbx),%eax
add    %edx,%eax
cmp    0x0(%rip),%eax        # 93f <printstream+0x78>
jl     952 <printstream+0x8b>
mov    $0xa,%edi
callq  94b <printstream+0x84>
mov    $0x0,%ebp
jmp    95c <printstream+0x95>
mov    $0x20,%edi
callq  95c <printstream+0x95>
movslq 0x1c(%r12),%rdx
movslq 0x28(%r12),%rsi
mov    %rbx,%rdi
callq  95 <printaname>
add    %eax,%ebp
mov    0x10(%rbx),%rbx
test   %rbx,%rbx
jne    916 <printstream+0x4f>
mov    $0xa,%edi
callq  983 <printstream+0xbc>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
printstream (DISPLAY *dp)
{
  extern int termwidth;
  FTSENT *p;
  int col;
  int extwidth;
  extwidth = 0;
  if (f_inode)
    extwidth += dp->s_inode + 1;
  if (f_size)
    extwidth += dp->s_block + 1;
  if (f_type)
    extwidth += 1;
  for (col = 0, p = dp->list; p != ((void *)0); p = p->fts_link)
    {
      if (((p)->fts_number == 1))
 continue;
      if (col > 0)
 {
   putchar (','), col++;
   if (col + 1 + extwidth + p->fts_namelen >= termwidth)
     putchar ('\n'), col = 0;
   else
     putchar (' '), col++;
 }
      col += printaname (p, dp->s_inode, dp->s_block);
    }
  putchar ('\n');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 8
9 8
10 9
11 9
12 10
13 10
14 11
15 11
16 13
17 13
18 14
19 14
20 14
21 14
22 16
23 16
24 18
25 18
26 20
27 20
28 21
29 21
30 21
31 21
32 21
33 21
34 22
35 22
36 22
37 22
38 24
39 24
40 26
41 26
42 26
43 26
44 26
45 14
46 14
47 14
48 28
49 28
50 29
51 29
52 29
53 29
54 29
55 29
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0x130,%edx
mov    $0x0,%esi
mov    $0x28,%edi
callq  31 <copy_cond_command+0x1d>
mov    %rax,%rbx
mov    0x0(%rbp),%eax
mov    %eax,(%rbx)
mov    0x4(%rbp),%eax
mov    %eax,0x4(%rbx)
mov    0x8(%rbp),%eax
mov    %eax,0x8(%rbx)
mov    0x10(%rbp),%rdi
mov    %rdi,%rax
test   %rdi,%rdi
je     56 <copy_cond_command+0x42>
callq  56 <copy_cond_command+0x42>
mov    %rax,0x10(%rbx)
mov    0x18(%rbp),%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     6d <copy_cond_command+0x59>
callq  14 <copy_cond_command>
mov    %rax,0x18(%rbx)
mov    0x20(%rbp),%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     84 <copy_cond_command+0x70>
callq  14 <copy_cond_command>
mov    %rax,0x20(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
copy_cond_command (com)
     COND_COM *com;
{
  COND_COM *new_cond;
  new_cond = (COND_COM *)sh_xmalloc((sizeof (COND_COM)), "copy_cmd.c", 304);
  new_cond->flags = com->flags;
  new_cond->line = com->line;
  new_cond->type = com->type;
  new_cond->op = com->op ? copy_word (com->op) : com->op;
  new_cond->left = com->left ? copy_cond_command (com->left) : (COND_COM *)((void *)0);
  new_cond->right = com->right ? copy_cond_command (com->right) : (COND_COM *)((void *)0);
  return (new_cond);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 8
15 8
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
30 11
31 11
32 11
33 11
34 13
35 13
36 13
37 13
38 13
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    0x20(%rdi),%rsi
mov    %rbx,%rdi
callq  9d <lmniel_gradient+0x10>
movsd  0x0(%rip),%xmm0        # a5 <lmniel_gradient+0x18>
mov    %rbx,%rdi
callq  ad <lmniel_gradient+0x20>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
lmniel_gradient(void *vstate, gsl_vector * g)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  gsl_vector_memcpy(g, state->rhs);
  gsl_vector_scale(g, -1.0);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
push   %rbx
callq  302 <bash_delete_last_history+0x6>
test   %rax,%rax
je     363 <bash_delete_last_history+0x67>
cmpq   $0x0,(%rax)
je     321 <bash_delete_last_history+0x25>
mov    $0x0,%edi
add    $0x1,%edi
movslq %edi,%rdx
cmpq   $0x0,(%rax,%rdx,8)
jne    312 <bash_delete_last_history+0x16>
jmp    326 <bash_delete_last_history+0x2a>
mov    $0x0,%edi
lea    -0x1(%rdi),%ebx
mov    %ebx,%edi
add    0x0(%rip),%edi        # 331 <bash_delete_last_history+0x35>
callq  336 <bash_delete_last_history+0x3a>
mov    $0x0,%edx
test   %rax,%rax
je     368 <bash_delete_last_history+0x6c>
mov    %ebx,%edi
callq  347 <bash_delete_last_history+0x4b>
mov    %eax,%ebx
callq  34e <bash_delete_last_history+0x52>
mov    0x0(%rip),%edi        # 354 <bash_delete_last_history+0x58>
mov    %ebx,%edx
cmp    %edi,%eax
jle    368 <bash_delete_last_history+0x6c>
callq  35f <bash_delete_last_history+0x63>
mov    %ebx,%edx
jmp    368 <bash_delete_last_history+0x6c>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
bash_delete_last_history ()
{
  register int i;
  HIST_ENTRY **hlist, *histent;
  int r;
  hlist = history_list ();
  if (hlist == ((void *)0))
    return 0;
  for (i = 0; hlist[i]; i++)
    ;
  i--;
  histent = history_get (history_base + i);
  if (histent == ((void *)0))
    return 0;
  r = bash_delete_histent (i);
  if (where_history () > history_length)
    history_set_pos (history_length);
  return r;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 11
15 12
16 12
17 12
18 14
19 13
20 13
21 15
22 15
23 15
24 16
25 16
26 18
27 16
28 16
29 17
30 18
31 18
32 8
33 19
34 19
35 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xe8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->sortedlist_remove (list, compar, elt);
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 5
5 5
<<<sep_out_sample>>>
mov    %rsi,0x88(%rdi)
retq   
<<<sep_in_sample>>>
gsasl_server_callback_securid_set (Gsasl * ctx,
       Gsasl_server_callback_securid cb)
{
  ctx->cbs_securid = cb;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2169 <swverify_inl_delete+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swverify_inl_delete(INFOLINE * inl) {
 free((void*)inl);
}
<<<sep_in_sample>>>
1 1
2 2
3 3
4 3
<<<sep_out_sample>>>
sub    $0x48,%rsp
movsd  %xmm2,0x28(%rsp)
movsd  %xmm3,0x30(%rsp)
movsd  %xmm4,0x38(%rsp)
divsd  %xmm2,%xmm0
movsd  %xmm0,0x18(%rsp)
divsd  %xmm3,%xmm1
movsd  %xmm1,0x20(%rsp)
movapd %xmm4,%xmm0
mulsd  %xmm4,%xmm0
movsd  0x0(%rip),%xmm1        # 192 <gsl_ran_bivariate_gaussian_pdf+0x3a>
subsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rsp)
sqrtsd %xmm1,%xmm3
movsd  %xmm3,0x10(%rsp)
ucomisd %xmm3,%xmm3
jnp    1bb <gsl_ran_bivariate_gaussian_pdf+0x63>
movapd %xmm1,%xmm0
callq  1b5 <gsl_ran_bivariate_gaussian_pdf+0x5d>
movsd  %xmm0,0x10(%rsp)
movsd  0x18(%rsp),%xmm6
movapd %xmm6,%xmm0
mulsd  %xmm6,%xmm0
movsd  0x38(%rsp),%xmm5
movapd %xmm5,%xmm1
addsd  %xmm5,%xmm1
mulsd  %xmm6,%xmm1
movsd  0x20(%rsp),%xmm7
mulsd  %xmm7,%xmm1
subsd  %xmm1,%xmm0
movapd %xmm7,%xmm1
mulsd  %xmm7,%xmm1
addsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 1fd <gsl_ran_bivariate_gaussian_pdf+0xa5>
xorpd  %xmm1,%xmm0
movsd  0x8(%rsp),%xmm4
movapd %xmm4,%xmm1
addsd  %xmm4,%xmm1
divsd  %xmm1,%xmm0
callq  218 <gsl_ran_bivariate_gaussian_pdf+0xc0>
movsd  0x28(%rsp),%xmm2
mulsd  0x0(%rip),%xmm2        # 226 <gsl_ran_bivariate_gaussian_pdf+0xce>
mulsd  0x30(%rsp),%xmm2
mulsd  0x10(%rsp),%xmm2
movsd  0x0(%rip),%xmm1        # 23a <gsl_ran_bivariate_gaussian_pdf+0xe2>
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_bivariate_gaussian_pdf (const double x, const double y,
                                const double sigma_x, const double sigma_y,
                                const double rho)
{
  double u = x / sigma_x ;
  double v = y / sigma_y ;
  double c = 1 - rho*rho ;
  double p = (1 / (2 * 3.14159265358979323846 * sigma_x * sigma_y * sqrt(c)))
    * exp (-(u * u - 2 * rho * u * v + v * v) / (2 * c));
  return p;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 11
49 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1984 <gsl_sf_gamma_inc_Q+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     19aa <gsl_sf_gamma_inc_Q+0x32>
mov    %eax,%ecx
mov    $0x2cb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19a3 <gsl_sf_gamma_inc_Q+0x2b>
movsd  (%rsp),%xmm0
jmp    19aa <gsl_sf_gamma_inc_Q+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_gamma_inc_Q(const double a, const double x)
{
  gsl_sf_result result; int status = gsl_sf_gamma_inc_Q_e(a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_gamma_inc_Q_e(a, x, &result)", "gamma_inc.c", 715, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x68,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x58(%rsp)
xor    %eax,%eax
mov    0x10(%rdi),%rax
mov    (%rax),%rcx
mov    $0x0,%edx
mov    $0x50,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  cd <_PySelectionKey_repr+0x32>
mov    %rsp,%rdi
callq  d5 <_PySelectionKey_repr+0x3a>
mov    0x58(%rsp),%rdx
xor    %fs:0x28,%rdx
je     ea <_PySelectionKey_repr+0x4f>
callq  ea <_PySelectionKey_repr+0x4f>
add    $0x68,%rsp
xchg   %ax,%ax
retq   
<<<sep_in_sample>>>
_PySelectionKey_repr (PyObject *self)
{
    PySelectionKey *py_key = (PySelectionKey *)self;
    char buf[80];
    snprintf (buf, sizeof buf, "<DicoSelectionKey %s>", py_key->key->word);
    return PyString_FromString (buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  6d <_gsasl_step64>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsasl_server_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
movb   $0x0,(%rdi)
test   %esi,%esi
jle    71 <concat+0x2d>
mov    %rdx,%rbx
lea    -0x1(%rsi),%eax
lea    0x8(%rdx,%rax,8),%r12
mov    (%rbx),%rsi
mov    %rbp,%rdi
callq  68 <concat+0x24>
add    $0x8,%rbx
cmp    %r12,%rbx
jne    5d <concat+0x19>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
concat(char *buf, int argc, char * argv[])
{
  int i;
  buf[0] = '\0';
  for (i=0; i<argc; ++i)
    strcat(buf, argv[i]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 5
16 5
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    (%rdi),%rbx
test   %rbx,%rbx
je     11fd <grecs_list_iterate+0x28>
mov    0x10(%rbx),%rdi
mov    %rbp,%rsi
callq  *%r12
test   %eax,%eax
jne    11fd <grecs_list_iterate+0x28>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    11e7 <grecs_list_iterate+0x12>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_list_iterate(struct grecs_list *list, grecs_list_iterator_t fun,
     void *data)
{
    struct grecs_list_entry *ep;
    for (ep = list->head; ep; ep = ep->next) {
 grecs_value_t *vp = ep->data;
 if (fun(vp, data))
     break;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 5
15 5
16 5
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
cmpl   $0x0,0x848(%rdi)
je     1be <OpenOptFiles+0x1d>
mov    0x838(%rdi),%rax
mov    %rax,0xf28(%rdi)
jmp    1d3 <OpenOptFiles+0x32>
cmpq   $0x0,0xf28(%rdi)
jne    1d3 <OpenOptFiles+0x32>
movq   $0x0,0xf28(%rdi)
cmpq   $0x0,0xf30(%rbx)
jne    215 <OpenOptFiles+0x74>
mov    0xf28(%rbx),%rdi
mov    $0x0,%esi
callq  1ee <OpenOptFiles+0x4d>
mov    %rax,0xf30(%rbx)
test   %rax,%rax
jne    215 <OpenOptFiles+0x74>
mov    0xf28(%rbx),%rdx
mov    $0x0,%ecx
mov    $0x8003,%esi
mov    $0x0,%edi
callq  215 <OpenOptFiles+0x74>
pop    %rbx
retq   
<<<sep_in_sample>>>
OpenOptFiles (PANALYSIS panal)
{
  if (panal->bCommandLineSpec)
    panal->gd.szGout = panal->szOutfilename;
  else if (!(panal->gd.szGout))
    panal->gd.szGout = "simopt.default.out";
  if (!(panal->gd.pfileOut)
      && !(panal->gd.pfileOut = fopen (panal->gd.szGout, "w")))
    ReportError (((void *)0), 0x8000 | 0x0003,
                 panal->gd.szGout, "[in OpenOptFiles()]");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 7
12 7
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 11
25 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x14(%rdi),%edi
callq  23d <rpmbis_rpmh_delete+0xc>
mov    0x10(%rbx),%edi
callq  245 <rpmbis_rpmh_delete+0x14>
mov    %rbx,%rdi
callq  24d <rpmbis_rpmh_delete+0x1c>
pop    %rbx
retq   
<<<sep_in_sample>>>
rpmbis_rpmh_delete(RPMBIS_RPMH * rpmh)
{
 uxfio_close(rpmh->store_fdM);
 uxfio_close(rpmh->hdrindex_fdM);
 free(rpmh);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 6
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
movzbl (%rdi),%eax
test   %r10,%r10
je     22a9 <gsl_matrix_uchar_min+0x4a>
mov    $0x0,%r8d
jmp    229b <gsl_matrix_uchar_min+0x3c>
movzbl (%rdx),%ecx
cmp    %cl,%al
cmova  %ecx,%eax
add    $0x1,%rdx
cmp    %rdx,%rsi
jne    227e <gsl_matrix_uchar_min+0x1f>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
je     22a9 <gsl_matrix_uchar_min+0x4a>
test   %r9,%r9
je     228f <gsl_matrix_uchar_min+0x30>
lea    (%rdi,%r9,1),%rsi
mov    %rdi,%rdx
jmp    227e <gsl_matrix_uchar_min+0x1f>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_uchar_min (const gsl_matrix_uchar * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned char min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned char x = m->data[i * tda + j];
          if (x < min)
            min = x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 8
7 8
8 8
9 8
10 12
11 12
12 12
13 12
14 10
15 10
16 8
17 8
18 8
19 8
20 10
21 10
22 10
23 10
24 10
25 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rbx,%rdi
callq  896 <closedown>
mov    (%rbx),%rax
cmpq   $0x0,(%rax)
je     a5f <last_file_with_data_p+0x4c>
lea    0x8(%rax),%rdx
mov    %rdx,(%rbx)
mov    %rbx,%rsi
mov    (%rax),%rdi
callq  27c <open_next_file>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     a17 <last_file_with_data_p+0x4>
callq  a48 <last_file_with_data_p+0x35>
cmp    $0xffffffff,%eax
je     a17 <last_file_with_data_p+0x4>
mov    0x38(%rbx),%rsi
mov    %eax,%edi
callq  a58 <last_file_with_data_p+0x45>
mov    $0x0,%eax
jmp    a64 <last_file_with_data_p+0x51>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
last_file_with_data_p(input)
  struct input *input;
{
  for (;;)
    {
      int ch;
      closedown(input);
      if (!*input->file_list)
 return 1;
      open_next_file(*input->file_list++, input);
      if (input->fp)
 {
   if ((ch = getc_unlocked (input->fp)) != (-1))
     {
       ungetc(ch, input->fp);
       return 0;
     }
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 8
6 8
7 8
8 10
9 10
10 10
11 10
12 10
13 11
14 11
15 11
16 13
17 13
18 13
19 15
20 15
21 15
22 16
23 16
24 9
25 20
26 20
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %edx,0xc(%rsp)
mov    %ecx,%r12d
mov    %r8,%r13
mov    0x38(%rdi),%rdi
lea    0x18(%rsp),%rcx
mov    $0x0,%edx
lea    0xc(%rsp),%rsi
callq  236 <__db_meta2pgset+0x32>
mov    %eax,%edx
test   %edx,%edx
jne    297 <__db_meta2pgset+0x93>
mov    0x18(%rsp),%rdx
movzbl 0x19(%rdx),%eax
and    $0xf,%eax
cmp    $0x8,%al
je     265 <__db_meta2pgset+0x61>
cmp    $0x9,%al
jne    27a <__db_meta2pgset+0x76>
mov    %r13,%r8
mov    %r12d,%ecx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  261 <__db_meta2pgset+0x5d>
mov    %eax,%ebp
jmp    27f <__db_meta2pgset+0x7b>
mov    %r13,%r8
mov    %r12d,%ecx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  276 <__db_meta2pgset+0x72>
mov    %eax,%ebp
jmp    27f <__db_meta2pgset+0x7b>
mov    $0xffff86f4,%ebp
mov    0x38(%rbx),%rdi
mov    $0x0,%edx
mov    0x18(%rsp),%rsi
callq  292 <__db_meta2pgset+0x8e>
test   %eax,%eax
cmove  %ebp,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
__db_meta2pgset(dbp, vdp, pgno, flags, pgset)
 DB *dbp;
 VRFY_DBINFO *vdp;
 db_pgno_t pgno;
 u_int32_t flags;
 DB *pgset;
{
 PAGE *h;
 int ret, t_ret;
 if ((ret = CDB_memp_fget(dbp->mpf, &pgno, 0, &h)) != 0)
  return (ret);
 switch (((((PAGE *)h)->type) & 0x0f)) {
 case 9:
  ret = CDB___bam_meta2pgset(dbp, vdp, (BTMETA *)h, flags, pgset);
  break;
 case 8:
  ret = CDB___ham_meta2pgset(dbp, vdp, (HMETA *)h, flags, pgset);
  break;
 default:
  ret = (-30988);
  break;
 }
 if ((t_ret = CDB_memp_fput(dbp->mpf, h, 0)) != 0)
  return (t_ret);
 return (ret);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 14
27 14
28 14
29 14
30 14
31 14
32 15
33 17
34 17
35 17
36 17
37 17
38 17
39 18
40 20
41 23
42 23
43 23
44 23
45 23
46 24
47 26
48 26
49 26
50 26
51 26
52 26
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  31 <io_destroy+0x9>
lea    0x8(%rbx),%rdi
callq  3a <io_destroy+0x12>
mov    %rbx,%rdi
callq  42 <io_destroy+0x1a>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
io_destroy(void *data)
{
    struct _iostr *p = data;
    dico_stream_destroy(&p->in);
    dico_stream_destroy(&p->out);
    free(p);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 6
7 6
8 8
9 8
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmp    %rsi,0x8(%rdi)
ja     1a5e <gsl_vector_ulong_alloc_col_from_matrix+0x32>
mov    $0x4,%ecx
mov    $0xd2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a57 <gsl_vector_ulong_alloc_col_from_matrix+0x2b>
mov    $0x0,%eax
jmp    1aaf <gsl_vector_ulong_alloc_col_from_matrix+0x83>
mov    $0x28,%edi
callq  1a68 <gsl_vector_ulong_alloc_col_from_matrix+0x3c>
test   %rax,%rax
jne    1a8d <gsl_vector_ulong_alloc_col_from_matrix+0x61>
mov    $0x8,%ecx
mov    $0xda,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a86 <gsl_vector_ulong_alloc_col_from_matrix+0x5a>
mov    $0x0,%eax
jmp    1aaf <gsl_vector_ulong_alloc_col_from_matrix+0x83>
mov    0x18(%rbx),%rdx
lea    (%rdx,%rbp,8),%rdx
mov    %rdx,0x10(%rax)
mov    (%rbx),%rdx
mov    %rdx,(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x8(%rax)
movq   $0x0,0x18(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
gsl_vector_ulong_alloc_col_from_matrix (gsl_matrix_ulong * m,
                                              const size_t j)
{
  gsl_vector_ulong * v;
  const size_t N = m->size2;
  if (j >= N)
    {
      do { gsl_error ("column index is out of range", "getset_source.c", 210, GSL_EINVAL) ; return 0 ; } while (0);
    }
  v = (gsl_vector_ulong *) malloc (sizeof (gsl_vector_ulong));
  if (v == 0)
    {
      do { gsl_error ("failed to allocate space for vector struct",
 "getset_source.c"
      ,
 218
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                      ;
    }
  v->data = m->data + 1 * j ;
  v->size = m->size1;
  v->stride = m->tda;
  v->block = 0;
  return v;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 10
16 10
17 11
18 11
19 13
20 13
21 13
22 13
23 13
24 17
25 17
26 20
27 20
28 20
29 21
30 21
31 22
32 22
33 23
34 25
35 25
36 25
37 25
<<<sep_out_sample>>>
test   %rsi,%rsi
je     28f <_gsasl_openid20_server_finish+0x15>
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  28b <_gsasl_openid20_server_finish+0x11>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
_gsasl_openid20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct openid20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  190b <gsl_sf_psi_int+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     192f <gsl_sf_psi_int+0x30>
mov    %eax,%ecx
mov    $0x348,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  192a <gsl_sf_psi_int+0x2b>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_psi_int(const int n)
{
  gsl_sf_result result; int status = gsl_sf_psi_int_e(n, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_psi_int_e(n, &result)", "psi.c", 840, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 680 <meta1get_lineno+0x6>
retq   
<<<sep_in_sample>>>
meta1get_lineno (void)
{
    return meta1lineno;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,0x8(%rsp)
mov    %edx,%r15d
mov    %ecx,%r14d
mov    %r8d,%r13d
mov    %r9d,%r12d
mov    $0x20,%edi
callq  1ce <add_medium+0x2c>
mov    %rax,%rbx
mov    0x8(%rsp),%rdi
callq  1db <add_medium+0x39>
mov    %rax,(%rbx)
mov    %r15d,0x8(%rbx)
mov    %r14d,0xc(%rbx)
mov    %r13d,0x10(%rbx)
mov    %r12d,0x14(%rbx)
mov    0x50(%rsp),%eax
mov    %eax,0x18(%rbx)
mov    0x58(%rsp),%eax
mov    %eax,0x1c(%rbx)
mov    0x20(%rbp),%rdi
mov    %rbx,%rsi
callq  208 <add_medium+0x66>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
add_medium (struct a2ps_job * job,
    const char * name,
    int w, int h,
    int llx, int lly, int urx, int ury)
{
  struct medium * a_medium = ((struct medium *) xmalloc (sizeof (struct medium) * (1)));
  a_medium->name = xstrdup (name);
  a_medium->w = w;
  a_medium->h = h;
  a_medium->llx = llx;
  a_medium->lly = lly;
  a_medium->urx = urx;
  a_medium->ury = ury;
  hash_insert (job->media, a_medium);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 7
20 8
21 9
22 10
23 11
24 12
25 12
26 13
27 13
28 14
29 14
30 14
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%rbx
test   %rbx,%rbx
je     cc8 <prim_list+0x82>
mov    %rdx,%r13
mov    %rbx,%rax
mov    $0x0,%ebp
lea    0x1(%rbp),%r12d
mov    (%rax),%rax
test   %rax,%rax
je     c99 <prim_list+0x53>
mov    %r12d,%ebp
jmp    c61 <prim_list+0x1b>
mov    %ebp,%edx
mov    0x18(%r14),%rax
lea    (%rax,%rdx,8),%r12
mov    0x8(%rbx),%rdi
mov    %r13,%rsi
callq  c88 <prim_list+0x42>
mov    %rax,(%r12)
add    $0x1,%ebp
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    c72 <prim_list+0x2c>
jmp    cf8 <prim_list+0xb2>
mov    $0x6,%edi
callq  ca3 <prim_list+0x5d>
mov    %rax,%r14
add    $0x2,%ebp
mov    %ebp,%edi
mov    $0x8,%esi
callq  cb5 <prim_list+0x6f>
mov    %rax,0x18(%r14)
mov    %ebp,0x24(%r14)
mov    %r12d,0x20(%r14)
mov    $0x0,%ebp
jmp    c72 <prim_list+0x2c>
mov    $0x6,%edi
callq  cd2 <prim_list+0x8c>
mov    %rax,%r14
mov    $0x8,%esi
mov    $0x1,%edi
callq  ce4 <prim_list+0x9e>
mov    %rax,0x18(%r14)
movl   $0x1,0x24(%r14)
movl   $0x0,0x20(%r14)
mov    %r14,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
prim_list (prim_name, args, env, filename, linenum) char *prim_name; List *args; Environment *env; char *filename; unsigned int linenum;
{
  ListItem *arg = args->head;
  unsigned int len;
  Node *n;
  for (len = 0; arg; len++, arg = arg->next)
    ;
  arg = args->head;
  n = node_alloc (nARRAY);
  n->u.array.array = (Node **) xcalloc (len + 1, sizeof (Node *));
  n->u.array.allocated = len + 1;
  n->u.array.len = len;
  for (len = 0; arg; len++, arg = arg->next)
    n->u.array.array[len] = eval_expr ((Expr *) arg->data, env);
  return n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 6
8 6
9 6
10 3
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 14
19 14
20 14
21 14
22 14
23 14
24 14
25 13
26 13
27 13
28 13
29 13
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 11
39 12
40 13
41 13
42 9
43 9
44 9
45 10
46 10
47 10
48 10
49 11
50 12
51 16
52 16
53 16
54 16
55 16
56 16
57 16
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm0        # 284 <lowerror+0x8>
ucomisd 0x0(%rip),%xmm0        # 28c <lowerror+0x10>
ja     2a0 <lowerror+0x24>
movsd  0x0(%rip),%xmm0        # 296 <lowerror+0x1a>
ucomisd 0x0(%rip),%xmm0        # 29e <lowerror+0x22>
jbe    2cb <lowerror+0x4f>
movsd  0x0(%rip),%xmm0        # 2a8 <lowerror+0x2c>
movsd  0x0(%rip),%xmm1        # 2b0 <lowerror+0x34>
andpd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm2        # 2bc <lowerror+0x40>
andpd  %xmm2,%xmm0
ucomisd %xmm1,%xmm0
setae  %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
lowerror (void)
{
  if (ssemax < ssmin || abemax < abmin)
    if (fabs(tstep) <= fabs(hmax))
      return true;
  return false;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 6
17 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movslq %edi,%rdi
callq  83 <xmalloc+0xc>
test   %rax,%rax
jne    8d <xmalloc+0x16>
callq  53 <memory_error_and_abort>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xmalloc (bytes)
     int bytes;
{
  char *temp = (char *)malloc (bytes);
  if (!temp)
    memory_error_and_abort ();
  return (temp);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
6 6
7 8
8 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rax        # 12b <echoc+0xa>
cmp    %rax,0x0(%rip)        # 132 <echoc+0x11>
jb     143 <echoc+0x22>
mov    $0x0,%esi
mov    $0x0,%edi
callq  143 <echoc+0x22>
mov    0x0(%rip),%rax        # 14a <echoc+0x29>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 155 <echoc+0x34>
mov    %bl,(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
echoc(int c)
{
        do { if (outbuf->curp >= outbuf->endp) __strbuf_expandbuf(outbuf, 0); *outbuf->curp++ = c;} while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rsi
cmp    %rdi,%rax
jae    37 <xnmalloc+0x1d>
callq  37 <xnmalloc+0x1d>
imul   %rsi,%rdi
callq  40 <xnmalloc+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnmalloc (size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xmalloc (n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 5
10 6
11 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 33 <do_mark+0xb>
movzbl 0x58(%rdx),%eax
xor    $0x1,%eax
mov    %al,0x58(%rdx)
test   %al,%al
je     73 <do_mark+0x4b>
mov    $0x0,%edi
callq  4b <do_mark+0x23>
mov    %rax,%rdi
callq  53 <do_mark+0x2b>
mov    0x0(%rip),%rax        # 5a <do_mark+0x32>
mov    0x20(%rax),%rdx
mov    %rdx,0x60(%rax)
mov    0x30(%rax),%rdx
mov    %rdx,0x68(%rax)
movl   $0x1,0x70(%rax)
jmp    9c <do_mark+0x74>
mov    $0x0,%edi
callq  7d <do_mark+0x55>
mov    %rax,%rdi
callq  85 <do_mark+0x5d>
mov    0x0(%rip),%rax        # 8c <do_mark+0x64>
movq   $0x0,0x60(%rax)
movq   $0x0,0x68(%rax)
callq  a1 <do_mark+0x79>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
do_mark(void)
{
    openfile->mark_set = !openfile->mark_set;
    if (openfile->mark_set) {
 statusbar(gettext("Mark Set"));
 openfile->mark_begin = openfile->current;
 openfile->mark_begin_x = openfile->current_x;
 openfile->kind_of_mark = HARDMARK;
    } else {
 statusbar(gettext("Mark Unset"));
 openfile->mark_begin = ((void *)0);
 openfile->mark_begin_x = 0;
    }
    edit_refresh();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 8
18 8
19 10
20 10
21 10
22 10
23 11
24 11
25 12
26 14
27 15
28 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  c87 <swverid_print_ver_id+0x17>
test   %rbx,%rbx
je     ce8 <swverid_print_ver_id+0x78>
mov    $0x1,%r12d
jmp    caa <swverid_print_ver_id+0x3a>
test   %r12d,%r12d
je     ca6 <swverid_print_ver_id+0x36>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  ca6 <swverid_print_ver_id+0x36>
add    $0x1,%r12d
lea    0x5(%rbx),%rsi
mov    %rbp,%rdi
callq  cb6 <swverid_print_ver_id+0x46>
lea    0x3(%rbx),%rsi
mov    %rbp,%rdi
callq  cc2 <swverid_print_ver_id+0x52>
lea    0x7(%rbx),%rsi
mov    %rbp,%rdi
callq  cce <swverid_print_ver_id+0x5e>
mov    0x10(%rbx),%rsi
test   %rsi,%rsi
je     cdf <swverid_print_ver_id+0x6f>
mov    %rbp,%rdi
callq  cdf <swverid_print_ver_id+0x6f>
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    c94 <swverid_print_ver_id+0x24>
mov    %rbp,%rdi
callq  cf0 <swverid_print_ver_id+0x80>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swverid_print_ver_id(struct VER_ID * next, STROB * buf)
{
 int vi;
 char * val;
 int n = 0;
 strob_strcpy(buf, "");
 while (next) {
  if (n++) strob_strcat(buf, ",");
  strob_strcat(buf, next->vqM);
  strob_strcat(buf, next->idM);
  strob_strcat(buf, next->rel_opM);
  vi = 0;
  if ((val=next->valueM) != ((void *)0)) {
   strob_strcat(buf, val);
  } else {
   ;
  }
  next = next->nextM;
 }
 return strob_str(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 10
23 10
24 10
25 11
26 11
27 11
28 13
29 13
30 13
31 14
32 14
33 18
34 7
35 7
36 20
37 20
38 21
39 21
40 21
41 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xb0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
                       const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rdi        # dd0 <close_stdout+0x8>
callq  dd5 <close_stdout+0xd>
mov    %eax,%ebx
mov    0x0(%rip),%rdi        # dde <close_stdout+0x16>
callq  de3 <close_stdout+0x1b>
or     %eax,%ebx
je     e2f <close_stdout+0x67>
test   %eax,%eax
je     e04 <close_stdout+0x3c>
mov    $0x0,%edi
callq  df5 <close_stdout+0x2d>
mov    $0x0,%esi
mov    %rax,%rdi
callq  e02 <close_stdout+0x3a>
jmp    e25 <close_stdout+0x5d>
mov    $0x0,%edi
callq  e0e <close_stdout+0x46>
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  e25 <close_stdout+0x5d>
mov    $0x1,%edi
callq  e2f <close_stdout+0x67>
pop    %rbx
retq   
<<<sep_in_sample>>>
close_stdout (void)
{
  int prev_fail = ferror (stdout);
  int fclose_fail = fclose (stdout);
  if (prev_fail || fclose_fail)
    {
      if (fclose_fail)
        perror_with_name (gettext ("write error: stdout"), "");
      else
        error((((floc *)0)), 0, (gettext ("write error: stdout")));
      exit (1);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 11
25 11
26 13
27 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     297 <swheader_close+0x11>
callq  297 <swheader_close+0x11>
test   %rbx,%rbx
je     2a4 <swheader_close+0x1e>
mov    %rbx,%rdi
callq  2a4 <swheader_close+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
swheader_close(SWHEADER * swheader)
{
 if (swheader->image_head_) free(swheader->image_head_);
 if (swheader != ((void *)0)) free(swheader);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm2        # 239 <gsl_complex_negative+0x8>
xorpd  %xmm2,%xmm1
xorpd  %xmm2,%xmm0
retq   
<<<sep_in_sample>>>
gsl_complex_negative (gsl_complex a)
{
  gsl_complex z;
  do {(&z)->dat[0]=(-((a).dat[0])); (&z)->dat[1]=(-((a).dat[1]));} while(0);
  return z;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  799 <gsl_sort_vector_float_largest_index+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_float_largest_index (size_t * p, const size_t k,
                                          const gsl_vector_float * v)
{
  return gsl_sort_float_largest_index (p, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x10b06,%edx
callq  34 <Gcompile+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
Gcompile (char const *pattern, size_t size)
{
  GEAcompile (pattern, size, ((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     21e1 <gdbmarglist_init+0xc>
movq   $0x0,(%rsi)
mov    %rsi,0x8(%rdi)
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
gdbmarglist_init (struct gdbmarglist *lst, struct gdbmarg *arg)
{
  if (arg)
    arg->next = ((void *)0);
  lst->head = lst->tail = arg;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    (%rbx),%rsi
mov    %r12,%rdi
callq  1c <swintl_get_lang_code+0x1c>
test   %eax,%eax
je     2d <swintl_get_lang_code+0x2d>
add    $0x10,%rbx
mov    -0x8(%rbx),%rbp
test   %rbp,%rbp
jne    11 <swintl_get_lang_code+0x11>
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swintl_get_lang_code (char * lang_name)
{
 int i=0;
 while (swintl_lang_table[i].language_code_ != ((void *)0)) {
  if (!strcmp (lang_name, swintl_lang_table[i].language_name_))
   return swintl_lang_table[i].language_code_;
  i++;
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 4
14 4
15 4
16 10
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    0x0(%rip),%rdx        # 1fe <osip_strdup_without_quote+0x14>
test   %rdx,%rdx
je     21e <osip_strdup_without_quote+0x34>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdi
not    %rdi
callq  *%rdx
mov    %rax,%rbp
jmp    23a <osip_strdup_without_quote+0x50>
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
callq  237 <osip_strdup_without_quote+0x4d>
mov    %rax,%rbp
test   %rbp,%rbp
je     2be <osip_strdup_without_quote+0xd4>
cmpb   $0x22,(%rbx)
jne    296 <osip_strdup_without_quote+0xac>
lea    0x1(%rbx),%rsi
mov    $0xffffffffffffffff,%r13
mov    %rsi,%rdi
mov    $0x0,%r12d
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rcx,%r13,1),%rdx
mov    %rbp,%rdi
callq  26f <osip_strdup_without_quote+0x85>
mov    %rbp,%rdi
mov    %r13,%rcx
mov    %r12d,%eax
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x2(%rbp,%rcx,1),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  291 <osip_strdup_without_quote+0xa7>
mov    %rbp,%rax
jmp    2c3 <osip_strdup_without_quote+0xd9>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  2b9 <osip_strdup_without_quote+0xcf>
mov    %rbp,%rax
jmp    2c3 <osip_strdup_without_quote+0xd9>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
osip_strdup_without_quote (const char *ch)
{
  char *copy = (char *) (osip_malloc_func?osip_malloc_func(strlen (ch) + 1):malloc(strlen (ch) + 1));
  if (copy == ((void *)0))
    return ((void *)0);
  if ((*ch == '\"')) {
    osip_strncpy (copy, ch + 1, strlen (ch + 1));
    osip_strncpy (copy + strlen (copy) - 1, "\0", 1);
  }
  else
    osip_strncpy (copy, ch, strlen (ch));
  return copy;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 4
26 4
27 6
28 6
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 8
48 8
49 12
50 12
51 11
52 11
53 11
54 11
55 11
56 11
57 11
58 11
59 11
60 12
61 12
62 5
63 13
64 13
65 13
66 13
67 13
68 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %esi,%ebx
mov    %rdx,%r12
mov    %rcx,%r13
mov    $0x18,%edi
callq  1df <depmap_first+0x1f>
mov    %rax,0x0(%r13)
mov    %ebx,(%rax)
test   %ebx,%ebx
sete   %dl
movzbl %dl,%edx
mov    %r12,0x8(%rax,%rdx,8)
mov    %ebx,%ebx
movq   $0xffffffffffffffff,0x8(%rax,%rbx,8)
mov    %rax,%rsi
mov    %rbp,%rdi
callq  208 <depmap_first+0x48>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
depmap_first (pies_depmap_t dmap, enum pies_depmap_direction dir,
       size_t coord, pies_depmap_pos_t *ppos)
{
  pies_depmap_pos_t pos = xmalloc (sizeof *pos);
  *ppos = pos;
  pos->dir = dir;
  pos->coord[!pos->dir] = coord;
  pos->coord[pos->dir] = -1;
  return depmap_next (dmap, pos);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 5
13 6
14 7
15 7
16 7
17 7
18 8
19 8
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
callq  260 <nmalloc+0xe>
mov    %rax,%rbx
test   %rax,%rax
jne    284 <nmalloc+0x32>
test   %rbp,%rbp
je     284 <nmalloc+0x32>
mov    $0x0,%edi
callq  277 <nmalloc+0x25>
mov    %rax,%rdi
mov    $0x0,%eax
callq  284 <nmalloc+0x32>
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nmalloc(size_t howmuch)
{
    void *r = malloc(howmuch);
    if (r == ((void *)0) && howmuch != 0)
 die(gettext("nano is out of memory!"));
    return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdi
not    %rdi
callq  2b67 <dotrans+0x1d>
cmpb   $0x0,0x0(%rip)        # 2b6e <dotrans+0x24>
je     2b84 <dotrans+0x3a>
mov    $0x0,%edi
add    $0x1,%rdi
cmpb   $0x0,0x0(%rdi)
jne    2b9e <dotrans+0x54>
jmp    2b89 <dotrans+0x3f>
mov    $0x0,%edi
movzbl (%rbx),%esi
test   %sil,%sil
je     2c00 <dotrans+0xb6>
movzbl 0x0(%rip),%r9d        # 2b99 <dotrans+0x4f>
mov    %rax,%r8
jmp    2bef <dotrans+0xa5>
cmp    $0x10,%rdi
jne    2b75 <dotrans+0x2b>
jmp    2b89 <dotrans+0x3f>
cmp    %cl,%sil
jne    2bcc <dotrans+0x82>
nopl   0x0(%rax,%rax,1)
jmp    2bb7 <dotrans+0x6d>
mov    $0x0,%edx
cmp    %rdi,%rdx
jae    2be3 <dotrans+0x99>
movzbl 0x0(%rdx),%edx
mov    %dl,(%r8)
lea    0x1(%r8),%r8
jmp    2be3 <dotrans+0x99>
add    $0x1,%rdx
movzbl 0x0(%rdx),%ecx
test   %cl,%cl
je     2c05 <dotrans+0xbb>
cmp    $0x10,%rdx
jne    2ba6 <dotrans+0x5c>
jmp    2c05 <dotrans+0xbb>
add    $0x1,%rbx
movzbl (%rbx),%esi
test   %sil,%sil
je     2c11 <dotrans+0xc7>
test   %r9b,%r9b
je     2c05 <dotrans+0xbb>
cmp    %r9b,%sil
je     2bb2 <dotrans+0x68>
mov    $0x0,%edx
jmp    2bcc <dotrans+0x82>
mov    %rax,%r8
jmp    2c11 <dotrans+0xc7>
movzbl (%rbx),%edx
mov    %dl,(%r8)
lea    0x1(%r8),%r8
jmp    2be3 <dotrans+0x99>
movb   $0x0,(%r8)
pop    %rbx
retq   
<<<sep_in_sample>>>
dotrans (char *name)
{
  char *new = xmalloc (strlen (name) + 1);
  char *cp1, *cp2 = new;
  size_t i, ostop, found;
  for (ostop = 0; *(ntout + ostop) && ostop < sizeof (ntout) - 1; ostop++)
    continue;
  for (cp1 = name; *cp1; cp1++)
    {
      found = 0;
      for (i = 0; *(ntin + i) && i < sizeof (ntin) - 1; i++)
 {
   if (*cp1 == *(ntin + i))
     {
       found++;
       if (i < ostop)
  {
    *cp2++ = *(ntout + i);
  }
       break;
     }
 }
      if (!found)
 {
   *cp2++ = *cp1;
 }
    }
  *cp2 = '\0';
  return (new);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 11
21 11
22 11
23 6
24 6
25 6
26 13
27 13
28 13
29 13
30 13
31 16
32 16
33 18
34 18
35 18
36 18
37 11
38 11
39 11
40 11
41 11
42 11
43 11
44 8
45 8
46 8
47 8
48 11
49 11
50 13
51 13
52 13
53 13
54 8
55 8
56 25
57 25
58 25
59 25
60 28
61 30
62 30
<<<sep_out_sample>>>
test   %rdi,%rdi
je     89d <dico_list_locate+0x14>
sub    $0x8,%rsp
mov    0x28(%rdi),%rdx
callq  89b <dico_list_locate+0x12>
jmp    8a3 <dico_list_locate+0x1a>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dico_list_locate(struct dico_list *list, void *data)
{
    if (!list)
 return ((void *)0);
    return _dico_list_locate(list, data, list->comp);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 5
7 4
8 4
9 6
10 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c2ff <rpl_re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # c306 <rpl_re_set_syntax+0xe>
retq   
<<<sep_in_sample>>>
rpl_re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = rpl_re_syntax_options;
  rpl_re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     1ea <c2f+0x12>
cmpl   $0xbeefdead,0x8(%rdi)
je     203 <c2f+0x2b>
mov    $0x0,%ecx
mov    $0x1b1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  203 <c2f+0x2b>
mov    %rdi,%rax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
c2f(void * cookie) {
 FD_t fd = (FD_t) cookie;
 ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 433, __PRETTY_FUNCTION__));
 return fd;
}
<<<sep_in_sample>>>
1 1
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_qrng_size (const gsl_qrng * q)
{
  return q->state_size;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %edx,%r12d
mov    0x10(%rsi),%rsi
test   %rsi,%rsi
je     3c1 <grecs_format_block_statement+0x1b>
callq  3c1 <grecs_format_block_statement+0x1b>
mov    %r12d,%esi
mov    %rbx,%rdi
callq  0 <format_level>
mov    %rbx,%rsi
mov    0x0(%rbp),%rdi
callq  3d8 <grecs_format_block_statement+0x32>
mov    0x8(%rbp),%rdi
test   %rdi,%rdi
je     3fb <grecs_format_block_statement+0x55>
callq  3e6 <grecs_format_block_statement+0x40>
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
mov    $0x0,%eax
callq  3fb <grecs_format_block_statement+0x55>
mov    %rbx,%rcx
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  412 <grecs_format_block_statement+0x6c>
lea    0x1(%r12),%ecx
mov    0x40(%rbp),%rsi
mov    $0x0,%edx
mov    %rbx,%rdi
callq  428 <grecs_format_block_statement+0x82>
mov    %r12d,%esi
mov    %rbx,%rdi
callq  0 <format_level>
mov    %rbx,%rcx
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  44a <grecs_format_block_statement+0xa4>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_format_block_statement (FILE *stream, struct grecs_keyword *kwp,
         unsigned level)
{
  if (kwp->docstring)
    grecs_format_docstring (stream, kwp->docstring, level);
  format_level (stream, level);
  fprintf (stream, "%s", kwp->ident);
  if (kwp->argname)
    fprintf (stream, " <%s>", gettext (kwp->argname));
  fprintf (stream, " {\n");
  grecs_format_statement_array (stream, kwp->kwd, 0, level + 1);
  format_level (stream, level);
  fprintf (stream, "}\n");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 5
11 6
12 6
13 6
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
22 9
23 9
24 9
25 9
26 10
27 10
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 12
37 12
38 12
39 13
40 13
41 13
42 13
43 13
44 14
45 14
46 14
47 14
<<<sep_out_sample>>>
push   %rbx
callq  70 <can_output+0x6>
mov    %eax,%ebx
mov    0x0(%rip),%edi        # 78 <can_output+0xe>
callq  7d <can_output+0x13>
cmp    %eax,%ebx
sete   %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
can_output(void)
{
 return (getpgrp() == tcgetpgrp(g_ofd));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x70,%rsp
mov    %rdi,%rbx
lea    0x20(%rsp),%rdx
mov    $0x9,%ecx
mov    $0x0,%eax
mov    %rdx,%rdi
rep stos %rax,%es:(%rdi)
mov    %rsi,0x60(%rsp)
mov    %rdx,(%rsp)
callq  16dd <grecs_tree_process+0x2b>
mov    %rax,0x8(%rsp)
cmpl   $0x0,(%rbx)
jne    16eb <grecs_tree_process+0x39>
mov    0x30(%rbx),%rbx
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  16fb <grecs_tree_process+0x49>
mov    %eax,%ebx
mov    0x8(%rsp),%rdi
callq  1707 <grecs_tree_process+0x55>
mov    %ebx,%eax
add    $0x70,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_tree_process(struct grecs_node *node, struct grecs_keyword *kwd)
{
 int rc;
 struct nodeproc_closure clos;
 struct grecs_keyword config_keywords;
 memset(&config_keywords, 0, sizeof(config_keywords));
 config_keywords.kwd = kwd;
 clos.cursect = &config_keywords;
 clos.sections = grecs_list_create();
 if (node->type == grecs_node_root)
  node = node->down;
 rc = grecs_tree_recurse(node, nodeproc, &clos);
 grecs_list_free(clos.sections);
 return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 6
7 6
8 6
9 7
10 8
11 9
12 9
13 10
14 10
15 11
16 12
17 12
18 12
19 12
20 12
21 13
22 13
23 15
24 15
25 15
26 15
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 73e <rl_clear_pending_input+0xa>
andq   $0xfffffffffffdffff,0x0(%rip)        # 749 <rl_clear_pending_input+0x15>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rl_clear_pending_input ()
{
  rl_pending_input = 0;
  (rl_readline_state &= ~(0x0020000));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  27c <parse_separator_style+0x11>
mov    $0x2,%edx
cmp    $0x0,%rax
je     2eb <parse_separator_style+0x80>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  296 <parse_separator_style+0x2b>
mov    $0x3,%edx
cmp    $0x0,%rax
je     2eb <parse_separator_style+0x80>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  2b0 <parse_separator_style+0x45>
mov    $0x4,%edx
cmp    $0x0,%rax
je     2eb <parse_separator_style+0x80>
mov    $0x0,%edi
callq  2c7 <parse_separator_style+0x5c>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  2e1 <parse_separator_style+0x76>
callq  2e6 <parse_separator_style+0x7b>
mov    $0x0,%edx
mov    %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
parse_separator_style (char const *arg)
{
  do { char const *_s_ = ("braces"); if (strstr (_s_, (arg)) == _s_) return (ss_braces); } while (0);
  do { char const *_s_ = ("space"); if (strstr (_s_, (arg)) == _s_) return (ss_space); } while (0);
  do { char const *_s_ = ("newline"); if (strstr (_s_, (arg)) == _s_) return (ss_newline); } while (0);
  error (0, 0, gettext ("invalid `--separator' style: `%s'"), arg);
  usage ();
  return ss_bogus;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 5
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 7
30 8
31 9
32 9
33 9
<<<sep_out_sample>>>
movslq %esi,%rax
cmp    0x40(%rdi),%rax
jae    27a <rec_sex_ast_node_child+0xf>
mov    0x28(%rdi,%rax,8),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rec_sex_ast_node_child (rec_sex_ast_node_t node,
                        int n)
{
  rec_sex_ast_node_t res;
  res = ((void *)0);
  if (n < node->num_children)
    {
      res = node->children[n];
    }
  return res;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 8
5 8
6 5
7 11
<<<sep_out_sample>>>
push   %rbx
mov    (%rdx),%rbx
test   %rbx,%rbx
je     2b <request_completed_callback+0x2b>
mov    (%rbx),%rax
test   %rax,%rax
je     15 <request_completed_callback+0x15>
subl   $0x1,0x2c(%rax)
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     23 <request_completed_callback+0x23>
callq  23 <request_completed_callback+0x23>
mov    %rbx,%rdi
callq  2b <request_completed_callback+0x2b>
pop    %rbx
retq   
<<<sep_in_sample>>>
request_completed_callback (void *cls,
       struct MHD_Connection *connection,
       void **con_cls,
       enum MHD_RequestTerminationCode toe)
{
  struct Request *request = *con_cls;
  if (((void *)0) == request)
    return;
  if (((void *)0) != request->session)
    request->session->rc--;
  if (((void *)0) != request->pp)
    MHD_destroy_post_processor (request->pp);
  free (request);
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 9
6 9
7 9
8 10
9 11
10 11
11 11
12 12
13 13
14 13
15 14
16 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdx
mov    $0x5413,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  3e <getScreenSize+0x1b>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 48 <getScreenSize+0x25>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 53 <getScreenSize+0x30>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  3b <dicod_crc32_no_xor+0x10>
repz retq 
<<<sep_in_sample>>>
dicod_crc32_no_xor (const char *buf, size_t len)
{
  return dicod_crc32_update_no_xor (0L, buf, len);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x288,%edi
callq  918 <rec_aggregate_reg_new+0xe>
test   %rax,%rax
je     928 <rec_aggregate_reg_new+0x1e>
movq   $0x0,0x280(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rec_aggregate_reg_new (void)
{
  rec_aggregate_reg_t new;
  new = malloc (sizeof (struct rec_aggregate_reg_s));
  if (new)
    {
      new->num_functions = 0;
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 10
8 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
callq  492 <gsl_stats_uint_kurtosis+0x18>
movsd  %xmm0,0x8(%rsp)
mov    0x8(%rsp),%r13
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  4ab <gsl_stats_uint_kurtosis+0x31>
movapd %xmm0,%xmm1
mov    %r13,0x8(%rsp)
movsd  0x8(%rsp),%xmm0
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  4c8 <gsl_stats_uint_kurtosis+0x4e>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_stats_uint_kurtosis (const unsigned int data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_uint_mean(data, stride, n);
  const double est_sd = gsl_stats_uint_sd_m(data, stride, n, mean);
  return gsl_stats_uint_kurtosis_m_sd(data, stride, n, mean, est_sd);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %esi,%r12d
mov    %rcx,%rbx
mov    %r8,%rbp
movq   $0x0,0x0(%rip)        # 1235 <merge_lists+0x21>
mov    %r8,%rsi
mov    %rdx,%rdi
callq  1070 <predlist_merge_sort>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x0(%rip)        # 124c <merge_lists+0x38>
test   %r12d,%r12d
jle    1277 <merge_lists+0x63>
mov    %r13,%rbx
lea    -0x1(%r12),%eax
shl    $0x4,%rax
lea    0x10(%r13,%rax,1),%r12
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  *0x0(%rip)        # 126e <merge_lists+0x5a>
add    $0x10,%rbx
cmp    %r12,%rbx
jne    1262 <merge_lists+0x4e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
merge_lists (struct predlist lists[], int nlists,
      struct predlist *name_list,
      struct predlist *regex_list,
      struct predicate **last)
{
  int i;
  static void (*mergefn)(struct predlist *, struct predicate**);
  mergefn = predlist_merge_sort;
  mergefn (name_list, last);
  mergefn (regex_list, last);
  for (i=0; i<nlists; i++)
    mergefn (&lists[i], last);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 8
11 9
12 9
13 9
14 10
15 10
16 10
17 11
18 11
19 11
20 11
21 11
22 11
23 12
24 12
25 12
26 12
27 11
28 11
29 13
30 13
31 13
32 13
33 13
34 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rdx,%rbx
test   %rdx,%rdx
jg     2834 <WriteOne_R_StateInit+0x29>
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %r12,%rdi
callq  2834 <WriteOne_R_StateInit+0x29>
test   %rbx,%rbx
je     2872 <WriteOne_R_StateInit+0x67>
cmp    $0x1,%rbx
je     289f <WriteOne_R_StateInit+0x94>
cmp    $0xffffffffffffffff,%rbx
jne    28b3 <WriteOne_R_StateInit+0xa8>
mov    0x8(%r12),%rcx
test   %rcx,%rcx
mov    $0x0,%edx
cmove  %rdx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  286b <WriteOne_R_StateInit+0x60>
mov    $0x1,%eax
jmp    28b8 <WriteOne_R_StateInit+0xad>
mov    0x8(%r12),%rcx
test   %rcx,%rcx
mov    $0x0,%edx
cmove  %rdx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x0,%eax
callq  2898 <WriteOne_R_StateInit+0x8d>
mov    $0x1,%eax
jmp    28b8 <WriteOne_R_StateInit+0xad>
mov    %rbp,%rsi
mov    $0xa,%edi
callq  28ac <WriteOne_R_StateInit+0xa1>
mov    $0x0,%eax
jmp    28b8 <WriteOne_R_StateInit+0xad>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
WriteOne_R_StateInit (PFILE pfile, PVMMAPSTRCT pvm, PVOID pInfo)
{
  PSTR szVarName;
  long End = (long) pInfo;
  if (End < 1)
    szVarName = GetName (pvm, ((void *)0), ((void *)0), 0x00000);
  switch (End) {
    case -1:
      fprintf (pfile, "    %s = %s", szVarName,
               (pvm->szEqn ? pvm->szEqn : "0.0"));
      break;
    case 0:
      fprintf (pfile, ",\n    %s = %s", szVarName,
               (pvm->szEqn ? pvm->szEqn : "0.0"));
      break;
    case 1:
      fprintf (pfile, "\n");
      return (0);
  }
  return (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 10
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 20
30 11
31 14
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 20
41 15
42 17
43 17
44 17
45 18
46 18
47 20
48 21
49 21
50 21
51 21
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1991 <ppdget_text+0x7>
retq   
<<<sep_in_sample>>>
ppdget_text (void)
{
        return ppdtext;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
callq  624 <xformat_get_next_dirent+0xd>
mov    0x28(%rbx),%rdx
mov    0x12c(%rdx),%edx
mov    %edx,0x10(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
xformat_get_next_dirent(XFORMAT * xux, struct stat * st)
{
 char * name;
 ;
 name = swvarfs_get_next_dirent(xux->swvarfsM, st);
 xux->eoaM = xux->swvarfsM->eoaM;
 return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 6
6 6
7 6
8 8
9 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
movslq 0x18(%rdi),%rdi
shl    $0x3,%rdi
callq  aa <AX11AllocBufferedSegments+0x18>
movzwl %bp,%ebp
shl    $0x4,%rbp
add    %rbp,%rbx
mov    %rax,0x20(%rbx)
test   %rax,%rax
jne    e2 <AX11AllocBufferedSegments+0x50>
mov    0x0(%rip),%rcx        # c4 <AX11AllocBufferedSegments+0x32>
mov    $0x2d,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  d8 <AX11AllocBufferedSegments+0x46>
mov    $0x1,%edi
callq  e2 <AX11AllocBufferedSegments+0x50>
movl   $0x0,0x28(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
AX11AllocBufferedSegments(AWindow * w, Color c)
{
 w->bseg[c].head = (XSegment *) malloc(w->bsegSize *
            sizeof(XSegment));
 if (w->bseg[c].head == (XSegment *) ((void *)0)) {
  fprintf(stderr, "Error allocating A library buffered segments\n");
  exit(1);
 }
 w->bseg[c].count = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 9
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  48f <set_vcwd+0x9>
mov    %rbx,%rdi
callq  497 <set_vcwd+0x11>
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %dl
setb   %al
cmp    %al,%dl
jne    4bc <set_vcwd+0x36>
mov    %rbx,%rdi
callq  4b8 <set_vcwd+0x32>
movb   $0x0,0x1(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
set_vcwd(STROB * cw, char * newvcwd)
{
 strob_strcpy(cw, newvcwd);
 if (strcmp(strob_str(cw), "./") == 0) {
  *(strob_str(cw) + 1) = '\0';
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 7
18 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x1,0x8(%rsp)
mov    %r8,(%rsp)
mov    %edx,%r9d
mov    $0x0,%r8d
callq  c5a5 <re_search_stub>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
re_match (struct re_pattern_buffer *bufp, const char *string, int length,
   int start, struct re_registers *regs)
{
  return re_search_stub (bufp, string, length, start, 0, length, regs, 1);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
lea    0x8(%rsp),%rdi
callq  8e9 <mu_cfg_create_node_list+0x13>
mov    %eax,%ebx
test   %eax,%eax
jne    907 <mu_cfg_create_node_list+0x31>
mov    $0x0,%esi
mov    0x8(%rsp),%rdi
callq  8fe <mu_cfg_create_node_list+0x28>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
mov    %ebx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_cfg_create_node_list (mu_list_t *plist)
{
  int rc;
  mu_list_t list;
  rc = mu_list_create (&list);
  if (rc)
    return rc;
  mu_list_set_destroy_item (list, free_node_item);
  *plist = list;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 8
11 8
12 8
13 9
14 9
15 11
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
movb   $0x1,0x0(%rip)        # 7 <cancel_stdin_pager+0x7>
retq   
<<<sep_in_sample>>>
cancel_stdin_pager(int signal)
{
    pager_input_aborted = 1;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x2010,%rsp
mov    %edi,%ebx
mov    %rsi,%rcx
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
mov    $0x0,%edx
mov    $0x2000,%esi
mov    %rsp,%rdi
callq  772 <fatal+0x32>
mov    %rsp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
movslq %edx,%rdx
mov    %rsp,%rsi
mov    %ebx,%edi
callq  797 <fatal+0x57>
mov    $0x1,%edi
callq  7a1 <fatal+0x61>
mov    $0x1,%edi
callq  7ab <fatalperror>
<<<sep_in_sample>>>
fatal (int f, char *msg)
{
  char buf[8192];
  snprintf (buf, sizeof buf, "telnetd: %s.\r\n", msg);
  write (f, buf, (int) strlen (buf));
  sleep (1);
            exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 6
23 6
24 7
25 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,0x8(%rsp)
movl   $0x0,(%rsp)
mov    $0x1,%r9d
callq  71 <_getopt_long_only_r+0x1b>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
_getopt_long_only_r (int argc, char **argv, const char *options,
       const struct rpl_option *long_options, int *opt_index,
       struct _getopt_data *d)
{
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
        1, 0, d);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 7
7 7
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <xalloc_die+0xb>
test   %rax,%rax
je     12 <xalloc_die+0x12>
callq  *%rax
mov    $0x0,%edi
callq  1c <xalloc_die+0x1c>
mov    %rax,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%edi        # 2f <xalloc_die+0x2f>
mov    $0x0,%eax
callq  39 <xalloc_die+0x39>
mov    $0x1,%edi
callq  43 <xmalloc>
<<<sep_in_sample>>>
xalloc_die (void)
{
  if (xalloc_fail_func)
    (*xalloc_fail_func) ();
  error (xalloc_exit_failure, 0, "%s", gettext (xalloc_msg_memory_exhausted));
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x0,%edx
lea    0xc(%rsp),%rsi
callq  10f8 <grecs_preproc_extrn_shutdown+0x13>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
grecs_preproc_extrn_shutdown (pid_t pid)
{
  int status;
  waitpid (pid, &status, 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rdx,%rsi
mov    %rbp,%rdi
callq  345 <ds_vsprintf+0x18>
movslq %eax,%rsi
mov    %rbx,%rdi
callq  350 <ds_vsprintf+0x23>
mov    0x28(%rbx),%rdi
mov    %r12,%rdx
mov    %rbp,%rsi
callq  35f <ds_vsprintf+0x32>
mov    0x28(%rbx),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
mov    %rcx,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
ds_vsprintf (struct dstring * ds, const char *format, va_list args)
{
  int len;
  len = vprintflen (format, args);
  ds_resize (ds, len);
  vsprintf (ds->content, format, args);
  ds->len = strlen (ds->content);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
push   %rbx
cmpl   $0x6,0x0(%rip)        # 1a3e <write_long_link+0x8>
ja     1abe <write_long_link+0x88>
mov    %rdi,%rbx
mov    0x0(%rip),%eax        # 1a49 <write_long_link+0x13>
jmpq   *0x0(,%rax,8)
mov    $0x0,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1a62 <write_long_link+0x2c>
jmp    1ac3 <write_long_link+0x8d>
mov    0x0(%rip),%rax        # 1a6b <write_long_link+0x35>
test   %rax,%rax
je     1a72 <write_long_link+0x3c>
callq  *%rax
mov    0x18(%rbx),%rdi
callq  1a7b <write_long_link+0x45>
mov    %rax,%rbx
mov    $0x0,%edi
callq  1a88 <write_long_link+0x52>
mov    %rbx,%rcx
mov    %rax,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1aa2 <write_long_link+0x6c>
movl   $0x2,0x0(%rip)        # 1aac <write_long_link+0x76>
jmp    1ac3 <write_long_link+0x8d>
mov    0x18(%rdi),%rsi
mov    $0x4b,%edx
callq  eb1 <write_gnu_long_link>
jmp    1ac3 <write_long_link+0x8d>
callq  1ac3 <write_long_link+0x8d>
pop    %rbx
retq   
<<<sep_in_sample>>>
write_long_link (struct tar_stat_info *st)
{
  switch (archive_format)
    {
    case POSIX_FORMAT:
      xheader_store ("linkpath", st, ((void *)0));
      break;
    case V7_FORMAT:
    case USTAR_FORMAT:
    case STAR_FORMAT:
      do { if (error_hook) error_hook (); error (0, 0, gettext ("%s: link name is too long; not dumped"), quotearg_colon (st->link_name)); exit_status = 2; } while (0)
                                       ;
      break;
    case OLDGNU_FORMAT:
    case GNU_FORMAT:
      write_gnu_long_link (st, st->link_name, 'K');
      break;
    default:
      abort();
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 7
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 13
29 16
30 16
31 16
32 17
33 19
34 21
35 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
xorpd  %xmm0,%xmm0
test   %rsi,%rsi
je     66b <display_ratio+0x23>
cvtsi2sd %rdi,%xmm0
mulsd  0x0(%rip),%xmm0        # 662 <display_ratio+0x1a>
cvtsi2sd %rsi,%xmm1
divsd  %xmm1,%xmm0
mov    $0x0,%esi
mov    %rdx,%rdi
mov    $0x1,%eax
callq  67d <display_ratio+0x35>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
display_ratio(num, den, file)
    off_t num;
    off_t den;
    FILE *file;
{
    fprintf(file, "%5.1f%%", den == 0 ? 0 : 100.0 * num / den);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xb0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
                       const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  5518 <check_unbind_variable+0x9>
test   %rax,%rax
je     5549 <check_unbind_variable+0x3a>
testb  $0x2,0x28(%rax)
je     5549 <check_unbind_variable+0x3a>
mov    $0x0,%edi
callq  552d <check_unbind_variable+0x1e>
mov    $0x0,%edx
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  5542 <check_unbind_variable+0x33>
mov    $0xffffffff,%eax
jmp    5551 <check_unbind_variable+0x42>
mov    %rbx,%rdi
callq  5551 <check_unbind_variable+0x42>
pop    %rbx
retq   
<<<sep_in_sample>>>
check_unbind_variable (name)
     const char *name;
{
  SHELL_VAR *v;
  v = find_variable (name);
  if (v && ((((v)->attributes) & (0x0000002))))
    {
      internal_error (gettext("%s: cannot unset: readonly %s"), name, "variable");
      return -1;
    }
  return (unbind_variable (name));
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 11
18 11
19 12
20 12
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
jne    4c1 <gsl_permutation_memcpy+0x14>
mov    $0x0,%eax
test   %r8,%r8
jne    4e5 <gsl_permutation_memcpy+0x38>
repz retq 
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x107,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4de <gsl_permutation_memcpy+0x31>
mov    $0x13,%eax
jmp    504 <gsl_permutation_memcpy+0x57>
mov    0x8(%rsi),%rdx
mov    (%rdx,%rax,8),%rcx
mov    0x8(%rdi),%rdx
mov    %rcx,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r8,%rax
jne    4e5 <gsl_permutation_memcpy+0x38>
mov    $0x0,%eax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permutation_memcpy (gsl_permutation * dest,
                        const gsl_permutation * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("permutation lengths are not equal", "permutation.c", 263, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        dest->data[j] = src->data[j];
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 12
5 12
6 12
7 18
8 3
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 14
18 14
19 14
20 12
21 12
22 12
23 17
24 17
25 18
26 18
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 25fb <c_get_in+0x7>
retq   
<<<sep_in_sample>>>
c_get_in (void)
{
        return c_in;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x0,%edx
callq  bfe <grecs_node_from_path+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
grecs_node_from_path(const char *path, const char *value)
{
 return grecs_node_from_path_locus(path, value, ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
lea    0x1(%rsi),%rsi
mov    (%rdi),%rdi
callq  3d7 <null_at+0x18>
mov    %rax,0x0(%rbp)
movb   $0x0,(%rax,%rbx,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
null_at(char **data, size_t index)
{
    ((void) (0));
    *data = (char *)nrealloc(*data, (index + 1) * sizeof(char));
    (*data)[index] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 6
12 6
13 6
14 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  25b <polynomial_init+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
polynomial_init (void *vstate,
                 const double xa[], const double ya[], size_t size)
{
  polynomial_state_t *state = (polynomial_state_t *) vstate;
  int status = gsl_poly_dd_init (state->d, xa, ya, size);
  return status;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x155,%esi
mov    $0x0,%edi
callq  986 <dfaerror+0x13>
mov    %rbx,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  998 <dfaerror+0x25>
mov    $0x2,%edi
callq  9a2 <re_update>
<<<sep_in_sample>>>
dfaerror(const char *s)
{
 (*(set_loc("re.c", 341), r_fatal))("%s", s);
 exit(2);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
jne    1cd <gsl_blas_cdotc+0x33>
mov    0x10(%rsi),%rcx
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  1c6 <gsl_blas_cdotc+0x2c>
mov    $0x0,%eax
jmp    1eb <gsl_blas_cdotc+0x51>
mov    $0x13,%ecx
mov    $0x8d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e6 <gsl_blas_cdotc+0x4c>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_cdotc (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotc)
{
  if (X->size == Y->size)
    {
      cblas_cdotc_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotc)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 141, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 12
22 14
23 14
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # b1 <raw_job_exit_status+0x7>
je     df <raw_job_exit_status+0x35>
movslq %edi,%rdi
mov    0x0(%rip),%rax        # bd <raw_job_exit_status+0x13>
mov    (%rax,%rdi,8),%rax
mov    0x8(%rax),%rsi
mov    %rsi,%rdx
mov    $0x0,%eax
mov    0xc(%rdx),%ecx
test   %ecx,%ecx
cmovne %ecx,%eax
mov    (%rdx),%rdx
cmp    %rdx,%rsi
jne    cd <raw_job_exit_status+0x23>
repz retq 
movslq %edi,%rdi
mov    0x0(%rip),%rax        # e9 <raw_job_exit_status+0x3f>
mov    (%rax,%rdi,8),%rax
mov    0x8(%rax),%rcx
mov    %rcx,%rdx
mov    (%rdx),%rax
cmp    %rax,%rcx
je     101 <raw_job_exit_status+0x57>
mov    %rax,%rdx
jmp    f4 <raw_job_exit_status+0x4a>
mov    0xc(%rdx),%eax
retq   
<<<sep_in_sample>>>
raw_job_exit_status (job)
     int job;
{
  register PROCESS *p;
  int fail;
  WAIT ret;
  if (pipefail_opt)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
 {
   if ((p->status) != 0)
     fail = (p->status);
   p = p->next;
 }
      while (p != jobs[job]->pipe);
      (ret) = fail;
      return ret;
    }
  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}
<<<sep_in_sample>>>
1 7
2 7
3 10
4 10
5 10
6 10
7 10
8 9
9 13
10 13
11 14
12 15
13 17
14 17
15 17
16 21
17 21
18 21
19 21
20 21
21 21
22 21
23 21
24 21
25 21
26 23
27 24
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 2101 <remove_delayed_set_stat+0xf>
test   %rbx,%rbx
je     215b <remove_delayed_set_stat+0x69>
mov    %rdi,%r14
mov    0x0(%rip),%r12d        # 2110 <remove_delayed_set_stat+0x1e>
mov    $0x0,%r13d
mov    (%rbx),%rbp
cmp    %r12d,0x5c(%rbx)
jne    214e <remove_delayed_set_stat+0x5c>
mov    0xa0(%rbx),%rdi
mov    %r14,%rsi
callq  212e <remove_delayed_set_stat+0x3c>
test   %eax,%eax
jne    214e <remove_delayed_set_stat+0x5c>
mov    %rbx,%rdi
callq  6 <free_delayed_set_stat>
test   %r13,%r13
je     2145 <remove_delayed_set_stat+0x53>
mov    %rbp,0x0(%r13)
jmp    215b <remove_delayed_set_stat+0x69>
mov    %rbp,0x0(%rip)        # 214c <remove_delayed_set_stat+0x5a>
jmp    215b <remove_delayed_set_stat+0x69>
test   %rbp,%rbp
je     215b <remove_delayed_set_stat+0x69>
mov    %rbx,%r13
mov    %rbp,%rbx
jmp    2116 <remove_delayed_set_stat+0x24>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
remove_delayed_set_stat (const char *fname)
{
  struct delayed_set_stat *data, *next, *prev = ((void *)0);
  for (data = delayed_set_stat_head; data; data = next)
    {
      next = data->next;
      if (chdir_current == data->change_dir
   && strcmp (data->file_name, fname) == 0)
 {
   free_delayed_set_stat (data);
   if (prev)
     prev->next = next;
   else
     delayed_set_stat_head = next;
   return;
 }
      else
 prev = data;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 7
11 3
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 10
21 10
22 11
23 11
24 12
25 12
26 14
27 14
28 4
29 4
30 6
31 6
32 6
33 20
34 20
35 20
36 20
37 20
38 20
<<<sep_out_sample>>>
movl   $0x7,0x0(%rip)        # a2d <begin_def+0xa>
retq   
<<<sep_in_sample>>>
begin_def (void)
{
  (yy_start) = 1 + 2 * (3);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    $0x10,%esi
mov    $0x1,%edi
callq  62e <mu_acl_create+0x16>
mov    %rax,%rbx
test   %rax,%rax
jne    63f <mu_acl_create+0x27>
callq  63b <mu_acl_create+0x23>
mov    (%rax),%eax
jmp    6a0 <mu_acl_create+0x88>
lea    0x8(%rax),%rdi
callq  648 <mu_acl_create+0x30>
mov    %eax,%ebp
test   %eax,%eax
je     658 <mu_acl_create+0x40>
mov    %rbx,%rdi
callq  656 <mu_acl_create+0x3e>
jmp    65c <mu_acl_create+0x44>
mov    %rbx,(%r12)
mov    0x8(%rbx),%rdi
mov    $0x0,%esi
callq  66a <mu_acl_create+0x52>
mov    $0x0,%edi
callq  674 <mu_acl_create+0x5c>
mov    %eax,%r12d
mov    %ebp,%eax
test   %r12d,%r12d
je     6a0 <mu_acl_create+0x88>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  68b <mu_acl_create+0x73>
mov    %eax,%edx
mov    %ebp,%eax
test   %edx,%edx
jne    6a0 <mu_acl_create+0x88>
mov    %r12d,%esi
mov    (%rbx),%rdi
callq  69e <mu_acl_create+0x86>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mu_acl_create (mu_acl_t *pacl)
{
  int rc;
  mu_acl_t acl;
  mu_log_level_t level;
  acl = calloc (1, sizeof (*acl));
  if (!acl)
    return (*__errno_location ());
  rc = mu_list_create (&acl->aclist);
  if (rc)
    free (acl);
  else
    *pacl = acl;
  mu_list_set_destroy_item (acl->aclist, _destroy_acl_entry);
  level = mu_global_debug_level ("acl");
  if (level)
    {
      int status = mu_debug_create (&acl->debug, ((void *)0));
      if (status == 0)
 mu_debug_set_level (acl->debug, level);
    }
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 9
15 9
16 9
17 10
18 10
19 11
20 11
21 11
22 13
23 14
24 14
25 14
26 15
27 15
28 15
29 22
30 16
31 16
32 18
33 18
34 18
35 18
36 22
37 19
38 19
39 20
40 20
41 20
42 22
43 23
44 23
45 23
46 23
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
cgst_preloop(const void * vtrust_state, void * vstate)
{
  (void)vtrust_state;
  (void)vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     656 <gsl_vector_complex_float_isnonneg+0x3e>
shl    $0x3,%rsi
mov    0x10(%rdi),%rax
mov    $0x0,%edx
xorps  %xmm1,%xmm1
movaps %xmm1,%xmm0
jmp    64b <gsl_vector_complex_float_isnonneg+0x33>
ucomiss 0x4(%rax),%xmm0
ja     65c <gsl_vector_complex_float_isnonneg+0x44>
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
je     662 <gsl_vector_complex_float_isnonneg+0x4a>
ucomiss (%rax),%xmm1
jbe    639 <gsl_vector_complex_float_isnonneg+0x21>
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_isnonneg (const gsl_vector_complex_float * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 11
18 11
19 13
20 13
21 17
22 17
23 13
24 13
25 17
26 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   $0xf,%sil
je     29 <nettle_camellia128_crypt+0x29>
lea    0x0(%rip),%rcx        # 11 <nettle_camellia128_crypt+0x11>
mov    $0x32,%edx
lea    0x0(%rip),%rsi        # 1d <nettle_camellia128_crypt+0x1d>
lea    0x0(%rip),%rdi        # 24 <nettle_camellia128_crypt+0x24>
callq  29 <nettle_camellia128_crypt+0x29>
mov    %rdx,%r8
mov    %rcx,%r9
mov    %rsi,%rcx
mov    0x0(%rip),%rdx        # 39 <nettle_camellia128_crypt+0x39>
mov    %rdi,%rsi
mov    $0x18,%edi
callq  46 <nettle_camellia128_crypt+0x46>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_camellia128_crypt(const struct camellia128_ctx *ctx,
    size_t length, uint8_t *dst,
    const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "camellia128-crypt.c", 50, __PRETTY_FUNCTION__));
  _nettle_camellia_crypt(24, ctx->keys,
    &_nettle_camellia_table,
    length, dst, src);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 9
17 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edx
lea    -0x53(%rdx),%eax
cmp    $0x1,%eax
jbe    118 <workbeforetest+0x79>
cmp    $0x59,%edx
je     118 <workbeforetest+0x79>
lea    -0x6b(%rdx),%ecx
mov    $0x1,%eax
cmp    $0x1,%ecx
jbe    124 <workbeforetest+0x85>
cmp    $0x75,%edx
je     124 <workbeforetest+0x85>
cmp    $0x50,%edx
jne    d5 <workbeforetest+0x36>
mov    0x38(%rdi),%rax
cmpb   $0x4e,0x5e(%rax)
jne    e5 <workbeforetest+0x46>
jmp    11f <workbeforetest+0x80>
cmp    $0x58,%edx
jne    e5 <workbeforetest+0x46>
mov    $0x1,%eax
cmpb   $0x0,0x19(%rdi)
jne    124 <workbeforetest+0x85>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     fe <workbeforetest+0x5f>
callq  9f <workbeforetest>
mov    %eax,%edx
mov    $0x1,%eax
test   %dl,%dl
jne    124 <workbeforetest+0x85>
mov    0x28(%rbx),%rdi
mov    $0x0,%eax
test   %rdi,%rdi
je     124 <workbeforetest+0x85>
callq  9f <workbeforetest>
test   %al,%al
setne  %al
jmp    124 <workbeforetest+0x85>
mov    $0x1,%eax
jmp    124 <workbeforetest+0x85>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
workbeforetest (exp_t *re)
{
  int token;
  token = re->token;
  if (token == MNEWARG || token == MARRAYARG ||
      token == MQUA || token == MQUANOTNONE || token == MQUANONEAND ||
      token == MCONC || (token == MIDENTIFIER && re->rd->categ == 'N') ||
      (token == MPROCARG && re->danger))
    return (1);
  if (re->left != ((void *)0) && workbeforetest (re->left))
    return (1);
  if (re->right != ((void *)0) && workbeforetest (re->right))
    return (1);
  return (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 5
7 5
8 5
9 6
10 9
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 11
32 10
33 10
34 12
35 14
36 12
37 12
38 12
39 12
40 12
41 12
42 9
43 9
44 9
45 15
46 15
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 207e <php_set_out+0x7>
retq   
<<<sep_in_sample>>>
php_set_out (FILE * out_str )
{
        php_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  16f <remove_pid+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
remove_pid (char *pidfile)
{
  return unlink (pidfile);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
ucomisd 0x0(%rip),%xmm0        # 174e <gsl_complex_arccot+0xc>
jp     175e <gsl_complex_arccot+0x1c>
jne    175e <gsl_complex_arccot+0x1c>
ucomisd 0x0(%rip),%xmm1        # 175a <gsl_complex_arccot+0x18>
jp     175e <gsl_complex_arccot+0x1c>
je     176a <gsl_complex_arccot+0x28>
callq  1763 <gsl_complex_arccot+0x21>
callq  1768 <gsl_complex_arccot+0x26>
jmp    1776 <gsl_complex_arccot+0x34>
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 1776 <gsl_complex_arccot+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_arccot (gsl_complex a)
{
  gsl_complex z;
  if (((a).dat[0]) == 0.0 && ((a).dat[1]) == 0.0)
    {
      do {(&z)->dat[0]=(1.57079632679489661923); (&z)->dat[1]=(0);} while(0);
    }
  else
    {
      z = gsl_complex_inverse (a);
      z = gsl_complex_arctan (z);
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 10
9 11
10 11
11 6
12 6
13 14
14 14
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
size_buffer(b)
  struct buffer *b;
{
  return b->length;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r12
mov    %rsi,%rbx
mov    0x30(%rdi),%rbp
cmp    %rsi,%rbp
jae    58e <gl_array_nx_add_at+0x1e>
callq  58e <gl_array_nx_add_at+0x1e>
mov    %rdx,%r13
cmp    %rbp,0x38(%rdi)
jne    5a0 <gl_array_nx_add_at+0x30>
callq  506 <grow>
test   %eax,%eax
js     5d7 <gl_array_nx_add_at+0x67>
mov    0x28(%r12),%rdx
cmp    %rbx,%rbp
jbe    5c4 <gl_array_nx_add_at+0x54>
lea    -0x8(%rdx,%rbp,8),%rcx
lea    -0x8(%rdx,%rbx,8),%rax
mov    (%rcx),%r8
mov    %r8,0x8(%rcx)
sub    $0x8,%rcx
cmp    %rax,%rcx
jne    5b4 <gl_array_nx_add_at+0x44>
mov    %r13,(%rdx,%rbx,8)
add    $0x1,%rbp
mov    %rbp,0x30(%r12)
lea    0x1(%rbx),%rax
jmp    5dc <gl_array_nx_add_at+0x6c>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gl_array_nx_add_at (gl_list_t list, size_t position, const void *elt)
{
  size_t count = list->count;
  const void **elements;
  size_t i;
  if (!(position <= count))
    abort ();
  if (count == list->allocated)
    if (grow (list) < 0)
      return ((void *)0);
  elements = list->elements;
  for (i = count; i > position; i--)
    elements[i] = elements[i - 1];
  elements[position] = elt;
  list->count = count + 1;
  return (gl_list_node_t)(unsigned long)(size_t)((position) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 9
18 11
19 12
20 12
21 12
22 12
23 13
24 13
25 13
26 12
27 12
28 14
29 15
30 15
31 16
32 16
33 10
34 17
35 17
36 17
37 17
38 17
39 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  164 <xcalloc+0x9>
test   %rax,%rax
jne    16e <xcalloc+0x13>
callq  16e <xcalloc+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 8
7 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4ef <taru_digs_delete+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
taru_digs_delete(FILE_DIGS * digs)
{
 free(digs);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     1fed <print_file_variables+0x24>
sub    $0x8,%rsp
mov    0x8(%rax),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  243 <print_variable_set>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
print_file_variables (const struct file *file)
{
  if (file->variables != 0)
    print_variable_set (file->variables->set, "# ", 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     612 <parseopts+0x130>
mov    %rsi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
movslq 0x0(%rip),%rax        # 511 <parseopts+0x2f>
cmp    %rax,%rdx
jbe    570 <parseopts+0x8e>
mov    0x0(%rip),%rdi        # 51d <parseopts+0x3b>
test   %rdi,%rdi
je     527 <parseopts+0x45>
callq  527 <parseopts+0x45>
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
mov    %eax,0x0(%rip)        # 545 <parseopts+0x63>
add    $0x1,%eax
movslq %eax,%rdi
callq  550 <parseopts+0x6e>
mov    %rax,0x0(%rip)        # 557 <parseopts+0x75>
test   %rax,%rax
jne    570 <parseopts+0x8e>
mov    $0x0,%edi
callq  566 <parseopts+0x84>
mov    $0x1,%edi
callq  570 <parseopts+0x8e>
mov    0x0(%rip),%rbx        # 577 <parseopts+0x95>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  582 <parseopts+0xa0>
cmpb   $0x20,(%rbx)
jne    59a <parseopts+0xb8>
mov    $0x0,%edx
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rbx,%rax,1)
je     58c <parseopts+0xaa>
jmp    59f <parseopts+0xbd>
mov    $0x0,%edx
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
je     619 <parseopts+0x137>
mov    $0x0,%eax
test   %rbp,%rbp
je     5bc <parseopts+0xda>
movslq %eax,%rsi
mov    %rcx,0x0(%rbp,%rsi,8)
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
je     5dd <parseopts+0xfb>
add    $0x1,%edx
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
jne    5cb <parseopts+0xe9>
test   %cl,%cl
je     602 <parseopts+0x120>
test   %rbp,%rbp
je     5ea <parseopts+0x108>
movb   $0x0,(%r8)
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
jne    602 <parseopts+0x120>
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
je     5f6 <parseopts+0x114>
add    $0x1,%eax
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
jne    5af <parseopts+0xcd>
jmp    61e <parseopts+0x13c>
mov    $0x0,%eax
jmp    61e <parseopts+0x13c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parseopts(char *opts, char **arg)
{
  static char *optcpy = ((void *)0);
  static int optlen = 0;
  int i;
  int a;
  if (!opts)
    return 0;
  if (strlen(opts) > optlen)
    {
      if (optcpy)
 free(optcpy);
      optlen = strlen(opts);
      if (!(optcpy = malloc(optlen + 1)))
 {
   perror("dap");
   exit(1);
 }
    }
  strcpy(optcpy, opts);
  for (i = 0; optcpy[i] == ' '; i++)
    ;
  for (a = 0; optcpy[i]; a++)
    {
      if (arg)
 arg[a] = optcpy + i;
      while (optcpy[i] && optcpy[i] != ' ')
 i++;
      if (optcpy[i])
 {
   if (arg)
     optcpy[i] = '\0';
   for (i++; optcpy[i] == ' '; i++)
     ;
 }
    }
  return a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 17
36 17
37 20
38 20
39 20
40 20
41 21
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 21
50 23
51 23
52 23
53 23
54 23
55 25
56 25
57 26
58 26
59 27
60 27
61 27
62 27
63 27
64 28
65 27
66 27
67 27
68 27
69 27
70 29
71 29
72 31
73 31
74 32
75 33
76 33
77 33
78 33
79 33
80 33
81 33
82 33
83 23
84 23
85 23
86 23
87 23
88 23
89 8
90 8
91 23
92 38
93 38
94 38
95 38
<<<sep_out_sample>>>
cmp    $0x9,%edi
je     c5 <c_isspace+0x18>
cmp    $0x20,%edi
je     c5 <c_isspace+0x18>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
movzbl %al,%eax
jmp    ca <c_isspace+0x1d>
mov    $0x1,%eax
and    $0x1,%eax
retq   
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 3
12 5
<<<sep_out_sample>>>
sub    $0x28,%rsp
test   %edi,%edi
je     72f <exec_login+0x57>
mov    0x90(%rsi),%r8
lea    0xb8(%rsi),%rax
mov    %rax,0x10(%rsp)
movq   $0x0,0x8(%rsp)
mov    0x98(%rsi),%rax
mov    %rax,(%rsp)
mov    $0x0,%r9d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 723 <exec_login+0x4b>
mov    $0x0,%eax
callq  72d <exec_login+0x55>
jmp    771 <exec_login+0x99>
mov    0x98(%rsi),%r9
mov    0x90(%rsi),%r8
add    $0xb8,%rsi
mov    %rsi,0x8(%rsp)
movq   $0x0,(%rsp)
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 767 <exec_login+0x8f>
mov    $0x0,%eax
callq  771 <exec_login+0x99>
mov    $0x0,%esi
mov    $0x3,%edi
mov    $0x0,%eax
callq  785 <exec_login+0xad>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
exec_login (int authenticated, struct auth_data *ap)
{
  if (authenticated)
    {
      execle (path_login, "login", "-p", "-h", ap->hostname, "-f",
       ap->lusername, ((void *)0), ap->env);
    }
  else
    {
      execle (path_login, "login", "-p", "-h", ap->hostname,
       ap->lusername, ((void *)0), ap->env);
    }
  syslog (3, "can't exec login: %m");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 13
30 13
31 13
32 13
33 14
34 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  13a <xzalloc+0x9>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %rax,%rdi
callq  14a <xzalloc+0x19>
pop    %rbx
retq   
<<<sep_in_sample>>>
xzalloc (size_t s)
{
  return memset (xmalloc (s), 0, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
cmpl   $0x1,0x118(%rdi)
jne    ab <a2ps_print_buffer+0x41>
mov    %rsi,%r13
mov    %rdx,%rbx
mov    %rcx,%rbp
mov    %r8d,%r14d
cmp    %rcx,%rdx
jae    b0 <a2ps_print_buffer+0x46>
movzbl 0x0(%r13,%rbx,1),%esi
mov    %r14d,%edx
mov    %r12,%rdi
callq  a0 <a2ps_print_buffer+0x36>
add    $0x1,%rbx
cmp    %rbx,%rbp
ja     8f <a2ps_print_buffer+0x25>
jmp    b0 <a2ps_print_buffer+0x46>
callq  b0 <a2ps_print_buffer+0x46>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
a2ps_print_buffer (a2ps_job * job,
     const unsigned char * buffer,
     size_t start, size_t end,
     enum face_e new_face)
{
  size_t i;
  switch (job->output_format)
    {
    case ps:
      for (i = start ; i < end ; i++)
 ps_print_char (job, buffer [i], new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 7
13 10
14 10
15 11
16 11
17 11
18 11
19 10
20 10
21 10
22 10
23 14
24 16
25 16
26 16
27 16
28 16
29 16
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    $0x4,%edi
ja     23e <gc_hash_digest_length+0x24>
mov    %edi,%edi
jmpq   *0x0(,%rdi,8)
mov    $0x14,%eax
retq   
mov    $0x14,%eax
retq   
mov    $0x10,%eax
repz retq 
<<<sep_in_sample>>>
gc_hash_digest_length (Gc_hash hash)
{
  size_t len;
  switch (hash)
    {
    case GC_MD2:
      len = 16;
      break;
    case GC_MD4:
      len = 16;
      break;
    case GC_MD5:
      len = 16;
      break;
    case GC_RMD160:
      len = 20;
      break;
    case GC_SHA1:
      len = 20;
      break;
    default:
      return 0;
    }
  return len;
}
<<<sep_in_sample>>>
1 22
2 4
3 4
4 4
5 4
6 16
7 17
8 19
9 20
10 7
11 25
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%ebp
mov    %rdx,%r12
mov    0x8(%rdi),%rdi
callq  8de <system_fh_rx_packets+0x15>
test   %rax,%rax
jne    8f2 <system_fh_rx_packets+0x29>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  8f0 <system_fh_rx_packets+0x27>
jmp    903 <system_fh_rx_packets+0x3a>
mov    0x10(%rax),%rcx
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
callq  903 <system_fh_rx_packets+0x3a>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
system_fh_rx_packets (format_data_t form, int argc, char *argv[]) { struct pnd_stats *stats = pnd_stats_locate (form->ifr->ifr_ifrn.ifrn_name); if (!stats) put_string (form, "(" "rx_packets" " unknown)"); else put_ulong (form, argc, argv, stats->rx_packets); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
<<<sep_out_sample>>>
test   %rdi,%rdi
je     41a <gsasl_client_callback_realm_get+0xa>
mov    0x78(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_client_callback_realm_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_realm : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x68(%rsp)
xor    %eax,%eax
jmp    c5 <dologout+0x3a>
mov    %eax,%edx
mov    $0x0,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  b5 <dologout+0x2a>
mov    $0x0,%edx
mov    %rdx,%rsi
mov    %rsp,%rdi
callq  c5 <dologout+0x3a>
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  d9 <dologout+0x4e>
test   %eax,%eax
jg     a1 <dologout+0x16>
mov    0x68(%rsp),%rax
xor    %fs:0x28,%rax
je     f5 <dologout+0x6a>
nopl   (%rax)
callq  f5 <dologout+0x6a>
add    $0x78,%rsp
retq   
<<<sep_in_sample>>>
dologout (void)
{
  int pid;
  while ((pid = wait3 (0, 1, 0)) > 0)
    {
      char line[100];
      sprintf (line, "uucp%.4d", (int) pid);
      logwtmp (line, "", "");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 7
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 4
16 4
17 4
18 4
19 4
20 4
21 10
22 10
23 10
24 10
25 10
26 10
27 10
<<<sep_out_sample>>>
lea    0x1(%rdi),%rax
imul   %rax,%rdi
shr    %rdi
lea    (%rdi,%rsi,1),%rax
retq   
<<<sep_in_sample>>>
gsl_sf_legendre_array_index(const size_t l, const size_t m)
{
  return (l * (l + 1) / 2 + m);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  138 <nettle_chacha_poly1305_set_key+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_chacha_poly1305_set_key (struct chacha_poly1305_ctx *ctx,
    const uint8_t *key)
{
  nettle_chacha_set_key (&ctx->chacha, key);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0xb0(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
                       const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %edx,%r13d
mov    0x8(%rdi),%rbx
mov    %rsi,%rdi
callq  8e <strhash_assign+0x1d>
movslq (%r12),%rcx
mov    $0x0,%edx
div    %rcx
lea    (%rbx,%rdx,8),%r14
mov    (%r14),%rbx
test   %rbx,%rbx
je     be <strhash_assign+0x4d>
mov    0x8(%rbx),%rdi
mov    %rbp,%rsi
callq  b2 <strhash_assign+0x41>
test   %eax,%eax
je     be <strhash_assign+0x4d>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    a6 <strhash_assign+0x35>
test   %rbx,%rbx
jne    107 <strhash_assign+0x96>
test   %r13d,%r13d
je     107 <strhash_assign+0x96>
mov    0x10(%r12),%rdi
mov    $0x18,%esi
callq  d7 <strhash_assign+0x66>
mov    %rax,%rbx
mov    0x10(%r12),%rdi
mov    $0x0,%edx
mov    %rbp,%rsi
callq  ec <strhash_assign+0x7b>
mov    %rax,0x8(%rbx)
movq   $0x0,0x10(%rbx)
mov    (%r14),%rax
mov    %rax,(%rbx)
mov    %rbx,(%r14)
addq   $0x1,0x18(%r12)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
strhash_assign(STRHASH *sh, const char *name, int force)
{
 struct sh_head *head = &sh->htab[__hash_string(name) % sh->buckets];
 struct sh_entry *entry;
 for((entry) = (head)->slh_first; (entry); (entry) = (entry)->ptr.sle_next)
  if (strcmp(entry->name, name) == 0)
   break;
 if (entry == ((void *)0) && force) {
  entry = pool_malloc(sh->pool, sizeof(struct sh_entry));
  entry->name = pool_strdup(sh->pool, name, 0);
  entry->value = ((void *)0);
  do { (entry)->ptr.sle_next = (head)->slh_first; (head)->slh_first = (entry); } while (0);
  sh->entries++;
 }
 return entry;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 6
24 5
25 5
26 5
27 8
28 8
29 8
30 8
31 9
32 9
33 9
34 9
35 10
36 10
37 10
38 10
39 10
40 11
41 12
42 12
43 12
44 13
45 16
46 16
47 16
48 16
49 16
50 16
51 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x3a,%edx
callq  f7a <quotearg_colon_mem+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x50,%rsp
mov    %rdi,%rbp
mov    %rdx,%r12
mov    (%rdi),%r13
mov    $0x1,%edx
lea    0x10(%rsp),%rdi
callq  407 <rec_parse_regexp+0x24>
test   %eax,%eax
sete   %bl
jne    499 <rec_parse_regexp+0xb6>
mov    $0x0,%r8d
mov    %rsp,%rcx
mov    $0x1,%edx
mov    %r13,%rsi
lea    0x10(%rsp),%rdi
callq  42d <rec_parse_regexp+0x4a>
test   %eax,%eax
jne    47d <rec_parse_regexp+0x9a>
test   %r12,%r12
je     465 <rec_parse_regexp+0x82>
mov    0x4(%rsp),%r14d
lea    0x1(%r14),%edi
movslq %edi,%rdi
callq  447 <rec_parse_regexp+0x64>
mov    %rax,(%r12)
movslq %r14d,%r14
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,%rdi
callq  45c <rec_parse_regexp+0x79>
mov    (%r12),%rax
movb   $0x0,(%rax,%r14,1)
movslq 0x4(%rsp),%rax
add    %rax,%r13
lea    0x10(%rsp),%rdi
callq  477 <rec_parse_regexp+0x94>
mov    %r13,0x0(%rbp)
jmp    499 <rec_parse_regexp+0xb6>
test   %r12,%r12
je     48a <rec_parse_regexp+0xa7>
movq   $0x0,(%r12)
lea    0x10(%rsp),%rdi
callq  494 <rec_parse_regexp+0xb1>
mov    $0x0,%ebx
mov    %ebx,%eax
add    $0x50,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
rec_parse_regexp (const char **str, const char *re, char **result)
{
  _Bool ret;
  const char *p;
  regex_t regexp;
  regmatch_t pm;
  ret = 1;
  p = *str;
  if (regcomp (&regexp, re, 1) != 0)
    {
      ret = 0;
    }
  if (ret)
    {
      if (regexec (&regexp, p, 1, &pm, 0) == 0)
        {
          if (result)
            {
              *result = malloc (pm.rm_eo + 1);
              memcpy (*result, p, pm.rm_eo);
              (*result)[pm.rm_eo] = '\0';
            }
          p = p + pm.rm_eo;
        }
      else
        {
          ret = 0;
          if (result)
            {
              *result = ((void *)0);
            }
        }
      regfree (&regexp);
    }
  if (ret)
    {
      *str = p;
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 8
10 9
11 9
12 9
13 9
14 13
15 13
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 17
25 17
26 19
27 19
28 19
29 19
30 19
31 20
32 20
33 20
34 20
35 20
36 21
37 21
38 23
39 23
40 33
41 33
42 37
43 37
44 28
45 28
46 30
47 33
48 33
49 33
50 40
51 40
52 40
53 40
54 40
55 40
56 40
57 40
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
mov    (%rdi),%rax
cmp    0x18(%rsi),%rax
je     27c <gsl_multiroot_fdfsolver_set+0x31>
mov    $0x13,%ecx
mov    $0x7a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  275 <gsl_multiroot_fdfsolver_set+0x2a>
mov    $0x13,%eax
jmp    2cb <gsl_multiroot_fdfsolver_set+0x80>
cmp    (%rdx),%rax
je     2a1 <gsl_multiroot_fdfsolver_set+0x56>
mov    $0x13,%ecx
mov    $0x7f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  29a <gsl_multiroot_fdfsolver_set+0x4f>
mov    $0x13,%eax
jmp    2cb <gsl_multiroot_fdfsolver_set+0x80>
mov    %rsi,0x8(%rbx)
mov    %rdx,%rsi
callq  2ad <gsl_multiroot_fdfsolver_set+0x62>
mov    (%rbx),%rax
mov    0x18(%rbx),%rcx
mov    0x10(%rbx),%rdx
mov    0x8(%rbx),%rsi
mov    0x30(%rbx),%rdi
mov    0x28(%rbx),%r9
mov    0x20(%rbx),%r8
callq  *0x18(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_multiroot_fdfsolver_set (gsl_multiroot_fdfsolver * s,
                             gsl_multiroot_function_fdf * f,
                             const gsl_vector * x)
{
  if (s->x->size != f->n)
    {
      do { gsl_error ("function incompatible with solver size", "fdfsolver.c", 122, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  if (x->size != f->n)
    {
      do { gsl_error ("vector length not compatible with function", "fdfsolver.c", 127, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  s->fdf = f;
  gsl_vector_memcpy(s->x,x);
  return (s->type->set) (s->state, s->fdf, s->x, s->f, s->J, s->dx);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 13
24 14
25 14
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 16
35 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 9b <add_pacct_file+0xe>
callq  a0 <add_pacct_file+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
add_pacct_file(char *name)
{
  file_reader_add_file (pacct_info, name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%edi
mov    $0x0,%eax
callq  6c <il_region_command>
mov    0x0(%rip),%rax        # 383 <il_kill_ring_save+0x1a>
movl   $0x19,0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
il_kill_ring_save()
{
    il_region_command(1);
    il->last_operation = 25;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
cmp    $0x0,%rdi
je     2a43 <rl_get_keymap_name+0x24>
mov    $0x0,%edx
jmp    2a39 <rl_get_keymap_name+0x1a>
add    $0x10,%rdx
cmp    %rdi,-0x8(%rdx)
je     2a48 <rl_get_keymap_name+0x29>
mov    (%rdx),%rax
test   %rax,%rax
jne    2a2f <rl_get_keymap_name+0x10>
repz retq 
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
rl_get_keymap_name (map)
     Keymap map;
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (map == keymap_names[i].map)
      return ((char *)keymap_names[i].name);
  return ((char *)((void *)0));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 5
9 5
10 5
11 5
12 5
13 9
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1,%eax
cmove  %rax,%rsi
and    $0xffffffff,%esi
mov    %rsi,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%r13
mov    0x0(%rip),%r12        # 533 <register_open_file+0x17>
test   %r12,%r12
je     55b <register_open_file+0x3f>
mov    %r12,%rbx
cmp    %rdi,(%r12)
jne    552 <register_open_file+0x36>
jmp    588 <register_open_file+0x6c>
cmp    %rbp,(%rbx)
jne    552 <register_open_file+0x36>
nopl   0x0(%rax,%rax,1)
jmp    58b <register_open_file+0x6f>
mov    0x10(%rbx),%rbx
test   %rbx,%rbx
jne    543 <register_open_file+0x27>
mov    $0x20,%edi
callq  565 <register_open_file+0x49>
mov    %rax,%rbx
mov    %r12,0x10(%rax)
mov    %rax,0x0(%rip)        # 573 <register_open_file+0x57>
mov    %r13,%rdi
callq  57b <register_open_file+0x5f>
mov    %rax,0x8(%rbx)
mov    %rbp,(%rbx)
andb   $0xfe,0x18(%rbx)
jmp    596 <register_open_file+0x7a>
mov    %r12,%rbx
mov    0x8(%rbx),%rdi
callq  594 <register_open_file+0x78>
jmp    573 <register_open_file+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
register_open_file (fp, name, temp)
  FILE *fp;
  const char *name;
  int temp;
{
  struct open_file *p;
  for (p=open_files; p; p=p->link)
    {
      if (fp == p->fp)
 {
   (ck_free(p->name));
   break;
 }
    }
  if (!p)
    {
      p = (ck_malloc((1)*sizeof(struct open_file)));
      p->link = open_files;
      open_files = p;
    }
  p->name = ck_strdup(name);
  p->fp = fp;
  p->temp = 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 7
20 7
21 7
22 17
23 17
24 17
25 18
26 19
27 21
28 21
29 21
30 22
31 23
32 23
33 7
34 11
35 11
36 11
37 24
38 24
39 24
40 24
41 24
42 24
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%r8
mov    %rdx,%rax
movzbl 0x50(%rdx),%edx
mov    0x58(%rax),%rsi
mov    0x40(%rax),%rdi
mov    $0x0,%ecx
callq  c5d <pred_print+0x20>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
pred_print (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) stat_buf;
  (void) pred_ptr;
  print_quoted (pred_ptr->args.printf_vec.stream,
  pred_ptr->args.printf_vec.quote_opts,
  pred_ptr->args.printf_vec.dest_is_tty,
  "%s\n", pathname);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 10
10 10
11 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%r8
mov    %rsi,%rbx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rsi
mov    %rbx,%rdx
mov    %r8,%rdi
callq  162 <_rl_get_char_len+0x27>
cmp    $0xfffffffffffffffe,%rax
jne    176 <_rl_get_char_len+0x3b>
test   %rbx,%rbx
je     195 <_rl_get_char_len+0x5a>
movq   $0x0,(%rbx)
jmp    195 <_rl_get_char_len+0x5a>
cmp    $0xffffffffffffffff,%rax
jne    18a <_rl_get_char_len+0x4f>
test   %rbx,%rbx
je     195 <_rl_get_char_len+0x5a>
movq   $0x0,(%rbx)
jmp    195 <_rl_get_char_len+0x5a>
test   %rax,%rax
mov    $0x0,%edx
cmove  %edx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
_rl_get_char_len (src, ps)
     char *src;
     mbstate_t *ps;
{
  size_t tmp;
  tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
  if (tmp == (size_t)(-2))
    {
      if (ps)
 memset (ps, 0, sizeof(mbstate_t));
      return -2;
    }
  else if (tmp == (size_t)(-1))
    {
      if (ps)
 memset (ps, 0, sizeof(mbstate_t));
      return -1;
    }
  else if (tmp == (size_t)0)
    return 0;
  else
    return (int)tmp;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 9
15 9
16 10
17 10
18 13
19 13
20 15
21 15
22 16
23 16
24 19
25 22
26 22
27 23
28 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     10d3 <gsl_sort_vector_char_index+0x2c>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10cc <gsl_sort_vector_char_index+0x25>
mov    $0x13,%eax
jmp    10e9 <gsl_sort_vector_char_index+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  10e4 <gsl_sort_vector_char_index+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_char_index (gsl_permutation * permutation, const gsl_vector_char * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_char_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 43 <disk_fill_input_buffer+0xb>
mov    %rax,0x0(%rip)        # 4a <disk_fill_input_buffer+0x12>
cmp    $0x200,%rsi
mov    $0x200,%edx
cmovle %rsi,%rdx
mov    %rax,%rsi
callq  62 <disk_fill_input_buffer+0x2a>
mov    %rax,%rdx
mov    %rax,0x0(%rip)        # 6c <disk_fill_input_buffer+0x34>
cmp    $0xffffffffffffffff,%rax
jne    84 <disk_fill_input_buffer+0x4c>
movq   $0x0,0x0(%rip)        # 7d <disk_fill_input_buffer+0x45>
mov    $0xffffffff,%eax
jmp    97 <disk_fill_input_buffer+0x5f>
mov    $0x1,%eax
test   %rdx,%rdx
je     97 <disk_fill_input_buffer+0x5f>
add    %rdx,0x0(%rip)        # 95 <disk_fill_input_buffer+0x5d>
mov    $0x0,%al
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
disk_fill_input_buffer (int in_des, off_t num_bytes)
{
  in_buff = input_buffer;
  num_bytes = (num_bytes < 512) ? num_bytes : 512;
  input_size = read (in_des, input_buffer, num_bytes);
  if (input_size == ((size_t) -1))
    {
      input_size = 0;
      return (-1);
    }
  else if (input_size == 0)
    return (1);
  input_bytes += input_size;
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 6
12 6
13 8
14 9
15 9
16 12
17 11
18 11
19 13
20 14
21 15
22 15
<<<sep_out_sample>>>
push   %rbx
callq  bb <read_2_bytes>
cmp    $0x1,%eax
ja     161 <skip_variable+0x30>
mov    $0x0,%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 14d <skip_variable+0x1c>
mov    $0x0,%eax
callq  157 <skip_variable+0x26>
mov    $0x1,%edi
callq  161 <skip_variable+0x30>
sub    $0x2,%eax
mov    %eax,%ebx
je     172 <skip_variable+0x41>
callq  7c <read_1_byte>
sub    $0x1,%ebx
jne    168 <skip_variable+0x37>
pop    %rbx
retq   
<<<sep_in_sample>>>
skip_variable (void)
{
  unsigned int length;
  length = read_2_bytes();
  if (length < 2)
    (fprintf(stderr, "%s\n", "Erroneous JPEG marker length"), exit(1));
  length -= 2;
  while (length > 0) {
    (void) read_1_byte();
    length--;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 8
15 9
16 8
17 8
18 12
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    $0x28,%ecx
mov    $0x5,%esi
callq  535 <nettle_arctwo40_set_key+0x16>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nettle_arctwo40_set_key (struct arctwo_ctx *ctx, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, 5, key, 40);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    %rdx,%rsi
shr    $0x3,%rsi
mov    %esi,%ecx
test   %esi,%esi
jle    55 <masklen_to_netmask+0x55>
mov    $0x0,%eax
movb   $0xff,(%rdi,%rax,1)
add    $0x1,%rax
cmp    %eax,%ecx
jg     12 <masklen_to_netmask+0x12>
cmp    $0x10,%esi
je     71 <masklen_to_netmask+0x71>
and    $0x7,%edx
mov    $0x8,%ecx
sub    %edx,%ecx
lea    0x1(%rsi),%eax
movslq %esi,%rsi
mov    $0xff,%edx
sar    %cl,%edx
shl    %cl,%edx
mov    %dl,(%rdi,%rsi,1)
cmp    $0xf,%eax
jg     71 <masklen_to_netmask+0x71>
movslq %eax,%rdx
movb   $0x0,(%rdi,%rdx,1)
add    $0x1,%eax
cmp    $0x10,%eax
jne    44 <masklen_to_netmask+0x44>
repz retq 
and    $0x7,%edx
mov    $0x8,%ecx
sub    %edx,%ecx
mov    $0xff,%eax
sar    %cl,%eax
shl    %cl,%eax
mov    %al,(%rdi)
mov    $0x1,%eax
jmp    44 <masklen_to_netmask+0x44>
repz retq 
<<<sep_in_sample>>>
masklen_to_netmask(unsigned char *buf, size_t len, size_t masklen)
{
 int i, cnt;
 cnt = masklen / 8;
 for (i = 0; i < cnt; i++)
  buf[i] = 0xff;
 if (i == 16)
  return;
 cnt = 8 - masklen % 8;
 buf[i++] = (0xff >> cnt) << cnt;
 for (; i < 16; i++)
  buf[i] = 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 5
10 5
11 7
12 7
13 9
14 9
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 12
26 11
27 11
28 11
29 11
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 10
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    (%rdi),%ebx
mov    $0x1,%eax
cmp    (%rsi),%ebx
jne    1a28 <grecs_node_eq+0x4e>
mov    $0x0,%al
test   %ebx,%ebx
je     1a28 <grecs_node_eq+0x4e>
mov    0x48(%rsi),%rsi
mov    0x48(%rdi),%rdi
callq  1a02 <grecs_node_eq+0x28>
test   %eax,%eax
jne    1a23 <grecs_node_eq+0x49>
cmp    $0x2,%ebx
jne    1a28 <grecs_node_eq+0x4e>
mov    0x70(%r12),%rsi
mov    0x70(%rbp),%rdi
callq  1a19 <grecs_node_eq+0x3f>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    1a28 <grecs_node_eq+0x4e>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
grecs_node_eq(struct grecs_node *a, struct grecs_node *b)
{
 if (a->type != b->type)
  return 1;
 if (a->type == grecs_node_root)
  return 0;
 if (strcmp(a->ident, b->ident))
  return 1;
 if (a->type == grecs_node_block &&
     !grecs_value_eq(a->v.value, b->v.value))
  return 1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 3
10 6
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 10
21 10
22 10
23 9
24 9
25 9
26 9
27 8
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%r12
mov    (%rsi),%ebx
mov    $0x0,%eax
test   $0x28,%bl
je     590 <CDB___ram_set_flags+0x71>
mov    %rdi,%rbp
testb  $0x10,0x23d(%rdi)
je     553 <CDB___ram_set_flags+0x34>
mov    0x28(%rdi),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
callq  551 <CDB___ram_set_flags+0x32>
jmp    590 <CDB___ram_set_flags+0x71>
mov    $0x8,%esi
callq  55d <CDB___ram_set_flags+0x3e>
mov    %eax,%edx
test   %edx,%edx
jne    590 <CDB___ram_set_flags+0x71>
test   $0x8,%bl
je     575 <CDB___ram_set_flags+0x56>
orl    $0x10000,0x23c(%rbp)
and    $0xfffffff7,%ebx
test   $0x20,%bl
je     587 <CDB___ram_set_flags+0x68>
orl    $0x20000,0x23c(%rbp)
and    $0xffffffdf,%ebx
mov    %ebx,(%r12)
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
CDB___ram_set_flags(dbp, flagsp)
 DB *dbp;
 u_int32_t *flagsp;
{
 u_int32_t flags;
 flags = *flagsp;
 if ((flags & (0x0008 | 0x0020))) {
  if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "DB->set_flags", 1));;
  { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x08)) != 0) return (__ret); };
  if ((flags & (0x0008))) {
   (dbp)->flags |= (0x10000);
   (flags &= ~(0x0008));
  }
  if ((flags & (0x0020))) {
   (dbp)->flags |= (0x20000);
   (flags &= ~(0x0020));
  }
  *flagsp = flags;
 }
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 20
7 7
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 11
25 12
26 14
27 14
28 15
29 16
30 18
31 20
32 21
33 21
34 21
35 21
<<<sep_out_sample>>>
movb   $0x1,0x1c(%rdi)
movl   $0x0,0x14(%rdi)
movl   $0x0,0x18(%rdi)
mov    %esi,(%rdi)
mov    %esi,0x4(%rdi)
mov    %esi,0x8(%rdi)
mov    %esi,0xc(%rdi)
mov    %esi,0x10(%rdi)
retq   
<<<sep_in_sample>>>
i_ring_init (I_ring *ir, int default_val)
{
  int i;
  ir->ir_empty = 1;
  ir->ir_front = 0;
  ir->ir_back = 0;
  for (i = 0; i < I_RING_SIZE; i++)
    ir->ir_data[i] = default_val;
  ir->ir_default_val = default_val;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 8
5 8
6 8
7 8
8 9
9 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    %rdi,%r12
mov    %rsi,%r15
mov    %rdx,%r14
mov    (%rdi),%r13
callq  0 <singular>
mov    %eax,%ebp
test   %eax,%eax
je     63e <gsl_linalg_LU_invert+0x45>
mov    $0x1,%ecx
mov    $0x106,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  637 <gsl_linalg_LU_invert+0x3e>
mov    $0x1,%ebp
jmp    67f <gsl_linalg_LU_invert+0x86>
mov    %r14,%rdi
callq  646 <gsl_linalg_LU_invert+0x4d>
test   %r13,%r13
je     67f <gsl_linalg_LU_invert+0x86>
mov    $0x0,%ebp
mov    $0x0,%ebx
mov    %rbx,%rdx
mov    %r14,%rsi
mov    %rsp,%rdi
callq  663 <gsl_linalg_LU_invert+0x6a>
mov    %rsp,%rdx
mov    %r15,%rsi
mov    %r12,%rdi
callq  671 <gsl_linalg_LU_invert+0x78>
test   %eax,%eax
cmovne %eax,%ebp
add    $0x1,%rbx
cmp    %r13,%rbx
jne    655 <gsl_linalg_LU_invert+0x5c>
mov    %ebp,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_linalg_LU_invert (const gsl_matrix * LU, const gsl_permutation * p, gsl_matrix * inverse)
{
  size_t i, n = LU->size1;
  int status = GSL_SUCCESS;
  if (singular (LU))
    {
      do { gsl_error ("matrix is singular", "lu.c", 262, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  gsl_matrix_set_identity (inverse);
  for (i = 0; i < n; i++)
    {
      gsl_vector_view c = gsl_matrix_column (inverse, i);
      int status_i = gsl_linalg_LU_svx (LU, p, &(c.vector));
      if (status_i)
        status = status_i;
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 9
24 9
25 10
26 10
27 4
28 10
29 12
30 12
31 12
32 12
33 13
34 13
35 13
36 13
37 14
38 15
39 10
40 10
41 10
42 18
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
cmp    %rdx,%rax
ja     723 <gsl_interp2d_get+0x2c>
mov    $0x2,%ecx
mov    $0x18f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  71d <gsl_interp2d_get+0x26>
xorpd  %xmm0,%xmm0
jmp    754 <gsl_interp2d_get+0x5d>
cmp    %rcx,0x30(%rdi)
ja     748 <gsl_interp2d_get+0x51>
mov    $0x2,%ecx
mov    $0x193,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  742 <gsl_interp2d_get+0x4b>
xorpd  %xmm0,%xmm0
jmp    754 <gsl_interp2d_get+0x5d>
imul   %rcx,%rax
add    %rax,%rdx
movsd  (%rsi,%rdx,8),%xmm0
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_interp2d_get(const gsl_interp2d * interp, const double zarr[],
                 const size_t i, const size_t j)
{
  if (i >= interp->xsize)
    {
      do { gsl_error ("x index out of range", "interp2d.c", 399, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else if (j >= interp->ysize)
    {
      do { gsl_error ("y index out of range", "interp2d.c", 403, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else
    {
      return zarr[((j) * ((interp)->xsize) + (i))];
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 14
22 14
23 14
24 16
25 16
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_www_authenticate_get_auth_type (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->auth_type;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edx,0xc(%rsp)
cmp    $0x1,%ecx
je     2b2 <gen_tempname+0x41>
cmp    $0x2,%ecx
je     289 <gen_tempname+0x18>
test   %ecx,%ecx
jne    292 <gen_tempname+0x21>
jmp    2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
xchg   %ax,%ax
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
mov    $0x140,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2ab <gen_tempname+0x3a>
mov    $0x0,%ecx
jmp    2b7 <gen_tempname+0x46>
mov    $0x0,%ecx
lea    0xc(%rsp),%rdx
callq  2c1 <gen_tempname+0x50>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
{
  int (*tryfunc) (char *, void *);
  switch (kind)
    {
    case 0:
      tryfunc = try_file;
      break;
    case 1:
      tryfunc = try_dir;
      break;
    case 2:
      tryfunc = try_nocreate;
      break;
    default:
      ((! "invalid KIND in __gen_tempname") ? (void) (0) : __assert_fail ("! \"invalid KIND in __gen_tempname\"", "tempname.c", 320, __PRETTY_FUNCTION__));
      abort ();
    }
  return try_tempname (tmpl, suffixlen, &flags, tryfunc);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 13
11 13
12 14
13 16
14 16
15 16
16 16
17 16
18 7
19 7
20 10
21 19
22 19
23 20
24 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdx        # f63 <pp_number+0xb>
test   %rdx,%rdx
je     f75 <pp_number+0x1d>
mov    0x8(%rdx),%rax
mov    %rax,0x0(%rip)        # f73 <pp_number+0x1b>
jmp    f82 <pp_number+0x2a>
mov    $0x1,%edi
callq  f7f <pp_number+0x27>
mov    %rax,%rdx
mov    (%rbx),%rax
mov    %rax,(%rdx)
mov    0x8(%rbx),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rbx),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rbx),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rbx),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rbx),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rbx),%rax
mov    %rax,0x30(%rdx)
mov    0x38(%rbx),%rax
mov    %rax,0x38(%rdx)
mov    0x40(%rbx),%rax
mov    %rax,0x40(%rdx)
andl   $0xfffffffb,0x44(%rdx)
mov    $0x0,%esi
mov    $0x0,%edi
callq  fdb <pp_number+0x83>
mov    %rax,%rdx
mov    0x8(%rax),%rcx
mov    0x10(%rax),%rax
movb   $0x0,(%rcx,%rax,1)
mov    0x8(%rdx),%rax
mov    0x0(%rip),%rcx        # ff5 <pp_number+0x9d>
mov    %rcx,0x8(%rdx)
mov    %rdx,0x0(%rip)        # 1000 <pp_number+0xa8>
pop    %rbx
retq   
<<<sep_in_sample>>>
pp_number(NODE *n)
{
 char *str;
 {
  NODE *s;
  (void) ((s = (NODE *) nextfree[BLOCK_NODE].freep) ? (NODE *) (nextfree[BLOCK_NODE].freep = ((BLOCK *) s)->freep) : (s = (NODE *) more_blocks(BLOCK_NODE)));
  *s = *n;
  s->flags &= ~0x0004;
  s = r_format_val("%.6g", 0, s);
  s->sub.val.sp[s->sub.val.slen] = '\0';
  str = s->sub.val.sp;
  (void) (((BLOCK *) s)->freep = nextfree[BLOCK_NODE].freep, nextfree[BLOCK_NODE].freep = (BLOCK *) s);
 }
 return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 8
31 9
32 9
33 9
34 9
35 10
36 10
37 10
38 11
39 12
40 12
41 12
42 15
43 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
mov    0x8(%rdi),%rdi
mov    (%rax),%esi
callq  348 <etar_set_chksum+0x12>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
etar_set_chksum(ETAR * etar)
{
 taru_set_tar_header_sum(((struct tar_header *)((etar)->tar_hdrM)), etar->etar_tarheaderflagsM);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  17 <gss_verify+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gss_verify (OM_uint32 * minor_status,
     gss_ctx_id_t context_handle,
     gss_buffer_t message_buffer,
     gss_buffer_t token_buffer, int *qop_state)
{
  return gss_verify_mic (minor_status, context_handle, message_buffer,
    token_buffer, (gss_qop_t *) qop_state);
}
<<<sep_in_sample>>>
1 5
2 6
3 8
4 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  186 <passes_reinit+0x9>
callq  18b <passes_reinit+0xe>
mov    $0x0,%eax
callq  195 <passes_reinit+0x18>
mov    $0x0,%eax
callq  19f <passes_reinit+0x22>
callq  1a4 <passes_reinit+0x27>
mov    $0x0,%eax
callq  1ae <passes_reinit+0x31>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
passes_reinit (void)
{
  mbuilder_reinit();
  decl_reinit ();
  salloc_reinit ();
  parser_reinit ();
  lex_reinit ();
  extspec_reinit ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 6
7 6
8 7
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %r8,%r12
callq  0 <compute_long_double_wvariance>
movsd  %xmm0,0x8(%rsp)
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  68 <compute_long_double_factor>
movsd  0x8(%rsp),%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    310 <gsl_stats_long_double_wsd_m+0x4d>
mulsd  0x8(%rsp),%xmm0
callq  30c <gsl_stats_long_double_wsd_m+0x49>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_wsd_m (const long double w[], const size_t wstride, const long double data[], const size_t stride, const size_t n, const double wmean)
{
  const double variance = compute_long_double_wvariance (w, wstride, data, stride, n, wmean);
  const double scale = compute_long_double_factor(w, wstride, n);
  const double wsd = sqrt(scale * variance) ;
  return wsd;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 7
23 7
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     13e5 <gsl_vector_free+0x20>
cmpl   $0x0,0x20(%rdi)
je     13dd <gsl_vector_free+0x18>
mov    0x18(%rdi),%rdi
callq  13dd <gsl_vector_free+0x18>
mov    %rbx,%rdi
callq  13e5 <gsl_vector_free+0x20>
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_free (gsl_vector * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 8
10 8
11 9
12 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  12a1 <quote_mem+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
quote_mem (char const *arg, size_t argsize)
{
  return quote_n_mem (0, arg, argsize);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %edi,%r12d
mov    %rsi,%rbp
mov    $0x5a,%edi
callq  dbe <swgp_write_as_echo_line+0x14>
mov    %rax,%rbx
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%eax
callq  ddb <swgp_write_as_echo_line+0x31>
mov    %rbx,%rdi
callq  de3 <swgp_write_as_echo_line+0x39>
mov    %rax,%rbp
mov    %rbx,%rdi
callq  dee <swgp_write_as_echo_line+0x44>
movslq %ebp,%rcx
mov    %rax,%rdx
mov    %r12d,%esi
mov    $0x0,%edi
callq  e01 <swgp_write_as_echo_line+0x57>
mov    %rax,%r12
mov    %rbx,%rdi
callq  e0c <swgp_write_as_echo_line+0x62>
cmp    %r12d,%ebp
setne  %al
movzbl %al,%eax
neg    %eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
swgp_write_as_echo_line(int fd, char * buf)
{
 int ret;
 int len;
 STROB * btmp;
 btmp = strob_open(90);
 strob_sprintf(btmp, 0, "%s\n", buf);
 len = (int)strob_strlen(btmp);
 ret = atomicio((ssize_t (*)(int, void *, size_t))uxfio_write,
   fd, strob_str(btmp), len);
 strob_close(btmp);
 if (ret != len) return -1;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 10
19 10
20 9
21 9
22 9
23 9
24 9
25 9
26 11
27 11
28 12
29 12
30 12
31 12
32 14
33 14
34 14
35 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  465a <set_var_read_only+0x9>
test   %rax,%rax
jne    4686 <set_var_read_only+0x35>
mov    $0x0,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  4671 <set_var_read_only+0x20>
cmpl   $0x0,0x0(%rip)        # 4678 <set_var_read_only+0x27>
jne    4686 <set_var_read_only+0x35>
test   %rax,%rax
je     4686 <set_var_read_only+0x35>
orl    $0x1000,0x28(%rax)
orl    $0x2,0x28(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
set_var_read_only (name)
     char *name;
{
  SHELL_VAR *entry;
  do { entry = find_variable (name); if (!entry) { entry = bind_variable (name, "", 0); if (!no_invisible_vars && entry) entry->attributes |= 0x0001000; } } while (0);
  ((entry)->attributes |= (0x0000002));
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 7
17 7
<<<sep_out_sample>>>
movzwl 0xa8(%rdi),%eax
shl    $0x7,%eax
sar    $0x7,%ax
cwtl   
retq   
<<<sep_in_sample>>>
term_ostream__get_color (term_ostream_t stream)
{
  return stream->curr_attr.color;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # f94 <prog_lookup_by_idx+0x7>
test   %rax,%rax
je     faf <prog_lookup_by_idx+0x22>
mov    %edi,%edi
cmpl   $0x0,0x10(%rax)
jne    fa7 <prog_lookup_by_idx+0x1a>
cmp    %rdi,0x38(%rax)
je     faf <prog_lookup_by_idx+0x22>
mov    (%rax),%rax
test   %rax,%rax
jne    f9b <prog_lookup_by_idx+0xe>
repz retq 
<<<sep_in_sample>>>
prog_lookup_by_idx (unsigned idx)
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (((prog)->type == TYPE_COMPONENT) && prog->v.p.idx == idx)
      break;
  return prog;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 4
12 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edx
mov    $0x0,%esi
callq  714 <CDB___log_init_print+0x13>
mov    %eax,%edx
test   %edx,%edx
jne    729 <CDB___log_init_print+0x28>
mov    $0x2,%dl
mov    $0x0,%esi
mov    %rbx,%rdi
callq  729 <CDB___log_init_print+0x28>
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___log_init_print(dbenv)
 DB_ENV *dbenv;
{
 int ret;
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register1_print, 1)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___log_register_print, 2)) != 0)
  return (ret);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 5
9 8
10 8
11 8
12 8
13 12
14 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpq   $0x0,0x28(%rdi)
jne    11b <jpeg_stdio_dest+0x27>
mov    0x8(%rdi),%rax
mov    $0x38,%edx
mov    $0x0,%esi
callq  *(%rax)
mov    %rax,0x28(%rbx)
mov    0x28(%rbx),%rax
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,0x20(%rax)
mov    %rbp,0x28(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
{
  my_dest_ptr dest;
  if (cinfo->dest == ((void *)0)) {
    cinfo->dest = (struct jpeg_destination_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 0,
      ((size_t) sizeof(my_destination_mgr)));
  }
  dest = (my_dest_ptr) cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->outfile = outfile;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 6
11 6
12 5
13 9
14 10
15 11
16 12
17 13
18 14
19 14
20 14
21 14
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,%r12
mov    %rdx,0x8(%rsp)
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%r15
cmp    %r13,%r15
je     1d9e <gsl_matrix_uchar_fprintf+0x40>
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     1dec <gsl_matrix_uchar_fprintf+0x8e>
jmp    1dbe <gsl_matrix_uchar_fprintf+0x60>
mov    %r15,%rdx
imul   %r14,%rdx
mov    0x18(%rsi),%rsi
mov    0x8(%rsp),%r8
mov    $0x1,%ecx
mov    (%rsp),%rdi
callq  1dbc <gsl_matrix_uchar_fprintf+0x5e>
jmp    1dec <gsl_matrix_uchar_fprintf+0x8e>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    0x8(%rsp),%r8
mov    $0x1,%ecx
mov    %r13,%rdx
mov    (%rsp),%rdi
callq  1ddc <gsl_matrix_uchar_fprintf+0x7e>
test   %eax,%eax
jne    1dec <gsl_matrix_uchar_fprintf+0x8e>
add    $0x1,%rbp
add    %r15,%rbx
cmp    %r14,%rbp
jne    1dbe <gsl_matrix_uchar_fprintf+0x60>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_uchar_fprintf (FILE * stream, const gsl_matrix_uchar * m,
                                const char *format)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uchar_raw_fprintf (stream,
                                                  m->data,
                                                  size1 * size2, 1,
                                                  format);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uchar_raw_fprintf (stream,
                                                      m->data + i * 1 * tda,
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 6
13 7
14 8
15 8
16 18
17 18
18 18
19 18
20 18
21 18
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 20
31 20
32 20
33 20
34 20
35 20
36 20
37 24
38 24
39 18
40 18
41 18
42 18
43 29
44 29
45 29
46 29
47 29
48 29
49 29
50 29
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 376 <terminal_put_text+0xb>
test   %rdx,%rdx
je     384 <terminal_put_text+0x19>
mov    $0x0,%eax
callq  *%rdx
jmp    396 <terminal_put_text+0x2b>
mov    %rdi,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  396 <terminal_put_text+0x2b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
terminal_put_text (char *string)
{
  if (terminal_put_text_hook)
    (*terminal_put_text_hook) (string);
  else
    {
      printf ("%s", string);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 7
9 7
10 7
11 7
12 9
13 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    (%rdi),%rdi
callq  7f6 <assign_string_n+0x15>
test   %r12,%r12
je     81e <assign_string_n+0x3d>
lea    0x1(%rbp),%rdi
callq  804 <assign_string_n+0x23>
mov    %rax,(%rbx)
mov    %rbp,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  815 <assign_string_n+0x34>
mov    (%rbx),%rax
movb   $0x0,(%rax,%rbp,1)
jmp    825 <assign_string_n+0x44>
movq   $0x0,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
assign_string_n (char **pstr, const char *s, size_t length)
{
  free (*pstr);
  if (s)
    {
      *pstr = xmalloc (length + 1);
      memcpy (*pstr, s, length);
      (*pstr)[length] = 0;
    }
  else
    *pstr = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 8
19 8
20 8
21 11
22 12
23 12
24 12
25 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rbx
callq  2b0 <compute_ushort_variance>
test   %rbx,%rbx
js     14b4 <gsl_stats_ushort_sd_m+0x15>
cvtsi2sd %rbx,%xmm1
jmp    14cc <gsl_stats_ushort_sd_m+0x2d>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mov    %rbx,%rax
sub    $0x1,%rax
js     14dc <gsl_stats_ushort_sd_m+0x3d>
cvtsi2sd %rax,%xmm2
jmp    14f1 <gsl_stats_ushort_sd_m+0x52>
mov    %rax,%rdx
shr    %rdx
and    $0x1,%eax
or     %rax,%rdx
cvtsi2sd %rdx,%xmm2
addsd  %xmm2,%xmm2
divsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    155a <gsl_stats_ushort_sd_m+0xbb>
test   %rbx,%rbx
js     150f <gsl_stats_ushort_sd_m+0x70>
cvtsi2sd %rbx,%xmm2
jmp    1527 <gsl_stats_ushort_sd_m+0x88>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm2
addsd  %xmm2,%xmm2
sub    $0x1,%rbx
js     1534 <gsl_stats_ushort_sd_m+0x95>
cvtsi2sd %rbx,%xmm1
jmp    1549 <gsl_stats_ushort_sd_m+0xaa>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
divsd  %xmm1,%xmm2
mulsd  %xmm2,%xmm0
callq  1556 <gsl_stats_ushort_sd_m+0xb7>
movapd %xmm0,%xmm1
movapd %xmm1,%xmm0
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_stats_ushort_sd_m (const unsigned short data[], const size_t stride, const size_t n, const double mean)
{
  const double variance = compute_ushort_variance (data, stride, n, mean);
  const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
  return sd;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 4
30 4
31 4
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 6
57 6
58 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,0x0(%rip)        # 1eb <range+0xc>
movsd  0x0(%rip),%xmm0        # 1f3 <range+0x14>
mulsd  0x0(%rip),%xmm0        # 1fb <range+0x1c>
movsd  %xmm0,(%rsp)
mov    $0x20,%esi
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 211 <range+0x32>
mov    $0x0,%edi
callq  21b <range+0x3c>
movsd  %xmm0,0x8(%rsp)
mov    $0x20,%esi
movsd  0x0(%rip),%xmm1        # 22e <range+0x4f>
xorpd  %xmm0,%xmm0
mov    $0x0,%edi
callq  23c <range+0x5d>
movsd  0x8(%rsp),%xmm1
addsd  %xmm0,%xmm1
mulsd  (%rsp),%xmm1
movsd  0x0(%rip),%xmm0        # 253 <range+0x74>
subsd  %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
range(double w0)
{
  w = w0;
  return 1.0 - dnumdf * 0.398942280401432677940 *
    (dap_simp(&rangef1, -1.0, 0.0, 32) + dap_simp(&rangef2, 0.0, 1.0, 32));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 4
20 4
21 4
22 6
23 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0x64,%edi
je     1d <rad_common_argp_parser+0x1d>
cmp    $0x1000007,%edi
je     51 <rad_common_argp_parser+0x51>
mov    $0x7,%eax
cmp    $0x4c,%edi
jne    62 <rad_common_argp_parser+0x62>
jmp    2b <rad_common_argp_parser+0x2b>
mov    %rsi,0x0(%rip)        # 24 <rad_common_argp_parser+0x24>
mov    $0x0,%eax
jmp    62 <rad_common_argp_parser+0x62>
mov    $0x0,%edi
callq  35 <rad_common_argp_parser+0x35>
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  47 <rad_common_argp_parser+0x47>
mov    $0x0,%edi
callq  51 <rad_common_argp_parser+0x51>
mov    $0x0,%eax
callq  5b <rad_common_argp_parser+0x5b>
mov    $0x0,%eax
jmp    62 <rad_common_argp_parser+0x62>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
rad_common_argp_parser(int key, char *arg, struct argp_state *state)
{
        switch (key) {
        case 'd':
                grad_config_dir = arg;
                break;
        case 'L':
                printf ("%s", gettext(license_text));
                exit (0);
        case 0x1000007:
                grad_path_init();
                break;
        default:
                return 7;
        }
        return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 14
7 3
8 3
9 3
10 5
11 16
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 11
22 11
23 16
24 12
25 17
26 17
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r15
mov    %rsi,%r12
mov    (%rsi),%r14
mov    0x8(%rsi),%r13
mov    0x10(%rsi),%rax
cmp    %r13,%rax
je     173e <gsl_matrix_int_fscanf+0x43>
shl    $0x2,%rax
mov    %rax,0x8(%rsp)
mov    $0x0,%ebx
mov    $0x0,%ebp
mov    $0x0,%eax
test   %r14,%r14
je     177f <gsl_matrix_int_fscanf+0x84>
jmp    1755 <gsl_matrix_int_fscanf+0x5a>
imul   %r14,%rax
mov    %rax,%rdx
mov    0x18(%rsi),%rsi
mov    $0x1,%ecx
callq  1753 <gsl_matrix_int_fscanf+0x58>
jmp    177f <gsl_matrix_int_fscanf+0x84>
mov    %rbx,%rsi
add    0x18(%r12),%rsi
mov    $0x1,%ecx
mov    %r13,%rdx
mov    %r15,%rdi
callq  176d <gsl_matrix_int_fscanf+0x72>
test   %eax,%eax
jne    177f <gsl_matrix_int_fscanf+0x84>
add    $0x1,%rbp
add    0x8(%rsp),%rbx
cmp    %r14,%rbp
jne    1755 <gsl_matrix_int_fscanf+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_matrix_int_fscanf (FILE * stream, gsl_matrix_int * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_int_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_int_raw_fscanf (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 6
13 7
14 7
15 19
16 19
17 19
18 19
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 9
29 18
30 18
31 18
32 18
33 18
34 18
35 21
36 21
37 16
38 16
39 16
40 16
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    0x0(%rip),%rax        # 4211 <reduceunit+0x10>
mov    (%rax),%rdi
test   %rdi,%rdi
je     421e <reduceunit+0x1d>
callq  421e <reduceunit+0x1d>
mov    0x0(%rip),%rax        # 4225 <reduceunit+0x24>
movq   $0x0,(%rax)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  4239 <reduceunit+0x38>
mov    %eax,%ebx
test   $0x4,%al
jne    4252 <reduceunit+0x51>
mov    $0x1,%esi
mov    %rbp,%rdi
callq  424c <reduceunit+0x4b>
or     %ebx,%eax
test   $0x4,%al
je     4267 <reduceunit+0x66>
mov    0x0(%rip),%rax        # 4259 <reduceunit+0x58>
cmpq   $0x1,(%rax)
sbb    %eax,%eax
and    $0xfffffffc,%eax
add    $0x7,%eax
jmp    426c <reduceunit+0x6b>
and    $0x1,%eax
jne    422c <reduceunit+0x2b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
reduceunit(struct unittype *theunit)
{
   int ret;
   if (irreducible)
     free(irreducible);
   irreducible=0;
   ret = (1<<0);
   while (ret & (1<<0)) {
      ret = reduceproduct(theunit, 0);
      if (!(ret & (1<<2)))
        ret |= reduceproduct(theunit, 1);
      if (ret & (1<<2)){
         if (irreducible)
           return 7;
         else
           return 3;
      }
   }
   return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 6
11 6
12 9
13 9
14 9
15 9
16 10
17 10
18 11
19 11
20 11
21 11
22 12
23 12
24 13
25 14
26 14
27 14
28 14
29 14
30 8
31 8
32 20
33 20
34 20
35 20
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
cmpb   $0x2f,(%rsi)
jne    7d <cdio_abspath+0x1c>
mov    %rsi,%rdi
callq  7b <cdio_abspath+0x1a>
jmp    dd <cdio_abspath+0x7c>
mov    %rdi,%rbp
mov    $0xffffffffffffffff,%rdx
mov    $0x0,%eax
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rsi
not    %rsi
mov    %rbx,%rdi
mov    %rdx,%rcx
repnz scas %es:(%rdi),%al
mov    %rcx,%rdx
not    %rdx
lea    (%rsi,%rdx,1),%r13
mov    %r13,%rsi
mov    $0x1,%edi
callq  b6 <cdio_abspath+0x55>
mov    %rax,%r12
mov    %rbx,%r9
mov    $0x2f,%r8d
mov    %rbp,%rcx
mov    $0x0,%edx
mov    %r13,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  da <cdio_abspath+0x79>
mov    %r12,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cdio_abspath(const char *cwd, const char *fname)
{
    if (((*fname) == '/')) return strdup(fname);
    size_t len = strlen(cwd) + strlen(fname) + 2;
    char* result = calloc(sizeof(char), len);
    snprintf(result, len, "%s%c%s",
      cwd, '/', fname);
    return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 8
38 9
39 9
40 9
41 9
42 9
43 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%r13
mov    %esi,%ebp
mov    %esi,%edi
callq  0 <regex_vtab_lookup>
mov    %rax,%r12
test   %rax,%rax
je     71b <anubis_regex_compile+0x68>
mov    $0x50,%edi
callq  6db <anubis_regex_compile+0x28>
mov    %rax,%rbx
mov    %ebp,%edx
mov    %r13,%rsi
mov    %rax,%rdi
callq  *0x18(%r12)
test   %eax,%eax
je     708 <anubis_regex_compile+0x55>
mov    $0x0,%eax
test   %rbx,%rbx
je     720 <anubis_regex_compile+0x6d>
mov    %rbx,%rdi
callq  701 <anubis_regex_compile+0x4e>
mov    $0x0,%eax
jmp    720 <anubis_regex_compile+0x6d>
mov    %r13,%rdi
callq  710 <anubis_regex_compile+0x5d>
mov    %rax,(%rbx)
mov    %ebp,0x8(%rbx)
mov    %rbx,%rax
jmp    720 <anubis_regex_compile+0x6d>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
anubis_regex_compile (char *line, int opt)
{
  struct regex_vtab *vp = regex_vtab_lookup (opt);
  RC_REGEX *p;
  if (!vp)
    return 0;
  p = xmalloc (sizeof (*p));
  if (vp->compile (p, line, opt))
    {
      do if (p) { free(p); p = ((void *)0); } while (0);
    }
  else
    {
      p->src = strdup (line);
      p->flags = opt;
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 5
12 5
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 7
23 10
24 10
25 10
26 10
27 10
28 10
29 14
30 14
31 14
32 15
33 7
34 7
35 6
36 18
37 18
38 18
39 18
40 18
41 18
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
<<<sep_in_sample>>>
gsl_block_complex_float_size (const gsl_block_complex_float * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  117 <l_getuidbyname+0x9>
test   %rax,%rax
je     129 <l_getuidbyname+0x1b>
mov    0x10(%rax),%eax
mov    %rax,(%rbx)
mov    $0x0,%eax
jmp    12e <l_getuidbyname+0x20>
mov    $0xffffffff,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
l_getuidbyname(char *user, long *puid)
{
 struct passwd *pwent;
 pwent = getpwnam(user);
 if (!pwent) {
  return -1;
 }
 *puid = pwent->pw_uid;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 8
7 8
8 9
9 9
10 6
11 10
12 10
<<<sep_out_sample>>>
movzbl (%rdi),%eax
test   %al,%al
je     74e <Barcode_128_verify+0x35>
lea    0x3f(%rax),%edx
cmp    $0x3,%dl
jbe    72c <Barcode_128_verify+0x13>
cmp    $0x80,%al
ja     743 <Barcode_128_verify+0x2a>
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
je     743 <Barcode_128_verify+0x2a>
lea    0x3f(%rax),%edx
cmp    $0x3,%dl
jbe    72c <Barcode_128_verify+0x13>
cmp    $0x80,%al
jbe    72c <Barcode_128_verify+0x13>
test   %al,%al
setne  %al
movzbl %al,%eax
neg    %eax
retq   
mov    $0xffffffff,%eax
retq   
<<<sep_in_sample>>>
Barcode_128_verify(unsigned char *text)
{
    if (text[0] == '\0')
 return -1;
    while (*text && (*text<=0x80 || (*text >= 0xc1 && *text <= 0xc4)))
 text++;
    if (*text)
 return -1;
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 6
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
20 7
21 7
22 7
23 4
24 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  35 <_destroy_acl_entry+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_destroy_acl_entry (void *item)
{
  struct _mu_acl_entry *p = item;
  free (p);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
<<<sep_out_sample>>>
test   %rdx,%rdx
je     2bd <gsl_stats_ulong_skew_m_sd+0x78>
shl    $0x3,%rsi
mov    $0x0,%eax
fldz   
flds   0x0(%rip)        # 25b <gsl_stats_ulong_skew_m_sd+0x16>
mov    (%rdi),%rcx
test   %rcx,%rcx
js     26a <gsl_stats_ulong_skew_m_sd+0x25>
cvtsi2sd %rcx,%xmm2
jmp    27f <gsl_stats_ulong_skew_m_sd+0x3a>
mov    %rcx,%r8
shr    %r8
and    $0x1,%ecx
or     %rcx,%r8
cvtsi2sd %r8,%xmm2
addsd  %xmm2,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x20(%rsp)
fldl   -0x20(%rsp)
add    $0x1,%rax
fld    %st(0)
fmul   %st(1),%st
fmulp  %st,%st(1)
fsub   %st(2),%st
mov    %rax,-0x18(%rsp)
fildll -0x18(%rsp)
test   %rax,%rax
jns    2ad <gsl_stats_ulong_skew_m_sd+0x68>
fadd   %st(2),%st
fdivrp %st,%st(1)
faddp  %st,%st(2)
add    %rsi,%rdi
cmp    %rdx,%rax
jne    25b <gsl_stats_ulong_skew_m_sd+0x16>
fstp   %st(0)
jmp    2bf <gsl_stats_ulong_skew_m_sd+0x7a>
fldz   
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
<<<sep_in_sample>>>
gsl_stats_ulong_skew_m_sd (const unsigned long data[],
                               const size_t stride, const size_t n,
                               const double mean, const double sd)
{
  long double skew = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const long double x = (data[i * stride] - mean) / sd;
      skew += (x * x * x - skew) / (i + 1);
    }
  return skew;
}
<<<sep_in_sample>>>
1 7
2 7
3 9
4 7
5 5
6 10
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 7
36 7
37 7
38 7
39 5
40 12
41 12
42 13
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
sasl_enabled_p()
{
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %edi,%ebp
mov    $0x0,%edi
callq  6bc <copy_dv>
mov    %rax,%rbx
mov    %rax,%rsi
mov    %ebp,%edi
callq  596 <array_size>
mov    $0x0,%edx
test   %eax,%eax
je     9df <alloc_same+0x32>
mov    %eax,%edi
callq  663 <push_stack>
mov    %rax,%rdx
mov    %rdx,(%rbx)
mov    %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
alloc_same(int type, struct dv *dope)
{
      struct dv *dv;
      int size;
      dv = copy_dv(0, dope);
      size = array_size(type, dv);
      dv->base = size == 0 ? ((void *)0) : push_stack(size);
      return dv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 9
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    %rsi,0x8(%rdi)
ja     3762 <_jit_pointer_p+0x14>
cmp    (%rdi),%rsi
setl   %al
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
_jit_pointer_p(jit_state_t *_jit, jit_pointer_t address)
{
    return ((jit_uint8_t *)address >= _jit->code.ptr &&
     (jit_word_t)address < _jit->pc.w);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  518 <sh_badjob+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
callq  528 <sh_badjob+0x1e>
pop    %rbx
retq   
<<<sep_in_sample>>>
sh_badjob (s)
     char *s;
{
  builtin_error (gettext("%s: no such job"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
raw_comparator (const void *a, const void *b)
{
  return a == b;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 1be <yy_fatal_error+0x13>
mov    $0x0,%eax
callq  1c8 <yy_fatal_error+0x1d>
mov    $0x2,%edi
callq  1d2 <php_ensure_buffer_stack>
<<<sep_in_sample>>>
yy_fatal_error (const char* msg )
{
     (void) fprintf( stderr, "%s\n", msg );
 exit( 2 );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rax
mov    0x0(%rip),%edx        # d <area_handler+0xd>
lea    0x1(%rdx),%ecx
mov    %ecx,0x0(%rip)        # 16 <area_handler+0x16>
mov    %edx,%edx
mov    %rax,0x0(,%rdx,8)
mov    0x0(%rip),%edx        # 26 <area_handler+0x26>
cmp    $0x9,%edx
jbe    30 <area_handler+0x30>
callq  30 <area_handler+0x30>
cmp    %rdi,%rax
ja     41 <area_handler+0x41>
sub    %rax,%rdi
cmp    $0x3fff,%rdi
jbe    46 <area_handler+0x46>
callq  46 <area_handler+0x46>
mov    $0x3,%edx
mov    $0x4000,%esi
mov    %rax,%rdi
callq  58 <area_handler+0x58>
test   %eax,%eax
sete   %al
movzbl %al,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
area_handler (void *fault_address, void *user_arg)
{
  unsigned long area = *(unsigned long *)user_arg;
  logdata[logcount++] = area;
  if (logcount >= sizeof (logdata) / sizeof (logdata[0]))
    abort ();
  if (!((unsigned long)fault_address >= area
        && (unsigned long)fault_address - area < 0x4000))
    abort ();
  if (mprotect ((void *) area, 0x4000, (0x1|0x2)) == 0)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 6
12 7
13 7
14 8
15 7
16 7
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 13
26 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %esi,%r12d
movslq %esi,%rbp
add    0x8(%rdi),%rbp
test   %rdi,%rdi
je     b91 <PreventLexSplit+0x35>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     b80 <PreventLexSplit+0x24>
cmpb   $0x0,(%rax)
jne    b9a <PreventLexSplit+0x3e>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     b91 <PreventLexSplit+0x35>
callq  b8d <PreventLexSplit+0x31>
test   %eax,%eax
je     b9a <PreventLexSplit+0x3e>
cmp    $0x1000,%r12d
jne    bbd <PreventLexSplit+0x61>
mov    %rbp,%rsi
sub    $0x1,%rsi
cmpb   $0xa,(%rsi)
jne    b9d <PreventLexSplit+0x41>
movb   $0x0,(%rsi)
sub    %rbp,%rsi
je     bc1 <PreventLexSplit+0x65>
mov    $0x1,%edx
mov    (%rbx),%rdi
callq  bbb <PreventLexSplit+0x5f>
jmp    bc1 <PreventLexSplit+0x65>
movb   $0x0,0x0(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
PreventLexSplit (PINPUTBUF pibIn, int iOffset)
{
  long lDelta;
  PBUF pbufEOB = pibIn->pbufOrg + iOffset;
  PBUF pbufEOBOld;
  if (!((!(pibIn)) || ((!(pibIn)->pbufCur || !*(pibIn)->pbufCur) && (!(pibIn)->pfileIn || feof((pibIn)->pfileIn))))
      || (iOffset == 0x1000)) {
    pbufEOBOld = pbufEOB;
    while (*(--pbufEOB) != ('\n'))
      ;
    *pbufEOB = '\0';
    if ((lDelta = (long) (pbufEOB - pbufEOBOld)))
      fseek (pibIn->pfileIn, lDelta, 1);
  }
  else
    *pbufEOB = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 4
24 9
25 9
26 9
27 11
28 12
29 12
30 13
31 13
32 13
33 13
34 16
35 17
36 17
37 17
38 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%esi
callq  18b5 <mu_scheme_autodetect_p+0xe>
test   %eax,%eax
je     18c6 <mu_scheme_autodetect_p+0x1f>
mov    %rbx,%rdi
callq  18c1 <mu_scheme_autodetect_p+0x1a>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_scheme_autodetect_p (mu_url_t url)
{
  if (mu_url_is_scheme (url, "file"))
    {
      mu_url_expand_path (url);
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 6
10 9
11 9
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x10(%rsi),%rdx
mov    0x8(%rsi),%rdi
lea    (%rdi,%rdi,1),%rcx
mov    (%rsi),%rsi
mov    %rsi,(%rax)
mov    %rcx,0x8(%rax)
mov    %rdx,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_real (gsl_vector_complex_float * v)
{
  gsl_vector_float s = {0, 0, 0, 0, 0};
  s.data = v->data;
  s.size = v->size;
  s.stride = 2 * v->stride;
  s.block = 0;
  s.owner = 0;
  {
    _gsl_vector_float_view view = {{0, 0, 0, 0, 0}};
    view.vector = s;
    return view;
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 14
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    $0xffffffff,%r13d
cmpb   $0x0,(%rdi)
je     1771 <copylist+0xab>
mov    %rsi,%r12
mov    %rdx,%r14
mov    $0x0,%ebx
mov    $0xffffffffffffffff,%r15
mov    %r12,%rsi
callq  1700 <copylist+0x3a>
test   %eax,%eax
je     1716 <copylist+0x50>
movslq %ebx,%rax
movzbl 0x0(%rbp,%rax,1),%eax
cmp    $0x3b,%al
je     1763 <copylist+0x9d>
test   %al,%al
jne    1750 <copylist+0x8a>
jmp    1763 <copylist+0x9d>
mov    %r12,%rdi
mov    $0x0,%eax
mov    %r15,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    (%rbx,%rcx,1),%r13d
mov    %r14,%rsi
mov    $0x20,%edi
callq  1737 <copylist+0x71>
movslq %r13d,%rdi
add    %rbp,%rdi
mov    $0x3b,%edx
mov    %r14,%rsi
callq  174a <copylist+0x84>
lea    (%rax,%r13,1),%ebx
jmp    1763 <copylist+0x9d>
add    $0x1,%ebx
movslq %ebx,%rax
movzbl 0x0(%rbp,%rax,1),%eax
cmp    $0x3b,%al
je     1763 <copylist+0x9d>
test   %al,%al
jne    1750 <copylist+0x8a>
add    $0x2,%ebx
movslq %ebx,%rdi
add    %rbp,%rdi
cmpb   $0x0,(%rdi)
jne    16f8 <copylist+0x32>
mov    %r13d,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
copylist(char *step, char *key, FILE *dapfile)
{
  int s;
  int start;
  for (s = 0, start = -1; step[s]; s += 2)
    {
      if (!linecmp(step + s, key))
 {
   s += strlen(key) + 1;
   start = s;
   _IO_putc (' ', dapfile);
   s += putlines(step + s, dapfile, ';');
 }
      else
 {
   while (step[s] && step[s] != ';')
     s++;
 }
    }
  return start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 9
16 7
17 7
18 7
19 7
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 9
28 9
29 9
30 9
31 9
32 9
33 11
34 11
35 11
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 17
44 16
45 16
46 16
47 16
48 16
49 16
50 5
51 5
52 5
53 5
54 5
55 21
56 21
57 21
58 21
59 21
60 21
61 21
62 21
63 21
<<<sep_out_sample>>>
testb  $0x3,0x0(%rip)        # 1577 <update_ext_api+0x7>
setne  %al
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 1583 <update_ext_api+0x13>
retq   
<<<sep_in_sample>>>
update_ext_api()
{
 api_impl.do_flags[0] = ((do_flags & (DO_LINT_INVALID|DO_LINT_ALL)) ? 1 : 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xd8,%rsp
mov    %edi,%ebp
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
test   %al,%al
je     775 <lreply+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rsi,%rbx
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    %ebp,%esi
mov    $0x0,%edi
mov    $0x0,%eax
callq  7b0 <lreply+0x95>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  7bd <lreply+0xa2>
mov    $0x0,%edi
callq  7c7 <lreply+0xac>
mov    0x0(%rip),%rdi        # 7ce <lreply+0xb3>
callq  7d3 <lreply+0xb8>
cmpl   $0x0,0x0(%rip)        # 7da <lreply+0xbf>
je     82b <lreply+0x110>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x7,%edi
mov    $0x0,%eax
callq  7f2 <lreply+0xd7>
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0xf0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    $0x7,%edi
callq  82b <lreply+0x110>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
lreply (int n, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  printf ("%d- ", n);
  vprintf (fmt, ap);
  __builtin_va_end(ap);
  printf ("\r\n");
  fflush (stdout);
  if (debug)
    {
      syslog (7, "<--- %d- ", n);
      __builtin_va_start(ap,fmt);
      vsyslog (7, fmt, ap);
      __builtin_va_end(ap);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 4
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 6
31 6
32 6
33 8
34 8
35 9
36 9
37 10
38 10
39 12
40 12
41 12
42 12
43 12
44 13
45 13
46 13
47 13
48 13
49 13
50 14
51 14
52 14
53 14
54 17
55 17
56 17
57 17
<<<sep_out_sample>>>
movzbl 0x1(%rsi),%edx
mov    $0x0,%eax
cmp    %dl,0x1(%rdi)
jl     1d <__rrin+0x1d>
movsbq %dl,%rdx
mov    0x30(%rdi),%rax
cmp    (%rax,%rdx,8),%rsi
sete   %al
repz retq 
<<<sep_in_sample>>>
__rrin (__pty q, __pty p)
{
  if (
       q->plev <
       p->plev || q->pref[p->plev] != p)
    return (0);
  return (1);
}
<<<sep_in_sample>>>
1 5
2 6
3 3
4 3
5 5
6 5
7 5
8 5
9 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 280 <rpm_clearenv+0x7>
cmp    0x0(%rip),%rdi        # 287 <rpm_clearenv+0xe>
jne    2b7 <rpm_clearenv+0x3e>
test   %rdi,%rdi
je     2b7 <rpm_clearenv+0x3e>
sub    $0x8,%rsp
callq  297 <rpm_clearenv+0x1e>
movq   $0x0,0x0(%rip)        # 2a2 <rpm_clearenv+0x29>
movq   $0x0,0x0(%rip)        # 2ad <rpm_clearenv+0x34>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
movq   $0x0,0x0(%rip)        # 2c2 <rpm_clearenv+0x49>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
rpm_clearenv (void)
{
  ;
  if (environ == last_environ && environ != ((void *)0))
    {
      free (environ);
      last_environ = ((void *)0);
    }
  environ = ((void *)0);
  ;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 2
7 6
8 7
9 9
10 12
11 12
12 12
13 9
14 12
15 12
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  5d5 <gsl_sf_hyperg_0F1+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     5fb <gsl_sf_hyperg_0F1+0x32>
mov    %eax,%ecx
mov    $0xb1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5f4 <gsl_sf_hyperg_0F1+0x2b>
movsd  (%rsp),%xmm0
jmp    5fb <gsl_sf_hyperg_0F1+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_0F1(const double c, const double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_0F1_e(c, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_0F1_e(c, x, &result)", "hyperg_0F1.c", 177, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rax
movzbl %r8b,%r8d
callq  *(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_list_create_empty (gl_list_implementation_t implementation,
        gl_listelement_equals_fn equals_fn,
        gl_listelement_hashcode_fn hashcode_fn,
        gl_listelement_dispose_fn dispose_fn,
        _Bool allow_duplicates)
{
  return implementation->create_empty (implementation, equals_fn, hashcode_fn,
           dispose_fn, allow_duplicates);
}
<<<sep_in_sample>>>
1 6
2 6
3 7
4 7
5 9
6 9
<<<sep_out_sample>>>
cmp    $0x2,%esi
jg     1452 <day_of_year+0x15>
sub    $0x1,%esi
movslq %esi,%rsi
mov    %edi,%eax
add    0x0(,%rsi,4),%eax
retq   
push   %rbx
sub    $0x1,%esi
movslq %esi,%rsi
mov    %edi,%ebx
add    0x0(,%rsi,4),%ebx
mov    %edx,%edi
callq  1469 <day_of_year+0x2c>
cmp    $0x1d,%eax
sete   %al
movzbl %al,%eax
add    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
day_of_year (day, month, year)
     const int day;
     const int month;
     const int year;
{
  register int i;
  if (month < 3)
    i = mvec[month - 1] + day;
  else
    i = mvec[month - 1] + day + (days_of_february (year) == 29);
  return (i);
}
<<<sep_in_sample>>>
1 7
2 7
3 8
4 8
5 8
6 8
7 12
8 5
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 12
20 12
<<<sep_out_sample>>>
test   %edi,%edi
jne    d83 <swlib_assertion_fatal+0x1b>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %rdx,%rsi
mov    %ecx,%edx
mov    %r8,%rcx
mov    %rax,%rdi
callq  d83 <swlib_assertion_fatal+0x1b>
repz retq 
<<<sep_in_sample>>>
swlib_assertion_fatal(int assertion_result, char * reason, char * file,
   int line, char * function)
{
 if (assertion_result == 0)
  swlib_fatal(reason, file, line, function);
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
movsd  %xmm0,(%rsp)
movsd  %xmm1,0x8(%rsp)
cmpw   $0x1,0x14(%rdi)
jne    25 <__rhisto+0x25>
cmpw   $0x1,0x14(%rsi)
je     2f <__rhisto+0x2f>
mov    $0x0,%edi
callq  2f <__rhisto+0x2f>
mov    0x1c(%rbx),%eax
add    $0x1,%eax
cmp    %eax,0x1c(%rbp)
je     44 <__rhisto+0x44>
mov    $0x0,%edi
callq  44 <__rhisto+0x44>
movslq 0x1c(%rbx),%rdx
test   %rdx,%rdx
jle    78 <__rhisto+0x78>
movsd  0x20(%rbx),%xmm0
ucomisd (%rsp),%xmm0
jae    7f <__rhisto+0x7f>
mov    $0x0,%eax
jmp    6d <__rhisto+0x6d>
movsd  0x20(%rbx,%rax,8),%xmm0
ucomisd (%rsp),%xmm0
jae    84 <__rhisto+0x84>
add    $0x1,%rax
cmp    %rdx,%rax
jl     60 <__rhisto+0x60>
jmp    84 <__rhisto+0x84>
mov    $0x0,%eax
jmp    84 <__rhisto+0x84>
mov    $0x0,%eax
lea    0x20(%rbp,%rax,8),%rax
movsd  0x8(%rsp),%xmm0
addsd  (%rax),%xmm0
movsd  %xmm0,(%rax)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__rhisto (__arrp A, __arrp B, double c, double d)
{
  long j;
  if (A->h.dim != 1 || B->h.dim != 1)
    __rerror ("Histo: Multi dimensional array");
  if (A->limits[0].size != B->limits[0].size + 1)
    __rerror ("Histo: Illegal size of arrays");
  for (j = 0; j < B->limits[0].size; j++)
    if (c <= (*(double *)(((char *)B)+sizeof(__ah)+ sizeof(__arrlimit)+sizeof(double)*(j))))
      break;
  (*(double *)(((char *)A)+sizeof(__ah)+ sizeof(__arrlimit)+sizeof(double)*(j))) += d;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 8
21 8
22 8
23 9
24 9
25 9
26 8
27 8
28 9
29 9
30 9
31 8
32 8
33 8
34 8
35 8
36 8
37 8
38 11
39 11
40 11
41 11
42 12
43 12
44 12
45 12
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c4be <re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # c4c5 <re_set_syntax+0xe>
retq   
<<<sep_in_sample>>>
re_set_syntax (reg_syntax_t syntax)
{
  reg_syntax_t ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movswq 0x4(%rdi),%rdi
callq  e <__rb+0xe>
movb   $0x0,0x18(%rax)
mov    %rbx,(%rax)
mov    0x0(%rip),%rdx        # 1c <__rb+0x1c>
mov    %rdx,0x10(%rax)
mov    %rdx,0x30(%rax)
mov    %rax,0x0(%rip)        # 2b <__rb+0x2b>
mov    %rax,0x0(%rip)        # 32 <__rb+0x32>
pop    %rbx
retq   
<<<sep_in_sample>>>
__rb (__pty ppx)
{
  __dhp x;
  x = __ralloc ((long) ppx->size);
  x->pm = 0;
  x->pp = ppx;
  x->sl = x->dl = __lb;
  __lb = __pb = x;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 7
8 7
9 7
10 8
11 8
12 9
13 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbx
mov    $0x63,%edx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1b <get_struct_by_message+0x1b>
movb   $0x0,0x0(%rip)        # 22 <get_struct_by_message+0x22>
mov    $0x0,%esi
mov    $0x0,%edi
callq  31 <get_struct_by_message+0x31>
mov    %rax,%rbp
test   %rax,%rax
je     6f <get_struct_by_message+0x6f>
mov    $0x0,%esi
mov    %rax,%rdi
callq  46 <get_struct_by_message+0x46>
test   %rax,%rax
je     76 <get_struct_by_message+0x76>
movb   $0x0,(%rax)
cmpl   $0xffffffff,0x8(%rbx)
je     7d <get_struct_by_message+0x7d>
mov    %rbp,%rsi
mov    (%rbx),%rdi
callq  5f <get_struct_by_message+0x5f>
test   %eax,%eax
je     84 <get_struct_by_message+0x84>
add    $0x20,%rbx
cmpl   $0xffffffff,0x8(%rbx)
jne    54 <get_struct_by_message+0x54>
jmp    89 <get_struct_by_message+0x89>
mov    $0x0,%eax
jmp    8e <get_struct_by_message+0x8e>
mov    $0x0,%eax
jmp    8e <get_struct_by_message+0x8e>
mov    $0x0,%eax
jmp    8e <get_struct_by_message+0x8e>
mov    %rbx,%rax
jmp    8e <get_struct_by_message+0x8e>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
get_struct_by_message(char * line, struct swEvents * evnt)
{
 char * ws;
 char * event_code;
 static char buf[100];
 struct swEvents * eop;
 strncpy(buf, line, sizeof(buf)-1);
 buf[sizeof(buf)-1] = '\0';
 event_code=strstr(buf, "SW");
 if (event_code == ((void *)0)) return ((void *)0);
 if ((ws=strpbrk(event_code, ": \r\n")) == ((void *)0))
  return ((void *)0);
 else
  *ws = '\0';
 eop = evnt;
 while (eop->valueM != -1) {
  if (strcmp(eop->codeM, event_code) == 0) {
   return eop;
  }
  eop++;
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 7
9 8
10 9
11 9
12 9
13 9
14 10
15 10
16 11
17 11
18 11
19 11
20 11
21 14
22 16
23 16
24 17
25 17
26 17
27 17
28 17
29 20
30 16
31 16
32 16
33 10
34 10
35 12
36 12
37 22
38 22
39 22
40 22
41 22
42 23
43 23
44 23
45 23
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rcx,0x38(%rsp)
mov    $0x0,%ecx
test   $0x40,%dl
je     33 <openat_safer+0x33>
movl   $0x18,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%ecx
mov    $0x0,%eax
callq  3d <openat_safer+0x3d>
mov    %eax,%edi
callq  44 <openat_safer+0x44>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
openat_safer (int fd, char const *file, int flags, ...)
{
  mode_t mode = 0;
  if (flags & 0100)
    {
      va_list ap;
      __builtin_va_start(ap,flags);
      mode = __builtin_va_arg(ap,mode_t);
      __builtin_va_end(ap);
    }
  return fd_safer (openat (fd, file, flags, mode));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 8
12 11
13 11
14 11
15 11
16 12
17 12
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <is_regular_file+0xf>
test   %eax,%eax
jne    29 <is_regular_file+0x29>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x8000,%eax
sete   %al
movzbl %al,%eax
jmp    37 <is_regular_file+0x37>
callq  2e <is_regular_file+0x2e>
cmpl   $0x2,(%rax)
sete   %al
movzbl %al,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
is_regular_file (const char *name)
{
  struct stat stbuf;
  if (stat (name, &stbuf) == 0)
    return ((((stbuf.st_mode)) & 0170000) == (0100000));
  else
    return (*__errno_location ()) == 2;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
callq  12 <pipe_safer+0x12>
mov    %eax,%ebp
test   %eax,%eax
jne    6a <pipe_safer+0x6a>
mov    (%rbx),%edi
callq  1f <pipe_safer+0x1f>
mov    %eax,(%rbx)
test   %eax,%eax
js     3c <pipe_safer+0x3c>
mov    0x4(%rbx),%edi
callq  2d <pipe_safer+0x2d>
mov    %eax,0x4(%rbx)
mov    $0x1,%r12d
test   %eax,%eax
js     42 <pipe_safer+0x42>
jmp    6f <pipe_safer+0x6f>
mov    $0x0,%r12d
callq  47 <pipe_safer+0x47>
mov    %rax,%rbp
mov    (%rax),%r13d
mov    $0x1,%eax
sub    %r12d,%eax
cltq   
mov    (%rbx,%rax,4),%edi
callq  5f <pipe_safer+0x5f>
mov    %r13d,0x0(%rbp)
mov    $0xffffffff,%ebp
jmp    6f <pipe_safer+0x6f>
mov    $0xffffffff,%ebp
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
pipe_safer (int fd[2])
{
  if (pipe (fd) == 0)
    {
      int i;
      for (i = 0; i < 2; i++)
        {
          fd[i] = fd_safer (fd[i]);
          if (fd[i] < 0)
            {
              int e = (*__errno_location ());
              close (fd[1 - i]);
              (*__errno_location ()) = e;
              return -1;
            }
        }
      return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 9
15 9
16 8
17 8
18 8
19 6
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 12
28 12
29 12
30 12
31 12
32 13
33 14
34 14
35 19
36 20
37 20
38 20
39 20
40 20
41 20
42 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
testb  $0x2,0x2d1(%rdi)
jne    e5 <update_aim9m+0xa5>
mov    (%rdi),%eax
movslq %eax,%rdx
cmpl   $0x0,0x0(,%rdx,4)
je     e5 <update_aim9m+0xa5>
cmpl   $0x0,0x0(,%rdx,4)
jle    e5 <update_aim9m+0xa5>
mov    $0x0,%esi
callq  78 <update_aim9m+0x38>
test   %eax,%eax
jns    99 <update_aim9m+0x59>
mov    0x0(%rip),%rcx        # 83 <update_aim9m+0x43>
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  97 <update_aim9m+0x57>
jmp    d7 <update_aim9m+0x97>
cmpl   $0x0,0x0(%rip)        # a0 <update_aim9m+0x60>
jne    c0 <update_aim9m+0x80>
movslq %eax,%rdx
shl    $0x5,%rdx
movq   $0x0,0x870(%rbx,%rdx,1)
movslq (%rbx),%rdx
subl   $0x1,0x0(,%rdx,4)
mov    %eax,%esi
mov    %rbx,%rdi
callq  ca <update_aim9m+0x8a>
mov    $0x4,%esi
mov    %rbx,%rdi
callq  d7 <update_aim9m+0x97>
movslq (%rbx),%rax
movl   $0x0,0x0(,%rax,4)
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
update_aim9m(craft * c)
{
 register int i;
 if ((c->flags & (1<<9)) == 0) {
  if (hasFired[c->pIndex] && count[c->pIndex] > 0) {
   i = readyStation(c, "aim9m");
   if (i < 0)
    fprintf(stderr, "Oops. Can't find an AIM-9\n");
   else {
    if (arcadeMode == 0) {
     c->station[i].type = "";
     count[c->pIndex]--;
    }
    fireMissile(c, i);
    playSound(c, 4);
   }
   hasFired[c->pIndex] = 0;
  }
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 6
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 10
23 11
24 11
25 11
26 12
27 12
28 14
29 14
30 14
31 15
32 15
33 15
34 17
35 17
36 21
37 21
38 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
jne    d43 <test_malloc+0x2f>
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # d2f <test_malloc+0x1b>
mov    $0x0,%eax
callq  d39 <test_malloc+0x25>
mov    $0x1,%edi
callq  d43 <test_malloc+0x2f>
callq  d48 <test_malloc+0x34>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
test_malloc(size_t count, const char *file, size_t line)
{
 if (count == 0) {
  fprintf(stderr, "%s:%lu: allocation of zero bytes\n",
    file, (unsigned long) line);
  exit(1);
 }
 return malloc(count);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 8
13 9
14 9
<<<sep_out_sample>>>
mov    $0x0,%eax
test   %edx,%edx
jg     10 <cblas_scopy+0x10>
mov    $0x1,%al
sub    %edi,%eax
imul   %edx,%eax
mov    $0x0,%r9d
test   %r8d,%r8d
jg     25 <cblas_scopy+0x25>
mov    $0x1,%r9b
sub    %edi,%r9d
imul   %r8d,%r9d
test   %edi,%edi
jle    4f <cblas_scopy+0x4f>
mov    $0x0,%r10d
movslq %eax,%r11
movss  (%rsi,%r11,4),%xmm0
movslq %r9d,%r11
movss  %xmm0,(%rcx,%r11,4)
add    %edx,%eax
add    %r8d,%r9d
add    $0x1,%r10d
cmp    %edi,%r10d
jne    2f <cblas_scopy+0x2f>
repz retq 
<<<sep_in_sample>>>
cblas_scopy (const int N, const float *X, const int incX, float *Y,
             const int incY)
{
{
  int i;
  int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
  int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
  for (i = 0; i < N; i++) {
    Y[iy] = X[ix];
    ix += incX;
    iy += incY;
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 10
21 11
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    $0xff,%esi
callq  0 <emit_byte>
mov    %ebp,%esi
mov    %rbx,%rdi
callq  0 <emit_byte>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
{
  emit_byte(cinfo, 0xFF);
  emit_byte(cinfo, (int) mark);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  a08 <wordsplit_free+0x9>
mov    0x8(%rbx),%rdi
callq  a11 <wordsplit_free+0x12>
movq   $0x0,0x8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
wordsplit_free (struct wordsplit *ws)
{
  wordsplit_free_words (ws);
  free (ws->ws_wordv);
  ws->ws_wordv = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x18(%rdi),%rdi
callq  648 <osip_nict_unlock+0xd>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
osip_nict_unlock (osip_t * osip)
{
  return osip_mutex_unlock (osip->nict_fastmutex);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  b95 <slc_import+0xd>
cmp    $0x9,%eax
jle    bf2 <slc_import+0x6a>
test   %ebx,%ebx
je     bc8 <slc_import+0x40>
mov    $0x9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bb2 <slc_import+0x2a>
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
callq  bc6 <slc_import+0x3e>
jmp    bfc <slc_import+0x74>
mov    $0x9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bdc <slc_import+0x54>
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
callq  bf0 <slc_import+0x68>
jmp    bfc <slc_import+0x74>
mov    $0x0,%edi
callq  bfc <slc_import+0x74>
pop    %rbx
retq   
<<<sep_in_sample>>>
slc_import (int def)
{
  if ((ring_empty_count(&netoring)) > (int) sizeof (slc_import_val))
    {
      if (def)
 {
   ring_supply_data (&netoring, slc_import_def,
       sizeof (slc_import_def));
   printsub ('>', &slc_import_def[2], sizeof (slc_import_def) - 2);
 }
      else
 {
   ring_supply_data (&netoring, slc_import_val,
       sizeof (slc_import_val));
   printsub ('>', &slc_import_val[2], sizeof (slc_import_val) - 2);
 }
    }
  else
    printf ("slc_import: not enough room\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 7
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 13
19 13
20 13
21 13
22 15
23 15
24 15
25 15
26 15
27 19
28 19
29 20
30 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
cmpb   $0x0,(%rsi)
je     27d <strbuf_puts_nl+0x44>
mov    0x10(%rbx),%rax
cmp    %rax,0x18(%rbx)
jb     261 <strbuf_puts_nl+0x28>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  261 <strbuf_puts_nl+0x28>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
add    $0x1,%rbp
movzbl -0x1(%rbp),%edx
mov    %dl,(%rax)
cmpb   $0x0,0x0(%rbp)
jne    24a <strbuf_puts_nl+0x11>
mov    0x10(%rbx),%rax
cmp    %rax,0x18(%rbx)
jb     294 <strbuf_puts_nl+0x5b>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  294 <strbuf_puts_nl+0x5b>
mov    0x18(%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,0x18(%rbx)
movb   $0xa,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
strbuf_puts_nl(STRBUF *sb, const char *s)
{
 while (*s) {
  if (sb->curp >= sb->endp)
   __strbuf_expandbuf(sb, 0);
  *sb->curp++ = *s++;
 }
 if (sb->curp >= sb->endp)
  __strbuf_expandbuf(sb, 0);
 *sb->curp++ = '\n';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 3
21 3
22 8
23 8
24 8
25 9
26 9
27 9
28 10
29 10
30 10
31 10
32 11
33 11
34 11
35 11
<<<sep_out_sample>>>
movzbl 0x0(%rip),%eax        # f93 <history_has_changed+0x7>
retq   
<<<sep_in_sample>>>
history_has_changed(void)
{
    return history_changed;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x38(%rdi),%rax
mov    0x10(%rax),%rax
mov    0x40(%rdi),%rsi
callq  *0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
lm_preloop(const void * vtrust_state, void * vstate)
{
  int status;
  const gsl_multifit_nlinear_trust_state *trust_state =
    (const gsl_multifit_nlinear_trust_state *) vtrust_state;
  const gsl_multifit_nlinear_parameters *params = trust_state->params;
  (void)vstate;
  status = (params->solver->init)(trust_state, trust_state->solver_state);
  if (status)
    return status;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 8
3 8
4 8
5 8
6 12
7 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  3b2 <dicod_init_strategies+0xe>
mov    $0x0,%edi
callq  3bc <dicod_init_strategies+0x18>
mov    $0x0,%edi
callq  3c6 <dicod_init_strategies+0x22>
mov    $0x0,%edi
callq  3d0 <dicod_init_strategies+0x2c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dicod_init_strategies()
{
    static struct dico_strategy defstrat[] = {
 { "exact", "Match words exactly", exact_sel },
 { "prefix", "Match word prefixes", prefix_sel },
 { "suffix", "Match word suffixes", suffix_sel },
 { "soundex", "Match using SOUNDEX algorithm", soundex_sel, ((void *)0) },
    };
    int i;
    for (i = 0; i < (sizeof(defstrat)/sizeof((defstrat)[0])); i++)
 dico_strategy_add(defstrat + i);
}
<<<sep_in_sample>>>
1 2
2 11
3 11
4 11
5 11
6 11
7 11
8 11
9 11
10 12
11 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  24 <_cmp_capa_name+0xc>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_cmp_capa_name(const void *item, void *data)
{
    const struct dicod_capa *cp = item;
    return strcmp(cp->name, (char*)data);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0xc(%rdi),%esi
test   %esi,%esi
jle    7d <vplob_get_nstore+0x26>
mov    (%rdi),%rcx
mov    $0x0,%edx
mov    $0x0,%eax
cmpq   $0x1,(%rcx,%rdx,8)
sbb    $0xffffffff,%eax
add    $0x1,%rdx
cmp    %edx,%esi
jg     6b <vplob_get_nstore+0x14>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
vplob_get_nstore(VPLOB * vplob)
{
 CPLOB * cplob = (CPLOB*)vplob;
 int i;
 int ret = 0;
 for (i = 0; i < cplob->nused; i++) {
  if (*(cplob->list + (i)) != (char*)((void *)0)) {
   ret++;
  }
 }
 return ret;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 5
7 8
8 8
9 8
10 6
11 6
12 6
13 5
14 12
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     1aca <gsl_vector_uint_sub+0x29>
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ac3 <gsl_vector_uint_sub+0x22>
mov    $0x13,%eax
jmp    1b1d <gsl_vector_uint_sub+0x7c>
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
test   %r10,%r10
je     1b11 <gsl_vector_uint_sub+0x70>
shl    $0x2,%rbx
shl    $0x2,%r11
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%eax
mov    %rdx,%r8
add    0x10(%rdi),%r8
mov    0x10(%rsi),%r9
mov    (%r9,%rcx,1),%r9d
sub    %r9d,(%r8)
add    $0x1,%rax
add    %rbx,%rdx
add    %r11,%rcx
cmp    %r10,%rax
jne    1aee <gsl_vector_uint_sub+0x4d>
jmp    1b18 <gsl_vector_uint_sub+0x77>
mov    $0x0,%eax
jmp    1b1d <gsl_vector_uint_sub+0x7c>
mov    $0x0,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_vector_uint_sub (gsl_vector_uint * a, const gsl_vector_uint * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 10
13 11
14 13
15 13
16 15
17 15
18 15
19 15
20 13
21 15
22 15
23 15
24 15
25 15
26 13
27 13
28 13
29 13
30 13
31 13
32 17
33 17
34 17
35 19
36 19
<<<sep_out_sample>>>
cmpl   $0x0,0x0(%rip)        # 6e1 <gsl_vector_complex_float_ptr+0x7>
je     70c <gsl_vector_complex_float_ptr+0x32>
cmp    %rsi,(%rdi)
ja     70c <gsl_vector_complex_float_ptr+0x32>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xe2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  705 <gsl_vector_complex_float_ptr+0x2b>
mov    $0x0,%eax
jmp    720 <gsl_vector_complex_float_ptr+0x46>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rax,%rsi
mov    %rsi,%rax
add    0x10(%rdi),%rax
retq   
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_complex_float_ptr (gsl_vector_complex_float * v,
                              const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_float.h", 226, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return ((gsl_complex_float*)&((v)->data[2*(i)*(v)->stride]));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 3
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     af5 <gsl_matrix_long_double_ispos+0x53>
shl    $0x4,%rax
mov    %rax,%r10
mov    $0x0,%esi
mov    $0x0,%r9d
jmp    aee <gsl_matrix_long_double_ispos+0x4c>
mov    %rsi,%rax
add    0x18(%rdi),%rax
mov    $0x0,%edx
fldz   
fldt   (%rax)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jb     b07 <gsl_matrix_long_double_ispos+0x65>
fstp   %st(0)
jmp    afb <gsl_matrix_long_double_ispos+0x59>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
je     b01 <gsl_matrix_long_double_ispos+0x5f>
test   %rcx,%rcx
jne    ac6 <gsl_matrix_long_double_ispos+0x24>
jmp    ae2 <gsl_matrix_long_double_ispos+0x40>
mov    $0x1,%eax
retq   
mov    $0x0,%eax
retq   
mov    $0x1,%eax
retq   
add    $0x1,%rdx
add    $0x10,%rax
cmp    %rcx,%rdx
jne    ad4 <gsl_matrix_long_double_ispos+0x32>
fstp   %st(0)
jmp    ae2 <gsl_matrix_long_double_ispos+0x40>
<<<sep_in_sample>>>
gsl_matrix_long_double_ispos (const gsl_matrix_long_double * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 20
30 20
31 15
32 15
33 20
34 20
35 9
36 9
37 9
38 9
39 9
40 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
jb     83 <gsl_cdf_poisson_Q+0x31>
mov    $0x1,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  79 <gsl_cdf_poisson_Q+0x27>
movsd  0x0(%rip),%xmm0        # 81 <gsl_cdf_poisson_Q+0x2f>
jmp    9f <gsl_cdf_poisson_Q+0x4d>
mov    %edi,%edi
cvtsi2sd %rdi,%xmm3
movsd  0x0(%rip),%xmm1        # 92 <gsl_cdf_poisson_Q+0x40>
movapd %xmm1,%xmm2
addsd  %xmm3,%xmm1
callq  9f <gsl_cdf_poisson_Q+0x4d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_poisson_Q (const unsigned int k, const double mu)
{
  double Q;
  double a;
  if (mu <= 0.0)
    {
      do { gsl_error ("mu <= 0", "poisson.c", 77, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) k + 1.0;
  Q = gsl_cdf_gamma_P (mu, a, 1.0);
  return Q;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 10
17 10
18 12
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 8c7 <_mu_line_finish+0x10>
callq  8cc <_mu_line_finish+0x15>
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 8d8 <_mu_line_finish+0x21>
callq  8dd <_mu_line_finish+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_mu_line_finish ()
{
  mu_opool_append_char (pool, 0);
  return mu_opool_finish (pool, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  486 <NextToken+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
NextToken(struct lex_record * p)
{
 field_id t;
 t = NextTokenx(p);
 return t;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
<<<sep_out_sample>>>
mov    $0x0,%eax
cmp    $0x18,%rdx
jne    2f06 <gl_3des_makekey+0x5e>
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
lea    0x10(%rsi),%r12
lea    0x8(%rsi),%rbp
mov    %r12,%rcx
mov    %rbp,%rdx
callq  2ecd <gl_3des_makekey+0x25>
mov    %rbx,%rdi
callq  2ed5 <gl_3des_makekey+0x2d>
mov    $0x0,%esi
test   %al,%al
jne    2efd <gl_3des_makekey+0x55>
mov    %rbp,%rdi
callq  2ee6 <gl_3des_makekey+0x3e>
mov    $0x0,%esi
test   %al,%al
jne    2efd <gl_3des_makekey+0x55>
mov    %r12,%rdi
callq  2ef7 <gl_3des_makekey+0x4f>
xor    $0x1,%eax
movzbl %al,%esi
mov    %esi,%eax
and    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
<<<sep_in_sample>>>
gl_3des_makekey (gl_3des_ctx *ctx, const char * key, size_t keylen)
{
  if (keylen != 24)
    return 0;
  gl_3des_set3keys (ctx, key, key + 8, key + 16);
  return !(gl_des_is_weak_key (key)
           || gl_des_is_weak_key (key + 8)
           || gl_des_is_weak_key (key + 16));
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 6
21 7
22 7
23 8
24 8
25 6
26 6
27 6
28 6
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  1e4d <gsl_sf_ellint_RC+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     1e73 <gsl_sf_ellint_RC+0x32>
mov    %eax,%ecx
mov    $0x27b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1e6c <gsl_sf_ellint_RC+0x2b>
movsd  (%rsp),%xmm0
jmp    1e73 <gsl_sf_ellint_RC+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_RC(double x, double y, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_RC_e(x, y, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_RC_e(x, y, mode, &result)", "ellint.c", 635, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
comment_handler (self, defs, arg)
     char *self;
     DEF_FILE *defs;
     char *arg;
{
  return (0);
}
<<<sep_in_sample>>>
1 7
2 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 3f7 <nlscan+0xe>
cmp    %rbx,%rdi
jae    42b <nlscan+0x42>
movzbl 0x0(%rip),%r12d        # 404 <nlscan+0x1b>
mov    $0x0,%ebp
mov    %rbx,%rdx
sub    %rdi,%rdx
mov    %r12d,%esi
callq  417 <nlscan+0x2e>
test   %rax,%rax
je     430 <nlscan+0x47>
add    $0x1,%rbp
lea    0x1(%rax),%rdi
cmp    %rdi,%rbx
ja     409 <nlscan+0x20>
jmp    430 <nlscan+0x47>
mov    $0x0,%ebp
mov    %rbp,%rsi
mov    0x0(%rip),%rdi        # 43a <nlscan+0x51>
callq  245 <add_count>
mov    %rax,0x0(%rip)        # 446 <nlscan+0x5d>
mov    %rbx,0x0(%rip)        # 44d <nlscan+0x64>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
nlscan (char const *lim)
{
  size_t newlines = 0;
  char const *beg;
  for (beg = lastnl; beg < lim; beg++)
    {
      beg = memchr (beg, eolbyte, lim - beg);
      if (!beg)
        break;
      newlines++;
    }
  totalnl = add_count (totalnl, newlines);
  lastnl = lim;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 3
10 7
11 7
12 7
13 7
14 8
15 8
16 10
17 5
18 5
19 5
20 5
21 3
22 12
23 12
24 12
25 12
26 13
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
lea    0x8(%rdi),%rdx
cmpq   $0x0,(%rdi)
je     302 <vector_cardinality+0x1f>
mov    $0x0,%eax
add    $0x1,%eax
add    $0x8,%rdx
cmpq   $0x0,-0x8(%rdx)
jne    2f2 <vector_cardinality+0xf>
repz retq 
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
vector_cardinality (void *vector)
{
  void **v = (void **) vector;
  int count = 0;
  while (*v++)
    count++;
  return count;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 4
5 6
6 5
7 5
8 5
9 5
10 4
11 8
<<<sep_out_sample>>>
movl   $0x0,(%rdi)
movl   $0x3f800000,0x4(%rdi)
movl   $0x3f4ccccd,0x8(%rdi)
movl   $0x3fb4fdf4,0xc(%rdi)
movb   $0x0,0x10(%rdi)
retq   
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edx
callq  159b <swverid_add_verid_if+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swverid_add_verid_if(SWVERID * swverid, struct VER_ID * verid)
{
 i_replace_verid(swverid, verid, 0 );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rbp
mov    %rdx,%r12
mov    %rcx,%r13
mov    %r8,%r14
callq  201 <gsl_stats_float_wabsdev+0x1c>
mov    %r14,%r8
mov    %r13,%rcx
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  215 <gsl_stats_float_wabsdev+0x30>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
gsl_stats_float_wabsdev (const float w[], const size_t wstride, const float data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_float_wmean(w, wstride, data, stride, n);
  return gsl_stats_float_wabsdev_m(w, wstride, data, stride, n, wmean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 5
20 5
21 5
22 5
23 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
get_dbpath(void)
{
 return (const char *)dbpath;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 292 <check_next+0x7>
mov    0x0(%rip),%rdx        # 299 <check_next+0xe>
cmp    %rdx,%rcx
jle    2de <check_next+0x53>
mov    %rdx,0x0(%rip)        # 2a5 <check_next+0x1a>
mov    0x0(%rip),%eax        # 2ab <check_next+0x20>
mov    %eax,0x0(%rip)        # 2b1 <check_next+0x26>
mov    0x0(%rip),%rax        # 2b8 <check_next+0x2d>
mov    %rax,0x0(%rip)        # 2bf <check_next+0x34>
movb   $0x1,0x0(%rip)        # 2c6 <check_next+0x3b>
mov    0x0(%rip),%eax        # 2cc <check_next+0x41>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 2d5 <check_next+0x4a>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
cmp    %rdx,%rcx
jne    354 <check_next+0xc9>
mov    0x0(%rip),%rax        # 2ef <check_next+0x64>
cmp    %rax,0x0(%rip)        # 2f6 <check_next+0x6b>
je     323 <check_next+0x98>
mov    %rax,0x0(%rip)        # 2ff <check_next+0x74>
mov    0x0(%rip),%eax        # 305 <check_next+0x7a>
mov    %eax,0x0(%rip)        # 30b <check_next+0x80>
mov    0x0(%rip),%eax        # 311 <check_next+0x86>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 31a <check_next+0x8f>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    0x0(%rip),%eax        # 329 <check_next+0x9e>
cmp    %eax,0x0(%rip)        # 32f <check_next+0xa4>
je     34f <check_next+0xc4>
mov    %eax,0x0(%rip)        # 337 <check_next+0xac>
mov    0x0(%rip),%eax        # 33d <check_next+0xb2>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 346 <check_next+0xbb>
test   %eax,%eax
sete   %al
movzbl %al,%eax
retq   
mov    $0x0,%eax
repz retq 
<<<sep_in_sample>>>
check_next(INSTRUCTION **pi)
{
 if (fcall_count < stop.fcall_count) {
  stop.fcall_count = fcall_count;
  stop.sourceline = sourceline;
  stop.source = source;
  stop.print_frame = 1;
  return (--stop.repeat_count == 0);
 }
 if (fcall_count == stop.fcall_count) {
  if (source != stop.source) {
   stop.source = source;
   stop.sourceline = sourceline;
   return (--stop.repeat_count == 0);
  }
  if (sourceline != stop.sourceline) {
   stop.sourceline = sourceline;
   return (--stop.repeat_count == 0);
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 5
8 6
9 6
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 21
19 10
20 10
21 11
22 11
23 11
24 12
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 16
35 16
36 16
37 17
38 18
39 18
40 18
41 18
42 18
43 18
44 18
45 21
46 22
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     612 <parseopts+0x130>
mov    %rsi,%rbp
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rdx
movslq 0x0(%rip),%rax        # 511 <parseopts+0x2f>
cmp    %rax,%rdx
jbe    570 <parseopts+0x8e>
mov    0x0(%rip),%rdi        # 51d <parseopts+0x3b>
test   %rdi,%rdi
je     527 <parseopts+0x45>
callq  527 <parseopts+0x45>
mov    %r12,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rcx),%rax
mov    %eax,0x0(%rip)        # 545 <parseopts+0x63>
add    $0x1,%eax
movslq %eax,%rdi
callq  550 <parseopts+0x6e>
mov    %rax,0x0(%rip)        # 557 <parseopts+0x75>
test   %rax,%rax
jne    570 <parseopts+0x8e>
mov    $0x0,%edi
callq  566 <parseopts+0x84>
mov    $0x1,%edi
callq  570 <parseopts+0x8e>
mov    0x0(%rip),%rbx        # 577 <parseopts+0x95>
mov    %r12,%rsi
mov    %rbx,%rdi
callq  582 <parseopts+0xa0>
cmpb   $0x20,(%rbx)
jne    59a <parseopts+0xb8>
mov    $0x0,%edx
add    $0x1,%edx
movslq %edx,%rax
cmpb   $0x20,(%rbx,%rax,1)
je     58c <parseopts+0xaa>
jmp    59f <parseopts+0xbd>
mov    $0x0,%edx
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
je     619 <parseopts+0x137>
mov    $0x0,%eax
test   %rbp,%rbp
je     5bc <parseopts+0xda>
movslq %eax,%rsi
mov    %rcx,0x0(%rbp,%rsi,8)
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
je     5dd <parseopts+0xfb>
add    $0x1,%edx
movslq %edx,%r8
add    %rbx,%r8
movzbl (%r8),%ecx
test   $0xdf,%cl
jne    5cb <parseopts+0xe9>
test   %cl,%cl
je     602 <parseopts+0x120>
test   %rbp,%rbp
je     5ea <parseopts+0x108>
movb   $0x0,(%r8)
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
jne    602 <parseopts+0x120>
add    $0x1,%edx
movslq %edx,%rcx
cmpb   $0x20,(%rbx,%rcx,1)
je     5f6 <parseopts+0x114>
add    $0x1,%eax
movslq %edx,%rcx
add    %rbx,%rcx
cmpb   $0x0,(%rcx)
jne    5af <parseopts+0xcd>
jmp    61e <parseopts+0x13c>
mov    $0x0,%eax
jmp    61e <parseopts+0x13c>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
parseopts(char *opts, char **arg)
{
  static char *optcpy = ((void *)0);
  static int optlen = 0;
  int i;
  int a;
  if (!opts)
    return 0;
  if (strlen(opts) > optlen)
    {
      if (optcpy)
 free(optcpy);
      optlen = strlen(opts);
      if (!(optcpy = malloc(optlen + 1)))
 {
   perror("dap");
   exit(1);
 }
    }
  strcpy(optcpy, opts);
  for (i = 0; optcpy[i] == ' '; i++)
    ;
  for (a = 0; optcpy[i]; a++)
    {
      if (arg)
 arg[a] = optcpy + i;
      while (optcpy[i] && optcpy[i] != ' ')
 i++;
      if (optcpy[i])
 {
   if (arg)
     optcpy[i] = '\0';
   for (i++; optcpy[i] == ' '; i++)
     ;
 }
    }
  return a;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 12
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 17
36 17
37 20
38 20
39 20
40 20
41 21
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 21
50 23
51 23
52 23
53 23
54 23
55 25
56 25
57 26
58 26
59 27
60 27
61 27
62 27
63 27
64 28
65 27
66 27
67 27
68 27
69 27
70 29
71 29
72 31
73 31
74 32
75 33
76 33
77 33
78 33
79 33
80 33
81 33
82 33
83 23
84 23
85 23
86 23
87 23
88 23
89 8
90 8
91 23
92 38
93 38
94 38
95 38
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     958 <grecs_match_buf_free+0x16>
callq  0 <grecs_match_buf_free_contents>
mov    %rbx,%rdi
callq  958 <grecs_match_buf_free+0x16>
pop    %rbx
retq   
<<<sep_in_sample>>>
grecs_match_buf_free(struct grecs_match_buf *buf)
{
 if (buf) {
  grecs_match_buf_free_contents(buf);
  free(buf);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
callq  bfd <gsl_sort_vector_uint_smallest+0x17>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_sort_vector_uint_smallest (unsigned int * dest, const size_t k,
                                     const gsl_vector_uint * v)
{
  return gsl_sort_uint_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbx
sub    $0x90,%rsp
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
mov    (%rsi),%ecx
mov    $0x0,%edx
mov    $0x80,%esi
mov    %rsp,%rdi
callq  146 <i2s+0x32>
mov    %rsp,%rdi
callq  14e <i2s+0x3a>
mov    %rax,(%rbx)
mov    $0x0,%eax
mov    0x88(%rsp),%rdx
xor    %fs:0x28,%rdx
je     16e <i2s+0x5a>
callq  16e <i2s+0x5a>
add    $0x90,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
i2s (union value *vp, void *val, int flags)
{
  char buf[128];
  snprintf (buf, sizeof buf, "%d", *(int*)val);
  vp->string = estrdup (buf);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
mov    $0x1,%edx
callq  23bb <swlib_write_catalog_stream+0x13>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
swlib_write_catalog_stream(XFORMAT * package, int ofd)
{
 int ret;
 ret = taruib_write_catalog_stream((void*)package,
    ofd, 1, 0);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 7
6 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  (%rdi),%xmm1
ucomisd 0x0(%rip),%xmm1        # 734 <heading+0x10>
jp     745 <heading+0x21>
jne    745 <heading+0x21>
xorpd  %xmm0,%xmm0
ucomisd 0x8(%rdi),%xmm0
jp     745 <heading+0x21>
je     761 <heading+0x3d>
movsd  0x8(%rdi),%xmm0
callq  74f <heading+0x2b>
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
jbe    761 <heading+0x3d>
addsd  0x0(%rip),%xmm0        # 761 <heading+0x3d>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
heading(VPoint * x)
{
 double m;
 if (x->x == 0.0 && x->y == 0.0)
  return 0.0;
 if ((m = atan2(x->y, x->x)) < 0.0)
  return (3.14159265358979323846 * 2.0 + m);
 else
  return m;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 7
16 10
17 10
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
_PySelectionKey_dealloc (PyObject *self)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,(%r8)
je     3ec <version_etc_ar+0x1d>
mov    $0x0,%r9d
add    $0x1,%r9
cmpq   $0x0,(%r8,%r9,8)
jne    3df <version_etc_ar+0x10>
jmp    3f2 <version_etc_ar+0x23>
mov    $0x0,%r9d
callq  3f7 <version_etc_ar+0x28>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
version_etc_ar (FILE *stream,
                const char *command_name, const char *package,
                const char *version, const char * const * authors)
{
  size_t n_authors;
  for (n_authors = 0; authors[n_authors]; n_authors++)
    ;
  version_etc_arn (stream, command_name, package, version, authors, n_authors);
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 9
12 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
add    0x10(%rdi),%rsi
cmp    0x8(%rdi),%rsi
jbe    10cf <text_buffer_alloc+0x2d>
cmp    $0x200,%rsi
mov    $0x200,%eax
cmovb  %rax,%rsi
mov    %rsi,0x8(%rdi)
mov    (%rdi),%rdi
callq  10cc <text_buffer_alloc+0x2a>
mov    %rax,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
text_buffer_alloc (struct text_buffer *buf, size_t len)
{
  if (buf->off + len > buf->size)
    {
      buf->size = buf->off + len;
      if (buf->size < 512)
 buf->size = 512;
      buf->base = xrealloc (buf->base, buf->size);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
9 5
10 8
11 8
12 8
13 10
14 10
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
<<<sep_in_sample>>>
rec_sex_parser_ast (rec_sex_parser_t parser)
{
  return parser->ast;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
test   %rdi,%rdi
je     14d <rec_writer_destroy+0x2c>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     137 <rec_writer_destroy+0x16>
callq  137 <rec_writer_destroy+0x16>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     145 <rec_writer_destroy+0x24>
callq  145 <rec_writer_destroy+0x24>
mov    %rbx,%rdi
callq  14d <rec_writer_destroy+0x2c>
pop    %rbx
retq   
<<<sep_in_sample>>>
rec_writer_destroy (rec_writer_t writer)
{
  if (writer)
    {
      if (writer->file_out)
        {
          fflush (writer->file_out);
        }
      if (writer->buf_out)
        {
          rec_buf_close (writer->buf_out);
        }
      free (writer);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 7
9 9
10 9
11 9
12 11
13 13
14 13
15 15
16 15
<<<sep_out_sample>>>
cmp    $0x9,%dil
sete   %dl
cmp    $0x20,%dil
sete   %al
or     %edx,%eax
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
is_space (unsigned char c)
{
  return (c == 0x20) || (c == 0x09);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
mov    0xf8(%rdi),%rax
retq   
<<<sep_in_sample>>>
osip_message_get_from (const osip_message_t * sip)
{
  return sip->from;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4d8 <_cdio_list_node_data+0xa>
mov    0x10(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
_cdio_list_node_data (CdioListNode_t *p_node)
{
  if (p_node)
    return p_node->data;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
<<<sep_out_sample>>>
minsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
GSL_MIN_DBL (double a, double b)
{
  return ((a) < (b) ? (a) : (b));
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbp
mov    %rsi,%rbx
mov    $0x28,%esi
mov    $0x1,%edi
callq  cb7 <wsnode_new+0x1b>
test   %rax,%rax
jne    cc6 <wsnode_new+0x2a>
mov    %rbp,%rdi
callq  c4b <_wsplt_nomem>
jmp    cce <wsnode_new+0x32>
mov    %rax,(%rbx)
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
wsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)
{
  struct wordsplit_node *node = calloc (1, sizeof (*node));
  if (!node)
    return _wsplt_nomem (wsp);
  *pnode = node;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 5
13 5
14 6
15 7
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x23,%edi
callq  13 <_gsasl_cram_md5_server_start+0x13>
mov    %rax,%rbx
mov    $0x7,%eax
test   %rbx,%rbx
je     39 <_gsasl_cram_md5_server_start+0x39>
mov    %rbx,%rdi
callq  28 <_gsasl_cram_md5_server_start+0x28>
mov    %eax,%edx
mov    $0x9,%eax
test   %edx,%edx
jne    39 <_gsasl_cram_md5_server_start+0x39>
mov    %rbx,0x0(%rbp)
mov    $0x0,%al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_gsasl_cram_md5_server_start (Gsasl_session * sctx, void **mech_data)
{
  char *challenge;
  int rc;
  challenge = malloc (35);
  if (challenge == ((void *)0))
    return GSASL_MALLOC_ERROR;
  rc = cram_md5_challenge (challenge);
  if (rc)
    return GSASL_CRYPTO_ERROR;
  *mech_data = challenge;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 6
10 6
11 8
12 8
13 8
14 10
15 9
16 9
17 11
18 12
19 13
20 13
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  13 <fixup_url+0x13>
cmpq   $0x0,0x0(%rip)        # 1b <fixup_url+0x1b>
jne    2c <fixup_url+0x2c>
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c <fixup_url+0x2c>
cmpq   $0x0,0x0(%rip)        # 34 <fixup_url+0x34>
jne    45 <fixup_url+0x45>
mov    $0x0,%esi
mov    $0x0,%edi
callq  45 <fixup_url+0x45>
cmpq   $0x0,0x0(%rip)        # 4d <fixup_url+0x4d>
jne    5e <fixup_url+0x5e>
mov    $0x0,%esi
mov    $0x0,%edi
callq  5e <fixup_url+0x5e>
cmpq   $0x0,0x0(%rip)        # 66 <fixup_url+0x66>
jne    77 <fixup_url+0x77>
mov    $0x0,%esi
mov    $0x0,%edi
callq  77 <fixup_url+0x77>
cmpl   $0x1,0x0(%rip)        # 7e <fixup_url+0x7e>
jne    8a <fixup_url+0x8a>
movl   $0x1,0x0(%rip)        # 8a <fixup_url+0x8a>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
fixup_url()
{
    xdico_assign_string(&dico_url.proto, "dict");
    if (!dico_url.host)
 xdico_assign_string(&dico_url.host, "gnu.org.ua");
    if (!dico_url.port)
 xdico_assign_string(&dico_url.port, "2628");
    if (!dico_url.req.database)
 xdico_assign_string(&dico_url.req.database, "!");
    if (!dico_url.req.strategy)
 xdico_assign_string(&dico_url.req.strategy, ".");
    if (mode == mode_match)
 dico_url.req.type = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 9
18 9
19 9
20 10
21 10
22 11
23 11
24 11
25 12
26 12
27 13
28 14
29 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  2c5 <gsl_sf_clausen+0xc>
movsd  (%rsp),%xmm0
test   %eax,%eax
je     2eb <gsl_sf_clausen+0x32>
mov    %eax,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2e4 <gsl_sf_clausen+0x2b>
movsd  (%rsp),%xmm0
jmp    2eb <gsl_sf_clausen+0x32>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_clausen(const double x)
{
  gsl_sf_result result; int status = gsl_sf_clausen_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_clausen_e(x, &result)", "clausen.c", 110, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     502 <gsasl_server_callback_maxbuf_get+0xd>
mov    0xc8(%rdi),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
gsasl_server_callback_maxbuf_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_maxbuf : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
divsd  %xmm1,%xmm0
ucomisd 0x0(%rip),%xmm0        # 8b <gsl_cdf_logistic_Q+0x10>
jb     cb <gsl_cdf_logistic_Q+0x50>
movsd  0x0(%rip),%xmm1        # 95 <gsl_cdf_logistic_Q+0x1a>
xorpd  %xmm1,%xmm0
movsd  %xmm0,(%rsp)
callq  a3 <gsl_cdf_logistic_Q+0x28>
movsd  %xmm0,0x8(%rsp)
movsd  (%rsp),%xmm0
callq  b3 <gsl_cdf_logistic_Q+0x38>
addsd  0x0(%rip),%xmm0        # bb <gsl_cdf_logistic_Q+0x40>
movsd  0x8(%rsp),%xmm2
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
jmp    e4 <gsl_cdf_logistic_Q+0x69>
callq  d0 <gsl_cdf_logistic_Q+0x55>
movsd  0x0(%rip),%xmm1        # d8 <gsl_cdf_logistic_Q+0x5d>
addsd  %xmm1,%xmm0
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_logistic_Q (const double x, const double a)
{
  double Q;
  double u = x / a;
  if (u >= 0)
    {
      Q = exp (-u) / (1 + exp (-u));
    }
  else
    {
      Q = 1 / (1 + exp (u));
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 14
23 14
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
movzbl (%rdx,%rcx,1),%eax
retq   
<<<sep_in_sample>>>
token_flags (char const *buf)
{
  return *(unsigned char const *)&buf[strlen (buf) + 1];
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
push   %rbx
callq  27 <xstr_cd_iconv+0x6>
mov    %rax,%rbx
test   %rax,%rax
jne    3e <xstr_cd_iconv+0x1d>
callq  34 <xstr_cd_iconv+0x13>
cmpl   $0xc,(%rax)
jne    3e <xstr_cd_iconv+0x1d>
callq  3e <xstr_cd_iconv+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
xstr_cd_iconv (const char *src, iconv_t cd)
{
  char *result = str_cd_iconv (src, cd);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%r12
mov    %rdx,%rbp
mov    0x10(%rdi),%eax
and    $0xf000,%eax
cmp    $0x2000,%eax
je     83a <hp_compute_dev+0x3a>
cmp    $0x2000,%eax
ja     82c <hp_compute_dev+0x2c>
cmp    $0x1000,%eax
jne    862 <hp_compute_dev+0x62>
jmp    83a <hp_compute_dev+0x3a>
cmp    $0x6000,%eax
je     83a <hp_compute_dev+0x3a>
cmp    $0xc000,%eax
jne    862 <hp_compute_dev+0x62>
mov    0x50(%rbx),%esi
mov    0x48(%rbx),%edi
callq  845 <hp_compute_dev+0x45>
mov    %rax,0x30(%rbx)
mov    $0x1,%esi
mov    $0x0,%edi
callq  858 <hp_compute_dev+0x58>
mov    %rax,0x0(%rbp)
mov    %rax,(%r12)
jmp    882 <hp_compute_dev+0x82>
mov    0x40(%rbx),%esi
mov    0x38(%rbx),%edi
callq  86d <hp_compute_dev+0x6d>
mov    %rax,(%r12)
mov    0x50(%rbx),%rsi
mov    0x48(%rbx),%rdi
callq  87e <hp_compute_dev+0x7e>
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
hp_compute_dev (struct cpio_file_stat *file_hdr, dev_t *pdev, dev_t *prdev)
{
  switch (file_hdr->c_mode & 0170000)
    {
    case 0020000:
    case 0060000:
    case 0140000:
    case 0010000:
      file_hdr->c_filesize = gnu_dev_makedev (file_hdr->c_rdev_maj, file_hdr->c_rdev_min)
                               ;
      *pdev = *prdev = gnu_dev_makedev (0, 1);
      break;
    default:
      *pdev = gnu_dev_makedev (file_hdr->c_dev_maj, file_hdr->c_dev_min);
      *prdev = gnu_dev_makedev (file_hdr->c_rdev_maj, file_hdr->c_rdev_min);
      break;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 9
21 9
22 9
23 9
24 11
25 11
26 11
27 11
28 11
29 12
30 14
31 14
32 14
33 14
34 15
35 15
36 15
37 15
38 18
39 18
40 18
41 18
<<<sep_out_sample>>>
test   %rdi,%rdi
je     34 <dico_udb_open+0x23>
mov    0x28(%rdi),%rcx
mov    $0x0,%eax
test   %rcx,%rcx
je     3e <dico_udb_open+0x2d>
sub    $0x8,%rsp
mov    0x20(%rdi),%rdx
mov    0x8(%rdi),%rsi
callq  *%rcx
jmp    3a <dico_udb_open+0x29>
mov    $0x1,%eax
retq   
add    $0x8,%rsp
xchg   %ax,%ax
repz retq 
<<<sep_in_sample>>>
dico_udb_open(dico_udb_t db)
{
    if (!db)
 return 1;
    if (!db->_db_open)
 return 0;
    return db->_db_open(&db->handle, db->url, db->options);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 5
6 5
7 2
8 7
9 7
10 7
11 7
12 4
13 4
14 8
15 8
16 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%r12
mov    %rsi,%r13
mov    %rdx,%rbp
mov    %rcx,%r14
mov    %r8,%r15
mov    %r9,%rbx
callq  25 <gsl_stats_long_double_ttest+0x25>
movsd  %xmm0,(%rsp)
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
callq  38 <gsl_stats_long_double_ttest+0x38>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%r9
mov    %r15,%r8
mov    %r14,%rcx
mov    %rbp,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
callq  55 <gsl_stats_long_double_ttest+0x55>
test   %rbp,%rbp
js     61 <gsl_stats_long_double_ttest+0x61>
cvtsi2sd %rbp,%xmm3
jmp    79 <gsl_stats_long_double_ttest+0x79>
mov    %rbp,%rax
shr    %rax
mov    %rbp,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm2        # 81 <gsl_stats_long_double_ttest+0x81>
divsd  %xmm3,%xmm2
test   %rbx,%rbx
js     91 <gsl_stats_long_double_ttest+0x91>
cvtsi2sd %rbx,%xmm3
jmp    a9 <gsl_stats_long_double_ttest+0xa9>
mov    %rbx,%rax
shr    %rax
mov    %rbx,%rdx
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm3
addsd  %xmm3,%xmm3
movsd  0x0(%rip),%xmm1        # b1 <gsl_stats_long_double_ttest+0xb1>
divsd  %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jnp    136 <gsl_stats_long_double_ttest+0x136>
test   %rbp,%rbp
js     d3 <gsl_stats_long_double_ttest+0xd3>
cvtsi2sd %rbp,%xmm1
jmp    e8 <gsl_stats_long_double_ttest+0xe8>
mov    %rbp,%rax
shr    %rax
and    $0x1,%ebp
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm2        # f0 <gsl_stats_long_double_ttest+0xf0>
divsd  %xmm1,%xmm2
test   %rbx,%rbx
js     100 <gsl_stats_long_double_ttest+0x100>
cvtsi2sd %rbx,%xmm1
jmp    115 <gsl_stats_long_double_ttest+0x115>
mov    %rbx,%rax
shr    %rax
and    $0x1,%ebx
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm3        # 11d <gsl_stats_long_double_ttest+0x11d>
divsd  %xmm1,%xmm3
movapd %xmm3,%xmm1
addsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm0
callq  132 <gsl_stats_long_double_ttest+0x132>
movapd %xmm0,%xmm1
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
divsd  %xmm1,%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
gsl_stats_long_double_ttest (const long double data1[],
                           const size_t stride1, const size_t n1,
                           const long double data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_long_double_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_long_double_mean (data2, stride2, n2);
  const double pv = gsl_stats_long_double_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 11
92 11
93 11
94 11
95 11
96 11
97 11
98 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
callq  2b0 <gsl_blas_snrm2+0x14>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_snrm2 (const gsl_vector_float * X)
{
  return cblas_snrm2 (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
cmpq   $0x0,(%rsi)
je     47d <mu_opool_head+0x1d>
mov    0x18(%rdi),%rax
test   %rax,%rax
je     475 <mu_opool_head+0x15>
mov    0x10(%rax),%rax
jmp    47a <mu_opool_head+0x1a>
mov    $0x0,%eax
mov    %rax,(%rsi)
mov    0x18(%rdi),%rax
test   %rax,%rax
je     48b <mu_opool_head+0x2b>
mov    0x8(%rax),%rax
retq   
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
mu_opool_head (mu_opool_t opool, size_t *psize)
{
  if (*psize)
    *psize = opool->head ? opool->head->level : 0;
  return opool->head ? opool->head->buf : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdx,%rbx
mov    %rcx,%rdx
mov    %r8,%rbp
mov    $0x0,%r8d
mov    %rbx,%rcx
callq  817 <acl_section_parser+0x1d>
test   %eax,%eax
jne    822 <acl_section_parser+0x28>
mov    (%rbx),%rdx
mov    %rdx,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
acl_section_parser (enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr,
      grecs_value_t *value,
      void *cb_data)
{
  int rc = _acl_common_section_parser (cmd, locus, value, varptr,
           0);
  if (rc == 0)
    *(void**)cb_data = *(pies_acl_t*)varptr;
  return rc;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 7
8 7
9 7
10 9
11 9
12 10
13 10
14 12
15 12
16 12
17 12
<<<sep_out_sample>>>
push   %rbx
sub    $0x1e0,%rsp
mov    %rsi,0x138(%rsp)
mov    %rdx,0x140(%rsp)
mov    %rcx,0x148(%rsp)
mov    %r8,0x150(%rsp)
mov    %r9,0x158(%rsp)
test   %al,%al
je     74 <outputf+0x74>
movaps %xmm0,0x160(%rsp)
movaps %xmm1,0x170(%rsp)
movaps %xmm2,0x180(%rsp)
movaps %xmm3,0x190(%rsp)
movaps %xmm4,0x1a0(%rsp)
movaps %xmm5,0x1b0(%rsp)
movaps %xmm6,0x1c0(%rsp)
movaps %xmm7,0x1d0(%rsp)
mov    %rdi,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x128(%rsp)
xor    %eax,%eax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0x1f0(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x130(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
lea    0x20(%rsp),%rdi
callq  c3 <outputf+0xc3>
lea    0x20(%rsp),%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
sub    $0x1,%rcx
cmp    $0xff,%rcx
jbe    ff <outputf+0xff>
mov    $0x0,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  ff <outputf+0xff>
movzbl 0x20(%rsp),%esi
test   %sil,%sil
je     128 <outputf+0x128>
lea    0x20(%rsp),%rbx
movsbl %sil,%esi
mov    $0x1,%edi
callq  11c <outputf+0x11c>
add    $0x1,%rbx
movzbl (%rbx),%esi
test   %sil,%sil
jne    10e <outputf+0x10e>
mov    0x128(%rsp),%rax
xor    %fs:0x28,%rax
je     140 <outputf+0x140>
callq  140 <outputf+0x140>
add    $0x1e0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
outputf(char *fmt, ...)
{
      va_list arg;
      char str[255+1], *ptr;
      __builtin_va_start(arg,fmt);
      vsprintf(str, fmt, arg);
      ((strlen(str) <= sizeof(str) - 1) ? (void) (0) : __assert_fail ("strlen(str) <= sizeof(str) - 1", "alglib3.c", 32, __PRETTY_FUNCTION__));
      __builtin_va_end(arg);
      for (ptr = str; *ptr != '\0'; ptr++) outchar(1, *ptr);
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 5
23 5
24 5
25 5
26 5
27 5
28 6
29 6
30 6
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 9
54 9
55 11
56 11
57 11
58 11
59 11
60 11
61 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
mov    $0x0,%edx
div    %rcx
cmp    %rsi,%rax
jae    a7 <xnrealloc+0x20>
callq  a7 <xnrealloc+0x20>
imul   %rcx,%rsi
callq  b0 <xnrealloc+0x29>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rax
mov    0xc0(%rax),%rax
mov    0x1c(%rax),%edi
cmp    $0x7,%edi
ja     54eb <_jit_pushargr_d+0x42>
movslq %esi,%rcx
mov    $0x1f,%edx
sub    %edi,%edx
movslq %edx,%rdx
mov    $0x12f,%esi
mov    %rbx,%rdi
callq  54da <_jit_pushargr_d+0x31>
mov    0x38(%rbx),%rax
mov    0xc0(%rax),%rax
addl   $0x1,0x1c(%rax)
jmp    5513 <_jit_pushargr_d+0x6a>
movslq 0x20(%rax),%rdx
movslq %esi,%r8
mov    $0xe,%ecx
mov    $0x138,%esi
mov    %rbx,%rdi
callq  5504 <_jit_pushargr_d+0x5b>
mov    0x38(%rbx),%rax
mov    0xc0(%rax),%rax
addl   $0x8,0x20(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
_jit_pushargr_d(jit_state_t *_jit, jit_int32_t u)
{
    ((void) (0));
    if (((_jit->comp->function->call.argf) >= 0 && (_jit->comp->function->call.argf) < 8)) {
 _jit_new_node_ww(_jit,jit_code_movr_d,_XMM0 - _jit->comp->function->call.argf,u);
 ++_jit->comp->function->call.argf;
    }
    else
    {
 _jit_new_node_www(_jit,jit_code_stxi_d,_jit->comp->function->call.size,_RSP,u);
 _jit->comp->function->call.size += sizeof(jit_float64_t);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 10
20 10
21 10
22 10
23 10
24 10
25 11
26 11
27 11
28 13
29 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 306 <ds_silent_close+0x7>
test   %rax,%rax
je     349 <ds_silent_close+0x4a>
sub    $0x8,%rsp
mov    0x8(%rax),%rdi
mov    $0x0,%esi
mov    $0x0,%eax
callq  322 <ds_silent_close+0x23>
mov    0x0(%rip),%rdi        # 329 <ds_silent_close+0x2a>
callq  32e <ds_silent_close+0x2f>
mov    0x0(%rip),%rdi        # 335 <ds_silent_close+0x36>
callq  33a <ds_silent_close+0x3b>
movq   $0x0,0x0(%rip)        # 345 <ds_silent_close+0x46>
add    $0x8,%rsp
repz retq 
<<<sep_in_sample>>>
ds_silent_close()
{
    if (conn) {
 stream_printf(conn->str, "QUIT\r\n");
 dict_read_reply(conn);
 dict_conn_close(conn);
 conn = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
13 7
14 9
15 9
<<<sep_out_sample>>>
sub    $0x58,%rsp
mov    %rcx,0x38(%rsp)
mov    $0x0,%ecx
test   $0x40,%dl
je     33 <openat_safer+0x33>
movl   $0x18,0x8(%rsp)
lea    0x60(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%ecx
mov    $0x0,%eax
callq  3d <openat_safer+0x3d>
mov    %eax,%edi
callq  44 <openat_safer+0x44>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
openat_safer (int fd, char const *file, int flags, ...)
{
  mode_t mode = 0;
  if (flags & 0100)
    {
      va_list ap;
      __builtin_va_start(ap,flags);
      mode = __builtin_va_arg(ap,mode_t);
      __builtin_va_end(ap);
    }
  return fd_safer (openat (fd, file, flags, mode));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 8
12 11
13 11
14 11
15 11
16 12
17 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
callq  c6b <dtoi+0xc>
mov    (%rax),%rcx
mov    $0x0,%r12d
jmp    c86 <dtoi+0x27>
lea    (%r12,%r12,4),%edx
add    $0x1,%rbx
movsbl %al,%eax
lea    -0x30(%rax,%rdx,2),%r12d
movzbl (%rbx),%eax
movsbq %al,%rdx
testb  $0x8,0x1(%rcx,%rdx,2)
jne    c76 <dtoi+0x17>
mov    %eax,%ebp
test   %al,%al
jne    ca8 <dtoi+0x49>
jmp    cc9 <dtoi+0x6a>
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     cce <dtoi+0x6f>
movsbl %bpl,%esi
mov    $0x0,%edi
callq  cb6 <dtoi+0x57>
test   %rax,%rax
jne    c9c <dtoi+0x3d>
test   %bpl,%bpl
mov    $0xffffffff,%eax
cmove  %r12d,%eax
jmp    cd1 <dtoi+0x72>
mov    %r12d,%eax
jmp    cd1 <dtoi+0x72>
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
dtoi (char const *str)
{
  int n = 0;
  while (((*__ctype_b_loc ())[(int) ((*str))] & (unsigned short int) _ISdigit))
    {
      n *= 10;
      n += *str++ - '0';
    }
  while (*str && strchr ("uUlL", *str))
    str++;
  return (*str ? -1 : n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 3
8 4
9 6
10 7
11 7
12 7
13 4
14 4
15 4
16 4
17 9
18 9
19 9
20 9
21 10
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 11
31 11
32 11
33 11
34 9
35 9
36 9
37 12
38 12
39 12
40 12
<<<sep_out_sample>>>
mov    %rdi,%rax
cmpb   $0x2e,(%rdi)
jne    14 <removedotslash+0x14>
lea    0x2(%rdi),%rax
cmpb   $0x2f,0x1(%rdi)
cmovne %rdi,%rax
repz retq 
<<<sep_in_sample>>>
removedotslash(const char *path)
{
 return (*path == '.' && *(path + 1) == '/') ? path + 2 : path;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rdi,%rbx
mov    %rsi,%rbp
test   %rdi,%rdi
jne    33d <parse_opt_set_mtu+0x32>
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  33d <parse_opt_set_mtu+0x32>
testb  $0x80,0x8(%rbx)
je     364 <parse_opt_set_mtu+0x59>
mov    (%rbx),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  364 <parse_opt_set_mtu+0x59>
mov    $0x0,%edx
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  376 <parse_opt_set_mtu+0x6b>
mov    %eax,0x48(%rbx)
cmpb   $0x0,0x0(%rbp)
je     389 <parse_opt_set_mtu+0x7e>
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
je     3a8 <parse_opt_set_mtu+0x9d>
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x1,%edi
mov    $0x0,%eax
callq  3a8 <parse_opt_set_mtu+0x9d>
orl    $0x80,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
parse_opt_set_mtu (struct ifconfig *ifp, char *arg) { char *end; if (!ifp) error (1, 0, "no interface specified for %s `%s'\n", "mtu value", arg); if (ifp->valid & 0x080) error (1, 0, "only one %s allowed for interface `%s'", "mtu value", ifp->name); ifp->mtu = strtol (arg, &end, 0); if (*arg == '\0' || *end != '\0') error (1, 0, "mtu value `%s' for interface `%s' is not a number", arg, ifp->name); ifp->valid |= 0x080; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
44 1
45 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
test   %rdi,%rdi
je     1c9 <pies_url_destroy+0xa0>
mov    (%rdi),%rbp
test   %rbp,%rbp
je     1c9 <pies_url_destroy+0xa0>
mov    0x0(%rbp),%rdi
callq  14e <pies_url_destroy+0x25>
mov    0x8(%rbp),%rdi
callq  157 <pies_url_destroy+0x2e>
mov    0x10(%rbp),%rdi
callq  160 <pies_url_destroy+0x37>
mov    0x18(%rbp),%rdi
callq  169 <pies_url_destroy+0x40>
mov    0x28(%rbp),%rdi
callq  172 <pies_url_destroy+0x49>
mov    0x38(%rbp),%rdi
callq  17b <pies_url_destroy+0x52>
mov    0x40(%rbp),%rdi
callq  184 <pies_url_destroy+0x5b>
mov    0x48(%rbp),%rdi
callq  18d <pies_url_destroy+0x64>
cmpl   $0x0,0x50(%rbp)
jle    1b0 <pies_url_destroy+0x87>
mov    $0x0,%ebx
movslq %ebx,%rdx
mov    0x58(%rbp),%rax
mov    (%rax,%rdx,8),%rdi
callq  1a8 <pies_url_destroy+0x7f>
add    $0x1,%ebx
cmp    %ebx,0x50(%rbp)
jg     198 <pies_url_destroy+0x6f>
mov    0x58(%rbp),%rdi
callq  1b9 <pies_url_destroy+0x90>
mov    %rbp,%rdi
callq  1c1 <pies_url_destroy+0x98>
movq   $0x0,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
pies_url_destroy (struct pies_url **purl)
{
  int i;
  if (purl && *purl)
    {
      struct pies_url *url = *purl;
      free (url->string);
      free (url->scheme);
      free (url->host);
      free (url->port_s);
      free (url->proto_s);
      free (url->path);
      free (url->user);
      free (url->passwd);
      for (i = 0; i < url->argc; i++)
 free (url->argv[i]);
      free (url->argv);
      free (url);
      *purl = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 7
11 7
12 8
13 8
14 9
15 9
16 10
17 10
18 11
19 11
20 12
21 12
22 13
23 13
24 14
25 14
26 15
27 15
28 15
29 16
30 16
31 16
32 16
33 15
34 15
35 15
36 17
37 17
38 18
39 18
40 19
41 21
42 21
43 21
44 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
and    $0x80000,%esi
cmp    $0x1,%esi
sbb    %esi,%esi
not    %esi
and    $0x406,%esi
mov    $0x3,%edx
mov    $0x0,%eax
callq  26 <dup_safer_flag+0x26>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
dup_safer_flag (int fd, int flag)
{
  return rpl_fcntl (fd, (flag & 02000000) ? 1030 : 0,
                2 + 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 220e <rewind_read_files+0x8>
test   %rbx,%rbx
je     222a <rewind_read_files+0x24>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     2221 <rewind_read_files+0x1b>
callq  2221 <rewind_read_files+0x1b>
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    2213 <rewind_read_files+0xd>
pop    %rbx
retq   
<<<sep_in_sample>>>
rewind_read_files()
{
  struct output *p;
  for (p=file_read; p; p=p->link)
    if (p->fp)
      rewind(p->fp);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 6
9 4
10 4
11 4
12 7
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x8(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gl_oset_size (gl_oset_t set)
{
  return ((const struct gl_oset_impl_base *) set)->vtable->size (set);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x1d0(%rdi),%rax
callq  *0x30(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
jpeg_write_m_byte (j_compress_ptr cinfo, int val)
{
  (*cinfo->marker->write_marker_byte) (cinfo, val);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%eax
retq   
<<<sep_in_sample>>>
swicat_req_get_pre_result(SWICAT_REQ * req)
{
 return req->pre_resultM;
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    $0x16,%eax
test   %rdi,%rdi
je     857 <mu_ip_server_shutdown+0xab>
cmpl   $0xffffffff,0x14(%rdi)
jne    857 <mu_ip_server_shutdown+0xab>
mov    0x20(%rdi),%rdi
mov    $0x1,%esi
callq  7db <mu_ip_server_shutdown+0x2f>
test   %eax,%eax
je     84a <mu_ip_server_shutdown+0x9e>
mov    0x10(%rbx),%esi
mov    0x8(%rbx),%rdi
callq  7eb <mu_ip_server_shutdown+0x3f>
mov    %rax,%rbp
cmpl   $0x0,0x0(%rip)        # 7f5 <mu_ip_server_shutdown+0x49>
je     818 <mu_ip_server_shutdown+0x6c>
mov    0x20(%rbx),%rdi
mov    $0x175,%edx
mov    $0x0,%esi
callq  80a <mu_ip_server_shutdown+0x5e>
mov    0x20(%rbx),%rdi
mov    $0x0,%esi
callq  818 <mu_ip_server_shutdown+0x6c>
mov    (%rbx),%rdx
test   %rdx,%rdx
mov    $0x0,%ecx
cmovne %rdx,%rcx
mov    0x20(%rbx),%rdi
mov    %rbp,%r8
mov    $0x0,%edx
mov    $0x1,%esi
mov    $0x0,%eax
callq  842 <mu_ip_server_shutdown+0x96>
mov    %rbp,%rdi
callq  84a <mu_ip_server_shutdown+0x9e>
mov    0x14(%rbx),%edi
callq  852 <mu_ip_server_shutdown+0xa6>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_ip_server_shutdown (mu_ip_server_t srv)
{
  if (!srv || srv->fd != -1)
    return 22;
  if (mu_debug_check_level (srv->debug, 1))
    {
      char *p = mu_sockaddr_to_astr (srv->addr, srv->addrlen);
      do { if (mu_debug_line_info) { mu_debug_set_locus (srv->debug,
 "ipsrv.c"
      ,
 373
      ); mu_debug_set_function (srv->debug, __FUNCTION__); } mu_debug_printf (srv->debug, 1, "closing server \"%s\" %s\n", ((srv)->ident ? (srv)->ident : "default"), p); } while (0)
       ;
      free (p);
    }
  close (srv->fd);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 8
23 8
24 8
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 14
39 14
40 16
41 16
42 17
43 18
44 18
45 18
46 18
<<<sep_out_sample>>>
mov    $0x0,%eax
mov    $0x0,%edx
jmp    107 <init_data+0x1a>
mov    %edx,%esi
imul   %edx,%esi
cmp    %ecx,%esi
adc    $0x0,%edx
add    $0x1,%rax
mov    %dl,(%rdi,%rax,1)
lea    0x1(%rax),%ecx
cmp    $0x27ff,%rax
jne    f9 <init_data+0xc>
repz retq 
<<<sep_in_sample>>>
init_data(uint8_t *data)
{
  unsigned i,j;
  for (i = j = 0; i<10240; i++)
    {
      if (j*j < i)
 j++;
      data[i] = j;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 7
7 7
8 7
9 8
10 8
11 4
12 4
13 10
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x18(%rsi),%rdi
mov    0x10(%rsi),%rcx
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    0x8(%rsi),%rdx
cmp    %rdx,(%rsi)
cmovbe (%rsi),%rdx
mov    %rdx,(%rax)
mov    %r8,0x8(%rax)
mov    %rdi,0x10(%rax)
mov    %rcx,0x18(%rax)
movl   $0x0,0x20(%rax)
retq   
<<<sep_in_sample>>>
gsl_matrix_long_const_diagonal (const gsl_matrix_long * m)
{
  _gsl_vector_long_const_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_long v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 2
2 5
3 7
4 7
5 8
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 11
14 12
<<<sep_out_sample>>>
sub    $0x3a8,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x398(%rsp)
xor    %eax,%eax
cmp    $0x1,%edi
jne    51 <main+0x2d>
mov    $0x0,%edi
callq  4d <main+0x29>
mov    %eax,%esi
jmp    77 <main+0x53>
cmp    $0x2,%edi
jne    6c <main+0x48>
mov    0x8(%rsi),%rdi
callq  5f <main+0x3b>
mov    %eax,%esi
test   %eax,%eax
jne    77 <main+0x53>
callq  0 <usage>
jmp    ca <main+0xa6>
nopl   0x0(%rax)
callq  0 <usage>
jmp    ca <main+0xa6>
mov    %rsp,%rdi
callq  7f <main+0x5b>
lea    0x1a0(%rsp),%rdx
mov    $0x1f4,%esi
mov    %rsp,%rdi
callq  94 <main+0x70>
mov    0x0(%rip),%rcx        # 9b <main+0x77>
mov    $0x1f4,%edx
mov    $0x1,%esi
lea    0x1a0(%rsp),%rdi
callq  b2 <main+0x8e>
cmp    $0x1f3,%rax
jbe    ca <main+0xa6>
mov    0x0(%rip),%rdi        # c1 <main+0x9d>
callq  c6 <main+0xa2>
test   %eax,%eax
jns    7f <main+0x5b>
mov    $0x1,%eax
mov    0x398(%rsp),%rcx
xor    %fs:0x28,%rcx
je     e7 <main+0xc3>
callq  e7 <main+0xc3>
add    $0x3a8,%rsp
retq   
<<<sep_in_sample>>>
main(int argc, char **argv)
{
  struct knuth_lfib_ctx ctx;
  uint32_t seed;
  if (argc == 1)
    seed = time(((void *)0));
  else if (argc == 2)
    {
      seed = atoi(argv[1]);
      if (!seed)
 {
   usage();
   return 1;
 }
    }
  else
    {
      usage();
      return 1;
    }
  nettle_knuth_lfib_init(&ctx, seed);
  for (;;)
    {
      char buffer[500];
      nettle_knuth_lfib_random(&ctx, 500, buffer);
      if (fwrite(buffer, 1, 500, stdout) < 500
   || fflush(stdout) < 0)
 return 1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 6
8 6
9 6
10 6
11 7
12 7
13 9
14 9
15 9
16 10
17 10
18 12
19 13
20 13
21 18
22 19
23 21
24 21
25 25
26 25
27 25
28 25
29 26
30 26
31 26
32 26
33 26
34 26
35 26
36 27
37 27
38 27
39 27
40 30
41 30
42 30
43 30
44 30
45 30
46 30
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     af2 <gsl_permute_vector_inverse+0x2c>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  aeb <gsl_permute_vector_inverse+0x25>
mov    $0x13,%eax
jmp    b08 <gsl_permute_vector_inverse+0x42>
mov    0x8(%rsi),%rdx
mov    0x10(%rsi),%rsi
mov    0x8(%rdi),%rdi
callq  b03 <gsl_permute_vector_inverse+0x3d>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_permute_vector_inverse (const gsl_permutation * p, gsl_vector * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 7
13 7
14 7
15 7
16 8
17 9
18 9
<<<sep_out_sample>>>
sub    0x58(%rdi),%rsi
cmp    0x0(%rip),%rsi        # 17e <check_stopping+0xb>
jb     1bb <check_stopping+0x48>
push   %rbx
mov    0x14(%rdi),%eax
test   %eax,%eax
jne    1ad <check_stopping+0x3a>
mov    0x18(%rdi),%rbx
mov    $0x0,%edi
callq  196 <check_stopping+0x23>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
mov    $0x0,%eax
callq  1ab <check_stopping+0x38>
jmp    1c6 <check_stopping+0x53>
mov    $0x9,%esi
mov    %eax,%edi
callq  1b9 <check_stopping+0x46>
jmp    1c6 <check_stopping+0x53>
movl   $0x1,0x0(%rip)        # 1c5 <check_stopping+0x52>
retq   
pop    %rbx
retq   
<<<sep_in_sample>>>
check_stopping (struct prog *prog, time_t now)
{
  if (now - prog->v.p.timestamp >= shutdown_timeout)
    {
      if (prog->pid == 0)
 logmsg (0,
         gettext("INTERNAL ERROR: attempting to kill unexisting process %s"),
  prog->tag);
      else
 kill (prog->pid, 9);
    }
  else
    recompute_alarm = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 5
8 6
9 7
10 7
11 6
12 6
13 6
14 6
15 6
16 6
17 10
18 10
19 10
20 10
21 13
22 13
23 14
24 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rsi,%rbp
mov    $0x16,%eax
test   %rsi,%rsi
je     55e <mu_string_to_flags+0x87>
mov    %rdi,%rbx
mov    $0x7,%edx
mov    $0x0,%esi
callq  4fc <mu_string_to_flags+0x25>
test   %eax,%eax
jne    511 <mu_string_to_flags+0x3a>
mov    $0x3a,%esi
mov    %rbx,%rdi
callq  50d <mu_string_to_flags+0x36>
lea    0x1(%rax),%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    539 <mu_string_to_flags+0x62>
jmp    552 <mu_string_to_flags+0x7b>
cmp    0x4(%rax),%cl
jne    524 <mu_string_to_flags+0x4d>
or     %edx,0x0(%rbp)
jmp    52e <mu_string_to_flags+0x57>
add    $0x8,%rax
mov    (%rax),%edx
test   %edx,%edx
jne    51a <mu_string_to_flags+0x43>
add    $0x1,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
je     559 <mu_string_to_flags+0x82>
mov    0x0(%rip),%edx        # 53f <mu_string_to_flags+0x68>
test   %edx,%edx
je     52e <mu_string_to_flags+0x57>
cmp    0x0(%rip),%cl        # 549 <mu_string_to_flags+0x72>
je     51f <mu_string_to_flags+0x48>
mov    $0x0,%eax
jmp    524 <mu_string_to_flags+0x4d>
mov    $0x0,%eax
jmp    55e <mu_string_to_flags+0x87>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
mu_string_to_flags (const char *buffer, int *pflags)
{
  const char *sep;
  if (pflags == ((void *)0))
    return 22;
  if (mu_c_strncasecmp (buffer, "Status:", 7) == 0)
    {
      sep = strchr(buffer, ':');
      sep++;
    }
  else
    sep = buffer;
  for (; *sep; sep++)
    {
      struct flagtrans *ft;
      for (ft = flagtrans; ft->flag; ft++)
 if (ft->letter == *sep)
   {
     *pflags |= ft->flag;
     break;
   }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 9
18 13
19 13
20 13
21 13
22 17
23 17
24 19
25 20
26 16
27 16
28 16
29 16
30 13
31 13
32 13
33 13
34 16
35 16
36 16
37 17
38 17
39 17
40 17
41 23
42 23
43 23
44 24
45 24
46 24
47 24
<<<sep_out_sample>>>
push   %rbx
sub    $0x410,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x408(%rsp)
xor    %eax,%eax
cmpl   $0x0,0x0(%rip)        # 319 <getconfn+0x22>
jne    325 <getconfn+0x2e>
mov    $0x0,%edi
callq  325 <getconfn+0x2e>
mov    %rsi,%rbx
mov    %rdi,%rcx
mov    $0x0,%edx
mov    $0x400,%esi
mov    %rsp,%rdi
mov    $0x0,%eax
callq  342 <getconfn+0x4b>
mov    $0x0,%edx
mov    %rsp,%rsi
mov    0x0(%rip),%rdi        # 351 <getconfn+0x5a>
callq  356 <getconfn+0x5f>
mov    %rax,%rdx
test   %rax,%rax
je     38a <getconfn+0x93>
mov    %rsp,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
lea    -0x1(%rdx,%rcx,1),%rdi
test   %rbx,%rbx
je     391 <getconfn+0x9a>
callq  381 <getconfn+0x8a>
mov    %eax,(%rbx)
mov    $0x1,%eax
jmp    396 <getconfn+0x9f>
mov    $0x0,%eax
jmp    396 <getconfn+0x9f>
mov    $0x1,%eax
mov    0x408(%rsp),%rbx
xor    %fs:0x28,%rbx
je     3ae <getconfn+0xb7>
callq  3ae <getconfn+0xb7>
add    $0x410,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
getconfn(const char *name, int *num)
{
 const char *p;
 char buf[1024];
 if (!opened)
  die("configuration file not opened.");
 snprintf(buf, sizeof(buf), ":%s#", name);
 if ((p = locatestring(confline, buf, 0)) != ((void *)0)) {
  p += strlen(buf);
  if (num != ((void *)0))
   *num = atoi(p);
  return 1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 10
31 10
32 11
33 11
34 12
35 12
36 14
37 14
38 12
39 15
40 15
41 15
42 15
43 15
44 15
45 15
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    %rdi,(%rsp)
test   %rsi,%rsi
mov    $0x0,%eax
cmove  %rax,%rsi
mov    %rsi,0x8(%rsp)
mov    $0x0,%eax
callq  38c8 <file_existsp+0x24>
mov    %rax,0x10(%rsp)
mov    %rsp,%rdx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 38dc <file_existsp+0x38>
callq  38e1 <file_existsp+0x3d>
mov    %eax,%ebx
mov    0x10(%rsp),%rdi
callq  38ed <file_existsp+0x49>
mov    %ebx,%eax
add    $0x20,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
file_existsp (char *name, char *suffix)
{
  FileLookupCtx ctx;
  int result;
  ctx.name = name;
  ctx.suffix = suffix ? suffix : "";
  ctx.fullname = buffer_alloc ();
  result = pathwalk (libpath, file_lookup, &ctx);
  buffer_free (ctx.fullname);
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 6
5 6
6 6
7 6
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 8
16 9
17 9
18 11
19 11
20 11
21 11
<<<sep_out_sample>>>
push   %rbx
sub    $0xf0,%rsp
mov    %rsi,0x48(%rsp)
mov    %rdx,0x50(%rsp)
mov    %rcx,0x58(%rsp)
mov    %r8,0x60(%rsp)
mov    %r9,0x68(%rsp)
test   %al,%al
je     272 <ask_confirmation+0x62>
movaps %xmm0,0x70(%rsp)
movaps %xmm1,0x80(%rsp)
movaps %xmm2,0x90(%rsp)
movaps %xmm3,0xa0(%rsp)
movaps %xmm4,0xb0(%rsp)
movaps %xmm5,0xc0(%rsp)
movaps %xmm6,0xd0(%rsp)
movaps %xmm7,0xe0(%rsp)
mov    %rdi,%rbx
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
mov    $0xffffffff,%edi
callq  28f <ask_confirmation+0x7f>
test   %rax,%rax
je     35e <ask_confirmation+0x14e>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
lea    0x100(%rsp),%rax
mov    %rax,0x10(%rsp)
lea    0x40(%rsp),%rax
mov    %rax,0x18(%rsp)
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    0x0(%rip),%rdi        # 2ce <ask_confirmation+0xbe>
callq  2d3 <ask_confirmation+0xc3>
mov    0x0(%rip),%rdi        # 2da <ask_confirmation+0xca>
callq  2df <ask_confirmation+0xcf>
mov    $0xffffffff,%edi
callq  2e9 <ask_confirmation+0xd9>
mov    %rax,%rdi
callq  2f1 <ask_confirmation+0xe1>
cmpl   $0x0,0x0(%rip)        # 2f8 <ask_confirmation+0xe8>
je     323 <ask_confirmation+0x113>
mov    $0x1,%edi
callq  304 <ask_confirmation+0xf4>
mov    %rax,%rdi
callq  30c <ask_confirmation+0xfc>
mov    %al,0x20(%rsp)
mov    0x0(%rip),%rsi        # 317 <ask_confirmation+0x107>
mov    $0xa,%edi
callq  321 <ask_confirmation+0x111>
jmp    344 <ask_confirmation+0x134>
mov    $0x0,%edi
callq  32d <ask_confirmation+0x11d>
mov    %rax,%rdx
mov    $0x9,%esi
lea    0x20(%rsp),%rdi
callq  33f <ask_confirmation+0x12f>
test   %rax,%rax
je     365 <ask_confirmation+0x155>
movzbl 0x20(%rsp),%eax
mov    %eax,%edx
and    $0xffffffdf,%edx
cmp    $0x59,%dl
je     36c <ask_confirmation+0x15c>
cmp    $0x4e,%dl
jne    298 <ask_confirmation+0x88>
jmp    373 <ask_confirmation+0x163>
mov    $0x0,%eax
jmp    378 <ask_confirmation+0x168>
mov    $0xffffffff,%eax
jmp    378 <ask_confirmation+0x168>
mov    $0x0,%eax
jmp    378 <ask_confirmation+0x168>
mov    $0xffffffff,%eax
mov    0x38(%rsp),%rcx
xor    %fs:0x28,%rcx
je     38d <ask_confirmation+0x17d>
callq  38d <ask_confirmation+0x17d>
add    $0xf0,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
ask_confirmation(const char *format, ...)
{
 char ans[10];
 va_list ap;
 if(!opentty(-1))
  return 0;
 while (1) {
  __builtin_va_start(ap,format);
  vfprintf(stderr, format, ap);
  __builtin_va_end(ap);
  fflush(stderr);
  fflush(opentty(-1));
  if (mtools_raw_tty) {
   ans[0] = fgetc(opentty(1));
   fputs("\n", stderr);
  } else {
   if(fgets(ans,9, opentty(0)) == ((void *)0))
    ans[0] = 'n';
  }
  if (ans[0] == 'y' || ans[0] == 'Y')
   return 0;
  if (ans[0] == 'n' || ans[0] == 'N')
   return -1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 5
23 5
24 5
25 5
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 11
37 11
38 12
39 12
40 12
41 12
42 13
43 13
44 14
45 14
46 14
47 14
48 14
49 15
50 15
51 15
52 15
53 17
54 17
55 17
56 17
57 17
58 17
59 17
60 17
61 20
62 20
63 20
64 20
65 20
66 22
67 22
68 22
69 6
70 6
71 23
72 23
73 21
74 21
75 23
76 25
77 25
78 25
79 25
80 25
81 25
82 25
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movzbl 0x5d(%rdi),%eax
cmp    $0x50,%al
je     5dc <update_gl_null+0x1d>
cmp    $0x50,%al
jg     5d8 <update_gl_null+0x19>
sub    $0x42,%eax
cmp    $0x1,%al
ja     60e <update_gl_null+0x4f>
jmp    5dc <update_gl_null+0x1d>
cmp    $0x52,%al
jne    60e <update_gl_null+0x4f>
cmpb   $0x0,0x63(%rbx)
je     60e <update_gl_null+0x4f>
mov    0x88(%rbx),%rcx
test   %rcx,%rcx
cmove  0x0(%rip),%rcx        # 5f4 <update_gl_null+0x35>
movswl 0x6a(%rbx),%edx
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 604 <update_gl_null+0x45>
mov    $0x0,%eax
callq  60e <update_gl_null+0x4f>
mov    0xa0(%rbx),%rbx
test   %rbx,%rbx
je     641 <update_gl_null+0x82>
movzbl 0x5d(%rbx),%eax
sub    $0x42,%eax
cmp    $0x10,%al
ja     638 <update_gl_null+0x79>
movzbl %al,%eax
jmpq   *0x0(,%rax,8)
mov    0x20(%rbx),%rdi
callq  5bf <update_gl_null>
mov    0x30(%rbx),%rbx
test   %rbx,%rbx
jne    61a <update_gl_null+0x5b>
pop    %rbx
retq   
<<<sep_in_sample>>>
update_gl_null (block_t *block)
{
  decl_t *rd;
  switch (block->quant.kind)
    {
    case 'P':
    case 'C':
    case 'B':
    case 'R':
      if (block->stat)
 fprintf (ccode, "((__dhp)&__blokk%d%s)->gl=(__dhp)0;\n",block->blno,
   block->timestamp?block->timestamp:timestamp);
    }
  for (rd= block->parloc; rd!= ((void *)0); rd= rd->next)
    {
      switch (rd->kind)
 {
 case 'P':
 case 'C':
 case 'B':
 case 'R':
 case 'F':
 case 'I':
 case 'O':
   update_gl_null (rd->descr);
   break;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 10
15 10
16 12
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 14
25 14
26 14
27 16
28 16
29 16
30 16
31 16
32 16
33 25
34 25
35 14
36 14
37 14
38 29
39 29
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%r12
mov    %rsi,%rbp
mov    %rdx,%rbx
mov    %rdx,%rdi
callq  2bdc <quotes_match+0x15>
mov    $0x0,%ecx
cmp    %rbp,%rax
jne    2bfc <quotes_match+0x35>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    %r12,%rdi
callq  2bf4 <quotes_match+0x2d>
test   %eax,%eax
sete   %cl
movzbl %cl,%ecx
mov    %ecx,%eax
and    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
quotes_match(const char *a_line, size_t a_quote, const char
 *b_line)
{
    ((void) (0));
    return (a_quote == quote_length(b_line) &&
 strncmp(a_line, b_line, a_quote) == 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 5
17 5
18 5
19 5
20 5
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    %rdi,%rbx
mov    %esi,%ebp
mov    $0x0,%edi
callq  1146 <coproc_alloc+0x15>
movl   $0x2,0x0(%rip)        # 1150 <coproc_alloc+0x1f>
mov    %ebp,0x0(%rip)        # 1156 <coproc_alloc+0x25>
mov    %rbx,%rdi
mov    $0x0,%eax
mov    $0xffffffffffffffff,%rcx
repnz scas %es:(%rdi),%al
not    %rcx
mov    %rcx,%rdi
mov    $0x7a1,%edx
mov    $0x0,%esi
callq  117c <coproc_alloc+0x4b>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1187 <coproc_alloc+0x56>
mov    %rax,0x0(%rip)        # 118e <coproc_alloc+0x5d>
movl   $0x0,0x0(%rip)        # 1198 <coproc_alloc+0x67>
mov    $0x0,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
coproc_alloc (name, pid)
     char *name;
     pid_t pid;
{
  struct coproc *cp;
  cp = &sh_coproc;
  coproc_init (cp);
  cp->c_lock = 2;
  cp->c_pid = pid;
  cp->c_name = (char *)strcpy (sh_xmalloc((1 + strlen (name)), "execute_cmd.c", 1953), (name));
  cp->c_lock = 0;
  return (cp);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 7
8 8
9 9
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 11
24 13
25 13
26 13
27 13
28 13