mov    (%rdi),%rdx
test   %rdx,%rdx
je     1c7 <gsl_histogram_sum+0x27>
mov    0x10(%rdi),%rax
xorpd  %xmm0,%xmm0
lea    (%rax,%rdx,8),%rdx
nopl   0x0(%rax)
addsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rdx,%rax
jne    1b8 <gsl_histogram_sum+0x18>
repz retq 
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_histogram_sum(const gsl_histogram * h)
{
  double sum=0;
  size_t i=0;
  size_t n;
  n=h->n;
  while(i < n)
    sum += h->bin[i++];
  return sum;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 3
6 3
7 3
8 8
9 8
10 7
11 7
12 7
13 3
14 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x38,%edi
push   %rbx
sub    $0x10,%rsp
callq  18 <gsl_wavelet_alloc+0x18>
test   %rax,%rax
mov    %rax,%rbx
je     80 <gsl_wavelet_alloc+0x80>
mov    %rbp,(%rax)
lea    0x8(%rax),%rdi
lea    0x20(%rax),%rcx
lea    0x18(%rax),%rdx
lea    0x10(%rax),%rsi
mov    %r12,(%rsp)
lea    0x30(%rax),%r9
lea    0x28(%rax),%r8
callq  *0x8(%rbp)
test   %eax,%eax
mov    %rbx,%rdi
jne    58 <gsl_wavelet_alloc+0x58>
add    $0x10,%rsp
mov    %rdi,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
callq  5d <gsl_wavelet_alloc+0x5d>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    $0x2e,%edx
mov    $0x0,%esi
callq  76 <gsl_wavelet_alloc+0x76>
xor    %edi,%edi
jmp    49 <gsl_wavelet_alloc+0x49>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
mov    $0x8,%ecx
mov    $0x23,%edx
mov    $0x0,%esi
callq  99 <gsl_wavelet_alloc+0x99>
xor    %edi,%edi
jmp    49 <gsl_wavelet_alloc+0x49>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_wavelet_alloc (const gsl_wavelet_type * T, size_t k)
{
  int status;
  gsl_wavelet *w = (gsl_wavelet *) malloc (sizeof (gsl_wavelet));
  if (w == ((void *)0))
    {
      do { gsl_error ("failed to allocate space for wavelet struct",
 "wavelet.c"
      ,
 35
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                   ;
    };
  w->type = T;
  status = (T->init) (&(w->h1), &(w->g1), &(w->h2), &(w->g2),
                      &(w->nc), &(w->offset), k);
  if (status)
    {
      free (w);
      do { gsl_error ("invalid wavelet member", "wavelet.c", 46, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return w;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 4
9 5
10 4
11 5
12 14
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 17
22 17
23 17
24 23
25 23
26 23
27 23
28 23
29 23
30 23
31 19
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 7
41 7
42 7
43 7
44 7
45 11
46 11
47 11
<<<sep_out_sample>>>
test   %esi,%esi
js     2f40 <ea_backward_kill_line+0x30>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 2f1e <ea_backward_kill_line+0xe>
mov    0x0(%rip),%edi        # 2f24 <ea_backward_kill_line+0x14>
callq  350 <ea_kill_text>
mov    0x0(%rip),%eax        # 2f2f <ea_backward_kill_line+0x1f>
mov    %eax,0x0(%rip)        # 2f35 <ea_backward_kill_line+0x25>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%esi        # 2f46 <ea_backward_kill_line+0x36>
mov    0x0(%rip),%edi        # 2f4c <ea_backward_kill_line+0x3c>
jmpq   350 <ea_kill_text>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ea_backward_kill_line (WINDOW *window, int count)
{
  if (count < 0)
    ea_kill_text (input_line_point, input_line_end);
  else
    {
      ea_kill_text (input_line_point, input_line_beg);
      input_line_point = input_line_beg;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 7
5 7
6 7
7 8
8 8
9 10
10 10
11 10
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x38,%rsp
lea    0x20(%rsp),%rsi
lea    0x28(%rsp),%rdi
movsd  %xmm0,(%rsp)
movapd %xmm1,%xmm0
callq  372c <gsl_complex_sinh+0x1c>
movsd  0x20(%rsp),%xmm2
movsd  0x28(%rsp),%xmm3
movsd  (%rsp),%xmm0
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x18(%rsp)
callq  374e <gsl_complex_sinh+0x3e>
movsd  %xmm0,0x8(%rsp)
movsd  (%rsp),%xmm0
callq  375e <gsl_complex_sinh+0x4e>
movapd %xmm0,%xmm1
movsd  0x8(%rsp),%xmm0
mulsd  0x18(%rsp),%xmm1
mulsd  0x10(%rsp),%xmm0
add    $0x38,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_complex_sinh (gsl_complex a)
{
  double R = ((a).dat[0]), I = ((a).dat[1]);
  gsl_complex z;
  do {(&z)->dat[0]=(sinh (R) * cos (I)); (&z)->dat[1]=(cosh (R) * sin (I));} while(0);
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 5
20 7
21 7
22 7
<<<sep_out_sample>>>
mov    0x260(%rdi),%rax
mov    0x8c(%rdi),%edx
movl   $0x0,0x48(%rax)
mov    %edx,0x50(%rax)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  upsample->spare_full = 0;
  upsample->rows_to_go = cinfo->output_height;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
movsd  (%rcx),%xmm0
test   %r9,%r9
lea    (%r9,%r9,1),%r11
movsd  %xmm0,(%rdi)
je     3f6 <gsl_poly_dd_hermite_init+0x86>
movsd  (%rdx),%xmm0
xor    %eax,%eax
xor    %r10d,%r10d
movsd  %xmm0,(%rsi)
movsd  (%rdx),%xmm0
movsd  %xmm0,0x8(%rsi)
jmp    3ed <gsl_poly_dd_hermite_init+0x7d>
nopl   0x0(%rax)
movsd  (%rdx,%r10,8),%xmm0
test   %r10,%r10
movsd  %xmm0,0x10(%rsi,%rax,2)
movsd  (%rdx,%r10,8),%xmm0
movsd  %xmm0,0x18(%rsi,%rax,2)
je     3e9 <gsl_poly_dd_hermite_init+0x79>
movsd  (%rcx,%r10,8),%xmm0
movsd  (%rdx,%r10,8),%xmm1
subsd  (%rcx,%rax,1),%xmm0
subsd  (%rdx,%rax,1),%xmm1
divsd  %xmm1,%xmm0
movsd  %xmm0,0x10(%rdi,%rax,2)
movsd  (%r8,%rax,1),%xmm0
movsd  %xmm0,0x8(%rdi,%rax,2)
add    $0x8,%rax
add    $0x1,%r10
cmp    %r9,%r10
jne    3a0 <gsl_poly_dd_hermite_init+0x30>
movsd  -0x8(%r8,%r9,8),%xmm0
cmp    $0x2,%r11
movsd  %xmm0,-0x8(%rdi,%r11,8)
jbe    464 <gsl_poly_dd_hermite_init+0xf4>
lea    -0x1(%r11),%r8
lea    -0x10(%rsi),%rcx
mov    $0x2,%edx
nopw   0x0(%rax,%rax,1)
cmp    %r8,%rdx
mov    %r8,%rax
ja     457 <gsl_poly_dd_hermite_init+0xe7>
nopl   0x0(%rax,%rax,1)
movsd  (%rdi,%rax,8),%xmm0
movsd  (%rsi,%rax,8),%xmm1
subsd  -0x8(%rdi,%rax,8),%xmm0
subsd  (%rcx,%rax,8),%xmm1
divsd  %xmm1,%xmm0
movsd  %xmm0,(%rdi,%rax,8)
sub    $0x1,%rax
cmp    %rdx,%rax
jae    430 <gsl_poly_dd_hermite_init+0xc0>
add    $0x1,%rdx
sub    $0x8,%rcx
cmp    %r11,%rdx
jne    420 <gsl_poly_dd_hermite_init+0xb0>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_poly_dd_hermite_init (double dd[], double za[], const double xa[], const double ya[],
                          const double dya[], const size_t size)
{
  const size_t N = 2 * size;
  size_t i, j;
  dd[0] = ya[0];
  for (j = 0; j < size; ++j)
    {
      za[2*j] = xa[j];
      za[2*j + 1] = xa[j];
      if (j != 0)
        {
          dd[2*j] = (ya[j] - ya[j - 1]) / (xa[j] - xa[j - 1]);
          dd[2*j - 1] = dya[j - 1];
        }
    }
  dd[N - 1] = dya[size - 1];
  for (i = 2; i < N; i++)
    {
      for (j = N - 1; j >= i; j--)
        {
          dd[j] = (dd[j] - dd[j - 1]) / (za[j] - za[j - i]);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 7
3 4
4 6
5 7
6 9
7 10
8 7
9 9
10 10
11 10
12 10
13 10
14 9
15 11
16 9
17 10
18 10
19 11
20 13
21 13
22 13
23 13
24 13
25 13
26 14
27 14
28 14
29 7
30 7
31 7
32 17
33 18
34 17
35 18
36 18
37 18
38 18
39 18
40 20
41 20
42 20
43 20
44 22
45 22
46 22
47 22
48 22
49 22
50 20
51 20
52 20
53 18
54 18
55 18
56 18
57 26
58 26
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rsi,%r13
xor    %esi,%esi
push   %r12
mov    %rdx,%r12
mov    $0x0,%edx
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    %rcx,0x8(%rsp)
callq  2b5 <pair_table_map+0x25>
mov    %rax,%r15
mov    (%rax),%rax
test   %rax,%rax
je     305 <pair_table_map+0x75>
test   %r12,%r12
je     320 <pair_table_map+0x90>
lea    0x8(%r15),%r14
mov    %r15,%rbx
xor    %ebp,%ebp
xchg   %ax,%ax
mov    0x8(%rax),%rsi
mov    (%rax),%rdi
callq  *%r12
test   %eax,%eax
je     2f5 <pair_table_map+0x65>
mov    (%rbx),%rax
mov    %ebp,%edi
add    $0x1,%ebp
mov    0x8(%rsp),%rcx
mov    0x8(%rax),%rdx
mov    (%rax),%rsi
callq  *%r13
mov    %r14,%rbx
add    $0x8,%r14
mov    -0x8(%r14),%rax
test   %rax,%rax
jne    2d0 <pair_table_map+0x40>
add    $0x18,%rsp
mov    %r15,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   31b <pair_table_map+0x8b>
nopl   0x0(%rax,%rax,1)
xor    %ebx,%ebx
nopw   0x0(%rax,%rax,1)
mov    %ebx,%edi
add    $0x1,%rbx
mov    0x8(%rax),%rdx
mov    (%rax),%rsi
mov    0x8(%rsp),%rcx
callq  *%r13
mov    (%r15,%rbx,8),%rax
test   %rax,%rax
jne    328 <pair_table_map+0x98>
jmp    305 <pair_table_map+0x75>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pair_table_map (struct pair_htable * table,
  pair_ht_map_fn_t map_fn,
  pair_ht_select_fn_t select_fn,
  void const * arg)
{
  int i, num = 0;
  struct pair ** entries;
  entries = (struct pair **)
    hash_dump (table, ((void *)0),
        (hash_cmp_func_t) pair_hash_qcmp);
  for (i = 0 ; entries[i] ; i++) {
    if (!select_fn
 || select_fn (entries[i]-> key, entries[i]->value))
      {
 map_fn (num, entries[i]-> key, entries[i]->value, arg);
 num++;
      }
  }
  free (entries);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 8
6 5
7 5
8 8
9 5
10 5
11 5
12 5
13 8
14 8
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 6
23 6
24 13
25 13
26 13
27 13
28 13
29 13
30 15
31 16
32 15
33 15
34 15
35 15
36 11
37 11
38 11
39 11
40 11
41 20
42 19
43 20
44 20
45 20
46 20
47 20
48 20
49 19
50 19
51 11
52 11
53 15
54 15
55 15
56 15
57 15
58 15
59 11
60 11
61 11
62 11
63 11
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     190a <lreply+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rbx
mov    $0x0,%edi
mov    %ebp,%esi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  1942 <lreply+0x92>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  194f <lreply+0x9f>
mov    $0x0,%edi
callq  1959 <lreply+0xa9>
mov    0x0(%rip),%rdi        # 1960 <lreply+0xb0>
callq  1965 <lreply+0xb5>
mov    0x0(%rip),%eax        # 196b <lreply+0xbb>
test   %eax,%eax
je     19bb <lreply+0x10b>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  1982 <lreply+0xd2>
lea    0xf0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    $0x7,%edi
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  19bb <lreply+0x10b>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lreply (int n, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  printf ("%d- ", n);
  vprintf (fmt, ap);
  __builtin_va_end(ap);
  printf ("\r\n");
  fflush (stdout);
  if (debug)
    {
      syslog (7, "<--- %d- ", n);
      __builtin_va_start(ap,fmt);
      vsyslog (7, fmt, ap);
      __builtin_va_end(ap);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 2
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 5
29 5
30 6
31 6
32 6
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 12
41 12
42 12
43 12
44 12
45 13
46 14
47 14
48 14
49 13
50 13
51 13
52 13
53 13
54 14
55 17
56 17
57 17
58 17
59 17
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remote_setup (void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    (%rsi),%rax
cmp    $0xffffffffffffffff,%rax
je     96 <min_timercmp+0x26>
mov    (%rdi),%rdx
cmp    %rdx,%rax
setl   %cl
cmp    %rdx,%rax
je     a0 <min_timercmp+0x30>
test   %cl,%cl
je     96 <min_timercmp+0x26>
mov    %rax,(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x8(%rdi)
repz retq 
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rcx
cmp    %rcx,0x8(%rdi)
setg   %cl
jmp    87 <min_timercmp+0x17>
nopl   (%rax)
<<<sep_in_sample>>>
min_timercmp (struct timeval *tv1, struct timeval *tv2)
{
  if (tv2->tv_sec == -1)
    return;
  if ((((tv1)->tv_sec == (tv2)->tv_sec) ? ((tv1)->tv_usec > (tv2)->tv_usec) : ((tv1)->tv_sec > (tv2)->tv_sec))) {
    tv1->tv_sec = tv2->tv_sec;
    tv1->tv_usec = tv2->tv_usec;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 7
13 7
14 7
15 7
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   1a <cdio_get_default_device_netbsd+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_default_device_netbsd()
{
  return strdup("/dev/rcd0c");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 517 <GetVarName+0x7>
cmpb   $0x0,(%rax)
je     542 <GetVarName+0x32>
cmp    %rdi,0x0(%rip)        # 523 <GetVarName+0x13>
je     547 <GetVarName+0x37>
mov    $0x0,%edx
jmp    536 <GetVarName+0x26>
nopl   0x0(%rax)
cmp    %rdi,0x10(%rdx)
je     550 <GetVarName+0x40>
add    $0x18,%rdx
mov    (%rdx),%rax
cmpb   $0x0,(%rax)
jne    530 <GetVarName+0x20>
mov    $0x0,%eax
repz retq 
nopl   0x0(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetVarName (HVAR hvar)
{
static char szInvalid[] = "InvalidVariable?";
  PVMMAPSTRCT pvm = vrgvmGlo;
  while (*pvm->szName && hvar != pvm->hvar)
    pvm++;
  return (*pvm->szName ? pvm->szName : szInvalid);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 4
7 4
8 4
9 5
10 5
11 6
12 5
13 5
14 5
15 7
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
mov    $0x34,%edx
mov    %edi,%ebp
mov    $0x0,%esi
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  1c <hash_create+0x1c>
test   %ebp,%ebp
mov    %rax,%rbx
je     78 <hash_create+0x78>
movslq %ebp,%rdi
mov    $0x39,%edx
mov    $0x0,%esi
shl    $0x3,%rdi
callq  39 <hash_create+0x39>
test   %ebp,%ebp
mov    %rax,(%rbx)
mov    %ebp,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    %rax,%rcx
jle    6b <hash_create+0x6b>
xor    %edx,%edx
jmp    5b <hash_create+0x5b>
nopl   0x0(%rax)
mov    (%rbx),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %edx,%ebp
jg     58 <hash_create+0x58>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x400,%edi
callq  8c <hash_create+0x8c>
mov    $0x80,%ebp
mov    %rax,(%rbx)
movl   $0x80,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    %rax,%rcx
jmp    4d <hash_create+0x4d>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_create (buckets)
     int buckets;
{
  HASH_TABLE *new_table;
  register int i;
  new_table = (HASH_TABLE *)sh_xmalloc((sizeof (HASH_TABLE)), "hashlib.c", 52);
  if (buckets == 0)
    buckets = 128;
  new_table->bucket_array =
    (BUCKET_CONTENTS **)sh_xmalloc((buckets * sizeof (BUCKET_CONTENTS *)), "hashlib.c", 57);
  new_table->nbuckets = buckets;
  new_table->nentries = 0;
  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)((void *)0);
  return (new_table);
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 6
5 6
6 3
7 3
8 6
9 7
10 6
11 7
12 10
13 10
14 10
15 10
16 10
17 13
18 9
19 11
20 12
21 13
22 13
23 3
24 3
25 3
26 3
27 14
28 14
29 13
30 13
31 16
32 16
33 16
34 16
35 16
36 16
37 10
38 10
39 10
40 10
41 8
42 9
43 11
44 12
45 12
46 12
47 12
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    58f8 <gsl_matrix_float_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  591a <gsl_matrix_float_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_const_column (const gsl_matrix_float * m, const size_t j)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %r15
mov    %r8,%rax
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
xor    %edx,%edx
div    %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    0x50(%rsp),%r13
test   %rdx,%rdx
jne    90 <nettle_cbc_encrypt+0x90>
mov    %r8,%r14
mov    %rsi,%r15
mov    %rcx,%r12
sub    %rbx,%r14
test   %r8,%r8
mov    %r9,%rbp
jne    43 <nettle_cbc_encrypt+0x43>
jmp    81 <nettle_cbc_encrypt+0x81>
xchg   %ax,%ax
mov    %rax,%r14
mov    %r13,%rsi
mov    %rbx,%rdx
mov    %r12,%rdi
callq  51 <nettle_cbc_encrypt+0x51>
mov    %rbp,%rdx
mov    %r12,%rcx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
add    %rbx,%r13
callq  *%r15
mov    %rbp,%rsi
mov    %rbx,%rdx
mov    %r12,%rdi
callq  73 <nettle_cbc_encrypt+0x73>
mov    %r14,%rax
add    %rbx,%rbp
sub    %rbx,%rax
test   %r14,%r14
jne    40 <nettle_cbc_encrypt+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
lea    0x0(%rip),%rcx        # 97 <nettle_cbc_encrypt+0x97>
lea    0x0(%rip),%rsi        # 9e <nettle_cbc_encrypt+0x9e>
lea    0x0(%rip),%rdi        # a5 <nettle_cbc_encrypt+0xa5>
mov    $0x35,%edx
callq  af <nettle_cbc_encrypt+0xaf>
nop
<<<sep_in_sample>>>
nettle_cbc_encrypt(const void *ctx, nettle_cipher_func *f,
     size_t block_size, uint8_t *iv,
     size_t length, uint8_t *dst,
     const uint8_t *src)
{
  ((!(length % block_size)) ? (void) (0) : __assert_fail ("!(length % block_size)", "cbc.c", 53, __PRETTY_FUNCTION__));
  for ( ; length; length -= block_size, src += block_size, dst += block_size)
    {
      nettle_memxor(iv, src, block_size);
      f(ctx, block_size, dst, iv);
      memcpy(iv, dst, block_size);
    }
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 7
35 10
36 11
37 11
38 11
39 11
40 11
41 7
42 7
43 7
44 7
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 13
53 6
54 6
55 6
56 6
57 6
58 6
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
ucomisd %xmm0,%xmm2
ja     c0 <gsl_ran_rayleigh_pdf+0x60>
movapd %xmm0,%xmm2
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm0        # 7a <gsl_ran_rayleigh_pdf+0x1a>
divsd  %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
xorpd  %xmm2,%xmm0
movsd  %xmm2,(%rsp)
mulsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # 99 <gsl_ran_rayleigh_pdf+0x39>
callq  9e <gsl_ran_rayleigh_pdf+0x3e>
movsd  (%rsp),%xmm2
movsd  0x8(%rsp),%xmm1
movapd %xmm0,%xmm3
add    $0x18,%rsp
divsd  %xmm1,%xmm2
movapd %xmm2,%xmm0
mulsd  %xmm3,%xmm0
retq   
xchg   %ax,%ax
movapd %xmm2,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ran_rayleigh_pdf (const double x, const double sigma)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      double u = x / sigma ;
      double p = (u / sigma) * exp(-u * u / 2.0) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 9
5 2
6 10
7 9
8 9
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 13
18 10
19 10
20 10
21 13
22 13
23 5
24 5
25 5
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 396 <write_behind+0x6>
push   %r14
push   %r13
movslq %edx,%rax
mov    %rax,%rcx
push   %r12
shl    $0x9,%rcx
lea    (%rcx,%rax,8),%rax
push   %rbp
mov    0x0(%rax),%r14d
push   %rbx
lea    0x0(%rax),%rbp
cmp    $0xffffffff,%r14d
jl     460 <write_behind+0xd0>
movl   $0xfffffffe,0x0(%rax)
xor    %eax,%eax
test   %edx,%edx
sete   %al
add    $0x8,%rbp
test   %r14d,%r14d
mov    %eax,0x0(%rip)        # 3e2 <write_behind+0x52>
jle    48b <write_behind+0xfb>
test   %esi,%esi
mov    %rdi,%r13
je     470 <write_behind+0xe0>
lea    -0x1(%r14),%eax
mov    0x0(%rip),%ecx        # 3fd <write_behind+0x6d>
lea    0x1(%rbp,%rax,1),%r12
jmp    40a <write_behind+0x7a>
nopl   0x0(%rax)
mov    %ebx,%ecx
add    $0x1,%rbp
cmp    $0xd,%ecx
movsbl -0x1(%rbp),%ebx
jne    420 <write_behind+0x90>
cmp    $0xa,%ebx
je     448 <write_behind+0xb8>
test   %ebx,%ebx
je     42a <write_behind+0x9a>
mov    %r13,%rsi
mov    %ebx,%edi
callq  42a <write_behind+0x9a>
cmp    %r12,%rbp
mov    %ebx,0x0(%rip)        # 433 <write_behind+0xa3>
jne    408 <write_behind+0x78>
mov    %r14d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
mov    $0x1,%edx
mov    $0xffffffffffffffff,%rsi
mov    %r13,%rdi
callq  45c <write_behind+0xcc>
jmp    420 <write_behind+0x90>
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
callq  475 <write_behind+0xe5>
movslq %r14d,%rdx
mov    %rbp,%rsi
mov    %eax,%edi
callq  482 <write_behind+0xf2>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
mov    $0xffffffff,%eax
jmp    438 <write_behind+0xa8>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_behind (FILE * file, int convert)
{
  char *buf;
  int count;
  register int ct;
  register char *p;
  register int c;
  struct bf *b;
  struct tftphdr *dp;
  b = &bfs[nextone];
  if (b->counter < -1)
    return 0;
  count = b->counter;
  b->counter = -2;
  dp = (struct tftphdr *) b->buf;
  nextone = !nextone;
  buf = dp->th_u1.th_u2.tu_data;
  if (count <= 0)
    return -1;
  if (convert == 0)
    return write (fileno (file), buf, count);
  p = buf;
  ct = count;
  while (ct--)
    {
      c = *p++;
      if (prevchar == '\r')
 {
   if (c == '\n')
     fseeko (file, -1, 1);
   else if (c == '\0')
     goto skipit;
 }
      _IO_putc (c, file);
    skipit:
      prevchar = c;
    }
  return count;
}
<<<sep_in_sample>>>
1 10
2 2
3 2
4 10
5 10
6 2
7 10
8 10
9 2
10 11
11 2
12 10
13 11
14 11
15 14
16 16
17 16
18 16
19 17
20 18
21 16
22 18
23 20
24 20
25 20
26 20
27 20
28 20
29 20
30 20
31 26
32 26
33 27
34 26
35 27
36 29
37 29
38 31
39 31
40 34
41 34
42 34
43 24
44 36
45 24
46 24
47 39
48 39
49 39
50 39
51 39
52 39
53 39
54 30
55 30
56 30
57 30
58 30
59 30
60 39
61 39
62 39
63 39
64 12
65 39
66 39
67 39
68 21
69 21
70 21
71 21
72 21
73 39
74 39
75 39
76 39
77 39
78 39
79 19
80 19
81 19
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jb     e40 <gsl_spmatrix_compare_idx+0x20>
mov    $0x1,%eax
ja     e48 <gsl_spmatrix_compare_idx+0x28>
xor    %edx,%edx
cmp    %rcx,%rsi
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopl   (%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spmatrix_compare_idx(const size_t ia, const size_t ja,
                         const size_t ib, const size_t jb)
{
  if (ia < ib)
    return -1;
  else if (ia > ib)
    return 1;
  else
    {
      if (ja < jb)
        return -1;
      else if (ja > jb)
        return 1;
      else
        return 0;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 12
12 5
13 5
14 17
15 17
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
jg     3a2f <pad_archive+0x6f>
jmpq   3a88 <pad_archive+0xc8>
nopl   (%rax)
test   $0x2,%dil
jne    3a58 <pad_archive+0x98>
test   $0x4,%dil
jne    3a70 <pad_archive+0xb0>
mov    %esi,%ecx
mov    %rbp,%rax
shr    $0x3,%ecx
test   $0x4,%sil
rep stos %rax,%es:(%rdi)
je     3a03 <pad_archive+0x43>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     3a13 <pad_archive+0x53>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%esi
je     3a1b <pad_archive+0x5b>
movb   $0x0,(%rdi)
mov    %r8,%rdi
sub    $0x200,%rbx
callq  3a2a <pad_archive+0x6a>
test   %rbx,%rbx
jle    3a88 <pad_archive+0xc8>
callq  3a34 <pad_archive+0x74>
test   $0x1,%al
mov    %rax,%r8
mov    %rax,%rdi
mov    $0x200,%esi
je     39d8 <pad_archive+0x18>
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
mov    $0x1ff,%si
test   $0x2,%dil
je     39de <pad_archive+0x1e>
nopl   0x0(%rax)
xor    %edx,%edx
add    $0x2,%rdi
sub    $0x2,%esi
mov    %dx,-0x2(%rdi)
test   $0x4,%dil
je     39e8 <pad_archive+0x28>
nop
movl   $0x0,(%rdi)
sub    $0x4,%esi
add    $0x4,%rdi
jmpq   39e8 <pad_archive+0x28>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
pad_archive (off_t size_left)
{
  union block *blk;
  while (size_left > 0)
    {
      blk = find_next_block ();
      memset (blk->buffer, 0, 512);
      set_next_block_after (blk);
      size_left -= 512;
    }
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 8
31 9
32 8
33 4
34 4
35 6
36 7
37 6
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
58 7
59 11
60 11
61 11
62 11
63 11
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e <integer_expected_error+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  19 <argv+0x9>
<<<sep_in_sample>>>
integer_expected_error (pch)
     char *pch;
{
  test_syntax_error (gettext("%s: integer expression expected"), pch);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
test   %esi,%esi
mov    $0x0,%eax
mov    0x0(%rip),%rdi        # 17 <mu_debug_stderr_printer+0x17>
mov    $0x0,%esi
cmovne %rcx,%rax
mov    %rdx,%rcx
mov    %rax,%rdx
xor    %eax,%eax
callq  2d <mu_debug_stderr_printer+0x2d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_debug_stderr_printer (void *unused, mu_log_level_t level, const char *str)
{
  fprintf (stderr, "%s: %s",
    (level == 0) ? "ERROR" : "DEBUG",
    str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 7
13 7
14 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     51f <__osip_nict_free+0x4f>
xor    %ecx,%ecx
mov    $0x0,%edi
xor    %eax,%eax
mov    $0x0,%r8d
mov    $0x5,%edx
mov    $0x93,%esi
callq  4f7 <__osip_nict_free+0x27>
mov    0x48(%rbx),%rdi
test   %rdi,%rdi
je     50e <__osip_nict_free+0x3e>
mov    0x0(%rip),%rax        # 507 <__osip_nict_free+0x37>
test   %rax,%rax
je     538 <__osip_nict_free+0x68>
callq  *%rax
mov    0x0(%rip),%rax        # 515 <__osip_nict_free+0x45>
mov    %rbx,%rdi
test   %rax,%rax
je     528 <__osip_nict_free+0x58>
callq  *%rax
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  52d <__osip_nict_free+0x5d>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  53d <__osip_nict_free+0x6d>
nopl   (%rax)
jmp    50e <__osip_nict_free+0x3e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_nict_free (osip_nict_t * nict)
{
  if (nict == ((void *)0))
    return 0;
  osip_trace ("nict.c", 147, TRACE_LEVEL5, ((void *)0), "free nict resource\n");
  { if (nict->destination!=((void *)0)) { if (osip_free_func) osip_free_func(nict->destination); else free(nict->destination);} };
  { if (nict!=((void *)0)) { if (osip_free_func) osip_free_func(nict); else free(nict);} };
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 9
25 9
26 9
27 9
28 7
29 9
30 9
31 9
32 9
33 6
34 6
35 6
36 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
jmpq   cd0 <cmdline_parser_internal.constprop.3>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cmdline_parser_ext (int argc, char * const *argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, ((void *)0));
  return result;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
movsd  %xmm0,(%rdi)
movsd  %xmm1,0x8(%rdi)
movsd  %xmm2,0x10(%rdi)
retq   
nop
<<<sep_in_sample>>>
DISSetDRThresholds(dis_dr_parameters * dr, double time, double location, double orientation)
{
 dr->timeThreshold = time;
 dr->locationThreshold = location;
 dr->orientationThreshold = orientation;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 15 <__gmpz_init+0x15>
movl   $0x0,0x4(%rbx)
mov    %rax,0x8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmpz_init (mpz_ptr x)
{
  ((x)->_mp_alloc) = 1;
  ((x)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  ((x)->_mp_size) = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
8 6
9 6
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # f27 <meta1get_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1get_out (void)
{
        return meta1out;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x8,%esi
mov    %rbx,%rdx
callq  c58 <gsl_block_complex_float_fwrite+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     c7a <gsl_block_complex_float_fwrite+0x3a>
mov    $0x30,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c75 <gsl_block_complex_float_fwrite+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_complex_float_fwrite (FILE * stream, const gsl_block_complex_float * b)
{
  size_t n = b->size ;
  float * data = b->data ;
  size_t items = fwrite (data, 2 * sizeof (float), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "fwrite_source.c", 48, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    0x20(%rsi),%eax
cmp    %eax,0x20(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sys_compare_gid (struct stat *a, struct stat *b)
{
  return a->st_gid == b->st_gid;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     956 <parse_error+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
test   %rdi,%rdi
mov    %rsi,%rcx
mov    $0x0,%esi
lea    0x8(%rsp),%r8
cmovne %rdi,%rsi
xor    %edx,%edx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    0x0(%rip),%rdi        # 995 <parse_error+0x95>
mov    %rax,0x18(%rsp)
callq  *0x0(%rip)        # 9a0 <parse_error+0xa0>
addl   $0x1,0x0(%rip)        # 9a7 <parse_error+0xa7>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
parse_error (struct rc_loc *loc, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  rc_error_printer (rc_error_printer_data, loc ? loc : &rc_locus, ((void *)0),
      fmt, ap);
  __builtin_va_end(ap);
  error_count++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 2
19 5
20 5
21 5
22 5
23 4
24 4
25 4
26 4
27 5
28 4
29 5
30 8
31 9
32 9
33 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 50 <format_find+0x10>
test   %rdi,%rdi
je     88 <format_find+0x48>
mov    $0x0,%ebx
jmp    6c <format_find+0x2c>
nopl   0x0(%rax)
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     88 <format_find+0x48>
mov    %rbp,%rsi
callq  74 <format_find+0x34>
test   %eax,%eax
jne    60 <format_find+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
format_find (const char *name)
{
  struct format *frm;
  for (frm = formats; frm->name; frm++)
    {
      if (strcmp (frm->name, name) == 0)
 return frm;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 6
16 6
17 6
18 6
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 9
27 10
28 10
29 10
30 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     156 <cdio_audio_read_subchannel+0x26>
mov    0x28(%rdi),%rax
test   %rax,%rax
je     150 <cdio_audio_read_subchannel+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_audio_read_subchannel (CdIo_t *p_cdio, cdio_subchannel_t *p_subchannel)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_read_subchannel) {
    return p_cdio->op.audio_read_subchannel(p_cdio->env, p_subchannel);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
13 3
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rax
mov    0x0(%rip),%rdi        # 112c <delete_handler+0xc>
mov    (%rax),%rax
mov    0x30(%rax),%rsi
mov    0x38(%rax),%rdx
callq  113c <delete_handler+0x1c>
test   %eax,%eax
je     1170 <delete_handler+0x50>
mov    0x0(%rip),%edi        # 1146 <delete_handler+0x26>
cmp    $0xf,%edi
je     1178 <delete_handler+0x58>
callq  1150 <delete_handler+0x30>
mov    $0x0,%esi
mov    %rax,%rbx
mov    $0x0,%edi
callq  1162 <delete_handler+0x42>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   1170 <delete_handler+0x50>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
mov    $0x0,%esi
callq  1187 <delete_handler+0x67>
pop    %rbx
mov    %rax,%rdi
xor    %eax,%eax
jmpq   1192 <delete_handler+0x72>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delete_handler (struct handler_param *param)
{
  if (gdbm_delete (gdbm_file, param->argv[0]->v.dat) != 0)
    {
      if (gdbm_errno == 15)
 terror (dgettext ("gdbm", "Item not found"));
      else
 terror (dgettext ("gdbm", "Can't delete: %s"), gdbm_strerror (gdbm_errno));
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 5
12 5
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 8
23 10
24 10
25 10
26 6
27 6
28 6
29 10
30 6
31 6
32 6
33 6
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  212 <f_long+0x12>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_long (FILE *fp, void *ptr, int size) { fprintf (fp, "%ld", *(long*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cgst_preloop(const void * vtrust_state, void * vstate)
{
  (void)vtrust_state;
  (void)vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    260 <__ram_set_re_source+0x50>
mov    %rsi,%rbp
mov    $0x8,%esi
callq  22f <__ram_set_re_source+0x1f>
test   %eax,%eax
je     240 <__ram_set_re_source+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0xc0(%rbx),%rax
mov    0x28(%rbx),%rdi
add    $0x8,%rsp
pop    %rbx
mov    %rbp,%rsi
pop    %rbp
lea    0x38(%rax),%rdx
jmpq   25d <__ram_set_re_source+0x4d>
nopl   (%rax)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   279 <__ram_set_re_source+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__ram_set_re_source(dbp, re_source)
 DB *dbp;
 const char *re_source;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_re_source", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x08)) != 0) return (__ret); };
 t = dbp->bt_internal;
 return (CDB___os_strdup(dbp->dbenv, re_source, &t->re_source));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 10
13 10
14 10
15 10
16 10
17 9
18 9
19 10
20 10
21 9
22 10
23 9
24 9
25 9
26 6
27 10
28 6
29 10
30 10
31 6
32 6
33 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # f47 <meta1get_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1get_text (void)
{
        return meta1text;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    $0x1,%ecx
jmpq   7baa <gsl_fft_complex_radix2_dif_backward+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_radix2_dif_backward (gsl_complex_packed_array data,
                                               const size_t stride,
                                               const size_t n)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_radix2_dif_transform (data, stride, n, sign);
  return status;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    0x0(%rip),%rdi        # 75c <variable_by_name+0xc>
push   %rbp
test   %rdi,%rdi
push   %rbx
je     7a8 <variable_by_name+0x58>
mov    $0x0,%ebx
xor    %ebp,%ebp
jmp    780 <variable_by_name+0x30>
nopl   0x0(%rax)
add    $0x28,%rbx
mov    -0x28(%rbx),%rdi
add    $0x1,%ebp
test   %rdi,%rdi
je     7a8 <variable_by_name+0x58>
mov    %r12,%rsi
callq  788 <variable_by_name+0x38>
test   %eax,%eax
jne    770 <variable_by_name+0x20>
movslq %ebp,%rbp
lea    0x0(%rbp,%rbp,4),%rax
pop    %rbx
pop    %rbp
lea    0x0(,%rax,8),%rax
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
variable_by_name (char *name)
{
  int i;
  for (i = 0; info_variables[i].name; i++)
    if (strcmp (info_variables[i].name, name) == 0)
      break;
  if (!info_variables[i].name)
    return ((void *)0);
  else
    return &info_variables[i];
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 10
22 10
23 11
24 11
25 10
26 11
27 11
28 11
29 11
30 11
31 8
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     16e0 <gsl_block_long_double_raw_fscanf+0x80>
shl    $0x4,%rcx
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rcx,%r14
xor    %ebp,%ebp
jmp    1694 <gsl_block_long_double_raw_fscanf+0x34>
nopl   (%rax)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     16e0 <gsl_block_long_double_raw_fscanf+0x80>
xor    %eax,%eax
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %r13,%rdi
callq  16a6 <gsl_block_long_double_raw_fscanf+0x46>
fldt   (%rsp)
cmp    $0x1,%eax
fstpt  (%rbx)
je     1688 <gsl_block_long_double_raw_fscanf+0x28>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16c9 <gsl_block_long_double_raw_fscanf+0x69>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
gsl_block_long_double_raw_fscanf (FILE * stream,
                                  long double * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          long double tmp;
          int status = fscanf (stream, "%Lg", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 13
22 13
23 13
24 13
25 13
26 14
27 15
28 14
29 15
30 17
31 17
32 17
33 17
34 17
35 22
36 17
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 22
45 21
46 22
47 22
48 22
49 22
50 22
51 22
52 22
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 77 <close_debugfile+0x7>
jmpq   7c <close_debugfile+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
close_debugfile (void)
{
  fclose (debug_file);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
mov    %edx,%r14d
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %r8d,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
xor    %esi,%esi
sub    $0x10,%rsp
mov    %rsp,%rdi
callq  1235 <__osip_transaction_need_timer_x_event+0x25>
test   %rbp,%rbp
je     1290 <__osip_transaction_need_timer_x_event+0x80>
test   %r14d,%r14d
je     1290 <__osip_transaction_need_timer_x_event+0x80>
mov    (%rbx),%rax
cmp    $0xffffffffffffffff,%rax
je     1290 <__osip_transaction_need_timer_x_event+0x80>
mov    (%rsp),%rdx
cmp    %rdx,%rax
setl   %cl
cmp    %rdx,%rax
je     1278 <__osip_transaction_need_timer_x_event+0x68>
xor    %eax,%eax
test   %cl,%cl
je     1268 <__osip_transaction_need_timer_x_event+0x58>
mov    %r13d,%esi
mov    %r12d,%edi
callq  1268 <__osip_transaction_need_timer_x_event+0x58>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   (%rax)
mov    0x8(%rbx),%rax
cmp    %rax,0x8(%rsp)
setg   %cl
jmp    1257 <__osip_transaction_need_timer_x_event+0x47>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
__osip_transaction_need_timer_x_event (void *xixt, struct timeval * timer, int cond_state, int transactionid, int TIMER_VAL)
{
  struct timeval now;
  osip_gettimeofday (&now, ((void *)0));
  if (xixt == ((void *)0))
    return ((void *)0);
  if (cond_state) {
    if (timer->tv_sec == -1)
      return ((void *)0);
    if ((((&now)->tv_sec == (timer)->tv_sec) ? ((&now)->tv_usec > (timer)->tv_usec) : ((&now)->tv_sec > (timer)->tv_sec)))
      return __osip_event_new (TIMER_VAL, transactionid);
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 4
12 2
13 4
14 4
15 5
16 5
17 7
18 7
19 8
20 8
21 8
22 10
23 10
24 10
25 10
26 10
27 6
28 10
29 10
30 11
31 11
32 11
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 10
42 10
43 10
44 10
45 10
46 14
47 6
48 14
49 14
50 14
51 14
52 14
53 14
54 14
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    (%rdi),%r13
push   %r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r12
movq   %xmm0,-0x20(%rsp)
mov    -0x20(%rsp),%rax
mov    %eax,-0x20(%rsp)
shr    $0x20,%rax
test   %r13,%r13
movss  -0x20(%rsp),%xmm1
mov    %eax,-0x20(%rsp)
movss  -0x20(%rsp),%xmm0
je     1aae <gsl_matrix_complex_float_scale+0x20e>
lea    0x0(,%r12,8),%rax
movaps %xmm1,%xmm7
movaps %xmm0,%xmm6
mov    %rax,-0x20(%rsp)
mov    %r8,%rax
shr    $0x2,%rax
shufps $0x0,%xmm7,%xmm7
mov    %rax,-0x10(%rsp)
shl    $0x2,%rax
test   %rax,%rax
mov    %rax,%rbx
mov    %rax,-0x18(%rsp)
sete   %r15b
cmp    $0x3,%r8
setbe  %al
xor    %r14d,%r14d
or     %al,%r15b
shufps $0x0,%xmm6,%xmm6
cmove  %rbx,%r14
xorps  %xmm5,%xmm5
lea    0x1(%r14),%rbp
lea    0x2(%r14),%rbx
xor    %r10d,%r10d
xor    %esi,%esi
xor    %r9d,%r9d
nop
test   %r8,%r8
je     1a99 <gsl_matrix_complex_float_scale+0x1f9>
test   %r15b,%r15b
mov    0x18(%rdi),%rax
jne    19d0 <gsl_matrix_complex_float_scale+0x130>
lea    (%rax,%r10,1),%rcx
xor    %edx,%edx
xor    %r11d,%r11d
movaps %xmm5,%xmm4
add    $0x1,%r11
movaps %xmm5,%xmm3
movlps (%rcx,%rdx,1),%xmm4
movlps 0x10(%rcx,%rdx,1),%xmm3
movhps 0x8(%rcx,%rdx,1),%xmm4
movhps 0x18(%rcx,%rdx,1),%xmm3
movaps %xmm4,%xmm2
shufps $0xdd,%xmm3,%xmm4
shufps $0x88,%xmm3,%xmm2
movaps %xmm4,%xmm8
movaps %xmm2,%xmm3
mulps  %xmm7,%xmm4
mulps  %xmm7,%xmm3
mulps  %xmm6,%xmm8
mulps  %xmm6,%xmm2
subps  %xmm8,%xmm3
addps  %xmm4,%xmm2
movaps %xmm3,%xmm4
unpckhps %xmm2,%xmm3
unpcklps %xmm2,%xmm4
movlps %xmm3,0x10(%rcx,%rdx,1)
movlps %xmm4,(%rcx,%rdx,1)
movhps %xmm4,0x8(%rcx,%rdx,1)
movhps %xmm3,0x18(%rcx,%rdx,1)
add    $0x20,%rdx
cmp    -0x10(%rsp),%r11
jb     195b <gsl_matrix_complex_float_scale+0xbb>
cmp    -0x18(%rsp),%r8
je     1a99 <gsl_matrix_complex_float_scale+0x1f9>
lea    (%r14,%rsi,1),%rdx
cmp    %rbp,%r8
lea    (%rax,%rdx,8),%rcx
lea    0x4(%rax,%rdx,8),%rdx
movss  (%rcx),%xmm2
movss  (%rdx),%xmm4
movaps %xmm2,%xmm3
movaps %xmm4,%xmm8
mulss  %xmm0,%xmm2
mulss  %xmm1,%xmm3
mulss  %xmm0,%xmm8
mulss  %xmm1,%xmm4
subss  %xmm8,%xmm3
addss  %xmm4,%xmm2
movss  %xmm3,(%rcx)
movss  %xmm2,(%rdx)
jbe    1a99 <gsl_matrix_complex_float_scale+0x1f9>
lea    0x0(%rbp,%rsi,1),%rdx
cmp    %rbx,%r8
lea    (%rax,%rdx,8),%rcx
lea    0x4(%rax,%rdx,8),%rdx
movss  (%rcx),%xmm2
movss  (%rdx),%xmm4
movaps %xmm2,%xmm3
movaps %xmm4,%xmm8
mulss  %xmm0,%xmm2
mulss  %xmm1,%xmm3
mulss  %xmm0,%xmm8
mulss  %xmm1,%xmm4
subss  %xmm8,%xmm3
addss  %xmm4,%xmm2
movss  %xmm3,(%rcx)
movss  %xmm2,(%rdx)
jbe    1a99 <gsl_matrix_complex_float_scale+0x1f9>
lea    (%rsi,%rbx,1),%rcx
lea    (%rax,%rcx,8),%rdx
lea    0x4(%rax,%rcx,8),%rax
movss  (%rdx),%xmm2
movss  (%rax),%xmm4
movaps %xmm2,%xmm3
movaps %xmm4,%xmm8
mulss  %xmm0,%xmm2
mulss  %xmm1,%xmm3
mulss  %xmm0,%xmm8
mulss  %xmm1,%xmm4
subss  %xmm8,%xmm3
addss  %xmm4,%xmm2
movss  %xmm3,(%rdx)
movss  %xmm2,(%rax)
add    $0x1,%r9
add    %r12,%rsi
add    -0x20(%rsp),%r10
cmp    %r13,%r9
jne    1940 <gsl_matrix_complex_float_scale+0xa0>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
xor    %eax,%eax
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_scale (gsl_matrix_complex_float * a, const gsl_complex_float x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  float xr = ((x).dat[0]);
  float xi = ((x).dat[1]);
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          const size_t aij = 2 * (i * tda + j);
          float ar = a->data[aij];
          float ai = a->data[aij + 1];
          a->data[aij] = ar * xr - ai * xi;
          a->data[aij + 1] = ar * xi + ai * xr;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 2
8 4
9 5
10 2
11 2
12 7
13 8
14 9
15 7
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 14
39 11
40 11
41 11
42 11
43 9
44 9
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 14
54 14
55 14
56 14
57 14
58 14
59 14
60 14
61 14
62 14
63 16
64 16
65 17
66 16
67 16
68 17
69 16
70 17
71 17
72 17
73 17
74 17
75 17
76 17
77 17
78 17
79 17
80 17
81 17
82 17
83 13
84 11
85 14
86 15
87 14
88 15
89 16
90 16
91 17
92 16
93 16
94 17
95 16
96 17
97 16
98 17
99 11
100 13
101 11
102 14
103 15
104 14
105 15
106 16
107 16
108 17
109 16
110 16
111 17
112 16
113 17
114 16
115 17
116 11
117 13
118 14
119 15
120 14
121 15
122 16
123 16
124 17
125 16
126 16
127 17
128 16
129 17
130 16
131 17
132 9
133 9
134 9
135 9
136 9
137 21
138 21
139 21
140 21
141 21
142 21
143 21
144 21
145 21
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
mov    %rdi,%rsi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  8f1 <read_fatal+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_fatal (char const *name)
{
  call_arg_fatal ("read", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
cmp    $0x1,%esi
ja     740 <CDB___db_joinchk+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   750 <CDB___db_joingetchk>
<<<sep_in_sample>>>
CDB___db_joinchk(dbp, flags)
 const DB *dbp;
 u_int32_t flags;
{
 switch (flags) {
 case 0:
 case 0x0001:
  break;
 default:
  return (CDB___db_ferr(dbp->dbenv, "DB->join", 0));
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 13
4 13
5 13
6 10
7 10
8 10
9 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
test   %rdx,%rdx
jle    60 <__gmpf_fits_slong_p+0x60>
xor    %eax,%eax
cmp    $0x1,%rdx
movslq 0x4(%rdi),%rcx
mov    0x10(%rdi),%rsi
je     20 <__gmpf_fits_slong_p+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %rcx,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rax
xor    %rcx,%rax
sub    %rdx,%rax
test   %rcx,%rcx
movabs $0x7fffffffffffffff,%rdx
movabs $0x8000000000000000,%rcx
cmovs  %rcx,%rdx
cmp    -0x8(%rsi,%rax,8),%rdx
setae  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
__gmpf_fits_slong_p (mpf_srcptr f)
{
  mp_size_t fs, fn;
  mp_srcptr fp;
  mp_exp_t exp;
  mp_limb_t fl;
  exp = ((f)->_mp_exp);
  if (exp < 1)
    return 1;
  fs = ((f)->_mp_size);
  fp = ((f)->_mp_d);
  fn = ((fs) >= 0 ? (fs) : -(fs));
  if (exp == 1)
    {
      fl = fp[fn-1];
    }
  else
    return 0;
  return fl <= (fs >= 0 ? (mp_limb_t) 9223372036854775807L : - (mp_limb_t) (-9223372036854775807L - 1L));
}
<<<sep_in_sample>>>
1 7
2 8
3 8
4 18
5 13
6 10
7 11
8 13
9 20
10 20
11 12
12 12
13 12
14 12
15 12
16 19
17 19
18 19
19 19
20 19
21 19
22 19
23 19
24 19
25 9
26 20
<<<sep_out_sample>>>
test   %rdi,%rdi
je     34c <mu_body_clear_modified+0xc>
andl   $0xfffeffff,0x20(%rdi)
xor    %eax,%eax
retq   
nop
<<<sep_in_sample>>>
mu_body_clear_modified (mu_body_t body)
{
  if (body)
    body->flags &= ~0x10000;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    %rdx,%rax
shl    $0xd,%rax
mov    %eax,%eax
xor    %rdx,%rax
shl    $0xc,%rdx
and    $0xffffe000,%edx
shr    $0x13,%rax
xor    %rdx,%rax
mov    0x8(%rdi),%rdx
mov    %rax,(%rdi)
lea    0x0(,%rdx,4),%rcx
mov    %ecx,%ecx
xor    %rdx,%rcx
shl    $0x4,%rdx
and    $0xffffff80,%edx
shr    $0x19,%rcx
xor    %rdx,%rcx
lea    0x0(,%rsi,8),%rdx
xor    %rcx,%rax
mov    %rcx,0x8(%rdi)
mov    %edx,%edx
xor    %rsi,%rdx
shl    $0x11,%rsi
shr    $0xb,%rdx
and    $0xffe00000,%esi
xor    %rsi,%rdx
mov    %rdx,0x10(%rdi)
xor    %rdx,%rax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taus_get (void *vstate)
{
  taus_state_t *state = (taus_state_t *) vstate;
  state->s1 = (((state->s1 &4294967294UL) <<12) &0xffffffffUL) ^ ((((state->s1 <<13) &0xffffffffUL)^state->s1) >>19);
  state->s2 = (((state->s2 &4294967288UL) <<4) &0xffffffffUL) ^ ((((state->s2 <<2) &0xffffffffUL)^state->s2) >>25);
  state->s3 = (((state->s3 &4294967280UL) <<17) &0xffffffffUL) ^ ((((state->s3 <<3) &0xffffffffUL)^state->s3) >>11);
  return (state->s1 ^ state->s2 ^ state->s3);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 6
21 7
22 5
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 7
31 8
32 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
__gmpz_limbs_read (mpz_srcptr x)
{
  return ((x)->_mp_d);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   1bd0 <info_node_of_tag_ext>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_node_of_tag (FILE_BUFFER *fb, TAG **tag_ptr)
{
  return info_node_of_tag_ext (fb, tag_ptr, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x0(%rip),%rax        # f <__gmpf_init_set_d+0xf>
movsd  %xmm0,0x8(%rsp)
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 25 <__gmpf_init_set_d+0x25>
movsd  0x8(%rsp),%xmm0
mov    %rax,0x10(%rbx)
add    $0x10,%rsp
mov    %rbx,%rdi
pop    %rbx
jmpq   3c <__gmpf_init_set_d+0x3c>
<<<sep_in_sample>>>
__gmpf_init_set_d (mpf_ptr r, double val)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
  __gmpf_set_d (r, val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 4
7 5
8 5
9 6
10 5
11 7
12 6
13 7
14 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
lea    0x320(%rsi),%rsi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movsd  0x640(%rdi),%xmm0
divsd  0x320(%rsi),%xmm0
movsd  %xmm0,0x640(%rdi)
callq  4120 <divunit+0x30>
test   %eax,%eax
je     4130 <divunit+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
lea    0x320(%rbx),%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   4145 <divunit+0x55>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
divunit(struct unittype *left, struct unittype *right)
{
  int myerr;
  left->factor /= right->factor;
  myerr = moveproduct(left->numerator, right->denominator);
  if (!myerr)
    myerr = moveproduct(left->denominator, right->numerator);
  return myerr;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 4
8 4
9 4
10 5
11 6
12 6
13 9
14 9
15 9
16 9
17 9
18 9
19 7
20 7
21 9
22 9
23 7
24 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 4d37 <rl_macro_dumper+0x7>
xor    %eax,%eax
jmpq   f20 <_rl_macro_dumper_internal.constprop.12>
xchg   %ax,%ax
<<<sep_in_sample>>>
rl_macro_dumper (print_readably)
     int print_readably;
{
  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rdi,%rbx
add    $0x1,%rax
cmp    %rsi,%rax
jb     208 <ds_resize+0x18>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %rsi,0x18(%rdi)
mov    0x28(%rdi),%rdi
callq  215 <ds_resize+0x25>
mov    %rax,0x28(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_resize (struct dstring *string, size_t size)
{
  if (string->len + 1 < size)
    {
      string->size = size;
      string->content = ((char *) xrealloc ((void *) (string->content), sizeof (char) * (size)));
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 8
8 8
9 8
10 5
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 5c2 <make_word_list+0x12>
test   %eax,%eax
jle    5f0 <make_word_list+0x40>
mov    0x0(%rip),%rdx        # 5cd <make_word_list+0x1d>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 5d6 <make_word_list+0x26>
cltq   
mov    (%rdx,%rax,8),%rax
mov    %rbp,0x8(%rax)
mov    %rbx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xaf,%edx
mov    $0x0,%esi
mov    $0x10,%edi
callq  604 <make_word_list+0x54>
mov    %rbp,0x8(%rax)
mov    %rbx,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_word_list (word, wlink)
     WORD_DESC *word;
     WORD_LIST *wlink;
{
  WORD_LIST *temp;
  do { if ((wlcache).nc > 0) { (temp) = (WORD_LIST *)((WORD_LIST **)((wlcache).data))[--(wlcache).nc]; } else (temp) = (WORD_LIST *)sh_xmalloc((sizeof (WORD_LIST)), "make_cmd.c", 175); } while (0);
  temp->word = word;
  temp->next = wlink;
  return (temp);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 7
15 8
16 10
17 10
18 10
19 10
20 10
21 6
22 6
23 6
24 6
25 7
26 8
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   48 <nettle_gcm_camellia128_set_iv+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_camellia128_set_iv (struct gcm_camellia128_ctx *ctx,
   size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,(%rdi)
mov    %rdi,%rbx
je     4c8 <meta_free+0x38>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     4be <meta_free+0x2e>
callq  4ae <meta_free+0x1e>
movq   $0x0,0x18(%rbx)
movq   $0x0,0x8(%rbx)
add    $0x28,%rbx
cmpq   $0x0,(%rbx)
jne    4a0 <meta_free+0x10>
pop    %rbx
retq   
<<<sep_in_sample>>>
meta_free (struct metadef *def)
{
  for (; def->kw; def++)
    {
      if (def->storage)
 {
   free (def->storage);
   def->value = def->storage = ((void *)0);
 }
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 5
7 5
8 5
9 7
10 8
11 8
12 3
13 3
14 3
15 11
16 11
<<<sep_out_sample>>>
sub    $0x48,%rsp
movzbl %r9b,%r9d
movzbl %r8b,%r8d
lea    0x30(%rsp),%rax
mov    %r9d,0x10(%rsp)
mov    %r8d,0x8(%rsp)
mov    %rcx,(%rsp)
xor    %r9d,%r9d
xor    %r8d,%r8d
mov    %rax,0x20(%rsp)
movzbl 0x50(%rsp),%eax
mov    $0x1,%ecx
mov    %eax,0x18(%rsp)
callq  0 <create_pipe>
cmp    $0xffffffff,%eax
je     69d <create_pipe_out+0x4d>
mov    0x34(%rsp),%ecx
mov    0x58(%rsp),%rdx
mov    %ecx,(%rdx)
add    $0x48,%rsp
retq   
<<<sep_in_sample>>>
create_pipe_out (const char *progname,
                 const char *prog_path, char **prog_argv,
                 const char *prog_stdout, _Bool null_stderr,
                 _Bool slave_process, _Bool exit_on_error,
                 int fd[1])
{
  int iofd[2];
  pid_t result = create_pipe (progname, prog_path, prog_argv,
                              1, 0, ((void *)0), prog_stdout,
                              null_stderr, slave_process, exit_on_error,
                              iofd);
  if (result != -1)
    fd[0] = iofd[1];
  return result;
}
<<<sep_in_sample>>>
1 6
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 12
16 12
17 13
18 13
19 13
20 15
21 15
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %rdi,%rdi
je     11c8 <node_free+0x208>
subl   $0x1,0x4(%rdi)
jne    11c8 <node_free+0x208>
mov    (%rdi),%eax
cmp    $0x1,%eax
je     11e0 <node_free+0x220>
nop
jb     11c8 <node_free+0x208>
cmp    $0x2,%eax
je     1270 <node_free+0x2b0>
cmp    $0x6,%eax
jne    11ad <node_free+0x1ed>
mov    0x20(%rdi),%ecx
mov    0x18(%rdi),%rdi
test   %ecx,%ecx
je     11a8 <node_free+0x1e8>
movl   $0x0,0x8(%rsp)
nop
mov    0x8(%rsp),%eax
mov    (%rdi,%rax,8),%r15
test   %r15,%r15
je     1199 <node_free+0x1d9>
mov    0x4(%r15),%eax
lea    -0x1(%rax),%edx
test   %edx,%edx
mov    %edx,0x4(%r15)
jne    1199 <node_free+0x1d9>
mov    (%r15),%edx
cmp    $0x1,%edx
je     1260 <node_free+0x2a0>
jb     1199 <node_free+0x1d9>
cmp    $0x2,%edx
je     1240 <node_free+0x280>
cmp    $0x6,%edx
jne    1187 <node_free+0x1c7>
mov    0x20(%r15),%ecx
xor    %r14d,%r14d
mov    0x18(%r15),%rdi
test   %ecx,%ecx
je     1182 <node_free+0x1c2>
nopl   0x0(%rax,%rax,1)
mov    %r14d,%edx
mov    (%rdi,%rdx,8),%rbp
test   %rbp,%rbp
je     1175 <node_free+0x1b5>
mov    0x4(%rbp),%eax
lea    -0x1(%rax),%edx
test   %edx,%edx
mov    %edx,0x4(%rbp)
jne    1175 <node_free+0x1b5>
mov    0x0(%rbp),%edx
cmp    $0x1,%edx
je     1230 <node_free+0x270>
jb     1175 <node_free+0x1b5>
cmp    $0x2,%edx
je     1210 <node_free+0x250>
cmp    $0x6,%edx
nop
jne    1165 <node_free+0x1a5>
mov    0x20(%rbp),%ecx
xor    %r13d,%r13d
mov    0x18(%rbp),%rdi
test   %ecx,%ecx
je     1160 <node_free+0x1a0>
nopl   0x0(%rax,%rax,1)
mov    %r13d,%edx
mov    (%rdi,%rdx,8),%rbx
test   %rbx,%rbx
je     1157 <node_free+0x197>
mov    0x4(%rbx),%eax
lea    -0x1(%rax),%edx
test   %edx,%edx
mov    %edx,0x4(%rbx)
jne    1157 <node_free+0x197>
mov    (%rbx),%edx
cmp    $0x1,%edx
je     113f <node_free+0x17f>
jb     1157 <node_free+0x197>
cmp    $0x2,%edx
je     11f0 <node_free+0x230>
cmp    $0x6,%edx
xchg   %ax,%ax
jne    1148 <node_free+0x188>
mov    0x20(%rbx),%eax
xor    %dl,%dl
test   %eax,%eax
je     113f <node_free+0x17f>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rcx
mov    %edx,%esi
mov    %edx,0xc(%rsp)
mov    (%rcx,%rsi,8),%rdi
callq  1133 <node_free+0x173>
mov    0xc(%rsp),%edx
add    $0x1,%edx
cmp    0x20(%rbx),%edx
jb     1120 <node_free+0x160>
mov    0x18(%rbx),%rdi
callq  1148 <node_free+0x188>
mov    %rbx,%rdi
callq  1150 <node_free+0x190>
mov    0x18(%rbp),%rdi
mov    0x20(%rbp),%ecx
add    $0x1,%r13d
cmp    %ecx,%r13d
jb     10e0 <node_free+0x120>
callq  1165 <node_free+0x1a5>
mov    %rbp,%rdi
callq  116d <node_free+0x1ad>
mov    0x18(%r15),%rdi
mov    0x20(%r15),%ecx
add    $0x1,%r14d
cmp    %ecx,%r14d
jb     1080 <node_free+0xc0>
callq  1187 <node_free+0x1c7>
mov    %r15,%rdi
callq  118f <node_free+0x1cf>
mov    0x18(%r12),%rdi
mov    0x20(%r12),%ecx
addl   $0x1,0x8(%rsp)
cmp    %ecx,0x8(%rsp)
jb     1020 <node_free+0x60>
callq  11ad <node_free+0x1ed>
add    $0x18,%rsp
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   11c3 <node_free+0x203>
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
mov    0x18(%rdi),%rdi
callq  11e9 <node_free+0x229>
jmp    11ad <node_free+0x1ed>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rdi
callq  11f9 <node_free+0x239>
mov    0x48(%rbx),%rdi
callq  1202 <node_free+0x242>
jmpq   1148 <node_free+0x188>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rbp),%rdi
callq  1219 <node_free+0x259>
mov    0x48(%rbp),%rdi
callq  1222 <node_free+0x262>
jmpq   1165 <node_free+0x1a5>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rbp),%rdi
callq  1239 <node_free+0x279>
jmpq   1165 <node_free+0x1a5>
xchg   %ax,%ax
mov    0x18(%r15),%rdi
callq  1249 <node_free+0x289>
mov    0x48(%r15),%rdi
callq  1252 <node_free+0x292>
jmpq   1187 <node_free+0x1c7>
nopw   0x0(%rax,%rax,1)
mov    0x18(%r15),%rdi
callq  1269 <node_free+0x2a9>
jmpq   1187 <node_free+0x1c7>
xchg   %ax,%ax
mov    0x18(%rdi),%rdi
callq  1279 <node_free+0x2b9>
mov    0x48(%r12),%rdi
callq  1283 <node_free+0x2c3>
jmpq   11ad <node_free+0x1ed>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
node_free (node)
     Node *node;
{
  unsigned int i;
  if (node == ((void *)0))
    return;
  if (--node->refcount > 0)
    return;
  switch (node->type)
    {
    case nVOID:
      return;
      break;
    case nSTRING:
      xfree (node->u.str.data);
      break;
    case nREGEXP:
      free (node->u.re.data);
      xfree (node->u.re.compiled.fastmap);
      break;
    case nINTEGER:
    case nREAL:
    case nSYMBOL:
      break;
    case nARRAY:
      for (i = 0; i < node->u.array.len; i++)
 node_free (node->u.array.array[i]);
      xfree (node->u.array.array);
      break;
    }
  xfree (node);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 26
23 26
24 26
25 26
26 26
27 26
28 27
29 27
30 5
31 5
32 7
33 7
34 7
35 7
36 7
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 26
46 26
47 26
48 26
49 26
50 26
51 27
52 27
53 5
54 5
55 7
56 7
57 7
58 7
59 7
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 26
70 26
71 26
72 26
73 26
74 26
75 27
76 27
77 5
78 5
79 7
80 7
81 7
82 7
83 7
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 26
94 26
95 26
96 26
97 26
98 27
99 27
100 27
101 27
102 27
103 26
104 26
105 26
106 26
107 15
108 15
109 31
110 31
111 31
112 31
113 26
114 26
115 26
116 28
117 31
118 31
119 31
120 31
121 26
122 26
123 26
124 28
125 31
126 31
127 31
128 31
129 26
130 26
131 26
132 28
133 32
134 31
135 32
136 32
137 32
138 32
139 32
140 32
141 31
142 31
143 32
144 32
145 32
146 32
147 32
148 32
149 32
150 32
151 32
152 15
153 15
154 15
155 15
156 18
157 18
158 19
159 19
160 19
161 19
162 18
163 18
164 19
165 19
166 19
167 19
168 15
169 15
170 15
171 15
172 18
173 18
174 19
175 19
176 19
177 19
178 15
179 15
180 15
181 15
182 18
183 18
184 19
185 19
186 19
187 19
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %r8,%rbx
callq  162 <_tcp_write+0x12>
test   %rbx,%rbx
mov    $0x1004,%ecx
je     18f <_tcp_write+0x3f>
mov    (%rax),%edi
xor    %cx,%cx
movq   $0x0,(%rbx)
mov    %r12,%rdx
mov    %rbp,%rsi
callq  183 <_tcp_write+0x33>
cmp    $0xffffffff,%eax
je     1a0 <_tcp_write+0x50>
cltq   
xor    %ecx,%ecx
mov    %rax,(%rbx)
pop    %rbx
pop    %rbp
mov    %ecx,%eax
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
movq   $0x0,(%rbx)
callq  1ac <_tcp_write+0x5c>
mov    (%rax),%ecx
pop    %rbx
pop    %rbp
mov    %ecx,%eax
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_tcp_write (mu_stream_t stream, const char *buf, size_t buf_size,
     mu_off_t offset,
     size_t * bw)
{
  struct _tcp_instance *tcp = mu_stream_get_owner (stream);
  int bytes;
  offset = offset;
  if (bw == ((void *)0))
    return (0x1000 +4);
  *bw = 0;
  if ((bytes = send (tcp->fd, buf, buf_size, 0)) == -1)
    {
      *bw = 0;
      return (*__errno_location ());
    }
  *bw = bytes;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 8
9 9
10 8
11 11
12 11
13 10
14 11
15 11
16 11
17 11
18 11
19 16
20 17
21 16
22 18
23 18
24 18
25 18
26 18
27 18
28 13
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_rspauth (osip_authentication_info_t * authentication_info)
{
  return authentication_info->rspauth;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
cmpl   $0x1,0xc(%rdi)
je     1410 <put_include_anchor+0xa0>
mov    0x8(%rdi),%ecx
mov    $0x0,%edx
mov    $0x20,%esi
mov    %rsp,%rdi
xor    %eax,%eax
callq  13aa <put_include_anchor+0x3a>
mov    0x0(%rip),%rbp        # 13b1 <put_include_anchor+0x41>
mov    $0x0,%edi
callq  13bb <put_include_anchor+0x4b>
mov    %rsp,%rsi
mov    %rax,%rdi
xor    %ecx,%ecx
mov    %rbp,%rdx
callq  13cb <put_include_anchor+0x5b>
mov    $0x0,%edi
mov    %rax,%rsi
callq  13d8 <put_include_anchor+0x68>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  13e5 <put_include_anchor+0x75>
callq  13ea <put_include_anchor+0x7a>
mov    $0x0,%edi
mov    %rax,%rsi
callq  13f7 <put_include_anchor+0x87>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    1446 <put_include_anchor+0xd6>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    0x18(%rdi),%rdi
mov    0x0(%rip),%rbp        # 141b <put_include_anchor+0xab>
callq  1420 <put_include_anchor+0xb0>
mov    %rax,%rdi
callq  1428 <put_include_anchor+0xb8>
xor    %edi,%edi
xor    %ecx,%ecx
mov    %rbp,%rdx
mov    %rax,%rsi
callq  1437 <put_include_anchor+0xc7>
mov    $0x0,%edi
mov    %rax,%rsi
callq  1444 <put_include_anchor+0xd4>
jmp    13d8 <put_include_anchor+0x68>
callq  144b <put_include_anchor+0xdb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_include_anchor(struct data *inc, const char *path)
{
 if (inc->count == 1)
  strbuf_puts(outbuf, gen_href_begin(((void *)0), path2fid(strbuf_value(inc->contents)), HTML, ((void *)0)));
 else {
  char id[32];
  snprintf(id, sizeof(id), "%d", inc->id);
  strbuf_puts(outbuf, gen_href_begin(upperdir("I"), id, HTML, ((void *)0)));
 }
 strbuf_puts(outbuf, path);
 strbuf_puts(outbuf, gen_href_end());
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 12
57 12
<<<sep_out_sample>>>
push   %rbx
mov    $0x28,%edi
callq  b <rec_sex_parser_new+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     3f <rec_sex_parser_new+0x3f>
lea    0x10(%rax),%rdi
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movb   $0x0,0x18(%rax)
xor    %eax,%eax
callq  31 <rec_sex_parser_new+0x31>
mov    0x10(%rbx),%rsi
mov    %rbx,%rdi
xor    %eax,%eax
callq  3f <rec_sex_parser_new+0x3f>
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_parser_new (void)
{
  rec_sex_parser_t new;
  new = malloc (sizeof (struct rec_sex_parser_s));
  if (new)
    {
      new->in = ((void *)0);
      new->index = 0;
      new->case_insensitive = 0;
      sexlex_init (&(new->scanner));
      sexset_extra (new, new->scanner);
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 10
8 7
9 8
10 9
11 10
12 10
13 11
14 11
15 11
16 11
17 14
18 14
19 14
20 14
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x8(%rax),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_min_size(const gsl_interp2d * interp)
{
  return interp->type->min_size;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x20(%rdi)
je     556 <hash_get_first+0x36>
mov    (%rdi),%rdx
mov    0x8(%rdi),%rcx
cmp    %rcx,%rdx
jb     549 <hash_get_first+0x29>
jmp    55d <hash_get_first+0x3d>
nopl   0x0(%rax)
add    $0x10,%rdx
cmp    %rcx,%rdx
jae    55d <hash_get_first+0x3d>
mov    (%rdx),%rax
test   %rax,%rax
je     540 <hash_get_first+0x20>
add    $0x8,%rsp
retq   
xor    %eax,%eax
add    $0x8,%rsp
retq   
callq  562 <hash_get_first+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_first (const Hash_table *table)
{
  struct hash_entry const *bucket;
  if (table->n_entries == 0)
    return ((void *)0);
  for (bucket = table->bucket; ; bucket++)
    if (! (bucket < table->bucket_limit))
      abort ();
    else if (bucket->data)
      return bucket->data;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 7
6 7
7 7
8 7
9 7
10 6
11 7
12 7
13 9
14 9
15 9
16 11
17 11
18 5
19 11
20 11
21 8
22 8
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1fc3 <gsl_matrix_short_isnonneg+0x53>
xorpd  %xmm1,%xmm1
lea    (%rax,%rax,1),%r11
xor    %r8d,%r8d
xor    %r10d,%r10d
test   %rdx,%rdx
je     1fb7 <gsl_matrix_short_isnonneg+0x47>
mov    %r8,%rsi
add    0x18(%rdi),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movswl (%rsi,%rax,2),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm0,%xmm1
ja     1fc9 <gsl_matrix_short_isnonneg+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1fa0 <gsl_matrix_short_isnonneg+0x30>
add    $0x1,%r10
add    %r11,%r8
cmp    %r9,%r10
jne    1f8e <gsl_matrix_short_isnonneg+0x1e>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_short_isnonneg (const gsl_matrix_short * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0x80,%ecx
mov    $0x10,%esi
jmpq   7a2 <nettle_arctwo128_set_key+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_arctwo128_set_key (struct arctwo_ctx *ctx, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, 16, key, 128);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     8f0 <mu_folder_lsub+0x60>
cmpq   $0x0,0x68(%rdi)
je     8f0 <mu_folder_lsub+0x60>
mov    %rcx,%rdi
mov    %rsi,%r12
mov    %rdx,%r13
mov    %rcx,%rbp
callq  8ba <mu_folder_lsub+0x2a>
test   %eax,%eax
jne    8f5 <mu_folder_lsub+0x65>
mov    0x0(%rbp),%rdi
mov    $0x0,%esi
callq  8cc <mu_folder_lsub+0x3c>
mov    0x68(%rbx),%rax
mov    0x0(%rbp),%rcx
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %r12,%rsi
mov    %r13,%rdx
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   *%rax
nopl   0x0(%rax)
mov    $0x26,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
mu_folder_lsub (mu_folder_t folder, const char *dirname, const char *basename,
  mu_list_t *pflist)
{
  int status;
  if (folder == ((void *)0) || folder->_lsub == ((void *)0))
    return 38;
  else
    {
      status = mu_list_create (pflist);
      if (status)
 return status;
      mu_list_set_destroy_item (*pflist, mu_list_response_free);
      status = folder->_lsub (folder, dirname, basename, *pflist);
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 12
19 12
20 12
21 13
22 13
23 16
24 13
25 13
26 13
27 16
28 16
29 16
30 16
31 13
32 13
33 6
34 16
35 16
36 16
37 16
38 16
39 16
<<<sep_out_sample>>>
mov    0x23c(%rdi),%eax
test   $0x10,%ah
je     2c8 <__db_get_byteswapped+0x18>
shr    $0x8,%eax
and    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   2d8 <__db_get_byteswapped+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__db_get_byteswapped(dbp)
 DB *dbp;
{
 if (!(((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "get_byteswapped", 0));;
 return (((dbp)->flags & (0x00100)) ? 1 : 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 6
8 4
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    %rsi,%rbx
lea    0x1(%rbx),%edi
callq  18 <get_sha1+0x18>
mov    %ebx,%edx
mov    %rax,(%r12)
mov    %rbp,%rsi
mov    %rax,%rdi
mov    %rdx,%rcx
rep movsb %ds:(%rsi),%es:(%rdi)
movb   $0x0,(%rax,%rdx,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
get_sha1(char **sha1, char const *start, char const *end)
{
  unsigned int len = end - start;
  *sha1 = xmalloc (len + 1);
  memcpy (*sha1, start, len);
  (*sha1)[len] = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 24a6 <ppdlex_initialize+0x6>
test   %eax,%eax
jne    24b8 <ppdlex_initialize+0x18>
movl   $0x0,0x0(%rip)        # 24b4 <ppdlex_initialize+0x14>
retq   
nopl   (%rax)
sub    $0x8,%rsp
mov    $0x0,%r8d
mov    $0x0,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x0,%edi
movl   $0x0,0x0(%rip)        # 24da <ppdlex_initialize+0x3a>
callq  24df <ppdlex_initialize+0x3f>
movl   $0x0,0x0(%rip)        # 24e9 <ppdlex_initialize+0x49>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
ppdlex_initialize (void)
{
  static int first_time = 1;
  if (first_time)
    {
      first_time = 0;
      _obstack_begin ((&string_stack), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
    }
  include_stack_ptr = 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 9
5 9
6 9
7 2
8 7
9 7
10 7
11 7
12 7
13 6
14 7
15 9
16 10
17 10
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     278 <grecs_error+0x58>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rdx,%rsi
lea    0x8(%rsp),%rdx
mov    %rsp,%rdi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movq   $0x0,(%rsp)
movl   $0x18,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  2b7 <grecs_error+0x97>
mov    (%rsp),%rcx
mov    %ebp,%edx
mov    %rbx,%rdi
mov    $0x1,%esi
callq  2ca <grecs_error+0xaa>
mov    (%rsp),%rdi
callq  2d3 <grecs_error+0xb3>
addl   $0x1,0x0(%rip)        # 2da <grecs_error+0xba>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_error (grecs_locus_t *locus, int errcode, const char *fmt, ...)
{
  va_list ap;
  char *buf = ((void *)0);
  __builtin_va_start(ap,fmt);
  vasprintf (&buf, fmt, ap);
  __builtin_va_end(ap);
  grecs_print_diag (locus, 1, errcode, buf);
  free (buf);
  grecs_error_count++;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 2
21 6
22 6
23 5
24 5
25 4
26 5
27 5
28 5
29 6
30 8
31 8
32 8
33 8
34 8
35 9
36 9
37 10
38 11
39 11
40 11
41 11
42 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x10(%rsi),%eax
cmp    $0x1,%eax
jbe    6a8 <fro_spew_partial+0x28>
cmp    $0x2,%eax
jne    6d8 <fro_spew_partial+0x58>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   30 <fro_spew_partial.part.0>
nopl   0x0(%rax)
mov    (%rdx),%rax
mov    0x8(%rdx),%rsi
mov    %rdi,%rdx
sub    %rax,%rsi
add    0x28(%rbx),%rax
mov    %rax,%rdi
callq  6c1 <fro_spew_partial+0x41>
mov    0x8(%rbp),%rax
cmp    %rax,0x8(%rbx)
jne    6d8 <fro_spew_partial+0x58>
mov    0x20(%rbx),%rax
mov    %rax,0x18(%rbx)
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
fro_spew_partial (FILE *to, struct fro *f, struct range *r)
{
  switch (f->rm)
    {
    case RM_MMAP:
    case RM_MEM:
      awrite (f->base + r->beg, r->end - r->beg, to);
      if (f->end == r->end)
        f->ptr = f->lim;
      break;
    case RM_STDIO:
      {
        char buf[(8 * 8192)];
        size_t count;
        off_t pos = r->beg;
        fseeko (f->stream, pos, 0);
        while (pos < r->end)
          {
            if (!(count = fread (buf, sizeof (*buf),
                                 (pos < r->end - (8 * 8192)
                                  ? (8 * 8192)
                                  : r->end - pos),
                                 f->stream)))
              {
                testIerror (f->stream);
                return;
              }
            awrite (buf, count, to);
            pos += count;
          }
      }
      break;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 34
12 34
13 34
14 34
15 34
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 8
26 9
27 9
28 9
29 34
30 34
31 34
32 34
33 34
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # b <print_and_abort+0xb>
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1c <print_and_abort+0x1c>
mov    0x0(%rip),%edi        # 22 <print_and_abort+0x22>
callq  27 <print_and_abort+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_and_abort (void)
{
  fprintf (stderr, "%s\n", ((const char *) ("memory exhausted")));
  exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
cmpb   $0x11,0x30(%rsi)
je     140 <mark_opt_subexp+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
cmp    0x28(%rsi),%rdi
jne    136 <mark_opt_subexp+0x6>
orb    $0x8,0x32(%rsi)
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
mark_opt_subexp (void *extra, bin_tree_t *node)
{
  Idx idx = (Idx) (long) extra;
  if (node->token.type == SUBEXP && node->token.opr.idx == idx)
    node->token.opt_subexp = 1;
  return _REG_NOERROR;
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 7
5 7
6 4
7 4
8 5
9 7
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     1010 <gsl_sort_vector_ulong_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1005 <gsl_sort_vector_ulong_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1021 <gsl_sort_vector_ulong_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_ulong_index (gsl_permutation * permutation, const gsl_vector_ulong * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_ulong_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    $0x4,%edx
jmpq   18a <in_addr_cmp+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
in_addr_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(struct in_addr)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 1e <__gmpz_init_set_str+0x1e>
movl   $0x0,0x4(%rbx)
mov    %rax,0x8(%rbx)
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rsi
mov    %r12d,%edx
pop    %rbp
pop    %r12
jmpq   3b <__gmpz_init_set_str+0x3b>
<<<sep_in_sample>>>
__gmpz_init_set_str (mpz_ptr x, const char *str, int base)
{
  ((x)->_mp_alloc) = 1;
  ((x)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  ((x)->_mp_size) = 0;
  return __gmpz_set_str (x, str, base);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 5
11 4
12 6
13 7
14 6
15 6
16 7
17 7
18 6
<<<sep_out_sample>>>
push   %r14
test   %edx,%edx
mov    %edx,%r14d
push   %r13
push   %r12
push   %rbp
push   %rbx
jle    9c <f_string+0x9c>
mov    %rsi,%rbx
mov    %rdi,%rbp
callq  1e <f_string+0x1e>
mov    %rax,%r13
lea    -0x1(%r14),%eax
lea    0x1(%rbx,%rax,1),%r12
jmp    41 <f_string+0x41>
nopl   0x0(%rax)
mov    %rbp,%rsi
callq  38 <f_string+0x38>
add    $0x1,%rbx
cmp    %r12,%rbx
je     79 <f_string+0x79>
movzbl (%rbx),%ecx
mov    0x0(%r13),%rax
movsbq %cl,%rdx
movsbl %cl,%edi
testb  $0x40,0x1(%rax,%rdx,2)
jne    30 <f_string+0x30>
callq  5b <f_string+0x5b>
test   %eax,%eax
je     88 <f_string+0x88>
mov    %eax,%edx
mov    $0x0,%esi
xor    %eax,%eax
mov    %rbp,%rdi
add    $0x1,%rbx
callq  74 <f_string+0x74>
cmp    %r12,%rbx
jne    41 <f_string+0x41>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14d,%eax
pop    %r14
retq   
nopl   (%rax)
movsbl (%rbx),%edx
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  9a <f_string+0x9a>
jmp    38 <f_string+0x38>
xor    %r14d,%r14d
jmp    79 <f_string+0x79>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_string (FILE *fp, void *ptr, int size)
{
  int sz;
  char *s;
  for (sz = 0, s = ptr; sz < size; s++, sz++)
    {
      int c;
      if (((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISprint))
 fputc (*s, fp);
      else if ((c = escape (*s)))
 fprintf (fp, "\\%c", c);
      else
 fprintf (fp, "\\%03o", *s);
    }
  return sz;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 9
18 9
19 5
20 5
21 5
22 8
23 8
24 8
25 9
26 8
27 8
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 5
36 11
37 5
38 5
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 13
48 13
49 13
50 13
51 13
52 13
53 5
54 5
55 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
callq  2c9 <closepipe+0x9>
lea    0xc(%rsp),%rsi
xor    %edx,%edx
mov    $0xffffffff,%edi
xor    %eax,%eax
callq  2dc <closepipe+0x1c>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
closepipe(int handle)
{
  int statloc;
  close(handle);
  waitpid(-1, &statloc, 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   533 <gsl_vector_ushort_fwrite+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fwrite (FILE * stream, const gsl_vector_ushort * v)
{
  int status = gsl_block_ushort_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_name (const gsl_multilarge_nlinear_workspace * w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_num_children (rec_sex_ast_node_t node)
{
  return node->num_children;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 2657 <smapset_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smapset_in (FILE * in_str )
{
        smapin = in_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 4d37 <rl_macro_dumper+0x7>
xor    %eax,%eax
jmpq   f20 <_rl_macro_dumper_internal.constprop.12>
xchg   %ax,%ax
<<<sep_in_sample>>>
rl_macro_dumper (print_readably)
     int print_readably;
{
  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x10,%rsp
test   %rdx,%rdx
movsd  (%rdi),%xmm2
movsd  %xmm2,0x8(%rsp)
je     69f <gsl_stats_min_index+0x6f>
lea    0x0(,%rsi,8),%r13
movapd %xmm2,%xmm0
xor    %ebx,%ebx
xor    %r14d,%r14d
lea    (%rdi,%r13,1),%rbp
jmp    696 <gsl_stats_min_index+0x66>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r12,%rbx
je     6b0 <gsl_stats_min_index+0x80>
movsd  0x0(%rbp),%xmm0
movsd  0x8(%rsp),%xmm1
ucomisd %xmm0,%xmm1
jbe    693 <gsl_stats_min_index+0x63>
movsd  %xmm0,0x8(%rsp)
mov    %rbx,%r14
add    %r13,%rbp
callq  69b <gsl_stats_min_index+0x6b>
test   %eax,%eax
je     670 <gsl_stats_min_index+0x40>
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
add    $0x10,%rsp
mov    %r14,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_min_index (const double data[], const size_t stride,
                                const size_t n)
{
  double min = data[0 * stride];
  size_t i, min_index = 0;
  for (i = 0; i < n; i++)
    {
      double xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          return i;
        }
    }
  return min_index;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 3
9 6
10 4
11 4
12 6
13 8
14 8
15 6
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 8
24 9
25 9
26 9
27 8
28 8
29 8
30 14
31 14
32 14
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
<<<sep_out_sample>>>
mov    $0xb8,%edi
jmpq   e5a <make_new_opennode+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_new_opennode(void)
{
    return (openfilestruct *)nmalloc(sizeof(openfilestruct));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  79 <mt_lseek+0x9>
add    $0x8,%rsp
sar    $0x3f,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mt_lseek(int fd, mt_off_t where, int whence)
{
 if(lseek64(fd, where, whence) >= 0)
  return 0;
 else
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 7
4 3
5 7
6 7
<<<sep_out_sample>>>
jmpq   85 <username_completion_function+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
username_completion_function (s, i)
     const char *s;
     int i;
{
  return rl_username_completion_function (s, i);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <osip_authorization_init+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x90,%edi
test   %rax,%rax
je     a0 <osip_authorization_init+0xa0>
callq  *%rax
test   %rax,%rax
mov    %rax,(%rbx)
je     f0 <osip_authorization_init+0xf0>
test   $0x1,%al
mov    %rax,%rdi
mov    $0x90,%edx
jne    b0 <osip_authorization_init+0xb0>
test   $0x2,%dil
jne    c0 <osip_authorization_init+0xc0>
test   $0x4,%dil
jne    d8 <osip_authorization_init+0xd8>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
jne    88 <osip_authorization_init+0x88>
test   $0x2,%dl
jne    70 <osip_authorization_init+0x70>
and    $0x1,%edx
jne    68 <osip_authorization_init+0x68>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
movb   $0x0,(%rdi)
xor    %eax,%eax
jmp    62 <osip_authorization_init+0x62>
nop
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     60 <osip_authorization_init+0x60>
jmp    68 <osip_authorization_init+0x68>
nopl   0x0(%rax)
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     5b <osip_authorization_init+0x5b>
jmp    70 <osip_authorization_init+0x70>
nopl   0x0(%rax)
callq  a5 <osip_authorization_init+0xa5>
jmpq   1b <osip_authorization_init+0x1b>
nopw   0x0(%rax,%rax,1)
movb   $0x0,(%rax)
add    $0x1,%rdi
mov    $0x8f,%dl
jmpq   33 <osip_authorization_init+0x33>
xchg   %ax,%ax
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
jmpq   3d <osip_authorization_init+0x3d>
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmpq   47 <osip_authorization_init+0x47>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffc,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_init (osip_authorization_t ** dest)
{
  *dest = (osip_authorization_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_authorization_t)):malloc(sizeof (osip_authorization_t)));
  if (*dest == ((void *)0))
    return -4;
  memset (*dest, 0, sizeof (osip_authorization_t));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 3
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 7
30 8
31 8
32 8
33 6
34 7
35 7
36 7
37 6
38 6
39 6
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 3
51 3
52 3
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 6
62 6
63 6
64 6
65 6
66 6
67 6
68 6
69 5
70 8
71 8
72 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # e07 <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     e12 <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
mov    0x8(%rax),%rax
movl   $0x0,0x0(%rip)        # e20 <rl_on_new_line+0x20>
movl   $0x0,0x0(%rip)        # e2a <rl_on_new_line+0x2a>
movl   $0x0,0x0(%rip)        # e34 <rl_on_new_line+0x34>
movl   $0x0,0x0(%rip)        # e3e <rl_on_new_line+0x3e>
test   %rax,%rax
je     e50 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # e5a <rl_on_new_line+0x5a>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 7
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 11
17 11
18 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rsi
xor    %eax,%eax
mov    $0x0,%edi
callq  6b0 <test_encode+0x10>
mov    0x0(%rip),%rsi        # 6b7 <test_encode+0x17>
mov    0x0(%rip),%rdi        # 6be <test_encode+0x1e>
callq  6c3 <test_encode+0x23>
mov    $0x0,%edi
mov    %eax,%ebx
callq  6cf <test_encode+0x2f>
mov    %ebx,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
test_encode(const char *arg)
{
    int rv;
    printf("begin 600 %s\n", arg);
    rv = encode_stream(stdin, stdout);
    printf("end\n");
    return rv;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 5
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 13 <__gmpf_init_set_si+0x13>
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 23 <__gmpf_init_set_si+0x23>
test   %rbp,%rbp
mov    %rax,0x10(%rbx)
js     50 <__gmpf_init_set_si+0x50>
mov    %rbp,(%rax)
setne  %al
movzbl %al,%edx
movzbl %al,%eax
mov    %rdx,0x8(%rbx)
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
neg    %rbp
mov    %rbp,(%rax)
mov    $0xffffffff,%eax
movq   $0x1,0x8(%rbx)
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmpf_init_set_si (mpf_ptr r, long int val)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  mp_size_t size;
  mp_limb_t vl;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
  vl = (mp_limb_t) ((val) >= 0 ? ((unsigned long int) (val)) : (- (((unsigned long int) ((val) + 1)) - 1)));
  r->_mp_d[0] = vl & ((~ ((mp_limb_t) (0))) >> 0);
  size = vl != 0;
  r->_mp_exp = size;
  r->_mp_size = val >= 0 ? size : -size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 6
8 7
9 7
10 8
11 7
12 8
13 9
14 10
15 10
16 12
17 10
18 12
19 13
20 13
21 13
22 13
23 13
24 8
25 8
26 12
27 11
28 12
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
mov    0x30(%rdx),%rsi
callq  224 <gsl_eigen_nonsymm_params+0x14>
mov    %ebp,0x20(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_eigen_nonsymm_params (const int compute_t, const int balance,
                          gsl_eigen_nonsymm_workspace *w)
{
  gsl_eigen_francis_T(compute_t, w->francis_workspace_p);
  w->do_balance = balance;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 6
10 6
11 6
12 6
13 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <xmalloc+0x9>
test   %rax,%rax
je     10 <xmalloc+0x10>
pop    %rbx
retq   
mov    %rbx,%rdi
callq  18 <xmalloc+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (size)
     size_t size;
{
  void *ptr;
  ptr = malloc (size);
  if (ptr == ((void *)0))
    {
      fprintf (stderr, gettext ("xmalloc(): couldn't allocate %d bytes\n"), size);
      exit (1);
    }
  return ptr;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 12
7 12
8 12
9 12
10 12
<<<sep_out_sample>>>
mov    (%rdi),%r11
mov    0x20(%rdi),%r9
mov    0x8(%rdi),%r10
test   %r11,%r11
movsd  (%r9),%xmm0
je     167 <gsl_histogram2d_min_bin+0x67>
push   %rbx
lea    0x0(,%r10,8),%rbx
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edi,%edi
nopl   (%rax)
test   %r10,%r10
je     153 <gsl_histogram2d_min_bin+0x53>
xor    %eax,%eax
nop
movsd  (%r9,%rax,8),%xmm1
ucomisd %xmm1,%xmm0
minsd  %xmm0,%xmm1
cmova  %r8,%rdi
cmova  %rax,%rcx
add    $0x1,%rax
cmp    %r10,%rax
movapd %xmm1,%xmm0
jne    130 <gsl_histogram2d_min_bin+0x30>
add    $0x1,%r8
add    %rbx,%r9
cmp    %r11,%r8
jne    128 <gsl_histogram2d_min_bin+0x28>
mov    %rdi,(%rsi)
mov    %rcx,(%rdx)
pop    %rbx
retq   
xor    %ecx,%ecx
xor    %edi,%edi
mov    %rdi,(%rsi)
mov    %rcx,(%rdx)
retq   
<<<sep_in_sample>>>
gsl_histogram2d_min_bin (const gsl_histogram2d * h, size_t * imin_out, size_t * jmin_out)
{
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  size_t imin = 0, jmin = 0, i, j;
  double min = h->bin[0 * ny + 0];
  for (i = 0; i < nx; i++)
    {
      for (j = 0; j < ny; j++)
        {
          double x = h->bin[i * ny + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 3
2 6
3 4
4 7
5 6
6 7
7 2
8 2
9 7
10 5
11 5
12 5
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 11
21 11
22 9
23 9
24 9
25 9
26 7
27 7
28 7
29 7
30 20
31 21
32 22
33 22
34 5
35 5
36 20
37 21
38 21
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     13e0 <gsl_sort_vector_long_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  13d5 <gsl_sort_vector_long_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  13f1 <gsl_sort_vector_long_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_index (gsl_permutation * permutation, const gsl_vector_long * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_long_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  3b9 <file_error+0x9>
mov    (%rax),%edi
callq  3c0 <file_error+0x10>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
pop    %rbx
xor    %eax,%eax
jmpq   3d3 <file_error+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_error (filename)
     const char *filename;
{
  report_error ("%s: %s", filename, strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x20(%rdi)
je     556 <hash_get_first+0x36>
mov    (%rdi),%rdx
mov    0x8(%rdi),%rcx
cmp    %rcx,%rdx
jb     549 <hash_get_first+0x29>
jmp    55d <hash_get_first+0x3d>
nopl   0x0(%rax)
add    $0x10,%rdx
cmp    %rcx,%rdx
jae    55d <hash_get_first+0x3d>
mov    (%rdx),%rax
test   %rax,%rax
je     540 <hash_get_first+0x20>
add    $0x8,%rsp
retq   
xor    %eax,%eax
add    $0x8,%rsp
retq   
callq  562 <hash_get_first+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_first (const Hash_table *table)
{
  struct hash_entry const *bucket;
  if (table->n_entries == 0)
    return ((void *)0);
  for (bucket = table->bucket; ; bucket++)
    if (! (bucket < table->bucket_limit))
      abort ();
    else if (bucket->data)
      return bucket->data;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 7
6 7
7 7
8 7
9 7
10 6
11 7
12 7
13 9
14 9
15 9
16 11
17 11
18 5
19 11
20 11
21 8
22 8
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     538 <gsl_matrix_complex_long_double_set_identity+0x78>
fldz   
lea    0x10(%rax),%rdi
shl    $0x5,%r9
xor    %ecx,%ecx
fld1   
jmp    4ea <gsl_matrix_complex_long_double_set_identity+0x2a>
nopl   0x0(%rax)
fxch   %st(1)
test   %rsi,%rsi
je     523 <gsl_matrix_complex_long_double_set_identity+0x63>
fld    %st(0)
mov    %rdi,%rdx
xor    %eax,%eax
fld    %st(2)
nopl   0x0(%rax,%rax,1)
fstpt  (%rdx)
fldt   (%rdx)
cmp    %rax,%rcx
fld    %st(3)
fcmove %st(2),%st
add    $0x1,%rax
add    $0x20,%rdx
fstpt  -0x30(%rdx)
cmp    %rsi,%rax
jne    500 <gsl_matrix_complex_long_double_set_identity+0x40>
fstp   %st(3)
fstp   %st(0)
fxch   %st(1)
jmp    528 <gsl_matrix_complex_long_double_set_identity+0x68>
fxch   %st(1)
nopl   (%rax)
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    4e8 <gsl_matrix_complex_long_double_set_identity+0x28>
fstp   %st(0)
fstp   %st(0)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_set_identity (gsl_matrix_complex_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex_long_double zero = {{0.0L,0.0L}};
  const gsl_complex_long_double one = {{1.0L,0.0L}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex_long_double *) (data + 2 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 10
39 10
40 10
41 10
42 10
43 10
44 10
45 10
<<<sep_out_sample>>>
cmp    $0xc,%edi
jbe    10d0 <cdio_have_driver+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    %edi,%edi
lea    (%rdi,%rdi,4),%rax
shl    $0x4,%rax
mov    0x0(%rax),%rax
jmpq   *%rax
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_have_driver(driver_id_t driver_id)
{
  if (driver_id >= sizeof(CdIo_all_drivers)/sizeof(CdIo_all_drivers[0]))
    return 0;
  return (*CdIo_all_drivers[driver_id].have_driver)();
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 5
7 5
8 5
9 5
10 5
11 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x18(%rdi),%rbp
mov    %rdi,%rbx
cmp    %rcx,%rbp
je     170 <gsl_spline_init+0x40>
mov    $0x4,%ecx
mov    $0x4a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15d <gsl_spline_init+0x2d>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x4,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
lea    0x0(,%rbp,8),%r14
mov    0x8(%rdi),%rdi
mov    %rdx,%r13
mov    %rsi,%r12
mov    %r14,%rdx
callq  18a <gsl_spline_init+0x5a>
mov    0x10(%rbx),%rdi
mov    %r14,%rdx
mov    %r13,%rsi
callq  199 <gsl_spline_init+0x69>
mov    (%rbx),%rdi
mov    %rbp,%rcx
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdx
pop    %r13
pop    %r14
jmpq   1b2 <gsl_spline_init+0x82>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline_init (gsl_spline * spline, const double x_array[], const double y_array[], size_t size)
{
  if (size != spline->size)
    {
      do { gsl_error ("data must match size of spline object", "spline.c", 74, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  memcpy (spline->x, x_array, size * sizeof(double));
  memcpy (spline->y, y_array, size * sizeof(double));
  {
    int status = gsl_interp_init (spline->interp, x_array, y_array, size);
    return status;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 7
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 10
34 10
35 10
36 13
37 13
38 13
39 10
40 13
41 13
42 10
43 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     4e0 <gsl_permutation_mul+0x30>
mov    $0x4,%ecx
mov    $0xee,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4d5 <gsl_permutation_mul+0x25>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
cmp    (%rdx),%rcx
je     510 <gsl_permutation_mul+0x60>
mov    $0x4,%ecx
mov    $0xf3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4fe <gsl_permutation_mul+0x4e>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
test   %rcx,%rcx
je     53d <gsl_permutation_mul+0x8d>
mov    0x8(%rdi),%r8
mov    0x8(%rsi),%rsi
xor    %eax,%eax
mov    0x8(%rdx),%rdi
nopl   0x0(%rax,%rax,1)
mov    (%rsi,%rax,8),%rdx
mov    (%rdi,%rdx,8),%rdx
mov    %rdx,(%r8,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    528 <gsl_permutation_mul+0x78>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permutation_mul (gsl_permutation * p, const gsl_permutation * pa, const gsl_permutation * pb)
{
  size_t i;
  const size_t size = p->size;
  if (pa->size != size)
    {
      do { gsl_error ("size of result does not match size of pa", "permutation.c", 238, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  if (pb->size != size)
    {
      do { gsl_error ("size of result does not match size of pb", "permutation.c", 243, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      p->data[i] = pb->data[pa->data[i]];
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 18
12 18
13 18
14 9
15 9
16 11
17 11
18 11
19 11
20 11
21 11
22 18
23 18
24 18
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 15
34 15
35 13
36 13
37 13
38 17
39 18
40 18
41 18
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
cmp    $0xffffffff,%edx
je     848 <stealthCraft+0x88>
mov    0x0(%rip),%eax        # 7d7 <stealthCraft+0x17>
mov    %edx,0x22e0(%rbx)
test   %eax,%eax
je     7e5 <stealthCraft+0x25>
test   %ecx,%ecx
jne    800 <stealthCraft+0x40>
movl   $0x2,0x8(%rbx)
mov    %rbp,0x28(%rbx)
add    $0x18,%rsp
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
cmp    $0xffffffff,%edx
je     7e5 <stealthCraft+0x25>
movslq %edx,%rdx
mov    %rbx,%rsi
lea    (%rdx,%rdx,2),%rax
shl    $0x4,%rax
mov    0x0(%rax),%rax
mov    0x20(%rax),%rdi
orq    $0x8000,0x2d0(%rdi)
movl   $0x3,0x8(%rbx)
callq  835 <stealthCraft+0x75>
mov    %rbp,0x28(%rbx)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
mov    %ecx,0xc(%rsp)
mov    %edx,0x8(%rsp)
callq  857 <stealthCraft+0x97>
mov    0x0(%rip),%edi        # 85d <stealthCraft+0x9d>
mov    0x8(%rsp),%edx
mov    0xc(%rsp),%ecx
test   %edi,%edi
jle    7d1 <stealthCraft+0x11>
mov    0x0(%rip),%rax        # 874 <stealthCraft+0xb4>
cmp    %rbp,0x20(%rax)
je     8a7 <stealthCraft+0xe7>
mov    $0x0,%r8d
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
add    $0x1,%eax
cmp    %edi,%eax
je     7d1 <stealthCraft+0x11>
mov    (%r8),%rsi
add    $0x30,%r8
cmp    %rbp,0x20(%rsi)
jne    888 <stealthCraft+0xc8>
mov    %eax,%edx
jmpq   7d1 <stealthCraft+0x11>
xor    %edx,%edx
jmpq   7d1 <stealthCraft+0x11>
xchg   %ax,%ax
<<<sep_in_sample>>>
stealthCraft ( craft *c, viewer *u, int item, int take_control)
{
 int i;
 if ( item == -1 ) {
  buildBrowseInfoTable ();
  for(i=0; i<bcount; ++i) {
   if (browse_info[i].p->c == c) {
    item = i;
    break;
   }
  }
 }
 if ( item != -1 ) {
  u->browseSelectedItem = item;
 }
 else {
  u->browseSelectedItem = -1;
 }
 if ( end_game_mode && take_control && item != -1 ) {
  browse_info[item].p->c->flags |= (1<<15);
  u->viewer_state = 3;
  endGameDistanceCheck ((char *) browse_info[item].p->c,
         (char *) u );
 }
 else {
  u->viewer_state = 2;
 }
 u->watchedCraft = c;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 19
9 19
10 19
11 19
12 19
13 19
14 26
15 28
16 30
17 30
18 30
19 30
20 30
21 30
22 19
23 19
24 20
25 22
26 20
27 20
28 20
29 20
30 20
31 21
32 22
33 28
34 30
35 30
36 30
37 30
38 30
39 30
40 5
41 5
42 5
43 5
44 6
45 6
46 6
47 6
48 6
49 7
50 7
51 7
52 7
53 6
54 6
55 6
56 6
57 6
58 7
59 7
60 7
61 7
62 7
63 7
64 6
65 6
66 6
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
goldensection_init (void * vstate, gsl_function * f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper)
{
  goldensection_state_t * state = (goldensection_state_t *) vstate;
  state = 0;
  f = 0;
  x_minimum = 0;
  f_minimum = 0;
  x_lower = 0;
  f_lower = 0;
  x_upper = 0;
  f_upper = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 13
2 13
3 13
<<<sep_out_sample>>>
mov    0x0(%rip),%ecx        # 266 <xattrs_acls_set+0x6>
test   %ecx,%ecx
jle    2b1 <xattrs_acls_set+0x51>
cmp    $0x32,%dl
je     2b1 <xattrs_acls_set+0x51>
mov    0x0(%rip),%eax        # 275 <xattrs_acls_set+0x15>
test   %eax,%eax
jne    2b8 <xattrs_acls_set+0x58>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 284 <xattrs_acls_set+0x24>
test   %rax,%rax
je     28b <xattrs_acls_set+0x2b>
callq  *%rax
mov    $0x0,%edi
callq  295 <xattrs_acls_set+0x35>
xor    %esi,%esi
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
callq  2a3 <xattrs_acls_set+0x43>
movl   $0x1,0x0(%rip)        # 2ad <xattrs_acls_set+0x4d>
add    $0x8,%rsp
repz retq 
nopl   0x0(%rax,%rax,1)
movl   $0x1,0x0(%rip)        # 2c2 <xattrs_acls_set+0x62>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattrs_acls_set (struct tar_stat_info const *st,
                 char const *file_name, char typeflag)
{
  if (acls_option > 0 && typeflag != '2')
    {
      static int done = 0;
      if (!done)
        do { if (error_hook) error_hook (); error (0, 0, gettext ("POSIX ACL support is not available")); } while (0);
      done = 1;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 7
8 7
9 3
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 11
23 11
24 11
25 9
26 9
27 9
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  115 <describe_command+0x15>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  120 <describe_command+0x20>
test   %rax,%rax
mov    %rax,%rbx
je     170 <describe_command+0x70>
cmpb   $0x0,(%rax)
je     154 <describe_command+0x54>
mov    %rax,%rdi
callq  135 <describe_command+0x35>
test   %rax,%rax
je     168 <describe_command+0x68>
mov    %rax,%rdi
callq  142 <describe_command+0x42>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  154 <describe_command+0x54>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   162 <describe_command+0x62>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    0x0(%rip),%rdi        # 177 <describe_command+0x77>
add    $0x8,%rsp
mov    %ebp,%esi
pop    %rbx
pop    %rbp
jmpq   184 <describe_command+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
describe_command (WINDOW *window, int count)
{
  char *line;
  line = read_function_name (gettext ("Describe command: "), window);
  if (!line)
    {
      info_abort_key (active_window, count);
      return;
    }
  if (*line)
    {
      InfoCommand *cmd = named_function (line);
      if (!cmd)
        return;
      window_message_in_echo_area ("%s: %s.",
                                   line, function_documentation (cmd));
    }
  free (line);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 10
15 10
16 12
17 12
18 13
19 13
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 19
28 18
29 19
30 19
31 18
32 18
33 19
34 19
35 19
36 19
37 19
38 7
39 19
40 7
41 19
42 19
43 7
44 7
<<<sep_out_sample>>>
xor    %eax,%eax
test   %edx,%edx
jle    1527 <string_bin_to_hex+0x47>
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rsi,%rax,1),%ecx
lea    (%rax,%rax,1),%r8d
movslq %r8d,%r8
shr    $0x4,%cl
and    $0xf,%ecx
movzbl 0x0(%rcx),%ecx
mov    %cl,(%rdi,%r8,1)
movzbl (%rsi,%rax,1),%ecx
add    $0x1,%rax
and    $0xf,%ecx
cmp    %eax,%edx
movzbl 0x0(%rcx),%ecx
mov    %cl,0x1(%rdi,%r8,1)
jg     14f0 <string_bin_to_hex+0x10>
repz retq 
<<<sep_in_sample>>>
string_bin_to_hex (unsigned char *output, unsigned char *input, int inlen)
{
  int i;
  for (i = 0; i < inlen; i++)
    {
      output[i << 1] = xlet[input[i] >> 4];
      output[(i << 1) + 1] = xlet[input[i] & 0x0f];
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 7
13 7
14 7
15 4
16 7
17 7
18 4
19 4
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x8(%rbx),%rcx
mov    $0x1,%esi
callq  db <_stdio_read+0x1b>
cmp    %rax,%r12
mov    %rax,%rbp
je     109 <_stdio_read+0x49>
mov    0x8(%rbx),%rdi
callq  ec <_stdio_read+0x2c>
test   %eax,%eax
jne    118 <_stdio_read+0x58>
mov    0x8(%rbx),%rdi
callq  f9 <_stdio_read+0x39>
test   %eax,%eax
jne    138 <_stdio_read+0x78>
mov    $0x0,%edi
xor    %eax,%eax
callq  109 <_stdio_read+0x49>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
xor    %eax,%eax
mov    $0x0,%edi
callq  124 <_stdio_read+0x64>
mov    0x8(%rbx),%rdi
callq  12d <_stdio_read+0x6d>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
callq  13d <_stdio_read+0x7d>
mov    (%rax),%edi
callq  144 <_stdio_read+0x84>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  153 <_stdio_read+0x93>
mov    0x8(%rbx),%rdi
callq  15c <_stdio_read+0x9c>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_stdio_read(void *user_data, void *buf, size_t count)
{
  _UserData *const ud = user_data;
  long read_count;
  read_count = fread(buf, 1, count, ud->fd);
  if (read_count != count)
    {
      if (feof (ud->fd))
        {
          cdio_debug ("fread (): EOF encountered");
          clearerr (ud->fd);
        }
      else if (ferror (ud->fd))
        {
          cdio_error ("fread (): %s", strerror ((*__errno_location ())));
          clearerr (ud->fd);
        }
      else
        cdio_debug ("fread (): short read and no EOF?!?");
    }
  return read_count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 6
11 5
12 6
13 8
14 8
15 8
16 8
17 13
18 13
19 13
20 13
21 19
22 19
23 19
24 22
25 22
26 22
27 22
28 22
29 22
30 10
31 10
32 10
33 11
34 11
35 22
36 22
37 22
38 22
39 22
40 22
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 16
49 16
50 22
51 22
52 22
53 22
54 22
55 22
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  8d1 <xdr_dis_double_vector+0x11>
test   %eax,%eax
jne    8e0 <xdr_dis_double_vector+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  8ec <xdr_dis_double_vector+0x2c>
test   %eax,%eax
je     8d5 <xdr_dis_double_vector+0x15>
lea    0x10(%rbp),%rsi
mov    %rbx,%rdi
callq  8fc <xdr_dis_double_vector+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_double_vector(xdrs, objp)
	XDR *xdrs;
	dis_double_vector *objp;
{
	if (!xdr_byte_double(xdrs, &objp->x)) {
		return (FALSE);
	}
	if (!xdr_byte_double(xdrs, &objp->y)) {
		return (FALSE);
	}
	if (!xdr_byte_double(xdrs, &objp->z)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
test   %rdi,%rdi
je     260 <_get_mcn_image+0x20>
mov    0x1618(%rdi),%rdi
test   %rdi,%rdi
je     260 <_get_mcn_image+0x20>
jmpq   256 <_get_mcn_image+0x16>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_get_mcn_image(const void *p_user_data)
{
  const _img_private_t *p_env = p_user_data;
  if (!p_env || !p_env->psz_mcn) return ((void *)0);
  return strdup(p_env->psz_mcn);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rcx
test   %rsi,%rsi
je     6aa <gsl_vector_complex_isnonneg+0x5a>
mov    0x10(%rdi),%rax
xorpd  %xmm0,%xmm0
ucomisd (%rax),%xmm0
ja     6b0 <gsl_vector_complex_isnonneg+0x60>
ucomisd 0x8(%rax),%xmm0
ja     6b0 <gsl_vector_complex_isnonneg+0x60>
mov    %rcx,%rdi
neg    %rcx
xor    %edx,%edx
shl    $0x4,%rdi
shl    $0x4,%rcx
lea    0x8(%rax,%rdi,1),%rax
movapd %xmm0,%xmm1
jmp    6a1 <gsl_vector_complex_isnonneg+0x51>
nopl   0x0(%rax)
ucomisd -0x8(%rax),%xmm0
ja     6b0 <gsl_vector_complex_isnonneg+0x60>
add    %rdi,%rax
ucomisd (%rax,%rcx,1),%xmm1
ja     6b0 <gsl_vector_complex_isnonneg+0x60>
add    $0x1,%rdx
cmp    %rsi,%rdx
jne    690 <gsl_vector_complex_isnonneg+0x40>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_isnonneg (const gsl_vector_complex * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 6
26 6
27 6
28 17
29 17
30 13
31 18
32 18
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 336 <grecs_gram_trace+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_gram_trace (int n)
{
  yy_grecsdebug = n;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x28(%rdi),%rax
cmp    0x28(%rsi),%rax
je     4e0 <da_cmp_equal+0x20>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
xor    %ebx,%ebx
test   %rax,%rax
jne    4fa <da_cmp_equal+0x3a>
jmp    518 <da_cmp_equal+0x58>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    %rbx,0x28(%rbp)
jbe    518 <da_cmp_equal+0x58>
mov    0x30(%r12),%rax
mov    0x30(%rbp),%rdx
mov    (%rax,%rbx,8),%rsi
mov    (%rdx,%rbx,8),%rdi
callq  *0x40(%rbp)
test   %eax,%eax
je     4f0 <da_cmp_equal+0x30>
jmp    4d4 <da_cmp_equal+0x14>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_cmp_equal (struct darray * ar1, struct darray * ar2)
{
  size_t i;
  if (ar1->len != ar2->len)
    return 0;
  for (i = 0 ; i< ar1->len ; i++)
    if (ar1->cmp (ar1->content [i], ar2->content [i]))
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 10
10 10
11 5
12 10
13 10
14 10
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 10
34 9
35 10
36 10
37 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     d0 <sdp_attribute_free+0x50>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     9f <sdp_attribute_free+0x1f>
mov    0x0(%rip),%rax        # 98 <sdp_attribute_free+0x18>
test   %rax,%rax
je     e8 <sdp_attribute_free+0x68>
callq  *%rax
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     b6 <sdp_attribute_free+0x36>
mov    0x0(%rip),%rax        # af <sdp_attribute_free+0x2f>
test   %rax,%rax
je     f0 <sdp_attribute_free+0x70>
callq  *%rax
mov    0x0(%rip),%rax        # bd <sdp_attribute_free+0x3d>
mov    %rbx,%rdi
test   %rax,%rax
je     d8 <sdp_attribute_free+0x58>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   e5 <sdp_attribute_free+0x65>
nopl   (%rax)
callq  ed <sdp_attribute_free+0x6d>
jmp    9f <sdp_attribute_free+0x1f>
nop
callq  f5 <sdp_attribute_free+0x75>
jmp    b6 <sdp_attribute_free+0x36>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_attribute_free (sdp_attribute_t * attribute)
{
  if (attribute == ((void *)0))
    return;
  { if (attribute->a_att_field!=((void *)0)) { if (osip_free_func) osip_free_func(attribute->a_att_field); else free(attribute->a_att_field);} };
  { if (attribute->a_att_value!=((void *)0)) { if (osip_free_func) osip_free_func(attribute->a_att_value); else free(attribute->a_att_value);} };
  { if (attribute!=((void *)0)) { if (osip_free_func) osip_free_func(attribute); else free(attribute);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 8
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 7
32 7
33 5
34 5
35 5
36 6
37 6
38 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 3917 <c_get_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_get_text (void)
{
        return c_text;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x238(%rdi),%rax
mov    %rsi,%r8
mov    %ecx,(%rsp)
mov    %rdx,%r9
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
callq  *0x8(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
process_data_crank_post (j_decompress_ptr cinfo,
    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
    JDIMENSION out_rows_avail)
{
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) ((void *)0),
         (JDIMENSION *) ((void *)0), (JDIMENSION) 0,
         output_buf, out_row_ctr, out_rows_avail);
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 5
7 5
8 5
9 5
10 8
11 8
12 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     1b0 <gsl_blas_cdotu+0x30>
mov    $0x13,%ecx
mov    $0x7c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a5 <gsl_blas_cdotu+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  1d0 <gsl_blas_cdotu+0x50>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_cdotu (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
{
  if (X->size == Y->size)
    {
      cblas_cdotu_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotu)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 12
6 12
7 12
8 12
9 12
10 12
11 14
12 14
13 14
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 14
25 14
26 14
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_os2 (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x20(%rsi),%rsi
mov    (%rax),%rdx
jmpq   19f <nettle_buffer_copy+0xf>
<<<sep_in_sample>>>
nettle_buffer_copy(struct nettle_buffer *dst,
     const struct nettle_buffer *src)
{
  return nettle_buffer_write(dst, src->size, src->contents);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1350 <gsl_block_ushort_free+0x20>
mov    0x8(%rdi),%rdi
callq  1342 <gsl_block_ushort_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   134b <gsl_block_ushort_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_ushort_free (gsl_block_ushort * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
cmpl   $0x5,0x0(%rip)        # d97 <print_count+0x7>
mov    $0x0,%ecx
mov    $0x0,%eax
cmovne %rax,%rcx
test   %edi,%edi
je     de0 <print_count+0x50>
cmp    $0x1,%edi
jne    dc8 <print_count+0x38>
mov    0x0(%rip),%rdi        # db5 <print_count+0x25>
mov    %rcx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
jmpq   dc4 <print_count+0x34>
nopl   0x0(%rax)
mov    %edi,%edx
mov    0x0(%rip),%rdi        # dd1 <print_count+0x41>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   ddd <print_count+0x4d>
nopl   (%rax)
mov    0x0(%rip),%rcx        # de7 <print_count+0x57>
mov    $0x10,%edx
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   dfb <print_count+0x6b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_count(int number)
{
 const char *target = format == 5 ? "file" : "object";
 switch (number) {
 case 0:
  fprintf(stderr, "object not found");
  break;
 case 1:
  fprintf(stderr, "1 %s located", target);
  break;
 default:
  fprintf(stderr, "%d %ss located", number, target);
  break;
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 9
10 9
11 9
12 9
13 9
14 9
15 12
16 12
17 12
18 12
19 12
20 12
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  2d1c <gsl_sf_mathieu_a+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    2d30 <gsl_sf_mathieu_a+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x374,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2d46 <gsl_sf_mathieu_a+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_mathieu_a(int order, double qq)
{
 gsl_sf_result result; int status = gsl_sf_mathieu_a_e(order, qq, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_mathieu_a_e(order, qq, &result)", "mathieu_charv.c", 884, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_residual (const gsl_multifit_nlinear_workspace * w)
{
  return w->f;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    $0x1,%edi
jmpq   47a <do_para_end_void+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_para_end_void(void)
{
    do_para_end(1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x250,%edi
callq  8e <stream_create+0xe>
mov    %rax,(%rbx)
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stream_create (struct net_stream **str)
{
  *str = xzalloc (sizeof **str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  20de <get_symbol+0xe>
test   %rax,%rax
mov    %rax,%rbx
jne    20f9 <get_symbol+0x29>
jmp    2120 <get_symbol+0x50>
nopl   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     2120 <get_symbol+0x50>
cmpl   $0x2,0x18(%rbx)
jne    20f0 <get_symbol+0x20>
mov    0x20(%rbx),%rdi
mov    %rbp,%rsi
callq  210b <get_symbol+0x3b>
test   %eax,%eax
jne    20f0 <get_symbol+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbp,%rdi
xor    %esi,%esi
pop    %rbx
pop    %rbp
jmpq   2130 <add_reference>
<<<sep_in_sample>>>
get_symbol(char *name)
{
     Symbol *sp = lookup(name) ;
     if (sp) {
   for (; sp; sp = sp->next) {
        if (sp->type == SymIdentifier && strcmp(sp->name, name) == 0)
      break;
   }
   if (sp)
        return sp;
     }
     return install_ident(name, ExternStorage);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 12
29 12
30 13
31 13
32 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x20,%rsp
test   %rsi,%rsi
je     14 <osip_message_set_proxy_authenticate+0x14>
cmpb   $0x0,(%rsi)
jne    20 <osip_message_set_proxy_authenticate+0x20>
add    $0x20,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
mov    %rdi,%rbp
lea    0x10(%rsp),%rdi
mov    %rsi,0x8(%rsp)
callq  32 <osip_message_set_proxy_authenticate+0x32>
test   %eax,%eax
mov    %eax,%ebx
mov    0x8(%rsp),%rsi
jne    14 <osip_message_set_proxy_authenticate+0x14>
mov    0x10(%rsp),%rdi
callq  47 <osip_message_set_proxy_authenticate+0x47>
test   %eax,%eax
mov    %eax,%r12d
jne    70 <osip_message_set_proxy_authenticate+0x70>
mov    0x10(%rsp),%rsi
lea    0x108(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
mov    $0xffffffff,%edx
callq  6e <osip_message_set_proxy_authenticate+0x6e>
jmp    14 <osip_message_set_proxy_authenticate+0x14>
mov    0x10(%rsp),%rdi
mov    %r12d,%ebx
callq  7d <osip_message_set_proxy_authenticate+0x7d>
jmp    14 <osip_message_set_proxy_authenticate+0x14>
nop
<<<sep_in_sample>>>
osip_message_set_proxy_authenticate (osip_message_t * sip, const char *hvalue)
{
  osip_proxy_authenticate_t *proxy_authenticate;
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  i = osip_www_authenticate_init(&(proxy_authenticate));
  if (i != 0)
    return i;
  i = osip_www_authenticate_parse(proxy_authenticate, hvalue);
  if (i != 0) {
    osip_www_authenticate_free (proxy_authenticate);
    return i;
  }
  sip->message_property = 2;
  osip_list_add (&sip->proxy_authenticates, proxy_authenticate, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 2
6 5
7 5
8 5
9 5
10 18
11 18
12 18
13 18
14 18
15 18
16 18
17 18
18 7
19 7
20 7
21 8
22 7
23 8
24 8
25 10
26 10
27 11
28 10
29 11
30 16
31 16
32 15
33 16
34 16
35 17
36 12
37 13
38 12
39 13
40 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     240 <sdp_message_u_uri_get+0x10>
mov    0x48(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_u_uri_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->u_uri;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ecx
xor    %edx,%edx
mov    %esi,%ebx
sub    $0x20,%rsp
test   %ecx,%ecx
mov    %esi,(%rsp)
js     56 <mu_pop3_carrier_is_ready+0x56>
mov    %ecx,%eax
mov    $0x51eb851f,%edx
mov    %ecx,%esi
imul   %edx
sar    $0x1f,%esi
mov    %ecx,%eax
sar    $0x5,%edx
sub    %esi,%edx
movslq %edx,%rdx
mov    %rdx,0x10(%rsp)
mov    $0x10624dd3,%edx
imul   %edx
sar    $0x6,%edx
sub    %esi,%edx
imul   $0x3e8,%edx,%edx
sub    %edx,%ecx
lea    0x10(%rsp),%rdx
imul   $0x3e8,%ecx,%ecx
movslq %ecx,%rcx
mov    %rcx,0x18(%rsp)
mov    %rsp,%rsi
callq  5e <mu_pop3_carrier_is_ready+0x5e>
xor    %edx,%edx
test   %eax,%eax
jne    69 <mu_pop3_carrier_is_ready+0x69>
and    (%rsp),%ebx
mov    %ebx,%edx
add    $0x20,%rsp
mov    %edx,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_pop3_carrier_is_ready (mu_stream_t carrier, int flag, int timeout)
{
  struct timeval tv, *tvp = ((void *)0);
  int wflags = flag;
  int status;
  if (timeout >= 0)
    {
      tv.tv_sec = timeout / 100;
      tv.tv_usec = (timeout % 1000) * 1000;
      tvp = &tv;
    }
  status = mu_stream_wait (carrier, &wflags, tvp);
  if (status)
    return 0;
  return wflags & flag;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 6
7 4
8 6
9 8
10 8
11 8
12 8
13 8
14 9
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 9
27 9
28 9
29 12
30 12
31 14
32 13
33 13
34 15
35 15
36 16
37 16
38 16
39 16
40 16
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    e39 <gsl_matrix_equal+0x19>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     e60 <gsl_matrix_equal+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e52 <gsl_matrix_equal+0x32>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     ec8 <gsl_matrix_equal+0xa8>
lea    0x0(,%r8,8),%r12
lea    0x0(,%rax,8),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     eb9 <gsl_matrix_equal+0x99>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movsd  (%r9,%rax,8),%xmm0
ucomisd (%r8,%rax,8),%xmm0
jp     ecf <gsl_matrix_equal+0xaf>
jne    ecf <gsl_matrix_equal+0xaf>
add    $0x1,%rax
cmp    %rdx,%rax
jne    ea0 <gsl_matrix_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    e85 <gsl_matrix_equal+0x65>
mov    $0x1,%eax
jmp    e54 <gsl_matrix_equal+0x34>
xor    %eax,%eax
jmp    e54 <gsl_matrix_equal+0x34>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_equal (const gsl_matrix * a, const gsl_matrix * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 30
18 30
19 30
20 30
21 30
22 14
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 20
40 20
41 20
42 20
43 16
44 16
45 16
46 14
47 14
48 14
49 14
50 14
51 29
52 29
53 23
54 23
55 23
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  1f6 <vgetcwd+0x16>
test   %rax,%rax
je     228 <vgetcwd+0x48>
mov    $0x0,%edi
callq  205 <vgetcwd+0x25>
test   %rax,%rax
je     228 <vgetcwd+0x48>
mov    %ebp,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  217 <vgetcwd+0x37>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  233 <vgetcwd+0x53>
test   %rax,%rax
cmovne %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
vgetcwd(char *buf, size_t size) {
 char *p;
 if (getenv("GTAGSLOGICALPATH")) {
  if ((p = getenv("PWD")) != ((void *)0)) {
   strlimcpy(buf, p, size);
   return buf;
  }
 }
 if (getcwd(buf, size) != ((void *)0))
  return buf;
 return ((void *)0);
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 3
6 1
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 12
19 6
20 12
21 12
22 12
23 12
24 9
25 9
26 9
27 10
28 10
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  1ee <xvfprintf+0xe>
test   %eax,%eax
mov    %eax,%ebx
js     200 <xvfprintf+0x20>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %rbp,%rdi
callq  208 <xvfprintf+0x28>
test   %eax,%eax
jne    1f4 <xvfprintf+0x14>
callq  211 <xvfprintf+0x31>
mov    0x0(%rip),%edi        # 217 <xvfprintf+0x37>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
callq  225 <xvfprintf+0x45>
jmp    1f4 <xvfprintf+0x14>
<<<sep_in_sample>>>
xvfprintf (FILE *__restrict stream, char const *__restrict format, va_list args)
{
  int retval = vfprintf (stream, format, args);
  if (retval < 0 && ! ferror (stream))
    error (exit_failure, (*__errno_location ()), ((const char *) ("cannot perform formatted output")));
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
23 5
24 5
25 5
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,(%rdi)
mov    %rdi,%rbx
jne    f5e <tail+0x1e>
jmp    f70 <tail+0x30>
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x1(%rax)
jne    f78 <tail+0x38>
movb   $0x0,(%rax)
cmpb   $0x0,(%rbx)
je     f70 <tail+0x30>
mov    $0x2f,%esi
mov    %rbx,%rdi
callq  f6b <tail+0x2b>
test   %rax,%rax
jne    f50 <tail+0x10>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   (%rax)
add    $0x1,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
tail (char *filename)
{
  register char *s;
  while (*filename)
    {
      s = strrchr (filename, '/');
      if (s == ((void *)0))
 break;
      if (s[1])
 return (s + 1);
      *s = '\0';
    }
  return filename;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 9
8 9
9 11
10 4
11 4
12 6
13 6
14 6
15 7
16 7
17 2
18 14
19 14
20 14
21 10
22 14
23 14
24 14
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_downsample (j_compress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %r9,0x48(%rsp)
je     bb7 <CDB___db_logmsg+0x47>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%r9
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x28,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  be8 <CDB___db_logmsg+0x78>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
CDB___db_logmsg(const DB_ENV *dbenv,
    DB_TXN *txnid, const char *opname, u_int32_t flags, const char *fmt, ...)
{
 va_list ap;
 __builtin_va_start(ap,fmt);
 CDB___db_real_log(dbenv, txnid, opname, flags, fmt, ap);
 __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 5
14 6
15 5
16 5
17 5
18 5
19 5
20 6
21 8
22 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  4d1 <xdr_dis_simulation_addr+0x11>
xor    %edx,%edx
test   %eax,%eax
je     4ea <xdr_dis_simulation_addr+0x2a>
lea    0x2(%rbp),%rsi
mov    %rbx,%rdi
callq  4e3 <xdr_dis_simulation_addr+0x23>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_simulation_addr(xdrs, objp)
	XDR *xdrs;
	dis_simulation_addr *objp;
{
	if (!xdr_byte_u_short(xdrs, &objp->site_id)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->application_id)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 6
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a89 <rl_free_line_state+0x9>
callq  a8e <rl_free_line_state+0xe>
test   %rax,%rax
je     a9b <rl_free_line_state+0x1b>
movq   $0x0,0x10(%rax)
callq  aa0 <rl_free_line_state+0x20>
callq  aa5 <rl_free_line_state+0x25>
add    $0x8,%rsp
jmpq   aae <rl_free_line_state+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
rl_free_line_state ()
{
  register HIST_ENTRY *entry;
  rl_free_undo_list ();
  entry = current_history ();
  if (entry)
    entry->data = (char *)((void *)0);
  _rl_kill_kbd_macro ();
  rl_clear_message ();
  _rl_reset_argument ();
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 6
6 7
7 8
8 9
9 11
10 10
11 10
<<<sep_out_sample>>>
mov    %rsi,0x28(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_stale (osip_www_authenticate_t * www_authenticate, char *stale)
{
  www_authenticate->stale = (char *) stale;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1979 <gsl_vector_uchar_isneg+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm1,%xmm0
jae    197f <gsl_vector_uchar_isneg+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1960 <gsl_vector_uchar_isneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_isneg (const gsl_vector_uchar * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
21 13
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    %rdi,%rax
mov    0x18(%rdi),%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    0x28(%rdi),%rdi
mov    0x20(%r8),%r9
mov    0x20(%rax),%r8
jmpq   *%r9
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * s)
{
  return (s->type->iterate) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rdx,%rdi
mov    $0x10,%edx
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
sub    $0x8,%rsp
callq  ce <wprepend+0x1e>
mov    %rbp,(%rax)
mov    %rbx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
wprepend (void *x, struct wlink *ls, struct divvy *to)
{
  struct wlink *pair = alloc (to, "struct wlink", sizeof (struct wlink)); pair->entry = x; pair->next = ls; return pair;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 3
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_diagonal (gsl_matrix_complex_long_double * m)
{
  _gsl_vector_complex_long_double_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  16 <rec_atoi+0x16>
xor    %edx,%edx
cmpb   $0x0,(%rbx)
je     2e <rec_atoi+0x2e>
mov    (%rsp),%rcx
cmpb   $0x0,(%rcx)
jne    2e <rec_atoi+0x2e>
mov    %eax,0x0(%rbp)
mov    $0x1,%edx
add    $0x18,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_atoi (const char *str,
          int *number)
{
  _Bool res;
  long int li;
  char *end;
  int base = 0;
  res = 0;
  li = strtol (str, &end, base);
  if ((*str != '\0') && (*end == '\0'))
    {
      res = 1;
      *number = (int) li;
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 9
3 3
4 3
5 3
6 3
7 9
8 9
9 8
10 10
11 10
12 10
13 10
14 10
15 13
16 12
17 16
18 16
19 16
20 16
21 16
22 16
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x1,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x8,%esi
push   %rbx
callq  199 <cdio_charset_converter_create+0x19>
mov    %r12,%rsi
mov    %rax,%rbx
mov    %rbp,%rdi
callq  1a7 <cdio_charset_converter_create+0x27>
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_charset_converter_create(const char * src_charset,
                              const char * dst_charset)
  {
  cdio_charset_coverter_t * ret;
  ret = calloc(1, sizeof(*ret));
  ret->ic = iconv_open(dst_charset, src_charset);
  return ret;
  }
<<<sep_in_sample>>>
1 3
2 3
3 5
4 3
5 3
6 5
7 3
8 5
9 6
10 5
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %rsi,%rsi
mov    %rdx,%rcx
setne  %al
mov    %rsi,0x8(%rsp)
lea    0x8(%rsp),%rsi
movzbl %al,%eax
mov    %rax,%rdx
callq  22 <__gmpz_ui_pow_ui+0x22>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmpz_ui_pow_ui (mpz_ptr r, unsigned long b, unsigned long e)
{
    {
      __gmpz_n_pow_ui (r, &b, (mp_size_t) (b != 0), e);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 2
6 4
7 4
8 4
9 4
10 6
11 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rax
mov    %rsi,%rbx
mov    0x10(%rax),%rdx
test   %rdx,%rdx
je     118 <opitr_destroy+0x28>
sub    $0x1,%rdx
mov    %rbx,%rdi
mov    %rdx,0x10(%rax)
callq  110 <opitr_destroy+0x20>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  127 <opitr_destroy+0x37>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  136 <opitr_destroy+0x46>
mov    %rbx,%rdi
callq  13e <opitr_destroy+0x4e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
opitr_destroy (mu_iterator_t iterator, void *data)
{
  struct opool_iterator *itr = data;
  if (itr->opool->itr_count == 0)
    {
      mu_error (dgettext ("mailutils", "%s: INTERNAL ERROR: zero reference count"),
  "opool_destroy");
    }
  else
    itr->opool->itr_count--;
  free (data);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 10
8 11
9 10
10 11
11 13
12 13
13 13
14 13
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 11
23 11
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
cmp    0x8(%rdi),%r9
je     32f0 <gsl_matrix_uint_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  32e6 <gsl_matrix_uint_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %r9,%r9
je     3354 <gsl_matrix_uint_transpose+0x94>
xor    %eax,%eax
lea    0x1(%rax),%r11
cmp    %r9,%r11
je     3354 <gsl_matrix_uint_transpose+0x94>
mov    0x10(%rdi),%rdx
mov    %rax,%rsi
mov    0x18(%rdi),%rcx
imul   %rdx,%rsi
lea    0x0(,%rdx,4),%r10
add    %rsi,%rdx
add    %rdx,%rax
lea    (%rcx,%rax,4),%rdx
lea    (%rcx,%rsi,4),%rcx
mov    %r11,%rax
nopl   0x0(%rax,%rax,1)
mov    (%rdx),%r8d
mov    (%rcx,%rax,4),%esi
mov    %r8d,(%rcx,%rax,4)
add    $0x1,%rax
mov    %esi,(%rdx)
add    %r10,%rdx
cmp    %r9,%rax
jne    3330 <gsl_matrix_uint_transpose+0x70>
mov    %r11,%rax
lea    0x1(%rax),%r11
cmp    %r9,%r11
jne    3300 <gsl_matrix_uint_transpose+0x40>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_transpose (gsl_matrix_uint * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                unsigned int tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 20
31 19
32 20
33 12
34 21
35 21
36 12
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmalloc+0x9>
test   %rax,%rax
je     13 <xmalloc+0x13>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  1d <xmalloc+0x1d>
mov    $0x1,%edi
callq  27 <xmalloc+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (size_t length)
{
  void * p;
  p = (void *) malloc (length);
  if (p == (void *) ((void *)0))
    {
      perror ("out of memory");
      exit (1);
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 11
6 11
7 7
8 7
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %r12
xor    %r12d,%r12d
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rdi)
cmpq   $0x0,(%rdi)
mulsd  0x0(%rip),%xmm0        # f81 <gsl_integration_qawo_table_set+0x21>
movsd  %xmm1,0x10(%rdi)
mov    %esi,0x20(%rdi)
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # f95 <gsl_integration_qawo_table_set+0x35>
movsd  %xmm0,0x18(%rdi)
jne    fa5 <gsl_integration_qawo_table_set+0x45>
jmp    fd9 <gsl_integration_qawo_table_set+0x79>
xchg   %ax,%ax
movsd  0x18(%rbx),%xmm0
mov    %r12,%rdi
mulsd  %xmm1,%xmm0
add    0x28(%rbx),%rdi
movsd  %xmm1,0x8(%rsp)
add    $0x1,%rbp
add    $0xc8,%r12
callq  1f0 <compute_moments>
cmp    %rbp,(%rbx)
movsd  0x8(%rsp),%xmm1
mulsd  0x0(%rip),%xmm1        # fd7 <gsl_integration_qawo_table_set+0x77>
ja     fa0 <gsl_integration_qawo_table_set+0x40>
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_integration_qawo_table_set (gsl_integration_qawo_table * t,
                                    double omega, double L,
                                    enum gsl_integration_qawo_enum sine)
{
  t->omega = omega;
  t->sine = sine;
  t->L = L;
  t->par = 0.5 * omega * L;
  {
    size_t i;
    double scale = 1.0;
    for (i = 0 ; i < t->n; i++)
      {
        compute_moments (t->par * scale, t->chebmo + 25*i);
        scale *= 0.5;
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 12
3 4
4 12
5 4
6 4
7 4
8 5
9 12
10 8
11 7
12 6
13 8
14 11
15 8
16 12
17 12
18 12
19 12
20 14
21 14
22 14
23 14
24 12
25 12
26 14
27 12
28 15
29 15
30 12
31 19
32 19
33 19
34 19
35 19
36 19
37 19
<<<sep_out_sample>>>
push   %r12
cmpb   $0x0,(%rdx)
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
jne    5bb <revstrpbrk+0x1b>
cmp    %rdi,%rdx
je     5e9 <revstrpbrk+0x49>
sub    $0x1,%rbx
cmp    %rbx,%rbp
jbe    5d1 <revstrpbrk+0x31>
jmp    5e9 <revstrpbrk+0x49>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rbx
cmp    %rbx,%rbp
ja     5e4 <revstrpbrk+0x44>
movsbl (%rbx),%esi
mov    %r12,%rdi
callq  5dc <revstrpbrk+0x3c>
test   %rax,%rax
je     5c8 <revstrpbrk+0x28>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    5e4 <revstrpbrk+0x44>
nopl   (%rax)
<<<sep_in_sample>>>
revstrpbrk(const char *s, const char *accept, const char
 *rev_start)
{
    ((void) (0));
    if (*rev_start == '\0') {
 if (rev_start == s)
    return ((void *)0);
 rev_start--;
    }
    for (; rev_start >= s; rev_start--) {
 if (strchr(accept, *rev_start) != ((void *)0))
     return (char *)rev_start;
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 5
9 6
10 6
11 8
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 15
28 15
29 7
30 7
31 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     140 <gsl_eigen_herm_free+0x30>
mov    0x18(%rdi),%rdi
callq  122 <gsl_eigen_herm_free+0x12>
mov    0x10(%rbx),%rdi
callq  12b <gsl_eigen_herm_free+0x1b>
mov    0x8(%rbx),%rdi
callq  134 <gsl_eigen_herm_free+0x24>
mov    %rbx,%rdi
pop    %rbx
jmpq   13d <gsl_eigen_herm_free+0x2d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_herm_free (gsl_eigen_herm_workspace * w)
{
  if (!w) { return ; };
  free (w->tau);
  free (w->sd);
  free (w->d);
  free(w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 8
13 7
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x20(%rdi),%rcx
imul   (%rdi),%rdx
movsd  (%rcx),%xmm0
test   %rdx,%rdx
je     35 <gsl_histogram2d_max_val+0x35>
lea    0x8(%rcx),%rax
lea    (%rcx,%rdx,8),%rdx
jmp    30 <gsl_histogram2d_max_val+0x30>
nop
movsd  (%rax),%xmm1
add    $0x8,%rax
maxsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
cmp    %rdx,%rax
jne    20 <gsl_histogram2d_max_val+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_max_val (const gsl_histogram2d * h)
{
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  size_t i;
  double max = h->bin[0 * ny + 0];
  for (i = 0; i < nx * ny; i++)
    {
      if (h->bin[i] > max)
        {
          max = h->bin[i];
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 6
5 7
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 7
16 7
17 15
18 15
<<<sep_out_sample>>>
push   %rbx
mov    %esi,%ebx
callq  9c8 <mbox_set_attr_flags+0x8>
mov    %rax,%rdi
callq  9d0 <mbox_set_attr_flags+0x10>
mov    %rax,%rdx
mov    $0x16,%eax
test   %rdx,%rdx
je     9e2 <mbox_set_attr_flags+0x22>
or     %ebx,0x28(%rdx)
xor    %al,%al
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_set_attr_flags (mu_attribute_t attr, int flags)
{
  mu_message_t msg = mu_attribute_get_owner (attr);
  mbox_message_t mum = mu_message_get_owner (msg);
  if (mum == ((void *)0))
    return 22;
  mum->attr_flags |= flags;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 5
9 5
10 7
11 8
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x18(%rsi),%rbp
cmp    %rbp,%rdi
je     1760 <find_history+0x40>
mov    %rdx,%r12
mov    %rcx,%r13
jmp    175b <find_history+0x3b>
xchg   %ax,%ax
mov    (%rbx),%rsi
mov    %r13,%rdx
mov    %r12,%rdi
callq  174e <find_history+0x2e>
test   %eax,%eax
je     1770 <find_history+0x50>
mov    0x18(%rbx),%rbx
cmp    %rbp,%rbx
je     1760 <find_history+0x40>
test   %rbx,%rbx
jne    1740 <find_history+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
find_history(const filestruct *h_start, const filestruct
 *h_end, const char *s, size_t len)
{
    const filestruct *p;
    for (p = h_start; p != h_end->prev && p != ((void *)0); p = p->prev) {
 if (strncmp(s, p->data, len) == 0)
     return (filestruct *)p;
    }
    return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 5
21 5
22 5
23 5
24 5
25 10
26 9
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
<<<sep_out_sample>>>
orl    $0x1,0x48(%rdi)
mov    %rsi,0x40(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_auth_data_set_quota (struct mu_auth_data *ptr, mu_off_t q)
{
  ptr->flags |= 0x1;
  ptr->quota = q;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_get_domain (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->domain;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_reason_phrase (const osip_message_t * sip)
{
  return sip->reason_phrase;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0xa8,%rsp
mov    0x8(%rdi),%rsi
mov    %rbx,%rdi
callq  aaa <_mbox_is_scheme+0x1a>
test   %eax,%eax
je     ac0 <_mbox_is_scheme+0x30>
mov    %ebp,%eax
and    $0x2,%eax
add    $0xa8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %rbx,%rdi
callq  ac8 <_mbox_is_scheme+0x38>
test   %eax,%eax
je     ab3 <_mbox_is_scheme+0x23>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  ad9 <_mbox_is_scheme+0x49>
mov    0x8(%rsp),%rdi
lea    0x10(%rsp),%rsi
callq  ae8 <_mbox_is_scheme+0x58>
test   %eax,%eax
js     b60 <_mbox_is_scheme+0xd0>
mov    0x28(%rsp),%edx
and    $0xf000,%edx
cmp    $0x2000,%edx
je     b06 <_mbox_is_scheme+0x76>
cmp    $0x8000,%edx
jne    b40 <_mbox_is_scheme+0xb0>
cmpq   $0x0,0x40(%rsp)
je     b50 <_mbox_is_scheme+0xc0>
mov    %ebp,%eax
and    $0x2,%eax
cmp    $0x1,%eax
sbb    %ecx,%ecx
and    $0xfffffffe,%ecx
add    $0x3,%ecx
cmp    $0x1,%eax
sbb    %eax,%eax
not    %eax
and    $0x2,%eax
and    $0x1,%ebp
je     ab3 <_mbox_is_scheme+0x23>
cmp    $0x4000,%edx
cmove  %ecx,%eax
jmpq   ab3 <_mbox_is_scheme+0x23>
nopl   0x0(%rax,%rax,1)
mov    $0x1,%ecx
xor    %eax,%eax
jmp    b28 <_mbox_is_scheme+0x98>
nopl   0x0(%rax)
mov    $0x3,%ecx
mov    $0x2,%eax
jmp    b28 <_mbox_is_scheme+0x98>
nopl   0x0(%rax)
xor    %eax,%eax
jmpq   ab3 <_mbox_is_scheme+0x23>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mbox_is_scheme (mu_record_t record, mu_url_t url, int flags)
{
  int rc = 0;
  if (mu_url_is_scheme (url, record->scheme))
    return 0x002 & flags;
  if (mu_scheme_autodetect_p (url))
    {
      struct stat st;
      const char *path;
      mu_url_sget_path (url, &path);
      if (stat (path, &st) < 0)
 return 0;
      if (((((st.st_mode)) & 0170000) == (0100000)) || ((((st.st_mode)) & 0170000) == (0020000)))
 {
   if (st.st_size == 0)
     {
       rc |= 0x002;
     }
   else if (flags & 0x002)
     {
       rc |= 0x002;
     }
 }
      if ((flags & 0x001)
   && ((((st.st_mode)) & 0170000) == (0040000)))
 rc |= 0x001;
    }
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 29
14 29
15 29
16 29
17 29
18 6
19 6
20 6
21 6
22 10
23 10
24 10
25 11
26 11
27 11
28 11
29 11
30 13
31 13
32 13
33 13
34 13
35 13
36 15
37 15
38 19
39 19
40 19
41 19
42 19
43 19
44 19
45 19
46 19
47 19
48 24
49 24
50 26
51 26
52 26
53 26
54 13
55 3
56 3
57 3
58 15
59 17
60 17
61 17
62 12
63 12
64 12
<<<sep_out_sample>>>
sub    $0x58,%rsp
movapd %xmm0,%xmm5
movsd  0x0(%rip),%xmm4        # 200 <solve_cubic+0x10>
mulsd  %xmm5,%xmm0
mulsd  %xmm1,%xmm4
movsd  0x0(%rip),%xmm3        # 210 <solve_cubic+0x20>
mulsd  0x0(%rip),%xmm2        # 218 <solve_cubic+0x28>
xorpd  %xmm6,%xmm6
subsd  %xmm0,%xmm4
movapd %xmm5,%xmm0
addsd  %xmm5,%xmm0
divsd  %xmm3,%xmm4
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm0
mulsd  %xmm1,%xmm3
mulsd  %xmm5,%xmm0
subsd  %xmm2,%xmm3
movapd %xmm4,%xmm2
mulsd  %xmm4,%xmm2
subsd  %xmm0,%xmm3
mulsd  %xmm4,%xmm2
divsd  0x0(%rip),%xmm3        # 258 <solve_cubic+0x68>
movapd %xmm3,%xmm0
mulsd  %xmm3,%xmm0
addsd  %xmm0,%xmm2
ucomisd %xmm6,%xmm2
jb     388 <solve_cubic+0x198>
sqrtsd %xmm2,%xmm6
ucomisd %xmm6,%xmm6
movapd %xmm6,%xmm0
jp     465 <solve_cubic+0x275>
addsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm7        # 28c <solve_cubic+0x9c>
movsd  0x0(%rip),%xmm1        # 294 <solve_cubic+0xa4>
movsd  %xmm6,0x48(%rsp)
movsd  %xmm5,0x40(%rsp)
movapd %xmm0,%xmm4
movsd  %xmm0,0x30(%rsp)
movsd  %xmm2,0x38(%rsp)
andpd  %xmm7,%xmm4
movsd  %xmm3,0x20(%rsp)
movapd %xmm7,0x10(%rsp)
movapd %xmm4,%xmm0
movsd  %xmm4,0x8(%rsp)
callq  2cf <solve_cubic+0xdf>
movsd  0x8(%rsp),%xmm4
movsd  0x30(%rsp),%xmm8
movsd  0x48(%rsp),%xmm6
divsd  %xmm8,%xmm4
movapd 0x10(%rsp),%xmm7
ucomisd %xmm6,%xmm6
movsd  0x20(%rsp),%xmm3
movsd  0x38(%rsp),%xmm2
movsd  0x40(%rsp),%xmm5
mulsd  %xmm0,%xmm4
movapd %xmm6,%xmm0
jp     427 <solve_cubic+0x237>
subsd  %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # 31d <solve_cubic+0x12d>
movsd  %xmm5,0x20(%rsp)
movsd  %xmm4,0x30(%rsp)
andpd  %xmm3,%xmm7
movsd  %xmm3,0x10(%rsp)
movapd %xmm7,%xmm2
movapd %xmm2,%xmm0
movsd  %xmm2,0x8(%rsp)
callq  346 <solve_cubic+0x156>
movsd  0x8(%rsp),%xmm2
movsd  0x10(%rsp),%xmm3
movapd %xmm2,%xmm1
movsd  0x30(%rsp),%xmm4
movsd  0x20(%rsp),%xmm5
divsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
divsd  0x0(%rip),%xmm5        # 372 <solve_cubic+0x182>
addsd  %xmm1,%xmm4
add    $0x58,%rsp
movapd %xmm4,%xmm0
subsd  %xmm5,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm2        # 390 <solve_cubic+0x1a0>
xorpd  %xmm4,%xmm2
movapd %xmm2,%xmm0
mulsd  %xmm4,%xmm0
mulsd  %xmm4,%xmm0
sqrtsd %xmm0,%xmm1
ucomisd %xmm1,%xmm1
jp     4a3 <solve_cubic+0x2b3>
divsd  %xmm1,%xmm3
movsd  %xmm5,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movapd %xmm3,%xmm0
callq  3c7 <solve_cubic+0x1d7>
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
movsd  0x10(%rsp),%xmm5
sqrtsd %xmm2,%xmm4
ucomisd %xmm4,%xmm4
jp     4d5 <solve_cubic+0x2e5>
addsd  0x0(%rip),%xmm1        # 3ed <solve_cubic+0x1fd>
movsd  %xmm4,0x10(%rsp)
movsd  %xmm5,0x8(%rsp)
movapd %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 405 <solve_cubic+0x215>
callq  40a <solve_cubic+0x21a>
movsd  0x10(%rsp),%xmm4
xorpd  %xmm1,%xmm1
addsd  %xmm4,%xmm4
movsd  0x8(%rsp),%xmm5
mulsd  %xmm0,%xmm4
jmpq   36a <solve_cubic+0x17a>
movapd %xmm2,%xmm0
movsd  %xmm5,0x30(%rsp)
movapd %xmm7,0x20(%rsp)
movsd  %xmm3,0x10(%rsp)
movsd  %xmm4,0x8(%rsp)
callq  448 <solve_cubic+0x258>
movsd  0x30(%rsp),%xmm5
movapd 0x20(%rsp),%xmm7
movsd  0x10(%rsp),%xmm3
movsd  0x8(%rsp),%xmm4
jmpq   311 <solve_cubic+0x121>
movapd %xmm2,%xmm0
movsd  %xmm6,0x20(%rsp)
movsd  %xmm5,0x30(%rsp)
movsd  %xmm3,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
callq  486 <solve_cubic+0x296>
movsd  0x20(%rsp),%xmm6
movsd  0x30(%rsp),%xmm5
movsd  0x10(%rsp),%xmm3
movsd  0x8(%rsp),%xmm2
jmpq   280 <solve_cubic+0x90>
movsd  %xmm5,0x30(%rsp)
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  4ba <solve_cubic+0x2ca>
movsd  0x30(%rsp),%xmm5
movapd %xmm0,%xmm1
movsd  0x10(%rsp),%xmm2
movsd  0x8(%rsp),%xmm3
jmpq   3ae <solve_cubic+0x1be>
movsd  %xmm0,0x8(%rsp)
movapd %xmm2,%xmm0
callq  4e4 <solve_cubic+0x2f4>
movsd  0x10(%rsp),%xmm5
movapd %xmm0,%xmm4
movsd  0x8(%rsp),%xmm1
jmpq   3e5 <solve_cubic+0x1f5>
nopl   0x0(%rax)
<<<sep_in_sample>>>
solve_cubic(double c2, double c1, double c0)
{
  double qq, rr, ww, ss, tt;
  qq = (3*c1 - c2*c2)/9;
  rr = (9*c2*c1 - 27*c0 - 2*c2*c2*c2)/54;
  ww = qq*qq*qq + rr*rr;
  if (ww >= 0)
  {
      double t1 = rr + sqrt(ww);
      ss = fabs(t1)/t1*pow(fabs(t1), 1/3.);
      t1 = rr - sqrt(ww);
      tt = fabs(t1)/t1*pow(fabs(t1), 1/3.);
  }
  else
  {
      double theta = acos(rr/sqrt(-qq*qq*qq));
      ss = 2*sqrt(-qq)*cos((theta + 4*3.14159265358979323846)/3.);
      tt = 0.0;
  }
  return (ss + tt - c2/3);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 7
9 4
10 5
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 5
21 6
22 5
23 6
24 6
25 6
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 9
42 10
43 10
44 10
45 10
46 10
47 10
48 11
49 10
50 11
51 11
52 11
53 11
54 11
55 10
56 11
57 11
58 11
59 12
60 12
61 12
62 12
63 12
64 12
65 12
66 12
67 12
68 12
69 12
70 12
71 12
72 12
73 12
74 12
75 20
76 20
77 21
78 20
79 20
80 21
81 21
82 16
83 16
84 16
85 16
86 16
87 16
88 16
89 16
90 16
91 16
92 16
93 16
94 16
95 17
96 16
97 17
98 17
99 17
100 17
101 17
102 17
103 17
104 17
105 17
106 17
107 17
108 18
109 17
110 18
111 17
112 17
113 11
114 11
115 11
116 11
117 11
118 11
119 11
120 11
121 11
122 11
123 11
124 9
125 9
126 9
127 9
128 9
129 9
130 9
131 9
132 9
133 9
134 9
135 9
136 9
137 9
138 16
139 16
140 16
141 16
142 16
143 16
144 16
145 17
146 17
147 17
148 17
149 17
150 17
151 17
<<<sep_out_sample>>>
movq   $0x0,0x20(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_buffer_reset(struct nettle_buffer *buffer)
{
  buffer->size = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  15 <main+0x15>
mov    %ebx,%edi
mov    %rbp,%rsi
callq  1f <main+0x1f>
mov    0x0(%rip),%rdi        # 26 <main+0x26>
callq  2b <main+0x2b>
test   %rax,%rax
mov    %rax,%rbx
je     88 <main+0x88>
mov    %rbx,%rdi
callq  3b <main+0x3b>
mov    0x0(%rip),%rdi        # 42 <main+0x42>
callq  47 <main+0x47>
test   %al,%al
je     63 <main+0x63>
mov    0x0(%rip),%rsi        # 52 <main+0x52>
mov    %rbx,%rdi
callq  5a <main+0x5a>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%rbx        # 6a <main+0x6a>
mov    $0x0,%edi
callq  74 <main+0x74>
mov    %rax,%rdi
xor    %eax,%eax
mov    %rbx,%rsi
callq  81 <main+0x81>
mov    $0x1,%eax
jmp    5c <main+0x5c>
callq  8d <main+0x8d>
mov    %rax,%rbx
jmp    33 <main+0x33>
<<<sep_in_sample>>>
main (int argc, char *argv[])
{
  rec_db_t db;
  recutl_init ("recins");
  recins_parse_args (argc, argv);
  db = recutl_read_db_from_file (recins_file);
  if (!db)
    {
      db = rec_db_new ();
    }
  recins_add_new_record (db);
  if (!recutl_file_is_writable (recins_file))
    {
      recutl_error (gettext ("file %s is not writable.\n"), recins_file);
      return 1;
    }
  recutl_write_db_to_file (db, recins_file);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 5
10 5
11 6
12 6
13 7
14 6
15 7
16 11
17 11
18 12
19 12
20 12
21 12
22 17
23 17
24 17
25 18
26 19
27 19
28 19
29 19
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 15
38 15
39 9
40 9
41 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
jne    1b <CDB___db_vrfy_dbinfo_destroy+0x1b>
jmp    2b <CDB___db_vrfy_dbinfo_destroy+0x2b>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    0x10(%rdi),%rbx
xor    %esi,%esi
callq  26 <CDB___db_vrfy_dbinfo_destroy+0x26>
test   %rbx,%rbx
jne    18 <CDB___db_vrfy_dbinfo_destroy+0x18>
mov    0x10(%rbp),%rax
xor    %esi,%esi
mov    %rax,%rdi
callq  *0xe8(%rax)
mov    %eax,%ebx
mov    0x18(%rbp),%rax
xor    %esi,%esi
mov    %rax,%rdi
callq  *0xe8(%rax)
test   %eax,%eax
mov    %eax,%r12d
je     80 <CDB___db_vrfy_dbinfo_destroy+0x80>
test   %ebx,%ebx
mov    0x28(%rbp),%rax
cmovne %ebx,%r12d
xor    %esi,%esi
mov    %r12d,%ebx
mov    %rax,%rdi
callq  *0xe8(%rax)
mov    %rbp,%rdi
mov    $0x48,%esi
callq  77 <CDB___db_vrfy_dbinfo_destroy+0x77>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    0x28(%rbp),%rax
xor    %esi,%esi
mov    %rax,%rdi
callq  *0xe8(%rax)
test   %eax,%eax
je     6a <CDB___db_vrfy_dbinfo_destroy+0x6a>
test   %ebx,%ebx
cmove  %eax,%ebx
jmp    6a <CDB___db_vrfy_dbinfo_destroy+0x6a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_vrfy_dbinfo_destroy(vdp)
 VRFY_DBINFO *vdp;
{
 VRFY_CHILDINFO *c, *d;
 int t_ret, ret;
 ret = 0;
 for (c = ((&vdp->subdbs)->lh_first); c != ((void *)0); c = d) {
  d = ((c)->links.le_next);
  CDB___os_free(c, 0);
 }
 if ((t_ret = vdp->pgdbp->close(vdp->pgdbp, 0)) != 0)
  ret = t_ret;
 if ((t_ret = vdp->cdbp->close(vdp->cdbp, 0)) != 0 && ret == 0)
  ret = t_ret;
 if ((t_ret = vdp->pgset->close(vdp->pgset, 0)) != 0 && ret == 0)
  ret = t_ret;
 ((void)0);
 CDB___os_free(vdp, sizeof(VRFY_DBINFO));
 return (ret);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 7
8 7
9 7
10 7
11 8
12 9
13 9
14 7
15 7
16 11
17 11
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 15
30 13
31 15
32 15
33 15
34 15
35 18
36 18
37 18
38 20
39 20
40 20
41 20
42 20
43 20
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  939 <gsl_blas_srotmg+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
{
  cblas_srotmg (d1, d2, b1, b2, P);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
callq  a <echo_finish+0xa>
mov    0x0(%rip),%rcx        # 11 <echo_finish+0x11>
xor    %edx,%edx
mov    0xb0(%rcx),%rax
test   %rax,%rax
je     2c <echo_finish+0x2c>
cmpq   $0xf,0x0(%rip)        # 27 <echo_finish+0x27>
mov    %rax,%rdx
ja     40 <echo_finish+0x40>
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
add    0xb8(%rcx),%rax
mov    0x68(%rcx),%rbx
js     c8 <echo_finish+0xc8>
cvtsi2sd %rax,%xmm1
movsd  0x10(%rbx),%xmm4
movsd  0x18(%rbx),%xmm0
divsd  %xmm1,%xmm4
divsd  %xmm1,%xmm0
movapd %xmm4,%xmm1
movsd  %xmm4,0x8(%rsp)
mulsd  %xmm4,%xmm1
subsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 7e <echo_finish+0x7e>
callq  83 <echo_finish+0x83>
movsd  0x8(%rsp),%xmm4
mov    $0x0,%edi
movapd %xmm0,%xmm3
mov    $0x4,%eax
movsd  0x8(%rbx),%xmm2
movsd  (%rbx),%xmm0
movapd %xmm4,%xmm1
callq  a9 <echo_finish+0xa9>
mov    0x0(%rip),%rax        # b0 <echo_finish+0xb0>
mov    0xb0(%rax),%rdx
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
add    $0x10,%rsp
pop    %rbx
retq   
nopl   (%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   52 <echo_finish+0x52>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_finish (void)
{
  ping_finish ();
  if (ping->ping_num_recv && ((data_length) >= sizeof (struct timeval)))
    {
      struct ping_stat *ping_stat = (struct ping_stat *) ping->ping_closure;
      double total = ping->ping_num_recv + ping->ping_num_rept;
      double avg = ping_stat->tsum / total;
      double vari = ping_stat->tsumsq / total - avg * avg;
      printf ("round-trip min/avg/max/stddev = %.3f/%.3f/%.3f/%.3f ms\n",
       ping_stat->tmin, avg, ping_stat->tmax, nsqrt (vari, 0.0005));
    }
  return (ping->ping_num_recv == 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 13
13 13
14 13
15 14
16 14
17 14
18 14
19 7
20 6
21 7
22 7
23 8
24 9
25 8
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 10
43 13
44 13
45 13
46 14
47 14
48 14
49 14
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
test   %rax,%rax
je     1e50 <sexget_lineno+0x20>
mov    0x18(%rdi),%rdx
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     1e50 <sexget_lineno+0x20>
mov    0x30(%rax),%eax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexget_lineno (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (! ( yyg->yy_buffer_stack ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] : ((void *)0)))
            return 0;
    return (yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]->yy_bs_lineno);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 5
12 7
13 7
<<<sep_out_sample>>>
movzbl 0x19(%rdx),%eax
mov    %rcx,%r10
mov    %eax,%ecx
and    $0xf,%ecx
cmp    $0xc,%cl
ja     a5 <CDB___db_pgout+0x35>
mov    $0x1,%r8d
shl    %cl,%r8
test   $0x12f8,%r8d
jne    b8 <CDB___db_pgout+0x48>
test   $0x105,%r8d
jne    d0 <CDB___db_pgout+0x60>
test   $0xc00,%r8d
jne    c0 <CDB___db_pgout+0x50>
movzbl %al,%edx
mov    $0x0,%esi
jmpq   b2 <CDB___db_pgout+0x42>
nopw   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   c0 <CDB___db_pgout+0x50>
mov    %r10,%rcx
jmpq   c8 <CDB___db_pgout+0x58>
nopl   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   d8 <CDB___db_pgout+0x68>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_pgout(dbenv, pg, pp, cookie)
 DB_ENV *dbenv;
 db_pgno_t pg;
 void *pp;
 DBT *cookie;
{
 switch (((((PAGE *)pp)->type) & 0x0f)) {
 case 2:
 case 8:
 case 0:
  return (CDB___ham_pgout(dbenv, pg, pp, cookie));
 case 9:
 case 3:
 case 4:
 case 5:
 case 12:
 case 6:
 case 7:
  return (CDB___bam_pgout(dbenv, pg, pp, cookie));
 case 10:
 case 11:
  return (CDB___qam_pgin_out(dbenv, pg, pp, cookie));
 default:
  break;
 }
 return (CDB___db_unknown_type(dbenv, "CDB___db_pgout", ((PAGE *)pp)->type));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 26
16 26
17 26
18 26
19 19
20 19
21 22
22 22
23 22
24 11
25 11
26 11
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x10,%rsp
mov    0x4(%rsi),%eax
mov    0x4(%rsi),%ebx
sar    $0x1f,%eax
xor    %eax,%ebx
sub    %eax,%ebx
cmp    %rdi,%rsi
movslq %ebx,%rdx
je     38 <__gmpz_abs+0x38>
movslq (%rdi),%rax
cmp    %rax,%rdx
jg     46 <__gmpz_abs+0x46>
mov    0x8(%rdi),%rdi
mov    0x8(%rbp),%rsi
callq  38 <__gmpz_abs+0x38>
mov    %ebx,0x4(%r12)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rdx,%rsi
mov    %rdx,0x8(%rsp)
callq  53 <__gmpz_abs+0x53>
mov    0x8(%rsp),%rdx
mov    %rax,%rdi
jmp    2f <__gmpz_abs+0x2f>
<<<sep_in_sample>>>
__gmpz_abs (mpz_ptr w, mpz_srcptr u)
{
  mp_ptr wp;
  mp_srcptr up;
  mp_size_t size;
  size = ((((u)->_mp_size)) >= 0 ? (((u)->_mp_size)) : -(((u)->_mp_size)));
  if (u != w)
    {
      wp = (__builtin_expect (((size) > ((w)->_mp_alloc)) != 0, 0) ? (mp_ptr) __gmpz_realloc(w,size) : ((w)->_mp_d));
      up = ((u)->_mp_d);
      do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (wp, up, size); } while (0); } while (0);
    }
  ((w)->_mp_size) = size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 9
16 9
17 9
18 9
19 11
20 11
21 13
22 14
23 14
24 14
25 14
26 14
27 9
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
test   %edi,%edi
push   %rbx
jne    710 <sh_ttyerror+0x30>
callq  6ea <sh_ttyerror+0xa>
mov    (%rax),%edi
callq  6f1 <sh_ttyerror+0x11>
mov    $0x0,%edi
mov    %rax,%rbx
callq  6fe <sh_ttyerror+0x1e>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   70c <sh_ttyerror+0x2c>
nopl   0x0(%rax)
callq  715 <sh_ttyerror+0x35>
mov    (%rax),%edi
callq  71c <sh_ttyerror+0x3c>
mov    $0x0,%edi
mov    %rax,%rbx
jmp    6f9 <sh_ttyerror+0x19>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_ttyerror (set)
     int set;
{
  if (set)
    builtin_error (gettext("error setting terminal attributes: %s"), strerror ((*__errno_location ())));
  else
    builtin_error (gettext("error getting terminal attributes: %s"), strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 7
15 7
16 5
17 5
18 5
19 5
20 5
21 5
22 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  b <redir_exit+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
redir_exit (int sig)
{
  _exit (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     6f0 <_log_handler+0x40>
cmp    $0x2,%edi
je     6d8 <_log_handler+0x28>
cmp    $0x3,%edi
jne    6c9 <_log_handler+0x19>
mov    0x0(%rip),%eax        # 6c5 <_log_handler+0x15>
test   %eax,%eax
jne    6e8 <_log_handler+0x38>
mov    0x0(%rip),%rax        # 6d0 <_log_handler+0x20>
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%edx        # 6de <_log_handler+0x2e>
test   %edx,%edx
jne    6c9 <_log_handler+0x19>
repz retq 
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
cmpl   $0x1,0x0(%rip)        # 6f7 <_log_handler+0x47>
ja     6c9 <_log_handler+0x19>
repz retq 
<<<sep_in_sample>>>
_log_handler (cdio_log_level_t level, const char message[])
{
  if (level == CDIO_LOG_DEBUG && opts.debug_level < 2)
    return;
  if (level == CDIO_LOG_INFO && opts.debug_level < 1)
    return;
  if (level == CDIO_LOG_WARN && opts.silent)
    return;
  gl_default_cdio_log_handler (level, message);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 3
21 3
22 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <CDB___os_closehandle+0x7>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %rax,%rax
je     40 <CDB___os_closehandle+0x40>
callq  *%rax
andb   $0xfd,0x8(%rbx)
test   %eax,%eax
movl   $0xffffffff,(%rbx)
jne    30 <CDB___os_closehandle+0x30>
xor    %eax,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
jmpq   36 <CDB___os_closehandle+0x36>
nopw   %cs:0x0(%rax,%rax,1)
callq  45 <CDB___os_closehandle+0x45>
jmp    14 <CDB___os_closehandle+0x14>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___os_closehandle(fhp)
 DB_FH *fhp;
{
 int ret;
 ((void)0);
 ret = CDB___db_jump.j_close != ((void *)0) ?
     CDB___db_jump.j_close(fhp->fd) : close(fhp->fd);
 fhp->fd = -1;
 (fhp)->flags &= ~(0x02);
 return (ret == 0 ? 0 : CDB___os_get_errno());
}
<<<sep_in_sample>>>
1 6
2 3
3 3
4 7
5 7
6 7
7 7
8 9
9 10
10 8
11 10
12 11
13 11
14 11
15 11
16 11
17 10
18 10
19 7
20 7
21 7
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_add_1_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
mov    $0x18,%esi
mov    $0x1,%edi
jmpq   f <_cdio_list_new+0xf>
nop
<<<sep_in_sample>>>
_cdio_list_new (void)
{
  CdioList_t *p_new_obj = calloc (1, sizeof (CdioList_t));
  return p_new_obj;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    $0x2800,%esi
mov    (%rdi),%rdi
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bench_hash(void *arg)
{
  struct bench_hash_info *info = arg;
  info->update(info->ctx, 10240, info->data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    %rsp,%rdi
callq  10 <printf_frexp+0x10>
mov    (%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,(%rsp)
jge    34 <printf_frexp+0x34>
lea    0x3fd(%rdx),%edi
callq  2f <printf_frexp+0x2f>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
push   %r12
lea    0x38(%rdi),%r12
push   %rbp
mov    %r12,%rdi
mov    %rdx,%rbp
push   %rbx
mov    %esi,%ebx
movq   $0x0,(%rdx)
callq  1dc <osip_message_get_accept_encoding+0x1c>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    1f5 <osip_message_get_accept_encoding+0x35>
mov    %ebx,%esi
mov    %r12,%rdi
callq  1ef <osip_message_get_accept_encoding+0x2f>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_message_get_accept_encoding (const osip_message_t * sip, int pos, osip_accept_encoding_t ** dest)
{
  osip_accept_encoding_t *accept_encoding;
  *dest = ((void *)0);
  if (osip_list_size (&sip->accept_encodings) <= pos)
    return -1;
  accept_encoding = (osip_accept_encoding_t *) osip_list_get (&sip->accept_encodings, pos);
  *dest = accept_encoding;
  return pos;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 4
9 5
10 5
11 6
12 5
13 7
14 7
15 7
16 9
17 8
18 10
19 10
20 10
21 10
22 10
23 10
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    2aa8 <gsl_matrix_int_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2aca <gsl_matrix_int_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_column (gsl_matrix_int * m, const size_t j)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
jmpq   a5 <zreadintr+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
zreadintr (fd, buf, len)
     int fd;
     char *buf;
     size_t len;
{
  return (read (fd, buf, len));
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
mov    (%rdi),%ecx
test   %ecx,%ecx
jne    40 <version_null_p+0x20>
mov    0x4(%rdi),%edx
test   %edx,%edx
jne    40 <version_null_p+0x20>
mov    0x8(%rdi),%eax
test   %eax,%eax
sete   %al
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_null_p (version_t version)
{
  size_t n;
  for (n = 0 ; n < 3 ; n++)
    if (version[n])
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   %edx,%edx
jne    7b0 <fprintPwd+0x20>
add    $0x18,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
pop    %rbx
pop    %rbp
jmpq   1c0 <_fprintPwd>
nop
mov    %rdi,%rsi
mov    $0x22,%edi
mov    %edx,0xc(%rsp)
callq  7c1 <fprintPwd+0x31>
mov    0xc(%rsp),%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
mov    %edx,%ecx
xor    %edx,%edx
callq  1c0 <_fprintPwd>
add    $0x18,%rsp
mov    %rbx,%rsi
mov    $0x22,%edi
pop    %rbx
pop    %rbp
jmpq   7e7 <fprintPwd+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fprintPwd(FILE *f, direntry_t *entry, int escape)
{
 if (escape)
  _IO_putc ('"', f);
 _fprintPwd(f, entry, 0, escape);
 if(escape)
  _IO_putc ('"', f);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 8
9 5
10 5
11 8
12 8
13 5
14 5
15 4
16 4
17 4
18 4
19 5
20 5
21 5
22 5
23 5
24 5
25 8
26 7
27 7
28 8
29 8
30 7
31 7
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  181 <_s_get_transport2+0x11>
mov    (%rax),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
mov    %rbp,%rdx
pop    %rbp
jmpq   195 <_s_get_transport2+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_s_get_transport2 (mu_stream_t stream,
     mu_transport_t *pin, mu_transport_t *pout)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_get_transport2 (s->fstream, pin, pout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 6
9 5
10 6
11 5
12 6
13 5
14 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 9fa <gsl_matrix_float_get+0xa>
test   %eax,%eax
je     a09 <gsl_matrix_float_get+0x19>
cmp    %rsi,(%rdi)
jbe    a20 <gsl_matrix_float_get+0x30>
cmp    %rdx,0x8(%rdi)
jbe    a48 <gsl_matrix_float_get+0x58>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
movss  (%rax,%rdx,4),%xmm0
add    $0x8,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x115,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a39 <gsl_matrix_float_get+0x49>
xorps  %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x119,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a61 <gsl_matrix_float_get+0x71>
xorps  %xmm0,%xmm0
jmp    a1a <gsl_matrix_float_get+0x2a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_get(const gsl_matrix_float * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_float.h", 277, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_float.h", 281, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return m->data[i * m->tda + j] ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 15
23 15
24 15
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 1b36 <close_conversion+0x6>
test   %edx,%edx
jne    1b40 <close_conversion+0x10>
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1b4b <close_conversion+0x1b>
callq  1b50 <close_conversion+0x20>
mov    0x0(%rip),%eax        # 1b56 <close_conversion+0x26>
test   %eax,%eax
je     1b60 <close_conversion+0x30>
add    $0x8,%rsp
retq   
nop
mov    0x0(%rip),%rdi        # 1b67 <close_conversion+0x37>
add    $0x8,%rsp
jmpq   1b70 <save_conversion_state>
<<<sep_in_sample>>>
close_conversion (void)
{
  if (convert_encoding_p)
    {
      iconv_close (iconv_to_output);
      if (!file_is_in_utf8) iconv_close (iconv_to_utf8);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 8
5 8
6 2
7 5
8 5
9 6
10 6
11 6
12 8
13 8
14 8
15 6
16 8
17 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movzbl 0x10(%rdi),%eax
mov    0x8(%rdi),%rdx
test   %eax,%eax
je     58 <function_table_entry_hash_1+0x58>
cmp    $0x1,%eax
je     58 <function_table_entry_hash_1+0x58>
movzbl (%rdx),%esi
test   %sil,%sil
je     70 <function_table_entry_hash_1+0x70>
lea    -0x2(%rax),%r8d
xor    %eax,%eax
add    %rdx,%r8
jmp    34 <function_table_entry_hash_1+0x34>
nopl   0x0(%rax)
test   %sil,%sil
lea    0x1(%rdx),%rcx
je     68 <function_table_entry_hash_1+0x68>
mov    %rcx,%rdx
movzbl %sil,%edi
movzbl 0x1(%rdx),%esi
mov    %esi,%ecx
and    $0xf,%ecx
shl    %cl,%edi
movslq %edi,%rdi
add    %rdi,%rax
cmp    %r8,%rdx
jne    28 <function_table_entry_hash_1+0x28>
add    %rsi,%rax
retq   
nopw   0x0(%rax,%rax,1)
movzbl (%rdx),%esi
xor    %eax,%eax
add    %rsi,%rax
retq   
nopl   0x0(%rax)
movzbl 0x2(%rdx),%esi
add    %rsi,%rax
retq   
movzbl 0x1(%rdx),%esi
xor    %eax,%eax
jmp    4e <function_table_entry_hash_1+0x4e>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
function_table_entry_hash_1 (const void *keyv)
{
  const struct function_table_entry *key = keyv;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((key->name)) - 1; int _n_ = ((key->len)); if (_n_) while (--_n_ && *++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); (_result_) += *++_key_; } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 5
30 5
31 5
32 4
33 4
34 5
35 5
36 5
37 4
38 5
39 5
40 4
41 4
42 4
<<<sep_out_sample>>>
mov    0x20(%rsi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_node_value (gl_list_t list, gl_list_node_t node)
{
  return node->value;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x118,%rsp
mov    %rdi,%r8
mov    %fs:0x28,%rax
mov    %rax,0x108(%rsp)
xor    %eax,%eax
test   %rdi,%rdi
mov    $0xffffffffffffffff,%rax
je     fa8 <dstrspn+0xb8>
cmpq   $0x0,0x10(%rdi)
je     fd8 <dstrspn+0xe8>
test   %rsi,%rsi
mov    $0xffffffffffffffff,%rax
je     fa8 <dstrspn+0xb8>
cmpq   $0x0,0x10(%rsi)
je     fc8 <dstrspn+0xd8>
xor    %eax,%eax
mov    $0x20,%ecx
mov    %rsp,%rdi
rep stos %rax,%es:(%rdi)
mov    (%rsi),%rcx
test   %rcx,%rcx
je     f70 <dstrspn+0x80>
mov    0x10(%rsi),%rax
add    %rax,%rcx
nopl   0x0(%rax,%rax,1)
movzbl (%rax),%edx
add    $0x1,%rax
cmp    %rcx,%rax
movb   $0xff,(%rsp,%rdx,1)
jne    f60 <dstrspn+0x70>
mov    (%r8),%rcx
xor    %eax,%eax
test   %rcx,%rcx
je     fa8 <dstrspn+0xb8>
mov    0x10(%r8),%rsi
movzbl (%rsi),%eax
cmpb   $0x0,(%rsp,%rax,1)
mov    $0x0,%eax
jne    f9a <dstrspn+0xaa>
jmp    fa8 <dstrspn+0xb8>
xchg   %ax,%ax
movzbl (%rsi,%rax,1),%edx
cmpb   $0x0,(%rsp,%rdx,1)
je     fa8 <dstrspn+0xb8>
add    $0x1,%rax
cmp    %rcx,%rax
jne    f90 <dstrspn+0xa0>
nopl   0x0(%rax,%rax,1)
mov    0x108(%rsp),%rdi
xor    %fs:0x28,%rdi
jne    fe5 <dstrspn+0xf5>
add    $0x118,%rsp
retq   
nopl   0x0(%rax,%rax,1)
cmpq   $0x0,(%rsi)
jne    fa8 <dstrspn+0xb8>
jmpq   f3f <dstrspn+0x4f>
nopl   0x0(%rax,%rax,1)
cmpq   $0x0,(%rdi)
jne    fa8 <dstrspn+0xb8>
xchg   %ax,%ax
jmpq   f28 <dstrspn+0x38>
callq  fea <dstrspn+0xfa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dstrspn (string, charset)
     DStr_string_descriptor *string;
     DStr_string_descriptor *charset;
{
  char charlist[256];
  size_t i;
  if ((string) == ((void *)0) || ((string)->string == ((void *)0) && (string)->length != 0))
    return -1;
  if ((charset) == ((void *)0) || ((charset)->string == ((void *)0) && (charset)->length != 0))
    return -1;
  bzero (charlist, 256);
  for (i = 0; i < charset->length; i++)
    charlist[charset->string[i]] = -1;
  for (i = 0; i < string->length; i++)
    if (charlist[string->string[i]] == 0)
      return i;
  return string->length;
  }
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 8
8 7
9 7
10 7
11 9
12 8
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 12
21 12
22 12
23 12
24 12
25 12
26 13
27 13
28 12
29 13
30 12
31 14
32 14
33 14
34 14
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 14
46 14
47 14
48 14
49 18
50 18
51 18
52 18
53 18
54 18
55 9
56 9
57 9
58 9
59 7
60 7
61 7
62 7
63 18
64 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x18(%rdi),%rbp
mov    (%rdi),%r14
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%r15
movsd  0x0(%rbp),%xmm3
test   %r14,%r14
movsd  %xmm3,(%rsp)
je     653 <gsl_matrix_max+0xa3>
shl    $0x3,%r15
xor    %r13d,%r13d
test   %r12,%r12
je     640 <gsl_matrix_max+0x90>
xor    %ebx,%ebx
jmp    5f9 <gsl_matrix_max+0x49>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    %r12,%rbx
je     640 <gsl_matrix_max+0x90>
movsd  0x0(%rbp,%rbx,8),%xmm1
movapd %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
movapd %xmm1,%xmm0
maxsd  (%rsp),%xmm2
movsd  %xmm2,(%rsp)
callq  61c <gsl_matrix_max+0x6c>
test   %eax,%eax
movsd  0x8(%rsp),%xmm1
je     5f0 <gsl_matrix_max+0x40>
add    $0x18,%rsp
movapd %xmm1,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x1,%r13
add    %r15,%rbp
cmp    %r14,%r13
jne    5e3 <gsl_matrix_max+0x33>
movsd  (%rsp),%xmm1
jmp    626 <gsl_matrix_max+0x76>
movapd %xmm3,%xmm1
jmp    626 <gsl_matrix_max+0x76>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_max (const gsl_matrix * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  double max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          double x = m->data[i * tda + j];
          if (x > max)
            max = x;
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            return x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 3
10 4
11 5
12 6
13 8
14 6
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 12
27 12
28 15
29 15
30 12
31 12
32 15
33 15
34 15
35 15
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 8
47 8
48 8
49 8
50 8
51 8
52 8
53 8
54 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
je     3f <precmd+0x3f>
cmpq   $0x0,0x40(%rdi)
je     3f <precmd+0x3f>
callq  19 <precmd+0x19>
cmp    $0xffffffff,%eax
je     60 <precmd+0x60>
test   %eax,%eax
jne    48 <precmd+0x48>
mov    0x40(%rbx),%rcx
xor    %r8d,%r8d
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  3f <precmd+0x3f>
add    $0x10,%rsp
pop    %rbx
retq   
nopl   (%rax)
mov    %rsp,%rdi
callq  50 <precmd+0x50>
add    $0x10,%rsp
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  6a <precmd+0x6a>
mov    $0x1,%edi
callq  74 <precmd+0x74>
<<<sep_in_sample>>>
precmd(struct device *dev)
{
 int status;
 pid_t pid;
 if(!dev || !dev->precmd)
  return;
 switch((pid=fork())){
  case -1:
   perror("Could not fork");
   exit(1);
   break;
  case 0:
   execl("/bin/sh", "sh", "-c", dev->precmd, (char *)((void *)0));
   break;
  default:
   wait(&status);
   break;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 19
21 19
22 19
23 19
24 16
25 16
26 19
27 19
28 19
29 19
30 9
31 9
32 10
33 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
movzbl %r8b,%r8d
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_create_empty (gl_list_implementation_t implementation,
        gl_listelement_equals_fn equals_fn,
        gl_listelement_hashcode_fn hashcode_fn,
        gl_listelement_dispose_fn dispose_fn,
        _Bool allow_duplicates)
{
  return implementation->create_empty (implementation, equals_fn, hashcode_fn,
           dispose_fn, allow_duplicates);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
xor    %edx,%edx
cmp    %rax,0x8(%rdi)
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
jmpq   35 <rec_record_comment_disp_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_comment_disp_fn (void *data)
{
  rec_comment_destroy ((rec_comment_t) data);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x0(%rip),%edx        # 11 <do_set_limit+0x11>
test   %edx,%edx
je     30 <do_set_limit+0x30>
mov    0x0(%rip),%eax        # 1b <do_set_limit+0x1b>
test   %eax,%eax
jne    80 <do_set_limit+0x80>
mov    %rbx,%rdx
mov    %ebp,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  30 <do_set_limit+0x30>
mov    %rsp,%rsi
mov    %ebp,%edi
mov    %rbx,(%rsp)
mov    %rbx,0x8(%rsp)
callq  43 <do_set_limit+0x43>
test   %eax,%eax
je     77 <do_set_limit+0x77>
callq  4c <do_set_limit+0x4c>
mov    (%rax),%edi
callq  53 <do_set_limit+0x53>
mov    $0x0,%edi
mov    %rax,%rbx
callq  60 <do_set_limit+0x60>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x5,%edi
xor    %eax,%eax
callq  72 <do_set_limit+0x72>
mov    $0x1,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    $0x0,%r8d
mov    $0x35,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  a1 <do_set_limit+0xa1>
jmpq   1f <do_set_limit+0x1f>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_set_limit (int rlimit, rlim_t limit)
{
  struct rlimit rlim;
  do if (debug_level >= 1) { if (source_info_option) logmsg_printf (7, "%s:%lu:%s: ", "limits.c", 53, __FUNCTION__); debug_msg ("setting limit %d to %lu", rlimit, (unsigned long) limit); } while (0);
  rlim.rlim_cur = limit;
  rlim.rlim_max = limit;
  if (setrlimit(rlimit, &rlim))
    {
      logmsg (5, gettext("error setting limit: %s"),
       strerror ((*__errno_location ())));
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 7
18 7
19 5
20 6
21 7
22 7
23 7
24 10
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 14
37 14
38 14
39 14
40 14
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
test   %rdx,%rdx
je     2d <__gmpf_get_d+0x2d>
mov    %rdx,%rax
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rdi
sar    $0x3f,%rax
mov    %rax,%rsi
xor    %rdx,%rsi
sub    %rax,%rsi
sub    %rsi,%rcx
shl    $0x6,%rcx
jmpq   2d <__gmpf_get_d+0x2d>
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
__gmpf_get_d (mpf_srcptr src)
{
  mp_size_t size, abs_size;
  long exp;
  size = ((src)->_mp_size);
  if (__builtin_expect ((size == 0) != 0, 0))
    return 0.0;
  abs_size = ((size) >= 0 ? (size) : -(size));
  exp = (((src)->_mp_exp) - abs_size) * (64 - 0);
  return __gmpn_get_d (((src)->_mp_d), abs_size, size, exp);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 8
5 9
6 10
7 8
8 8
9 8
10 8
11 9
12 9
13 10
14 11
15 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <cache_open+0x9>
mov    %rax,0x0(%rip)        # 10 <cache_open+0x10>
callq  15 <cache_open+0x15>
mov    0x0(%rip),%edx        # 1b <cache_open+0x1b>
mov    %rax,0x0(%rip)        # 22 <cache_open+0x22>
xor    %eax,%eax
test   %edx,%edx
je     2d <cache_open+0x2d>
callq  2d <cache_open+0x2d>
mov    %rax,0x0(%rip)        # 34 <cache_open+0x34>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cache_open(void)
{
 assoc[1] = assoc_open();
 assoc[2] = assoc_open();
 assoc[3] = symbol ? assoc_open() : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 4
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rcx
xor    %eax,%eax
fldt   0x8(%rsp)
mov    0x10(%rdi),%rdx
shl    $0x4,%rcx
test   %rsi,%rsi
je     13a4 <gsl_vector_long_double_set_all+0x34>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
fld    %st(0)
fstpt  (%rdx)
add    %rcx,%rdx
cmp    %rsi,%rax
jne    1390 <gsl_vector_long_double_set_all+0x20>
fstp   %st(0)
jmp    13b0 <gsl_vector_long_double_set_all+0x40>
fstp   %st(0)
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_set_all (gsl_vector_long_double * v, long double x)
{
  long double * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long double *) (data + 1 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
sub    $0x58,%rsp
xorpd  %xmm0,%xmm0
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x18(%rsp)
ucomisd %xmm3,%xmm0
ja     1e0 <gsl_ran_fdist_pdf+0x160>
movsd  0x0(%rip),%xmm5        # a9 <gsl_ran_fdist_pdf+0x29>
movapd %xmm1,%xmm0
movsd  %xmm1,0x28(%rsp)
mulsd  %xmm1,%xmm5
movsd  %xmm5,0x8(%rsp)
callq  c2 <gsl_ran_fdist_pdf+0x42>
movsd  (%rsp),%xmm4
movsd  0x0(%rip),%xmm6        # cf <gsl_ran_fdist_pdf+0x4f>
movsd  %xmm0,0x20(%rsp)
movapd %xmm4,%xmm0
mulsd  %xmm4,%xmm6
movsd  %xmm6,0x10(%rsp)
callq  e8 <gsl_ran_fdist_pdf+0x68>
movsd  0x28(%rsp),%xmm1
movsd  (%rsp),%xmm4
movsd  0x20(%rsp),%xmm2
addsd  %xmm1,%xmm4
mulsd  0x10(%rsp),%xmm0
movsd  %xmm1,0x40(%rsp)
mulsd  0x8(%rsp),%xmm2
mulsd  0x0(%rip),%xmm4        # 117 <gsl_ran_fdist_pdf+0x97>
addsd  %xmm0,%xmm2
movapd %xmm4,%xmm0
movsd  %xmm4,0x38(%rsp)
movsd  %xmm2,0x48(%rsp)
callq  130 <gsl_ran_fdist_pdf+0xb0>
movsd  %xmm0,0x20(%rsp)
movsd  0x8(%rsp),%xmm0
callq  141 <gsl_ran_fdist_pdf+0xc1>
movsd  %xmm0,0x28(%rsp)
movsd  0x10(%rsp),%xmm0
callq  152 <gsl_ran_fdist_pdf+0xd2>
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x10(%rsp)
movapd %xmm3,%xmm0
movsd  %xmm3,0x30(%rsp)
callq  16d <gsl_ran_fdist_pdf+0xed>
movsd  0x40(%rsp),%xmm1
movsd  0x30(%rsp),%xmm3
movsd  %xmm0,0x18(%rsp)
mulsd  %xmm3,%xmm1
movsd  (%rsp),%xmm0
addsd  %xmm1,%xmm0
callq  191 <gsl_ran_fdist_pdf+0x111>
movsd  0x48(%rsp),%xmm2
movsd  0x20(%rsp),%xmm1
movsd  0x38(%rsp),%xmm4
addsd  %xmm2,%xmm1
movsd  0x8(%rsp),%xmm2
mulsd  %xmm4,%xmm0
subsd  0x0(%rip),%xmm2        # 1b9 <gsl_ran_fdist_pdf+0x139>
subsd  0x28(%rsp),%xmm1
mulsd  0x18(%rsp),%xmm2
subsd  0x10(%rsp),%xmm1
add    $0x58,%rsp
addsd  %xmm2,%xmm1
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
jmpq   1e0 <gsl_ran_fdist_pdf+0x160>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_fdist_pdf (const double x, const double nu1, const double nu2)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      double p;
      double lglg = (nu1 / 2) * log (nu1) + (nu2 / 2) * log (nu2) ;
      double lg12 = gsl_sf_lngamma ((nu1 + nu2) / 2);
      double lg1 = gsl_sf_lngamma (nu1 / 2);
      double lg2 = gsl_sf_lngamma (nu2 / 2);
      p =
 exp (lglg + lg12 - lg1 - lg2 + (nu1 / 2 - 1) * log (x) -
      ((nu1 + nu2) / 2) * log (nu2 + nu1 * x));
      return p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 3
6 3
7 3
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 11
22 11
23 10
24 11
25 10
26 11
27 10
28 11
29 10
30 11
31 11
32 10
33 11
34 11
35 12
36 12
37 12
38 13
39 13
40 15
41 13
42 15
43 15
44 15
45 16
46 16
47 15
48 16
49 16
50 16
51 16
52 15
53 15
54 16
55 15
56 15
57 16
58 15
59 15
60 15
61 15
62 19
63 15
64 15
65 14
66 14
67 19
68 19
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
flip_execute_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     97a <grecs_symtab_enumerate+0x5a>
mov    0x4(%rdi),%eax
mov    %rdx,%r12
mov    0x0(,%rax,4),%edx
test   %edx,%edx
je     97a <grecs_symtab_enumerate+0x5a>
mov    %rsi,%rbp
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    0x10(%r13),%rax
mov    %ebx,%ecx
mov    (%rax,%rcx,8),%rdi
test   %rdi,%rdi
je     973 <grecs_symtab_enumerate+0x53>
mov    %r12,%rsi
callq  *%rbp
test   %eax,%eax
jne    97c <grecs_symtab_enumerate+0x5c>
mov    0x4(%r13),%eax
mov    0x0(,%rax,4),%edx
add    $0x1,%ebx
cmp    %edx,%ebx
jb     950 <grecs_symtab_enumerate+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
grecs_symtab_enumerate(struct grecs_symtab *st, grecs_symtab_enumerator_t fun,
         void *data)
{
 unsigned i;
 if (!st)
  return 0;
 for (i = 0; i < hash_size[st->hash_num]; i++) {
  struct grecs_syment *ep = st->tab[i];
  if (ep) {
   int rc = fun(ep, data);
   if (rc)
    return rc;
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
22 10
23 10
24 11
25 11
26 11
27 11
28 7
29 7
30 7
31 6
32 16
33 16
34 16
35 16
36 16
37 16
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    %rdi,%rax
mov    0x18(%rdi),%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    0x28(%rdi),%rdi
mov    0x20(%r8),%r9
mov    0x20(%rax),%r8
jmpq   *%r9
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fsolver_iterate (gsl_multiroot_fsolver * s)
{
  return (s->type->iterate) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 7 <nettle_hmac_md5_set_key+0x7>
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x60(%rdi),%rsi
lea    0xc0(%rdi),%rdx
jmpq   1d <nettle_hmac_md5_set_key+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
nettle_hmac_md5_set_key(struct hmac_md5_ctx *ctx,
   size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_md5), (key_length), (key) );
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
cmpq   $0x0,0x658(%rdi)
jg     b683 <SetFixedVars+0x33>
jmp    b6b8 <SetFixedVars+0x68>
nopl   (%rax)
mov    0x8(%rbp),%rsi
mov    0x0(%rbp),%rdi
add    $0x1,%rbx
callq  b679 <SetFixedVars+0x29>
cmp    %rbx,0x658(%r12)
jle    b6b8 <SetFixedVars+0x68>
mov    0x660(%r12),%rax
mov    (%rax,%rbx,8),%rbp
mov    0x0(%rbp),%rdi
callq  b698 <SetFixedVars+0x48>
test   %eax,%eax
jne    b668 <SetFixedVars+0x18>
mov    0x0(%rbp),%rdi
movsd  0x8(%rbp),%xmm0
add    $0x1,%rbx
callq  b6ae <SetFixedVars+0x5e>
cmp    %rbx,0x658(%r12)
jg     b683 <SetFixedVars+0x33>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
SetFixedVars (PLEVEL plevel)
{
  long n;
  PVARMOD pFVar;
  for (n = 0; n < plevel->nFixedVars; n++) {
    pFVar = plevel->rgpFixedVars[n];
    if (IsInput (pFVar->hvar))
      SetInput (pFVar->hvar, pFVar->uvar.pifn);
    else
      SetVar (pFVar->hvar, pFVar->uvar.dVal);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 8
11 8
12 5
13 8
14 5
15 5
16 6
17 6
18 7
19 7
20 7
21 7
22 10
23 10
24 5
25 10
26 5
27 5
28 12
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2bd8 <gsl_matrix_ulong_free+0x38>
mov    0x28(%rdi),%eax
test   %eax,%eax
jne    2bc0 <gsl_matrix_ulong_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   2bb9 <gsl_matrix_ulong_free+0x19>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdi
callq  2bc9 <gsl_matrix_ulong_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   2bd2 <gsl_matrix_ulong_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_free (gsl_matrix_ulong * m)
{
  if (!m) { return ; };
  if (m->owner)
    {
      gsl_block_ulong_free (m->block);
    }
  free (m);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm1        # 48 <sign+0x8>
movsd  0x0(%rip),%xmm1        # 50 <sign+0x10>
andpd  %xmm1,%xmm0
jb     60 <sign+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm1        # 68 <sign+0x28>
xorpd  %xmm1,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
sign(double a,double b)
{
 if(b>=0.) return(+1.*fabs(a));
 else return(-1.*fabs(a));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
mov    0x1a8(%rdi),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
__db_set_errpfx(dbp, errpfx)
 DB *dbp;
 const char *errpfx;
{
 dbp->dbenv->set_errpfx(dbp->dbenv, errpfx);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2156 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rcx
je     70f <gsl_vector_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  705 <gsl_vector_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
je     747 <gsl_vector_swap+0x77>
lea    0x0(,%rcx,8),%rsi
shl    $0x3,%rdi
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
movsd  (%rdx),%xmm0
add    $0x1,%rcx
movsd  (%rax),%xmm1
movsd  %xmm1,(%rdx)
add    %rdi,%rdx
movsd  %xmm0,(%rax)
add    %rsi,%rax
cmp    %r8,%rcx
jne    728 <gsl_vector_swap+0x58>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_swap (gsl_vector * v, gsl_vector * w)
{
  double * d1 = v->data ;
  double * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          double tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 13
18 13
19 13
20 13
21 13
22 13
23 17
24 13
25 18
26 18
27 18
28 19
29 19
30 13
31 13
32 22
33 23
34 23
<<<sep_out_sample>>>
test   %rdi,%rdi
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0x6666666666666667,%rsi
js     58 <offtostr+0x58>
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %rsi
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    20 <offtostr+0x20>
mov    %rcx,%rax
retq   
nopl   0x0(%rax)
mov    %rsi,%r8
mov    $0x30,%esi
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %r8
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
test   %rdx,%rdx
mov    %rdx,%rdi
mov    %al,(%rcx)
jne    60 <offtostr+0x60>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
offtostr (off_t i, char *buf)
{
  char *p = buf + ((sizeof (off_t) * 8 - (! ((__typeof__ (off_t)) 0 < (__typeof__ (off_t)) -1))) * 146 / 485 + (! ((__typeof__ (off_t)) 0 < (__typeof__ (off_t)) -1)) + 1);
  *p = 0;
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: ((! ((off_t) 0 < (off_t) -1)) == 1) ? 1 : -1; }))];
  if (i < 0)
    {
      do
 *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 6
2 3
3 4
4 16
5 6
6 6
7 16
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 17
19 16
20 17
21 17
22 20
23 20
24 20
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 10
38 10
39 9
40 10
41 9
42 11
43 11
44 20
45 20
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
finished_process (void *item, void *data)
{
  struct process_status *ps = item;
  return ps->running;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xc8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_search_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->sortedlist_search_from_to (list, compar, start_index, end_index,
          elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmp    %esi,(%rdi)
jae    17f0 <afm_message+0x10>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 17f7 <afm_message+0x17>
mov    %rdx,%rdi
jmpq   17ff <afm_message+0x1f>
nop
<<<sep_in_sample>>>
afm_message (AFMHandle handle, unsigned int level, char *message)
{
  if (handle->verbose < level)
    return;
  fprintf (stderr, "%s", message);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
callq  242 <git_addfn+0x12>
mov    (%rax),%rsi
jmp    254 <git_addfn+0x24>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%eax
movsbq %al,%rcx
testb  $0x20,0x1(%rsi,%rcx,2)
jne    250 <git_addfn+0x20>
cmp    $0x23,%al
je     288 <git_addfn+0x58>
test   %al,%al
je     288 <git_addfn+0x58>
cmp    $0x5c,%al
nopl   0x0(%rax)
je     290 <git_addfn+0x60>
mov    %rbx,%rsi
mov    %rbp,%rdi
mov    %r12d,%edx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   284 <git_addfn+0x54>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
xor    %eax,%eax
cmpb   $0x23,0x1(%rbx)
sete   %al
add    %rax,%rbx
jmp    272 <git_addfn+0x42>
xchg   %ax,%ax
<<<sep_in_sample>>>
git_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  while (((*__ctype_b_loc ())[(int) ((*pattern))] & (unsigned short int) _ISspace))
    ++pattern;
  if (*pattern == 0 || *pattern == '#')
    return;
  if (*pattern == '\\' && pattern[1] == '#')
    ++pattern;
  add_exclude (ex, pattern, options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 9
24 9
25 9
26 10
27 10
28 10
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 8
37 8
38 8
39 8
40 8
41 8
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uchar_size (const gsl_block_uchar * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x10(%rdi),%rsi
mov    %rax,%rdi
jmpq   8f <lmniel_jac+0xf>
nop
<<<sep_in_sample>>>
lmniel_jac(void *vstate, gsl_matrix * J)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  int s = gsl_matrix_memcpy(J, state->J);
  return s;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm4
movapd %xmm1,%xmm5
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm4
mulsd  %xmm3,%xmm5
mulsd  %xmm0,%xmm3
subsd  %xmm5,%xmm4
addsd  %xmm3,%xmm1
movapd %xmm4,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_mul (gsl_complex a, gsl_complex b)
{
  double ar = ((a).dat[0]), ai = ((a).dat[1]);
  double br = ((b).dat[0]), bi = ((b).dat[1]);
  gsl_complex z;
  do {(&z)->dat[0]=(ar * br - ai * bi); (&z)->dat[1]=(ar * bi + ai * br);} while(0);
  return z;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 8
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
lea    0x28(%rdi),%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    0x28(%rdi),%rbx
cmp    %r12,%rbx
jne    18e <gl_linked_sortedlist_indexof+0x2e>
jmp    19d <gl_linked_sortedlist_indexof+0x3d>
nop
je     1b0 <gl_linked_sortedlist_indexof+0x50>
mov    (%rbx),%rbx
add    $0x1,%rbp
cmp    %r12,%rbx
je     19d <gl_linked_sortedlist_indexof+0x3d>
mov    0x10(%rbx),%rdi
mov    %r13,%rsi
callq  *%r14
cmp    $0x0,%eax
jle    180 <gl_linked_sortedlist_indexof+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffffffffffff,%rax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
                              const void *elt)
{
  gl_list_node_t node;
  size_t index;
  for (node = list->root.next, index = 0;
       node != &list->root;
       node = node->next, index++)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
        break;
      if (cmp == 0)
        return index;
    }
  return (size_t)(-1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 3
8 6
9 3
10 6
11 6
12 6
13 6
14 6
15 13
16 8
17 8
18 6
19 6
20 10
21 10
22 10
23 11
24 11
25 17
26 17
27 17
28 17
29 16
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
jmpq   35 <rec_comment_dup+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_dup (rec_comment_t comment)
{
  return strdup (comment);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x2,%edi
callq  63 <cgt_time_start+0x13>
test   %eax,%eax
js     6c <cgt_time_start+0x1c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
callq  75 <cgt_time_start+0x25>
mov    (%rax),%edi
callq  7c <cgt_time_start+0x2c>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  8b <cgt_time_start+0x3b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cgt_time_start(void)
{
  if (clock_gettime(2, &cgt_start) < 0)
    die("clock_gettime failed: %s\n", strerror((*__errno_location ())));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # f36 <gsl_vector_short_const_ptr+0x6>
test   %eax,%eax
je     f3f <gsl_vector_short_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    f50 <gsl_vector_short_const_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f6d <gsl_vector_short_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_const_ptr (const gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %edi,%r12d
mov    %rsi,%rdi
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  5b68 <spotlight+0x18>
movslq 0x0(%rip),%rbx        # 5b6f <spotlight+0x1f>
mov    %rax,%rbp
callq  5b77 <spotlight+0x27>
mov    %rax,%rdi
callq  5b7f <spotlight+0x2f>
add    %rax,%rbx
callq  5b87 <spotlight+0x37>
sub    %rax,%rbx
cmp    %rbp,%rbx
sbb    $0x0,%rbx
callq  5b96 <spotlight+0x46>
mov    0x0(%rip),%rdi        # 5b9d <spotlight+0x4d>
callq  5ba2 <spotlight+0x52>
test   %r12b,%r12b
jne    5c30 <spotlight+0xe0>
test   %rbp,%rbp
jne    5bd8 <spotlight+0x88>
mov    0x0(%rip),%rdi        # 5bb7 <spotlight+0x67>
mov    $0x20,%esi
callq  5bc1 <spotlight+0x71>
test   %r12b,%r12b
jne    5c0f <spotlight+0xbf>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rsi
mov    %r13,%rdi
callq  5be3 <spotlight+0x93>
mov    0x0(%rip),%rdi        # 5bea <spotlight+0x9a>
mov    %eax,%edx
mov    %r13,%rsi
callq  5bf4 <spotlight+0xa4>
cmp    %rbp,%rbx
jae    5bc1 <spotlight+0x71>
mov    0x0(%rip),%rdi        # 5c00 <spotlight+0xb0>
mov    $0x24,%esi
callq  5c0a <spotlight+0xba>
test   %r12b,%r12b
je     5bc6 <spotlight+0x76>
movslq 0x0(%rip),%rsi        # 5c16 <spotlight+0xc6>
mov    0x0(%rip),%rdi        # 5c1d <spotlight+0xcd>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   5c2e <spotlight+0xde>
xchg   %ax,%ax
movslq 0x0(%rip),%rsi        # 5c37 <spotlight+0xe7>
mov    0x0(%rip),%rdi        # 5c3e <spotlight+0xee>
xor    %edx,%edx
callq  5c45 <spotlight+0xf5>
jmpq   5bab <spotlight+0x5b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
spotlight(_Bool active, const char *word)
{
    size_t word_len = strlenpt(word), room;
    room = COLS + get_page_start(xplustabs()) - xplustabs();
    ((void) (0));
    if (word_len > room)
 room--;
    reset_cursor();
    wnoutrefresh(edit);
    if (active)
 wattr_on(edit, (attr_t)(hilite_attribute), ((void *)0));
    if (word_len == 0)
 waddch(edit, ' ');
    else
 waddnstr(edit, word, actual_x(word, room));
    if (word_len > room)
 waddch(edit, '$');
    if (active)
 wattr_off(edit, (attr_t)(hilite_attribute), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 4
18 7
19 7
20 8
21 9
22 9
23 10
24 10
25 12
26 12
27 13
28 13
29 13
30 18
31 18
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 16
47 16
48 17
49 17
50 17
51 18
52 18
53 19
54 19
55 20
56 20
57 20
58 20
59 20
60 19
61 19
62 19
63 11
64 11
65 11
66 11
67 11
68 11
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   1a <rec_field_name_p+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_name_p (const char *str)
{
  return rec_match (str, "^" "[a-zA-Z%][a-zA-Z0-9_]*" "$");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %edi,%edi
jle    b8 <cblas_snrm2+0xb8>
test   %edx,%edx
jle    b8 <cblas_snrm2+0xb8>
cmp    $0x1,%edi
je     c0 <cblas_snrm2+0xc0>
xorps  %xmm0,%xmm0
movslq %edx,%rdx
xor    %eax,%eax
movss  0x0(%rip),%xmm6        # 29 <cblas_snrm2+0x29>
shl    $0x2,%rdx
movaps %xmm6,%xmm2
movss  0x0(%rip),%xmm4        # 38 <cblas_snrm2+0x38>
movaps %xmm0,%xmm3
movaps %xmm0,%xmm5
jmp    5d <cblas_snrm2+0x5d>
divss  %xmm1,%xmm3
mulss  %xmm3,%xmm2
mulss  %xmm3,%xmm2
movaps %xmm1,%xmm3
addss  %xmm6,%xmm2
add    $0x1,%eax
add    %rdx,%rsi
cmp    %eax,%edi
jle    89 <cblas_snrm2+0x89>
movss  (%rsi),%xmm1
ucomiss %xmm0,%xmm1
jp     6b <cblas_snrm2+0x6b>
ucomiss %xmm5,%xmm1
je     53 <cblas_snrm2+0x53>
andps  %xmm4,%xmm1
ucomiss %xmm3,%xmm1
ja     40 <cblas_snrm2+0x40>
divss  %xmm3,%xmm1
add    $0x1,%eax
add    %rdx,%rsi
cmp    %eax,%edi
mulss  %xmm1,%xmm1
addss  %xmm1,%xmm2
jg     5d <cblas_snrm2+0x5d>
unpcklps %xmm2,%xmm2
sub    $0x18,%rsp
cvtps2pd %xmm2,%xmm2
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     d0 <cblas_snrm2+0xd0>
unpcklps %xmm3,%xmm3
add    $0x18,%rsp
cvtps2pd %xmm3,%xmm3
mulsd  %xmm0,%xmm3
unpcklpd %xmm3,%xmm3
cvtpd2ps %xmm3,%xmm0
retq   
nopl   0x0(%rax)
xorps  %xmm0,%xmm0
retq   
nopl   0x0(%rax)
movss  0x0(%rip),%xmm1        # c8 <cblas_snrm2+0xc8>
movss  (%rsi),%xmm0
andps  %xmm1,%xmm0
retq   
movapd %xmm2,%xmm0
movss  %xmm3,0xc(%rsp)
callq  df <cblas_snrm2+0xdf>
movss  0xc(%rsp),%xmm3
jmp    9d <cblas_snrm2+0x9d>
<<<sep_in_sample>>>
cblas_snrm2 (const int N, const float *X, const int incX)
{
{
  float scale = 0.0;
  float ssq = 1.0;
  int i;
  int ix = 0;
  if (N <= 0 || incX <= 0) {
    return 0;
  } else if (N == 1) {
    return fabs(X[0]);
  }
  for (i = 0; i < N; i++) {
    const float x = X[ix];
    if (x != 0.0) {
      const float ax = fabs(x);
      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
        scale = ax;
      } else {
        ssq += (ax / scale) * (ax / scale);
      }
    }
    ix += incX;
  }
  return scale * sqrt(ssq);
}
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 16
14 10
15 15
16 15
17 18
18 18
19 18
20 19
21 18
22 13
23 13
24 13
25 13
26 14
27 15
28 15
29 15
30 15
31 16
32 17
33 17
34 21
35 13
36 13
37 13
38 21
39 21
40 13
41 26
42 2
43 26
44 26
45 26
46 26
47 26
48 28
49 26
50 26
51 26
52 26
53 28
54 28
55 9
56 9
57 9
58 11
59 11
60 11
61 11
62 26
63 26
64 26
65 26
66 26
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %ecx,%ebx
sub    $0x8,%rsp
callq  16e0 <blank_line+0x10>
test   %ebx,%ebx
jle    16fa <blank_line+0x2a>
nopl   0x0(%rax)
mov    $0x20,%esi
mov    %rbp,%rdi
callq  16f5 <blank_line+0x25>
sub    $0x1,%ebx
jne    16e8 <blank_line+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
blank_line(WINDOW *win, int y, int x, int n)
{
    wmove(win, y, x);
    for (; n > 0; n--)
 waddch(win, ' ');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 4
14 4
15 6
16 6
17 6
18 6
19 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  140e <mu_auth_finish_setup+0xe>
mov    $0x0,%edi
callq  1418 <mu_auth_finish_setup+0x18>
mov    $0x0,%edi
callq  1422 <mu_auth_finish_setup+0x22>
mov    0x0(%rip),%rax        # 1429 <mu_auth_finish_setup+0x29>
movq   $0x0,0x0(%rip)        # 1434 <mu_auth_finish_setup+0x34>
mov    %rax,0x0(%rip)        # 143b <mu_auth_finish_setup+0x3b>
mov    0x0(%rip),%rax        # 1442 <mu_auth_finish_setup+0x42>
movq   $0x0,0x0(%rip)        # 144d <mu_auth_finish_setup+0x4d>
mov    %rax,0x0(%rip)        # 1454 <mu_auth_finish_setup+0x54>
mov    0x0(%rip),%rax        # 145b <mu_auth_finish_setup+0x5b>
movq   $0x0,0x0(%rip)        # 1466 <mu_auth_finish_setup+0x66>
mov    %rax,0x0(%rip)        # 146d <mu_auth_finish_setup+0x6d>
add    $0x8,%rsp
jmpq   1476 <mu_auth_finish_setup+0x76>
<<<sep_in_sample>>>
mu_auth_finish_setup ()
{
  mu_list_destroy (&mu_authenticate_list);
  mu_list_destroy (&mu_auth_by_name_list);
  mu_list_destroy (&mu_auth_by_uid_list);
  mu_authenticate_list = _tmp_authenticate_list;
  _tmp_authenticate_list = ((void *)0);
  mu_auth_by_name_list = _tmp_auth_by_name_list;
  _tmp_auth_by_name_list = ((void *)0);
  mu_auth_by_uid_list = _tmp_auth_by_uid_list;
  _tmp_auth_by_uid_list = ((void *)0);
  mu_auth_begin_setup ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 7
10 6
11 8
12 9
13 8
14 10
15 11
16 10
17 13
18 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <DISxSetProtocolVersion+0x6>
mov    %edi,0x0(%rip)        # c <DISxSetProtocolVersion+0xc>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
DISxSetProtocolVersion(int version)
{
 int result = protocol_version;
 protocol_version = version;
 return result;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rcx,%rcx
je     149a0 <gsl_fft_real_unpack+0x40>
lea    0x0(,%rdx,8),%r8
xor    %eax,%eax
shl    $0x4,%rdx
nopl   0x0(%rax,%rax,1)
movsd  (%rdi),%xmm0
add    $0x1,%rax
movq   $0x0,0x8(%rsi)
add    %r8,%rdi
movsd  %xmm0,(%rsi)
add    %rdx,%rsi
cmp    %rcx,%rax
jne    14978 <gsl_fft_real_unpack+0x18>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x1,%cl
mov    $0x1f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  149ba <gsl_fft_real_unpack+0x5a>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_real_unpack (const double real_coefficient[],
                               double complex_coefficient[],
                               const size_t stride, const size_t n)
{
  size_t i;
  if (n == 0)
    {
      do { gsl_error ("length n must be positive integer", "real_unpack.c", 31, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  for (i = 0; i < n; i++)
    {
      ((complex_coefficient)[2*(stride)*(i)]) = real_coefficient[i * stride];
      ((complex_coefficient)[2*(stride)*(i)+1]) = 0.0;
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 12
8 10
9 13
10 13
11 12
12 12
13 10
14 10
15 15
16 15
17 15
18 4
19 8
20 8
21 8
22 8
23 8
24 8
25 16
26 16
27 16
<<<sep_out_sample>>>
mov    %rsi,0x18(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_nonce (osip_authorization_t * authorization, char *nonce)
{
  authorization->nonce = (char *) nonce;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0xfffffff9,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_tray_osx (const char *psz_drive)
{
  return DRIVER_OP_NO_DRIVER;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
lea    0xcc(%rdi),%rdx
push   %rbp
mov    %rsi,%rbp
mov    $0x48,%esi
push   %rbx
mov    0xc8(%rdi),%ecx
mov    %rdi,%rbx
callq  e4 <nettle_sha3_512_digest+0x24>
mov    %rbp,%rdi
mov    %rbx,%rdx
mov    %r12,%rsi
callq  f2 <nettle_sha3_512_digest+0x32>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   fe <nettle_sha3_512_digest+0x3e>
<<<sep_in_sample>>>
nettle_sha3_512_digest(struct sha3_512_ctx *ctx,
  size_t length,
  uint8_t *digest)
{
  _nettle_sha3_pad (&ctx->state, 72, ctx->block, ctx->index);
  _nettle_write_le64 (length, digest, ctx->state.a);
  nettle_sha3_512_init (ctx);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 4
6 5
7 4
8 5
9 4
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 7
<<<sep_out_sample>>>
mov    0x204(%rdi),%eax
movl   $0x0,0x4(%rsi)
mov    $0x1,%edx
mov    %eax,0x8(%rsi)
mov    (%rsi),%eax
orl    $0x2,0x27c(%rdi)
mov    %eax,0x204(%rdi)
mov    (%rdi),%rdi
jmpq   2c <__bt_free+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__bt_free(t, h)
 BTREE *t;
 PAGE *h;
{
 h->prevpg = 0;
 h->nextpg = t->bt_free;
 t->bt_free = h->pgno;
 (t)->flags |= (0x00002);
 return (mpool_put(t->bt_mp, h, 0x01));
}
<<<sep_in_sample>>>
1 6
2 5
3 9
4 6
5 7
6 8
7 7
8 9
9 9
10 9
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  139 <xrealloc+0x9>
test   %rax,%rax
je     140 <xrealloc+0x10>
pop    %rbx
retq   
test   %rbx,%rbx
je     13e <xrealloc+0xe>
callq  14a <xrealloc+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xrealloc (void *p, size_t n)
{
  p = realloc (p, n);
  if (!p && n != 0)
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 7
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x20(%rsi),%rax
mov    (%rax),%rbx
mov    0x30(%rdi),%eax
test   %eax,%eax
je     12d <get_16bit_row+0x6d>
sub    $0x1,%eax
lea    0x3(%rax,%rax,2),%r12
add    %rbx,%r12
mov    %rbp,%rdi
add    $0x3,%rbx
callq  *0x50(%rbp)
movzbl 0x59(%rbp),%eax
movzbl 0x58(%rbp),%edx
shl    $0x8,%eax
add    %edx,%eax
mov    %eax,%edx
and    $0x1f,%edx
movzbl 0x0(%rdx),%edx
mov    %dl,-0x1(%rbx)
mov    %eax,%edx
sar    $0xa,%eax
sar    $0x5,%edx
and    $0x1f,%eax
and    $0x1f,%edx
movzbl 0x0(%rax),%eax
movzbl 0x0(%rdx),%edx
mov    %al,-0x3(%rbx)
mov    %dl,-0x2(%rbx)
cmp    %r12,%rbx
jne    e0 <get_16bit_row+0x20>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_16bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  tga_source_ptr source = (tga_source_ptr) sinfo;
  register int t;
  register JSAMPROW ptr;
  register JDIMENSION col;
  ptr = source->pub.buffer[0];
  for (col = cinfo->image_width; col > 0; col--) {
    (*source->read_pixel) (source);
    t = ((int) (source->tga_pixel[0]));
    t += ((int) (source->tga_pixel[1])) << 8;
    ptr[2] = (JSAMPLE) c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[1] = (JSAMPLE) c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[0] = (JSAMPLE) c5to8bits[t & 0x1F];
    ptr += 3;
  }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 9
14 17
15 9
16 11
17 10
18 11
19 11
20 12
21 12
22 12
23 12
24 13
25 15
26 13
27 16
28 14
29 16
30 14
31 16
32 14
33 8
34 8
35 20
36 20
37 20
38 20
39 20
40 20
<<<sep_out_sample>>>
mov    %rdi,0x90(%rsi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_lval (YYSTYPE * yylval_param , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yylval_r = yylval_param;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
callq  462 <_env_msg_date+0x12>
mov    %rax,%rdi
callq  46a <_env_msg_date+0x1a>
mov    %rax,%r8
mov    $0x16,%eax
test   %r8,%r8
je     4a0 <_env_msg_date+0x50>
mov    0x8(%r8),%rsi
test   %rsi,%rsi
je     4a0 <_env_msg_date+0x50>
test   %rbx,%rbx
je     4a8 <_env_msg_date+0x58>
mov    %rbp,%rdx
mov    %rbx,%rdi
callq  490 <_env_msg_date+0x40>
test   %r12,%r12
movb   $0x0,-0x1(%rbx,%rbp,1)
je     4c0 <_env_msg_date+0x70>
mov    %rbp,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
test   %r12,%r12
je     4a0 <_env_msg_date+0x50>
mov    %rsi,%rdi
callq  4b5 <_env_msg_date+0x65>
pop    %rbx
pop    %rbp
mov    %rax,(%r12)
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
jmp    4a0 <_env_msg_date+0x50>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_env_msg_date (mu_envelope_t envelope, char *buf, size_t len, size_t *pnwrite)
{
  mu_message_t msg = mu_envelope_get_owner (envelope);
  struct _mu_rfc822_message *env = mu_message_get_owner (msg);
  if (!env || !env->date)
    return 22;
  if (buf)
    {
      strncpy (buf, env->date, len);
      buf[len-1] = 0;
      if (pnwrite)
 *pnwrite = len;
    }
  else if (!pnwrite)
    return 22;
  else
    *pnwrite = strlen (env->date);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 6
12 5
13 5
14 5
15 5
16 5
17 7
18 7
19 9
20 9
21 9
22 11
23 10
24 11
25 12
26 18
27 19
28 19
29 19
30 19
31 19
32 14
33 14
34 17
35 17
36 19
37 19
38 17
39 18
40 19
41 19
42 18
43 18
44 18
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4_order (void *vstate)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
lea    -0x1(%rsi),%ebp
test   %ebp,%ebp
push   %rbx
jle    1d1 <hassubscript+0x41>
mov    0x0(%rip),%rax        # 1a2 <hassubscript+0x12>
movslq %ebp,%rbx
add    %rdi,%rbx
mov    (%rax),%r12
jmp    1c1 <hassubscript+0x31>
nopl   (%rax)
sub    $0x1,%ebp
cmpb   $0x5f,-0x1(%rbx)
je     1e0 <hassubscript+0x50>
sub    $0x1,%rbx
test   %ebp,%ebp
je     1d1 <hassubscript+0x41>
movsbl (%rbx),%esi
mov    %r12,%rdi
callq  1cc <hassubscript+0x3c>
test   %rax,%rax
jne    1b0 <hassubscript+0x20>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hassubscript(const char *str, int length)
{
  length--;
  while(length>0){
    if (!strchr(digits, str[length]))
      return 0;
    length--;
    if (str[length]=='_')
      return 1;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 7
14 8
15 8
16 8
17 4
18 4
19 5
20 5
21 5
22 5
23 5
24 12
25 12
26 11
27 12
28 12
29 12
30 12
31 12
32 9
33 12
34 12
35 12
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm0        # 37b8 <initializeunit+0x8>
movq   $0x0,0x320(%rdi)
movq   $0x0,(%rdi)
movsd  %xmm0,0x640(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initializeunit(struct unittype *theunit)
{
   theunit->factor = 1.0;
   theunit->numerator[0] = theunit->denominator[0] = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x90,%rsp
test   %rdi,%rdi
je     14fe <check_filename+0x4e>
mov    %rsi,%r12
mov    %rsp,%rsi
callq  14d0 <check_filename+0x20>
cmp    $0xffffffff,%eax
je     1540 <check_filename+0x90>
mov    0x18(%rsp),%eax
test   $0x80,%ah
je     1510 <check_filename+0x60>
test   $0xa0,%ah
je     1510 <check_filename+0x60>
test   %r12,%r12
je     1560 <check_filename+0xb0>
mov    (%r12),%rdx
mov    0x58(%rsp),%rax
xor    %ebp,%ebp
cmp    %rax,%rdx
mov    %rax,(%r12)
setl   %bpl
add    $0x90,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %ebp,%ebp
callq  151c <check_filename+0x6c>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
xor    %eax,%eax
xor    %edi,%edi
callq  152d <check_filename+0x7d>
add    $0x90,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  1545 <check_filename+0x95>
mov    (%rax),%esi
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  1558 <check_filename+0xa8>
jmp    14fe <check_filename+0x4e>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%ebp
jmp    14fe <check_filename+0x4e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_filename (char *path, time_t *timep)
{
  struct stat st;
  if (path == ((void *)0))
    return 0;
  if (stat (path, &st) == -1)
    {
      anubis_error (0, (*__errno_location ()), "%s", path);
      return 0;
    }
  if (!(st.st_mode & 0100000) || !(st.st_mode & 0120000))
    {
      anubis_error (0, 0,
      gettext("%s is not a regular file or a symbolic link."), path);
      return 0;
    }
  if (timep)
    {
      time_t mtime = *timep;
      *timep = st.st_mtim.tv_sec;
      return st.st_mtim.tv_sec > mtime;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 11
15 11
16 11
17 11
18 11
19 17
20 17
21 19
22 20
23 21
24 21
25 20
26 21
27 24
28 24
29 24
30 24
31 24
32 24
33 24
34 14
35 15
36 14
37 13
38 13
39 13
40 13
41 13
42 13
43 24
44 24
45 24
46 24
47 24
48 24
49 24
50 8
51 8
52 8
53 8
54 8
55 8
56 8
57 9
58 9
59 23
60 23
61 23
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rax
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    %rax,%rsi
sub    $0x30,%rsp
mov    %rsp,%rdx
mov    %fs:0x28,%rcx
mov    %rcx,0x28(%rsp)
xor    %ecx,%ecx
callq  49 <time_to_env+0x29>
mov    $0x1,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  59 <time_to_env+0x39>
test   %eax,%eax
je     62 <time_to_env+0x42>
callq  62 <time_to_env+0x42>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
je     77 <time_to_env+0x57>
callq  77 <time_to_env+0x57>
add    $0x30,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
time_to_env (char const *envar, struct timespec t)
{
  char buf[TIMESPEC_STRSIZE_BOUND];
  if (setenv (envar, code_timespec (t, buf), 1) != 0)
    xalloc_die ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 2
9 2
10 2
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 6
20 6
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 6da7 <sigstop_sighandler+0x7>
push   %rbx
mov    %edi,%ebx
mov    $0x14,%edi
callq  6db4 <sigstop_sighandler+0x14>
mov    0x0(%rip),%rsi        # 6dbb <sigstop_sighandler+0x1b>
mov    $0x16,%edi
callq  6dc5 <sigstop_sighandler+0x25>
mov    0x0(%rip),%rsi        # 6dcc <sigstop_sighandler+0x2c>
mov    $0x15,%edi
callq  6dd6 <sigstop_sighandler+0x36>
mov    $0x0,%esi
mov    $0x12,%edi
callq  6de5 <sigstop_sighandler+0x45>
mov    0x0(%rip),%edi        # 6deb <sigstop_sighandler+0x4b>
xor    %esi,%esi
mov    %rax,0x0(%rip)        # 6df4 <sigstop_sighandler+0x54>
callq  6df9 <sigstop_sighandler+0x59>
callq  6dfe <sigstop_sighandler+0x5e>
mov    %ebx,%esi
mov    %eax,%edi
pop    %rbx
jmpq   6e08 <sigstop_sighandler+0x68>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigstop_sighandler (sig)
     int sig;
{
  set_signal_handler (20, old_tstp);
  set_signal_handler (22, old_ttou);
  set_signal_handler (21, old_ttin);
  old_cont = set_signal_handler (18, sigcont_sighandler);
  give_terminal_to (shell_pgrp, 0);
  kill (getpid (), sig);
  return;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 6
10 6
11 6
12 7
13 7
14 7
15 8
16 8
17 7
18 8
19 9
20 9
21 9
22 11
23 9
24 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  47e <sh_invalidid+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   48c <sh_invalidid+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sh_invalidid (s)
     char *s;
{
  builtin_error (gettext("`%s': not a valid identifier"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
mov    $0x1,%edx
jmpq   1bd0 <info_node_of_tag_ext>
<<<sep_in_sample>>>
info_node_of_tag_fast (FILE_BUFFER *fb, TAG **tag_ptr)
{
  return info_node_of_tag_ext (fb, tag_ptr, 1);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_is_to_void (struct output * out)
{
  return out->to_void;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r15
mov    $0x0,%eax
mov    %rcx,%r15
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
cmove  %rax,%rbx
mov    %rdi,0x18(%rsp)
callq  d40 <quotearg_buffer+0x30>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    0x30(%rbx),%rax
mov    0x4(%rbx),%r9d
mov    0x18(%rsp),%rdi
mov    %r15,%rcx
mov    %r14,%rdx
mov    %r13,%rsi
mov    %rax,0x10(%rsp)
mov    0x28(%rbx),%rax
mov    %rax,0x8(%rsp)
lea    0x8(%rbx),%rax
mov    %rax,(%rsp)
mov    (%rbx),%r8d
callq  0 <quotearg_buffer_restyled>
mov    %r12d,0x0(%rbp)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
<<<sep_in_sample>>>
quotearg_buffer (char *buffer, size_t buffersize,
                 char const *arg, size_t argsize,
                 struct quoting_options const *o)
{
  struct quoting_options const *p = o ? o : &default_quoting_options;
  int e = (*__errno_location ());
  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,
                                       p->style, p->flags, p->quote_these_too,
                                       p->left_quote, p->right_quote);
  (*__errno_location ()) = e;
  return r;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 4
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 7
31 7
32 10
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0xc(%rdi),%ecx
mov    0x8(%rdx),%rax
add    $0xf,%rax
and    $0xfffffffffffffff8,%rax
imul   %rcx,%rax
add    0x10(%rdx),%rax
cmp    %rax,%rsi
sete   %al
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
curitem_p (void *owner, void *item)
{
  struct assoc_iterator *itr = owner;
  mu_assoc_t assoc = itr->assoc;
  struct _mu_assoc_elem *elem = ((struct _mu_assoc_elem*) ((char*) ((assoc)->tab) + (((((assoc)->elsize + ((size_t)&((struct _mu_assoc_elem*)0)->data))) + ((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1) & ~(((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1)) * itr->index));
  return elem == item;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6b6 <gsl_matrix_long_double_set+0x6>
fldt   0x8(%rsp)
test   %eax,%eax
je     6c9 <gsl_matrix_long_double_set+0x19>
cmp    %rsi,(%rdi)
jbe    6e0 <gsl_matrix_long_double_set+0x30>
cmp    %rdx,0x8(%rdi)
jbe    700 <gsl_matrix_long_double_set+0x50>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
shl    $0x4,%rdx
add    0x18(%rdi),%rdx
fstpt  (%rdx)
retq   
nopl   0x0(%rax)
fstp   %st(0)
mov    $0x4,%ecx
mov    $0x129,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   6fb <gsl_matrix_long_double_set+0x4b>
nopl   0x0(%rax,%rax,1)
fstp   %st(0)
mov    $0x4,%ecx
mov    $0x12d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   71b <gsl_matrix_long_double_set+0x6b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_set(gsl_matrix_long_double * m, const size_t i, const size_t j, const long double x)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_long_double.h", 297, GSL_EINVAL) ; return ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_long_double.h", 301, GSL_EINVAL) ; return ; } while (0) ;
        }
    }
  m->data[i * m->tda + j] = x ;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 14
14 14
15 14
16 14
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 1507 <progman_running_count+0x7>
xor    %eax,%eax
test   %rdx,%rdx
je     1527 <progman_running_count+0x27>
xchg   %ax,%ax
mov    0x14(%rdx),%esi
mov    (%rdx),%rdx
lea    0x1(%rax),%rcx
test   %esi,%esi
cmovg  %rcx,%rax
test   %rdx,%rdx
jne    1510 <progman_running_count+0x10>
repz retq 
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
progman_running_count ()
{
  size_t size = 0;
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (prog->pid > 0)
      size++;
  return size;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 5
12 5
13 5
14 9
15 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x218,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
callq  6c <a2ps_common_finalize+0x2c>
test   %rax,%rax
je     90 <a2ps_common_finalize+0x50>
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
jne    b5 <a2ps_common_finalize+0x75>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    $0x2f,%ecx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rsp,%rdi
callq  a5 <a2ps_common_finalize+0x65>
mov    (%rbx),%rdi
mov    %rsp,%rsi
callq  b0 <a2ps_common_finalize+0x70>
mov    %rax,(%rbx)
jmp    71 <a2ps_common_finalize+0x31>
callq  ba <a2ps_common_finalize+0x7a>
<<<sep_in_sample>>>
a2ps_common_finalize (struct a2ps_common_s * common, const char * home)
{
  char buf [512];
  if (! getenv ("NO_HOME_CONF"))
    {
      sprintf (buf, "%s%c.a2ps", home, '/');
      common->path = pw_prepend_string_to_path (common->path, buf);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 2
9 2
10 4
11 4
12 4
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 9
<<<sep_out_sample>>>
push   %rbp
test   %ecx,%ecx
push   %rbx
jle    64 <VMatrixMultByRank+0x64>
lea    -0x1(%rcx),%r8d
xorpd  %xmm2,%xmm2
xor    %r11d,%r11d
add    $0x1,%r8
mov    %r8,%rbp
shl    $0x3,%r8
shl    $0x5,%rbp
lea    (%rsi,%r11,1),%r10
lea    (%rdx,%r11,1),%rbx
xor    %ecx,%ecx
movapd %xmm2,%xmm1
lea    (%rdi,%rcx,1),%r9
xor    %eax,%eax
movsd  (%r9,%rax,4),%xmm0
mulsd  (%r10,%rax,1),%xmm0
add    $0x8,%rax
cmp    %rax,%r8
addsd  %xmm0,%xmm1
jne    34 <VMatrixMultByRank+0x34>
movsd  %xmm1,(%rbx,%rcx,1)
add    $0x8,%rcx
cmp    %r8,%rcx
jne    2a <VMatrixMultByRank+0x2a>
add    $0x20,%r11
cmp    %rbp,%r11
jne    20 <VMatrixMultByRank+0x20>
movsd  0x0(%rip),%xmm3        # 6c <VMatrixMultByRank+0x6c>
movq   $0x0,0x58(%rdx)
movq   $0x0,0x38(%rdx)
movq   $0x0,0x18(%rdx)
movq   $0x0,0x70(%rdx)
movq   $0x0,0x68(%rdx)
movsd  %xmm3,0x78(%rdx)
movq   $0x0,0x60(%rdx)
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
VMatrixMultByRank(VMatrix * Mt1, VMatrix * Mt2, VMatrix * R, int rank)
{
 register int I, J, K, r = rank;
 register double x;
 for (I = 0; I < r; ++I)
  for (J = 0; J < r; ++J) {
   x = 0.0;
   for (K = 0; K < r; ++K)
    x += Mt1->m[K][J] * Mt2->m[I][K];
   R->m[I][J] = x;
  }
 R->m[0][3] = R->m[1][3] = R->m[2][3] = 0.0;
 R->m[3][0] = R->m[3][1] = R->m[3][2] = 0.0;
 R->m[3][3] = 1.0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 2
15 2
16 2
17 2
18 9
19 9
20 9
21 8
22 9
23 8
24 10
25 10
26 6
27 6
28 6
29 5
30 5
31 14
32 12
33 12
34 12
35 13
36 13
37 14
38 13
39 15
40 15
41 15
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 7 <sigwinch_handler+0x7>
je     10 <sigwinch_handler+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    $0x19a,%edi
jmpq   1a <sigwinch_handler+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigwinch_handler(int sig, siginfo_t *info, void *unused)
{
    (void) sig;
    (void) info;
    (void) unused;
    if(incurses == YES)
        ungetch(0632);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 7
6 7
7 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 5d6 <pty_input_level+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pty_input_level (void)
{
  return pcc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x1,%esi
mov    %rbx,%rdx
callq  4328 <gsl_block_char_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     434a <gsl_block_char_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4345 <gsl_block_char_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_char_fread (FILE * stream, gsl_block_char * b)
{
  size_t n = b->size ;
  char * data = b->data ;
  size_t items = fread (data, 1 * sizeof (char), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
term_source (j_decompress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
user_access (void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a9 <_rl_abort_internal+0x9>
callq  ae <_rl_abort_internal+0xe>
callq  b3 <_rl_abort_internal+0x13>
callq  b8 <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # c3 <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # cb <_rl_abort_internal+0x2b>
je     df <_rl_abort_internal+0x3f>
nopl   (%rax)
callq  d5 <_rl_abort_internal+0x35>
cmpq   $0x0,0x0(%rip)        # dd <_rl_abort_internal+0x3d>
jne    d0 <_rl_abort_internal+0x30>
mov    $0x1,%esi
mov    $0x0,%edi
andq   $0xffffffffffdfffff,0x0(%rip)        # f4 <_rl_abort_internal+0x54>
movq   $0x0,0x0(%rip)        # ff <_rl_abort_internal+0x5f>
callq  104 <_rl_abort_internal+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 8
12 8
13 12
14 12
15 10
16 11
17 12
18 12
<<<sep_out_sample>>>
movzbl (%rdi),%eax
test   %al,%al
je     450 <isbranch+0x30>
xor    %edx,%edx
jmp    43b <isbranch+0x1b>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
je     450 <isbranch+0x30>
cmp    $0x2e,%al
sete   %al
movzbl %al,%eax
add    %eax,%edx
cmp    $0x1,%edx
jle    430 <isbranch+0x10>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
isbranch (const char *sid)
{
  register const char *p;
  int dots;
  dots = 0;
  for (p = sid; *p != '\0'; p++)
    {
      if (*p == '.')
        dots++;
      if (dots > 1)
        return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 9
12 9
13 9
14 9
15 10
16 10
17 11
18 11
19 13
20 14
21 14
<<<sep_out_sample>>>
cmp    $0x20,%dil
sete   %al
cmp    $0x9,%dil
sete   %dl
or     %edx,%eax
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_ws (char c)
{
    return c == '\t' || c == ' ';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rdx,%r12
shr    $0x6,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rcx,%rbx
lea    (%rcx,%r12,8),%rcx
mov    %rbx,%rdi
sub    $0x8,%rsp
callq  26 <__gmpn_bsqrt+0x26>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %r12,%rcx
mov    %r13,%rdi
pop    %r12
pop    %r13
jmpq   41 <__gmpn_bsqrt+0x41>
<<<sep_in_sample>>>
__gmpn_bsqrt (mp_ptr rp, mp_srcptr ap, mp_bitcnt_t nb, mp_ptr tp)
{
  mp_ptr sp;
  mp_size_t n;
  do {} while (0);
  n = nb / (64 - 0);
  sp = tp + n;
  __gmpn_bsqrtinv (tp, ap, nb, sp);
  __gmpn_mullo_n (rp, tp, ap, n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 2
7 2
8 2
9 2
10 7
11 8
12 2
13 8
14 10
15 9
16 9
17 10
18 10
19 9
20 9
21 10
22 10
23 9
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 16 <handle_sigwinch+0x6>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 1f <handle_sigwinch+0xf>
retq   
<<<sep_in_sample>>>
handle_sigwinch(int signal)
{
    sigwinch_counter++;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 366 <ungetc_with_restart+0x6>
test   %eax,%eax
je     388 <ungetc_with_restart+0x28>
cmp    $0xffffffff,%edi
je     390 <ungetc_with_restart+0x30>
sub    $0x1,%eax
mov    %eax,0x0(%rip)        # 378 <ungetc_with_restart+0x18>
cltq   
mov    %dil,0x0(%rax)
mov    %edi,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
retq   
xchg   %ax,%ax
mov    %edi,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ungetc_with_restart (c, stream)
     int c;
     FILE *stream;
{
  if (local_index == 0 || c == (-1))
    return (-1);
  localbuf[--local_index] = c;
  return c;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 8
11 8
12 8
13 6
14 6
15 6
16 6
17 9
18 9
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
jmpq   1425 <yyrealloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     400 <gsl_sort_vector_long_double_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3f5 <gsl_sort_vector_long_double_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  411 <gsl_sort_vector_long_double_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_double_index (gsl_permutation * permutation, const gsl_vector_long_double * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_long_double_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
test   %rcx,%rcx
je     a3 <gsl_permute_complex_long_double+0xa3>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
lea    (%rdx,%rdx,1),%rbx
shl    $0x5,%rdx
mov    %rdx,%r12
xor    %edx,%edx
nopl   (%rax)
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    39 <gsl_permute_complex_long_double+0x39>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     30 <gsl_permute_complex_long_double+0x30>
cmp    %rdx,%rax
jb     90 <gsl_permute_complex_long_double+0x90>
mov    (%rdi,%rax,8),%r9
cmp    %rdx,%r9
je     90 <gsl_permute_complex_long_double+0x90>
fldt   0x0(%rbp)
fldt   0x10(%rbp)
jmp    56 <gsl_permute_complex_long_double+0x56>
nop
mov    %r9,%rax
mov    %r8,%r9
mov    %r9,%r8
imul   %rbx,%r8
imul   %rbx,%rax
shl    $0x4,%r8
lea    (%rsi,%r8,1),%r11
shl    $0x4,%rax
lea    0x10(%rsi,%r8,1),%r10
mov    (%rdi,%r9,8),%r8
fldt   (%r11)
cmp    %r8,%rdx
fstpt  (%rsi,%rax,1)
fldt   (%r10)
fstpt  0x10(%rsi,%rax,1)
jne    50 <gsl_permute_complex_long_double+0x50>
fxch   %st(1)
fstpt  (%r11)
fstpt  (%r10)
add    $0x1,%rdx
add    %r12,%rbp
cmp    %rcx,%rdx
jne    20 <gsl_permute_complex_long_double+0x20>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_complex_long_double (const size_t * p, long double * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        long double t[2];
        for (a = 0; a < 2; a++)
          t[a] = data[i*stride*2 + a];
        while (pk != i)
          {
            for (a = 0; a < 2; a++)
              {
                long double r1 = data[pk*stride*2 + a];
                data[k*stride*2 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 2; a++)
          data[k*stride*2 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 18
8 18
9 18
10 4
11 4
12 6
13 7
14 7
15 7
16 8
17 7
18 7
19 9
20 9
21 11
22 12
23 12
24 18
25 18
26 18
27 18
28 27
29 27
30 23
31 23
32 24
33 23
34 23
35 24
36 23
37 27
38 23
39 19
40 24
41 23
42 24
43 19
44 19
45 30
46 30
47 4
48 4
49 4
50 4
51 34
52 34
53 34
54 34
55 34
56 34
57 34
58 34
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
lea    0x10(%rsp),%rdi
callq  313 <mu_folder_create+0x13>
test   %eax,%eax
mov    %eax,%ebx
je     328 <mu_folder_create+0x28>
add    $0x28,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x10(%rsp),%rdi
callq  332 <mu_folder_create+0x32>
test   %eax,%eax
je     358 <mu_folder_create+0x58>
lea    0x10(%rsp),%rdi
mov    %eax,0xc(%rsp)
callq  344 <mu_folder_create+0x44>
mov    0xc(%rsp),%eax
add    $0x28,%rsp
mov    %eax,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x10(%rsp),%rsi
xor    %edx,%edx
mov    %rbp,%rdi
callq  367 <mu_folder_create+0x67>
test   %eax,%eax
jne    336 <mu_folder_create+0x36>
add    $0x28,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_folder_create (mu_folder_t *pfolder, const char *name)
{
  int rc;
  mu_url_t url;
  rc = mu_url_create (&url, name);
  if (rc)
    return rc;
  rc = mu_url_parse (url);
  if (rc == 0)
    rc = mu_folder_create_from_record (pfolder, url, ((void *)0));
  if (rc)
    mu_url_destroy (&url);
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 6
8 5
9 6
10 14
11 14
12 14
13 14
14 14
15 14
16 8
17 8
18 9
19 9
20 12
21 12
22 12
23 12
24 14
25 12
26 14
27 14
28 14
29 14
30 14
31 10
32 10
33 10
34 10
35 11
36 11
37 14
38 14
39 14
40 14
41 14
42 14
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gsl_utils_placeholder (void)
{
  int i = 0;
  i++ ;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3bf0 <gsl_eigen_francis_free+0x10>
jmpq   3bea <gsl_eigen_francis_free+0xa>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_francis_free (gsl_eigen_francis_workspace *w)
{
  if (!w) { return ; };
  free(w);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
sub    $0x18,%rsp
callq  48 <mu_nntp_stream_readline+0x18>
mov    %rax,%rbx
xor    %ecx,%ecx
xor    %eax,%eax
test   %rbx,%rbx
movq   $0x0,(%rsp)
je     63 <mu_nntp_stream_readline+0x33>
mov    0x8(%rbx),%edx
test   %edx,%edx
je     80 <mu_nntp_stream_readline+0x50>
test   %rbp,%rbp
je     6c <mu_nntp_stream_readline+0x3c>
mov    %rcx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %rsp,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
callq  91 <mu_nntp_stream_readline+0x61>
mov    (%rsp),%rcx
test   %rcx,%rcx
jne    63 <mu_nntp_stream_readline+0x33>
mov    (%rbx),%rdx
movl   $0x0,0x80(%rdx)
movl   $0x1,0x8(%rbx)
jmp    63 <mu_nntp_stream_readline+0x33>
<<<sep_in_sample>>>
mu_nntp_stream_readline (mu_stream_t stream, char *buf, size_t buflen, mu_off_t offset, size_t *pn)
{
  struct mu_nntp_stream *nntp_stream = mu_stream_get_owner (stream);
  size_t n = 0;
  int status = 0;
  (void)offset;
  if (nntp_stream)
    {
      if (!nntp_stream->done)
 {
   status = mu_nntp_readline (nntp_stream->nntp, buf, buflen, &n);
   if (n == 0)
     {
       nntp_stream->nntp->state = MU_NNTP_NO_STATE;
       nntp_stream->done = 1;
     }
 }
    }
  if (pn)
    *pn = n;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 5
13 7
14 4
15 7
16 9
17 9
18 9
19 19
20 19
21 20
22 22
23 22
24 22
25 22
26 22
27 22
28 22
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 14
38 14
39 15
40 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <maxerr+0x7>
xorpd  %xmm0,%xmm0
mov    0x108(%rax),%rax
movsd  %xmm0,0x0(%rip)        # 1a <maxerr+0x1a>
movsd  %xmm0,0x0(%rip)        # 22 <maxerr+0x22>
movsd  %xmm0,0x0(%rip)        # 2a <maxerr+0x2a>
test   %rax,%rax
je     109 <maxerr+0x109>
movsd  0x0(%rip),%xmm5        # 3b <maxerr+0x3b>
mov    0x0(%rip),%rsi        # 42 <maxerr+0x42>
mov    0x0(%rip),%rcx        # 49 <maxerr+0x49>
movapd %xmm0,%xmm1
mov    0x0(%rip),%rdx        # 54 <maxerr+0x54>
movapd %xmm0,%xmm3
movapd %xmm0,%xmm4
jmp    64 <maxerr+0x64>
xchg   %ax,%ax
movapd %xmm0,%xmm3
movsd  0xa8(%rax),%xmm2
ucomisd %xmm4,%xmm2
jbe    79 <maxerr+0x79>
movapd %xmm2,%xmm4
mov    %rax,%rsi
movsd  0xb0(%rax),%xmm2
movapd %xmm0,%xmm6
ucomisd %xmm3,%xmm2
cmpnltsd %xmm2,%xmm3
movapd %xmm3,%xmm0
andpd  %xmm3,%xmm6
movapd %xmm5,%xmm3
andnpd %xmm2,%xmm0
cmova  %rax,%rcx
movsd  0xb8(%rax),%xmm2
cmpnltsd %xmm2,%xmm3
orpd   %xmm6,%xmm0
ucomisd %xmm5,%xmm2
andpd  %xmm3,%xmm1
movapd %xmm1,%xmm6
cmova  %rax,%rdx
movapd %xmm3,%xmm1
mov    0x108(%rax),%rax
andnpd %xmm2,%xmm1
test   %rax,%rax
orpd   %xmm6,%xmm1
jne    60 <maxerr+0x60>
movsd  %xmm4,0x0(%rip)        # e3 <maxerr+0xe3>
mov    %rsi,0x0(%rip)        # ea <maxerr+0xea>
mov    %rcx,0x0(%rip)        # f1 <maxerr+0xf1>
movsd  %xmm0,0x0(%rip)        # f9 <maxerr+0xf9>
mov    %rdx,0x0(%rip)        # 100 <maxerr+0x100>
movsd  %xmm1,0x0(%rip)        # 108 <maxerr+0x108>
retq   
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maxerr (void)
{
  struct sym *sp, *dq;
  dq = symtab->sy_link;
  ssemax = abemax = acemax = 0.0;
  for (sp = dq; sp != ((void *)0); sp = sp->sy_link)
    {
      if (ssemax < sp->sy_sserr)
 {
   ssemax = sp->sy_sserr;
   ssenam = sp->sy_name;
 }
      if (abemax < sp->sy_aberr)
 {
   abemax = sp->sy_aberr;
   abenam = sp->sy_name;
 }
      if (acmax < sp->sy_acerr)
 {
   acemax = sp->sy_acerr;
   acenam = sp->sy_name;
 }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 8
22 10
23 11
24 13
25 16
26 16
27 16
28 16
29 16
30 21
31 16
32 16
33 18
34 21
35 16
36 21
37 21
38 21
39 21
40 21
41 6
42 21
43 6
44 21
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2857 <asm_get_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_get_in (void)
{
        return asm_in;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_search_atleast (gl_oset_t set,
                        gl_setelement_threshold_fn threshold_fn,
                        const void *threshold, const void **eltp)
{
  return ((const struct gl_oset_impl_base *) set)->vtable
         ->search_atleast (set, threshold_fn, threshold, eltp);
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r12
mov    0x18(%rdi),%rbx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rbp
test   %r12,%r12
je     3c70 <gsl_matrix_uint_set_all+0x1a0>
mov    %esi,-0xc(%rsp)
lea    0x0(,%rbp,4),%r13
mov    %rbx,%rcx
movd   -0xc(%rsp),%xmm1
xor    %r8d,%r8d
xor    %r9d,%r9d
pshufd $0x0,%xmm1,%xmm0
jmpq   3be0 <gsl_matrix_uint_set_all+0x110>
nopw   0x0(%rax,%rax,1)
cmp    $0x1,%rdi
mov    %esi,(%rcx)
je     3c20 <gsl_matrix_uint_set_all+0x150>
cmp    $0x2,%rdi
mov    %esi,0x4(%rcx)
je     3c60 <gsl_matrix_uint_set_all+0x190>
cmp    $0x3,%rdi
mov    %esi,0x8(%rcx)
je     3c50 <gsl_matrix_uint_set_all+0x180>
cmp    $0x4,%rdi
mov    %esi,0xc(%rcx)
je     3c40 <gsl_matrix_uint_set_all+0x170>
cmp    $0x6,%rdi
mov    %esi,0x10(%rcx)
jne    3c30 <gsl_matrix_uint_set_all+0x160>
mov    %esi,0x14(%rcx)
mov    $0x6,%eax
cmp    %rdi,%rdx
je     3bcd <gsl_matrix_uint_set_all+0xfd>
mov    %rdx,%r14
sub    %rdi,%r14
mov    %r14,%r10
shr    $0x2,%r10
lea    0x0(,%r10,4),%r11
test   %r11,%r11
je     3ba8 <gsl_matrix_uint_set_all+0xd8>
lea    (%rcx,%rdi,4),%r15
xor    %edi,%edi
add    $0x1,%rdi
add    $0x10,%r15
movdqa %xmm0,-0x10(%r15)
cmp    %r10,%rdi
jb     3b8d <gsl_matrix_uint_set_all+0xbd>
add    %r11,%rax
cmp    %r11,%r14
je     3bcd <gsl_matrix_uint_set_all+0xfd>
lea    (%rax,%r8,1),%rdi
mov    %esi,(%rbx,%rdi,4)
lea    0x1(%rax),%rdi
cmp    %rdi,%rdx
jbe    3bcd <gsl_matrix_uint_set_all+0xfd>
add    $0x2,%rax
add    %r8,%rdi
cmp    %rax,%rdx
mov    %esi,(%rbx,%rdi,4)
jbe    3bcd <gsl_matrix_uint_set_all+0xfd>
add    %r8,%rax
mov    %esi,(%rbx,%rax,4)
add    $0x1,%r9
add    %r13,%rcx
add    %rbp,%r8
cmp    %r12,%r9
je     3c70 <gsl_matrix_uint_set_all+0x1a0>
test   %rdx,%rdx
je     3bcd <gsl_matrix_uint_set_all+0xfd>
mov    %rcx,%rax
mov    %rdx,%rdi
and    $0xf,%eax
shr    $0x2,%rax
neg    %rax
and    $0x3,%eax
cmp    %rdx,%rax
cmova  %rdx,%rax
cmp    $0x6,%rdx
jbe    3b20 <gsl_matrix_uint_set_all+0x50>
test   %rax,%rax
jne    3c7b <gsl_matrix_uint_set_all+0x1ab>
xor    %edi,%edi
xor    %eax,%eax
jmpq   3b6d <gsl_matrix_uint_set_all+0x9d>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
jmpq   3b68 <gsl_matrix_uint_set_all+0x98>
nopw   0x0(%rax,%rax,1)
mov    $0x5,%eax
jmpq   3b68 <gsl_matrix_uint_set_all+0x98>
nopw   0x0(%rax,%rax,1)
mov    $0x4,%eax
jmpq   3b68 <gsl_matrix_uint_set_all+0x98>
nopw   0x0(%rax,%rax,1)
mov    $0x3,%eax
jmpq   3b68 <gsl_matrix_uint_set_all+0x98>
nopw   0x0(%rax,%rax,1)
mov    $0x2,%eax
jmpq   3b68 <gsl_matrix_uint_set_all+0x98>
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %rax,%rdi
jmpq   3b20 <gsl_matrix_uint_set_all+0x50>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_set_all (gsl_matrix_uint * m, unsigned int x)
{
  size_t i, j;
  unsigned int * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(unsigned int *) (data + 1 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 4
9 6
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 10
39 10
40 10
41 10
42 10
43 10
44 10
45 10
46 10
47 10
48 10
49 2
50 2
51 2
52 12
53 12
54 12
55 12
56 12
57 12
58 12
59 12
60 10
61 10
62 10
63 10
64 12
65 10
66 12
67 10
68 12
69 12
70 8
71 8
72 8
73 8
74 8
75 10
76 10
77 10
78 10
79 10
80 10
81 10
82 10
83 10
84 10
85 10
86 10
87 10
88 10
89 10
90 10
91 10
92 10
93 10
94 10
95 10
96 10
97 10
98 10
99 10
100 10
101 10
102 10
103 10
104 10
105 10
106 10
107 10
108 15
109 15
110 15
111 15
112 15
113 15
114 15
115 10
116 10
117 10
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0xa0,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x98(%rsp)
xor    %eax,%eax
mov    0x8(%rsi),%eax
test   %eax,%eax
je     117 <nntp_itr_destroy+0x77>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     d3 <nntp_itr_destroy+0x33>
callq  d3 <nntp_itr_destroy+0x33>
mov    (%rbx),%rax
mov    %rbx,%rdi
movl   $0x0,0x80(%rax)
callq  e8 <nntp_itr_destroy+0x48>
xor    %eax,%eax
mov    0x98(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    13a <nntp_itr_destroy+0x9a>
add    $0xa0,%rsp
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
cmpq   $0x0,(%rsp)
je     c5 <nntp_itr_destroy+0x25>
mov    (%rbx),%rdi
lea    0x10(%rsp),%rsi
mov    %rsp,%rcx
mov    $0x80,%edx
movq   $0x0,(%rsp)
callq  134 <nntp_itr_destroy+0x94>
test   %eax,%eax
jg     110 <nntp_itr_destroy+0x70>
jmp    c5 <nntp_itr_destroy+0x25>
nopw   0x0(%rax,%rax,1)
callq  145 <nntp_itr_destroy+0xa5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_itr_destroy (mu_iterator_t iterator, void *owner)
{
  struct nntp_iterator *nntp_iterator = (struct nntp_iterator *)owner;
  if (!nntp_iterator->done)
    {
      char buf[128];
      size_t n = 0;
      while (mu_nntp_readline (nntp_iterator->nntp, buf, sizeof buf, &n) > 0 && n > 0)
 n = 0;
    }
  if (nntp_iterator->item)
    free (nntp_iterator->item);
  nntp_iterator->nntp->state = MU_NNTP_NO_STATE;
  free (nntp_iterator);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 11
11 11
12 11
13 12
14 13
15 14
16 13
17 14
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 8
34 8
35 8
36 8
37 8
38 16
39 16
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %rdx,%rsi
mov    %rcx,%rdx
push   %rbx
mov    %rcx,%rbx
sub    $0x8,%rsp
callq  1a <AAllocColor+0x1a>
test   %eax,%eax
je     3e <AAllocColor+0x3e>
mov    0x1820(%rbp),%rdx
mov    (%rbx),%rcx
mov    %rcx,0x1020(%rbp,%rdx,8)
mov    %rdx,(%rbx)
add    $0x1,%rdx
mov    %rdx,0x1820(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
AAllocColor(AWindow *a, Display *display, Colormap colormap, XColor *c)
{
 int result;
 result = XAllocColor (display, colormap, c);
 if (result) {
  a->color_to_pixel_map[a->color_to_pixel_map_top] = c->pixel;
  c->pixel = a->color_to_pixel_map_top;
  a->color_to_pixel_map_top++;
 }
 return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 2
9 4
10 5
11 5
12 6
13 6
14 6
15 7
16 8
17 8
18 11
19 11
20 11
21 11
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
new_buffer_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dummy_free(void *vstate)
{
  (void) vstate;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbx
callq  df6 <setup_glob_ignore+0x6>
mov    $0x0,%edi
mov    %rax,%rbx
callq  e03 <setup_glob_ignore+0x13>
mov    0x0(%rip),%eax        # e09 <setup_glob_ignore+0x19>
test   %eax,%eax
jne    e18 <setup_glob_ignore+0x28>
test   %rbx,%rbx
je     e28 <setup_glob_ignore+0x38>
pop    %rbx
retq   
nopl   0x0(%rax)
movl   $0x1,0x0(%rip)        # e22 <setup_glob_ignore+0x32>
pop    %rbx
retq   
nopl   0x0(%rax)
movl   $0x0,0x0(%rip)        # e32 <setup_glob_ignore+0x42>
pop    %rbx
retq   
<<<sep_in_sample>>>
setup_glob_ignore (name)
     char *name;
{
  char *v;
  v = get_string_value (name);
  setup_ignore_patterns (&globignore);
  if (globignore.num_ignores)
    glob_dot_filenames = 1;
  else if (v == 0)
    glob_dot_filenames = 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 5
5 6
6 7
7 7
8 7
9 9
10 9
11 11
12 11
13 11
14 8
15 11
16 11
17 11
18 10
19 11
20 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2867 <asm_get_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_get_out (void)
{
        return asm_out;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  37ce <version+0xe>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  37dd <version+0x1d>
mov    $0x0,%edi
callq  37e7 <version+0x27>
mov    $0x0,%edi
callq  37f1 <version+0x31>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  3800 <version+0x40>
mov    $0x0,%edi
callq  380a <version+0x4a>
mov    %rax,%rdi
xor    %eax,%eax
callq  3814 <version+0x54>
mov    $0x0,%edi
callq  381e <version+0x5e>
mov    %rax,%rdi
xor    %eax,%eax
callq  3828 <version+0x68>
mov    $0x0,%edi
xor    %eax,%eax
callq  3834 <version+0x74>
mov    $0x0,%edi
xor    %eax,%eax
callq  3840 <version+0x80>
mov    $0xa,%edi
add    $0x8,%rsp
jmpq   384e <version+0x8e>
xchg   %ax,%ax
<<<sep_in_sample>>>
version(void)
{
    printf(gettext(" GNU nano, version %s\n"), "2.7.0");
    printf(" (C) 1999..2016 Free Software Foundation, Inc.\n");
    printf(gettext(" (C) 2014..%s the contributors to nano\n"), "2016");
    printf(
 gettext(" Email: nano@nano-editor.org	Web: https://nano-editor.org/"));
    printf(gettext("\n Compiled options:"));
    printf(" --disable-libmagic");
    printf(" --disable-utf8");
    printf("\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 6
19 6
20 6
21 8
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 10
30 10
31 10
32 11
33 12
34 11
35 11
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     80 <sdp_message_o_username_get+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_o_username_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->o_username;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 46 <set_current_addr+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_current_addr( const int addr ) { current_addr_ = addr; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
mov    (%rsi),%edx
cmp    %edx,(%rdi)
mov    $0x1,%eax
jg     38 <gdbm_version_cmp+0x38>
jl     30 <gdbm_version_cmp+0x30>
mov    0x4(%rsi),%ecx
cmp    %ecx,0x4(%rdi)
jg     38 <gdbm_version_cmp+0x38>
jl     30 <gdbm_version_cmp+0x30>
mov    0x8(%rsi),%ecx
cmp    %ecx,0x8(%rdi)
jg     38 <gdbm_version_cmp+0x38>
setl   %al
movzbl %al,%eax
neg    %eax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
<<<sep_in_sample>>>
gdbm_version_cmp (int const a[], int const b[])
{
  if (a[0] > b[0])
    return 1;
  else if (a[0] < b[0])
    return -1;
  if (a[1] > b[1])
    return 1;
  else if (a[1] < b[1])
    return -1;
  if (a[2] > b[2])
    return 1;
  else if (a[2] < b[2])
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 5
6 7
7 7
8 7
9 9
10 11
11 11
12 11
13 13
14 13
15 13
16 13
17 13
18 6
19 6
20 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # b <print_and_abort+0xb>
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1c <print_and_abort+0x1c>
mov    0x0(%rip),%edi        # 22 <print_and_abort+0x22>
callq  27 <print_and_abort+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_and_abort (void)
{
  fprintf (stderr, "%s\n", ((const char *) ("memory exhausted")));
  exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  4ce <__osip_message_is_known_header+0xe>
movabs $0x6d3a06d3a06d3a07,%rdx
mov    %rax,%rcx
mul    %rdx
shr    $0x6,%rdx
imul   $0x96,%rdx,%rdx
sub    %rdx,%rcx
mov    0x0(,%rcx,4),%ebx
cmp    $0xffffffff,%ebx
je     519 <__osip_message_is_known_header+0x59>
movslq %ebx,%rax
mov    %rbp,%rsi
lea    (%rax,%rax,2),%rax
mov    0x0(,%rax,8),%rdi
callq  50f <__osip_message_is_known_header+0x4f>
test   %eax,%eax
mov    $0xffffffff,%eax
cmovne %eax,%ebx
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_message_is_known_header (const char *hname)
{
  unsigned long hash;
  int result = -1;
  int index;
  hash = osip_hash (hname);
  hash = hash % 150;
  index = hdr_ref_table[hash];
  if ((index != -1) && (0 == strcmp (pconfig[index].hname, hname))) {
    result = index;
  }
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 7
7 6
8 7
9 7
10 7
11 7
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 4
21 4
22 4
23 13
24 13
25 13
26 13
27 13
28 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    $0x0,%edi
mov    %rsp,%rsi
callq  1a <__gmp_vsnprintf+0x1a>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_vsnprintf (char *buf, size_t size, const char *fmt, va_list ap)
{
  struct gmp_snprintf_t d;
  do {} while (0);
  d.buf = buf;
  d.size = size;
  return __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 7
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
mov    0x30(%rdi),%rcx
test   %rcx,%rcx
je     148 <gsl_spmatrix_minmax+0x58>
mov    0x18(%rdi),%rdi
cmp    $0x1,%rcx
movsd  (%rdi),%xmm1
jbe    16c <gsl_spmatrix_minmax+0x7c>
lea    0x8(%rdi),%rax
lea    (%rdi,%rcx,8),%rcx
movapd %xmm1,%xmm2
nopl   0x0(%rax,%rax,1)
movsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rcx,%rax
movapd %xmm0,%xmm3
maxsd  %xmm2,%xmm0
minsd  %xmm1,%xmm3
movapd %xmm0,%xmm2
movapd %xmm3,%xmm1
jne    118 <gsl_spmatrix_minmax+0x28>
movsd  %xmm1,(%rsi)
xor    %eax,%eax
movsd  %xmm2,(%rdx)
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%cl
mov    $0x31,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  162 <gsl_spmatrix_minmax+0x72>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
movapd %xmm1,%xmm2
jmp    139 <gsl_spmatrix_minmax+0x49>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spmatrix_minmax(const gsl_spmatrix *m, double *min_out, double *max_out)
{
  double min, max;
  size_t n;
  if (m->nz == 0)
    {
      do { gsl_error ("matrix is empty", "spoper.c", 49, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  min = m->data[0];
  max = m->data[0];
  for (n = 1; n < m->nz; ++n)
    {
      double x = m->data[n];
      if (x < min)
        min = x;
      if (x > max)
        max = x;
    }
  *min_out = min;
  *max_out = max;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 9
5 11
6 9
7 11
8 11
9 11
10 10
11 10
12 13
13 13
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 19
22 21
23 20
24 21
25 21
26 2
27 7
28 7
29 7
30 7
31 7
32 7
33 22
34 22
35 10
36 10
37 10
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 7b6 <mu_m_server_stop+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_stop (int code)
{
  stop = code;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4_order (void *vstate)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   3a8 <anubis_assoc_cmp+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
anubis_assoc_cmp (void *item, void *data)
{
  ASSOC *p = item;
  return strcmp (p->key, data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  266 <ET_main+0x16>
test   %eax,%eax
jne    2a0 <ET_main+0x50>
xor    %edx,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  0 <run>
test   %eax,%eax
je     288 <ET_main+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    $0x2,%edx
jmpq   0 <run>
xchg   %ax,%ax
callq  2a5 <ET_main+0x55>
mov    (%rax),%edi
callq  2ac <ET_main+0x5c>
mov    0x0(%rip),%rdi        # 2b3 <ET_main+0x63>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  2c2 <ET_main+0x72>
jmp    26a <ET_main+0x1a>
<<<sep_in_sample>>>
ET_main (const char *plugin_name,
  struct ProblemSet *ps)
{
  int ret;
  if (0 != putenv ("LIBEXTRACTOR_PREFIX=." ":" ".libs/"))
    fprintf (stderr,
      "Failed to update my environment, plugin loading may fail: %s\n",
      strerror ((*__errno_location ())));
  ret = run (plugin_name, ps, EXTRACTOR_OPTION_DEFAULT_POLICY);
  if (0 != ret)
    return ret;
  ret = run (plugin_name, ps, EXTRACTOR_OPTION_IN_PROCESS);
  if (0 != ret)
    return ret;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 3
7 5
8 5
9 5
10 9
11 9
12 9
13 9
14 10
15 10
16 16
17 16
18 16
19 16
20 16
21 16
22 12
23 12
24 16
25 16
26 12
27 12
28 12
29 8
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
<<<sep_out_sample>>>
push   %r12
xor    %eax,%eax
mov    %rdx,%r12
mov    $0x0,%edx
push   %rbp
mov    %rdi,%rbp
mov    0x0(%rip),%rdi        # 257 <vdiag+0x17>
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
callq  265 <vdiag+0x25>
test   %rbx,%rbx
je     280 <vdiag+0x40>
mov    0x0(%rip),%rdi        # 271 <vdiag+0x31>
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  280 <vdiag+0x40>
mov    0x0(%rip),%rdi        # 287 <vdiag+0x47>
mov    %rbp,%rsi
mov    %r12,%rdx
callq  292 <vdiag+0x52>
pop    %rbx
pop    %rbp
pop    %r12
mov    0x0(%rip),%rsi        # 29d <vdiag+0x5d>
mov    $0xa,%edi
jmpq   2a7 <vdiag+0x67>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vdiag (const char *fmt, const char *diagtype, va_list ap)
{
  fprintf (stderr, "%s: ", progname);
  if (diagtype)
    fprintf (stderr, "%s: ", diagtype);
  vfprintf (stderr, fmt, ap);
  _IO_putc ('\n', stderr);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 2
9 2
10 3
11 3
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 8
24 8
25 8
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
callq  203 <startBlackBoxPlayback+0x13>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 20d <startBlackBoxPlayback+0x1d>
je     268 <startBlackBoxPlayback+0x78>
mov    $0x0,%edx
mov    $0xffffffffffffffff,%rax
mov    $0x40,%ecx
mov    %rdx,%rdi
mov    %rax,0x0(%rip)        # 22a <startBlackBoxPlayback+0x3a>
mov    %rax,0x0(%rip)        # 231 <startBlackBoxPlayback+0x41>
mov    %rax,0x0(%rip)        # 238 <startBlackBoxPlayback+0x48>
mov    %rax,0x0(%rip)        # 23f <startBlackBoxPlayback+0x4f>
mov    %rax,0x0(%rip)        # 246 <startBlackBoxPlayback+0x56>
mov    %rax,0x0(%rip)        # 24d <startBlackBoxPlayback+0x5d>
mov    %rax,0x0(%rip)        # 254 <startBlackBoxPlayback+0x64>
mov    %rax,0x0(%rip)        # 25b <startBlackBoxPlayback+0x6b>
rep stos %rax,%es:(%rdi)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rcx        # 26f <startBlackBoxPlayback+0x7f>
mov    $0x27,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  283 <startBlackBoxPlayback+0x93>
jmp    20f <startBlackBoxPlayback+0x1f>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
startBlackBoxPlayback(void)
{
 int i;
 if ((bbin = fopen("./black_box_input", "r")) == (FILE *) ((void *)0)) {
  fprintf(stderr, "unable to open black box playback file\n");
 }
 for (i = 0; i < 32; ++i) {
  pp_map[i] = -1;
 }
 for (i = 0; i < (32 * 8); ++i) {
  pm_map[i] = -1;
 }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 13
22 13
23 13
24 5
25 5
26 5
27 5
28 5
29 5
30 5
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  139 <xrealloc+0x9>
test   %rax,%rax
je     140 <xrealloc+0x10>
pop    %rbx
retq   
test   %rbx,%rbx
je     13e <xrealloc+0xe>
callq  14a <xrealloc+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xrealloc (void *p, size_t n)
{
  p = realloc (p, n);
  if (!p && n != 0)
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 7
7 7
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rcx
lea    (%rcx,%rcx,1),%rdi
lea    0x1(%rdi),%r8
add    %rcx,%rdi
lea    0x0(,%r8,8),%r10
mov    %r8,%r9
shl    $0x4,%r9
mov    -0x8(%rsi,%r10,1),%rax
mov    -0x8(%rsi,%r9,1),%r9
mov    %rax,%rbx
cmp    %rax,%r9
cmovge %r9,%rbx
add    %rbx,%rbx
lea    0x3(%rbx,%rdi,4),%rdi
lea    0x2(%rcx,%rcx,8),%rbx
add    %rbx,%rax
add    %rax,%r9
mov    (%rsi,%rcx,8),%rax
lea    0x1(%rcx,%r8,1),%rcx
sub    (%rsi),%rax
add    -0x8(%rsi,%rcx,8),%rax
sub    (%rsi,%r10,1),%rax
pop    %rbx
add    %r9,%rax
sub    %rax,%rdi
xor    %eax,%eax
test   %rdi,%rdi
cmovns %rdi,%rax
mov    %rax,(%rdx)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
adjlr_(long *n, long *isp, long *ldif)
{
  long lnfc, lsfc, nzlu, jlmax, jumax, ip;
  --isp;
  ip = (*n << 1) + 1;
  jlmax = isp[ip];
  jumax = isp[ip + ip];
  nzlu = isp[*n + 1] - isp[1] + isp[ip + *n + 1] - isp[ip + 1];
  lsfc = *n * 12 + 3 + (((jlmax) >= (jumax) ? (jlmax) : (jumax)) << 1);
  lnfc = *n * 9 + 2 + jlmax + jumax + nzlu;
  *ldif = lsfc - lnfc;
  if (*ldif < 0) *ldif = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 9
6 6
7 7
8 7
9 6
10 7
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 10
19 8
20 8
21 8
22 8
23 8
24 14
25 10
26 11
27 11
28 11
29 11
30 11
31 14
32 14
<<<sep_out_sample>>>
movsd  0x18(%rdi),%xmm0
mov    %rdi,%rax
addsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x18(%rdi)
movsd  0x38(%rdi),%xmm0
addsd  0x10(%rsp),%xmm0
movsd  %xmm0,0x38(%rdi)
movsd  0x58(%rdi),%xmm0
addsd  0x18(%rsp),%xmm0
movsd  %xmm0,0x58(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
VTranslatePoint(VMatrix * Mt, VPoint loc)
{
 Mt->m[0][3] += loc.x;
 Mt->m[1][3] += loc.y;
 Mt->m[2][3] += loc.z;
 return Mt;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %rcx,%rcx
je     938 <gsl_vector_complex_float_isneg+0x68>
mov    0x10(%rdi),%rax
xorps  %xmm1,%xmm1
movss  (%rax),%xmm0
ucomiss %xmm1,%xmm0
jae    940 <gsl_vector_complex_float_isneg+0x70>
movss  0x4(%rax),%xmm0
ucomiss %xmm1,%xmm0
jae    940 <gsl_vector_complex_float_isneg+0x70>
lea    0x0(,%rdx,8),%rsi
neg    %rdx
lea    0x0(,%rdx,8),%rdi
movaps %xmm1,%xmm2
lea    0x4(%rax,%rsi,1),%rax
xor    %edx,%edx
jmp    92f <gsl_vector_complex_float_isneg+0x5f>
nopl   (%rax)
movss  -0x4(%rax),%xmm0
ucomiss %xmm1,%xmm0
jae    940 <gsl_vector_complex_float_isneg+0x70>
add    %rsi,%rax
movss  (%rax,%rdi,1),%xmm0
ucomiss %xmm2,%xmm0
jae    940 <gsl_vector_complex_float_isneg+0x70>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    918 <gsl_vector_complex_float_isneg+0x48>
mov    $0x1,%eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_isneg (const gsl_vector_complex_float * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 6
19 6
20 6
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 6
29 6
30 6
31 17
32 17
33 17
34 13
35 18
36 18
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     32a <reply+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rbx
mov    $0x0,%edi
mov    %ebp,%esi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  362 <reply+0x92>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  36f <reply+0x9f>
mov    $0x0,%edi
callq  379 <reply+0xa9>
mov    0x0(%rip),%rdi        # 380 <reply+0xb0>
callq  385 <reply+0xb5>
mov    0x0(%rip),%eax        # 38b <reply+0xbb>
test   %eax,%eax
je     3db <reply+0x10b>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  3a2 <reply+0xd2>
lea    0xf0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    $0x7,%edi
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  3db <reply+0x10b>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reply (int n, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  printf ("%d ", n);
  vprintf (fmt, ap);
  __builtin_va_end(ap);
  printf ("\r\n");
  fflush (stdout);
  if (debug)
    {
      syslog (7, "<--- %d ", n);
      __builtin_va_start(ap,fmt);
      vsyslog (7, fmt, ap);
      __builtin_va_end(ap);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 2
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 5
29 5
30 6
31 6
32 6
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 12
41 12
42 12
43 12
44 12
45 13
46 14
47 14
48 14
49 13
50 13
51 13
52 13
53 13
54 14
55 17
56 17
57 17
58 17
59 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %esi,%ebp
mov    $0x28,%esi
push   %rbx
mov    %rdi,%rbx
mov    0xe0(%rdi),%rdi
mov    (%rdi),%r12
callq  dd <__xa_close+0x1d>
movq   $0x0,0xe0(%rbx)
mov    %rbx,%rdi
mov    %ebp,%esi
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
jmpq   *%rax
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__xa_close(dbp, flags)
 DB *dbp;
 u_int32_t flags;
{
 int (*real_close) (DB *, u_int32_t);
 real_close = ((XA_METHODS *)dbp->xa_internal)->close;
 CDB___os_free(dbp->xa_internal, sizeof(XA_METHODS));
 dbp->xa_internal = ((void *)0);
 return (real_close(dbp, flags));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 4
6 4
7 6
8 6
9 7
10 8
11 9
12 9
13 10
14 10
15 9
16 10
17 9
18 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x98,%rsp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
callq  44a <rec_record_get_field_index+0x1a>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
jmp    4b3 <rec_record_get_field_index+0x83>
nopl   0x0(%rax)
cmp    0x40(%rsp),%rbp
je     4cd <rec_record_get_field_index+0x9d>
add    $0x1,%rbx
lea    0x40(%rsp),%rdx
lea    0x50(%rsp),%rdi
xor    %ecx,%ecx
mov    $0x1,%esi
callq  4c9 <rec_record_get_field_index+0x99>
test   %al,%al
jne    4a8 <rec_record_get_field_index+0x78>
lea    0x50(%rsp),%rdi
callq  4d7 <rec_record_get_field_index+0xa7>
add    $0x98,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_get_field_index (rec_record_t record,
                            rec_field_t field)
{
  size_t res = 0;
  rec_mset_iterator_t iter;
  rec_field_t list_field;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &list_field, ((void *)0)))
    {
      if (field == list_field)
        {
          break;
        }
      res++;
    }
  rec_mset_iterator_free (&iter);
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 8
26 8
27 10
28 10
29 14
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 16
38 16
39 18
40 18
41 18
42 18
43 18
44 18
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_data (const gsl_block_short * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rsi),%eax
cmp    %eax,(%rdi)
movsd  0x0(%rip),%xmm0        # 10c <Mtsp+0xc>
xorpd  %xmm1,%xmm1
je     220 <Mtsp+0x120>
mov    0x4(%rsi),%eax
cmp    %eax,0x4(%rdi)
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 128 <Mtsp+0x28>
addsd  %xmm1,%xmm2
je     2d0 <Mtsp+0x1d0>
mov    0x8(%rsi),%eax
cmp    %eax,0x8(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 144 <Mtsp+0x44>
je     2c0 <Mtsp+0x1c0>
mov    0xc(%rsi),%eax
cmp    %eax,0xc(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 15c <Mtsp+0x5c>
je     2b0 <Mtsp+0x1b0>
mov    0x10(%rsi),%eax
cmp    %eax,0x10(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 174 <Mtsp+0x74>
je     2a0 <Mtsp+0x1a0>
mov    0x14(%rsi),%eax
cmp    %eax,0x14(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 18c <Mtsp+0x8c>
je     290 <Mtsp+0x190>
mov    0x18(%rsi),%eax
cmp    %eax,0x18(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 1a4 <Mtsp+0xa4>
je     280 <Mtsp+0x180>
mov    0x1c(%rsi),%eax
cmp    %eax,0x1c(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 1bc <Mtsp+0xbc>
je     270 <Mtsp+0x170>
mov    0x20(%rsi),%eax
cmp    %eax,0x20(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 1d4 <Mtsp+0xd4>
je     260 <Mtsp+0x160>
mov    0x24(%rsi),%eax
cmp    %eax,0x24(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 1ec <Mtsp+0xec>
je     250 <Mtsp+0x150>
mov    0x28(%rsi),%eax
cmp    %eax,0x28(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 200 <Mtsp+0x100>
je     240 <Mtsp+0x140>
mov    0x2c(%rsi),%eax
cmp    %eax,0x2c(%rdi)
addsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 214 <Mtsp+0x114>
je     230 <Mtsp+0x130>
addsd  %xmm2,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
jmpq   116 <Mtsp+0x16>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
addsd  %xmm2,%xmm0
retq   
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmp    202 <Mtsp+0x102>
nopw   %cs:0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
jmp    1ee <Mtsp+0xee>
nopw   %cs:0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
jmpq   1da <Mtsp+0xda>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   1c2 <Mtsp+0xc2>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   1aa <Mtsp+0xaa>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   192 <Mtsp+0x92>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   17a <Mtsp+0x7a>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   162 <Mtsp+0x62>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   14a <Mtsp+0x4a>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
jmpq   132 <Mtsp+0x32>
nopl   0x0(%rax)
<<<sep_in_sample>>>
Mtsp(void *xp, void *yp)
{
  int *route1 = (int *) xp, *route2 = (int *) yp;
  double distance = 0;
  unsigned int i;
  for (i = 0; i < (sizeof(cities)/sizeof(Stsp_city)); ++i) {
    distance += ((route1[i] == route2[i]) ? 0 : 1);
  }
  return distance;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
47 7
48 7
49 7
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
58 7
59 7
60 7
61 7
62 7
63 10
64 10
65 10
66 10
67 10
68 10
69 7
70 10
71 10
72 10
73 10
74 10
75 10
76 10
77 10
78 10
79 10
80 10
81 10
82 10
83 10
84 10
85 10
86 10
87 10
88 10
89 10
90 10
91 10
92 10
93 10
94 10
95 10
96 10
97 10
98 10
99 10
100 10
101 10
<<<sep_out_sample>>>
push   %r14
test   %rdi,%rdi
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
je     525 <assoc_dequote+0x85>
mov    0xc(%rdi),%eax
test   %eax,%eax
je     525 <assoc_dequote+0x85>
mov    0x8(%rdi),%eax
xor    %r13d,%r13d
xor    %r12d,%r12d
test   %eax,%eax
jle    519 <assoc_dequote+0x79>
nopl   0x0(%rax)
mov    (%r14),%rdx
mov    (%rdx,%r13,1),%rbx
test   %rbx,%rbx
je     50c <assoc_dequote+0x6c>
nopl   0x0(%rax)
mov    0x10(%rbx),%rdi
callq  4e1 <assoc_dequote+0x41>
mov    0x10(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     4fc <assoc_dequote+0x5c>
mov    $0xce,%edx
mov    $0x0,%esi
callq  4fc <assoc_dequote+0x5c>
mov    %rbp,0x10(%rbx)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    4d8 <assoc_dequote+0x38>
mov    0x8(%r14),%eax
add    $0x1,%r12d
add    $0x8,%r13
cmp    %eax,%r12d
jl     4c8 <assoc_dequote+0x28>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14,%rax
pop    %r14
retq   
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
<<<sep_in_sample>>>
assoc_dequote (h)
     HASH_TABLE *h;
{
  int i;
  BUCKET_CONTENTS *tlist;
  char *t;
  if (h == 0 || ((h)->nentries == 0))
    return ((HASH_TABLE *)((void *)0));
  for (i = 0; i < h->nbuckets; i++)
    for (tlist = ((h && (i < h->nbuckets)) ? h->bucket_array[i] : (BUCKET_CONTENTS *)((void *)0)); tlist; tlist = tlist->next)
      {
 t = dequote_string ((char *)tlist->data);
 do { if (tlist->data) sh_xfree((tlist->data), "assoc.c", 206); } while (0);
 tlist->data = t;
      }
  return h;
}
<<<sep_in_sample>>>
1 3
2 7
3 3
4 3
5 3
6 3
7 3
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 12
24 12
25 13
26 12
27 13
28 13
29 13
30 13
31 13
32 14
33 10
34 10
35 10
36 10
37 9
38 9
39 9
40 9
41 17
42 17
43 17
44 17
45 9
46 17
47 17
48 17
49 17
50 17
51 17
52 8
53 17
54 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # c <gsl_odeiv2_driver_set_hmin+0xc>
movsd  0x20(%rdi),%xmm1
andpd  %xmm2,%xmm0
andpd  %xmm2,%xmm1
ucomisd %xmm1,%xmm0
ja     38 <gsl_odeiv2_driver_set_hmin+0x38>
ucomisd 0x30(%rdi),%xmm0
ja     38 <gsl_odeiv2_driver_set_hmin+0x38>
movsd  %xmm0,0x28(%rdi)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x71,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  51 <gsl_odeiv2_driver_set_hmin+0x51>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv2_driver_set_hmin (gsl_odeiv2_driver * d, const double hmin)
{
  if ((fabs (hmin) > fabs (d->h)) || (fabs (hmin) > d->hmax))
    {
      do { gsl_error ("hmin <= fabs(h) <= hmax required", "driver.c", 113, GSL_EINVAL) ; return 0 ; } while (0);
    }
  d->hmin = fabs (hmin);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 7
11 9
12 9
13 9
14 9
15 5
16 5
17 5
18 5
19 5
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
libunistring_c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_step_name(const gsl_odeiv_step * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
movslq %esi,%rsi
sub    %rsi,0x10(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_rewind (rec_buf_t buf, int n)
{
  if ((buf->used - n) >= 0)
    {
      buf->used = buf->used - n;
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    %edi,%edi
sub    $0x48,%rsp
cvtsi2sd %rdi,%xmm3
movsd  %xmm0,0x10(%rsp)
movsd  %xmm1,0x18(%rsp)
movapd %xmm3,%xmm4
movsd  %xmm3,0x8(%rsp)
addsd  %xmm1,%xmm4
movapd %xmm4,%xmm0
callq  7e <gsl_ran_negative_binomial_pdf+0x2e>
movsd  0x18(%rsp),%xmm1
movsd  %xmm0,0x38(%rsp)
movapd %xmm1,%xmm0
movsd  %xmm1,0x30(%rsp)
callq  99 <gsl_ran_negative_binomial_pdf+0x49>
movsd  0x8(%rsp),%xmm5
movsd  %xmm0,0x18(%rsp)
addsd  0x0(%rip),%xmm5        # ad <gsl_ran_negative_binomial_pdf+0x5d>
movapd %xmm5,%xmm0
callq  b6 <gsl_ran_negative_binomial_pdf+0x66>
movsd  %xmm0,0x20(%rsp)
movsd  0x10(%rsp),%xmm0
callq  c7 <gsl_ran_negative_binomial_pdf+0x77>
movsd  0x10(%rsp),%xmm6
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm0        # db <gsl_ran_negative_binomial_pdf+0x8b>
xorpd  %xmm0,%xmm6
movapd %xmm6,%xmm0
callq  e8 <gsl_ran_negative_binomial_pdf+0x98>
movsd  0x38(%rsp),%xmm2
movsd  0x30(%rsp),%xmm1
subsd  0x18(%rsp),%xmm2
mulsd  0x8(%rsp),%xmm0
mulsd  0x28(%rsp),%xmm1
subsd  0x20(%rsp),%xmm2
add    $0x48,%rsp
addsd  %xmm1,%xmm2
addsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
jmpq   121 <gsl_ran_negative_binomial_pdf+0xd1>
<<<sep_in_sample>>>
gsl_ran_negative_binomial_pdf (const unsigned int k, const double p, double n)
{
  double P;
  double f = gsl_sf_lngamma (k + n) ;
  double a = gsl_sf_lngamma (n) ;
  double b = gsl_sf_lngamma (k + 1.0) ;
  P = exp(f - a - b + n * log(p) + k * log1p(-p));
  return P;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 5
15 5
16 6
17 5
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 9
37 7
38 7
39 7
40 7
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  12c <s2s+0xc>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
s2s (union value *vp, void *val, int flags)
{
  vp->string = estrdup (val);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
9 5
<<<sep_out_sample>>>
sub    $0x28,%rsp
movapd %xmm2,%xmm3
movsd  %xmm0,0x10(%rsp)
xorpd  %xmm0,%xmm0
lea    0x10(%rsp),%rax
movapd %xmm1,%xmm2
movsd  0x0(%rip),%xmm1        # 1533 <gsl_integration_qagiu+0x23>
mov    $0x0,%r9d
mov    %rdi,0x18(%rsp)
mov    %rsp,%rdi
movq   $0x0,(%rsp)
mov    %rax,0x8(%rsp)
callq  f0 <qags>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
gsl_integration_qagiu (gsl_function * f,
                       double a,
                       double epsabs, double epsrel, size_t limit,
                       gsl_integration_workspace * workspace,
                       double *result, double *abserr)
{
  int status;
  gsl_function f_transform;
  struct iu_params transform_params ;
  transform_params.a = a ;
  transform_params.f = f ;
  f_transform.function = &iu_transform;
  f_transform.params = &transform_params;
  status = qags (&f_transform, 0.0, 1.0,
                 epsabs, epsrel, limit,
                 workspace,
                 result, abserr,
                 &gsl_integration_qk15);
  return status;
}
<<<sep_in_sample>>>
1 6
2 14
3 10
4 14
5 13
6 14
7 14
8 14
9 11
10 14
11 12
12 13
13 14
14 20
15 20
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x20,%rsp
mov    %r8,0x18(%rsp)
callq  333b <mbox_body_readline+0x1b>
mov    %rax,%rdi
callq  3343 <mbox_body_readline+0x23>
mov    %rax,%rdi
callq  334b <mbox_body_readline+0x2b>
mov    0x18(%rax),%rdx
lea    0x48(%rax),%rdi
mov    0x18(%rsp),%r8
mov    %r12,%rcx
mov    %rbx,%rsi
mov    $0x1,%r9d
mov    %rdx,0x8(%rsp)
mov    0x10(%rax),%rax
mov    %rbp,%rdx
mov    %rax,(%rsp)
callq  3190 <mbox_readstream.isra.1>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_body_readline (mu_stream_t is, char *buffer, size_t buflen,
      mu_off_t off, size_t *pnread)
{
  mu_body_t body = mu_stream_get_owner (is);
  mu_message_t msg = mu_body_get_owner (body);
  mbox_message_t mum = mu_message_get_owner (msg);
  return mbox_readstream (mum, buffer, buflen, off, pnread, 1,
     mum->body, mum->body_end);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x1028(%rsi),%edx
mov    0x102c(%rsi),%esi
cmp    %esi,%edx
jae    6ae0 <is_ungetc+0x40>
mov    0x1020(%rbx),%rax
lea    0x1(%rdx),%ecx
mov    %ecx,0x1028(%rbx)
mov    %bpl,(%rax,%rdx,1)
add    $0x8,%rsp
pop    %rbx
mov    $0x1,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x1020(%rbx),%rdi
add    $0x400,%esi
mov    %esi,0x102c(%rbx)
callq  6af8 <is_ungetc+0x58>
mov    0x1028(%rbx),%edx
mov    %rax,0x1020(%rbx)
jmp    6ac2 <is_ungetc+0x22>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_ungetc (int ch, InputStream *is)
{
  if (is->unget_pos >= is->unget_alloc)
    {
      is->unget_alloc += 1024;
      is->unget_ch = xrealloc (is->unget_ch, is->unget_alloc);
    }
  is->unget_ch[is->unget_pos++] = ch;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 10
20 6
21 5
22 5
23 6
24 6
25 6
26 6
27 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdx),%rax
cmp    0x8(%rdx),%rax
je     1950 <gsl_blas_cher+0x30>
mov    $0x14,%ecx
mov    $0x460,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1946 <gsl_blas_cher+0x26>
mov    $0x14,%eax
add    $0x18,%rsp
retq   
cmp    (%rsi),%rax
je     1980 <gsl_blas_cher+0x60>
mov    $0x13,%ecx
mov    $0x464,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  196e <gsl_blas_cher+0x4e>
mov    $0x13,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x18(%rdx),%r9
mov    0x10(%rdx),%rdx
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rcx
mov    %edi,%esi
mov    $0x65,%edi
mov    %edx,(%rsp)
mov    %eax,%edx
callq  19a1 <gsl_blas_cher+0x81>
xor    %eax,%eax
jmp    194b <gsl_blas_cher+0x2b>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
               const gsl_vector_complex_float * X,
               gsl_matrix_complex_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 1120, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (X->size != N)
    {
      do { gsl_error ("invalid length", "blas.c", 1124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_cher (CblasRowMajor, Uplo, ((int)(M)), alpha, X->data, ((int)(X->stride)),
              A->data, ((int)(A->tda)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 18
12 18
13 11
14 11
15 13
16 13
17 13
18 13
19 13
20 13
21 18
22 18
23 18
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 17
34 17
35 17
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_error(struct csv_parser *p)
{
  return p->status;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  cb <_s_write+0x1b>
mov    0x8(%rsp),%r8
mov    (%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   e9 <_s_write+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_s_write (mu_stream_t stream, const char *iptr, size_t isize,
   mu_off_t offset, size_t *nbytes)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_write (s->fstream, iptr, isize, offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mac_format_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
test   $0x1,%dil
mov    $0x1b8,%edx
jne    3030 <tar_stat_init+0x50>
test   $0x2,%dil
jne    3040 <tar_stat_init+0x60>
test   $0x4,%dil
jne    3058 <tar_stat_init+0x78>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     3010 <tar_stat_init+0x30>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     301f <tar_stat_init+0x3f>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     3027 <tar_stat_init+0x47>
movb   $0x0,(%rdi)
repz retq 
nopl   0x0(%rax)
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0xb7,%dl
test   $0x2,%dil
je     2ff1 <tar_stat_init+0x11>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     2ff7 <tar_stat_init+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    2ff7 <tar_stat_init+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tar_stat_init (struct tar_stat_info *st)
{
  memset (st, 0, sizeof (*st));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
<<<sep_out_sample>>>
sub    $0x7e8,%rsp
mov    0x0(%rip),%edx        # 27fd <ask_if_junkable+0xd>
mov    %fs:0x28,%rax
mov    %rax,0x7d8(%rsp)
xor    %eax,%eax
test   %edx,%edx
mov    $0x1,%al
je     2838 <ask_if_junkable+0x48>
mov    0x7d8(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    28a7 <ask_if_junkable+0xb7>
add    $0x7e8,%rsp
retq   
nopl   0x0(%rax)
mov    %rdi,%rdx
xor    %eax,%eax
mov    $0x0,%edi
callq  2847 <ask_if_junkable+0x57>
mov    0x0(%rip),%rdi        # 284e <ask_if_junkable+0x5e>
callq  2853 <ask_if_junkable+0x63>
mov    0x0(%rip),%rdx        # 285a <ask_if_junkable+0x6a>
mov    $0x3e8,%esi
mov    %rsp,%rdi
callq  2867 <ask_if_junkable+0x77>
test   %rax,%rax
je     28a0 <ask_if_junkable+0xb0>
lea    0x3f0(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %rsp,%rdi
callq  2883 <ask_if_junkable+0x93>
test   %eax,%eax
jle    28a0 <ask_if_junkable+0xb0>
movzbl 0x3f0(%rsp),%eax
and    $0xffffffdf,%eax
cmp    $0x59,%al
sete   %al
movzbl %al,%eax
jmpq   2816 <ask_if_junkable+0x26>
nop
xor    %eax,%eax
jmpq   2816 <ask_if_junkable+0x26>
callq  28ac <ask_if_junkable+0xbc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ask_if_junkable(char *s, int len)
{
  char line[1000];
  char word[1000];
  if (always_yes)
    return 1;
  (void)printf ("Junk `%*s'? ", len, s);
  (void)fflush (stdout);
  if (fgets (line, 1000, stdin) &&
      (sscanf (line, " %s ", word) > 0) &&
      ((word[0] == 'y') || (word[0] == 'Y')))
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 6
8 5
9 14
10 14
11 14
12 14
13 14
14 14
15 7
16 7
17 7
18 7
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 10
28 10
29 10
30 10
31 10
32 9
33 9
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 13
42 13
43 14
44 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  161 <nettle_buffer_write+0x11>
mov    %rax,%rdi
xor    %eax,%eax
test   %rdi,%rdi
je     17b <nettle_buffer_write+0x2b>
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  176 <nettle_buffer_write+0x26>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_buffer_write(struct nettle_buffer *buffer,
      size_t length, const uint8_t *data)
{
  uint8_t *p = nettle_buffer_space(buffer, length);
  if (p)
    {
      memcpy(p, data, length);
      return 1;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 11
9 5
10 5
11 7
12 7
13 7
14 8
15 12
16 12
17 12
18 12
19 12
<<<sep_out_sample>>>
mov    (%rdi),%rcx
cmp    %rcx,0x8(%rdi)
cmovbe 0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %rcx,%rcx
je     2a50 <gsl_matrix_add_diagonal+0x40>
lea    0x8(,%rax,8),%rsi
mov    0x18(%rdi),%rax
xor    %edx,%edx
nopl   0x0(%rax,%rax,1)
movsd  (%rax),%xmm1
add    $0x1,%rdx
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rax)
add    %rsi,%rax
cmp    %rcx,%rdx
jne    2a38 <gsl_matrix_add_diagonal+0x28>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_add_diagonal (gsl_matrix * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 8
13 10
14 10
15 10
16 8
17 8
18 13
19 13
20 13
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rbx
test   %rbx,%rbx
je     350 <gl_array_list_free+0x30>
mov    0x18(%rdi),%r12
test   %r12,%r12
je     380 <gl_array_list_free+0x60>
mov    0x30(%rdi),%rbp
mov    %rbx,%rdi
test   %rbp,%rbp
jne    368 <gl_array_list_free+0x48>
callq  350 <gl_array_list_free+0x30>
add    $0x8,%rsp
mov    %r13,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   362 <gl_array_list_free+0x42>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rbx
mov    -0x8(%rbx),%rdi
callq  *%r12
sub    $0x1,%rbp
jne    368 <gl_array_list_free+0x48>
mov    0x28(%r13),%rdi
jmp    34b <gl_array_list_free+0x2b>
nop
mov    %rbx,%rdi
jmp    34b <gl_array_list_free+0x2b>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_list_free (gl_list_t list)
{
  if (list->elements != ((void *)0))
    {
      if (list->base.dispose_fn != ((void *)0))
        {
          size_t count = list->count;
          if (count > 0)
            {
              gl_listelement_dispose_fn dispose = list->base.dispose_fn;
              const void **elements = list->elements;
              do
                dispose (*elements++);
              while (--count > 0);
            }
        }
      free (list->elements);
    }
  free (list);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 5
11 5
12 5
13 7
14 7
15 8
16 8
17 17
18 20
19 19
20 20
21 20
22 20
23 20
24 19
25 19
26 13
27 13
28 13
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %rdx,%r8
mov    %rdi,%rsi
lea    0x8(%rdi),%rdx
mov    0x18(%rax),%rdi
movsd  (%r8),%xmm0
callq  *0x10(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
secant_init (void * vstate, gsl_function_fdf * fdf, double * root)
{
  secant_state_t * state = (secant_state_t *) vstate;
  const double x = *root;
  (*((fdf)->fdf))(x,(fdf)->params,(&(state->f)),(&(state->df)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  17c <hash_free_medium+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   185 <hash_free_medium+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_free_medium (struct medium * medium)
{
  free (medium->name);
  free (medium);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
mov    0x110(%rdi),%rax
mov    $0x80,%esi
add    0x38(%rax),%rdx
lea    0x34(%rdx),%rdi
test   $0x1,%dil
jne    3c0 <CDB___db_unmap_xid+0x60>
test   $0x2,%dil
jne    3d8 <CDB___db_unmap_xid+0x78>
test   $0x4,%dil
jne    3f0 <CDB___db_unmap_xid+0x90>
mov    %esi,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%sil
rep stos %rax,%es:(%rdi)
je     3a0 <CDB___db_unmap_xid+0x40>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     3b0 <CDB___db_unmap_xid+0x50>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%esi
je     3b8 <CDB___db_unmap_xid+0x58>
movb   $0x0,(%rdi)
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x35(%rdx),%rdi
movb   $0x0,0x34(%rdx)
mov    $0x7f,%sil
test   $0x2,%dil
je     380 <CDB___db_unmap_xid+0x20>
nopl   0x0(%rax)
xor    %edx,%edx
add    $0x2,%rdi
sub    $0x2,%esi
mov    %dx,-0x2(%rdi)
test   $0x4,%dil
je     386 <CDB___db_unmap_xid+0x26>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%esi
add    $0x4,%rdi
jmp    386 <CDB___db_unmap_xid+0x26>
<<<sep_in_sample>>>
CDB___db_unmap_xid(env, xid, off)
 DB_ENV *env;
 XID *xid;
 size_t off;
{ if(xid){}
 TXN_DETAIL *td;
 (xid) = (((void *)0));
 td = (TXN_DETAIL *)((void *)((u_int8_t *)((&((DB_TXNMGR *)env->tx_handle)->reginfo)->addr) + off));
 memset(td->xid, 0, sizeof(td->xid));
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
<<<sep_out_sample>>>
push   %r13
mov    $0x16,%eax
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     63b <mu_list_prepend+0x6b>
mov    0x8(%rdi),%r13
mov    %rsi,%r12
mov    $0x18,%edi
mov    $0x1,%esi
callq  5fd <mu_list_prepend+0x2d>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     63b <mu_list_prepend+0x6b>
mov    0x20(%rbx),%rdi
mov    %r12,0x0(%rbp)
callq  617 <mu_list_prepend+0x47>
mov    0x8(%rbx),%rax
mov    %rbx,0x10(%rbp)
mov    0x20(%rbx),%rdi
mov    %rax,0x8(%rbp)
mov    %rbp,0x10(%r13)
addq   $0x1,0x18(%rbx)
mov    %rbp,0x8(%rbx)
callq  639 <mu_list_prepend+0x69>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_prepend (mu_list_t list, void *item)
{
  struct list_data *ldata;
  struct list_data *first;
  if (list == ((void *)0))
    return 22;
  first = list->head.next;
  ldata = calloc (sizeof (*ldata), 1);
  if (ldata == ((void *)0))
    return 12;
  ldata->item = item;
  mu_monitor_wrlock (list->monitor);
  ldata->prev = &list->head;
  ldata->next = list->head.next;
  first->prev = ldata;
  list->head.next = ldata;
  list->count++;
  mu_monitor_unlock (list->monitor);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 8
16 10
17 9
18 9
19 12
20 11
21 12
22 14
23 13
24 18
25 14
26 15
27 17
28 16
29 18
30 19
31 20
32 20
33 20
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rcx
test   %rsi,%rsi
je     543 <gsl_vector_complex_isnull+0x63>
mov    0x10(%rdi),%rax
xorpd  %xmm1,%xmm1
ucomisd (%rax),%xmm1
jp     550 <gsl_vector_complex_isnull+0x70>
jne    550 <gsl_vector_complex_isnull+0x70>
ucomisd 0x8(%rax),%xmm1
jp     550 <gsl_vector_complex_isnull+0x70>
jne    550 <gsl_vector_complex_isnull+0x70>
mov    %rcx,%rdi
neg    %rcx
xor    %edx,%edx
shl    $0x4,%rdi
shl    $0x4,%rcx
lea    0x8(%rax,%rdi,1),%rax
movapd %xmm1,%xmm0
jmp    53a <gsl_vector_complex_isnull+0x5a>
ucomisd -0x8(%rax),%xmm1
jp     550 <gsl_vector_complex_isnull+0x70>
ucomisd -0x8(%rax),%xmm0
jne    550 <gsl_vector_complex_isnull+0x70>
add    %rdi,%rax
ucomisd (%rax,%rcx,1),%xmm0
jp     550 <gsl_vector_complex_isnull+0x70>
jne    550 <gsl_vector_complex_isnull+0x70>
add    $0x1,%rdx
cmp    %rsi,%rdx
jne    520 <gsl_vector_complex_isnull+0x40>
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_isnull (const gsl_vector_complex * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 6
16 6
17 6
18 6
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 6
30 6
31 6
32 17
33 17
34 17
35 13
36 18
37 18
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
sigsegv_reset_onstack_flag (void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
cmpb   $0x17,0x2(%rdi)
jne    88 <DISAddPDUSizes+0x88>
xor    %r10d,%r10d
cmpb   $0x0,0x19(%rdi)
mov    0x20(%rdi),%r11
mov    %r11,%rdx
mov    %r11,%r9
je     88 <DISAddPDUSizes+0x88>
nopl   (%rax)
mov    %r9,%r8
mov    0x18(%r9),%rax
sub    %r11,%r8
cmpb   $0x0,0x1(%rdx,%r8,1)
je     8a <DISAddPDUSizes+0x8a>
xor    %esi,%esi
xor    %edx,%edx
nopw   %cs:0x0(%rax,%rax,1)
movzbl 0x2d(%rax),%ecx
add    $0x1,%edx
add    $0x40,%rax
lea    0xd(%rcx,%rcx,1),%ecx
mov    %cl,-0x40(%rax)
movzbl %cl,%ecx
add    %rcx,%rsi
mov    0x20(%rdi),%rcx
movzbl 0x1(%rcx,%r8,1),%ecx
cmp    %edx,%ecx
jg     40 <DISAddPDUSizes+0x40>
add    $0x5,%esi
mov    %sil,(%r9)
movzbl 0x19(%rdi),%eax
add    $0x1,%r10d
add    $0x20,%r9
cmp    %r10d,%eax
jle    88 <DISAddPDUSizes+0x88>
mov    0x20(%rdi),%rdx
jmp    20 <DISAddPDUSizes+0x20>
nopl   0x0(%rax,%rax,1)
repz retq 
mov    $0x5,%esi
jmp    69 <DISAddPDUSizes+0x69>
<<<sep_in_sample>>>
DISAddPDUSizes(dis_pdu * p)
{
 int i, j;
 switch (p->hdr.pdu_type) {
 case 23:
  {
   dis_em_emission_pdu *pdu = (dis_em_emission_pdu *) p;
   dis_em_system_info *s = pdu->system;
   dis_beam_info *b;
   unsigned long len;
   for (i = 0; i < pdu->num_systems; ++i, ++s) {
    b = s->beam;
    len = 0;
    for (j = 0; j < pdu->system[i].num_beams; ++j, ++b) {
     b->beam_data_length = 13 + b->num_targets * 2;
     len += b->beam_data_length;
    }
    s->sys_data_length = (u_char) (5 + len);
   }
  }
  break;
 default:
  break;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 11
4 11
5 8
6 11
7 8
8 11
9 11
10 11
11 12
12 12
13 14
14 14
15 13
16 14
17 14
18 15
19 14
20 14
21 15
22 15
23 16
24 16
25 14
26 14
27 14
28 14
29 14
30 18
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 14
41 14
<<<sep_out_sample>>>
jmp    8fe <legal_alias_name+0x2e>
nopw   0x0(%rax,%rax,1)
movzbl %al,%edx
testl  $0x402,0x0(,%rdx,4)
jne    910 <legal_alias_name+0x40>
cmp    $0x24,%al
je     910 <legal_alias_name+0x40>
mov    %eax,%edx
and    $0xfffffffd,%edx
cmp    $0x3c,%dl
je     910 <legal_alias_name+0x40>
cmp    $0x2f,%al
je     910 <legal_alias_name+0x40>
add    $0x1,%rdi
movzbl (%rdi),%eax
test   %al,%al
jne    8d8 <legal_alias_name+0x8>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
legal_alias_name (string, flags)
     char *string;
     int flags;
{
  register char *s;
  for (s = string; *s; s++)
    if ((sh_syntaxtab[(unsigned char)(*s)] & 0x0002) || (sh_syntaxtab[(unsigned char)(*s)] & 0x0400) || ((*s) == '$' || (*s) == '<' || (*s) == '>') || (*s == '/'))
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 6
15 6
16 6
17 6
18 9
19 9
20 9
21 8
22 10
23 10
<<<sep_out_sample>>>
push   %r13
mov    $0x22,%edi
push   %r12
push   %rbp
push   %rbx
mov    $0x22,%ebx
sub    $0x8,%rsp
callq  19 <xgethostname+0x19>
mov    %rax,%rbp
callq  21 <xgethostname+0x21>
mov    %rax,%r13
jmp    48 <xgethostname+0x48>
nopw   %cs:0x0(%rax,%rax,1)
cmpb   $0x0,(%r12)
je     90 <xgethostname+0x90>
add    %rbx,%rbx
mov    %rbp,%rdi
mov    %rbx,%rsi
callq  45 <xgethostname+0x45>
mov    %rax,%rbp
lea    -0x2(%rbx),%r12d
movl   $0x0,0x0(%r13)
xor    %eax,%eax
mov    %rbx,%rsi
mov    %rbp,%rdi
movslq %r12d,%r12
add    %rbp,%r12
movb   $0x0,(%r12)
callq  6c <xgethostname+0x6c>
test   %eax,%eax
je     30 <xgethostname+0x30>
mov    0x0(%r13),%esi
cmp    $0x24,%esi
je     37 <xgethostname+0x37>
test   %esi,%esi
je     37 <xgethostname+0x37>
mov    $0x0,%edx
mov    $0x1,%edi
xor    %eax,%eax
callq  8e <xgethostname+0x8e>
jmp    37 <xgethostname+0x37>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xgethostname ()
{
  char *hostname;
  size_t size;
  int err;
  size = 34;
  hostname = ((char *) xmalloc (sizeof (char) * (size)));
  while (1)
    {
      int k = size - 2;
      (*__errno_location ()) = 0;
      hostname[k] = '\0';
      err = gethostname (hostname, size);
      if (err == 0 && hostname[k] == '\0')
 break;
      else if (err != 0 && (*__errno_location ()) != 36 && (*__errno_location ()) != 0)
 error (1, (*__errno_location ()), "gethostname");
      size *= 2;
      hostname = ((char *) xrealloc ((void *) (hostname), sizeof (char) * (size)));
    }
  return hostname;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 2
6 6
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 14
15 14
16 18
17 19
18 19
19 19
20 19
21 10
22 11
23 13
24 13
25 13
26 12
27 12
28 12
29 13
30 14
31 14
32 16
33 16
34 16
35 16
36 16
37 17
38 17
39 17
40 17
41 17
42 22
43 22
44 22
45 22
46 22
47 22
48 22
<<<sep_out_sample>>>
cmp    %rdx,%rsi
je     30 <_nettle_camellia_invert_key+0x30>
test   %edi,%edi
lea    -0x1(%rdi),%eax
je     64 <_nettle_camellia_invert_key+0x64>
nopl   0x0(%rax)
mov    %eax,%ecx
sub    $0x1,%eax
add    $0x8,%rsi
mov    (%rdx,%rcx,8),%rcx
mov    %rcx,-0x8(%rsi)
cmp    $0xffffffff,%eax
jne    10 <_nettle_camellia_invert_key+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
sub    $0x1,%edi
mov    %edi,%r9d
je     26 <_nettle_camellia_invert_key+0x26>
mov    %edi,%edx
xor    %eax,%eax
nopl   0x0(%rax)
mov    %eax,%ecx
lea    (%rsi,%rdx,8),%rdx
add    $0x1,%eax
lea    (%rsi,%rcx,8),%rcx
mov    (%rdx),%r8
mov    (%rcx),%rdi
mov    %r8,(%rcx)
mov    %rdi,(%rdx)
mov    %r9d,%edx
sub    %eax,%edx
cmp    %edx,%eax
jb     40 <_nettle_camellia_invert_key+0x40>
repz retq 
repz retq 
<<<sep_in_sample>>>
_nettle_camellia_invert_key(unsigned nkeys,
       uint64_t *dst, const uint64_t *src)
{
  unsigned i;
  if (dst == src)
    for (i = 0; i < nkeys - 1 - i; i++)
 do { uint64_t t_swap = (dst[i]); (dst[i]) = (dst[nkeys - 1- i]); (dst[nkeys - 1- i]) = t_swap; } while(0);
  else
    for (i = 0; i < nkeys; i++)
      dst[i] = src[nkeys - 1 - i];
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 9
5 9
6 9
7 10
8 10
9 10
10 10
11 10
12 9
13 9
14 9
15 9
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 6
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 6
33 6
34 6
35 6
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     17e0 <gsl_vector_uint_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  17d5 <gsl_vector_uint_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1813 <gsl_vector_uint_sub+0x63>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%esi
add    %r9,%rcx
sub    %esi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1800 <gsl_vector_uint_sub+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_sub (gsl_vector_uint * a, const gsl_vector_uint * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
xor    %eax,%eax
mov    $0x0,%edx
jmp    217d <slc_update+0x1d>
nopl   0x0(%rax)
add    $0x18,%rdx
cmp    $0x0,%rdx
je     21b8 <slc_update+0x58>
movzbl 0x10(%rdx),%ecx
test   %cl,%cl
jns    2170 <slc_update+0x10>
and    $0x7f,%ecx
mov    %cl,0x10(%rdx)
mov    0x8(%rdx),%rcx
test   %rcx,%rcx
je     2170 <slc_update+0x10>
movzbl (%rdx),%esi
cmp    %sil,(%rcx)
je     2170 <slc_update+0x10>
add    $0x18,%rdx
mov    %sil,(%rcx)
mov    $0x1,%eax
cmp    $0x0,%rdx
jne    217d <slc_update+0x1d>
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
slc_update (void)
{
  register struct spc *spcp;
  int need_update = 0;
  for (spcp = &spc_data[1]; spcp < &spc_data[18 + 1]; spcp++)
    {
      if (!(spcp->flags & 0x80))
 continue;
      spcp->flags &= ~0x80;
      if (spcp->valp && (*spcp->valp != spcp->val))
 {
   *spcp->valp = spcp->val;
   need_update = 1;
 }
    }
  return (need_update);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 9
12 9
13 10
14 10
15 10
16 10
17 10
18 10
19 5
20 12
21 13
22 5
23 5
24 5
25 17
26 17
<<<sep_out_sample>>>
cmpl   $0x1,0x118(%rdi)
jne    e <a2ps_print_char+0xe>
jmpq   e <a2ps_print_char+0xe>
push   %rax
callq  14 <a2ps_print_char+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
a2ps_print_char (a2ps_job * job, int c, enum face_e new_face)
{
  switch (job->output_format)
    {
    case ps:
      ps_print_char (job, c, new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 2
5 9
6 9
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     12b9 <iso9660_close+0x19>
mov    (%rdi),%rdi
callq  12b1 <iso9660_close+0x11>
mov    %rbx,%rdi
callq  12b9 <iso9660_close+0x19>
mov    $0x1,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
iso9660_close (iso9660_t *p_iso)
{
  if (((void *)0) != p_iso) {
    cdio_stdio_destroy(p_iso->stream);
    free(p_iso);
  }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
mov    0xd8(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_timeout (mu_m_server_t srv)
{
  return srv->timeout;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
mov    %rdi,%r14
mov    %rsi,%rdi
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     4420 <gsl_block_char_raw_fread+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
mov    %rsi,%rbx
jne    43cc <gsl_block_char_raw_fread+0x3c>
jmp    4410 <gsl_block_char_raw_fread+0x80>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r13,%rbx
cmp    %r12,%rbp
je     4410 <gsl_block_char_raw_fread+0x80>
mov    %r14,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  43e1 <gsl_block_char_raw_fread+0x51>
cmp    $0x1,%rax
je     43c0 <gsl_block_char_raw_fread+0x30>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4400 <gsl_block_char_raw_fread+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r14,%rcx
mov    $0x1,%esi
callq  442d <gsl_block_char_raw_fread+0x9d>
cmp    %r12,%rax
je     4410 <gsl_block_char_raw_fread+0x80>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  444b <gsl_block_char_raw_fread+0xbb>
mov    $0x5,%eax
jmp    4405 <gsl_block_char_raw_fread+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_char_raw_fread (FILE * stream, char * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (char), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (char), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 19
28 19
29 21
30 21
31 21
32 21
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 25
47 26
48 26
49 26
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     ff0 <gsl_vector_complex_long_double_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  100f <gsl_vector_complex_long_double_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_complex_long_double_const_view_array (const long double * base, size_t n)
{
  _gsl_vector_complex_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
    v.data = (long double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1e8 <gsl_interp_free+0x28>
mov    (%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     1db <gsl_interp_free+0x1b>
mov    0x20(%rdi),%rdi
callq  *%rax
mov    %rbx,%rdi
pop    %rbx
jmpq   1e4 <gsl_interp_free+0x24>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_free (gsl_interp * interp)
{
  if (!interp) { return ; };
  if (interp->type->free)
    interp->type->free (interp->state);
  free (interp);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 7
13 6
14 6
15 7
16 7
17 7
<<<sep_out_sample>>>
push   %rbx
mov    0xa0(%rdi),%rax
mov    %rdi,%rbx
mov    $0x13,%esi
movl   $0xffffffff,(%rax)
movq   $0xffffffffffffffff,0x8(%rax)
callq  263 <osip_nist_timeout_j_event+0x23>
mov    %rbx,%rsi
mov    $0x3,%edi
pop    %rbx
jmpq   271 <osip_nist_timeout_j_event+0x31>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_nist_timeout_j_event (osip_transaction_t * nist, osip_event_t * evt)
{
  nist->nist_context->timer_j_length = -1;
  nist->nist_context->timer_j_start.tv_sec = -1;
  __osip_transaction_set_state (nist, NIST_TERMINATED);
  __osip_kill_transaction_callback (OSIP_NIST_KILL_TRANSACTION, nist);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 3
6 4
7 5
8 6
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
mov    %rsi,0x68(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
msadams_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msadams_state_t *state = (msadams_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  7e <rk4_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  8c <rk4_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  9a <rk4_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  a8 <rk4_reset+0x48>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  b6 <rk4_reset+0x56>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
rk4_reset (void *vstate, size_t dim)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  memset((state->k),0,(dim)*sizeof(double));
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y_onestep),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %r12
movslq %edi,%rax
mov    %rsi,%r12
push   %rbp
lea    -0x8(%rsi,%rax,8),%rbp
push   %rbx
mov    %edi,%ebx
jmp    eca <mu_argcv_free+0x2a>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rbp),%rdi
test   %rdi,%rdi
je     ec6 <mu_argcv_free+0x26>
callq  ec6 <mu_argcv_free+0x26>
sub    $0x8,%rbp
sub    $0x1,%ebx
jns    eb8 <mu_argcv_free+0x18>
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
jmpq   edb <mu_argcv_free+0x3b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_argcv_free (int argc, char **argv)
{
  while (--argc >= 0)
    if (argv[argc])
      free (argv[argc]);
  free (argv);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 4
11 4
12 4
13 5
14 5
15 3
16 3
17 7
18 7
19 6
20 7
21 6
22 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  1ee <_rl_push_executing_macro+0xe>
mov    0x0(%rip),%rdx        # 1f5 <_rl_push_executing_macro+0x15>
mov    %rax,0x0(%rip)        # 1fc <_rl_push_executing_macro+0x1c>
mov    %rdx,(%rax)
mov    0x0(%rip),%edx        # 205 <_rl_push_executing_macro+0x25>
mov    %edx,0x10(%rax)
mov    0x0(%rip),%rdx        # 20f <_rl_push_executing_macro+0x2f>
mov    %rdx,0x8(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_push_executing_macro ()
{
  struct saved_macro *saver;
  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
  saver->next = macro_list;
  saver->sindex = executing_macro_index;
  saver->string = rl_executing_macro;
  macro_list = saver;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 8
6 5
7 6
8 6
9 7
10 7
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    %rsi,%rdi
jmpq   588 <_free_rcpt+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_free_rcpt (void *data, char *value)
{
  free (value);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
test   %rsi,%rsi
je     4938 <ForAllVarwSep+0x148>
test   %rcx,%rcx
jne    48a0 <ForAllVarwSep+0xb0>
xor    %r12d,%r12d
xor    %ebp,%ebp
test   %rdx,%rdx
mov    $0xffffffffffffffff,%r15
je     4880 <ForAllVarwSep+0x90>
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x8(%rbx)
je     4858 <ForAllVarwSep+0x68>
test   %r12d,%r12d
mov    $0x0,%edx
mov    %rbx,%rsi
cmove  %r15,%rdx
mov    %r14,%rdi
add    $0x1,%r12d
mov    %rdx,%r15
callq  *%r13
add    %eax,%ebp
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    4830 <ForAllVarwSep+0x40>
mov    %r14,%rdi
mov    $0x1,%edx
xor    %esi,%esi
callq  *%r13
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nop
xor    %eax,%eax
cmpq   $0x0,0x8(%rbx)
mov    0x18(%rbx),%rbx
setne  %al
add    %eax,%ebp
test   %rbx,%rbx
jne    4880 <ForAllVarwSep+0x90>
jmp    4861 <ForAllVarwSep+0x71>
nopw   0x0(%rax,%rax,1)
xor    %r15d,%r15d
xor    %ebp,%ebp
test   %rdx,%rdx
mov    $0xffffffffffffffff,%r12
jne    48c1 <ForAllVarwSep+0xd1>
jmp    4908 <ForAllVarwSep+0x118>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
je     4861 <ForAllVarwSep+0x71>
mov    0x10(%rbx),%rsi
and    $0xf0000,%esi
cmp    %rsi,%rcx
jne    48b8 <ForAllVarwSep+0xc8>
cmpq   $0x0,0x8(%rbx)
je     48b8 <ForAllVarwSep+0xc8>
test   %r15d,%r15d
mov    $0x0,%edx
mov    %rcx,0x8(%rsp)
cmove  %r12,%rdx
mov    %rbx,%rsi
mov    %r14,%rdi
mov    %rdx,%r12
add    $0x1,%r15d
callq  *%r13
mov    0x8(%rsp),%rcx
add    %eax,%ebp
jmp    48b8 <ForAllVarwSep+0xc8>
nopl   0x0(%rax)
mov    0x10(%rbx),%rax
and    $0xf0000,%eax
cmp    %rax,%rcx
jne    4925 <ForAllVarwSep+0x135>
xor    %eax,%eax
cmpq   $0x0,0x8(%rbx)
setne  %al
add    %eax,%ebp
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
jne    4908 <ForAllVarwSep+0x118>
jmpq   4861 <ForAllVarwSep+0x71>
nopl   0x0(%rax,%rax,1)
xor    %ebp,%ebp
jmpq   4861 <ForAllVarwSep+0x71>
nop
<<<sep_in_sample>>>
ForAllVarwSep (PFILE pfile, PVMMAPSTRCT pvm, PFI_CALLBACK pfiFunc,
                   HANDLE hType, PVOID pinfo)
{
  int iTotal = 0;
  long End = -1;
  int iCount = 0;
  while (pvm) {
    if (hType == (0)
        || (pvm ? (pvm)->hType & 0xF0000 : 0x00000) == hType) {
      if (pvm->szEqn != vszHasInitializer) {
        if (pfiFunc) {
          if (iCount > 0)
            End = 0;
          iTotal += (*pfiFunc) (pfile, pvm, (PVOID) End);
          iCount++;
        }
        else
          iTotal++;
      }
    }
    pvm = pvm->pvmNextVar;
  }
  End = 1;
  (*pfiFunc) (pfile, pvm, (PVOID) End);
  return (iTotal);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 7
12 7
13 7
14 7
15 6
16 4
17 4
18 5
19 5
20 5
21 10
22 10
23 10
24 10
25 14
26 14
27 14
28 15
29 15
30 14
31 14
32 21
33 7
34 7
35 24
36 24
37 24
38 24
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 26
47 26
48 26
49 18
50 18
51 21
52 18
53 18
54 7
55 7
56 7
57 7
58 6
59 4
60 4
61 5
62 5
63 5
64 5
65 21
66 7
67 7
68 9
69 9
70 9
71 9
72 10
73 10
74 12
75 12
76 12
77 12
78 14
79 14
80 12
81 15
82 14
83 15
84 14
85 14
86 14
87 9
88 9
89 9
90 9
91 18
92 18
93 18
94 18
95 21
96 7
97 7
98 7
99 7
100 4
101 4
102 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     6ab1 <regfree+0x11>
callq  6ab1 <regfree+0x11>
mov    0x20(%rbx),%rdi
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
test   %rdi,%rdi
je     6ad6 <regfree+0x36>
callq  6ad6 <regfree+0x36>
mov    0x28(%rbx),%rdi
andb   $0xf7,0x38(%rbx)
movq   $0x0,0x20(%rbx)
test   %rdi,%rdi
je     6af0 <regfree+0x50>
callq  6af0 <regfree+0x50>
movq   $0x0,0x28(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
regfree (preg)
    regex_t *preg;
{
  if (preg->buffer != ((void *)0))
    free (preg->buffer);
  preg->buffer = ((void *)0);
  preg->allocated = 0;
  preg->used = 0;
  if (preg->fastmap != ((void *)0))
    free (preg->fastmap);
  preg->fastmap = ((void *)0);
  preg->fastmap_accurate = 0;
  if (preg->translate != ((void *)0))
    free (preg->translate);
  preg->translate = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 9
8 6
9 7
10 8
11 9
12 9
13 10
14 13
15 12
16 11
17 13
18 13
19 14
20 15
21 16
22 16
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1306 <yyset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d0 <filename_pattern_match+0x90>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    (%rdi),%rbx
test   %rbx,%rbx
jne    93 <filename_pattern_match+0x53>
jmp    b8 <filename_pattern_match+0x78>
nopw   0x0(%rax,%rax,1)
cmp    $0x1,%edx
jne    78 <filename_pattern_match+0x38>
lea    0x8(%rbp),%rdi
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    %r12,%rsi
callq  78 <filename_pattern_match+0x38>
mov    0x4(%rbp),%edx
test   %edx,%edx
je     87 <filename_pattern_match+0x47>
test   %eax,%eax
sete   %al
movzbl %al,%eax
test   %eax,%eax
je     c8 <filename_pattern_match+0x88>
mov    (%rbx),%rbx
test   %rbx,%rbx
je     b8 <filename_pattern_match+0x78>
mov    0x10(%rbx),%rbp
mov    0x0(%rbp),%edx
test   %edx,%edx
jne    60 <filename_pattern_match+0x20>
mov    0x8(%rbp),%rdi
mov    $0x1,%edx
mov    %r12,%rsi
callq  af <filename_pattern_match+0x6f>
jmp    78 <filename_pattern_match+0x38>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
filename_pattern_match(struct grecs_list *lp, const char *name)
{
 struct grecs_list_entry *ep;
 if (!lp)
  return 0;
 for (ep = lp->head; ep; ep = ep->next) {
  struct filename_pattern *pat = ep->data;
  int rc;
  switch (pat->type) {
  case 0:
   rc = fnmatch(pat->v.glob, name, (1 << 0));
   break;
  case 1:
   rc = regexec(&pat->v.re, name, 0, ((void *)0), 0);
   break;
  }
  if (pat->neg)
   rc = !rc;
  if (rc == 0)
   return 0;
 }
 return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 9
13 9
14 14
15 14
16 14
17 14
18 14
19 14
20 17
21 17
22 17
23 18
24 18
25 18
26 19
27 19
28 6
29 6
30 6
31 7
32 9
33 9
34 9
35 11
36 11
37 11
38 11
39 12
40 12
41 23
42 23
43 22
44 23
45 23
46 23
47 23
48 23
49 5
50 23
51 23
52 23
53 5
54 23
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x20(%rdi),%rax
mov    0x18(%rdi),%r9
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rcx
mov    %rax,(%rsp)
mov    (%rdi),%rdx
xor    %eax,%eax
mov    %rbp,%rdi
callq  7e2 <putpfent+0x32>
mov    0x28(%rbx),%rdx
test   %rdx,%rdx
je     800 <putpfent+0x50>
add    $0x18,%rsp
mov    %rbp,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
xor    %eax,%eax
jmpq   800 <putpfent+0x50>
add    $0x18,%rsp
mov    %rbp,%rsi
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   813 <putpfent+0x63>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
putpfent (register const struct pfile *pf, register FILE * f)
{
  fprintf (f, "%s %s %s %s %s", pf->p_osid, pf->p_nsid,
           pf->p_user, pf->p_date, pf->p_time);
  if (pf->p_aux != ((void *)0))
    fprintf (f, " %s", pf->p_aux);
  else
    fprintf (f, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 9
20 6
21 6
22 9
23 9
24 6
25 6
26 9
27 8
28 8
29 9
30 9
31 8
32 8
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    45d0 <gsl_vector_char_set_basis+0x40>
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     45bf <gsl_vector_char_set_basis+0x2f>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movb   $0x0,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    45b0 <gsl_vector_char_set_basis+0x20>
imul   %rsi,%rdi
xor    %eax,%eax
movb   $0x1,(%r8,%rdi,1)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  45ed <gsl_vector_char_set_basis+0x5d>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_vector_char_set_basis (gsl_vector_char * v, size_t i)
{
  char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const char zero = 0 ;
  const char one = 1;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(char *) (data + 1 * k * stride) = zero;
    }
  *(char *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 13
7 13
8 13
9 13
10 13
11 13
12 15
13 15
14 13
15 13
16 17
17 18
18 17
19 19
20 19
21 2
22 11
23 11
24 11
25 11
26 11
27 11
28 19
29 19
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  9c5 <gsl_stats_ushort_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  9d8 <gsl_stats_ushort_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  9f5 <gsl_stats_ushort_ttest+0x55>
test   %rbp,%rbp
js     a58 <gsl_stats_ushort_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # a07 <gsl_stats_ushort_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     a78 <gsl_stats_ushort_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     a92 <gsl_stats_ushort_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    9ff <gsl_stats_ushort_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    a19 <gsl_stats_ushort_ttest+0x79>
test   %rbp,%rbp
js     acc <gsl_stats_ushort_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     ae3 <gsl_stats_ushort_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  ac3 <gsl_stats_ushort_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   a37 <gsl_stats_ushort_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    a9c <gsl_stats_ushort_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    aae <gsl_stats_ushort_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ushort_ttest (const unsigned short data1[],
                           const size_t stride1, const size_t n1,
                           const unsigned short data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_ushort_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_ushort_mean (data2, stride2, n2);
  const double pv = gsl_stats_ushort_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %r14
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    1dbf <gsl_matrix_short_equal+0x1f>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     1de8 <gsl_matrix_short_equal+0x48>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1dd8 <gsl_matrix_short_equal+0x38>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r14
retq   
nopl   (%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     1e44 <gsl_matrix_short_equal+0xa4>
lea    (%r8,%r8,1),%r12
lea    (%rax,%rax,1),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     1e35 <gsl_matrix_short_equal+0x95>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movzwl (%r8,%rax,2),%r14d
cmp    %r14w,(%r9,%rax,2)
jne    1e4b <gsl_matrix_short_equal+0xab>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1e20 <gsl_matrix_short_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    1e05 <gsl_matrix_short_equal+0x65>
mov    $0x1,%eax
jmp    1dda <gsl_matrix_short_equal+0x3a>
xor    %eax,%eax
jmp    1dda <gsl_matrix_short_equal+0x3a>
nop
<<<sep_in_sample>>>
gsl_matrix_short_equal (const gsl_matrix_short * a, const gsl_matrix_short * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 30
20 30
21 30
22 30
23 30
24 30
25 30
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 20
44 20
45 20
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 29
55 29
56 23
57 23
58 23
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 14c7 <set_next_block_after+0x7>
cmp    %rax,%rdi
jb     14e5 <set_next_block_after+0x25>
sub    %rax,%rdi
and    $0xfffffffffffffe00,%rdi
lea    0x200(%rax,%rdi,1),%rax
mov    %rax,0x0(%rip)        # 14e5 <set_next_block_after+0x25>
cmp    %rax,0x0(%rip)        # 14ec <set_next_block_after+0x2c>
jb     14f0 <set_next_block_after+0x30>
repz retq 
sub    $0x8,%rsp
callq  14f9 <set_next_block_after+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
set_next_block_after (union block *block)
{
  while (block >= current_block)
    current_block++;
  if (current_block > record_end)
    abort ();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 2
12 6
13 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  eb <osip_thread_exit+0xb>
<<<sep_in_sample>>>
osip_thread_exit ()
{
  pthread_exit (((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   493 <gsl_vector_int_fread+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_fread (FILE * stream, gsl_vector_int * v)
{
  int status = gsl_block_int_raw_fread (stream,
                                                v->data,
                                                v->size,
                                                v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
test   %rbx,%rbx
je     96 <_gdbm_full_write+0x36>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  80 <_gdbm_full_write+0x20>
cmp    $0xffffffffffffffff,%rax
je     a0 <_gdbm_full_write+0x40>
test   %rax,%rax
je     b8 <_gdbm_full_write+0x58>
sub    %rax,%rbx
add    %rax,%rbp
test   %rbx,%rbx
jne    72 <_gdbm_full_write+0x12>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   (%rax)
callq  a5 <_gdbm_full_write+0x45>
cmpl   $0x4,(%rax)
je     6d <_gdbm_full_write+0xd>
pop    %rbx
pop    %rbp
mov    $0x4,%eax
pop    %r12
retq   
nopl   0x0(%rax)
callq  bd <_gdbm_full_write+0x5d>
movl   $0x1c,(%rax)
jmp    aa <_gdbm_full_write+0x4a>
<<<sep_in_sample>>>
_gdbm_full_write (GDBM_FILE dbf, void *buffer, size_t size)
{
  char *ptr = buffer;
  while (size)
    {
      ssize_t wrbytes = _gdbm_mapped_write(dbf, ptr, size);
      if (wrbytes == -1)
 {
   if ((*__errno_location ()) == 4)
     continue;
   return 4;
 }
      if (wrbytes == 0)
 {
   (*__errno_location ()) = 28;
   return 4;
 }
      ptr += wrbytes;
      size -= wrbytes;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 7
14 7
15 13
16 13
17 19
18 18
19 4
20 4
21 22
22 22
23 21
24 22
25 22
26 22
27 9
28 9
29 9
30 22
31 22
32 16
33 22
34 22
35 22
36 15
37 15
38 15
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x28,%rsp
callq  fb <mu_daemon_remove_pidfile+0xb>
cmp    0x0(%rip),%eax        # 101 <mu_daemon_remove_pidfile+0x11>
je     110 <mu_daemon_remove_pidfile+0x20>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rbx        # 117 <mu_daemon_remove_pidfile+0x27>
mov    $0x2f,%esi
movl   $0x0,0x10(%rsp)
mov    %rbx,%rdi
callq  12c <mu_daemon_remove_pidfile+0x3c>
cmp    %rax,%rbx
mov    %rax,%rbp
je     1c9 <mu_daemon_remove_pidfile+0xd9>
lea    0x10(%rsp),%rsi
movb   $0x0,(%rax)
mov    %rbx,%rdi
callq  0 <access_dir>
test   %eax,%eax
movb   $0x2f,0x0(%rbp)
je     1a0 <mu_daemon_remove_pidfile+0xb0>
mov    %eax,%edi
callq  157 <mu_daemon_remove_pidfile+0x67>
mov    0x0(%rip),%rbx        # 15e <mu_daemon_remove_pidfile+0x6e>
mov    %rax,%rbp
mov    $0x0,%esi
mov    $0x0,%edi
callq  170 <mu_daemon_remove_pidfile+0x80>
mov    %rbp,%rdx
mov    %rax,%rdi
mov    %rbx,%rsi
xor    %eax,%eax
callq  180 <mu_daemon_remove_pidfile+0x90>
mov    0x0(%rip),%rdi        # 187 <mu_daemon_remove_pidfile+0x97>
callq  18c <mu_daemon_remove_pidfile+0x9c>
movq   $0x0,0x0(%rip)        # 197 <mu_daemon_remove_pidfile+0xa7>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rbx,%rdi
callq  1a8 <mu_daemon_remove_pidfile+0xb8>
test   %eax,%eax
mov    %rbx,%rdi
je     187 <mu_daemon_remove_pidfile+0x97>
mov    %rbx,0x8(%rsp)
callq  1b9 <mu_daemon_remove_pidfile+0xc9>
mov    (%rax),%eax
mov    0x8(%rsp),%rdi
test   $0xfffffffd,%eax
je     187 <mu_daemon_remove_pidfile+0x97>
jmp    150 <mu_daemon_remove_pidfile+0x60>
callq  1ce <mu_daemon_remove_pidfile+0xde>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_daemon_remove_pidfile (void)
{
  if (getpid () == current_pid)
    {
      int rc;
      uid_t uid = 0;
      char *p = strrchr (pidfile, '/');
      if (pidfile == p)
 {
   abort ();
 }
      *p = 0;
      rc = access_dir (pidfile, &uid);
      *p = '/';
      if (rc == 0)
 {
   if (unlink (pidfile) && (*__errno_location ()) != 2)
     rc = (*__errno_location ());
   else
     rc = 0;
 }
      if (rc)
 mu_error (dgettext ("mailutils", "cannot remove pidfile %s: %s"),
    pidfile, mu_strerror (rc));
      free (pidfile);
      pidfile = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 28
8 28
9 28
10 28
11 28
12 7
13 7
14 6
15 7
16 7
17 8
18 7
19 8
20 13
21 12
22 13
23 13
24 15
25 14
26 15
27 23
28 23
29 23
30 23
31 23
32 23
33 23
34 23
35 23
36 23
37 23
38 23
39 23
40 25
41 26
42 28
43 28
44 28
45 28
46 28
47 17
48 17
49 17
50 17
51 17
52 17
53 17
54 17
55 22
56 22
57 22
58 22
59 10
60 10
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    $0x2,%esi
mov    %rsp,%rdx
callq  e71 <getSizeFromId+0x11>
mov    $0xffffffffffffffff,%rdx
cmp    $0xffffffff,%eax
cmovne 0x30(%rsp),%rdx
add    $0x78,%rsp
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
getSizeFromId (int id)
{
  struct shmid_ds informations;
  if (shmctl (id, 2, (struct shmid_ds *)&informations) == -1)
  {
    return -1;
  }
  return informations.shm_segsz;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 8
6 8
7 8
8 9
9 9
10 9
<<<sep_out_sample>>>
push   %rbx
movzbl 0x188(%rdi),%eax
mov    %rdi,%rbx
test   %al,%al
je     34f9 <is_dumpdir+0x19>
cmpq   $0x0,0x190(%rdi)
je     3500 <is_dumpdir+0x20>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  1e0 <get_gnu_dumpdir>
movzbl 0x188(%rbx),%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
is_dumpdir (struct tar_stat_info *stat_info)
{
  if (stat_info->is_dumpdir && !stat_info->dumpdir)
    get_gnu_dumpdir (stat_info);
  return stat_info->is_dumpdir;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 6
9 6
10 6
11 4
12 4
13 6
14 6
15 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 235a <pict_newstr+0xa>
mov    0x0(%rip),%r9        # 2361 <pict_newstr+0x11>
movslq %esi,%rax
add    %r9,%rax
test   %rdi,%rdi
je     23bf <pict_newstr+0x6f>
movzbl (%rdi),%ecx
test   %cl,%cl
je     23bf <pict_newstr+0x6f>
cmp    0x0(%rip),%esi        # 2379 <pict_newstr+0x29>
jge    23cb <pict_newstr+0x7b>
add    $0x1,%esi
xor    %edx,%edx
jmp    2398 <pict_newstr+0x48>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rdx
add    $0x1,%esi
cmp    %r8d,0x0(%rip)        # 2396 <pict_newstr+0x46>
jle    23c4 <pict_newstr+0x74>
mov    %cl,(%rax,%rdx,1)
movzbl 0x1(%rdi,%rdx,1),%ecx
mov    %esi,%r8d
test   %cl,%cl
jne    2388 <pict_newstr+0x38>
movslq %esi,%rdx
add    %rdx,%r9
add    $0x1,%esi
movb   $0x0,(%r9)
mov    %esi,0x0(%rip)        # 23ba <pict_newstr+0x6a>
add    $0x8,%rsp
retq   
mov    %rax,%r9
jmp    23ad <pict_newstr+0x5d>
mov    %r8d,0x0(%rip)        # 23cb <pict_newstr+0x7b>
mov    0x0(%rip),%rcx        # 23d2 <pict_newstr+0x82>
mov    $0x0,%edi
mov    $0x23,%edx
mov    $0x1,%esi
callq  23e6 <pict_newstr+0x96>
mov    $0x1,%edi
callq  23f0 <pict_init>
<<<sep_in_sample>>>
pict_newstr(char *str)
{
  int s;
  char *s0;
  s0 = charbuf + charnext;
  if (str)
    {
      for (s = 0; str[s]; s++)
 {
   if (charnext < dap_maxchar)
     charbuf[charnext++] = str[s];
   else
     {
       fputs("(pict_newstr) Too many characters.\n", dap_err);
       exit(1);
     }
 }
    }
  charbuf[charnext++] = '\0';
  return s0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 8
9 8
10 8
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 11
22 8
23 11
24 8
25 8
26 8
27 8
28 19
29 19
30 19
31 21
32 21
33 21
34 21
35 21
36 14
37 14
38 14
39 14
40 14
41 15
42 15
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # eb6 <to_int+0x6>
test   %eax,%eax
je     ec5 <to_int+0x15>
push   %rbx
cmpl   $0x1,0x4(%rdi)
mov    %rdi,%rbx
je     ed0 <to_int+0x20>
pop    %rbx
repz retq 
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
movl   $0x2,0x4(%rdi)
mov    $0x0,%esi
xor    %eax,%eax
callq  6f0 <prepend>
mov    %rbx,%rdi
mov    $0x0,%esi
xor    %eax,%eax
pop    %rbx
jmpq   860 <append>
nopl   0x0(%rax)
<<<sep_in_sample>>>
to_int(CODE *x)
{ if (second_pass && x->type == 0x0001)
      { x->lval = 0;
         x->type = 0x0002;
         prepend(x, "real2int" "(");
         append(x, ")");
      }
      return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 9
9 9
10 9
11 3
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 9
20 6
21 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 387 <CDB___os_free+0x7>
test   %rax,%rax
je     390 <CDB___os_free+0x10>
jmpq   *%rax
xchg   %ax,%ax
jmpq   395 <CDB___os_free+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___os_free(ptr, size)
 void *ptr;
 size_t size;
{ if(size){}
 (size) = (0);
 if (CDB___db_jump.j_free != ((void *)0))
  CDB___db_jump.j_free(ptr);
 else
  free(ptr);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 9
7 9
<<<sep_out_sample>>>
mov    %rdi,0x10(%rsi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_out (FILE * out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yyout_r = out_str ;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
movsd  0x18(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_min_fminimizer_x_lower (const gsl_min_fminimizer * s)
{
  return s->x_lower;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
xorpd  %xmm4,%xmm4
sub    $0x8,%rsp
ucomisd %xmm3,%xmm4
ja     170 <gsl_root_test_delta+0x50>
ucomisd %xmm2,%xmm4
ja     198 <gsl_root_test_delta+0x78>
movsd  0x0(%rip),%xmm5        # 13c <gsl_root_test_delta+0x1c>
movapd %xmm0,%xmm4
xor    %eax,%eax
andpd  %xmm5,%xmm4
mulsd  %xmm3,%xmm4
addsd  %xmm2,%xmm4
movapd %xmm0,%xmm2
subsd  %xmm1,%xmm2
andpd  %xmm5,%xmm2
ucomisd %xmm2,%xmm4
ja     168 <gsl_root_test_delta+0x48>
ucomisd %xmm1,%xmm0
jp     1c0 <gsl_root_test_delta+0xa0>
jne    1c0 <gsl_root_test_delta+0xa0>
add    $0x8,%rsp
retq   
nopl   (%rax)
mov    $0xd,%ecx
mov    $0x41,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  189 <gsl_root_test_delta+0x69>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xd,%ecx
mov    $0x44,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b1 <gsl_root_test_delta+0x91>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
jmp    168 <gsl_root_test_delta+0x48>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_root_test_delta (double x1, double x0, double epsabs, double epsrel)
{
  const double tolerance = epsabs + epsrel * fabs(x1) ;
  if (epsrel < 0.0)
    do { gsl_error ("relative tolerance is negative", "convergence.c", 65, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
  if (epsabs < 0.0)
    do { gsl_error ("absolute tolerance is negative", "convergence.c", 68, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
  if (fabs(x1 - x0) < tolerance || x1 == x0)
    return GSL_SUCCESS;
  return GSL_CONTINUE ;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 6
6 6
7 3
8 3
9 9
10 3
11 3
12 3
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 5
29 5
30 11
31 11
32 11
33 7
34 7
35 7
36 7
37 7
38 7
39 11
40 11
41 11
42 10
43 10
44 10
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x8(%rdi),%rdi
callq  1e83 <print_array_assignment+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     1eb8 <print_array_assignment+0x48>
mov    0x0(%rbp),%rsi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  1e9e <print_array_assignment+0x2e>
mov    %rbx,%rdi
mov    $0x353,%edx
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1eb4 <print_array_assignment+0x44>
nopl   0x0(%rax)
pop    %rbx
mov    0x0(%rbp),%rsi
test   %r12d,%r12d
mov    $0x0,%eax
pop    %rbp
pop    %r12
mov    $0x0,%edx
mov    $0x0,%edi
cmove  %rax,%rdx
xor    %eax,%eax
jmpq   1edd <print_array_assignment+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
print_array_assignment (var, quoted)
     SHELL_VAR *var;
     int quoted;
{
  char *vstr;
  vstr = array_to_assign ((ARRAY *)((var)->value), quoted);
  if (vstr == 0)
    printf ("%s=%s\n", var->name, quoted ? "'()'" : "()");
  else
    {
      printf ("%s=%s\n", var->name, vstr);
      sh_xfree((vstr), "arrayfunc.c", 851);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 7
9 6
10 7
11 11
12 11
13 11
14 11
15 11
16 12
17 12
18 12
19 14
20 14
21 14
22 12
23 12
24 14
25 8
26 8
27 8
28 14
29 14
30 8
31 8
32 8
33 8
34 8
35 8
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    %rdx,%rdi
push   %rbp
push   %rbx
mov    %rdx,%rbx
callq  ef0 <encoding_get>
mov    0x8(%rax),%rbp
mov    %r12,%rsi
mov    %rbx,%rdi
callq  ef0 <encoding_get>
pop    %rbx
mov    %rbp,%rsi
mov    0x8(%rax),%rdi
pop    %rbp
pop    %r12
jmpq   1261 <da_encoding_name_cmp+0x31>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_encoding_name_cmp (char * key1, char * key2, struct a2ps_job * job)
{
  return strverscmp ((char *) encoding_get (job, key1)->name,
       (char *) encoding_get (job, key2)->name);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 3
10 3
11 3
12 5
13 3
14 3
15 5
16 5
17 3
18 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    %rsi,%rdi
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
callq  905 <gstrcpy+0x15>
cmp    %rbp,%rax
jae    91d <gstrcpy+0x2d>
mov    %rbx,%rsi
mov    %r12,%rdi
lea    0x1(%rax),%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   91d <gstrcpy+0x2d>
xor    %esi,%esi
mov    %rbx,%rdi
callq  927 <gstrcpy+0x37>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gstrcpy (char *to, const char *from, size_t length)
{
  if (strlen (from) >= length)
    {
      gstrbotch (from, (char *) 0);
    }
  return strcpy (to, from);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 7
12 7
13 7
14 8
15 8
16 8
17 7
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1ce5 <free_history_node+0x45>
testb  $0x10,0x38(%rdi)
je     1ce5 <free_history_node+0x45>
mov    0x18(%rdi),%rdi
callq  1cb8 <free_history_node+0x18>
mov    0x40(%rbx),%rdi
callq  1cc1 <free_history_node+0x21>
mov    0x58(%rbx),%rdi
callq  1cca <free_history_node+0x2a>
mov    0x50(%rbx),%rdi
callq  1cd3 <free_history_node+0x33>
mov    0x48(%rbx),%rdi
callq  1cdc <free_history_node+0x3c>
mov    0x10(%rbx),%rdi
callq  1ce5 <free_history_node+0x45>
mov    %rbx,%rdi
pop    %rbx
jmpq   1cee <free_history_node+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
free_history_node (NODE *n)
{
  if (n && (n->flags & 0x10))
    {
      free (n->contents);
      info_free_references (n->references);
      free (n->next); free (n->prev); free (n->up);
      free (n->nodename);
    }
  free (n);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 10
20 11
21 10
22 10
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1a10 <gsl_vector_int_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a2f <gsl_vector_int_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_const_view_array (const int * base, size_t n)
{
  _gsl_vector_int_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = (int *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
sub    $0x58,%rsp
test   %esi,%esi
lea    0x60(%rsp),%rax
mov    %rdx,0x30(%rsp)
movl   $0x10,(%rsp)
mov    %rax,0x8(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x10(%rsp)
jne    50 <__gmp_randinit+0x50>
mov    0x10(%rax),%rsi
movl   $0x18,(%rsp)
callq  38 <__gmp_randinit+0x38>
test   %eax,%eax
jne    43 <__gmp_randinit+0x43>
orl    $0x8,0x0(%rip)        # 43 <__gmp_randinit+0x43>
add    $0x58,%rsp
retq   
nopl   0x0(%rax,%rax,1)
orl    $0x1,0x0(%rip)        # 57 <__gmp_randinit+0x57>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
__gmp_randinit (gmp_randstate_t rstate, gmp_randalg_t alg, ...)
{
  va_list ap;
  __builtin_va_start(ap,alg);
  switch (alg) {
  case GMP_RAND_ALG_LC:
    if (! __gmp_randinit_lc_2exp_size (rstate, __builtin_va_arg(ap,unsigned long)))
      __gmp_errno |= GMP_ERROR_INVALID_ARGUMENT;
    break;
  default:
    __gmp_errno |= GMP_ERROR_UNSUPPORTED_ARGUMENT;
    break;
  }
  __builtin_va_end(ap);
}
<<<sep_in_sample>>>
1 2
2 5
3 4
4 2
5 4
6 4
7 4
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 8
16 15
17 15
18 15
19 11
20 15
21 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 197 <echoc+0x7>
cmp    0x0(%rip),%rax        # 19e <echoc+0xe>
push   %rbx
mov    %edi,%ebx
jb     1b6 <echoc+0x26>
xor    %esi,%esi
mov    $0x0,%edi
callq  1af <echoc+0x1f>
mov    0x0(%rip),%rax        # 1b6 <echoc+0x26>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 1c1 <echoc+0x31>
mov    %bl,(%rax)
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echoc(int c)
{
        do { if (outbuf->curp >= outbuf->endp) __strbuf_expandbuf(outbuf, 0); *outbuf->curp++ = c;} while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
cmp    $0x1,%ecx
mov    %rdi,%rax
mov    %rdx,%rdi
je     2c0 <nettle_openssl_des_ecb_encrypt+0x20>
mov    %rsi,%rdx
mov    0x0(%rip),%r8        # 2b5 <nettle_openssl_des_ecb_encrypt+0x15>
mov    %rax,%rcx
mov    $0x8,%esi
jmpq   *%r8
mov    %rsi,%rdx
mov    0x0(%rip),%r8        # 2ca <nettle_openssl_des_ecb_encrypt+0x2a>
mov    %rax,%rcx
mov    $0x8,%esi
jmpq   *%r8
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_openssl_des_ecb_encrypt(des_cblock *src, des_cblock *dst,
  des_key_schedule ctx,
  int enc)
{
  ((enc == DES_ENCRYPT) ? nettle_des_encrypt : nettle_des_decrypt)
    (ctx, 8, *dst, *src);
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 5
5 6
6 5
7 6
8 6
9 6
10 6
11 5
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     2100 <gsl_vector_uchar_sub+0x30>
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  20f2 <gsl_vector_uchar_sub+0x22>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
test   %r10,%r10
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
je     213a <gsl_vector_uchar_sub+0x6a>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r8
mov    0x10(%rsi),%r9
add    0x10(%rdi),%r8
add    $0x1,%rax
add    %rbx,%rdx
movzbl (%r9,%rcx,1),%r9d
add    %r11,%rcx
sub    %r9b,(%r8)
cmp    %r10,%rax
jne    2118 <gsl_vector_uchar_sub+0x48>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_uchar_sub (gsl_vector_uchar * a, const gsl_vector_uchar * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 13
16 13
17 13
18 10
19 11
20 13
21 13
22 15
23 15
24 15
25 13
26 13
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1357 <__osip_uri_escape_userinfo+0x7>
jmpq   135c <__osip_uri_escape_userinfo+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__osip_uri_escape_userinfo (const char *string)
{
  return __osip_uri_escape_nonascii_and_nondef (string, userinfo_def);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    0x28(%rdi),%rax
mov    %rdi,%rbx
mov    0x18(%rdi),%rdx
subq   $0x1,0x8(%rax)
test   %rdx,%rdx
je     740 <hashtab_delete+0x50>
mov    0x20(%rdi),%rax
mov    %rax,0x20(%rdx)
mov    0x20(%rbx),%rax
test   %rax,%rax
je     71f <hashtab_delete+0x2f>
mov    0x18(%rbx),%rdx
mov    %rdx,0x18(%rax)
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     72d <hashtab_delete+0x3d>
callq  72d <hashtab_delete+0x3d>
mov    (%rbx),%rdi
callq  735 <hashtab_delete+0x45>
mov    %rbx,%rdi
pop    %rbx
jmpq   73e <hashtab_delete+0x4e>
xchg   %ax,%ax
mov    0xc(%rdi),%edx
mov    0x20(%rdi),%rcx
mov    0x18(%rax),%rax
mov    %rcx,(%rax,%rdx,8)
jmp    70e <hashtab_delete+0x1e>
<<<sep_in_sample>>>
hashtab_delete(struct hashtab_elem *he)
{
  he->ht->items_hashed--;
  if (he->prev)
    he->prev->next = he->next;
  else
    he->ht->table[he->hashval] = he->next;
  if (he->next)
    he->next->prev = he->prev;
  if (he->data)
    free (he->data);
  free (he->key);
  free (he);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 3
6 4
7 4
8 5
9 5
10 8
11 8
12 8
13 9
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 13
22 14
23 13
24 13
25 7
26 7
27 7
28 7
29 7
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
callq  40a0 <gsl_fft_complex_float_transform.constprop.6>
test   %eax,%eax
jne    9cf6 <gsl_fft_complex_float_inverse+0x66>
test   %rbx,%rbx
js     9d00 <gsl_fft_complex_float_inverse+0x70>
cvtsi2ss %rbx,%xmm1
movss  0x0(%rip),%xmm0        # 9cb8 <gsl_fft_complex_float_inverse+0x28>
test   %rbx,%rbx
divss  %xmm1,%xmm0
je     9cf6 <gsl_fft_complex_float_inverse+0x66>
lea    0x0(,%r12,8),%rsi
mov    %rbp,%rdi
xor    %ecx,%ecx
xchg   %ax,%ax
movss  (%rdi),%xmm1
add    $0x1,%rcx
mulss  %xmm0,%xmm1
movss  %xmm1,(%rdi)
movss  0x4(%rdi),%xmm1
mulss  %xmm0,%xmm1
movss  %xmm1,0x4(%rdi)
add    %rsi,%rdi
cmp    %rbx,%rcx
jne    9cd0 <gsl_fft_complex_float_inverse+0x40>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbx,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2ss %rdx,%xmm1
addss  %xmm1,%xmm1
jmp    9cb0 <gsl_fft_complex_float_inverse+0x20>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_float_inverse (gsl_complex_packed_array_float data,
                                   const size_t stride,
                                   const size_t n,
                                   const gsl_fft_complex_wavetable_float * wavetable,
                                   gsl_fft_complex_workspace_float * work)
{
  gsl_fft_direction sign = gsl_fft_backward;
  int status = gsl_fft_complex_float_transform (data, stride, n,
                                                    wavetable, work, sign);
  if (status)
    {
      return status;
    }
  {
    const float norm = 1.0F / (float)n;
    size_t i;
    for (i = 0; i < n; i++)
      {
        ((data)[2*(stride)*(i)]) *= norm;
        ((data)[2*(stride)*(i)+1]) *= norm;
      }
  }
  return status;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 8
8 10
9 10
10 15
11 15
12 15
13 15
14 17
15 15
16 17
17 17
18 17
19 17
20 17
21 19
22 17
23 19
24 19
25 20
26 20
27 20
28 20
29 17
30 17
31 24
32 24
33 24
34 24
35 24
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
<<<sep_out_sample>>>
test   %esi,%esi
jle    10b8 <lm_will+0x68>
sub    $0x8,%rsp
movb   $0xfe,0x0(%rip)        # 105f <lm_will+0xf>
movzbl (%rdi),%eax
mov    $0x0,%edi
mov    %al,0x0(%rip)        # 106d <lm_will+0x1d>
callq  1072 <lm_will+0x22>
cmp    $0x7,%eax
jg     1088 <lm_will+0x38>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   1085 <lm_will+0x35>
nopl   (%rax)
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  109c <lm_will+0x4c>
mov    $0x5,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
add    $0x8,%rsp
jmpq   10b4 <lm_will+0x64>
nopl   0x0(%rax)
mov    $0x0,%edi
jmpq   10c2 <lm_will+0x72>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_will (unsigned char *cmd, int len)
{
  if (len < 1)
    {
             printf ("lm_will: no command!!!\n");
      return;
    }
  switch (cmd[0])
    {
    case 2:
    default:
      str_lm[3] = 254;
      str_lm[4] = cmd[0];
      if ((ring_empty_count(&netoring)) > (int) sizeof (str_lm))
 {
   ring_supply_data (&netoring, str_lm, sizeof (str_lm));
   printsub ('>', &str_lm[2], sizeof (str_lm) - 2);
 }
      else
 printf ("lm_will: not enough room in buffer\n");
      break;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 12
5 13
6 14
7 13
8 14
9 14
10 14
11 20
12 23
13 20
14 20
15 16
16 16
17 16
18 16
19 17
20 17
21 17
22 23
23 17
24 17
25 5
26 5
27 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  3c <def_free_fun+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   45 <def_free_fun+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
def_free_fun(void *p)
{
 struct grecs_syment *sym = p;
 free(sym->name);
 free(sym);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
orl    $0x2,(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_itemlist_dirty (it)
     ITEMLIST *it;
{
  it->flags |= 0x002;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x4c,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  10e3 <CDB___qam_init_recover+0x13>
test   %eax,%eax
je     10f0 <CDB___qam_init_recover+0x20>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x4d,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1102 <CDB___qam_init_recover+0x32>
test   %eax,%eax
jne    10e7 <CDB___qam_init_recover+0x17>
mov    $0x4e,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1118 <CDB___qam_init_recover+0x48>
test   %eax,%eax
jne    10e7 <CDB___qam_init_recover+0x17>
mov    $0x4f,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  112e <CDB___qam_init_recover+0x5e>
test   %eax,%eax
jne    10e7 <CDB___qam_init_recover+0x17>
mov    %rbx,%rdi
mov    $0x50,%edx
mov    $0x0,%esi
pop    %rbx
jmpq   1145 <CDB___qam_init_recover+0x75>
<<<sep_in_sample>>>
CDB___qam_init_recover(dbenv)
 DB_ENV *dbenv;
{
 int ret;
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___qam_inc_recover, 76)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___qam_incfirst_recover, 77)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___qam_mvptr_recover, 78)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___qam_del_recover, 79)) != 0)
  return (ret);
 if ((ret = CDB___db_add_recovery(dbenv,
     CDB___qam_add_recover, 80)) != 0)
  return (ret);
 return (0);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 3
5 5
6 5
7 5
8 21
9 21
10 21
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
21 11
22 11
23 14
24 14
25 14
26 14
27 14
28 14
29 17
30 17
31 17
32 21
33 17
<<<sep_out_sample>>>
test   %r8,%r8
mov    %rcx,%rsi
mov    %r8,%rdx
jle    4d <hgcd_hook+0x4d>
lea    0x0(,%r8,8),%r8
cmpq   $0x0,-0x8(%rcx,%r8,1)
jne    53 <hgcd_hook+0x53>
lea    -0x1(%rdx),%rax
lea    0x0(,%rax,8),%r10
jmp    43 <hgcd_hook+0x43>
nopl   0x0(%rax)
cmpq   $0x0,-0x8(%rsi,%r10,1)
lea    -0x8(%r10),%r11
jne    50 <hgcd_hook+0x50>
mov    %r11,%r10
sub    $0x1,%rax
test   %rax,%rax
mov    %rax,%rdx
jne    30 <hgcd_hook+0x30>
repz retq 
repz retq 
nop
mov    %r10,%r8
add    %rsi,%r8
mov    %r9d,%ecx
jmpq   5e <hgcd_hook+0x5e>
xchg   %ax,%ax
<<<sep_in_sample>>>
hgcd_hook (void *p, mp_srcptr gp, mp_size_t gn,
    mp_srcptr qp, mp_size_t qn, int d)
{
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do { while ((qn) > 0) { if ((qp)[(qn) - 1] != 0) break; (qn)--; } } while (0);
  if (qn > 0)
    {
      struct hgcd_matrix *M = (struct hgcd_matrix *) p;
      mp_ptr tp = (mp_ptr) qp + qn;
      __gmpn_hgcd_matrix_update_q (M, qp, qn, d, tp);
    }
}
<<<sep_in_sample>>>
1 7
2 3
3 3
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0xffffffffffffffff,%rsi
je     14dc <setmtime+0x2c>
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # 14c3 <setmtime+0x13>
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
mov    0x50(%rax),%rax
mov    %rax,(%rsp)
callq  14d8 <setmtime+0x28>
add    $0x18,%rsp
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
setmtime (char const *file, time_t mtime)
{
  struct utimbuf amtime;
  if (mtime == -1)
    return 0;
  amtime.actime = (top->behavior. now);
  amtime.modtime = mtime;
  return utime (file, &amtime);
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 2
5 6
6 7
7 8
8 6
9 6
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%r8
mov    %rdx,%rdi
shr    %rdi
je     6bf <gsl_vector_long_double_reverse+0x4f>
shl    $0x4,%rdx
mov    %r8,%rsi
xor    %ecx,%ecx
sub    $0x10,%rdx
neg    %rsi
imul   %r8,%rdx
shl    $0x4,%rsi
shl    $0x4,%r8
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
fldt   (%rdx)
add    $0x1,%rcx
fldt   (%rax)
fstpt  (%rdx)
add    %rsi,%rdx
fstpt  (%rax)
add    %r8,%rax
cmp    %rdi,%rcx
jne    6a8 <gsl_vector_long_double_reverse+0x38>
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_reverse (gsl_vector_long_double * v)
{
  long double * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          long double tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 14
18 8
19 15
20 15
21 15
22 16
23 16
24 8
25 8
26 20
27 20
28 20
<<<sep_out_sample>>>
xor    %r10d,%r10d
test   %edx,%edx
jle    78 <cblas_zswap+0x78>
xor    %eax,%eax
test   %r8d,%r8d
jle    89 <cblas_zswap+0x89>
test   %edi,%edi
jle    71 <cblas_zswap+0x71>
add    %r10d,%r10d
lea    (%rdx,%rdx,1),%r9d
add    %eax,%eax
movslq %r10d,%r10
cltq   
lea    0x8(%rsi,%r10,8),%rdx
lea    (%r8,%r8,1),%esi
movslq %r9d,%r9
lea    0x8(%rcx,%rax,8),%rax
shl    $0x3,%r9
xor    %ecx,%ecx
movslq %esi,%rsi
shl    $0x3,%rsi
xchg   %ax,%ax
movsd  -0x8(%rax),%xmm2
add    $0x1,%ecx
movsd  -0x8(%rdx),%xmm1
movsd  %xmm2,-0x8(%rdx)
movsd  (%rdx),%xmm0
movsd  (%rax),%xmm2
movsd  %xmm2,(%rdx)
add    %r9,%rdx
movsd  %xmm1,-0x8(%rax)
movsd  %xmm0,(%rax)
add    %rsi,%rax
cmp    %edi,%ecx
jne    40 <cblas_zswap+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    $0x1,%r10b
xor    %eax,%eax
sub    %edi,%r10d
imul   %edx,%r10d
test   %r8d,%r8d
jg     e <cblas_zswap+0xe>
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   e <cblas_zswap+0xe>
<<<sep_in_sample>>>
cblas_zswap (const int N, void *X, const int incX, void *Y, const int incY)
{
{
  int i;
  int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
  int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
  for (i = 0; i < N; i++) {
    const double tmp_real = (((double *) X)[2*(ix)]);
    const double tmp_imag = (((double *) X)[2*(ix)+1]);
    (((double *) X)[2*(ix)]) = (((double *) Y)[2*(iy)]);
    (((double *) X)[2*(ix)+1]) = (((double *) Y)[2*(iy)+1]);
    (((double *) Y)[2*(iy)]) = tmp_real;
    (((double *) Y)[2*(iy)+1]) = tmp_imag;
    ix += incX;
    iy += incY;
  }
}
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 10
24 7
25 8
26 10
27 9
28 11
29 11
30 11
31 12
32 13
33 13
34 7
35 7
36 7
37 7
38 5
39 6
40 5
41 5
42 6
43 6
44 6
45 6
46 6
47 6
<<<sep_out_sample>>>
addl   $0x1,0x0(%rip)        # 277 <disable_interrupts+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
disable_interrupts( void ) { ++mutex; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1e0 <ForAllList+0x50>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     1e8 <ForAllList+0x58>
mov    (%rdi),%rbx
test   %rbx,%rbx
je     1e8 <ForAllList+0x58>
mov    %rdx,%r13
xor    %ebp,%ebp
nopl   0x0(%rax)
mov    (%rbx),%rdi
mov    %r13,%rsi
callq  *%r12
mov    0x8(%rbx),%rbx
add    %eax,%ebp
test   %rbx,%rbx
jne    1b8 <ForAllList+0x28>
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    1ce <ForAllList+0x3e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ForAllList (PLIST plist, PFI_FORLISTCALLBACK pfiCallback, PVOID pUserInfo)
{
  int iTotal = 0;
  PLISTELEM ple;
  if (!plist || !pfiCallback)
    return 0;
  ple = plist->pleHead;
  while (ple) {
    iTotal += (*pfiCallback) (ple->pData, pUserInfo);
    ple = ple->pleNext;
  }
  return (iTotal);
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 7
12 8
13 8
14 8
15 3
16 3
17 9
18 9
19 9
20 10
21 9
22 8
23 8
24 9
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 6
33 13
34 13
35 6
36 6
37 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1e6 <cdio_audio_stop+0x26>
mov    0x40(%rdi),%rax
test   %rax,%rax
je     1e0 <cdio_audio_stop+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
<<<sep_in_sample>>>
cdio_audio_stop (CdIo_t *p_cdio)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_stop) {
    return p_cdio->op.audio_stop(p_cdio->env);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_splinalg_itersolve_name(const gsl_splinalg_itersolve *w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 34f0 <xtrace_print_case_command_head+0x10>
test   %rbx,%rbx
cmove  0x0(%rip),%rbx        # 34fb <xtrace_print_case_command_head+0x1b>
mov    %rbx,0x0(%rip)        # 3502 <xtrace_print_case_command_head+0x22>
callq  3507 <xtrace_print_case_command_head+0x27>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  3512 <xtrace_print_case_command_head+0x32>
mov    0x8(%rbp),%rax
mov    0x0(%rip),%rdi        # 351d <xtrace_print_case_command_head+0x3d>
mov    $0x0,%esi
mov    (%rax),%rdx
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   3532 <xtrace_print_case_command_head+0x52>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xtrace_print_case_command_head (case_command)
     CASE_COM *case_command;
{
  xtrace_fp = (xtrace_fp ? xtrace_fp : stderr);
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 7
18 6
19 7
20 7
21 6
22 6
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
test   %rdx,%rdx
je     6a0 <gsl_stats_ushort_quantile_from_sorted_data+0x70>
sub    $0x1,%rdx
js     6a8 <gsl_stats_ushort_quantile_from_sorted_data+0x78>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     6cf <gsl_stats_ushort_quantile_from_sorted_data+0x9f>
test   %rax,%rax
js     6e0 <gsl_stats_ushort_quantile_from_sorted_data+0xb0>
cvtsi2sd %rax,%xmm1
add    %rsi,%rsi
movapd %xmm0,%xmm2
imul   %rsi,%rax
movsd  0x0(%rip),%xmm0        # 674 <gsl_stats_ushort_quantile_from_sorted_data+0x44>
subsd  %xmm1,%xmm2
add    %rdi,%rsi
movzwl (%rdi,%rax,1),%edx
movzwl (%rsi,%rax,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    653 <gsl_stats_ushort_quantile_from_sorted_data+0x23>
add    %rsi,%rsi
imul   %rdx,%rsi
movzwl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nop
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   661 <gsl_stats_ushort_quantile_from_sorted_data+0x31>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_quantile_from_sorted_data (const unsigned short sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 18
18 8
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 18
30 11
31 21
32 21
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 7
42 7
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
51 8
52 8
53 8
54 8
55 8
56 8
57 8
58 8
59 8
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
xorpd  %xmm2,%xmm2
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 13 <alarmCheck+0x13>
movsd  0x0(%rip),%xmm3        # 1b <alarmCheck+0x1b>
jmp    2a <alarmCheck+0x2a>
nopl   (%rax)
movapd %xmm2,%xmm0
mov    %rax,%rbx
mov    %rdx,%rax
test   %rax,%rax
je     60 <alarmCheck+0x60>
ucomisd %xmm2,%xmm0
jbe    a0 <alarmCheck+0xa0>
movsd  0x8(%rax),%xmm1
subsd  %xmm0,%xmm1
ucomisd %xmm1,%xmm2
jb     b0 <alarmCheck+0xb0>
mov    (%rax),%rdx
mov    %rbx,(%rax)
jbe    20 <alarmCheck+0x20>
movapd %xmm1,%xmm0
xorpd  %xmm3,%xmm0
jmp    24 <alarmCheck+0x24>
nopw   %cs:0x0(%rax,%rax,1)
movq   $0x0,0x0(%rip)        # 6b <alarmCheck+0x6b>
test   %rbx,%rbx
jne    7b <alarmCheck+0x7b>
jmp    98 <alarmCheck+0x98>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rbx
xor    %eax,%eax
mov    0x28(%rbx),%rsi
mov    0x20(%rbx),%rdi
callq  *0x18(%rbx)
mov    (%rbx),%rbp
mov    %rbx,%rdi
callq  93 <alarmCheck+0x93>
test   %rbp,%rbp
jne    78 <alarmCheck+0x78>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    %rax,0x0(%rip)        # a7 <alarmCheck+0xa7>
jmp    6b <alarmCheck+0x6b>
nopl   0x0(%rax)
mov    %rax,0x0(%rip)        # b7 <alarmCheck+0xb7>
movsd  %xmm1,0x8(%rax)
jmp    6b <alarmCheck+0x6b>
xchg   %ax,%ax
<<<sep_in_sample>>>
alarmCheck(double delta)
{
 double d = delta;
 alarm_descriptor_t *p, *list = ((void *)0), *list1;
 while (alarm_list != (alarm_descriptor_t *) ((void *)0) && d > 0.0) {
  if ((d = alarm_list->delta - d) <= 0.0) {
   p = alarm_list;
   alarm_list = alarm_list->next;
   if (list) {
    p->next = list;
    list = p;
   }
   else {
    p->next = ((void *)0);
    list = p;
   }
   d = (d < 0.0) ? -d : 0.0;
  }
  else {
   alarm_list->delta = d;
   break;
  }
 }
 while (list) {
  (*list->proc) (list->arg1, list->arg2);
  list1 = list->next;
  free((char *) list);
  list = list1;
 }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 4
5 2
6 2
7 17
8 5
9 5
10 17
11 17
12 17
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 8
22 8
23 17
24 17
25 17
26 17
27 17
28 17
29 24
30 24
31 24
32 24
33 28
34 25
35 25
36 25
37 25
38 26
39 27
40 27
41 24
42 24
43 30
44 30
45 30
46 30
47 30
48 30
49 30
50 30
51 30
52 20
53 21
54 21
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %edi,%ebx
mov    $0x0,%edi
callq  12 <punycode_strerror+0x12>
cmp    $0x1,%ebx
je     70 <punycode_strerror+0x70>
jb     60 <punycode_strerror+0x60>
cmp    $0x2,%ebx
nopl   0x0(%rax)
je     40 <punycode_strerror+0x40>
cmp    $0x3,%ebx
jne    50 <punycode_strerror+0x50>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   37 <punycode_strerror+0x37>
nopw   0x0(%rax,%rax,1)
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   50 <punycode_strerror+0x50>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   60 <punycode_strerror+0x60>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   70 <punycode_strerror+0x70>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   80 <punycode_strerror+0x80>
<<<sep_in_sample>>>
punycode_strerror (Punycode_status rc)
{
  const char *p;
  bindtextdomain ("libidn", "/usr/local/share/locale");
  switch (rc)
    {
    case PUNYCODE_SUCCESS:
      p = dgettext ("libidn", "Success");
      break;
    case PUNYCODE_BAD_INPUT:
      p = dgettext ("libidn", "Invalid input");
      break;
    case PUNYCODE_BIG_OUTPUT:
      p = dgettext ("libidn", "Output would exceed the buffer space provided");
      break;
    case PUNYCODE_OVERFLOW:
      p = dgettext ("libidn", "String size limit exceeded");
      break;
    default:
      p = dgettext ("libidn", "Unknown error");
      break;
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 24
15 17
16 17
17 17
18 17
19 24
20 14
21 14
22 14
23 24
24 20
25 20
26 20
27 24
28 8
29 8
30 8
31 24
32 11
33 11
34 11
<<<sep_out_sample>>>
testb  $0x1,0x0(%rip)        # 19f7 <slc_mode_export+0x7>
movl   $0x1,0x0(%rip)        # 1a01 <slc_mode_export+0x11>
jne    1a08 <slc_mode_export+0x18>
repz retq 
nopl   (%rax)
jmpq   1a0d <slc_mode_export+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
slc_mode_export (void)
{
  slc_mode = 1;
  if ((options[34]&0x01))
    slc_export ();
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
lea    0x28(%rdi),%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    0x28(%rdi),%rbx
cmp    %r12,%rbx
jne    18e <gl_linked_sortedlist_indexof+0x2e>
jmp    19d <gl_linked_sortedlist_indexof+0x3d>
nop
je     1b0 <gl_linked_sortedlist_indexof+0x50>
mov    (%rbx),%rbx
add    $0x1,%rbp
cmp    %r12,%rbx
je     19d <gl_linked_sortedlist_indexof+0x3d>
mov    0x10(%rbx),%rdi
mov    %r13,%rsi
callq  *%r14
cmp    $0x0,%eax
jle    180 <gl_linked_sortedlist_indexof+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffffffffffff,%rax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
         const void *elt)
{
  gl_list_node_t node;
  size_t index;
  for (node = list->root.next, index = 0;
       node != &list->root;
       node = node->next, index++)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
 break;
      if (cmp == 0)
 return index;
    }
  return (size_t)(-1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 3
8 6
9 3
10 6
11 6
12 6
13 6
14 6
15 13
16 8
17 8
18 6
19 6
20 10
21 10
22 10
23 11
24 11
25 17
26 17
27 17
28 17
29 16
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
push   %r13
lea    -0x1(%rsi),%rdx
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x30(%rdi),%rbp
cmp    %rdx,%rbp
jbe    23f <gl_array_remove_node+0x6f>
mov    0x18(%rdi),%rax
mov    0x28(%rdi),%r13
test   %rax,%rax
je     201 <gl_array_remove_node+0x31>
mov    0x0(%r13,%rdx,8),%rdi
callq  *%rax
cmp    %r12,%rbp
jbe    227 <gl_array_remove_node+0x57>
lea    0x0(,%r12,8),%rax
mov    %rbp,%rdx
sub    %r12,%rdx
lea    0x0(%r13,%rax,1),%rsi
lea    -0x8(%r13,%rax,1),%rdi
shl    $0x3,%rdx
callq  227 <gl_array_remove_node+0x57>
sub    $0x1,%rbp
mov    $0x1,%eax
mov    %rbp,0x30(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  244 <gl_array_remove_node+0x74>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_remove_node (gl_list_t list, gl_list_node_t node)
{
  size_t count = list->count;
  unsigned long index = ((unsigned long)(node) - 1);
  size_t position;
  const void **elements;
  size_t i;
  if (!(index < count))
    abort ();
  position = index;
  elements = list->elements;
  if (list->base.dispose_fn != ((void *)0))
    list->base.dispose_fn (elements[position]);
  for (i = position + 1; i < count; i++)
    elements[i - 1] = elements[i];
  list->count = count - 1;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 8
11 8
12 12
13 11
14 12
15 12
16 13
17 13
18 14
19 14
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 16
28 18
29 16
30 18
31 18
32 18
33 18
34 18
35 18
36 9
37 9
<<<sep_out_sample>>>
lea    0x1(%rdi,%rdi,1),%eax
sub    $0x38,%rsp
movapd %xmm0,%xmm7
sqrtsd %xmm0,%xmm0
cvtsi2sd %eax,%xmm5
ucomisd %xmm0,%xmm0
movapd %xmm5,%xmm2
mulsd  %xmm5,%xmm2
movapd %xmm2,%xmm6
mulsd  %xmm2,%xmm6
movapd %xmm6,%xmm1
mulsd  %xmm2,%xmm1
jp     1a2 <asymptotic+0x1a2>
movapd %xmm0,%xmm3
mulsd  0x0(%rip),%xmm7        # 42 <asymptotic+0x42>
movsd  0x0(%rip),%xmm4        # 4a <asymptotic+0x4a>
addsd  %xmm0,%xmm3
movsd  0x0(%rip),%xmm11        # 57 <asymptotic+0x57>
movsd  0x0(%rip),%xmm12        # 60 <asymptotic+0x60>
mulsd  %xmm2,%xmm12
mulsd  %xmm3,%xmm4
movapd %xmm7,%xmm0
mulsd  %xmm5,%xmm3
movapd %xmm5,%xmm7
mulsd  %xmm11,%xmm7
movapd %xmm4,%xmm10
addsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 8b <asymptotic+0x8b>
mulsd  %xmm4,%xmm10
addsd  %xmm2,%xmm3
movapd %xmm10,%xmm9
mulsd  0x0(%rip),%xmm3        # a1 <asymptotic+0xa1>
mulsd  %xmm4,%xmm9
movapd %xmm9,%xmm8
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # b7 <asymptotic+0xb7>
mulsd  %xmm4,%xmm8
addsd  %xmm2,%xmm3
mulsd  %xmm7,%xmm3
divsd  %xmm4,%xmm3
mulsd  %xmm8,%xmm4
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # d9 <asymptotic+0xd9>
mulsd  %xmm6,%xmm3
addsd  %xmm12,%xmm3
addsd  0x0(%rip),%xmm3        # ea <asymptotic+0xea>
mulsd  %xmm11,%xmm3
divsd  %xmm10,%xmm3
movsd  0x0(%rip),%xmm10        # fd <asymptotic+0xfd>
mulsd  %xmm2,%xmm10
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 10e <asymptotic+0x10e>
mulsd  %xmm6,%xmm3
addsd  %xmm10,%xmm3
addsd  0x0(%rip),%xmm3        # 11f <asymptotic+0x11f>
mulsd  %xmm7,%xmm3
movsd  0x0(%rip),%xmm7        # 12b <asymptotic+0x12b>
mulsd  %xmm6,%xmm7
divsd  %xmm9,%xmm3
mulsd  0x0(%rip),%xmm6        # 13c <asymptotic+0x13c>
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 148 <asymptotic+0x148>
mulsd  %xmm1,%xmm3
mulsd  0x0(%rip),%xmm1        # 154 <asymptotic+0x154>
addsd  %xmm7,%xmm3
movsd  0x0(%rip),%xmm7        # 160 <asymptotic+0x160>
mulsd  %xmm2,%xmm7
mulsd  0x0(%rip),%xmm2        # 16c <asymptotic+0x16c>
addsd  %xmm6,%xmm1
addsd  %xmm7,%xmm3
addsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm3        # 180 <asymptotic+0x180>
addsd  0x0(%rip),%xmm1        # 188 <asymptotic+0x188>
add    $0x38,%rsp
divsd  %xmm8,%xmm3
mulsd  %xmm5,%xmm1
subsd  %xmm3,%xmm0
divsd  %xmm4,%xmm1
subsd  %xmm1,%xmm0
retq   
movapd %xmm7,%xmm0
movsd  %xmm1,0x28(%rsp)
movsd  %xmm6,0x20(%rsp)
movsd  %xmm2,0x18(%rsp)
movsd  %xmm5,0x10(%rsp)
movsd  %xmm7,0x8(%rsp)
callq  1c9 <asymptotic+0x1c9>
movsd  0x28(%rsp),%xmm1
movsd  0x20(%rsp),%xmm6
movsd  0x18(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
movsd  0x8(%rsp),%xmm7
jmpq   36 <asymptotic+0x36>
nopl   0x0(%rax)
<<<sep_in_sample>>>
asymptotic(int order, double qq)
{
  double asymp;
  double nn, n2, n4, n6;
  double hh, ah, ah2, ah3, ah4, ah5;
  nn = 2*order + 1;
  n2 = nn*nn;
  n4 = n2*n2;
  n6 = n4*n2;
  hh = 2*sqrt(qq);
  ah = 16*hh;
  ah2 = ah*ah;
  ah3 = ah2*ah;
  ah4 = ah3*ah;
  ah5 = ah4*ah;
  asymp = -2*qq + nn*hh - 0.125*(n2 + 1);
  asymp -= 0.25*nn*( n2 + 3)/ah;
  asymp -= 0.25* ( 5*n4 + 34*n2 + 9)/ah2;
  asymp -= 0.25*nn*( 33*n4 + 410*n2 + 405)/ah3;
  asymp -= ( 63*n6 + 1260*n4 + 2943*n2 + 486)/ah4;
  asymp -= nn*(527*n6 + 15617*n4 + 69001*n2 + 41607)/ah5;
  return asymp;
}
<<<sep_in_sample>>>
1 6
2 2
3 2
4 10
5 6
6 10
7 7
8 7
9 8
10 8
11 9
12 9
13 10
14 10
15 16
16 11
17 10
18 17
19 18
20 18
21 11
22 16
23 16
24 17
25 17
26 12
27 16
28 16
29 12
30 16
31 13
32 16
33 13
34 14
35 16
36 17
37 14
38 17
39 17
40 17
41 15
42 17
43 18
44 18
45 18
46 18
47 18
48 18
49 19
50 19
51 18
52 19
53 19
54 19
55 19
56 19
57 20
58 20
59 19
60 21
61 19
62 20
63 20
64 21
65 20
66 20
67 20
68 21
69 21
70 20
71 21
72 20
73 21
74 23
75 20
76 21
77 20
78 21
79 21
80 23
81 10
82 10
83 10
84 10
85 10
86 10
87 10
88 10
89 10
90 10
91 10
92 10
93 10
94 10
<<<sep_out_sample>>>
sub    $0x38,%rsp
lea    0x10(%rsp),%rsi
mov    %rsp,%rdx
movl   $0x10,(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
callq  28 <isnetconn+0x28>
test   %eax,%eax
mov    $0x1,%edx
js     50 <isnetconn+0x50>
mov    0x28(%rsp),%rcx
xor    %fs:0x28,%rcx
mov    %edx,%eax
jne    72 <isnetconn+0x72>
add    $0x38,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  55 <isnetconn+0x55>
mov    (%rax),%eax
xor    %edx,%edx
cmp    $0x58,%eax
je     31 <isnetconn+0x31>
cmp    $0x6b,%eax
je     31 <isnetconn+0x31>
cmp    $0x16,%eax
je     31 <isnetconn+0x31>
xor    %edx,%edx
cmp    $0x9,%eax
setne  %dl
jmp    31 <isnetconn+0x31>
callq  77 <isnetconn+0x77>
<<<sep_in_sample>>>
isnetconn (fd)
     int fd;
{
  int rv;
  socklen_t l;
  struct sockaddr sa;
  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  return ((rv < 0 && ((*__errno_location ()) == 88 || (*__errno_location ()) == 107 || (*__errno_location ()) == 22 || (*__errno_location ()) == 9)) ? 0 : 1);
}
<<<sep_in_sample>>>
1 3
2 8
3 8
4 7
5 3
6 3
7 3
8 8
9 9
10 9
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 10
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    %rdi,%rax
je     5c0 <osip_cseq_match+0xe0>
test   %rsi,%rsi
mov    %rsi,%rdx
je     5c0 <osip_cseq_match+0xe0>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     5c0 <osip_cseq_match+0xe0>
mov    0x8(%rsi),%rsi
test   %rsi,%rsi
je     5c0 <osip_cseq_match+0xe0>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rax),%rbp
test   %rbp,%rbp
je     5e0 <osip_cseq_match+0x100>
mov    (%rdx),%rbx
test   %rbx,%rbx
je     5e0 <osip_cseq_match+0x100>
callq  535 <osip_cseq_match+0x55>
test   %eax,%eax
jne    5d0 <osip_cseq_match+0xf0>
mov    $0x0,%eax
mov    $0x7,%ecx
mov    %rbx,%rsi
mov    %rax,%rdi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     580 <osip_cseq_match+0xa0>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     580 <osip_cseq_match+0xa0>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  56d <osip_cseq_match+0x8d>
test   %eax,%eax
setne  %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rax,%rdi
mov    $0x7,%ecx
mov    %rbp,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
je     577 <osip_cseq_match+0x97>
mov    %rbp,%rsi
mov    $0x0,%edi
mov    $0x4,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
pop    %rbx
neg    %eax
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0xffffffff,%eax
jmp    577 <osip_cseq_match+0x97>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
jmp    577 <osip_cseq_match+0x97>
<<<sep_in_sample>>>
osip_cseq_match (osip_cseq_t * cseq1, osip_cseq_t * cseq2)
{
  if (cseq1 == ((void *)0) || cseq2 == ((void *)0))
    return -2;
  if (cseq1->number == ((void *)0) || cseq2->number == ((void *)0) || cseq1->method == ((void *)0) || cseq2->method == ((void *)0))
    return -2;
  if (0 == strcmp (cseq1->number, cseq2->number)) {
    if (0 == strcmp (cseq2->method, "INVITE")
        || 0 == strcmp (cseq2->method, "ACK")) {
      if (0 == strcmp (cseq1->method, "INVITE") || 0 == strcmp (cseq1->method, "ACK"))
        return 0;
    }
    else {
      if (0 == strcmp (cseq1->method, cseq2->method))
        return 0;
    }
  }
  return -1;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 2
14 2
15 2
16 5
17 5
18 5
19 5
20 5
21 5
22 7
23 7
24 7
25 8
26 8
27 8
28 8
29 8
30 8
31 9
32 9
33 9
34 9
35 9
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 19
44 19
45 19
46 19
47 19
48 10
49 10
50 10
51 10
52 10
53 10
54 10
55 10
56 10
57 10
58 10
59 10
60 10
61 10
62 10
63 19
64 10
65 19
66 10
67 19
68 19
69 19
70 4
71 19
72 19
73 18
74 18
75 18
76 4
77 4
<<<sep_out_sample>>>
movslq (%rdi),%rdx
mov    0x8(%rdi),%rax
movsd  (%rax,%rdx,8),%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_histogram_max (const gsl_histogram * h)
{
  const int n = h->n;
  return h->range[n];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
address_finish (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9e6 <gsl_vector_long_ptr+0x6>
test   %eax,%eax
je     9ef <gsl_vector_long_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    a00 <gsl_vector_long_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a1d <gsl_vector_long_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_ptr (gsl_vector_long * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (long *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 2
12 5
13 5
14 5
15 5
16 5
17 5
18 8
19 8
20 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  39 <nettle_aes_set_decrypt_key+0x9>
mov    %rbx,%rsi
mov    %rbx,%rdi
pop    %rbx
jmpq   45 <nettle_aes_set_decrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes_set_decrypt_key(struct aes_ctx *ctx,
      size_t keysize, const uint8_t *key)
{
  nettle_aes_set_encrypt_key(ctx, keysize, key);
  nettle_aes_invert_key(ctx, ctx);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 5
<<<sep_out_sample>>>
movzbl 0x19(%rdx),%eax
mov    %rcx,%r10
mov    %eax,%ecx
and    $0xf,%ecx
cmp    $0xc,%cl
ja     35 <CDB___db_pgin+0x35>
mov    $0x1,%r8d
shl    %cl,%r8
test   $0x12f8,%r8d
jne    48 <CDB___db_pgin+0x48>
test   $0x105,%r8d
jne    60 <CDB___db_pgin+0x60>
test   $0xc00,%r8d
jne    50 <CDB___db_pgin+0x50>
movzbl %al,%edx
mov    $0x0,%esi
jmpq   42 <CDB___db_pgin+0x42>
nopw   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   50 <CDB___db_pgin+0x50>
mov    %r10,%rcx
jmpq   58 <CDB___db_pgin+0x58>
nopl   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   68 <CDB___db_pgin+0x68>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_pgin(dbenv, pg, pp, cookie)
 DB_ENV *dbenv;
 db_pgno_t pg;
 void *pp;
 DBT *cookie;
{
 switch (((((PAGE *)pp)->type) & 0x0f)) {
 case 2:
 case 8:
 case 0:
  return (CDB___ham_pgin(dbenv, pg, pp, cookie));
 case 9:
 case 3:
 case 4:
 case 5:
 case 12:
 case 6:
 case 7:
  return (CDB___bam_pgin(dbenv, pg, pp, cookie));
 case 10:
 case 11:
  return (CDB___qam_pgin_out(dbenv, pg, pp, cookie));
 default:
  break;
 }
 return (CDB___db_unknown_type(dbenv, "CDB___db_pgin", ((PAGE *)pp)->type));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 26
16 26
17 26
18 26
19 19
20 19
21 22
22 22
23 22
24 11
25 11
26 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdx
test   %rdx,%rdx
je     c8 <faced_string_self_print+0x38>
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  b3 <faced_string_self_print+0x23>
mov    0xc(%rbx),%rdi
add    $0x8,%rsp
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   c5 <faced_string_self_print+0x35>
nopl   (%rax)
mov    0x8(%rdi),%edx
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  da <faced_string_self_print+0x4a>
jmp    b3 <faced_string_self_print+0x23>
nopl   0x0(%rax)
<<<sep_in_sample>>>
faced_string_self_print (struct faced_string * faced_string, FILE * stream)
{
  if (faced_string->string)
    fprintf (stream, "\"%s\": ", faced_string->string);
  else
    fprintf (stream, "\\%d: ", faced_string->reg_ref);
  fface_self_print (faced_string->face, stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 7
14 8
15 7
16 8
17 8
18 7
19 7
20 6
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
mov    %edi,%eax
retq   
<<<sep_in_sample>>>
CDB___lock_locker_hash(locker)
 u_int32_t locker;
{
 return (locker);
}
<<<sep_in_sample>>>
1 3
2 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # f17 <meta1get_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1get_in (void)
{
        return meta1in;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x20(%rdi)
je     556 <hash_get_first+0x36>
mov    (%rdi),%rdx
mov    0x8(%rdi),%rcx
cmp    %rcx,%rdx
jb     549 <hash_get_first+0x29>
jmp    55d <hash_get_first+0x3d>
nopl   0x0(%rax)
add    $0x10,%rdx
cmp    %rcx,%rdx
jae    55d <hash_get_first+0x3d>
mov    (%rdx),%rax
test   %rax,%rax
je     540 <hash_get_first+0x20>
add    $0x8,%rsp
retq   
xor    %eax,%eax
add    $0x8,%rsp
retq   
callq  562 <hash_get_first+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_first (const Hash_table *table)
{
  struct hash_entry const *bucket;
  if (table->n_entries == 0)
    return ((void *)0);
  for (bucket = table->bucket; ; bucket++)
    if (! (bucket < table->bucket_limit))
      abort ();
    else if (bucket->data)
      return bucket->data;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 7
6 7
7 7
8 7
9 7
10 6
11 7
12 7
13 9
14 9
15 9
16 11
17 11
18 5
19 11
20 11
21 8
22 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %esi,%edx
sub    $0x10,%rsp
mov    0x0(%rip),%rdi        # 5c1 <lookup_dir_entry+0x11>
test   %rdi,%rdi
je     5d8 <lookup_dir_entry+0x28>
add    $0x10,%rsp
mov    %rbx,%rsi
pop    %rbx
jmpq   5d3 <lookup_dir_entry+0x23>
nopl   0x0(%rax,%rax,1)
mov    %esi,0xc(%rsp)
callq  0 <build_dir_node>
mov    0xc(%rsp),%edx
mov    %rax,0x0(%rip)        # 5ec <lookup_dir_entry+0x3c>
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   5fc <lookup_dir_entry+0x4c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
lookup_dir_entry (char *label, int sloppy)
{
  REFERENCE *entry;
  if (!dir_node)
    dir_node = build_dir_node ();
  entry = info_get_menu_entry_by_label (dir_node, label, sloppy);
  return entry;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 8
9 6
10 8
11 6
12 6
13 6
14 5
15 5
16 5
17 8
18 6
19 5
20 8
21 6
22 6
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <file_hash_2+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <file_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
file_hash_2 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct file const *) key)->hname)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     ce <font_info_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    b0 <font_info_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
font_info_hash_1 (struct font_info *font_info)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((font_info->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  79 <filter_flush+0x9>
mov    (%rax),%rdi
add    $0x8,%rsp
jmpq   85 <filter_flush+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filter_flush (mu_stream_t stream)
{
  mu_filter_t filter = mu_stream_get_owner(stream);
  return mu_stream_flush (filter->stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 4
6 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yywrap ()
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
goto_dir_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x0,%eax
movb   $0x0,0x0(%rip)        # f <flags_to_string+0xf>
cmovne %rsi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
flags_to_string (u_int flags, char *def)
{
  static char string[128];
  char *prefix;
  string[0] = '\0';
  prefix = ((void *)0);
  return (prefix == ((void *)0) && def != ((void *)0) ? def : string);
}
<<<sep_in_sample>>>
1 7
2 7
3 5
4 7
5 8
6 8
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%rdi        # 34c <gsl_odeiv2_control_standard_new+0xc>
movsd  %xmm0,0x18(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  368 <gsl_odeiv2_control_standard_new+0x28>
movsd  (%rsp),%xmm3
mov    %rax,%rdi
movsd  0x8(%rsp),%xmm2
mov    %rax,%rbx
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm0
callq  38a <gsl_odeiv2_control_standard_new+0x4a>
test   %eax,%eax
mov    %rbx,%rdi
jne    3a0 <gsl_odeiv2_control_standard_new+0x60>
add    $0x20,%rsp
mov    %rdi,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,(%rsp)
callq  3a8 <gsl_odeiv2_control_standard_new+0x68>
mov    (%rsp),%eax
mov    $0x0,%edi
mov    $0xc7,%edx
mov    $0x0,%esi
mov    %eax,%ecx
callq  3c1 <gsl_odeiv2_control_standard_new+0x81>
xor    %edi,%edi
jmp    391 <gsl_odeiv2_control_standard_new+0x51>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv2_control_standard_new (double eps_abs, double eps_rel,
                                 double a_y, double a_dydt)
{
  gsl_odeiv2_control *c =
    gsl_odeiv2_control_alloc (gsl_odeiv2_control_standard);
  int status = gsl_odeiv2_control_init (c, eps_abs, eps_rel, a_y, a_dydt);
  if (status != GSL_SUCCESS)
    {
      gsl_odeiv2_control_free (c);
      do { gsl_error ("error trying to initialize control", "cstd.c", 199, status) ; return 0 ; } while (0);
    }
  return c;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 3
7 3
8 4
9 6
10 6
11 6
12 4
13 6
14 6
15 6
16 7
17 12
18 7
19 13
20 13
21 13
22 13
23 13
24 13
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 29c7 <java_set_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_set_out (FILE * out_str )
{
        java_out = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   d7a <setup_history_ignore+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setup_history_ignore (varname)
     char *varname;
{
  setup_ignore_patterns (&histignore);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1d70 <gsl_vector_uchar_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d8f <gsl_vector_uchar_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_uchar_const_view_array (const unsigned char * base, size_t n)
{
  _gsl_vector_uchar_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_uchar v = {0, 0, 0, 0, 0};
    v.data = (unsigned char *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
cmp    $0x1,%rdx
mov    %rcx,(%r8)
je     42 <__gmpn_sec_add_1+0x32>
lea    -0x8(,%rdx,8),%rdx
lea    0x8(%r8),%rdi
xor    %esi,%esi
callq  42 <__gmpn_sec_add_1+0x32>
add    $0x8,%rsp
mov    %rbx,%rcx
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %r12,%rdi
mov    %r13,%rsi
pop    %r12
pop    %r13
jmpq   5d <__gmpn_sec_add_1+0x4d>
<<<sep_in_sample>>>
__gmpn_sec_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b, mp_ptr scratch)
{
  scratch[0] = b;
  do { do {} while (0); if ((n-1) != 0) do { mp_ptr __dst = (scratch + 1); mp_size_t __n = (n-1); do {} while (0); do *__dst++ = (((mp_limb_t) 0L)); while (--__n); } while (0); } while (0);
  return __gmpn_add_n (rp, ap, scratch, n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 6
18 5
19 5
20 6
21 6
22 5
23 5
24 6
25 6
26 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     250 <osip_content_length_to_str+0x20>
push   %rbx
mov    (%rdi),%rdi
mov    %rsi,%rbx
callq  241 <osip_content_length_to_str+0x11>
cmp    $0x1,%rax
mov    %rax,(%rbx)
sbb    %eax,%eax
and    $0xfffffffc,%eax
pop    %rbx
retq   
nop
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_content_length_to_str (const osip_content_length_t * cl, char **dest)
{
  if (cl == ((void *)0))
    return -2;
  *dest = osip_strdup (cl->value);
  if (*dest == ((void *)0))
    return -4;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 5
5 5
6 5
7 7
8 5
9 7
10 7
11 9
12 9
13 9
14 4
15 4
16 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0xfffffffe,0x8(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
isNotFound(direntry_t *entry)
{
 return entry->entry == -2;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xor    %eax,%eax
test   %esi,%esi
js     1270 <ap_code+0x20>
cmp    0x10(%rdi),%esi
jge    1270 <ap_code+0x20>
movslq %esi,%rsi
shl    $0x4,%rsi
add    (%rdi),%rsi
mov    (%rsi),%eax
retq   
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ap_code( const struct Arg_parser * const ap, const int i )
  {
  if( i >= 0 && i < ap_arguments( ap ) ) return ap->data[i].code;
  else return 0;
  }
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
<<<sep_out_sample>>>
add    $0x28,%rdi
jmpq   9 <nettle_ccm_aes256_set_key+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key)
{
  nettle_aes256_set_encrypt_key(&ctx->cipher, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rdi,%r9
mov    $0x40,%r10d
test   $0x1,%r9b
jne    78 <ring_init+0x78>
test   $0x2,%dil
jne    90 <ring_init+0x90>
test   $0x4,%dil
jne    b0 <ring_init+0xb0>
mov    %r10d,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%r10b
rep stos %rax,%es:(%rdi)
je     3a <ring_init+0x3a>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r10b
je     4a <ring_init+0x4a>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%r10d
je     53 <ring_init+0x53>
movb   $0x0,(%rdi)
mov    %edx,0x28(%r9)
movslq %edx,%rdx
mov    %rsi,0x10(%r9)
mov    %rsi,(%r9)
mov    %rsi,0x8(%r9)
add    %rdx,%rsi
mov    %rsi,0x18(%r9)
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
lea    0x1(%r9),%rdi
movb   $0x0,(%r9)
mov    $0x3f,%r10b
test   $0x2,%dil
je     15 <ring_init+0x15>
nopl   0x0(%rax)
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%r10d
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     1f <ring_init+0x1f>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%r10d
add    $0x4,%rdi
jmpq   1f <ring_init+0x1f>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ring_init (Ring * ring, unsigned char *buffer, int count)
{
  memset ((char *) ring, 0, sizeof *ring);
  ring->size = count;
  ring->supply = ring->consume = ring->bottom = buffer;
  ring->top = ring->bottom + ring->size;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 4
26 6
27 5
28 5
29 5
30 6
31 6
32 8
33 8
34 8
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
44 3
45 3
46 3
47 3
48 3
49 3
50 3
51 3
52 3
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_set_comment (osip_via_t * via, char *comment)
{
  via->comment = comment;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  49e <killed+0xe>
mov    0x0(%rip),%edi        # 4a4 <killed+0x14>
mov    $0x2,%esi
callq  4ae <killed+0x1e>
mov    0x0(%rip),%edi        # 4b4 <killed+0x24>
callq  4b9 <killed+0x29>
callq  4be <killed+0x2e>
xor    %edi,%edi
callq  4c5 <killed+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
killed(int i)
{
 printf("\ninterrupt\n");
 shutdown(listen_socket, 2);
 close(listen_socket);
 dis_close();
 exit(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 6
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
test   %r9,%r9
movzwl (%rdi),%ecx
je     2212 <gsl_vector_short_max_index+0x42>
add    %r10,%r10
xor    %edx,%edx
xor    %eax,%eax
jmp    21f3 <gsl_vector_short_max_index+0x23>
nopl   0x0(%rax)
mov    %r8d,%ecx
movzwl (%rdi),%esi
mov    %ecx,%r8d
cmp    %cx,%si
cmovge %esi,%r8d
cmovg  %rdx,%rax
add    $0x1,%rdx
add    %r10,%rdi
cmp    %r9,%rdx
jne    21f0 <gsl_vector_short_max_index+0x20>
repz retq 
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_max_index (const gsl_vector_short * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  short max = v->data[0 * stride];
  size_t imax = 0;
  size_t i;
  for (i = 0; i < N; i++)
    {
      short x = v->data[i*stride];
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  return imax;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 8
5 5
6 8
7 8
8 8
9 6
10 6
11 6
12 8
13 10
14 10
15 10
16 10
17 10
18 8
19 8
20 8
21 8
22 18
23 6
24 18
25 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmmalloca+0x9>
test   %rax,%rax
je     13 <xmmalloca+0x13>
add    $0x8,%rsp
retq   
callq  18 <xmmalloca+0x18>
<<<sep_in_sample>>>
xmmalloca (size_t n)
{
  void *p;
  p = mmalloca (n);
  if (p == ((void *)0))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 8
6 8
7 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     6b <dbg_printf+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    0x0(%rip),%edx        # 71 <dbg_printf+0x61>
test   %edx,%edx
je     7f <dbg_printf+0x6f>
mov    0x0(%rip),%eax        # 7b <dbg_printf+0x6b>
test   %eax,%eax
jne    90 <dbg_printf+0x80>
add    $0xd8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
lea    0xe0(%rsp),%rax
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # a2 <dbg_printf+0x92>
lea    0x8(%rsp),%rdx
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  cb <dbg_printf+0xbb>
mov    0x0(%rip),%rdi        # d2 <dbg_printf+0xc2>
callq  d7 <dbg_printf+0xc7>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
dbg_printf (const char *fmt, ...)
{
  va_list ap;
  if (!(NoDetach && dbg_output))
    return;
  __builtin_va_start(ap,fmt);
  vfprintf (stdout, fmt, ap);
  __builtin_va_end(ap);
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 4
19 4
20 4
21 4
22 4
23 10
24 10
25 10
26 6
27 7
28 7
29 7
30 6
31 6
32 6
33 6
34 6
35 7
36 9
37 9
38 10
39 10
40 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x0,%edi
callq  30a <yy_grecserror+0x1a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecserror(char *s)
{
  grecs_error (&grecs_current_locus, 0, "%s", s);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     68 <mu_pop3_disconnect+0x68>
movl   $0x0,0x60(%rdi)
movl   $0x0,0x40(%rdi)
xor    %esi,%esi
mov    (%rdi),%rdi
mov    0x18(%rbx),%rdx
callq  25 <mu_pop3_disconnect+0x25>
mov    (%rbx),%rax
mov    0x20(%rbx),%rdi
xor    %esi,%esi
mov    0x38(%rbx),%rdx
mov    %rax,0x8(%rbx)
callq  3b <mu_pop3_disconnect+0x3b>
mov    0x48(%rbx),%rdi
mov    0x20(%rbx),%rax
test   %rdi,%rdi
mov    %rax,0x28(%rbx)
je     59 <mu_pop3_disconnect+0x59>
callq  51 <mu_pop3_disconnect+0x51>
movq   $0x0,0x48(%rbx)
mov    0x68(%rbx),%rdi
pop    %rbx
jmpq   63 <mu_pop3_disconnect+0x63>
nopl   0x0(%rax,%rax,1)
mov    $0x16,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_pop3_disconnect (mu_pop3_t pop3)
{
  if (pop3 == ((void *)0))
    return 22;
  pop3->state = MU_POP3_NO_STATE;
  pop3->acknowledge = 0;
  memset (pop3->io.buf, '\0', pop3->io.len);
  pop3->io.ptr = pop3->io.buf;
  memset (pop3->ack.buf, '\0', pop3->ack.len);
  pop3->ack.ptr = pop3->ack.buf;
  if (pop3->timestamp)
    {
      free (pop3->timestamp);
      pop3->timestamp = ((void *)0);
    }
  return mu_stream_close (pop3->carrier);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 6
7 7
8 7
9 7
10 7
11 8
12 9
13 9
14 9
15 8
16 9
17 11
18 10
19 11
20 10
21 11
22 13
23 14
24 16
25 17
26 16
27 16
28 17
29 17
30 17
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  70c <gsl_sf_lambert_W0+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    720 <gsl_sf_lambert_W0+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xe1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  736 <gsl_sf_lambert_W0+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_lambert_W0(double x)
{
  gsl_sf_result result; int status = gsl_sf_lambert_W0_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_lambert_W0_e(x, &result)", "lambert.c", 225, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
movzbl 0x0(%rip),%eax        # 5d47 <pch_rename+0x7>
movzbl 0x0(%rip),%edx        # 5d4e <pch_rename+0xe>
test   %al,%al
cmovne %edx,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pch_rename (void)
{
  return p_rename[OLD] && p_rename[NEW];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x30,%rsp
mov    0x0(%rip),%rdi        # c7 <defevt+0x17>
movl   $0x1,(%rsp)
test   %rdi,%rdi
je     118 <defevt+0x68>
lea    0x10(%rsp),%rsi
mov    %rsp,%rdx
mov    %rbx,0x18(%rsp)
callq  e5 <defevt+0x35>
mov    (%rsp),%edx
test   %edx,%edx
je     108 <defevt+0x58>
mov    (%r12),%rdx
mov    %ebp,0x18(%rax)
mov    %rdx,0x10(%rax)
add    $0x30,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x18(%rax),%eax
add    $0x30,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
xor    %r8d,%r8d
mov    $0x0,%r9d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x20,%dil
callq  138 <defevt+0x88>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 142 <defevt+0x92>
je     149 <defevt+0x99>
mov    %rax,%rdi
jmp    d3 <defevt+0x23>
mov    $0x2,%edi
mov    $0x0,%esi
callq  158 <defevt+0xa8>
mov    $0x1,%edi
callq  162 <defevt+0xb2>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defevt(const char *name, event_mask *mask, int line)
{
 struct symevt key, *evp;
 int install = 1;
 if (!evtab) {
  evtab = hashtab_create(sizeof(struct symevt),
           symevt_hash, symevt_cmp,
           symevt_copy,
           ((void *)0), symevt_free);
  if (!evtab) {
   diag(2, "not enough memory");
   exit(1);
  }
 }
 key.name = (char *) name;
 evp = hashtab_lookup_or_install(evtab, &key, &install);
 if (!install)
  return evp->line;
 evp->mask = *mask;
 evp->line = line;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 4
10 5
11 5
12 16
13 16
14 15
15 16
16 17
17 17
18 17
19 19
20 20
21 19
22 22
23 21
24 22
25 22
26 22
27 22
28 22
29 18
30 22
31 22
32 22
33 22
34 22
35 22
36 6
37 6
38 6
39 6
40 6
41 6
42 6
43 10
44 6
45 10
46 10
47 10
48 11
49 11
50 11
51 12
52 12
53 12
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     90 <dep_hash_2+0x40>
sub    $0x1,%rax
movzbl 0x1(%rax),%edx
lea    0x1(%rax),%rdi
xor    %eax,%eax
test   %dl,%dl
je     9d <dep_hash_2+0x4d>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    70 <dep_hash_2+0x20>
repz retq 
xchg   %ax,%ax
mov    0x10(%rdi),%rax
mov    (%rax),%rax
sub    $0x1,%rax
jmp    5d <dep_hash_2+0xd>
repz retq 
nop
<<<sep_in_sample>>>
dep_hash_2 (const void *key)
{
  const struct dep *d = key;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((d)->name ? (d)->name : (d)->file->name))) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 4
<<<sep_out_sample>>>
mov    %rdx,0x10(%rsi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_node_nx_set_value (gl_list_t list, gl_list_node_t node,
                             const void *elt)
{
  node->value = elt;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
movzbl (%rdi),%eax
cmp    $0x3a,%al
je     1b9d <colon+0x2d>
test   %al,%al
je     1b9d <colon+0x2d>
cmp    $0x2f,%al
jne    1b92 <colon+0x22>
nop
jmp    1b9d <colon+0x2d>
nopw   0x0(%rax,%rax,1)
cmp    $0x3a,%dl
je     1ba0 <colon+0x30>
cmp    $0x2f,%dl
je     1b9d <colon+0x2d>
add    $0x1,%rdi
movzbl (%rdi),%edx
test   %dl,%dl
jne    1b88 <colon+0x18>
xor    %eax,%eax
retq   
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
colon (char *cp)
{
  if (*cp == ':')
    return (0);
  for (; *cp; ++cp)
    {
      if (*cp == ':')
 return (cp);
      if (*cp == '/')
 return (0);
    }
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 9
7 9
8 9
9 9
10 9
11 7
12 7
13 9
14 9
15 5
16 5
17 5
18 5
19 4
20 13
21 5
22 5
23 5
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rsi,%rdi
mov    $0x100,%esi
jmpq   60 <openssl_arcfour_crypt>
<<<sep_in_sample>>>
openssl_aes256_set_encrypt_key(void *ctx, const uint8_t *key)
{
  AES_set_encrypt_key(key, 256, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2ec7 <cpp_get_in+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_get_in (void)
{
        return cpp_in;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %r8d,%r10d
je     d50 <csv_write2+0xc0>
test   %rdi,%rdi
je     d40 <csv_write2+0xb0>
test   %rsi,%rsi
je     cb1 <csv_write2+0x21>
mov    %r8b,(%rdi)
add    $0x1,%rdi
test   %rcx,%rcx
je     d53 <csv_write2+0xc3>
add    %rdx,%rcx
mov    $0x1,%r9d
jmp    cec <csv_write2+0x5c>
nopl   (%rax)
cmp    %rsi,%r9
jae    cd7 <csv_write2+0x47>
movzbl (%rdx),%eax
add    $0x1,%rdi
mov    %al,-0x1(%rdi)
xor    %eax,%eax
cmp    $0xffffffffffffffff,%r9
setne  %al
add    $0x1,%rdx
add    %rax,%r9
cmp    %rcx,%rdx
je     d20 <csv_write2+0x90>
cmp    %r10b,(%rdx)
jne    cc8 <csv_write2+0x38>
cmp    %rsi,%r9
jae    d08 <csv_write2+0x78>
mov    %r10b,(%rdi)
add    $0x1,%rdi
add    $0x1,%r9
jmp    cc8 <csv_write2+0x38>
nopl   0x0(%rax,%rax,1)
cmp    $0xffffffffffffffff,%r9
jne    cfd <csv_write2+0x6d>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    cec <csv_write2+0x5c>
nopw   0x0(%rax,%rax,1)
cmp    %rsi,%r9
jae    d28 <csv_write2+0x98>
mov    %r8b,(%rdi)
mov    $0xffffffffffffffff,%rax
lea    0x1(%r9),%rdx
cmp    %rax,%r9
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
xor    %esi,%esi
jmpq   cb1 <csv_write2+0x21>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
mov    $0x1,%r9d
jmp    d20 <csv_write2+0x90>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_write2 (void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote)
{
  unsigned char *cdest = dest;
  const unsigned char *csrc = src;
  size_t chars = 0;
  if (src == ((void *)0))
    return 0;
  if (dest == ((void *)0))
    dest_size = 0;
  if (dest_size > 0)
    *cdest++ = quote;
  chars++;
  while (src_size) {
    if (*csrc == quote) {
      if (dest_size > chars)
        *cdest++ = quote;
      if (chars < ((size_t)-1)) chars++;
    }
    if (dest_size > chars)
      *cdest++ = *csrc;
    if (chars < ((size_t)-1)) chars++;
    src_size--;
    csrc++;
  }
  if (dest_size > chars)
    *cdest = quote;
  if (chars < ((size_t)-1)) chars++;
  return chars;
}
<<<sep_in_sample>>>
1 6
2 2
3 6
4 8
5 8
6 10
7 10
8 11
9 11
10 13
11 13
12 13
13 13
14 13
15 13
16 19
17 19
18 20
19 20
20 20
21 21
22 21
23 21
24 23
25 21
26 13
27 13
28 14
29 14
30 15
31 15
32 16
33 16
34 17
35 17
36 17
37 17
38 17
39 23
40 13
41 13
42 13
43 25
44 25
45 26
46 26
47 27
48 27
49 27
50 27
51 27
52 9
53 9
54 9
55 7
56 29
57 13
58 13
59 13
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <medium_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <medium_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
medium_hash_2 (void const *key)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((((const struct medium *)key)->name)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  5b1 <xdr_dis_euler_angles+0x11>
test   %eax,%eax
jne    5c0 <xdr_dis_euler_angles+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  5cc <xdr_dis_euler_angles+0x2c>
test   %eax,%eax
je     5b5 <xdr_dis_euler_angles+0x15>
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  5dc <xdr_dis_euler_angles+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_euler_angles(xdrs, objp)
	XDR *xdrs;
	dis_euler_angles *objp;
{
	if (!xdr_byte_float(xdrs, &objp->psi)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->theta)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->phi)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r15
mov    %r8,%r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
mov    %rdx,%r12
mov    %r12,%rdi
push   %rbx
mov    %rcx,%rbx
sub    $0x28,%rsp
mov    %rsi,-0x48(%rbp)
mov    0xc(%rcx),%esi
mov    %fs:0x28,%rax
mov    %rax,-0x38(%rbp)
xor    %eax,%eax
mov    %r9,-0x50(%rbp)
lea    0x1e(%rsi),%rax
shr    $0x4,%rax
shl    $0x4,%rax
sub    %rax,%rsp
lea    0xf(%rsp),%r13
and    $0xfffffffffffffff0,%r13
mov    %r13,%rdx
callq  *0x28(%rcx)
mov    0x8(%rbx),%edx
mov    %r14,%rsi
mov    %r12,%rdi
callq  206 <nettle_hmac_digest+0x66>
mov    0xc(%rbx),%esi
mov    %r13,%rdx
mov    %r12,%rdi
callq  *0x20(%rbx)
mov    -0x50(%rbp),%r9
mov    %r15,%rsi
mov    %r12,%rdi
mov    %r9,%rdx
callq  *0x28(%rbx)
mov    0x8(%rbx),%edx
mov    -0x48(%rbp),%rsi
mov    %r12,%rdi
callq  231 <nettle_hmac_digest+0x91>
mov    -0x38(%rbp),%rax
xor    %fs:0x28,%rax
jne    24f <nettle_hmac_digest+0xaf>
lea    -0x28(%rbp),%rsp
pop    %rbx
pop    %r12
pop    %r13
pop    %r14
pop    %r15
pop    %rbp
retq   
callq  254 <nettle_hmac_digest+0xb4>
<<<sep_in_sample>>>
nettle_hmac_digest(const void *outer, const void *inner, void *state,
     const struct nettle_hash *hash,
     size_t length, uint8_t *dst)
{
  uint8_t *digest;
  (digest = __builtin_alloca (sizeof (*digest) * (hash->digest_size)));
  hash->digest(state, hash->digest_size, digest);
  memcpy(state, outer, hash->context_size);
  hash->update(state, hash->digest_size, digest);
  hash->digest(state, length, dst);
  memcpy(state, inner, hash->context_size);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 7
11 4
12 4
13 4
14 4
15 6
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 11
42 11
43 11
44 11
45 12
46 12
47 12
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 12
56 12
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2376 <yyset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     25 <acl_errno_valid+0x25>
jle    20 <acl_errno_valid+0x20>
cmp    $0x26,%edi
je     25 <acl_errno_valid+0x25>
cmp    $0x5f,%edi
nop
je     25 <acl_errno_valid+0x25>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x10,%edi
jne    12 <acl_errno_valid+0x12>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 11
11 11
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xb0(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
         const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     720 <gsl_permute_vector_complex_float+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  715 <gsl_permute_vector_complex_float+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  731 <gsl_permute_vector_complex_float+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_complex_float (const gsl_permutation * p, gsl_vector_complex_float * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex_float (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rdx,%r9
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # c5 <nettle_gcm_aes128_decrypt+0x15>
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    %rsi,%r8
mov    %rax,%rsi
callq  de <nettle_gcm_aes128_decrypt+0x2e>
add    $0x18,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_aes128_decrypt(struct gcm_aes128_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes128_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_decrypt(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 3
9 4
10 4
11 5
12 5
13 5
<<<sep_out_sample>>>
movsd  0xa0(%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0xa8(%rdi),%xmm0
movsd  %xmm0,(%rdx)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_monte_vegas_runval (const gsl_monte_vegas_state * s, double * result, double * sigma)
{
  *result = s->result;
  *sigma = s->sigma;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <delegate_hash_1+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <delegate_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
delegate_hash_1 (void const *key)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((((const struct delegation *) key)->contract)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x9,%dil
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_parse822_is_htab (char c)
{
  return c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  681 <invocation_error+0x11>
mov    %rax,%rdi
mov    %rax,%r12
callq  68c <invocation_error+0x1c>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  697 <invocation_error+0x27>
lea    0x1(%rbp,%rax,1),%rdi
callq  6a1 <invocation_error+0x31>
mov    %rbx,%rdx
mov    %rax,%rbp
mov    %r12,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  6b4 <invocation_error+0x44>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
invocation_error(const char *name)
{
    char *message, *invoke_error = gettext("Error invoking \"%s\"");
    message = (char *)nmalloc((strlen(invoke_error) + strlen(name) + 1) * sizeof(char));
    sprintf(message, invoke_error, name);
    return message;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 3
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 4
17 5
18 5
19 5
20 5
21 7
22 7
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
push   %r12
test   %r8,%r8
mov    (%rdx),%r10d
push   %rbp
push   %rbx
je     120a <gsl_stats_uint_minmax_index+0x5a>
lea    0x0(,%rcx,4),%r12
mov    %r10d,%r11d
xor    %ecx,%ecx
xor    %ebx,%ebx
xor    %r9d,%r9d
jmp    11d6 <gsl_stats_uint_minmax_index+0x26>
mov    %r10d,%r11d
mov    %ebp,%r10d
mov    (%rdx),%eax
mov    %r10d,%ebp
cmp    %r10d,%eax
mov    %r11d,%r10d
cmovb  %r9,%rbx
cmovbe %eax,%ebp
cmp    %r11d,%eax
cmovae %eax,%r10d
cmova  %r9,%rcx
add    $0x1,%r9
add    %r12,%rdx
cmp    %r8,%r9
jne    11d0 <gsl_stats_uint_minmax_index+0x20>
mov    %rbx,(%rdi)
mov    %rcx,(%rsi)
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ecx,%ecx
xor    %ebx,%ebx
jmp    11ff <gsl_stats_uint_minmax_index+0x4f>
<<<sep_in_sample>>>
gsl_stats_uint_minmax_index (size_t * min_index_out,
                                   size_t * max_index_out, const unsigned int data[],
                                   const size_t stride, const size_t n)
{
  unsigned int min = data[0 * stride];
  unsigned int max = data[0 * stride];
  size_t i, min_index = 0, max_index = 0;
  for (i = 0; i < n; i++)
    {
      unsigned int xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
    }
  *min_index_out = min_index;
  *max_index_out = max_index;
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 4
5 4
6 8
7 8
8 6
9 7
10 7
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 8
25 8
26 8
27 8
28 22
29 23
30 24
31 24
32 24
33 24
34 7
35 7
36 7
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
cmp    $0x1,%rdx
mov    %rcx,(%r8)
je     42 <__gmpn_sec_add_1+0x32>
lea    -0x8(,%rdx,8),%rdx
lea    0x8(%r8),%rdi
xor    %esi,%esi
callq  42 <__gmpn_sec_add_1+0x32>
add    $0x8,%rsp
mov    %rbx,%rcx
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %r12,%rdi
mov    %r13,%rsi
pop    %r12
pop    %r13
jmpq   5d <__gmpn_sec_add_1+0x4d>
<<<sep_in_sample>>>
__gmpn_sec_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b, mp_ptr scratch)
{
  scratch[0] = b;
  do { do {} while (0); if ((n-1) != 0) do { mp_ptr __dst = (scratch + 1); mp_size_t __n = (n-1); do {} while (0); do *__dst++ = (((mp_limb_t) 0L)); while (--__n); } while (0); } while (0);
  return __gmpn_add_n (rp, ap, scratch, n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 6
18 5
19 5
20 6
21 6
22 5
23 5
24 6
25 6
26 5
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyerror (const char *s)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     2c88 <gsl_vector_uint_free+0x38>
mov    0x20(%rdi),%eax
test   %eax,%eax
jne    2c70 <gsl_vector_uint_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   2c69 <gsl_vector_uint_free+0x19>
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
callq  2c79 <gsl_vector_uint_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   2c82 <gsl_vector_uint_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_free (gsl_vector_uint * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_uint_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
add    $0x28,%rdi
mov    0x40(%rsp),%rax
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x0(%rip),%rsi        # 134 <nettle_ccm_aes256_decrypt_message+0x24>
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
callq  152 <nettle_ccm_aes256_decrypt_message+0x42>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
      size_t nlength, const uint8_t *nonce,
      size_t alength, const uint8_t *adata,
      size_t tlength,
      size_t mlength, uint8_t *dst, const uint8_t *src)
{
  return nettle_ccm_decrypt_message(&ctx->cipher, (nettle_cipher_func *) nettle_aes256_encrypt,
        nlength, nonce, alength, adata,
        tlength, mlength, dst, src);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0xb8(%rsi),%rdx
mov    0x30(%rsi),%rsi
mov    0x20(%rax),%rax
jmpq   *%rax
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_rcond (double * rcond, const gsl_multilarge_nlinear_workspace * w)
{
  int status = (w->type->rcond) (rcond, w->JTJ, w->state);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     216 <mu_tcp_server_set_backlog+0x16>
mov    0x18(%rdi),%eax
test   %eax,%eax
je     220 <mu_tcp_server_set_backlog+0x20>
mov    $0x16,%eax
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %esi,0x50(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_tcp_server_set_backlog (mu_ip_server_t srv, int backlog)
{
  if (!srv || srv->type != 0)
    return 22;
  srv->v.tcp_data.backlog = backlog;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 4
8 7
9 7
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%eax
mov    %edx,%ebx
movsd  (%rsi),%xmm0
mov    $0x0,%esi
callq  176 <f_double+0x16>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_double (FILE *fp, void *ptr, int size) { fprintf (fp, "%e", *(double*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 27b7 <php_get_leng+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_get_leng (void)
{
        return php_leng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
mov    %rsi,%rbx
callq  1de <libunistring_gl_locale_name_environ+0xe>
test   %rax,%rax
je     1e8 <libunistring_gl_locale_name_environ+0x18>
cmpb   $0x0,(%rax)
jne    215 <libunistring_gl_locale_name_environ+0x45>
mov    %rbx,%rdi
callq  1f0 <libunistring_gl_locale_name_environ+0x20>
test   %rax,%rax
je     1fa <libunistring_gl_locale_name_environ+0x2a>
cmpb   $0x0,(%rax)
jne    215 <libunistring_gl_locale_name_environ+0x45>
mov    $0x0,%edi
callq  204 <libunistring_gl_locale_name_environ+0x34>
mov    %rax,%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     215 <libunistring_gl_locale_name_environ+0x45>
cmpb   $0x0,(%rdx)
cmovne %rdx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
libunistring_gl_locale_name_environ (int category, const char *categoryname)
{
  const char *retval;
  retval = getenv ("LC_ALL");
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != ((void *)0) && retval[0] != '\0')
    {
        return retval;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 15
19 11
20 11
21 15
22 15
23 16
24 16
25 16
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
xor    %r8d,%r8d
mov    %rdx,%rbx
add    $0xffffffffffffff80,%rsp
lea    0xc(%rsp),%rcx
mov    %esi,0xc(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x68(%rsp)
xor    %esi,%esi
mov    %rcx,0x20(%rsp)
lea    0x1c(%rsp),%rcx
movq   $0x0,0x30(%rsp)
movq   $0x0,0x38(%rsp)
movq   $0x0,0x40(%rsp)
lea    0x20(%rsp),%rdx
mov    %rcx,0x50(%rsp)
movq   $0x0,0x60(%rsp)
lea    0x50(%rsp),%rcx
movq   $0x0,0x70(%rsp)
movl   $0x4,0x28(%rsp)
movl   $0x4,0x5c(%rsp)
movl   $0x10,0x68(%rsp)
callq  *0x118(%rax)
test   %eax,%eax
jne    610 <CDB___db_vrfy_pgset_get+0xb0>
mov    0x50(%rsp),%rax
mov    (%rax),%eax
mov    %eax,(%rbx)
xor    %eax,%eax
sub    $0xffffffffffffff80,%rsp
pop    %rbx
retq   
nopl   (%rax)
cmp    $0xffff86f1,%eax
jne    607 <CDB___db_vrfy_pgset_get+0xa7>
xor    %eax,%eax
jmp    603 <CDB___db_vrfy_pgset_get+0xa3>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_vrfy_pgset_get(dbp, pgno, valp)
 DB *dbp;
 db_pgno_t pgno;
 int *valp;
{
 DBT key, data;
 int ret, val;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 key.data = &pgno;
 key.size = sizeof(db_pgno_t);
 data.data = &val;
 data.ulen = sizeof(int);
 (&data)->flags |= (0x010);
 if ((ret = dbp->get(dbp, ((void *)0), &key, &data, 0)) == 0) {
  ((void)0);
  memcpy(&val, data.data, sizeof(int));
 } else if (ret == (-30991))
  val = 0;
 else
  return (ret);
 *valp = val;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 15
4 5
5 5
6 10
7 5
8 8
9 9
10 9
11 15
12 10
13 12
14 8
15 8
16 8
17 15
18 12
19 9
20 15
21 9
22 11
23 13
24 14
25 15
26 15
27 15
28 17
29 17
30 22
31 23
32 24
33 24
34 24
35 24
36 18
37 18
38 18
39 18
40 18
<<<sep_out_sample>>>
mov    0x0(%rip),%ecx        # 1d66 <ssherror+0x6>
mov    0x0(%rip),%rdx        # 1d6d <ssherror+0xd>
mov    %rdi,%r8
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
jmpq   1d7e <ssherror+0x1e>
xchg   %ax,%ax
<<<sep_in_sample>>>
ssherror (const char *msg)
{
  error_at_line (1, 0, sshfilename, sshlineno, msg);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     18b8 <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jb     18a9 <_argp_input+0x29>
jmp    18b8 <_argp_input+0x38>
nopl   0x0(%rax,%rax,1)
add    $0x48,%rax
cmp    %rdx,%rax
jae    18b8 <_argp_input+0x38>
cmp    %rdi,0x8(%rax)
jne    18a0 <_argp_input+0x20>
mov    0x30(%rax),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
 if (group->argp == argp)
   return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 9
16 9
17 9
18 11
19 12
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x8(%rdi),%rbx
mov    %rsi,%rdi
callq  7d <strhash_assign+0x1d>
movslq (%r12),%rcx
xor    %edx,%edx
div    %rcx
lea    (%rbx,%rdx,8),%r14
mov    (%r14),%rbx
test   %rbx,%rbx
jne    a0 <strhash_assign+0x40>
jmp    c0 <strhash_assign+0x60>
nopl   0x0(%rax)
mov    (%rbx),%rbx
test   %rbx,%rbx
je     c0 <strhash_assign+0x60>
mov    0x8(%rbx),%rdi
mov    %rbp,%rsi
callq  ac <strhash_assign+0x4c>
test   %eax,%eax
jne    98 <strhash_assign+0x38>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
xor    %ebx,%ebx
test   %r13d,%r13d
je     b0 <strhash_assign+0x50>
mov    0x10(%r12),%rdi
mov    $0x18,%esi
callq  d6 <strhash_assign+0x76>
mov    0x10(%r12),%rdi
mov    %rax,%rbx
mov    %rbp,%rsi
xor    %edx,%edx
callq  e8 <strhash_assign+0x88>
mov    %rax,0x8(%rbx)
mov    (%r14),%rax
movq   $0x0,0x10(%rbx)
mov    %rax,(%rbx)
mov    %rbx,(%r14)
mov    %rbx,%rax
addq   $0x1,0x18(%r12)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
strhash_assign(STRHASH *sh, const char *name, int force)
{
 struct sh_head *head = &sh->htab[__hash_string(name) % sh->buckets];
 struct sh_entry *entry;
 for((entry) = (head)->slh_first; (entry); (entry) = (entry)->ptr.sle_next)
  if (strcmp(entry->name, name) == 0)
   break;
 if (entry == ((void *)0) && force) {
  entry = pool_malloc(sh->pool, sizeof(struct sh_entry));
  entry->name = pool_strdup(sh->pool, name, 0);
  entry->value = ((void *)0);
  do { (entry)->ptr.sle_next = (head)->slh_first; (head)->slh_first = (entry); } while (0);
  sh->entries++;
 }
 return entry;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 6
25 6
26 6
27 6
28 6
29 16
30 16
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 8
39 8
40 9
41 9
42 9
43 10
44 9
45 10
46 10
47 10
48 10
49 12
50 11
51 12
52 12
53 16
54 13
55 16
56 16
57 16
58 16
59 16
60 16
61 16
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     1191 <mu_message_set_mailbox+0x11>
cmp    %rdx,(%rdi)
mov    $0xd,%al
je     1198 <mu_message_set_mailbox+0x18>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x50(%rdi)
xor    %al,%al
retq   
nop
<<<sep_in_sample>>>
mu_message_set_mailbox (mu_message_t msg, mu_mailbox_t mailbox, void *owner)
{
  if (msg == ((void *)0))
    return 22;
  if (msg->owner != owner)
    return 13;
  msg->mailbox = mailbox;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 9
8 9
9 7
10 8
11 9
12 9
<<<sep_out_sample>>>
cmp    $0x35,%rsi
mov    $0x35,%eax
cmovae %rsi,%rax
add    $0x7f,%rax
shr    $0x6,%rax
mov    %eax,(%rdi)
retq   
<<<sep_in_sample>>>
__gmpf_set_prec_raw (mpf_ptr x, mp_bitcnt_t prec_in_bits)
{
  x->_mp_prec = ((mp_size_t) ((((53) > (prec_in_bits) ? (53) : (prec_in_bits)) + 2 * (64 - 0) - 1) / (64 - 0)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
mov    %edi,%edi
mov    0x0(,%rdi,4),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_is_trace_level_activate (osip_trace_level_t level)
{
  return tracing_table[level];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0xb8,%rdi
callq  1160 <sdp_message_m_proto_get+0x10>
test   %rax,%rax
je     1170 <sdp_message_m_proto_get+0x20>
mov    0x18(%rax),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
xor    %eax,%eax
jmp    1169 <sdp_message_m_proto_get+0x19>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_m_proto_get (sdp_message_t * sdp, int pos_media)
{
  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return ((void *)0);
  return med->m_proto;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 7
8 7
9 7
10 5
11 5
12 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # d56 <gsl_vector_ushort_set+0x6>
test   %eax,%eax
je     d5f <gsl_vector_ushort_set+0xf>
cmp    %rsi,(%rdi)
jbe    d78 <gsl_vector_ushort_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
add    %rax,%rax
imul   %rsi,%rax
mov    %dx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   d91 <gsl_vector_ushort_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_set (gsl_vector_ushort * v, const size_t i, unsigned short x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_ushort.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %rbx
callq  bd6 <isfunction+0x6>
mov    %rax,%rbx
mov    %rax,%rdi
callq  be1 <isfunction+0x11>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   bec <isfunction+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
isfunction(char *str)
{
  str = removepadding(str);
  return fnlookup(str,strlen(str));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_wrap_size_limit (OM_uint32 * minor_status,
       const gss_ctx_id_t context_handle,
       int conf_req_flag,
       gss_qop_t qop_req,
       OM_uint32 req_output_size, OM_uint32 * max_input_size)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 8
2 8
3 8
<<<sep_out_sample>>>
push   %rbp
mov    $0x4,%edx
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  216 <xdr_simx_session_handle+0x16>
xor    %edx,%edx
test   %eax,%eax
je     22f <xdr_simx_session_handle+0x2f>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  228 <xdr_simx_session_handle+0x28>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_simx_session_handle (XDR *xdrs, simx_session_handle *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_opaque (xdrs, objp->data, 4))
		 return FALSE;
	 if (!xdr_dis_simulation_addr (xdrs, &objp->address))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 6
8 7
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     25 <acl_errno_valid+0x25>
jle    20 <acl_errno_valid+0x20>
cmp    $0x26,%edi
je     25 <acl_errno_valid+0x25>
cmp    $0x5f,%edi
nop
je     25 <acl_errno_valid+0x25>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x10,%edi
jne    12 <acl_errno_valid+0x12>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 11
11 11
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
mov    (%rsi),%rdx
mov    (%rdi),%rax
mov    (%rdx),%rsi
mov    (%rax),%rdi
jmpq   101 <printer_hash_qcmp+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_hash_qcmp (struct printer **x, struct printer **y)
{
  return strverscmp ((*x)->key, (*y)->key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 27ab <pict_end+0xb>
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  27bf <pict_end+0x1f>
mov    0x0(%rip),%rcx        # 27c6 <pict_end+0x26>
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  27da <pict_end+0x3a>
mov    0x0(%rip),%rcx        # 27e1 <pict_end+0x41>
mov    $0x0,%edi
mov    $0xa,%edx
mov    $0x1,%esi
callq  27f5 <pict_end+0x55>
mov    0x0(%rip),%rdi        # 27fc <pict_end+0x5c>
add    $0x8,%rsp
jmpq   2805 <pict_end+0x65>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pict_end()
{
  fputs("gr\n", pict_out);
  fputs("showpage\n", pict_out);
  fputs("%%Trailer\n", pict_out);
  fflush(pict_out);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 7
19 6
20 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     260 <parse_opt_set_netmask+0x50>
mov    0x8(%rbx),%eax
test   $0x10,%al
je     246 <parse_opt_set_netmask+0x36>
mov    (%rbx),%r8
xor    %eax,%eax
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
callq  243 <parse_opt_set_netmask+0x33>
mov    0x8(%rbx),%eax
or     $0x10,%eax
mov    %rbp,0x30(%rbx)
mov    %eax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  27b <parse_opt_set_netmask+0x6b>
jmp    221 <parse_opt_set_netmask+0x11>
nopl   (%rax)
<<<sep_in_sample>>>
parse_opt_set_netmask (struct ifconfig *ifp, char *addr) { if (!ifp) error (1, 0, "no interface specified for %s `%s'", "netmask", addr); if (ifp->valid & 0x010) error (1, 0, "only one %s allowed for interface `%s'", "netmask", ifp->name); ifp->netmask = addr; ifp->valid |= 0x010; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
<<<sep_out_sample>>>
mov    0x58(%rdi),%rdi
jmpq   39 <name_hash+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
name_hash (void const *entry, size_t n_buckets)
{
  struct name const *name = entry;
  return hash_string (name->caname, n_buckets);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     10b0 <gsl_integration_qawo_table_free+0x20>
mov    0x28(%rdi),%rdi
callq  10a2 <gsl_integration_qawo_table_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   10ab <gsl_integration_qawo_table_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_integration_qawo_table_free (gsl_integration_qawo_table * t)
{
  if (!t) { return ; };
  free (t->chebmo);
  free (t);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1680 <gsl_vector_long_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1675 <gsl_vector_long_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     16ba <gsl_vector_long_div+0x6a>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %esi,%esi
nop
mov    (%rdi),%rax
add    $0x1,%rsi
cqto   
idivq  (%rcx)
add    %r9,%rcx
mov    %rax,(%rdi)
add    %r10,%rdi
cmp    %r8,%rsi
jne    16a0 <gsl_vector_long_div+0x50>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_vector_long_div (gsl_vector_long * a, const gsl_vector_long * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_add_1_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
mov    %rsp,%rdi
callq  11 <_mu_mailer_sendmail_init+0x11>
test   %eax,%eax
mov    %eax,%ebp
jne    6e <_mu_mailer_sendmail_init+0x6e>
mov    (%rsp),%rax
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
movq   $0x0,0x40(%rbx)
movq   $0x0,0x48(%rbx)
movq   $0x0,0x50(%rbx)
movq   $0x0,0x58(%rbx)
mov    %rax,0x38(%rbx)
movq   $0x0,0x10(%rsp)
callq  55 <_mu_mailer_sendmail_init+0x55>
mov    0x10(%rsp),%rdi
mov    $0x1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  6e <_mu_mailer_sendmail_init+0x6e>
add    $0x28,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mu_mailer_sendmail_init (mu_mailer_t mailer)
{
  int status;
  mu_progmailer_t pm;
  status = mu_progmailer_create (&pm);
  if (status)
    return status;
  mailer->data = pm;
  mailer->_destroy = sendmail_destroy;
  mailer->_open = sendmail_open;
  mailer->_close = sendmail_close;
  mailer->_send_message = sendmail_send_message;
  {
    mu_property_t property = ((void *)0);
    mu_mailer_get_property (mailer, &property);
    mu_property_set_value (property, "TYPE", "SENDMAIL", 1);
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 6
8 5
9 6
10 8
11 15
12 15
13 9
14 10
15 11
16 12
17 8
18 14
19 15
20 16
21 16
22 16
23 16
24 16
25 19
26 19
27 19
28 19
29 19
30 19
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
lea    0x5c(%rdi),%rdi
sub    $0x8,%rsp
callq  15 <nettle_poly1305_aes_set_key+0x15>
lea    0x10(%rbp),%rsi
mov    %rbx,%rdi
callq  21 <nettle_poly1305_aes_set_key+0x21>
movl   $0x0,0x48(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
nettle_poly1305_aes_set_key (struct poly1305_aes_ctx *ctx, const uint8_t * key)
{
  nettle_aes128_set_encrypt_key(&ctx->aes, (key));
  nettle_poly1305_set_key(&ctx->pctx, (key+16));
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 4
9 4
10 4
11 5
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbx
mov    0x34(%rdi),%ecx
mov    %rsi,%rbx
mov    0x8(%rdi),%rax
xor    %r8d,%r8d
lea    -0x1(%rcx),%edx
sub    0x48(%rsi),%edx
mov    $0x1,%ecx
mov    0x40(%rsi),%rsi
callq  *0x38(%rax)
addl   $0x1,0x48(%rbx)
mov    %rax,0x20(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
get_memory_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  tga_source_ptr source = (tga_source_ptr) sinfo;
  JDIMENSION source_row;
  source_row = cinfo->image_height - source->current_row - 1;
  source->pub.buffer = (*cinfo->mem->access_virt_sarray)
    ((j_common_ptr) cinfo, source->whole_image,
     source_row, (JDIMENSION) 1, 0);
  source->current_row++;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 7
5 7
6 5
7 5
8 7
9 7
10 7
11 9
12 6
13 11
14 11
15 11
16 11
<<<sep_out_sample>>>
mov    %esi,%eax
and    $0x1,%eax
mov    %eax,(%rdi)
mov    %esi,%eax
and    $0x8,%esi
shr    %al
and    $0x1,%eax
cmp    $0x1,%sil
mov    %eax,0x4(%rdi)
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
mov    %eax,0x8(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_track_flags(track_flags_t *p_track_flag, uint8_t i_flag)
{
  p_track_flag->preemphasis = ( i_flag & CDIO_TRACK_FLAG_PRE_EMPHASIS )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->copy_permit = ( i_flag & CDIO_TRACK_FLAG_COPY_PERMITTED )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->channels = ( i_flag & CDIO_TRACK_FLAG_FOUR_CHANNEL_AUDIO )
    ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 7
6 6
7 6
8 8
9 5
10 8
11 8
12 8
13 7
14 7
15 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x12,%edi
callq  5e3 <logout+0x13>
callq  5e8 <logout+0x18>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
logout (void)
{
  send_do (18, 1);
  netflush ();
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 6
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x18,%rsp
mov    (%rsi),%rbp
mov    0x8(%rsi),%r13
test   %rbp,%rbp
jne    133 <gsl_permutation_fscanf+0x33>
jmp    178 <gsl_permutation_fscanf+0x78>
nopl   (%rax)
mov    0x8(%rsp),%rax
mov    %rax,0x0(%r13,%rbx,8)
add    $0x1,%rbx
cmp    %rbp,%rbx
je     178 <gsl_permutation_fscanf+0x78>
lea    0x8(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r12,%rdi
callq  147 <gsl_permutation_fscanf+0x47>
cmp    $0x1,%eax
je     120 <gsl_permutation_fscanf+0x20>
mov    $0x5,%ecx
mov    $0x69,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  165 <gsl_permutation_fscanf+0x65>
add    $0x18,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_permutation_fscanf (FILE * stream, gsl_permutation * p)
{
  size_t n = p->size ;
  size_t * data = p->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned long j ;
      int status = fscanf (stream, "%lu", &j);
      if (status != 1)
        {
          do { gsl_error ("fscanf failed", "file.c", 105, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
      data[i] = j;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 3
9 4
10 6
11 6
12 6
13 6
14 14
15 14
16 6
17 6
18 6
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 12
27 12
28 12
29 12
30 12
31 17
32 12
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 16
41 17
42 17
43 17
44 17
45 17
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     31f <gsl_vector_ulong_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  315 <gsl_vector_ulong_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     355 <gsl_vector_ulong_memcpy+0x65>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%rsi
add    $0x1,%rax
add    %r10,%rcx
mov    %rsi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    340 <gsl_vector_ulong_memcpy+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_memcpy (gsl_vector_ulong * dest,
                               const gsl_vector_ulong * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  cb3 <seek_warn_details+0x23>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # cbc <seek_warn_details+0x2c>
test   %rax,%rax
je     cc3 <seek_warn_details+0x33>
callq  *%rax
mov    %rsp,%rsi
mov    %r12,%rdi
callq  cce <seek_warn_details+0x3e>
mov    %rbp,%rdi
mov    %rax,%r12
callq  cd9 <seek_warn_details+0x49>
mov    $0x0,%edi
mov    %rax,%rbp
callq  ce6 <seek_warn_details+0x56>
xor    %edi,%edi
mov    %rax,%rdx
mov    %r12,%r8
xor    %eax,%eax
mov    %rbp,%rcx
mov    %ebx,%esi
callq  cfa <seek_warn_details+0x6a>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
jne    d13 <seek_warn_details+0x83>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  d18 <seek_warn_details+0x88>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
seek_warn_details (char const *name, off_t offset)
{
  char buf[(((((sizeof (uintmax_t) * 8 - (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) * 146 + 484) / 485) + (! ((__typeof__ (uintmax_t)) 0 < (__typeof__ (uintmax_t)) -1))) + 1)];
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Warning: Cannot seek to %s"), quotearg_colon (name), umaxtostr (offset, buf)); } while (0)
                                  ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <acm_rand+0x9>
add    $0x8,%rsp
movzwl %ax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
acm_rand(void)
{
 return rand() & 0xffff;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    0x28(%rsi),%rsi
test   %rsi,%rsi
je     12 <auth_pass+0x12>
cmpb   $0x0,(%rsi)
jne    20 <auth_pass+0x20>
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  25 <auth_pass+0x25>
test   %rax,%rax
je     12 <auth_pass+0x12>
mov    0x28(%rbx),%rsi
mov    %rax,%rdi
callq  36 <auth_pass+0x36>
test   %eax,%eax
setne  %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
auth_pass (const char *passwd, struct credentials *pcred)
{
  switch (pcred->auth_type)
    {
    case 0:
    default:
      {
 char *xpasswd;
 char *salt = pcred->passwd;
 if (pcred->passwd == ((void *)0) || *pcred->passwd == '\0')
   return 1;
 xpasswd = crypt (passwd, salt);
 return (!xpasswd || strcmp (xpasswd, pcred->passwd) != 0);
      }
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 9
4 10
5 10
6 10
7 10
8 11
9 17
10 17
11 17
12 12
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 17
22 17
<<<sep_out_sample>>>
xor    %eax,%eax
test   %dil,%dil
js     27 <mu_parse822_is_digit+0x17>
movsbl %dil,%edi
mov    0x0(,%rdi,4),%eax
shr    %eax
and    $0x1,%eax
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_parse822_is_digit (char c)
{
  return (((unsigned)((unsigned) c)) < 128 && mu_c_tab[(unsigned)((unsigned) c)] & (0x002));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbx
mov    0x20(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    820 <hash_map_arg+0x40>
mov    (%rbx),%rdi
test   %rdi,%rdi
je     817 <hash_map_arg+0x37>
cmp    0x0(%rip),%rdi        # 80f <hash_map_arg+0x2f>
je     817 <hash_map_arg+0x37>
mov    %r12,%rsi
callq  *%r13
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     800 <hash_map_arg+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_map_arg (struct hash_table *ht, hash_map_arg_func_t map, void *arg)
{
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  for (slot = ht->ht_vec; slot < end; slot++)
    {
      if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
 (*map) (*slot, arg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 5
21 5
22 5
23 10
24 10
25 10
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_osx(void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     970 <gsl_permute_vector_long_double+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  965 <gsl_permute_vector_long_double+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  981 <gsl_permute_vector_long_double+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_long_double (const gsl_permutation * p, gsl_vector_long_double * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_long_double (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
movapd %xmm1,%xmm5
subsd  %xmm0,%xmm1
subsd  %xmm4,%xmm5
movapd %xmm5,%xmm4
divsd  %xmm1,%xmm4
movsd  0x0(%rip),%xmm1        # 4dfc <linearinterp+0x1c>
subsd  %xmm4,%xmm1
movapd %xmm4,%xmm0
mulsd  %xmm2,%xmm0
mulsd  %xmm3,%xmm1
addsd  %xmm1,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
linearinterp(double a, double b, double aval, double bval, double c)
{
  double lambda;
  lambda = (b-c)/(b-a);
  return lambda*aval + (1-lambda)*bval;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <gsl_multiset_get+0x6>
test   %eax,%eax
je     10 <gsl_multiset_get+0x10>
cmp    %rsi,0x8(%rdi)
jbe    20 <gsl_multiset_get+0x20>
mov    0x10(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x53,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d <gsl_multiset_get+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multiset_get (const gsl_multiset * c, const size_t i)
{
  if ((gsl_check_range && (i >= c->k)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_multiset.h", 83, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return c->data[i];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 8
18 8
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 747 <_hs_append_history_line+0x17>
mov    (%rax,%rdi,8),%rbp
mov    0x0(%rbp),%r12
mov    %r12,%rdi
callq  757 <_hs_append_history_line+0x27>
mov    %r13,%rdi
mov    %rax,%rbx
callq  762 <_hs_append_history_line+0x32>
lea    0x2(%rbx,%rax,1),%rsi
mov    %r12,%rdi
callq  76f <_hs_append_history_line+0x3f>
test   %rax,%rax
je     7a0 <_hs_append_history_line+0x70>
mov    %rax,0x0(%rbp)
movb   $0xa,(%rax,%rbx,1)
mov    %r13,%rsi
mov    0x0(%rbp),%rax
add    $0x8,%rsp
lea    0x1(%rax,%rbx,1),%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   797 <_hs_append_history_line+0x67>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_hs_append_history_line (which, line)
     int which;
     const char *line;
{
  HIST_ENTRY *hent;
  size_t newlen, curlen;
  char *newline;
  hent = the_history[which];
  curlen = strlen (hent->line);
  newlen = curlen + strlen (line) + 2;
  newline = realloc (hent->line, newlen);
  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 9
11 9
12 9
13 10
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 14
22 15
23 16
24 16
25 18
26 16
27 18
28 18
29 18
30 18
31 16
32 16
33 18
34 18
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
mov    %rsi,0x58(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk2imp_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  rk2imp_state_t *state = (rk2imp_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 154b <archive_read_error+0xb>
mov    (%rax),%rdi
callq  1553 <archive_read_error+0x13>
cmpq   $0x0,0x0(%rip)        # 155b <archive_read_error+0x1b>
je     1576 <archive_read_error+0x36>
mov    0x0(%rip),%eax        # 1563 <archive_read_error+0x23>
lea    0x1(%rax),%edx
cmp    $0xa,%eax
mov    %edx,0x0(%rip)        # 156f <archive_read_error+0x2f>
jg     157b <archive_read_error+0x3b>
add    $0x8,%rsp
retq   
callq  157b <archive_read_error+0x3b>
mov    0x0(%rip),%rax        # 1582 <archive_read_error+0x42>
test   %rax,%rax
je     1589 <archive_read_error+0x49>
callq  *%rax
mov    $0x0,%edi
callq  1593 <archive_read_error+0x53>
xor    %esi,%esi
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
callq  15a1 <archive_read_error+0x61>
callq  15a6 <archive_read_error+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
archive_read_error (void)
{
  read_error (*archive_name_cursor);
  if (record_start_block == 0)
    do { if (error_hook) error_hook (); error (0, 0, gettext ("At beginning of tape, quitting now")); fatal_exit (); } while (0);
  if (read_error_count++ > 10)
    do { if (error_hook) error_hook (); error (0, 0, gettext ("Too many errors, quitting")); fatal_exit (); } while (0);
  return;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 9
13 9
14 9
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
<<<sep_out_sample>>>
movslq (%rdi),%rax
movl   $0x1,0x0(,%rax,4)
mov    $0x1,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fire_aim120(craft * c)
{
 hasFired[c->pIndex] = 1;
 return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    %rsp,%rdi
callq  10 <printf_frexp+0x10>
mov    (%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,(%rsp)
jge    34 <printf_frexp+0x34>
lea    0x3fd(%rdx),%edi
callq  2f <printf_frexp+0x2f>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
cmp    $0x1,%edi
mov    %edi,0xc(%rsp)
mov    %rsi,(%rsp)
jle    2730 <removedir+0x60>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  26f5 <removedir+0x25>
cmp    $0x5,%eax
je     2700 <removedir+0x30>
add    $0x18,%rsp
retq   
nop
cmpl   $0x1f4,0x0(%rip)        # 270a <removedir+0x3a>
jne    26fa <removedir+0x2a>
mov    0x0(%rip),%eax        # 2712 <removedir+0x42>
test   %eax,%eax
jne    2768 <removedir+0x98>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    0x8(%rax),%rsi
xor    %eax,%eax
callq  272a <removedir+0x5a>
add    $0x18,%rsp
retq   
nop
lea    0xc(%rsp),%rdi
mov    $0x0,%edx
mov    %rsp,%rsi
callq  2742 <removedir+0x72>
test   %eax,%eax
jne    26e1 <removedir+0x11>
mov    (%rsp),%rax
mov    $0x0,%edi
mov    (%rax),%rsi
xor    %eax,%eax
callq  2759 <removedir+0x89>
movl   $0xffffffff,0x0(%rip)        # 2763 <removedir+0x93>
jmp    26fa <removedir+0x2a>
nopl   (%rax)
mov    $0x0,%edi
callq  2772 <removedir+0xa2>
jmp    2716 <removedir+0x46>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
removedir (int argc, char **argv)
{
  if (argc < 2 && !another (&argc, &argv, "directory-name"))
    {
      printf ("usage: %s directory-name\n", argv[0]);
      code = -1;
      return;
    }
  if (command ("RMD %s", argv[1]) == 5 && code == 500)
    {
      if (verbose)
 printf ("RMD command not recognized, trying XRMD\n");
      command ("XRMD %s", argv[1]);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 15
14 15
15 15
16 9
17 9
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 15
27 15
28 15
29 3
30 3
31 3
32 3
33 3
34 3
35 5
36 5
37 5
38 5
39 5
40 6
41 7
42 7
43 12
44 12
45 12
46 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  ec <delegate_free+0xc>
mov    0x8(%rbx),%rdi
callq  f5 <delegate_free+0x15>
mov    0x10(%rbx),%rdi
callq  fe <delegate_free+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   107 <delegate_free+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delegate_free (struct delegation *delegation)
{
  free (delegation->name);
  free (delegation->contract);
  free (delegation->command);
  free (delegation);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
mov    %edi,%edi
shl    $0x5,%rdi
add    0x0(%rip),%rdi        # 36d <get_file_last_page+0xd>
mov    0x8(%rdi),%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_file_last_page(unsigned int this_file_number)
{
  return files[this_file_number].ending_page;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1663 <gsl_matrix_long_isnull+0x53>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,8),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1657 <gsl_matrix_long_isnull+0x47>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdq (%rcx,%rax,8),%xmm0
ucomisd %xmm1,%xmm0
jp     1669 <gsl_matrix_long_isnull+0x59>
jne    1669 <gsl_matrix_long_isnull+0x59>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1640 <gsl_matrix_long_isnull+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    1631 <gsl_matrix_long_isnull+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_long_isnull (const gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbx
mov    $0xc8,%esi
mov    %rdi,%rbx
mov    $0x1,%edi
callq  6b3 <mu_server_create+0x13>
test   %rax,%rax
mov    $0xc,%edx
je     6c2 <mu_server_create+0x22>
mov    %rax,(%rbx)
xor    %dl,%dl
mov    %edx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_server_create (mu_server_t *psrv)
{
  mu_server_t srv = calloc (1, sizeof (*srv));
  if (!srv)
    return 12;
  *psrv = srv;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 5
8 4
9 6
10 7
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%r14
mov    0x8(%rdi),%rax
cmp    %r14,%rax
jbe    5b2 <hash_do_for_each+0x72>
mov    %rsi,%r12
mov    %rdx,%r13
xor    %ebp,%ebp
mov    (%r14),%rdi
test   %rdi,%rdi
je     596 <hash_do_for_each+0x56>
mov    %r14,%rbx
jmp    57b <hash_do_for_each+0x3b>
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %r13,%rsi
callq  *%r12
test   %al,%al
je     5a0 <hash_do_for_each+0x60>
mov    0x8(%rbx),%rbx
add    $0x1,%rbp
test   %rbx,%rbx
jne    578 <hash_do_for_each+0x38>
mov    0x8(%r15),%rax
add    $0x10,%r14
cmp    %r14,%rax
ja     565 <hash_do_for_each+0x25>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
xor    %ebp,%ebp
jmp    5a0 <hash_do_for_each+0x60>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_do_for_each (const Hash_table *table, Hash_processor processor,
    void *processor_data)
{
  size_t counter = 0;
  struct hash_entry const *bucket;
  struct hash_entry const *cursor;
  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)
    {
      if (bucket->data)
 {
   for (cursor = bucket; cursor; cursor = cursor->next)
     {
       if (! processor (cursor->data, processor_data))
  return counter;
       counter++;
     }
 }
    }
  return counter;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 7
10 7
11 7
12 7
13 7
14 7
15 4
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 13
24 13
25 13
26 13
27 11
28 15
29 11
30 11
31 11
32 7
33 7
34 7
35 7
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 4
46 4
47 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
mov    (%rdi),%rbp
push   %rbx
mov    0x8(%rdi),%r9
test   %rbp,%rbp
mov    0x10(%rdi),%rbx
movq   %xmm0,-0x10(%rsp)
mov    -0x10(%rsp),%rax
je     1bce <gsl_matrix_complex_float_add_constant+0x10e>
mov    %eax,-0x10(%rsp)
shr    $0x20,%rax
lea    0x0(,%rbx,8),%r12
movss  -0x10(%rsp),%xmm2
mov    %eax,-0x10(%rsp)
mov    %r9,%rax
shr    %rax
movaps %xmm2,%xmm4
movss  -0x10(%rsp),%xmm1
mov    %rax,%r15
add    %r15,%r15
unpcklps %xmm1,%xmm4
sete   %r13b
cmp    $0x1,%r9
mov    %rax,-0x10(%rsp)
xorps  %xmm3,%xmm3
setbe  %al
movlhps %xmm4,%xmm4
xor    %r14d,%r14d
or     %al,%r13b
cmove  %r15,%r14
xor    %esi,%esi
xor    %ecx,%ecx
xor    %eax,%eax
nopl   0x0(%rax)
test   %r9,%r9
je     1bbb <gsl_matrix_complex_float_add_constant+0xfb>
test   %r13b,%r13b
mov    0x18(%rdi),%rdx
jne    1b90 <gsl_matrix_complex_float_add_constant+0xd0>
lea    (%rdx,%rsi,1),%r10
xor    %r8d,%r8d
xor    %r11d,%r11d
movaps %xmm3,%xmm0
add    $0x1,%r11
movlps (%r10,%r8,1),%xmm0
movhps 0x8(%r10,%r8,1),%xmm0
addps  %xmm4,%xmm0
movlps %xmm0,(%r10,%r8,1)
movhps %xmm0,0x8(%r10,%r8,1)
add    $0x10,%r8
cmp    %r11,-0x10(%rsp)
ja     1b60 <gsl_matrix_complex_float_add_constant+0xa0>
cmp    %r15,%r9
je     1bbb <gsl_matrix_complex_float_add_constant+0xfb>
lea    (%r14,%rcx,1),%r8
shl    $0x3,%r8
lea    (%rdx,%r8,1),%r10
lea    0x4(%rdx,%r8,1),%rdx
movss  (%r10),%xmm0
addss  %xmm2,%xmm0
movss  %xmm0,(%r10)
movss  (%rdx),%xmm0
addss  %xmm1,%xmm0
movss  %xmm0,(%rdx)
add    $0x1,%rax
add    %rbx,%rcx
add    %r12,%rsi
cmp    %rbp,%rax
jne    1b48 <gsl_matrix_complex_float_add_constant+0x88>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
xor    %eax,%eax
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_add_constant (gsl_matrix_complex_float * a, const gsl_complex_float x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[2 * (i * tda + j)] += ((x).dat[0]);
          a->data[2 * (i * tda + j) + 1] += ((x).dat[1]);
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 4
9 7
10 5
11 2
12 2
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 11
30 11
31 11
32 11
33 11
34 11
35 7
36 7
37 7
38 7
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 11
55 11
56 11
57 11
58 11
59 11
60 11
61 11
62 12
63 11
64 11
65 11
66 12
67 12
68 12
69 7
70 7
71 7
72 7
73 7
74 16
75 16
76 16
77 16
78 16
79 16
80 16
81 16
82 16
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 616 <tty_rspeed+0x6>
cmp    $0xffffffff,%eax
je     650 <tty_rspeed+0x40>
cmp    %eax,%edi
mov    $0x0,%eax
jg     634 <tty_rspeed+0x24>
jmp    643 <tty_rspeed+0x33>
nopw   %cs:0x0(%rax,%rax,1)
cmp    %edi,%edx
jge    643 <tty_rspeed+0x33>
add    $0x8,%rax
mov    (%rax),%edx
cmp    $0xffffffff,%edx
jne    630 <tty_rspeed+0x20>
sub    $0x8,%rax
mov    0x4(%rax),%esi
mov    $0x0,%edi
jmpq   650 <tty_rspeed+0x40>
mov    $0x0,%eax
jmp    63f <tty_rspeed+0x2f>
<<<sep_in_sample>>>
tty_rspeed (int val)
{
  struct termspeeds *tp;
  for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)
    ;
  if (tp->speed == -1)
    --tp;
  val = tp->value;
  cfsetispeed (&termbuf, val);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 7
16 9
17 9
18 9
19 4
20 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 2f68 <fixup_prerequisites+0x8>
test   %rbx,%rbx
jne    2f78 <fixup_prerequisites+0x18>
jmp    2f90 <fixup_prerequisites+0x30>
nop
mov    (%rbx),%rbx
test   %rbx,%rbx
je     2f90 <fixup_prerequisites+0x30>
mov    0x10(%rbx),%eax
test   %eax,%eax
jne    2f70 <fixup_prerequisites+0x10>
mov    0x30(%rbx),%rdi
callq  2f88 <fixup_prerequisites+0x28>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    2f78 <fixup_prerequisites+0x18>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fixup_prerequisites ()
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (((prog)->type == TYPE_COMPONENT))
      component_fixup_depend (prog->v.p.comp);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 6
14 6
15 4
16 4
17 4
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbp
mov    $0x13f,%edx
movslq %edi,%rbp
mov    $0x0,%esi
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  139d <new_fd_bitmap+0x1d>
test   %ebp,%ebp
mov    %rax,%rbx
mov    %ebp,(%rax)
jne    13c0 <new_fd_bitmap+0x40>
movq   $0x0,0x8(%rax)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
mov    $0x145,%edx
mov    $0x0,%esi
callq  13d2 <new_fd_bitmap+0x52>
mov    %rbp,%rdx
mov    %rax,0x8(%rbx)
xor    %esi,%esi
mov    %rax,%rdi
callq  13e3 <new_fd_bitmap+0x63>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
new_fd_bitmap (size)
     int size;
{
  struct fd_bitmap *ret;
  ret = (struct fd_bitmap *)sh_xmalloc((sizeof (struct fd_bitmap)), "execute_cmd.c", 319);
  ret->size = size;
  if (size)
    {
      ret->bitmap = (char *)sh_xmalloc((size), "execute_cmd.c", 325);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)((void *)0);
  return (ret);
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 3
7 3
8 5
9 7
10 5
11 6
12 7
13 13
14 15
15 15
16 15
17 15
18 15
19 15
20 9
21 9
22 9
23 9
24 10
25 9
26 10
27 10
28 10
29 15
30 15
31 15
32 15
33 15
34 15
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
lea    0x100(%rdi),%rdi
push   %rbx
mov    %rdx,%rbx
callq  b9 <nettle_des3_decrypt+0x19>
lea    0x80(%rbp),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %r12,%rsi
callq  ce <nettle_des3_decrypt+0x2e>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
mov    %r12,%rsi
pop    %r12
jmpq   e3 <nettle_des3_decrypt+0x43>
<<<sep_in_sample>>>
nettle_des3_decrypt(const struct des3_ctx *ctx,
      size_t length, uint8_t *dst,
      const uint8_t *src)
{
  nettle_des_decrypt(&ctx->des[2],
       length, dst, src);
  nettle_des_encrypt(&ctx->des[1],
       length, dst, dst);
  nettle_des_decrypt(&ctx->des[0],
       length, dst, dst);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 4
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 11
18 11
19 9
20 11
21 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 2f6e <hangup_all_jobs+0xe>
test   %edx,%edx
jg     2f83 <hangup_all_jobs+0x23>
jmp    2fd0 <hangup_all_jobs+0x70>
nopl   0x0(%rax)
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %edx,%eax
jge    2fd0 <hangup_all_jobs+0x70>
mov    0x0(%rip),%rax        # 2f8a <hangup_all_jobs+0x2a>
lea    0x0(,%rbx,8),%rbp
mov    (%rax,%rbx,8),%rax
test   %rax,%rax
je     2f78 <hangup_all_jobs+0x18>
testb  $0x8,0x18(%rax)
jne    2f78 <hangup_all_jobs+0x18>
mov    0x10(%rax),%edi
mov    $0x1,%esi
callq  2fae <hangup_all_jobs+0x4e>
mov    0x0(%rip),%rax        # 2fb5 <hangup_all_jobs+0x55>
mov    (%rax,%rbp,1),%rax
cmpl   $0x2,0x14(%rax)
je     2fe0 <hangup_all_jobs+0x80>
mov    0x0(%rip),%edx        # 2fc5 <hangup_all_jobs+0x65>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %edx,%eax
jl     2f83 <hangup_all_jobs+0x23>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x10(%rax),%edi
mov    $0x12,%esi
callq  2fed <hangup_all_jobs+0x8d>
jmp    2fbf <hangup_all_jobs+0x5f>
nop
<<<sep_in_sample>>>
hangup_all_jobs ()
{
  register int i;
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i])
 {
   if (jobs[i]->flags & 0x08)
     continue;
   killpg (jobs[i]->pgrp, 1);
   if ((jobs[(i)]->state == JSTOPPED))
     killpg (jobs[i]->pgrp, 18);
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 10
22 10
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 4
32 4
33 15
34 15
35 15
36 15
37 15
38 12
39 12
40 12
41 12
42 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_name (const gsl_multimin_fdfminimizer * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
sub    $0x10,%rsp
mov    %rsp,%rdi
callq  365f <machtime+0xf>
test   %eax,%eax
js     3680 <machtime+0x30>
mov    (%rsp),%eax
lea    -0x7c558180(%rax),%edi
callq  3671 <machtime+0x21>
mov    %eax,%ebx
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ebx,%ebx
cmpb   $0x0,0x0(%rip)        # 3689 <machtime+0x39>
je     3673 <machtime+0x23>
mov    0x0(%rip),%rcx        # 3692 <machtime+0x42>
mov    $0x1a,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  36a6 <machtime+0x56>
jmp    3673 <machtime+0x23>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
machtime (void)
{
  struct timeval tv;
  if (gettimeofday (&tv, ((void *)0)) < 0)
    {
      if (debug)
 fprintf (stderr, "Unable to get time of day\n");
      return 0L;
    }
  return (htonl ((long) (tv.tv_sec + ((unsigned long)25567 * 24*60*60))));
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 4
8 10
9 10
10 10
11 10
12 11
13 11
14 11
15 11
16 11
17 8
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
mov    (%rdx),%r8d
movslq %r8d,%rcx
shl    $0x4,%rcx
lea    (%rdi,%rcx,1),%r9
mov    (%r9),%rax
test   %rax,%rax
je     6b0 <trans_toknext+0x40>
test   %esi,0x8(%r9)
lea    0x10(%rdi,%rcx,1),%rcx
je     6a1 <trans_toknext+0x31>
jmp    6c0 <trans_toknext+0x50>
nopl   0x0(%rax,%rax,1)
add    $0x10,%rcx
test   %esi,0x8(%rdi)
jne    6c0 <trans_toknext+0x50>
mov    (%rcx),%rax
add    $0x1,%r8d
mov    %rcx,%rdi
test   %rax,%rax
jne    698 <trans_toknext+0x28>
mov    %r8d,(%rdx)
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%r8d
mov    %r8d,(%rdx)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trans_toknext(struct transtab *tab, int tok, int *next)
{
 int i;
 for (i = *next; tab[i].name; i++)
  if (tab[i].tok & tok) {
   *next = i + 1;
   return tab[i].name;
  }
 *next = i;
 return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 4
17 4
18 4
19 4
20 4
21 9
22 10
23 11
24 11
25 6
26 6
27 7
28 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1109 <gsl_vector_long_isnull+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdq (%rdx),%xmm0
ucomisd %xmm1,%xmm0
jp     110f <gsl_vector_long_isnull+0x3f>
jne    110f <gsl_vector_long_isnull+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    10f0 <gsl_vector_long_isnull+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_isnull (const gsl_vector_long * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 17
19 18
20 13
21 13
22 13
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  90c <proper_name+0xc>
cmp    %rbp,%rax
mov    %rax,%rbx
je     923 <proper_name+0x23>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  0 <mbsstr_trimmed_wordbounded>
test   %al,%al
je     930 <proper_name+0x30>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  938 <proper_name+0x38>
mov    %rbp,%rdi
mov    %rax,%r12
callq  943 <proper_name+0x43>
lea    0x4(%r12,%rax,1),%rdi
callq  94d <proper_name+0x4d>
mov    %rax,%r12
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rax,%rdi
mov    %r12,%rbx
mov    $0x0,%esi
xor    %eax,%eax
callq  968 <proper_name+0x68>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
proper_name (const char *name)
{
  const char *translation = gettext (name);
  if (translation != name)
    {
      if (mbsstr_trimmed_wordbounded (translation, name))
        return translation;
      else
        {
          char *result =
            ((char *) (sizeof (char) == 1 ? xmalloc (strlen (translation) + 2 + strlen (name) + 1 + 1) : xnmalloc (strlen (translation) + 2 + strlen (name) + 1 + 1, sizeof (char))));
          sprintf (result, "%s (%s)", translation, name);
          return result;
        }
    }
  else
    return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 6
10 6
11 6
12 6
13 6
14 18
15 18
16 18
17 18
18 18
19 18
20 11
21 11
22 11
23 11
24 11
25 11
26 10
27 10
28 12
29 12
30 12
31 13
32 12
33 12
34 12
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  519 <mkfilename+0x19>
mov    %r13,%rdi
mov    %rax,%r12
callq  524 <mkfilename+0x24>
test   %r12,%r12
mov    %rax,%r14
je     5cb <mkfilename+0xcb>
cmpb   $0x2f,-0x1(%rbp,%r12,1)
lea    -0x1(%r12),%rbx
je     556 <mkfilename+0x56>
jmpq   5cf <mkfilename+0xcf>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2f,-0x1(%rbp,%rbx,1)
lea    -0x1(%rbx),%rcx
jne    55b <mkfilename+0x5b>
mov    %rcx,%rbx
test   %rbx,%rbx
jne    548 <mkfilename+0x48>
xor    %r15d,%r15d
cmpb   $0x0,0x0(%rbp)
setne  %r15b
add    %r14,%r15
add    %rbx,%r15
lea    0x1(%r15),%rdi
callq  575 <mkfilename+0x75>
test   %rax,%rax
mov    %rax,%r12
je     5a5 <mkfilename+0xa5>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  58b <mkfilename+0x8b>
cmpb   $0x0,0x0(%rbp)
jne    5c0 <mkfilename+0xc0>
lea    (%r12,%rbx,1),%rdi
mov    %r14,%rdx
mov    %r13,%rsi
callq  5a0 <mkfilename+0xa0>
movb   $0x0,(%r12,%r15,1)
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
movb   $0x2f,(%r12,%rbx,1)
add    $0x1,%rbx
jmp    591 <mkfilename+0x91>
xor    %ebx,%ebx
jmp    55b <mkfilename+0x5b>
mov    %r12,%rbx
jmp    55b <mkfilename+0x5b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mkfilename(const char *dir, const char *file)
{
 char *tmp;
 size_t dirlen = strlen(dir);
 size_t fillen = strlen(file);
 size_t len;
 while (dirlen > 0 && dir[dirlen-1] == '/')
  dirlen--;
 len = dirlen + (dir[0] ? 1 : 0) + fillen;
 tmp = malloc(len + 1);
 if (tmp) {
  memcpy(tmp, dir, dirlen);
  if (dir[0])
   tmp[dirlen++] = '/';
  memcpy(tmp + dirlen, file, fillen);
  tmp[len] = 0;
 }
 return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 4
11 5
12 4
13 5
14 7
15 5
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 11
36 10
37 11
38 12
39 12
40 12
41 12
42 13
43 13
44 15
45 15
46 15
47 15
48 16
49 19
50 19
51 19
52 19
53 19
54 19
55 19
56 19
57 19
58 19
59 14
60 14
61 14
62 7
63 7
64 7
65 7
66 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     10 <rec_comment_new+0x10>
jmpq   a <rec_comment_new+0xa>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_new (char *text)
{
  if (!text)
    {
      return ((void *)0);
    }
  return strdup (text);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 8
6 8
7 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rsi
mov    0x38(%rdi),%rdx
xor    %eax,%eax
mov    $0x0,%edi
jmpq   *%rdx
<<<sep_in_sample>>>
parser(const struct parser_param *param)
{
 param->warning("nop parser: %s", param->file);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 25f6 <smapget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smapget_lineno (void)
{
    return smaplineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x48,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     50e0 <gsl_matrix_int_add+0x50>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  50c3 <gsl_matrix_int_add+0x33>
mov    $0x13,%eax
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
jne    50aa <gsl_matrix_int_add+0x1a>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rbx
test   %r10,%r10
mov    %rax,(%rsp)
mov    %rbx,0x8(%rsp)
je     5248 <gsl_matrix_int_add+0x1b8>
shl    $0x2,%rax
xor    %ecx,%ecx
mov    %r10,0x20(%rsp)
mov    %rax,0x10(%rsp)
lea    0x0(,%rbx,4),%rax
xor    %r11d,%r11d
xor    %r14d,%r14d
xor    %r13d,%r13d
mov    %rcx,%r10
mov    %rax,0x18(%rsp)
mov    %rdx,%rax
mov    %rdi,0x30(%rsp)
shr    $0x2,%rax
mov    %rsi,0x38(%rsp)
lea    0x0(,%rax,4),%r15
mov    %rax,0x28(%rsp)
lea    0x2(%r15),%rbx
lea    0x1(%r15),%rax
mov    %rbx,%rbp
mov    %rax,%r12
xor    %ebx,%ebx
jmpq   51f0 <gsl_matrix_int_add+0x160>
nop
cmp    $0x6,%rdx
jbe    522e <gsl_matrix_int_add+0x19e>
test   %r15,%r15
je     519b <gsl_matrix_int_add+0x10b>
xor    %esi,%esi
xor    %r9d,%r9d
movdqu (%rax,%rsi,1),%xmm1
add    $0x1,%r9
movdqu (%rcx,%rsi,1),%xmm0
paddd  %xmm1,%xmm0
movdqu %xmm0,(%rax,%rsi,1)
add    $0x10,%rsi
cmp    %r9,0x28(%rsp)
ja     5174 <gsl_matrix_int_add+0xe4>
cmp    %rdx,%r15
je     51d2 <gsl_matrix_int_add+0x142>
lea    (%r15,%r11,1),%rax
lea    (%r15,%rbx,1),%rcx
mov    (%r8,%rcx,4),%ecx
add    %ecx,(%rdi,%rax,4)
cmp    %r12,%rdx
jbe    51d2 <gsl_matrix_int_add+0x142>
lea    (%r12,%r11,1),%rax
lea    (%r12,%rbx,1),%rcx
mov    (%r8,%rcx,4),%ecx
add    %ecx,(%rdi,%rax,4)
cmp    %rbp,%rdx
jbe    51d2 <gsl_matrix_int_add+0x142>
lea    (%r11,%rbp,1),%rax
lea    (%rbx,%rbp,1),%rcx
mov    (%r8,%rcx,4),%ecx
add    %ecx,(%rdi,%rax,4)
add    $0x1,%r10
add    0x10(%rsp),%r13
add    0x18(%rsp),%r14
add    (%rsp),%r11
add    0x8(%rsp),%rbx
cmp    0x20(%rsp),%r10
je     5248 <gsl_matrix_int_add+0x1b8>
test   %rdx,%rdx
je     51d2 <gsl_matrix_int_add+0x142>
mov    0x30(%rsp),%rax
mov    0x18(%rax),%rdi
mov    0x38(%rsp),%rax
mov    0x18(%rax),%r8
lea    (%rdi,%r13,1),%rax
lea    (%r8,%r14,1),%rcx
lea    0x10(%rcx),%rsi
cmp    %rsi,%rax
lea    0x10(%rax),%rsi
setae  %r9b
cmp    %rsi,%rcx
setae  %sil
or     %sil,%r9b
jne    5160 <gsl_matrix_int_add+0xd0>
xor    %esi,%esi
mov    (%rcx,%rsi,4),%edi
add    %edi,(%rax,%rsi,4)
add    $0x1,%rsi
cmp    %rdx,%rsi
jne    5230 <gsl_matrix_int_add+0x1a0>
jmp    51d2 <gsl_matrix_int_add+0x142>
nopl   0x0(%rax)
xor    %eax,%eax
jmpq   50c8 <gsl_matrix_int_add+0x38>
nop
<<<sep_in_sample>>>
gsl_matrix_int_add (gsl_matrix_int * a, const gsl_matrix_int * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 28, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] += b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 4
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 23
19 23
20 23
21 23
22 23
23 23
24 23
25 23
26 23
27 5
28 5
29 5
30 11
31 12
32 14
33 11
34 12
35 14
36 14
37 14
38 14
39 14
40 14
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 16
50 16
51 16
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 18
66 18
67 18
68 18
69 18
70 18
71 18
72 18
73 18
74 18
75 18
76 18
77 18
78 18
79 16
80 16
81 18
82 18
83 18
84 18
85 16
86 16
87 18
88 18
89 18
90 18
91 14
92 14
93 14
94 14
95 14
96 14
97 14
98 16
99 16
100 16
101 16
102 16
103 16
104 16
105 16
106 16
107 16
108 16
109 16
110 16
111 16
112 16
113 16
114 16
115 18
116 18
117 16
118 16
119 16
120 16
121 16
122 21
123 21
124 21
<<<sep_out_sample>>>
mov    %rsi,%rax
xor    %esi,%esi
cmpb   $0x2f,(%rdi)
sete   %sil
add    %rdi,%rsi
mov    %rax,%rdi
jmpq   17 <mu_folder_match+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_folder_match (const char *name, void *pattern, int flags)
{
  return fnmatch (pattern, name[0] == '/' ? name + 1 : name, flags);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0x40,%ecx
mov    $0x8,%esi
jmpq   782 <nettle_arctwo64_set_key+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_arctwo64_set_key (struct arctwo_ctx *ctx, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, 8, key, 64);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     55d0 <gsl_fft_complex_wavetable_free+0x30>
mov    0x410(%rdi),%rdi
callq  55b5 <gsl_fft_complex_wavetable_free+0x15>
movq   $0x0,0x410(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   55c9 <gsl_fft_complex_wavetable_free+0x29>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_wavetable_free (gsl_fft_complex_wavetable * wavetable)
{
  if (!wavetable) { return ; };
  free (wavetable->trig);
  wavetable->trig = ((void *)0);
  free (wavetable) ;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
unac_version(void)
{
  return "1.5.0";
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
mov    0x0(%rip),%rdx        # 30b <print_version_handler+0xb>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   317 <print_version_handler+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_version_handler (struct handler_param *param)
{
  fprintf (param->fp, "%s\n", gdbm_version);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     887 <mu_record_list_p+0x27>
mov    0x60(%rdi),%rcx
mov    $0x1,%al
test   %rcx,%rcx
je     887 <mu_record_list_p+0x27>
sub    $0x8,%rsp
callq  *%rcx
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
repz retq 
<<<sep_in_sample>>>
mu_record_list_p (mu_record_t record, const char *name, int flags)
{
  if (record == ((void *)0))
    return 22;
  return record == ((void *)0)
          || !record->_list_p
          || record->_list_p (record, name, flags);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 6
5 7
6 6
7 6
8 2
9 7
10 7
11 7
12 8
13 7
14 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
jmp    262 <jobserver_release+0x12>
nopl   (%rax)
callq  25d <jobserver_release+0xd>
cmpl   $0x4,(%rax)
jne    281 <jobserver_release+0x31>
mov    0x0(%rip),%edi        # 268 <jobserver_release+0x18>
mov    $0x1,%edx
mov    $0x0,%esi
callq  277 <jobserver_release+0x27>
cmp    $0xffffffff,%eax
je     258 <jobserver_release+0x8>
cmp    $0x1,%eax
je     298 <jobserver_release+0x48>
test   %ebx,%ebx
jne    29a <jobserver_release+0x4a>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   295 <jobserver_release+0x45>
nopl   (%rax)
pop    %rbx
retq   
mov    $0x0,%edi
callq  2a4 <jobserver_release+0x54>
mov    %rax,%rdi
callq  2ac <jobserver_release+0x5c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
jobserver_release (int is_fatal)
{
  int r;
  while (((r)=write (job_fds[1], &token, 1))==-1 && (*__errno_location ())==4);
  if (r != 1)
    {
      if (is_fatal)
        pfatal_with_name (gettext ("write jobserver"));
      perror_with_name ("write", "");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 11
19 9
20 9
21 9
22 9
23 11
24 11
25 8
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
push   %r13
movslq %edi,%rdi
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 747 <_hs_append_history_line+0x17>
mov    (%rax,%rdi,8),%rbp
mov    0x0(%rbp),%r12
mov    %r12,%rdi
callq  757 <_hs_append_history_line+0x27>
mov    %r13,%rdi
mov    %rax,%rbx
callq  762 <_hs_append_history_line+0x32>
lea    0x2(%rbx,%rax,1),%rsi
mov    %r12,%rdi
callq  76f <_hs_append_history_line+0x3f>
test   %rax,%rax
je     7a0 <_hs_append_history_line+0x70>
mov    %rax,0x0(%rbp)
movb   $0xa,(%rax,%rbx,1)
mov    %r13,%rsi
mov    0x0(%rbp),%rax
add    $0x8,%rsp
lea    0x1(%rax,%rbx,1),%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   797 <_hs_append_history_line+0x67>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_hs_append_history_line (which, line)
     int which;
     const char *line;
{
  HIST_ENTRY *hent;
  size_t newlen, curlen;
  char *newline;
  hent = the_history[which];
  curlen = strlen (hent->line);
  newlen = curlen + strlen (line) + 2;
  newline = realloc (hent->line, newlen);
  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 4
4 4
5 4
6 4
7 4
8 8
9 8
10 9
11 9
12 9
13 10
14 9
15 10
16 10
17 11
18 11
19 12
20 12
21 14
22 15
23 16
24 16
25 18
26 16
27 18
28 18
29 18
30 18
31 16
32 16
33 18
34 18
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
mov    0x3880(%rdi),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_get_discmode_image (void *p_user_data)
{
  _img_private_t *p_env = p_user_data;
  return p_env->disc_mode;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     6b0 <mu_acl_count+0x10>
mov    0x8(%rdi),%rdi
jmpq   6ae <mu_acl_count+0xe>
xchg   %ax,%ax
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_acl_count (mu_acl_t acl, size_t *pcount)
{
  if (!acl)
    return 22;
  return mu_list_count (acl->aclist, pcount);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    (%rcx),%rax
cmp    0x8(%rcx),%rax
je     10f0 <gsl_blas_strmv+0x30>
mov    $0x14,%ecx
mov    $0x320,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10e6 <gsl_blas_strmv+0x26>
mov    $0x14,%eax
add    $0x28,%rsp
retq   
cmp    (%r8),%rax
je     1120 <gsl_blas_strmv+0x60>
mov    $0x13,%ecx
mov    $0x324,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  110e <gsl_blas_strmv+0x4e>
mov    $0x13,%eax
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%r8),%r10
mov    0x18(%rcx),%r9
mov    %r10d,0x10(%rsp)
mov    0x10(%r8),%r8
mov    %r8,0x8(%rsp)
mov    0x10(%rcx),%rcx
mov    %eax,%r8d
mov    %ecx,(%rsp)
mov    %edx,%ecx
mov    %esi,%edx
mov    %edi,%esi
mov    $0x65,%edi
callq  1150 <gsl_blas_strmv+0x90>
xor    %eax,%eax
jmp    10eb <gsl_blas_strmv+0x2b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 800, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (N != X->size)
    {
      do { gsl_error ("invalid length", "blas.c", 804, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_strmv (CblasRowMajor, Uplo, TransA, Diag, ((int)(N)), A->data,
               ((int)(A->tda)), X->data, ((int)(X->stride)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 18
12 18
13 11
14 11
15 13
16 13
17 13
18 13
19 13
20 13
21 18
22 18
23 18
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 17
38 17
39 17
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_mset (rec_rset_t rset)
{
  return rset->mset;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%ecx
mov    0x4(%rdi),%edx
mov    0x8(%rdi),%rsi
mov    %ecx,%eax
mov    %edx,%r9d
lea    (%rdi,%rax,8),%r8
mov    0x10(%r8),%rax
sub    0x10(%rdi,%r9,8),%rax
lea    0x1000000(%rax),%r9
test   %rax,%rax
cmovs  %r9,%rax
lea    -0x1(%rcx),%r9d
test   %ecx,%ecx
mov    %rax,0x10(%r8)
mov    $0x60,%r8d
mov    %r9d,%ecx
cmove  %r8d,%ecx
test   %edx,%edx
mov    %ecx,(%rdi)
lea    -0x1(%rdx),%ecx
mov    %rsi,%rdx
cmovne %ecx,%r8d
sub    $0x74cbb1,%rdx
mov    %r8d,0x4(%rdi)
js     80 <ranmar_get+0x80>
sub    %rdx,%rax
mov    %rdx,0x8(%rdi)
js     70 <ranmar_get+0x70>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1000000,%rax
retq   
nopw   0x0(%rax,%rax,1)
lea    0x8b344c(%rsi),%rdx
jmp    5b <ranmar_get+0x5b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ranmar_get (void *vstate)
{
  ranmar_state_t *state = (ranmar_state_t *) vstate;
  unsigned int i = state->i;
  unsigned int j = state->j;
  long int carry = state->carry;
  long int delta = state->u[i] - state->u[j];
  if (delta < 0)
    delta += two24 ;
  state->u[i] = delta;
  if (i == 0)
    {
      i = 96;
    }
  else
    {
      i--;
    }
  state->i = i;
  if (j == 0)
    {
      j = 96;
    }
  else
    {
      j--;
    }
  state->j = j;
  carry += - 7654321 ;
  if (carry < 0)
    carry += two24 - 3;
  state->carry = carry ;
  delta += - carry ;
  if (delta < 0)
    delta += two24 ;
  return delta;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 17
13 17
14 10
15 17
16 17
17 17
18 26
19 19
20 26
21 30
22 26
23 30
24 28
25 30
26 34
27 32
28 34
29 37
30 37
31 35
32 37
33 37
34 31
35 31
36 31
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9a6 <set_dollar_vars_changed+0x6>
test   %eax,%eax
jne    9c0 <set_dollar_vars_changed+0x20>
cmpq   $0x0,0x0(%rip)        # 9b5 <set_dollar_vars_changed+0x15>
je     9d0 <set_dollar_vars_changed+0x30>
orl    $0x1,0x0(%rip)        # 9be <set_dollar_vars_changed+0x1e>
retq   
nop
orl    $0x2,0x0(%rip)        # 9c7 <set_dollar_vars_changed+0x27>
retq   
nopl   0x0(%rax,%rax,1)
orl    $0x4,0x0(%rip)        # 9d7 <set_dollar_vars_changed+0x37>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_dollar_vars_changed ()
{
  if (variable_context)
    changed_dollar_vars |= 0x02;
  else if (this_shell_builtin == set_builtin)
    changed_dollar_vars |= 0x04;
  else
    changed_dollar_vars |= 0x01;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 8
7 8
8 8
9 4
10 4
11 4
12 6
13 6
14 6
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    (%rax),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     23 <__gmpz_fits_sint_p+0x23>
cmp    $0x1,%rdx
je     40 <__gmpz_fits_sint_p+0x40>
xor    %eax,%eax
cmp    $0xffffffffffffffff,%rdx
je     28 <__gmpz_fits_sint_p+0x28>
repz retq 
nopl   (%rax)
mov    $0x80000000,%eax
cmp    %rax,%rcx
setbe  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
cmp    $0x7fffffff,%rcx
setbe  %al
retq   
<<<sep_in_sample>>>
__gmpz_fits_sint_p (mpz_srcptr z)
{
  mp_size_t n = ((z)->_mp_size);
  mp_ptr p = ((z)->_mp_d);
  mp_limb_t limb = p[0];
  if (n == 0)
    return 1;
  if (n == 1)
    return limb <= 2147483647;
  if (n == -1)
    return limb <= (- (((mp_limb_t) (((-2147483647 - 1)) + 1)) - 1));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 6
6 6
7 8
8 8
9 12
10 10
11 10
12 13
13 13
14 11
15 11
16 11
17 11
18 13
19 13
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
movl   $0x5,0x0(%rip)        # 10fa <verbatim+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
verbatim (void)
{
  (yy_start) = 1 + 2 * (2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # e07 <mu_locker_set_default_retry_count+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_locker_set_default_retry_count (size_t n)
{
  mu_locker_retry_count = n;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%esi
cmp    $0x1c,%esi
je     50 <CDB___lock_ohash+0x10>
mov    (%rdi),%rdi
jmpq   50 <CDB___lock_ohash+0x10>
mov    (%rdi),%rax
movzbl 0x4(%rax),%edx
xor    (%rax),%dl
mov    %dl,-0xc(%rsp)
movzbl 0x5(%rax),%edx
xor    0x1(%rax),%dl
mov    %dl,-0xb(%rsp)
movzbl 0x6(%rax),%edx
xor    0x2(%rax),%dl
mov    %dl,-0xa(%rsp)
movzbl 0x7(%rax),%edx
xor    0x3(%rax),%dl
mov    %dl,-0x9(%rsp)
mov    -0xc(%rsp),%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___lock_ohash(dbt)
 const DBT *dbt;
{
 if (dbt->size == sizeof(DB_LOCK_ILOCK))
  { u_int32_t __h; u_int8_t *__cp, *__hp; __hp = (u_int8_t *)&__h; __cp = (u_int8_t *)(dbt->data); __hp[0] = __cp[0] ^ __cp[4]; __hp[1] = __cp[1] ^ __cp[5]; __hp[2] = __cp[2] ^ __cp[6]; __hp[3] = __cp[3] ^ __cp[7]; return (__h); };
 return (CDB___ham_func5(dbt->data, dbt->size));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_body (MESSAGE msg)
{
  return msg->body;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # d7 <nettle_eax_aes128_digest+0x7>
mov    %rdi,%rax
mov    %rdx,%r9
lea    0x60(%rdi),%rdx
lea    0x20(%rdi),%rdi
mov    %rsi,%r8
mov    %rax,%rsi
jmpq   f0 <nettle_eax_aes128_digest+0x20>
<<<sep_in_sample>>>
nettle_eax_aes128_digest(struct eax_aes128_ctx *ctx,
    size_t length, uint8_t *digest)
{
  (0 ? (nettle_aes128_encrypt) (&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_eax_digest (&(ctx)->eax, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (digest)));
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    ed8 <gsl_matrix_long_double_column+0x38>
shl    $0x4,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  efa <gsl_matrix_long_double_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_column (gsl_matrix_long_double * m, const size_t j)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
jmp    831 <window_mark_chain+0x11>
nopw   0x0(%rax,%rax,1)
or     %esi,0x98(%rdi)
mov    (%rdi),%rdi
test   %rdi,%rdi
jne    828 <window_mark_chain+0x8>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
window_mark_chain (WINDOW *chain, int flag)
{
  register WINDOW *win;
  for (win = chain; win; win = win->next)
    win->flags |= flag;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 4
5 4
6 4
7 4
8 4
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_generic_param_set_value (osip_generic_param_t * fparam, char *value)
{
  fparam->gvalue = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
je     1e3 <gss_compare_name+0x13>
movl   $0x0,(%rdi)
test   %rbx,%rbx
jne    1f8 <gss_compare_name+0x28>
mov    $0x1020000,%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %rdx,%rdx
je     1e8 <gss_compare_name+0x18>
mov    0x10(%rdx),%rsi
mov    0x10(%rbx),%rdi
mov    %rcx,0x8(%rsp)
mov    %rdx,(%rsp)
callq  213 <gss_compare_name+0x43>
mov    %eax,%esi
mov    (%rsp),%rdx
mov    $0x30000,%eax
test   %esi,%esi
mov    0x8(%rsp),%rcx
je     1ed <gss_compare_name+0x1d>
test   %rcx,%rcx
je     23c <gss_compare_name+0x6c>
mov    (%rbx),%r8
xor    %eax,%eax
cmp    (%rdx),%r8
je     240 <gss_compare_name+0x70>
mov    %eax,(%rcx)
xor    %eax,%eax
jmp    1ed <gss_compare_name+0x1d>
xor    %eax,%eax
jmp    1ed <gss_compare_name+0x1d>
mov    0x8(%rdx),%rsi
mov    0x8(%rbx),%rdi
mov    %r8,%rdx
mov    %rcx,(%rsp)
callq  254 <gss_compare_name+0x84>
test   %eax,%eax
mov    (%rsp),%rcx
sete   %al
movzbl %al,%eax
jmp    236 <gss_compare_name+0x66>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_compare_name (OM_uint32 * minor_status,
    const gss_name_t name1,
    const gss_name_t name2, int *name_equal)
{
  if (minor_status)
    *minor_status = 0;
  if (!name1 || !name2)
    return (2ul << 16) | (1ul << 24);
  if (!gss_oid_equal (name1->type, name2->type))
    return (3ul << 16);
  if (name_equal)
    *name_equal = (name1->length == name2->length) &&
      memcmp (name1->value, name2->value, name1->length) == 0;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 7
8 7
9 8
10 15
11 15
12 15
13 15
14 7
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 9
25 9
26 9
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 14
37 14
38 13
39 13
40 13
41 13
42 13
43 12
44 12
45 12
46 12
47 12
48 12
<<<sep_out_sample>>>
mov    %rdi,%rsi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  4c1 <exec_fatal+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exec_fatal (char const *name)
{
  call_arg_fatal ("exec", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
mov    %rdx,(%rsp)
mov    $0x0,%esi
mov    %rsp,%rdx
callq  1ea <message_append_text_file+0x1a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
message_append_text_file (MESSAGE msg, char *filename, char *prefix)
{
  struct append_closure clos;
  clos.filename = filename;
  clos.prefix = prefix;
  message_proc_body (msg, _append_proc, &clos);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 6
6 6
7 7
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  6e <rk2_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  7c <rk2_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  8a <rk2_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  98 <rk2_reset+0x48>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk2_reset (void *vstate, size_t dim)
{
  rk2_state_t *state = (rk2_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_opaque (osip_authentication_info_t *
       authentication_info, char *opaque)
{
  authentication_info->opaque = (char *) opaque;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
callq  a0ad <program_name_from_file_name+0xd>
mov    %rax,%rdi
callq  a0b5 <program_name_from_file_name+0x15>
mov    %rax,%rdi
mov    %rax,%r14
callq  a0c0 <program_name_from_file_name+0x20>
lea    -0x1(%rax),%ebp
test   %ebp,%ebp
jle    a123 <program_name_from_file_name+0x83>
movslq %ebp,%rbx
mov    $0x5,%r12d
mov    $0x4,%r13d
add    %r14,%rbx
jmp    a0e9 <program_name_from_file_name+0x49>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%rbx
sub    $0x1,%ebp
je     a123 <program_name_from_file_name+0x83>
cmpb   $0x2e,(%rbx)
jne    a0e0 <program_name_from_file_name+0x40>
mov    $0x0,%edi
mov    %rbx,%rsi
mov    %r12,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     a120 <program_name_from_file_name+0x80>
mov    $0x0,%edi
mov    %rbx,%rsi
mov    %r13,%rcx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     a120 <program_name_from_file_name+0x80>
callq  a111 <program_name_from_file_name+0x71>
movsbq 0x1(%rbx),%rdx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rdx,2)
je     a0e0 <program_name_from_file_name+0x40>
movb   $0x0,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14,%rax
pop    %r14
retq   
nop
<<<sep_in_sample>>>
program_name_from_file_name (char *file_name)
{
  int i;
  char *program_name = xstrdup (filename_non_directory (file_name));
  for (i = strlen (program_name) - 1; i > 0; i--)
    if (program_name[i] == '.'
        && (strncmp (program_name + i, ".info", 5) == 0
            || strncmp (program_name + i, ".inf", 4) == 0
            || ((*__ctype_b_loc ())[(int) ((program_name[i + 1]))] & (unsigned short int) _ISdigit)))
      {
        program_name[i] = 0;
        break;
      }
  return program_name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 4
11 5
12 5
13 5
14 5
15 5
16 7
17 8
18 8
19 8
20 8
21 8
22 5
23 5
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 8
32 8
33 8
34 8
35 8
36 9
37 9
38 9
39 9
40 9
41 11
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x40(%rdi),%rdi
callq  317d <mbox_cleanup+0xd>
mov    0x18(%rbx),%rdi
pop    %rbx
jmpq   3187 <mbox_cleanup+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_cleanup (void *arg)
{
  mu_mailbox_t mailbox = arg;
  mu_monitor_unlock (mailbox->monitor);
  mu_locker_unlock (mailbox->locker);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     e52 <xargs_close+0x62>
cmpq   $0x0,0x8(%rdi)
mov    0x20(%rdi),%ebp
jne    e39 <xargs_close+0x49>
mov    (%rdi),%rdi
callq  e10 <xargs_close+0x20>
mov    0x10(%rbx),%rdi
callq  e19 <xargs_close+0x29>
cmpl   $0x1,0x24(%rbx)
jne    e28 <xargs_close+0x38>
mov    0x58(%rbx),%rdi
callq  e28 <xargs_close+0x38>
mov    %rbx,%rdi
callq  e30 <xargs_close+0x40>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%ecx
mov    $0x1dc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e52 <xargs_close+0x62>
mov    $0x0,%ecx
mov    $0x1da,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e6b <xargs_close+0x7b>
<<<sep_in_sample>>>
xargs_close(XARGS *xp)
{
 int count;
 ((xp != ((void *)0)) ? (void) (0) : __assert_fail ("xp != ((void *)0)", "xargs.c", 474, __PRETTY_FUNCTION__));
 count = xp->seqno;
 ((xp->pipe == ((void *)0)) ? (void) (0) : __assert_fail ("xp->pipe == ((void *)0)", "xargs.c", 476, __PRETTY_FUNCTION__));
 free(xp->command);
 strbuf_close(xp->result);
 switch (xp->type) {
 case 1:
  strbuf_close(xp->path);
  break;
 case 2:
 case 3:
  break;
 }
 free(xp);
 return count;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 5
9 6
10 7
11 7
12 8
13 8
14 9
15 9
16 11
17 11
18 17
19 17
20 19
21 19
22 19
23 19
24 19
25 6
26 6
27 6
28 6
29 6
30 4
31 4
32 4
33 4
34 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
movabs $0xcccccccccccccccd,%r8
mov    %fs:0x28,%rax
mov    %rax,0x18(%rsp)
xor    %eax,%eax
lea    0x14(%rsp),%rcx
movb   $0x0,0x14(%rsp)
nopl   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
mul    %r8
shr    $0x3,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    350 <print_rlimtype+0x30>
test   %esi,%esi
mov    $0x0,%eax
mov    $0x0,%edx
cmove  %rax,%rdx
mov    %rcx,%rsi
xor    %eax,%eax
mov    $0x0,%edi
callq  395 <print_rlimtype+0x75>
mov    0x18(%rsp),%rax
xor    %fs:0x28,%rax
jne    3aa <print_rlimtype+0x8a>
add    $0x28,%rsp
retq   
nopw   0x0(%rax,%rax,1)
callq  3b5 <print_rlimtype+0x95>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_rlimtype (n, addnl)
     rlim_t n;
     int addnl;
{
  char s[((sizeof (rlim_t) * 8 - (! ((rlim_t) 0 < (rlim_t) -1))) * 302 / 1000 + 1 + (! ((rlim_t) 0 < (rlim_t) -1))) + 1], *p;
  p = s + sizeof(s);
  *--p = '\0';
  if (n < 0)
    {
      do
 *--p = '0' - n % 10;
      while ((n /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + n % 10;
      while ((n /= 10) != 0);
    }
  printf ("%s%s", p, addnl ? "\n" : "");
}
<<<sep_in_sample>>>
1 4
2 18
3 4
4 4
5 4
6 7
7 7
8 7
9 18
10 18
11 18
12 18
13 18
14 18
15 18
16 18
17 19
18 18
19 19
20 19
21 21
22 21
23 21
24 21
25 21
26 21
27 21
28 21
29 22
30 22
31 22
32 22
33 22
34 22
35 22
36 22
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 91a <gsl_matrix_ptr+0xa>
test   %eax,%eax
je     929 <gsl_matrix_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    940 <gsl_matrix_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    960 <gsl_matrix_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  959 <gsl_matrix_ptr+0x49>
xor    %eax,%eax
jmp    939 <gsl_matrix_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  979 <gsl_matrix_ptr+0x69>
xor    %eax,%eax
jmp    939 <gsl_matrix_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_double.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_double.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (double *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
cmp    $0xffffffff,%edi
je     ec <rec_buf_putc+0x2c>
mov    0x10(%rsi),%rcx
mov    %rsi,%rbx
mov    0x8(%rsi),%rsi
lea    0x1(%rcx),%rdx
cmp    %rsi,%rdx
ja     f8 <rec_buf_putc+0x38>
mov    (%rbx),%rax
mov    %rdx,0x10(%rbx)
mov    %bpl,(%rax,%rcx,1)
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    (%rbx),%rdi
add    $0x200,%rsi
mov    %rsi,0x8(%rbx)
callq  10b <rec_buf_putc+0x4b>
mov    %rax,%rsi
mov    %rax,(%rbx)
mov    $0xffffffff,%eax
test   %rsi,%rsi
je     ee <rec_buf_putc+0x2e>
mov    0x10(%rbx),%rcx
mov    %rsi,%rax
lea    0x1(%rcx),%rdx
jmp    e4 <rec_buf_putc+0x24>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_putc (int c, rec_buf_t buf)
{
  unsigned int ret;
  if (c == (-1))
    {
      return (-1);
    }
  ret = (unsigned int) c;
  if ((buf->used + 1) > buf->size)
    {
      buf->size = buf->size + 512;
      buf->data = realloc (buf->data, buf->size);
      if (!buf->data)
        {
          ret = (-1);
        }
    }
  if (ret != (-1))
    {
      buf->data[buf->used++] = (char) c;
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 20
15 20
16 20
17 23
18 23
19 23
20 23
21 23
22 12
23 11
24 11
25 12
26 12
27 12
28 12
29 13
30 13
31 13
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     258 <gsl_spline2d_free+0x38>
mov    (%rdi),%rax
mov    0x50(%rax),%rax
test   %rax,%rax
je     23b <gsl_spline2d_free+0x1b>
mov    0x38(%rdi),%rdi
callq  *%rax
mov    0x40(%rbx),%rdi
test   %rdi,%rdi
je     249 <gsl_spline2d_free+0x29>
callq  249 <gsl_spline2d_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   252 <gsl_spline2d_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline2d_free(gsl_spline2d * interp)
{
  if (!interp) { return ; };
  if (interp->interp_object.type->free)
    interp->interp_object.type->free(interp->interp_object.state);
  if (interp->xarr)
    free(interp->xarr);
  free(interp);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 6
13 6
14 7
15 8
16 9
17 8
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
callq  11 <_icvt_get_transport2+0x11>
test   %rbp,%rbp
je     1d <_icvt_get_transport2+0x1d>
mov    (%rax),%rax
mov    %rax,0x0(%rbp)
cmpq   $0x0,(%rbx)
je     2a <_icvt_get_transport2+0x2a>
movq   $0x0,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_icvt_get_transport2 (mu_stream_t stream,
       mu_transport_t *pt, mu_transport_t *pt2)
{
  struct icvt_stream *s = mu_stream_get_owner (stream);
  if (pt)
    *pt = s->stream;
  if (*pt2)
    *pt2 = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 10
15 10
16 10
17 10
18 10
19 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
test   %rdi,%rdi
je     828 <putabranch+0x168>
mov    0x60(%rdi),%r12
mov    %rsi,%rbp
test   %r12,%r12
je     807 <putabranch+0x147>
mov    0x60(%r12),%r13
test   %r13,%r13
je     7f7 <putabranch+0x137>
mov    0x60(%r13),%r14
test   %r14,%r14
je     7e7 <putabranch+0x127>
mov    0x60(%r14),%r15
test   %r15,%r15
je     7d7 <putabranch+0x117>
mov    0x60(%r15),%rax
test   %rax,%rax
je     7c7 <putabranch+0x107>
mov    0x60(%rax),%r8
test   %r8,%r8
je     7b7 <putabranch+0xf7>
mov    0x60(%r8),%r9
test   %r9,%r9
je     79f <putabranch+0xdf>
mov    0x60(%r9),%r10
test   %r10,%r10
je     77d <putabranch+0xbd>
mov    0x60(%r10),%rdi
mov    %r9,0x18(%rsp)
mov    %r8,0x10(%rsp)
mov    %rax,0x8(%rsp)
mov    %r10,(%rsp)
callq  6c0 <putabranch>
mov    (%rsp),%r10
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r10,%rsi
mov    %r10,%rdi
callq  370 <putadelta>
mov    0x18(%rsp),%r9
mov    0x10(%rsp),%r8
mov    0x8(%rsp),%rax
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r9,%rsi
mov    %r9,%rdi
mov    %r8,0x8(%rsp)
mov    %rax,(%rsp)
callq  370 <putadelta>
mov    0x8(%rsp),%r8
mov    (%rsp),%rax
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r8,%rsi
mov    %r8,%rdi
mov    %rax,(%rsp)
callq  370 <putadelta>
mov    (%rsp),%rax
mov    %rbp,%rcx
xor    %edx,%edx
mov    %rax,%rsi
mov    %rax,%rdi
callq  370 <putadelta>
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r15,%rsi
mov    %r15,%rdi
callq  370 <putadelta>
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r14,%rsi
mov    %r14,%rdi
callq  370 <putadelta>
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r13,%rsi
mov    %r13,%rdi
callq  370 <putadelta>
mov    %rbp,%rcx
xor    %edx,%edx
mov    %r12,%rsi
mov    %r12,%rdi
callq  370 <putadelta>
add    $0x28,%rsp
mov    %rbx,%rsi
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rcx
xor    %edx,%edx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   370 <putadelta>
nopl   (%rax)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
putabranch (struct delta const *root, const char *insDelFormat)
{
  if (!root)
    return;
  putabranch (root->ilk, insDelFormat);
  putadelta (root, root, 0, insDelFormat);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 5
12 5
13 3
14 3
15 5
16 3
17 3
18 5
19 3
20 3
21 5
22 3
23 3
24 5
25 3
26 3
27 5
28 3
29 3
30 5
31 3
32 3
33 5
34 3
35 3
36 5
37 5
38 5
39 5
40 5
41 5
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 6
62 6
63 6
64 6
65 6
66 6
67 6
68 6
69 6
70 6
71 6
72 6
73 6
74 6
75 6
76 6
77 6
78 6
79 6
80 6
81 6
82 6
83 6
84 6
85 6
86 6
87 6
88 6
89 6
90 6
91 6
92 7
93 6
94 6
95 7
96 6
97 6
98 7
99 7
100 7
101 7
102 7
103 6
104 6
105 7
106 7
107 7
108 7
109 7
110 7
111 7
112 7
113 7
<<<sep_out_sample>>>
test   %edx,%edx
jle    48 <cblas_isamax+0x48>
test   %edi,%edi
jle    48 <cblas_isamax+0x48>
movslq %edx,%rdx
xor    %ecx,%ecx
xor    %eax,%eax
shl    $0x2,%rdx
xorps  %xmm1,%xmm1
movss  0x0(%rip),%xmm3        # 1e <cblas_isamax+0x1e>
jmp    23 <cblas_isamax+0x23>
movaps %xmm2,%xmm1
movss  (%rsi),%xmm0
andps  %xmm3,%xmm0
ucomiss %xmm1,%xmm0
movaps %xmm0,%xmm2
maxss  %xmm1,%xmm2
cmova  %rcx,%rax
add    $0x1,%rcx
add    %rdx,%rsi
cmp    %ecx,%edi
jg     20 <cblas_isamax+0x20>
repz retq 
nopl   (%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
cblas_isamax (const int N, const float *X, const int incX)
{
{
  float max = 0.0;
  int ix = 0;
  int i;
  size_t result = 0;
  if (incX <= 0) {
    return 0;
  }
  for (i = 0; i < N; i++) {
    if (fabs(X[ix]) > max) {
      max = fabs(X[ix]);
      result = i;
    }
    ix += incX;
  }
  return result;
}
}
<<<sep_in_sample>>>
1 8
2 8
3 11
4 11
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 11
22 11
23 20
24 20
25 9
26 20
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_len (Buffer *buffer)
{
  return buffer->len;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,0x28(%rdi)
mov    0x30(%rdi),%rdi
callq  421 <rec_field_set_char_location+0x11>
mov    0x28(%rbx),%rdx
lea    0x30(%rbx),%rdi
xor    %eax,%eax
mov    $0x0,%esi
callq  435 <rec_field_set_char_location+0x25>
cmp    $0xffffffff,%eax
setne  %al
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rec_field_set_char_location (rec_field_t field,
                             size_t location)
{
  field->char_location = location;
  free (field->char_location_str);
  return (rpl_asprintf (&(field->char_location_str), "%zu", field->char_location)
          != -1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   613 <gsl_vector_uchar_fread+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_fread (FILE * stream, gsl_vector_uchar * v)
{
  int status = gsl_block_uchar_raw_fread (stream,
                                                v->data,
                                                v->size,
                                                v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     a2f <gsl_vector_ulong_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a25 <gsl_vector_ulong_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
shl    $0x3,%r10
shl    $0x3,%r9
xor    %ecx,%ecx
test   %r8,%r8
je     a5b <gsl_vector_ulong_swap+0x6b>
xchg   %ax,%ax
mov    (%rdx),%rsi
mov    (%rax),%rdi
add    $0x1,%rcx
mov    %rdi,(%rdx)
mov    %rsi,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    a40 <gsl_vector_ulong_swap+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_ulong_swap (gsl_vector_ulong * v, gsl_vector_ulong * w)
{
  unsigned long * d1 = v->data ;
  unsigned long * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          unsigned long tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 23
18 23
19 13
20 13
21 13
22 13
23 17
24 18
25 13
26 18
27 19
28 19
29 19
30 13
31 13
32 22
33 23
34 23
<<<sep_out_sample>>>
test   %rdx,%rdx
je     4c6 <gsl_stats_ulong_absdev_m+0x96>
shl    $0x3,%rsi
xor    %eax,%eax
xorpd  %xmm2,%xmm2
movsd  0x0(%rip),%xmm3        # 44b <gsl_stats_ulong_absdev_m+0x1b>
jmp    46d <gsl_stats_ulong_absdev_m+0x3d>
nopl   (%rax)
cvtsi2sd %rcx,%xmm1
subsd  %xmm0,%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
je     490 <gsl_stats_ulong_absdev_m+0x60>
mov    (%rdi),%rcx
test   %rcx,%rcx
jns    450 <gsl_stats_ulong_absdev_m+0x20>
mov    %rcx,%r8
and    $0x1,%ecx
shr    %r8
or     %rcx,%r8
cvtsi2sd %r8,%xmm1
addsd  %xmm1,%xmm1
jmp    455 <gsl_stats_ulong_absdev_m+0x25>
nopl   0x0(%rax)
test   %rax,%rax
js     4a8 <gsl_stats_ulong_absdev_m+0x78>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    495 <gsl_stats_ulong_absdev_m+0x65>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_ulong_absdev_m (const unsigned long data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 6
6 6
7 6
8 6
9 10
10 10
11 8
12 8
13 8
14 10
15 11
16 8
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 13
29 13
30 13
31 13
32 13
33 15
34 15
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 15
44 6
45 6
46 6
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x20(%rdi)
je     556 <hash_get_first+0x36>
mov    (%rdi),%rdx
mov    0x8(%rdi),%rcx
cmp    %rcx,%rdx
jb     549 <hash_get_first+0x29>
jmp    55d <hash_get_first+0x3d>
nopl   0x0(%rax)
add    $0x10,%rdx
cmp    %rcx,%rdx
jae    55d <hash_get_first+0x3d>
mov    (%rdx),%rax
test   %rax,%rax
je     540 <hash_get_first+0x20>
add    $0x8,%rsp
retq   
xor    %eax,%eax
add    $0x8,%rsp
retq   
callq  562 <hash_get_first+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_first (const Hash_table *table)
{
  struct hash_entry const *bucket;
  if (table->n_entries == 0)
    return ((void *)0);
  for (bucket = table->bucket; ; bucket++)
    if (! (bucket < table->bucket_limit))
      abort ();
    else if (bucket->data)
      return bucket->data;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 7
6 7
7 7
8 7
9 7
10 6
11 7
12 7
13 9
14 9
15 9
16 11
17 11
18 5
19 11
20 11
21 8
22 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1c6 <gsl_vector_complex_long_double_set+0x6>
test   %eax,%eax
je     1cf <gsl_vector_complex_long_double_set+0xf>
cmp    %rsi,(%rdi)
jbe    210 <gsl_vector_complex_long_double_set+0x50>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rdx
mov    0x8(%rsp),%rcx
shl    $0x5,%rax
imul   %rsi,%rax
mov    %rcx,(%rdx,%rax,1)
mov    0x10(%rsp),%rcx
mov    %rcx,0x8(%rdx,%rax,1)
mov    0x18(%rsp),%rcx
mov    %rcx,0x10(%rdx,%rax,1)
mov    0x20(%rsp),%rcx
mov    %rcx,0x18(%rdx,%rax,1)
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xd4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   229 <gsl_vector_complex_long_double_set+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_complex_long_double_set (gsl_vector_complex_long_double * v,
                              const size_t i, gsl_complex_long_double z)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_long_double.h", 212, GSL_EINVAL) ; return ; } while (0);
    }
  *((gsl_complex_long_double*)&((v)->data[2*(i)*(v)->stride])) = z;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 6
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_container (rec_record_t record)
{
  return record->container;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0xb8,%rdi
callq  10a0 <sdp_message_m_port_get+0x10>
test   %rax,%rax
je     10b0 <sdp_message_m_port_get+0x20>
mov    0x8(%rax),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
xor    %eax,%eax
jmp    10a9 <sdp_message_m_port_get+0x19>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_m_port_get (sdp_message_t * sdp, int pos_media)
{
  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return ((void *)0);
  return med->m_port;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 7
8 7
9 7
10 5
11 5
12 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   %rdi,%rdi
je     480 <parse_opt_set_metric+0x80>
testb  $0x1,0x9(%rbx)
jne    460 <parse_opt_set_metric+0x60>
xor    %edx,%edx
mov    %rsp,%rsi
mov    %rbp,%rdi
callq  424 <parse_opt_set_metric+0x24>
mov    %eax,0x4c(%rbx)
cmpb   $0x0,0x0(%rbp)
je     436 <parse_opt_set_metric+0x36>
mov    (%rsp),%rax
cmpb   $0x0,(%rax)
je     44f <parse_opt_set_metric+0x4f>
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  44f <parse_opt_set_metric+0x4f>
orl    $0x100,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    (%rbx),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  47b <parse_opt_set_metric+0x7b>
jmp    417 <parse_opt_set_metric+0x17>
nopl   (%rax)
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  49b <parse_opt_set_metric+0x9b>
jmpq   411 <parse_opt_set_metric+0x11>
<<<sep_in_sample>>>
parse_opt_set_metric (struct ifconfig *ifp, char *arg) { char *end; if (!ifp) error (1, 0, "no interface specified for %s `%s'\n", "metric value", arg); if (ifp->valid & 0x100) error (1, 0, "only one %s allowed for interface `%s'", "metric value", ifp->name); ifp->metric = strtol (arg, &end, 0); if (*arg == '\0' || *end != '\0') error (1, 0, "mtu value `%s' for interface `%s' is not a number", arg, ifp->name); ifp->valid |= 0x100; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
44 1
45 1
46 1
47 1
48 1
49 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
lea    -0x1(%rdi),%ebp
test   %ebp,%ebp
push   %rbx
jle    4a <main+0x4a>
lea    0x8(%rsi),%r12
mov    %ebp,%edi
mov    %r12,%rsi
callq  19 <main+0x19>
lea    0x1(%rax),%rdi
callq  22 <main+0x22>
test   %rax,%rax
mov    %rax,%rbx
je     60 <main+0x60>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rax,%rdi
callq  37 <main+0x37>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  48 <main+0x48>
jmp    40 <main+0x40>
mov    $0x0,%edi
callq  54 <main+0x54>
mov    $0x0,%edi
callq  5e <main+0x5e>
jmp    4a <main+0x4a>
mov    0x0(%rip),%rcx        # 67 <main+0x67>
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  7b <main+0x7b>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
main(int argc, char *argv[])
{
  char *msg;
  unsigned long l;
  argv++;
  argc--;
  if (argc > 0)
    {
      l = total_len(argc, argv);
      msg = malloc(l + 1u);
      if (((void *)0) == msg)
        {
          fprintf(stderr, "Ran out of memory.\n");
          return 1;
        }
      concat(msg, argc, argv);
      for (;;)
        puts(msg);
    }
  else
    {
      for (;;)
        puts("yes");
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 7
5 2
6 7
7 5
8 9
9 9
10 9
11 10
12 10
13 11
14 10
15 11
16 16
17 16
18 16
19 16
20 16
21 18
22 18
23 18
24 23
25 23
26 23
27 23
28 23
29 13
30 13
31 13
32 13
33 13
34 26
35 26
36 26
37 26
38 26
<<<sep_out_sample>>>
mov    (%rdi),%edx
mov    %rsi,%rax
mov    %edx,(%rsi)
mov    0x4(%rdi),%edx
mov    %edx,0x4(%rsi)
mov    0x8(%rdi),%edx
mov    %edx,0x8(%rsi)
mov    0xc(%rdi),%edx
mov    %edx,0xc(%rsi)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_md5_read_ctx (const struct mu_md5_ctx *ctx, void *resbuf)
{
  ((uint32_t *) resbuf)[0] = (ctx->A);
  ((uint32_t *) resbuf)[1] = (ctx->B);
  ((uint32_t *) resbuf)[2] = (ctx->C);
  ((uint32_t *) resbuf)[3] = (ctx->D);
  return resbuf;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 8
11 8
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
jmpq   3a0 <gsl_blas_icamax>
<<<sep_in_sample>>>
gsl_blas_idamax (const gsl_vector * X)
{
  return cblas_idamax (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     32 <lm_free+0x12>
callq  32 <lm_free+0x12>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     40 <lm_free+0x20>
callq  40 <lm_free+0x20>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     4e <lm_free+0x2e>
callq  4e <lm_free+0x2e>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     5c <lm_free+0x3c>
callq  5c <lm_free+0x3c>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     6a <lm_free+0x4a>
callq  6a <lm_free+0x4a>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     78 <lm_free+0x58>
callq  78 <lm_free+0x58>
mov    %rbx,%rdi
pop    %rbx
jmpq   81 <lm_free+0x61>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_free(void *vstate)
{
  lm_state_t *state = (lm_state_t *) vstate;
  if (state->workp)
    gsl_vector_free(state->workp);
  if (state->workn)
    gsl_vector_free(state->workn);
  if (state->fvv)
    gsl_vector_free(state->fvv);
  if (state->vel)
    gsl_vector_free(state->vel);
  if (state->acc)
    gsl_vector_free(state->acc);
  if (state->JTfvv)
    gsl_vector_free(state->JTfvv);
  free(state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 15
27 16
28 17
29 16
30 16
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  fd2 <wordsplit+0x12>
mov    %rbx,%rdi
mov    %rbp,%rdx
mov    %r12d,%ecx
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rsi
jmpq   fe7 <wordsplit+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit (const char *command, struct wordsplit *ws, int flags)
{
  return wordsplit_len (command, strlen (command), ws, flags);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 4
12 4
13 4
14 3
15 3
16 3
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   573 <gsl_vector_ushort_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fscanf (FILE * stream, gsl_vector_ushort * v)
{
  int status = gsl_block_ushort_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x18(%rsi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
<<<sep_in_sample>>>
__gmp_randinit_set (gmp_randstate_ptr dst, gmp_randstate_srcptr src)
{
  (*((gmp_randfnptr_t *) ((src)->_mp_algdata._mp_lc))->randiset_fn) (dst, src);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <font_entry_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <font_entry_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
font_entry_hash_2 (struct font_entry * entry)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((entry->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    (%rax),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
jmpq   147b <gsl_sort_vector2_long+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector2_long (gsl_vector_long * v1, gsl_vector_long * v2)
{
  gsl_sort2_long (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
cdio_have_os2 (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %esi,0x18(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_to_void (struct output * out, int forget)
{
  out->to_void = forget;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x38(%rdi),%rdi
jmpq   429 <gsl_multifit_fdfridge_residual+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_multifit_fdfridge_residual (const gsl_multifit_fdfridge * w)
{
  return gsl_multifit_fdfsolver_residual(w->s);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %edi,%esi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  10 <stackoverflow_handler>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <pair_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <pair_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
pair_hash_1 (struct pair *pair)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((pair->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    %rsi,%r8
mov    %rdx,%r9
mov    0x50(%rdi),%rcx
mov    0x48(%rdi),%rdx
mov    0x40(%rdi),%rsi
jmpq   317 <gsl_spline2d_eval_deriv_y+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline2d_eval_deriv_y(const gsl_spline2d * interp, const double x,
                          const double y, gsl_interp_accel * xa, gsl_interp_accel * ya)
{
  return gsl_interp2d_eval_deriv_y(&(interp->interp_object), interp->xarr, interp->yarr,
                                   interp->zarr, x, y, xa, ya);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
cmp    $0xffff4f0b,%edi
je     2d0 <cdio_lsn_to_lba+0x10>
lea    0x96(%rdi),%eax
retq   
nop
mov    %edi,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_lsn_to_lba (lsn_t lsn)
{
  if (-45301 == lsn) return -45301;
  return lsn + 150;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 3
7 5
8 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <hash_string_compare+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string_compare (void const *name1, void const *name2)
{
  return strcmp (name1, name2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <do_nothing+0xe>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_nothing(const char *name)
{
  (void) name;
  printf("stdin is buffered in the default way\n");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    (%rsi),%rdx
sub    $0x1,%rcx
sub    $0x1,%rdx
jmp    74 <printer_hash_cmp+0x14>
cmp    (%rdx),%al
jne    85 <printer_hash_cmp+0x25>
add    $0x1,%rcx
movzbl (%rcx),%eax
add    $0x1,%rdx
test   %al,%al
jne    70 <printer_hash_cmp+0x10>
xor    %eax,%eax
movzbl (%rdx),%edx
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_hash_cmp (struct printer *x, struct printer *y)
{
  do { int result; do { unsigned char const *xx = (unsigned char const *) (x->key) - 1; unsigned char const *yy = (unsigned char const *) (y->key) - 1; do { if (*++xx == '\0') { yy++; break; } } while (*xx == *++yy); (result) = *xx - *yy; } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 22b <restore_lastcom+0xb>
test   %rdi,%rdi
je     23f <restore_lastcom+0x1f>
mov    $0x5f,%edx
mov    $0x0,%esi
callq  23f <restore_lastcom+0x1f>
mov    %rbx,0x0(%rip)        # 246 <restore_lastcom+0x26>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
restore_lastcom (x)
     char *x;
{
  do { if (the_printed_command_except_trap) sh_xfree((the_printed_command_except_trap), "evalstring.c", 95); } while (0);
  the_printed_command_except_trap = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x20,%edi
callq  1e <list_create+0xe>
movq   $0x0,0x10(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,(%rax)
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
list_create ()
{
  struct list *p = xmalloc (sizeof (*p));
  p->head = p->tail = ((void *)0);
  p->itr = ((void *)0);
  p->count = 0;
  return p;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 6
8 8
9 8
10 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x30,%rsp
mov    %rsi,0x10(%rsp)
lea    0x10(%rsp),%rsi
mov    %rdx,0x18(%rsp)
mov    %ecx,0x20(%rsp)
movq   $0x0,0x28(%rsp)
callq  17ac <mu_format_config_tree+0x2c>
mov    %rbx,%rdi
mov    %rax,%rsi
mov    %rax,0x8(%rsp)
callq  17bc <mu_format_config_tree+0x3c>
lea    0x8(%rsp),%rdi
callq  17c6 <mu_format_config_tree+0x46>
add    $0x30,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_format_config_tree (mu_stream_t stream, const char *progname,
         struct mu_cfg_param *progparam, int flags)
{
  struct include_data idata;
  struct mu_cfg_cont *cont;
  idata.progname = progname;
  idata.progparam = progparam;
  idata.flags = flags;
  idata.target = ((void *)0);
  cont = mu_build_container (progname, &idata);
  mu_cfg_format_container (stream, cont);
  mu_config_destroy_container (&cont);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 10
7 7
8 8
9 9
10 10
11 11
12 11
13 10
14 11
15 12
16 12
17 13
18 13
19 13
20 13
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 506 <net_input_level+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
net_input_level (void)
{
  return ncc;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x810,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
mov    0x30(%rdi),%rax
movl   $0x2,(%rax)
mov    0x18(%rdi),%rax
add    $0x1,%rax
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x22,-0x2(%rax)
jne    1610 <ReadReaction_L1+0x30>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  1629 <ReadReaction_L1+0x49>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1638 <ReadReaction_L1+0x58>
mov    $0x3c,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  1658 <ReadReaction_L1+0x78>
mov    0x18(%rbx),%rdx
jmp    1663 <ReadReaction_L1+0x83>
xchg   %ax,%ax
mov    %rax,%rdx
lea    0x1(%rdx),%rax
mov    %rax,0x18(%rbx)
cmpb   $0x22,(%rdx)
jne    1660 <ReadReaction_L1+0x80>
lea    0x400(%rsp),%rsi
mov    %rdx,0x18(%rbx)
mov    %rbx,%rdi
callq  1684 <ReadReaction_L1+0xa4>
lea    0x400(%rsp),%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  169b <ReadReaction_L1+0xbb>
lea    0x400(%rsp),%rdx
xor    %ecx,%ecx
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  16b0 <ReadReaction_L1+0xd0>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    16c0 <ReadReaction_L1+0xe0>
mov    0x808(%rsp),%rax
xor    %fs:0x28,%rax
jne    16ea <ReadReaction_L1+0x10a>
add    $0x810,%rsp
pop    %rbx
retq   
callq  16ef <ReadReaction_L1+0x10f>
nop
<<<sep_in_sample>>>
ReadReaction_L1 (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 60);
  while (*pibIn->pbufCur++ != '"');
  pibIn->pbufCur = pibIn->pbufCur - 1;
  GetaString (pibIn, szEqn);
  printf ("reaction %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 0);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 13
38 12
39 13
40 13
41 14
42 14
43 14
44 14
45 14
46 15
47 15
48 15
49 15
50 15
51 15
52 15
53 15
54 16
55 16
56 16
57 16
58 17
59 17
60 17
61 17
62 17
63 17
64 17
65 17
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <isdir+0xf>
xor    %edx,%edx
test   %eax,%eax
jne    28 <isdir+0x28>
mov    0x18(%rsp),%eax
xor    %edx,%edx
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
isdir (const char *path)
{
  struct stat stats;
  return stat (path, &stats) == 0 && ((((stats.st_mode)) & 0170000) == (0040000));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  61 <_file_wait+0x11>
mov    (%rax),%rdi
test   %rdi,%rdi
je     88 <_file_wait+0x38>
callq  6e <_file_wait+0x1e>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %eax,%edi
jmpq   81 <_file_wait+0x31>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x16,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_file_wait (mu_stream_t stream, int *pflags, struct timeval *tvp)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  if (!fs->file)
    return 22;
  return mu_fd_wait (fileno (fs->file), pflags, tvp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 6
11 7
12 6
13 6
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
jmpq   25 <rec_comment_destroy+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_destroy (rec_comment_t comment)
{
  free (comment);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
imul   (%rdi),%rdx
test   %rdx,%rdx
je     2f <gsl_histogram2d_sum+0x2f>
mov    0x20(%rdi),%rax
xorpd  %xmm0,%xmm0
lea    (%rax,%rdx,8),%rdx
nopl   0x0(%rax)
addsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rdx,%rax
jne    20 <gsl_histogram2d_sum+0x20>
repz retq 
xorpd  %xmm0,%xmm0
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_sum (const gsl_histogram2d * h)
{
  const size_t n = h->nx * h->ny;
  double sum = 0;
  size_t i = 0;
  while (i < n)
    sum += h->bin[i++];
  return sum;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 4
7 4
8 4
9 7
10 7
11 6
12 6
13 6
14 4
15 9
16 9
<<<sep_out_sample>>>
sub    $0x28,%rsp
xor    %r9d,%r9d
xor    %r8d,%r8d
movq   $0x0,0x8(%rsp)
movl   $0x3,(%rsp)
mov    $0x0,%ecx
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c0 <setup_print_prompter+0x30>
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
xor    %r9d,%r9d
movl   $0x3,0x8(%rsp)
movq   $0x0,(%rsp)
mov    $0x0,%r8d
mov    $0x1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  304 <setup_print_prompter+0x74>
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
setup_print_prompter(void)
{
  string_option("A", "print-pages", ((void *)0), &print_selection, ((void *)0), ((void *)0),
  OPT_PRINT,
  "specify list of pages to be printed");
  boolean_option("a", "no-prompt", "prompt", TRUE, &no_prompt_to_print, ((void *)0), ((void *)0),
   OPT_PRINT,
   "don't prompt for each page, whether it should be printed or not",
   "prompt for each page, whether it should be printed or not");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %r15
mov    0x0(%rip),%eax        # 8a18 <Faraday+0x8>
push   %r14
cmp    $0x1,%eax
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %eax,-0x4(%rsp)
jle    8d31 <Faraday+0x321>
mov    0x0(%rip),%r10d        # 8a34 <Faraday+0x24>
movsd  0x0(%rip),%xmm11        # 8a3d <Faraday+0x2d>
movsd  0x0(%rip),%xmm10        # 8a46 <Faraday+0x36>
mov    $0x0,%r15d
movsd  0x0(%rip),%xmm6        # 8a54 <Faraday+0x44>
mov    $0x0,%ebp
movsd  0x0(%rip),%xmm5        # 8a61 <Faraday+0x51>
lea    -0x1(%r10),%ebx
movsd  0x0(%rip),%xmm4        # 8a6d <Faraday+0x5d>
mov    $0x3,%r12d
movapd %xmm11,%xmm9
movapd %xmm10,%xmm7
nopl   (%rax)
cmp    $0x1,%r10d
lea    -0x1(%r12),%r14d
jle    8d3c <Faraday+0x32c>
lea    -0x2(%r12),%eax
cmp    $0x4,%r10d
mov    %r12d,%r13d
movapd %xmm11,%xmm8
mov    %eax,-0x8(%rsp)
movapd %xmm10,%xmm3
mov    $0x2,%eax
jle    8c42 <Faraday+0x232>
lea    -0x1350(%rbp),%r9
lea    -0x26a0(%rbp),%r8
mov    %rbp,%rdi
lea    -0x1350(%r15),%rsi
lea    -0x9a8(%r15),%rdx
mov    %r15,%rcx
movsd  -0x9a0(%r15),%xmm0
mov    $0x2,%eax
movsd  -0x1330(%rbp),%xmm13
movsd  -0x1340(%rbp),%xmm12
movapd %xmm9,%xmm8
movapd %xmm7,%xmm3
jmp    8b0c <Faraday+0xfc>
nopl   0x0(%rax)
movapd %xmm1,%xmm0
movsd  0x10(%rcx),%xmm1
add    $0x3,%eax
add    $0x18,%rcx
movsd  0x30(%r9),%xmm2
lea    0x1(%rax),%r11d
addsd  0x18(%rdx),%xmm1
add    $0x18,%rsi
add    $0x18,%rdx
movapd %xmm2,%xmm14
add    $0x30,%rdi
add    $0x30,%r8
add    $0x30,%r9
subsd  %xmm12,%xmm14
addsd  -0x8(%rsi),%xmm1
movapd %xmm14,%xmm12
mulsd  %xmm7,%xmm12
addsd  %xmm0,%xmm1
movsd  -0x8(%rdi),%xmm0
divsd  %xmm5,%xmm12
subsd  -0x8(%r8),%xmm0
mulsd  %xmm7,%xmm0
mulsd  %xmm9,%xmm1
divsd  %xmm6,%xmm0
subsd  %xmm12,%xmm0
movsd  0x10(%r9),%xmm12
movapd %xmm12,%xmm15
mulsd  %xmm4,%xmm0
subsd  %xmm13,%xmm15
subsd  %xmm0,%xmm1
movapd %xmm15,%xmm13
mulsd  %xmm7,%xmm13
movsd  %xmm1,-0x8(%rdx)
movsd  (%rcx),%xmm0
divsd  %xmm5,%xmm13
addsd  0x8(%rdx),%xmm0
addsd  (%rsi),%xmm0
addsd  %xmm1,%xmm0
movsd  0x8(%rdi),%xmm1
mulsd  %xmm9,%xmm0
subsd  0x8(%r8),%xmm1
mulsd  %xmm7,%xmm1
divsd  %xmm6,%xmm1
subsd  %xmm13,%xmm1
movsd  0x20(%r9),%xmm13
movapd %xmm13,%xmm14
mulsd  %xmm4,%xmm1
subsd  %xmm2,%xmm14
subsd  %xmm1,%xmm0
movapd %xmm14,%xmm2
mulsd  %xmm7,%xmm2
movsd  %xmm0,(%rdx)
movsd  0x8(%rcx),%xmm1
divsd  %xmm5,%xmm2
addsd  0x10(%rdx),%xmm1
addsd  0x8(%rsi),%xmm1
addsd  %xmm0,%xmm1
movsd  0x18(%rdi),%xmm0
mulsd  %xmm9,%xmm1
subsd  0x18(%r8),%xmm0
mulsd  %xmm7,%xmm0
divsd  %xmm6,%xmm0
subsd  %xmm2,%xmm0
mulsd  %xmm4,%xmm0
subsd  %xmm0,%xmm1
movsd  %xmm1,0x8(%rdx)
cmp    %r11d,%ebx
jg     8b08 <Faraday+0xf8>
movslq -0x8(%rsp),%r9
movslq %r14d,%rcx
movslq %r12d,%r11
imul   $0x135,%rcx,%rcx
imul   $0x135,%r11,%r11
imul   $0x135,%r9,%r9
jmp    8c6a <Faraday+0x25a>
nopl   0x0(%rax)
mov    %edx,%eax
lea    0x1(%rax),%edx
lea    -0x1(%rax),%r8d
cltq   
lea    (%r11,%rax,1),%rdi
lea    (%rcx,%rax,1),%r14
add    %r9,%rax
movslq %edx,%rsi
movslq %r8d,%r8
movsd  0x0(,%rdi,8),%xmm0
add    %rcx,%rsi
shl    $0x4,%rdi
add    %rcx,%r8
movsd  0x0(%rdi),%xmm1
addsd  0x0(,%rsi,8),%xmm0
shl    $0x4,%rsi
movsd  0x0(%rsi),%xmm2
addsd  0x0(,%rax,8),%xmm0
shl    $0x4,%rax
subsd  0x0(%rax),%xmm1
addsd  0x0(,%r8,8),%xmm0
shl    $0x4,%r8
cmp    %edx,%r10d
subsd  0x0(%r8),%xmm2
mulsd  %xmm3,%xmm1
divsd  %xmm6,%xmm1
mulsd  %xmm3,%xmm2
mulsd  %xmm8,%xmm0
divsd  %xmm5,%xmm2
subsd  %xmm2,%xmm1
mulsd  %xmm4,%xmm1
subsd  %xmm1,%xmm0
movsd  %xmm0,0x0(,%r14,8)
jge    8c68 <Faraday+0x258>
add    $0x1,%r12d
add    $0x9a8,%r15
add    $0x1350,%rbp
cmp    %r13d,-0x4(%rsp)
jge    8a80 <Faraday+0x70>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %r12d,%r13d
jmp    8d14 <Faraday+0x304>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Faraday(void)
{
 int i,j;
 for(i=2;i<=nx;i++)
  for(j=2;j<=ny;j++)
   B[i][j]=0.25*(B[i+1][j]+B[i][j+1]+B[i-1][j]+B[i][j-1])
          -DT*(0.5*(E[i+1][j][1]-E[i-1][j][1])/dx
       -0.5*(E[i][j+1][0]-E[i][j-1][0])/dy);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 5
45 5
46 5
47 5
48 5
49 5
50 6
51 6
52 6
53 8
54 8
55 6
56 6
57 6
58 8
59 8
60 8
61 8
62 8
63 6
64 8
65 8
66 6
67 7
68 8
69 7
70 7
71 6
72 7
73 8
74 8
75 8
76 7
77 8
78 7
79 8
80 8
81 6
82 6
83 8
84 6
85 6
86 6
87 7
88 6
89 7
90 7
91 7
92 8
93 8
94 8
95 7
96 8
97 7
98 8
99 8
100 6
101 6
102 8
103 6
104 6
105 6
106 7
107 6
108 7
109 7
110 7
111 8
112 7
113 7
114 6
115 6
116 6
117 6
118 6
119 6
120 6
121 6
122 6
123 6
124 6
125 6
126 6
127 6
128 6
129 6
130 6
131 6
132 6
133 6
134 6
135 6
136 7
137 6
138 7
139 6
140 8
141 8
142 6
143 7
144 7
145 6
146 8
147 5
148 8
149 7
150 7
151 8
152 6
153 8
154 8
155 7
156 7
157 6
158 5
159 5
160 5
161 5
162 4
163 4
164 9
165 9
166 9
167 9
168 9
169 9
170 9
171 9
172 9
173 9
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  18 <CDB___os_set_errno+0x8>
mov    %ebx,(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___os_set_errno(evalue)
 int evalue;
{
 (*__errno_location ()) = evalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 14f7 <put_macro+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  1505 <put_macro+0x15>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1512 <put_macro+0x22>
pop    %rbx
mov    0x0(%rip),%rsi        # 151a <put_macro+0x2a>
mov    $0x0,%edi
jmpq   1524 <put_macro+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_macro(const char *word)
{
 strbuf_puts(outbuf, sharp_begin);
 strbuf_puts(outbuf, word);
 strbuf_puts(outbuf, sharp_end);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 4
7 4
8 4
9 6
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 15c7 <stat_diag+0x7>
jne    15d0 <stat_diag+0x10>
jmpq   15ce <stat_diag+0xe>
xchg   %ax,%ax
jmpq   15d5 <stat_diag+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stat_diag (char const *name)
{
  if (ignore_failed_read_option)
    stat_warn (name);
  else
    stat_error (name);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
cmp    %rsi,%rax
jbe    c60 <gsl_interp2d_idx+0x20>
cmp    %rdx,0x30(%rdi)
jbe    c80 <gsl_interp2d_idx+0x40>
imul   %rdx,%rax
add    $0x8,%rsp
add    %rsi,%rax
retq   
nop
mov    $0x2,%ecx
mov    $0x16a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c79 <gsl_interp2d_idx+0x39>
xor    %eax,%eax
add    $0x8,%rsp
retq   
mov    $0x2,%ecx
mov    $0x16e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c99 <gsl_interp2d_idx+0x59>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_interp2d_idx(const gsl_interp2d * interp,
                 const size_t i, const size_t j)
{
  if (i >= interp->xsize)
    {
      do { gsl_error ("x index out of range", "interp2d.c", 362, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else if (j >= interp->ysize)
    {
      do { gsl_error ("y index out of range", "interp2d.c", 366, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else
    {
      return ((j) * ((interp)->xsize) + (i));
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 8
6 8
7 14
8 16
9 14
10 16
11 16
12 6
13 6
14 6
15 6
16 6
17 6
18 16
19 16
20 10
21 10
22 10
23 10
24 10
25 10
26 16
27 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     348 <documentation_print_plain+0x188>
push   %r12
mov    $0x0,%r9d
mov    %rsi,%r12
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%esi
push   %rbp
xor    %eax,%eax
mov    %rdx,%rbp
mov    $0x0,%edx
push   %rbx
sub    $0xe0,%rsp
movq   $0x0,0xd8(%rsp)
movq   $0x0,0xd0(%rsp)
movq   $0x0,0xc8(%rsp)
movq   $0x0,0xc0(%rsp)
movq   $0x0,0xb8(%rsp)
movq   $0x0,0xb0(%rsp)
movq   $0x0,0xa8(%rsp)
movq   $0x0,0xa0(%rsp)
movq   $0x0,0x98(%rsp)
movq   $0x0,0x90(%rsp)
movq   $0x0,0x88(%rsp)
movq   $0x0,0x80(%rsp)
movq   $0x0,0x78(%rsp)
movq   $0x0,0x70(%rsp)
movq   $0x0,0x68(%rsp)
movq   $0x0,0x60(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x50(%rsp)
movq   $0x0,0x48(%rsp)
movq   $0x0,0x40(%rsp)
movq   $0x0,0x38(%rsp)
movq   $0x0,0x30(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x20(%rsp)
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
callq  31b <documentation_print_plain+0x15b>
mov    %rbp,%rdi
mov    %rax,%rbx
mov    %rax,%rdx
mov    %r12,%rsi
xor    %eax,%eax
callq  32e <documentation_print_plain+0x16e>
add    $0xe0,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   341 <documentation_print_plain+0x181>
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
documentation_print_plain (const unsigned char * documentation,
      const char *format, FILE * stream)
{
  char *cp;
  if (!documentation)
    return;
  cp = xvstrrpl ((const char *) documentation, "url(", "", ")url(", " (", ")url", ")", "samp(", "`", ")samp", "'", "emph(", "*", ")emph", "*", "code(", "", ")code", "", "@example\n", "", "@end example\n", "", "@end example", "", "@itemize\n", "", "@end itemize", "", "@item\n", " - ", "@@", "@", ((void *)0));
  fprintf (stream, format, cp);
  free (cp);
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 7
6 7
7 7
8 7
9 3
10 7
11 7
12 7
13 3
14 3
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 8
45 7
46 8
47 8
48 8
49 8
50 10
51 9
52 10
53 10
54 10
55 9
56 9
57 9
58 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x1,%edx
mov    %sil,0xc(%rsp)
lea    0xc(%rsp),%rsi
callq  3b8 <mu_opool_append_char+0x18>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
mu_opool_append_char (mu_opool_t opool, char c)
{
  return mu_opool_append (opool, &c, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
ucomisd %xmm2,%xmm0
jae    60 <gsl_ran_pareto_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm0
sub    $0x18,%rsp
movapd %xmm1,%xmm3
movsd  %xmm2,0x8(%rsp)
addsd  0x0(%rip),%xmm1        # 7a <gsl_ran_pareto_pdf+0x2a>
movsd  %xmm3,(%rsp)
callq  84 <gsl_ran_pareto_pdf+0x34>
movsd  (%rsp),%xmm3
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
add    $0x18,%rsp
divsd  %xmm2,%xmm3
movapd %xmm3,%xmm0
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_pareto_pdf (const double x, const double a, const double b)
{
  if (x >= b)
    {
      double p = (a/b) / pow (x/b, a + 1);
      return p;
    }
  else
    {
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 10
4 10
5 10
6 5
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 12
17 5
18 5
19 5
20 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  4c <polynomial_free+0xc>
mov    0x8(%rbx),%rdi
callq  55 <polynomial_free+0x15>
mov    0x10(%rbx),%rdi
callq  5e <polynomial_free+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   67 <polynomial_free+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
polynomial_free (void *vstate)
{
  polynomial_state_t *state = (polynomial_state_t *) vstate;
  free (state->d);
  free (state->coeff);
  free (state->work);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
jmpq   85 <username_completion_function+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
username_completion_function (s, i)
     const char *s;
     int i;
{
  return rl_username_completion_function (s, i);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
sub    $0x88,%rsp
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  402 <nettle_openssl_des_is_weak_key+0x12>
test   %eax,%eax
sete   %al
add    $0x88,%rsp
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
nettle_openssl_des_is_weak_key(des_cblock *key)
{
  struct des_ctx ctx;
  return !nettle_des_set_key(&ctx, *key);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 4
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    %rsp,%rdi
callq  10 <printf_frexp+0x10>
mov    (%rsp),%edx
addsd  %xmm0,%xmm0
lea    -0x1(%rdx),%eax
cmp    $0xfffffc02,%eax
mov    %eax,(%rsp)
jge    34 <printf_frexp+0x34>
lea    0x3fd(%rdx),%edi
callq  2f <printf_frexp+0x2f>
mov    $0xfffffc02,%eax
mov    %eax,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
printf_frexp (double x, int *expptr)
{
  int exponent;
  ;
  x = frexp (x, &exponent);
  x = x + x;
  exponent -= 1;
  if (exponent < (-1021) - 1)
    {
      x = ldexp (x, exponent - ((-1021) - 1));
      exponent = (-1021) - 1;
    }
  ;
  *expptr = exponent;
  return x;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 7
7 6
8 7
9 8
10 7
11 8
12 10
13 10
14 10
15 14
16 16
17 16
18 16
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%rcx
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%r14
test   %rbp,%rbp
je     597d <gsl_matrix_uchar_set_all+0x4d>
xor    %ebx,%ebx
test   %r12,%r12
movzbl %sil,%r13d
je     5990 <gsl_matrix_uchar_set_all+0x60>
nopw   0x0(%rax,%rax,1)
mov    %rcx,%rdi
mov    %r12,%rdx
mov    %r13d,%esi
callq  596e <gsl_matrix_uchar_set_all+0x3e>
add    $0x1,%rbx
mov    %rax,%rcx
add    %r14,%rcx
cmp    %rbp,%rbx
jne    5960 <gsl_matrix_uchar_set_all+0x30>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %rbp,%rbx
je     597d <gsl_matrix_uchar_set_all+0x4d>
add    $0x1,%rbx
cmp    %rbp,%rbx
jne    5990 <gsl_matrix_uchar_set_all+0x60>
jmp    597d <gsl_matrix_uchar_set_all+0x4d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_set_all (gsl_matrix_uchar * m, unsigned char x)
{
  size_t i, j;
  unsigned char * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(unsigned char *) (data + 1 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 4
8 6
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 8
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  22cb <font_info_table_new+0xb>
mov    $0x0,%r8d
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
callq  22eb <font_info_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
font_info_table_new (void)
{
  struct hash_table_s *(res) = ((struct hash_table_s *) xmalloc (sizeof (struct hash_table_s) * (1)));
  hash_init (res, 8,
      (hash_func_t) font_info_hash_1,
      (hash_func_t) font_info_hash_2,
      (hash_cmp_func_t) font_info_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 4
9 4
10 4
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 12b6 <yyget_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_lineno (void)
{
    return yylineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1591 <gsl_matrix_long_fread+0x91>
lea    0x0(,%r15,8),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    154e <gsl_matrix_long_fread+0x4e>
jmp    1580 <gsl_matrix_long_fread+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1580 <gsl_matrix_long_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1565 <gsl_matrix_long_fread+0x65>
test   %eax,%eax
je     1540 <gsl_matrix_long_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   15b4 <gsl_matrix_long_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_fread (FILE * stream, gsl_matrix_long * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     500 <mu_ticket_get_data+0x10>
mov    0x30(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ticket_get_data (mu_ticket_t ticket)
{
  if (!ticket)
    return ((void *)0);
  return ticket->data;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
xor    %edx,%edx
xor    %eax,%eax
jmp    10cd <rl_unbind_function_in_map+0x1d>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
je     10f5 <rl_unbind_function_in_map+0x45>
cmpb   $0x0,(%rsi,%rdx,1)
jne    10c0 <rl_unbind_function_in_map+0x10>
cmp    %rdi,0x8(%rsi,%rdx,1)
jne    10c0 <rl_unbind_function_in_map+0x10>
movq   $0x0,0x8(%rsi,%rdx,1)
add    $0x10,%rdx
mov    $0x1,%eax
cmp    $0x1010,%rdx
jne    10cd <rl_unbind_function_in_map+0x1d>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_unbind_function_in_map (func, map)
     rl_command_func_t *func;
     Keymap map;
{
  register int i, rval;
  for (i = rval = 0; i < 257; i++)
    {
      if (map[i].type == 0 && map[i].function == func)
 {
   map[i].function = (rl_command_func_t *)((void *)0);
   rval = 1;
 }
    }
  return rval;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 10
13 10
14 11
15 6
16 6
17 15
18 15
<<<sep_out_sample>>>
push   %rbx
add    $0xb8,%rdi
mov    %rdx,%rbx
callq  1190 <sdp_message_m_payload_add+0x10>
test   %rax,%rax
je     11b0 <sdp_message_m_payload_add+0x30>
lea    0x20(%rax),%rdi
mov    %rbx,%rsi
mov    $0xffffffff,%edx
callq  11a6 <sdp_message_m_payload_add+0x26>
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_m_payload_add (sdp_message_t * sdp, int pos_media, char *payload)
{
  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return -2;
  osip_list_add (&med->m_payloads, payload, -1);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 8
13 8
14 8
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
callq  97d <unmake_editstuff+0xd>
test   $0x1,%bl
mov    %rbx,%rdi
mov    $0x50,%edx
jne    9d0 <unmake_editstuff+0x60>
test   $0x2,%dil
jne    9e0 <unmake_editstuff+0x70>
test   $0x4,%dil
jne    9f8 <unmake_editstuff+0x88>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     9af <unmake_editstuff+0x3f>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     9be <unmake_editstuff+0x4e>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     9c6 <unmake_editstuff+0x56>
movb   $0x0,(%rdi)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdi
movb   $0x0,(%rbx)
mov    $0x4f,%dl
test   $0x2,%dil
je     990 <unmake_editstuff+0x20>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     996 <unmake_editstuff+0x26>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    996 <unmake_editstuff+0x26>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unmake_editstuff (struct editstuff *es)
{
  free (es->line);
  memset (es, 0, sizeof (struct editstuff));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 5
30 5
31 5
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 4
40 4
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
<<<sep_out_sample>>>
sub    $0x58,%rsp
xor    %edi,%edi
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x48(%rsp)
xor    %eax,%eax
callq  423e <enable_signals+0x1e>
xor    %esi,%esi
xor    %edi,%edi
mov    %rsp,%rdx
orl    $0x1,0xc(%rsp)
callq  424f <enable_signals+0x2f>
mov    0x48(%rsp),%rax
xor    %fs:0x28,%rax
jne    4264 <enable_signals+0x44>
add    $0x58,%rsp
retq   
callq  4269 <enable_signals+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
enable_signals(void)
{
    struct termios term;
    tcgetattr(0, &term);
    term.c_lflag |= 0000001;
    tcsetattr(0, 0, &term);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 2
7 4
8 6
9 6
10 6
11 5
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     74 <rec_sex_parser_destroy+0x14>
xor    %eax,%eax
callq  74 <rec_sex_parser_destroy+0x14>
mov    (%rbx),%rdi
callq  7c <rec_sex_parser_destroy+0x1c>
mov    %rbx,%rdi
pop    %rbx
jmpq   85 <rec_sex_parser_destroy+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_parser_destroy (rec_sex_parser_t parser)
{
  if (parser->scanner)
    {
      sexlex_destroy (parser->scanner);
    }
  free (parser->in);
  free (parser);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 7
9 7
10 8
11 9
12 8
13 8
<<<sep_out_sample>>>
test   %edi,%edi
mov    0x0(%rip),%eax        # f8 <tty_binaryout+0x8>
jne    110 <tty_binaryout+0x20>
and    $0xffffffcf,%eax
orl    $0x1,0x0(%rip)        # 104 <tty_binaryout+0x14>
or     $0x120,%eax
mov    %eax,0x0(%rip)        # 10f <tty_binaryout+0x1f>
retq   
and    $0xfffffecf,%eax
andl   $0xfffffffe,0x0(%rip)        # 11c <tty_binaryout+0x2c>
or     $0x30,%eax
mov    %eax,0x0(%rip)        # 125 <tty_binaryout+0x35>
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_binaryout (int on)
{
  if (on)
    {
      termbuf.c_cflag &= ~(0000060 | 0000400);
      termbuf.c_cflag |= 0000060;
      termbuf.c_oflag &= ~0000001;
    }
  else
    {
      termbuf.c_cflag &= ~0000060;
      termbuf.c_cflag |= 0000040 | 0000400;
      termbuf.c_oflag |= 0000001;
    }
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 11
5 13
6 12
7 12
8 12
9 5
10 7
11 6
12 6
13 6
14 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x98,%rsp
test   %rsi,%rsi
je     3aa9 <dap_name+0x19>
cmpb   $0x0,(%rsi)
jne    3ad0 <dap_name+0x40>
movabs $0x6c756e2f7665642f,%rax
mov    %rax,(%rbx)
mov    $0x6c,%eax
mov    %ax,0x8(%rbx)
add    $0x98,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 3ad7 <dap_name+0x47>
callq  3adc <dap_name+0x4c>
mov    %rsp,%rsi
mov    %rbx,%rdi
callq  3ae7 <dap_name+0x57>
test   %eax,%eax
js     3b18 <dap_name+0x88>
testb  $0x40,0x19(%rsp)
je     3b3f <dap_name+0xaf>
mov    %rbx,%rdi
callq  3afa <dap_name+0x6a>
movb   $0x2f,(%rbx,%rax,1)
add    $0x98,%rsp
lea    0x1(%rbx,%rax,1),%rdi
pop    %rbx
mov    %rbp,%rsi
pop    %rbp
jmpq   3b14 <dap_name+0x84>
nopl   0x0(%rax)
mov    $0x1c0,%esi
mov    %rbx,%rdi
callq  3b25 <dap_name+0x95>
test   %eax,%eax
jns    3af2 <dap_name+0x62>
mov    0x0(%rip),%rdi        # 3b30 <dap_name+0xa0>
callq  3b35 <dap_name+0xa5>
mov    $0x1,%edi
callq  3b3f <dap_name+0xaf>
mov    0x0(%rip),%rdi        # 3b46 <dap_name+0xb6>
mov    0x0(%rip),%rdx        # 3b4d <dap_name+0xbd>
mov    %rbx,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  3b5c <dap_name+0xcc>
mov    $0x1,%edi
callq  3b66 <dap_name+0xd6>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dap_name(char dname[], char *fname)
{
  struct stat statbuf;
  if (!fname || !fname[0])
    {
      strcpy(dname, "/dev/null");
      return;
    }
  strcpy(dname, dap_setdir);
  if (stat(dname, &statbuf) < 0)
    {
      if (mkdir(dname, (mode_t) 0700) < 0)
 {
   perror(dap_dapname);
   exit(1);
 }
    }
  else if (!(statbuf.st_mode & 0040000))
    {
      fprintf(dap_err, "%s: non-directory file exists: %s\n", dap_dapname, dname);
      exit(1);
    }
  strcat(dname, "/");
  strcat(dname, fname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 25
15 25
16 25
17 25
18 25
19 9
20 9
21 10
22 10
23 10
24 10
25 10
26 18
27 18
28 23
29 23
30 23
31 25
32 24
33 25
34 24
35 25
36 24
37 24
38 12
39 12
40 12
41 12
42 12
43 14
44 14
45 15
46 15
47 20
48 20
49 20
50 20
51 20
52 20
53 21
54 21
55 21
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initdiffcmd (register struct diffcmd *dc)
{
  dc->adprev = 0;
  dc->dafter = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1af0 <gsl_matrix_int_ispos+0x50>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1ae4 <gsl_matrix_int_ispos+0x44>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm0,%xmm1
jae    1af6 <gsl_matrix_int_ispos+0x56>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1ad0 <gsl_matrix_int_ispos+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    1ac1 <gsl_matrix_int_ispos+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_int_ispos (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
push   %rbp
push   %rbx
mov    %rdx,%rbx
je     a09 <pw_fprintf_path+0x39>
mov    (%rdx),%rdx
mov    %rdi,%rbp
mov    %rsi,%r12
test   %rdx,%rdx
je     a09 <pw_fprintf_path+0x39>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rbx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  a01 <pw_fprintf_path+0x31>
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    9f0 <pw_fprintf_path+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
pw_fprintf_path (FILE * stream, const char * format, char * const * path)
{
  if (path)
    while (*path) {
      fprintf (stream, format, *path);
      path++;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 6
15 5
16 5
17 5
18 4
19 4
20 4
21 8
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4997 <need_horizontal_scroll+0x7>
movzbl 0x58(%rax),%eax
test   %al,%al
je     49a0 <need_horizontal_scroll+0x10>
retq   
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  49ae <need_horizontal_scroll+0x1e>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  49b9 <need_horizontal_scroll+0x29>
cmp    %rax,%rbp
setne  %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
need_horizontal_scroll(const size_t old_column, const size_t new_column)
{
    if (openfile->mark_set)
 return 1;
    else
 return (get_page_start(old_column) != get_page_start(new_column));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
xorpd  %xmm2,%xmm2
movsd  (%rdi),%xmm1
movsd  0x8(%rdi),%xmm3
ucomisd %xmm2,%xmm1
jp     8df <heading+0x1f>
jne    8df <heading+0x1f>
ucomisd %xmm2,%xmm3
jnp    900 <heading+0x40>
movapd %xmm3,%xmm0
movsd  %xmm2,0x8(%rsp)
callq  8ee <heading+0x2e>
movsd  0x8(%rsp),%xmm2
ucomisd %xmm0,%xmm2
ja     910 <heading+0x50>
add    $0x18,%rsp
retq   
nop
movapd %xmm2,%xmm0
jne    8df <heading+0x1f>
jmp    8fa <heading+0x3a>
nopl   0x0(%rax,%rax,1)
addsd  0x0(%rip),%xmm0        # 918 <heading+0x58>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
heading(VPoint * x)
{
 double m;
 if (x->x == 0.0 && x->y == 0.0)
  return 0.0;
 if ((m = atan2(x->y, x->x)) < 0.0)
  return (3.14159265358979323846 * 2.0 + m);
 else
  return m;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 5
20 4
21 4
22 4
23 7
24 10
25 10
26 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a9 <_rl_abort_internal+0x9>
callq  ae <_rl_abort_internal+0xe>
callq  b3 <_rl_abort_internal+0x13>
callq  b8 <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # c3 <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # cb <_rl_abort_internal+0x2b>
je     df <_rl_abort_internal+0x3f>
nopl   (%rax)
callq  d5 <_rl_abort_internal+0x35>
cmpq   $0x0,0x0(%rip)        # dd <_rl_abort_internal+0x3d>
jne    d0 <_rl_abort_internal+0x30>
mov    $0x1,%esi
mov    $0x0,%edi
andq   $0xffffffffffdfffff,0x0(%rip)        # f4 <_rl_abort_internal+0x54>
movq   $0x0,0x0(%rip)        # ff <_rl_abort_internal+0x5f>
callq  104 <_rl_abort_internal+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 8
12 8
13 12
14 12
15 10
16 11
17 12
18 12
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
callq  2a52 <window_point_to_column+0x12>
mov    0x68(%rbp),%r8
test   %r8,%r8
je     2ac0 <window_point_to_column+0x80>
mov    (%r8),%rcx
xor    %eax,%eax
cmp    %rbx,%rcx
jg     2aa2 <window_point_to_column+0x62>
mov    0x60(%rbp),%rsi
test   %rsi,%rsi
je     2ac9 <window_point_to_column+0x89>
cmp    %rbx,%rcx
jge    2ac7 <window_point_to_column+0x87>
mov    $0x1,%ecx
jmp    2a8e <window_point_to_column+0x4e>
nopw   0x0(%rax,%rax,1)
lea    0x1(%rcx),%rdi
cmp    -0x8(%r8,%rdi,8),%rbx
jle    2ab0 <window_point_to_column+0x70>
mov    %rdi,%rcx
cmp    %rsi,%rcx
mov    %ecx,%eax
jne    2a80 <window_point_to_column+0x40>
test   %r12,%r12
je     2aa2 <window_point_to_column+0x62>
mov    (%r8,%rsi,8),%rdx
mov    %rdx,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
test   %r12,%r12
mov    %rcx,%rsi
jne    2a9a <window_point_to_column+0x5a>
jmp    2aa2 <window_point_to_column+0x62>
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xor    %esi,%esi
xor    %eax,%eax
jmp    2a95 <window_point_to_column+0x55>
<<<sep_in_sample>>>
window_point_to_column (WINDOW *win, long point, long *np)
{
  int i;
  window_compute_line_map (win);
  if (!win->line_map.map || point < win->line_map.map[0])
    return 0;
  for (i = 0; i < win->line_map.used; i++)
    if (win->line_map.map[i] >= point)
      break;
  if (np)
    *np = win->line_map.map[i];
  return i;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 5
9 5
10 5
11 5
12 6
13 5
14 5
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 7
28 7
29 7
30 10
31 10
32 11
33 11
34 13
35 13
36 13
37 13
38 13
39 10
40 7
41 10
42 10
43 10
44 13
45 13
46 6
47 13
48 13
49 7
50 8
51 8
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
mov    0x0(,%rdi,4),%edx
mov    0x0(,%rdi,4),%esi
mov    0x0(,%rdi,4),%ecx
cmp    %edx,%eax
jge    50 <fixJoy+0x40>
cmp    %ecx,%esi
jg     70 <fixJoy+0x60>
sub    %eax,%esi
sub    %eax,%ecx
cvtsi2sd %esi,%xmm0
cvtsi2sd %ecx,%xmm1
divsd  %xmm1,%xmm0
subsd  0x0(%rip),%xmm0        # 4f <fixJoy+0x3f>
retq   
cmp    %ecx,%esi
jge    88 <fixJoy+0x78>
mov    %ecx,%eax
sub    %edx,%ecx
sub    %esi,%eax
cvtsi2sd %ecx,%xmm1
cvtsi2sd %eax,%xmm0
divsd  %xmm1,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
sub    %ecx,%esi
sub    %ecx,%edx
cvtsi2sd %esi,%xmm0
cvtsi2sd %edx,%xmm1
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    %eax,%edx
sub    %ecx,%eax
sub    %esi,%edx
cvtsi2sd %eax,%xmm1
cvtsi2sd %edx,%xmm0
divsd  %xmm1,%xmm0
subsd  0x0(%rip),%xmm0        # a2 <fixJoy+0x92>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fixJoy(int i)
{
  if (min[i] < max[i])
  {
    if (value[i] <= home[i])
      return (double) (value[i] - min[i]) / (double)(home[i] - min[i]) - 1.0;
    else
      return (double) (value[i] - home[i]) / (double)(max[i] - home[i]);
  }
  else
    if (value[i] >= home[i])
      return ((double)(min[i] - value[i]) / (double)(min[i] - home[i]) - 1.0);
    else
      return ((double)(home[i] - value[i]) / (double)(home[i] - max[i]));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 11
18 11
19 14
20 14
21 14
22 14
23 14
24 14
25 15
26 15
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
cmpq   $0x0,0x28(%rdi)
je     16bd <da_map+0x2d>
nopl   0x0(%rax,%rax,1)
mov    0x30(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
add    $0x1,%rbx
callq  *%r12
cmp    %rbx,0x28(%rbp)
ja     16a8 <da_map+0x18>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_map (struct darray * arr, da_map_func_t fn)
{
  size_t i;
  for (i = 0 ; i < arr->len ; i++)
    (*fn) (arr->content [i]);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 5
12 4
13 5
14 4
15 4
16 6
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # 90 <gsl_cdf_binomial_Q+0x10>
ucomisd %xmm1,%xmm0
ja     d0 <gsl_cdf_binomial_Q+0x50>
xorpd  %xmm0,%xmm0
ucomisd %xmm3,%xmm0
ja     d0 <gsl_cdf_binomial_Q+0x50>
cmp    %esi,%edi
jae    f1 <gsl_cdf_binomial_Q+0x71>
mov    %edi,%edi
mov    %esi,%esi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm0
cvtsi2sd %rsi,%xmm2
addsd  %xmm0,%xmm1
subsd  %xmm0,%xmm2
movapd %xmm3,%xmm0
jmpq   c7 <gsl_cdf_binomial_Q+0x47>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x5d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e9 <gsl_cdf_binomial_Q+0x69>
movsd  0x0(%rip),%xmm0        # f1 <gsl_cdf_binomial_Q+0x71>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_binomial_Q (const unsigned int k, const double p, const unsigned int n)
{
  double Q;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "binomial.c", 93, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (k >= n)
    {
      Q = 0.0;
    }
  else
    {
      a = (double) k + 1.0;
      b = (double) n - k;
      Q = gsl_cdf_beta_P (p, a, b);
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 6
7 6
8 6
9 10
10 10
11 16
12 17
13 21
14 16
15 17
16 18
17 18
18 18
19 18
20 18
21 8
22 8
23 8
24 8
25 8
26 8
27 21
28 21
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  290 <gnu_mbswidth+0x10>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %ebp,%edx
pop    %rbx
pop    %rbp
mov    %rax,%rsi
jmpq   2a3 <gnu_mbswidth+0x23>
<<<sep_in_sample>>>
gnu_mbswidth (const char *string, int flags)
{
  return mbsnwidth (string, strlen (string), flags);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 3
10 4
11 4
12 3
13 3
<<<sep_out_sample>>>
push   %rbx
mov    0x1b0(%rdi),%rax
mov    %rdi,%rbx
movl   $0x0,0x18(%rax)
mov    0x1d0(%rdi),%rax
callq  *0x8(%rax)
mov    0x1d0(%rbx),%rax
mov    %rbx,%rdi
pop    %rbx
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
pass_startup (j_compress_ptr cinfo)
{
  cinfo->master->call_pass_startup = 0;
  (*cinfo->marker->write_frame_header) (cinfo);
  (*cinfo->marker->write_scan_header) (cinfo);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 5
11 5
12 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     d54 <gsl_vector_long_double_add_constant+0x34>
movsd  %xmm0,-0x10(%rsp)
mov    0x10(%rdi),%rax
shl    $0x4,%rsi
xor    %edx,%edx
fldl   -0x10(%rsp)
fldt   (%rax)
add    $0x1,%rdx
fadd   %st(1),%st
fstpt  (%rax)
add    %rsi,%rax
cmp    %rcx,%rdx
jne    d40 <gsl_vector_long_double_add_constant+0x20>
fstp   %st(0)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_add_constant (gsl_vector_long_double * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 6
12 8
13 8
14 8
15 6
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     de0 <gsl_block_complex_float_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
jne    d8c <gsl_block_complex_float_raw_fwrite+0x3c>
jmp    dd0 <gsl_block_complex_float_raw_fwrite+0x80>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     dd0 <gsl_block_complex_float_raw_fwrite+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  da1 <gsl_block_complex_float_raw_fwrite+0x51>
cmp    $0x1,%rax
je     d80 <gsl_block_complex_float_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  dc0 <gsl_block_complex_float_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x8,%esi
callq  ded <gsl_block_complex_float_raw_fwrite+0x9d>
cmp    %r12,%rax
je     dd0 <gsl_block_complex_float_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e0b <gsl_block_complex_float_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    dc5 <gsl_block_complex_float_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_float_raw_fwrite (FILE * stream, const float * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 2 * sizeof (float), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 2 * i * stride,
                                2 * sizeof (float),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %r13
mov    $0x1,%eax
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%ecx
cmp    %ecx,(%rdi)
je     210 <cidr_cmp+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x4(%rdi),%edx
cmp    0x4(%rsi),%edx
mov    $0x1,%r12d
je     230 <cidr_cmp+0x50>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
movslq %edx,%r13
lea    0x8(%rsi),%rsi
lea    0x8(%rdi),%rdi
mov    %r13,%rdx
callq  243 <cidr_cmp+0x63>
test   %eax,%eax
jne    21e <cidr_cmp+0x3e>
lea    0x18(%rbp),%rsi
lea    0x18(%rbx),%rdi
mov    %r13,%rdx
xor    %r12d,%r12d
callq  25a <cidr_cmp+0x7a>
test   %eax,%eax
setne  %r12b
jmp    21e <cidr_cmp+0x3e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cidr_cmp(const void *elt1, const void *elt2)
{
 struct grecs_cidr const *cp1 = elt1, *cp2 = elt2;
 return !(cp1->family == cp2->family
   && cp1->len == cp2->len
   && memcmp(cp1->address, cp2->address, cp1->len) == 0
   && memcmp(cp1->netmask, cp2->netmask, cp1->len) == 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 5
20 5
21 4
22 5
23 8
24 4
25 8
26 8
27 8
28 8
29 8
30 8
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 7
39 7
40 7
41 4
42 7
43 4
44 4
45 4
46 4
<<<sep_out_sample>>>
mov    $0xffffffffffffffff,%rcx
jmpq   0 <__gmpz_aorsmul>
<<<sep_in_sample>>>
__gmpz_submul (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)
{
  __gmpz_aorsmul (w,u,v,(mp_size_t) -1);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x70(%rdi),%eax
movsd  0x60(%rdi),%xmm0
movsd  %xmm0,(%rsi)
mov    %rax,0x8(%rsi)
mov    0x74(%rdi),%eax
mov    %eax,0x10(%rsi)
mov    0x68(%rdi),%eax
mov    %eax,0x14(%rsi)
mov    0x6c(%rdi),%eax
mov    %eax,0x18(%rsi)
mov    0xc0(%rdi),%rax
mov    %rax,0x20(%rsi)
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_monte_vegas_params_get (const gsl_monte_vegas_state * s, gsl_monte_vegas_params * p)
{
  p->alpha = s->alpha;
  p->iterations = s->iterations;
  p->stage = s->stage;
  p->mode = s->mode;
  p->verbose = s->verbose;
  p->ostream = s->ostream;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 48d <do_prev_block+0xd>
mov    0x20(%rcx),%rbp
mov    0x18(%rbp),%rdx
test   %rdx,%rdx
je     516 <do_prev_block+0x96>
xor    %ebx,%ebx
jmp    4a5 <do_prev_block+0x25>
xchg   %ax,%ax
cmp    $0x1,%bl
je     510 <do_prev_block+0x90>
mov    (%rdx),%rdi
mov    %rdx,0x20(%rcx)
callq  4b1 <do_prev_block+0x31>
mov    0x0(%rip),%rcx        # 4b8 <do_prev_block+0x38>
xor    $0x1,%eax
or     %eax,%ebx
mov    0x20(%rcx),%rsi
mov    0x18(%rsi),%rdx
test   %rdx,%rdx
jne    4a0 <do_prev_block+0x20>
cmpq   $0x0,0x10(%rsi)
je     4f0 <do_prev_block+0x70>
mov    (%rsi),%rdi
callq  4d9 <do_prev_block+0x59>
test   %al,%al
mov    0x0(%rip),%rcx        # 4e2 <do_prev_block+0x62>
je     4f0 <do_prev_block+0x70>
mov    0x20(%rcx),%rax
mov    0x10(%rax),%rax
mov    %rax,0x20(%rcx)
movq   $0x0,0x30(%rcx)
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   506 <do_prev_block+0x86>
nopw   %cs:0x0(%rax,%rax,1)
test   %al,%al
jne    4a5 <do_prev_block+0x25>
jmp    4ca <do_prev_block+0x4a>
mov    %rbp,%rsi
jmp    4ca <do_prev_block+0x4a>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_prev_block(void)
{
    filestruct *was_current = openfile->current;
    _Bool is_text = 0, seen_text = 0;
    while (openfile->current->prev != ((void *)0) && (!seen_text || is_text)) {
 openfile->current = openfile->current->prev;
 is_text = !white_string(openfile->current->data);
 seen_text = seen_text || is_text;
    }
    if (openfile->current->next != ((void *)0) &&
  white_string(openfile->current->data))
 openfile->current = openfile->current->next;
    openfile->current_x = 0;
    edit_redraw(was_current);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 5
7 5
8 5
9 4
10 4
11 4
12 5
13 5
14 7
15 6
16 7
17 5
18 7
19 8
20 5
21 5
22 5
23 5
24 10
25 10
26 11
27 11
28 10
29 12
30 10
31 12
32 12
33 12
34 13
35 15
36 14
37 15
38 15
39 14
40 14
41 5
42 5
43 5
44 5
45 5
46 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     2d1 <gsl_matrix_complex_long_double_fscanf+0x91>
shl    $0x5,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    28e <gsl_matrix_complex_long_double_fscanf+0x4e>
jmp    2c0 <gsl_matrix_complex_long_double_fscanf+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     2c0 <gsl_matrix_complex_long_double_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  2a5 <gsl_matrix_complex_long_double_fscanf+0x65>
test   %eax,%eax
je     280 <gsl_matrix_complex_long_double_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   2f4 <gsl_matrix_complex_long_double_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_fscanf (FILE * stream, gsl_matrix_complex_long_double * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_long_double_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_long_double_raw_fscanf (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rsi,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
random8_bsd_set (void *vstate, unsigned long int s)
{
  random8_state_t *state = (random8_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 27 <close_stdout+0x7>
push   %rbx
callq  2d <close_stdout+0xd>
test   %eax,%eax
je     44 <close_stdout+0x24>
cmpb   $0x0,0x0(%rip)        # 38 <close_stdout+0x18>
je     56 <close_stdout+0x36>
callq  3f <close_stdout+0x1f>
cmpl   $0x20,(%rax)
jne    56 <close_stdout+0x36>
mov    0x0(%rip),%rdi        # 4b <close_stdout+0x2b>
callq  50 <close_stdout+0x30>
test   %eax,%eax
jne    88 <close_stdout+0x68>
pop    %rbx
retq   
mov    0x0(%rip),%rdi        # 5d <close_stdout+0x3d>
test   %rdi,%rdi
je     93 <close_stdout+0x73>
callq  67 <close_stdout+0x47>
mov    %rax,%rbx
callq  6f <close_stdout+0x4f>
mov    (%rax),%esi
mov    $0x0,%r8d
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  88 <close_stdout+0x68>
mov    0x0(%rip),%edi        # 8e <close_stdout+0x6e>
callq  93 <close_stdout+0x73>
callq  98 <close_stdout+0x78>
mov    (%rax),%esi
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  ad <close_stdout+0x8d>
jmp    88 <close_stdout+0x68>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (close_stream (stdout) != 0
      && !(ignore_EPIPE && (*__errno_location ()) == 32))
    {
      char const *write_error = ((const char *) ("write error"));
      if (file_name)
        error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
               write_error);
      else
        error (0, (*__errno_location ()), "%s", write_error);
      _exit (exit_failure);
    }
   if (close_stream (stderr) != 0)
     _exit (exit_failure);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 14
12 14
13 14
14 14
15 16
16 16
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 15
31 15
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     5c48 <rc_run_section+0xa8>
test   %rcx,%rcx
mov    %edi,%r13d
mov    %rdx,%rbx
mov    %rcx,%rbp
mov    %r8,%r14
mov    %r9,%r15
jne    5be0 <rc_run_section+0x40>
jmp    5c42 <rc_run_section+0xa2>
mov    %rbp,%rsi
callq  5bd8 <rc_run_section+0x38>
test   %eax,%eax
je     5c20 <rc_run_section+0x80>
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    5bd0 <rc_run_section+0x30>
mov    0x20(%r12),%rbx
mov    $0x0,%edi
callq  5bf7 <rc_run_section+0x57>
add    $0x8,%rsp
mov    %rax,%rdx
xor    %esi,%esi
mov    %rbx,%rcx
xor    %edi,%edi
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   5c16 <rc_run_section+0x76>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13d,%edi
mov    %r14,%rcx
mov    %r15,%r8
pop    %r13
pop    %r14
pop    %r15
jmpq   5c42 <rc_run_section+0xa2>
mov    0x20(%rsi),%rbp
jmp    5be0 <rc_run_section+0x40>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
rc_run_section (int method, RC_SECTION *sec, struct rc_secdef *secdef,
  const char *class_name,
  void *data, MESSAGE msg)
{
  if (!sec)
    return;
  if (!class_name)
    class_name = sec->name;
  for (; secdef->name; secdef++)
    {
      if (!strcmp (secdef->name, class_name))
 {
   eval_section (method, sec, secdef, data, msg);
   return;
 }
    }
  anubis_error (0, 0, gettext("Unknown section: %s"), sec->name);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 11
20 11
21 11
22 11
23 9
24 9
25 9
26 9
27 17
28 17
29 17
30 18
31 17
32 17
33 17
34 17
35 17
36 18
37 18
38 18
39 18
40 18
41 18
42 17
43 17
44 18
45 13
46 13
47 18
48 18
49 18
50 13
51 13
52 13
53 18
54 18
55 18
56 13
57 8
58 8
59 18
60 18
61 18
62 18
63 18
64 18
65 18
66 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  2ec <mu_property_is_set+0xc>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_property_is_set (mu_property_t prop, const char *key)
{
  struct property_item *item = mu_assoc_ref (prop->assoc, key);
  return (item == ((void *)0)) ? 0 : 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 4
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
xor    %ebx,%ebx
test   %rdi,%rdi
je     888 <ignore_primitive+0x28>
callq  86d <ignore_primitive+0xd>
test   %rax,%rax
je     888 <ignore_primitive+0x28>
mov    0x8(%rax),%rdi
mov    $0x21,%esi
xor    %ebx,%ebx
callq  882 <ignore_primitive+0x22>
test   %rax,%rax
setne  %bl
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
ignore_primitive(char *name)
{
  struct unitlist *ul;
  if (!name)
    return 0;
  ul = ulookup(name);
  if (ul && strchr(ul->value, '!'))
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 4
4 4
5 6
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 10
15 10
16 10
17 10
<<<sep_out_sample>>>
cmp    $0x3,%edi
mov    $0x0,%eax
ja     25 <csv_strerror+0x15>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rax
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_strerror(int status)
{
  if (status >= 4 || status < 0)
    return csv_errors[4];
  else
    return csv_errors[status];
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 6
5 6
6 7
7 7
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     1ad1 <gsl_matrix_uint_fscanf+0x91>
lea    0x0(,%r15,4),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    1a8e <gsl_matrix_uint_fscanf+0x4e>
jmp    1ac0 <gsl_matrix_uint_fscanf+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1ac0 <gsl_matrix_uint_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1aa5 <gsl_matrix_uint_fscanf+0x65>
test   %eax,%eax
je     1a80 <gsl_matrix_uint_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1af4 <gsl_matrix_uint_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_fscanf (FILE * stream, gsl_matrix_uint * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uint_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uint_raw_fscanf (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
test   %rcx,%rcx
mov    %rdx,%rax
je     9f0 <output_file_now+0x20>
cmpq   $0xffffffffffffffff,0x30(%rdx)
je     a0d <output_file_now+0x3d>
movzbl %r9b,%r9d
jmpq   9e8 <output_file_now+0x18>
nopl   0x0(%rax,%rax,1)
test   %r9b,%r9b
jne    a00 <output_file_now+0x30>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x1,%edx
mov    %rax,%rsi
jmpq   a0d <output_file_now+0x3d>
push   %rax
callq  a13 <output_file_now+0x43>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_file_now (char const *from, _Bool *from_needs_removal,
   const struct stat *from_st, char const *to,
   mode_t mode, _Bool backup)
{
  if (to == ((void *)0))
    {
      if (backup)
 create_backup (from, from_st, 1);
    }
  else
    {
      ((from_st->st_size != -1) ? (void) (0) : __assert_fail ("from_st->st_size != -1", "patch.c", 1863, __PRETTY_FUNCTION__));
      move_file (from, from_needs_removal, from_st, to, mode, backup);
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 12
5 12
6 13
7 13
8 13
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 4
17 4
18 4
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
test   %rdx,%rdx
movsd  (%rdi),%xmm3
movsd  %xmm3,(%rsp)
movapd %xmm3,%xmm1
je     498 <gsl_stats_min+0x68>
lea    0x0(,%rsi,8),%r13
xor    %ebx,%ebx
lea    (%rdi,%r13,1),%rbp
jmp    47f <gsl_stats_min+0x4f>
nop
add    $0x1,%rbx
cmp    %r12,%rbx
je     4b0 <gsl_stats_min+0x80>
movsd  0x0(%rbp),%xmm1
add    %r13,%rbp
movapd %xmm1,%xmm2
minsd  (%rsp),%xmm2
movsd  %xmm2,(%rsp)
movapd %xmm1,%xmm0
movsd  %xmm1,0x8(%rsp)
callq  48e <gsl_stats_min+0x5e>
test   %eax,%eax
movsd  0x8(%rsp),%xmm1
je     460 <gsl_stats_min+0x30>
add    $0x18,%rsp
movapd %xmm1,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
movsd  (%rsp),%xmm1
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
movapd %xmm1,%xmm0
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_min (const double data[], const size_t stride,
                          const size_t n)
{
  double min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      double xi = data[i * stride];
      if (xi < min)
        min = xi;
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        return xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 4
9 4
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 8
21 8
22 8
23 8
24 8
25 11
26 11
27 11
28 11
29 11
30 11
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    3350 <gsl_matrix_short_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdi,1),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  3372 <gsl_matrix_short_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_row (gsl_matrix_short * m, const size_t i)
{
  _gsl_vector_short_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_short v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fminimizer_minimum (const gsl_multimin_fminimizer * s)
{
  return s->fval;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     100 <mu_observer_get_owner+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_observer_get_owner (mu_observer_t observer)
{
  return (observer) ? observer->owner : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
je     1d70 <add_argless_short_opt+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x10(%rsi)
jne    1d67 <add_argless_short_opt+0x7>
mov    0x18(%rsi),%eax
or     0x18(%rdi),%eax
test   $0x10,%al
jne    1d67 <add_argless_short_opt+0x7>
mov    (%rcx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rcx)
mov    0x8(%rdi),%edx
mov    %dl,(%rax)
jmp    1d67 <add_argless_short_opt+0x7>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_argless_short_opt (const struct argp_option *opt,
                       const struct argp_option *real,
                       const char *domain, void *cookie)
{
  char **snao_end = cookie;
  if (!(opt->arg || real->arg)
      && !((opt->flags | real->flags) & 0x10))
    *(*snao_end)++ = opt->key;
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
3 10
4 10
5 10
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
jmpq   2915 <php_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    %rsi,(%rdi)
mov    0x8(%rdi),%rax
jbe    30 <gsl_histogram2d_get+0x30>
cmp    %rdx,%rax
jbe    58 <gsl_histogram2d_get+0x58>
imul   %rax,%rsi
mov    0x20(%rdi),%rcx
add    %rsi,%rdx
movsd  (%rcx,%rdx,8),%xmm0
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x23,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  49 <gsl_histogram2d_get+0x49>
xorpd  %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x29,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  71 <gsl_histogram2d_get+0x71>
xorpd  %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_get (const gsl_histogram2d * h, const size_t i, const size_t j)
{
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  if (i >= nx)
    {
      do { gsl_error ("index i lies outside valid range of 0 .. nx - 1",
 "get2d.c"
      ,
 35
      , GSL_EDOM) ; return 0 ; } while (0)
                                    ;
    }
  if (j >= ny)
    {
      do { gsl_error ("index j lies outside valid range of 0 .. ny - 1",
 "get2d.c"
      ,
 41
      , GSL_EDOM) ; return 0 ; } while (0)
                                    ;
    }
  return h->bin[i * ny + j];
}
<<<sep_in_sample>>>
1 2
2 5
3 4
4 5
5 14
6 14
7 23
8 23
9 23
10 23
11 24
12 24
13 24
14 7
15 7
16 7
17 7
18 7
19 11
20 24
21 24
22 24
23 16
24 16
25 16
26 16
27 16
28 20
29 24
30 24
31 24
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0x10(%rax),%rsi
mov    (%rdi),%rax
mov    0x10(%rax),%rdi
jmpq   a63 <dumpdef_cmp+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dumpdef_cmp (const void *s1, const void *s2)
{
  return strcmp (((* (symbol *const *) s1)->name),
                 ((* (symbol *const *) s2)->name));
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a89 <rl_free_line_state+0x9>
callq  a8e <rl_free_line_state+0xe>
test   %rax,%rax
je     a9b <rl_free_line_state+0x1b>
movq   $0x0,0x10(%rax)
callq  aa0 <rl_free_line_state+0x20>
callq  aa5 <rl_free_line_state+0x25>
add    $0x8,%rsp
jmpq   aae <rl_free_line_state+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
rl_free_line_state ()
{
  register HIST_ENTRY *entry;
  rl_free_undo_list ();
  entry = current_history ();
  if (entry)
    entry->data = (char *)((void *)0);
  _rl_kill_kbd_macro ();
  rl_clear_message ();
  _rl_reset_argument ();
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 6
6 7
7 8
8 9
9 11
10 10
11 10
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    %rdi,%rsi
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 383 <gpath_fid2path+0x13>
callq  388 <gpath_fid2path+0x18>
mov    0x0(%rip),%edx        # 38e <gpath_fid2path+0x1e>
test   %edx,%edx
jle    3d2 <gpath_fid2path+0x62>
test   %rax,%rax
mov    %rax,%rbx
jne    3a8 <gpath_fid2path+0x38>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
test   %rbp,%rbp
je     39a <gpath_fid2path+0x2a>
mov    0x0(%rip),%rdi        # 3b4 <gpath_fid2path+0x44>
callq  3b9 <gpath_fid2path+0x49>
cmpb   $0x6f,(%rax)
sete   %al
movzbl %al,%eax
add    $0x1,%eax
mov    %eax,0x0(%rbp)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%ecx
mov    $0xd9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3eb <gpath_fid2path+0x7b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_fid2path(const char *fid, int *type)
{
 const char *path = dbop_get(dbop, fid);
 ((opened > 0) ? (void) (0) : __assert_fail ("opened > 0", "gpathop.c", 217, __PRETTY_FUNCTION__));
 if (path && type) {
  const char *flag = dbop_getflag(dbop);
  *type = (*flag == 'o') ? 2 : 1;
 }
 return path;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 10
15 10
16 10
17 10
18 10
19 10
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 10
30 10
31 10
32 10
33 10
34 4
35 4
36 4
37 4
38 4
39 4
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_size (gl_list_t list)
{
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  619 <mbox_message_uid+0x9>
test   %rbx,%rbx
je     625 <mbox_message_uid+0x15>
mov    0x20(%rax),%rax
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mbox_message_uid (mu_message_t msg, size_t *puid)
{
  mbox_message_t mum = mu_message_get_owner (msg);
  if (puid)
    *puid = mum->uid;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 83d <GetSBMLKeywordCode+0xd>
cmpb   $0x0,(%rsi)
je     872 <GetSBMLKeywordCode+0x42>
mov    %rdi,%rbp
mov    $0x0,%ebx
jmp    85c <GetSBMLKeywordCode+0x2c>
nopl   0x0(%rax)
add    $0x10,%rbx
mov    (%rbx),%rsi
cmpb   $0x0,(%rsi)
je     868 <GetSBMLKeywordCode+0x38>
mov    %rbp,%rdi
callq  864 <GetSBMLKeywordCode+0x34>
test   %eax,%eax
jne    850 <GetSBMLKeywordCode+0x20>
mov    0x8(%rbx),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%ebx
jmp    868 <GetSBMLKeywordCode+0x38>
nopl   0x0(%rax)
<<<sep_in_sample>>>
GetSBMLKeywordCode (PSTR szKeyword)
{
  PKM pkm = &vrgSBMLKW[0];
  while (*pkm->szKeyword && strcmp (szKeyword, pkm->szKeyword))
    pkm++;
  return (pkm->iKWCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 3
9 3
10 3
11 5
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 7
21 7
22 7
23 7
24 3
25 3
26 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x28,%edi
push   %rbx
callq  14 <rec_buf_new+0x14>
test   %rax,%rax
mov    %rax,%rbx
je     46 <rec_buf_new+0x46>
mov    %rbp,0x18(%rax)
mov    %r12,0x20(%rax)
mov    $0x200,%edi
callq  2e <rec_buf_new+0x2e>
test   %rax,%rax
mov    %rax,(%rbx)
movq   $0x200,0x8(%rbx)
movq   $0x0,0x10(%rbx)
je     4e <rec_buf_new+0x4e>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbx,%rdi
xor    %ebx,%ebx
callq  58 <rec_buf_new+0x58>
jmp    46 <rec_buf_new+0x46>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_new (char **data, size_t *size)
{
  rec_buf_t new;
  new = malloc (sizeof (struct rec_buf_s));
  if (new)
    {
      new->data_pointer = data;
      new->size_pointer = size;
      new->data = malloc (512);
      new->size = 512;
      new->used = 0;
      if (!new->data)
        {
          free (new);
          new = ((void *)0);
        }
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 4
10 5
11 7
12 8
13 9
14 9
15 12
16 9
17 10
18 11
19 12
20 19
21 19
22 19
23 19
24 19
25 14
26 15
27 14
28 14
29 14
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
mov    0x10(%rdi),%ecx
mov    (%rdi),%rdx
mov    %rsi,%r8
mov    0x0(%rip),%rdi        # 9d0 <ParseError+0x10>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   9dc <ParseError+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ParseError(struct lex_record *p, char *s)
{
 fprintf(stderr, "error in file %s (line %d):\n\t%s\n", p->filename,
   p->lineno, s);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d50 <via_get_protocol+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_get_protocol (osip_via_t * via)
{
  if (via == ((void *)0))
    return ((void *)0);
  return via->protocol;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
movl   $0x1,0x48(%rax)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  src->start_of_file = 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    $0x100,%r8d
test   $0x1,%dl
jne    e1 <string_to_array+0x61>
test   $0x2,%dil
jne    f3 <string_to_array+0x73>
test   $0x4,%dil
jne    107 <string_to_array+0x87>
mov    %r8d,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%r8b
rep stos %rax,%es:(%rdi)
je     b5 <string_to_array+0x35>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r8b
je     c5 <string_to_array+0x45>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%r8d
je     d8 <string_to_array+0x58>
movb   $0x0,(%rdi)
jmp    d8 <string_to_array+0x58>
movb   $0x1,(%rdx,%rax,1)
add    $0x1,%rsi
movzbl (%rsi),%eax
test   %al,%al
jne    d0 <string_to_array+0x50>
repz retq 
lea    0x1(%rdx),%rdi
movb   $0x0,(%rdx)
mov    $0xff,%r8w
test   $0x2,%dil
je     94 <string_to_array+0x14>
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%r8d
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     9a <string_to_array+0x1a>
movl   $0x0,(%rdi)
sub    $0x4,%r8d
add    $0x4,%rdi
jmp    9a <string_to_array+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_array (unsigned char arr[256], const unsigned char * string)
{
  int c;
  for (c = 0 ; c < 256 ; c++)
    arr [c] = 0;
  for ( ; *string ; string ++)
    arr [*string] = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 2
20 2
21 2
22 2
23 2
24 2
25 2
26 7
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30 <stringprep_check_version+0x30>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <stringprep_check_version+0x13>
xor    %edx,%edx
test   %eax,%eax
mov    $0x0,%eax
cmovle %rax,%rdx
add    $0x8,%rsp
mov    %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
stringprep_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.33") <= 0)
    return "1.33";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 4
15 6
16 6
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2896 <asm_set_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_set_lineno (int line_number )
{
    asm_lineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     29c <run_err+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rbx
mov    0x0(%rip),%rsi        # 2ae <run_err+0x6e>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
addl   $0x1,0x0(%rip)        # 2bf <run_err+0x7f>
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
test   %rsi,%rsi
je     3b0 <run_err+0x170>
mov    $0x1,%edi
callq  2e7 <run_err+0xa7>
mov    0x0(%rip),%rcx        # 2ee <run_err+0xae>
mov    $0x5,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  302 <run_err+0xc2>
mov    0x0(%rip),%rdi        # 309 <run_err+0xc9>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
callq  316 <run_err+0xd6>
mov    0x0(%rip),%rsi        # 31d <run_err+0xdd>
mov    $0xa,%edi
callq  327 <run_err+0xe7>
mov    0x0(%rip),%rdi        # 32e <run_err+0xee>
callq  333 <run_err+0xf3>
mov    0x0(%rip),%eax        # 339 <run_err+0xf9>
test   %eax,%eax
jne    3a3 <run_err+0x163>
mov    0x0(%rip),%rdx        # 344 <run_err+0x104>
mov    0x0(%rip),%rdi        # 34b <run_err+0x10b>
mov    $0x0,%esi
xor    %eax,%eax
callq  357 <run_err+0x117>
lea    0xe0(%rsp),%rax
mov    0x0(%rip),%rdi        # 366 <run_err+0x126>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  392 <run_err+0x152>
mov    0x0(%rip),%rsi        # 399 <run_err+0x159>
mov    $0xa,%edi
callq  3a3 <run_err+0x163>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%edi        # 3b6 <run_err+0x176>
mov    $0x0,%esi
callq  3c0 <run_err+0x180>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 3ca <run_err+0x18a>
je     3a3 <run_err+0x163>
mov    %rax,%rsi
jmpq   2dd <run_err+0x9d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
run_err (const char *fmt, ...)
{
  static FILE *fp;
  va_list ap;
  __builtin_va_start(ap,fmt);
  ++errs;
  if (fp == ((void *)0) && !(fp = fdopen (rem, "w")))
    return;
  fprintf (fp, "%c", 0x01);
  fprintf (fp, "rcp: ");
  vfprintf (fp, fmt, ap);
  __builtin_va_end(ap);
  fprintf (fp, "\n");
  fflush (fp);
  if (!iamremote)
    {
      fprintf (stderr, "%s: ", program_invocation_name);
      __builtin_va_start(ap,fmt);
      vfprintf (stderr, fmt, ap);
      __builtin_va_end(ap);
      fprintf (stderr, "\n");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 5
19 2
20 7
21 5
22 5
23 6
24 5
25 5
26 5
27 7
28 7
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 11
37 11
38 11
39 11
40 13
41 13
42 13
43 14
44 14
45 15
46 15
47 15
48 17
49 17
50 17
51 17
52 17
53 18
54 19
55 19
56 19
57 18
58 18
59 18
60 18
61 18
62 19
63 21
64 21
65 21
66 23
67 23
68 23
69 23
70 7
71 7
72 7
73 7
74 7
75 7
76 7
77 7
78 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1c7 <get_key_buffer_len+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_key_buffer_len(void)
{
    return key_buffer_len;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     16b0 <gsl_block_uchar_free+0x20>
mov    0x8(%rdi),%rdi
callq  16a2 <gsl_block_uchar_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   16ab <gsl_block_uchar_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uchar_free (gsl_block_uchar * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # b917 <dispose_saved_dollar_vars+0x7>
test   %rax,%rax
je     b927 <dispose_saved_dollar_vars+0x17>
movslq 0x0(%rip),%rdx        # b923 <dispose_saved_dollar_vars+0x13>
test   %edx,%edx
jne    b930 <dispose_saved_dollar_vars+0x20>
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    (%rax,%rdx,8),%rdi
callq  b93d <dispose_saved_dollar_vars+0x2d>
movslq 0x0(%rip),%rdx        # b944 <dispose_saved_dollar_vars+0x34>
mov    0x0(%rip),%rax        # b94b <dispose_saved_dollar_vars+0x3b>
movq   $0x0,(%rax,%rdx,8)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dispose_saved_dollar_vars ()
{
  if (!dollar_arg_stack || dollar_arg_stack_index == 0)
    return;
  dispose_words (dollar_arg_stack[dollar_arg_stack_index]);
  dollar_arg_stack[dollar_arg_stack_index] = (WORD_LIST *)((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 7
8 7
9 2
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     440 <gsl_monte_plain_free+0x20>
mov    0x8(%rdi),%rdi
callq  432 <gsl_monte_plain_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   43b <gsl_monte_plain_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_monte_plain_free (gsl_monte_plain_state * s)
{
  if (!s) { return ; };
  free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    %rdi,%rcx
mov    %fs:0x28,%rax
mov    %rax,0x68(%rsp)
xor    %eax,%eax
movzbl (%rdi),%edx
cmp    $0x5b,%dl
jne    2384 <rec_sex_lex_extract_index+0x34>
jmp    2388 <rec_sex_lex_extract_index+0x38>
nopl   0x0(%rax)
add    $0x1,%rcx
movzbl (%rcx),%edx
cmp    $0x5b,%dl
je     2388 <rec_sex_lex_extract_index+0x38>
test   %dl,%dl
jne    2378 <rec_sex_lex_extract_index+0x28>
xor    %eax,%eax
test   %dl,%dl
je     23c7 <rec_sex_lex_extract_index+0x77>
movzbl 0x1(%rcx),%edx
cmp    $0x5d,%dl
je     23dc <rec_sex_lex_extract_index+0x8c>
xor    %eax,%eax
mov    %rsp,%rdi
nopl   0x0(%rax)
mov    %dl,(%rdi,%rax,1)
lea    0x1(%rax),%r8d
add    $0x1,%rax
movzbl 0x1(%rcx,%rax,1),%edx
cmp    $0x5d,%dl
jne    23a0 <rec_sex_lex_extract_index+0x50>
movslq %r8d,%r8
movb   $0x0,(%rsp,%r8,1)
callq  23c2 <rec_sex_lex_extract_index+0x72>
mov    $0x1,%eax
mov    0x68(%rsp),%rsi
xor    %fs:0x28,%rsi
jne    23e4 <rec_sex_lex_extract_index+0x94>
add    $0x78,%rsp
retq   
xor    %r8d,%r8d
mov    %rsp,%rdi
jmp    23b5 <rec_sex_lex_extract_index+0x65>
callq  23e9 <rec_sex_lex_extract_index+0x99>
<<<sep_in_sample>>>
rec_sex_lex_extract_index (char *str,
                           int *num)
{
  _Bool res;
  char *p;
  char aux[100];
  int aux_size;
  aux_size = 0;
  p = str;
  while ((*p != 0) && (*p != '['))
    {
      p++;
    }
  if (*p == 0)
    {
      res = 0;
    }
  else
    {
      p++;
      while (*p != ']')
        {
          aux[aux_size++] = *p;
          p++;
        }
      aux[aux_size] = 0;
      if (!rec_atoi (aux, num))
        {
          res = 0;
        }
      res = 1;
    }
  return res;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 10
7 10
8 10
9 10
10 10
11 12
12 10
13 10
14 10
15 10
16 10
17 16
18 14
19 14
20 21
21 21
22 21
23 21
24 21
25 21
26 23
27 23
28 23
29 21
30 21
31 21
32 26
33 26
34 27
35 31
36 34
37 34
38 34
39 34
40 34
41 8
42 8
43 8
44 34
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x0,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
Ambiguous (char *s)
{
  return ((char **) s == &ambiguous);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 516 <gid_substitute+0x6>
push   %rbx
mov    %rdi,%rbx
test   %eax,%eax
je     530 <gid_substitute+0x20>
movl   $0x0,(%rbx)
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  53f <gid_substitute+0x2f>
test   %eax,%eax
jne    560 <gid_substitute+0x50>
movl   $0xfffffffe,0x0(%rip)        # 54d <gid_substitute+0x3d>
mov    $0xfffffffe,%eax
movl   $0x0,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 566 <gid_substitute+0x56>
movl   $0x0,(%rbx)
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gid_substitute (int *negative)
{
  gid_t r;
  static gid_t gid_nobody;
  if (!gid_nobody && !gname_to_gid ("nobody", &gid_nobody))
    gid_nobody = -2;
  r = gid_nobody;
  *negative = r < 0;
  return r;
}
<<<sep_in_sample>>>
1 5
2 2
3 2
4 5
5 5
6 8
7 10
8 10
9 10
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 8
18 10
19 10
20 10
21 10
22 8
23 10
24 10
25 10
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
movslq %edx,%rdx
push   %r12
mov    %rsi,%r12
xor    %esi,%esi
push   %rbp
mov    %edi,%ebp
mov    %r12,%rdi
push   %rbx
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
callq  d9f <_rl_read_mbstring+0x2f>
test   %ebp,%ebp
js     dfb <_rl_read_mbstring+0x8b>
test   %r13d,%r13d
jle    dfb <_rl_read_mbstring+0x8b>
xor    %ebx,%ebx
jmp    ddf <_rl_read_mbstring+0x6f>
nopl   0x0(%rax)
orq    $0x40,0x0(%rip)        # db8 <_rl_read_mbstring+0x48>
callq  dbd <_rl_read_mbstring+0x4d>
mov    %eax,%ecx
mov    %eax,%ebp
lea    0x1(%rbx),%eax
not    %ecx
andq   $0xffffffffffffffbf,0x0(%rip)        # dce <_rl_read_mbstring+0x5e>
shr    $0x1f,%ecx
cmp    %eax,%r13d
setg   %al
add    $0x1,%rbx
test   %cl,%al
je     dfb <_rl_read_mbstring+0x8b>
mov    %bpl,(%r12,%rbx,1)
mov    %rsp,%rsi
mov    %r12,%rdi
movq   $0x0,(%rsp)
callq  df6 <_rl_read_mbstring+0x86>
cmp    $0xfffffffe,%eax
je     db0 <_rl_read_mbstring+0x40>
mov    0x8(%rsp),%rdx
xor    %fs:0x28,%rdx
mov    %ebp,%eax
jne    e18 <_rl_read_mbstring+0xa8>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  e1d <_rl_read_mbstring+0xad>
<<<sep_in_sample>>>
_rl_read_mbstring (first, mb, mlen)
     int first;
     char *mb;
     int mlen;
{
  int i, c;
  mbstate_t ps;
  c = first;
  memset (mb, 0, mlen);
  for (i = 0; c >= 0 && i < mlen; i++)
    {
      mb[i] = (char)c;
      memset (&ps, 0, sizeof (mbstate_t));
      if (_rl_get_char_len (mb, &ps) == -2)
 {
   (rl_readline_state |= (0x0000040));
   c = rl_read_key ();
   (rl_readline_state &= ~(0x0000040));
 }
      else
 break;
    }
  return c;
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 5
5 5
6 9
7 5
8 5
9 9
10 5
11 5
12 5
13 5
14 5
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 16
24 17
25 10
26 17
27 17
28 10
29 18
30 10
31 10
32 10
33 10
34 10
35 10
36 12
37 14
38 14
39 13
40 14
41 14
42 14
43 24
44 24
45 24
46 24
47 24
48 24
49 24
50 24
51 24
52 24
53 24
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 296 <dis_enableNetwork+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dis_enableNetwork(int state)
{
 network_enabled = state;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 57 <send_help+0x7>
push   %rbx
mov    $0x0,%ebx
test   %rsi,%rsi
je     89 <send_help+0x39>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     7d <send_help+0x2d>
mov    $0x0,%edi
xor    %eax,%eax
callq  7d <send_help+0x2d>
add    $0x28,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    68 <send_help+0x18>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
send_help (void)
{
  struct sendlist *s;
  for (s = Sendlist; s->name; s++)
    {
      if (s->help)
 printf ("%-15s %s\n", s->name, s->help);
    }
  return (0);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 7
13 4
14 4
15 4
16 4
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    4658 <gsl_matrix_complex_const_column+0x38>
shl    $0x4,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  467a <gsl_matrix_complex_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_const_column (const gsl_matrix_complex * m, const size_t j)
{
  _gsl_vector_complex_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 2;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  9e <rkck_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  ac <rkck_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  ba <rkck_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  c8 <rkck_reset+0x48>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  d6 <rkck_reset+0x56>
mov    0x28(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  e4 <rkck_reset+0x64>
mov    0x38(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  f2 <rkck_reset+0x72>
mov    0x30(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  100 <rkck_reset+0x80>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rkck_reset (void *vstate, size_t dim)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->k4),0,(dim)*sizeof(double));
  memset((state->k5),0,(dim)*sizeof(double));
  memset((state->k6),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 13
39 13
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
mov    %rdx,%rbp
push   %rbx
movq   $0x0,(%rdx)
je     48 <osip_message_get_via+0x48>
lea    0x160(%rdi),%r12
mov    %esi,%ebx
mov    %r12,%rdi
callq  24 <osip_message_get_via+0x24>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    3d <osip_message_get_via+0x3d>
mov    %ebx,%esi
mov    %r12,%rdi
callq  37 <osip_message_get_via+0x37>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
mov    $0xfffffffe,%edx
jmp    3d <osip_message_get_via+0x3d>
nop
<<<sep_in_sample>>>
osip_message_get_via (const osip_message_t * sip, int pos, osip_via_t ** dest)
{
  *dest = ((void *)0);
  if (sip == ((void *)0))
    return -2;
  if (osip_list_size (&sip->vias) <= pos)
    return -1;
  *dest = (osip_via_t *) osip_list_get (&sip->vias, pos);
  return pos;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 7
14 6
15 8
16 8
17 8
18 9
19 8
20 10
21 10
22 10
23 10
24 10
25 10
26 5
27 5
28 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
xorpd  %xmm0,%xmm0
test   %rax,%rax
je     64a <gsl_rstat_kurtosis+0x4a>
js     650 <gsl_rstat_kurtosis+0x50>
cvtsi2sd %rax,%xmm0
movapd %xmm0,%xmm2
movsd  0x18(%rdi),%xmm1
subsd  0x0(%rip),%xmm2        # 625 <gsl_rstat_kurtosis+0x25>
mulsd  %xmm1,%xmm1
movapd %xmm2,%xmm3
divsd  %xmm0,%xmm3
movapd %xmm3,%xmm0
mulsd  %xmm2,%xmm0
mulsd  0x28(%rdi),%xmm0
divsd  %xmm1,%xmm0
subsd  0x0(%rip),%xmm0        # 64a <gsl_rstat_kurtosis+0x4a>
repz retq 
nopl   0x0(%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
jmp    614 <gsl_rstat_kurtosis+0x14>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rstat_kurtosis(gsl_rstat_workspace *w)
{
  if (w->n > 0)
    {
      double n = (double) w->n;
      double fac = ((n - 1.0) / n) * (n - 1.0);
      return ((fac * w->M4) / (w->M2 * w->M2) - 3.0);
    }
  else
    return 0.0;
}
<<<sep_in_sample>>>
1 3
2 10
3 3
4 3
5 5
6 5
7 6
8 7
9 6
10 7
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 11
19 11
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 206 <sigint_handler+0x6>
test   %edx,%edx
je     215 <sigint_handler+0x15>
movl   $0x1,0x0(%rip)        # 214 <sigint_handler+0x14>
retq   
push   %rax
callq  21b <sigint_handler+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigint_handler( int signum )
  {
  if( mutex ) sigint_pending = true;
  else
    {
    sigset_t set;
    sigint_pending = false;
    sigemptyset( &set );
    sigaddset( &set, signum );
    sigprocmask( 1, &set, 0 );
    longjmp( jmp_state, -1 );
    }
  }
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 2
8 2
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %rcx,%rcx
je     848 <gsl_vector_complex_float_isnull+0x68>
mov    0x10(%rdi),%rax
xorps  %xmm1,%xmm1
ucomiss (%rax),%xmm1
jp     850 <gsl_vector_complex_float_isnull+0x70>
jne    850 <gsl_vector_complex_float_isnull+0x70>
ucomiss 0x4(%rax),%xmm1
jp     850 <gsl_vector_complex_float_isnull+0x70>
jne    850 <gsl_vector_complex_float_isnull+0x70>
lea    0x0(,%rdx,8),%rsi
neg    %rdx
lea    0x0(,%rdx,8),%rdi
movaps %xmm1,%xmm0
lea    0x4(%rax,%rsi,1),%rax
xor    %edx,%edx
jmp    83f <gsl_vector_complex_float_isnull+0x5f>
nopl   0x0(%rax)
ucomiss -0x4(%rax),%xmm1
jp     850 <gsl_vector_complex_float_isnull+0x70>
ucomiss -0x4(%rax),%xmm0
jne    850 <gsl_vector_complex_float_isnull+0x70>
add    %rsi,%rax
ucomiss (%rax,%rdi,1),%xmm0
jp     850 <gsl_vector_complex_float_isnull+0x70>
jne    850 <gsl_vector_complex_float_isnull+0x70>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    828 <gsl_vector_complex_float_isnull+0x48>
mov    $0x1,%eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_float_isnull (const gsl_vector_complex_float * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 11
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 6
19 6
20 6
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 6
30 6
31 6
32 17
33 17
34 17
35 13
36 18
37 18
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    7018 <gsl_matrix_ushort_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,2),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  703a <gsl_matrix_ushort_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_const_column (const gsl_matrix_ushort * m, const size_t j)
{
  _gsl_vector_ushort_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ushort v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x10,%edi
ja     119 <cdio_is_discmode_cdrom+0x19>
mov    $0x1,%eax
mov    %edi,%ecx
shl    %cl,%rax
test   $0x1000f,%eax
setne  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_is_discmode_cdrom(discmode_t discmode)
{
  switch (discmode) {
  case CDIO_DISC_MODE_CD_DA:
  case CDIO_DISC_MODE_CD_DATA:
  case CDIO_DISC_MODE_CD_XA:
  case CDIO_DISC_MODE_CD_MIXED:
  case CDIO_DISC_MODE_NO_INFO:
    return 1;
  default:
    return 0;
  }
}
<<<sep_in_sample>>>
1 11
2 11
3 11
4 11
5 11
6 11
7 11
8 11
9 13
10 13
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    0x0(%rip),%rdi        # 2c <IsMathFunc+0xc>
push   %rbp
push   %rbx
movzbl (%rdi),%ebp
test   %bpl,%bpl
je     68 <IsMathFunc+0x48>
mov    $0x0,%ebx
jmp    4f <IsMathFunc+0x2f>
nopl   (%rax)
mov    (%rbx),%rdi
add    $0x8,%rbx
movzbl (%rdi),%ebp
test   %bpl,%bpl
je     68 <IsMathFunc+0x48>
mov    %r12,%rsi
callq  57 <IsMathFunc+0x37>
test   %eax,%eax
jne    40 <IsMathFunc+0x20>
pop    %rbx
movsbl %bpl,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
IsMathFunc (PSTR sz)
{
  int i = 0;
  while (*vrgszMathFuncs[i] && strcmp (vrgszMathFuncs[i], sz))
    i++;
  return (*vrgszMathFuncs[i]);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    %r8,0x8(%rsp)
callq  30f <_body_readline+0x1f>
mov    %rax,%rdi
callq  317 <_body_readline+0x27>
mov    %rax,%rdi
mov    %rax,%rbx
callq  322 <_body_readline+0x32>
lea    0x18(%rsp),%rsi
mov    %rax,%r14
mov    %rbx,%rdi
callq  332 <_body_readline+0x42>
mov    %r13,%rcx
add    0x10(%r14),%rcx
mov    0x8(%rsp),%r8
mov    0x18(%rsp),%rdi
mov    %r12,%rdx
mov    %rbp,%rsi
callq  34e <_body_readline+0x5e>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_body_readline (mu_stream_t stream, char *optr, size_t osize,
  mu_off_t offset, size_t *nbytes)
{
  mu_body_t body = mu_stream_get_owner (stream);
  mu_message_t msg = mu_body_get_owner (body);
  struct _mu_rfc822_message *mp = mu_message_get_owner (msg);
  mu_stream_t str;
  mu_message_get_stream (msg, &str);
  return mu_stream_readline (str, optr, osize,
        mp->body_start + offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 6
15 5
16 6
17 8
18 6
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 11
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # 57e8 <_rl_move_vert+0x8>
mov    %edi,%r12d
push   %rbp
cmp    %edi,%eax
push   %rbx
je     5847 <_rl_move_vert+0x67>
cmp    0x0(%rip),%edi        # 57f7 <_rl_move_vert+0x17>
jg     5847 <_rl_move_vert+0x67>
mov    %edi,%ebp
sub    %eax,%ebp
test   %ebp,%ebp
jle    5850 <_rl_move_vert+0x70>
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 580f <_rl_move_vert+0x2f>
mov    $0xa,%edi
add    $0x1,%ebx
callq  581c <_rl_move_vert+0x3c>
cmp    %ebp,%ebx
jne    5808 <_rl_move_vert+0x28>
mov    0x0(%rip),%rdi        # 5827 <_rl_move_vert+0x47>
mov    $0x0,%edx
mov    $0x1,%esi
callq  5836 <_rl_move_vert+0x56>
movl   $0x0,0x0(%rip)        # 5840 <_rl_move_vert+0x60>
mov    %r12d,0x0(%rip)        # 5847 <_rl_move_vert+0x67>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 5857 <_rl_move_vert+0x77>
test   %rdi,%rdi
je     5840 <_rl_move_vert+0x60>
cmpb   $0x0,(%rdi)
je     5840 <_rl_move_vert+0x60>
neg    %ebp
je     5840 <_rl_move_vert+0x60>
xor    %ebx,%ebx
jmp    5877 <_rl_move_vert+0x97>
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 5877 <_rl_move_vert+0x97>
mov    $0x0,%edx
mov    $0x1,%esi
add    $0x1,%ebx
callq  5889 <_rl_move_vert+0xa9>
cmp    %ebp,%ebx
jne    5870 <_rl_move_vert+0x90>
jmp    5840 <_rl_move_vert+0x60>
nop
<<<sep_in_sample>>>
_rl_move_vert (to)
     int to;
{
  register int delta, i;
  if (_rl_last_v_pos == to || to > _rl_screenheight)
    return;
  if ((delta = to - _rl_last_v_pos) > 0)
    {
      for (i = 0; i < delta; i++)
 _IO_putc ('\n', rl_outstream);
      tputs (_rl_term_cr, 1, _rl_output_character_function);
      _rl_last_c_pos = 0;
    }
  else
    {
      if (_rl_term_up && *_rl_term_up)
 for (i = 0; i < -delta; i++)
   tputs (_rl_term_up, 1, _rl_output_character_function);
    }
  _rl_last_v_pos = to;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 9
19 10
20 9
21 9
22 11
23 11
24 11
25 11
26 12
27 20
28 21
29 21
30 21
31 21
32 21
33 16
34 16
35 16
36 16
37 16
38 17
39 17
40 17
41 17
42 17
43 17
44 18
45 18
46 17
47 18
48 17
49 17
50 17
51 17
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <isdir+0xf>
xor    %edx,%edx
test   %eax,%eax
jne    28 <isdir+0x28>
mov    0x18(%rsp),%eax
xor    %edx,%edx
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
isdir (const char *path)
{
  struct stat stats;
  return stat (path, &stats) == 0 && ((((stats.st_mode)) & 0170000) == (0040000));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%eax        # 8b0a <set_maxchild+0xa>
test   %eax,%eax
js     8b30 <set_maxchild+0x30>
cmp    %eax,%edi
jl     8b20 <set_maxchild+0x20>
mov    $0x2000,%eax
cmp    $0x2000,%edi
cmovle %edi,%eax
cltq   
mov    %rax,0x0(%rip)        # 8b29 <set_maxchild+0x29>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
mov    %edi,0xc(%rsp)
callq  8b39 <set_maxchild+0x39>
test   %eax,%eax
mov    0xc(%rsp),%edi
jns    8b52 <set_maxchild+0x52>
movl   $0x20,0x0(%rip)        # 8b4b <set_maxchild+0x4b>
mov    $0x20,%eax
jmp    8b0e <set_maxchild+0xe>
mov    %eax,0x0(%rip)        # 8b58 <set_maxchild+0x58>
jmp    8b0e <set_maxchild+0xe>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_maxchild (nchild)
     int nchild;
{
  static int lmaxchild = -1;
  if (lmaxchild < 0)
    lmaxchild = getmaxchild ();
  if (lmaxchild < 0)
    lmaxchild = 32;
  if (nchild < lmaxchild)
    nchild = lmaxchild;
  else if (nchild > 8192)
    nchild = 8192;
  js.c_childmax = nchild;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
5 9
6 9
7 9
8 9
9 9
10 13
11 13
12 14
13 14
14 14
15 14
16 6
17 7
18 7
19 7
20 8
21 8
22 8
23 6
24 6
25 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2d0 <build_aliasvar>
mov    %rbx,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
get_aliasvar (self)
     SHELL_VAR *self;
{
  build_aliasvar (self);
  return (self);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
jmpq   2ae3 <gsl_sort_vector_char+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_char (gsl_vector_char * v)
{
  gsl_sort_char (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
movapd %xmm1,%xmm0
movapd %xmm3,%xmm1
divsd  %xmm2,%xmm1
xorpd  %xmm2,%xmm2
ucomisd %xmm3,%xmm2
jae    98 <gsl_cdf_gamma_Q+0x48>
ucomisd %xmm1,%xmm0
jbe    90 <gsl_cdf_gamma_Q+0x40>
sub    $0x8,%rsp
callq  79 <gsl_cdf_gamma_Q+0x29>
movsd  0x0(%rip),%xmm1        # 81 <gsl_cdf_gamma_Q+0x31>
add    $0x8,%rsp
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
xchg   %ax,%ax
jmpq   95 <gsl_cdf_gamma_Q+0x45>
nopl   (%rax)
movsd  0x0(%rip),%xmm1        # a0 <gsl_cdf_gamma_Q+0x50>
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_gamma_Q (const double x, const double a, const double b)
{
  double Q;
  double y = x / b;
  if (x <= 0.0)
    {
      return 1.0;
    }
  if (y < a)
    {
      Q = 1 - gsl_sf_gamma_inc_P (a, y);
    }
  else
    {
      Q = gsl_sf_gamma_inc_Q (a, y);
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 9
9 9
10 2
11 11
12 11
13 18
14 11
15 18
16 18
17 18
18 15
19 15
20 7
21 18
22 18
<<<sep_out_sample>>>
lea    -0x61(%rdi),%edx
lea    -0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
libunistring_c_toupper (int c)
{
  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  158d <convert_close+0xd>
callq  1592 <convert_close+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   159b <convert_close+0x1b>
<<<sep_in_sample>>>
convert_close(CONVERT *cv)
{
 strbuf_close(cv->abspath);
 gpath_close();
 free(cv);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 6
8 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x40(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_iterator_next (gl_oset_iterator_t *iterator, const void **eltp)
{
  return iterator->vtable->iterator_next (iterator, eltp);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
movl   $0x2a,0x678(%rdi)
retq   
<<<sep_in_sample>>>
crasher (unsigned long p)
{
  *(volatile int *) (p + 0x678) = 42;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1106 <gsl_vector_char_set+0x6>
test   %eax,%eax
je     110f <gsl_vector_char_set+0xf>
cmp    %rsi,(%rdi)
jbe    1120 <gsl_vector_char_set+0x20>
imul   0x8(%rdi),%rsi
mov    0x10(%rdi),%rax
mov    %dl,(%rax,%rsi,1)
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   1139 <gsl_vector_char_set+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_char_set (gsl_vector_char * v, const size_t i, char x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_char.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 5
12 5
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # f38 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # f3f <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    f6a <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  f65 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    f58 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     f93 <quotearg_free+0x63>
callq  f7d <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # f88 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # f93 <quotearg_free+0x63>
cmp    $0x0,%r12
je     faf <quotearg_free+0x7f>
mov    %r12,%rdi
callq  fa4 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # faf <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # fbb <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdx),%rax
cmp    0x8(%rdx),%rax
je     1c00 <gsl_blas_ssyr+0x30>
mov    $0x14,%ecx
mov    $0x4c1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1bf6 <gsl_blas_ssyr+0x26>
mov    $0x14,%eax
add    $0x18,%rsp
retq   
cmp    (%rsi),%rax
je     1c30 <gsl_blas_ssyr+0x60>
mov    $0x13,%ecx
mov    $0x4c5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c1e <gsl_blas_ssyr+0x4e>
mov    $0x13,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x18(%rdx),%r9
mov    0x10(%rdx),%rdx
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rcx
mov    %edi,%esi
mov    $0x65,%edi
mov    %edx,(%rsp)
mov    %eax,%edx
callq  1c51 <gsl_blas_ssyr+0x81>
xor    %eax,%eax
jmp    1bfb <gsl_blas_ssyr+0x2b>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
               gsl_matrix_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 1217, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (X->size != N)
    {
      do { gsl_error ("invalid length", "blas.c", 1221, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_ssyr (CblasRowMajor, Uplo, ((int)(N)), alpha, X->data, ((int)(X->stride)),
              A->data, ((int)(A->tda)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 17
12 17
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 17
22 17
23 17
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1619 <do_filesearch+0x9>
test   %eax,%eax
jne    1690 <do_filesearch+0x80>
mov    0x0(%rip),%rdi        # 1624 <do_filesearch+0x14>
cmpb   $0x0,(%rdi)
je     1658 <do_filesearch+0x48>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 1633 <do_filesearch+0x23>
callq  1638 <do_filesearch+0x28>
mov    0x0(%rip),%rdi        # 163f <do_filesearch+0x2f>
mov    %rax,0x0(%rip)        # 1646 <do_filesearch+0x36>
cmpb   $0x0,(%rdi)
jne    1673 <do_filesearch+0x63>
add    $0x8,%rsp
jmpq   1654 <do_filesearch+0x44>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 165f <do_filesearch+0x4f>
callq  1664 <do_filesearch+0x54>
mov    %rax,%rdi
mov    %rax,0x0(%rip)        # 166e <do_filesearch+0x5e>
cmpb   $0x0,(%rdi)
je     164b <do_filesearch+0x3b>
mov    %rdi,%rsi
mov    $0x0,%edi
callq  1680 <do_filesearch+0x70>
mov    0x0(%rip),%rdi        # 1687 <do_filesearch+0x77>
add    $0x8,%rsp
jmpq   1690 <do_filesearch+0x80>
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_filesearch(void)
{
    if (filesearch_init() != 0)
 return;
    if (*answer == '\0')
 answer = mallocstrcpy(answer, last_search);
    else
 last_search = mallocstrcpy(last_search, answer);
    if (*answer != '\0')
 update_history(&search_history, answer);
    findnextfile(answer);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 12
16 11
17 11
18 6
19 6
20 6
21 6
22 9
23 9
24 10
25 10
26 10
27 10
28 12
29 11
30 12
31 12
32 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  1ee <_rl_push_executing_macro+0xe>
mov    0x0(%rip),%rdx        # 1f5 <_rl_push_executing_macro+0x15>
mov    %rax,0x0(%rip)        # 1fc <_rl_push_executing_macro+0x1c>
mov    %rdx,(%rax)
mov    0x0(%rip),%edx        # 205 <_rl_push_executing_macro+0x25>
mov    %edx,0x10(%rax)
mov    0x0(%rip),%rdx        # 20f <_rl_push_executing_macro+0x2f>
mov    %rdx,0x8(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_push_executing_macro ()
{
  struct saved_macro *saver;
  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
  saver->next = macro_list;
  saver->sindex = executing_macro_index;
  saver->string = rl_executing_macro;
  macro_list = saver;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 8
6 5
7 6
8 6
9 7
10 7
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c7 <write_stdout+0x7>
retq   
<<<sep_in_sample>>>
write_stdout (void)
{
  FILE * output_file = stdout;
  return output_file;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
testb  $0x10,0x23d(%rdi)
je     2a0 <__db_get_type+0x10>
mov    0x30(%rdi),%eax
retq   
nopl   (%rax)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   2b0 <__db_get_byteswapped>
<<<sep_in_sample>>>
__db_get_type(dbp)
 DB *dbp;
{
 if (!(((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "get_type", 0));;
 return (dbp->type);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 6
6 4
7 4
8 4
9 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     fe0 <gsl_block_uint_free+0x20>
mov    0x8(%rdi),%rdi
callq  fd2 <gsl_block_uint_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   fdb <gsl_block_uint_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uint_free (gsl_block_uint * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     838 <gsl_stats_uchar_quantile_from_sorted_data+0x68>
sub    $0x1,%rdx
js     840 <gsl_stats_uchar_quantile_from_sorted_data+0x70>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     867 <gsl_stats_uchar_quantile_from_sorted_data+0x97>
test   %rax,%rax
js     878 <gsl_stats_uchar_quantile_from_sorted_data+0xa8>
cvtsi2sd %rax,%xmm1
imul   %rsi,%rax
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 80d <gsl_stats_uchar_quantile_from_sorted_data+0x3d>
subsd  %xmm1,%xmm2
movzbl (%rdi,%rax,1),%edx
add    %rdi,%rax
movzbl (%rax,%rsi,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   (%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    7ef <gsl_stats_uchar_quantile_from_sorted_data+0x1f>
imul   %rsi,%rdx
movzbl (%rdi,%rdx,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nopl   0x0(%rax)
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   7fd <gsl_stats_uchar_quantile_from_sorted_data+0x2d>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uchar_quantile_from_sorted_data (const unsigned char sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 8
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 11
30 21
31 21
32 6
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 7
41 7
42 12
43 12
44 14
45 14
46 14
47 14
48 14
49 8
50 8
51 8
52 8
53 8
54 8
55 8
56 8
57 8
<<<sep_out_sample>>>
cmp    $0x43,%edi
ja     5e0 <signal_name+0x20>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rax
test   %rax,%rax
je     5e0 <signal_name+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   5ea <signal_name+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
signal_name (sig)
     int sig;
{
  char *ret;
  ret = (sig >= 65 +3 || sig < 0 || signal_names[sig] == ((void *)0))
 ? gettext("invalid signal number")
 : signal_names[sig];
  return ret;
}
<<<sep_in_sample>>>
1 7
2 7
3 5
4 5
5 5
6 5
7 9
8 9
9 7
10 7
11 7
<<<sep_out_sample>>>
cmp    %rsi,(%rdi)
jbe    60 <gsl_histogram_get_range+0x20>
mov    0x8(%rdi),%rax
movsd  (%rax,%rsi,8),%xmm0
movsd  %xmm0,(%rdx)
movsd  0x8(%rax,%rsi,8),%xmm0
xor    %eax,%eax
movsd  %xmm0,(%rcx)
retq   
nop
sub    $0x8,%rsp
mov    $0x1,%ecx
mov    $0x30,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7d <gsl_histogram_get_range+0x3d>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_get_range (const gsl_histogram * h, size_t i,
                         double *lower, double *upper)
{
  const size_t n = h->n;
  if (i >= n)
    {
      do { gsl_error ("index lies outside valid range of 0 .. n - 1", "get.c", 48, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  *lower = h->range[i];
  *upper = h->range[i + 1];
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 9
5 9
6 10
7 11
8 10
9 11
10 11
11 3
12 7
13 7
14 7
15 7
16 7
17 7
18 12
19 12
20 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1128 <osip_generic_param_get_value+0x18>
mov    (%rdi),%rax
test   %rax,%rax
je     112a <osip_generic_param_get_value+0x1a>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_generic_param_get_value (const osip_generic_param_t * fparam)
{
  if (fparam == ((void *)0))
    return ((void *)0);
  if (fparam->gname == ((void *)0))
    return ((void *)0);
  return fparam->gvalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 4
10 8
11 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     13e8 <strdupdstr+0x68>
mov    0x10(%rdi),%r12
test   %r12,%r12
je     13d8 <strdupdstr+0x58>
mov    (%rdi),%r13
lea    0x1(%r13),%rdi
callq  13a7 <strdupdstr+0x27>
test   %rax,%rax
mov    %rax,%rbp
je     13e8 <strdupdstr+0x68>
mov    %r13,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  13bd <strdupdstr+0x3d>
mov    (%rbx),%rax
movb   $0x0,0x0(%rbp,%rax,1)
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
cmpq   $0x0,(%rdi)
jne    13e8 <strdupdstr+0x68>
xor    %r13d,%r13d
jmp    139e <strdupdstr+0x1e>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    13c8 <strdupdstr+0x48>
nopl   0x0(%rax)
<<<sep_in_sample>>>
strdupdstr (string)
     DStr_string_descriptor *string;
{
  char *return_value;
  if ((string) == ((void *)0) || ((string)->string == ((void *)0) && (string)->length != 0))
    return ((void *)0);
  return_value = malloc (string->length + 1);
  if (return_value == ((void *)0))
    return ((void *)0);
  strncpy (return_value, string->string, string->length);
  return_value[string->length] = '\0';
  return return_value;
  }
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 8
16 7
17 8
18 10
19 10
20 10
21 10
22 11
23 11
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1470 <gsl_vector_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  148f <gsl_vector_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_const_view_array (const double * base, size_t n)
{
  _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector v = {0, 0, 0, 0, 0};
    v.data = (double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
cmp    $0x2,%edi
je     24 <main+0x24>
mov    (%rsi),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  19 <main+0x19>
mov    $0x1,%eax
add    $0x20,%rsp
pop    %rbx
retq   
mov    0x8(%rsi),%rdi
callq  2d <main+0x2d>
mov    $0x0,%r9d
movzwl %ax,%esi
mov    $0x0,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x819,%edi
movl   $0x0,0x10(%rsp)
movl   $0x78,0x8(%rsp)
xor    %eax,%eax
movl   $0x3,(%rsp)
callq  63 <main+0x63>
mov    0x0(%rip),%rdi        # 6a <main+0x6a>
mov    %rax,%rbx
callq  72 <main+0x72>
mov    %rbx,%rdi
callq  7a <main+0x7a>
xor    %eax,%eax
jmp    1e <main+0x1e>
<<<sep_in_sample>>>
main (int argc, char *const *argv)
{
  struct MHD_Daemon *d;
  if (argc != 2)
    {
      printf ("%s PORT\n", argv[0]);
      return 1;
    }
  d = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY | MHD_USE_DEBUG | MHD_USE_DUAL_STACK,
   atoi (argv[1]),
   ((void *)0), ((void *)0), &ahc_echo, "<html><head><title>libmicrohttpd demo</title></head><body>libmicrohttpd demo</body></html>",
   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,
   MHD_OPTION_END);
  (void) _IO_getc (stdin);
  MHD_stop_daemon (d);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 17
11 17
12 17
13 10
14 10
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 14
27 9
28 14
29 15
30 15
31 16
32 16
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_dest(const char *p, const char *o, char *value)
{
  return;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
jmpq   dfa5 <gsl_fft_halfcomplex_backward+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_halfcomplex_backward (double data[], const size_t stride,
                                        const size_t n,
                                        const gsl_fft_halfcomplex_wavetable * wavetable,
                                        gsl_fft_real_workspace * work)
{
  int status = gsl_fft_halfcomplex_transform (data, stride, n, wavetable, work) ;
  return status ;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
test   %esi,%esi
je     1f4d <fh_foreachformat+0x5d>
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    $0x0,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 1f10 <fh_foreachformat+0x20>
mov    (%rdi),%r13
test   %rax,%rax
je     1f40 <fh_foreachformat+0x50>
nopl   0x0(%rax,%rax,1)
mov    %rax,(%rbx)
mov    (%r12),%rax
add    $0x18,%rbp
mov    %rbx,%rdi
mov    %rax,0x18(%rbx)
callq  1a70 <print_interfaceX.constprop.26>
mov    0x0(%rbp),%rax
test   %rax,%rax
jne    1f20 <fh_foreachformat+0x30>
mov    %r13,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
nop
<<<sep_in_sample>>>
fh_foreachformat (format_data_t form, int argc, char *argv[])
{
  struct format *frm;
  const char *save_name;
  if (argc == 0)
    return;
  save_name = form->name;
  for (frm = formats; frm->name; frm++)
    {
      form->name = frm->name;
      form->format = argv[0];
      print_interfaceX (form, 0);
    }
  form->name = save_name;
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 8
8 2
9 2
10 2
11 8
12 7
13 8
14 8
15 8
16 10
17 11
18 8
19 12
20 11
21 12
22 8
23 8
24 8
25 14
26 15
27 15
28 15
29 15
30 15
31 15
32 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2347 <yyget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_out (void)
{
        return yyout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
add    $0xffffffffffffff80,%rsp
jmp    d16 <pies_pause+0x16>
nopw   0x0(%rax,%rax,1)
jne    e50 <pies_pause+0x150>
mov    0x0(%rip),%rax        # d1d <pies_pause+0x1d>
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    %rsp,%rsi
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # d32 <pies_pause+0x32>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # d3e <pies_pause+0x3e>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # d4a <pies_pause+0x4a>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # d56 <pies_pause+0x56>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # d62 <pies_pause+0x62>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # d6e <pies_pause+0x6e>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%rax        # d7a <pies_pause+0x7a>
mov    %rax,0x38(%rsp)
mov    0x0(%rip),%rax        # d86 <pies_pause+0x86>
mov    %rax,0x40(%rsp)
mov    0x0(%rip),%rax        # d92 <pies_pause+0x92>
mov    %rax,0x48(%rsp)
mov    0x0(%rip),%rax        # d9e <pies_pause+0x9e>
mov    %rax,0x50(%rsp)
mov    0x0(%rip),%rax        # daa <pies_pause+0xaa>
mov    %rax,0x58(%rsp)
mov    0x0(%rip),%rax        # db6 <pies_pause+0xb6>
mov    %rax,0x60(%rsp)
mov    0x0(%rip),%rax        # dc2 <pies_pause+0xc2>
mov    %rax,0x68(%rsp)
mov    0x0(%rip),%rax        # dce <pies_pause+0xce>
mov    %rax,0x70(%rsp)
mov    0x0(%rip),%rax        # dda <pies_pause+0xda>
mov    %rax,0x78(%rsp)
mov    0x0(%rip),%eax        # de5 <pies_pause+0xe5>
lea    0x1(%rax),%edi
callq  ded <pies_pause+0xed>
cmp    $0x0,%eax
jle    d10 <pies_pause+0x10>
mov    0x0(%rip),%edx        # dfc <pies_pause+0xfc>
test   %edx,%edx
js     e40 <pies_pause+0x140>
xor    %ebx,%ebx
jmp    e0f <pies_pause+0x10f>
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    %edx,%ebx
jg     e40 <pies_pause+0x140>
mov    %ebx,%eax
mov    %ebx,%ecx
sar    $0x6,%eax
cltq   
mov    (%rsp,%rax,8),%rax
sar    %cl,%rax
test   $0x1,%al
je     e08 <pies_pause+0x108>
mov    %ebx,%edi
add    $0x1,%ebx
callq  e2d <pies_pause+0x12d>
mov    0x0(%rip),%edx        # e33 <pies_pause+0x133>
cmp    %edx,%ebx
jle    e0f <pies_pause+0x10f>
nopw   0x0(%rax,%rax,1)
sub    $0xffffffffffffff80,%rsp
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
callq  e55 <pies_pause+0x155>
mov    (%rax),%edi
cmp    $0x4,%edi
je     e40 <pies_pause+0x140>
callq  e61 <pies_pause+0x161>
mov    $0x0,%esi
mov    %rax,%rdx
mov    $0x3,%edi
xor    %eax,%eax
callq  e75 <pies_pause+0x175>
sub    $0xffffffffffffff80,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
pies_pause ()
{
  while (1)
    {
      fd_set rdset = listenset;
      int rc = select (fd_max + 1, &rdset, ((void *)0), ((void *)0), ((void *)0));
      if (rc > 0)
 {
   int i;
   for (i = 0; i <= fd_max; i++)
     {
       if (((((&rdset)->fds_bits)[((i) / (8 * (int) sizeof (__fd_mask)))] & ((__fd_mask) 1 << ((i) % (8 * (int) sizeof (__fd_mask))))) != 0))
  progman_accept (i);
     }
   break;
 }
      else if (rc < 0)
 {
   if ((*__errno_location ()) != 4)
     logmsg (3, "select: %s", strerror ((*__errno_location ())));
   break;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 17
6 5
7 6
8 6
9 6
10 6
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 5
41 5
42 6
43 6
44 6
45 7
46 7
47 10
48 10
49 10
50 10
51 10
52 10
53 10
54 10
55 10
56 12
57 12
58 12
59 12
60 12
61 12
62 12
63 12
64 13
65 10
66 13
67 13
68 10
69 10
70 10
71 24
72 24
73 24
74 24
75 19
76 19
77 19
78 19
79 20
80 20
81 20
82 20
83 20
84 20
85 24
86 24
87 24
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     2090 <gsl_vector_uchar_add+0x30>
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2082 <gsl_vector_uchar_add+0x22>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
test   %r10,%r10
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
je     20ca <gsl_vector_uchar_add+0x6a>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r8
mov    0x10(%rsi),%r9
add    0x10(%rdi),%r8
add    $0x1,%rax
add    %rbx,%rdx
movzbl (%r9,%rcx,1),%r9d
add    %r11,%rcx
add    %r9b,(%r8)
cmp    %r10,%rax
jne    20a8 <gsl_vector_uchar_add+0x48>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_uchar_add (gsl_vector_uchar * a, const gsl_vector_uchar * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 13
16 13
17 13
18 10
19 11
20 13
21 13
22 15
23 15
24 15
25 13
26 13
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_jac (const gsl_multifit_nlinear_workspace * w)
{
  return w->J;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rdi,%rbx
callq  *0x10(%rax)
mov    %rbx,%rdi
callq  1f2 <error_exit+0x12>
mov    $0x1,%edi
callq  1fc <error_exit+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
error_exit (j_common_ptr cinfo)
{
  (*cinfo->err->output_message) (cinfo);
  jpeg_destroy(cinfo);
  exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 5
9 5
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
mulsd  %xmm1,%xmm0
mulsd  %xmm1,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_pow_6(const double x) { double x2 = x*x; return x2*x2*x2; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
ucomisd %xmm3,%xmm2
movsd  %xmm0,0x8(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x18(%rsp)
jae    2546 <TruncNormalRandom+0x96>
mov    $0x1,%ebx
jmp    24e8 <TruncNormalRandom+0x38>
nopl   0x0(%rax)
add    $0x1,%ebx
cmp    $0x19,%ebx
je     2512 <TruncNormalRandom+0x62>
movsd  0x10(%rsp),%xmm1
movsd  0x8(%rsp),%xmm0
callq  24f9 <TruncNormalRandom+0x49>
movsd  (%rsp),%xmm4
ucomisd %xmm0,%xmm4
ja     24e0 <TruncNormalRandom+0x30>
ucomisd 0x18(%rsp),%xmm0
ja     24e0 <TruncNormalRandom+0x30>
add    $0x20,%rsp
pop    %rbx
retq   
mov    $0x0,%edi
xor    %eax,%eax
callq  251e <TruncNormalRandom+0x6e>
movsd  0x10(%rsp),%xmm3
mov    $0x0,%edi
movsd  0x8(%rsp),%xmm2
mov    $0x4,%eax
movsd  0x18(%rsp),%xmm1
movsd  (%rsp),%xmm0
callq  2544 <TruncNormalRandom+0x94>
jmp    24e8 <TruncNormalRandom+0x38>
movapd %xmm3,%xmm1
mov    $0x0,%edi
movapd %xmm2,%xmm0
mov    $0x2,%eax
callq  255d <TruncNormalRandom+0xad>
xor    %edi,%edi
callq  2564 <TruncNormalRandom+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TruncNormalRandom (double dMean, double dStdDev, double a, double b)
{
  double X = 0.0;
  int iter = 0;
  if (a >= b) {
    printf ("Error: TruncNormalRandom: min >= max  [%g %g]\n", a, b);
    exit (0);
  }
  else do {
    if(++iter == 25) {
      printf("Warning: TruncNormalRandom: problem with range: ");
      printf("min %g, max %g, ave %g, sd %g\n", a, b, dMean, dStdDev);
    }
    X = NormalRandom(dMean, dStdDev);
  }
  while (X < a || X > b);
  return X;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 2
5 2
6 2
7 2
8 5
9 10
10 10
11 10
12 10
13 10
14 10
15 14
16 14
17 14
18 16
19 16
20 16
21 16
22 16
23 18
24 18
25 18
26 11
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 6
39 6
40 6
41 6
42 7
43 7
44 7
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 1418 <checkdb+0x8>
je     1420 <checkdb+0x10>
xor    %eax,%eax
retq   
nopl   (%rax)
mov    0x0(%rip),%rdi        # 1427 <checkdb+0x17>
test   %rdi,%rdi
je     1438 <checkdb+0x28>
jmpq   320 <opendb>
nopl   0x0(%rax)
push   %rbx
mov    $0x0,%edi
callq  1443 <checkdb+0x33>
mov    $0x0,%esi
mov    %rax,%rbx
mov    $0x0,%edi
mov    %rax,0x0(%rip)        # 1457 <checkdb+0x47>
callq  145c <checkdb+0x4c>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  1469 <checkdb+0x59>
pop    %rbx
mov    0x0(%rip),%rdi        # 1471 <checkdb+0x61>
jmpq   320 <opendb>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
checkdb ()
{
  if (!gdbm_file)
    {
      if (!file_name)
 {
   file_name = estrdup ("junk.gdbm");
   terror (dgettext ("gdbm", "warning: using default database file %s"),
   file_name);
 }
      return opendb (file_name);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 14
4 14
5 14
6 5
7 5
8 5
9 11
10 11
11 2
12 7
13 7
14 8
15 7
16 8
17 7
18 8
19 8
20 8
21 8
22 8
23 14
24 14
25 11
26 11
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_mime_header (MESSAGE msg)
{
  return msg->mime_hdr;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0x7,%sil
jne    3e1 <openssl_cast_decrypt+0x51>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     3d6 <openssl_cast_decrypt+0x46>
nopl   0x0(%rax)
xor    %ecx,%ecx
mov    %rbp,%rsi
mov    %r12,%rdi
mov    %r13,%rdx
add    $0x8,%rbp
add    $0x8,%r12
callq  3d0 <openssl_cast_decrypt+0x40>
sub    $0x8,%rbx
jne    3b8 <openssl_cast_decrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0x13e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3fa <openssl_cast_decrypt+0x6a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openssl_cast_decrypt(const void *ctx, size_t length,
       uint8_t *dst, const uint8_t *src)
{
  ((!(length % 8)) ? (void) (0) : __assert_fail ("!(length % 8)", "nettle-openssl.c", 318, __PRETTY_FUNCTION__));
  while (length)
    {
      CAST_ecb_encrypt(src, dst, ctx, 0);
      length -= 8;
      dst += 8;
      src += 8;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x428,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x418(%rsp)
xor    %eax,%eax
cmpl   $0xfffffffd,0x8(%rsi)
je     2d0 <_fprintPwd+0x110>
mov    (%rsi),%rdi
mov    %ecx,%ebx
lea    0x2c(%r12),%r13
callq  1ff <_fprintPwd+0x3f>
mov    %ebx,%ecx
mov    $0x1,%edx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  1c0 <_fprintPwd>
test   %ebx,%ebx
je     2a0 <_fprintPwd+0xe0>
mov    $0x0,%esi
mov    %r13,%rdi
mov    %r13,%rbx
callq  229 <_fprintPwd+0x69>
test   %rax,%rax
je     2a0 <_fprintPwd+0xe0>
mov    %rbp,%rsi
mov    $0x2f,%edi
callq  23b <_fprintPwd+0x7b>
mov    0x2c(%r12),%esi
test   %esi,%esi
je     278 <_fprintPwd+0xb8>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  252 <_fprintPwd+0x92>
test   %rax,%rax
je     264 <_fprintPwd+0xa4>
mov    %rbp,%rsi
mov    $0x5c,%edi
callq  264 <_fprintPwd+0xa4>
mov    (%rbx),%edi
mov    %rbp,%rsi
add    $0x4,%rbx
callq  272 <_fprintPwd+0xb2>
mov    (%rbx),%esi
test   %esi,%esi
jne    248 <_fprintPwd+0x88>
mov    0x418(%rsp),%rax
xor    %fs:0x28,%rax
jne    312 <_fprintPwd+0x152>
add    $0x428,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x10(%rsp),%rsi
mov    %r13,%rdi
mov    $0xff,%edx
callq  2b2 <_fprintPwd+0xf2>
lea    0x10(%rsp),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  2c6 <_fprintPwd+0x106>
jmp    278 <_fprintPwd+0xb8>
nopl   0x0(%rax,%rax,1)
mov    (%rsi),%rdi
mov    %edx,0xc(%rsp)
callq  2dc <_fprintPwd+0x11c>
mov    %rbp,%rsi
movsbl %al,%edi
callq  2e7 <_fprintPwd+0x127>
mov    %rbp,%rsi
mov    $0x3a,%edi
callq  2f4 <_fprintPwd+0x134>
mov    0xc(%rsp),%edx
test   %edx,%edx
jne    278 <_fprintPwd+0xb8>
mov    %rbp,%rsi
mov    $0x2f,%edi
callq  30d <_fprintPwd+0x14d>
jmpq   278 <_fprintPwd+0xb8>
callq  317 <_fprintPwd+0x157>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_fprintPwd(FILE *f, direntry_t *entry, int recurs, int escape)
{
 if(entry->entry == -3) {
  _IO_putc (getDrive(entry->Dir), f);
  _IO_putc (':', f);
  if(!recurs)
   _IO_putc ('/', f);
 } else {
  _fprintPwd(f, getDirentry(entry->Dir), 1, escape);
  if (escape && wcspbrk(entry->name, L"\"$\\")) {
   wchar_t *ptr;
   _IO_putc ('/', f);
   for(ptr = entry->name; *ptr; ptr++) {
    if (wcschr(L"\"$\\", *ptr))
     _IO_putc ('\\', f);
    putwc(*ptr, f);
   }
  } else {
   char tmp[4*(255)+1];
   wchar_to_native(entry->name,tmp,(255));
   fprintf(f, "/%s", tmp);
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 9
14 9
15 10
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 13
34 13
35 13
36 13
37 14
38 14
39 14
40 14
41 15
42 15
43 15
44 16
45 16
46 13
47 16
48 13
49 13
50 13
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
59 24
60 24
61 20
62 20
63 20
64 20
65 21
66 21
67 21
68 21
69 21
70 21
71 21
72 4
73 4
74 4
75 4
76 4
77 4
78 5
79 5
80 5
81 6
82 6
83 6
84 7
85 7
86 7
87 7
88 24
89 24
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 246 <defalt+0x6>
movsd  0x0(%rip),%xmm0        # 24e <defalt+0xe>
test   %edx,%edx
jne    25a <defalt+0x1a>
movsd  %xmm0,0x0(%rip)        # 25a <defalt+0x1a>
mov    0x0(%rip),%eax        # 260 <defalt+0x20>
test   %eax,%eax
jne    26e <defalt+0x2e>
movl   $0x1,0x0(%rip)        # 26e <defalt+0x2e>
movsd  0x0(%rip),%xmm1        # 276 <defalt+0x36>
ucomisd %xmm1,%xmm0
jbe    2b0 <defalt+0x70>
movsd  0x0(%rip),%xmm2        # 284 <defalt+0x44>
ucomisd 0x0(%rip),%xmm2        # 28c <defalt+0x4c>
jbe    2b0 <defalt+0x70>
movsd  0x0(%rip),%xmm0        # 296 <defalt+0x56>
xorpd  %xmm0,%xmm2
movsd  %xmm2,0x0(%rip)        # 2a2 <defalt+0x62>
movl   $0x0,0x0(%rip)        # 2ac <defalt+0x6c>
retq   
nopl   (%rax)
ucomisd %xmm0,%xmm1
jbe    2a2 <defalt+0x62>
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 2c2 <defalt+0x82>
ucomisd %xmm0,%xmm1
jbe    2a2 <defalt+0x62>
movsd  0x0(%rip),%xmm1        # 2d0 <defalt+0x90>
movl   $0x0,0x0(%rip)        # 2da <defalt+0x9a>
xorpd  %xmm1,%xmm0
movsd  %xmm0,0x0(%rip)        # 2e6 <defalt+0xa6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defalt (void)
{
  if (!sawfrom)
    tfrom = tstart;
  if (!sawevery)
    tevery = 1;
  if (tstart>tstop && tstep>0)
    tstep = -tstep;
  else if (tstart<tstop && tstep<0)
    tstep = -tstep;
  printnum = false;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 4
6 5
7 5
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 11
20 11
21 11
22 9
23 9
24 9
25 9
26 9
27 9
28 10
29 11
30 10
31 10
32 11
33 11
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rdi),%rdi
callq  7c5 <__osip_add_ist+0x15>
lea    0x50(%rbx),%rdi
mov    %rbp,%rsi
mov    $0xffffffff,%edx
callq  7d6 <__osip_add_ist+0x26>
mov    0x10(%rbx),%rdi
callq  7df <__osip_add_ist+0x2f>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__osip_add_ist (osip_t * osip, osip_transaction_t * ist)
{
  osip_mutex_lock (osip->ist_fastmutex);
  osip_list_add (&osip->osip_ist_transactions, ist, -1);
  osip_mutex_unlock (osip->ist_fastmutex);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 7
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     e48 <trace_icmp_sock+0x8>
mov    (%rdi),%eax
retq   
mov    $0xffffffff,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
trace_icmp_sock (trace_t * t)
{
  return (t != ((void *)0) ? t->icmpfd : -1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  1ad <output_free+0xd>
mov    0x10(%rbx),%rdi
mov    $0x0,%esi
callq  1bb <output_free+0x1b>
mov    %rbx,%rdi
pop    %rbx
jmpq   1c4 <output_free+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_free (struct output * out)
{
  ds_erase (out->chunk);
  da_free (out->derivations, (da_map_func_t) free);
  free (out);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  8be <locateCraftByDISEntityID+0xe>
mov    %rax,%rbx
callq  8c6 <locateCraftByDISEntityID+0x16>
test   %rax,%rax
js     910 <locateCraftByDISEntityID+0x60>
movzwl 0x0(%rbp),%ecx
xor    %edx,%edx
jmp    8e8 <locateCraftByDISEntityID+0x38>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdx
add    $0x3a8,%rbx
cmp    %rdx,%rax
jl     910 <locateCraftByDISEntityID+0x60>
cmp    %cx,0x32(%rbx)
jne    8d8 <locateCraftByDISEntityID+0x28>
movzwl 0x2(%rbp),%esi
cmp    %si,0x34(%rbx)
jne    8d8 <locateCraftByDISEntityID+0x28>
movzwl 0x4(%rbp),%edi
cmp    %di,0x36(%rbx)
jne    8d8 <locateCraftByDISEntityID+0x28>
mov    0x20(%rbx),%rax
jmp    912 <locateCraftByDISEntityID+0x62>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
locateCraftByDISEntityID ( dis_entity_id *id )
{
 Entity_t *e = dis_getEntityTable();
 long top = dis_getEntityTop();
 long i;
 craft *result = ((void *)0);
 for (i=0; i<=top; ++i) {
  if ( e->entityId.sim_id.site_id == id->sim_id.site_id &&
    e->entityId.sim_id.application_id == id->sim_id.application_id &&
    e->entityId.entity_id == id->entity_id ) {
   result = e->c;
   break;
  }
  ++ e;
 }
 return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 14
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 11
27 12
28 12
29 6
30 17
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
push   %r15
mov    %edx,%r15d
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x218,%rsp
mov    (%rsi),%r12
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
cmpb   $0x20,(%r12)
mov    %r12,%rax
je     49 <put_standard_format+0x49>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    40 <put_standard_format+0x40>
cmpb   $0x20,0x1(%rax)
lea    0x1(%rax),%r13
movb   $0x0,(%rax)
mov    %r13,%rbx
je     69 <put_standard_format+0x69>
nopl   0x0(%rax)
add    $0x1,%rbx
cmpb   $0x20,(%rbx)
jne    60 <put_standard_format+0x60>
test   $0x8,%r15b
movb   $0x0,(%rbx)
jne    f8 <put_standard_format+0xf8>
mov    0x0(%rip),%eax        # 7c <put_standard_format+0x7c>
mov    $0x0,%r8d
test   %eax,%eax
jne    a3 <put_standard_format+0xa3>
cmpb   $0x20,0x1(%rbx)
lea    0x1(%rbx),%rax
je     99 <put_standard_format+0x99>
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    90 <put_standard_format+0x90>
and    $0x2,%r15d
lea    0x1(%rax),%r8
jne    e0 <put_standard_format+0xe0>
mov    0x18(%rbp),%ecx
mov    0x8(%rbp),%rdx
mov    %r12,%r9
mov    %r13,%rsi
mov    %r14,%rdi
callq  b8 <put_standard_format+0xb8>
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
jne    11c <put_standard_format+0x11c>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
mov    0x10(%rbp),%rsi
mov    %r8,%rdi
callq  ec <put_standard_format+0xec>
mov    %rax,%r8
jmp    a3 <put_standard_format+0xa3>
nopl   0x0(%rax)
mov    0x10(%rbp),%rsi
mov    %r13,%rdi
mov    %rsp,%r13
callq  107 <put_standard_format+0x107>
mov    $0x200,%edx
mov    %rax,%rsi
mov    %rsp,%rdi
callq  117 <put_standard_format+0x117>
jmpq   76 <put_standard_format+0x76>
callq  121 <put_standard_format+0x121>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_standard_format(CONVERT *cv, GTP *gtp, int flags)
{
 char *p = (char *)gtp->tagline;
 char namebuf[512];
 const char *fid, *tagname, *image;
 fid = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 tagname = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 if (flags & 8) {
  strlimcpy(namebuf, (char *)uncompress(tagname, gtp->tag), sizeof(namebuf));
  tagname = namebuf;
 }
 if (nosource) {
  image = " ";
 } else {
  while (*p != ' ')
   p++;
  image = p + 1;
  if (flags & 2)
   image = (char *)uncompress(image, gtp->tag);
 }
 convert_put_using(cv, tagname, gtp->path, gtp->lineno, image, fid);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 2
13 2
14 2
15 7
16 7
17 7
18 7
19 8
20 7
21 7
22 11
23 9
24 9
25 9
26 11
27 11
28 12
29 11
30 11
31 14
32 13
33 14
34 18
35 19
36 18
37 18
38 21
39 13
40 21
41 22
42 21
43 21
44 24
45 23
46 24
47 27
48 27
49 27
50 27
51 27
52 27
53 28
54 28
55 28
56 28
57 28
58 28
59 28
60 28
61 28
62 28
63 28
64 28
65 25
66 25
67 25
68 25
69 25
70 25
71 15
72 15
73 16
74 15
75 15
76 15
77 15
78 15
79 15
80 28
81 28
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
callq  601 <_mime_body_transport+0x11>
mov    %rax,%rdi
callq  609 <_mime_body_transport+0x19>
mov    %rax,%rdi
callq  611 <_mime_body_transport+0x21>
mov    %rax,%rcx
movq   $0x0,(%rsp)
mov    $0x16,%eax
cmpq   $0x0,0x30(%rcx)
jne    630 <_mime_body_transport+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nop
cmpq   $0x0,0x48(%rcx)
je     628 <_mime_body_transport+0x38>
mov    0x50(%rcx),%rdx
mov    0x38(%rcx),%rax
mov    %rsp,%rsi
mov    (%rax,%rdx,8),%rax
mov    0x8(%rax),%rdi
callq  64f <_mime_body_transport+0x5f>
mov    (%rsp),%rdi
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  65e <_mime_body_transport+0x6e>
jmp    628 <_mime_body_transport+0x38>
<<<sep_in_sample>>>
_mime_body_transport (mu_stream_t stream, mu_transport_t *tr1,
        mu_transport_t *tr2)
{
  mu_body_t body = mu_stream_get_owner (stream);
  mu_message_t msg = mu_body_get_owner (body);
  mu_mime_t mime = mu_message_get_owner (msg);
  mu_stream_t msg_stream = ((void *)0);
  if (mime->nmtp_parts == 0 || mime->cur_offset == 0)
    return 22;
  mu_message_get_stream (mime->mtp_parts[mime->cur_part]->msg, &msg_stream);
  return mu_stream_get_transport2 (msg_stream, tr1, tr2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 9
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
jmpq   5 <file_free_callback+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_free_callback (void *cls)
{
  FILE *file = cls;
  fclose (file);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x4(%rax),%eax
mov    0x0(,%rax,4),%eax
cmp    %eax,0xc(%rdi)
setae  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
finished_p (void *owner)
{
  struct assoc_iterator *itr = owner;
  return itr->index >= hash_size[itr->assoc->hash_num];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 737 <progcomp_search+0x7>
test   %rsi,%rsi
je     758 <progcomp_search+0x28>
sub    $0x8,%rsp
xor    %edx,%edx
callq  747 <progcomp_search+0x17>
test   %rax,%rax
je     760 <progcomp_search+0x30>
mov    0x10(%rax),%rax
add    $0x8,%rsp
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    750 <progcomp_search+0x20>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
progcomp_search (cmd)
     const char *cmd;
{
  register BUCKET_CONTENTS *item;
  COMPSPEC *cs;
  if (prog_completes == 0)
    return ((COMPSPEC *)((void *)0));
  item = hash_search (cmd, prog_completes, 0);
  if (item == ((void *)0))
    return ((COMPSPEC *)((void *)0));
  cs = (COMPSPEC *)item->data;
  return (cs);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 3
5 8
6 8
7 9
8 9
9 11
10 13
11 13
12 13
13 7
14 13
15 13
16 7
17 7
18 7
<<<sep_out_sample>>>
mov    0x240(%rdi),%rax
movq   $0x0,(%rax)
retq   
nop
<<<sep_in_sample>>>
finish_input_pass (j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
mov    0x8(%rbx),%rax
lea    (%rdi,%rax,8),%rax
cmp    %rax,%rdi
jae    570 <hash_delete_items+0x30>
mov    %rdi,%rdx
xor    %esi,%esi
not    %rdx
add    %rdx,%rax
shr    $0x3,%rax
lea    0x8(,%rax,8),%rdx
callq  570 <hash_delete_items+0x30>
movq   $0x0,0x18(%rbx)
movq   $0x0,0x20(%rbx)
movq   $0x0,0x28(%rbx)
movl   $0x0,0x30(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_delete_items (struct hash_table_s* ht)
{
  void **vec = ht->ht_vec;
  void **end = &vec[ht->ht_size];
  for (; vec < end; vec++)
    *vec = 0;
  ht->ht_fill = 0;
  ht->ht_collisions = 0;
  ht->ht_lookups = 0;
  ht->ht_rehashes = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 8
17 9
18 10
19 11
20 11
21 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b <sdp_message_v_version_set+0xb>
mov    %rsi,(%rdi)
xor    %eax,%eax
retq   
mov    $0xfffffffe,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_v_version_set (sdp_message_t * sdp, char *v_version)
{
  if (sdp == ((void *)0))
    return -2;
  sdp->v_version = v_version;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 4
7 7
8 7
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_index (rec_sex_ast_node_t node)
{
  return node->index;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movl   $0x0,0x1258(%rdi)
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
clearRadarInfo(craft * c)
{
 c->rtop = 0;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 2a <setdebug+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setdebug(void)
{
 debug = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     90 <osip_mutex_lock+0x10>
jmpq   8a <osip_mutex_lock+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_mutex_lock (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return -2;
  return pthread_mutex_lock (mut);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 7
7 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 527 <terminal_clear_to_eol+0x7>
test   %rdx,%rdx
je     530 <terminal_clear_to_eol+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%rdi        # 537 <terminal_clear_to_eol+0x17>
test   %rdi,%rdi
je     550 <terminal_clear_to_eol+0x30>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   54b <terminal_clear_to_eol+0x2b>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
terminal_clear_to_eol (void)
{
  if (terminal_clear_to_eol_hook)
    (*terminal_clear_to_eol_hook) ();
  else
    {
      do { if (term_clreol) tputs (term_clreol, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 39a <_rl_arg_getchar+0xa>
mov    $0x0,%edi
imul   0x0(%rip),%esi        # 3a6 <_rl_arg_getchar+0x16>
xor    %eax,%eax
callq  3ad <_rl_arg_getchar+0x1d>
orq    $0x40,0x0(%rip)        # 3b5 <_rl_arg_getchar+0x25>
callq  3ba <_rl_arg_getchar+0x2a>
andq   $0xffffffffffffffbf,0x0(%rip)        # 3c2 <_rl_arg_getchar+0x32>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_arg_getchar ()
{
  int c;
  rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 7
10 9
11 9
12 9
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # f38 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # f3f <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    f6a <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  f65 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    f58 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     f93 <quotearg_free+0x63>
callq  f7d <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # f88 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # f93 <quotearg_free+0x63>
cmp    $0x0,%r12
je     faf <quotearg_free+0x7f>
mov    %r12,%rdi
callq  fa4 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # faf <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # fbb <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  921 <xdr_dis_world_coordinates+0x11>
test   %eax,%eax
jne    930 <xdr_dis_world_coordinates+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  93c <xdr_dis_world_coordinates+0x2c>
test   %eax,%eax
je     925 <xdr_dis_world_coordinates+0x15>
lea    0x10(%rbp),%rsi
mov    %rbx,%rdi
callq  94c <xdr_dis_world_coordinates+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_world_coordinates(xdrs, objp)
	XDR *xdrs;
	dis_world_coordinates *objp;
{
	if (!xdr_byte_double(xdrs, &objp->x)) {
		return (FALSE);
	}
	if (!xdr_byte_double(xdrs, &objp->y)) {
		return (FALSE);
	}
	if (!xdr_byte_double(xdrs, &objp->z)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # e07 <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     e12 <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
mov    0x8(%rax),%rax
movl   $0x0,0x0(%rip)        # e20 <rl_on_new_line+0x20>
movl   $0x0,0x0(%rip)        # e2a <rl_on_new_line+0x2a>
movl   $0x0,0x0(%rip)        # e34 <rl_on_new_line+0x34>
movl   $0x0,0x0(%rip)        # e3e <rl_on_new_line+0x3e>
test   %rax,%rax
je     e50 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # e5a <rl_on_new_line+0x5a>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 7
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 11
17 11
18 11
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    0x10(%rax),%rdi
jmpq   9d <dwname_hash+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
dwname_hash(void *data, unsigned long hashsize)
{
 struct dwref *sym = data;
 return hash_string(sym->dw->dirname, hashsize);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x8,%esi
lea    0x38(%rdi),%rsi
sete   %al
mov    %edx,%ecx
mov    $0x8,%r8d
mov    %eax,%edx
jmpq   33b <__osip_ist_need_timer_i_event+0x1b>
<<<sep_in_sample>>>
__osip_ist_need_timer_i_event (osip_ist_t * ist, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (ist, &ist->timer_i_start, state == IST_CONFIRMED, transactionid, TIMEOUT_I);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     830 <mu_mailbox_get_message+0x20>
mov    0x70(%rdi),%rcx
test   %rcx,%rcx
je     830 <mu_mailbox_get_message+0x20>
testb  $0x8,0x31(%rdi)
mov    $0x1033,%eax
je     840 <mu_mailbox_get_message+0x30>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    $0x1003,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
jmpq   *%rcx
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_get_message (mu_mailbox_t mbox, size_t msgno, mu_message_t *pmsg)
{
  if (mbox == ((void *)0) || mbox->_get_message == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_get_message (mbox, msgno, pmsg);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 5
9 8
10 8
11 4
12 8
13 8
14 7
15 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 407 <sys_detect_dev_null_output+0x7>
mov    $0xa,%ecx
mov    $0x0,%edi
mov    (%rax),%rsi
mov    $0x1,%eax
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
je     445 <sys_detect_dev_null_output+0x45>
cmpl   $0x3fffffff,0x0(%rip)        # 42f <sys_detect_dev_null_output+0x2f>
jg     443 <sys_detect_dev_null_output+0x43>
mov    0x0(%rip),%eax        # 437 <sys_detect_dev_null_output+0x37>
and    $0xf000,%eax
cmp    $0x2000,%eax
je     450 <sys_detect_dev_null_output+0x50>
xor    %eax,%eax
mov    %al,0x0(%rip)        # 44b <sys_detect_dev_null_output+0x4b>
retq   
nopl   0x0(%rax)
sub    $0x98,%rsp
mov    $0x0,%edi
mov    %rsp,%rsi
callq  464 <sys_detect_dev_null_output+0x64>
test   %eax,%eax
jne    490 <sys_detect_dev_null_output+0x90>
mov    (%rsp),%rax
cmp    %rax,0x0(%rip)        # 473 <sys_detect_dev_null_output+0x73>
jne    490 <sys_detect_dev_null_output+0x90>
mov    0x8(%rsp),%rax
cmp    %rax,0x0(%rip)        # 481 <sys_detect_dev_null_output+0x81>
sete   %al
jmp    492 <sys_detect_dev_null_output+0x92>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
mov    %al,0x0(%rip)        # 498 <sys_detect_dev_null_output+0x98>
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
sys_detect_dev_null_output (void)
{
  static char const dev_null[] = "/dev/null";
  struct stat dev_null_stat;
  dev_null_output = (strcmp (archive_name_array[0], dev_null) == 0
       || (! ((archive) >= (1 << 30))
    && ((((archive_stat.st_mode)) & 0170000) == (0020000))
    && stat (dev_null, &dev_null_stat) == 0
    && archive_stat.st_dev == dev_null_stat.st_dev
    && archive_stat.st_ino == dev_null_stat.st_ino));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 5
19 5
20 5
21 2
22 8
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 10
36 5
37 11
38 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x98,%rsp
mov    0x38(%rdi),%rsi
mov    %rsp,%rdi
callq  d1b <rec_record_contains_field+0x1b>
mov    (%rsp),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rsp),%rax
mov    %rax,0x58(%rsp)
mov    0x10(%rsp),%rax
mov    %rax,0x60(%rsp)
mov    0x18(%rsp),%rax
mov    %rax,0x68(%rsp)
mov    0x20(%rsp),%rax
mov    %rax,0x70(%rsp)
mov    0x28(%rsp),%rax
mov    %rax,0x78(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x80(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x88(%rsp)
jmp    d91 <rec_record_contains_field+0x91>
nopw   0x0(%rax,%rax,1)
mov    0x40(%rsp),%rdi
callq  d82 <rec_record_contains_field+0x82>
mov    %rbx,%rdi
mov    %rax,%rsi
callq  d8d <rec_record_contains_field+0x8d>
test   %al,%al
jne    dc8 <rec_record_contains_field+0xc8>
lea    0x40(%rsp),%rdx
lea    0x50(%rsp),%rdi
xor    %ecx,%ecx
mov    $0x1,%esi
callq  da7 <rec_record_contains_field+0xa7>
test   %al,%al
jne    d78 <rec_record_contains_field+0x78>
xor    %ebx,%ebx
lea    0x50(%rsp),%rdi
callq  db7 <rec_record_contains_field+0xb7>
add    $0x98,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x40(%rsp),%rdi
callq  dd2 <rec_record_contains_field+0xd2>
mov    %rbp,%rdi
mov    %rax,%rsi
callq  ddd <rec_record_contains_field+0xdd>
test   %eax,%eax
jne    d91 <rec_record_contains_field+0x91>
mov    $0x1,%ebx
jmp    dad <rec_record_contains_field+0xad>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_contains_field (rec_record_t record,
                           const char *field_name,
                           const char *field_value)
{
  _Bool res = 0;
  rec_mset_iterator_t iter;
  rec_field_t field;
  iter = rec_mset_iterator (record->mset);
  while (rec_mset_iterator_next (&iter, 1, (const void **) &field, ((void *)0)))
    {
      if (rec_field_name_equal_p (field_name,
                                  rec_field_name (field))
          && (strcmp (field_value, rec_field_value (field)) == 0))
        {
          res = 1;
          break;
        }
    }
  rec_mset_iterator_free (&iter);
  return res;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 9
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 5
42 19
43 19
44 21
45 21
46 21
47 21
48 21
49 21
50 13
51 13
52 13
53 13
54 13
55 13
56 13
57 15
58 15
59 15
<<<sep_out_sample>>>
cmpb   $0xff,(%rdi)
je     690 <nextitem+0x10>
lea    0x1(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
movzbl 0x1(%rdi),%eax
cmp    $0xfa,%eax
je     6ae <nextitem+0x2e>
jl     6a9 <nextitem+0x29>
cmp    $0xfe,%eax
jg     6a9 <nextitem+0x29>
lea    0x3(%rdi),%rax
retq   
lea    0x2(%rdi),%rax
retq   
lea    0x2(%rdi),%rdx
jmp    6bb <nextitem+0x3b>
nopl   0x0(%rax)
mov    %rax,%rdx
cmpb   $0xff,(%rdx)
lea    0x1(%rdx),%rax
jne    6b8 <nextitem+0x38>
cmpb   $0xf0,0x1(%rdx)
lea    0x2(%rdx),%rax
jne    6b8 <nextitem+0x38>
repz retq 
<<<sep_in_sample>>>
nextitem (char *current)
{
  if ((*current & 0xff) != 255)
    return current + 1;
  switch (*(current + 1) & 0xff)
    {
    case 253:
    case 254:
    case 251:
    case 252:
      return current + 3;
    case 250:
      {
 char *look = current + 2;
 for (;;)
   if ((*look++ & 0xff) == 255 && (*look++ & 0xff) == 240)
     return look;
      default:
 return current + 2;
      }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 11
13 11
14 19
15 22
16 14
17 14
18 14
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 22
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_root_fsolver_name (const gsl_root_fsolver * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 98a <gsl_matrix_const_ptr+0xa>
test   %eax,%eax
je     999 <gsl_matrix_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    9b0 <gsl_matrix_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    9d0 <gsl_matrix_const_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9c9 <gsl_matrix_const_ptr+0x49>
xor    %eax,%eax
jmp    9a9 <gsl_matrix_const_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9e9 <gsl_matrix_const_ptr+0x69>
xor    %eax,%eax
jmp    9a9 <gsl_matrix_const_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_double.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_double.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const double *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   f3 <gsl_vector_complex_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_fscanf (FILE * stream, gsl_vector_complex * v)
{
  int status = gsl_block_complex_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # ac <gsl_cdf_negative_binomial_Q+0xc>
ucomisd %xmm2,%xmm0
ja     e0 <gsl_cdf_negative_binomial_Q+0x40>
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
ja     e0 <gsl_cdf_negative_binomial_Q+0x40>
ucomisd %xmm1,%xmm3
ja     110 <gsl_cdf_negative_binomial_Q+0x70>
mov    %edi,%edi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm3
addsd  %xmm3,%xmm2
jmpq   d6 <gsl_cdf_negative_binomial_Q+0x36>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x46,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f9 <gsl_cdf_negative_binomial_Q+0x59>
movsd  0x0(%rip),%xmm0        # 101 <gsl_cdf_negative_binomial_Q+0x61>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x4b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  129 <gsl_cdf_negative_binomial_Q+0x89>
movsd  0x0(%rip),%xmm0        # 131 <gsl_cdf_negative_binomial_Q+0x91>
jmp    101 <gsl_cdf_negative_binomial_Q+0x61>
<<<sep_in_sample>>>
gsl_cdf_negative_binomial_Q (const unsigned int k, const double p, const double n)
{
  double Q;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "nbinomial.c", 70, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (n < 0)
    {
      do { gsl_error ("n < 0", "nbinomial.c", 75, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) n;
  b = (double) k + 1.0;
  Q = gsl_cdf_beta_Q (p, a, b);
  return Q;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 10
9 10
10 15
11 18
12 15
13 16
14 16
15 16
16 8
17 8
18 8
19 8
20 8
21 8
22 18
23 18
24 18
25 12
26 12
27 12
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
test   %rdx,%rdx
xorpd  %xmm0,%xmm0
je     217 <gsl_stats_uint_median_from_sorted_data+0x37>
lea    -0x1(%rdx),%rax
shr    %rdx
shl    $0x2,%rsi
shr    %rax
cmp    %rdx,%rax
je     220 <gsl_stats_uint_median_from_sorted_data+0x40>
imul   %rsi,%rax
imul   %rsi,%rdx
mov    (%rdi,%rax,1),%eax
add    (%rdi,%rdx,1),%eax
cvtsi2sd %rax,%xmm0
mulsd  0x0(%rip),%xmm0        # 217 <gsl_stats_uint_median_from_sorted_data+0x37>
repz retq 
nopl   0x0(%rax)
imul   %rax,%rsi
mov    (%rdi,%rsi,1),%eax
cvtsi2sd %rax,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_uint_median_from_sorted_data (const unsigned int sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 6
5 7
6 12
7 6
8 10
9 10
10 16
11 16
12 16
13 16
14 16
15 16
16 19
17 19
18 12
19 12
20 12
21 12
22 12
<<<sep_out_sample>>>
test   %edi,%edi
je     68 <madir_to_string+0x28>
cmp    $0x1,%edi
jne    58 <madir_to_string+0x18>
mov    $0x0,%edi
jmpq   53 <madir_to_string+0x13>
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
callq  61 <madir_to_string+0x21>
nopl   0x0(%rax)
mov    $0x0,%edi
jmpq   72 <madir_to_string+0x32>
<<<sep_in_sample>>>
madir_to_string (madir_t madir)
{
  switch (madir)
    {
    case madir_rows:
      return gettext ("rows first");
    case madir_columns:
      return gettext ("columns first");
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 8
6 8
7 8
8 2
9 10
10 10
11 6
12 6
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    7940 <gsl_matrix_uchar_const_column+0x30>
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  7962 <gsl_matrix_uchar_const_column+0x52>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_const_column (const gsl_matrix_uchar * m, const size_t j)
{
  _gsl_vector_uchar_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uchar v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 13
7 16
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 2
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 18
29 18
30 18
<<<sep_out_sample>>>
test   %edi,%edi
je     700 <code_ns_fraction+0xe0>
mov    %edi,%eax
mov    $0x66666667,%edx
movb   $0x2e,(%rsi)
imul   %edx
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
jne    706 <code_ns_fraction+0xe6>
mov    $0x9,%r8d
mov    $0x66666667,%ecx
jmp    663 <code_ns_fraction+0x43>
nopw   0x0(%rax,%rax,1)
mov    %r9d,%r8d
mov    %edi,%eax
sar    $0x1f,%edi
lea    -0x1(%r8),%r9d
imul   %ecx
sar    $0x2,%edx
sub    %edi,%edx
mov    %edx,%eax
mov    %edx,%edi
imul   %ecx
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
je     660 <code_ns_fraction+0x40>
sub    $0x2,%r8d
add    $0x30,%edx
movslq %r9d,%r9
movslq %r8d,%rax
test   %r8d,%r8d
movb   $0x0,0x1(%rsi,%r9,1)
mov    %dl,0x1(%rsi,%rax,1)
je     704 <code_ns_fraction+0xe4>
lea    -0x1(%rsi,%rax,1),%r9
lea    (%rsi,%rax,1),%rcx
lea    -0x1(%r8),%eax
mov    $0x66666667,%esi
sub    %rax,%r9
nop
mov    %edi,%eax
sar    $0x1f,%edi
sub    $0x1,%rcx
imul   %esi
sar    $0x2,%edx
sub    %edi,%edx
mov    %edx,%eax
mov    %edx,%edi
imul   %esi
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
mov    %edx,%eax
add    $0x30,%eax
mov    %al,0x1(%rcx)
cmp    %r9,%rcx
jne    6c0 <code_ns_fraction+0xa0>
repz retq 
nopl   0x0(%rax,%rax,1)
movb   $0x0,(%rsi)
retq   
repz retq 
add    $0x30,%edx
movb   $0x0,0xa(%rsi)
mov    $0x8,%r8d
mov    %dl,0x9(%rsi)
mov    $0x8,%eax
jmp    6aa <code_ns_fraction+0x8a>
nopl   (%rax)
<<<sep_in_sample>>>
code_ns_fraction (int ns, char *p)
{
  if (ns == 0)
    *p = '\0';
  else
    {
      int i = 9;
      *p++ = '.';
      while (ns % 10 == 0)
 {
   ns /= 10;
   i--;
 }
      p[i] = '\0';
      for (;;)
 {
   p[--i] = '0' + ns % 10;
   if (i == 0)
     break;
   ns /= 10;
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 9
5 8
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 7
17 11
18 11
19 11
20 12
21 11
22 11
23 12
24 11
25 11
26 11
27 9
28 11
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 17
40 17
41 14
42 17
43 18
44 14
45 17
46 18
47 18
48 18
49 18
50 20
51 20
52 20
53 20
54 20
55 20
56 20
57 20
58 20
59 17
60 20
61 17
62 17
63 17
64 17
65 17
66 17
67 17
68 17
69 17
70 17
71 17
72 17
73 18
74 18
75 18
76 18
77 4
78 4
79 4
80 17
81 14
82 17
83 17
84 17
85 17
86 17
<<<sep_out_sample>>>
mov    0x0(%rip),%r8d        # 157 <getconnmode+0x7>
mov    $0x100,%eax
test   %r8d,%r8d
je     168 <getconnmode+0x18>
repz retq 
nopl   0x0(%rax,%rax,1)
movzbl 0x0(%rip),%edx        # 16f <getconnmode+0x1f>
mov    0x0(%rip),%esi        # 175 <getconnmode+0x25>
mov    0x0(%rip),%edi        # 17b <getconnmode+0x2b>
and    $0x8,%edx
cmp    $0x1,%dl
sbb    %eax,%eax
and    $0x200,%eax
add    $0x100,%eax
cmp    $0x1,%dl
sbb    %edx,%edx
and    $0x200,%edx
test   %esi,%esi
cmovne %eax,%edx
movzbl 0x0(%rip),%eax        # 1a4 <getconnmode+0x54>
mov    %edx,%ecx
or     $0x4,%ch
test   $0x2,%al
cmovne %ecx,%edx
mov    %edx,%ecx
or     $0x8,%ch
test   $0x8,%al
cmovne %ecx,%edx
test   %edi,%edi
mov    %edx,%eax
je     1f0 <getconnmode+0xa0>
testb  $0x8,0x0(%rip)        # 1c5 <getconnmode+0x75>
jne    161 <getconnmode+0x11>
mov    0x0(%rip),%ecx        # 1cd <getconnmode+0x7d>
or     $0x3,%eax
test   %ecx,%ecx
je     161 <getconnmode+0x11>
mov    0x0(%rip),%esi        # 1da <getconnmode+0x8a>
cmp    %esi,0x0(%rip)        # 1e0 <getconnmode+0x90>
jle    161 <getconnmode+0x11>
mov    %edx,%eax
and    $0xfd,%ah
or     $0x3,%eax
retq   
nop
testb  $0x2,0x0(%rip)        # 1f7 <getconnmode+0xa7>
je     161 <getconnmode+0x11>
or     0x0(%rip),%eax        # 203 <getconnmode+0xb3>
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getconnmode (void)
{
  extern int linemode;
  int mode = 0;
  extern int kludgelinemode;
  if (In3270)
    return (0x0100);
  if ((!(options[1]&0x08)))
    mode |= 0x0200;
  if (localflow)
    mode |= 0x0100;
  if ((options[0]&0x02))
    mode |= 0x0400;
  if ((options[0]&0x08))
    mode |= 0x0800;
  if (kludgelinemode)
    {
      if ((!(options[3]&0x08)))
 {
   mode |= (0x02 | 0x01);
   if (dontlecho && (clocks.echotoggle > clocks.modenegotiated))
     {
       mode &= ~0x0200;
     }
 }
      return (mode);
    }
  if ((options[34]&0x02))
    mode |= linemode;
  return (mode);
}
<<<sep_in_sample>>>
1 6
2 7
3 6
4 6
5 31
6 31
7 8
8 11
9 16
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 11
19 11
20 12
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 16
30 16
31 16
32 18
33 18
34 21
35 20
36 21
37 21
38 21
39 21
40 21
41 23
42 23
43 23
44 23
45 23
46 28
47 28
48 29
49 31
50 31
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r13
mov    %rdi,0x8(%rsp)
mov    (%rsi),%r14
cmp    %r12,%r13
je     2971 <gsl_matrix_char_fscanf+0x81>
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r14,%r14
jne    2934 <gsl_matrix_char_fscanf+0x44>
jmp    2960 <gsl_matrix_char_fscanf+0x70>
nopw   0x0(%rax,%rax,1)
add    $0x1,%r15
add    %r13,%rbx
cmp    %r14,%r15
je     2960 <gsl_matrix_char_fscanf+0x70>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    0x8(%rsp),%rdi
mov    $0x1,%ecx
mov    %r12,%rdx
callq  294d <gsl_matrix_char_fscanf+0x5d>
test   %eax,%eax
je     2928 <gsl_matrix_char_fscanf+0x38>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r13,%rdx
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
imul   %r14,%rdx
mov    $0x1,%ecx
pop    %r14
pop    %r15
jmpq   2994 <gsl_matrix_char_fscanf+0xa4>
<<<sep_in_sample>>>
gsl_matrix_char_fscanf (FILE * stream, gsl_matrix_char * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_char_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_char_raw_fscanf (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 6
11 2
12 4
13 7
14 7
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 18
26 18
27 18
28 18
29 18
30 18
31 21
32 21
33 26
34 26
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 16
43 26
44 26
45 26
46 26
47 26
48 26
49 26
50 9
51 26
52 9
53 26
54 26
55 26
56 26
57 9
58 9
59 26
60 26
61 9
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
movslq %edx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rdi),%rcx
mov    0x18(%rdi),%rsi
lea    0x0(%rbp,%rcx,1),%rdx
cmp    %rdx,%rsi
jbe    b0 <__gmp_asprintf_reps+0x50>
mov    0x8(%rdi),%rdi
mov    %rbp,%rdx
mov    %r13d,%esi
add    %rcx,%rdi
callq  9a <__gmp_asprintf_reps+0x3a>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    %rdx,%rdx
mov    %rdx,0x18(%rdi)
mov    0x8(%rdi),%rdi
callq  *0x0(%rip)        # c1 <__gmp_asprintf_reps+0x61>
mov    0x10(%rbx),%rcx
mov    %rax,0x8(%rbx)
mov    %rax,%rdi
jmp    8c <__gmp_asprintf_reps+0x2c>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_asprintf_reps (struct gmp_asprintf_t *d, int c, int reps)
{
  do { size_t alloc, newsize, newalloc; do {} while (0); alloc = (d)->alloc; newsize = (d)->size + (reps); if (alloc <= newsize) { newalloc = 2*newsize; (d)->alloc = newalloc; (d)->buf = ((char *) (*__gmp_reallocate_func) ((d)->buf, (alloc) * sizeof (char), (newalloc) * sizeof (char))); } } while (0);
  memset (d->buf + d->size, c, reps);
  d->size += reps;
  return reps;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 5
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
<<<sep_out_sample>>>
mov    0x1020(%rdi),%rdi
mov    %ecx,%r8d
mov    $0x1,%ecx
jmpq   6d4 <read_audio_sectors_linux+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_audio_sectors_linux (void *p_user_data, void *p_buf, lsn_t i_lsn,
                           uint32_t i_blocks)
{
  _img_private_t *p_env = p_user_data;
  return mmc_read_sectors( p_env->gen.cdio, p_buf, i_lsn,
                           CDIO_MMC_READ_TYPE_CDDA, i_blocks);
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rcx
mov    %rdx,%r8
xor    %edx,%edx
jmpq   4c0 <gl_array_sortedlist_indexof_from_to>
xchg   %ax,%ax
<<<sep_in_sample>>>
gl_array_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
                             const void *elt)
{
  return gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count,
                                              elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     356 <gsl_stats_float_absdev_m+0x76>
xorpd  %xmm2,%xmm2
shl    $0x2,%rsi
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 2f7 <gsl_stats_float_absdev_m+0x17>
nopw   0x0(%rax,%rax,1)
movss  (%rdi),%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
cvtps2pd %xmm1,%xmm1
subsd  %xmm0,%xmm1
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
jne    300 <gsl_stats_float_absdev_m+0x20>
test   %rax,%rax
js     338 <gsl_stats_float_absdev_m+0x58>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    324 <gsl_stats_float_absdev_m+0x44>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_float_absdev_m (const float data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 6
4 6
5 8
6 8
7 8
8 10
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 8
17 13
18 13
19 13
20 13
21 13
22 15
23 15
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 6
34 6
35 6
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     5d1 <gsl_matrix_complex_fscanf+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    58e <gsl_matrix_complex_fscanf+0x4e>
jmp    5c0 <gsl_matrix_complex_fscanf+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     5c0 <gsl_matrix_complex_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  5a5 <gsl_matrix_complex_fscanf+0x65>
test   %eax,%eax
je     580 <gsl_matrix_complex_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   5f4 <gsl_matrix_complex_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_fscanf (FILE * stream, gsl_matrix_complex * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_raw_fscanf (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
push   %r14
mov    %edx,%eax
and    $0x1,%eax
push   %r13
cmp    $0x1,%eax
sbb    %r9d,%r9d
push   %r12
and    $0xffffffc0,%r9d
mov    %edx,%r12d
add    $0x240,%r9d
cmp    $0x1,%eax
mov    %r12d,%r14d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sbb    %edi,%edi
and    $0xffffffc0,%edi
add    $0x242,%edi
cmp    $0x1,%eax
sbb    %edx,%edx
and    $0xffffffc0,%edx
add    $0x42,%edx
cmp    $0x1,%eax
sbb    %r13d,%r13d
and    $0xffffffc0,%r13d
add    $0x2c0,%r13d
cmp    $0x1,%eax
sbb    %r11d,%r11d
and    $0xffffffc0,%r11d
add    $0x2c2,%r11d
cmp    $0x1,%eax
sbb    %esi,%esi
and    $0xffffffc0,%esi
add    $0xc2,%esi
cmp    $0x1,%eax
sbb    %r10d,%r10d
neg    %eax
and    $0xffffffc0,%r10d
and    $0x40,%eax
add    $0xc0,%r10d
and    $0x2,%r14d
cmove  %eax,%r10d
mov    %r12d,%eax
cmove  %edi,%r11d
cmovne %r13d,%r9d
cmovne %esi,%edx
and    $0x8,%eax
cmovne %r10d,%edx
cmove  %r11d,%r9d
test   $0x40,%r12b
cmove  %edx,%r9d
mov    %rbp,%rsi
mov    %rbx,%rdi
mov    %r9d,%edx
callq  c0 <CDB___os_open+0xc0>
test   %eax,%eax
mov    %eax,%r13d
jne    cd <CDB___os_open+0xcd>
and    $0x20,%r12d
jne    e0 <CDB___os_open+0xe0>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13d,%eax
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  eb <CDB___os_open+0xeb>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13d,%eax
pop    %r13
pop    %r14
retq   
<<<sep_in_sample>>>
CDB___os_open(dbenv, name, flags, mode, fhp)
 DB_ENV *dbenv;
 const char *name;
 u_int32_t flags;
 int mode;
 DB_FH *fhp;
{
 int oflags, ret;
 oflags = 0;
 if ((flags & (0x001)))
  oflags |= 0100;
 if ((flags & (0x002)))
  oflags |= 0200;
 if ((flags & (0x008)))
  oflags |= 00;
 else
  oflags |= 02;
 if ((flags & (0x040)))
  oflags |= 01000;
 if ((ret = CDB___os_openhandle(dbenv, name, oflags, mode, fhp)) != 0)
  return (ret);
 if ((flags & (0x020)))
  (void)CDB___os_unlink(dbenv, name);
 return (0);
}
<<<sep_in_sample>>>
1 7
2 10
3 10
4 7
5 10
6 10
7 7
8 10
9 7
10 10
11 10
12 12
13 7
14 7
15 7
16 7
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 12
43 12
44 14
45 12
46 12
47 12
48 14
49 14
50 14
51 18
52 18
53 20
54 20
55 20
56 20
57 20
58 20
59 20
60 22
61 22
62 25
63 25
64 25
65 25
66 25
67 25
68 25
69 25
70 23
71 23
72 23
73 25
74 25
75 25
76 25
77 25
78 25
79 25
<<<sep_out_sample>>>
test   %rdi,%rdi
je     186 <cdio_audio_resume+0x26>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     180 <cdio_audio_resume+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_audio_resume (CdIo_t *p_cdio)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_resume) {
    return p_cdio->op.audio_resume(p_cdio->env);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
13 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
movq   $0x100,0x18(%rsp)
mov    $0x100,%edi
callq  *0x0(%rip)        # e4 <__gmp_vasprintf+0x24>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
movq   $0x0,0x10(%rsp)
callq  105 <__gmp_vasprintf+0x45>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmp_vasprintf (char **result, const char *fmt, va_list ap)
{
  struct gmp_asprintf_t d;
  do { (d).result = (result); (d).alloc = 256; (d).buf = (char *) (*__gmp_allocate_func) ((d).alloc); (d).size = 0; } while (0);
  return __gmp_doprnt (&__gmp_asprintf_funs, &d, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 4
15 4
16 5
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
push   %rbp
mov    $0x8,%edx
mov    $0x0,%ecx
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  ab <xdr_simx_entity_type_attr+0x1b>
xor    %edx,%edx
test   %eax,%eax
je     c8 <xdr_simx_entity_type_attr+0x38>
lea    0x8(%rbp),%rsi
mov    $0x100,%dx
mov    %rbx,%rdi
callq  c1 <xdr_simx_entity_type_attr+0x31>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_simx_entity_type_attr (XDR *xdrs, simx_entity_type_attr *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->type, sizeof (dis_entity_type), (xdrproc_t) xdr_dis_entity_type))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->attr, 256))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 2
7 2
8 5
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xe,%edi
jmpq   10 <nettle_aes256_set_decrypt_key>
<<<sep_in_sample>>>
nettle_aes256_invert_key (struct aes256_ctx *dst, const struct aes256_ctx *src)
{
  _nettle_aes_invert (14, dst->keys, src->keys);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_pow_2(const double x) { return x*x; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
mov    0x0(%rip),%rdi        # 27f <dirwatcher_register+0xf>
movl   $0x1,(%rsp)
test   %rdi,%rdi
je     2b8 <dirwatcher_register+0x48>
lea    0x10(%rsp),%rsi
mov    %rsp,%rdx
movq   $0x0,0x10(%rsp)
mov    %rbx,0x18(%rsp)
callq  2a6 <dirwatcher_register+0x36>
test   %rax,%rax
je     2e9 <dirwatcher_register+0x79>
add    $0x20,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %r8d,%r8d
mov    $0x0,%r9d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x10,%dil
callq  2d8 <dirwatcher_register+0x68>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 2e2 <dirwatcher_register+0x72>
je     2e9 <dirwatcher_register+0x79>
mov    %rax,%rdi
jmp    28b <dirwatcher_register+0x1b>
mov    $0x0,%edi
callq  2f3 <dirwatcher_register+0x83>
mov    $0x3,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  302 <dirwatcher_register+0x92>
mov    $0x1,%edi
callq  30c <dirwatcher_register+0x9c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dirwatcher_register(struct dirwatcher *dw)
{
 struct dwref key;
 struct dwref *ent;
 int install = 1;
 if (!dwtab) {
  dwtab = hashtab_create(sizeof(struct dwref),
           dw_hash, dw_cmp, dw_copy,
           ((void *)0), dwref_free);
  if (!dwtab) {
   diag(3, gettext("not enough memory"));
   exit(1);
  }
 }
 memset(&key, 0, sizeof(key));
 key.dw = dw;
 ent = hashtab_lookup_or_install(dwtab, &key, &install);
 if (!ent) {
  diag(3, gettext("not enough memory"));
  exit(1);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 5
6 6
7 6
8 17
9 17
10 15
11 16
12 17
13 18
14 18
15 22
16 22
17 22
18 22
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 10
27 7
28 10
29 10
30 10
31 19
32 19
33 19
34 19
35 19
36 19
37 20
38 20
39 20
<<<sep_out_sample>>>
push   %r12
mov    %edi,%r12d
mov    $0x20,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  14 <addcmd+0x14>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 1e <addcmd+0x1e>
test   %rax,%rax
je     60 <addcmd+0x60>
mov    %rbx,0x8(%rax)
mov    %rbx,0x0(%rip)        # 2e <addcmd+0x2e>
movq   $0x0,0x8(%rbx)
mov    %rax,(%rbx)
mov    %r12d,0x10(%rbx)
mov    %rbp,%rdi
callq  45 <addcmd+0x45>
mov    %rax,0x18(%rbx)
movq   $0x0,0x0(%rip)        # 54 <addcmd+0x54>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %rbx,0x0(%rip)        # 67 <addcmd+0x67>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
jmp    39 <addcmd+0x39>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addcmd(int f, char *s)
{
 struct cmd *h;
 h = mymalloc(sizeof(struct cmd));
 if( tail) {
  tail->next = h;
  h->next = 0;
  h->prev = tail;
  tail = h;
 } else {
  tail = h;
  h->next = h->prev = 0;
 }
 h->field = f;
 h->text = my_strdup( s);
 current = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 5
10 5
11 5
12 6
13 9
14 7
15 8
16 14
17 15
18 15
19 15
20 16
21 17
22 17
23 17
24 17
25 17
26 11
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1f29 <write_fatal_details+0x9>
mov    0x0(%rip),%edi        # 1f2f <write_fatal_details+0xf>
cmp    $0x3fffffff,%edi
jle    1f5d <write_fatal_details+0x3d>
sub    $0x40000000,%edi
callq  1f42 <write_fatal_details+0x22>
test   %eax,%eax
setne  %al
test   %al,%al
jne    1f69 <write_fatal_details+0x49>
mov    0x0(%rip),%edi        # 1f51 <write_fatal_details+0x31>
xor    %esi,%esi
callq  1f58 <write_fatal_details+0x38>
callq  1f5d <write_fatal_details+0x3d>
callq  1f62 <write_fatal_details+0x42>
test   %eax,%eax
setne  %al
jmp    1f47 <write_fatal_details+0x27>
mov    0x0(%rip),%rax        # 1f70 <write_fatal_details+0x50>
mov    (%rax),%rdi
callq  1f78 <write_fatal_details+0x58>
jmp    1f4b <write_fatal_details+0x2b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_fatal_details (char const *name, ssize_t status, size_t size)
{
  write_error_details (name, status, size);
  if ((((archive) >= (1 << 30)) ? rmt_close__ (archive - (1 << 30)) : close (archive)) != 0)
    close_error (*archive_name_cursor);
  sys_wait_for_child (child_pid, 0);
  fatal_exit ();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 7
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 5
24 5
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 4a7 <gpath_nextkey+0x7>
je     4b0 <gpath_nextkey+0x10>
mov    0x0(%rip),%eax        # 4af <gpath_nextkey+0xf>
retq   
push   %rax
mov    $0x0,%ecx
mov    $0xfb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4ca <gpath_nextkey+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_nextkey(void)
{
 ((_mode != 1) ? (void) (0) : __assert_fail ("_mode != 1", "gpathop.c", 251, __PRETTY_FUNCTION__));
 return _nextkey;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 2
6 3
7 3
8 3
9 3
10 3
11 3
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 219 <valprint+0x9>
mov    %edi,%r12d
push   %rbp
movslq %edi,%rbp
shl    $0x3,%rbp
test   %esi,%esi
push   %rbx
jns    247 <valprint+0x37>
jmpq   2b8 <valprint+0xa8>
xchg   %ax,%ax
mov    %r12d,%edi
callq  210 <valprint>
mov    0x0(%rip),%rax        # 23f <valprint+0x2f>
mov    0xc(%rax,%rbx,1),%esi
test   %esi,%esi
js     2b8 <valprint+0xa8>
movslq %esi,%rsi
lea    (%rsi,%rsi,2),%rbx
shl    $0x3,%rbx
add    %rbx,%rax
mov    0x8(%rax),%esi
test   %esi,%esi
jns    230 <valprint+0x20>
mov    0x0(%rip),%rdx        # 263 <valprint+0x53>
movslq 0x10(%rax),%rax
mov    (%rdx,%rbp,1),%rdx
mov    (%rdx,%rax,4),%edx
test   %edx,%edx
je     2c0 <valprint+0xb0>
mov    0x0(%rip),%rdx        # 279 <valprint+0x69>
mov    0x0(%rip),%rdi        # 280 <valprint+0x70>
mov    $0x0,%esi
mov    (%rdx,%rbp,1),%rdx
movsd  (%rdx,%rax,8),%xmm0
mov    $0x1,%eax
callq  298 <valprint+0x88>
mov    0x0(%rip),%rsi        # 29f <valprint+0x8f>
mov    $0x7c,%edi
callq  2a9 <valprint+0x99>
mov    0x0(%rip),%rax        # 2b0 <valprint+0xa0>
mov    0xc(%rax,%rbx,1),%esi
test   %esi,%esi
jns    247 <valprint+0x37>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x0(%rip),%rdi        # 2c7 <valprint+0xb7>
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  2d8 <valprint+0xc8>
jmp    298 <valprint+0x88>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
valprint(int row, int node)
{
  while (node >= 0)
    {
      if (collabel[node].labd >= 0)
 valprint(row, collabel[node].labd);
      else
 {
   if (valset[row][collabel[node].labc])
     fprintf(dap_lst, tabform, tableval[row][collabel[node].labc]);
   else
     fprintf(dap_lst, emptyform, "");
   _IO_putc ('|', dap_lst);
 }
      node = collabel[node].laba;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 9
6 9
7 3
8 2
9 3
10 3
11 3
12 6
13 6
14 15
15 15
16 3
17 3
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 9
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 13
39 13
40 13
41 15
42 15
43 3
44 3
45 17
46 17
47 17
48 17
49 17
50 12
51 12
52 12
53 12
54 12
55 12
56 12
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,(%rdi)
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
jne    370 <stream_close+0x20>
callq  362 <stream_close+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   36b <stream_close+0x1b>
nopl   0x0(%rax,%rax,1)
callq  375 <stream_close+0x25>
mov    %rbx,%rdi
pop    %rbx
jmpq   37e <stream_close+0x2e>
<<<sep_in_sample>>>
stream_close (struct stream * stream)
{
  if (stream->is_file)
    fclose (stream->fp);
  else
    pclose (stream->fp);
  free (stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 3
6 6
7 7
8 8
9 7
10 7
11 4
12 7
13 8
14 7
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     398 <mu_mailer_set_url_default+0x38>
push   %rbx
callq  370 <mu_mailer_set_url_default+0x10>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     397 <mu_mailer_set_url_default+0x37>
mov    0x0(%rip),%rdi        # 384 <mu_mailer_set_url_default+0x24>
test   %rdi,%rdi
je     38e <mu_mailer_set_url_default+0x2e>
callq  38e <mu_mailer_set_url_default+0x2e>
mov    %rbx,0x0(%rip)        # 395 <mu_mailer_set_url_default+0x35>
xor    %eax,%eax
pop    %rbx
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailer_set_url_default (const char *url)
{
  char *n = ((void *)0);
  if (!url)
    return 22;
  if ((n = strdup (url)) == ((void *)0))
    return 12;
  if (mailer_url_default)
    free (mailer_url_default);
  mailer_url_default = n;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 2
5 6
6 6
7 7
8 6
9 6
10 8
11 8
12 8
13 9
14 10
15 11
16 12
17 12
18 12
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
mov    (%rcx),%rax
je     c56 <gsl_vector_ulong_min+0x36>
lea    0x0(,%rdx,8),%rdi
xor    %edx,%edx
nopl   (%rax)
mov    (%rcx),%rsi
cmp    %rsi,%rax
cmova  %rsi,%rax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    c40 <gsl_vector_ulong_min+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_min (const gsl_vector_ulong * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    %rdi,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  a96 <print_version_only+0x16>
mov    $0x0,%edi
callq  aa0 <print_version_only+0x20>
mov    %rbx,%rdi
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  ab2 <print_version_only+0x32>
mov    %rbx,%rsi
mov    $0xa,%edi
pop    %rbx
jmpq   ac0 <print_version>
<<<sep_in_sample>>>
print_version_only(const char *program_version, FILE *stream)
{
  fprintf (stream, "%s\n", program_version);
  fprintf (stream, version_etc_copyright, gettext("(C)"));
  fputc ('\n', stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 5
<<<sep_out_sample>>>
jmpq   5 <osip_route_init+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_route_init (osip_route_t ** route)
{
  return osip_from_init ((osip_from_t **) route);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  de0 <with_input_from_buffered_stream+0x10>
mov    $0x0,%edi
test   %rax,%rax
mov    $0x0,%eax
cmovne %rax,%rdi
mov    %rbx,%r8
mov    %rbp,%rcx
mov    $0x4,%edx
mov    $0x0,%esi
callq  e06 <with_input_from_buffered_stream+0x36>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
with_input_from_buffered_stream (bfd, name)
     int bfd;
     char *name;
{
  INPUT_STREAM location;
  BUFFERED_STREAM *bp;
  location.buffered_fd = bfd;
  bp = fd_to_buffered_stream (bfd);
  init_yy_io (bp == 0 ? return_EOF : buffered_getchar,
       buffered_ungetchar, st_bstream, name, location);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 4
6 8
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 11
17 11
18 11
19 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     b9a0 <gsl_fft_halfcomplex_wavetable_free+0x30>
mov    0x410(%rdi),%rdi
callq  b985 <gsl_fft_halfcomplex_wavetable_free+0x15>
movq   $0x0,0x410(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   b999 <gsl_fft_halfcomplex_wavetable_free+0x29>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_halfcomplex_wavetable_free (gsl_fft_halfcomplex_wavetable * wavetable)
{
  if (!wavetable) { return ; };
  free (wavetable->trig);
  wavetable->trig = ((void *)0);
  free (wavetable);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     1b39 <gsl_vector_char_isnonneg+0x39>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
xor    %eax,%eax
nopw   %cs:0x0(%rax,%rax,1)
movsbl (%rdx),%edi
cvtsi2sd %edi,%xmm0
ucomisd %xmm0,%xmm1
ja     1b3f <gsl_vector_char_isnonneg+0x3f>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1b20 <gsl_vector_char_isnonneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_char_isnonneg (const gsl_vector_char * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 11
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     40 <ecopy+0x40>
callq  13 <ecopy+0x13>
lea    0x1(%rax),%rbp
mov    %rbp,%rdi
callq  1f <ecopy+0x1f>
test   %rax,%rax
je     44 <ecopy+0x44>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  32 <ecopy+0x32>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    32 <ecopy+0x32>
mov    $0x0,%edi
callq  4e <ecopy+0x4e>
mov    $0x1,%edi
callq  58 <ecopy+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ecopy(char *e)
{
  char *copy;
  if (e)
    {
      if (!(copy = malloc(strlen(e) + 1)))
 {
   perror("dap");
   exit(1);
 }
      strcpy(copy, e);
      return copy;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 11
14 11
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 14
23 14
24 8
25 8
26 9
27 9
28 9
<<<sep_out_sample>>>
push   %rbx
mov    0x24(%rdi),%eax
mov    %rdi,%rbx
lea    -0xc8(%rax),%edx
cmp    $0xa,%edx
jbe    814 <jpeg_input_complete+0x24>
mov    (%rdi),%rdx
mov    %eax,0x2c(%rdx)
mov    (%rdi),%rax
movl   $0x14,0x28(%rdx)
callq  *(%rax)
mov    0x240(%rbx),%rax
pop    %rbx
mov    0x24(%rax),%eax
retq   
<<<sep_in_sample>>>
jpeg_input_complete (j_decompress_ptr cinfo)
{
  if (cinfo->global_state < 200 ||
      cinfo->global_state > 210)
    ((cinfo)->err->msg_code = (JERR_BAD_STATE), (cinfo)->err->msg_parm.i[0] = (cinfo->global_state), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
  return cinfo->inputctl->eoi_reached;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 6
13 7
14 6
15 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 156a <gsl_matrix_short_ptr+0xa>
test   %eax,%eax
je     1579 <gsl_matrix_short_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1590 <gsl_matrix_short_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    15b0 <gsl_matrix_short_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,2),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15a9 <gsl_matrix_short_ptr+0x49>
xor    %eax,%eax
jmp    1589 <gsl_matrix_short_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15c9 <gsl_matrix_short_ptr+0x69>
xor    %eax,%eax
jmp    1589 <gsl_matrix_short_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_short_ptr(gsl_matrix_short * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_short.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_short.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (short *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xor    %edx,%edx
xor    %eax,%eax
jmp    10cd <rl_unbind_function_in_map+0x1d>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x10,%rdx
cmp    $0x1010,%rdx
je     10f5 <rl_unbind_function_in_map+0x45>
cmpb   $0x0,(%rsi,%rdx,1)
jne    10c0 <rl_unbind_function_in_map+0x10>
cmp    %rdi,0x8(%rsi,%rdx,1)
jne    10c0 <rl_unbind_function_in_map+0x10>
movq   $0x0,0x8(%rsi,%rdx,1)
add    $0x10,%rdx
mov    $0x1,%eax
cmp    $0x1010,%rdx
jne    10cd <rl_unbind_function_in_map+0x1d>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_unbind_function_in_map (func, map)
     rl_command_func_t *func;
     Keymap map;
{
  register int i, rval;
  for (i = rval = 0; i < 257; i++)
    {
      if (map[i].type == 0 && map[i].function == func)
 {
   map[i].function = (rl_command_func_t *)((void *)0);
   rval = 1;
 }
    }
  return rval;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 8
9 8
10 8
11 8
12 10
13 10
14 11
15 6
16 6
17 15
18 15
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     22b0 <gsl_matrix_sub+0x50>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2293 <gsl_matrix_sub+0x33>
mov    $0x13,%eax
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsi),%r9
cmp    %rax,%r9
jne    227a <gsl_matrix_sub+0x1a>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rbx
test   %r10,%r10
mov    %rax,(%rsp)
mov    %rbx,0x8(%rsp)
je     23d4 <gsl_matrix_sub+0x174>
shl    $0x3,%rax
mov    %r10,0x20(%rsp)
xor    %r12d,%r12d
mov    %rax,0x10(%rsp)
lea    0x0(,%rbx,8),%rax
xor    %r8d,%r8d
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rax,0x18(%rsp)
mov    %r9,%rax
mov    %rdi,0x28(%rsp)
shr    %rax
lea    (%rax,%rax,1),%r13
mov    %rax,%r10
nopl   (%rax)
test   %r9,%r9
je     23b2 <gsl_matrix_sub+0x152>
mov    0x28(%rsp),%rax
mov    0x18(%rsi),%r15
mov    0x18(%rax),%r14
lea    (%r15,%rbp,1),%rcx
lea    0x10(%rcx),%rax
lea    (%r14,%rbx,1),%rdx
cmp    %rax,%rdx
lea    0x10(%rdx),%rax
setae  %dil
cmp    %rax,%rcx
setae  %al
or     %al,%dil
je     23e0 <gsl_matrix_sub+0x180>
cmp    $0x13,%r9
jbe    23e0 <gsl_matrix_sub+0x180>
test   %r13,%r13
je     2396 <gsl_matrix_sub+0x136>
xor    %eax,%eax
xor    %edi,%edi
movsd  (%rcx,%rax,1),%xmm1
add    $0x1,%rdi
movsd  (%rdx,%rax,1),%xmm0
movhpd 0x8(%rax,%rcx,1),%xmm1
movhpd 0x8(%rdx,%rax,1),%xmm0
subpd  %xmm1,%xmm0
movlpd %xmm0,(%rdx,%rax,1)
movhpd %xmm0,0x8(%rdx,%rax,1)
add    $0x10,%rax
cmp    %rdi,%r10
ja     235f <gsl_matrix_sub+0xff>
cmp    %r9,%r13
je     23b2 <gsl_matrix_sub+0x152>
lea    0x0(%r13,%r8,1),%rax
lea    0x0(%r13,%r12,1),%rdx
lea    (%r14,%rax,8),%rax
movsd  (%rax),%xmm0
subsd  (%r15,%rdx,8),%xmm0
movsd  %xmm0,(%rax)
add    $0x1,%r11
add    0x10(%rsp),%rbx
add    0x18(%rsp),%rbp
add    (%rsp),%r8
add    0x8(%rsp),%r12
cmp    0x20(%rsp),%r11
jne    2310 <gsl_matrix_sub+0xb0>
xor    %eax,%eax
jmpq   2298 <gsl_matrix_sub+0x38>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movsd  (%rdx,%rax,8),%xmm0
subsd  (%rcx,%rax,8),%xmm0
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r9,%rax
jne    23e8 <gsl_matrix_sub+0x188>
jmp    23b2 <gsl_matrix_sub+0x152>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_sub (gsl_matrix * a, const gsl_matrix * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 4
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 23
19 23
20 23
21 23
22 23
23 23
24 23
25 23
26 23
27 5
28 5
29 5
30 11
31 12
32 14
33 11
34 12
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 14
51 14
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 16
66 16
67 16
68 16
69 16
70 16
71 16
72 16
73 18
74 18
75 18
76 18
77 18
78 18
79 18
80 18
81 18
82 18
83 18
84 18
85 18
86 18
87 18
88 18
89 18
90 18
91 18
92 14
93 14
94 14
95 14
96 14
97 14
98 14
99 21
100 21
101 21
102 16
103 16
104 18
105 18
106 18
107 16
108 16
109 16
110 16
111 16
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
test   %rcx,%rcx
movsd  (%rdx),%xmm0
je     c5 <gsl_histogram_min_val+0x35>
lea    0x8(%rdx),%rax
lea    (%rdx,%rcx,8),%rdx
jmp    c0 <gsl_histogram_min_val+0x30>
nopw   0x0(%rax,%rax,1)
movsd  (%rax),%xmm1
add    $0x8,%rax
minsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
cmp    %rdx,%rax
jne    b0 <gsl_histogram_min_val+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_min_val (const gsl_histogram * h)
{
  size_t i;
  double min = h->bin[0];
  for (i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 4
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 5
15 5
16 13
17 13
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fdfsolver_root (const gsl_multiroot_fdfsolver * s)
{
  return s->x;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <savestring+0x9>
lea    0x1(%rax),%rdi
callq  12 <savestring+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1d <savestring+0x1d>
pop    %rbx
retq   
<<<sep_in_sample>>>
savestring (s)
     const char *s;
{
  char *ret;
  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
  return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
9 8
10 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 39a <_rl_arg_getchar+0xa>
mov    $0x0,%edi
imul   0x0(%rip),%esi        # 3a6 <_rl_arg_getchar+0x16>
xor    %eax,%eax
callq  3ad <_rl_arg_getchar+0x1d>
orq    $0x40,0x0(%rip)        # 3b5 <_rl_arg_getchar+0x25>
callq  3ba <_rl_arg_getchar+0x2a>
andq   $0xffffffffffffffbf,0x0(%rip)        # 3c2 <_rl_arg_getchar+0x32>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_arg_getchar ()
{
  int c;
  rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
  (rl_readline_state |= (0x0000040));
  c = rl_read_key ();
  (rl_readline_state &= ~(0x0000040));
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 7
10 9
11 9
12 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 2307 <init_backup_dir+0x7>
test   %rdi,%rdi
je     2349 <init_backup_dir+0x49>
push   %rbx
callq  2312 <init_backup_dir+0x12>
test   %rax,%rax
mov    %rax,%rbx
je     2329 <init_backup_dir+0x29>
mov    %rax,%rdi
callq  2322 <init_backup_dir+0x22>
cmpb   $0x2f,-0x1(%rbx,%rax,1)
je     2350 <init_backup_dir+0x50>
mov    %rbx,%rdi
callq  2331 <init_backup_dir+0x31>
mov    0x0(%rip),%rdi        # 2338 <init_backup_dir+0x38>
callq  233d <init_backup_dir+0x3d>
pop    %rbx
movq   $0x0,0x0(%rip)        # 2349 <init_backup_dir+0x49>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 2357 <init_backup_dir+0x57>
callq  235c <init_backup_dir+0x5c>
mov    %rbx,0x0(%rip)        # 2363 <init_backup_dir+0x63>
pop    %rbx
jmp    2349 <init_backup_dir+0x49>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_backup_dir(void)
{
    char *full_backup_dir;
    if (backup_dir == ((void *)0))
 return;
    full_backup_dir = get_full_path(backup_dir);
    if (full_backup_dir == ((void *)0) ||
  full_backup_dir[strlen(full_backup_dir) - 1] != '/') {
 free(full_backup_dir);
 free(backup_dir);
 backup_dir = ((void *)0);
    } else {
 free(backup_dir);
 backup_dir = full_backup_dir;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 7
7 6
8 7
9 8
10 8
11 7
12 7
13 9
14 9
15 10
16 10
17 16
18 11
19 16
20 16
21 13
22 13
23 14
24 16
25 16
26 16
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  aa0 <topdomain+0x10>
lea    -0x1(%rbx,%rax,1),%rdx
cmp    %rdx,%rbx
ja     ad0 <topdomain+0x40>
xor    %eax,%eax
jmp    ab9 <topdomain+0x29>
xchg   %ax,%ax
sub    $0x1,%rdx
cmp    %rdx,%rbx
ja     ad0 <topdomain+0x40>
cmpb   $0x2e,(%rdx)
jne    ab0 <topdomain+0x20>
add    $0x1,%eax
cmp    %ebp,%eax
jne    ab0 <topdomain+0x20>
add    $0x8,%rsp
lea    0x1(%rdx),%rax
pop    %rbx
pop    %rbp
retq   
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topdomain (char *name, int max_dots)
{
  char *p;
  int dot_count = 0;
  for (p = name + strlen (name) - 1; p >= name; p--)
    {
      if (*p == '.' && ++dot_count == max_dots)
 return p + 1;
    }
  return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 4
11 4
12 4
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 11
22 8
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
test   %rdi,%rdi
je     970 <anubis_regex_source+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
anubis_regex_source (RC_REGEX *re)
{
  if (!re)
    return ((void *)0);
  return re->src;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1040 <gsl_vector_float_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1035 <gsl_vector_float_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     107b <gsl_vector_float_sub+0x6b>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
movss  (%rax),%xmm0
add    $0x1,%rdx
subss  (%rcx),%xmm0
add    %r9,%rcx
movss  %xmm0,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1060 <gsl_vector_float_sub+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_float_sub (gsl_vector_float * a, const gsl_vector_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_opaque (osip_www_authenticate_t * www_authenticate, char *opaque)
{
  www_authenticate->opaque = (char *) opaque;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     3ff <gsl_vector_uint_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3f5 <gsl_vector_uint_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     433 <gsl_vector_uint_memcpy+0x63>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%esi
add    $0x1,%rax
add    %r10,%rcx
mov    %esi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    420 <gsl_vector_uint_memcpy+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_memcpy (gsl_vector_uint * dest,
                               const gsl_vector_uint * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
mov    %esi,0x8(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_set_type (mu_m_server_t srv, int type)
{
  srv->deftype = type;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
movapd %xmm2,%xmm1
sub    $0x18,%rsp
callq  11 <gsl_cdf_weibull_P+0x11>
movsd  0x0(%rip),%xmm1        # 19 <gsl_cdf_weibull_P+0x19>
xorpd  %xmm1,%xmm0
movapd %xmm1,(%rsp)
callq  27 <gsl_cdf_weibull_P+0x27>
movapd (%rsp),%xmm1
add    $0x18,%rsp
xorpd  %xmm1,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_weibull_P (const double x, const double a, const double b)
{
  double P = -expm1 (-pow(x/a, b));
  return P;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 3
12 5
13 5
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rsi,%rbx
mov    $0x5310,%esi
sub    $0x10,%rsp
mov    0x18(%rdi),%edi
mov    %rsp,%rdx
movb   $0x1,0x5(%rsp)
callq  f3f <get_last_session_linux+0x1f>
test   %eax,%eax
jne    f50 <get_last_session_linux+0x30>
mov    (%rsp),%eax
mov    %eax,(%rbx)
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
retq   
callq  f55 <get_last_session_linux+0x35>
mov    (%rax),%edi
callq  f5c <get_last_session_linux+0x3c>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  f6b <get_last_session_linux+0x4b>
mov    $0xffffffff,%eax
jmp    f4a <get_last_session_linux+0x2a>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_last_session_linux (void *p_user_data,
                                lsn_t *i_last_session)
{
  const _img_private_t *p_env = p_user_data;
  struct cdrom_multisession ms;
  int i_rc;
  ms.addr_format = 0x01;
  i_rc = ioctl(p_env->gen.fd, 0x5310, &ms);
  if (0 == i_rc) {
    *i_last_session = ms.addr.lba;
    return DRIVER_OP_SUCCESS;
  } else {
    cdio_warn ("ioctl CDROMMULTISESSION failed: %s\n", strerror((*__errno_location ())));
    return DRIVER_OP_ERROR;
  }
}
<<<sep_in_sample>>>
1 3
2 8
3 3
4 8
5 3
6 8
7 8
8 7
9 8
10 9
11 9
12 10
13 10
14 11
15 16
16 16
17 16
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 2ccb <non_monotonic_error+0xb>
mov    0x0(%rip),%rdx        # 2cd2 <non_monotonic_error+0x12>
mov    $0x0,%esi
xor    %eax,%eax
callq  2cde <non_monotonic_error+0x1e>
mov    $0x1,%edi
callq  2ce8 <non_monotonic_error+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
non_monotonic_error (void)
{
  fprintf (stderr, "%s: error: the abscissa values are not monotonic\n",
    progname);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
<<<sep_out_sample>>>
movsd  0x250(%rdi),%xmm0
xorpd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm0        # 14 <magHeading+0x14>
ucomisd %xmm0,%xmm1
ja     20 <magHeading+0x20>
repz retq 
nopl   0x0(%rax)
addsd  0x0(%rip),%xmm0        # 28 <magHeading+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
magHeading(craft * c)
{
 register double h = c->curHeading + mag_var;
 return (h < 0.0) ? h + 2.0 * 3.14159265358979323846 : h;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 4
6 5
7 5
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 389 <panicn+0x19>
mov    0x0(%rip),%rdi        # 390 <panicn+0x20>
callq  395 <panicn+0x25>
mov    0x0(%rip),%rdi        # 39c <panicn+0x2c>
mov    %ebp,%edx
mov    %rbx,%rsi
xor    %eax,%eax
callq  3a8 <panicn+0x38>
mov    0x0(%rip),%rsi        # 3af <panicn+0x3f>
mov    $0xa,%edi
callq  3b9 <panicn+0x49>
mov    $0x1,%edi
callq  3c3 <panicn+0x53>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panicn (const char *fmt, int n)
{
  fprintf (stderr, "%s panic: ", progname);
  fprintf (stderr, fmt, n);
  fprintf (stderr, "\n");
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 2
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 6
20 6
21 6
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  7db <_prog_read+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   7fa <_prog_read+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_prog_read (mu_stream_t stream, char *optr, size_t osize,
     mu_off_t offset, size_t *pnbytes)
{
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  return mu_stream_read (fs->in, optr, osize, offset, pnbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 6d57 <unbind_function_def+0x7>
push   %rbx
xor    %edx,%edx
callq  6d5f <unbind_function_def+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     6d9e <unbind_function_def+0x4e>
mov    0x10(%rax),%rdi
test   %rdi,%rdi
je     6d75 <unbind_function_def+0x25>
callq  6d75 <unbind_function_def+0x25>
mov    0x8(%rbx),%rdi
mov    $0xd73,%edx
mov    $0x0,%esi
callq  6d88 <unbind_function_def+0x38>
mov    %rbx,%rdi
mov    $0xd74,%edx
mov    $0x0,%esi
callq  6d9a <unbind_function_def+0x4a>
xor    %eax,%eax
pop    %rbx
retq   
mov    $0xffffffff,%eax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unbind_function_def (name)
     const char *name;
{
  BUCKET_CONTENTS *elt;
  FUNCTION_DEF *funcdef;
  elt = hash_remove (name, shell_function_defs, 0);
  if (elt == 0)
    return -1;
  funcdef = (FUNCTION_DEF *)elt->data;
  if (funcdef)
    dispose_function_def (funcdef);
  sh_xfree((elt->key), "variables.c", 3443);
  sh_xfree((elt), "variables.c", 3444);
  return 0;
}
<<<sep_in_sample>>>
1 6
2 3
3 6
4 6
5 7
6 6
7 7
8 9
9 10
10 10
11 11
12 12
13 12
14 12
15 12
16 13
17 13
18 13
19 13
20 14
21 15
22 15
23 8
24 15
25 15
26 15
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%r8
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d50 <mu_cfg_parse_boolean+0xe0>
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d50 <mu_cfg_parse_boolean+0xe0>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d50 <mu_cfg_parse_boolean+0xe0>
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d50 <mu_cfg_parse_boolean+0xe0>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d50 <mu_cfg_parse_boolean+0xe0>
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d40 <mu_cfg_parse_boolean+0xd0>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d40 <mu_cfg_parse_boolean+0xd0>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d40 <mu_cfg_parse_boolean+0xd0>
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     3d40 <mu_cfg_parse_boolean+0xd0>
mov    $0x2,%ecx
mov    %rax,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x1,%eax
seta   %cl
setb   %dl
cmp    %dl,%cl
jne    3d49 <mu_cfg_parse_boolean+0xd9>
nopl   (%rax)
movl   $0x0,(%r8)
xor    %eax,%eax
repz retq 
nopl   0x0(%rax,%rax,1)
movl   $0x1,(%r8)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_parse_boolean (const char *str, int *res)
{
  if (strcmp (str, "yes") == 0
      || strcmp (str, "on") == 0
      || strcmp (str, "t") == 0
      || strcmp (str, "true") == 0
      || strcmp (str, "1") == 0)
    *res = 1;
  else if (strcmp (str, "no") == 0
    || strcmp (str, "off") == 0
    || strcmp (str, "nil") == 0
    || strcmp (str, "false") == 0
    || strcmp (str, "0") == 0)
    *res = 0;
  else
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 11
39 11
40 11
41 11
42 11
43 12
44 12
45 12
46 12
47 12
48 13
49 13
50 13
51 13
52 16
53 13
54 13
55 13
56 13
57 13
58 14
59 17
60 18
61 18
62 8
63 17
64 8
65 8
<<<sep_out_sample>>>
test   %rdi,%rdi
je     390 <mu_property_unset+0x10>
mov    (%rdi),%rdi
jmpq   38d <mu_property_unset+0xd>
nopl   (%rax)
mov    $0x16,%eax
retq   
<<<sep_in_sample>>>
mu_property_unset (mu_property_t prop, const char *key)
{
  if (!prop)
    return 22;
  return mu_assoc_remove (prop->assoc, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    2570 <gsl_matrix_uint_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,4),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2592 <gsl_matrix_uint_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_row (gsl_matrix_uint * m, const size_t i)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
jmp    45b7 <rl_get_keymap_by_name+0x27>
add    $0x1,%rbx
mov    %rbx,%rax
shl    $0x4,%rax
mov    0x0(%rax),%rsi
test   %rsi,%rsi
je     45e0 <rl_get_keymap_by_name+0x50>
mov    %rbp,%rdi
movslq %ebx,%r12
callq  45c2 <rl_get_keymap_by_name+0x32>
test   %eax,%eax
jne    45a0 <rl_get_keymap_by_name+0x10>
pop    %rbx
shl    $0x4,%r12
pop    %rbp
mov    0x0(%r12),%rax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_get_keymap_by_name (name)
     const char *name;
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (strcasecmp (name, keymap_names[i].name) == 0)
      return (keymap_names[i].map);
  return ((Keymap) ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 9
20 7
21 9
22 7
23 9
24 9
25 9
26 9
27 9
28 8
29 9
30 9
31 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1d6 <tty_issofttab+0x6>
and    $0x1800,%eax
cmp    $0x1800,%eax
sete   %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_issofttab (void)
{
  return (termbuf.c_oflag & 0014000) == 0014000;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
jmpq   25 <rec_record_comment_dup_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_comment_dup_fn (void *data)
{
  rec_comment_t copy;
  copy = rec_comment_dup ((rec_comment_t) data);
  return (void *) copy;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     de0 <via_get_comment+0x10>
mov    0x20(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_get_comment (osip_via_t * via)
{
  if (via == ((void *)0))
    return ((void *)0);
  return via->comment;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0xc,%esi
jmpq   d <gcm_camellia256_set_nonce_wrapper+0xd>
<<<sep_in_sample>>>
gcm_camellia256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)
{
  nettle_gcm_camellia256_set_iv (ctx, (16 - 4), nonce);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x5,%edi
ja     60 <custom_log_handler+0x60>
mov    %edi,%eax
jmpq   *0x0(,%rax,8)
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
jmpq   1c <custom_log_handler+0x1c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   2c <custom_log_handler+0x2c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   3c <custom_log_handler+0x3c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   4c <custom_log_handler+0x4c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   5c <custom_log_handler+0x5c>
nopl   0x0(%rax)
mov    %rsi,%rdx
xor    %eax,%eax
mov    %edi,%esi
mov    $0x0,%edi
jmpq   71 <custom_log_handler+0x71>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
custom_log_handler (cdio_log_level_t level, const char *message)
{
  switch(level) {
  case CDIO_LOG_DEBUG:
    printf("-- custom debug message: %s\n", message);
    return;
  case CDIO_LOG_INFO:
    printf("-- custom info message: %s\n", message);
    return;
  case CDIO_LOG_WARN:
    printf("-- custom warning message: %s\n", message);
    return;
  case CDIO_LOG_ERROR:
    printf("-- custom error message: %s\n", message);
    return;
  case CDIO_LOG_ASSERT:
    printf("-- custom assertion message: %s\n", message);
    return;
  default:
    printf("custom level %d message: %s\n", level, message);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 17
7 17
8 17
9 17
10 5
11 5
12 5
13 5
14 8
15 8
16 8
17 8
18 11
19 11
20 11
21 11
22 14
23 14
24 14
25 14
26 20
27 20
28 20
29 20
30 20
31 20
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (unsigned long) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              if (*chain == p)
                {
                  char *p_begin = (char *) p - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max);
                  *chain = ((struct header *) p_begin)->next;
                  free (p_begin);
                  return;
                }
              chain = &((struct header *) ((char *) *chain - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)))->next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 9
30 18
31 14
32 13
33 14
34 15
35 8
36 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  8b9 <rename_file+0x9>
test   %rbx,%rbx
je     8d0 <rename_file+0x20>
xchg   %ax,%ax
mov    0x8(%rbx),%rax
mov    %rax,(%rbx)
mov    0x38(%rbx),%rbx
test   %rbx,%rbx
jne    8c0 <rename_file+0x10>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rename_file (struct file *from_file, const char *to_hname)
{
  rehash_file (from_file, to_hname);
  while (from_file)
    {
      from_file->name = from_file->hname;
      from_file = from_file->prev;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 6
9 7
10 4
11 4
12 9
13 9
14 9
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1cd6 <psset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psset_debug (int bdebug )
{
        ps_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
addsd  %xmm0,%xmm0
movapd %xmm1,%xmm4
movsd  0x0(%rip),%xmm2        # f0 <gsl_sf_bessel_asymp_thetanu_corr_e+0x10>
xor    %eax,%eax
mulsd  %xmm1,%xmm4
movsd  0x0(%rip),%xmm3        # fe <gsl_sf_bessel_asymp_thetanu_corr_e+0x1e>
divsd  %xmm1,%xmm0
divsd  %xmm4,%xmm2
divsd  %xmm4,%xmm3
mulsd  %xmm0,%xmm0
movapd %xmm0,%xmm5
subsd  %xmm3,%xmm0
subsd  %xmm2,%xmm5
movapd %xmm5,%xmm2
mulsd  %xmm1,%xmm2
movsd  0x0(%rip),%xmm1        # 12a <gsl_sf_bessel_asymp_thetanu_corr_e+0x4a>
mulsd  %xmm2,%xmm0
mulsd  %xmm2,%xmm1
divsd  0x0(%rip),%xmm0        # 13a <gsl_sf_bessel_asymp_thetanu_corr_e+0x5a>
subsd  0x0(%rip),%xmm1        # 142 <gsl_sf_bessel_asymp_thetanu_corr_e+0x62>
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rdi)
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_asymp_thetanu_corr_e(const double nu, const double x, double * result)
{
  const double r = 2.0*nu/x;
  const double r2 = r*r;
  const double x2 = x*x;
  const double term1 = x*(r2 - 1.0/x2)/8.0;
  const double term2 = x*(r2 - 1.0/x2)*(r2 - 25.0/x2)/384.0;
  *result = (-0.25*3.14159265358979323846 + term1 + term2);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 10
5 5
6 7
7 3
8 6
9 7
10 4
11 6
12 7
13 6
14 6
15 6
16 6
17 7
18 6
19 7
20 8
21 8
22 8
23 10
<<<sep_out_sample>>>
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_tray_os2 (const char *psz_os2_drive)
{
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1cc6 <psget_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psget_debug (void)
{
        return ps_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rcx),%rax
mov    %rdx,%r8
lea    (%rax,%rax,2),%rdx
mov    0x160(%rdi),%rax
mov    %r8,%rdi
lea    (%rax,%rdx,8),%rax
mov    0x10(%rax),%rcx
mov    0x8(%rax),%rdx
jmpq   470 <xheader_print_n>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattr_coder (struct tar_stat_info const *st, char const *keyword,
             struct xheader *xhdr, void const *data)
{
  struct xattr_array *xattr_map = st->xattr_map;
  const size_t *off = data;
  xheader_print_n (xhdr, keyword,
                   xattr_map[*off].xval_ptr, xattr_map[*off].xval_len);
}
<<<sep_in_sample>>>
1 7
2 3
3 7
4 7
5 6
6 7
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    0x0(%rip),%rbx        # d <getuser+0xd>
test   %rbx,%rbx
jne    21 <getuser+0x21>
jmp    40 <getuser+0x40>
nopl   0x0(%rax)
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     40 <getuser+0x40>
cmp    %ebp,(%rbx)
jne    18 <getuser+0x18>
xor    %eax,%eax
cmpb   $0x0,0x10(%rbx)
lea    0x10(%rbx),%rdx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    %ebp,%edi
mov    $0x0,%r12d
callq  4d <getuser+0x4d>
test   %rax,%rax
mov    $0x11,%edi
je     66 <getuser+0x66>
mov    (%rax),%r12
mov    %r12,%rdi
callq  62 <getuser+0x62>
lea    0x11(%rax),%rdi
callq  6b <getuser+0x6b>
lea    0x10(%rax),%rdi
mov    %ebp,(%rax)
mov    %r12,%rsi
mov    %rax,%rbx
callq  7c <getuser+0x7c>
mov    0x0(%rip),%rax        # 83 <getuser+0x83>
mov    %rbx,0x0(%rip)        # 8a <getuser+0x8a>
mov    %rax,0x8(%rbx)
jmp    25 <getuser+0x25>
<<<sep_in_sample>>>
getuser (uid_t uid)
{
  struct userid *tail;
  struct userid *match = ((void *)0);
  for (tail = user_alist; tail; tail = tail->next)
    {
      if (tail->id.u == uid)
        {
          match = tail;
          break;
        }
    }
  if (match == ((void *)0))
    {
      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : "";
      match = xmalloc (__builtin_offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
      match->next = user_alist;
      user_alist = match;
    }
  return match->name[0] ? match->name : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 23
16 23
17 23
18 24
19 24
20 24
21 23
22 24
23 24
24 15
25 16
26 15
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 17
35 19
36 18
37 19
38 17
39 19
40 20
41 21
42 20
43 20
<<<sep_out_sample>>>
xorpd  %xmm3,%xmm3
movapd %xmm0,%xmm4
ucomisd %xmm3,%xmm0
jp     38 <gsl_poly_solve_quadratic+0x38>
jne    38 <gsl_poly_solve_quadratic+0x38>
ucomisd %xmm3,%xmm1
jnp    d0 <gsl_poly_solve_quadratic+0xd0>
movsd  0x0(%rip),%xmm0        # 22 <gsl_poly_solve_quadratic+0x22>
mov    $0x1,%eax
xorpd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,(%rdi)
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm0        # 40 <gsl_poly_solve_quadratic+0x40>
movapd %xmm1,%xmm5
mulsd  %xmm4,%xmm0
mulsd  %xmm1,%xmm5
mulsd  %xmm2,%xmm0
subsd  %xmm0,%xmm5
ucomisd %xmm3,%xmm5
jbe    110 <gsl_poly_solve_quadratic+0x110>
sub    $0x48,%rsp
ucomisd %xmm3,%xmm1
jnp    e0 <gsl_poly_solve_quadratic+0xe0>
cmpltsd %xmm1,%xmm3
movsd  0x0(%rip),%xmm0        # 75 <gsl_poly_solve_quadratic+0x75>
movsd  0x0(%rip),%xmm6        # 7d <gsl_poly_solve_quadratic+0x7d>
andpd  %xmm3,%xmm0
andnpd %xmm6,%xmm3
orpd   %xmm0,%xmm3
sqrtsd %xmm5,%xmm0
ucomisd %xmm0,%xmm0
jp     16e <gsl_poly_solve_quadratic+0x16e>
mulsd  %xmm0,%xmm3
addsd  %xmm1,%xmm3
mulsd  0x0(%rip),%xmm3        # a7 <gsl_poly_solve_quadratic+0xa7>
movapd %xmm3,%xmm0
divsd  %xmm3,%xmm2
divsd  %xmm4,%xmm0
ucomisd %xmm0,%xmm2
jbe    130 <gsl_poly_solve_quadratic+0x130>
movsd  %xmm0,(%rdi)
mov    $0x2,%eax
movsd  %xmm2,(%rsi)
add    $0x48,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%eax
jne    1a <gsl_poly_solve_quadratic+0x1a>
repz retq 
nopl   (%rax)
jne    68 <gsl_poly_solve_quadratic+0x68>
movsd  0x0(%rip),%xmm3        # ea <gsl_poly_solve_quadratic+0xea>
xorpd  %xmm3,%xmm2
divsd  %xmm4,%xmm2
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     143 <gsl_poly_solve_quadratic+0x143>
xorpd  %xmm0,%xmm3
mov    $0x2,%eax
movsd  %xmm3,(%rdi)
movsd  %xmm0,(%rsi)
jmp    c6 <gsl_poly_solve_quadratic+0xc6>
nop
jp     140 <gsl_poly_solve_quadratic+0x140>
jne    140 <gsl_poly_solve_quadratic+0x140>
mulsd  0x0(%rip),%xmm1        # 11c <gsl_poly_solve_quadratic+0x11c>
mov    $0x2,%eax
divsd  %xmm4,%xmm1
movsd  %xmm1,(%rdi)
movsd  %xmm1,(%rsi)
retq   
xchg   %ax,%ax
movsd  %xmm2,(%rdi)
mov    $0x2,%eax
movsd  %xmm0,(%rsi)
jmp    c6 <gsl_poly_solve_quadratic+0xc6>
nop
xor    %eax,%eax
retq   
movapd %xmm2,%xmm0
mov    %rsi,0x20(%rsp)
movapd %xmm3,0x10(%rsp)
mov    %rdi,0x8(%rsp)
callq  15c <gsl_poly_solve_quadratic+0x15c>
movapd 0x10(%rsp),%xmm3
mov    0x20(%rsp),%rsi
mov    0x8(%rsp),%rdi
jmp    fc <gsl_poly_solve_quadratic+0xfc>
movapd %xmm5,%xmm0
mov    %rsi,0x38(%rsp)
mov    %rdi,0x30(%rsp)
movsd  %xmm2,0x28(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm4,0x20(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  199 <gsl_poly_solve_quadratic+0x199>
mov    0x38(%rsp),%rsi
mov    0x30(%rsp),%rdi
movsd  0x28(%rsp),%xmm2
movsd  0x10(%rsp),%xmm1
movsd  0x20(%rsp),%xmm4
movsd  0x8(%rsp),%xmm3
jmpq   97 <gsl_poly_solve_quadratic+0x97>
<<<sep_in_sample>>>
gsl_poly_solve_quadratic (double a, double b, double c,
                          double *x0, double *x1)
{
  if (a == 0)
    {
      if (b == 0)
        {
          return 0;
        }
      else
        {
          *x0 = -c / b;
          return 1;
        };
    }
  {
    double disc = b * b - 4 * a * c;
    if (disc > 0)
      {
        if (b == 0)
          {
            double r = sqrt (-c / a);
            *x0 = -r;
            *x1 = r;
          }
        else
          {
            double sgnb = (b > 0 ? 1 : -1);
            double temp = -0.5 * (b + sgnb * sqrt (disc));
            double r1 = temp / a ;
            double r2 = c / temp ;
            if (r1 < r2)
              {
                *x0 = r1 ;
                *x1 = r2 ;
              }
            else
              {
                *x0 = r2 ;
                  *x1 = r1 ;
              }
          }
        return 2;
      }
    else if (disc == 0)
      {
        *x0 = -0.5 * b / a ;
        *x1 = -0.5 * b / a ;
        return 2 ;
      }
    else
      {
        return 0;
      }
  }
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 6
7 6
8 12
9 13
10 12
11 12
12 12
13 13
14 13
15 17
16 17
17 17
18 17
19 17
20 17
21 18
22 18
23 3
24 20
25 20
26 28
27 28
28 28
29 28
30 28
31 28
32 29
33 29
34 29
35 29
36 29
37 29
38 30
39 31
40 30
41 32
42 32
43 34
44 43
45 35
46 56
47 56
48 56
49 8
50 6
51 56
52 56
53 20
54 22
55 22
56 22
57 22
58 22
59 22
60 23
61 43
62 23
63 24
64 24
65 24
66 45
67 45
68 47
69 49
70 47
71 47
72 48
73 49
74 49
75 39
76 43
77 40
78 40
79 40
80 8
81 8
82 22
83 22
84 22
85 22
86 22
87 22
88 22
89 22
90 22
91 29
92 29
93 29
94 29
95 29
96 29
97 29
98 29
99 29
100 29
101 29
102 29
103 29
104 29
105 29
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm1        # 10 <gsl_cdf_cauchy_P+0x10>
ucomisd %xmm1,%xmm0
jbe    30 <gsl_cdf_cauchy_P+0x30>
callq  1b <gsl_cdf_cauchy_P+0x1b>
divsd  0x0(%rip),%xmm0        # 23 <gsl_cdf_cauchy_P+0x23>
addsd  0x0(%rip),%xmm0        # 2b <gsl_cdf_cauchy_P+0x2b>
add    $0x8,%rsp
retq   
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  3d <gsl_cdf_cauchy_P+0x3d>
divsd  0x0(%rip),%xmm0        # 45 <gsl_cdf_cauchy_P+0x45>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_cauchy_P (const double x, const double a)
{
  double P;
  double u = x / a;
  if (u > -1)
    {
      P = 0.5 + atan (u) / 3.14159265358979323846;
    }
  else
    {
      P = atan(-1/u) / 3.14159265358979323846;
    }
  return P;
}
<<<sep_in_sample>>>
1 4
2 2
3 5
4 5
5 5
6 7
7 7
8 7
9 14
10 14
11 11
12 11
13 11
14 11
15 14
16 14
17 14
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
mov    0x28(%rsi),%r8
lea    (%r8,%rax,1),%r9
cmp    0x8(%rdi),%r9
ja     908 <da_prefix+0xa8>
mov    %eax,%edx
sub    $0x1,%edx
js     8c8 <da_prefix+0x68>
movslq %edx,%rcx
mov    %edx,%edx
lea    0x0(,%r8,8),%rsi
lea    0x0(,%rcx,8),%rax
sub    %rdx,%rcx
lea    -0x8(,%rcx,8),%rdi
nopl   0x0(%rax)
mov    0x30(%rbx),%rdx
mov    (%rdx,%rax,1),%rcx
add    %rax,%rdx
sub    $0x8,%rax
cmp    %rdi,%rax
mov    %rcx,(%rdx,%rsi,1)
jne    8b0 <da_prefix+0x50>
test   %r8d,%r8d
jle    8f9 <da_prefix+0x99>
lea    -0x1(%r8),%eax
lea    0x8(,%rax,8),%rsi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
mov    0x30(%rbp),%rdx
mov    (%rdx,%rax,1),%rcx
mov    0x30(%rbx),%rdx
mov    %rcx,(%rdx,%rax,1)
add    $0x8,%rax
cmp    %rsi,%rax
jne    8e0 <da_prefix+0x80>
mov    %r9,0x28(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
add    $0x1,%r9
mov    %r9,0x8(%rdi)
mov    0x30(%rdi),%rdi
lea    0x0(,%r9,8),%rsi
callq  921 <da_prefix+0xc1>
mov    0x28(%rbp),%r8
mov    %rax,0x30(%rbx)
mov    0x28(%rbx),%rax
lea    (%r8,%rax,1),%r9
jmpq   882 <da_prefix+0x22>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_prefix (struct darray * arr, struct darray * arr2)
{
  int i;
  size_t len = arr->len + arr2->len;
  if (len > arr->size) {
    arr->size = len + 1;
    arr->content = ((void * *) xrealloc ((void *) (arr->content), sizeof (void *) * (arr->size)));
  }
  for (i = (int) arr->len - 1 ; i >= 0 ; i--)
    arr->content [ i + arr2->len ] = arr->content [ i ];
  for (i = 0 ; i < (int) arr2->len ; i++)
    arr->content [ i ] = arr2->content[ i ];
  arr->len += arr2->len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 10
22 10
23 10
24 10
25 9
26 10
27 9
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 11
40 11
41 13
42 14
43 14
44 14
45 14
46 14
47 6
48 6
49 7
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x10,%esi
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e3 <_rl_vi_callback_char_search+0x13>
test   %eax,%eax
mov    %eax,0x0(%rip)        # eb <_rl_vi_callback_char_search+0x1b>
jle    128 <_rl_vi_callback_char_search+0x58>
mov    (%rbx),%edi
andq   $0xffffffffff7fffff,0x0(%rip)        # fa <_rl_vi_callback_char_search+0x2a>
mov    %eax,%ecx
pop    %rbx
mov    0x0(%rip),%esi        # 103 <_rl_vi_callback_char_search+0x33>
mov    $0x0,%edx
movq   $0x0,0x0(%rip)        # 113 <_rl_vi_callback_char_search+0x43>
movl   $0x1,0x0(%rip)        # 11d <_rl_vi_callback_char_search+0x4d>
jmpq   122 <_rl_vi_callback_char_search+0x52>
nopw   0x0(%rax,%rax,1)
mov    $0xffffffff,%eax
andq   $0xffffffffff7fffff,0x0(%rip)        # 138 <_rl_vi_callback_char_search+0x68>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_callback_char_search (data)
     _rl_callback_generic_arg *data;
{
  int c;
  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, 16);
  if (c <= 0)
    {
      (rl_readline_state &= ~(0x0800000));
      return -1;
    }
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  (rl_readline_state &= ~(0x0800000));
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 6
7 5
8 6
9 14
10 13
11 14
12 15
13 14
14 14
15 11
16 12
17 14
18 14
19 15
20 8
21 15
22 15
23 15
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigsegv_init (sigsegv_dispatcher *dispatcher)
{
  dispatcher->tree = ((node_t *) 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %r10d,%r10d
test   %edx,%edx
jle    80 <cblas_drot+0x80>
xor    %eax,%eax
test   %r8d,%r8d
jle    91 <cblas_drot+0x91>
test   %edi,%edi
jle    7d <cblas_drot+0x7d>
movsd  0x0(%rip),%xmm6        # 1e <cblas_drot+0x1e>
movslq %r10d,%r10
movslq %edx,%r9
cltq   
lea    (%rsi,%r10,8),%rdx
movslq %r8d,%rsi
xorpd  %xmm1,%xmm6
lea    (%rcx,%rax,8),%rax
shl    $0x3,%r9
shl    $0x3,%rsi
xor    %ecx,%ecx
nop
movsd  (%rdx),%xmm2
add    $0x1,%ecx
movsd  (%rax),%xmm4
movapd %xmm0,%xmm3
movapd %xmm1,%xmm5
mulsd  %xmm2,%xmm3
mulsd  %xmm4,%xmm5
mulsd  %xmm6,%xmm2
mulsd  %xmm0,%xmm4
addsd  %xmm5,%xmm3
addsd  %xmm4,%xmm2
movsd  %xmm3,(%rdx)
add    %r9,%rdx
movsd  %xmm2,(%rax)
add    %rsi,%rax
cmp    %edi,%ecx
jne    40 <cblas_drot+0x40>
repz retq 
nop
mov    $0x1,%r10b
xor    %eax,%eax
sub    %edi,%r10d
imul   %edx,%r10d
test   %r8d,%r8d
jg     12 <cblas_drot+0x12>
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   12 <cblas_drot+0x12>
<<<sep_in_sample>>>
cblas_drot (const int N, double *X, const int incX, double *Y, const int incY,
            const double c, const double s)
{
{
  int i;
  int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
  int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
  for (i = 0; i < N; i++) {
    const double x = X[ix];
    const double y = Y[iy];
    X[ix] = c * x + s * y;
    Y[iy] = -s * x + c * y;
    ix += incX;
    iy += incY;
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 8
23 10
24 11
25 11
26 11
27 11
28 12
29 12
30 11
31 12
32 11
33 11
34 12
35 12
36 8
37 8
38 8
39 8
40 6
41 7
42 6
43 6
44 7
45 7
46 7
47 7
48 7
49 7
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
mov    0x0(%rip),%rsi        # 16 <print_function_name+0x16>
callq  1b <print_function_name+0x1b>
mov    0x74(%rbx),%ecx
test   %ecx,%ecx
js     3d <print_function_name+0x3d>
mov    0x0(%rip),%rcx        # 29 <print_function_name+0x29>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3d <print_function_name+0x3d>
mov    0x68(%rbx),%rdx
test   %rdx,%rdx
je     61 <print_function_name+0x61>
mov    0x48(%rbx),%rcx
mov    0x50(%rbx),%r8d
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 5a <print_function_name+0x5a>
xor    %eax,%eax
callq  61 <print_function_name+0x61>
mov    0x38(%rbx),%edx
test   %edx,%edx
jne    a8 <print_function_name+0xa8>
mov    0x78(%rbx),%edx
test   %edx,%edx
jne    88 <print_function_name+0x88>
mov    0x0(%rip),%eax        # 75 <print_function_name+0x75>
test   %eax,%eax
jne    7d <print_function_name+0x7d>
test   %ebp,%ebp
jne    c8 <print_function_name+0xc8>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rcx        # 8f <print_function_name+0x8f>
mov    $0x4,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a3 <print_function_name+0xa3>
jmp    6f <print_function_name+0x6f>
nopl   (%rax)
mov    0x0(%rip),%rdi        # af <print_function_name+0xaf>
add    $0x8,%rsp
sub    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
xor    %eax,%eax
jmpq   c4 <print_function_name+0xc4>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # cf <print_function_name+0xcf>
add    $0x8,%rsp
mov    $0x3a,%edi
pop    %rbx
pop    %rbp
jmpq   df <print_function_name+0xdf>
nop
<<<sep_in_sample>>>
print_function_name(Symbol *sym, int has_subtree)
{
     fprintf(outfile, "%s", sym->name);
     if (sym->arity >= 0)
   fprintf(outfile, "()");
     if (sym->decl)
   fprintf(outfile, " <%s at %s:%d>",
    sym->decl,
    sym->source,
    sym->def_line);
     if (sym->active) {
   fprintf(outfile, " (recursive: see %d)", sym->active-1);
   return;
     }
     if (sym->recursive)
   fprintf(outfile, " (R)");
     if (!print_as_tree && has_subtree)
   fprintf(outfile, ":");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 11
27 11
28 11
29 15
30 15
31 15
32 17
33 17
34 17
35 17
36 17
37 19
38 19
39 19
40 19
41 19
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 12
50 19
51 12
52 19
53 19
54 12
55 12
56 12
57 12
58 18
59 19
60 18
61 19
62 19
63 18
64 18
<<<sep_out_sample>>>
mov    %edi,%r9d
mov    $0x318,%r8d
mov    $0x264,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x70,%edi
jmpq   277c <pict_port+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
pict_port(int npages)
{
  pict_init('p', 0, 0, 612, 792, npages);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
mov    $0x66,%edx
mov    $0x0,%esi
callq  20 <sh_single_quote+0x20>
cmpb   $0x27,(%rbx)
je     78 <sh_single_quote+0x78>
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jmp    3a <sh_single_quote+0x3a>
xchg   %ax,%ax
add    $0x1,%rdx
add    $0x1,%rbx
je     68 <sh_single_quote+0x68>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     68 <sh_single_quote+0x68>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    30 <sh_single_quote+0x30>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    3a <sh_single_quote+0x3a>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
cmpb   $0x0,0x1(%rbx)
jne    25 <sh_single_quote+0x25>
movb   $0x5c,(%rax)
movb   $0x27,0x1(%rax)
movb   $0x0,0x2(%rax)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_single_quote (string)
     const char *string;
{
  register int c;
  char *result, *r;
  const char *s;
  result = (char *)sh_xmalloc((3 + (4 * strlen (string))), "shquote.c", 102);
  r = result;
  if (string[0] == '\'' && string[1] == 0)
    {
      *r++ = '\\';
      *r++ = '\'';
      *r++ = 0;
      return result;
    }
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 7
6 7
7 7
8 9
9 9
10 16
11 16
12 16
13 16
14 19
15 17
16 17
17 17
18 17
19 17
20 17
21 20
22 19
23 20
24 22
25 23
26 24
27 24
28 17
29 17
30 17
31 27
32 28
33 30
34 30
35 30
36 9
37 9
38 11
39 12
40 13
41 30
42 30
43 30
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     1d0 <mu_opool_set_bucket_size+0x10>
mov    %rsi,0x8(%rdi)
xor    %al,%al
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_opool_set_bucket_size (mu_opool_t opool, size_t size)
{
  if (!opool)
    return 22;
  opool->bucket_size = size;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 7
7 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2146 <afmget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmget_leng (void)
{
        return afmleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     900 <gsl_blas_drot+0x30>
mov    $0x13,%ecx
mov    $0x1ee,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8f5 <gsl_blas_drot+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  91a <gsl_blas_drot+0x4a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s)
{
  if (X->size == Y->size)
    {
      cblas_drot (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                  ((int)(Y->stride)), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 494, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 11
6 11
7 11
8 11
9 11
10 11
11 13
12 13
13 13
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 13
23 13
24 13
<<<sep_out_sample>>>
movq   $0x1,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbx_first (void *owner)
{
  struct mailbox_iterator *itr = owner;
  itr->idx = 1;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  22be <mu_scheme_autodetect_p+0xe>
test   %eax,%eax
jne    22c8 <mu_scheme_autodetect_p+0x18>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  22d0 <mu_scheme_autodetect_p+0x20>
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_scheme_autodetect_p (mu_url_t url)
{
  if (mu_url_is_scheme (url, "file"))
    {
      mu_url_expand_path (url);
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 9
8 9
9 9
10 5
11 5
12 6
13 9
14 9
15 9
<<<sep_out_sample>>>
mov    $0x10b06,%edx
jmpq   2a <Gcompile+0xa>
<<<sep_in_sample>>>
Gcompile (char const *pattern, size_t size)
{
  GEAcompile (pattern, size, ((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1db <endBlackBoxRecording+0xb>
callq  1e0 <endBlackBoxRecording+0x10>
movq   $0x0,0x0(%rip)        # 1eb <endBlackBoxRecording+0x1b>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
endBlackBoxRecording(void)
{
 fclose(bbout);
 bbout = (FILE *) ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %rdi,%rdi
mov    $0x0,%eax
mov    %rdi,0x8(%rsp)
je     35e <dev_gnu_name+0x3e>
mov    0x0(%rip),%rdi        # 33a <dev_gnu_name+0x1a>
test   %rdi,%rdi
je     390 <dev_gnu_name+0x70>
lea    0x8(%rsp),%rsi
mov    $0x8,%edx
callq  34e <dev_gnu_name+0x2e>
test   %rax,%rax
je     368 <dev_gnu_name+0x48>
mov    %rax,%rdi
callq  35b <dev_gnu_name+0x3b>
mov    (%rax),%rax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdx
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
movzbl %dl,%ecx
movzbl %dh,%edx
callq  384 <dev_gnu_name+0x64>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
xchg   %ax,%ax
mov    $0x8,%dil
callq  398 <dev_gnu_name+0x78>
mov    $0x0,%edi
mov    %rax,0x0(%rip)        # 3a4 <dev_gnu_name+0x84>
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    0x0(%rip),%rdi        # 3ce <dev_gnu_name+0xae>
jmpq   33f <dev_gnu_name+0x1f>
<<<sep_in_sample>>>
dev_gnu_name(long dev_num)
{
  struct hashtab_elem *he;
  static char devstr [20];
  if (dev_num == 0)
    return "__";
  if (dev_table == ((void *)0))
    {
      dev_table = hashtab_init (sizeof (long));
      setup_devices ("/dev");
      setup_devices ("/dev/pty");
      setup_devices ("/dev/ptym");
      setup_devices ("/dev/pts");
    }
  he = hashtab_find (dev_table, (void *) &dev_num, (unsigned int)sizeof (dev_num));
  if (he != ((void *)0))
    {
      struct dev_data *dd = hashtab_get_value (he);
      return dd->name;
    }
  sprintf (devstr, "[%d,%d]",
           (int) ((dev_num & 0xFF00) >> 8), (int) (dev_num & 0x00FF));
  return devstr;
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 2
5 5
6 7
7 7
8 7
9 15
10 15
11 15
12 16
13 16
14 18
15 18
16 19
17 24
18 24
19 24
20 21
21 21
22 21
23 21
24 21
25 22
26 21
27 23
28 24
29 24
30 24
31 9
32 9
33 10
34 9
35 10
36 11
37 11
38 12
39 12
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
push   %rbx
xor    %edx,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  2d0 <xdatabase_capability+0x10>
test   %eax,%eax
je     2e0 <xdatabase_capability+0x20>
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    $0x0,%esi
pop    %rbx
jmpq   2ee <xdatabase_capability+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
xdatabase_capability (ANUBIS_SMTP_REPLY reply)
{
  if (!smtp_reply_has_capa (reply, "XDATABASE", ((void *)0)))
    smtp_reply_add_line (reply, "XDATABASE");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 4
12 4
13 5
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
lea    0xf(%rsp),%rax
cmp    %rax,0x0(%rip)        # 11 <stackoverflow_handler+0x11>
ja     75 <stackoverflow_handler+0x75>
cmp    %rax,0x0(%rip)        # 1a <stackoverflow_handler+0x1a>
jb     75 <stackoverflow_handler+0x75>
mov    0x0(%rip),%eax        # 22 <stackoverflow_handler+0x22>
mov    %edi,%ebx
mov    $0x0,%edi
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 32 <stackoverflow_handler+0x32>
mov    0x0(%rip),%esi        # 38 <stackoverflow_handler+0x38>
xor    %eax,%eax
callq  3f <stackoverflow_handler+0x3f>
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x2,%edi
callq  50 <stackoverflow_handler+0x50>
test   %ebx,%ebx
mov    $0xffffffffffffffff,%rsi
jne    62 <stackoverflow_handler+0x62>
movslq 0x0(%rip),%rsi        # 62 <stackoverflow_handler+0x62>
add    $0x10,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
pop    %rbx
mov    $0x0,%edi
jmpq   75 <stackoverflow_handler+0x75>
callq  7a <stackoverflow_handler+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stackoverflow_handler (int emergency, stackoverflow_context_t scp)
{
  char dummy;
  volatile char *addr = &dummy;
  if (!(addr >= stack_lower_bound && addr <= stack_upper_bound))
    abort ();
  pass++;
  printf ("Stack overflow %d caught.\n", pass);
  sigprocmask (2, &mainsigset, ((void *)0));
  sigsegv_leave_handler (stackoverflow_handler_continuation,
                         (void *) (long) (emergency ? -1 : pass), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 11
24 12
25 10
26 10
27 12
28 10
29 10
30 6
31 6
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 195a <gsl_matrix_char_const_ptr+0xa>
test   %eax,%eax
je     1969 <gsl_matrix_char_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1980 <gsl_matrix_char_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    19a0 <gsl_matrix_char_const_ptr+0x50>
mov    %rsi,%rax
imul   0x10(%rdi),%rax
add    %rdx,%rax
add    0x18(%rdi),%rax
add    $0x8,%rsp
retq   
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1999 <gsl_matrix_char_const_ptr+0x49>
xor    %eax,%eax
jmp    1978 <gsl_matrix_char_const_ptr+0x28>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19b9 <gsl_matrix_char_const_ptr+0x69>
xor    %eax,%eax
jmp    1978 <gsl_matrix_char_const_ptr+0x28>
<<<sep_in_sample>>>
gsl_matrix_char_const_ptr(const gsl_matrix_char * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_char.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_char.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const char *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x68(%rdi)
mov    %rdi,%rbx
je     58f8 <showfuncdefinition+0x18>
pop    %rbx
jmpq   58f1 <showfuncdefinition+0x11>
nopl   0x0(%rax)
test   %esi,%esi
mov    (%rdi),%rcx
je     5930 <showfuncdefinition+0x50>
mov    0x0(%rip),%rax        # 5906 <showfuncdefinition+0x26>
lea    0x0(%rip),%rdi        # 590d <showfuncdefinition+0x2d>
lea    0x0(%rip),%rdx        # 5914 <showfuncdefinition+0x34>
mov    (%rax),%rsi
xor    %eax,%eax
callq  591e <showfuncdefinition+0x3e>
lea    0x38(%rbx),%rdi
pop    %rbx
jmpq   5928 <showfuncdefinition+0x48>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 5937 <showfuncdefinition+0x57>
lea    0x0(%rip),%rdi        # 593e <showfuncdefinition+0x5e>
lea    0x0(%rip),%rdx        # 5945 <showfuncdefinition+0x65>
mov    (%rax),%rsi
xor    %eax,%eax
callq  594f <showfuncdefinition+0x6f>
lea    0x8(%rbx),%rdi
pop    %rbx
jmpq   5959 <showfuncdefinition+0x79>
nopl   0x0(%rax)
<<<sep_in_sample>>>
showfuncdefinition(struct func *fun, int inverse)
{
  if (fun->table)
    showtable(fun, inverse);
  else {
    logprintf("%s%s%s", deftext,inverse?"~":"", fun->name);
    if (inverse)
      showfunction(&fun->inverse);
    else
      showfunction(&fun->forward);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 12
6 4
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 8
18 12
19 8
20 8
21 6
22 6
23 6
24 6
25 6
26 6
27 10
28 12
29 10
30 10
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x48(%rdi),%rdi
test   %rdi,%rdi
je     9a <ict_rcv_1xx+0x1a>
callq  9a <ict_rcv_1xx+0x1a>
mov    0x8(%rbp),%rdx
mov    %rbx,%rsi
mov    $0x4,%edi
mov    %rdx,0x48(%rbx)
callq  af <ict_rcv_1xx+0x2f>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    $0x2,%esi
pop    %rbx
pop    %rbp
jmpq   c2 <ict_rcv_1xx+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ict_rcv_1xx (osip_transaction_t * ict, osip_event_t * evt)
{
  if (ict->last_response != ((void *)0)) {
    osip_message_free (ict->last_response);
  }
  ict->last_response = evt->sip;
  __osip_message_callback (OSIP_ICT_STATUS_1XX_RECEIVED, ict, evt->sip);
  __osip_transaction_set_state (ict, ICT_PROCEEDING);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 6
11 7
12 7
13 6
14 7
15 9
16 8
17 8
18 9
19 9
20 8
21 8
<<<sep_out_sample>>>
test   %rsi,%rsi
je     eea <dbop_lastdat+0xa>
mov    0x18(%rdi),%eax
mov    %eax,(%rsi)
mov    0x10(%rdi),%rax
retq   
nop
<<<sep_in_sample>>>
dbop_lastdat(DBOP *dbop, int *size)
{
 if (size)
  *size = dbop->lastsize;
 return dbop->lastdat;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5c97 <re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # 5c9e <re_set_syntax+0xe>
retq   
nop
<<<sep_in_sample>>>
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
test   %rsi,%rsi
je     70 <gss_get_mic+0x70>
mov    (%rsi),%rdi
mov    %r8,0x8(%rsp)
mov    %edx,%r12d
mov    %rcx,%r13
callq  28 <gss_get_mic+0x28>
test   %rax,%rax
mov    0x8(%rsp),%r8
je     50 <gss_get_mic+0x50>
mov    0x70(%rax),%rax
add    $0x18,%rsp
mov    %rbx,%rsi
pop    %rbx
mov    %rbp,%rdi
mov    %r12d,%edx
mov    %r13,%rcx
pop    %rbp
pop    %r12
pop    %r13
jmpq   *%rax
xchg   %ax,%ax
test   %rbp,%rbp
je     90 <gss_get_mic+0x90>
movl   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    $0x10000,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
test   %rdi,%rdi
je     a0 <gss_get_mic+0xa0>
movl   $0x0,(%rdi)
mov    $0x80000,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x10000,%eax
jmp    80 <gss_get_mic+0x80>
nopw   0x0(%rax,%rax,1)
mov    $0x80000,%eax
jmp    80 <gss_get_mic+0x80>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_get_mic (OM_uint32 * minor_status,
      const gss_ctx_id_t context_handle,
      gss_qop_t qop_req,
      const gss_buffer_t message_buffer, gss_buffer_t message_token)
{
  _gss_mech_api_t mech;
  if (!context_handle)
    {
      if (minor_status)
 *minor_status = 0;
      return (8ul << 16);
    }
  mech = _gss_find_mech (context_handle->mech);
  if (mech == ((void *)0))
    {
      if (minor_status)
 *minor_status = 0;
      return (1ul << 16);
    }
  return mech->get_mic (minor_status, context_handle, qop_req,
   message_buffer, message_token);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 13
11 13
12 13
13 13
14 13
15 14
16 14
17 14
18 20
19 22
20 20
21 22
22 20
23 20
24 20
25 22
26 22
27 22
28 20
29 20
30 16
31 16
32 17
33 22
34 18
35 22
36 22
37 22
38 22
39 22
40 22
41 9
42 9
43 10
44 11
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 18
53 18
54 18
55 11
56 11
57 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 156 <tty_isediting+0x6>
and    $0x2,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_isediting (void)
{
  return termbuf.c_lflag & 0000002;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
xor    %edx,%edx
cmp    $0x1,%edi
mov    0x0(%rip),%eax        # fb <malloc_set_trace+0xb>
setg   %dl
mov    %edi,0x0(%rip)        # 104 <malloc_set_trace+0x14>
mov    %edx,0x0(%rip)        # 10a <malloc_set_trace+0x1a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
malloc_set_trace (n)
     int n;
{
  int old;
  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}
<<<sep_in_sample>>>
1 7
2 7
3 5
4 7
5 6
6 7
7 9
8 9
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 377 <dirwatcher_remove_wd+0x7>
test   %rax,%rax
je     39d <dirwatcher_remove_wd+0x2d>
sub    $0x58,%rsp
lea    0x10(%rsp),%rdx
mov    %edi,0x14(%rsp)
mov    %rsp,%rsi
mov    %rax,%rdi
mov    %rdx,0x8(%rsp)
callq  399 <dirwatcher_remove_wd+0x29>
add    $0x58,%rsp
repz retq 
nop
<<<sep_in_sample>>>
dirwatcher_remove_wd(int wd)
{
 struct dirwatcher dwkey;
 struct dwref dwref;
 if (!dwtab)
  return;
 dwkey.wd = wd;
 dwref.dw = &dwkey;
 hashtab_remove(dwtab, &dwref);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 2
5 8
6 7
7 9
8 9
9 8
10 9
11 10
12 10
13 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <string_compare_ci+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_compare_ci (void const *data1, void const *data2)
{
  char const *p1 = data1;
  char const *p2 = data2;
  return mbscasecmp (p1, p2) == 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
movsd  (%rax),%xmm0
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_histogram2d_xmin (const gsl_histogram2d * h)
{
  return h->xrange[0];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # dc6 <yyset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  1b08 <Exit+0x8>
mov    %ebx,%edi
callq  1b0f <Exit+0xf>
nop
<<<sep_in_sample>>>
Exit (int returnCode)
{
  SetForExit ();
  exit (returnCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5e07 <pch_write_line+0x7>
push   %rbx
mov    %rsi,%rcx
mov    $0x1,%esi
mov    (%rax,%rdi,8),%r8
mov    0x0(%rip),%rax        # 5e1b <pch_write_line+0x1b>
mov    (%rax,%rdi,8),%rdx
mov    %r8,%rdi
cmpb   $0xa,-0x1(%r8,%rdx,1)
sete   %bl
callq  5e30 <pch_write_line+0x30>
test   %rax,%rax
je     5e39 <pch_write_line+0x39>
mov    %ebx,%eax
pop    %rbx
retq   
callq  5e3e <pch_write_line+0x3e>
xchg   %ax,%ax
<<<sep_in_sample>>>
pch_write_line (lin line, FILE *file)
{
  _Bool after_newline = p_line[line][p_len[line] - 1] == '\n';
  if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))
    write_fatal ();
  return after_newline;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 4
5 3
6 3
7 3
8 4
9 3
10 3
11 4
12 4
13 4
14 7
15 7
16 7
17 5
18 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rdi
callq  1d <rkck_free+0xd>
mov    0x30(%rbx),%rdi
callq  26 <rkck_free+0x16>
mov    0x28(%rbx),%rdi
callq  2f <rkck_free+0x1f>
mov    0x20(%rbx),%rdi
callq  38 <rkck_free+0x28>
mov    0x18(%rbx),%rdi
callq  41 <rkck_free+0x31>
mov    0x10(%rbx),%rdi
callq  4a <rkck_free+0x3a>
mov    0x8(%rbx),%rdi
callq  53 <rkck_free+0x43>
mov    (%rbx),%rdi
callq  5b <rkck_free+0x4b>
mov    %rbx,%rdi
pop    %rbx
jmpq   64 <rkck_free+0x54>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rkck_free (void *vstate)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  free (state->ytmp);
  free (state->y0);
  free (state->k6);
  free (state->k5);
  free (state->k4);
  free (state->k3);
  free (state->k2);
  free (state->k1);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 13
21 12
22 12
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  79 <_memory_size+0x9>
test   %rbx,%rbx
je     85 <_memory_size+0x15>
mov    0x10(%rax),%rax
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_memory_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _memory_stream *mfs = mu_stream_get_owner (stream);
  if (psize)
    *psize = mfs->size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  e <palloc+0xe>
movq   $0x0,0x10(%rax)
movq   $0x0,0x8(%rax)
movl   $0x0,(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
palloc (void)
{
  struct prt *pp;
  pp = (struct prt *)xmalloc (sizeof(struct prt));
  pp->pr_sym = ((void *)0);
  pp->pr_link = ((void *)0);
  pp->pr_which = P_VALUE;
  return pp;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 9
8 9
9 9
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  12b <pair_table_new+0xb>
mov    $0x0,%r8d
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
callq  14b <pair_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
pair_table_new (void)
{
  struct pair_htable * res;
  res = ((struct pair_htable *) xmalloc (sizeof (struct pair_htable) * (1)));
  hash_init (res, 8,
      (hash_func_t) pair_hash_1,
      (hash_func_t) pair_hash_2,
      (hash_cmp_func_t) pair_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 5
8 5
9 5
10 5
11 10
12 10
13 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %esi,%esi
callq  11b <do_help+0xb>
<<<sep_in_sample>>>
do_help(const char *name)
{
  usage(name, 0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
add    $0x28,%rdi
jmpq   9 <nettle_ccm_aes128_set_key+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key)
{
  nettle_aes128_set_encrypt_key(&ctx->cipher, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    0x10(%rdi),%rdi
lea    0x1(%rax),%esi
mov    0x0(%rip),%rax        # 10 <__gmpf_clear+0x10>
movslq %esi,%rsi
shl    $0x3,%rsi
jmpq   *%rax
<<<sep_in_sample>>>
__gmpf_clear (mpf_ptr x)
{
  (*__gmp_free_func) (((x)->_mp_d), (((x)->_mp_prec) + 1) * sizeof (mp_limb_t));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,0x18(%rdi)
mov    0x20(%rdi),%rdi
callq  3c1 <rec_field_set_location+0x11>
mov    0x18(%rbx),%rdx
lea    0x20(%rbx),%rdi
xor    %eax,%eax
mov    $0x0,%esi
callq  3d5 <rec_field_set_location+0x25>
cmp    $0xffffffff,%eax
setne  %al
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rec_field_set_location (rec_field_t field,
                        size_t location)
{
  field->location = location;
  free (field->location_str);
  return (rpl_asprintf (&(field->location_str), "%zu", field->location)
          != -1);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
<<<sep_out_sample>>>
push   %rbp
lea    0x1040(%rdi),%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rbp,%rdi
sub    $0x8,%rsp
callq  18 <nettle_gcm_camellia256_set_key+0x18>
mov    0x0(%rip),%rdx        # 1f <nettle_gcm_camellia256_set_key+0x1f>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rsi
pop    %rbp
jmpq   30 <nettle_gcm_camellia256_set_iv>
<<<sep_in_sample>>>
nettle_gcm_camellia256_set_key(struct gcm_camellia256_ctx *ctx, const uint8_t *key)
{
  do { (nettle_camellia256_set_encrypt_key)(&(ctx)->cipher, (key)); if (0) (nettle_camellia256_crypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0); nettle_gcm_set_key(&(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_camellia256_crypt)); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 2
7 3
8 3
9 4
10 3
11 4
12 3
13 4
14 3
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  15 <mu_make_file_name+0x15>
test   %rax,%rax
je     8b <mu_make_file_name+0x8b>
cmpb   $0x2f,-0x1(%rbp,%rax,1)
lea    -0x1(%rax),%rbx
je     3e <mu_make_file_name+0x3e>
jmp    8f <mu_make_file_name+0x8f>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2f,-0x1(%rbp,%rbx,1)
lea    -0x1(%rbx),%rax
jne    43 <mu_make_file_name+0x43>
mov    %rax,%rbx
test   %rbx,%rbx
jne    30 <mu_make_file_name+0x30>
mov    %r13,%rdi
callq  4b <mu_make_file_name+0x4b>
lea    0x2(%rbx,%rax,1),%rdi
callq  55 <mu_make_file_name+0x55>
test   %rax,%rax
mov    %rax,%r12
je     7d <mu_make_file_name+0x7d>
mov    %rbp,%rsi
mov    %rax,%rdi
mov    %rbx,%rdx
callq  6b <mu_make_file_name+0x6b>
lea    0x1(%r12,%rbx,1),%rdi
movb   $0x2f,(%r12,%rbx,1)
mov    %r13,%rsi
callq  7d <mu_make_file_name+0x7d>
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %ebx,%ebx
jmp    43 <mu_make_file_name+0x43>
mov    %rax,%rbx
jmp    43 <mu_make_file_name+0x43>
<<<sep_in_sample>>>
mu_make_file_name (const char *dir, const char *file)
{
  char *tmp;
  size_t dirlen = strlen (dir);
  size_t len;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  len = dirlen + 1 + strlen (file);
  tmp = mu_alloc (len + 1);
  if (tmp)
    {
      memcpy (tmp, dir, dirlen);
      tmp[dirlen++] = '/';
      strcpy (tmp + dirlen, file);
    }
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 8
23 8
24 9
25 9
26 10
27 9
28 10
29 12
30 12
31 12
32 12
33 14
34 13
35 14
36 14
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 6
45 6
46 6
47 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r12
mov    0x18(%rdi),%rbx
mov    0x8(%rdi),%rbp
mov    0x10(%rdi),%r13
test   %r12,%r12
movzwl (%rbx),%edi
je     3a7b <gsl_matrix_ushort_max_index+0x7b>
add    %r13,%r13
xor    %r11d,%r11d
xor    %r9d,%r9d
xor    %r10d,%r10d
nopl   0x0(%rax)
test   %rbp,%rbp
je     3a62 <gsl_matrix_ushort_max_index+0x62>
mov    %edi,%r8d
xor    %eax,%eax
jmp    3a43 <gsl_matrix_ushort_max_index+0x43>
nopl   0x0(%rax)
mov    %edi,%r8d
movzwl (%rbx,%rax,2),%ecx
cmp    %di,%cx
cmovae %ecx,%edi
cmp    %r8w,%cx
cmova  %r11,%r10
cmova  %rax,%r9
add    $0x1,%rax
cmp    %rbp,%rax
jne    3a40 <gsl_matrix_ushort_max_index+0x40>
add    $0x1,%r11
add    %r13,%rbx
cmp    %r12,%r11
jne    3a30 <gsl_matrix_ushort_max_index+0x30>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r10,(%rsi)
mov    %r9,(%rdx)
pop    %r13
retq   
pop    %rbx
pop    %rbp
xor    %r9d,%r9d
xor    %r10d,%r10d
pop    %r12
mov    %r10,(%rsi)
mov    %r9,(%rdx)
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_matrix_ushort_max_index (const gsl_matrix_ushort * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned short max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned short x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 6
7 4
8 5
9 9
10 6
11 9
12 9
13 9
14 7
15 7
16 7
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 13
27 13
28 13
29 13
30 11
31 11
32 11
33 9
34 9
35 9
36 9
37 24
38 24
39 24
40 22
41 23
42 24
43 24
44 24
45 24
46 7
47 7
48 24
49 22
50 23
51 24
52 24
53 24
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   $0x2,%sil
je     1dd9 <do_redirections+0x59>
mov    0x0(%rip),%rdi        # 1d98 <do_redirections+0x18>
test   %rdi,%rdi
je     1dad <do_redirections+0x2d>
callq  1da2 <do_redirections+0x22>
movq   $0x0,0x0(%rip)        # 1dad <do_redirections+0x2d>
cmpq   $0x0,0x0(%rip)        # 1db5 <do_redirections+0x35>
je     1dd9 <do_redirections+0x59>
callq  1dbc <do_redirections+0x3c>
test   %rbx,%rbx
je     1dde <do_redirections+0x5e>
nopl   0x0(%rax)
mov    %ebp,%esi
mov    %rbx,%rdi
callq  350 <do_redirection_internal>
test   %eax,%eax
jne    1df0 <do_redirections+0x70>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    1dc8 <do_redirections+0x48>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%esi
mov    %rbx,%rdi
mov    %eax,0xc(%rsp)
callq  1dfe <do_redirections+0x7e>
mov    0xc(%rsp),%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
do_redirections (list, flags)
     REDIRECT *list;
     int flags;
{
  int error;
  REDIRECT *temp;
  if (flags & 0x02)
    {
      if (redirection_undo_list)
 {
   dispose_redirects (redirection_undo_list);
   redirection_undo_list = (REDIRECT *)((void *)0);
 }
      if (exec_redirection_undo_list)
 dispose_exec_redirects ();
    }
  for (temp = list; temp; temp = temp->next)
    {
      error = do_redirection_internal (temp, flags);
      if (error)
 {
   redirection_error (temp, error);
   return (error);
 }
    }
  return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 7
7 7
8 9
9 9
10 9
11 11
12 12
13 14
14 14
15 15
16 17
17 17
18 17
19 19
20 19
21 19
22 20
23 20
24 17
25 17
26 17
27 27
28 26
29 27
30 27
31 27
32 27
33 22
34 22
35 22
36 22
37 19
38 27
39 27
40 27
41 27
42 27
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
je     7f0 <debug_set_output+0x80>
cmpb   $0x0,(%rdi)
je     7c0 <debug_set_output+0x50>
mov    $0x0,%esi
callq  785 <debug_set_output+0x15>
mov    %rax,%rbx
xor    %eax,%eax
test   %rbx,%rbx
je     7b4 <debug_set_output+0x44>
mov    %rbx,%rdi
callq  797 <debug_set_output+0x27>
mov    $0x1,%esi
mov    %eax,%edi
callq  7a3 <debug_set_output+0x33>
test   %eax,%eax
jne    7d0 <debug_set_output+0x60>
mov    %rbx,%rdi
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %edi,%edi
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
xchg   %ax,%ax
callq  7d5 <debug_set_output+0x65>
mov    0x0(%rip),%edi        # 7db <debug_set_output+0x6b>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
callq  7e9 <debug_set_output+0x79>
jmp    7a7 <debug_set_output+0x37>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 7f7 <debug_set_output+0x87>
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
debug_set_output (const char *name)
{
  FILE *fp;
  if (name == ((void *)0))
    debug_set_file (stderr);
  else if (*name == '\0')
    debug_set_file (((void *)0));
  else
    {
      fp = fopen_safer (name, "a");
      if (fp == ((void *)0))
        return 0;
      if (set_cloexec_flag (fileno (fp), 1) != 0)
        (m4_error (warning_status, (*__errno_location ()), "Warning: cannot protect debug file across forks"))
                                                                     ;
      debug_set_file (fp);
    }
  return 1;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 6
5 6
6 10
7 10
8 10
9 12
10 11
11 11
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 18
22 19
23 19
24 19
25 7
26 7
27 18
28 19
29 19
30 19
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 5
40 5
41 18
42 19
43 19
44 19
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%r12
test   %r12,%r12
je     646 <copyargs+0xb6>
mov    %r12,%rdi
mov    %rbx,%rbp
xor    %r13d,%r13d
nopw   0x0(%rax,%rax,1)
add    $0x8,%rbp
callq  5c1 <copyargs+0x31>
mov    0x0(%rbp),%rdi
lea    0x1(%r13,%rax,1),%r13d
test   %rdi,%rdi
jne    5b8 <copyargs+0x28>
mov    %r13d,%edi
callq  5d7 <copyargs+0x47>
test   %rax,%rax
mov    %rax,%rbp
je     64a <copyargs+0xba>
test   %r12,%r12
mov    %rbp,%rcx
je     638 <copyargs+0xa8>
nopw   0x0(%rax,%rax,1)
mov    %rcx,%rdi
mov    %r12,%rsi
callq  5fb <copyargs+0x6b>
mov    (%rbx),%rsi
mov    %rax,%rdi
callq  606 <copyargs+0x76>
cmpb   $0x0,(%rax)
je     619 <copyargs+0x89>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
cmpb   $0x0,(%rax)
jne    610 <copyargs+0x80>
cmpq   $0x0,0x8(%rbx)
je     638 <copyargs+0xa8>
movb   $0x20,(%rax)
mov    0x8(%rbx),%r12
add    $0x8,%rbx
lea    0x1(%rax),%rcx
test   %r12,%r12
jne    5f0 <copyargs+0x60>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %edi,%edi
jmp    5d2 <copyargs+0x42>
callq  64f <copyargs+0xbf>
mov    (%rax),%esi
mov    $0x0,%edx
mov    $0x1,%edi
xor    %eax,%eax
callq  662 <copyargs+0xd2>
mov    (%rbx),%r12
jmpq   5df <copyargs+0x4f>
<<<sep_in_sample>>>
copyargs (char **argv)
{
  int cc;
  char **ap, *args, *p;
  cc = 0;
  for (ap = argv; *ap; ++ap)
    cc += strlen (*ap) + 1;
  args = malloc ((u_int) cc);
  if (!args)
    error (1, (*__errno_location ()), "copyargs");
  for (p = args, ap = argv; *ap; ++ap)
    {
      strcpy (p, *ap);
      for (p = strcpy (p, *ap); *p; ++p);
      if (ap[1])
 *p++ = ' ';
    }
  return args;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 5
13 5
14 6
15 7
16 6
17 7
18 6
19 6
20 6
21 8
22 9
23 8
24 9
25 11
26 8
27 11
28 11
29 13
30 13
31 13
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 15
42 15
43 16
44 16
45 11
46 16
47 11
48 11
49 11
50 19
51 19
52 19
53 19
54 19
55 19
56 19
57 6
58 6
59 10
60 10
61 10
62 10
63 10
64 10
65 10
66 10
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     17db <gsl_matrix_long_double_set_identity+0x6b>
fld1   
shl    $0x4,%r9
mov    %rax,%rdi
xor    %ecx,%ecx
fldz   
nopl   0x0(%rax)
test   %rsi,%rsi
je     17cb <gsl_matrix_long_double_set_identity+0x5b>
fld    %st(1)
mov    %rdi,%rdx
xor    %eax,%eax
fld    %st(1)
nopw   %cs:0x0(%rax,%rax,1)
fld    %st(0)
cmp    %rax,%rcx
fcmove %st(2),%st
add    $0x1,%rax
add    $0x10,%rdx
fstpt  -0x10(%rdx)
cmp    %rsi,%rax
jne    17b0 <gsl_matrix_long_double_set_identity+0x40>
fstp   %st(0)
fstp   %st(0)
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    1798 <gsl_matrix_long_double_set_identity+0x28>
fstp   %st(0)
fstp   %st(0)
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_long_double_set_identity (gsl_matrix_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const long double zero = 0.0L;
  const long double one = 1.0L;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(long double *) (data + 1 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 14
26 12
27 12
28 12
29 12
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_float_size (const gsl_block_float * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     1418 <extract_colon_unit+0xd8>
mov    %rsi,%rbp
callq  135a <extract_colon_unit+0x1a>
mov    0x0(%rbp),%esi
cmp    %eax,%esi
jge    1418 <extract_colon_unit+0xd8>
test   %esi,%esi
jne    13b8 <extract_colon_unit+0x78>
movzbl (%rbx),%eax
mov    %rbx,%r8
test   %al,%al
je     13d8 <extract_colon_unit+0x98>
cmp    $0x3a,%al
je     13d8 <extract_colon_unit+0x98>
movslq %esi,%rax
mov    %esi,%edx
lea    0x1(%rbx,%rax,1),%rax
jmp    138c <extract_colon_unit+0x4c>
nopl   0x0(%rax,%rax,1)
test   %cl,%cl
je     139e <extract_colon_unit+0x5e>
movzbl (%rax),%ecx
add    $0x1,%edx
mov    %rax,%r8
add    $0x1,%rax
cmp    $0x3a,%cl
jne    1388 <extract_colon_unit+0x48>
cmp    %edx,%esi
mov    %edx,0x0(%rbp)
je     13e0 <extract_colon_unit+0xa0>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   13b3 <extract_colon_unit+0x73>
nopl   0x0(%rax,%rax,1)
movslq %esi,%r8
add    %rbx,%r8
movzbl (%r8),%eax
cmp    $0x3a,%al
jne    136f <extract_colon_unit+0x2f>
add    $0x1,%esi
movslq %esi,%r8
add    %rbx,%r8
movzbl (%r8),%eax
jmp    136f <extract_colon_unit+0x2f>
nopl   (%rax)
mov    %esi,0x0(%rbp)
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,(%r8)
jne    1408 <extract_colon_unit+0xc8>
mov    $0x39d,%edx
mov    $0x0,%esi
mov    $0x1,%edi
callq  13fa <extract_colon_unit+0xba>
movb   $0x0,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
lea    0x1(%rsi),%r9d
mov    %r9d,0x0(%rbp)
jmp    13e6 <extract_colon_unit+0xa6>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extract_colon_unit (string, p_index)
     char *string;
     int *p_index;
{
  int i, start, len;
  char *value;
  if (string == 0)
    return (string);
  len = strlen (string);
  if (*p_index >= len)
    return ((char *)((void *)0));
  i = *p_index;
  if (i && string[i] == ':')
    i++;
  for (start = i; string[i] && string[i] != ':'; i++)
    ;
  *p_index = i;
  if (i == start)
    {
      if (string[i])
 (*p_index)++;
      value = (char *)sh_xmalloc((1), "general.c", 925);
      value[0] = '\0';
    }
  else
    value = substring (string, start, i);
  return (value);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 7
6 7
7 7
8 9
9 10
10 10
11 10
12 13
13 13
14 13
15 13
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 18
34 17
35 18
36 28
37 26
38 28
39 28
40 26
41 26
42 13
43 13
44 13
45 13
46 13
47 14
48 14
49 14
50 14
51 14
52 14
53 17
54 17
55 20
56 20
57 22
58 22
59 22
60 22
61 23
62 28
63 28
64 28
65 28
66 28
67 21
68 21
69 21
70 21
71 28
72 28
73 28
74 28
75 28
76 28
<<<sep_out_sample>>>
movsd  %xmm0,-0x18(%rsp)
test   %r8,%r8
fldl   -0x18(%rsp)
movsd  %xmm1,-0x18(%rsp)
fldl   -0x18(%rsp)
je     17a <gsl_stats_long_double_wkurtosis_m_sd+0x8a>
fldz   
shl    $0x4,%rsi
shl    $0x4,%rcx
xor    %eax,%eax
fld    %st(0)
fld    %st(1)
nopl   0x0(%rax)
fldt   (%rdi)
fucomi %st(3),%st
jbe    150 <gsl_stats_long_double_wkurtosis_m_sd+0x60>
fldt   (%rdx)
fsub   %st(6),%st
fdiv   %st(5),%st
fxch   %st(3)
fadd   %st(1),%st
fld    %st(3)
fmul   %st(4),%st
fmul   %st(4),%st
fmulp  %st,%st(4)
fxch   %st(3)
fsub   %st(2),%st
fxch   %st(1)
fdiv   %st(3),%st
fmulp  %st,%st(1)
faddp  %st,%st(1)
jmp    152 <gsl_stats_long_double_wkurtosis_m_sd+0x62>
nopw   %cs:0x0(%rax,%rax,1)
fstp   %st(0)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    120 <gsl_stats_long_double_wkurtosis_m_sd+0x30>
fstp   %st(3)
fstp   %st(0)
fstp   %st(0)
fstp   %st(1)
fsubs  0x0(%rip)        # 16f <gsl_stats_long_double_wkurtosis_m_sd+0x7f>
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
fstp   %st(0)
fstp   %st(0)
movsd  0x0(%rip),%xmm0        # 186 <gsl_stats_long_double_wkurtosis_m_sd+0x96>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_wkurtosis_m_sd (const long double w[], const size_t wstride,
                                    const long double data[],
                                    const size_t stride,
                                    const size_t n,
                                    const double wmean,
                                    const double wsd)
{
  long double wavg = 0, kurtosis;
  long double W = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      long double wi = w[i * wstride];
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wavg += (x * x * x * x - wavg) * (wi / W);
      }
    }
  kurtosis = wavg - 3.0;
  return kurtosis;
}
<<<sep_in_sample>>>
1 7
2 11
3 7
4 7
5 7
6 11
7 9
8 9
9 15
10 11
11 9
12 8
13 8
14 13
15 14
16 14
17 15
18 15
19 15
20 15
21 16
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 17
35 11
36 11
37 11
38 11
39 11
40 11
41 11
42 11
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 22
52 22
<<<sep_out_sample>>>
push   %rbp
mov    $0x1005,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     2a3 <mu_debug_create+0x43>
mov    %rsi,%rbp
mov    $0x48,%edi
mov    $0x1,%esi
callq  285 <mu_debug_create+0x25>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     2a3 <mu_debug_create+0x43>
movq   $0x0,0x38(%rdx)
mov    %rbp,0x10(%rdx)
xor    %al,%al
mov    %rdx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_debug_create (mu_debug_t *pdebug, void *owner)
{
  mu_debug_t debug;
  if (pdebug == ((void *)0))
    return (0x1000 +5);
  debug = calloc (sizeof (*debug), 1);
  if (debug == ((void *)0))
    return 12;
  debug->printer = ((void *)0);
  debug->owner = owner;
  *pdebug = debug;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 8
14 7
15 7
16 9
17 10
18 12
19 11
20 13
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
movsd  0x0(%rip),%xmm3        # 3c <gsl_cdf_flat_Q+0xc>
ja     58 <gsl_cdf_flat_Q+0x28>
ucomisd %xmm2,%xmm0
xorpd  %xmm3,%xmm3
ja     58 <gsl_cdf_flat_Q+0x28>
movapd %xmm2,%xmm3
subsd  %xmm1,%xmm2
subsd  %xmm0,%xmm3
divsd  %xmm2,%xmm3
movapd %xmm3,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_flat_Q (const double x, const double a, const double b)
{
  double Q;
  if (x < a)
    {
      Q = 1;
    }
  else if (x > b)
    {
      Q = 0;
    }
  else
    {
      Q = (b-x)/(b-a);
    }
  return Q;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 8
5 10
6 8
7 14
8 14
9 14
10 14
11 17
12 17
<<<sep_out_sample>>>
push   %rbx
movslq %edi,%rbx
mov    0x0(,%rbx,8),%rsi
callq  11 <reset_signal+0x11>
andl   $0xfffffffe,0x0(,%rbx,4)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reset_signal (sig)
     int sig;
{
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~0x1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    0x18(%rdi),%rax
mov    $0x15,%r8d
lea    0xc(%rsp),%rcx
mov    %esi,0xc(%rsp)
movq   $0x0,0x18(%rsp)
movq   $0x0,0x48(%rsp)
mov    %rdx,0x40(%rsp)
xor    %esi,%esi
mov    %rcx,0x10(%rsp)
lea    0x10(%rsp),%rdx
movq   $0x0,0x20(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x30(%rsp)
lea    0x40(%rsp),%rcx
movq   $0x0,0x50(%rsp)
movq   $0x0,0x58(%rsp)
mov    %rax,%rdi
movq   $0x0,0x60(%rsp)
movl   $0x4,0x18(%rsp)
movl   $0x20,0x48(%rsp)
callq  *0x148(%rax)
xor    %edx,%edx
cmp    $0xffff86eb,%eax
cmovne %eax,%edx
add    $0x78,%rsp
mov    %edx,%eax
retq   
nop
<<<sep_in_sample>>>
CDB___db_vrfy_childput(vdp, pgno, cip)
 VRFY_DBINFO *vdp;
 db_pgno_t pgno;
 VRFY_CHILDINFO *cip;
{
 DBT key, data;
 DB *cdbp;
 int ret;
 cdbp = vdp->cdbp;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 key.data = &pgno;
 key.size = sizeof(db_pgno_t);
 data.data = cip;
 data.size = sizeof(VRFY_CHILDINFO);
 ret = cdbp->put(cdbp, ((void *)0), &key, &data, 21);
 return (ret == (-30997) ? 0 : ret);
}
<<<sep_in_sample>>>
1 5
2 9
3 16
4 12
5 5
6 10
7 11
8 14
9 16
10 12
11 16
12 10
13 10
14 10
15 16
16 11
17 11
18 16
19 11
20 13
21 15
22 16
23 17
24 17
25 17
26 18
27 18
28 18
29 18
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1120 <gsl_vector_float_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1115 <gsl_vector_float_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     115b <gsl_vector_float_div+0x6b>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
movss  (%rax),%xmm0
add    $0x1,%rdx
divss  (%rcx),%xmm0
add    %r9,%rcx
movss  %xmm0,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1140 <gsl_vector_float_div+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_float_div (gsl_vector_float * a, const gsl_vector_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rdi
test   %rdi,%rdi
je     d2 <gsl_rstat_free+0x12>
callq  d2 <gsl_rstat_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   db <gsl_rstat_free+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rstat_free(gsl_rstat_workspace *w)
{
  if (w->median_workspace_p)
    gsl_rstat_quantile_free(w->median_workspace_p);
  free(w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <cdio_log_set_handler+0x7>
mov    %rdi,0x0(%rip)        # e <cdio_log_set_handler+0xe>
retq   
nop
<<<sep_in_sample>>>
cdio_log_set_handler(cdio_log_handler_t new_handler)
{
  cdio_log_handler_t old_handler = _handler;
  _handler = new_handler;
  return old_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    2c0 <__bam_set_bt_minkey+0x40>
mov    %esi,%ebp
mov    $0x1,%esi
callq  29e <__bam_set_bt_minkey+0x1e>
test   %eax,%eax
jne    2b1 <__bam_set_bt_minkey+0x31>
cmp    $0x1,%ebp
mov    0xc0(%rbx),%rdx
jbe    2e0 <__bam_set_bt_minkey+0x60>
mov    %ebp,0x10(%rdx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   2d9 <__bam_set_bt_minkey+0x59>
nopl   0x0(%rax)
mov    0x28(%rbx),%rdi
mov    $0x0,%esi
callq  2ee <__bam_set_bt_minkey+0x6e>
mov    $0x16,%eax
jmp    2b1 <__bam_set_bt_minkey+0x31>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__bam_set_bt_minkey(dbp, bt_minkey)
 DB *dbp;
 u_int32_t bt_minkey;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_bt_minkey", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x01)) != 0) return (__ret); };
 t = dbp->bt_internal;
 if (bt_minkey < 2) {
  CDB___db_err(dbp->dbenv, "minimum bt_minkey value is 2");
  return (22);
 }
 t->bt_minkey = bt_minkey;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 9
13 8
14 9
15 13
16 15
17 15
18 15
19 15
20 15
21 6
22 15
23 6
24 15
25 15
26 6
27 6
28 6
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   68 <nettle_gcm_aes192_update+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_aes192_update (struct gcm_aes192_ctx *ctx,
     size_t length, const uint8_t *data)
{
  nettle_gcm_update(&(ctx)->gcm, &(ctx)->key, (length), (data));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
xor    %eax,%eax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdx
test   %rcx,%rcx
je     40b7 <gsl_vector_uchar_set_zero+0x27>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
movb   $0x0,(%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    40a8 <gsl_vector_uchar_set_zero+0x18>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_uchar_set_zero (gsl_vector_uchar * v)
{
  unsigned char * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const unsigned char zero = 0U ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(unsigned char *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 4
2 8
3 5
4 5
5 8
6 8
7 8
8 8
9 10
10 10
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0xfa88,%edi
callq  3de <cdtext_init+0xe>
lea    0x1f40(%rax),%rcx
lea    0x119c0(%rax),%rsi
lea    -0x1f40(%rcx),%rdx
nopl   0x0(%rax,%rax,1)
movq   $0x0,(%rdx)
movq   $0x0,0x8(%rdx)
add    $0x50,%rdx
movq   $0x0,-0x40(%rdx)
movq   $0x0,-0x38(%rdx)
movq   $0x0,-0x30(%rdx)
movq   $0x0,-0x28(%rdx)
movq   $0x0,-0x20(%rdx)
movq   $0x0,-0x18(%rdx)
movq   $0x0,-0x10(%rdx)
movq   $0x0,-0x8(%rdx)
cmp    %rcx,%rdx
jne    3f8 <cdtext_init+0x28>
lea    0x1f50(%rdx),%rcx
movl   $0x0,(%rdx)
movl   $0x0,0x4(%rdx)
cmp    %rsi,%rcx
jne    3ec <cdtext_init+0x1c>
movb   $0x0,0xfa80(%rax)
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdtext_init(void)
{
  cdtext_field_t k;
  track_t j;
  int i;
  cdtext_t *p_cdtext;
  p_cdtext = (cdtext_t *) malloc(sizeof(struct cdtext_s));
  for (i=0; i<CDTEXT_NUM_BLOCKS_MAX; i++) {
    for (j=0; j<CDTEXT_NUM_TRACKS_MAX; j++) {
      for (k=0; k < 10; k++) {
        p_cdtext->block[i].track[j].field[k] = ((void *)0);
      }
    }
    p_cdtext->block[i].genre_code = CDTEXT_GENRE_UNUSED;
    p_cdtext->block[i].language_code = CDTEXT_LANGUAGE_UNKNOWN;
  }
  p_cdtext->block_i = 0;
  return p_cdtext;
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 7
5 7
6 2
7 2
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 9
20 9
21 9
22 14
23 15
24 8
25 8
26 17
27 19
28 19
29 19
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_self (self)
     SHELL_VAR *self;
{
  return (self);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 27 <pe_program_version+0x7>
mov    $0x1,%edx
mov    $0x4,%esi
mov    $0x0,%edi
jmpq   3b <pe_program_version+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pe_program_version (struct prompt_exp *p)
{
  fwrite ("1.12", sizeof ("1.12") - 1, 1, stdout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,(%rsp)
movapd %xmm2,%xmm0
movsd  %xmm1,0x8(%rsp)
callq  78 <gsl_cdf_gumbel1_Q+0x18>
movsd  0x8(%rsp),%xmm1
mulsd  (%rsp),%xmm1
subsd  %xmm0,%xmm1
xorpd  0x0(%rip),%xmm1        # 8f <gsl_cdf_gumbel1_Q+0x2f>
movapd %xmm1,%xmm0
movsd  %xmm1,(%rsp)
callq  9d <gsl_cdf_gumbel1_Q+0x3d>
xorpd  0x0(%rip),%xmm0        # a5 <gsl_cdf_gumbel1_Q+0x45>
callq  aa <gsl_cdf_gumbel1_Q+0x4a>
movsd  0x0(%rip),%xmm2        # b2 <gsl_cdf_gumbel1_Q+0x52>
movsd  (%rsp),%xmm1
ucomisd %xmm0,%xmm2
jbe    d8 <gsl_cdf_gumbel1_Q+0x78>
movsd  0x0(%rip),%xmm1        # c5 <gsl_cdf_gumbel1_Q+0x65>
add    $0x18,%rsp
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
callq  e1 <gsl_cdf_gumbel1_Q+0x81>
xorpd  0x0(%rip),%xmm0        # e9 <gsl_cdf_gumbel1_Q+0x89>
callq  ee <gsl_cdf_gumbel1_Q+0x8e>
movapd %xmm0,%xmm1
xorpd  0x0(%rip),%xmm1        # fa <gsl_cdf_gumbel1_Q+0x9a>
add    $0x18,%rsp
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel1_Q (const double x, const double a, const double b)
{
  double u = a * x - log (b);
  double Q;
  double P = exp (-exp (-u));
  if (P < 0.5)
    {
      Q = 1 - P;
    }
  else
    {
      Q = -expm1 (-exp (-u));
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 8
20 15
21 8
22 15
23 15
24 15
25 12
26 12
27 12
28 12
29 12
30 12
31 15
32 15
33 15
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
sub    $0x38,%rsp
movsd  0x0(%rip),%xmm4        # 12360 <cwi+0x10>
divsd  0x0(%rip),%xmm2        # 12368 <cwi+0x18>
movsd  %xmm4,(%rsp)
movsd  0x0(%rip),%xmm1        # 12375 <cwi+0x25>
movapd %xmm2,%xmm0
movsd  %xmm2,0x10(%rsp)
callq  12384 <cwi+0x34>
movsd  0x10(%rsp),%xmm2
movsd  %xmm0,0x18(%rsp)
movsd  0x0(%rip),%xmm5        # 12398 <cwi+0x48>
movapd %xmm2,%xmm0
movsd  0x0(%rip),%xmm1        # 123a4 <cwi+0x54>
movsd  %xmm5,0x8(%rsp)
movsd  %xmm2,0x28(%rsp)
callq  123b5 <cwi+0x65>
movsd  0x28(%rsp),%xmm2
movsd  %xmm0,0x20(%rsp)
movsd  0x0(%rip),%xmm6        # 123c9 <cwi+0x79>
movapd %xmm2,%xmm0
movsd  0x0(%rip),%xmm1        # 123d5 <cwi+0x85>
movsd  %xmm6,0x10(%rsp)
callq  123e0 <cwi+0x90>
movsd  (%rsp),%xmm1
movsd  0x8(%rsp),%xmm3
mulsd  0x18(%rsp),%xmm1
mulsd  0x20(%rsp),%xmm3
mulsd  0x10(%rsp),%xmm0
movsd  0x28(%rsp),%xmm2
addsd  %xmm3,%xmm1
addsd  %xmm0,%xmm1
movapd %xmm2,%xmm0
mulsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm2        # 1241b <cwi+0xcb>
mulsd  0x0(%rip),%xmm0        # 12423 <cwi+0xd3>
addsd  %xmm0,%xmm1
addsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 12433 <cwi+0xe3>
mulsd  0x0(%rip),%xmm1        # 1243b <cwi+0xeb>
add    $0x38,%rsp
movapd %xmm1,%xmm0
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cwi(double t)
{
 double W=t/Q;
 return (cw[1]*pow(W,5.)+cw[2]*pow(W,4.)
  +cw[3]*pow(W,3.)+cw[4]*pow(W,2.)+cw[5]*W+cw[6])*Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 4
20 5
21 5
22 5
23 5
24 5
25 4
26 4
27 4
28 4
29 5
30 5
31 4
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
40 4
41 6
42 6
43 6
44 6
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rsi),%rbx
cmp    (%rdi),%rbx
mov    0x8(%rdi),%r15
mov    0x8(%rsi),%rax
jne    490 <gsl_vector_complex_equal+0xd0>
test   %rbx,%rbx
je     4c0 <gsl_vector_complex_equal+0x100>
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%rbp
movsd  (%r12),%xmm0
ucomisd 0x0(%rbp),%xmm0
jp     47b <gsl_vector_complex_equal+0xbb>
jne    47b <gsl_vector_complex_equal+0xbb>
lea    (%r15,%r15,1),%r13
lea    (%rax,%rax,1),%r14
shl    $0x4,%r15
shl    $0x4,%rax
lea    (%r12,%r15,1),%rcx
xor    %r9d,%r9d
mov    %rax,0x8(%rsp)
lea    0x0(%rbp,%rax,1),%rdx
mov    %r14,%rdi
mov    %r13,%rsi
xor    %r8d,%r8d
xor    %eax,%eax
jmp    46b <gsl_vector_complex_equal+0xab>
jne    47b <gsl_vector_complex_equal+0xbb>
add    $0x1,%rax
cmp    %rbx,%rax
je     4c0 <gsl_vector_complex_equal+0x100>
movsd  (%rcx),%xmm1
add    %r15,%rcx
lea    (%rsi,%r13,1),%r10
movsd  (%rdx),%xmm0
add    0x8(%rsp),%rdx
lea    (%rdi,%r14,1),%r11
ucomisd %xmm0,%xmm1
jp     47b <gsl_vector_complex_equal+0xbb>
jne    47b <gsl_vector_complex_equal+0xbb>
mov    %rsi,%r8
mov    %rdi,%r9
mov    %r10,%rsi
mov    %r11,%rdi
movsd  0x8(%r12,%r8,8),%xmm0
ucomisd 0x8(%rbp,%r9,8),%xmm0
jnp    430 <gsl_vector_complex_equal+0x70>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4a9 <gsl_vector_complex_equal+0xe9>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
add    $0x18,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_equal (const gsl_vector_complex * u, const gsl_vector_complex * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (u->data[2 * stride_u * j + k] != v->data[2 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 7
10 4
11 5
12 7
13 11
14 11
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 16
35 11
36 11
37 11
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 16
50 16
51 16
52 16
53 16
54 23
55 18
56 23
57 23
58 23
59 23
60 23
61 23
62 23
63 23
64 9
65 9
66 9
67 9
68 9
69 23
70 9
71 23
72 23
73 23
74 23
75 23
76 23
77 23
78 23
79 23
80 22
81 23
82 23
83 23
84 23
85 23
86 23
87 23
88 23
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4d0 <mu_folder_open+0x10>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     4d0 <mu_folder_open+0x10>
jmpq   *%rax
mov    $0x26,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_folder_open (mu_folder_t folder, int flags)
{
  if (folder == ((void *)0) || folder->_open == ((void *)0))
    return 38;
  return folder->_open (folder, flags);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  (void) (args_info);
  (void) (prog_name);
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
jmpq   175 <gsl_spmatrix_compcol+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spmatrix_compcol(const gsl_spmatrix *T)
{
  return gsl_spmatrix_ccs(T);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     7a0 <_rl_free_history_entry+0x30>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     786 <_rl_free_history_entry+0x16>
callq  786 <_rl_free_history_entry+0x16>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     794 <_rl_free_history_entry+0x24>
callq  794 <_rl_free_history_entry+0x24>
mov    %rbx,%rdi
pop    %rbx
jmpq   79d <_rl_free_history_entry+0x2d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_free_history_entry (entry)
     HIST_ENTRY *entry;
{
  if (entry == 0)
    return;
  if (entry->line) free (entry->line);
  if (entry->timestamp) free (entry->timestamp);
  xfree (entry);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 9
15 8
16 8
17 9
18 9
19 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  11 <_mapfile_get_transport2+0x11>
test   %rbp,%rbp
je     1e <_mapfile_get_transport2+0x1e>
movq   $0x0,0x0(%rbp)
test   %rbx,%rbx
je     29 <_mapfile_get_transport2+0x29>
movslq (%rax),%rax
mov    %rax,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  if (pout)
    *pout = ((void *)0);
  if (pin)
    *pin = (mu_transport_t) mfs->fd;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 5
10 6
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  361 <xdr_dis_linear_vel_vector+0x11>
test   %eax,%eax
jne    370 <xdr_dis_linear_vel_vector+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  37c <xdr_dis_linear_vel_vector+0x2c>
test   %eax,%eax
je     365 <xdr_dis_linear_vel_vector+0x15>
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  38c <xdr_dis_linear_vel_vector+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_linear_vel_vector(xdrs, objp)
	XDR *xdrs;
	dis_linear_vel_vector *objp;
{
	if (!xdr_byte_float(xdrs, &objp->x)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->y)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->z)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1cb7 <psset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psset_out (FILE * out_str )
{
        psout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x1370,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sobol_state_size(unsigned int dimension)
{
  return sizeof(sobol_state_t);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %rdi,%r12
mov    $0x1,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x30,%esi
push   %rbx
mov    %r8,%rbx
callq  126 <make_ht+0x26>
test   %rax,%rax
mov    %rax,(%rbx)
je     160 <make_ht+0x60>
mov    %r12,(%rax)
mov    %rbp,0x8(%rax)
mov    %r13d,%esi
mov    %r14,0x10(%rax)
movl   $0x0,0x18(%rax)
mov    %rax,%rdi
callq  0 <alloc_ht>
test   %eax,%eax
setne  %al
movzbl %al,%eax
neg    %eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
mov    $0xffffffff,%eax
jmp    155 <make_ht+0x55>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_ht(T_HashFunc f1, T_HashFunc f2, T_ComparFunc c, int size,
     T_HashTable **H)
{
  *H = ((T_HashTable*)(calloc(1,sizeof(T_HashTable))));
  if (*H == ((void *)0)){
    return -1;
  }
  (*H)->f1 = f1;
  (*H)->f2 = f2;
  (*H)->compar = c;
  (*H)->size = 0;
  if(alloc_ht(*H,size))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 3
9 3
10 4
11 3
12 3
13 4
14 5
15 4
16 5
17 8
18 9
19 12
20 10
21 11
22 12
23 12
24 12
25 12
26 12
27 12
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 6
36 6
37 6
<<<sep_out_sample>>>
mov    (%rdi),%r10
cmp    0x8(%rdi),%r10
je     5550 <gsl_matrix_char_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5546 <gsl_matrix_char_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %r10,%r10
je     55b4 <gsl_matrix_char_transpose+0x94>
xor    %r8d,%r8d
lea    0x1(%r8),%r11
cmp    %r10,%r11
je     55b4 <gsl_matrix_char_transpose+0x94>
nopl   0x0(%rax)
mov    %r11,%rax
nopl   0x0(%rax,%rax,1)
mov    0x10(%rdi),%rcx
mov    %rax,%rdx
mov    0x18(%rdi),%rsi
imul   %rcx,%rdx
imul   %r8,%rcx
add    %r8,%rdx
add    %rax,%rcx
add    $0x1,%rax
add    %rsi,%rcx
movzbl (%rsi,%rdx,1),%esi
cmp    %r10,%rax
movzbl (%rcx),%r9d
mov    %sil,(%rcx)
mov    0x18(%rdi),%rcx
mov    %r9b,(%rcx,%rdx,1)
jne    5570 <gsl_matrix_char_transpose+0x50>
mov    %r11,%r8
lea    0x1(%r8),%r11
cmp    %r10,%r11
jne    5568 <gsl_matrix_char_transpose+0x48>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_transpose (gsl_matrix_char * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                char tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 16
23 17
24 19
25 17
26 16
27 17
28 16
29 12
30 19
31 20
32 12
33 19
34 20
35 21
36 21
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%rbx
xor    %ecx,%ecx
callq  2b <_def_write+0xb>
test   %eax,%eax
js     40 <_def_write+0x20>
cltq   
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  45 <_def_write+0x25>
pop    %rbx
mov    (%rax),%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_def_write (void *sd, const char *data, size_t size, size_t * nbytes)
{
  int rc = send ((int) sd, data, size, 0);
  if (rc >= 0)
    {
      *nbytes = rc;
      return 0;
    }
  return (*__errno_location ());
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 7
10 10
11 10
12 10
13 9
14 10
15 9
16 10
17 10
<<<sep_out_sample>>>
push   %rbx
testb  $0x2,0x2d1(%rdi)
mov    %rdi,%rbx
jne    423 <update_aim120+0x63>
movslq (%rdi),%rax
mov    0x0(,%rax,4),%esi
test   %esi,%esi
je     423 <update_aim120+0x63>
mov    0x0(,%rax,4),%ecx
test   %ecx,%ecx
jle    423 <update_aim120+0x63>
mov    $0x0,%esi
callq  3f0 <update_aim120+0x30>
test   %eax,%eax
js     450 <update_aim120+0x90>
mov    0x0(%rip),%edx        # 3fa <update_aim120+0x3a>
test   %edx,%edx
je     430 <update_aim120+0x70>
mov    %eax,%esi
mov    %rbx,%rdi
callq  408 <update_aim120+0x48>
mov    $0x4,%esi
mov    %rbx,%rdi
callq  415 <update_aim120+0x55>
movslq (%rbx),%rax
movl   $0x0,0x0(,%rax,4)
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movslq %eax,%rdx
shl    $0x5,%rdx
movq   $0x0,0x870(%rbx,%rdx,1)
movslq (%rbx),%rdx
subl   $0x1,0x0(,%rdx,4)
jmp    3fe <update_aim120+0x3e>
mov    0x0(%rip),%rcx        # 457 <update_aim120+0x97>
mov    $0x1c,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  46b <update_aim120+0xab>
jmp    415 <update_aim120+0x55>
nopl   (%rax)
<<<sep_in_sample>>>
update_aim120(craft * c)
{
 register int i;
 if ((c->flags & (1<<9)) == 0) {
  if (hasFired[c->pIndex] && count[c->pIndex] > 0) {
   i = readyStation(c, "aim120");
   if (i < 0)
    fprintf(stderr, "Oops. Can't find an AIM-120\n");
   else {
    if (arcadeMode == 0) {
     c->station[i].type = "";
     count[c->pIndex]--;
    }
    fireMissile(c, i);
    playSound(c, 4);
   }
   hasFired[c->pIndex] = 0;
  }
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 10
17 10
18 10
19 14
20 14
21 14
22 15
23 15
24 15
25 17
26 17
27 21
28 21
29 21
30 21
31 11
32 11
33 11
34 12
35 12
36 12
37 8
38 8
39 8
40 8
41 8
42 8
43 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  9b <remove_watcher+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     e0 <remove_watcher+0x50>
mov    %rax,%rdi
callq  ab <remove_watcher+0x1b>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  b6 <remove_watcher+0x26>
test   %rbp,%rbp
je     d0 <remove_watcher+0x40>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   c9 <remove_watcher+0x39>
nopl   0x0(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x0,%esi
xor    %edi,%edi
pop    %rbx
pop    %rbp
xor    %eax,%eax
jmpq   f4 <remove_watcher+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remove_watcher(const char *dir, const char *name)
{
 struct dirwatcher *dwp;
 char *fullname = mkfilename(dir, name);
 if (!fullname) {
  diag(0, "not enough memory: "
       "cannot look up a watcher to delete");
  return;
 }
 dwp = dirwatcher_lookup(fullname);
 free(fullname);
 if (dwp)
  dirwatcher_destroy(dwp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 4
7 5
8 10
9 10
10 11
11 10
12 11
13 12
14 12
15 14
16 13
17 14
18 14
19 13
20 13
21 14
22 14
23 14
24 14
25 14
26 14
27 6
28 6
29 14
30 14
31 6
32 6
33 6
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x50(%rdi),%rbx
test   %rbx,%rbx
je     25a <remote_mbox_destroy+0x2a>
mov    %rbx,%rdi
callq  24a <remote_mbox_destroy+0x1a>
mov    %rbx,%rdi
callq  252 <remote_mbox_destroy+0x22>
movq   $0x0,0x50(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remote_mbox_destroy (mu_mailbox_t mailbox)
{
  if (mailbox->data)
    {
      struct remote_mbox_data *dat = mailbox->data;
      mu_mailer_destroy (&dat->mailer);
      free (dat);
      mailbox->data = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 6
9 6
10 7
11 7
12 8
13 10
14 10
15 10
16 10
17 10
<<<sep_out_sample>>>
cmpq   $0x2,0x8(%rsp)
mov    $0xffffffff,%eax
jne    39 <haar_init+0x39>
movq   $0x0,(%rdi)
xor    %eax,%eax
movq   $0x0,(%rsi)
movq   $0x0,(%rdx)
movq   $0x0,(%rcx)
movq   $0x2,(%r8)
movq   $0x0,(%r9)
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
haar_init (const double **h1, const double **g1, const double **h2,
           const double **g2, size_t * nc, size_t * offset,
           const size_t member)
{
  if (member != 2)
    {
      return GSL_FAILURE;
    }
  *h1 = ch_2;
  *g1 = cg_2;
  *h2 = ch_2;
  *g2 = cg_2;
  *nc = 2;
  *offset = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 9
5 15
6 10
7 11
8 12
9 13
10 14
11 16
12 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edx,%ebp
xor    0x0(%rip),%ebp        # 6b <doJoystickEvent+0xb>
push   %rbx
mov    %edx,%ebx
je     8d <doJoystickEvent+0x2d>
test   $0x1,%bpl
mov    %rdi,%r12
je     83 <doJoystickEvent+0x23>
test   $0x1,%dl
je     a0 <doJoystickEvent+0x40>
callq  83 <doJoystickEvent+0x23>
and    $0x2,%ebp
je     8d <doJoystickEvent+0x2d>
test   $0x2,%bl
jne    b0 <doJoystickEvent+0x50>
mov    %ebx,0x0(%rip)        # 93 <doJoystickEvent+0x33>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
callq  a5 <doJoystickEvent+0x45>
and    $0x2,%ebp
jne    88 <doJoystickEvent+0x28>
jmp    8d <doJoystickEvent+0x2d>
nopl   0x0(%rax)
mov    %r12,%rdi
callq  b8 <doJoystickEvent+0x58>
mov    %ebx,0x0(%rip)        # be <doJoystickEvent+0x5e>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doJoystickEvent(craft * c, viewer * u, double throttle, int switches)
{
 int switch_xor = switches ^ last_switches;
 if (switch_xor != 0) {
  if (switch_xor & 1) {
   if (switches & 1) {
    fireWeapon(c);
   }
   else {
    ceaseFireWeapon(c);
   }
  }
  if (switch_xor & 2) {
   if (switches & 2) {
    selectWeapon(c);
   }
  }
 }
 last_switches = switches;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 2
6 2
7 4
8 5
9 5
10 5
11 6
12 6
13 7
14 13
15 13
16 14
17 14
18 19
19 21
20 21
21 21
22 21
23 21
24 21
25 10
26 13
27 13
28 13
29 13
30 15
31 15
32 19
33 21
34 21
35 21
36 21
37 21
38 21
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 10bb <string_begin+0xb>
movq   $0x0,0x0(%rip)        # 10c6 <string_begin+0x16>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_begin (void)
{
  strseg_head = strseg_tail = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
test   %rsi,%rsi
mov    %rsi,%r12
push   %rbp
push   %rbx
je     b1e <argcv_free+0x3e>
test   %edi,%edi
jle    b28 <argcv_free+0x48>
movslq %edi,%rdi
lea    -0x8(%rsi),%rbp
lea    -0x8(%rsi,%rdi,8),%rbx
jmp    b11 <argcv_free+0x31>
xchg   %ax,%ax
mov    (%rbx),%rdi
test   %rdi,%rdi
je     b0d <argcv_free+0x2d>
callq  b0d <argcv_free+0x2d>
sub    $0x8,%rbx
cmp    %rbp,%rbx
jne    b00 <argcv_free+0x20>
mov    %r12,%rdi
callq  b1e <argcv_free+0x3e>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   (%rax)
mov    (%rsi),%rdi
lea    0x8(%rsi),%rbx
test   %rdi,%rdi
je     b16 <argcv_free+0x36>
nopl   0x0(%rax)
add    $0x8,%rbx
callq  b41 <argcv_free+0x61>
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    b38 <argcv_free+0x58>
jmp    b16 <argcv_free+0x36>
nopl   0x0(%rax)
<<<sep_in_sample>>>
argcv_free (int argc, char **argv)
{
  if (!argv)
    return 0;
  if (argc > 0)
    {
      while (--argc >= 0)
 if (argv[argc])
   free (argv[argc]);
    }
  else
    {
      int i;
      for (i = 0; argv[i]; i++)
 free (argv[i]);
    }
  free (argv);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 8
15 8
16 8
17 9
18 9
19 7
20 7
21 17
22 17
23 19
24 19
25 19
26 19
27 19
28 19
29 14
30 14
31 14
32 14
33 14
34 14
35 15
36 14
37 14
38 14
39 14
40 14
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fixbounds(const char *r)
{
    return r;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
jmpq   5 <cdio_realpath+0x5>
<<<sep_in_sample>>>
cdio_realpath (const char *psz_src_path, char *psz_resolved_path) {
  psz_resolved_path = realpath(psz_src_path, psz_resolved_path);
  return psz_resolved_path;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x14(%rdi),%eax
mov    %eax,0xc(%rdi)
mov    0x18(%rdi),%eax
mov    %eax,0x10(%rdi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
coproc_fdrestore (cp)
     struct coproc *cp;
{
  cp->c_rfd = cp->c_rsave;
  cp->c_wfd = cp->c_wsave;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
jmp    45b7 <rl_get_keymap_by_name+0x27>
add    $0x1,%rbx
mov    %rbx,%rax
shl    $0x4,%rax
mov    0x0(%rax),%rsi
test   %rsi,%rsi
je     45e0 <rl_get_keymap_by_name+0x50>
mov    %rbp,%rdi
movslq %ebx,%r12
callq  45c2 <rl_get_keymap_by_name+0x32>
test   %eax,%eax
jne    45a0 <rl_get_keymap_by_name+0x10>
pop    %rbx
shl    $0x4,%r12
pop    %rbp
mov    0x0(%r12),%rax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_get_keymap_by_name (name)
     const char *name;
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (strcasecmp (name, keymap_names[i].name) == 0)
      return (keymap_names[i].map);
  return ((Keymap) ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 9
20 7
21 9
22 7
23 9
24 9
25 9
26 9
27 9
28 8
29 9
30 9
31 9
<<<sep_out_sample>>>
mov    %edi,%edi
jmpq   1da7 <psalloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_algorithm (osip_www_authenticate_t * www_authenticate, char *algorithm)
{
  www_authenticate->algorithm = (char *) algorithm;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  2a6 <imap_mailbox_name_match+0x16>
test   %eax,%eax
je     2c0 <imap_mailbox_name_match+0x30>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
xor    %edx,%edx
jmpq   2bd <imap_mailbox_name_match+0x2d>
nopl   (%rax)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <imap_mailbox_name_match+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
imap_mailbox_name_match (const char* pattern, const char* mailbox)
{
  if (mu_c_strcasecmp (pattern, "inbox") == 0)
    {
      return mu_c_strcasecmp (pattern, mailbox);
    }
  return fnmatch (pattern, mailbox, 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 3
10 8
11 7
12 7
13 8
14 8
15 7
16 7
17 7
18 8
19 5
20 5
21 8
22 8
23 5
24 5
<<<sep_out_sample>>>
mov    $0x0,%ecx
jmpq   0 <authors_print.constprop.0>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
authors_print_plain (const unsigned char * authors, FILE * stream,
       const char *before)
{
  authors_print (authors, stream,
   before, "%s <%s>", ", ", ".\n");
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
movzbl %sil,%esi
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
mov    0x163c(%rdi,%rax,8),%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_track_channels_image(const void *p_user_data, track_t i_track)
{
  const _img_private_t *p_env = p_user_data;
  return ( p_env->tocent[i_track-p_env->gen.i_first_track].flags
   & FOUR_CHANNEL_AUDIO ) ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
<<<sep_out_sample>>>
mov    %dl,0x0(%rip)        # b6 <set_no_of_sides+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_no_of_sides(const char *p, const char *s, char value)
{
  no_of_sides = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_digest (osip_authorization_t * authorization, char *digest)
{
  authorization->digest = (char *) digest;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x50(%rdi),%rbx
cmpq   $0x0,0x68(%rbx)
je     b0 <amd_message_unseen+0x40>
mov    0x78(%rbx),%rax
mov    (%rax),%rax
mov    0x1c(%rax),%eax
test   %eax,%eax
je     a0 <amd_message_unseen+0x30>
test   $0x20,%al
je     a0 <amd_message_unseen+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
movq   $0x1,0x0(%rbp)
jmp    96 <amd_message_unseen+0x26>
nopw   0x0(%rax,%rax,1)
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x1,%esi
callq  *0x38(%rbx)
test   %eax,%eax
jne    98 <amd_message_unseen+0x28>
cmpq   $0x0,0x68(%rbx)
jne    84 <amd_message_unseen+0x14>
jmp    96 <amd_message_unseen+0x26>
nopl   0x0(%rax)
<<<sep_in_sample>>>
amd_message_unseen (mu_mailbox_t mailbox, size_t *pmsgno)
{
  struct _amd_data *amd = mailbox->data;
  size_t i;
  if (amd->msg_count == 0)
    {
      int status = amd->scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  for (i = 0; i < amd->msg_count; i++)
    {
      if (((amd->msg_array[0]->attr_flags) == 0 || ! ((amd->msg_array[0]->attr_flags) & 0x20)))
 {
   *pmsgno = i + 1;
   break;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 13
14 13
15 19
16 20
17 20
18 20
19 20
20 20
21 15
22 15
23 15
24 7
25 7
26 7
27 7
28 8
29 8
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 627 <terminal_begin_inverse+0x7>
test   %rdx,%rdx
je     630 <terminal_begin_inverse+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%rdi        # 637 <terminal_begin_inverse+0x17>
test   %rdi,%rdi
je     650 <terminal_begin_inverse+0x30>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   64b <terminal_begin_inverse+0x2b>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
terminal_begin_inverse (void)
{
  if (terminal_begin_inverse_hook)
    (*terminal_begin_inverse_hook) ();
  else
    {
      do { if (term_invbeg) tputs (term_invbeg, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
test   %rsi,%rsi
jne    6dd1 <delete_var+0x21>
jmp    6e30 <delete_var+0x80>
nopl   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
je     6e30 <delete_var+0x80>
mov    0x20(%rbx),%rsi
xor    %edx,%edx
mov    %rbp,%rdi
callq  6ddf <delete_var+0x2f>
test   %rax,%rax
je     6dc8 <delete_var+0x18>
mov    0x8(%rax),%rdi
mov    $0xd8b,%edx
mov    $0x0,%esi
mov    0x10(%rax),%rbx
mov    %rax,0x8(%rsp)
callq  6e00 <delete_var+0x50>
mov    0x8(%rsp),%rax
mov    $0xd8c,%edx
mov    $0x0,%esi
mov    %rax,%rdi
callq  6e17 <delete_var+0x67>
mov    %rbx,%rdi
callq  6e1f <delete_var+0x6f>
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
delete_var (name, vc)
     const char *name;
     VAR_CONTEXT *vc;
{
  BUCKET_CONTENTS *elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;
  for (elt = (BUCKET_CONTENTS *)((void *)0), v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;
  if (elt == 0)
    return (-1);
  old_var = (SHELL_VAR *)elt->data;
  sh_xfree((elt->key), "variables.c", 3467);
  sh_xfree((elt), "variables.c", 3468);
  dispose_variable (old_var);
  return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 14
20 14
21 14
22 13
23 14
24 14
25 15
26 15
27 15
28 15
29 15
30 16
31 16
32 18
33 17
34 18
35 18
36 18
37 18
38 18
39 12
40 18
41 18
42 18
43 18
<<<sep_out_sample>>>
mov    0x14(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ip_server_get_fd (mu_ip_server_t srv)
{
  return srv->fd;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1276 <clearmsg+0x6>
test   %eax,%eax
je     1280 <clearmsg+0x10>
repz retq 
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 128b <clearmsg+0x1b>
xor    %edx,%edx
xor    %esi,%esi
callq  1294 <clearmsg+0x24>
mov    0x0(%rip),%rdi        # 129b <clearmsg+0x2b>
add    $0x8,%rsp
jmpq   12a4 <clearmsg+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
clearmsg(void)
{
 if (linemode == NO) {
  wmove(stdscr,(0),(0));
  wclrtoeol(stdscr);
 }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 4
8 4
9 4
10 4
11 5
12 7
13 5
14 5
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 327 <grecs_set_keywords+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_set_keywords (struct grecs_keyword *kwd)
{
  config_keywords.kwd = kwd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     710 <gsl_block_complex_raw_fread+0x90>
shl    $0x4,%rcx
xor    %ebp,%ebp
test   %rdx,%rdx
mov    %rcx,%r14
mov    %rsi,%rbx
jne    6bc <gsl_block_complex_raw_fread+0x3c>
jmp    700 <gsl_block_complex_raw_fread+0x80>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     700 <gsl_block_complex_raw_fread+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x10,%esi
mov    %rbx,%rdi
callq  6d1 <gsl_block_complex_raw_fread+0x51>
cmp    $0x1,%rax
je     6b0 <gsl_block_complex_raw_fread+0x30>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6f0 <gsl_block_complex_raw_fread+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x10,%esi
callq  71d <gsl_block_complex_raw_fread+0x9d>
cmp    %r12,%rax
je     700 <gsl_block_complex_raw_fread+0x80>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  73b <gsl_block_complex_raw_fread+0xbb>
mov    $0x5,%eax
jmp    6f5 <gsl_block_complex_raw_fread+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_raw_fread (FILE * stream, double * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 2 * sizeof (double), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 2 * i * stride,
                               2 * sizeof (double), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 17
24 17
25 17
26 17
27 17
28 19
29 19
30 21
31 21
32 21
33 21
34 21
35 21
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 26
47 25
48 26
49 26
50 26
51 6
52 6
53 6
54 7
55 7
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
mov    (%rcx),%rax
je     e36 <gsl_vector_long_min+0x36>
lea    0x0(,%rdx,8),%rdi
xor    %edx,%edx
nopl   (%rax)
mov    (%rcx),%rsi
cmp    %rsi,%rax
cmovg  %rsi,%rax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    e20 <gsl_vector_long_min+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_min (const gsl_vector_long * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      long x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  25 <gsl_stats_long_double_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  38 <gsl_stats_long_double_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  55 <gsl_stats_long_double_ttest+0x55>
test   %rbp,%rbp
js     b8 <gsl_stats_long_double_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 67 <gsl_stats_long_double_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     d8 <gsl_stats_long_double_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     f2 <gsl_stats_long_double_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    5f <gsl_stats_long_double_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    79 <gsl_stats_long_double_ttest+0x79>
test   %rbp,%rbp
js     12c <gsl_stats_long_double_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     143 <gsl_stats_long_double_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  123 <gsl_stats_long_double_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   97 <gsl_stats_long_double_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    fc <gsl_stats_long_double_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    10e <gsl_stats_long_double_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_ttest (const long double data1[],
                           const size_t stride1, const size_t n1,
                           const long double data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_long_double_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_long_double_mean (data2, stride2, n2);
  const double pv = gsl_stats_long_double_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # 57e8 <_rl_move_vert+0x8>
mov    %edi,%r12d
push   %rbp
cmp    %edi,%eax
push   %rbx
je     5847 <_rl_move_vert+0x67>
cmp    0x0(%rip),%edi        # 57f7 <_rl_move_vert+0x17>
jg     5847 <_rl_move_vert+0x67>
mov    %edi,%ebp
sub    %eax,%ebp
test   %ebp,%ebp
jle    5850 <_rl_move_vert+0x70>
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 580f <_rl_move_vert+0x2f>
mov    $0xa,%edi
add    $0x1,%ebx
callq  581c <_rl_move_vert+0x3c>
cmp    %ebp,%ebx
jne    5808 <_rl_move_vert+0x28>
mov    0x0(%rip),%rdi        # 5827 <_rl_move_vert+0x47>
mov    $0x0,%edx
mov    $0x1,%esi
callq  5836 <_rl_move_vert+0x56>
movl   $0x0,0x0(%rip)        # 5840 <_rl_move_vert+0x60>
mov    %r12d,0x0(%rip)        # 5847 <_rl_move_vert+0x67>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 5857 <_rl_move_vert+0x77>
test   %rdi,%rdi
je     5840 <_rl_move_vert+0x60>
cmpb   $0x0,(%rdi)
je     5840 <_rl_move_vert+0x60>
neg    %ebp
je     5840 <_rl_move_vert+0x60>
xor    %ebx,%ebx
jmp    5877 <_rl_move_vert+0x97>
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 5877 <_rl_move_vert+0x97>
mov    $0x0,%edx
mov    $0x1,%esi
add    $0x1,%ebx
callq  5889 <_rl_move_vert+0xa9>
cmp    %ebp,%ebx
jne    5870 <_rl_move_vert+0x90>
jmp    5840 <_rl_move_vert+0x60>
nop
<<<sep_in_sample>>>
_rl_move_vert (to)
     int to;
{
  register int delta, i;
  if (_rl_last_v_pos == to || to > _rl_screenheight)
    return;
  if ((delta = to - _rl_last_v_pos) > 0)
    {
      for (i = 0; i < delta; i++)
 _IO_putc ('\n', rl_outstream);
      tputs (_rl_term_cr, 1, _rl_output_character_function);
      _rl_last_c_pos = 0;
    }
  else
    {
      if (_rl_term_up && *_rl_term_up)
 for (i = 0; i < -delta; i++)
   tputs (_rl_term_up, 1, _rl_output_character_function);
    }
  _rl_last_v_pos = to;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 9
19 10
20 9
21 9
22 11
23 11
24 11
25 11
26 12
27 20
28 21
29 21
30 21
31 21
32 21
33 16
34 16
35 16
36 16
37 16
38 17
39 17
40 17
41 17
42 17
43 17
44 18
45 18
46 17
47 18
48 17
49 17
50 17
51 17
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     7a0 <_rl_free_history_entry+0x30>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     786 <_rl_free_history_entry+0x16>
callq  786 <_rl_free_history_entry+0x16>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     794 <_rl_free_history_entry+0x24>
callq  794 <_rl_free_history_entry+0x24>
mov    %rbx,%rdi
pop    %rbx
jmpq   79d <_rl_free_history_entry+0x2d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_free_history_entry (entry)
     HIST_ENTRY *entry;
{
  if (entry == 0)
    return;
  if (entry->line) free (entry->line);
  if (entry->timestamp) free (entry->timestamp);
  xfree (entry);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 6
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 9
15 8
16 8
17 9
18 9
19 9
<<<sep_out_sample>>>
xor    %r8d,%r8d
shl    $0x4,%rdx
test   %rcx,%rcx
je     93a <gsl_permute_long_double_inverse+0x6a>
nopl   0x0(%rax)
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    8f9 <gsl_permute_long_double_inverse+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     8f0 <gsl_permute_long_double_inverse+0x20>
cmp    %r8,%rax
jb     931 <gsl_permute_long_double_inverse+0x61>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
je     931 <gsl_permute_long_double_inverse+0x61>
imul   %rdx,%rax
fldt   (%rsi,%rax,1)
mov    %rdx,%rax
imul   %r9,%rax
mov    (%rdi,%r9,8),%r9
add    %rsi,%rax
cmp    %r9,%r8
fldt   (%rax)
fxch   %st(1)
fstpt  (%rax)
jne    90e <gsl_permute_long_double_inverse+0x3e>
mov    %rdx,%rax
imul   %r8,%rax
fstpt  (%rsi,%rax,1)
add    $0x1,%r8
cmp    %rcx,%r8
jne    8e0 <gsl_permute_long_double_inverse+0x10>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_permute_long_double_inverse (const size_t * p, long double * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        long double t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                long double r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 18
3 4
4 4
5 4
6 6
7 7
8 7
9 7
10 8
11 7
12 7
13 9
14 9
15 11
16 12
17 12
18 18
19 18
20 23
21 23
22 28
23 23
24 19
25 23
26 23
27 24
28 19
29 31
30 31
31 31
32 4
33 4
34 4
35 35
36 35
37 35
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
mov    %rbp,%rsi
push   %rbx
mov    0x10(%rdi),%rdi
mov    %rdx,%rbx
callq  18 <des_compat_des3_decrypt+0x18>
mov    0x8(%r12),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  2b <des_compat_des3_decrypt+0x2b>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    (%r12),%rdi
pop    %r12
jmpq   41 <des_compat_des3_decrypt+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
des_compat_des3_decrypt(struct des_compat_des3 *ctx,
   uint32_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_des_decrypt(ctx->keys[2], length, dst, src);
  nettle_des_encrypt(ctx->keys[1], length, dst, dst);
  nettle_des_decrypt(ctx->keys[0], length, dst, dst);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 6
21 7
22 6
23 6
<<<sep_out_sample>>>
cmp    %si,(%rdi)
mov    $0xffffffff,%eax
jne    146 <udf_checktag+0x46>
movzbl 0x4(%rdi),%edx
movzbl (%rdi),%eax
sub    %edx,%eax
add    0x1(%rdi),%al
add    0x2(%rdi),%al
add    0x3(%rdi),%al
add    %edx,%eax
add    0x5(%rdi),%al
add    0x6(%rdi),%al
add    0x7(%rdi),%al
add    0x8(%rdi),%al
add    0x9(%rdi),%al
add    0xa(%rdi),%al
add    0xb(%rdi),%al
add    0xc(%rdi),%al
add    0xd(%rdi),%al
add    0xe(%rdi),%al
cmp    %al,%dl
setne  %al
movzbl %al,%eax
neg    %eax
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
udf_checktag(const udf_tag_t *p_tag, udf_Uint16_t tag_id)
{
  uint8_t *itag;
  uint8_t i;
  uint8_t cksum = 0;
  itag = (uint8_t *)p_tag;
  if (p_tag->id != tag_id)
    return -1;
  for (i = 0; i < 15; i++)
    cksum = cksum + itag[i];
  cksum = cksum - itag[4];
  if (cksum == p_tag->cksum)
    return 0;
  return -1;
}
<<<sep_in_sample>>>
1 7
2 8
3 7
4 11
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 11
21 12
22 12
23 12
24 12
25 15
26 15
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
mov    %rcx,%rsi
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  260 <cdio_charset_to_utf8+0x20>
mov    %r13,%rcx
mov    %rax,%rbx
mov    %r12d,%edx
mov    %rbp,%rsi
xor    %r8d,%r8d
mov    %rax,%rdi
callq  0 <do_convert>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  281 <cdio_charset_to_utf8+0x41>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cdio_charset_to_utf8(const char *src, size_t src_len, cdio_utf8_t **dst,
                          const char * src_charset)
  {
  iconv_t ic;
  unsigned char result;
  ic = iconv_open("UTF-8", src_charset);
  result = do_convert(ic, src, src_len, dst, ((void *)0));
  iconv_close(ic);
  return result;
  }
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 3
7 3
8 6
9 3
10 3
11 6
12 7
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 7
21 8
22 10
23 10
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 166 <tty_istrapsig+0x6>
and    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_istrapsig (void)
{
  return termbuf.c_lflag & 0000001;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    0x0(%rip),%rsi        # a <__gmp_vprintf+0xa>
mov    %rdi,%rdx
mov    $0x0,%edi
jmpq   17 <__gmp_vprintf+0x17>
<<<sep_in_sample>>>
__gmp_vprintf (const char *fmt, va_list ap)
{
  return __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    2c38 <gsl_matrix_int_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,4),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c5a <gsl_matrix_int_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_superdiagonal (gsl_matrix_int * m,
                                      const size_t k)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
mov    $0xa,%eax
sub    $0x8,%rsp
or     %edi,0x0(%rip)        # f <__gmp_exception+0xf>
cltd   
idivl  0x0(%rip)        # 16 <__gmp_exception+0x16>
mov    %eax,0x0(%rip)        # 1c <__gmp_exception+0x1c>
callq  21 <__gmp_exception+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmp_exception (int error_bit)
{
  __gmp_errno |= error_bit;
  __gmp_junk = 10 / __gmp_0;
  abort ();
}
<<<sep_in_sample>>>
1 4
2 2
3 3
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
movzbl (%rax),%edx
mov    0x0(%rip),%rax        # 9ed <addfunction+0xd>
and    $0x7f,%edx
mov    (%rax,%rdx,8),%rcx
mov    %rcx,0x80(%rdi)
mov    %rdi,(%rax,%rdx,8)
retq   
<<<sep_in_sample>>>
addfunction(struct func *newfunc)
{
  int val;
  val = (*(newfunc->name) & 127);
  newfunc->next = ftab[val];
  ftab[val] = newfunc;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
mov    0xc(%rdi),%eax
mov    %eax,0x14(%rdi)
mov    0x10(%rdi),%eax
mov    %eax,0x18(%rdi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
coproc_fdsave (cp)
     struct coproc *cp;
{
  cp->c_rsave = cp->c_rfd;
  cp->c_wsave = cp->c_wfd;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
fldt   -0x18(%rsp)
retq   
<<<sep_in_sample>>>
gsl_coerce_long_double (const long double x)
{
  volatile long double y;
  y = x;
  return y;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 27c <StoreDelayed+0xc>
add    $0x1,%eax
cmp    $0x3e8,%eax
je     2f0 <StoreDelayed+0x80>
mov    %eax,0x0(%rip)        # 28c <StoreDelayed+0x1c>
cltq   
shl    $0x3,%rax
mov    0x0(%rip),%rdx        # 299 <StoreDelayed+0x29>
xor    %ebx,%ebx
movsd  %xmm0,(%rdx,%rax,1)
jmp    2da <StoreDelayed+0x6a>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 2af <StoreDelayed+0x3f>
cmpq   $0x0,(%rax,%rbx,8)
je     2d6 <StoreDelayed+0x66>
mov    0x0(%rip),%rax        # 2bd <StoreDelayed+0x4d>
movslq 0x0(%rip),%rdx        # 2c4 <StoreDelayed+0x54>
movsd  0x0(,%rbp,8),%xmm0
mov    (%rax,%rbx,8),%rax
movsd  %xmm0,(%rax,%rdx,8)
add    $0x1,%rbx
callq  2df <StoreDelayed+0x6f>
cmp    %eax,%ebx
movslq %ebx,%rbp
jl     2a8 <StoreDelayed+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
movl   $0x0,0x0(%rip)        # 2fa <StoreDelayed+0x8a>
xor    %eax,%eax
jmp    292 <StoreDelayed+0x22>
<<<sep_in_sample>>>
StoreDelayed (double t)
{
  int i;
  iCurrentTime++;
  if (iCurrentTime == 1000)
    iCurrentTime = 0;
  rgdTime[iCurrentTime] = t;
  for (i = 0; i < GetNModelVars(); i++)
    if (rgiVars[i]) {
      pdVar[i][iCurrentTime] = vrgModelVars[i];
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 4
9 4
10 4
11 7
12 8
13 7
14 8
15 8
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 10
25 8
26 8
27 8
28 8
29 12
30 12
31 12
32 12
33 12
34 6
35 6
36 6
<<<sep_out_sample>>>
mov    (%rdi),%r10
movsd  %xmm0,-0x8(%rsp)
mov    0x18(%rdi),%rdx
mov    -0x8(%rsp),%rsi
mov    0x8(%rdi),%r9
movsd  %xmm1,-0x8(%rsp)
mov    0x10(%rdi),%r11
test   %r10,%r10
mov    -0x8(%rsp),%r8
je     c3e <gsl_matrix_complex_set_all+0x6e>
mov    %r9,%rcx
shl    $0x4,%r11
xor    %edi,%edi
shl    $0x4,%rcx
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     c32 <gsl_matrix_complex_set_all+0x62>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    %rsi,(%rdx,%rax,1)
mov    %r8,0x8(%rdx,%rax,1)
add    $0x10,%rax
cmp    %rcx,%rax
jne    c20 <gsl_matrix_complex_set_all+0x50>
add    $0x1,%rdi
add    %r11,%rdx
cmp    %r10,%rdi
jne    c10 <gsl_matrix_complex_set_all+0x40>
repz retq 
<<<sep_in_sample>>>
gsl_matrix_complex_set_all (gsl_matrix_complex * m, gsl_complex x)
{
  size_t i, j;
  double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex *) (data + 2 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 2
3 4
4 2
5 6
6 2
7 7
8 8
9 2
10 8
11 8
12 8
13 8
14 8
15 8
16 10
17 10
18 10
19 10
20 12
21 12
22 12
23 10
24 10
25 8
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_trapped (sig)
     int sig;
{
  return (sigmodes[sig] & 0x1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    0x0(%rip),%r12        # 7b13 <getuser_noreadline+0x13>
push   %rbp
mov    0x0(%rip),%rbp        # 7b1b <getuser_noreadline+0x1b>
push   %rbx
mov    %rdi,%rbx
nop
mov    (%r12),%rsi
mov    %r13,%rdi
callq  7b2c <getuser_noreadline+0x2c>
mov    0x0(%rbp),%rdx
xor    %ecx,%ecx
mov    %r14,%rsi
mov    %rbx,%rdi
callq  7b3d <getuser_noreadline+0x3d>
test   %rax,%rax
je     7b7a <getuser_noreadline+0x7a>
mov    (%rbx),%rdi
callq  7b4a <getuser_noreadline+0x4a>
test   %eax,%eax
js     7b60 <getuser_noreadline+0x60>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 7b67 <getuser_noreadline+0x67>
lea    0x0(%rip),%rdi        # 7b6e <getuser_noreadline+0x6e>
mov    (%rax),%rsi
xor    %eax,%eax
callq  7b78 <getuser_noreadline+0x78>
jmp    7b20 <getuser_noreadline+0x20>
mov    0x0(%rip),%rax        # 7b81 <getuser_noreadline+0x81>
mov    0x8(%rax),%eax
test   %eax,%eax
je     7b8f <getuser_noreadline+0x8f>
xor    %edi,%edi
callq  7b8f <getuser_noreadline+0x8f>
mov    $0xa,%edi
callq  7b99 <getuser_noreadline+0x99>
jmp    7b88 <getuser_noreadline+0x88>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getuser_noreadline(char **buffer, int *bufsize, const char *query)
{
  int valid = 0;
  while(!valid){
    fputs(query, stdout);
    if (!fgetslong(buffer, bufsize, stdin,0)){
      if (!flags.quiet)
        putchar('\n');
      exit(0);
    }
    valid = strwidth(*buffer)>=0;
    if (!valid)
      printf("Error: %s\n",invalid_utf8);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 11
23 11
24 12
25 12
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 13
34 13
35 13
36 13
37 13
38 13
39 7
40 7
41 7
42 7
43 9
44 9
45 8
46 8
47 8
48 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    0x8(%rdi),%rax
je     550 <gsl_linalg_QR_svx+0x40>
mov    $0x14,%ecx
mov    $0x93,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  53b <gsl_linalg_QR_svx+0x2b>
mov    $0x14,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmp    (%rdx),%rax
mov    %rdx,%rbp
je     580 <gsl_linalg_QR_svx+0x70>
mov    $0x13,%ecx
mov    $0x97,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  571 <gsl_linalg_QR_svx+0x61>
add    $0x8,%rsp
mov    $0x13,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
callq  585 <gsl_linalg_QR_svx+0x75>
mov    %rbp,%r8
mov    %rbx,%rcx
mov    $0x83,%edx
mov    $0x6f,%esi
mov    $0x79,%edi
callq  59f <gsl_linalg_QR_svx+0x8f>
xor    %eax,%eax
jmp    540 <gsl_linalg_QR_svx+0x30>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_linalg_QR_svx (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * x)
{
  if (QR->size1 != QR->size2)
    {
      do { gsl_error ("QR matrix must be square", "qr.c", 147, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (QR->size1 != x->size)
    {
      do { gsl_error ("matrix size must match x/rhs size", "qr.c", 151, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      gsl_linalg_QR_QTvec (QR, tau, x);
      gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, QR, x);
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 5
14 17
15 17
16 17
17 17
18 17
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 17
28 9
29 17
30 17
31 17
32 17
33 13
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
<<<sep_out_sample>>>
mov    %rdi,%rcx
mov    0x0(%rip),%rdi        # 64a <pty_input_putback+0xa>
mov    $0x0,%eax
push   %rbx
sub    %rdi,%rax
cmp    %rax,%rsi
cmovbe %rsi,%rax
mov    %rcx,%rsi
mov    %rax,%rdx
mov    %rax,%rbx
callq  668 <pty_input_putback+0x28>
add    %ebx,0x0(%rip)        # 66e <pty_input_putback+0x2e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pty_input_putback (const char *str, size_t len)
{
  if (len > (size_t) (&ptyibuf[8192] - ptyip))
    len = &ptyibuf[8192] - ptyip;
  strncpy (ptyip, str, len);
  pcc += len;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 6
13 8
14 8
15 8
16 8
<<<sep_out_sample>>>
mov    %esi,%esi
jmpq   22d7 <yyrealloc+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyrealloc (void * ptr, yy_size_t size )
{
 return (void *) realloc( (char *) ptr, size );
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 217 <dirwatcher_lookup+0x7>
test   %rax,%rax
je     260 <dirwatcher_lookup+0x50>
sub    $0x58,%rsp
lea    0x10(%rsp),%rdx
mov    %rdi,0x20(%rsp)
mov    %rsp,%rsi
mov    %rax,%rdi
mov    %rdx,0x8(%rsp)
xor    %edx,%edx
callq  23c <dirwatcher_lookup+0x2c>
test   %rax,%rax
je     250 <dirwatcher_lookup+0x40>
mov    0x8(%rax),%rax
add    $0x58,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x58,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dirwatcher_lookup(const char *dirname)
{
 struct dirwatcher dwkey;
 struct dwref key;
 struct dwref *ent;
 if (!texttab)
  return ((void *)0);
 dwkey.dirname = (char*) dirname;
 key.dw = &dwkey;
 ent = hashtab_lookup_or_install(texttab, &key, ((void *)0));
 return ent ? ent->dw : ((void *)0);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 2
5 9
6 8
7 10
8 10
9 9
10 10
11 10
12 11
13 11
14 11
15 12
16 12
17 12
18 7
19 12
20 12
21 12
22 7
23 12
24 12
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rdx
mov    %r9,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rbx),%r8
mov    (%rbx),%rsi
mov    0x8(%rdi),%rdi
callq  cf <polynomial_deriv+0x1f>
mov    0x8(%rbx),%rax
movsd  0x8(%rax),%xmm0
xor    %eax,%eax
movsd  %xmm0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
polynomial_deriv (const void *vstate,
                  const double xa[], const double ya[], size_t size, double x,
                  gsl_interp_accel * acc, double *y)
{
  const polynomial_state_t *state = (const polynomial_state_t *) vstate;
  gsl_poly_dd_taylor (state->coeff, x, state->d, xa, size, state->work);
  *y = state->coeff[1];
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 9
14 7
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    %rdx,%r8
mov    0x8(%rsi),%rcx
mov    (%rax),%rdx
mov    0x10(%rsi),%rsi
jmpq   556 <gsl_vector_ushort_fprintf+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fprintf (FILE * stream, const gsl_vector_ushort * v,
                                const char *format)
{
  int status = gsl_block_ushort_raw_fprintf (stream,
                                                  v->data,
                                                  v->size,
                                                  v->stride,
                                                  format);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edx,%ecx
xor    %eax,%eax
mov    %rsi,%rdx
mov    $0x0,%esi
callq  c05 <CDB___db_unknown_flag+0x15>
mov    $0x16,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
CDB___db_unknown_flag(dbenv, routine, flag)
 DB_ENV *dbenv;
 char *routine;
 u_int32_t flag;
{
 CDB___db_err(dbenv, "%s: Unknown flag: 0x%x", routine, flag);
 ((void)0);
 return (22);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 6
6 6
7 9
8 9
9 9
10 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0xf,%sil
jne    1b4 <openssl_aes_encrypt+0x54>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     1a9 <openssl_aes_encrypt+0x49>
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x1,%ecx
mov    %r13,%rdx
add    $0x10,%rbp
add    $0x10,%r12
callq  1a3 <openssl_aes_encrypt+0x43>
sub    $0x10,%rbx
jne    188 <openssl_aes_encrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0x69,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1cd <openssl_aes_encrypt+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
openssl_aes_encrypt(const void *ctx, size_t length,
      uint8_t *dst, const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "nettle-openssl.c", 105, __PRETTY_FUNCTION__));
  while (length)
    {
      AES_ecb_encrypt(src, dst, ctx, 1);
      length -= 16;
      dst += 16;
      src += 16;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # b0 <gsl_complex_logabs+0x10>
andpd  %xmm0,%xmm2
andpd  %xmm1,%xmm0
ucomisd %xmm0,%xmm2
jae    100 <gsl_complex_logabs+0x60>
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm1
movsd  %xmm1,0x8(%rsp)
callq  d1 <gsl_complex_logabs+0x31>
movsd  0x8(%rsp),%xmm1
movsd  %xmm0,(%rsp)
movapd %xmm1,%xmm3
mulsd  %xmm1,%xmm3
movapd %xmm3,%xmm0
callq  ed <gsl_complex_logabs+0x4d>
mulsd  0x0(%rip),%xmm0        # f5 <gsl_complex_logabs+0x55>
addsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
nop
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
divsd  %xmm2,%xmm1
jmp    c6 <gsl_complex_logabs+0x26>
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_complex_logabs (gsl_complex z)
{
  double xabs = fabs (((z).dat[0]));
  double yabs = fabs (((z).dat[1]));
  double max, u;
  if (xabs >= yabs)
    {
      max = xabs;
      u = yabs / xabs;
    }
  else
    {
      max = yabs;
      u = xabs / yabs;
    }
  return log (max) + 0.5 * log1p (u * u);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 6
7 6
8 14
9 14
10 14
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 17
21 17
22 17
23 9
24 8
25 9
26 9
27 9
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x10,%esi
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e3 <_rl_vi_callback_char_search+0x13>
test   %eax,%eax
mov    %eax,0x0(%rip)        # eb <_rl_vi_callback_char_search+0x1b>
jle    128 <_rl_vi_callback_char_search+0x58>
mov    (%rbx),%edi
andq   $0xffffffffff7fffff,0x0(%rip)        # fa <_rl_vi_callback_char_search+0x2a>
mov    %eax,%ecx
pop    %rbx
mov    0x0(%rip),%esi        # 103 <_rl_vi_callback_char_search+0x33>
mov    $0x0,%edx
movq   $0x0,0x0(%rip)        # 113 <_rl_vi_callback_char_search+0x43>
movl   $0x1,0x0(%rip)        # 11d <_rl_vi_callback_char_search+0x4d>
jmpq   122 <_rl_vi_callback_char_search+0x52>
nopw   0x0(%rax,%rax,1)
mov    $0xffffffff,%eax
andq   $0xffffffffff7fffff,0x0(%rip)        # 138 <_rl_vi_callback_char_search+0x68>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_callback_char_search (data)
     _rl_callback_generic_arg *data;
{
  int c;
  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, 16);
  if (c <= 0)
    {
      (rl_readline_state &= ~(0x0800000));
      return -1;
    }
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  (rl_readline_state &= ~(0x0800000));
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 6
7 5
8 6
9 14
10 13
11 14
12 15
13 14
14 14
15 11
16 12
17 14
18 14
19 15
20 8
21 15
22 15
23 15
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_get_version (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->version;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_kernel (mu_locker_t locker)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
test   %rdx,%rdx
fldt   (%rdi)
je     f0 <gsl_stats_long_double_min+0x70>
shl    $0x4,%rsi
xor    %ebx,%ebx
mov    %rsi,%r13
lea    (%rdi,%rsi,1),%rbp
fld    %st(0)
jmp    c3 <gsl_stats_long_double_min+0x43>
nopl   (%rax)
fstp   %st(0)
add    $0x1,%rbx
cmp    %r12,%rbx
fldt   0x20(%rsp)
je     f0 <gsl_stats_long_double_min+0x70>
fldt   0x0(%rbp)
fxch   %st(1)
fucomi %st(1),%st
fcmovnbe %st(1),%st
add    %r13,%rbp
fstpt  0x20(%rsp)
fld    %st(0)
fstpt  (%rsp)
fstpt  0x10(%rsp)
callq  d5 <gsl_stats_long_double_min+0x55>
test   %eax,%eax
fldt   0x10(%rsp)
je     a8 <gsl_stats_long_double_min+0x28>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_min (const long double data[], const size_t stride,
                          const size_t n)
{
  long double min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      long double xi = data[i * stride];
      if (xi < min)
        min = xi;
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        return xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 4
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 6
19 6
20 6
21 6
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     2251 <gsl_matrix_short_fwrite+0x91>
lea    (%r15,%r15,1),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    220e <gsl_matrix_short_fwrite+0x4e>
jmp    2240 <gsl_matrix_short_fwrite+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     2240 <gsl_matrix_short_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  2225 <gsl_matrix_short_fwrite+0x65>
test   %eax,%eax
je     2200 <gsl_matrix_short_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   2274 <gsl_matrix_short_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_fwrite (FILE * stream, const gsl_matrix_short * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_short_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_short_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     46f <gsl_vector_int_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  465 <gsl_vector_int_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     4a3 <gsl_vector_int_memcpy+0x63>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%esi
add    $0x1,%rax
add    %r10,%rcx
mov    %esi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    490 <gsl_vector_int_memcpy+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_memcpy (gsl_vector_int * dest,
                               const gsl_vector_int * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,0x9(%rdi)
mov    %rdi,%rbx
je     750 <get_first_track_num_generic+0x10>
movzbl 0x1c(%rbx),%eax
pop    %rbx
retq   
mov    0x1020(%rdi),%rax
callq  *0x158(%rax)
cmpb   $0x0,0x9(%rbx)
jne    74a <get_first_track_num_generic+0xa>
mov    $0xffffffff,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_first_track_num_generic(void *p_user_data)
{
  const generic_img_private_t *p_env = p_user_data;
  if (!p_env->toc_init)
    p_env->cdio->op.read_toc (p_user_data);
  return p_env->toc_init ? p_env->i_first_track : CDIO_INVALID_TRACK;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 6
6 7
7 7
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rdx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    %rax,%rsi
lea    0x70(%rdx),%rdi
callq  86 <hdr_destroy+0x16>
mov    %rbx,%rdi
callq  8e <hdr_destroy+0x1e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hdr_destroy (mu_iterator_t iterator, void *data)
{
  struct header_iterator *itr = data;
  mu_iterator_detach (&itr->header->itr, iterator);
  free (data);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
movaps 0x0(%rip),%xmm0        # 607 <hash_reset_tuning+0x7>
movb   $0x0,0x10(%rdi)
movlps %xmm0,(%rdi)
movhps %xmm0,0x8(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_reset_tuning (Hash_tuning *tuning)
{
  *tuning = default_tuning;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2137 <afmget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmget_out (void)
{
        return afmout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x68,%rsp
mov    0x40(%rdi),%rax
movq   $0x1,0x40(%rsp)
mov    %rdi,0x58(%rsp)
mov    0x40(%rsp),%rcx
test   %rax,%rax
je     146e <rec_sex_ast_node_unfix+0x2ae>
mov    0x58(%rsp),%rsi
mov    0x20(%rsi,%rcx,8),%rsi
mov    0x40(%rsi),%rdx
mov    %rsi,0x30(%rsp)
test   %rdx,%rdx
je     144f <rec_sex_ast_node_unfix+0x28f>
movq   $0x1,0x48(%rsp)
mov    0x48(%rsp),%rcx
mov    %rdx,%rax
mov    0x30(%rsp),%rsi
mov    0x20(%rsi,%rcx,8),%rsi
mov    0x40(%rsi),%rdx
mov    %rsi,0x38(%rsp)
test   %rdx,%rdx
je     1422 <rec_sex_ast_node_unfix+0x262>
movq   $0x1,0x50(%rsp)
mov    0x50(%rsp),%rsi
mov    0x38(%rsp),%rax
mov    0x20(%rax,%rsi,8),%rax
mov    %rax,0x28(%rsp)
mov    0x40(%rax),%rax
test   %rax,%rax
je     13f2 <rec_sex_ast_node_unfix+0x232>
movq   $0x1,0x20(%rsp)
mov    0x20(%rsp),%rcx
mov    0x28(%rsp),%rsi
mov    0x20(%rsi,%rcx,8),%rsi
mov    0x40(%rsi),%rdx
mov    %rsi,0x18(%rsp)
test   %rdx,%rdx
je     13c5 <rec_sex_ast_node_unfix+0x205>
movq   $0x1,0x10(%rsp)
mov    0x10(%rsp),%rsi
mov    0x18(%rsp),%rax
mov    0x20(%rax,%rsi,8),%rax
mov    %rax,0x8(%rsp)
mov    0x40(%rax),%rax
test   %rax,%rax
je     1395 <rec_sex_ast_node_unfix+0x1d5>
movq   $0x1,(%rsp)
mov    (%rsp),%rcx
mov    0x8(%rsp),%rsi
mov    0x20(%rsi,%rcx,8),%r13
mov    0x40(%r13),%rdx
test   %rdx,%rdx
je     136d <rec_sex_ast_node_unfix+0x1ad>
mov    $0x1,%r12d
mov    0x20(%r13,%r12,8),%r15
mov    0x40(%r15),%rax
test   %rax,%rax
je     1344 <rec_sex_ast_node_unfix+0x184>
mov    $0x1,%r14d
mov    0x20(%r15,%r14,8),%rbp
cmpq   $0x0,0x40(%rbp)
je     1324 <rec_sex_ast_node_unfix+0x164>
mov    $0x1,%ebx
mov    0x20(%rbp,%rbx,8),%rdi
callq  130d <rec_sex_ast_node_unfix+0x14d>
cmp    0x40(%rbp),%rbx
lea    0x1(%rbx),%rax
jae    1320 <rec_sex_ast_node_unfix+0x160>
mov    %rax,%rbx
jmp    1303 <rec_sex_ast_node_unfix+0x143>
nopl   0x0(%rax)
mov    0x40(%r15),%rax
cmp    %rax,%r14
movb   $0x0,0x1c(%rbp)
lea    0x1(%r14),%rdx
jae    1340 <rec_sex_ast_node_unfix+0x180>
mov    %rdx,%r14
jmp    12f2 <rec_sex_ast_node_unfix+0x132>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x40(%r13),%rdx
cmp    %rdx,%r12
movb   $0x0,0x1c(%r15)
lea    0x1(%r12),%rax
jae    1360 <rec_sex_ast_node_unfix+0x1a0>
mov    %rax,%r12
jmp    12de <rec_sex_ast_node_unfix+0x11e>
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rax
mov    (%rsp),%rcx
mov    0x40(%rax),%rax
cmp    %rax,%rcx
movb   $0x0,0x1c(%r13)
lea    0x1(%rcx),%rdx
jae    1387 <rec_sex_ast_node_unfix+0x1c7>
mov    %rdx,(%rsp)
mov    %rdx,%rcx
jmpq   12c1 <rec_sex_ast_node_unfix+0x101>
mov    0x18(%rsp),%rax
mov    0x10(%rsp),%rsi
mov    0x40(%rax),%rdx
mov    0x8(%rsp),%rax
movb   $0x0,0x1c(%rax)
mov    %rsi,%rax
add    $0x1,%rax
cmp    %rdx,%rsi
jae    13b7 <rec_sex_ast_node_unfix+0x1f7>
mov    %rax,0x10(%rsp)
mov    %rax,%rsi
jmpq   1299 <rec_sex_ast_node_unfix+0xd9>
mov    0x28(%rsp),%rax
mov    0x18(%rsp),%rsi
mov    0x40(%rax),%rax
movb   $0x0,0x1c(%rsi)
mov    0x20(%rsp),%rsi
cmp    %rax,%rsi
lea    0x1(%rsi),%rdx
jae    13e4 <rec_sex_ast_node_unfix+0x224>
mov    %rdx,0x20(%rsp)
mov    %rdx,%rcx
jmpq   126f <rec_sex_ast_node_unfix+0xaf>
mov    0x38(%rsp),%rax
mov    0x50(%rsp),%rsi
mov    0x40(%rax),%rdx
mov    0x28(%rsp),%rax
movb   $0x0,0x1c(%rax)
mov    %rsi,%rax
add    $0x1,%rax
cmp    %rdx,%rsi
jae    1414 <rec_sex_ast_node_unfix+0x254>
mov    %rax,0x50(%rsp)
mov    %rax,%rsi
jmpq   1245 <rec_sex_ast_node_unfix+0x85>
mov    0x30(%rsp),%rax
mov    0x38(%rsp),%rsi
mov    0x40(%rax),%rax
movb   $0x0,0x1c(%rsi)
mov    0x48(%rsp),%rsi
cmp    %rax,%rsi
lea    0x1(%rsi),%rdx
jae    1441 <rec_sex_ast_node_unfix+0x281>
mov    %rdx,0x48(%rsp)
mov    %rdx,%rcx
jmpq   121b <rec_sex_ast_node_unfix+0x5b>
mov    0x58(%rsp),%rax
mov    0x30(%rsp),%rsi
mov    0x40(%rax),%rax
movb   $0x0,0x1c(%rsi)
mov    0x40(%rsp),%rsi
cmp    %rax,%rsi
lea    0x1(%rsi),%rdx
jae    146e <rec_sex_ast_node_unfix+0x2ae>
mov    %rdx,0x40(%rsp)
mov    %rdx,%rcx
jmpq   11ee <rec_sex_ast_node_unfix+0x2e>
mov    0x58(%rsp),%rax
movb   $0x0,0x1c(%rax)
add    $0x68,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_unfix (rec_sex_ast_node_t node)
{
  int i;
  for (i = 0; i < node->num_children; i++)
    {
      rec_sex_ast_node_unfix (node->children[i]);
    }
  node->fixed = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 2
11 2
12 4
13 4
14 6
15 6
16 4
17 6
18 4
19 4
20 4
21 4
22 4
23 6
24 6
25 4
26 6
27 4
28 4
29 4
30 4
31 6
32 6
33 6
34 4
35 4
36 4
37 4
38 4
39 6
40 6
41 4
42 6
43 4
44 4
45 4
46 4
47 6
48 6
49 6
50 4
51 4
52 4
53 4
54 4
55 6
56 6
57 4
58 4
59 4
60 4
61 6
62 4
63 4
64 4
65 4
66 6
67 4
68 4
69 4
70 6
71 6
72 4
73 4
74 4
75 4
76 4
77 4
78 4
79 4
80 8
81 8
82 4
83 4
84 4
85 4
86 4
87 4
88 8
89 8
90 4
91 4
92 4
93 4
94 4
95 4
96 4
97 4
98 8
99 8
100 4
101 4
102 4
103 4
104 4
105 4
106 4
107 8
108 8
109 8
110 8
111 4
112 4
113 4
114 4
115 4
116 4
117 4
118 4
119 8
120 8
121 4
122 4
123 4
124 4
125 4
126 4
127 4
128 4
129 4
130 8
131 8
132 8
133 8
134 4
135 4
136 4
137 4
138 4
139 4
140 4
141 4
142 8
143 8
144 4
145 4
146 4
147 4
148 4
149 4
150 4
151 4
152 4
153 8
154 8
155 4
156 4
157 4
158 4
159 4
160 4
161 8
162 8
163 9
164 9
165 9
166 9
167 9
168 9
169 9
170 9
171 9
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rdx        # f59 <freelist+0x9>
mov    %edi,%r12d
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # f65 <freelist+0x15>
mov    (%rbx),%eax
cmp    (%rdx),%eax
jle    f6d <freelist+0x1d>
mov    %eax,(%rdx)
cmp    %r12d,%eax
jle    fa5 <freelist+0x55>
mov    0x0(%rip),%rbp        # f79 <freelist+0x29>
nopl   0x0(%rax)
sub    $0x1,%eax
mov    %eax,(%rbx)
cltq   
mov    0x0(%rbp,%rax,8),%rdi
callq  f91 <freelist+0x41>
movslq (%rbx),%rax
mov    0x0(%rbp,%rax,8),%rdi
callq  f9e <freelist+0x4e>
mov    (%rbx),%eax
cmp    %r12d,%eax
jg     f80 <freelist+0x30>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
freelist(int startunit)
{
  if (nextunit>maxunit)
    maxunit = nextunit;
  while(nextunit>startunit){
    freeunit(memtable[--nextunit]);
    free(memtable[nextunit]);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 5
24 5
25 5
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
movsd  0x58(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trust_avratio(void *vstate)
{
  trust_state_t *state = (trust_state_t *) vstate;
  return state->avratio;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     c9 <mu_attribute_clear_modified+0x9>
andl   $0xffffffbf,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_attribute_clear_modified (mu_attribute_t attr)
{
  if (attr)
    attr->flags &= ~0x40;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %rbp
mov    $0xe58,%edx
mov    %edi,%ebp
mov    $0x0,%esi
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  18c <vlist_alloc+0x1c>
lea    0x1(%rbp),%edi
mov    %rax,%rbx
mov    $0xe59,%edx
mov    $0x0,%esi
movslq %edi,%rdi
shl    $0x3,%rdi
callq  1a8 <vlist_alloc+0x38>
mov    %ebp,0x8(%rbx)
mov    %rax,(%rbx)
movl   $0x0,0xc(%rbx)
movq   $0x0,(%rax)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vlist_alloc (nentries)
     int nentries;
{
  VARLIST *vlist;
  vlist = (VARLIST *)sh_xmalloc((sizeof (VARLIST)), "variables.c", 3672);
  vlist->list = (SHELL_VAR **)sh_xmalloc(((nentries + 1) * sizeof (SHELL_VAR *)), "variables.c", 3673);
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)((void *)0);
  return vlist;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 3
7 3
8 5
9 6
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 6
18 8
19 9
20 11
21 11
22 11
23 11
24 11
25 11
<<<sep_out_sample>>>
push   %rbx
lea    0x0(%rip),%rsi        # a828 <checklocale+0x8>
xor    %edi,%edi
callq  a82f <checklocale+0xf>
mov    $0xe,%edi
mov    %rax,%rbx
callq  a83c <checklocale+0x1c>
lea    0x0(%rip),%rdi        # a843 <checklocale+0x23>
mov    %rax,%rsi
mov    $0x6,%ecx
mov    0x0(%rip),%rax        # a852 <checklocale+0x32>
repz cmpsb %es:(%rdi),%ds:(%rsi)
sete   %dl
test   %rbx,%rbx
movzbl %dl,%edx
mov    %edx,(%rax)
je     a890 <checklocale+0x70>
mov    %rbx,%rdi
callq  a869 <checklocale+0x49>
mov    0x0(%rip),%rdx        # a870 <checklocale+0x50>
mov    $0x2e,%esi
mov    %rax,%rdi
mov    %rax,(%rdx)
callq  a880 <checklocale+0x60>
test   %rax,%rax
je     a888 <checklocale+0x68>
movb   $0x0,(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # a897 <checklocale+0x77>
lea    0x0(%rip),%rcx        # a89e <checklocale+0x7e>
mov    %rcx,(%rax)
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
checklocale()
{
  char *temp;
  temp = setlocale(0,"");
  utf8mode = (strcmp(nl_langinfo(CODESET),"UTF-8")==0);
  if (temp){
    mylocale = dupstr(temp);
    temp = strchr(mylocale,'.');
    if (temp)
      *temp = 0;
  } else
    mylocale = "en_US";
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 5
16 5
17 6
18 7
19 7
20 7
21 8
22 8
23 7
24 8
25 9
26 9
27 10
28 13
29 13
30 13
31 12
32 12
33 12
34 13
35 13
36 13
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  24 <rec_field_set_name+0x14>
mov    %rbp,%rdi
callq  2c <rec_field_set_name+0x1c>
test   %rax,%rax
mov    %rax,(%rbx)
setne  %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_field_set_name (rec_field_t field, const char *name)
{
  free (field->name);
  field->name = strdup (name);
  return (field->name != ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 4
12 5
13 6
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
callq  beb <emit_bug_reporting_address+0xb>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  bfa <emit_bug_reporting_address+0x1a>
mov    $0x0,%edi
callq  c04 <emit_bug_reporting_address+0x24>
mov    $0x0,%esi
mov    %rax,%rdi
mov    $0x0,%edx
xor    %eax,%eax
callq  c18 <emit_bug_reporting_address+0x38>
mov    0x0(%rip),%rbx        # c1f <emit_bug_reporting_address+0x3f>
mov    $0x0,%edi
callq  c29 <emit_bug_reporting_address+0x49>
mov    %rax,%rdi
mov    %rbx,%rsi
pop    %rbx
jmpq   c35 <emit_bug_reporting_address+0x55>
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  printf (gettext ("\nReport bugs to: %s\n"), "bug-libidn@gnu.org");
  printf (gettext ("%s home page: <%s>\n"), "GNU Libidn", "http://www.gnu.org/software/libidn/");
  fputs (gettext ("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),
         stdout);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
20 7
21 5
<<<sep_out_sample>>>
push   %r14
push   %rbx
sub    $0x138,%rsp
mov    0x10(%rdx),%rax
mov    %rsi,0x8(%rsp)
mov    %edi,0x10(%rsp)
movl   $0x0,0x30(%rsp)
movq   $0x0,0x38(%rsp)
mov    %rax,0x18(%rsp)
mov    (%rsi),%rax
mov    %r8,0x20(%rsp)
mov    %rcx,0x28(%rsp)
mov    %rax,0x108(%rsp)
mov    0x8(%rsi),%rax
mov    %rax,0x110(%rsp)
mov    0x10(%rsi),%rax
mov    %rax,0x118(%rsp)
mov    0xc(%rdx),%eax
test   %eax,%eax
mov    %eax,0x120(%rsp)
jne    5b58 <eval_section+0x98>
lea    0x40(%rsp),%rdi
callq  5b32 <eval_section+0x72>
test   %eax,%eax
je     5b87 <eval_section+0xc7>
mov    0x38(%rsp),%rsi
test   %rsi,%rsi
je     5b4a <eval_section+0x8a>
mov    $0xffffffff,%edi
callq  5b4a <eval_section+0x8a>
add    $0x138,%rsp
pop    %rbx
pop    %r14
retq   
nopl   (%rax)
mov    0x20(%rsi),%rbx
mov    %rsi,%r14
mov    $0x0,%edi
callq  5b69 <eval_section+0xa9>
mov    %r14,%rdi
mov    %rax,%rsi
xor    %eax,%eax
mov    %rbx,%rdx
callq  5b79 <eval_section+0xb9>
lea    0x40(%rsp),%rdi
callq  5b83 <eval_section+0xc3>
test   %eax,%eax
jne    5b36 <eval_section+0x76>
mov    0x8(%rsp),%rax
lea    0x10(%rsp),%rdi
mov    0x28(%rax),%rsi
callq  5570 <stmt_list_eval>
jmp    5b36 <eval_section+0x76>
nopl   0x0(%rax)
<<<sep_in_sample>>>
eval_section (int method, RC_SECTION *sec, struct rc_secdef *secdef,
       void *data, MESSAGE msg)
{
  struct eval_env env;
  env.method = method;
  env.child = secdef->child;
  env.refcnt = 0;
  env.refstr = ((void *)0);
  env.msg = msg;
  env.data = data;
  env.loc = sec->loc;
  env.traceable = secdef->allow_prog;
  if (env.traceable)
    tracefile (&sec->loc, gettext("Section %s"), sec->name);
  if (_setjmp (env.jmp) == 0)
    stmt_list_eval (&env, sec->stmt);
  if (env.refstr)
    argcv_free (-1, env.refstr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 3
6 5
7 7
8 8
9 6
10 11
11 9
12 10
13 11
14 11
15 11
16 11
17 11
18 12
19 13
20 12
21 13
22 15
23 15
24 15
25 15
26 17
27 17
28 17
29 18
30 18
31 19
32 19
33 19
34 19
35 19
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 15
46 15
47 15
48 15
49 16
50 16
51 16
52 16
53 16
54 16
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     70f <gsl_matrix_complex_ispos+0x6f>
xorpd  %xmm0,%xmm0
shl    $0x4,%rax
xor    %esi,%esi
mov    %rax,%r10
xor    %r8d,%r8d
test   %rcx,%rcx
je     703 <gsl_matrix_complex_ispos+0x63>
mov    0x18(%rdi),%rax
ucomisd (%rax,%rsi,1),%xmm0
jae    718 <gsl_matrix_complex_ispos+0x78>
ucomisd 0x8(%rax,%rsi,1),%xmm0
jae    718 <gsl_matrix_complex_ispos+0x78>
lea    0x18(%rax,%rsi,1),%rax
xor    %edx,%edx
jmp    6fa <gsl_matrix_complex_ispos+0x5a>
nopl   0x0(%rax)
ucomisd -0x8(%rax),%xmm0
jae    718 <gsl_matrix_complex_ispos+0x78>
add    $0x10,%rax
ucomisd -0x10(%rax),%xmm0
jae    718 <gsl_matrix_complex_ispos+0x78>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    6e8 <gsl_matrix_complex_ispos+0x48>
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    6c0 <gsl_matrix_complex_ispos+0x20>
mov    $0x1,%eax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_ispos (const gsl_matrix_complex * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 13
7 13
8 7
9 7
10 7
11 9
12 9
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 9
28 9
29 9
30 7
31 7
32 7
33 7
34 20
35 20
36 20
37 15
38 21
39 21
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_accept_encoding_get_element (const osip_accept_encoding_t * ae)
{
  return ae->element;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2eb6 <cpp_get_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_get_lineno (void)
{
    return cpp_lineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
callq  75d <ds_unsafe_vsprintf+0xd>
mov    0x28(%rbx),%rdi
callq  766 <ds_unsafe_vsprintf+0x16>
mov    %rax,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_unsafe_vsprintf (struct dstring * ds, const char *format, va_list args)
{
  vsprintf (ds->content, format, args);
  ds->len = strlen (ds->content);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x48,%rsp
test   %rdi,%rdi
jne    356 <found_in_list+0x26>
jmp    3a0 <found_in_list+0x70>
nopl   0x0(%rax,%rax,1)
callq  34d <found_in_list+0x1d>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     3a0 <found_in_list+0x70>
mov    (%rbx),%rdi
callq  35e <found_in_list+0x2e>
mov    $0x1,%edx
mov    %rax,%rsi
mov    %rsp,%rdi
callq  36e <found_in_list+0x3e>
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    %rsp,%rdi
mov    %rbp,%rsi
callq  380 <found_in_list+0x50>
test   %eax,%eax
mov    %rsp,%rdi
jne    348 <found_in_list+0x18>
callq  38c <found_in_list+0x5c>
add    $0x48,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x48,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
found_in_list(regexlisttype *head, const char *shibboleth)
{
    regexlisttype *item;
    regex_t rgx;
    for (item = head; item != ((void *)0); item = item->next) {
 regcomp(&rgx, fixbounds(item->full_regex), 1);
 if (regexec(&rgx, shibboleth, 0, ((void *)0), 0) == 0) {
     regfree(&rgx);
     return 1;
 }
 regfree(&rgx);
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 11
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 8
28 7
29 8
30 14
31 9
32 14
33 14
34 14
35 14
36 14
37 13
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    5d00 <gsl_matrix_ulong_const_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,8),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  5d22 <gsl_matrix_ulong_const_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_const_row (const gsl_matrix_ulong * m, const size_t i)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
mov    %rsi,%r8
movabs $0x8000000080000001,%rdx
and    $0x3,%r8d
sub    $0x2,%r8
mov    %r8,%rax
mul    %rdx
mov    %esi,%eax
shr    $0x1f,%rdx
mov    %rdx,%rcx
shl    $0x20,%rcx
sub    %rdx,%rcx
mov    %r8,%rdx
sub    %rcx,%rdx
je     67 <ran_set+0x37>
mov    %esi,%eax
sub    %edx,%eax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
ran_set (void *vstate, unsigned long int s)
{
  ran_state_t *state = (ran_state_t *) vstate;
  unsigned long int diff = ((s % 4UL) - 2UL) % 0xffffffffUL;
  if (diff)
    state->x = (s - diff) & 0xffffffffUL;
  else
    state->x = s & 0xffffffffUL;
  return;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 8
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 5e7 <gsl_multilarge_nlinear_default_parameters+0x7>
movsd  0x0(%rip),%xmm0        # 5ef <gsl_multilarge_nlinear_default_parameters+0xf>
movsd  0x0(%rip),%xmm1        # 5f7 <gsl_multilarge_nlinear_default_parameters+0x17>
mov    %rdi,%rax
movsd  0x0(%rip),%xmm2        # 602 <gsl_multilarge_nlinear_default_parameters+0x22>
movl   $0x0,0x18(%rdi)
mov    %rdx,(%rdi)
mov    0x0(%rip),%rdx        # 613 <gsl_multilarge_nlinear_default_parameters+0x33>
movsd  %xmm0,0x20(%rdi)
movsd  0x0(%rip),%xmm3        # 620 <gsl_multilarge_nlinear_default_parameters+0x40>
movq   $0x0,0x48(%rdi)
movsd  0x0(%rip),%xmm4        # 630 <gsl_multilarge_nlinear_default_parameters+0x50>
mov    %rdx,0x8(%rdi)
mov    0x0(%rip),%rdx        # 63b <gsl_multilarge_nlinear_default_parameters+0x5b>
movsd  %xmm1,0x28(%rdi)
movsd  0x0(%rip),%xmm5        # 648 <gsl_multilarge_nlinear_default_parameters+0x68>
movsd  %xmm2,0x30(%rdi)
mov    %rdx,0x10(%rdi)
movsd  %xmm3,0x38(%rdi)
movsd  %xmm4,0x40(%rdi)
movsd  %xmm5,0x50(%rdi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_default_parameters(void)
{
  gsl_multilarge_nlinear_parameters params;
  params.trs = gsl_multilarge_nlinear_trs_lm;
  params.scale = gsl_multilarge_nlinear_scale_more;
  params.solver = gsl_multilarge_nlinear_solver_cholesky;
  params.fdtype = GSL_MULTILARGE_NLINEAR_FWDIFF;
  params.factor_up = 3.0;
  params.factor_down = 2.0;
  params.avmax = 0.75;
  params.h_df = 1.4901161193847656e-08;
  params.h_fvv = 0.01;
  params.max_iter = 0;
  params.tol = 1.0e-6;
  return params;
}
<<<sep_in_sample>>>
1 15
2 15
3 15
4 2
5 15
6 15
7 15
8 15
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 16
23 16
<<<sep_out_sample>>>
mov    0xf8(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_from (const osip_message_t * sip)
{
  return sip->from;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
sub    $0x18,%rsp
callq  48 <mu_pop3_stream_readline+0x18>
mov    %rax,%rbx
xor    %ecx,%ecx
xor    %eax,%eax
test   %rbx,%rbx
movq   $0x0,(%rsp)
je     63 <mu_pop3_stream_readline+0x33>
mov    0x8(%rbx),%edx
test   %edx,%edx
je     80 <mu_pop3_stream_readline+0x50>
test   %rbp,%rbp
je     6c <mu_pop3_stream_readline+0x3c>
mov    %rcx,0x0(%rbp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    %rsp,%rcx
mov    %r13,%rdx
mov    %r12,%rsi
callq  91 <mu_pop3_stream_readline+0x61>
mov    (%rsp),%rcx
test   %rcx,%rcx
jne    63 <mu_pop3_stream_readline+0x33>
mov    (%rbx),%rdx
movl   $0x0,0x60(%rdx)
movl   $0x1,0x8(%rbx)
jmp    63 <mu_pop3_stream_readline+0x33>
nopl   (%rax)
<<<sep_in_sample>>>
mu_pop3_stream_readline (mu_stream_t stream, char *buf, size_t buflen, mu_off_t offset, size_t *pn)
{
  struct mu_pop3_stream *pop3_stream = mu_stream_get_owner (stream);
  size_t n = 0;
  int status = 0;
  (void)offset;
  if (pop3_stream)
    {
      if (!pop3_stream->done)
 {
   status = mu_pop3_readline (pop3_stream->pop3, buf, buflen, &n);
   if (n == 0)
     {
       pop3_stream->pop3->state = MU_POP3_NO_STATE;
       pop3_stream->done = 1;
     }
 }
    }
  if (pn)
    *pn = n;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 5
13 7
14 4
15 7
16 9
17 9
18 9
19 19
20 19
21 20
22 22
23 22
24 22
25 22
26 22
27 22
28 22
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 14
38 14
39 15
40 15
41 15
<<<sep_out_sample>>>
mov    0x38(%rdi),%rdi
jmpq   489 <prog_close+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
prog_close (mu_mailer_t mailer)
{
  return mu_progmailer_close (mailer->data);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     100 <sdp_message_o_addrtype_get+0x10>
mov    0x28(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_o_addrtype_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->o_addrtype;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     56 <__gmp_obstack_printf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  92 <__gmp_obstack_printf+0x92>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_obstack_printf (struct obstack *ob, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  do {} while (0)
                                               ;
  ret = __gmp_doprnt (&__gmp_obstack_printf_funs, ob, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 8
18 2
19 8
20 8
21 5
22 5
23 5
24 5
25 5
26 8
27 11
28 11
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    $0x28,%edx
mov    $0x0,%esi
shl    $0x3,%rdi
jmpq   26 <strvec_create+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strvec_create (n)
     int n;
{
  return ((char **)sh_xmalloc(((n) * sizeof (char *)), "stringvec.c", 40));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1wrap ()
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x9,%dil
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_tab (char c)
{
  return c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rsi,0x78(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
msbdf_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msbdf_state_t *state = (msbdf_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   128 <delegate_name_fputs+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delegate_name_fputs (struct delegation *delegation, FILE * stream)
{
  fputs (delegation->name, stream);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
movslq %edx,%rdx
push   %r12
mov    %rsi,%r12
xor    %esi,%esi
push   %rbp
mov    %edi,%ebp
mov    %r12,%rdi
push   %rbx
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x8(%rsp)
xor    %eax,%eax
callq  d9f <_rl_read_mbstring+0x2f>
test   %ebp,%ebp
js     dfb <_rl_read_mbstring+0x8b>
test   %r13d,%r13d
jle    dfb <_rl_read_mbstring+0x8b>
xor    %ebx,%ebx
jmp    ddf <_rl_read_mbstring+0x6f>
nopl   0x0(%rax)
orq    $0x40,0x0(%rip)        # db8 <_rl_read_mbstring+0x48>
callq  dbd <_rl_read_mbstring+0x4d>
mov    %eax,%ecx
mov    %eax,%ebp
lea    0x1(%rbx),%eax
not    %ecx
andq   $0xffffffffffffffbf,0x0(%rip)        # dce <_rl_read_mbstring+0x5e>
shr    $0x1f,%ecx
cmp    %eax,%r13d
setg   %al
add    $0x1,%rbx
test   %cl,%al
je     dfb <_rl_read_mbstring+0x8b>
mov    %bpl,(%r12,%rbx,1)
mov    %rsp,%rsi
mov    %r12,%rdi
movq   $0x0,(%rsp)
callq  df6 <_rl_read_mbstring+0x86>
cmp    $0xfffffffe,%eax
je     db0 <_rl_read_mbstring+0x40>
mov    0x8(%rsp),%rdx
xor    %fs:0x28,%rdx
mov    %ebp,%eax
jne    e18 <_rl_read_mbstring+0xa8>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
callq  e1d <_rl_read_mbstring+0xad>
<<<sep_in_sample>>>
_rl_read_mbstring (first, mb, mlen)
     int first;
     char *mb;
     int mlen;
{
  int i, c;
  mbstate_t ps;
  c = first;
  memset (mb, 0, mlen);
  for (i = 0; c >= 0 && i < mlen; i++)
    {
      mb[i] = (char)c;
      memset (&ps, 0, sizeof (mbstate_t));
      if (_rl_get_char_len (mb, &ps) == -2)
 {
   (rl_readline_state |= (0x0000040));
   c = rl_read_key ();
   (rl_readline_state &= ~(0x0000040));
 }
      else
 break;
    }
  return c;
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 5
5 5
6 9
7 5
8 5
9 9
10 5
11 5
12 5
13 5
14 5
15 9
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 16
24 17
25 10
26 17
27 17
28 10
29 18
30 10
31 10
32 10
33 10
34 10
35 10
36 12
37 14
38 14
39 13
40 14
41 14
42 14
43 24
44 24
45 24
46 24
47 24
48 24
49 24
50 24
51 24
52 24
53 24
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    %rsi,%rcx
ja     3fa2 <indents_match+0x22>
mov    %rdx,%r8
sub    $0x8,%rsp
mov    %rcx,%rdx
mov    %r8,%rsi
callq  3f99 <indents_match+0x19>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
indents_match(const char *a_line, size_t a_indent, const char
 *b_line, size_t b_indent)
{
    ((void) (0));
    ((void) (0));
    return (b_indent <= a_indent &&
 strncmp(a_line, b_line, b_indent) == 0);
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 6
5 3
6 7
7 7
8 7
9 6
10 6
11 8
12 8
13 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 667 <terminal_end_inverse+0x7>
test   %rdx,%rdx
je     670 <terminal_end_inverse+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%rdi        # 677 <terminal_end_inverse+0x17>
test   %rdi,%rdi
je     690 <terminal_end_inverse+0x30>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   68b <terminal_end_inverse+0x2b>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
terminal_end_inverse (void)
{
  if (terminal_end_inverse_hook)
    (*terminal_end_inverse_hook) ();
  else
    {
      do { if (term_invend) tputs (term_invend, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    %edi,%r12d
push   %rbp
sub    $0x18,%rsp
test   %ecx,%ecx
jne    770 <mu_diag_funcall+0x50>
test   %rdx,%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    $0x0,%ebp
cmovne %rdx,%rbp
callq  750 <mu_diag_funcall+0x30>
add    $0x18,%rsp
mov    %rbp,%rcx
mov    %r12d,%edi
pop    %rbp
pop    %r12
mov    %r13,%rdx
mov    %rax,%rsi
xor    %eax,%eax
pop    %r13
pop    %r14
jmpq   76e <mu_diag_funcall+0x4e>
xchg   %ax,%ax
mov    %ecx,%edi
mov    %rdx,0x8(%rsp)
mov    $0x0,%ebp
callq  781 <mu_diag_funcall+0x61>
mov    0x8(%rsp),%rdx
mov    $0x0,%esi
mov    $0x0,%edi
mov    %rax,%r14
test   %rdx,%rdx
cmovne %rdx,%rbp
callq  79f <mu_diag_funcall+0x7f>
add    $0x18,%rsp
mov    %rbp,%rcx
mov    %r12d,%edi
pop    %rbp
pop    %r12
mov    %r13,%rdx
mov    %r14,%r8
mov    %rax,%rsi
pop    %r13
pop    %r14
xor    %eax,%eax
jmpq   7c0 <mu_diag_funcall+0xa0>
<<<sep_in_sample>>>
mu_diag_funcall (mu_log_level_t level, const char *func,
   const char *arg, int err)
{
  if (err)
    mu_diag_output (level, dgettext ("mailutils", "%s(%s) failed: %s"), func, arg ? arg : "",
      mu_strerror (err));
  else
    mu_diag_output (level, dgettext ("mailutils", "%s(%s) failed"), func, arg ? arg : "");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 8
11 8
12 8
13 8
14 8
15 8
16 9
17 8
18 8
19 9
20 9
21 8
22 8
23 8
24 9
25 9
26 8
27 8
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 9
40 5
41 5
42 9
43 9
44 5
45 5
46 5
47 9
48 9
49 5
50 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1897 <find_next_block+0x7>
cmp    0x0(%rip),%rax        # 189e <find_next_block+0xe>
je     18a8 <find_next_block+0x18>
retq   
nopl   0x0(%rax)
xor    %eax,%eax
cmpb   $0x0,0x0(%rip)        # 18b1 <find_next_block+0x21>
jne    18a0 <find_next_block+0x10>
sub    $0x18,%rsp
mov    %rax,0x8(%rsp)
callq  18c1 <find_next_block+0x31>
mov    0x0(%rip),%rdx        # 18c8 <find_next_block+0x38>
cmp    0x0(%rip),%rdx        # 18cf <find_next_block+0x3f>
mov    0x8(%rsp),%rax
je     18de <find_next_block+0x4e>
mov    %rdx,%rax
add    $0x18,%rsp
retq   
movb   $0x1,0x0(%rip)        # 18e5 <find_next_block+0x55>
jmp    18d9 <find_next_block+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_next_block (void)
{
  if (current_block == record_end)
    {
      if (hit_eof)
        return 0;
      flush_archive ();
      if (current_block == record_end)
        {
          hit_eof = 1;
          return 0;
        }
    }
  return current_block;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 15
5 15
6 6
7 5
8 5
9 2
10 2
11 7
12 8
13 8
14 8
15 8
16 8
17 15
18 15
19 10
20 11
21 11
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  865 <gsl_stats_int_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  878 <gsl_stats_int_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  895 <gsl_stats_int_ttest+0x55>
test   %rbp,%rbp
js     8f8 <gsl_stats_int_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 8a7 <gsl_stats_int_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     918 <gsl_stats_int_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     932 <gsl_stats_int_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    89f <gsl_stats_int_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    8b9 <gsl_stats_int_ttest+0x79>
test   %rbp,%rbp
js     96c <gsl_stats_int_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     983 <gsl_stats_int_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  963 <gsl_stats_int_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   8d7 <gsl_stats_int_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    93c <gsl_stats_int_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    94e <gsl_stats_int_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_int_ttest (const int data1[],
                           const size_t stride1, const size_t n1,
                           const int data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_int_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_int_mean (data2, stride2, n2);
  const double pv = gsl_stats_int_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
jmpq   1c5 <osip_contact_clone+0x5>
<<<sep_in_sample>>>
osip_contact_clone (const osip_contact_t * contact, osip_contact_t ** dest)
{
  return osip_from_clone ((osip_from_t *) contact, (osip_from_t **) dest);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1d <close_stdout+0xd>
callq  22 <close_stdout+0x12>
test   %eax,%eax
jne    3d <close_stdout+0x2d>
mov    0x0(%rip),%rdi        # 2d <close_stdout+0x1d>
callq  32 <close_stdout+0x22>
test   %eax,%eax
jne    79 <close_stdout+0x69>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%edi
callq  47 <close_stdout+0x37>
mov    0x0(%rip),%rdi        # 4e <close_stdout+0x3e>
mov    %rax,%rbx
test   %rdi,%rdi
je     84 <close_stdout+0x74>
callq  5b <close_stdout+0x4b>
mov    %rax,%rbp
callq  63 <close_stdout+0x53>
mov    (%rax),%esi
mov    %rbx,%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  79 <close_stdout+0x69>
mov    0x0(%rip),%edi        # 7f <close_stdout+0x6f>
callq  84 <close_stdout+0x74>
callq  89 <close_stdout+0x79>
mov    (%rax),%esi
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  9c <close_stdout+0x8c>
jmp    79 <close_stdout+0x69>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (close_stream (stdout) != 0)
    {
      char const *write_error = gettext ("write error");
      if (file_name)
 error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
        write_error);
      else
 error (0, (*__errno_location ()), "%s", write_error);
      _exit (exit_failure);
    }
   if (close_stream (stderr) != 0)
     _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 13
9 13
10 13
11 13
12 15
13 15
14 15
15 15
16 5
17 5
18 6
19 5
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 14
33 14
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_aix (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
lea    0x0(%rip),%rsi        # 8207 <checkcwd+0x7>
sub    $0x8,%rsp
callq  8210 <checkcwd+0x10>
mov    %rax,%rdi
xor    %eax,%eax
test   %rdi,%rdi
je     8224 <checkcwd+0x24>
callq  821f <checkcwd+0x1f>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
checkcwd (char *file)
{
  FILE *fp;
  char *p;
  fp = fopen(file, "r");
  if (fp){
    fclose(fp);
    return 1;
  }
  return 0;
}
<<<sep_in_sample>>>
1 5
2 2
3 5
4 5
5 10
6 6
7 6
8 7
9 8
10 11
11 11
12 11
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
test   %rdi,%rdi
je     130 <pfree+0x100>
mov    0x8(%rdi),%rbp
test   %rbp,%rbp
je     110 <pfree+0xe0>
mov    0x8(%rbp),%r12
test   %r12,%r12
je     108 <pfree+0xd8>
mov    0x8(%r12),%r13
test   %r13,%r13
je     100 <pfree+0xd0>
mov    0x8(%r13),%r14
test   %r14,%r14
je     f8 <pfree+0xc8>
mov    0x8(%r14),%r15
test   %r15,%r15
je     f0 <pfree+0xc0>
mov    0x8(%r15),%rax
test   %rax,%rax
je     e8 <pfree+0xb8>
mov    0x8(%rax),%rdx
test   %rdx,%rdx
je     e0 <pfree+0xb0>
mov    0x8(%rdx),%rcx
test   %rcx,%rcx
je     ce <pfree+0x9e>
mov    0x8(%rcx),%rdi
mov    %rdx,0x18(%rsp)
mov    %rax,0x10(%rsp)
mov    %rcx,0x8(%rsp)
callq  b7 <pfree+0x87>
mov    0x8(%rsp),%rcx
mov    %rcx,%rdi
callq  c4 <pfree+0x94>
mov    0x18(%rsp),%rdx
mov    0x10(%rsp),%rax
mov    %rdx,%rdi
mov    %rax,0x8(%rsp)
callq  db <pfree+0xab>
mov    0x8(%rsp),%rax
mov    %rax,%rdi
callq  e8 <pfree+0xb8>
mov    %r15,%rdi
callq  f0 <pfree+0xc0>
mov    %r14,%rdi
callq  f8 <pfree+0xc8>
mov    %r13,%rdi
callq  100 <pfree+0xd0>
mov    %r12,%rdi
callq  108 <pfree+0xd8>
mov    %rbp,%rdi
callq  110 <pfree+0xe0>
add    $0x28,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   126 <pfree+0xf6>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
pfree (struct prt *pp)
{
  if (pp != ((void *)0))
    {
      pfree (pp->pr_link);
      free ((void *)pp);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 5
12 3
13 3
14 5
15 3
16 3
17 5
18 3
19 3
20 5
21 3
22 3
23 5
24 3
25 3
26 5
27 3
28 3
29 5
30 3
31 3
32 5
33 3
34 3
35 5
36 5
37 5
38 5
39 5
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 8
62 6
63 8
64 8
65 8
66 8
67 8
68 8
69 6
70 6
71 8
72 8
73 8
74 8
75 8
76 8
77 8
78 8
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 699a <bashline_reinitialize+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bashline_reinitialize ()
{
  bash_readline_initialized = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (unsigned long) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              if (*chain == p)
                {
                  char *p_begin = (char *) p - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max);
                  *chain = ((struct header *) p_begin)->next;
                  free (p_begin);
                  return;
                }
              chain = &((struct header *) ((char *) *chain - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)))->next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 9
30 18
31 14
32 13
33 14
34 15
35 8
36 8
<<<sep_out_sample>>>
push   %rbp
movslq %edi,%rdi
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
addl   $0x1,0x0(%rip)        # b13 <dap_malloc+0x13>
callq  b18 <dap_malloc+0x18>
test   %rax,%rax
mov    %rax,%rbx
je     b70 <dap_malloc+0x70>
cmpq   $0x0,0x0(%rip)        # b28 <dap_malloc+0x28>
je     b61 <dap_malloc+0x61>
mov    0x0(%rip),%rdi        # b31 <dap_malloc+0x31>
mov    %eax,%edx
mov    %rbp,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  b42 <dap_malloc+0x42>
mov    0x0(%rip),%rdi        # b49 <dap_malloc+0x49>
callq  b4e <dap_malloc+0x4e>
mov    0x0(%rip),%eax        # b54 <dap_malloc+0x54>
test   %eax,%eax
je     b61 <dap_malloc+0x61>
cmp    0x0(%rip),%rbx        # b5f <dap_malloc+0x5f>
je     b6b <dap_malloc+0x6b>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
callq  b70 <dap_malloc+0x70>
callq  b75 <dap_malloc+0x75>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dap_malloc(int nbytes, char *mesg)
{
  char *m;
  nmallocs++;
  if (!(m = malloc(nbytes)))
    {
      perror(dap_dapname);
      exit(1);
    }
  if (dap_memtrace)
    {
      fprintf(dap_log, "malloc %x %s\n", (unsigned int) m, mesg);
      fflush(dap_log);
      if (dap_mabort && m == dap_memtrace)
 abort();
    }
  return m;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 5
8 5
9 5
10 5
11 10
12 10
13 12
14 12
15 12
16 12
17 12
18 12
19 13
20 13
21 14
22 14
23 14
24 14
25 14
26 18
27 18
28 18
29 18
30 18
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
lea    -0x1(%rsi),%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
test   %rsi,%rsi
jle    b8 <WriteArrayExp+0x58>
nopl   0x0(%rax)
movsd  (%r14,%rbx,8),%xmm0
callq  8b <WriteArrayExp+0x2b>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x1,%eax
callq  9d <WriteArrayExp+0x3d>
cmp    %rbx,%r13
jle    af <WriteArrayExp+0x4f>
mov    %rbp,%rsi
mov    $0x9,%edi
callq  af <WriteArrayExp+0x4f>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    80 <WriteArrayExp+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
WriteArrayExp (FILE *pfile, long cElems, double *rg)
{
  register long i;
  register long cElems_minus_1 = cElems - 1;
  for (i = 0; i < cElems; i++) {
    fprintf(pfile, "%g", exp(rg[i]));
    if (i < cElems_minus_1) fputc ('\t', pfile);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 5
26 5
27 5
28 9
29 9
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
movzbl (%rdi),%ecx
test   %cl,%cl
je     905 <putlines+0x85>
movsbl %cl,%edi
mov    %edx,%r12d
cmp    %edx,%edi
je     905 <putlines+0x85>
mov    %r13,%rbx
jmp    8c8 <putlines+0x48>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbx
callq  8b9 <putlines+0x39>
movzbl (%rbx),%ecx
test   %cl,%cl
je     8e8 <putlines+0x68>
movsbl %cl,%edi
cmp    %r12d,%edi
je     8e8 <putlines+0x68>
cmp    $0xa,%cl
mov    %rbp,%rsi
jne    8b0 <putlines+0x30>
add    $0x1,%rbx
mov    $0x20,%edi
callq  8de <putlines+0x5e>
movzbl (%rbx),%ecx
test   %cl,%cl
jne    8c0 <putlines+0x40>
nopl   (%rax)
sub    %r13d,%ebx
mov    %rbp,%rsi
mov    $0x20,%edi
callq  8f8 <putlines+0x78>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %ebx,%ebx
jmp    8eb <putlines+0x6b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
putlines(char *line, FILE *file, int term)
{
  char *start;
  for (start = line; *line && *line != term; line++)
    {
      if (*line == '\n')
 _IO_putc (' ', file);
      else
 _IO_putc (*line, file);
    }
  _IO_putc (' ', file);
  return line - start;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 9
20 4
21 4
22 4
23 4
24 4
25 4
26 6
27 7
28 6
29 4
30 7
31 7
32 4
33 4
34 4
35 4
36 4
37 11
38 11
39 11
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 4
48 4
49 4
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
mulsd  %xmm0,%xmm0
mulsd  %xmm0,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_pow_8(const double x) { double x2 = x*x; double x4 = x2*x2; return x4*x4; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
mov    (%rsi),%rax
movsd  (%rdi),%xmm0
lea    0x8(%rax),%rdx
mov    %rdx,(%rsi)
movsd  %xmm0,(%rax)
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
OneDToArray (PVOID pData, PVOID pInfo)
{
  PDOUBLE *ppdArrayVal = (PDOUBLE *) pInfo;
  *(*ppdArrayVal)++ = *(PDOUBLE) pData;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
push   %rbp
mov    %rdx,%rbp
push   %rbx
je     70 <__gmpz_cdiv_r_ui+0x70>
movslq 0x4(%rsi),%rbx
mov    %rdi,%r12
mov    %rsi,%rax
test   %rbx,%rbx
je     3c <__gmpz_cdiv_r_ui+0x3c>
mov    %rbx,%rdx
mov    0x8(%rax),%rdi
sar    $0x3f,%rdx
mov    %rdx,%rsi
xor    %rbx,%rsi
sub    %rdx,%rsi
mov    %rbp,%rdx
callq  37 <__gmpz_cdiv_r_ui+0x37>
test   %rax,%rax
jne    50 <__gmpz_cdiv_r_ui+0x50>
movl   $0x0,0x4(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%r12),%rdx
sub    %rax,%rbp
test   %rbx,%rbx
cmovns %rbp,%rax
mov    %rax,(%rdx)
movl   $0xffffffff,0x4(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  75 <__gmpz_cdiv_r_ui+0x75>
<<<sep_in_sample>>>
__gmpz_cdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)
{
  mp_size_t ns, nn;
  mp_ptr np;
  mp_limb_t rl;
  if (__builtin_expect ((divisor == 0) != 0, 0))
    __gmp_divide_by_zero ();
  ns = ((dividend)->_mp_size);
  if (ns == 0)
    {
      ((rem)->_mp_size) = 0;
      return 0;
    }
  nn = ((ns) >= 0 ? (ns) : -(ns));
  np = ((dividend)->_mp_d);
    {
      rl = __gmpn_mod_1 (np, nn, (mp_limb_t) divisor);
      if (rl == 0)
 ((rem)->_mp_size) = 0;
      else
 {
   if (ns >= 0)
     rl = divisor - rl;
   ((rem)->_mp_d)[0] = rl;
   ((rem)->_mp_size) = -1;
 }
    }
  return rl;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 6
7 8
8 8
9 8
10 9
11 9
12 14
13 17
14 14
15 14
16 14
17 14
18 17
19 17
20 18
21 18
22 11
23 12
24 29
25 29
26 29
27 29
28 29
29 24
30 23
31 23
32 23
33 24
34 25
35 29
36 29
37 29
38 29
39 7
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
xor    %eax,%eax
movq   $0x0,0x0(%rip)        # 3d <setup_index+0xd>
movq   $0x0,0x0(%rip)        # 48 <setup_index+0x18>
mov    %ax,0x0(%rip)        # 4f <setup_index+0x1f>
movl   $0x0,0x0(%rip)        # 59 <setup_index+0x29>
movl   $0x0,0x0(%rip)        # 63 <setup_index+0x33>
movl   $0x0,0x0(%rip)        # 6d <setup_index+0x3d>
movq   $0x0,0x0(%rip)        # 78 <setup_index+0x48>
movq   $0x0,0x0(%rip)        # 83 <setup_index+0x53>
movq   $0x0,0x0(%rip)        # 8e <setup_index+0x5e>
movq   $0x0,0x0(%rip)        # 99 <setup_index+0x69>
movl   $0x0,0x0(%rip)        # a3 <setup_index+0x73>
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setup_index(void)
{
  max_function_name_length = 0;
  max_file_name_length = 0;
  no_of_functions=0;
  function_list_size = 0;
  file_list_size = 0;
  page_list_size = 0;
  functions = ((void *)0);
  sorted_functions = ((void *)0);
  files = ((void *)0);
  pages = ((void *)0);
  current_function_changed = FALSE;
}
<<<sep_in_sample>>>
1 5
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 13
14 13
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 587 <output_init+0x7>
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
xor    %edi,%edi
lea    (%rax,%rax,2),%rax
shl    $0x3,%rax
mov    0x0(%rax),%r9
mov    0x0(%rax),%r8
jmpq   *%r9
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_init()
{
     output_driver[driver_index].handler(cflow_output_init,
      ((void *)0), 0,
      ((void *)0),
             output_driver[driver_index].handler_data);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x78(%rsi),%rbp
cmp    %rdi,%rbp
je     2163 <discard_until+0x73>
nopl   0x0(%rax)
test   %rbp,%rbp
je     2163 <discard_until+0x73>
mov    0x60(%rbp),%rax
mov    0x18(%rbp),%rdi
mov    %rax,0x78(%r12)
callq  2127 <discard_until+0x37>
mov    0x40(%rbp),%rdi
callq  2130 <discard_until+0x40>
mov    0x38(%rbp),%rdi
test   %rdi,%rdi
jne    2143 <discard_until+0x53>
jmp    2151 <discard_until+0x61>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    0x10(%rdi),%rbx
callq  214c <discard_until+0x5c>
test   %rbx,%rbx
jne    2140 <discard_until+0x50>
mov    %rbp,%rdi
callq  2159 <discard_until+0x69>
mov    0x78(%r12),%rbp
cmp    %rbp,%r13
jne    2110 <discard_until+0x20>
movl   $0xf,0x88(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
discard_until(const undo *thisitem, openfilestruct *thefile)
{
    undo *dropit = thefile->undotop;
    undo_group *group;
    while (dropit != ((void *)0) && dropit != thisitem) {
 thefile->undotop = dropit->next;
 free(dropit->strdata);
 free_filestruct(dropit->cutbuffer);
 group = dropit->grouping;
 while (group != ((void *)0)) {
     undo_group *next = group->next;
     free(group);
     group = next;
 }
 free(dropit);
 dropit = thefile->undotop;
    }
    thefile->last_action = OTHER;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 6
17 7
18 8
19 8
20 9
21 10
22 10
23 10
24 10
25 13
26 11
27 12
28 10
29 10
30 15
31 15
32 16
33 5
34 5
35 18
36 19
37 19
38 19
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_get_type_reg (rec_rset_t rset)
{
  return rset->type_reg;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 20c7 <slc_end_reply+0x7>
push   %rbx
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 20d3 <slc_end_reply+0x13>
movb   $0xff,(%rax)
mov    0x0(%rip),%rax        # 20dd <slc_end_reply+0x1d>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 20e8 <slc_end_reply+0x28>
movb   $0xf0,(%rax)
mov    0x0(%rip),%rbx        # 20f2 <slc_end_reply+0x32>
sub    $0x0,%rbx
cmp    $0x6,%ebx
jg     2100 <slc_end_reply+0x40>
pop    %rbx
retq   
mov    $0x0,%edi
callq  210a <slc_end_reply+0x4a>
cmp    %eax,%ebx
jl     2120 <slc_end_reply+0x60>
pop    %rbx
mov    $0x0,%edi
jmpq   2119 <slc_end_reply+0x59>
nopl   0x0(%rax)
mov    0x0(%rip),%rdx        # 2127 <slc_end_reply+0x67>
mov    $0x0,%esi
mov    $0x0,%edi
sub    $0x0,%rdx
callq  213d <slc_end_reply+0x7d>
mov    0x0(%rip),%edx        # 2143 <slc_end_reply+0x83>
mov    $0x0,%eax
mov    $0x0,%esi
pop    %rbx
mov    $0x3e,%edi
sub    %eax,%edx
sub    $0x2,%edx
jmpq   215d <slc_end_reply+0x9d>
nopl   (%rax)
<<<sep_in_sample>>>
slc_end_reply (void)
{
  register int len;
  *slc_replyp++ = 255;
  *slc_replyp++ = 240;
  len = slc_replyp - slc_reply;
  if (len <= 6)
    return;
  if ((ring_empty_count(&netoring)) > len)
    {
      ring_supply_data (&netoring, slc_reply, slc_replyp - slc_reply);
      printsub ('>', &slc_reply[2], slc_replyp - slc_reply - 2);
    }
  else
    printf ("slc_end_reply: not enough room\n");
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 16
15 16
16 9
17 9
18 9
19 9
20 16
21 15
22 15
23 15
24 11
25 11
26 11
27 11
28 11
29 12
30 12
31 12
32 16
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
movzbl (%rdi),%edx
mov    %rdi,%rax
testb  $0x6,0x0(%rdx,%rdx,1)
je     741 <next_token+0x21>
add    $0x1,%rax
movzbl (%rax),%edx
testb  $0x6,0x0(%rdx,%rdx,1)
jne    730 <next_token+0x10>
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_token (const char *s)
{
  while ((((stopchar_map[(unsigned char)((*(s)))])&(((0x0002|0x0004)))) != 0)) ++(s);
  return (char *)s;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     660 <mu_mailbox_open+0x30>
mov    0x60(%rdi),%rdx
test   %rdx,%rdx
je     660 <mu_mailbox_open+0x30>
test   $0x800,%esi
je     658 <mu_mailbox_open+0x28>
test   $0x1e,%sil
mov    $0x16,%eax
je     658 <mu_mailbox_open+0x28>
repz retq 
nopl   0x0(%rax,%rax,1)
jmpq   *%rdx
nopw   0x0(%rax,%rax,1)
mov    $0x1003,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_open (mu_mailbox_t mbox, int flag)
{
  if (mbox == ((void *)0) || mbox->_open == ((void *)0))
    return (0x1000 +3);
  if (flag & 0x00000800)
    {
      if (flag & (0x00000002 | 0x00000004
    | 0x00000008 | 0x00000010))
 return 22;
    }
  return mbox->_open (mbox, flag);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 7
9 9
10 7
11 12
12 12
13 11
14 11
15 4
16 12
17 12
<<<sep_out_sample>>>
movsd  %xmm0,-0x48(%rsp)
mov    -0x48(%rsp),%rax
movq   %xmm2,-0x38(%rsp)
movq   %xmm1,-0x20(%rsp)
mov    %rax,-0x28(%rsp)
movq   %xmm3,-0x30(%rsp)
movsd  -0x28(%rsp),%xmm4
movsd  -0x38(%rsp),%xmm0
movhpd -0x20(%rsp),%xmm4
movhpd -0x30(%rsp),%xmm0
addpd  %xmm4,%xmm0
movapd %xmm0,-0x48(%rsp)
mov    -0x48(%rsp),%rdx
mov    -0x40(%rsp),%rax
mov    %rdx,-0x48(%rsp)
movsd  -0x48(%rsp),%xmm0
mov    %rax,-0x48(%rsp)
movsd  -0x48(%rsp),%xmm1
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_add (gsl_complex a, gsl_complex b)
{
  double ar = ((a).dat[0]), ai = ((a).dat[1]);
  double br = ((b).dat[0]), bi = ((b).dat[1]);
  gsl_complex z;
  do {(&z)->dat[0]=(ar + br); (&z)->dat[1]=(ai + bi);} while(0);
  return z;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 3
10 4
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 7
19 8
20 8
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     4a0 <gsl_permute_vector_complex_inverse+0x30>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  495 <gsl_permute_vector_complex_inverse+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  4b1 <gsl_permute_vector_complex_inverse+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_complex_inverse (const gsl_permutation * p, gsl_vector_complex * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_complex_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 47a <gsl_matrix_complex_float_get+0xa>
test   %eax,%eax
je     489 <gsl_matrix_complex_float_get+0x19>
cmp    %rsi,(%rdi)
jbe    4a0 <gsl_matrix_complex_float_get+0x30>
cmp    %rdx,0x8(%rdi)
jbe    4c8 <gsl_matrix_complex_float_get+0x58>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
movq   (%rax,%rdx,8),%xmm0
add    $0x8,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x113,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b9 <gsl_matrix_complex_float_get+0x49>
pxor   %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4e1 <gsl_matrix_complex_float_get+0x71>
pxor   %xmm0,%xmm0
jmp    49a <gsl_matrix_complex_float_get+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_get(const gsl_matrix_complex_float * m,
                     const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      gsl_complex_float zero = {{0,0}};
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_float.h", 275, GSL_EINVAL) ; return zero ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_float.h", 279, GSL_EINVAL) ; return zero ; } while (0) ;
        }
    }
  return *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 7
6 7
7 11
8 11
9 16
10 16
11 16
12 16
13 17
14 17
15 17
16 9
17 9
18 9
19 9
20 9
21 9
22 17
23 17
24 17
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  311 <xdr_dis_linear_acc_vector+0x11>
test   %eax,%eax
jne    320 <xdr_dis_linear_acc_vector+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  32c <xdr_dis_linear_acc_vector+0x2c>
test   %eax,%eax
je     315 <xdr_dis_linear_acc_vector+0x15>
lea    0x8(%rbp),%rsi
mov    %rbx,%rdi
callq  33c <xdr_dis_linear_acc_vector+0x3c>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_linear_acc_vector(xdrs, objp)
	XDR *xdrs;
	dis_linear_acc_vector *objp;
{
	if (!xdr_byte_float(xdrs, &objp->x)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->y)) {
		return (FALSE);
	}
	if (!xdr_byte_float(xdrs, &objp->z)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 15
10 6
11 15
12 15
13 15
14 15
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 15
26 15
27 11
28 15
29 15
30 15
<<<sep_out_sample>>>
test   $0xf,%sil
jne    c3 <nettle_aes192_decrypt+0x23>
mov    %rdx,%r8
lea    0x0(%rip),%rdx        # b0 <nettle_aes192_decrypt+0x10>
mov    %rcx,%r9
mov    %rsi,%rcx
mov    %rdi,%rsi
mov    $0xc,%edi
jmpq   c3 <nettle_aes192_decrypt+0x23>
lea    0x0(%rip),%rcx        # ca <nettle_aes192_decrypt+0x2a>
push   %rax
lea    0x0(%rip),%rsi        # d2 <nettle_aes192_decrypt+0x32>
lea    0x0(%rip),%rdi        # d9 <nettle_aes192_decrypt+0x39>
mov    $0x174,%edx
callq  e3 <nettle_aes192_decrypt+0x43>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_aes192_decrypt(const struct aes192_ctx *ctx,
        size_t length, uint8_t *dst,
        const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "aes-decrypt.c", 372, __PRETTY_FUNCTION__));
  _nettle_aes_decrypt(12, ctx->keys, &_aes_decrypt_table,
        length, dst, src);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 5
11 4
12 5
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     ac8 <gsl_vector_long_double_ispos+0x38>
mov    0x10(%rdi),%rdx
fldz   
shl    $0x4,%rsi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
fldt   (%rdx)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jae    ace <gsl_vector_long_double_ispos+0x3e>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    ab0 <gsl_vector_long_double_ispos+0x20>
fstp   %st(0)
mov    $0x1,%eax
retq   
fstp   %st(0)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_ispos (const gsl_vector_long_double * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 11
7 11
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 6
16 6
17 6
18 6
19 6
20 17
21 18
22 18
23 13
24 13
25 13
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  fe <string_htable_free+0xe>
mov    %rbx,%rdi
pop    %rbx
jmpq   107 <string_htable_free+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_htable_free (struct string_htable * table)
{
  hash_free (table, (hash_map_func_t) free);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
jmpq   5 <idn_free+0x5>
<<<sep_in_sample>>>
idn_free (void *ptr)
{
  free (ptr);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1b20 <gsl_vector_int_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b15 <gsl_vector_int_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1b56 <gsl_vector_int_div+0x66>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %esi,%esi
nop
mov    (%rdi),%eax
add    $0x1,%rsi
cltd   
idivl  (%rcx)
add    %r9,%rcx
mov    %eax,(%rdi)
add    %r10,%rdi
cmp    %r8,%rsi
jne    1b40 <gsl_vector_int_div+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_int_div (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
jmpq   183 <gsl_sort_vector_long_double+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_double (gsl_vector_long_double * v)
{
  gsl_sort_long_double (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1b0 <osip_uri_get_scheme+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_uri_get_scheme (osip_uri_t * url)
{
  if (url == ((void *)0))
    return ((void *)0);
  return url->scheme;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0x1,%edx
jmpq   37cd <info_read_completing_in_echo_area_with_exclusions+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
info_read_completing_in_echo_area_with_exclusions (const char *prompt,
     REFERENCE **completions, reference_bool_fn exclude)
{
  return info_read_completing_internal (prompt, completions, 1, exclude);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
je     1750 <wordsplit+0x30>
callq  1737 <wordsplit+0x17>
mov    %rax,%rsi
mov    %rbx,%rdi
mov    %rbp,%rdx
mov    %r12d,%ecx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   174c <wordsplit+0x2c>
nopl   0x0(%rax)
xor    %esi,%esi
jmp    173a <wordsplit+0x1a>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit (const char *command, struct wordsplit *ws, int flags)
{
  return wordsplit_len (command, command ? strlen (command) : 0, ws,
      flags);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 3
12 3
13 3
14 5
15 5
16 5
17 3
18 3
19 3
20 3
21 3
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
mov    0x40(%rdi),%rsi
mov    0x10(%rax),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_preloop(const void * vtrust_state, void * vstate)
{
  int status;
  const gsl_multilarge_nlinear_trust_state *trust_state =
    (const gsl_multilarge_nlinear_trust_state *) vtrust_state;
  const gsl_multilarge_nlinear_parameters *params = trust_state->params;
  (void)vstate;
  status = (params->solver->init)(trust_state, trust_state->solver_state);
  if (status)
    return status;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_record_equal_fn (void *data1,
                          void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%r12
mov    0x18(%rdi),%rbx
mov    0x8(%rdi),%rbp
mov    0x10(%rdi),%r13
test   %r12,%r12
movzbl (%rbx),%edi
je     539a <gsl_matrix_uchar_min_index+0x7a>
xor    %r11d,%r11d
xor    %r9d,%r9d
xor    %r10d,%r10d
nopw   %cs:0x0(%rax,%rax,1)
test   %rbp,%rbp
je     5381 <gsl_matrix_uchar_min_index+0x61>
mov    %edi,%r8d
xor    %eax,%eax
jmp    5363 <gsl_matrix_uchar_min_index+0x43>
nopl   0x0(%rax)
mov    %edi,%r8d
movzbl (%rbx,%rax,1),%ecx
cmp    %dil,%cl
cmovbe %ecx,%edi
cmp    %r8b,%cl
cmovb  %r11,%r10
cmovb  %rax,%r9
add    $0x1,%rax
cmp    %rbp,%rax
jne    5360 <gsl_matrix_uchar_min_index+0x40>
add    $0x1,%r11
add    %r13,%rbx
cmp    %r12,%r11
jne    5350 <gsl_matrix_uchar_min_index+0x30>
pop    %rbx
pop    %rbp
pop    %r12
mov    %r10,(%rsi)
mov    %r9,(%rdx)
pop    %r13
retq   
pop    %rbx
pop    %rbp
xor    %r9d,%r9d
xor    %r10d,%r10d
pop    %r12
mov    %r10,(%rsi)
mov    %r9,(%rdx)
pop    %r13
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_uchar_min_index (const gsl_matrix_uchar * m, size_t * imin_out, size_t *jmin_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned char min = m->data[0 * tda + 0];
  size_t imin = 0, jmin = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned char x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 6
7 4
8 5
9 9
10 6
11 9
12 9
13 7
14 7
15 7
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 13
24 13
25 13
26 13
27 13
28 13
29 11
30 11
31 11
32 9
33 9
34 9
35 9
36 24
37 24
38 24
39 22
40 23
41 24
42 24
43 24
44 24
45 7
46 7
47 24
48 22
49 23
50 24
51 24
52 24
<<<sep_out_sample>>>
xor    %r8d,%r8d
test   %rcx,%rcx
lea    0x0(,%rdx,4),%r10
je     1538 <gsl_permute_uint_inverse+0x78>
mov    (%rdi,%r8,8),%rax
cmp    %r8,%rax
jbe    14e9 <gsl_permute_uint_inverse+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %r8,%rax
ja     14e0 <gsl_permute_uint_inverse+0x20>
cmp    %r8,%rax
jb     152f <gsl_permute_uint_inverse+0x6f>
mov    (%rdi,%rax,8),%rdx
cmp    %r8,%rdx
je     152f <gsl_permute_uint_inverse+0x6f>
imul   %r10,%rax
mov    (%rsi,%rax,1),%r9d
jmp    150b <gsl_permute_uint_inverse+0x4b>
nopl   0x0(%rax)
mov    %r11d,%r9d
mov    %r10,%rax
imul   %rdx,%rax
mov    (%rdi,%rdx,8),%rdx
add    %rsi,%rax
cmp    %rdx,%r8
mov    (%rax),%r11d
mov    %r9d,(%rax)
jne    1508 <gsl_permute_uint_inverse+0x48>
mov    %r10,%rax
imul   %r8,%rax
mov    %r11d,(%rsi,%rax,1)
add    $0x1,%r8
cmp    %rcx,%r8
jne    14d0 <gsl_permute_uint_inverse+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_uint_inverse (const size_t * p, unsigned int * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        unsigned int t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[k*stride*1 +a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                unsigned int r1 = data[pk*stride*1 + a];
                data[pk*stride*1 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[pk*stride*1 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 18
4 4
5 6
6 7
7 7
8 7
9 8
10 7
11 7
12 9
13 9
14 11
15 12
16 12
17 18
18 18
19 18
20 18
21 23
22 23
23 23
24 28
25 23
26 19
27 23
28 24
29 19
30 31
31 31
32 31
33 4
34 4
35 4
36 35
37 35
38 35
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 161d <write_pid_file+0xd>
test   %rdi,%rdi
je     1660 <write_pid_file+0x50>
mov    $0x0,%esi
callq  162c <write_pid_file+0x1c>
test   %rax,%rax
mov    %rax,%rbx
je     1678 <write_pid_file+0x68>
callq  1639 <write_pid_file+0x29>
mov    %rbx,%rdi
movslq %eax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  164b <write_pid_file+0x3b>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   1659 <write_pid_file+0x49>
nopl   0x0(%rax)
movq   $0x0,0x0(%rip)        # 166b <write_pid_file+0x5b>
mov    $0x0,%edi
jmp    1622 <write_pid_file+0x12>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rbp        # 167f <write_pid_file+0x6f>
mov    $0x0,%edi
callq  1689 <write_pid_file+0x79>
mov    %rax,%rbx
callq  1691 <write_pid_file+0x81>
mov    (%rax),%esi
add    $0x8,%rsp
mov    %rbx,%rdx
pop    %rbx
mov    %rbp,%rcx
xor    %edi,%edi
xor    %eax,%eax
pop    %rbp
jmpq   16a8 <write_pid_file+0x98>
<<<sep_in_sample>>>
write_pid_file (void)
{
  FILE *fp;
  if (!pidfile)
    pidfile = "/var/run/" "anubis.pid";
  fp = fopen (pidfile, "w");
  if (!fp)
    anubis_error (0, (*__errno_location ()), gettext("Cannot open pid file '%s'"), pidfile);
  else
    {
      fprintf (fp, "%ld\n", (unsigned long) getpid ());
      fclose (fp);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 6
8 6
9 7
10 6
11 7
12 11
13 11
14 11
15 11
16 11
17 11
18 14
19 12
20 14
21 14
22 12
23 12
24 5
25 5
26 5
27 5
28 8
29 8
30 8
31 8
32 8
33 8
34 14
35 8
36 14
37 8
38 8
39 8
40 14
41 8
<<<sep_out_sample>>>
jmpq   775 <gsl_linalg_mcholesky_solve+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_linalg_mcholesky_solve(const gsl_matrix * LDLT,
                           const gsl_permutation * p,
                           const gsl_vector * b,
                           gsl_vector * x)
{
  int status = gsl_linalg_pcholesky_solve(LDLT, p, b, x);
  return status;
}
<<<sep_in_sample>>>
1 6
2 6