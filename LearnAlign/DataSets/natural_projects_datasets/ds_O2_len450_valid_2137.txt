mov    0x0(%rip),%rsi        # 57 <send_help+0x7>
push   %rbx
mov    $0x0,%ebx
test   %rsi,%rsi
je     89 <send_help+0x39>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rdx
test   %rdx,%rdx
je     7d <send_help+0x2d>
mov    $0x0,%edi
xor    %eax,%eax
callq  7d <send_help+0x2d>
add    $0x28,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
jne    68 <send_help+0x18>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
send_help (void)
{
  struct sendlist *s;
  for (s = Sendlist; s->name; s++)
    {
      if (s->help)
 printf ("%-15s %s\n", s->name, s->help);
    }
  return (0);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 7
13 4
14 4
15 4
16 4
17 10
18 10
19 10
20 10
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  2b7 <chown_error_details+0x17>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 2c0 <chown_error_details+0x20>
test   %rax,%rax
je     2c7 <chown_error_details+0x27>
callq  *%rax
mov    %r13,%rdi
callq  2cf <chown_error_details+0x2f>
mov    $0x0,%edi
mov    %rax,%r13
callq  2dc <chown_error_details+0x3c>
mov    %r12d,%r9d
mov    %ebp,%r8d
mov    %r13,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  2f3 <chown_error_details+0x53>
movl   $0x2,0x0(%rip)        # 2fd <chown_error_details+0x5d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chown_error_details (char const *name, uid_t uid, gid_t gid)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot change ownership to uid %lu, gid %lu"), quotearg_colon (name), (unsigned long) uid, (unsigned long) gid); exit_status = 2; } while (0)
                                                                    ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 6
30 6
31 6
32 6
33 6
34 6
35 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
lea    0xf(%rsp),%rax
cmp    %rax,0x0(%rip)        # 11 <stackoverflow_handler+0x11>
ja     75 <stackoverflow_handler+0x75>
cmp    %rax,0x0(%rip)        # 1a <stackoverflow_handler+0x1a>
jb     75 <stackoverflow_handler+0x75>
mov    0x0(%rip),%eax        # 22 <stackoverflow_handler+0x22>
mov    %edi,%ebx
mov    $0x0,%edi
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 32 <stackoverflow_handler+0x32>
mov    0x0(%rip),%esi        # 38 <stackoverflow_handler+0x38>
xor    %eax,%eax
callq  3f <stackoverflow_handler+0x3f>
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x2,%edi
callq  50 <stackoverflow_handler+0x50>
test   %ebx,%ebx
mov    $0xffffffffffffffff,%rsi
jne    62 <stackoverflow_handler+0x62>
movslq 0x0(%rip),%rsi        # 62 <stackoverflow_handler+0x62>
add    $0x10,%rsp
xor    %ecx,%ecx
xor    %edx,%edx
pop    %rbx
mov    $0x0,%edi
jmpq   75 <stackoverflow_handler+0x75>
callq  7a <stackoverflow_handler+0x7a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stackoverflow_handler (int emergency, stackoverflow_context_t scp)
{
  char dummy;
  volatile char *addr = &dummy;
  if (!(addr >= stack_lower_bound && addr <= stack_upper_bound))
    abort ();
  pass++;
  printf ("Stack overflow %d caught.\n", pass);
  sigprocmask (2, &mainsigset, ((void *)0));
  sigsegv_leave_handler (stackoverflow_handler_continuation,
                         (void *) (long) (emergency ? -1 : pass), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 7
13 8
14 8
15 8
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 11
24 12
25 10
26 10
27 12
28 10
29 10
30 6
31 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
jne    2ab <defer_close+0x1b>
jmp    2b9 <defer_close+0x29>
nopl   0x0(%rax)
mov    %rbx,%rdi
mov    0x8(%rdi),%rbx
callq  0 <def_free_deferment>
test   %rbx,%rbx
jne    2a8 <defer_close+0x18>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2c7 <defer_close+0x37>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defer_close(DEFER * def)
{
        struct deferment *oldd;
        struct deferment *d=def->deferoutsM;
 while (d) {
  oldd=d;
  d=d->nextP;
  def_free_deferment(oldd);
 }
 free(def);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 5
9 5
10 7
11 7
12 8
13 5
14 5
15 12
16 10
17 12
18 12
19 10
20 10
<<<sep_out_sample>>>
push   %r15
mov    %r9d,%r15d
push   %r14
mov    %r8,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # b868 <ch_bs_hdy+0x28>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  1f0 <ch_base_hdy>
mov    0x0(%rip),%rdi        # b87b <ch_bs_hdy+0x3b>
mov    0x0(%rip),%rbx        # b882 <ch_bs_hdy+0x42>
callq  b887 <ch_bs_hdy+0x47>
mov    0x70(%rsp),%ecx
mov    %r15d,0x18(%rsp)
mov    %r12d,%esi
mov    %r14,0x10(%rsp)
mov    %r13d,0x8(%rsp)
mov    $0x1,%r9d
movl   $0x5,(%rsp)
mov    $0x0,%r8d
mov    %rax,%rdx
mov    %ecx,0x20(%rsp)
mov    0x0(%rbp),%edi
mov    %rbx,%rcx
callq  b8c2 <ch_bs_hdy+0x82>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ch_bs_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_BS";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[169].ht_text),
    ptr_cc_id, "+", 1, 5, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
mov    0x4(%rdi),%esi
xor    %eax,%eax
mov    $0x0,%edi
jmpq   2ff <print_packet_too_big+0xf>
nop
<<<sep_in_sample>>>
print_packet_too_big (struct icmp6_hdr *icmp6)
{
  printf ("Packet too big, mtu=%d\n", icmp6->icmp6_dataun.icmp6_un_data32[0]);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    %rbx,%rdi
sub    $0x8,%rsp
mov    (%rsi),%rax
xor    %esi,%esi
callq  *0x28(%rax)
mov    0x0(%rbp),%rax
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  *0x40(%rax)
mov    0x0(%rbp),%rax
mov    %rax,(%rbx)
mov    0x44(%rbp),%eax
mov    %eax,0x44(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assoc_copy(NODE *symbol, NODE *newsymb)
{
 ((void) (0));
 (void) ((newsymb)->sub.nodep.l.lp[5](newsymb, ((void *)0)));
 (void) symbol->sub.nodep.l.lp[8](symbol, newsymb);
 newsymb->sub.nodep.l.lp = symbol->sub.nodep.l.lp;
 newsymb->flags = symbol->flags;
 return newsymb;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 9
19 9
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
push   %r14
push   %r13
mov    %rdx,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rdi),%r12
mov    (%rsi),%rbp
mov    %rsi,0x8(%rsp)
test   %r12,%r12
je     68f <grecs_getline+0xbf>
xor    %ebx,%ebx
jmp    62b <grecs_getline+0x5b>
nopl   0x0(%rax)
lea    (%r12,%rbx,1),%r14
mov    %ebp,%esi
mov    %r13,%rdx
sub    %ebx,%esi
mov    %r14,%rdi
callq  613 <grecs_getline+0x43>
test   %rax,%rax
je     658 <grecs_getline+0x88>
mov    %r14,%rdi
callq  620 <grecs_getline+0x50>
add    %rax,%rbx
cmpb   $0xa,-0x1(%r12,%rbx,1)
je     666 <grecs_getline+0x96>
lea    -0x1(%rbp),%rax
cmp    %rax,%rbx
jne    600 <grecs_getline+0x30>
lea    0x0(%rbp,%rbp,1),%r14
cmp    %r14,%rbp
ja     688 <grecs_getline+0xb8>
mov    %r12,%rdi
mov    %r14,%rsi
mov    %r14,%rbp
callq  64c <grecs_getline+0x7c>
mov    %rax,%r12
jmp    600 <grecs_getline+0x30>
nopl   0x0(%rax)
test   %rbx,%rbx
mov    $0xffffffffffffffff,%rax
cmove  %rax,%rbx
mov    0x8(%rsp),%rax
mov    %r12,(%r15)
mov    %rbp,(%rax)
add    $0x18,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
callq  68d <grecs_getline+0xbd>
jmp    63e <grecs_getline+0x6e>
mov    $0x1,%edi
mov    $0x1,%ebp
callq  69e <grecs_getline+0xce>
mov    %rax,%r12
jmpq   5f8 <grecs_getline+0x28>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_getline(char **pbuf, size_t *psize, FILE *fp)
{
 char *buf = *pbuf;
 size_t size = *psize;
 ssize_t off = 0;
 if (!buf) {
  size = 1;
  buf = grecs_malloc(size);
 }
 do {
  if (off == size - 1) {
   size_t nsize = 2 * size;
   if (nsize < size)
    grecs_alloc_die();
   buf = grecs_realloc(buf, nsize);
   size = nsize;
  }
  if (!fgets(buf + off, size - off, fp)) {
   if (off == 0)
    off = -1;
   break;
  }
  off += strlen(buf + off);
 } while (buf[off - 1] != '\n');
 *pbuf = buf;
 *psize = size;
 return off;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 2
13 6
14 6
15 7
16 7
17 7
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 23
27 23
28 23
29 24
30 24
31 11
32 11
33 11
34 12
35 13
36 13
37 15
38 15
39 12
40 15
41 15
42 15
43 15
44 20
45 20
46 20
47 26
48 25
49 26
50 28
51 28
52 28
53 28
54 28
55 28
56 28
57 28
58 28
59 28
60 14
61 14
62 8
63 7
64 8
65 8
66 8
67 8
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    (%rdi),%rdi
mov    0x20(%rsp),%r10
mov    0x40(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %r10,0x8(%rsp)
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  0 <interp2d_eval>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_eval_deriv_xy_e (const gsl_interp2d * interp, const double xarr[],
                              const double yarr[], const double zarr[],
                              const double x, const double y,
                              gsl_interp_accel * xa, gsl_interp_accel * ya, double * z)
{
  return interp2d_eval(interp->type->eval_deriv_xy, interp,
                       xarr, yarr, zarr, x, y, xa, ya, z);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
mov    (%rsi),%rax
movzbl 0xf(%rdi),%edx
lea    0x0(%rip),%rcx        # e <md2_transform+0xe>
xor    %r8d,%r8d
mov    %rax,0x20(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x28(%rdi)
mov    %rdi,%rax
movzbl 0x20(%rax),%r9d
add    $0x1,%rax
xor    0xf(%rax),%r9b
mov    %r9b,0x2f(%rax)
xor    (%rsi,%r8,1),%dl
add    $0x1,%r8
movzbl %dl,%edx
movzbl (%rcx,%rdx,1),%edx
xor    -0x1(%rax),%dl
mov    %dl,-0x1(%rax)
cmp    $0x10,%r8
jne    20 <md2_transform+0x20>
xor    %esi,%esi
xor    %eax,%eax
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
movzbl %al,%eax
movzbl (%rcx,%rax,1),%eax
xor    0x10(%rdi,%rdx,1),%al
mov    %al,0x10(%rdi,%rdx,1)
add    $0x1,%rdx
cmp    $0x30,%rdx
jne    58 <md2_transform+0x58>
add    %esi,%eax
add    $0x1,%esi
cmp    $0x12,%esi
jne    50 <md2_transform+0x50>
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
md2_transform(struct md2_ctx *ctx, const uint8_t *data)
{
  unsigned i;
  uint8_t t;
  memcpy(ctx->X + 16, data, 16);
  for (i = 0, t = ctx->C[15];
       i<16; i++)
    {
      ctx->X[2 * 16 + i]
 = ctx->X[i] ^ ctx->X[16 + i];
      t = (ctx->C[i] ^= S[data[i]^t]);
    }
  for (i = t = 0;
       i< 16 + 2;
       t = (t + i) & 0xff, i++)
    {
      unsigned j;
      for (j = 0; j < 3 * 16; j++)
 t = (ctx->X[j] ^= S[t]);
    }
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 5
6 5
7 5
8 5
9 10
10 10
11 10
12 10
13 11
14 11
15 11
16 11
17 11
18 11
19 6
20 6
21 6
22 6
23 6
24 6
25 19
26 19
27 19
28 19
29 19
30 18
31 18
32 15
33 15
34 13
35 13
36 13
37 13
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rdi
mov    %rsi,%rbx
callq  30 <def_count_defered_links_to_dev_ino.isra.0>
add    $0x1,%eax
cmp    0x28(%rbx),%eax
pop    %rbx
sete   %al
movzbl %al,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defer_is_last_link(DEFER * def, struct new_cpio_header *file_hdr)
{
        int other_files_sofar;
 other_files_sofar = def_count_defered_links_to_dev_ino(def, file_hdr);
        if ((int)(file_hdr->c_nlink) == (other_files_sofar + 1)) {
                return 1;
        }
        return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 9
8 5
9 5
10 9
11 9
<<<sep_out_sample>>>
movsd  0x58(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trust_avratio(void *vstate)
{
  trust_state_t *state = (trust_state_t *) vstate;
  return state->avratio;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     b31 <gsl_vector_ulong_isnull+0x41>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rdi
test   %rdi,%rdi
js     b40 <gsl_vector_ulong_isnull+0x50>
cvtsi2sd %rdi,%xmm0
ucomisd %xmm1,%xmm0
jp     b57 <gsl_vector_ulong_isnull+0x67>
jne    b57 <gsl_vector_ulong_isnull+0x67>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    b10 <gsl_vector_ulong_isnull+0x20>
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    %rdi,%r8
and    $0x1,%edi
shr    %r8
or     %rdi,%r8
cvtsi2sd %r8,%xmm0
addsd  %xmm0,%xmm0
jmp    b1d <gsl_vector_ulong_isnull+0x2d>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_isnull (const gsl_vector_ulong * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 11
16 11
17 6
18 6
19 6
20 6
21 17
22 18
23 18
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 13
32 13
33 13
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
mov    $0x0,%esi
mov    $0x11,%edi
jmpq   655f <set_sigchld_handler+0xf>
nop
<<<sep_in_sample>>>
set_sigchld_handler ()
{
  set_signal_handler (17, sigchld_handler);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movsd  %xmm0,(%rsp)
callq  b12 <SetVar+0x12>
cmp    $0x30000,%eax
movsd  (%rsp),%xmm0
je     b38 <SetVar+0x38>
cmp    $0x40000,%eax
je     b50 <SetVar+0x50>
cmp    $0x10000,%eax
je     b38 <SetVar+0x38>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
movzwl %bx,%ebx
mov    $0x1,%eax
movsd  %xmm0,0x0(,%rbx,8)
add    $0x8,%rsp
pop    %rbx
retq   
nop
movzwl %bx,%ebx
lea    (%rbx,%rbx,2),%rax
mov    0x0(,%rax,8),%rax
movsd  %xmm0,(%rax)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
SetVar (HVAR hvar, double dVal)
{
  BOOL bReturn = 1;
  switch (GetVarType (hvar)) {
    default:
    case 0x20000:
      bReturn = 0;
      break;
    case 0x30000:
    case 0x10000:
      vrgModelVars[((int) ((hvar) & 0x0FFFF))] = dVal;
      break;
    case 0x40000:
    {
      PVMMAPSTRCT pvm = &vrgvmGlo[((int) ((hvar) & 0x0FFFF))];
      *(PDOUBLE) pvm->pVar = dVal;
      break;
    }
  }
  return (bReturn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 21
14 7
15 21
16 21
17 21
18 11
19 3
20 11
21 21
22 21
23 21
24 21
25 15
26 15
27 16
28 16
29 21
30 3
31 21
32 21
33 21
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     7c4 <gsl_matrix_complex_float_isneg+0x64>
xorps  %xmm0,%xmm0
lea    0x0(,%rax,8),%r10
xor    %esi,%esi
xor    %r8d,%r8d
test   %rcx,%rcx
je     7b8 <gsl_matrix_complex_float_isneg+0x58>
mov    %rsi,%rdx
xor    %eax,%eax
add    0x18(%rdi),%rdx
jmp    7a4 <gsl_matrix_complex_float_isneg+0x44>
movss  0x4(%rdx,%rax,8),%xmm1
ucomiss %xmm0,%xmm1
jae    7ae <gsl_matrix_complex_float_isneg+0x4e>
add    $0x1,%rax
cmp    %rcx,%rax
je     7b8 <gsl_matrix_complex_float_isneg+0x58>
movss  (%rdx,%rax,8),%xmm1
ucomiss %xmm0,%xmm1
jb     790 <gsl_matrix_complex_float_isneg+0x30>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    780 <gsl_matrix_complex_float_isneg+0x20>
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_isneg (const gsl_matrix_complex_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 13
23 13
24 13
25 15
26 15
27 15
28 7
29 7
30 7
31 7
32 20
33 20
34 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 195a <gsl_matrix_char_const_ptr+0xa>
test   %eax,%eax
je     1969 <gsl_matrix_char_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1980 <gsl_matrix_char_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    19a0 <gsl_matrix_char_const_ptr+0x50>
mov    %rsi,%rax
imul   0x10(%rdi),%rax
add    %rdx,%rax
add    0x18(%rdi),%rax
add    $0x8,%rsp
retq   
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1999 <gsl_matrix_char_const_ptr+0x49>
xor    %eax,%eax
jmp    1978 <gsl_matrix_char_const_ptr+0x28>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  19b9 <gsl_matrix_char_const_ptr+0x69>
xor    %eax,%eax
jmp    1978 <gsl_matrix_char_const_ptr+0x28>
<<<sep_in_sample>>>
gsl_matrix_char_const_ptr(const gsl_matrix_char * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_char.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_char.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const char *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  939 <gsl_blas_srotmg+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
{
  cblas_srotmg (d1, d2, b1, b2, P);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x1,%ebp
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
callq  65 <get_slc_defaults+0x15>
nopl   (%rax)
lea    0x7(%rbx),%rdx
mov    %rbx,%rsi
mov    %ebp,%edi
add    $0x1,%ebp
add    $0x10,%rbx
callq  7d <get_slc_defaults+0x2d>
movb   $0x0,-0xf(%rbx)
mov    %al,-0x11(%rbx)
movb   $0x0,-0xe(%rbx)
cmp    $0x13,%ebp
jne    68 <get_slc_defaults+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_slc_defaults (void)
{
  register int i;
  init_termbuf ();
  for (i = 1; i <= 18; i++)
    {
      slctab[i].defset.flag =
 spcset (i, &slctab[i].defset.val, &slctab[i].sptr);
      slctab[i].current.flag = 0;
      slctab[i].current.val = 0;
    }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 4
9 8
10 8
11 5
12 5
13 8
14 9
15 7
16 10
17 5
18 5
19 12
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
push   %r13
mov    %ecx,%r8d
mov    %edx,%r13d
push   %r12
mov    %ecx,%r12d
mov    %edx,%ecx
mov    %esi,%edx
push   %rbp
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12d,%ecx
mov    %r13d,%r8d
xor    %r9d,%r9d
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x63,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   ad0 <_rx.isra.34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_ldxr_i(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r0, r1, r2);
    *_jit->pc.uc++ = 0x63;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 2
9 2
10 3
11 2
12 2
13 2
14 3
15 4
16 5
17 5
18 5
19 5
20 5
21 4
22 4
23 4
24 6
25 6
26 6
27 6
28 6
29 5
30 5
31 5
<<<sep_out_sample>>>
test   %esi,%esi
mov    %edx,(%rdi)
movb   $0x0,0x4(%rdi)
movb   $0x0,0x28(%rdi)
movb   $0x0,0x54(%rdi)
movb   $0x0,0xd8(%rdi)
js     65f <taru_digs_init+0x2f>
mov    %si,0x26(%rdi)
mov    %si,0x52(%rdi)
mov    %si,0xd6(%rdi)
mov    %si,0xf8(%rdi)
repz retq 
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_digs_init(FILE_DIGS * digs, int enable, int poison)
{
 digs->do_poisonM = poison;
 digs->md5[0] = '\0';
 digs->sha1[0] = '\0';
 digs->sha512[0] = '\0';
 digs->size[0] = '\0';
 if (enable >= 0) {
  digs->do_md5 = enable;
  digs->do_sha1 = enable;
  digs->do_sha512 = enable;
  digs->do_size = enable;
 }
}
<<<sep_in_sample>>>
1 8
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 12
13 12
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
sub    $0x48,%rsp
xor    %eax,%eax
mov    %rdi,%rdx
mov    $0x7,%ecx
mov    %rsp,%rdi
cmp    $0x8,%esi
rep stos %rax,%es:(%rdi)
je     61 <quoting_options_from_style+0x61>
mov    %esi,(%rsp)
mov    (%rsp),%rax
mov    %rax,(%rdx)
mov    0x8(%rsp),%rax
mov    %rax,0x8(%rdx)
mov    0x10(%rsp),%rax
mov    %rax,0x10(%rdx)
mov    0x18(%rsp),%rax
mov    %rax,0x18(%rdx)
mov    0x20(%rsp),%rax
mov    %rax,0x20(%rdx)
mov    0x28(%rsp),%rax
mov    %rax,0x28(%rdx)
mov    0x30(%rsp),%rax
mov    %rax,0x30(%rdx)
mov    %rdx,%rax
add    $0x48,%rsp
retq   
callq  66 <quoting_options_from_style+0x66>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quoting_options_from_style (enum quoting_style style)
{
  struct quoting_options o = { 0 };
  if (style == custom_quoting_style)
    abort ();
  o.style = style;
  return o;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 3
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 5
28 5
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
mov    $0x1,%ecx
mov    $0x1,%edx
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  5ef <get_flag_var+0x1f>
mov    0x8(%rsp),%r8
test   %r8,%r8
je     670 <get_flag_var+0xa0>
mov    $0x3,%ecx
mov    $0x0,%edi
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x1,%eax
seta   %cl
setb   %dl
cmp    %dl,%cl
je     635 <get_flag_var+0x65>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %r8,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
jne    640 <get_flag_var+0x70>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rdx        # 647 <get_flag_var+0x77>
mov    0x0(%rip),%rdi        # 64e <get_flag_var+0x7e>
mov    %rbx,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  65d <get_flag_var+0x8d>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_flag_var(var_name, default_value)
    char *var_name;
    int default_value;
{
    char *data;
    configuration_getvarinfo(var_name, &data, 1, 1);
    if (data)
    {
 if (strcmp(data, "ON") == 0)
     return 1;
 if (strcmp(data, "OFF") == 0)
     return 0;
 fprintf(stderr, "%s: invalid %s (%s).\n", g_program, var_name, data);
 return default_value;
    }
    return default_value;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 4
6 4
7 4
8 6
9 6
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 10
18 9
19 9
20 9
21 9
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 17
33 17
34 17
35 17
36 17
37 13
38 13
39 13
40 13
41 13
42 13
43 17
44 14
45 17
46 17
47 17
48 17
49 17
50 16
51 17
52 17
53 17
54 17
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
jmp    262 <jobserver_release+0x12>
nopl   (%rax)
callq  25d <jobserver_release+0xd>
cmpl   $0x4,(%rax)
jne    281 <jobserver_release+0x31>
mov    0x0(%rip),%edi        # 268 <jobserver_release+0x18>
mov    $0x1,%edx
mov    $0x0,%esi
callq  277 <jobserver_release+0x27>
cmp    $0xffffffff,%eax
je     258 <jobserver_release+0x8>
cmp    $0x1,%eax
je     298 <jobserver_release+0x48>
test   %ebx,%ebx
jne    29a <jobserver_release+0x4a>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   295 <jobserver_release+0x45>
nopl   (%rax)
pop    %rbx
retq   
mov    $0x0,%edi
callq  2a4 <jobserver_release+0x54>
mov    %rax,%rdi
callq  2ac <jobserver_release+0x5c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
jobserver_release (int is_fatal)
{
  int r;
  while (((r)=write (job_fds[1], &token, 1))==-1 && (*__errno_location ())==4);
  if (r != 1)
    {
      if (is_fatal)
        pfatal_with_name (gettext ("write jobserver"));
      perror_with_name ("write", "");
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 7
17 7
18 11
19 9
20 9
21 9
22 9
23 11
24 11
25 8
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # 3b <gawk_exit+0xb>
je     52 <gawk_exit+0x22>
mov    %edi,0x0(%rip)        # 43 <gawk_exit+0x13>
mov    $0x1,%esi
mov    $0x0,%edi
callq  52 <gawk_exit+0x22>
callq  57 <gawk_exit+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gawk_exit(int status)
{
 if (fatal_tag_valid) {
  exit_val = status;
  longjmp(fatal_tag, 1);
 }
 final_exit(status);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 5
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %r14
test   %edx,%edx
mov    %edx,%r14d
push   %r13
push   %r12
push   %rbp
push   %rbx
jle    9c <f_string+0x9c>
mov    %rsi,%rbx
mov    %rdi,%rbp
callq  1e <f_string+0x1e>
mov    %rax,%r13
lea    -0x1(%r14),%eax
lea    0x1(%rbx,%rax,1),%r12
jmp    41 <f_string+0x41>
nopl   0x0(%rax)
mov    %rbp,%rsi
callq  38 <f_string+0x38>
add    $0x1,%rbx
cmp    %r12,%rbx
je     79 <f_string+0x79>
movzbl (%rbx),%ecx
mov    0x0(%r13),%rax
movsbq %cl,%rdx
movsbl %cl,%edi
testb  $0x40,0x1(%rax,%rdx,2)
jne    30 <f_string+0x30>
callq  5b <f_string+0x5b>
test   %eax,%eax
je     88 <f_string+0x88>
mov    %eax,%edx
mov    $0x0,%esi
xor    %eax,%eax
mov    %rbp,%rdi
add    $0x1,%rbx
callq  74 <f_string+0x74>
cmp    %r12,%rbx
jne    41 <f_string+0x41>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14d,%eax
pop    %r14
retq   
nopl   (%rax)
movsbl (%rbx),%edx
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  9a <f_string+0x9a>
jmp    38 <f_string+0x38>
xor    %r14d,%r14d
jmp    79 <f_string+0x79>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_string (FILE *fp, void *ptr, int size)
{
  int sz;
  char *s;
  for (sz = 0, s = ptr; sz < size; s++, sz++)
    {
      int c;
      if (((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISprint))
 fputc (*s, fp);
      else if ((c = escape (*s)))
 fprintf (fp, "\\%c", c);
      else
 fprintf (fp, "\\%03o", *s);
    }
  return sz;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 9
18 9
19 5
20 5
21 5
22 8
23 8
24 8
25 9
26 8
27 8
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 5
36 11
37 5
38 5
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 13
48 13
49 13
50 13
51 13
52 13
53 5
54 5
55 5
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    $0xc,%esi
jmpq   d <gcm_camellia256_set_nonce_wrapper+0xd>
<<<sep_in_sample>>>
gcm_camellia256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)
{
  nettle_gcm_camellia256_set_iv (ctx, (16 - 4), nonce);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 737 <lang_wanted+0x7>
test   %rsi,%rsi
je     758 <lang_wanted+0x28>
sub    $0x8,%rsp
callq  745 <lang_wanted+0x15>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 75f <lang_wanted+0x2f>
test   %rsi,%rsi
je     770 <lang_wanted+0x40>
jmpq   769 <lang_wanted+0x39>
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lang_wanted (char const *lang_name)
{
  if (langs_excluded)
    return !string_in_vector (lang_name, langs_excluded);
  else if (langs_included)
    return string_in_vector (lang_name, langs_included);
  else
    return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 4
6 4
7 4
8 9
9 4
10 9
11 9
12 5
13 5
14 5
15 6
16 6
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2d9 <smtp_step_recv+0x9>
test   %eax,%eax
je     328 <smtp_step_recv+0x58>
mov    (%rbx),%rbx
mov    %rbx,%rdi
callq  2e8 <smtp_step_recv+0x18>
mov    %rax,%rdx
xor    %eax,%eax
cmp    $0x3,%rdx
jbe    328 <smtp_step_recv+0x58>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     370 <smtp_step_recv+0xa0>
mov    $0x4,%ecx
mov    $0x0,%edi
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x2,%eax
seta   %cl
setb   %dl
cmp    %dl,%cl
jne    330 <smtp_step_recv+0x60>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x0,%edi
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x3,%al
seta   %cl
setb   %dl
cmp    %dl,%cl
je     328 <smtp_step_recv+0x58>
mov    $0x0,%edi
callq  355 <smtp_step_recv+0x85>
mov    0x0(%rip),%rdi        # 35c <smtp_step_recv+0x8c>
mov    %rbx,%rdx
mov    %rax,%rsi
xor    %eax,%eax
callq  369 <smtp_step_recv+0x99>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
lea    0x4(%rbx),%rsi
sub    $0x3,%rdx
mov    %rbx,%rdi
callq  380 <smtp_step_recv+0xb0>
mov    %rbx,%rdi
callq  388 <smtp_step_recv+0xb8>
lea    -0x1(%rbx,%rax,1),%rcx
movzbl (%rcx),%edx
cmp    $0xa,%dl
je     3a8 <smtp_step_recv+0xd8>
cmp    $0xd,%dl
mov    $0x1,%eax
jne    328 <smtp_step_recv+0x58>
movb   $0x0,(%rcx)
pop    %rbx
retq   
nopl   0x0(%rax)
movb   $0x0,(%rcx)
mov    %rbx,%rdi
callq  3b3 <smtp_step_recv+0xe3>
lea    -0x1(%rbx,%rax,1),%rcx
movzbl (%rcx),%edx
jmp    395 <smtp_step_recv+0xc5>
nopl   (%rax)
<<<sep_in_sample>>>
smtp_step_recv (char **data)
{
  char *p;
  if (!readln (data))
    return 0;
  p = *data;
  if (strlen (p) <= 3)
    return 0;
  if (strncmp (p, "334 ", 4) == 0)
    {
      memmove (&p[0], &p[4], strlen (p) - 3);
      if (p[strlen (p) - 1] == '\n')
 p[strlen (p) - 1] = '\0';
      if (p[strlen (p) - 1] == '\r')
 p[strlen (p) - 1] = '\0';
      return 1;
    }
  if (strncmp (p, "235 ", 4) == 0)
    {
      return 2;
    }
  if (strncmp (p, "535 ", 4) == 0)
    return 3;
  fprintf (stderr, gettext ("error: could not parse server data:\n%s\n"), p);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 6
7 7
8 7
9 7
10 5
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 18
19 18
20 18
21 18
22 20
23 18
24 18
25 18
26 18
27 18
28 26
29 26
30 26
31 22
32 22
33 22
34 22
35 23
36 22
37 22
38 22
39 22
40 24
41 24
42 24
43 24
44 24
45 24
46 24
47 25
48 26
49 26
50 26
51 11
52 11
53 11
54 11
55 12
56 12
57 12
58 12
59 12
60 12
61 14
62 16
63 14
64 15
65 26
66 26
67 26
68 13
69 13
70 13
71 13
72 13
73 13
74 13
<<<sep_out_sample>>>
cmpl   $0x3,0x8(%rdi)
mov    $0xffffffff,%eax
jne    11ce <rec_type_min+0xe>
mov    0x20(%rdi),%eax
repz retq 
<<<sep_in_sample>>>
rec_type_min (rec_type_t type)
{
  int res;
  if (type->kind != REC_TYPE_RANGE)
    {
      res = -1;
    }
  else
    {
      res = type->data.range[0];
    }
  return res;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 10
5 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     156 <cdio_audio_read_subchannel+0x26>
mov    0x28(%rdi),%rax
test   %rax,%rax
je     150 <cdio_audio_read_subchannel+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_audio_read_subchannel (CdIo_t *p_cdio, cdio_subchannel_t *p_subchannel)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_read_subchannel) {
    return p_cdio->op.audio_read_subchannel(p_cdio->env, p_subchannel);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
13 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  199 <xstrdup+0x9>
mov    %rbx,%rdi
lea    0x1(%rax),%rsi
pop    %rbx
jmpq   1a6 <xstrdup+0x16>
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
<<<sep_out_sample>>>
mov    (%rdi),%rsi
cmp    %rsi,0x8(%rdi)
cmovbe 0x8(%rdi),%rsi
mov    0x10(%rdi),%rax
test   %rsi,%rsi
je     335e <gsl_matrix_ushort_add_diagonal+0x3e>
lea    0x2(%rax,%rax,1),%r8
mov    0x18(%rdi),%rax
xor    %edx,%edx
movzwl (%rax),%ecx
add    $0x1,%rdx
cvtsi2sd %ecx,%xmm1
addsd  %xmm0,%xmm1
cvttsd2si %xmm1,%ecx
mov    %cx,(%rax)
add    %r8,%rax
cmp    %rsi,%rdx
jne    3340 <gsl_matrix_ushort_add_diagonal+0x20>
xor    %eax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_add_diagonal (gsl_matrix_ushort * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  const size_t loop_lim = ( M < N ? M : N );
  size_t i;
  for (i = 0; i < loop_lim; i++)
  {
    a->data[i * tda + i] += x;
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 5
5 8
6 8
7 8
8 8
9 8
10 10
11 8
12 10
13 10
14 10
15 10
16 10
17 8
18 8
19 13
20 13
21 13
<<<sep_out_sample>>>
xor    %ecx,%ecx
jmpq   567 <gsl_multifit_fdfridge_set+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfridge_set (gsl_multifit_fdfridge * w,
                           gsl_multifit_function_fdf * f,
                           const gsl_vector * x,
                           const double lambda)
{
  return gsl_multifit_fdfridge_wset(w, f, x, lambda, ((void *)0));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d0 <xfree+0x10>
jmpq   1ca <xfree+0xa>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xfree (string)
     void * string;
{
  if (string)
    free (string);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  1f5 <equivalent+0x15>
mov    %eax,%edx
mov    $0x1,%eax
test   %edx,%edx
je     26a <equivalent+0x8a>
cmpb   $0x0,(%r12)
je     263 <equivalent+0x83>
mov    %r12,%rdi
nopw   0x0(%rax,%rax,1)
mov    $0x2f,%esi
callq  21a <equivalent+0x3a>
test   %rax,%rax
mov    %rax,%rbx
je     256 <equivalent+0x76>
movzbl 0x1(%rax),%edx
lea    0x2(%rax),%rbp
lea    0x1(%rax),%rcx
cmp    $0x2f,%dl
jne    24f <equivalent+0x6f>
nopl   0x0(%rax,%rax,1)
mov    %rcx,%rdi
mov    %rbp,%rsi
callq  243 <equivalent+0x63>
movzbl 0x1(%rbx),%edx
mov    %rax,%rcx
cmp    $0x2f,%dl
je     238 <equivalent+0x58>
test   %dl,%dl
mov    %rcx,%rdi
jne    210 <equivalent+0x30>
mov    %r13,%rsi
mov    %r12,%rdi
callq  261 <equivalent+0x81>
mov    %eax,%edx
xor    %eax,%eax
test   %edx,%edx
sete   %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
equivalent(char *lname, const char *rname)
{
    char *s;
    if (!strcmp(lname, rname))
        return 1;
    for (s = lname; *s && (s = strchr(s, '/')); s++) {
        while (s[1] == '/')
            strcpy(s+1, s+2);
    }
    return !strcmp(lname, rname);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 5
11 4
12 4
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 8
29 8
30 8
31 7
32 8
33 7
34 7
35 6
36 8
37 6
38 6
39 6
40 6
41 6
42 10
43 10
44 10
45 11
46 11
47 11
48 11
49 11
50 11
51 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    $0x0,%esi
callq  131 <write_header_line+0x11>
nopl   0x0(%rax)
mov    %rax,%rdx
xor    %edi,%edi
mov    %rbx,%rsi
callq  145 <write_header_line+0x25>
xor    %edi,%edi
mov    %rbx,%rsi
callq  14f <write_header_line+0x2f>
xor    %edi,%edi
mov    $0x0,%esi
callq  15b <write_header_line+0x3b>
test   %rax,%rax
jne    138 <write_header_line+0x18>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_header_line (NET_STREAM sd_server, char *line)
{
  char *p;
  p = strtok (line, "\r\n");
  do
    {
      swrite (0, sd_server, p);
      send_eol (0, sd_server);
    }
  while ((p = strtok (((void *)0), "\r\n")));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 10
15 10
16 10
17 10
18 10
19 11
20 11
21 11
<<<sep_out_sample>>>
push   %rbx
mov    $0xa0,%esi
mov    $0x1,%edi
sub    $0x10,%rsp
movsd  %xmm0,0x8(%rsp)
callq  fa <gsl_rstat_quantile_alloc+0x1a>
test   %rax,%rax
mov    %rax,%rbx
movsd  0x8(%rsp),%xmm0
je     120 <gsl_rstat_quantile_alloc+0x40>
movsd  %xmm0,(%rax)
mov    %rax,%rdi
callq  114 <gsl_rstat_quantile_alloc+0x34>
mov    %rbx,%rax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   (%rax)
mov    $0x8,%ecx
mov    $0x2f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  139 <gsl_rstat_quantile_alloc+0x59>
xor    %eax,%eax
jmp    117 <gsl_rstat_quantile_alloc+0x37>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_rstat_quantile_alloc(const double p)
{
  gsl_rstat_quantile_workspace *w;
  w = calloc(1, sizeof(gsl_rstat_quantile_workspace));
  if (w == 0)
    {
      do { gsl_error ("failed to allocate space for workspace", "rquantile.c", 47, GSL_ENOMEM) ; return 0 ; } while (0);
    }
  w->p = p;
  gsl_rstat_quantile_reset(w);
  return w;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 4
7 5
8 4
9 5
10 5
11 9
12 10
13 10
14 11
15 12
16 12
17 12
18 12
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  4e7e <insertTab+0xe>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   4e89 <insertTab+0x19>
<<<sep_in_sample>>>
insertTab()
{
  int j = TAB_CHARS-((selectedChar+selectedCharCarry)%TAB_CHARS);
  j = 0 ? TAB_CHARS:j;
  static char *t = "\t   ";
  insertChar(t);
  refreshBottomView();
  return;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 9
6 7
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
xor    %r8d,%r8d
xor    %ecx,%ecx
jmpq   ada <message+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message (char const *format_msgid, char const *arg1, char const *arg2)
{
  message5 (format_msgid, arg1, arg2, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x28(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
styled_ostream_free (styled_ostream_t first_arg)
{
  const struct styled_ostream_implementation *vtable =
    ((struct styled_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->free (first_arg);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
xor    %r8d,%r8d
jmpq   768 <gsl_multifit_fdfridge_set2+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfridge_set2 (gsl_multifit_fdfridge * w,
                            gsl_multifit_function_fdf * f,
                            const gsl_vector * x,
                            const gsl_vector * lambda)
{
  return gsl_multifit_fdfridge_wset2(w, f, x, lambda, ((void *)0));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <pair_hash_1+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <pair_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
pair_hash_1 (struct pair *pair)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((pair->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  519 <swi_xfile_has_posix_control_file+0x9>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
swi_xfile_has_posix_control_file(SWI_XFILE * xfile, char * tag)
{
 SWI_CONTROL_SCRIPT * ret;
 ret = swi_xfile_get_control_script_by_tag(xfile, tag);
 return ret ? 1 : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 6
6 5
7 6
<<<sep_out_sample>>>
mov    $0x0,%edx
mov    $0x80,%ecx
xor    %eax,%eax
mov    %rdx,%rdi
mov    %rdx,0x0(%rip)        # 96 <reinitialize+0x16>
movl   $0x0,0x0(%rip)        # a0 <reinitialize+0x20>
rep stos %rax,%es:(%rdi)
movq   $0x0,0x0(%rip)        # ae <reinitialize+0x2e>
retq   
nop
<<<sep_in_sample>>>
reinitialize()
{
 memset (curline, 0, 1024);
 where = curline;
 linenum = 0;
 defined = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 3
8 6
9 6
10 6
<<<sep_out_sample>>>
movl   $0x69,0x0(%rip)        # 91a <_rl_vi_reset_last+0xa>
movl   $0x1,0x0(%rip)        # 924 <_rl_vi_reset_last+0x14>
movl   $0x1,0x0(%rip)        # 92e <_rl_vi_reset_last+0x1e>
movl   $0x0,0x0(%rip)        # 938 <_rl_vi_reset_last+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_vi_reset_last ()
{
  _rl_vi_last_command = 'i';
  _rl_vi_last_repeat = 1;
  _rl_vi_last_arg_sign = 1;
  _rl_vi_last_motion = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 6
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 3ca <_rl_reset_argument+0xa>
movl   $0x1,0x0(%rip)        # 3d4 <_rl_reset_argument+0x14>
movl   $0x0,0x0(%rip)        # 3de <_rl_reset_argument+0x1e>
movl   $0x0,0x0(%rip)        # 3e8 <_rl_reset_argument+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_reset_argument ()
{
  rl_numeric_arg = rl_arg_sign = 1;
  rl_explicit_arg = 0;
  _rl_argcxt = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    $0x1a4,%edx
mov    $0x441,%esi
xor    %eax,%eax
jmpq   1791 <swc_open_logfile+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc_open_logfile(char * logfile)
{
 int ret;
 ret = open(logfile, 01|0100|02000, 0644);
 return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2e6 <get_report_func+0x6>
lea    -0x2(%rax),%edx
mov    $0x0,%eax
cmp    $0x2,%edx
ja     2fb <get_report_func+0x1b>
mov    0x0(,%rdx,8),%rax
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
get_report_func (void)
{
  switch (result_style)
    {
    case rs_filenames: return report_filenames;
    case rs_grep: return report_grep;
    case rs_edit: return report_edit;
    default: return report_nothing;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 10
8 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     71 <_stdio_free+0x11>
callq  71 <_stdio_free+0x11>
cmpq   $0x0,0x8(%rbx)
je     80 <_stdio_free+0x20>
mov    %rbx,%rdi
callq  10 <_stdio_close>
mov    %rbx,%rdi
pop    %rbx
jmpq   89 <_stdio_free+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_stdio_free(void *user_data)
{
  _UserData *const ud = user_data;
  if (ud->pathname)
    free(ud->pathname);
  if (ud->fd)
    _stdio_close(user_data);
  free(ud);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 7
10 7
11 8
12 9
13 8
14 8
<<<sep_out_sample>>>
push   %r14
mov    %rcx,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
test   %rsi,%rsi
je     290 <mu_nntp_head+0x80>
mov    $0x80,%edi
mov    %r8,0x8(%rsp)
callq  23c <mu_nntp_head+0x2c>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     282 <mu_nntp_head+0x72>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x7f,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  260 <mu_nntp_head+0x50>
mov    0x8(%rsp),%r8
mov    %r14,%rcx
mov    %r13,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  276 <mu_nntp_head+0x66>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  280 <mu_nntp_head+0x70>
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
add    $0x10,%rsp
xor    %esi,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
jmpq   2a3 <mu_nntp_head+0x93>
<<<sep_in_sample>>>
mu_nntp_head (mu_nntp_t nntp, unsigned long number, unsigned long *pnum, char **mid, mu_stream_t *pstream)
{
  int status;
  char *message_id = ((void *)0);
  if (number != 0)
    {
      message_id = malloc (128);
      if (message_id == ((void *)0))
 {
   return 12;
 }
      snprintf (message_id, 127, "%lu", number);
    }
  status = mu_nntp_head_id (nntp, message_id, pnum, mid, pstream);
  if (message_id)
    {
      free (message_id);
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 7
14 7
15 7
16 7
17 10
18 8
19 8
20 12
21 12
22 12
23 12
24 12
25 12
26 14
27 14
28 14
29 14
30 14
31 14
32 17
33 14
34 17
35 14
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 14
46 20
47 20
48 20
49 20
50 20
51 14
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
xor    %edx,%edx
cmp    %rax,0x8(%rdi)
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
jit_finish_debug(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,(%rdi)
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
jne    370 <stream_close+0x20>
callq  362 <stream_close+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   36b <stream_close+0x1b>
nopl   0x0(%rax,%rax,1)
callq  375 <stream_close+0x25>
mov    %rbx,%rdi
pop    %rbx
jmpq   37e <stream_close+0x2e>
<<<sep_in_sample>>>
stream_close (struct stream * stream)
{
  if (stream->is_file)
    fclose (stream->fp);
  else
    pclose (stream->fp);
  free (stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 3
6 6
7 7
8 8
9 7
10 7
11 4
12 7
13 8
14 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  2d0c <gsl_sf_gammastar+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    2d20 <gsl_sf_gammastar+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x680,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2d36 <gsl_sf_gammastar+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_gammastar(const double x)
{
  gsl_sf_result result; int status = gsl_sf_gammastar_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_gammastar_e(x, &result)", "gamma.c", 1664, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # d7 <nettle_eax_aes128_digest+0x7>
mov    %rdi,%rax
mov    %rdx,%r9
lea    0x60(%rdi),%rdx
lea    0x20(%rdi),%rdi
mov    %rsi,%r8
mov    %rax,%rsi
jmpq   f0 <nettle_eax_aes128_digest+0x20>
<<<sep_in_sample>>>
nettle_eax_aes128_digest(struct eax_aes128_ctx *ctx,
    size_t length, uint8_t *digest)
{
  (0 ? (nettle_aes128_encrypt) (&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_eax_digest (&(ctx)->eax, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (digest)));
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    $0x18,%esi
mov    $0x1,%edi
jmpq   f <_cdio_list_new+0xf>
nop
<<<sep_in_sample>>>
_cdio_list_new (void)
{
  CdioList_t *p_new_obj = calloc (1, sizeof (CdioList_t));
  return p_new_obj;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x5f8(%rsi),%rdx
mov    %rdi,%rax
mov    %rax,%rsi
mov    0x68(%rdx),%rdi
jmpq   5c6 <dump_setup+0x16>
<<<sep_in_sample>>>
dump_setup (FILE * stream, a2ps_job * job)
{
  output_dump (job->status->setup, stream);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
mov    $0xc,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 12 <find_footnotes_window+0x12>
test   %rbx,%rbx
je     49 <find_footnotes_window+0x49>
nopw   0x0(%rax,%rax,1)
mov    0x30(%rbx),%rdi
callq  29 <find_footnotes_window+0x29>
test   %eax,%eax
je     41 <find_footnotes_window+0x41>
mov    0x30(%rbx),%rax
mov    $0x0,%edi
mov    %rbp,%rcx
mov    0x10(%rax),%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     4b <find_footnotes_window+0x4b>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    20 <find_footnotes_window+0x20>
xor    %ebx,%ebx
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_footnotes_window (void)
{
  WINDOW *win;
  for (win = windows; win; win = win->next)
    if (internal_info_node_p (win->node) &&
        (strcmp (win->node->nodename, footnote_nodename) == 0))
      break;
  return win;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 6
17 5
18 5
19 4
20 4
21 4
22 2
23 9
24 9
25 9
26 9
27 9
28 9
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    %rdi,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  886 <print_version_only+0x16>
mov    $0x0,%edi
callq  890 <print_version_only+0x20>
mov    %rbx,%rdi
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  8a2 <print_version_only+0x32>
mov    %rbx,%rsi
mov    $0xa,%edi
pop    %rbx
jmpq   8b0 <print_version>
<<<sep_in_sample>>>
print_version_only(const char *program_version, FILE *stream)
{
  fprintf (stream, "%s\n", program_version);
  fprintf (stream, version_etc_copyright, gettext("(C)"));
  fputc ('\n', stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fdfsolver_root (const gsl_multiroot_fdfsolver * s)
{
  return s->x;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x1e,%edi
xor    %eax,%eax
cmp    $0x11,%edi
ja     12 <findColorName+0x12>
mov    0x0(,%rdi,8),%rax
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findColorName(int c)
{
  switch(c)
  {
    case(30):case(40): return "BLACK  "; break;
    case(31):case(41): return "RED    "; break;
    case(32):case(42): return "GREEN  "; break;
    case(33):case(43): return "BROWN  "; break;
    case(34):case(44): return "BLUE   "; break;
    case(35):case(45): return "MAGENTA"; break;
    case(36):case(46): return "CYAN   "; break;
    case(37):case(47): return "WHITE  "; break;
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 15
7 15
<<<sep_out_sample>>>
push   %r12
mov    %r8,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
callq  170f <mu_header_get_field_value_unfold+0xf>
test   %eax,%eax
mov    %eax,%ebx
jne    1720 <mu_header_get_field_value_unfold+0x20>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  1720 <mu_header_get_field_value_unfold+0x20>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_header_get_field_value_unfold (mu_header_t header, size_t num, char *buf,
      size_t buflen, size_t *nwritten)
{
  int rc = mu_header_get_field_value (header, num, buf, buflen, nwritten);
  if (rc == 0)
    mu_string_unfold (buf, nwritten);
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 4
9 5
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 2dd7 <vapply+0x7>
push   %rbx
callq  2ddd <vapply+0xd>
test   %rax,%rax
mov    %rax,%rbx
je     2ded <vapply+0x1d>
mov    %rax,%rdi
callq  2ded <vapply+0x1d>
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vapply (func)
     sh_var_map_func_t *func;
{
  SHELL_VAR **list;
  list = map_over (func, shell_variables);
  if (list )
    sort_variables (list);
  return (list);
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 6
5 5
6 6
7 7
8 7
9 9
10 9
11 9
12 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   %rdi,%rdi
je     4a0 <parse_opt_set_metric+0x80>
testb  $0x1,0x9(%rbx)
jne    480 <parse_opt_set_metric+0x60>
lea    0x8(%rsp),%rsi
xor    %edx,%edx
mov    %rbp,%rdi
callq  446 <parse_opt_set_metric+0x26>
mov    %eax,0x4c(%rbx)
cmpb   $0x0,0x0(%rbp)
je     459 <parse_opt_set_metric+0x39>
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
je     472 <parse_opt_set_metric+0x52>
mov    (%rbx),%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  472 <parse_opt_set_metric+0x52>
orl    $0x100,0x8(%rbx)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    (%rbx),%r8
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  49b <parse_opt_set_metric+0x7b>
jmp    437 <parse_opt_set_metric+0x17>
nopl   (%rax)
mov    %rsi,%r8
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  4bb <parse_opt_set_metric+0x9b>
jmpq   431 <parse_opt_set_metric+0x11>
<<<sep_in_sample>>>
parse_opt_set_metric (struct ifconfig *ifp, char *arg) { char *end; if (!ifp) error (1, 0, "no interface specified for %s `%s'\n", "metric value", arg); if (ifp->valid & 0x100) error (1, 0, "only one %s allowed for interface `%s'", "metric value", ifp->name); ifp->metric = strtol (arg, &end, 0); if (*arg == '\0' || *end != '\0') error (1, 0, "mtu value `%s' for interface `%s' is not a number", arg, ifp->name); ifp->valid |= 0x100; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
44 1
45 1
46 1
47 1
48 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
jmp    345 <rl_digit_loop+0x35>
nopw   %cs:0x0(%rax,%rax,1)
callq  325 <rl_digit_loop+0x15>
test   %eax,%eax
js     360 <rl_digit_loop+0x50>
mov    0x0(%rip),%edi        # 32f <rl_digit_loop+0x1f>
mov    %eax,%esi
xor    %eax,%eax
callq  338 <rl_digit_loop+0x28>
test   %eax,%eax
jle    353 <rl_digit_loop+0x43>
testb  $0x4,0x0(%rip)        # 343 <rl_digit_loop+0x33>
je     353 <rl_digit_loop+0x43>
callq  34a <rl_digit_loop+0x3a>
test   %eax,%eax
je     320 <rl_digit_loop+0x10>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  365 <rl_digit_loop+0x55>
mov    $0xffffffff,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_digit_loop ()
{
  int c, r;
  while (1)
    {
      if (_rl_arg_overflow ())
 return 1;
      c = _rl_arg_getchar ();
      if (c < 0)
 {
   _rl_abort_internal ();
   return -1;
 }
      r = _rl_arg_dispatch (_rl_argcxt, c);
      if (r <= 0 || ((rl_readline_state & (0x0000400)) == 0))
        break;
    }
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 8
5 9
6 9
7 14
8 14
9 14
10 14
11 15
12 15
13 15
14 15
15 6
16 6
17 6
18 7
19 19
20 19
21 19
22 11
23 12
24 19
25 19
26 19
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  59 <fatal+0x9>
mov    $0x0,%edx
mov    %rax,%rcx
xor    %esi,%esi
mov    $0x2,%edi
xor    %eax,%eax
callq  6f <fatal+0x1f>
callq  74 <fatal+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fatal (char const *msgid)
{
  error (2, 0, "%s", gettext (msgid));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
sub    $0x2e8,%rsp
test   %al,%al
mov    %rdx,0x240(%rsp)
mov    %rcx,0x248(%rsp)
mov    %r8,0x250(%rsp)
mov    %r9,0x258(%rsp)
je     1eb <info+0x6b>
movaps %xmm0,0x260(%rsp)
movaps %xmm1,0x270(%rsp)
movaps %xmm2,0x280(%rsp)
movaps %xmm3,0x290(%rsp)
movaps %xmm4,0x2a0(%rsp)
movaps %xmm5,0x2b0(%rsp)
movaps %xmm6,0x2c0(%rsp)
movaps %xmm7,0x2d0(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0x228(%rsp)
xor    %eax,%eax
cmp    %edi,0x0(%rip)        # 204 <info+0x84>
jge    228 <info+0xa8>
mov    0x228(%rsp),%rax
xor    %fs:0x28,%rax
jne    308 <info+0x188>
add    $0x2e8,%rsp
retq   
nopl   (%rax)
lea    0x2f0(%rsp),%rax
lea    0x8(%rsp),%rcx
lea    0x20(%rsp),%rdi
mov    %rsi,%rdx
mov    $0x200,%esi
movl   $0x10,0x8(%rsp)
mov    %rax,0x10(%rsp)
lea    0x230(%rsp),%rax
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  269 <info+0xe9>
mov    0x0(%rip),%rax        # 270 <info+0xf0>
mov    %rax,%rdx
and    $0x60,%edx
cmp    $0x40,%rdx
je     2c0 <info+0x140>
test   $0x20,%al
je     2a0 <info+0x120>
callq  285 <info+0x105>
lea    0x20(%rsp),%rdx
mov    %eax,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  298 <info+0x118>
jmpq   206 <info+0x86>
nopl   (%rax)
lea    0x20(%rsp),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  2b1 <info+0x131>
jmpq   206 <info+0x86>
nopw   %cs:0x0(%rax,%rax,1)
test   $0x1,%al
je     2f0 <info+0x170>
mov    0x0(%rip),%rdi        # 2cb <info+0x14b>
test   %rdi,%rdi
je     206 <info+0x86>
cmpl   $0x1,0x0(%rip)        # 2db <info+0x15b>
jle    206 <info+0x86>
lea    0x20(%rsp),%rsi
callq  2eb <info+0x16b>
jmpq   206 <info+0x86>
lea    0x20(%rsp),%rdx
mov    $0x0,%esi
mov    $0x6,%edi
xor    %eax,%eax
callq  306 <info+0x186>
jmp    2c4 <info+0x144>
callq  30d <info+0x18d>
nopl   (%rax)
<<<sep_in_sample>>>
info (int mode, const char *fmt, ...)
{
  va_list arglist;
  char msg[512 + 1];
  if (mode > options.termlevel)
    return;
  __builtin_va_start(arglist,fmt);
  vsnprintf (msg, 512, fmt, arglist);
  __builtin_va_end(arglist);
  if ((topt & 0x00000040) && !(topt & 0x00000020))
    {
      if (!(topt & 0x00000001))
 syslog (6, "%s", msg);
      if (options.ulogfile && options.uloglevel >= 2)
 filelog (options.ulogfile, msg);
    }
  else if (topt & 0x00000020)
    mprintf ("> [%d] %s", (int) getpid (), msg);
  else
    mprintf ("> %s", msg);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 5
20 5
21 21
22 21
23 21
24 21
25 21
26 21
27 7
28 8
29 8
30 8
31 8
32 7
33 7
34 7
35 7
36 7
37 8
38 10
39 10
40 10
41 10
42 10
43 17
44 17
45 18
46 18
47 18
48 18
49 18
50 18
51 18
52 18
53 20
54 20
55 20
56 20
57 20
58 20
59 12
60 12
61 14
62 14
63 14
64 14
65 14
66 15
67 15
68 15
69 13
70 13
71 13
72 13
73 13
74 13
75 21
76 21
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  293 <get_tz+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     2d8 <get_tz+0x58>
mov    %rax,%rdi
callq  2a3 <get_tz+0x23>
lea    0x1(%rax),%rdx
cmp    $0x64,%rdx
ja     2c0 <get_tz+0x40>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2be <get_tz+0x3e>
xchg   %ax,%ax
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <get_tz+0x51>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_tz (char tzbuf[TZBUFSIZE])
{
  char *tz = getenv ("TZ");
  if (tz)
    {
      size_t tzsize = strlen (tz) + 1;
      tz = (tzsize <= TZBUFSIZE
            ? memcpy (tzbuf, tz, tzsize)
            : xmemdup (tz, tzsize));
    }
  return tz;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 12
16 7
17 7
18 12
19 12
20 7
21 7
22 12
23 7
24 7
25 12
26 12
27 7
28 7
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     186 <cdio_audio_resume+0x26>
mov    0x30(%rdi),%rax
test   %rax,%rax
je     180 <cdio_audio_resume+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_audio_resume (CdIo_t *p_cdio)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_resume) {
    return p_cdio->op.audio_resume(p_cdio->env);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
13 3
<<<sep_out_sample>>>
jmpq   d3e5 <gsl_fft_halfcomplex_float_radix2_backward+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_halfcomplex_float_radix2_backward (float data[],
                                               const size_t stride,
                                               const size_t n)
{
  int status = gsl_fft_halfcomplex_float_radix2_transform (data, stride, n) ;
  return status ;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     676 <gsl_vector_long_double_isnull+0x36>
mov    0x10(%rdi),%rdx
fldz   
shl    $0x4,%rsi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
fldt   (%rdx)
fucomip %st(1),%st
jp     67c <gsl_vector_long_double_isnull+0x3c>
jne    680 <gsl_vector_long_double_isnull+0x40>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    660 <gsl_vector_long_double_isnull+0x20>
fstp   %st(0)
mov    $0x1,%eax
retq   
fstp   %st(0)
jmp    682 <gsl_vector_long_double_isnull+0x42>
fstp   %st(0)
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_isnull (const gsl_vector_long_double * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] != 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 11
7 11
8 6
9 6
10 11
11 11
12 11
13 11
14 6
15 6
16 6
17 6
18 6
19 17
20 18
21 18
22 18
23 18
24 13
25 13
26 13
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rdx
callq  ba <_gsasl_step64+0x1a>
cmp    $0x1,%eax
jbe    d0 <_gsasl_step64+0x30>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%r13
mov    %eax,%r12d
mov    %r13,%rdi
callq  e0 <_gsasl_step64+0x40>
cmp    %rbx,%rax
jae    110 <_gsasl_step64+0x70>
test   %rbp,%rbp
je     f9 <_gsasl_step64+0x59>
lea    0x1(%rax),%rdx
mov    %r13,%rsi
mov    %rbp,%rdi
callq  f9 <_gsasl_step64+0x59>
mov    %r13,%rdi
callq  101 <_gsasl_step64+0x61>
add    $0x18,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    %r13,%rdi
callq  118 <_gsasl_step64+0x78>
add    $0x18,%rsp
mov    $0x4,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_step64 (Gsasl_session * sctx,
        const char *b64input, char *b64output, size_t b64output_len)
{
  char *tmp;
  int rc;
  rc = gsasl_step64 (sctx, b64input, &tmp);
  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)
    {
      if (b64output_len <= strlen (tmp))
 {
   free (tmp);
   return GSASL_TOO_SMALL_BUFFER;
 }
      if (b64output)
 strcpy (b64output, tmp);
      free (tmp);
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 6
9 6
10 7
11 7
12 19
13 19
14 19
15 19
16 19
17 19
18 19
19 9
20 9
21 9
22 9
23 9
24 9
25 14
26 14
27 15
28 15
29 15
30 15
31 16
32 16
33 19
34 16
35 19
36 19
37 19
38 19
39 19
40 19
41 11
42 11
43 19
44 12
45 19
46 19
47 19
48 19
49 19
50 19
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1712 <gsl_matrix_int_isnull+0x52>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,4),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     1706 <gsl_matrix_int_isnull+0x46>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdl (%rcx,%rax,4),%xmm0
ucomisd %xmm1,%xmm0
jp     1718 <gsl_matrix_int_isnull+0x58>
jne    1718 <gsl_matrix_int_isnull+0x58>
add    $0x1,%rax
cmp    %rdx,%rax
jne    16f0 <gsl_matrix_int_isnull+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    16e1 <gsl_matrix_int_isnull+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_isnull (const gsl_matrix_int * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 9
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
cmpb   $0x17,0x2(%rdi)
jne    88 <DISAddPDUSizes+0x88>
xor    %r10d,%r10d
cmpb   $0x0,0x19(%rdi)
mov    0x20(%rdi),%r11
mov    %r11,%rdx
mov    %r11,%r9
je     88 <DISAddPDUSizes+0x88>
nopl   (%rax)
mov    %r9,%r8
mov    0x18(%r9),%rax
sub    %r11,%r8
cmpb   $0x0,0x1(%rdx,%r8,1)
je     8a <DISAddPDUSizes+0x8a>
xor    %esi,%esi
xor    %edx,%edx
nopw   %cs:0x0(%rax,%rax,1)
movzbl 0x2d(%rax),%ecx
add    $0x1,%edx
add    $0x40,%rax
lea    0xd(%rcx,%rcx,1),%ecx
mov    %cl,-0x40(%rax)
movzbl %cl,%ecx
add    %rcx,%rsi
mov    0x20(%rdi),%rcx
movzbl 0x1(%rcx,%r8,1),%ecx
cmp    %edx,%ecx
jg     40 <DISAddPDUSizes+0x40>
add    $0x5,%esi
mov    %sil,(%r9)
movzbl 0x19(%rdi),%eax
add    $0x1,%r10d
add    $0x20,%r9
cmp    %r10d,%eax
jle    88 <DISAddPDUSizes+0x88>
mov    0x20(%rdi),%rdx
jmp    20 <DISAddPDUSizes+0x20>
nopl   0x0(%rax,%rax,1)
repz retq 
mov    $0x5,%esi
jmp    69 <DISAddPDUSizes+0x69>
<<<sep_in_sample>>>
DISAddPDUSizes(dis_pdu * p)
{
 int i, j;
 switch (p->hdr.pdu_type) {
 case 23:
  {
   dis_em_emission_pdu *pdu = (dis_em_emission_pdu *) p;
   dis_em_system_info *s = pdu->system;
   dis_beam_info *b;
   unsigned long len;
   for (i = 0; i < pdu->num_systems; ++i, ++s) {
    b = s->beam;
    len = 0;
    for (j = 0; j < pdu->system[i].num_beams; ++j, ++b) {
     b->beam_data_length = 13 + b->num_targets * 2;
     len += b->beam_data_length;
    }
    s->sys_data_length = (u_char) (5 + len);
   }
  }
  break;
 default:
  break;
 }
}
<<<sep_in_sample>>>
1 4
2 4
3 11
4 11
5 8
6 11
7 8
8 11
9 11
10 11
11 12
12 12
13 14
14 14
15 13
16 14
17 14
18 15
19 14
20 14
21 15
22 15
23 16
24 16
25 14
26 14
27 14
28 14
29 14
30 18
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 14
41 14
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  1b08 <Exit+0x8>
mov    %ebx,%edi
callq  1b0f <Exit+0xf>
nop
<<<sep_in_sample>>>
Exit (int returnCode)
{
  SetForExit ();
  exit (returnCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
address_finish (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
xor    %ecx,%ecx
xor    %edx,%edx
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%r8
callq  28b <sockaddr_to_astr+0x1b>
mov    0x8(%rsp),%rdi
callq  295 <sockaddr_to_astr+0x25>
mov    0x8(%rsp),%rcx
mov    %rax,%rdx
mov    %ebp,%esi
mov    %rbx,%rdi
xor    %r8d,%r8d
mov    %rax,%r12
callq  2ad <sockaddr_to_astr+0x3d>
add    $0x10,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
sockaddr_to_astr (const struct sockaddr *sa, int salen)
{
  size_t size;
  char *p;
  sockaddr_to_str(sa, salen, ((void *)0), 0, &size);
  p = xmalloc (size);
  sockaddr_to_str(sa, salen, p, size, ((void *)0));
  return p;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 6
19 7
20 9
21 9
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  1008 <write_temp_file+0x18>
mov    $0x0,%esi
mov    %rbp,%rdi
callq  1015 <write_temp_file+0x25>
test   %rax,%rax
mov    %rax,%rbx
je     1070 <write_temp_file+0x80>
mov    %rax,%rsi
mov    %r13,%rdi
callq  1028 <write_temp_file+0x38>
mov    %rbx,%rdi
callq  1030 <write_temp_file+0x40>
xor    %edx,%edx
test   %eax,%eax
je     105e <write_temp_file+0x6e>
mov    $0x0,%edi
callq  1040 <write_temp_file+0x50>
mov    %rax,%rbx
callq  1048 <write_temp_file+0x58>
mov    (%rax),%esi
mov    %rbx,%rdx
mov    %rbp,%rcx
xor    %edi,%edi
xor    %eax,%eax
callq  1059 <write_temp_file+0x69>
mov    $0x1,%edx
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  107a <write_temp_file+0x8a>
mov    %rax,%rbx
callq  1082 <write_temp_file+0x92>
mov    (%rax),%esi
mov    %rbx,%rdx
mov    %rbp,%rcx
xor    %eax,%eax
xor    %edi,%edi
callq  1093 <write_temp_file+0xa3>
mov    %rbp,%rsi
mov    %r12,%rdi
callq  109e <write_temp_file+0xae>
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
pop    %r12
mov    %edx,%eax
pop    %r13
retq   
<<<sep_in_sample>>>
write_temp_file (struct temp_dir *tmpdir, const char *file_name,
                 const char *contents)
{
  FILE *fp;
  register_temp_file (tmpdir, file_name);
  fp = fopen_temp (file_name, "w");
  if (fp == ((void *)0))
    {
      error (0, (*__errno_location ()), gettext ("failed to create \"%s\""), file_name);
      unregister_temp_file (tmpdir, file_name);
      return 1;
    }
  fputs (contents, fp);
  if (fwriteerror_temp (fp))
    {
      error (0, (*__errno_location ()), gettext ("error while writing \"%s\" file"), file_name);
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 6
11 6
12 6
13 7
14 6
15 7
16 13
17 13
18 13
19 14
20 14
21 19
22 14
23 14
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 17
35 20
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 9
44 9
45 9
46 9
47 9
48 9
49 9
50 9
51 9
52 9
53 10
54 10
55 10
56 20
57 10
58 20
59 20
60 20
61 20
62 20
63 20
<<<sep_out_sample>>>
push   %r14
mov    %r8,%r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  16c <gsl_stats_wabsdev+0x1c>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rcx
mov    %r14,%r8
pop    %r13
pop    %r14
jmpq   188 <gsl_stats_wabsdev+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wabsdev (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t n)
{
  const double wmean = gsl_stats_wmean(w, wstride, data, stride, n);
  return gsl_stats_wabsdev_m(w, wstride, data, stride, n, wmean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 4
13 4
14 4
15 5
16 5
17 5
18 4
19 4
20 5
21 5
22 4
23 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1ca7 <init_job_stats+0x7>
mov    %rax,0x0(%rip)        # 1cae <init_job_stats+0xe>
mov    0x0(%rip),%rax        # 1cb5 <init_job_stats+0x15>
mov    %rax,0x0(%rip)        # 1cbc <init_job_stats+0x1c>
mov    0x0(%rip),%rax        # 1cc3 <init_job_stats+0x23>
mov    %rax,0x0(%rip)        # 1cca <init_job_stats+0x2a>
mov    0x0(%rip),%rax        # 1cd1 <init_job_stats+0x31>
mov    %rax,0x0(%rip)        # 1cd8 <init_job_stats+0x38>
mov    0x0(%rip),%rax        # 1cdf <init_job_stats+0x3f>
mov    %rax,0x0(%rip)        # 1ce6 <init_job_stats+0x46>
mov    0x0(%rip),%rax        # 1ced <init_job_stats+0x4d>
mov    %rax,0x0(%rip)        # 1cf4 <init_job_stats+0x54>
mov    0x0(%rip),%rax        # 1cfb <init_job_stats+0x5b>
mov    %rax,0x0(%rip)        # 1d02 <init_job_stats+0x62>
mov    0x0(%rip),%rax        # 1d09 <init_job_stats+0x69>
mov    %rax,0x0(%rip)        # 1d10 <init_job_stats+0x70>
mov    0x0(%rip),%rax        # 1d17 <init_job_stats+0x77>
mov    %rax,0x0(%rip)        # 1d1e <init_job_stats+0x7e>
retq   
nop
<<<sep_in_sample>>>
init_job_stats ()
{
  js = zerojs;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    260 <__ram_set_re_source+0x50>
mov    %rsi,%rbp
mov    $0x8,%esi
callq  22f <__ram_set_re_source+0x1f>
test   %eax,%eax
je     240 <__ram_set_re_source+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0xc0(%rbx),%rax
mov    0x28(%rbx),%rdi
add    $0x8,%rsp
pop    %rbx
mov    %rbp,%rsi
pop    %rbp
lea    0x38(%rax),%rdx
jmpq   25d <__ram_set_re_source+0x4d>
nopl   (%rax)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   279 <__ram_set_re_source+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__ram_set_re_source(dbp, re_source)
 DB *dbp;
 const char *re_source;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_re_source", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x08)) != 0) return (__ret); };
 t = dbp->bt_internal;
 return (CDB___os_strdup(dbp->dbenv, re_source, &t->re_source));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 10
13 10
14 10
15 10
16 10
17 9
18 9
19 10
20 10
21 9
22 10
23 9
24 9
25 9
26 6
27 10
28 6
29 10
30 10
31 6
32 6
33 6
<<<sep_out_sample>>>
sub    $0x88,%rsp
mov    %rsp,%rdi
callq  eef <unblock_sigs+0xf>
mov    %rsp,%rsi
xor    %edx,%edx
mov    $0x2,%edi
callq  efe <unblock_sigs+0x1e>
add    $0x88,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
unblock_sigs (void)
{
  sigset_t empty;
  sigemptyset (&empty);
  sigprocmask (2, &empty, (sigset_t *) 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1ce9 <parse_and+0x9>
movq   $0x0,(%rax)
movl   $0x3,0x10(%rax)
movl   $0x3,0x14(%rax)
movb   $0x0,0x1b(%rax)
movb   $0x0,0x1a(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
parse_and (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = get_new_pred_noarg (entry);
  our_pred->pred_func = pred_and;
  our_pred->p_type = BI_OP;
  our_pred->p_prec = AND_PREC;
  our_pred->need_stat = our_pred->need_type = 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 8
5 9
6 10
7 10
8 12
9 12
10 12
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     3ff <gsl_vector_uint_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3f5 <gsl_vector_uint_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     433 <gsl_vector_uint_memcpy+0x63>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%esi
add    $0x1,%rax
add    %r10,%rcx
mov    %esi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    420 <gsl_vector_uint_memcpy+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_memcpy (gsl_vector_uint * dest,
                               const gsl_vector_uint * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdi,%r13
mov    $0x20,%edi
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
callq  1438 <swverid_i_print+0x18>
xor    %esi,%esi
mov    %rax,%r14
jmp    145f <swverid_i_print+0x3f>
nop
cmp    $0x1,%ebp
je     1452 <swverid_i_print+0x32>
mov    $0x0,%esi
mov    %r12,%rdi
callq  1452 <swverid_i_print+0x32>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  145d <swverid_i_print+0x3d>
mov    %ebp,%esi
mov    0x20(%r13),%rdi
lea    0x1(%rsi),%ebp
callq  146b <swverid_i_print+0x4b>
test   %rax,%rax
mov    %rax,%rbx
jne    1440 <swverid_i_print+0x20>
mov    0x30(%r13),%rdi
mov    %r14,%rsi
callq  147f <swverid_i_print+0x5f>
mov    %r14,%rdi
callq  1487 <swverid_i_print+0x67>
test   %rax,%rax
je     14ac <swverid_i_print+0x8c>
mov    $0x0,%esi
mov    %r12,%rdi
callq  1499 <swverid_i_print+0x79>
mov    %r14,%rdi
callq  14a1 <swverid_i_print+0x81>
mov    %r12,%rdi
mov    %rax,%rsi
callq  14ac <swverid_i_print+0x8c>
mov    %r12,%rdi
callq  14b4 <swverid_i_print+0x94>
mov    %r14,%rdi
mov    %rax,%rbx
callq  14bf <swverid_i_print+0x9f>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swverid_i_print(SWVERID * swverid, STROB * buf)
{
 char * s;
 int i = 0;
 char * ret;
 STROB * version = strob_open(32);
 struct VER_ID * next;
 while ((s = cplob_val(swverid->taglistM, i++))) {
  if (i > 1) strob_strcat(buf, ".");
  strob_strcat(buf, s);
 }
 next = swverid->ver_id_listM;
 swverid_print_ver_id(next, version);
 if (strob_strlen(version) > 0) {
  strob_strcat(buf, ",");
  strob_strcat(buf, strob_str(version));
 }
 ret = strob_str(buf);
 strob_close(version);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 2
6 2
7 2
8 2
9 6
10 4
11 6
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 13
30 13
31 13
32 14
33 14
34 14
35 14
36 15
37 15
38 15
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 19
47 18
48 19
49 21
50 21
51 21
52 21
53 21
54 21
55 21
56 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  1ad <output_free+0xd>
mov    0x10(%rbx),%rdi
mov    $0x0,%esi
callq  1bb <output_free+0x1b>
mov    %rbx,%rdi
pop    %rbx
jmpq   1c4 <output_free+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_free (struct output * out)
{
  ds_erase (out->chunk);
  da_free (out->derivations, (da_map_func_t) free);
  free (out);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x16,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     51a <mu_body_set_stream+0x1a>
cmp    %rdx,(%rdi)
mov    $0xd,%al
je     528 <mu_body_set_stream+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
lea    0x10(%rdi),%rdi
mov    %rsi,%rbp
mov    %rbx,%rsi
callq  537 <mu_body_set_stream+0x37>
mov    %rbp,0x10(%rbx)
orl    $0x10000,0x20(%rbx)
xor    %eax,%eax
jmp    51a <mu_body_set_stream+0x1a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_body_set_stream (mu_body_t body, mu_stream_t stream, void *owner)
{
  if (body == ((void *)0))
   return 22;
  if (body->owner != owner)
    return 13;
  mu_stream_destroy (&(body->stream), body);
  body->stream = stream;
  body->flags |= 0x10000;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 3
8 5
9 6
10 5
11 11
12 11
13 11
14 11
15 11
16 7
17 7
18 7
19 7
20 8
21 9
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
mov    %rsi,%rbx
callq  967 <gl_linked_add_after+0x17>
mov    (%rbx),%rdx
mov    %r12,0x10(%rax)
mov    %rbx,0x8(%rax)
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
mov    %rax,(%rbx)
addq   $0x1,0x40(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_add_after (gl_list_t list, gl_list_node_t node, const void *elt)
{
  gl_list_node_t new_node = ((struct gl_list_node_impl *) xmalloc (sizeof (struct gl_list_node_impl)));
  new_node->value = elt;
  new_node->prev = node;
  new_node->next = node->next;
  new_node->next->prev = new_node;
  node->next = new_node;
  list->count++;
  return new_node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 3
9 6
10 4
11 5
12 6
13 7
14 8
15 9
16 11
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x28,%edi
callq  59d <dsegm_new+0xd>
movq   $0x0,(%rax)
mov    %ebx,0x8(%rax)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
dsegm_new (int type)
{
  struct dsegm *p = emalloc (sizeof (*p));
  p->next = ((void *)0);
  p->type = type;
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 7
8 7
9 7
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
mov    %rdi,%rbx
sub    $0x10,%rsp
movl   $0x0,0xc(%rsp)
jmp    148f <swlist_has_annex_attribute+0x2f>
nopl   0x0(%rax)
mov    %rax,%rdi
callq  1480 <swlist_has_annex_attribute+0x20>
test   %eax,%eax
jne    14b0 <swlist_has_annex_attribute+0x50>
mov    0xc(%rsp),%eax
lea    0x1(%rax),%esi
mov    %esi,0xc(%rsp)
lea    0xc(%rsp),%rdx
mov    %rbx,%rdi
callq  149c <swlist_has_annex_attribute+0x3c>
test   %rax,%rax
jne    1478 <swlist_has_annex_attribute+0x18>
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlist_has_annex_attribute(BLIST * BL)
{
 char * attr;
 int attr_index;
 ;
 attr_index = 0;
 while ((attr=swlist_blist_get_next_attr(BL, attr_index, &attr_index)) != ((void *)0)) {
  if (swlist_is_annex_attribute(attr)) {
   ;
   return 1;
  }
  attr_index++;
 }
 ;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 6
6 7
7 7
8 8
9 8
10 8
11 8
12 12
13 12
14 12
15 7
16 7
17 7
18 7
19 7
20 16
21 16
22 16
23 16
24 16
25 10
26 16
27 16
28 16
<<<sep_out_sample>>>
lea    -0x61(%rdi),%edx
lea    -0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
<<<sep_in_sample>>>
libunistring_c_toupper (int c)
{
  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
lea    0x28(%rdi),%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    0x28(%rdi),%rbx
cmp    %r12,%rbx
jne    18e <gl_linked_sortedlist_indexof+0x2e>
jmp    19d <gl_linked_sortedlist_indexof+0x3d>
nop
je     1b0 <gl_linked_sortedlist_indexof+0x50>
mov    (%rbx),%rbx
add    $0x1,%rbp
cmp    %r12,%rbx
je     19d <gl_linked_sortedlist_indexof+0x3d>
mov    0x10(%rbx),%rdi
mov    %r13,%rsi
callq  *%r14
cmp    $0x0,%eax
jle    180 <gl_linked_sortedlist_indexof+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffffffffffff,%rax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
                              const void *elt)
{
  gl_list_node_t node;
  size_t index;
  for (node = list->root.next, index = 0;
       node != &list->root;
       node = node->next, index++)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
        break;
      if (cmp == 0)
        return index;
    }
  return (size_t)(-1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 3
8 6
9 3
10 6
11 6
12 6
13 6
14 6
15 13
16 8
17 8
18 6
19 6
20 10
21 10
22 10
23 11
24 11
25 17
26 17
27 17
28 17
29 16
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  445 <grecs_grecs__init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%r12
mov    (%rax),%r13d
callq  453 <grecs_grecs__init_buffer+0x23>
mov    0x0(%rip),%rax        # 45a <grecs_grecs__init_buffer+0x2a>
mov    %rbp,(%rbx)
movl   $0x1,0x38(%rbx)
test   %rax,%rax
je     476 <grecs_grecs__init_buffer+0x46>
mov    0x0(%rip),%rdx        # 470 <grecs_grecs__init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     484 <grecs_grecs__init_buffer+0x54>
movl   $0x1,0x30(%rbx)
movl   $0x0,0x34(%rbx)
xor    %eax,%eax
test   %rbp,%rbp
je     4a2 <grecs_grecs__init_buffer+0x72>
mov    %rbp,%rdi
callq  493 <grecs_grecs__init_buffer+0x63>
mov    %eax,%edi
callq  49a <grecs_grecs__init_buffer+0x6a>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x28(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs__init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 grecs_grecs__flush_buffer(b );
 b->grecs_grecs__input_file = file;
 b->grecs_grecs__fill_buffer = 1;
    if (b != ( (grecs_grecs__buffer_stack) ? (grecs_grecs__buffer_stack)[(grecs_grecs__buffer_stack_top)] : ((void *)0))){
        b->grecs_grecs__bs_lineno = 1;
        b->grecs_grecs__bs_column = 0;
    }
        b->grecs_grecs__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
mov    0x70(%rdi),%eax
movsd  0x60(%rdi),%xmm0
movsd  %xmm0,(%rsi)
mov    %rax,0x8(%rsi)
mov    0x74(%rdi),%eax
mov    %eax,0x10(%rsi)
mov    0x68(%rdi),%eax
mov    %eax,0x14(%rsi)
mov    0x6c(%rdi),%eax
mov    %eax,0x18(%rsi)
mov    0xc0(%rdi),%rax
mov    %rax,0x20(%rsi)
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_monte_vegas_params_get (const gsl_monte_vegas_state * s, gsl_monte_vegas_params * p)
{
  p->alpha = s->alpha;
  p->iterations = s->iterations;
  p->stage = s->stage;
  p->mode = s->mode;
  p->verbose = s->verbose;
  p->ostream = s->ostream;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 8
14 8
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_is_to_void (struct output * out)
{
  return out->to_void;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cmp    $0x773593ff,%edi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %edi,%esi
jbe    330 <uxfio_unix_safe_read+0x20>
mov    $0x0,%edi
jmpq   32a <uxfio_unix_safe_read+0x1a>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   33a <uxfio_unix_safe_read+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uxfio_unix_safe_read(int fd, void * buf, size_t nbyte) {
 if (fd < 2000000000 && fd >= 0) {
  return safeio((ssize_t (*)(int, void *, size_t))read,
     fd, buf, nbyte);
 } else {
  return safeio((ssize_t (*)(int, void *, size_t))uxfio_read,
     fd, buf, nbyte);
 }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 2
6 6
7 6
8 6
9 3
10 3
11 3
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1b20 <gsl_vector_int_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b15 <gsl_vector_int_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1b56 <gsl_vector_int_div+0x66>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %esi,%esi
nop
mov    (%rdi),%eax
add    $0x1,%rsi
cltd   
idivl  (%rcx)
add    %r9,%rcx
mov    %eax,(%rdi)
add    %r10,%rdi
cmp    %r8,%rsi
jne    1b40 <gsl_vector_int_div+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_int_div (gsl_vector_int * a, const gsl_vector_int * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     850 <dico_stream_flush+0x40>
mov    $0x1,%esi
callq  9c0 <_stream_flush_buffer>
test   %eax,%eax
jne    840 <dico_stream_flush+0x30>
mov    0x58(%rbx),%rdx
test   %rdx,%rdx
je     845 <dico_stream_flush+0x35>
mov    0x98(%rbx),%rdi
pop    %rbx
jmpq   *%rdx
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
callq  855 <dico_stream_flush+0x45>
movl   $0x16,(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dico_stream_flush(dico_stream_t stream)
{
    if (!stream) {
 (*__errno_location ()) = 22;
 return 1;
    }
    if (_stream_flush_buffer(stream, 1))
 return 1;
    if (stream->flush)
 return stream->flush(stream->data);
    return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 10
13 12
14 10
15 10
16 8
17 12
18 12
19 12
20 4
21 4
22 4
23 12
24 12
25 12
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    2b7 <no_args+0x7>
repz retq 
push   %rax
callq  2bd <no_args+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
no_args (list)
     WORD_LIST *list;
{
  if (list)
    {
      builtin_error (gettext("too many arguments"));
      top_level_cleanup ();
      jump_to_top_level (2);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 3
5 3
6 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     4058 <gsl_fft_complex_workspace_float_free+0x28>
mov    0x8(%rdi),%rdi
callq  4042 <gsl_fft_complex_workspace_float_free+0x12>
movq   $0x0,0x8(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   4053 <gsl_fft_complex_workspace_float_free+0x23>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_workspace_float_free (gsl_fft_complex_workspace_float * workspace)
{
  if (!workspace) { return ; };
  free (workspace->scratch);
  workspace->scratch = ((void *)0);
  free (workspace) ;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  58c <gsl_sf_bessel_J1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    5a0 <gsl_sf_bessel_J1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x7f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  5b6 <gsl_sf_bessel_J1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_J1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_J1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_J1_e(x, &result)", "bessel_J1.c", 127, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     29fd <freelist+0x3d>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     29fd <freelist+0x3d>
lea    0x8(%rbp),%rbx
nopw   0x0(%rax,%rax,1)
callq  29e5 <freelist+0x25>
movq   $0x0,0x0(%rbp)
mov    %rbx,%rbp
add    $0x8,%rbx
mov    -0x8(%rbx),%rdi
test   %rdi,%rdi
jne    29e0 <freelist+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
freelist (char **cpp)
{
  int i;
  if (cpp == ((void *)0))
    return;
  for (i = 0; cpp[i] != ((void *)0); ++i)
    {
      free(cpp[i]);
      cpp[i] = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 8
13 9
14 6
15 6
16 6
17 6
18 6
19 11
20 11
21 11
22 11
23 11
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
xor    %ebx,%ebx
callq  53b <smtp_reply_has_capa+0x1b>
cmpq   $0x0,0x18(%rbp)
mov    %rax,%r12
jne    55a <smtp_reply_has_capa+0x3a>
jmp    5b0 <smtp_reply_has_capa+0x90>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %rbx,0x18(%rbp)
jbe    5b0 <smtp_reply_has_capa+0x90>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  565 <smtp_reply_has_capa+0x45>
lea    0x4(%rax),%rdi
mov    $0x0,%esi
callq  573 <smtp_reply_has_capa+0x53>
cmp    %r12,%rax
jne    550 <smtp_reply_has_capa+0x30>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  583 <smtp_reply_has_capa+0x63>
lea    0x4(%rax),%rdi
mov    %r12,%rdx
mov    %r13,%rsi
callq  592 <smtp_reply_has_capa+0x72>
test   %eax,%eax
jne    550 <smtp_reply_has_capa+0x30>
test   %r14,%r14
je     5bb <smtp_reply_has_capa+0x9b>
mov    %rbx,(%r14)
mov    $0x1,%al
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
mov    $0x1,%eax
jmp    5b2 <smtp_reply_has_capa+0x92>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_reply_has_capa (ANUBIS_SMTP_REPLY reply, const char *capa, size_t *pind)
{
  size_t i;
  size_t capa_len = strlen (capa);
  for (i = 0; i < reply->line_count; i++)
    {
      char const *p = smtp_reply_line (reply, i) + 4;
      size_t len = strcspn (p, " ");
      if (len == capa_len
   && memcmp (smtp_reply_line (reply, i) + 4, capa, len) == 0)
 {
   if (pind)
     *pind = i;
   return 1;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 2
10 5
11 4
12 5
13 4
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 7
24 8
25 8
26 9
27 9
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 12
38 12
39 13
40 14
41 18
42 18
43 18
44 18
45 18
46 18
47 18
48 17
49 18
50 18
51 18
52 18
53 18
54 18
55 14
56 14
57 14
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdx,%rdx
je     6a0 <gsl_stats_ushort_quantile_from_sorted_data+0x70>
sub    $0x1,%rdx
js     6a8 <gsl_stats_ushort_quantile_from_sorted_data+0x78>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     6cf <gsl_stats_ushort_quantile_from_sorted_data+0x9f>
test   %rax,%rax
js     6e0 <gsl_stats_ushort_quantile_from_sorted_data+0xb0>
cvtsi2sd %rax,%xmm1
add    %rsi,%rsi
movapd %xmm0,%xmm2
imul   %rsi,%rax
movsd  0x0(%rip),%xmm0        # 674 <gsl_stats_ushort_quantile_from_sorted_data+0x44>
subsd  %xmm1,%xmm2
add    %rdi,%rsi
movzwl (%rdi,%rax,1),%edx
movzwl (%rsi,%rax,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    653 <gsl_stats_ushort_quantile_from_sorted_data+0x23>
add    %rsi,%rsi
imul   %rdx,%rsi
movzwl (%rdi,%rsi,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nop
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   661 <gsl_stats_ushort_quantile_from_sorted_data+0x31>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_ushort_quantile_from_sorted_data (const unsigned short sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 18
18 8
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 18
30 11
31 21
32 21
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 7
42 7
43 12
44 12
45 14
46 14
47 14
48 14
49 14
50 14
51 8
52 8
53 8
54 8
55 8
56 8
57 8
58 8
59 8
<<<sep_out_sample>>>
cmpq   $0x0,0x10(%rdi)
jne    26b <sexp_put_code_start+0x1b>
mov    0x40(%rdi),%eax
mov    %rsi,0x10(%rdi)
add    $0x30,%rdi
mov    %eax,-0x18(%rdi)
mov    0x18(%rsi),%rax
jmpq   *%rax
push   %rax
mov    $0x0,%ecx
mov    $0xae,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  285 <sexp_put_code_start+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexp_put_code_start(struct sexp_output *output,
      const struct nettle_armor *coding)
{
  ((!output->coding) ? (void) (0) : __assert_fail ("!output->coding", "output.c", 174, __PRETTY_FUNCTION__));
  output->coding_indent = output->pos;
  output->coding = coding;
  output->coding->encode_init(&output->base64);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 7
6 5
7 7
8 7
9 3
10 4
11 4
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %esi,%esi
callq  11b <do_help+0xb>
<<<sep_in_sample>>>
do_help(const char *name)
{
  usage(name, 0);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%r9
mov    %rdx,%r8
shr    %r8
je     b83 <gsl_vector_ulong_reverse+0x53>
lea    -0x8(,%rdx,8),%rdx
mov    %r9,%r10
xor    %ecx,%ecx
neg    %r10
imul   %r9,%rdx
shl    $0x3,%r10
shl    $0x3,%r9
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rsi
mov    (%rax),%rdi
add    $0x1,%rcx
mov    %rdi,(%rdx)
mov    %rsi,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    b68 <gsl_vector_ulong_reverse+0x38>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_reverse (gsl_vector_ulong * v)
{
  unsigned long * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          unsigned long tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 15
18 8
19 15
20 16
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     25 <acl_errno_valid+0x25>
jle    20 <acl_errno_valid+0x20>
cmp    $0x26,%edi
je     25 <acl_errno_valid+0x25>
cmp    $0x5f,%edi
nop
je     25 <acl_errno_valid+0x25>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x10,%edi
jne    12 <acl_errno_valid+0x12>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 11
11 11
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%ecx        # 281 <is_slavo_germanic+0x11>
test   %ecx,%ecx
je     2bf <is_slavo_germanic+0x4f>
nopl   (%rax)
mov    $0x0,%esi
mov    %rbp,%rdi
callq  295 <is_slavo_germanic+0x25>
test   %rax,%rax
jne    2c8 <is_slavo_germanic+0x58>
nopw   0x0(%rax,%rax,1)
movslq %ebx,%rax
add    $0x1,%ebx
mov    0x0(,%rax,4),%edx
test   %edx,%edx
jne    2a0 <is_slavo_germanic+0x30>
movslq %ebx,%rax
mov    0x0(,%rax,4),%eax
test   %eax,%eax
jne    288 <is_slavo_germanic+0x18>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_slavo_germanic(unsigned const *str)
{
    static unsigned pat[] = {
 'W', 0,
 'K', 0,
 'C', 'Z', 0,
 'W', 'I', 'T', 'Z', 0,
 0
    };
    int i;
    for (i = 0; pat[i]; i++) {
 if (utf8_wc_strstr(str, pat))
     return 1;
 while (pat[i])
     ++i;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 11
5 2
6 11
7 11
8 11
9 11
10 12
11 12
12 12
13 12
14 12
15 12
16 14
17 15
18 14
19 14
20 14
21 11
22 11
23 11
24 11
25 18
26 17
27 18
28 18
29 18
30 18
31 13
32 18
33 18
34 18
35 18
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1887 <asm_get_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_get_text (void)
{
        return asm_text;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %r13
push   %r12
movslq %edx,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     60 <glue_prefix_and_suffix+0x60>
cmpb   $0x0,(%rdi)
je     60 <glue_prefix_and_suffix+0x60>
add    %rbx,%r12
callq  25 <glue_prefix_and_suffix+0x25>
mov    %r12,%rdi
mov    %rax,%r13
callq  30 <glue_prefix_and_suffix+0x30>
lea    0x1(%r13,%rax,1),%edi
mov    $0x150,%edx
mov    $0x0,%esi
movslq %edi,%rdi
callq  47 <glue_prefix_and_suffix+0x47>
test   %r13d,%r13d
mov    %rax,%rbx
je     83 <glue_prefix_and_suffix+0x83>
mov    %rax,%rdi
mov    %rbp,%rsi
callq  5a <glue_prefix_and_suffix+0x5a>
movslq %r13d,%rdi
jmp    85 <glue_prefix_and_suffix+0x85>
nop
add    %rbx,%r12
mov    %r12,%rdi
callq  6b <glue_prefix_and_suffix+0x6b>
lea    0x1(%rax),%edi
mov    $0x150,%edx
mov    $0x0,%esi
movslq %edi,%rdi
callq  80 <glue_prefix_and_suffix+0x80>
mov    %rax,%rbx
xor    %edi,%edi
add    %rbx,%rdi
mov    %r12,%rsi
callq  90 <glue_prefix_and_suffix+0x90>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
glue_prefix_and_suffix (prefix, suffix, suffind)
     char *prefix;
     const char *suffix;
     int suffind;
{
  char *ret;
  int plen, slen;
  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)sh_xmalloc((plen + slen + 1), "tilde.c", 336);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 8
10 8
11 8
12 8
13 9
14 8
15 9
16 8
17 9
18 10
19 10
20 10
21 10
22 10
23 11
24 10
25 11
26 12
27 12
28 12
29 12
30 12
31 12
32 9
33 9
34 9
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 13
43 13
44 13
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 15
<<<sep_out_sample>>>
mov    %edi,%eax
and    $0x1,%edi
and    $0x1fe,%eax
cmp    $0x1,%edi
sbb    $0xffffffff,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_mode(__mode_t st_mode)
{
  mode_t mode = 00;
  if(st_mode & 0400) { mode += 0400; }
  if(st_mode & 0200) { mode += 0200; }
  if(st_mode & 0100) { mode += 0100; }
  if(st_mode & (0400 >> 3)) { mode += 040; }
  if(st_mode & (0200 >> 3)) { mode += 020; }
  if(st_mode & (0100 >> 3)) { mode += 010; }
  if(st_mode & ((0400 >> 3) >> 3)) { mode += 04; }
  if(st_mode & ((0200 >> 3) >> 3)) { mode += 02; }
  if(st_mode & ((0100 >> 3) >> 3)) { mode += 01; }
  return mode;
}
<<<sep_in_sample>>>
1 11
2 12
3 11
4 12
5 12
6 14
7 14
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  8a0 <gsasl_md5pwd_get_password+0x20>
mov    %rax,%rdi
mov    $0x5,%eax
test   %rdi,%rdi
je     8fe <gsasl_md5pwd_get_password+0x7e>
callq  8b2 <gsasl_md5pwd_get_password+0x32>
lea    0x8(%rsp),%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  8c2 <gsasl_md5pwd_get_password+0x42>
test   %eax,%eax
jne    8fe <gsasl_md5pwd_get_password+0x7e>
mov    0x8(%rsp),%rbx
mov    %rbx,%rdi
callq  8d3 <gsasl_md5pwd_get_password+0x53>
lea    0x1(%rax),%rdx
cmp    %rdx,(%r12)
jb     910 <gsasl_md5pwd_get_password+0x90>
test   %r13,%r13
mov    %rax,(%r12)
je     8f4 <gsasl_md5pwd_get_password+0x74>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    %r13,%rdi
callq  8f4 <gsasl_md5pwd_get_password+0x74>
mov    %rbx,%rdi
callq  8fc <gsasl_md5pwd_get_password+0x7c>
xor    %eax,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  918 <gsasl_md5pwd_get_password+0x98>
add    $0x18,%rsp
mov    $0x4,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_md5pwd_get_password (const char *filename,
      const char *username, char *key, size_t * keylen)
{
  char *tmp;
  size_t tmplen;
  int res;
  FILE *fh;
  fh = fopen (filename, "r");
  if (fh == ((void *)0))
    return GSASL_FOPEN_ERROR;
  fclose (fh);
  res = gsasl_simple_getpass (filename, username, &tmp);
  if (res != GSASL_OK)
    return res;
  tmplen = strlen (tmp);
  if (*keylen < tmplen + 1)
    {
      free (tmp);
      return GSASL_TOO_SMALL_BUFFER;
    }
  *keylen = tmplen;
  if (key)
    memcpy (key, tmp, tmplen);
  free (tmp);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 3
9 3
10 3
11 8
12 8
13 10
14 9
15 9
16 11
17 12
18 12
19 12
20 12
21 13
22 13
23 15
24 15
25 15
26 16
27 16
28 16
29 22
30 21
31 22
32 23
33 23
34 23
35 23
36 24
37 24
38 25
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 18
47 18
48 26
49 19
50 26
51 26
52 26
53 26
54 26
55 26
<<<sep_out_sample>>>
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
jmpq   7e1 <grecs_symtab_create_default+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_symtab_create_default(size_t elsize)
{
 return grecs_symtab_create(elsize,
       ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4f66 <_rl_clean_up_for_exit+0x6>
test   %eax,%eax
je     4fa8 <_rl_clean_up_for_exit+0x48>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 4f74 <_rl_clean_up_for_exit+0x14>
test   %edi,%edi
jle    4f7d <_rl_clean_up_for_exit+0x1d>
callq  4f7d <_rl_clean_up_for_exit+0x1d>
mov    0x0(%rip),%rdi        # 4f84 <_rl_clean_up_for_exit+0x24>
movl   $0x0,0x0(%rip)        # 4f8e <_rl_clean_up_for_exit+0x2e>
callq  4f93 <_rl_clean_up_for_exit+0x33>
xor    %esi,%esi
mov    $0x1,%edi
add    $0x8,%rsp
jmpq   4fa3 <_rl_clean_up_for_exit+0x43>
nopl   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_clean_up_for_exit ()
{
  if (_rl_echoing_p)
    {
      if (_rl_vis_botlin > 0)
 _rl_move_vert (_rl_vis_botlin);
      _rl_vis_botlin = 0;
      fflush (rl_outstream);
      rl_restart_output (1, 0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 5
8 6
9 8
10 7
11 8
12 9
13 9
14 11
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # ce67 <re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # ce6e <re_set_syntax+0xe>
retq   
nop
<<<sep_in_sample>>>
re_set_syntax (reg_syntax_t syntax)
{
  reg_syntax_t ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
mov    %rdx,%rsi
mov    %rbx,%rdi
sub    $0x8,%rsp
callq  3b6 <handle_termination+0x16>
mov    %rbx,%rdi
callq  3be <handle_termination+0x1e>
mov    %rax,%rdi
mov    %rax,%rbx
callq  3c9 <handle_termination+0x29>
cmp    $0x1,%eax
mov    %rax,%rdx
je     430 <handle_termination+0x90>
cmp    $0xa,%bpl
je     420 <handle_termination+0x80>
mov    %edx,%eax
sub    $0x2,%eax
js     430 <handle_termination+0x90>
cltq   
cmpb   $0x5c,(%rbx,%rax,1)
jne    430 <handle_termination+0x90>
lea    -0x1(%rbx,%rax,1),%rcx
lea    -0x1(%rdx),%eax
xor    %edx,%edx
jmp    402 <handle_termination+0x62>
nopw   0x0(%rax,%rax,1)
sub    $0x1,%rcx
cmpb   $0x5c,0x1(%rcx)
jne    409 <handle_termination+0x69>
add    $0x1,%edx
cmp    %eax,%edx
jne    3f8 <handle_termination+0x58>
xor    %eax,%eax
cmp    $0x1,%edx
je     418 <handle_termination+0x78>
mov    %edx,%eax
and    $0x1,%eax
xor    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
cltq   
cmpb   $0xa,-0x1(%rbx,%rax,1)
jne    3d7 <handle_termination+0x37>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
handle_termination(char termch, STROB * strb, char *str, char * loc)
{
 int len, i = 0, j = 0;
 char *p;
 strob_catstr(strb, str);
 p = strob_str(strb);
 len = strlen(p);
 if (len == 1)
  return 1;
 if (termch == '\n' && p[len - 1] == '\n')
  return 1;
 i = len - 2;
 while (i >= 0 && p[i] == '\\') {
  j++;
  i--;
 }
 if (j == 1 || j % 2) {
  return 0;
 } else {
  return 1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 2
8 5
9 6
10 6
11 7
12 6
13 7
14 8
15 7
16 8
17 10
18 10
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 3
28 3
29 3
30 3
31 13
32 13
33 14
34 13
35 13
36 18
37 17
38 17
39 17
40 17
41 17
42 23
43 23
44 23
45 23
46 23
47 10
48 10
49 10
50 10
51 23
52 9
53 23
54 23
55 23
56 23
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <isdir+0xf>
xor    %edx,%edx
test   %eax,%eax
jne    28 <isdir+0x28>
mov    0x18(%rsp),%eax
xor    %edx,%edx
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
isdir (const char *path)
{
  struct stat stats;
  return stat (path, &stats) == 0 && ((((stats.st_mode)) & 0170000) == (0040000));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
jne    d8c <grecs_match_next+0x1c>
jmp    da6 <grecs_match_next+0x36>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  740 <grecs_match>
test   %eax,%eax
jne    da0 <grecs_match_next+0x30>
mov    0x28(%rbx),%rdi
callq  d95 <grecs_match_next+0x25>
test   %rax,%rax
mov    %rax,0x28(%rbx)
jne    d80 <grecs_match_next+0x10>
pop    %rbx
retq   
mov    0x28(%rbx),%rax
pop    %rbx
retq   
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_match_next(struct grecs_match_buf *buf)
{
 if (!buf)
  return ((void *)0);
 while ((buf->node = grecs_next_node(buf->node)))
  if (grecs_match(buf))
   break;
 return buf->node;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 5
12 5
13 5
14 5
15 5
16 9
17 9
18 9
19 9
20 9
21 4
22 9
23 9
24 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     7c8 <putforest+0x38>
mov    0x8(%rdi),%rdi
mov    %rsi,%rbp
callq  790 <putforest>
mov    (%rbx),%rdi
mov    %rbp,%rsi
callq  750 <putabranch>
mov    (%rbx),%rdi
add    $0x8,%rsp
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmp    7d0 <putree>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
putforest (struct wlink const *branchroot, const char *insDelFormat)
{
  if (!branchroot)
    return;
  putforest (branchroot->next, insDelFormat);
  putabranch (branchroot->entry, insDelFormat);
  putree (branchroot->entry, insDelFormat);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 6
11 6
12 6
13 7
14 8
15 7
16 8
17 8
18 7
19 7
20 8
21 8
22 8
23 8
24 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1167 <pch_suffix_context+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pch_suffix_context (void)
{
    return p_suffix_context;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  161 <nettle_buffer_write+0x11>
mov    %rax,%rdi
xor    %eax,%eax
test   %rdi,%rdi
je     17b <nettle_buffer_write+0x2b>
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  176 <nettle_buffer_write+0x26>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_buffer_write(struct nettle_buffer *buffer,
      size_t length, const uint8_t *data)
{
  uint8_t *p = nettle_buffer_space(buffer, length);
  if (p)
    {
      memcpy(p, data, length);
      return 1;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 11
9 5
10 5
11 7
12 7
13 7
14 8
15 12
16 12
17 12
18 12
19 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1a49 <grecs_value_list_create+0x9>
movq   $0x0,0x20(%rax)
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_value_list_create()
{
 struct grecs_list *list = grecs_list_create();
 list->free_entry = free_value_entry;
 return list;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x18,%edi
callq  e <palloc+0xe>
movq   $0x0,0x10(%rax)
movq   $0x0,0x8(%rax)
movl   $0x0,(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
palloc (void)
{
  struct prt *pp;
  pp = (struct prt *)xmalloc (sizeof(struct prt));
  pp->pr_sym = ((void *)0);
  pp->pr_link = ((void *)0);
  pp->pr_which = P_VALUE;
  return pp;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 9
8 9
9 9
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %rdi,%r12
mov    $0x1,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x30,%esi
push   %rbx
mov    %r8,%rbx
callq  3d6 <make_ht+0x26>
test   %rax,%rax
mov    %rax,(%rbx)
je     410 <make_ht+0x60>
mov    %r12,(%rax)
mov    %rbp,0x8(%rax)
mov    %r13d,%esi
mov    %r14,0x10(%rax)
movl   $0x0,0x18(%rax)
mov    %rax,%rdi
callq  2b0 <alloc_ht>
test   %eax,%eax
setne  %al
movzbl %al,%eax
neg    %eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
mov    $0xffffffff,%eax
jmp    405 <make_ht+0x55>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_ht(T_HashFunc f1, T_HashFunc f2, T_ComparFunc c, int size,
     T_HashTable **H)
{
  *H = ((T_HashTable*)(calloc(1,sizeof(T_HashTable))));
  if (*H == ((void *)0)){
    return -1;
  }
  (*H)->f1 = f1;
  (*H)->f2 = f2;
  (*H)->compar = c;
  (*H)->size = 0;
  if(alloc_ht(*H,size))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 3
9 3
10 4
11 3
12 3
13 4
14 5
15 4
16 5
17 8
18 9
19 12
20 10
21 11
22 12
23 12
24 12
25 12
26 12
27 12
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 6
36 6
37 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
movl   $0x1,0x48(%rax)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
init_source (j_decompress_ptr cinfo)
{
  my_src_ptr src = (my_src_ptr) cinfo->src;
  src->start_of_file = 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sh_single_quote+0x9>
lea    0x3(,%rax,4),%rdi
mov    $0x66,%edx
mov    $0x0,%esi
callq  20 <sh_single_quote+0x20>
cmpb   $0x27,(%rbx)
je     78 <sh_single_quote+0x78>
lea    0x1(%rax),%rdx
movb   $0x27,(%rax)
jmp    3a <sh_single_quote+0x3a>
xchg   %ax,%ax
add    $0x1,%rdx
add    $0x1,%rbx
je     68 <sh_single_quote+0x68>
movzbl (%rbx),%esi
movsbl %sil,%ecx
test   %ecx,%ecx
je     68 <sh_single_quote+0x68>
cmp    $0x27,%ecx
mov    %sil,(%rdx)
jne    30 <sh_single_quote+0x30>
movb   $0x5c,0x1(%rdx)
movb   $0x27,0x2(%rdx)
add    $0x4,%rdx
movb   $0x27,-0x1(%rdx)
add    $0x1,%rbx
jne    3a <sh_single_quote+0x3a>
nopl   0x0(%rax,%rax,1)
movb   $0x27,(%rdx)
movb   $0x0,0x1(%rdx)
pop    %rbx
retq   
nopl   0x0(%rax)
cmpb   $0x0,0x1(%rbx)
jne    25 <sh_single_quote+0x25>
movb   $0x5c,(%rax)
movb   $0x27,0x1(%rax)
movb   $0x0,0x2(%rax)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_single_quote (string)
     const char *string;
{
  register int c;
  char *result, *r;
  const char *s;
  result = (char *)sh_xmalloc((3 + (4 * strlen (string))), "shquote.c", 102);
  r = result;
  if (string[0] == '\'' && string[1] == 0)
    {
      *r++ = '\\';
      *r++ = '\'';
      *r++ = 0;
      return result;
    }
  *r++ = '\'';
  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;
      if (c == '\'')
 {
   *r++ = '\\';
   *r++ = '\'';
   *r++ = '\'';
 }
    }
  *r++ = '\'';
  *r = '\0';
  return (result);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 7
6 7
7 7
8 9
9 9
10 16
11 16
12 16
13 16
14 19
15 17
16 17
17 17
18 17
19 17
20 17
21 20
22 19
23 20
24 22
25 23
26 24
27 24
28 17
29 17
30 17
31 27
32 28
33 30
34 30
35 30
36 9
37 9
38 11
39 12
40 13
41 30
42 30
43 30
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  16f3 <mu_url_aget_auth+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    1717 <mu_url_aget_auth+0x37>
mov    0x8(%rsp),%rdi
test   %rdi,%rdi
je     1720 <mu_url_aget_auth+0x40>
callq  1708 <mu_url_aget_auth+0x28>
test   %rax,%rax
mov    %rax,0x0(%rbp)
mov    $0xc,%eax
cmove  %eax,%ebx
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
movq   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_aget_auth (mu_url_t url, char **buf) { const char *str; int status = mu_url_sget_auth (url, &str); if (status) return status; if (str) { *buf = strdup (str); if (!*buf) status = 12; } else *buf = ((void *)0); return status; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
test   $0x2,%dil
je     90 <wsnode_flagstr+0x90>
movb   $0x77,0x0(%rip)        # 11 <wsnode_flagstr+0x11>
mov    %edi,%eax
movb   $0x0,0x0(%rip)        # 1a <wsnode_flagstr+0x1a>
and    $0x4,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbc,%eax
add    $0x71,%eax
mov    %al,0x0(%rip)        # 2e <wsnode_flagstr+0x2e>
mov    %edi,%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffe8,%eax
add    $0x45,%eax
mov    %al,0x0(%rip)        # 44 <wsnode_flagstr+0x44>
mov    %edi,%eax
and    $0x10,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffc3,%eax
add    $0x6a,%eax
mov    %al,0x0(%rip)        # 5a <wsnode_flagstr+0x5a>
mov    %edi,%eax
and    $0x20,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0x40,%edi
and    $0xffffffba,%eax
add    $0x73,%eax
cmp    $0x1,%edi
mov    %al,0x0(%rip)        # 76 <wsnode_flagstr+0x76>
sbb    %eax,%eax
and    $0xffffffc9,%eax
add    $0x64,%eax
mov    %al,0x0(%rip)        # 84 <wsnode_flagstr+0x84>
mov    $0x0,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    %edi,%eax
and    $0x1,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbf,%eax
add    $0x6e,%eax
mov    %al,0x0(%rip)        # a6 <wsnode_flagstr+0xa6>
jmpq   11 <wsnode_flagstr+0x11>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_flagstr (int flags)
{
  static char retbuf[7];
  char *p = retbuf;
  if (flags & 0x02)
    *p++ = 'w';
  else if (flags & 0x01)
    *p++ = 'n';
  else
    *p++ = '-';
  if (flags & 0x04)
    *p++ = 'q';
  else
    *p++ = '-';
  if (flags & 0x08)
    *p++ = 'E';
  else
    *p++ = '-';
  if (flags & 0x10)
    *p++ = 'j';
  else
    *p++ = '-';
  if (flags & 0x20)
    *p++ = 's';
  else
    *p++ = '-';
  if (flags & 0x40)
    *p++ = 'd';
  else
    *p++ = '-';
  *p = 0;
  return retbuf;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 11
5 31
6 11
7 12
8 12
9 12
10 12
11 12
12 15
13 15
14 16
15 16
16 16
17 16
18 16
19 19
20 19
21 20
22 20
23 20
24 20
25 20
26 23
27 23
28 24
29 24
30 27
31 24
32 24
33 28
34 24
35 28
36 28
37 28
38 28
39 33
40 33
41 33
42 7
43 7
44 8
45 8
46 8
47 8
48 8
49 8
50 8
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     2d1 <gsl_matrix_complex_long_double_fscanf+0x91>
shl    $0x5,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    28e <gsl_matrix_complex_long_double_fscanf+0x4e>
jmp    2c0 <gsl_matrix_complex_long_double_fscanf+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     2c0 <gsl_matrix_complex_long_double_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  2a5 <gsl_matrix_complex_long_double_fscanf+0x65>
test   %eax,%eax
je     280 <gsl_matrix_complex_long_double_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   2f4 <gsl_matrix_complex_long_double_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_fscanf (FILE * stream, gsl_matrix_complex_long_double * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_long_double_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_long_double_raw_fscanf (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  3aae <gsl_vector_char_calloc+0xe>
test   %rax,%rax
mov    %rax,%rbp
je     3aeb <gsl_vector_char_calloc+0x4b>
mov    0x10(%rax),%rdi
xor    %esi,%esi
mov    %rbx,%rdx
callq  3ac4 <gsl_vector_char_calloc+0x24>
test   %rbx,%rbx
je     3ae1 <gsl_vector_char_calloc+0x41>
xor    %ecx,%ecx
nopl   0x0(%rax,%rax,1)
mov    0x10(%rbp),%rsi
movb   $0x0,(%rsi,%rcx,1)
add    $0x1,%rcx
cmp    %rbx,%rcx
jne    3ad0 <gsl_vector_char_calloc+0x30>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    3ae4 <gsl_vector_char_calloc+0x44>
nop
<<<sep_in_sample>>>
gsl_vector_char_calloc (const size_t n)
{
  size_t i;
  gsl_vector_char * v = gsl_vector_char_alloc (n);
  if (v == 0)
    return 0;
  memset(v->data, 0, 1 * n * sizeof(char));
  for (i = 0; i < 1 * n; i++)
    {
      v->data[i] = 0;
    }
  return v;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 10
18 10
19 8
20 8
21 8
22 8
23 13
24 13
25 13
26 13
27 6
28 6
29 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
mov    0x40(%rdi),%rsi
mov    0x10(%rax),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_preloop(const void * vtrust_state, void * vstate)
{
  int status;
  const gsl_multilarge_nlinear_trust_state *trust_state =
    (const gsl_multilarge_nlinear_trust_state *) vtrust_state;
  const gsl_multilarge_nlinear_parameters *params = trust_state->params;
  (void)vstate;
  status = (params->solver->init)(trust_state, trust_state->solver_state);
  if (status)
    return status;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
<<<sep_out_sample>>>
push   %rbx
testb  $0x2,0x2d1(%rdi)
mov    %rdi,%rbx
jne    423 <update_aim120+0x63>
movslq (%rdi),%rax
mov    0x0(,%rax,4),%esi
test   %esi,%esi
je     423 <update_aim120+0x63>
mov    0x0(,%rax,4),%ecx
test   %ecx,%ecx
jle    423 <update_aim120+0x63>
mov    $0x0,%esi
callq  3f0 <update_aim120+0x30>
test   %eax,%eax
js     450 <update_aim120+0x90>
mov    0x0(%rip),%edx        # 3fa <update_aim120+0x3a>
test   %edx,%edx
je     430 <update_aim120+0x70>
mov    %eax,%esi
mov    %rbx,%rdi
callq  408 <update_aim120+0x48>
mov    $0x4,%esi
mov    %rbx,%rdi
callq  415 <update_aim120+0x55>
movslq (%rbx),%rax
movl   $0x0,0x0(,%rax,4)
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movslq %eax,%rdx
shl    $0x5,%rdx
movq   $0x0,0x870(%rbx,%rdx,1)
movslq (%rbx),%rdx
subl   $0x1,0x0(,%rdx,4)
jmp    3fe <update_aim120+0x3e>
mov    0x0(%rip),%rcx        # 457 <update_aim120+0x97>
mov    $0x1c,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  46b <update_aim120+0xab>
jmp    415 <update_aim120+0x55>
nopl   (%rax)
<<<sep_in_sample>>>
update_aim120(craft * c)
{
 register int i;
 if ((c->flags & (1<<9)) == 0) {
  if (hasFired[c->pIndex] && count[c->pIndex] > 0) {
   i = readyStation(c, "aim120");
   if (i < 0)
    fprintf(stderr, "Oops. Can't find an AIM-120\n");
   else {
    if (arcadeMode == 0) {
     c->station[i].type = "";
     count[c->pIndex]--;
    }
    fireMissile(c, i);
    playSound(c, 4);
   }
   hasFired[c->pIndex] = 0;
  }
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 7
15 7
16 10
17 10
18 10
19 14
20 14
21 14
22 15
23 15
24 15
25 17
26 17
27 21
28 21
29 21
30 21
31 11
32 11
33 11
34 12
35 12
36 12
37 8
38 8
39 8
40 8
41 8
42 8
43 8
<<<sep_out_sample>>>
add    $0x10,%rdi
mov    $0xffffffff,%esi
jmpq   c70 <it_init_joblist.isra.1>
xchg   %ax,%ax
<<<sep_in_sample>>>
it_init_jobs (itp)
     ITEMLIST *itp;
{
  return (it_init_joblist (itp, -1));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x0(%rip),%rdi        # 42 <mu_global_debug_set_level+0x12>
test   %rdi,%rdi
je     78 <mu_global_debug_set_level+0x48>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
callq  54 <mu_global_debug_set_level+0x24>
cmp    $0x1029,%eax
mov    %eax,%edx
je     61 <mu_global_debug_set_level+0x31>
test   %edx,%edx
jne    6a <mu_global_debug_set_level+0x3a>
mov    0x8(%rsp),%rax
mov    %ebp,(%rax)
mov    %edx,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %edx,%edx
mov    $0x4,%esi
mov    $0x0,%edi
callq  89 <mu_global_debug_set_level+0x59>
test   %eax,%eax
jne    6a <mu_global_debug_set_level+0x3a>
mov    0x0(%rip),%rdi        # 94 <mu_global_debug_set_level+0x64>
jmp    47 <mu_global_debug_set_level+0x17>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_global_debug_set_level (const char *object_name, mu_log_level_t level)
{
  int rc;
  struct debug_level *dbg;
  if (!debug_table)
    {
      rc = mu_assoc_create (&debug_table, sizeof(struct debug_level), 0);
      if (rc)
 return rc;
    }
  rc = mu_assoc_ref_install (debug_table, object_name, (void**) &dbg);
  if (rc == 0 || rc == (0x1000 +41))
    dbg->level = level;
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 11
10 11
11 11
12 12
13 11
14 12
15 12
16 12
17 13
18 13
19 11
20 15
21 15
22 15
23 15
24 15
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  428 <search_line_node+0x8>
mov    0x0(%rip),%eax        # 42e <search_line_node+0xe>
cmp    %ebx,%eax
jge    490 <search_line_node+0x70>
mov    0x0(%rip),%ecx        # 438 <search_line_node+0x18>
lea    (%rbx,%rbx,1),%edx
lea    (%rax,%rcx,1),%esi
cmp    %edx,%esi
jge    508 <search_line_node+0xe8>
mov    0x0(%rip),%rdx        # 44d <search_line_node+0x2d>
cmp    %ecx,%ebx
mov    %ecx,0x0(%rip)        # 455 <search_line_node+0x35>
mov    %rdx,0x0(%rip)        # 45c <search_line_node+0x3c>
jge    480 <search_line_node+0x60>
sub    %ebx,%ecx
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
add    $0x1,%eax
mov    0x8(%rdx),%rdx
cmp    %ecx,%eax
jne    468 <search_line_node+0x48>
mov    %ebx,0x0(%rip)        # 479 <search_line_node+0x59>
mov    %rdx,0x0(%rip)        # 480 <search_line_node+0x60>
callq  485 <search_line_node+0x65>
mov    0x0(%rip),%rax        # 48c <search_line_node+0x6c>
pop    %rbx
retq   
xchg   %ax,%ax
lea    (%rbx,%rbx,1),%edx
cmp    %edx,%eax
jg     4c0 <search_line_node+0xa0>
cmp    %ebx,%eax
jle    480 <search_line_node+0x60>
mov    0x0(%rip),%rdx        # 4a2 <search_line_node+0x82>
sub    %ebx,%eax
mov    %eax,%ecx
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
add    $0x1,%eax
mov    0x8(%rdx),%rdx
cmp    %ecx,%eax
jne    4b0 <search_line_node+0x90>
jmp    473 <search_line_node+0x53>
nopl   (%rax)
test   %ebx,%ebx
movq   $0x0,0x0(%rip)        # 4cd <search_line_node+0xad>
movl   $0x0,0x0(%rip)        # 4d7 <search_line_node+0xb7>
jle    480 <search_line_node+0x60>
xor    %eax,%eax
mov    $0x0,%edx
add    $0x1,%eax
mov    (%rdx),%rdx
cmp    %ebx,%eax
jne    4e0 <search_line_node+0xc0>
mov    %eax,0x0(%rip)        # 4f0 <search_line_node+0xd0>
mov    %rdx,0x0(%rip)        # 4f7 <search_line_node+0xd7>
callq  4fc <search_line_node+0xdc>
mov    0x0(%rip),%rax        # 503 <search_line_node+0xe3>
pop    %rbx
retq   
nopl   (%rax)
mov    0x0(%rip),%rdx        # 50f <search_line_node+0xef>
mov    %ebx,%ecx
sub    %eax,%ecx
xor    %eax,%eax
nopl   (%rax)
add    $0x1,%eax
mov    (%rdx),%rdx
cmp    %ecx,%eax
jne    518 <search_line_node+0xf8>
jmpq   473 <search_line_node+0x53>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
search_line_node( const int addr )
  {
  static line_t * lp = &buffer_head;
  static int o_addr = 0;
  disable_interrupts();
  if( o_addr < addr )
    {
    if( o_addr + last_addr_ >= 2 * addr )
      while( o_addr < addr ) { ++o_addr; lp = lp->q_forw; }
    else
      {
      lp = buffer_head.q_back; o_addr = last_addr_;
      while( o_addr > addr ) { --o_addr; lp = lp->q_back; }
      }
    }
  else if( o_addr <= 2 * addr )
    while( o_addr > addr ) { --o_addr; lp = lp->q_back; }
  else
    { lp = &buffer_head; o_addr = 0;
      while( o_addr < addr ) { ++o_addr; lp = lp->q_forw; } }
  enable_interrupts();
  return lp;
  }
<<<sep_in_sample>>>
1 2
2 2
3 5
4 6
5 6
6 6
7 8
8 8
9 8
10 8
11 8
12 12
13 13
14 12
15 12
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 21
27 22
28 23
29 23
30 23
31 16
32 16
33 16
34 17
35 17
36 17
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 17
46 17
47 20
48 19
49 19
50 20
51 20
52 20
53 20
54 20
55 20
56 20
57 20
58 20
59 21
60 22
61 23
62 23
63 23
64 23
65 23
66 23
67 8
68 8
69 8
70 9
71 9
72 9
73 9
74 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_splinalg_itersolve_name(const gsl_splinalg_itersolve *w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
mov    %rdx,(%rsp)
mov    $0x0,%esi
mov    %rsp,%rdx
callq  1ea <message_append_text_file+0x1a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
message_append_text_file (MESSAGE msg, char *filename, char *prefix)
{
  struct append_closure clos;
  clos.filename = filename;
  clos.prefix = prefix;
  message_proc_body (msg, _append_proc, &clos);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 6
6 6
7 7
8 7
9 7
<<<sep_out_sample>>>
mov    %rdi,%rsi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  5a1 <read_fatal+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_fatal (char const *name)
{
  call_arg_fatal ("read", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  90c <proper_name+0xc>
cmp    %rbp,%rax
mov    %rax,%rbx
je     923 <proper_name+0x23>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  0 <mbsstr_trimmed_wordbounded>
test   %al,%al
je     930 <proper_name+0x30>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  938 <proper_name+0x38>
mov    %rbp,%rdi
mov    %rax,%r12
callq  943 <proper_name+0x43>
lea    0x4(%r12,%rax,1),%rdi
callq  94d <proper_name+0x4d>
mov    %rax,%r12
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rax,%rdi
mov    %r12,%rbx
mov    $0x0,%esi
xor    %eax,%eax
callq  968 <proper_name+0x68>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
proper_name (const char *name)
{
  const char *translation = gettext (name);
  if (translation != name)
    {
      if (mbsstr_trimmed_wordbounded (translation, name))
        return translation;
      else
        {
          char *result =
            ((char *) (sizeof (char) == 1 ? xmalloc (strlen (translation) + 2 + strlen (name) + 1 + 1) : xnmalloc (strlen (translation) + 2 + strlen (name) + 1 + 1, sizeof (char))));
          sprintf (result, "%s (%s)", translation, name);
          return result;
        }
    }
  else
    return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 6
10 6
11 6
12 6
13 6
14 18
15 18
16 18
17 18
18 18
19 18
20 11
21 11
22 11
23 11
24 11
25 11
26 10
27 10
28 12
29 12
30 12
31 13
32 12
33 12
34 12
35 18
36 18
37 18
38 18
39 18
<<<sep_out_sample>>>
mov    %rdi,%r8
mov    $0xa,%ecx
mov    %rsi,%rdi
mov    $0x0,%esi
repz cmpsb %es:(%rdi),%ds:(%rsi)
sete   %al
movzbl %al,%eax
jne    78 <IsDelayFunc+0x28>
mov    (%r8),%edx
test   %edx,%edx
jne    78 <IsDelayFunc+0x28>
movl   $0x1,(%r8)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
IsDelayFunc (BOOL *bDelays, PSTR sz)
{
  BOOL bIsDelay;
  bIsDelay = (!strcmp ("CalcDelay", sz));
  if (bIsDelay && !(*bDelays))
    *bDelays = 1;
  return (bIsDelay);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
test   %rdx,%rdx
jle    1290 <WriteOne_R_PSDecl+0x90>
test   %rbx,%rbx
je     1270 <WriteOne_R_PSDecl+0x70>
cmp    $0x1,%rbx
je     1250 <WriteOne_R_PSDecl+0x50>
cmp    $0xffffffffffffffff,%rbx
je     1230 <WriteOne_R_PSDecl+0x30>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rax,%rdx
mov    %rbp,%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  1242 <WriteOne_R_PSDecl+0x42>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rbp,%rsi
mov    $0xa,%edi
callq  125d <WriteOne_R_PSDecl+0x5d>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rax,%rdx
mov    %rbp,%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  1282 <WriteOne_R_PSDecl+0x82>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rsi,%rdi
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
callq  129e <WriteOne_R_PSDecl+0x9e>
jmpq   1211 <WriteOne_R_PSDecl+0x11>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
WriteOne_R_PSDecl (PFILE pfile, PVMMAPSTRCT pvm, PVOID pInfo)
{
  PSTR szVarName;
  long End = (long) pInfo;
  if (End < 1)
    szVarName = GetName (pvm, ((void *)0), ((void *)0), 0x00000);
  switch (End) {
    case -1:
      fprintf (pfile, "    %s = 0.0", szVarName);
      break;
    case 0:
      fprintf (pfile, ",\n    %s = 0.0", szVarName);
      break;
    case 1:
      fprintf (pfile, "\n");
      return (0);
  }
  return (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 19
15 18
16 19
17 19
18 19
19 19
20 9
21 9
22 9
23 9
24 9
25 19
26 18
27 19
28 19
29 19
30 19
31 15
32 15
33 15
34 19
35 16
36 19
37 19
38 19
39 19
40 12
41 12
42 12
43 12
44 12
45 19
46 18
47 19
48 19
49 19
50 19
51 19
52 6
53 6
54 6
55 6
56 6
57 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     640 <nntp_get_transport2+0x50>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     640 <nntp_get_transport2+0x50>
mov    0x18(%rax),%rcx
mov    $0x16,%eax
test   %rcx,%rcx
je     650 <nntp_get_transport2+0x60>
cmpq   $0x0,0x8(%rcx)
je     637 <nntp_get_transport2+0x47>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x18(%rcx),%rdi
lea    0x8(%rsp),%rsi
callq  62d <nntp_get_transport2+0x3d>
test   %eax,%eax
je     658 <nntp_get_transport2+0x68>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
repz retq 
nopl   0x0(%rax)
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdi
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  668 <nntp_get_transport2+0x78>
jmp    631 <nntp_get_transport2+0x41>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nntp_get_transport2 (msg_nntp_t msg_nntp, mu_transport_t *pin, mu_transport_t *pout)
{
  int status = 22;
  if (msg_nntp && msg_nntp->m_nntp
      && msg_nntp->m_nntp->f_nntp && msg_nntp->m_nntp->f_nntp->folder)
    {
      mu_stream_t carrier;
      status = mu_nntp_get_carrier (msg_nntp->m_nntp->f_nntp->nntp, &carrier);
      if (status == 0)
 return mu_stream_get_transport2 (carrier, pin, pout);
    }
  return status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 3
8 5
9 5
10 5
11 5
12 2
13 2
14 2
15 2
16 2
17 8
18 8
19 8
20 9
21 9
22 13
23 13
24 13
25 13
26 13
27 3
28 3
29 3
30 3
31 3
32 10
33 10
34 10
35 10
36 10
37 10
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     1401 <gsl_matrix_long_isnonneg+0x51>
xorpd  %xmm1,%xmm1
lea    0x0(,%rax,8),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     13f5 <gsl_matrix_long_isnonneg+0x45>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
nop
cvtsi2sdq (%rcx,%rax,8),%xmm0
ucomisd %xmm0,%xmm1
ja     1407 <gsl_matrix_long_isnonneg+0x57>
add    $0x1,%rax
cmp    %rdx,%rax
jne    13e0 <gsl_matrix_long_isnonneg+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    13d1 <gsl_matrix_long_isnonneg+0x21>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_isnonneg (const gsl_matrix_long * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 9
21 9
22 7
23 7
24 7
25 7
26 20
27 21
28 15
29 15
30 15
<<<sep_out_sample>>>
jmpq   85 <username_completion_function+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
username_completion_function (s, i)
     const char *s;
     int i;
{
  return rl_username_completion_function (s, i);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     260 <_get_mcn_image+0x20>
mov    0x1618(%rdi),%rdi
test   %rdi,%rdi
je     260 <_get_mcn_image+0x20>
jmpq   256 <_get_mcn_image+0x16>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_get_mcn_image(const void *p_user_data)
{
  const _img_private_t *p_env = p_user_data;
  if (!p_env || !p_env->psz_mcn) return ((void *)0);
  return strdup(p_env->psz_mcn);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
mov    0x38(%rdi),%eax
test   %eax,%eax
je     b <_count_databases+0xb>
addq   $0x1,(%rsi)
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
_count_databases(void *item, void *data)
{
    const dicod_database_t *db = item;
    size_t *pcount = data;
    if (((db)->visible))
 ++*pcount;
    return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 8
6 8
7 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 487 <getmapfile+0x7>
cmp    %rdi,0x10(%rax)
jle    49d <getmapfile+0x1d>
movq   $0x0,0x0(%rip)        # 498 <getmapfile+0x18>
mov    $0x0,%eax
mov    0x18(%rax),%rdx
cmp    0x10(%rdx),%rdi
jge    4b3 <getmapfile+0x33>
jmp    4c8 <getmapfile+0x48>
nopl   0x0(%rax)
mov    %rax,%rdx
mov    0x18(%rdx),%rax
cmp    0x10(%rax),%rdi
jge    4b0 <getmapfile+0x30>
mov    %rdx,0x0(%rip)        # 4c4 <getmapfile+0x44>
mov    (%rdx),%rax
retq   
mov    %rax,%rdx
jmp    4c4 <getmapfile+0x44>
nopl   (%rax)
<<<sep_in_sample>>>
getmapfile (long line)
{
  if (mapindeks->fromline > line)
    mapindeks = firstmappos;
  while (mapindeks->neste->fromline <= line)
    mapindeks = mapindeks->neste;
  return (mapindeks->filename);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 8
18 5
19 5
20 5
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rdx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    %rax,%rsi
lea    0x70(%rdx),%rdi
callq  86 <hdr_destroy+0x16>
mov    %rbx,%rdi
callq  8e <hdr_destroy+0x1e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hdr_destroy (mu_iterator_t iterator, void *data)
{
  struct header_iterator *itr = data;
  mu_iterator_detach (&itr->header->itr, iterator);
  free (data);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 7
11 7
12 7
13 7
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  992 <gsl_stats_char_lag1_autocorrelation+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   9a4 <gsl_stats_char_lag1_autocorrelation+0x24>
<<<sep_in_sample>>>
gsl_stats_char_lag1_autocorrelation (const char data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_char_mean (data, stride, n);
  return gsl_stats_char_lag1_autocorrelation_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  cb <_s_write+0x1b>
mov    0x8(%rsp),%r8
mov    (%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   e9 <_s_write+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_s_write (mu_stream_t stream, const char *iptr, size_t isize,
   mu_off_t offset, size_t *nbytes)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_write (s->fstream, iptr, isize, offset, nbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
lea    -0x3a(%rdi),%eax
cmp    $0x6,%eax
jbe    e60 <iso9660_is_dchar+0x20>
lea    -0x30(%rdi),%eax
cmp    $0x2f,%eax
ja     e60 <iso9660_is_dchar+0x20>
sub    $0x5b,%edi
cmp    $0x3,%edi
seta   %al
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_is_dchar (int c)
{
  if (!((c) >= (0x30) && (c) <= (0x5f))
      || ((c) >= (0x3a) && (c) <= (0x40))
      || ((c) >= (0x5b) && (c) <= (0x5e)))
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  445 <grecs_grecs__init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%r12
mov    (%rax),%r13d
callq  453 <grecs_grecs__init_buffer+0x23>
mov    0x0(%rip),%rax        # 45a <grecs_grecs__init_buffer+0x2a>
mov    %rbp,(%rbx)
movl   $0x1,0x38(%rbx)
test   %rax,%rax
je     476 <grecs_grecs__init_buffer+0x46>
mov    0x0(%rip),%rdx        # 470 <grecs_grecs__init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     484 <grecs_grecs__init_buffer+0x54>
movl   $0x1,0x30(%rbx)
movl   $0x0,0x34(%rbx)
xor    %eax,%eax
test   %rbp,%rbp
je     4a2 <grecs_grecs__init_buffer+0x72>
mov    %rbp,%rdi
callq  493 <grecs_grecs__init_buffer+0x63>
mov    %eax,%edi
callq  49a <grecs_grecs__init_buffer+0x6a>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x28(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs__init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 grecs_grecs__flush_buffer(b );
 b->grecs_grecs__input_file = file;
 b->grecs_grecs__fill_buffer = 1;
    if (b != ( (grecs_grecs__buffer_stack) ? (grecs_grecs__buffer_stack)[(grecs_grecs__buffer_stack_top)] : ((void *)0))){
        b->grecs_grecs__bs_lineno = 1;
        b->grecs_grecs__bs_column = 0;
    }
        b->grecs_grecs__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_aix (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
mov    %sil,0x6e(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panel_set_wrapped_isearch_flag(this, value)
    panel_t *this;
    int value;
{
    this->wrapped_isearch = value;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  23cf <env_define+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     2420 <env_define+0x60>
mov    0x10(%rax),%rdi
callq  23e0 <env_define+0x20>
mov    0x18(%rbx),%rdi
callq  23e9 <env_define+0x29>
mov    %rbp,%rdi
callq  23f1 <env_define+0x31>
mov    %rbp,%rdi
mov    %eax,0x24(%rbx)
movl   $0x1,0x20(%rbx)
callq  2403 <env_define+0x43>
mov    %r12,%rdi
mov    %rax,0x10(%rbx)
callq  240f <env_define+0x4f>
mov    %rax,0x18(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x28,%edi
callq  242a <env_define+0x6a>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 2434 <env_define+0x74>
movq   $0x0,0x8(%rbx)
mov    %rbx,0x0(%rip)        # 2443 <env_define+0x83>
test   %rax,%rax
mov    %rax,(%rbx)
je     23e9 <env_define+0x29>
mov    %rbx,0x8(%rax)
jmp    23e9 <env_define+0x29>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
env_define (const char *var, unsigned char *value)
{
  register struct env_lst *ep = env_find (var);
  if (ep)
    {
      free (ep->var);
      free (ep->value);
    }
  else
    {
      ep = (struct env_lst *) xmalloc (sizeof (struct env_lst));
      ep->next = envlisthead.next;
      envlisthead.next = ep;
      ep->prev = &envlisthead;
      if (ep->next)
 ep->next->prev = ep;
    }
  ep->welldefined = opt_welldefined ((char *)var);
  ep->export = 1;
  ep->var = (unsigned char *) strdup ((char *) var);
  ep->value = (unsigned char *) strdup ((char *) value);
  return (ep);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 7
13 7
14 18
15 18
16 20
17 18
18 19
19 20
20 21
21 20
22 21
23 21
24 23
25 23
26 23
27 23
28 23
29 23
30 11
31 11
32 11
33 12
34 14
35 13
36 15
37 12
38 15
39 16
40 16
41 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  a6c <gsl_sf_bessel_y1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    a80 <gsl_sf_bessel_y1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a96 <gsl_sf_bessel_y1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_y1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_y1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_y1_e(x, &result)", "bessel_y.c", 279, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rax
mov    %rsi,%rbx
mov    $0x12,%ecx
sub    $0x70,%rsp
lea    0xc(%rsp),%rdx
movq   $0x0,0x18(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x20(%rsp)
lea    0x10(%rsp),%rsi
mov    %rdx,0x10(%rsp)
movq   $0x0,0x30(%rsp)
lea    0x40(%rsp),%rdx
movq   $0x0,0x40(%rsp)
movq   $0x0,0x48(%rsp)
movq   $0x0,0x50(%rsp)
movq   $0x0,0x60(%rsp)
movl   $0x14,0x58(%rsp)
movl   $0x10,0x28(%rsp)
movl   $0x4,0x1c(%rsp)
callq  *0x110(%rax)
test   %eax,%eax
jne    67d <CDB___db_vrfy_pgset_next+0x9d>
mov    0xc(%rsp),%edx
mov    %edx,(%rbx)
add    $0x70,%rsp
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_vrfy_pgset_next(dbc, pgnop)
 DBC *dbc;
 db_pgno_t *pgnop;
{
 DBT key, data;
 db_pgno_t pgno;
 int ret;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 (&data)->flags |= (0x010 | 0x004);
 (&key)->flags |= (0x010);
 key.data = &pgno;
 key.ulen = sizeof(db_pgno_t);
 if ((ret = dbc->c_get(dbc, &key, &data, 18)) != 0)
  return (ret);
 ((void)0);
 *pgnop = pgno;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 14
5 4
6 12
7 8
8 8
9 9
10 8
11 14
12 12
13 8
14 14
15 9
16 9
17 9
18 9
19 10
20 11
21 13
22 14
23 14
24 14
25 17
26 17
27 19
28 19
29 19
30 19
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
mov    $0x1,%eax
ucomisd %xmm1,%xmm0
jbe    18 <__rsignr+0x18>
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
ucomisd %xmm0,%xmm1
seta   %al
neg    %rax
retq   
<<<sep_in_sample>>>
__rsignr (double e)
{
  return ((e > 0.0) ? 1 : (e < 0.0) ? -1 : 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 3
8 3
9 3
10 3
11 4
<<<sep_out_sample>>>
push   %rbx
xor    %edx,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  2d0 <xdatabase_capability+0x10>
test   %eax,%eax
je     2e0 <xdatabase_capability+0x20>
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    $0x0,%esi
pop    %rbx
jmpq   2ee <xdatabase_capability+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
xdatabase_capability (ANUBIS_SMTP_REPLY reply)
{
  if (!smtp_reply_has_capa (reply, "XDATABASE", ((void *)0)))
    smtp_reply_add_line (reply, "XDATABASE");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 4
12 4
13 5
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  79 <_memory_size+0x9>
test   %rbx,%rbx
je     85 <_memory_size+0x15>
mov    0x10(%rax),%rax
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_memory_size (mu_stream_t stream, mu_off_t *psize)
{
  struct _memory_stream *mfs = mu_stream_get_owner (stream);
  if (psize)
    *psize = mfs->size;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
jmp    1a <nonintr_close+0x1a>
nopw   0x0(%rax,%rax,1)
callq  15 <nonintr_close+0x15>
cmpl   $0x4,(%rax)
jne    27 <nonintr_close+0x27>
mov    %ebp,%edi
callq  21 <nonintr_close+0x21>
test   %eax,%eax
mov    %eax,%ebx
js     10 <nonintr_close+0x10>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nonintr_close (int fd)
{
  int retval;
  do
    retval = close (fd);
  while (retval < 0 && (*__errno_location ()) == 4);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 5
11 5
12 6
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     34a8 <gsl_vector_short_free+0x38>
mov    0x20(%rdi),%eax
test   %eax,%eax
jne    3490 <gsl_vector_short_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   3489 <gsl_vector_short_free+0x19>
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
callq  3499 <gsl_vector_short_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   34a2 <gsl_vector_short_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_free (gsl_vector_short * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_short_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x1,%esi
mov    %rbx,%rdx
callq  3e78 <gsl_block_uchar_fread+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     3e9a <gsl_block_uchar_fread+0x3a>
mov    $0x1f,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3e95 <gsl_block_uchar_fread+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_uchar_fread (FILE * stream, gsl_block_uchar * b)
{
  size_t n = b->size ;
  unsigned char * data = b->data ;
  size_t items = fread (data, 1 * sizeof (unsigned char), n, stream);
  if (items != n)
    {
      do { gsl_error ("fread failed", "fwrite_source.c", 31, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 24a <swparse_set_do_not_warn_utf+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swparse_set_do_not_warn_utf(void)
{
 do_not_warn_utf = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <cdio_log_set_handler+0x7>
mov    %rdi,0x0(%rip)        # e <cdio_log_set_handler+0xe>
retq   
nop
<<<sep_in_sample>>>
cdio_log_set_handler(cdio_log_handler_t new_handler)
{
  cdio_log_handler_t old_handler = _handler;
  _handler = new_handler;
  return old_handler;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0xa0,%rsp
mov    0x8(%rdi),%rsi
mov    %rbp,%rdi
callq  dd <_maildir_is_scheme+0x1d>
test   %eax,%eax
je     f8 <_maildir_is_scheme+0x38>
mov    %r12d,%ebx
and    $0x2,%ebx
add    $0xa0,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    %rbp,%rdi
callq  100 <_maildir_is_scheme+0x40>
test   %eax,%eax
mov    %eax,%ebx
je     e7 <_maildir_is_scheme+0x27>
lea    0x8(%rsp),%rsi
mov    %rbp,%rdi
callq  113 <_maildir_is_scheme+0x53>
test   %eax,%eax
mov    %eax,%ebx
je     130 <_maildir_is_scheme+0x70>
add    $0xa0,%rsp
xor    %ebx,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
lea    0x10(%rsp),%rsi
callq  13f <_maildir_is_scheme+0x7f>
test   %eax,%eax
js     119 <_maildir_is_scheme+0x59>
mov    0x28(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
jne    119 <_maildir_is_scheme+0x59>
and    $0x2,%r12d
je     e7 <_maildir_is_scheme+0x27>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  70 <dir_exists>
test   %eax,%eax
je     e7 <_maildir_is_scheme+0x27>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  70 <dir_exists>
test   %eax,%eax
je     e7 <_maildir_is_scheme+0x27>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  70 <dir_exists>
test   %eax,%eax
mov    $0x3,%eax
cmovne %eax,%ebx
jmpq   e7 <_maildir_is_scheme+0x27>
<<<sep_in_sample>>>
_maildir_is_scheme (mu_record_t record, mu_url_t url, int flags)
{
  if (mu_url_is_scheme (url, record->scheme))
    return 0x002 & flags;
  if (mu_scheme_autodetect_p (url))
    {
      const char *path;
      struct stat st;
      if (mu_url_sget_path (url, &path))
        return 0;
      if (stat (path, &st) < 0)
 return 0;
      if (!((((st.st_mode)) & 0170000) == (0040000)))
 return 0;
      if ((flags & 0x002)
   && dir_exists (path, "tmp")
      && dir_exists (path, "cur")
       && dir_exists (path, "new"))
        return 0x002|0x001;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 22
15 22
16 22
17 22
18 22
19 22
20 22
21 5
22 5
23 5
24 5
25 5
26 9
27 9
28 9
29 9
30 9
31 9
32 22
33 10
34 22
35 22
36 22
37 22
38 22
39 22
40 11
41 11
42 11
43 11
44 11
45 13
46 13
47 13
48 13
49 15
50 15
51 16
52 16
53 16
54 16
55 16
56 17
57 17
58 17
59 17
60 17
61 18
62 18
63 18
64 19
65 19
66 19
67 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  5b9 <dicod_loader_init+0x9>
mov    0x0(%rip),%rdi        # 5c0 <dicod_loader_init+0x10>
xor    %edx,%edx
mov    $0x0,%esi
callq  5cc <dicod_loader_init+0x1c>
mov    $0x0,%edi
callq  5d6 <dicod_loader_init+0x26>
mov    0x0(%rip),%rdi        # 5dd <dicod_loader_init+0x2d>
xor    %edx,%edx
mov    $0x0,%esi
add    $0x8,%rsp
jmpq   5ed <dicod_loader_init+0x3d>
nopl   (%rax)
<<<sep_in_sample>>>
dicod_loader_init()
{
    lt_dlinit();
    dico_list_iterate(prepend_load_path, _add_load_dir, ((void *)0));
    lt_dladdsearchdir("/usr/local/lib/dico");
    dico_list_iterate(module_load_path, _add_load_dir, ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 6
14 6
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,(%rdi)
mov    %rdi,%rbx
jne    c9e <tail+0x1e>
jmp    cb0 <tail+0x30>
nopl   0x0(%rax,%rax,1)
cmpb   $0x0,0x1(%rax)
jne    cb8 <tail+0x38>
movb   $0x0,(%rax)
cmpb   $0x0,(%rbx)
je     cb0 <tail+0x30>
mov    $0x2f,%esi
mov    %rbx,%rdi
callq  cab <tail+0x2b>
test   %rax,%rax
jne    c90 <tail+0x10>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   (%rax)
add    $0x1,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
tail (char *filename)
{
  register char *s;
  while (*filename)
    {
      s = strrchr (filename, '/');
      if (s == ((void *)0))
 break;
      if (s[1])
 return (s + 1);
      *s = '\0';
    }
  return filename;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 9
8 9
9 11
10 4
11 4
12 6
13 6
14 6
15 7
16 7
17 2
18 14
19 14
20 14
21 10
22 14
23 14
24 14
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%edi
xor    %r12d,%r12d
push   %rbp
xor    %ebp,%ebp
push   %rbx
callq  13 <main+0x13>
mov    $0x0,%edi
callq  1d <main+0x1d>
jmp    2c <main+0x2c>
nop
add    $0x1,%rbp
cmp    %rbx,%r12
je     63 <main+0x63>
mov    %rbx,%r12
mov    %ebp,%edi
callq  33 <main+0x33>
mov    %ebp,%edi
mov    %rax,%rbx
callq  3d <main+0x3d>
test   %rax,%rax
je     54 <main+0x54>
mov    %rax,%rsi
mov    %rbx,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  54 <main+0x54>
test   %rbx,%rbx
jne    20 <main+0x20>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    5e <main+0x5e>
<<<sep_in_sample>>>
main (void)
{
  const char *this = ((void *)0), *last = ((void *)0);
  const char *name;
  size_t i = 0;
  printf ("@c This file is automatically generated.  DO NOT EDIT!\n");
  printf ("@c Instead, edit print-errors.c and re-run.\n");
  do
    {
      last = this;
      this = gsasl_strerror (i);
      name = gsasl_strerror_name (i);
      if (name != ((void *)0))
 printf ("\n@item @code{%s}\n%s\n", name, this);
      if (this == ((void *)0))
 return 1;
      i++;
    }
  while (this != last);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 3
4 2
5 5
6 2
7 6
8 7
9 7
10 7
11 7
12 17
13 19
14 19
15 19
16 11
17 11
18 12
19 11
20 12
21 13
22 13
23 14
24 14
25 14
26 14
27 14
28 15
29 15
30 16
31 21
32 21
33 21
34 21
35 20
36 20
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
test   %rdi,%rdi
jne    790 <mu_assoc_install+0x20>
mov    $0x16,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
test   %rsi,%rsi
je     77e <mu_assoc_install+0xe>
lea    0xc(%rsp),%rcx
mov    %rdx,%rbp
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
callq  270 <assoc_lookup_or_install>
test   %eax,%eax
jne    783 <mu_assoc_install+0x13>
mov    0xc(%rsp),%edx
mov    $0x1029,%ax
test   %edx,%edx
je     783 <mu_assoc_install+0x13>
mov    0x0(%rip),%rax        # 7c4 <mu_assoc_install+0x54>
mov    0x8(%rbx),%rdx
mov    %rbp,%rsi
lea    0x8(%rax),%rdi
callq  7d4 <mu_assoc_install+0x64>
xor    %eax,%eax
jmp    783 <mu_assoc_install+0x13>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_assoc_install (mu_assoc_t assoc, const char *name, void *value)
{
  int rc;
  int inst;
  static struct _mu_assoc_elem *elp;
  if (!assoc || !name)
    return 22;
  rc = assoc_lookup_or_install (&elp, assoc, name, &inst);
  if (rc)
    return rc;
  if (!inst)
    return (0x1000 +41);
  memcpy (elp->data, value, assoc->elsize);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 6
7 7
8 15
9 15
10 15
11 15
12 15
13 6
14 6
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 11
24 12
25 11
26 11
27 13
28 13
29 13
30 13
31 13
32 14
33 14
34 14
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rdi
callq  915 <message_replace_body+0x15>
mov    %rbp,0x28(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
message_replace_body (MESSAGE msg, char *body)
{
  free (msg->body);
  msg->body = body;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 5
10 5
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
lea    0x10(%rdi),%rsi
push   %rbx
mov    %rdi,%rbx
lea    0x8(%rdi),%rdi
sub    $0x8,%rsp
mov    (%rbx),%rdx
callq  2bc <script_getline+0x1c>
mov    0x8(%rbx),%rdx
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %rdx,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
script_getline(void *data, char **buf)
{
    struct init_script *p = data;
    int rc = getline(&p->buf, &p->size, p->fp);
    *buf = p->buf;
    return rc > 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 2
8 4
9 4
10 5
11 6
12 6
13 6
14 5
15 7
16 7
17 7
18 7
19 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  199 <xstrdup+0x9>
mov    %rbx,%rdi
lea    0x1(%rax),%rsi
pop    %rbx
jmpq   1a6 <xstrdup+0x16>
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  164 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   178 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %rbp
mov    $0xffffffff,%eax
mov    %rdi,%rbp
push   %rbx
cmpb   $0x0,(%rdi)
je     131e <isby+0x6e>
xor    %ebx,%ebx
nopl   0x0(%rax)
mov    $0x0,%esi
callq  12d2 <isby+0x22>
test   %eax,%eax
je     1321 <isby+0x71>
movslq %ebx,%rax
movzbl 0x0(%rbp,%rax,1),%edx
cmp    $0x3b,%dl
je     130b <isby+0x5b>
test   %dl,%dl
lea    0x1(%rbp,%rax,1),%rax
setne  %dl
test   %dl,%dl
jne    12fc <isby+0x4c>
jmp    130b <isby+0x5b>
nopl   0x0(%rax,%rax,1)
test   %dl,%dl
je     130b <isby+0x5b>
movzbl (%rax),%edx
add    $0x1,%ebx
add    $0x1,%rax
cmp    $0x3b,%dl
jne    12f8 <isby+0x48>
add    $0x2,%ebx
movslq %ebx,%rdi
add    %rbp,%rdi
cmpb   $0x0,(%rdi)
jne    12c8 <isby+0x18>
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
lea    0x3(%rbx),%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
isby(char *step)
{
  int s;
  for (s = 0; step[s]; s += 2)
    {
      if (!linecmp(step + s, "by"))
 return s + 3;
      else
 {
   while (step[s] && step[s] != ';')
     s++;
 }
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 14
3 2
4 2
5 4
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 10
30 10
31 4
32 4
33 4
34 4
35 4
36 14
37 15
38 15
39 15
40 7
41 15
42 15
43 15
44 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rdi
callq  48d <delete_commands_item+0xd>
mov    0x20(%rbx),%rdi
callq  496 <delete_commands_item+0x16>
mov    0x8(%rbx),%rdx
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %rdx,0x8(%rax)
mov    0x8(%rbx),%rdx
mov    %rax,(%rdx)
pop    %rbx
jmpq   4b1 <delete_commands_item+0x31>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delete_commands_item(struct commands_item *c)
{
 free(c->cmd_string);
 free_cmdarg(c->arg);
 c->next->prev = c->prev;
 c->prev->next = c->next;
 free(c);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 7
10 5
11 6
12 6
13 8
14 7
15 7
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_name (const gsl_multilarge_nlinear_workspace * w)
{
  return w->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %rsi,%rcx
mov    0x0(%rip),%rsi        # a <__gmp_vprintf+0xa>
mov    %rdi,%rdx
mov    $0x0,%edi
jmpq   17 <__gmp_vprintf+0x17>
<<<sep_in_sample>>>
__gmp_vprintf (const char *fmt, va_list ap)
{
  return __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%rbp
lea    -0x8(%rsi),%rbx
test   %rbp,%rbp
jle    7d2 <cntnzu_+0x92>
add    $0x1,%rbp
xor    %r11d,%r11d
mov    $0x1,%r8d
jmp    771 <cntnzu_+0x31>
nopl   0x0(%rax)
add    $0x1,%r8
cmp    %rbp,%r8
je     788 <cntnzu_+0x48>
mov    -0x8(%rsi,%r8,8),%rdi
mov    (%rsi,%r8,8),%r10
cmp    %r10,%rdi
jl     79f <cntnzu_+0x5f>
add    $0x1,%r8
cmp    %rbp,%r8
jne    771 <cntnzu_+0x31>
pop    %rbx
xor    %eax,%eax
mov    %r11,(%rcx)
pop    %rbp
retq   
je     796 <cntnzu_+0x56>
add    $0x1,%r11
add    $0x1,%rdi
cmp    %r10,%rdi
je     768 <cntnzu_+0x28>
mov    -0x8(%rdx,%rdi,8),%r9
cmp    %r8,%r9
jns    790 <cntnzu_+0x50>
mov    (%rbx,%r9,8),%rax
mov    0x8(%rbx,%r9,8),%r9
cmp    %r9,%rax
jge    792 <cntnzu_+0x52>
nopw   0x0(%rax,%rax,1)
cmp    %r8,-0x8(%rdx,%rax,8)
je     796 <cntnzu_+0x56>
add    $0x1,%rax
cmp    %r9,%rax
jne    7c0 <cntnzu_+0x80>
jmp    792 <cntnzu_+0x52>
xor    %r11d,%r11d
jmp    788 <cntnzu_+0x48>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cntnzu_(long *n, long *ia, long *ja, long *nzsut) {
  long i__1, i__2, i__3;
  long jmin, kmin, jmax, kmax, j, k, ii, jj, num;
  --ja;
  --ia;
  num = 0;
  i__1 = *n;
  for (ii = 1; ii <= i__1; ++ii) {
    jmin = ia[ii];
    jmax = ia[ii + 1] - 1;
    if (jmin > jmax) goto L50;
    i__2 = jmax;
    for (j = jmin; j <= i__2; ++j) {
      if ((i__3 = ja[j] - ii) < 0) {
        goto L10;
      }
      else {
        if (i__3 == 0) {
          goto L40;
        }
        else {
         goto L30;
        }
      }
L10:
      jj = ja[j];
      kmin = ia[jj];
      kmax = ia[jj + 1] - 1;
      if (kmin > kmax) goto L30;
      i__3 = kmax;
      for (k = kmin; k <= i__3; ++k) {
        if (ja[k] == ii) goto L40;
      }
L30:
      ++num;
L40:
      ;
    }
L50:
    ;
  }
  *nzsut = num;
  return 0;
}
<<<sep_in_sample>>>
1 1
2 1
3 7
4 5
5 8
6 8
7 8
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 9
16 10
17 11
18 11
19 8
20 8
21 8
22 44
23 44
24 42
25 44
26 44
27 18
28 35
29 13
30 13
31 13
32 14
33 14
34 14
35 27
36 28
37 29
38 29
39 29
40 32
41 32
42 31
43 31
44 31
45 31
46 6
47 6
48 6
<<<sep_out_sample>>>
test   $0x1,%dil
mov    $0x54,%edx
jne    d0 <nettle_md2_init+0x50>
test   $0x2,%dil
jne    e0 <nettle_md2_init+0x60>
test   $0x4,%dil
jne    f8 <nettle_md2_init+0x78>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     b0 <nettle_md2_init+0x30>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     bf <nettle_md2_init+0x3f>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     c7 <nettle_md2_init+0x47>
movb   $0x0,(%rdi)
repz retq 
nopl   0x0(%rax)
movb   $0x0,(%rdi)
add    $0x1,%rdi
mov    $0x53,%dl
test   $0x2,%dil
je     91 <nettle_md2_init+0x11>
nop
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     97 <nettle_md2_init+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmp    97 <nettle_md2_init+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_md2_init(struct md2_ctx *ctx)
{
  memset(ctx, 0, sizeof(*ctx));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
<<<sep_out_sample>>>
push   %rbp
mov    $0x16,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     11c <mu_authority_set_ticket+0x2c>
cmpq   $0x0,0x8(%rdi)
mov    %rsi,%rbp
je     116 <mu_authority_set_ticket+0x26>
lea    0x8(%rdi),%rdi
callq  116 <mu_authority_set_ticket+0x26>
mov    %rbp,0x8(%rbx)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_authority_set_ticket (mu_authority_t authority, mu_ticket_t ticket)
{
  if (authority == ((void *)0))
    return 22;
  if (authority->ticket)
    mu_ticket_destroy (&authority->ticket);
  authority->ticket = ticket;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 5
11 6
12 6
13 7
14 8
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
xor    %ecx,%ecx
jmpq   187 <gsl_multifit_fdfsolver_set+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * s,
                            gsl_multifit_function_fdf * f,
                            const gsl_vector * x)
{
  return gsl_multifit_fdfsolver_wset(s, f, x, ((void *)0));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     398 <mu_mailer_set_url_default+0x38>
push   %rbx
callq  370 <mu_mailer_set_url_default+0x10>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     397 <mu_mailer_set_url_default+0x37>
mov    0x0(%rip),%rdi        # 384 <mu_mailer_set_url_default+0x24>
test   %rdi,%rdi
je     38e <mu_mailer_set_url_default+0x2e>
callq  38e <mu_mailer_set_url_default+0x2e>
mov    %rbx,0x0(%rip)        # 395 <mu_mailer_set_url_default+0x35>
xor    %eax,%eax
pop    %rbx
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailer_set_url_default (const char *url)
{
  char *n = ((void *)0);
  if (!url)
    return 22;
  if ((n = strdup (url)) == ((void *)0))
    return 12;
  if (mailer_url_default)
    free (mailer_url_default);
  mailer_url_default = n;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 2
5 6
6 6
7 7
8 6
9 6
10 8
11 8
12 8
13 9
14 10
15 11
16 12
17 12
18 12
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_reason_phrase (const osip_message_t * sip)
{
  return sip->reason_phrase;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movsd  0x10(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fminimizer_minimum (const gsl_multimin_fminimizer * s)
{
  return s->fval;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
jmpq   c5 <osip_contact_init+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_contact_init (osip_contact_t ** contact)
{
  return osip_from_init ((osip_from_t **) contact);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  210 <free_rule>
mov    0x18(%rbx),%rdi
callq  d65 <free_sequence+0x15>
mov    0x10(%rbx),%rdi
callq  d6e <free_sequence+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   d77 <free_sequence+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
free_sequence (struct sequence * sequence)
{
  free_rule (sequence->open);
  words_free (sequence->close);
  words_free (sequence->exceptions);
  free (sequence);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm2,0x0(%rip)        # 22fc <PiecewiseRandom+0xc>
mov    $0x1,%r8d
movsd  0x0(%rip),%xmm4        # 230a <PiecewiseRandom+0x1a>
mov    $0x0,%ecx
movsd  %xmm3,0x0(%rip)        # 2317 <PiecewiseRandom+0x27>
xorpd  %xmm5,%xmm5
mulsd  %xmm4,%xmm2
movsd  %xmm1,0x0(%rip)        # 2327 <PiecewiseRandom+0x37>
mov    $0x0,%edx
mulsd  %xmm4,%xmm3
movsd  %xmm0,0x0(%rip)        # 2338 <PiecewiseRandom+0x48>
mov    $0x0,%esi
mulsd  %xmm4,%xmm1
mov    $0x4,%edi
movsd  %xmm5,0x0(%rip)        # 234e <PiecewiseRandom+0x5e>
mulsd  %xmm0,%xmm4
movsd  %xmm5,0x0(%rip)        # 235a <PiecewiseRandom+0x6a>
movsd  0x0(%rip),%xmm0        # 2362 <PiecewiseRandom+0x72>
addsd  %xmm2,%xmm3
subsd  %xmm1,%xmm3
subsd  %xmm4,%xmm3
divsd  %xmm3,%xmm0
movsd  %xmm0,0x0(%rip)        # 237a <PiecewiseRandom+0x8a>
movsd  %xmm0,0x0(%rip)        # 2382 <PiecewiseRandom+0x92>
callq  2387 <PiecewiseRandom+0x97>
lea    0x8(%rsp),%r9
mov    $0x1,%r8d
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x4,%edi
callq  23ab <PiecewiseRandom+0xbb>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
PiecewiseRandom (double min, double a, double b, double max)
{
  double dTemp;
  static double Grille[4];
  static double densite[4];
  static double densiteCum[4];
  double nvlle_densite;
  Grille[0] = min;
  Grille[1] = a;
  Grille[2] = b;
  Grille[3] = max;
  densite[0] = 0;
  densite[1] = 1/(max/2+b/2-a/2-min/2);
  densite[2] = 1/(max/2+b/2-a/2-min/2);
  densite[3] = 0;
  CalcCumulative (4, Grille, densite, densiteCum, 1);
  dTemp = PiecewiseVariate (4, Grille, densite, densiteCum, 1,
                            &nvlle_densite);
  return (dTemp);
}
<<<sep_in_sample>>>
1 2
2 10
3 16
4 13
5 16
6 11
7 12
8 13
9 9
10 16
11 13
12 8
13 16
14 13
15 16
16 12
17 13
18 15
19 13
20 13
21 13
22 13
23 13
24 13
25 14
26 16
27 17
28 17
29 17
30 17
31 17
32 17
33 17
34 20
35 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x10,%rsp
test   %rsi,%rsi
je     332 <osip_message_set_cseq+0x42>
cmpb   $0x0,(%rsi)
mov    %rsi,0x8(%rsp)
je     332 <osip_message_set_cseq+0x42>
cmpq   $0x0,0xe0(%rdi)
mov    %rdi,%rbp
mov    $0xfffffffe,%ebx
jne    332 <osip_message_set_cseq+0x42>
lea    0xe0(%rdi),%rdi
callq  327 <osip_message_set_cseq+0x37>
test   %eax,%eax
mov    %eax,%ebx
mov    0x8(%rsp),%rsi
je     340 <osip_message_set_cseq+0x50>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0xe0(%rbp),%rdi
movl   $0x2,0x1a0(%rbp)
callq  356 <osip_message_set_cseq+0x66>
test   %eax,%eax
mov    %eax,%r12d
je     332 <osip_message_set_cseq+0x42>
mov    0xe0(%rbp),%rdi
mov    %r12d,%ebx
callq  36c <osip_message_set_cseq+0x7c>
movq   $0x0,0xe0(%rbp)
jmp    332 <osip_message_set_cseq+0x42>
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_message_set_cseq (osip_message_t * sip, const char *hvalue)
{
  int i;
  if (hvalue == ((void *)0) || hvalue[0] == '\0')
    return 0;
  if (sip->cseq != ((void *)0))
    return -2;
  i = osip_cseq_init (&(sip->cseq));
  if (i != 0)
    return i;
  sip->message_property = 2;
  i = osip_cseq_parse (sip->cseq, hvalue);
  if (i != 0) {
    osip_cseq_free (sip->cseq);
    sip->cseq = ((void *)0);
    return i;
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 2
6 4
7 4
8 4
9 4
10 4
11 6
12 6
13 7
14 6
15 8
16 8
17 9
18 8
19 9
20 9
21 19
22 19
23 19
24 19
25 19
26 19
27 19
28 12
29 11
30 12
31 13
32 12
33 13
34 14
35 16
36 14
37 15
38 16
39 16
<<<sep_out_sample>>>
push   %rbx
callq  e06 <getenv_long+0x6>
test   %rax,%rax
mov    %rax,%rbx
je     e51 <getenv_long+0x51>
callq  e13 <getenv_long+0x13>
movsbq (%rbx),%rdx
mov    (%rax),%rsi
movzbl %dl,%eax
testb  $0x8,0x1(%rsi,%rax,2)
je     e51 <getenv_long+0x51>
xor    %eax,%eax
test   %dl,%dl
jne    e3a <getenv_long+0x3a>
jmp    e4f <getenv_long+0x4f>
nopl   0x0(%rax)
movzbl %dl,%ecx
testb  $0x8,0x1(%rsi,%rcx,2)
je     e4f <getenv_long+0x4f>
lea    (%rax,%rax,4),%rax
add    $0x1,%rbx
lea    -0x30(%rdx,%rax,2),%rax
movsbq (%rbx),%rdx
test   %dl,%dl
jne    e30 <getenv_long+0x30>
pop    %rbx
retq   
mov    $0xffffffffffffffff,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
getenv_long(const char *name)
{
 const char *val;
 long newval;
 if ((val = getenv(name)) != ((void *)0) && ((*__ctype_b_loc ())[(int) (((unsigned char) *val))] & (unsigned short int) _ISdigit)) {
  for (newval = 0; *val && ((*__ctype_b_loc ())[(int) (((unsigned char) *val))] & (unsigned short int) _ISdigit); val++)
   newval = (newval * 10) + *val - '0';
  return newval;
 }
 return -1;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 6
22 7
23 6
24 6
25 6
26 11
27 11
28 10
29 11
30 11
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x50(%rdi),%rcx
mov    0x48(%rdi),%rdx
mov    %rax,%rdi
jmpq   860 <xheader_print_n>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xattr_acls_d_coder (struct tar_stat_info const *st , char const *keyword,
                    struct xheader *xhdr, void const *data)
{
  xheader_print_n (xhdr, keyword, st->acls_d_ptr, st->acls_d_len);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
lea    0x8(%rsp),%r8
mov    %rsp,%rcx
callq  1b1 <print_unidiff_number_range+0x11>
mov    0x8(%rsp),%rdx
mov    (%rsp),%rax
cmp    %rax,%rdx
jg     1e0 <print_unidiff_number_range+0x40>
mov    0x0(%rip),%rdi        # 1c6 <print_unidiff_number_range+0x26>
mov    $0x0,%eax
mov    $0x0,%esi
cmovge %rax,%rsi
xor    %eax,%eax
callq  1db <print_unidiff_number_range+0x3b>
add    $0x18,%rsp
retq   
sub    %rax,%rdx
mov    0x0(%rip),%rdi        # 1ea <print_unidiff_number_range+0x4a>
mov    $0x0,%esi
lea    0x1(%rdx),%rcx
mov    %rax,%rdx
xor    %eax,%eax
callq  1fd <print_unidiff_number_range+0x5d>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_unidiff_number_range (struct file_data const *file, lin a, lin b)
{
  long int trans_a, trans_b;
  translate_range (file, a, b, &trans_a, &trans_b);
  if (trans_b <= trans_a)
    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
  else
    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 6
14 6
15 9
16 9
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 9
26 9
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  e7c <gsl_sf_bessel_i2_scaled+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    e90 <gsl_sf_bessel_i2_scaled+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x142,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  ea6 <gsl_sf_bessel_i2_scaled+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_i2_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_i2_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_i2_scaled_e(x, &result)", "bessel_i.c", 322, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x23,%esi
callq  9ee <strip_comment+0xe>
test   %rax,%rax
mov    %rax,%rdx
je     a08 <strip_comment+0x28>
lea    0x1(%rax),%rax
movb   $0x0,(%rdx)
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    9fd <strip_comment+0x1d>
nopl   0x0(%rax)
<<<sep_in_sample>>>
strip_comment(char *line)
{
  char *comment = 0;
  if ((line = strchr(line,'#'))) {
    comment = line+1;
    *line = 0;
  }
  return comment;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 6
9 9
10 9
11 9
12 3
13 3
14 3
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    $0x2800,%esi
mov    (%rdi),%rdi
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bench_hash(void *arg)
{
  struct bench_hash_info *info = arg;
  info->update(info->ctx, 10240, info->data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
xor    %eax,%eax
test   %esi,%esi
js     970 <ap_code+0x20>
cmp    0x10(%rdi),%esi
jge    970 <ap_code+0x20>
movslq %esi,%rsi
shl    $0x4,%rsi
add    (%rdi),%rsi
mov    (%rsi),%eax
retq   
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ap_code( const struct Arg_parser * const ap, const int i )
  {
  if( i >= 0 && i < ap_arguments( ap ) ) return ap->data[i].code;
  else return 0;
  }
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
mov    (%rax),%rdx
jmpq   183 <gsl_sort_vector_long_double+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_long_double (gsl_vector_long_double * v)
{
  gsl_sort_long_double (v->data, v->stride, v->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 716 <meta1get_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1get_lineno (void)
{
    return meta1lineno;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
movslq (%rdi),%rdx
mov    0x8(%rdi),%rax
movsd  (%rax,%rdx,8),%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_histogram_max (const gsl_histogram * h)
{
  const int n = h->n;
  return h->range[n];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    $0xe,%esi
jmpq   10a70 <expand_word_list_internal>
<<<sep_in_sample>>>
expand_words_shellexp (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, (0x002|0x004|0x008)));
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     7aa <lreply+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
mov    %rsi,%rbx
mov    $0x0,%edi
mov    %ebp,%esi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
xor    %eax,%eax
callq  7e2 <lreply+0x92>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  7ef <lreply+0x9f>
mov    $0x0,%edi
callq  7f9 <lreply+0xa9>
mov    0x0(%rip),%rdi        # 800 <lreply+0xb0>
callq  805 <lreply+0xb5>
mov    0x0(%rip),%eax        # 80b <lreply+0xbb>
test   %eax,%eax
je     85b <lreply+0x10b>
mov    %ebp,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  822 <lreply+0xd2>
lea    0xf0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
mov    $0x7,%edi
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  85b <lreply+0x10b>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lreply (int n, const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  printf ("%d- ", n);
  vprintf (fmt, ap);
  __builtin_va_end(ap);
  printf ("\r\n");
  fflush (stdout);
  if (debug)
    {
      syslog (7, "<--- %d- ", n);
      __builtin_va_start(ap,fmt);
      vsyslog (7, fmt, ap);
      __builtin_va_end(ap);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 2
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 5
29 5
30 6
31 6
32 6
33 8
34 8
35 9
36 9
37 10
38 10
39 10
40 12
41 12
42 12
43 12
44 12
45 13
46 14
47 14
48 14
49 13
50 13
51 13
52 13
53 13
54 14
55 17
56 17
57 17
58 17
59 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
cmpl   $0x1,0xc(%rdi)
je     1080 <put_include_anchor+0xa0>
mov    0x8(%rdi),%ecx
mov    $0x0,%edx
mov    $0x20,%esi
mov    %rsp,%rdi
xor    %eax,%eax
callq  101a <put_include_anchor+0x3a>
mov    0x0(%rip),%rbp        # 1021 <put_include_anchor+0x41>
mov    $0x0,%edi
callq  102b <put_include_anchor+0x4b>
mov    %rsp,%rsi
mov    %rax,%rdi
xor    %ecx,%ecx
mov    %rbp,%rdx
callq  103b <put_include_anchor+0x5b>
mov    $0x0,%edi
mov    %rax,%rsi
callq  1048 <put_include_anchor+0x68>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1055 <put_include_anchor+0x75>
callq  105a <put_include_anchor+0x7a>
mov    $0x0,%edi
mov    %rax,%rsi
callq  1067 <put_include_anchor+0x87>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    10b6 <put_include_anchor+0xd6>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    0x18(%rdi),%rdi
mov    0x0(%rip),%rbp        # 108b <put_include_anchor+0xab>
callq  1090 <put_include_anchor+0xb0>
mov    %rax,%rdi
callq  1098 <put_include_anchor+0xb8>
xor    %edi,%edi
xor    %ecx,%ecx
mov    %rbp,%rdx
mov    %rax,%rsi
callq  10a7 <put_include_anchor+0xc7>
mov    $0x0,%edi
mov    %rax,%rsi
callq  10b4 <put_include_anchor+0xd4>
jmp    1048 <put_include_anchor+0x68>
callq  10bb <put_include_anchor+0xdb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_include_anchor(struct data *inc, const char *path)
{
 if (inc->count == 1)
  strbuf_puts(outbuf, gen_href_begin(((void *)0), path2fid(strbuf_value(inc->contents)), HTML, ((void *)0)));
 else {
  char id[32];
  snprintf(id, sizeof(id), "%d", inc->id);
  strbuf_puts(outbuf, gen_href_begin(upperdir("I"), id, HTML, ((void *)0)));
 }
 strbuf_puts(outbuf, path);
 strbuf_puts(outbuf, gen_href_end());
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 12
57 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  bdc <gsl_sf_bessel_zero_Jnu+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    bf0 <gsl_sf_bessel_zero_Jnu+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x4c2,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c06 <gsl_sf_bessel_zero_Jnu+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_zero_Jnu(double nu, unsigned int s)
{
  gsl_sf_result result; int status = gsl_sf_bessel_zero_Jnu_e(nu, s, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_zero_Jnu_e(nu, s, &result)", "bessel_zero.c", 1218, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0xcccccccd,%esi
nopw   0x0(%rax,%rax,1)
mov    %edi,%eax
sub    $0x1,%rcx
mul    %esi
shr    $0x3,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
test   %edx,%edx
mov    %dil,(%rcx)
mov    %edx,%edi
jne    90 <ui_to_a+0x10>
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
ui_to_a(unsigned int i)
{
  static char buf[20 + 1];
  char *p = buf + 20;
  do {
    *--p = '0' + (i % 10);
    i /= 10;
  } while (i != 0);
  return p;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 8
13 6
14 7
15 8
16 10
17 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x30(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
term_ostream_rgb_to_color (term_ostream_t first_arg, int red, int green, int blue)
{
  const struct term_ostream_implementation *vtable =
    ((struct term_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  return vtable->rgb_to_color (first_arg,red,green,blue);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x18(%rdi),%rdi
callq  1d <transcript_destroy+0xd>
mov    0x20(%rbx),%rdi
callq  26 <transcript_destroy+0x16>
lea    0x8(%rbx),%rdi
callq  2f <transcript_destroy+0x1f>
lea    0x10(%rbx),%rdi
callq  38 <transcript_destroy+0x28>
mov    %rbx,%rdi
callq  40 <transcript_destroy+0x30>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
transcript_destroy(void *data)
{
    struct transcript_stream *p = data;
    free(p->prefix[0]);
    free(p->prefix[1]);
    dico_stream_destroy(&p->transport);
    dico_stream_destroy(&p->logstr);
    free(p);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 10
14 10
15 10
16 10
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  191 <gsl_histogram2d_mul+0x11>
test   %eax,%eax
je     1d8 <gsl_histogram2d_mul+0x58>
mov    0x8(%rbx),%rcx
imul   (%rbx),%rcx
test   %rcx,%rcx
je     1c8 <gsl_histogram2d_mul+0x48>
mov    0x20(%rbx),%rdx
mov    0x20(%rbp),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movsd  (%rdx,%rax,8),%xmm0
mulsd  (%rsi,%rax,8),%xmm0
movsd  %xmm0,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    1b0 <gsl_histogram2d_mul+0x30>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x85,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1f1 <gsl_histogram2d_mul+0x71>
add    $0x8,%rsp
mov    $0x4,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_histogram2d_mul (gsl_histogram2d * h1, const gsl_histogram2d * h2)
{
  size_t i;
  if (!gsl_histogram2d_equal_bins_p (h1, h2))
    {
      do { gsl_error ("histograms have different binning", "oper2d.c", 133, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < (h1->nx) * (h1->ny); i++)
    {
      h1->bin[i] *= h2->bin[i];
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 10
20 8
21 8
22 8
23 13
24 12
25 13
26 13
27 13
28 13
29 6
30 6
31 6
32 6
33 6
34 13
35 6
36 13
37 13
38 13
39 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsi,%rax
mov    0x10(%rsi),%r10
mov    0x8(%rsi),%r8
mov    0x18(%rsi),%rsi
mov    $0xffffffff,%r9d
mov    %rdx,(%rsp)
mov    (%rax),%rcx
mov    %r10,%rdx
callq  928 <gsl_wavelet2d_nstransform_matrix_inverse+0x28>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_wavelet2d_nstransform_matrix_inverse (const gsl_wavelet * w,
                                        gsl_matrix * a,
                                        gsl_wavelet_workspace * work)
{
  return gsl_wavelet2d_nstransform (w, a->data,
                                    a->tda, a->size1, a->size2,
                                    gsl_wavelet_backward, work);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 8
12 8
<<<sep_out_sample>>>
jmp    118c <taru_datoul+0xc>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rdi
movsbq (%rdi),%rcx
cmp    $0x20,%cl
je     1188 <taru_datoul+0x8>
lea    -0x30(%rcx),%eax
cmp    $0x9,%al
ja     1221 <taru_datoul+0xa1>
xor    %r8d,%r8d
jmp    11b0 <taru_datoul+0x30>
nopl   (%rax)
cmp    %r8,%r9
jb     11c8 <taru_datoul+0x48>
mov    %r9,%r8
lea    (%r8,%r8,4),%rax
add    $0x1,%rdi
lea    -0x30(%rcx,%rax,2),%r9
movsbq (%rdi),%rcx
lea    -0x30(%rcx),%eax
cmp    $0x9,%al
jbe    11a8 <taru_datoul+0x28>
test   %r8,%r8
je     11db <taru_datoul+0x5b>
xor    %edx,%edx
mov    %r9,%rax
div    %r8
cmp    $0x9,%rax
jbe    11f8 <taru_datoul+0x78>
cmp    $0x20,%cl
jne    11e9 <taru_datoul+0x69>
add    $0x1,%rdi
cmpb   $0x20,(%rdi)
je     11e0 <taru_datoul+0x60>
mov    %r9,(%rsi)
xor    %eax,%eax
cmpb   $0x0,(%rdi)
setne  %al
retq   
nopl   (%rax)
sub    $0x8,%rsp
callq  1201 <taru_datoul+0x81>
mov    0x0(%rip),%rdi        # 1208 <taru_datoul+0x88>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  1217 <taru_datoul+0x97>
mov    $0x2,%eax
add    $0x8,%rsp
retq   
xor    %r9d,%r9d
jmp    11e9 <taru_datoul+0x69>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_datoul (char * s, unsigned long *n)
{
  unsigned long oldval = 0;
  unsigned long val = 0;
  while (*s == ' ')
    ++s;
  while (*s >= '0' && *s <= '9' && val >= oldval) {
          oldval = val;
          val = 10 * val + *s++ - '0';
  }
  if (oldval && ((val / oldval) < 10)) {
 fprintf(stderr, "%s, taru_datoul : conversion overflow\n", swlib_utilname_get());
 return 2;
  }
  while (*s == ' ') ++s;
  *n = val;
  return (!(*s == '\0'));
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 9
19 7
20 7
21 7
22 7
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 15
31 15
32 15
33 15
34 15
35 16
36 17
37 17
38 17
39 17
40 17
41 2
42 12
43 12
44 12
45 12
46 12
47 12
48 13
49 18
50 18
51 7
52 7
53 7
<<<sep_out_sample>>>
callq  aa5 <IsModelVar+0x5>
and    $0xfffdffff,%eax
cmp    $0x10000,%eax
sete   %al
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
IsModelVar (HVAR hvar)
{
  int iType = GetVarType(hvar);
  return (iType == 0x10000 || iType == 0x30000);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 5
7 5
<<<sep_out_sample>>>
mov    %rsi,%rdi
jmpq   11e8 <rec_record_field_mark+0x8>
<<<sep_in_sample>>>
rec_record_field_mark (rec_record_t record,
                       rec_field_t field)
{
  return rec_field_mark (field);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,(%rdi)
mov    %rdi,%rbx
je     2a5 <white_string+0x35>
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  288 <white_string+0x18>
test   %al,%al
jne    293 <white_string+0x23>
movzbl (%rbx),%eax
cmp    $0xd,%al
jne    2a7 <white_string+0x37>
xor    %esi,%esi
mov    %rbx,%rdi
callq  29d <white_string+0x2d>
add    %rax,%rbx
cmpb   $0x0,(%rbx)
jne    280 <white_string+0x10>
xor    %eax,%eax
test   %al,%al
sete   %al
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
white_string(const char *s)
{
    while (*s != '\0' && (is_blank_mbchar(s) || *s == '\r'))
 s += move_mbright(s, 0);
    return !*s;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
16 4
17 3
18 3
19 3
20 5
21 5
22 6
23 6
24 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     68 <mu_pop3_disconnect+0x68>
movl   $0x0,0x60(%rdi)
movl   $0x0,0x40(%rdi)
xor    %esi,%esi
mov    (%rdi),%rdi
mov    0x18(%rbx),%rdx
callq  25 <mu_pop3_disconnect+0x25>
mov    (%rbx),%rax
mov    0x20(%rbx),%rdi
xor    %esi,%esi
mov    0x38(%rbx),%rdx
mov    %rax,0x8(%rbx)
callq  3b <mu_pop3_disconnect+0x3b>
mov    0x48(%rbx),%rdi
mov    0x20(%rbx),%rax
test   %rdi,%rdi
mov    %rax,0x28(%rbx)
je     59 <mu_pop3_disconnect+0x59>
callq  51 <mu_pop3_disconnect+0x51>
movq   $0x0,0x48(%rbx)
mov    0x68(%rbx),%rdi
pop    %rbx
jmpq   63 <mu_pop3_disconnect+0x63>
nopl   0x0(%rax,%rax,1)
mov    $0x16,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_pop3_disconnect (mu_pop3_t pop3)
{
  if (pop3 == ((void *)0))
    return 22;
  pop3->state = MU_POP3_NO_STATE;
  pop3->acknowledge = 0;
  memset (pop3->io.buf, '\0', pop3->io.len);
  pop3->io.ptr = pop3->io.buf;
  memset (pop3->ack.buf, '\0', pop3->ack.len);
  pop3->ack.ptr = pop3->ack.buf;
  if (pop3->timestamp)
    {
      free (pop3->timestamp);
      pop3->timestamp = ((void *)0);
    }
  return mu_stream_close (pop3->carrier);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 6
7 7
8 7
9 7
10 7
11 8
12 9
13 9
14 9
15 8
16 9
17 11
18 10
19 11
20 10
21 11
22 13
23 14
24 16
25 17
26 16
27 16
28 17
29 17
30 17
<<<sep_out_sample>>>
push   %r14
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    185f <gsl_matrix_ushort_equal+0x1f>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     1888 <gsl_matrix_ushort_equal+0x48>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1878 <gsl_matrix_ushort_equal+0x38>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r14
retq   
nopl   (%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     18e4 <gsl_matrix_ushort_equal+0xa4>
lea    (%r8,%r8,1),%r12
lea    (%rax,%rax,1),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     18d5 <gsl_matrix_ushort_equal+0x95>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movzwl (%r8,%rax,2),%r14d
cmp    %r14w,(%r9,%rax,2)
jne    18eb <gsl_matrix_ushort_equal+0xab>
add    $0x1,%rax
cmp    %rdx,%rax
jne    18c0 <gsl_matrix_ushort_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    18a5 <gsl_matrix_ushort_equal+0x65>
mov    $0x1,%eax
jmp    187a <gsl_matrix_ushort_equal+0x3a>
xor    %eax,%eax
jmp    187a <gsl_matrix_ushort_equal+0x3a>
nop
<<<sep_in_sample>>>
gsl_matrix_ushort_equal (const gsl_matrix_ushort * a, const gsl_matrix_ushort * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 7
18 7
19 30
20 30
21 30
22 30
23 30
24 30
25 30
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 20
44 20
45 20
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 29
55 29
56 23
57 23
58 23
<<<sep_out_sample>>>
push   %rbx
mov    0x1b0(%rdi),%rax
mov    %rdi,%rbx
movl   $0x0,0x18(%rax)
mov    0x1d0(%rdi),%rax
callq  *0x8(%rax)
mov    0x1d0(%rbx),%rax
mov    %rbx,%rdi
pop    %rbx
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
pass_startup (j_compress_ptr cinfo)
{
  cinfo->master->call_pass_startup = 0;
  (*cinfo->marker->write_frame_header) (cinfo);
  (*cinfo->marker->write_scan_header) (cinfo);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 5
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
mov    $0xe58,%edx
mov    %edi,%ebp
mov    $0x0,%esi
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  18c <vlist_alloc+0x1c>
lea    0x1(%rbp),%edi
mov    %rax,%rbx
mov    $0xe59,%edx
mov    $0x0,%esi
movslq %edi,%rdi
shl    $0x3,%rdi
callq  1a8 <vlist_alloc+0x38>
mov    %ebp,0x8(%rbx)
mov    %rax,(%rbx)
movl   $0x0,0xc(%rbx)
movq   $0x0,(%rax)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vlist_alloc (nentries)
     int nentries;
{
  VARLIST *vlist;
  vlist = (VARLIST *)sh_xmalloc((sizeof (VARLIST)), "variables.c", 3672);
  vlist->list = (SHELL_VAR **)sh_xmalloc(((nentries + 1) * sizeof (SHELL_VAR *)), "variables.c", 3673);
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)((void *)0);
  return vlist;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 3
7 3
8 5
9 6
10 5
11 6
12 6
13 6
14 6
15 6
16 7
17 6
18 8
19 9
20 11
21 11
22 11
23 11
24 11
25 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x40(%rdi),%eax
cmp    $0x5,%eax
je     378 <print_symbol+0xa8>
jbe    330 <print_symbol+0x60>
cmp    $0x6,%eax
je     310 <print_symbol+0x40>
cmp    $0x8,%eax
jne    370 <print_symbol+0xa0>
mov    0x0(%rip),%rcx        # 2f7 <print_symbol+0x27>
mov    $0xb,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x18,%rsp
jmpq   30f <print_symbol+0x3f>
nop
mov    0x0(%rip),%rcx        # 317 <print_symbol+0x47>
mov    $0x11,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x18,%rsp
jmpq   32f <print_symbol+0x5f>
nop
cmp    $0x4,%eax
jne    370 <print_symbol+0xa0>
test   %sil,%sil
jne    34f <print_symbol+0x7f>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     34f <print_symbol+0x7f>
mov    %rdi,0x8(%rsp)
callq  *%rax
mov    0x8(%rsp),%rdi
mov    0x0(%rip),%rdx        # 356 <print_symbol+0x86>
mov    (%rdi),%rdi
mov    $0x0,%esi
add    $0x18,%rsp
jmpq   367 <print_symbol+0x97>
nopw   0x0(%rax,%rax,1)
add    $0x18,%rsp
retq   
nopl   (%rax)
mov    (%rdi),%rax
xor    %esi,%esi
callq  *0x10(%rax)
mov    (%rax),%rax
mov    0x0(%rip),%rdi        # 38a <print_symbol+0xba>
mov    $0x0,%esi
mov    0x38(%rax),%rdx
xor    %eax,%eax
add    $0x18,%rsp
jmpq   39e <print_symbol+0xce>
xchg   %ax,%ax
<<<sep_in_sample>>>
print_symbol(NODE *r, _Bool isparam)
{
 switch (r->type) {
 case Node_var_new:
  fprintf(out_fp, "untyped variable\n");
  break;
 case Node_var:
  if (! isparam && r->sub.nodep.r.uptr)
   r->sub.nodep.r.uptr();
  valinfo(r->sub.nodep.l.lptr, fprintf, out_fp);
  break;
 case Node_var_array:
  fprintf(out_fp, "array, %ld elements\n", ((*((r)->sub.nodep.l.lp[2](r, ((void *)0))))->sub.nodep.reflags));
  break;
 case Node_func:
  fprintf(out_fp, "`function'\n");
  break;
 default:
  break;
 }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 16
11 16
12 16
13 16
14 21
15 16
16 16
17 5
18 5
19 5
20 5
21 21
22 5
23 5
24 3
25 3
26 8
27 8
28 8
29 8
30 8
31 8
32 9
33 9
34 10
35 10
36 10
37 21
38 10
39 10
40 21
41 21
42 21
43 13
44 13
45 13
46 13
47 13
48 13
49 13
50 13
51 21
52 13
53 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %edx,%edx
js     618 <CDB___db_joingetchk+0x58>
test   %edx,%edx
je     5d1 <CDB___db_joingetchk+0x11>
cmp    $0xe,%edx
jne    600 <CDB___db_joingetchk+0x40>
xor    %eax,%eax
testb  $0x4,0x18(%rsi)
jne    5e0 <CDB___db_joingetchk+0x20>
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    0x28(%rdi),%rdi
mov    $0x0,%esi
callq  5ee <CDB___db_joingetchk+0x2e>
mov    $0x16,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
add    $0x8,%rsp
jmpq   614 <CDB___db_joingetchk+0x54>
nopl   0x0(%rax)
mov    0x28(%rdi),%rax
and    $0x7fffffff,%edx
cmpq   $0x0,0x100(%rax)
jne    5c8 <CDB___db_joingetchk+0x8>
mov    %rax,%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  63b <CDB___db_joingetchk+0x7b>
mov    $0x16,%eax
jmp    5d9 <CDB___db_joingetchk+0x19>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_joingetchk(dbp, key, flags)
 const DB *dbp;
 DBT *key;
 u_int32_t flags;
{
 if ((flags & (0x80000000))) {
  if (!((dbp->dbenv)->lk_handle != ((void *)0))) {
   CDB___db_err(dbp->dbenv,
       "the DB_RMW flag requires locking");
   return (22);
  }
  (flags &= ~(0x80000000));
 }
 switch (flags) {
 case 0:
 case 14:
  break;
 default:
  return (CDB___db_ferr(dbp->dbenv, "DBcursor->c_get", 0));
 }
 if (((key)->flags & (0x004))) {
  CDB___db_err(dbp->dbenv,
      "DB_DBT_PARTIAL may not be set on key during join_get");
  return (22);
 }
 return (0);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 14
5 14
6 14
7 14
8 26
9 21
10 21
11 27
12 27
13 27
14 22
15 22
16 22
17 24
18 27
19 27
20 27
21 19
22 19
23 19
24 27
25 19
26 19
27 7
28 12
29 7
30 7
31 8
32 8
33 8
34 8
35 10
36 10
37 10
<<<sep_out_sample>>>
mov    0x23c(%rdi),%eax
test   $0x10,%ah
je     2c8 <__db_get_byteswapped+0x18>
shr    $0x8,%eax
and    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   2d8 <__db_get_byteswapped+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__db_get_byteswapped(dbp)
 DB *dbp;
{
 if (!(((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "get_byteswapped", 0));;
 return (((dbp)->flags & (0x00100)) ? 1 : 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 6
8 4
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0x10,0x23d(%rdi)
jne    2c0 <__bam_set_bt_minkey+0x40>
mov    %esi,%ebp
mov    $0x1,%esi
callq  29e <__bam_set_bt_minkey+0x1e>
test   %eax,%eax
jne    2b1 <__bam_set_bt_minkey+0x31>
cmp    $0x1,%ebp
mov    0xc0(%rbx),%rdx
jbe    2e0 <__bam_set_bt_minkey+0x60>
mov    %ebp,0x10(%rdx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x28(%rdi),%rdi
add    $0x8,%rsp
mov    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
jmpq   2d9 <__bam_set_bt_minkey+0x59>
nopl   0x0(%rax)
mov    0x28(%rbx),%rdi
mov    $0x0,%esi
callq  2ee <__bam_set_bt_minkey+0x6e>
mov    $0x16,%eax
jmp    2b1 <__bam_set_bt_minkey+0x31>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__bam_set_bt_minkey(dbp, bt_minkey)
 DB *dbp;
 u_int32_t bt_minkey;
{
 BTREE *t;
 if ((((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "set_bt_minkey", 1));;
 { int __ret; if ((__ret = CDB___dbh_am_chk(dbp, 0x01)) != 0) return (__ret); };
 t = dbp->bt_internal;
 if (bt_minkey < 2) {
  CDB___db_err(dbp->dbenv, "minimum bt_minkey value is 2");
  return (22);
 }
 t->bt_minkey = bt_minkey;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 6
8 7
9 7
10 7
11 7
12 9
13 8
14 9
15 13
16 15
17 15
18 15
19 15
20 15
21 6
22 15
23 6
24 15
25 15
26 6
27 6
28 6
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   241a <swi_fl_qsort_reverse+0xa>
<<<sep_in_sample>>>
swi_fl_qsort_reverse(SWI_FILELIST * fl) {
 STRAR * ar = (STRAR*)fl;
 strar_qsort(ar, swi_fl_compare_reverse);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     88a <checked_fprintf+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    0x8(%rbx),%rdi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  8bf <checked_fprintf+0x8f>
test   %eax,%eax
js     8d0 <checked_fprintf+0xa0>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
callq  8d5 <checked_fprintf+0xa5>
mov    0x10(%rbx),%rsi
mov    (%rax),%edi
callq  8e0 <checked_fprintf+0xb0>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
checked_fprintf (struct format_val *dest, const char *fmt, ...)
{
  int rv;
  va_list ap;
  __builtin_va_start(ap,fmt);
  rv = vfprintf (dest->stream, fmt, ap);
  if (rv < 0)
    nonfatal_nontarget_file_error ((*__errno_location ()), dest->filename);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 5
19 6
20 6
21 5
22 5
23 5
24 5
25 5
26 6
27 7
28 7
29 9
30 9
31 9
32 9
33 8
34 8
35 8
36 8
37 9
38 9
39 9
40 9
<<<sep_out_sample>>>
test   %rdx,%rdx
je     4c6 <gsl_stats_ulong_absdev_m+0x96>
shl    $0x3,%rsi
xor    %eax,%eax
xorpd  %xmm2,%xmm2
movsd  0x0(%rip),%xmm3        # 44b <gsl_stats_ulong_absdev_m+0x1b>
jmp    46d <gsl_stats_ulong_absdev_m+0x3d>
nopl   (%rax)
cvtsi2sd %rcx,%xmm1
subsd  %xmm0,%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
je     490 <gsl_stats_ulong_absdev_m+0x60>
mov    (%rdi),%rcx
test   %rcx,%rcx
jns    450 <gsl_stats_ulong_absdev_m+0x20>
mov    %rcx,%r8
and    $0x1,%ecx
shr    %r8
or     %rcx,%r8
cvtsi2sd %r8,%xmm1
addsd  %xmm1,%xmm1
jmp    455 <gsl_stats_ulong_absdev_m+0x25>
nopl   0x0(%rax)
test   %rax,%rax
js     4a8 <gsl_stats_ulong_absdev_m+0x78>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    495 <gsl_stats_ulong_absdev_m+0x65>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_ulong_absdev_m (const unsigned long data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 6
6 6
7 6
8 6
9 10
10 10
11 8
12 8
13 8
14 10
15 11
16 8
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 13
29 13
30 13
31 13
32 13
33 15
34 15
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 15
44 6
45 6
46 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x98,%esi
mov    %edi,%ebx
mov    $0x1,%edi
callq  12 <_asn1_add_single_node+0x12>
test   %rax,%rax
je     1a <_asn1_add_single_node+0x1a>
mov    %ebx,0x48(%rax)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_asn1_add_single_node (unsigned int type)
{
  asn1_node punt;
  punt = calloc (1, sizeof (struct asn1_node_st));
  if (punt == ((void *)0))
    return ((void *)0);
  punt->type = type;
  return punt;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 5
7 5
8 7
9 9
10 9
11 9
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x18,%rsp
mov    %r8,0x8(%rsp)
callq  104 <xlat_kw+0x24>
test   %rbp,%rbp
mov    %rax,%r12
je     174 <xlat_kw+0x94>
mov    %rbp,%rdi
callq  114 <xlat_kw+0x34>
cmp    %rax,%r12
mov    %rax,%r14
jbe    174 <xlat_kw+0x94>
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  12a <xlat_kw+0x4a>
test   %eax,%eax
jne    174 <xlat_kw+0x94>
mov    (%rbx),%rdi
add    %r14,%r13
sub    %r14,%r12
test   %rdi,%rdi
je     17c <xlat_kw+0x9c>
nopl   0x0(%rax)
mov    0x8(%rbx),%rbp
cmp    %r12,%rbp
ja     170 <xlat_kw+0x90>
mov    %rbp,%rdx
mov    %r13,%rsi
callq  154 <xlat_kw+0x74>
test   %eax,%eax
mov    %eax,%r14d
jne    170 <xlat_kw+0x90>
add    %r13,%rbp
movsbl 0x0(%rbp),%edi
test   %dil,%dil
je     198 <xlat_kw+0xb8>
callq  16c <xlat_kw+0x8c>
test   %al,%al
je     198 <xlat_kw+0xb8>
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    140 <xlat_kw+0x60>
mov    $0x1,%r14d
add    $0x18,%rsp
mov    %r14d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    0x10(%rbx),%eax
mov    %eax,(%r15)
mov    0x8(%rsp),%rax
mov    %rbp,(%rax)
jmp    182 <xlat_kw+0xa2>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xlat_kw (const char *s, const char *pfx,
  struct rmt_kw const *kw, int *valp, const char **endp)
{
  size_t slen = strlen (s);
  if (pfx)
    {
      size_t pfxlen = strlen (pfx);
      if (slen > pfxlen && memcmp (s, pfx, pfxlen) == 0)
 {
   s += pfxlen;
   slen -= pfxlen;
 }
    }
  for (; kw->name; kw++)
    {
      if (slen >= kw->len
   && memcmp (kw->name, s, kw->len) == 0
   && !(s[kw->len] && c_isalnum (s[kw->len])))
 {
   *valp = kw->value;
   *endp = s + kw->len;
   return 0;
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 5
15 4
16 5
17 7
18 7
19 8
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 14
29 10
30 11
31 14
32 14
33 14
34 16
35 16
36 16
37 17
38 17
39 17
40 17
41 17
42 17
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 14
51 14
52 14
53 14
54 25
55 26
56 26
57 26
58 26
59 26
60 26
61 26
62 26
63 26
64 26
65 20
66 20
67 21
68 21
69 22
70 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4f9 <CalculateVarHandle+0x9>
test   %rax,%rax
je     540 <CalculateVarHandle+0x50>
mov    0x18(%rax),%rdx
test   %rdx,%rdx
je     54b <CalculateVarHandle+0x5b>
mov    0x10(%rdx),%rsi
mov    0x10(%rax),%rax
cmp    %rax,%rsi
jne    547 <CalculateVarHandle+0x57>
xor    %ecx,%ecx
jmp    526 <CalculateVarHandle+0x36>
nopl   0x0(%rax,%rax,1)
cmp    %rsi,0x10(%rdx)
jne    532 <CalculateVarHandle+0x42>
mov    0x18(%rdx),%rdx
add    $0x1,%ecx
test   %rdx,%rdx
jne    520 <CalculateVarHandle+0x30>
movslq %ecx,%rcx
or     %rcx,%rax
add    $0x8,%rsp
retq   
nopl   (%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
xor    %ecx,%ecx
jmp    535 <CalculateVarHandle+0x45>
xor    %ecx,%ecx
mov    0x10(%rax),%rax
jmp    532 <CalculateVarHandle+0x42>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CalculateVarHandle (PVMMAPSTRCT pvm, PSTR sz)
{
  PVMMAPSTRCT pvmVar;
  int cSameType = 0;
  pvm = pvmVar = GetVarPTR (pvm, sz);
  if (pvm)
    pvm = pvm->pvmNextVar;
  while (pvm && pvm->hType == pvmVar->hType) {
    cSameType++;
    pvm = pvm->pvmNextVar;
  }
  return ((HANDLE) (pvmVar ? pvmVar->hType | (HANDLE) cSameType : 0));
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 6
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 9
19 8
20 8
21 8
22 12
23 13
24 13
25 13
26 12
27 13
28 13
29 8
30 8
31 8
32 8
33 8
34 8
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     a2c <itrace+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
callq  a34 <itrace+0x64>
mov    $0x0,%esi
movslq %eax,%rdx
xor    %eax,%eax
mov    0x0(%rip),%rdi        # a45 <itrace+0x75>
callq  a4a <itrace+0x7a>
lea    0xe0(%rsp),%rax
mov    0x0(%rip),%rdi        # a59 <itrace+0x89>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  a85 <itrace+0xb5>
mov    0x0(%rip),%rsi        # a8c <itrace+0xbc>
mov    $0xa,%edi
callq  a96 <itrace+0xc6>
mov    0x0(%rip),%rdi        # a9d <itrace+0xcd>
callq  aa2 <itrace+0xd2>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
itrace (const char *format, ...)
{
  va_list args;
  fprintf(stderr, "TRACE: pid %ld: ", (long)getpid());
  __builtin_va_start(args,format);
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  __builtin_va_end(args);
  fflush(stderr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 4
25 5
26 6
27 6
28 6
29 5
30 5
31 5
32 5
33 5
34 6
35 7
36 7
37 7
38 9
39 9
40 10
41 10
42 10
43 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %edi,%ebx
mov    $0x0,%edi
callq  12 <punycode_strerror+0x12>
cmp    $0x1,%ebx
je     70 <punycode_strerror+0x70>
jb     60 <punycode_strerror+0x60>
cmp    $0x2,%ebx
nopl   0x0(%rax)
je     40 <punycode_strerror+0x40>
cmp    $0x3,%ebx
jne    50 <punycode_strerror+0x50>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   37 <punycode_strerror+0x37>
nopw   0x0(%rax,%rax,1)
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   50 <punycode_strerror+0x50>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   60 <punycode_strerror+0x60>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   70 <punycode_strerror+0x70>
pop    %rbx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   80 <punycode_strerror+0x80>
<<<sep_in_sample>>>
punycode_strerror (Punycode_status rc)
{
  const char *p;
  bindtextdomain ("libidn", "/usr/local/share/locale");
  switch (rc)
    {
    case PUNYCODE_SUCCESS:
      p = dgettext ("libidn", "Success");
      break;
    case PUNYCODE_BAD_INPUT:
      p = dgettext ("libidn", "Invalid input");
      break;
    case PUNYCODE_BIG_OUTPUT:
      p = dgettext ("libidn", "Output would exceed the buffer space provided");
      break;
    case PUNYCODE_OVERFLOW:
      p = dgettext ("libidn", "String size limit exceeded");
      break;
    default:
      p = dgettext ("libidn", "Unknown error");
      break;
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 24
15 17
16 17
17 17
18 17
19 24
20 14
21 14
22 14
23 24
24 20
25 20
26 20
27 24
28 8
29 8
30 8
31 24
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  181 <_s_get_transport2+0x11>
mov    (%rax),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
mov    %rbp,%rdx
pop    %rbp
jmpq   195 <_s_get_transport2+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_s_get_transport2 (mu_stream_t stream,
     mu_transport_t *pin, mu_transport_t *pout)
{
  struct _socket_stream *s = mu_stream_get_owner (stream);
  return mu_stream_get_transport2 (s->fstream, pin, pout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 6
9 5
10 6
11 5
12 6
13 5
14 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_container (rec_record_t record)
{
  return record->container;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # de8 <dump_fcall_stack+0x8>
jne    dec <dump_fcall_stack+0xc>
repz retq 
push   %r15
push   %r14
push   %r13
mov    %rdi,%r13
mov    $0x0,%edi
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  e07 <dump_fcall_stack+0x27>
mov    %r13,%rdi
mov    %rax,%rsi
xor    %eax,%eax
callq  e14 <dump_fcall_stack+0x34>
mov    0x0(%rip),%rax        # e1b <dump_fcall_stack+0x3b>
xor    %edx,%edx
mov    0x10(%rax),%rbx
jmp    e2b <dump_fcall_stack+0x4b>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdx
mov    0x18(%rbx),%rcx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
lea    0x1(%rdx),%rbp
callq  e42 <dump_fcall_stack+0x62>
mov    0x0(%rip),%rax        # e49 <dump_fcall_stack+0x69>
cmp    0x30(%rax),%rbp
jbe    e28 <dump_fcall_stack+0x48>
cmpq   $0x1,0x0(%rip)        # e57 <dump_fcall_stack+0x77>
jle    eb1 <dump_fcall_stack+0xd1>
mov    $0x1,%r14d
nop
mov    0x0(%rip),%rax        # e67 <dump_fcall_stack+0x87>
mov    %rbp,%rdx
mov    (%rax,%r14,8),%r12
mov    0x10(%r12),%r15
jmp    e7b <dump_fcall_stack+0x9b>
nopl   (%rax)
mov    %rbx,%rdx
mov    0x18(%r15),%rcx
lea    0x1(%rdx),%rbx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  e92 <dump_fcall_stack+0xb2>
mov    %rbx,%rax
sub    %rbp,%rax
cmp    %rax,0x30(%r12)
jae    e78 <dump_fcall_stack+0x98>
add    $0x1,%r14
cmp    %r14,0x0(%rip)        # eaa <dump_fcall_stack+0xca>
jle    eb4 <dump_fcall_stack+0xd4>
mov    %rbx,%rbp
jmp    e60 <dump_fcall_stack+0x80>
mov    %rbp,%rbx
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %r13,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
mov    $0x0,%esi
xor    %eax,%eax
jmpq   ed4 <dump_fcall_stack+0xf4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dump_fcall_stack(FILE *fp)
{
 NODE *f, *func;
 long i = 0, j, k = 0;
 if (fcall_count == 0)
  return;
 fprintf(fp, gettext("\n\t# Function Call Stack:\n\n"));
 func = frame_ptr->sub.nodep.x.extra;
 for (j = 0; j <= frame_ptr->sub.nodep.cnt; j++)
  fprintf(fp, "\t# %3ld. %s\n", k++, func->sub.nodep.name);
 for (i = 1; i < fcall_count; i++) {
  f = fcall_list[i];
  func = f->sub.nodep.x.extra;
  for (j = 0; j <= f->sub.nodep.cnt; j++)
   fprintf(fp, "\t# %3ld. %s\n", k++, func->sub.nodep.name);
 }
 fprintf(fp, "\t# %3ld. -- main --\n", k);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 2
5 2
6 2
7 2
8 7
9 2
10 2
11 2
12 2
13 7
14 7
15 7
16 7
17 7
18 8
19 4
20 8
21 8
22 8
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 9
31 9
32 9
33 11
34 11
35 11
36 11
37 12
38 13
39 12
40 13
41 13
42 13
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 15
52 14
53 14
54 11
55 11
56 11
57 15
58 15
59 10
60 18
61 17
62 17
63 18
64 18
65 18
66 18
67 18
68 18
69 17
70 17
71 17
72 17
<<<sep_out_sample>>>
test   %rdi,%rdi
je     850 <mu_mailbox_scan+0x20>
mov    0xc0(%rdi),%rcx
test   %rcx,%rcx
je     850 <mu_mailbox_scan+0x20>
testb  $0x8,0x31(%rdi)
mov    $0x1033,%eax
je     860 <mu_mailbox_scan+0x30>
repz retq 
xchg   %ax,%ax
mov    $0x1003,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
jmpq   *%rcx
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_scan (mu_mailbox_t mbox, size_t msgno, size_t *pcount)
{
  if (mbox == ((void *)0) || mbox->_scan == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_scan (mbox, msgno, pcount);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 5
9 8
10 8
11 4
12 8
13 8
14 7
15 7
<<<sep_out_sample>>>
mov    0xc(%rdi),%ecx
test   %ecx,%ecx
je     140 <xstack_preview+0x40>
xor    %eax,%eax
cmp    %edx,%ecx
mov    %edx,%r8d
jl     135 <xstack_preview+0x35>
sub    $0x8,%rsp
mov    0x8(%rdi),%eax
sub    %r8d,%ecx
mov    %rsi,%r9
imul   %eax,%ecx
movslq %eax,%rdx
movslq %ecx,%rsi
add    (%rdi),%rsi
mov    %r9,%rdi
callq  131 <xstack_preview+0x31>
add    $0x8,%rsp
repz retq 
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xstack_preview(stack, data, offset)
    xstack_t *stack;
    void *data;
    int offset;
{
    if (stack->point == 0 || offset > stack->point)
 return ((void *)0);
    memcpy(data,
    ((char *)stack->data) + (stack->point - offset) * stack->esize,
    stack->esize);
    return data;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 6
6 6
7 6
8 5
9 10
10 9
11 9
12 9
13 8
14 8
15 9
16 8
17 8
18 12
19 12
20 12
21 7
22 7
23 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x50(%rdi),%rbx
cmpq   $0x0,0x68(%rbx)
je     b0 <amd_message_unseen+0x40>
mov    0x78(%rbx),%rax
mov    (%rax),%rax
mov    0x1c(%rax),%eax
test   %eax,%eax
je     a0 <amd_message_unseen+0x30>
test   $0x20,%al
je     a0 <amd_message_unseen+0x30>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
movq   $0x1,0x0(%rbp)
jmp    96 <amd_message_unseen+0x26>
nopw   0x0(%rax,%rax,1)
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x1,%esi
callq  *0x38(%rbx)
test   %eax,%eax
jne    98 <amd_message_unseen+0x28>
cmpq   $0x0,0x68(%rbx)
jne    84 <amd_message_unseen+0x14>
jmp    96 <amd_message_unseen+0x26>
nopl   0x0(%rax)
<<<sep_in_sample>>>
amd_message_unseen (mu_mailbox_t mailbox, size_t *pmsgno)
{
  struct _amd_data *amd = mailbox->data;
  size_t i;
  if (amd->msg_count == 0)
    {
      int status = amd->scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  for (i = 0; i < amd->msg_count; i++)
    {
      if (((amd->msg_array[0]->attr_flags) == 0 || ! ((amd->msg_array[0]->attr_flags) & 0x20)))
 {
   *pmsgno = i + 1;
   break;
 }
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 13
9 13
10 13
11 13
12 13
13 13
14 13
15 19
16 20
17 20
18 20
19 20
20 20
21 15
22 15
23 15
24 7
25 7
26 7
27 7
28 8
29 8
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1e8 <gsl_interp_free+0x28>
mov    (%rdi),%rax
mov    0x40(%rax),%rax
test   %rax,%rax
je     1db <gsl_interp_free+0x1b>
mov    0x20(%rdi),%rdi
callq  *%rax
mov    %rbx,%rdi
pop    %rbx
jmpq   1e4 <gsl_interp_free+0x24>
nopl   0x0(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_free (gsl_interp * interp)
{
  if (!interp) { return ; };
  if (interp->type->free)
    interp->type->free (interp->state);
  free (interp);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 4
9 5
10 5
11 6
12 7
13 6
14 6
15 7
16 7
17 7
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 1366 <getKey+0x6>
xor    %eax,%eax
test   %edx,%edx
jne    1378 <getKey+0x18>
jmpq   1371 <getKey+0x11>
nopl   0x0(%rax)
jmpq   137d <getKey+0x1d>
<<<sep_in_sample>>>
getKey()
{
  if(X_IS_RUNNING) return getKeyUnderX();
  else return getKeyUnderConsole();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 3
<<<sep_out_sample>>>
jmpq   b25 <encodings_map_free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
encodings_map_free (struct pair_htable * table)
{
  pair_table_free (table);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %edi,%edi
push   %rbx
mov    %edi,%ebx
js     c5d <disable_socket+0x4d>
cmpl   $0x1,0x0(%rip)        # c1e <disable_socket+0xe>
jbe    c40 <disable_socket+0x30>
mov    0x0(%rip),%eax        # c26 <disable_socket+0x16>
test   %eax,%eax
jne    c60 <disable_socket+0x50>
mov    $0x0,%edi
callq  c34 <disable_socket+0x24>
mov    %ebx,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  c40 <disable_socket+0x30>
mov    %ebx,%edx
mov    $0x1,%eax
mov    %ebx,%ecx
sar    $0x6,%edx
shl    %cl,%rax
movslq %edx,%rdx
not    %rax
and    %rax,0x0(,%rdx,8)
pop    %rbx
retq   
nop
mov    $0x0,%r8d
mov    $0x1a1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  c81 <disable_socket+0x71>
jmp    c2a <disable_socket+0x1a>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
disable_socket (int fd)
{
  if (fd < 0)
    return;
  do if (debug_level >= 2) { if (source_info_option) logmsg_printf (7, "%s:%lu:%s: ", "socket.c", 417, __FUNCTION__); debug_msg (gettext("disabling fd %d"), fd); } while (0);
  ((void) (((&listenset)->fds_bits)[((fd) / (8 * (int) sizeof (__fd_mask)))] &= ~((__fd_mask) 1 << ((fd) % (8 * (int) sizeof (__fd_mask))))));
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 5
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3d0 <osip_call_id_get_host+0x10>
mov    0x8(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_call_id_get_host (osip_call_id_t * callid)
{
  if (callid == ((void *)0))
    return ((void *)0);
  return callid->host;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     162 <gsl_vector_complex_long_double_ispos+0x52>
shl    $0x5,%rsi
mov    0x10(%rdi),%rax
xor    %edx,%edx
fldz   
jmp    147 <gsl_vector_complex_long_double_ispos+0x37>
nopw   0x0(%rax,%rax,1)
fldt   0x10(%rax)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jae    158 <gsl_vector_complex_long_double_ispos+0x48>
add    $0x1,%rdx
add    %rsi,%rax
cmp    %rcx,%rdx
je     160 <gsl_vector_complex_long_double_ispos+0x50>
fldt   (%rax)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jb     130 <gsl_vector_complex_long_double_ispos+0x20>
fstp   %st(0)
jmp    15a <gsl_vector_complex_long_double_ispos+0x4a>
nopl   (%rax)
fstp   %st(0)
xor    %eax,%eax
retq   
nopl   (%rax)
fstp   %st(0)
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_long_double_ispos (const gsl_vector_complex_long_double * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 2; k++)
        {
          if (v->data[2 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 11
9 11
10 11
11 11
12 11
13 11
14 11
15 11
16 6
17 6
18 6
19 6
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 17
34 17
35 17
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # a18 <title+0x8>
test   %rbx,%rbx
je     ac0 <title+0xb0>
mov    (%rbx),%esi
cmp    $0x4,%esi
ja     a6e <title+0x5e>
jmpq   *0x0(,%rsi,8)
nop
mov    $0x20,%r8d
mov    0x0(%rip),%eax        # a3c <title+0x2c>
mov    0x10(%rbx),%rcx
mov    $0x20,%edx
mov    $0x0,%edi
lea    -0x2(%rax),%esi
xor    %eax,%eax
callq  a54 <title+0x44>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     ac0 <title+0xb0>
mov    $0x20,%edi
callq  a67 <title+0x57>
mov    (%rbx),%esi
cmp    $0x4,%esi
jbe    a28 <title+0x18>
mov    $0x0,%edi
callq  a78 <title+0x68>
nopl   0x0(%rax,%rax,1)
mov    $0x21,%r8d
jmp    a36 <title+0x26>
nopl   0x0(%rax,%rax,1)
mov    $0x7e,%r8d
jmp    a36 <title+0x26>
nopl   0x0(%rax,%rax,1)
mov    $0x3f,%r8d
jmp    a36 <title+0x26>
nopl   0x0(%rax,%rax,1)
mov    $0x27,%r8d
jmpq   a36 <title+0x26>
nopl   0x0(%rax,%rax,1)
mov    $0xa,%edi
callq  aca <title+0xba>
pop    %rbx
mov    0x0(%rip),%rdi        # ad2 <title+0xc2>
jmpq   ad7 <title+0xc7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
title (void)
{
  struct prt *pp;
  char tag = '\0';
  pp = pqueue;
  if (pp != ((void *)0))
    for (;;)
      {
 switch (pp->pr_which)
   {
   case P_PRIME:
     tag = '\'';
     break;
   case P_VALUE:
     tag = ' ';
     break;
   case P_SSERR:
     tag = '?';
     break;
   case P_ABERR:
     tag = '!';
     break;
   case P_ACERR:
     tag = '~';
     break;
   default:
     panicn ("bad cell spec (%d) in title()", (int)(pp->pr_which));
     break;
   }
 printf (" %*.*s%c", fwd - 2, 32, pp->pr_sym->sy_name, tag);
 if ((pp=pp->pr_link) == ((void *)0))
   break;
 putchar (' ');
      }
  putchar ('\n');
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 6
5 9
6 9
7 9
8 9
9 9
10 9
11 30
12 30
13 30
14 30
15 30
16 30
17 30
18 31
19 31
20 31
21 33
22 33
23 9
24 9
25 9
26 27
27 27
28 27
29 22
30 22
31 22
32 25
33 25
34 25
35 19
36 19
37 19
38 9
39 9
40 9
41 35
42 35
43 37
44 36
45 36
46 36
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x70000,%edx
mov    $0x0,%edi
xor    %esi,%esi
callq  3d5 <mregister_table_init+0x15>
mov    $0x0,%edx
mov    $0x7,%ecx
xor    %eax,%eax
mov    %rdx,%rdi
movl   $0x0,0x0(%rip)        # 3ee <mregister_table_init+0x2e>
rep stos %rax,%es:(%rdi)
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mregister_table_init ()
{
  memset (mem_table, 0, sizeof(mr_table_t) * 8192);
  memset (&mem_overflow, 0, sizeof (mr_table_t));
  table_count = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 5
11 4
12 6
13 6
14 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1c,%edi
callq  0 <sigwinch_handler>
xor    %edi,%edi
callq  2d5 <set_signals+0x15>
test   %eax,%eax
je     2e8 <set_signals+0x28>
mov    $0x0,%esi
mov    $0x1c,%edi
callq  50 <set_signal>
mov    $0x0,%esi
mov    $0x1,%edi
callq  50 <set_signal>
mov    $0x1,%esi
mov    $0x3,%edi
callq  50 <set_signal>
mov    $0x0,%esi
mov    $0x2,%edi
add    $0x8,%rsp
jmpq   50 <set_signal>
nopl   0x0(%rax)
<<<sep_in_sample>>>
set_signals( void )
  {
  sigwinch_handler( 28 );
  if( isatty( 0 ) ) set_signal( 28, sigwinch_handler );
  set_signal( 1, sighup_handler );
  set_signal( 3, ((__sighandler_t) 1) );
  set_signal( 2, sigint_handler );
  }
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 7
18 7
19 8
20 7
21 7
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
gsl_utils_placeholder (void)
{
  int i = 0;
  i++ ;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
push   %r13
mov    $0x1,%eax
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%ecx
cmp    %ecx,(%rdi)
je     210 <cidr_cmp+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x4(%rdi),%edx
cmp    0x4(%rsi),%edx
mov    $0x1,%r12d
je     230 <cidr_cmp+0x50>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
movslq %edx,%r13
lea    0x8(%rsi),%rsi
lea    0x8(%rdi),%rdi
mov    %r13,%rdx
callq  243 <cidr_cmp+0x63>
test   %eax,%eax
jne    21e <cidr_cmp+0x3e>
lea    0x18(%rbp),%rsi
lea    0x18(%rbx),%rdi
mov    %r13,%rdx
xor    %r12d,%r12d
callq  25a <cidr_cmp+0x7a>
test   %eax,%eax
setne  %r12b
jmp    21e <cidr_cmp+0x3e>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cidr_cmp(const void *elt1, const void *elt2)
{
 struct grecs_cidr const *cp1 = elt1, *cp2 = elt2;
 return !(cp1->family == cp2->family
   && cp1->len == cp2->len
   && memcmp(cp1->address, cp2->address, cp1->len) == 0
   && memcmp(cp1->netmask, cp2->netmask, cp1->len) == 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 4
11 4
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 5
20 5
21 4
22 5
23 8
24 4
25 8
26 8
27 8
28 8
29 8
30 8
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 7
39 7
40 7
41 4
42 7
43 4
44 4
45 4
46 4
<<<sep_out_sample>>>
mov    (%rsi),%rax
movsd  (%rdi),%xmm0
lea    0x8(%rax),%rdx
mov    %rdx,(%rsi)
movsd  %xmm0,(%rax)
xor    %eax,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
OneDToArray (PVOID pData, PVOID pInfo)
{
  PDOUBLE *ppdArrayVal = (PDOUBLE *) pInfo;
  *(*ppdArrayVal)++ = *(PDOUBLE) pData;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 6
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rdx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     143d <gsl_matrix_long_double_set_zero+0x4d>
mov    %r8,%rcx
fldz   
shl    $0x4,%rdi
shl    $0x4,%rcx
xor    %esi,%esi
nopl   0x0(%rax,%rax,1)
test   %r8,%r8
je     142f <gsl_matrix_long_double_set_zero+0x3f>
xor    %eax,%eax
nop
fstpt  (%rdx,%rax,1)
fldt   (%rdx,%rax,1)
add    $0x10,%rax
cmp    %rcx,%rax
jne    1420 <gsl_matrix_long_double_set_zero+0x30>
add    $0x1,%rsi
add    %rdi,%rdx
cmp    %r9,%rsi
jne    1418 <gsl_matrix_long_double_set_zero+0x28>
fstp   %st(0)
repz retq 
nop
<<<sep_in_sample>>>
gsl_matrix_long_double_set_zero (gsl_matrix_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const long double zero = 0.0L;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(long double *) (data + 1 * (i * tda + j)) = zero;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 11
15 11
16 11
17 13
18 13
19 13
20 11
21 11
22 9
23 9
24 9
25 9
26 9
27 9
28 9
<<<sep_out_sample>>>
push   %r14
mov    %r8d,%r14d
push   %r13
mov    %esi,%r13d
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
callq  1580 <findEntry>
test   %rax,%rax
je     3688 <headerModifyEntry+0x88>
mov    (%rbx),%r9
cmp    %r9,%rax
jbe    3693 <headerModifyEntry+0x93>
mov    -0x20(%rax),%r10d
mov    %rax,%rbx
cmp    %r13d,%r10d
je     3646 <headerModifyEntry+0x46>
jmp    364f <headerModifyEntry+0x4f>
nopw   %cs:0x0(%rax,%rax,1)
cmp    %r10d,-0x20(%rbx)
jne    364f <headerModifyEntry+0x4f>
sub    $0x20,%rbx
cmp    %r9,%rbx
ja     3640 <headerModifyEntry+0x40>
mov    0x10(%rbx),%r13
lea    0x18(%rbx),%rcx
mov    %r14d,0xc(%rbx)
mov    %ebp,0x4(%rbx)
mov    %r14d,%edx
mov    %r12,%rsi
mov    %ebp,%edi
callq  1250 <grabData>
mov    %r13,%rdi
mov    %rax,0x10(%rbx)
callq  3677 <headerModifyEntry+0x77>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%eax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
mov    %rax,%rbx
jmp    364f <headerModifyEntry+0x4f>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
headerModifyEntry(Header h, int_32 tag, int_32 type, void *p, int_32 c)
{
    struct indexEntry *entry;
    void * oldData;
    entry = findEntry(h, tag, type);
    if (!entry) {
 return 0;
    }
    while (entry > h->index && (entry - 1)->info.tag == tag)
 entry--;
    oldData = entry->data;
    entry->info.count = c;
    entry->info.type = type;
    entry->data = grabData(type, p, c, &entry->length);
    free(oldData);
    return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 6
13 6
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 9
27 9
28 11
29 14
30 12
31 13
32 14
33 14
34 14
35 14
36 15
37 14
38 15
39 17
40 17
41 17
42 17
43 16
44 17
45 17
46 17
47 17
48 17
49 17
50 17
51 7
52 17
53 17
54 9
55 9
56 9
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rdi,%rbx
callq  *0x10(%rax)
mov    %rbx,%rdi
callq  1f2 <error_exit+0x12>
mov    $0x1,%edi
callq  1fc <error_exit+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
error_exit (j_common_ptr cinfo)
{
  (*cinfo->err->output_message) (cinfo);
  jpeg_destroy(cinfo);
  exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 4
7 5
8 5
9 5
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     50 <pfree+0x20>
mov    0x8(%rdi),%rdi
callq  42 <pfree+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   4b <pfree+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
pfree (struct prt *pp)
{
  if (pp != ((void *)0))
    {
      pfree (pp->pr_link);
      free ((void *)pp);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 6
8 8
9 6
10 6
11 8
12 8
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  d9 <grecs_strdup+0x9>
lea    0x1(%rax),%rdi
callq  e2 <grecs_strdup+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   ee <grecs_strdup+0x1e>
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_strdup(const char *str)
{
 char *newstr = grecs_malloc(strlen(str) + 1);
 return strcpy(newstr, str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   708 <strob_strlen+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strob_strlen(STROB * strb)
{
 return strlen((char*)(strb->str_));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x3f8,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x3e8(%rsp)
xor    %eax,%eax
jmp    399 <hash_file+0x49>
nopl   0x0(%rax,%rax,1)
mov    %rsp,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  *0x20(%r13)
mov    %rbx,%rdi
callq  395 <hash_file+0x45>
test   %eax,%eax
jne    3e0 <hash_file+0x90>
mov    %rbx,%rcx
mov    $0x3e8,%edx
mov    $0x1,%esi
mov    %rsp,%rdi
callq  3ae <hash_file+0x5e>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  3b9 <hash_file+0x69>
test   %eax,%eax
je     380 <hash_file+0x30>
xor    %eax,%eax
mov    0x3e8(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    3e7 <hash_file+0x97>
add    $0x3f8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x1,%eax
jmp    3bf <hash_file+0x6f>
callq  3ec <hash_file+0x9c>
<<<sep_in_sample>>>
hash_file(const struct nettle_hash *hash, void *ctx, FILE *f)
{
  for (;;)
    {
      char buffer[1000];
      size_t res = fread(buffer, 1, sizeof(buffer), f);
      if (ferror(f))
 return 0;
      hash->update(ctx, res, buffer);
      if (feof(f))
 return 1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 6
23 6
24 6
25 6
26 6
27 7
28 6
29 7
30 7
31 7
32 8
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 11
43 11
44 13
<<<sep_out_sample>>>
push   %r12
mov    $0x245,%edx
mov    %rdi,%r12
mov    $0x20,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
callq  2ae <array_create_element+0x1e>
mov    %rax,%rbx
mov    %r12,(%rax)
xor    %eax,%eax
test   %rbp,%rbp
je     2e1 <array_create_element+0x51>
mov    %rbp,%rdi
callq  2c3 <array_create_element+0x33>
lea    0x1(%rax),%rdi
mov    $0x0,%esi
mov    $0x247,%edx
callq  2d6 <array_create_element+0x46>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  2e1 <array_create_element+0x51>
mov    %rax,0x8(%rbx)
movq   $0x0,0x18(%rbx)
mov    %rbx,%rax
movq   $0x0,0x10(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
array_create_element(indx, value)
arrayind_t indx;
char *value;
{
 ARRAY_ELEMENT *r;
 r = (ARRAY_ELEMENT *)sh_xmalloc((sizeof(ARRAY_ELEMENT)), "array.c", 581);
 r->ind = indx;
 r->value = value ? (char *)strcpy (sh_xmalloc((1 + strlen (value)), "array.c", 583), (value)) : (char *)((void *)0);
 r->next = r->prev = (ARRAY_ELEMENT *) ((void *)0);
 return(r);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 4
7 6
8 4
9 6
10 6
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 11
27 9
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 816 <yyget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyget_leng (void)
{
        return yyleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
movslq %edi,%rbx
cmp    $0x6,%ebx
jbe    120e <redir2str+0x2e>
mov    $0x666,%esi
mov    $0x0,%edi
callq  11f8 <redir2str+0x18>
mov    $0x0,%edi
callq  1202 <redir2str+0x22>
mov    %ebx,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  120e <redir2str+0x2e>
mov    0x0(,%rbx,8),%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
redir2str(int redirtype)
{
 static const char *const redirtab[] = {
  "",
  " > ",
  " >> ",
  " | ",
  " | ",
  " < ",
  " |& ",
 };
 if (redirtype < 0 || redirtype > redirect_twoway)
  (*(set_loc("profile.c", 1638), r_fatal))(gettext("redir2str: unknown redirection type %d"), redirtype);
 return redirtab[redirtype];
}
<<<sep_in_sample>>>
1 2
2 2
3 12
4 12
5 13
6 13
7 13
8 13
9 13
10 13
11 13
12 13
13 13
14 14
15 15
16 15
17 15
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    %ebx,%edi
sub    $0x10,%rsp
movsd  %xmm0,(%rsp)
callq  143 <gsl_ran_poisson_pdf+0x13>
movsd  %xmm0,0x8(%rsp)
movsd  (%rsp),%xmm0
callq  153 <gsl_ran_poisson_pdf+0x23>
cvtsi2sd %rbx,%xmm1
mulsd  %xmm1,%xmm0
subsd  0x8(%rsp),%xmm0
subsd  (%rsp),%xmm0
add    $0x10,%rsp
pop    %rbx
jmpq   171 <gsl_ran_poisson_pdf+0x41>
<<<sep_in_sample>>>
gsl_ran_poisson_pdf (const unsigned int k, const double mu)
{
  double p;
  double lf = gsl_sf_lnfact (k);
  p = exp (log (mu) * k - lf - mu);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 7
15 7
16 5
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  46d <_rl_arg_callback+0xd>
test   %eax,%eax
mov    %eax,%ebx
js     4d0 <_rl_arg_callback+0x70>
mov    0x0(%rip),%eax        # 479 <_rl_arg_callback+0x19>
test   $0x4,%al
jne    4a0 <_rl_arg_callback+0x40>
mov    %ebx,%esi
mov    %ebp,%edi
xor    %eax,%eax
callq  488 <_rl_arg_callback+0x28>
cmp    $0x1,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
and    $0xfffffffb,%eax
mov    %eax,0x0(%rip)        # 4a9 <_rl_arg_callback+0x49>
callq  4ae <_rl_arg_callback+0x4e>
callq  4b3 <_rl_arg_callback+0x53>
mov    %ebx,%edi
andq   $0xfffffffffffffbff,0x0(%rip)        # 4c0 <_rl_arg_callback+0x60>
callq  4c5 <_rl_arg_callback+0x65>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_arg_callback (cxt)
     _rl_arg_cxt cxt;
{
  int c, r;
  c = _rl_arg_getchar ();
  if (c < 0)
    return (1);
  if (_rl_argcxt & 0x04)
    {
      _rl_argcxt &= ~0x04;
      rl_restore_prompt ();
      rl_clear_message ();
      (rl_readline_state &= ~(0x0000400));
      rl_execute_next (c);
      return 0;
    }
  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 5
8 6
9 8
10 8
11 8
12 17
13 17
14 17
15 17
16 18
17 18
18 19
19 19
20 18
21 19
22 19
23 19
24 10
25 10
26 11
27 12
28 14
29 13
30 14
31 19
32 15
33 19
34 19
35 19
36 19
37 19
38 7
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 16e6 <ppdget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdget_leng (void)
{
        return ppdleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
movzbl (%rdi),%edx
cmp    $0x3d,%dl
je     c21 <test_binop+0x11>
mov    %edx,%eax
and    $0xfffffffd,%eax
cmp    $0x3c,%al
jne    c2c <test_binop+0x1c>
cmpb   $0x0,0x1(%rdi)
mov    $0x1,%eax
je     c90 <test_binop+0x80>
cmp    $0x21,%dl
jne    c48 <test_binop+0x38>
cmpb   $0x3d,0x1(%rdi)
je     c98 <test_binop+0x88>
xor    %eax,%eax
cmp    $0x2d,%dl
je     c54 <test_binop+0x44>
xchg   %ax,%ax
repz retq 
nopw   0x0(%rax,%rax,1)
cmp    $0x3d,%dl
je     c31 <test_binop+0x21>
xor    %eax,%eax
cmp    $0x2d,%dl
jne    c3e <test_binop+0x2e>
movzbl 0x2(%rdi),%edx
test   %dl,%dl
je     c3e <test_binop+0x2e>
cmpb   $0x0,0x3(%rdi)
jne    c3e <test_binop+0x2e>
cmp    $0x74,%dl
movzbl 0x1(%rdi),%ecx
je     cc0 <test_binop+0xb0>
cmp    $0x65,%cl
je     ca8 <test_binop+0x98>
cmp    $0x65,%dl
jne    c3e <test_binop+0x2e>
sub    $0x67,%ecx
cmp    $0x7,%cl
ja     c3e <test_binop+0x2e>
mov    $0x1,%eax
shl    %cl,%rax
test   $0xa1,%al
setne  %al
movzbl %al,%eax
retq   
xchg   %ax,%ax
repz retq 
nopw   0x0(%rax,%rax,1)
cmpb   $0x0,0x2(%rdi)
mov    $0x1,%eax
jne    c37 <test_binop+0x27>
repz retq 
nopl   (%rax)
cmp    $0x66,%dl
je     cb2 <test_binop+0xa2>
cmp    $0x71,%dl
jne    c3e <test_binop+0x2e>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x67,%ecx
cmp    $0x8,%cl
ja     c3e <test_binop+0x2e>
mov    $0x1,%eax
shl    %cl,%rax
test   $0x1a1,%eax
setne  %al
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
test_binop (op)
     char *op;
{
  if (op[0] == '=' && op[1] == '\0')
    return (1);
  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\0')
    return (1);
  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\0')
    return (1);
  else if (op[0] != '-' || op[2] == '\0' || op[3] != '\0')
    return (0);
  else
    {
      if (op[2] == 't')
 switch (op[1])
   {
   case 'n':
   case 'o':
   case 'l':
   case 'g':
     return (1);
   default:
     return (0);
   }
      else if (op[1] == 'e')
 switch (op[2])
   {
   case 'q':
   case 'f':
     return (1);
   default:
     return (0);
   }
      else if (op[2] == 'e')
 switch (op[1])
   {
   case 'n':
   case 'g':
   case 'l':
     return (1);
   default:
     return (0);
   }
      else
 return (0);
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 6
8 4
9 5
10 4
11 8
12 8
13 8
14 8
15 11
16 10
17 10
18 10
19 47
20 47
21 8
22 8
23 11
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 14
32 14
33 14
34 25
35 25
36 34
37 34
38 34
39 34
40 34
41 34
42 34
43 34
44 34
45 34
46 47
47 47
48 47
49 47
50 8
51 5
52 8
53 47
54 47
55 26
56 26
57 26
58 26
59 30
60 30
61 30
62 30
63 30
64 30
65 30
66 30
67 30
68 30
69 30
70 30
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4e26 <info_scroll_half_screen_down+0x6>
test   %eax,%eax
jne    4e60 <info_scroll_half_screen_down+0x40>
mov    0x0(%rip),%eax        # 4e30 <info_scroll_half_screen_down+0x10>
test   %eax,%eax
jne    4e49 <info_scroll_half_screen_down+0x29>
mov    0x18(%rdi),%rax
add    $0x1,%rax
mov    %rax,%rdx
shr    $0x3f,%rdx
add    %rdx,%rax
sar    %rax
imul   %eax,%esi
mov    $0x1,%edx
jmpq   4bd0 <_scroll_forward>
nopw   %cs:0x0(%rax,%rax,1)
test   %esi,%esi
js     4e78 <info_scroll_half_screen_down+0x58>
mov    %esi,0x0(%rip)        # 4e6a <info_scroll_half_screen_down+0x4a>
mov    %esi,%eax
mov    $0x1,%esi
jmp    4e30 <info_scroll_half_screen_down+0x10>
nopl   0x0(%rax,%rax,1)
mov    %esi,%eax
mov    $0xffffffff,%esi
mov    $0x1,%edx
neg    %eax
imul   %eax,%esi
mov    %eax,0x0(%rip)        # 4e8f <info_scroll_half_screen_down+0x6f>
jmpq   4bd0 <_scroll_forward>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_scroll_half_screen_down (WINDOW *window, int count)
{
  int lines;
  if (info_explicit_arg)
    {
      default_scroll_size = count;
      count = 1;
      if (default_scroll_size < 0)
        {
          default_scroll_size *= -1;
          count = -1;
        }
    }
  if (default_scroll_size != 0)
    lines = default_scroll_size * count;
  else
    lines = (window->height + 1) / 2 * count;
  _scroll_forward (window, lines, 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 14
6 14
7 17
8 17
9 17
10 17
11 17
12 17
13 17
14 18
15 18
16 18
17 8
18 8
19 6
20 6
21 7
22 7
23 7
24 10
25 11
26 18
27 10
28 17
29 10
30 18
31 18
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  1abe <mu_scheme_autodetect_p+0xe>
test   %eax,%eax
jne    1ac8 <mu_scheme_autodetect_p+0x18>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  1ad0 <mu_scheme_autodetect_p+0x20>
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_scheme_autodetect_p (mu_url_t url)
{
  if (mu_url_is_scheme (url, "file"))
    {
      mu_url_expand_path (url);
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 9
8 9
9 9
10 5
11 5
12 6
13 9
14 9
15 9
<<<sep_out_sample>>>
push   %r12
cmp    %edx,%esi
mov    %rdi,%r12
push   %rbp
mov    %ecx,%ebp
push   %rbx
mov    %esi,%ebx
je     1c0b <_sse_mulr_d+0x1b>
cmp    %ecx,%esi
mov    %edx,%r8d
je     1c0e <_sse_mulr_d+0x1e>
callq  1b90 <_sse_movr_d.part.17>
mov    %ebp,%r8d
mov    %ebx,%ecx
mov    %r12,%rdi
mov    $0x59,%edx
pop    %rbx
pop    %rbp
pop    %r12
mov    $0xf2,%esi
jmpq   1a80 <_ssexr>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_mulr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf2,0x59,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf2,0x59,r0,r1);
    else {
 _sse_movr_d(_jit,r0,r1);
 _ssexr(_jit,0xf2,0x59,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 6
11 5
12 5
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 9
21 9
22 9
<<<sep_out_sample>>>
mov    %rsi,0xc0(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_qop_set (Gsasl * ctx, Gsasl_server_callback_qop cb)
{
  ctx->cbs_qop = cb;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %edx,%edx
jmp    d20 <safe_xstat>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_stat (const char *pathname, struct stat *buf)
{
  return safe_xstat (pathname, buf, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
xor    %edx,%edx
div    %rcx
cmp    %rsi,%rax
jb     8d <xnrealloc+0x1d>
imul   %rcx,%rsi
jmpq   8d <xnrealloc+0x1d>
push   %rax
callq  93 <xnrealloc+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 2
10 4
11 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 8a <editMenu_ToggleSelectMode+0xa>
test   %esi,%esi
je     e8 <editMenu_ToggleSelectMode+0x68>
mov    0x0(%rip),%edx        # 94 <editMenu_ToggleSelectMode+0x14>
xor    %eax,%eax
test   %edx,%edx
sete   %al
mov    %eax,0x0(%rip)        # a1 <editMenu_ToggleSelectMode+0x21>
xor    %eax,%eax
callq  a8 <editMenu_ToggleSelectMode+0x28>
mov    0x0(%rip),%ecx        # ae <editMenu_ToggleSelectMode+0x2e>
test   %ecx,%ecx
je     dc <editMenu_ToggleSelectMode+0x5c>
mov    0x0(%rip),%eax        # b8 <editMenu_ToggleSelectMode+0x38>
add    0x0(%rip),%eax        # be <editMenu_ToggleSelectMode+0x3e>
mov    0x0(%rip),%edx        # c4 <editMenu_ToggleSelectMode+0x44>
mov    %eax,0x0(%rip)        # ca <editMenu_ToggleSelectMode+0x4a>
mov    %edx,0x0(%rip)        # d0 <editMenu_ToggleSelectMode+0x50>
mov    %eax,0x0(%rip)        # d6 <editMenu_ToggleSelectMode+0x56>
mov    %edx,0x0(%rip)        # dc <editMenu_ToggleSelectMode+0x5c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %edx,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  f9 <editMenu_ToggleSelectMode+0x79>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   104 <editMenu_ToggleSelectMode+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
editMenu_ToggleSelectMode()
{
  if(X_IS_RUNNING)
  {
    SELECTING = !SELECTING;
    refreshBottomView();
    if(SELECTING)
    {
      sel_range_start.nline = firstVisLine+selectedLine;
      sel_range_start.nchar = selectedChar;
      sel_range_end.nline = firstVisLine+selectedLine;
      sel_range_end.nchar = selectedChar;
    }
  }
  else
  {
    msgBox("The select mode is only available under X.\nUse SHIFT to select text.", 1, INFO);
    refreshView();
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 7
13 7
14 7
15 9
16 9
17 10
18 9
19 10
20 11
21 12
22 20
23 20
24 20
25 17
26 17
27 17
28 17
29 18
30 20
31 18
32 18
<<<sep_out_sample>>>
jmpq   0 <get_struct_by_message>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swevents_get_struct_by_message(char * line, struct swEvents * evnt)
{
 return get_struct_by_message(line, evnt);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 95f <_rl_backspace+0xf>
test   %rax,%rax
je     9a0 <_rl_backspace+0x50>
test   %edi,%edi
jle    98d <_rl_backspace+0x3d>
mov    %rax,%rdi
xor    %ebx,%ebx
jmp    977 <_rl_backspace+0x27>
nop
mov    0x0(%rip),%rdi        # 977 <_rl_backspace+0x27>
mov    $0x0,%edx
mov    $0x1,%esi
add    $0x1,%ebx
callq  989 <_rl_backspace+0x39>
cmp    %ebp,%ebx
jne    970 <_rl_backspace+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %ebx,%ebx
test   %edi,%edi
jle    98d <_rl_backspace+0x3d>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 9b7 <_rl_backspace+0x67>
mov    $0x8,%edi
add    $0x1,%ebx
callq  9c4 <_rl_backspace+0x74>
cmp    %ebp,%ebx
jne    9b0 <_rl_backspace+0x60>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_backspace (count)
     int count;
{
  register int i;
  if (_rl_term_backspace)
    for (i = 0; i < count; i++)
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
  else
    for (i = 0; i < count; i++)
      _IO_putc ('\b', _rl_out_stream);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 6
18 7
19 6
20 6
21 12
22 12
23 12
24 12
25 12
26 12
27 9
28 9
29 9
30 9
31 10
32 10
33 9
34 10
35 9
36 9
37 12
38 12
39 12
40 12
41 12
42 12
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
mov    %edi,%ebx
xor    %eax,%eax
mov    $0x0,%edi
callq  11 <protect_fd+0x11>
cmp    %ebx,%eax
je     38 <protect_fd+0x38>
xor    %ebx,%ebx
test   %eax,%eax
js     2d <protect_fd+0x2d>
mov    %eax,%edi
callq  22 <protect_fd+0x22>
callq  27 <protect_fd+0x27>
movl   $0x9,(%rax)
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x1,%ebx
mov    %ebx,%eax
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
protect_fd (int fd)
{
  int value = open ("/dev/null", 00);
  if (value != fd)
    {
      if (0 <= value)
        {
          close (value);
          (*__errno_location ()) = 9;
        }
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 4
8 4
9 11
10 6
11 6
12 8
13 8
14 9
15 9
16 14
17 14
18 14
19 14
20 13
21 14
22 14
23 14
24 14
<<<sep_out_sample>>>
cmp    $0x1,%edx
mov    0x38(%rdi),%rdi
sbb    %edx,%edx
not    %edx
and    $0x2,%edx
jmpq   c43 <CDB___ham_put_page+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___ham_put_page(dbp, pagep, is_dirty)
 DB *dbp;
 PAGE *pagep;
 int32_t is_dirty;
{
 return (CDB_memp_fput(dbp->mpf, pagep, (is_dirty ? 0x002 : 0)));
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
cmp    $0x1,%eax
je     390 <tag_fixup+0x30>
cmp    $0x2,%eax
jne    394 <tag_fixup+0x34>
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
mov    %rsi,%rdx
mov    $0x0,%esi
callq  382 <tag_fixup+0x22>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
add    %rsi,0x20(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tag_fixup(void *item, void *data)
{
    struct gcide_tag *tag = item;
    char *textspace = data;
    switch (tag->tag_type) {
    case gcide_content_unspecified:
 break;
    case gcide_content_text:
 tag->tag_v.text = textspace + tag->tag_v.textpos;
 break;
    case gcide_content_taglist:
 dico_list_iterate(tag->tag_v.taglist, tag_fixup, textspace);
 break;
    }
    return 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 2
7 12
8 12
9 12
10 12
11 16
12 16
13 16
14 16
15 9
16 16
17 16
18 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a7 <grecs_text_table+0x7>
movq   $0x0,0x0(%rip)        # b2 <grecs_text_table+0x12>
retq   
<<<sep_in_sample>>>
grecs_text_table()
{
 struct grecs_symtab *tmp = text_table;
 text_table = ((void *)0);
 return tmp;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x5413,%esi
xor    %edi,%edi
mov    %rsp,%rdx
xor    %eax,%eax
callq  35 <getScreenSize+0x15>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 3f <getScreenSize+0x1f>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 4a <getScreenSize+0x2a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
jmpq   5 <osip_route_init+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_route_init (osip_route_t ** route)
{
  return osip_from_init ((osip_from_t **) route);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_algorithm (osip_www_authenticate_t * www_authenticate, char *algorithm)
{
  www_authenticate->algorithm = (char *) algorithm;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdx,%rdx
jne    2b70 <_movi+0x10>
jmp    2b50 <_movi.part.7>
nopw   0x0(%rax,%rax,1)
jmpq   2770 <_imovi>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_movi(jit_state_t *_jit, jit_int32_t r0, jit_word_t i0)
{
    if (i0)
 _imovi(_jit, r0, i0);
    else
 _alur(_jit, 6 << 3, r0, r0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %edi,%esi
mov    $0x1,%edi
callq  10 <xmalloc+0x10>
test   %rax,%rax
je     1a <xmalloc+0x1a>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  24 <xmalloc+0x24>
mov    0x0(%rip),%rdi        # 2b <xmalloc+0x2b>
mov    %rax,%rsi
xor    %eax,%eax
callq  35 <xmalloc+0x35>
mov    $0x5,%edi
callq  3f <xmalloc+0x3f>
nop
<<<sep_in_sample>>>
xmalloc (unsigned size)
{
    char *val = (char *) calloc (1, size);
    if (!val)
    {
        fprintf (stderr, gettext("indent: Virtual memory exhausted.\n"));
        exit (system_error);
    }
    return val;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 10
8 10
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  eb <osip_thread_exit+0xb>
<<<sep_in_sample>>>
osip_thread_exit ()
{
  pthread_exit (((void *)0));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
callq  1536 <reference+0x6>
test   %rax,%rax
mov    %rax,%rbx
je     1574 <reference+0x44>
mov    0x0(%rip),%rdi        # 1545 <reference+0x15>
test   %rdi,%rdi
je     1574 <reference+0x44>
mov    0x88(%rax),%rsi
callq  1556 <reference+0x26>
test   %eax,%eax
je     15a0 <reference+0x70>
mov    0x0(%rip),%rax        # 1561 <reference+0x31>
mov    %rbx,%rdi
mov    0x90(%rax),%rsi
callq  1570 <reference+0x40>
test   %eax,%eax
je     1580 <reference+0x50>
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 1587 <reference+0x57>
mov    %rbx,%rsi
pop    %rbx
lea    0x90(%rax),%rdi
jmpq   1597 <reference+0x67>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 15a7 <reference+0x77>
lea    0x88(%rbx),%rdi
callq  15b3 <reference+0x83>
jmp    155a <reference+0x2a>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reference(char *name, int line)
{
     Symbol *sp = add_reference(name, line);
     if (!sp)
   return;
     if (caller) {
   if (!data_in_list(caller, sp->caller))
        linked_list_append(&sp->caller, caller);
   if (!data_in_list(sp, caller->callee))
        linked_list_append(&caller->callee, sp);
     }
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 6
7 6
8 6
9 7
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 9
19 12
20 12
21 12
22 10
23 10
24 12
25 10
26 10
27 10
28 8
29 8
30 8
31 8
32 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rsi
mov    (%rdi),%rdi
callq  8f <rec_field_equal_p+0xf>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_field_equal_p (rec_field_t field1,
                   rec_field_t field2)
{
  return (strcmp (field1->name, field2->name) == 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%edi
xor    %ebp,%ebp
push   %rbx
sub    $0x8,%rsp
callq  2102 <print_variable_data_base+0x12>
mov    %rax,%rdi
callq  210a <print_variable_data_base+0x1a>
xor    %edx,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  240 <print_variable_set>
mov    $0x0,%edi
callq  2125 <print_variable_data_base+0x35>
mov    %rax,%rdi
callq  212d <print_variable_data_base+0x3d>
mov    0x0(%rip),%rbx        # 2134 <print_variable_data_base+0x44>
test   %rbx,%rbx
je     2190 <print_variable_data_base+0xa0>
nopl   0x0(%rax)
mov    0x10(%rbx),%rsi
mov    $0x0,%edi
xor    %eax,%eax
add    $0x1,%ebp
callq  2153 <print_variable_data_base+0x63>
lea    0x20(%rbx),%rdi
mov    $0x0,%esi
callq  2d0 <print_variable>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    2140 <print_variable_data_base+0x50>
test   %ebp,%ebp
je     2190 <print_variable_data_base+0xa0>
mov    $0x0,%edi
callq  2177 <print_variable_data_base+0x87>
add    $0x8,%rsp
mov    %ebp,%esi
mov    %rax,%rdi
pop    %rbx
pop    %rbp
xor    %eax,%eax
jmpq   2189 <print_variable_data_base+0x99>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  219a <print_variable_data_base+0xaa>
add    $0x8,%rsp
mov    %rax,%rdi
pop    %rbx
pop    %rbp
jmpq   21a8 <print_variable_data_base+0xb8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_variable_data_base (void)
{
  puts (gettext ("\n# Variables\n"));
  print_variable_set (&global_variable_set, "", 0);
  puts (gettext ("\n# Pattern-specific Variable Values"));
  {
    struct pattern_var *p;
    unsigned int rules = 0;
    for (p = pattern_vars; p != 0; p = p->next)
      {
        ++rules;
        printf ("\n%s :\n", p->target);
        print_variable (&p->variable, (void *)"# ");
      }
    if (rules == 0)
      puts (gettext ("\n# No pattern-specific variable values."));
    else
      printf (gettext ("\n# %u pattern-specific variable values"), rules);
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 8
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 9
18 9
19 9
20 9
21 12
22 12
23 12
24 11
25 12
26 13
27 13
28 13
29 9
30 9
31 9
32 15
33 15
34 18
35 18
36 20
37 18
38 18
39 20
40 20
41 18
42 18
43 18
44 16
45 16
46 20
47 16
48 20
49 20
50 16
51 16
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
movsd  0x0(%rip),%xmm0        # 18ac <gsl_monte_vegas_init+0xc>
movl   $0x0,0x74(%rdi)
movl   $0xffffffff,0x6c(%rdi)
movsd  %xmm0,0x60(%rdi)
movl   $0x5,0x70(%rdi)
movl   $0x1,0x68(%rdi)
mov    %eax,0x10(%rdi)
mov    0x0(%rip),%rax        # 18d7 <gsl_monte_vegas_init+0x37>
movq   $0x0,0x98(%rdi)
mov    %rax,0xc0(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_monte_vegas_init (gsl_monte_vegas_state * state)
{
  state->stage = 0;
  state->alpha = 1.5;
  state->verbose = -1;
  state->iterations = 5;
  state->mode = GSL_VEGAS_MODE_IMPORTANCE;
  state->chisq = 0;
  state->bins = state->bins_max;
  state->ostream = stdout;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 9
2 4
3 3
4 5
5 4
6 6
7 7
8 9
9 10
10 8
11 10
12 12
13 12
14 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
test   %r8,%r8
je     192 <gsl_stats_wkurtosis_m_sd+0x82>
fldz   
xorpd  %xmm4,%xmm4
shl    $0x3,%rsi
shl    $0x3,%rcx
xor    %eax,%eax
fld    %st(0)
nopw   0x0(%rax,%rax,1)
movsd  (%rdi),%xmm3
ucomisd %xmm4,%xmm3
jbe    170 <gsl_stats_wkurtosis_m_sd+0x60>
movsd  (%rdx),%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x18(%rsp)
fldl   -0x18(%rsp)
movsd  %xmm3,-0x18(%rsp)
fldl   -0x18(%rsp)
fadd   %st,%st(2)
fld    %st(1)
fmul   %st(2),%st
fmul   %st(2),%st
fmulp  %st,%st(2)
fxch   %st(1)
fsub   %st(3),%st
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    130 <gsl_stats_wkurtosis_m_sd+0x20>
fstp   %st(0)
fsubs  0x0(%rip)        # 187 <gsl_stats_wkurtosis_m_sd+0x77>
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
movsd  0x0(%rip),%xmm0        # 19a <gsl_stats_wkurtosis_m_sd+0x8a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wkurtosis_m_sd (const double w[], const size_t wstride,
                                    const double data[],
                                    const size_t stride,
                                    const size_t n,
                                    const double wmean,
                                    const double wsd)
{
  long double wavg = 0, kurtosis;
  long double W = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      double wi = w[i * wstride];
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wavg += (x * x * x * x - wavg) * (wi / W);
      }
    }
  kurtosis = wavg - 3.0;
  return kurtosis;
}
<<<sep_in_sample>>>
1 11
2 11
3 9
4 9
5 9
6 15
7 11
8 9
9 9
10 13
11 14
12 14
13 15
14 15
15 15
16 15
17 15
18 16
19 16
20 16
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 11
42 22
43 22
<<<sep_out_sample>>>
mov    $0xffffffff,%edx
xor    %esi,%esi
jmpq   a8c <read_history+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
read_history (filename)
     const char *filename;
{
  return (read_history_range (filename, 0, -1));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%ebx        # 337 <clearSelection+0x7>
xor    %eax,%eax
movl   $0x1,0x0(%rip)        # 343 <clearSelection+0x13>
callq  348 <clearSelection+0x18>
xor    %eax,%eax
movl   $0x2,0x0(%rip)        # 354 <clearSelection+0x24>
callq  359 <clearSelection+0x29>
mov    %ebx,0x0(%rip)        # 35f <clearSelection+0x2f>
movl   $0x0,0x0(%rip)        # 369 <clearSelection+0x39>
movl   $0x0,0x0(%rip)        # 373 <clearSelection+0x43>
movl   $0x0,0x0(%rip)        # 37d <clearSelection+0x4d>
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
clearSelection()
{
  int a = activeWindow;
  activeWindow = 1; unMarkAll();
  activeWindow = 2; unMarkAll();
  activeWindow = a;
  numCopy = 0;
  numCut = 0;
  numStarred = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 7
11 8
12 9
13 10
14 10
15 10
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  167c <gsl_sf_dilog+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1690 <gsl_sf_dilog+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x295,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16a6 <gsl_sf_dilog+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_dilog(const double x)
{
  gsl_sf_result result; int status = gsl_sf_dilog_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_dilog_e(x, &result)", "dilog.c", 661, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0xf8(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_message_get_from (const osip_message_t * sip)
{
  return sip->from;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     d3f <gsl_vector_uint_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d35 <gsl_vector_uint_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
shl    $0x2,%r10
shl    $0x2,%r9
xor    %ecx,%ecx
test   %r8,%r8
je     d67 <gsl_vector_uint_swap+0x67>
xchg   %ax,%ax
mov    (%rdx),%esi
mov    (%rax),%edi
add    $0x1,%rcx
mov    %edi,(%rdx)
mov    %esi,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    d50 <gsl_vector_uint_swap+0x50>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_swap (gsl_vector_uint * v, gsl_vector_uint * w)
{
  unsigned int * d1 = v->data ;
  unsigned int * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          unsigned int tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 23
18 23
19 13
20 13
21 13
22 13
23 17
24 18
25 13
26 18
27 19
28 19
29 19
30 13
31 13
32 22
33 23
34 23
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_pow_2(const double x) { return x*x; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
testb  $0xf,0x38(%rdi)
jne    603 <nettle_gcm_encrypt+0x53>
mov    %r9,%r12
mov    0x30(%rsp),%r9
mov    %r8,%rbp
mov    %rsi,%r13
mov    %r12,%r8
mov    %rdx,%rsi
mov    %rcx,%rdx
mov    %rbp,%rcx
callq  f0 <gcm_crypt>
lea    0x20(%rbx),%rsi
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r13,%rdi
callq  5f4 <nettle_gcm_encrypt+0x44>
add    %rbp,0x38(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
lea    0x0(%rip),%rcx        # 60a <nettle_gcm_encrypt+0x5a>
lea    0x0(%rip),%rsi        # 611 <nettle_gcm_encrypt+0x61>
lea    0x0(%rip),%rdi        # 618 <nettle_gcm_encrypt+0x68>
mov    $0x1df,%edx
callq  622 <nettle_gcm_encrypt+0x72>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,
      const void *cipher, nettle_cipher_func *f,
      size_t length, uint8_t *dst, const uint8_t *src)
{
  ((ctx->data_size % 16 == 0) ? (void) (0) : __assert_fail ("ctx->data_size % 16 == 0", "gcm.c", 479, __PRETTY_FUNCTION__));
  gcm_crypt(ctx, cipher, f, length, dst, src);
  _nettle_gcm_hash8(key, &ctx->x, length, dst);
  ctx->data_size += length;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 7
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 5
31 5
32 5
33 5
34 5
35 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    $0xffffffff,%ebx
sub    $0x8,%rsp
mov    0xc(%rdi),%esi
test   %esi,%esi
js     583d <Fileno+0x2d>
nopl   (%rax)
movslq %esi,%rax
sub    $0x1,%esi
lea    (%rax,%rax,2),%rax
mov    0x20(%rbp,%rax,8),%ebx
js     583d <Fileno+0x2d>
cmp    $0xffffffff,%ebx
je     5828 <Fileno+0x18>
mov    0x0(%rip),%eax        # 5843 <Fileno+0x33>
or     0x4(%rbp),%eax
test   $0x40000000,%eax
je     5870 <Fileno+0x60>
mov    %rbp,%rdi
callq  0 <fdbg>
mov    0x0(%rip),%rdi        # 585c <Fileno+0x4c>
mov    %rax,%r8
mov    %ebx,%ecx
mov    %rbp,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  5870 <Fileno+0x60>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
Fileno(FD_t fd) {
    int i, rc = -1;
    for (i = fd->nfps ; rc == -1 && i >= 0; i--) {
 rc = fd->fps[i].fdno;
    }
if ((_rpmio_debug | (((fd)) ? ((FD_t)((fd)))->flags : 0)) & (0x40000000)) fprintf (stderr, "==> Fileno(%p) rc %d %s\n", fd, rc, fdbg(fd));
    return rc;
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 2
5 1
6 3
7 3
8 3
9 3
10 4
11 3
12 4
13 4
14 3
15 3
16 3
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 8
31 8
32 8
33 8
34 8
35 8
<<<sep_out_sample>>>
push   %rbp
xor    %r8d,%r8d
push   %rbx
mov    %rdx,%rbx
mov    %ecx,%edx
xor    %ecx,%ecx
sub    $0x8,%rsp
callq  5f5 <completion_tags+0x15>
cmpl   $0x1,0x0(%rip)        # 5fc <completion_tags+0x1c>
mov    %rbx,%rsi
mov    %rax,%rdi
mov    %rax,%rbp
sbb    %edx,%edx
xor    %ebx,%ebx
and    $0xfffffff0,%edx
add    $0x1d,%edx
callq  614 <completion_tags+0x34>
test   %rax,%rax
je     651 <completion_tags+0x71>
nopl   0x0(%rax)
mov    0x10(%rax),%rdi
mov    0x0(%rip),%rsi        # 62b <completion_tags+0x4b>
add    $0x1,%ebx
callq  633 <completion_tags+0x53>
mov    0x0(%rip),%rsi        # 63a <completion_tags+0x5a>
mov    $0xa,%edi
callq  644 <completion_tags+0x64>
mov    %rbp,%rdi
callq  64c <completion_tags+0x6c>
test   %rax,%rax
jne    620 <completion_tags+0x40>
mov    0x0(%rip),%eax        # 657 <completion_tags+0x77>
test   %eax,%eax
je     663 <completion_tags+0x83>
mov    %rbp,%rdi
callq  663 <completion_tags+0x83>
mov    %rbp,%rdi
callq  66b <completion_tags+0x8b>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
completion_tags(const char *dbpath, const char *root, const char *prefix, int db)
{
 int flags = 1 | 8 | 4;
 GTOP *gtop = gtags_open(dbpath, root, db, 0, 0);
 GTP *gtp;
 int count = 0;
 if (iflag)
  flags |= 16;
 for (gtp = gtags_first(gtop, prefix, flags); gtp; gtp = gtags_next(gtop)) {
  fputs(gtp->tag, stdout);
  fputc('\n', stdout);
  count++;
 }
 if (debug)
  gtags_show_statistics(gtop);
 gtags_close(gtop);
 return count;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 2
8 4
9 3
10 9
11 9
12 4
13 3
14 6
15 3
16 3
17 9
18 9
19 9
20 9
21 10
22 10
23 12
24 10
25 11
26 11
27 11
28 9
29 9
30 9
31 9
32 14
33 14
34 14
35 15
36 15
37 16
38 16
39 18
40 18
41 18
42 18
43 18
44 18
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
size_buffer(b)
  struct buffer *b;
{
  return b->length;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # b <print_and_abort+0xb>
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1c <print_and_abort+0x1c>
mov    0x0(%rip),%edi        # 22 <print_and_abort+0x22>
callq  27 <print_and_abort+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_and_abort (void)
{
  fprintf (stderr, "%s\n", ((const char *) ("memory exhausted")));
  exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     2100 <gsl_vector_uchar_sub+0x30>
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  20f2 <gsl_vector_uchar_sub+0x22>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
test   %r10,%r10
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
je     213a <gsl_vector_uchar_sub+0x6a>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r8
mov    0x10(%rsi),%r9
add    0x10(%rdi),%r8
add    $0x1,%rax
add    %rbx,%rdx
movzbl (%r9,%rcx,1),%r9d
add    %r11,%rcx
sub    %r9b,(%r8)
cmp    %r10,%rax
jne    2118 <gsl_vector_uchar_sub+0x48>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_uchar_sub (gsl_vector_uchar * a, const gsl_vector_uchar * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 13
16 13
17 13
18 10
19 11
20 13
21 13
22 15
23 15
24 15
25 13
26 13
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
35 19
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # 15a <gsl_ieee_printf_float+0xa>
jmpq   15f <gsl_ieee_printf_float+0xf>
nop
<<<sep_in_sample>>>
gsl_ieee_printf_float (const float * x)
{
  gsl_ieee_fprintf_float (stdout,x);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %edx,%ebp
mov    %rdi,%rdx
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
sub    $0x18,%rsp
callq  8d <usage+0x1d>
mov    %rbx,%rcx
mov    $0x1f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a4 <usage+0x34>
mov    %rsp,%rsi
mov    $0x0,%edi
mov    %rbx,(%rsp)
movl   $0x3d,0x8(%rsp)
callq  bd <usage+0x4d>
mov    $0x0,%edi
mov    %rbx,%rcx
mov    $0x28,%edx
mov    $0x1,%esi
callq  d4 <usage+0x64>
mov    %ebp,%edi
callq  db <usage+0x6b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
usage(const char *arg, FILE *fp, int code)
{
 struct list_helper lh;
 fprintf(fp,
  "usage: %s [-h] [-list[=type]] [-locus] [-delim=char] [-reduce] [-sort]\n",
  arg);
 fprintf(fp, "    [-nopath] [-novalue] [-type");
 lh.file = fp;
 lh.delim = '=';
 grecs_enumerate_parsers(list_parser_types, &lh);
 fprintf(fp, "] [-Idir] [-include=dir] file [file...]\n");
 exit(code);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 4
8 4
9 2
10 4
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 8
19 9
20 10
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 12
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %rbp
lea    0x1040(%rdi),%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rbp,%rdi
sub    $0x8,%rsp
callq  18 <nettle_gcm_camellia256_set_key+0x18>
mov    0x0(%rip),%rdx        # 1f <nettle_gcm_camellia256_set_key+0x1f>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rsi
pop    %rbp
jmpq   30 <nettle_gcm_camellia256_set_iv>
<<<sep_in_sample>>>
nettle_gcm_camellia256_set_key(struct gcm_camellia256_ctx *ctx, const uint8_t *key)
{
  do { (nettle_camellia256_set_encrypt_key)(&(ctx)->cipher, (key)); if (0) (nettle_camellia256_crypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0); nettle_gcm_set_key(&(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_camellia256_crypt)); } while (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 2
7 3
8 3
9 4
10 3
11 4
12 3
13 4
14 3
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,(%rdi)
mov    %rdi,%rbx
je     eb0 <rec_rset_type+0x40>
mov    $0x5,%edi
callq  e84 <rec_rset_type+0x14>
mov    (%rbx),%rdi
xor    %edx,%edx
mov    %rax,%rsi
callq  e91 <rec_rset_type+0x21>
test   %rax,%rax
je     eb0 <rec_rset_type+0x40>
mov    %rax,%rdi
callq  e9e <rec_rset_type+0x2e>
pop    %rbx
mov    %rax,%rdi
jmpq   ea7 <rec_rset_type+0x37>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_type (rec_rset_t rset)
{
  char *res;
  rec_field_t field;
  res = ((void *)0);
  if (rset->descriptor)
    {
      field = rec_record_get_field_by_name (rset->descriptor,
                                            rec_std_field_name ((REC_FIELD_REC)),
                                            0);
      if (field)
        {
          res = rec_extract_type (rec_field_value (field));
        }
    }
  return res;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 11
12 11
13 13
14 13
15 17
16 13
17 13
18 13
19 17
20 17
21 17
22 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0xa8,%rsp
lea    0x10(%rsp),%rsi
mov    %rsp,%rdi
movb   $0x2f,(%rsp)
movb   $0x0,0x1(%rsp)
callq  2bbf <cwd_is_root+0x1f>
test   %eax,%eax
je     2bd0 <cwd_is_root+0x30>
xor    %eax,%eax
add    $0xa8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
lea    0x10(%rsp),%rsi
mov    $0x0,%edi
mov    0x10(%rsp),%rbx
mov    0x18(%rsp),%rbp
callq  2be9 <cwd_is_root+0x49>
test   %eax,%eax
jne    2bc3 <cwd_is_root+0x23>
cmp    %rbx,0x10(%rsp)
jne    2bc5 <cwd_is_root+0x25>
cmp    0x18(%rsp),%rbp
sete   %al
jmp    2bc5 <cwd_is_root+0x25>
<<<sep_in_sample>>>
cwd_is_root (char const *name)
{
  unsigned int prefix_len = 0;
  char root[prefix_len + 2];
  struct stat st;
  dev_t root_dev;
  ino_t root_ino;
  memcpy (root, name, prefix_len);
  root[prefix_len] = '/';
  root[prefix_len + 1] = 0;
  if (stat (root, &st))
    return 0;
  root_dev = st.st_dev;
  root_ino = st.st_ino;
  if (stat (".", &st))
    return 0;
  return root_dev == st.st_dev && root_ino == st.st_ino;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 11
5 11
6 9
7 10
8 11
9 11
10 11
11 12
12 18
13 18
14 18
15 18
16 18
17 15
18 15
19 13
20 14
21 15
22 15
23 15
24 17
25 17
26 17
27 17
28 17
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 42a1 <install_builtins+0x11>
mov    %eax,%edx
and    $0x8,%edx
cmp    $0x1,%edx
sbb    %ebp,%ebp
and    $0xfffffc00,%ebp
add    $0x2400,%ebp
mov    %ebp,%edx
or     $0x2,%dh
test   $0x10,%al
cmovne %edx,%ebp
jmp    42d5 <install_builtins+0x45>
nopl   0x0(%rax,%rax,1)
add    $0x28,%rbx
cmp    $0x0,%rbx
je     4308 <install_builtins+0x78>
mov    (%rbx),%eax
sub    $0x12c,%eax
cmp    $0x1,%eax
ja     42c8 <install_builtins+0x38>
test   %ebp,0x4(%rbx)
jne    42c8 <install_builtins+0x38>
mov    -0xc(%rbx),%rdi
mov    $0xb,%esi
add    $0x28,%rbx
callq  42f8 <install_builtins+0x68>
cmp    $0x0,%rbx
jne    42d5 <install_builtins+0x45>
nopl   0x0(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
install_builtins(void)
{
 int i, j;
 int flags_that_must_be_clear = 0x2000;
 if ((do_flags & DO_TRADITIONAL))
  flags_that_must_be_clear |= 0x0400;
 if ((do_flags & DO_POSIX))
  flags_that_must_be_clear |= 0x0200;
 j = sizeof(tokentab) / sizeof(tokentab[0]);
 for (i = 0; i < j; i++) {
  if ( (tokentab[i].class == 300
          || tokentab[i].class == 301)
      && (tokentab[i].flags & flags_that_must_be_clear) == 0) {
   (void) install_symbol(tokentab[i].operator, Node_builtin_func);
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 4
9 4
10 4
11 4
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 12
22 12
23 11
24 11
25 13
26 13
27 14
28 14
29 14
30 14
31 10
32 10
33 10
34 17
35 17
36 17
37 17
38 17
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     e7a <trace_inc_port+0x2a>
mov    0x8(%rdi),%eax
test   %eax,%eax
jne    e78 <trace_inc_port+0x28>
movzwl 0xe(%rdi),%edi
callq  e69 <trace_inc_port+0x19>
lea    0x1(%rax),%edi
movzwl %di,%edi
callq  e74 <trace_inc_port+0x24>
mov    %ax,0xe(%rbx)
pop    %rbx
retq   
mov    $0x0,%ecx
mov    $0x2ef,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e93 <trace_inc_port+0x43>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trace_inc_port (trace_t * t)
{
  ((t) ? (void) (0) : __assert_fail ("t", "traceroute.c", 751, __PRETTY_FUNCTION__));
  if (t->type == TRACE_UDP)
    t->to.sin_port = htons (ntohs (t->to.sin_port) + 1);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 3
17 3
18 3
19 3
20 3
21 3
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm8        # 4a9 <hyperg_1F1_1_series+0x9>
xorpd  %xmm9,%xmm9
movapd %xmm8,%xmm7
movapd %xmm8,%xmm2
movapd %xmm8,%xmm3
movsd  0x0(%rip),%xmm6        # 4c5 <hyperg_1F1_1_series+0x25>
movsd  0x0(%rip),%xmm13        # 4ce <hyperg_1F1_1_series+0x2e>
movsd  0x0(%rip),%xmm12        # 4d7 <hyperg_1F1_1_series+0x37>
movsd  0x0(%rip),%xmm11        # 4e0 <hyperg_1F1_1_series+0x40>
movapd %xmm0,%xmm4
movapd %xmm1,%xmm5
addsd  %xmm7,%xmm4
addsd  %xmm8,%xmm7
subsd  %xmm8,%xmm4
divsd  %xmm4,%xmm5
mulsd  %xmm5,%xmm2
addsd  %xmm2,%xmm3
movapd %xmm2,%xmm10
andpd  %xmm6,%xmm10
movapd %xmm3,%xmm5
movapd %xmm10,%xmm4
andpd  %xmm6,%xmm5
mulsd  %xmm13,%xmm4
mulsd  %xmm12,%xmm5
addsd  %xmm5,%xmm4
addsd  %xmm4,%xmm9
movapd %xmm2,%xmm4
divsd  %xmm3,%xmm4
andpd  %xmm6,%xmm4
ucomisd %xmm11,%xmm4
ja     4e0 <hyperg_1F1_1_series+0x40>
addsd  %xmm10,%xmm10
movsd  %xmm3,(%rdi)
xor    %eax,%eax
addsd  %xmm9,%xmm10
movsd  %xmm10,0x8(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hyperg_1F1_1_series(const double b, const double x, gsl_sf_result * result)
{
  double sum_val = 1.0;
  double sum_err = 0.0;
  double term = 1.0;
  double n = 1.0;
  while(fabs(term/sum_val) > 0.25*2.2204460492503131e-16) {
    term *= x/(b+n-1);
    sum_val += term;
    sum_err += 8.0*2.2204460492503131e-16*fabs(term) + 2.2204460492503131e-16*fabs(sum_val);
    n += 1.0;
  }
  result->val = sum_val;
  result->err = sum_err;
  result->err += 2.0 * fabs(term);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 5
5 3
6 3
7 3
8 3
9 3
10 8
11 8
12 8
13 11
14 8
15 8
16 8
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 7
28 7
29 7
30 7
31 7
32 15
33 13
34 17
35 15
36 15
37 17
38 17
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %esi,%esi
jne    4fdf <push_context+0x1f>
mov    %rdx,0x8(%rsp)
mov    %rdi,(%rsp)
callq  4fd6 <push_context+0x16>
mov    0x8(%rsp),%rdx
mov    (%rsp),%rdi
addl   $0x1,0x0(%rip)        # 4fe6 <push_context+0x26>
mov    $0x4,%esi
add    $0x18,%rsp
jmpq   4ff4 <push_context+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
push_context (name, is_subshell, tempvars)
     char *name;
     int is_subshell;
     HASH_TABLE *tempvars;
{
  if (is_subshell == 0)
    push_dollar_vars ();
  variable_context++;
  push_var_context (name, 0x04, tempvars);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 6
6 7
7 7
8 7
9 8
10 9
11 10
12 9
13 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x8(%rdi),%rdi
callq  d9d <rc_inst_destroy+0xd>
mov    0x10(%rbx),%rdi
callq  da6 <rc_inst_destroy+0x16>
mov    0x18(%rbx),%rdi
pop    %rbx
jmpq   db0 <rc_stmt_destroy>
<<<sep_in_sample>>>
rc_inst_destroy (RC_INST *inst)
{
  anubis_regex_free (&inst->key);
  free (inst->key2);
  free (inst->arg);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 5
<<<sep_out_sample>>>
push   %r15
mov    %r9d,%r15d
push   %r14
mov    %r8,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # b418 <ch_ar_hdy+0x28>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  1f0 <ch_base_hdy>
mov    0x0(%rip),%rdi        # b42b <ch_ar_hdy+0x3b>
mov    0x0(%rip),%rbx        # b432 <ch_ar_hdy+0x42>
callq  b437 <ch_ar_hdy+0x47>
mov    0x70(%rsp),%ecx
mov    %r15d,0x18(%rsp)
mov    %r12d,%esi
mov    %r14,0x10(%rsp)
mov    %r13d,0x8(%rsp)
mov    $0xd,%r9d
movl   $0x1,(%rsp)
mov    $0x0,%r8d
mov    %rax,%rdx
mov    %ecx,0x20(%rsp)
mov    0x0(%rbp),%edi
mov    %rbx,%rcx
callq  b472 <ch_ar_hdy+0x82>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ch_ar_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_AR";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "+", 13, 1, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 11
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  be <help_me_cpp+0xe>
add    $0x8,%rsp
mov    %rax,%rdi
xor    %eax,%eax
jmpq   cc <help_me_cpp+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
help_me_cpp (void)
{
  printf (gettext ("C++ language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n")
  );
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_ctx_get (Gsasl_session * sctx)
{
  return sctx->ctx;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rdi,%rdx
mov    %rsi,%rdi
mov    $0x100,%esi
jmpq   60 <openssl_arcfour_crypt>
<<<sep_in_sample>>>
openssl_aes256_set_encrypt_key(void *ctx, const uint8_t *key)
{
  AES_set_encrypt_key(key, 256, ctx);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     90 <osip_mutex_lock+0x10>
jmpq   8a <osip_mutex_lock+0xa>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_mutex_lock (struct osip_mutex *_mut)
{
  osip_mutex_t *mut = (osip_mutex_t *) _mut;
  if (mut == ((void *)0))
    return -2;
  return pthread_mutex_lock (mut);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 7
6 7
7 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
test   %eax,%eax
je     100 <_linetrimstr_close+0x10>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rdi),%rdi
jmpq   108 <_linetrimstr_close+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_linetrimstr_close(void *data)
{
    struct _linetrimstr *s = data;
    if (s->noclose)
 return 0;
    return dico_stream_close(s->transport);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 7
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rsp,%rsi
callq  1343 <mu_url_is_same_scheme+0x13>
test   %eax,%eax
mov    %eax,%ebx
setne  %bpl
cmp    $0x1028,%eax
je     1368 <mu_url_is_same_scheme+0x38>
test   %bpl,%bpl
je     1368 <mu_url_is_same_scheme+0x38>
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
lea    0x8(%rsp),%rsi
mov    %r12,%rdi
callq  1375 <mu_url_is_same_scheme+0x45>
cmp    $0x1028,%eax
jne    13a8 <mu_url_is_same_scheme+0x78>
cmp    %eax,%ebx
jne    138a <mu_url_is_same_scheme+0x5a>
test   %bpl,%bpl
mov    $0x1,%eax
jne    1359 <mu_url_is_same_scheme+0x29>
mov    0x8(%rsp),%rsi
mov    (%rsp),%rdi
callq  1398 <mu_url_is_same_scheme+0x68>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    1359 <mu_url_is_same_scheme+0x29>
nopw   0x0(%rax,%rax,1)
test   %eax,%eax
je     137c <mu_url_is_same_scheme+0x4c>
jmp    1357 <mu_url_is_same_scheme+0x27>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_url_is_same_scheme (mu_url_t url1, mu_url_t url2) { const char *s1, *s2; int status1, status2; status1 = mu_url_sget_scheme (url1, &s1); if (status1 && status1 != (0x1000 +40)) return 0; status2 = mu_url_sget_scheme (url2, &s2); if (status2 && status2 != (0x1000 +40)) return 0; if (status1 && status1 == status2) return 1; return mu_c_strcasecmp (s1, s2) == 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  3d68 <get_kbinput+0x18>
cmp    $0x19a,%eax
je     3d60 <get_kbinput+0x10>
cmp    $0xffffffff,%eax
je     3d60 <get_kbinput+0x10>
cmp    0x0(%rip),%rbx        # 3d7b <get_kbinput+0x2b>
je     3d83 <get_kbinput+0x33>
add    $0x10,%rsp
pop    %rbx
retq   
mov    %eax,0xc(%rsp)
callq  3d8c <get_kbinput+0x3c>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_kbinput(WINDOW *win)
{
    int kbinput = (-1);
    while (kbinput == (-1) || kbinput == 0632)
 kbinput = parse_kbinput(win);
    if (win == edit)
 check_statusblank();
    return kbinput;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 4
8 4
9 4
10 4
11 6
12 6
13 9
14 9
15 9
16 9
17 7
18 7
19 9
20 9
21 9
22 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30 <stringprep_check_version+0x30>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <stringprep_check_version+0x13>
xor    %edx,%edx
test   %eax,%eax
mov    $0x0,%eax
cmovle %rax,%rdx
add    $0x8,%rsp
mov    %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
stringprep_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.33") <= 0)
    return "1.33";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 4
15 6
16 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     900 <gsl_blas_drot+0x30>
mov    $0x13,%ecx
mov    $0x1ee,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8f5 <gsl_blas_drot+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %rdi,%rsi
mov    %eax,%edi
callq  91a <gsl_blas_drot+0x4a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s)
{
  if (X->size == Y->size)
    {
      cblas_drot (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                  ((int)(Y->stride)), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 494, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 11
6 11
7 11
8 11
9 11
10 11
11 13
12 13
13 13
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 13
23 13
24 13
<<<sep_out_sample>>>
lea    -0x1(%rsi),%ecx
sub    $0x68,%rsp
cmp    $0x8,%ecx
ja     891 <make_dv+0xa1>
movq   $0x0,(%rsp)
mov    %esi,0x8(%rsp)
lea    0x10(%rsp),%rax
lea    0x18(%rsp,%rcx,8),%r10
jmp    853 <make_dv+0x63>
nopl   0x0(%rax,%rax,1)
mov    0x10(%rdx),%r9
lea    0x8(%rsi),%r8d
mov    %esi,%ecx
mov    %r8d,(%rdx)
cmp    $0x2f,%r8d
mov    (%r9,%rcx,1),%ecx
mov    %ecx,-0x4(%rax)
ja     8aa <make_dv+0xba>
mov    %r8d,%ecx
add    $0x10,%esi
add    $0x8,%rax
add    %r9,%rcx
mov    %esi,(%rdx)
mov    (%rcx),%ecx
mov    %ecx,-0x8(%rax)
cmp    %r10,%rax
je     884 <make_dv+0x94>
mov    (%rdx),%esi
cmp    $0x30,%esi
jb     820 <make_dv+0x30>
mov    0x8(%rdx),%rcx
mov    %rcx,%rsi
add    $0x8,%rcx
mov    %rcx,0x8(%rdx)
mov    (%rsi),%esi
mov    %esi,-0x4(%rax)
lea    0x8(%rcx),%rsi
add    $0x8,%rax
mov    %rsi,0x8(%rdx)
mov    (%rcx),%ecx
mov    %ecx,-0x8(%rax)
cmp    %r10,%rax
jne    853 <make_dv+0x63>
mov    %rsp,%rsi
callq  780 <copy_dv>
add    $0x68,%rsp
retq   
mov    $0x0,%ecx
mov    $0x14d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8aa <make_dv+0xba>
mov    0x8(%rdx),%rcx
jmp    86e <make_dv+0x7e>
<<<sep_in_sample>>>
make_dv(int own, int n, va_list arg)
{
      struct dv dv;
      int k;
      ((1 <= n && n <= 9) ? (void) (0) : __assert_fail ("1 <= n && n <= 9", "alglib2.c", 333, __PRETTY_FUNCTION__));
      dv.base = ((void *)0);
      dv.n = n;
      for (k = 0; k < n; k++)
      { dv.d[k].lo = __builtin_va_arg(arg,int);
         dv.d[k].up = __builtin_va_arg(arg,int);
      }
      return copy_dv(own, &dv);
}
<<<sep_in_sample>>>
1 5
2 2
3 5
4 5
5 6
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 10
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 8
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 10
38 10
39 10
40 10
41 10
42 8
43 8
44 12
45 12
46 13
47 13
48 5
49 5
50 5
51 5
52 5
53 5
54 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 220b <xmitEC+0xb>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xff,(%rax)
callq  221d <xmitEC+0x1d>
mov    0x0(%rip),%rax        # 2224 <xmitEC+0x24>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xf7,(%rax)
callq  2236 <xmitEC+0x36>
mov    $0xf7,%edx
mov    $0xff,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   224e <xmitEC+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
xmitEC (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 247; ring_supplied(&netoring, 1); }; };
  printoption ("SENT", 255, 247);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 5
16 4
17 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    %rdx,%r8
mov    0x8(%rsi),%rcx
mov    (%rax),%rdx
mov    0x10(%rsi),%rsi
jmpq   556 <gsl_vector_ushort_fprintf+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fprintf (FILE * stream, const gsl_vector_ushort * v,
                                const char *format)
{
  int status = gsl_block_ushort_raw_fprintf (stream,
                                                  v->data,
                                                  v->size,
                                                  v->stride,
                                                  format);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_add_1_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
callq  23d6 <extr_init+0x6>
test   %eax,%eax
sete   %al
xor    %edi,%edi
mov    %al,0x0(%rip)        # 23e3 <extr_init+0x13>
movzbl %al,%eax
add    %eax,0x0(%rip)        # 23ec <extr_init+0x1c>
add    %eax,0x0(%rip)        # 23f2 <extr_init+0x22>
callq  23f7 <extr_init+0x27>
mov    %eax,%ebx
mov    %eax,0x0(%rip)        # 23ff <extr_init+0x2f>
mov    0x0(%rip),%eax        # 2405 <extr_init+0x35>
test   %eax,%eax
jle    2418 <extr_init+0x48>
movl   $0x0,0x0(%rip)        # 2413 <extr_init+0x43>
pop    %rbx
retq   
nopl   (%rax)
mov    %ebx,%edi
callq  241f <extr_init+0x4f>
mov    %ebx,0x0(%rip)        # 2425 <extr_init+0x55>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extr_init (void)
{
  we_are_root = geteuid () == 0;
  same_permissions_option += we_are_root;
  same_owner_option += we_are_root;
  newdir_umask = umask (0);
  if (0 < same_permissions_option)
    current_umask = 0;
  else
    {
      umask (newdir_umask);
      current_umask = newdir_umask;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 6
6 3
7 4
8 4
9 5
10 6
11 6
12 6
13 7
14 7
15 7
16 8
17 14
18 14
19 14
20 11
21 11
22 12
23 14
24 14
25 14
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0x1,0x0(%rip)        # 1a89 <in_main_context+0x9>
sete   %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
in_main_context()
{
 ((void) (0));
 return (ctxt_level == 1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   f3 <gsl_vector_complex_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_fscanf (FILE * stream, gsl_vector_complex * v)
{
  int status = gsl_block_complex_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  251 <scram_print_server_final+0x11>
test   %al,%al
je     280 <scram_print_server_final+0x40>
mov    (%rbx),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %rbp,%rdi
callq  267 <scram_print_server_final+0x27>
test   %eax,%eax
jle    280 <scram_print_server_final+0x40>
xor    %eax,%eax
cmpq   $0x0,0x0(%rbp)
sete   %al
add    $0x8,%rsp
pop    %rbx
neg    %eax
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
scram_print_server_final (struct scram_server_final *sl, char **out)
{
  int n;
  if (!scram_valid_server_final (sl))
    return -1;
  n = asprintf (out, "v=%s", sl->verifier);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 7
22 10
23 10
24 10
25 10
26 5
27 10
28 10
29 10
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
jmpq   5d5 <taru_digs_delete+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_digs_delete(FILE_DIGS * digs)
{
 free(digs);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  f9 <xcalloc+0x9>
test   %rax,%rax
je     100 <xcalloc+0x10>
pop    %rbx
retq   
mov    %rbx,%rdi
pop    %rbx
jmpq   30 <fixup_null_alloc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  p = calloc (n, s);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 8
7 8
8 6
9 8
10 6
11 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     ac0 <mu_stream_get_transport2+0x10>
mov    0x60(%rdi),%rax
test   %rax,%rax
je     ac0 <mu_stream_get_transport2+0x10>
jmpq   *%rax
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_stream_get_transport2 (mu_stream_t stream,
     mu_transport_t *p1, mu_transport_t *p2)
{
  if (stream == ((void *)0) || stream->_get_transport2 == ((void *)0))
    return 22;
  return stream->_get_transport2 (stream, p1, p2);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 7
<<<sep_out_sample>>>
push   %rbp
movslq %edx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmpb   $0x2d,(%rcx)
je     3e0 <getlimit+0x40>
mov    %rdi,%rsi
mov    $0xa,%edx
mov    %rcx,%rdi
callq  3c4 <getlimit+0x24>
test   %rax,%rax
mov    $0x1,%ecx
je     3d7 <getlimit+0x37>
imul   %rbp,%rax
xor    %cl,%cl
mov    %rax,(%rbx)
add    $0x8,%rsp
mov    %ecx,%eax
pop    %rbx
pop    %rbp
retq   
add    $0x1,%rcx
movq   $0xffffffffffffffff,(%rsi)
mov    %rcx,(%rdi)
add    $0x8,%rsp
xor    %ecx,%ecx
pop    %rbx
mov    %ecx,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
getlimit (char **ptr, rlim_t *rlim, int mul)
{
  if (**ptr == '-')
    {
      *rlim = ((__rlim_t) -1);
      ++*ptr;
    }
  else
    {
      unsigned long val;
      val = strtoul (*ptr, ptr, 10);
      if (val == 0)
 return 1;
      *rlim = val * mul;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 11
10 11
11 11
12 11
13 12
14 13
15 12
16 14
17 16
18 14
19 17
20 17
21 17
22 17
23 17
24 6
25 5
26 6
27 17
28 16
29 17
30 17
31 17
32 17
33 17
<<<sep_out_sample>>>
push   %rbp
mov    $0x1006,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     a5c <mu_mailbox_set_locker+0x2c>
cmpq   $0x0,0x18(%rdi)
mov    %rsi,%rbp
je     a56 <mu_mailbox_set_locker+0x26>
lea    0x18(%rdi),%rdi
callq  a56 <mu_mailbox_set_locker+0x26>
mov    %rbp,0x18(%rbx)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_set_locker (mu_mailbox_t mbox, mu_locker_t locker)
{
  if (mbox == ((void *)0))
    return (0x1000 +6);
  if (mbox->locker)
    mu_locker_destroy (&mbox->locker);
  mbox->locker = locker;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 5
11 6
12 6
13 7
14 8
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  120 <mc_maclist_read_from_file>
mov    $0x0,%edi
mov    %rax,0x0(%rip)        # 3ea <mc_maclist_init+0x1a>
callq  120 <mc_maclist_read_from_file>
cmpq   $0x0,0x0(%rip)        # 3f7 <mc_maclist_init+0x27>
mov    %rax,0x0(%rip)        # 3fe <mc_maclist_init+0x2e>
je     410 <mc_maclist_init+0x40>
test   %rax,%rax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
retq   
mov    $0xffffffff,%eax
jmp    40b <mc_maclist_init+0x3b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mc_maclist_init (void)
{
 list_others = mc_maclist_read_from_file("/usr/local/share/macchanger" "/OUI.list");
 list_wireless = mc_maclist_read_from_file("/usr/local/share/macchanger" "/wireless.list");
 return (list_others && list_wireless)? 0 : -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 5
8 4
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%ebx
cmp    %rbx,0x0(%rip)        # 201d <language_help_me+0xd>
jbe    203d <language_help_me+0x2d>
nop
mov    $0xa,%edi
callq  202a <language_help_me+0x1a>
callq  *0x18(%rbx)
add    $0xa8,%rbx
cmp    %rbx,0x0(%rip)        # 203b <language_help_me+0x2b>
ja     2020 <language_help_me+0x10>
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
language_help_me (void)
{
  struct language *lang;
  for (lang = languages_0; lang < languages_N; lang++)
    {
      putchar ('\n');
      (*lang->lg_help_me) ();
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 6
7 6
8 7
9 4
10 4
11 4
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r10
cmp    (%rdi),%r10
mov    0x8(%rdi),%rax
je     24a0 <gsl_matrix_long_sub+0x40>
mov    $0x13,%ecx
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  248f <gsl_matrix_long_sub+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%r8
cmp    %rax,%r8
jne    2476 <gsl_matrix_long_sub+0x16>
test   %r10,%r10
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r12
je     2500 <gsl_matrix_long_sub+0xa0>
shl    $0x3,%r13
shl    $0x3,%r12
xor    %ebp,%ebp
xor    %ebx,%ebx
xor    %r11d,%r11d
nopl   (%rax)
test   %r8,%r8
je     24f1 <gsl_matrix_long_sub+0x91>
mov    %rbx,%rdx
mov    %rbp,%r9
add    0x18(%rdi),%rdx
add    0x18(%rsi),%r9
xor    %eax,%eax
nopl   (%rax)
mov    (%r9,%rax,8),%rcx
sub    %rcx,(%rdx,%rax,8)
add    $0x1,%rax
cmp    %r8,%rax
jne    24e0 <gsl_matrix_long_sub+0x80>
add    $0x1,%r11
add    %r13,%rbx
add    %r12,%rbp
cmp    %r10,%r11
jne    24c8 <gsl_matrix_long_sub+0x68>
xor    %eax,%eax
jmp    2494 <gsl_matrix_long_sub+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_sub (gsl_matrix_long * a, const gsl_matrix_long * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 57, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] -= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 16
47 16
48 16
49 14
50 14
51 14
52 14
53 14
54 21
55 21
56 21
<<<sep_out_sample>>>
push   %rbx
movslq %edi,%rbx
mov    0x0(,%rbx,8),%rsi
callq  11 <reset_signal+0x11>
andl   $0xfffffffe,0x0(,%rbx,4)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reset_signal (sig)
     int sig;
{
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~0x1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     920 <gsl_block_ulong_free+0x20>
mov    0x8(%rdi),%rdi
callq  912 <gsl_block_ulong_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   91b <gsl_block_ulong_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_ulong_free (gsl_block_ulong * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    $0x0,%ebx
jmp    238 <find_string_var+0x28>
nopl   (%rax)
add    $0x18,%rbx
mov    -0x18(%rbx),%rsi
add    $0x1,%ebp
test   %rsi,%rsi
je     250 <find_string_var+0x40>
mov    %r12,%rdi
callq  240 <find_string_var+0x30>
test   %eax,%eax
jne    228 <find_string_var+0x18>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_string_var (name)
     const char *name;
{
  register int i;
  for (i = 0; string_varlist[i].name; i++)
    if (strcasecmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 8
28 9
29 9
30 9
<<<sep_out_sample>>>
push   %rbx
xor    %ecx,%ecx
mov    $0x2000,%edx
mov    %edi,%ebx
sub    $0x2030,%rsp
lea    0xc(%rsp),%r9
lea    0x10(%rsp),%r8
lea    0x20(%rsp),%rsi
mov    %fs:0x28,%rax
mov    %rax,0x2028(%rsp)
xor    %eax,%eax
movl   $0x10,0xc(%rsp)
callq  1a0 <echo_dg+0x40>
test   %eax,%eax
js     1c0 <echo_dg+0x60>
lea    0x10(%rsp),%r8
lea    0x20(%rsp),%rsi
movslq %eax,%rdx
mov    $0x10,%r9d
xor    %ecx,%ecx
mov    %ebx,%edi
callq  1c0 <echo_dg+0x60>
mov    0x2028(%rsp),%rax
xor    %fs:0x28,%rax
jne    1dc <echo_dg+0x7c>
add    $0x2030,%rsp
pop    %rbx
retq   
callq  1e1 <echo_dg+0x81>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_dg (int fd, struct component const *comp)
{
  int rc;
  char buffer[8192];
  struct sockaddr sa;
  socklen_t size = sizeof sa;
  rc = recvfrom (fd, buffer, sizeof buffer, 0, &sa, &size);
  if (rc < 0)
    return;
  sendto (fd, buffer, rc, 0, &sa, sizeof sa);
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 2
5 2
6 7
7 7
8 7
9 2
10 2
11 2
12 6
13 7
14 8
15 8
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # 45 <usage+0x15>
callq  4a <usage+0x1a>
mov    %rbx,%rdi
mov    %rax,%rsi
xor    %eax,%eax
mov    %rbp,%rdx
callq  5a <usage+0x2a>
mov    $0x0,%edi
callq  64 <usage+0x34>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
pop    %rbp
jmpq   75 <usage+0x45>
<<<sep_in_sample>>>
usage (FILE *stream)
{
  fprintf (stream,
    gettext ("Usage: %s [-0 | --null] [--version] [--help]\n"),
    program_name);
  fputs (gettext ("\nReport bugs to <bug-findutils@gnu.org>.\n"), stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 3
7 4
8 3
9 3
10 3
11 3
12 3
13 6
14 6
15 7
16 6
17 6
18 7
19 7
20 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topsf_get_psf_prefix(TOPSF * topsf)
{
 return topsf->prefix_;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  475 <php__init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%rbp
mov    (%rax),%r13d
callq  483 <php__init_buffer+0x23>
mov    0x0(%rip),%rax        # 48a <php__init_buffer+0x2a>
mov    %r12,(%rbx)
movl   $0x1,0x3c(%rbx)
test   %rax,%rax
je     4a6 <php__init_buffer+0x46>
mov    0x0(%rip),%rdx        # 4a0 <php__init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     4b4 <php__init_buffer+0x54>
movl   $0x1,0x34(%rbx)
movl   $0x0,0x38(%rbx)
movl   $0x0,0x2c(%rbx)
mov    %r13d,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php__init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 php__flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jb     b00 <gsl_spmatrix_compare_idx+0x20>
mov    $0x1,%eax
ja     b08 <gsl_spmatrix_compare_idx+0x28>
xor    %edx,%edx
cmp    %rcx,%rsi
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopl   (%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spmatrix_compare_idx(const size_t ia, const size_t ja,
                         const size_t ib, const size_t jb)
{
  if (ia < ib)
    return -1;
  else if (ia > ib)
    return 1;
  else
    {
      if (ja < jb)
        return -1;
      else if (ja > jb)
        return 1;
      else
        return 0;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 6
5 12
6 12
7 12
8 12
9 12
10 12
11 12
12 5
13 5
14 17
15 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
callq  11 <_icvt_get_transport2+0x11>
test   %rbp,%rbp
je     1d <_icvt_get_transport2+0x1d>
mov    (%rax),%rax
mov    %rax,0x0(%rbp)
cmpq   $0x0,(%rbx)
je     2a <_icvt_get_transport2+0x2a>
movq   $0x0,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_icvt_get_transport2 (mu_stream_t stream,
       mu_transport_t *pt, mu_transport_t *pt2)
{
  struct icvt_stream *s = mu_stream_get_owner (stream);
  if (pt)
    *pt = s->stream;
  if (*pt2)
    *pt2 = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 10
15 10
16 10
17 10
18 10
19 10
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x2f,%edi
sete   %al
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
isdirpunct(int c)
{
 return (c == '/');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e8 <mu_folder_rename+0x18>
mov    0x80(%rdi),%rax
test   %rax,%rax
je     8e8 <mu_folder_rename+0x18>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
mov    $0x26,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_folder_rename (mu_folder_t folder, const char *oldname, const char *newname)
{
  if (folder == ((void *)0) || folder->_rename == ((void *)0))
    return 38;
  return folder->_rename (folder, oldname, newname);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
jmp    872 <swevent_s_arr_delete+0x12>
nopl   (%rax)
mov    %rax,%rdi
callq  870 <swevent_s_arr_delete+0x10>
mov    %ebx,%esi
mov    0x0(%rip),%rdi        # 879 <swevent_s_arr_delete+0x19>
lea    0x1(%rsi),%ebx
callq  881 <swevent_s_arr_delete+0x21>
test   %rax,%rax
jne    868 <swevent_s_arr_delete+0x8>
pop    %rbx
mov    0x0(%rip),%rdi        # 88e <swevent_s_arr_delete+0x2e>
jmpq   893 <swevent_s_arr_delete+0x33>
<<<sep_in_sample>>>
swevent_s_arr_delete(void)
{
 void * s;
 int i;
 i = 0;
 while((s=vplob_val(s_arrM, i++)) != ((void *)0)) strob_close((STROB*)s);
 vplob_close(s_arrM);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 8
14 7
15 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1d <close_stdout+0xd>
callq  22 <close_stdout+0x12>
test   %eax,%eax
jne    3d <close_stdout+0x2d>
mov    0x0(%rip),%rdi        # 2d <close_stdout+0x1d>
callq  32 <close_stdout+0x22>
test   %eax,%eax
jne    79 <close_stdout+0x69>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%edi
callq  47 <close_stdout+0x37>
mov    0x0(%rip),%rdi        # 4e <close_stdout+0x3e>
mov    %rax,%rbx
test   %rdi,%rdi
je     84 <close_stdout+0x74>
callq  5b <close_stdout+0x4b>
mov    %rax,%rbp
callq  63 <close_stdout+0x53>
mov    (%rax),%esi
mov    %rbx,%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  79 <close_stdout+0x69>
mov    0x0(%rip),%edi        # 7f <close_stdout+0x6f>
callq  84 <close_stdout+0x74>
callq  89 <close_stdout+0x79>
mov    (%rax),%esi
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  9c <close_stdout+0x8c>
jmp    79 <close_stdout+0x69>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (close_stream (stdout) != 0)
    {
      char const *write_error = gettext ("write error");
      if (file_name)
 error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
        write_error);
      else
 error (0, (*__errno_location ()), "%s", write_error);
      _exit (exit_failure);
    }
   if (close_stream (stderr) != 0)
     _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 13
9 13
10 13
11 13
12 15
13 15
14 15
15 15
16 5
17 5
18 6
19 5
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 14
33 14
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rcx,%rcx
push   %rbx
je     c9 <gsl_poly_dd_taylor+0x29>
nopl   0x0(%rax,%rax,1)
movq   $0x0,(%rdi,%rax,8)
movq   $0x0,(%r8,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    b0 <gsl_poly_dd_taylor+0x10>
lea    -0x8(%r8,%rcx,8),%r10
movsd  0x0(%rip),%xmm4        # d6 <gsl_poly_dd_taylor+0x36>
lea    -0x1(%rcx),%r11
mov    $0x2,%r9d
movsd  %xmm4,(%r10)
mov    %r11,%rax
movsd  0x0(%rip),%xmm3        # f0 <gsl_poly_dd_taylor+0x50>
lea    -0x1(%rax),%rbx
movsd  (%rsi),%xmm1
cmp    $0xffffffffffffffff,%rbx
movsd  %xmm1,(%rdi)
je     1aa <gsl_poly_dd_taylor+0x10a>
nopw   %cs:0x0(%rax,%rax,1)
movsd  -0x10(%rdx,%r9,8),%xmm2
cmp    %rax,%r11
movsd  (%r10),%xmm1
subsd  %xmm0,%xmm2
xorpd  %xmm3,%xmm1
mulsd  %xmm2,%xmm1
movsd  %xmm1,-0x8(%r10)
jbe    163 <gsl_poly_dd_taylor+0xc3>
nopl   0x0(%rax,%rax,1)
movsd  -0x10(%rdx,%r9,8),%xmm1
movsd  (%r8,%rax,8),%xmm2
add    $0x1,%rax
subsd  %xmm0,%xmm1
cmp    %rax,%r11
mulsd  (%r8,%rax,8),%xmm1
subsd  %xmm1,%xmm2
movsd  %xmm2,-0x8(%r8,%rax,8)
jne    138 <gsl_poly_dd_taylor+0x98>
xor    %eax,%eax
cmp    %rbx,%rcx
jbe    191 <gsl_poly_dd_taylor+0xf1>
nopw   0x0(%rax,%rax,1)
movsd  -0x8(%r10,%rax,8),%xmm1
mulsd  -0x8(%rsi,%r9,8),%xmm1
addsd  (%rdi,%rax,8),%xmm1
movsd  %xmm1,(%rdi,%rax,8)
add    $0x1,%rax
cmp    %rax,%r9
jne    170 <gsl_poly_dd_taylor+0xd0>
mov    %rbx,%rax
sub    $0x8,%r10
add    $0x1,%r9
lea    -0x1(%rax),%rbx
cmp    $0xffffffffffffffff,%rbx
jne    110 <gsl_poly_dd_taylor+0x70>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_poly_dd_taylor (double c[], double xp,
                    const double dd[], const double xa[], size_t size,
                    double w[])
{
  size_t i, j;
  for (i = 0; i < size; i++)
    {
      c[i] = 0.0;
      w[i] = 0.0;
    }
  w[size - 1] = 1.0;
  c[0] = dd[0];
  for (i = size - 1; i-- > 0;)
    {
      w[i] = -w[i + 1] * (xa[size - 2 - i] - xp);
      for (j = i + 1; j < size - 1; j++)
        {
          w[j] = w[j] - w[j + 1] * (xa[size - 2 - i] - xp);
        }
      for (j = i; j < size; j++)
        {
          c[j - i] += w[j] * dd[size - i - 1];
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 4
4 6
5 6
6 8
7 9
8 6
9 6
10 6
11 11
12 11
13 13
14 13
15 11
16 13
17 15
18 13
19 12
20 13
21 12
22 13
23 13
24 15
25 16
26 15
27 15
28 15
29 15
30 15
31 16
32 16
33 18
34 18
35 18
36 18
37 16
38 18
39 18
40 18
41 16
42 20
43 20
44 20
45 20
46 22
47 22
48 22
49 22
50 22
51 20
52 20
53 20
54 20
55 20
56 13
57 13
58 13
59 26
60 26
61 26
62 26
<<<sep_out_sample>>>
movl   $0x0,0x1258(%rdi)
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
clearRadarInfo(craft * c)
{
 c->rtop = 0;
 return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    %rdi,%rax
push   %rbx
mov    %rdx,%rbx
mov    %rsi,%rdi
mov    %rax,%rdx
mov    %rbx,%rsi
callq  8e0 <insert_num>
test   %rax,%rax
je     a50 <parse_uid+0x40>
cmpq   $0x63,0x40(%rax)
movss  0x0(%rip),%xmm0        # a37 <parse_uid+0x27>
ja     a41 <parse_uid+0x31>
movss  0x0(%rip),%xmm0        # a41 <parse_uid+0x31>
movss  %xmm0,0x24(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
subl   $0x1,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *p = insert_num (argv, arg_ptr, entry);
  if (p)
    {
      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
      return 1;
    }
  else
    {
      --*arg_ptr;
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 7
16 14
17 14
18 14
19 11
20 12
21 14
22 14
23 14
<<<sep_out_sample>>>
push   %rbx
mov    0x50(%rdi),%rbx
mov    $0x0,%edi
callq  41f <_wsplt_alloc_die+0xf>
mov    %rax,%rdi
xor    %eax,%eax
callq  *%rbx
callq  42b <_wsplt_alloc_die+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_wsplt_alloc_die (struct wordsplit *wsp)
{
  wsp->ws_error (gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
fldt   0x8(%rsp)
fstpt  -0x18(%rsp)
fldt   -0x18(%rsp)
retq   
<<<sep_in_sample>>>
gsl_coerce_long_double (const long double x)
{
  volatile long double y;
  y = x;
  return y;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c6f <dbop_getoption+0xf>
test   %rax,%rax
mov    %rax,%rbx
je     ccf <dbop_getoption+0x6f>
mov    %r12,%rdi
callq  c7f <dbop_getoption+0x1f>
cmp    0x18(%rbp),%eax
jg     cd3 <dbop_getoption+0x73>
cltq   
add    %rax,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     cb3 <dbop_getoption+0x53>
callq  c96 <dbop_getoption+0x36>
mov    (%rax),%rax
jmp    cac <dbop_getoption+0x4c>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%ebp
test   %bpl,%bpl
je     cb3 <dbop_getoption+0x53>
testb  $0x20,0x1(%rax,%rbp,2)
jne    ca0 <dbop_getoption+0x40>
mov    $0x400,%edx
mov    %rbx,%rsi
mov    $0x0,%edi
callq  cc5 <dbop_getoption+0x65>
mov    $0x0,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    cca <dbop_getoption+0x6a>
mov    $0x0,%edi
xor    %eax,%eax
callq  cdf <dbop_getoption+0x7f>
nop
<<<sep_in_sample>>>
dbop_getoption(DBOP *dbop, const char *key)
{
 static char buf[1024];
 const char *p;
 int keysize;
 if ((p = dbop_get(dbop, key)) == ((void *)0))
  return ((void *)0);
 keysize = strlen(key);
 if (dbop->lastsize < keysize)
  die("invalid format (dbop_getoption).");
 for (p += keysize; *p && ((*__ctype_b_loc ())[(int) (((unsigned char)*p))] & (unsigned short int) _ISspace); p++)
  ;
 strlimcpy(buf, p, sizeof(buf));
 return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 6
8 6
9 6
10 8
11 8
12 9
13 9
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 13
30 13
31 13
32 13
33 14
34 15
35 15
36 15
37 15
38 7
39 7
40 10
41 10
42 10
43 10
<<<sep_out_sample>>>
test   %edi,%edi
js     808 <close_buffered_fd+0x38>
cmp    0x0(%rip),%edi        # 7da <close_buffered_fd+0xa>
jge    800 <close_buffered_fd+0x30>
mov    0x0(%rip),%rax        # 7e3 <close_buffered_fd+0x13>
test   %rax,%rax
je     800 <close_buffered_fd+0x30>
movslq %edi,%rdx
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     800 <close_buffered_fd+0x30>
mov    %rax,%rdi
jmpq   7fc <close_buffered_fd+0x2c>
nopl   0x0(%rax)
jmpq   805 <close_buffered_fd+0x35>
nopl   (%rax)
sub    $0x8,%rsp
callq  811 <close_buffered_fd+0x41>
movl   $0x9,(%rax)
mov    $0xffffffff,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_buffered_fd (fd)
     int fd;
{
  if (fd < 0)
    {
      (*__errno_location ()) = 9;
      return -1;
    }
  if (fd >= nbuffers || !buffers || !buffers[fd])
    return (close (fd));
  return (close_buffered_stream (buffers[fd]));
}
<<<sep_in_sample>>>
1 4
2 4
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 11
13 11
14 11
15 10
16 10
17 3
18 6
19 6
20 12
21 12
22 12
23 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edi,%ebp
mov    0x0(%rip),%rdi        # bbc <access_log+0xc>
push   %rbx
test   %rdi,%rdi
je     bf0 <access_log+0x40>
mov    %rsi,%r12
mov    $0x0,%esi
callq  bcf <access_log+0x1f>
test   %rax,%rax
mov    %rax,%rbx
je     bf8 <access_log+0x48>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rax,%rdi
callq  be4 <access_log+0x34>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   bf0 <access_log+0x40>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x0(%rip),%rbp        # bff <access_log+0x4f>
mov    $0x0,%edi
callq  c09 <access_log+0x59>
mov    %rax,%rbx
callq  c11 <access_log+0x61>
mov    %rbx,%rdx
mov    %rbp,%rcx
mov    (%rax),%esi
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x4,%edi
xor    %eax,%eax
jmpq   c29 <access_log+0x79>
nopl   0x0(%rax)
<<<sep_in_sample>>>
access_log(int argc, char **argv)
{
    FILE *fp;
    if (!access_log_file)
 return;
    fp = fopen(access_log_file, "a");
    if (!fp) {
 dico_log(4, (*__errno_location ()), gettext("cannot open access log file `%s'"),
   access_log_file);
 return;
    }
    format_access_log(fp, argc, argv);
    fclose(fp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 4
9 6
10 6
11 7
12 6
13 7
14 12
15 12
16 12
17 12
18 13
19 14
20 14
21 14
22 13
23 14
24 14
25 14
26 14
27 14
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 14
37 14
38 14
39 8
40 8
41 8
42 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0xf,%sil
jne    1b4 <openssl_aes_encrypt+0x54>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     1a9 <openssl_aes_encrypt+0x49>
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %r12,%rdi
mov    $0x1,%ecx
mov    %r13,%rdx
add    $0x10,%rbp
add    $0x10,%r12
callq  1a3 <openssl_aes_encrypt+0x43>
sub    $0x10,%rbx
jne    188 <openssl_aes_encrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0x69,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1cd <openssl_aes_encrypt+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
openssl_aes_encrypt(const void *ctx, size_t length,
      uint8_t *dst, const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "nettle-openssl.c", 105, __PRETTY_FUNCTION__));
  while (length)
    {
      AES_ecb_encrypt(src, dst, ctx, 1);
      length -= 16;
      dst += 16;
      src += 16;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
test   %r8,%r8
je     294 <gsl_stats_float_wkurtosis_m_sd+0x84>
xorps  %xmm4,%xmm4
shl    $0x2,%rsi
shl    $0x2,%rcx
xor    %eax,%eax
movss  %xmm4,-0x18(%rsp)
flds   -0x18(%rsp)
fld    %st(0)
xchg   %ax,%ax
movss  (%rdi),%xmm3
ucomiss %xmm4,%xmm3
jbe    272 <gsl_stats_float_wkurtosis_m_sd+0x62>
movss  (%rdx),%xmm2
cvtps2pd %xmm2,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x18(%rsp)
fldl   -0x18(%rsp)
movss  %xmm3,-0x18(%rsp)
flds   -0x18(%rsp)
fadd   %st,%st(2)
fld    %st(1)
fmul   %st(2),%st
fmul   %st(2),%st
fmulp  %st,%st(2)
fxch   %st(1)
fsub   %st(3),%st
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    230 <gsl_stats_float_wkurtosis_m_sd+0x20>
fstp   %st(0)
fsubs  0x0(%rip)        # 289 <gsl_stats_float_wkurtosis_m_sd+0x79>
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
movsd  0x0(%rip),%xmm0        # 29c <gsl_stats_float_wkurtosis_m_sd+0x8c>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_float_wkurtosis_m_sd (const float w[], const size_t wstride,
                                    const float data[],
                                    const size_t stride,
                                    const size_t n,
                                    const double wmean,
                                    const double wsd)
{
  long double wavg = 0, kurtosis;
  long double W = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      float wi = w[i * wstride];
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wavg += (x * x * x * x - wavg) * (wi / W);
      }
    }
  kurtosis = wavg - 3.0;
  return kurtosis;
}
<<<sep_in_sample>>>
1 11
2 11
3 9
4 9
5 15
6 11
7 9
8 9
9 9
10 9
11 13
12 14
13 14
14 15
15 15
16 15
17 15
18 15
19 15
20 16
21 16
22 16
23 17
24 17
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 11
34 11
35 11
36 11
37 11
38 11
39 11
40 11
41 11
42 11
43 11
44 22
45 22
<<<sep_out_sample>>>
xor    %r9d,%r9d
mov    $0x0,%r8d
mov    $0x2,%ecx
mov    $0x1,%edx
mov    $0x2,%esi
mov    $0x0,%edi
jmpq   b2 <ancestors_new+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ancestors_new (void)
{
  return da_new ("Ancestors", 2,
   da_linear, 2,
   (da_print_func_t) da_str_print, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_result_count(dico_result_t rp)
{
    return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # af7 <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     b02 <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
mov    0x8(%rax),%rax
movl   $0x0,0x0(%rip)        # b10 <rl_on_new_line+0x20>
movl   $0x0,0x0(%rip)        # b1a <rl_on_new_line+0x2a>
movl   $0x0,0x0(%rip)        # b24 <rl_on_new_line+0x34>
movl   $0x0,0x0(%rip)        # b2e <rl_on_new_line+0x3e>
test   %rax,%rax
je     b40 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # b4a <rl_on_new_line+0x5a>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 7
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 11
17 11
18 11
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # c1d <il_downcase_word+0xd>
mov    0x18(%rax),%rbx
cmp    0x38(%rax),%rbx
jb     c30 <il_downcase_word+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
xor    %eax,%eax
callq  c37 <il_downcase_word+0x27>
mov    0x0(%rip),%rax        # c3e <il_downcase_word+0x2e>
cmp    0x18(%rax),%rbx
jae    c6c <il_downcase_word+0x5c>
nopl   0x0(%rax)
mov    %rbx,%rbp
add    0x58(%rax),%rbp
add    $0x1,%rbx
movsbl 0x0(%rbp),%edi
callq  c5c <il_downcase_word+0x4c>
mov    %al,0x0(%rbp)
mov    0x0(%rip),%rax        # c66 <il_downcase_word+0x56>
cmp    %rbx,0x18(%rax)
ja     c48 <il_downcase_word+0x38>
movl   $0x12,0x10(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_downcase_word()
{
    if (il->point < il->length)
    {
 size_t i;
 size_t previous_point = il->point;
 il_forward_word();
 for (i = previous_point; i < il->point; i++)
     il->buffer[i] = tolower((int)il->buffer[i]);
 il->last_operation = 18;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 12
9 12
10 12
11 12
12 12
13 7
14 7
15 8
16 8
17 8
18 8
19 9
20 9
21 8
22 9
23 9
24 9
25 8
26 8
27 8
28 10
29 12
30 12
31 12
32 12
33 12
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x18,%rsp
mov    %r8,0x8(%rsp)
callq  104 <xlat_kw+0x24>
test   %rbp,%rbp
mov    %rax,%r12
je     174 <xlat_kw+0x94>
mov    %rbp,%rdi
callq  114 <xlat_kw+0x34>
cmp    %rax,%r12
mov    %rax,%r14
jbe    174 <xlat_kw+0x94>
mov    %rax,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  12a <xlat_kw+0x4a>
test   %eax,%eax
jne    174 <xlat_kw+0x94>
mov    (%rbx),%rdi
add    %r14,%r13
sub    %r14,%r12
test   %rdi,%rdi
je     17c <xlat_kw+0x9c>
nopl   0x0(%rax)
mov    0x8(%rbx),%rbp
cmp    %r12,%rbp
ja     170 <xlat_kw+0x90>
mov    %rbp,%rdx
mov    %r13,%rsi
callq  154 <xlat_kw+0x74>
test   %eax,%eax
mov    %eax,%r14d
jne    170 <xlat_kw+0x90>
add    %r13,%rbp
movsbl 0x0(%rbp),%edi
test   %dil,%dil
je     198 <xlat_kw+0xb8>
callq  16c <xlat_kw+0x8c>
test   %al,%al
je     198 <xlat_kw+0xb8>
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
jne    140 <xlat_kw+0x60>
mov    $0x1,%r14d
add    $0x18,%rsp
mov    %r14d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    0x10(%rbx),%eax
mov    %eax,(%r15)
mov    0x8(%rsp),%rax
mov    %rbp,(%rax)
jmp    182 <xlat_kw+0xa2>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xlat_kw (const char *s, const char *pfx,
  struct rmt_kw const *kw, int *valp, const char **endp)
{
  size_t slen = strlen (s);
  if (pfx)
    {
      size_t pfxlen = strlen (pfx);
      if (slen > pfxlen && memcmp (s, pfx, pfxlen) == 0)
 {
   s += pfxlen;
   slen -= pfxlen;
 }
    }
  for (; kw->name; kw++)
    {
      if (slen >= kw->len
   && memcmp (kw->name, s, kw->len) == 0
   && !(s[kw->len] && c_isalnum (s[kw->len])))
 {
   *valp = kw->value;
   *endp = s + kw->len;
   return 0;
 }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 5
15 4
16 5
17 7
18 7
19 8
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 14
29 10
30 11
31 14
32 14
33 14
34 16
35 16
36 16
37 17
38 17
39 17
40 17
41 17
42 17
43 18
44 18
45 18
46 18
47 18
48 18
49 18
50 14
51 14
52 14
53 14
54 25
55 26
56 26
57 26
58 26
59 26
60 26
61 26
62 26
63 26
64 26
65 20
66 20
67 21
68 21
69 22
70 22
<<<sep_out_sample>>>
push   %r12
push   %rbp
lea    -0x1(%rdi),%ebp
test   %ebp,%ebp
push   %rbx
jle    4a <main+0x4a>
lea    0x8(%rsi),%r12
mov    %ebp,%edi
mov    %r12,%rsi
callq  19 <main+0x19>
lea    0x1(%rax),%rdi
callq  22 <main+0x22>
test   %rax,%rax
mov    %rax,%rbx
je     60 <main+0x60>
mov    %r12,%rdx
mov    %ebp,%esi
mov    %rax,%rdi
callq  37 <main+0x37>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  48 <main+0x48>
jmp    40 <main+0x40>
mov    $0x0,%edi
callq  54 <main+0x54>
mov    $0x0,%edi
callq  5e <main+0x5e>
jmp    4a <main+0x4a>
mov    0x0(%rip),%rcx        # 67 <main+0x67>
mov    $0x13,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  7b <main+0x7b>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
main(int argc, char *argv[])
{
  char *msg;
  unsigned long l;
  argv++;
  argc--;
  if (argc > 0)
    {
      l = total_len(argc, argv);
      msg = malloc(l + 1u);
      if (((void *)0) == msg)
        {
          fprintf(stderr, "Ran out of memory.\n");
          return 1;
        }
      concat(msg, argc, argv);
      for (;;)
        puts(msg);
    }
  else
    {
      for (;;)
        puts("yes");
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 7
5 2
6 7
7 5
8 9
9 9
10 9
11 10
12 10
13 11
14 10
15 11
16 16
17 16
18 16
19 16
20 16
21 18
22 18
23 18
24 23
25 23
26 23
27 23
28 23
29 13
30 13
31 13
32 13
33 13
34 26
35 26
36 26
37 26
38 26
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  11ce <list_style_sheets_short+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  11d9 <list_style_sheets_short+0x19>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  11e6 <list_style_sheets_short+0x26>
mov    0x0(%rip),%rax        # 11ed <list_style_sheets_short+0x2d>
mov    %rbx,%rdi
mov    $0x0,%edx
pop    %rbx
mov    0x10(%rax),%rsi
jmpq   11ff <list_style_sheets_short+0x3f>
nop
<<<sep_in_sample>>>
list_style_sheets_short (FILE * stream)
{
  fputs (gettext ("Known Style Sheets"), stream);
  _IO_putc ('\n', stream);
  pw_lister_on_suffix (stream, job->common.path, ".ssh");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 6
15 5
16 5
17 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # a8 <rl_free_undo_list+0x8>
mov    %rbx,%rdi
callq  b0 <rl_free_undo_list+0x10>
mov    %rbx,%rsi
xor    %edx,%edx
mov    $0xffffffff,%edi
pop    %rbx
movq   $0x0,0x0(%rip)        # c6 <rl_free_undo_list+0x26>
jmpq   cb <rl_free_undo_list+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_free_undo_list ()
{
  UNDO_LIST *release, *orig_list;
  orig_list = rl_undo_list;
  _rl_free_undo_list (rl_undo_list);
  rl_undo_list = (UNDO_LIST *)((void *)0);
  _hs_replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)((void *)0));
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 7
8 8
9 6
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 13b <badDiffOutput+0xb>
mov    %rdi,%rdx
mov    $0x0,%esi
mov    0xd0(%rax),%rdi
xor    %eax,%eax
callq  151 <badDiffOutput+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
badDiffOutput (char const *buf)
{
  generic_fatal ((top->repository. filename), "bad diff output line: %s", buf);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
mov    0xc8(%rdi),%eax
cmp    %esi,%eax
jne    1ca8 <swvarfs_u_get_linkname+0x18>
mov    0xc0(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    0x0(%rip),%rdi        # 1cb3 <swvarfs_u_get_linkname+0x23>
mov    $0x0,%r9d
mov    %eax,(%rsp)
mov    $0x9ec,%r8d
mov    $0x0,%ecx
xor    %edx,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1cd5 <swvarfs_u_get_linkname+0x45>
xor    %eax,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
swvarfs_u_get_linkname(SWVARFS * swvarfs, int fd)
{
 if (fd != swvarfs->u_fdM){
  { fprintf(stderr, "INTERNAL ERROR: " "[%d]: %18s:%-5d , %s : " "error, expecting %d.\n" "\n", (int)0, "swvarfs.c", 2540, __FUNCTION__, swvarfs->u_fdM); };
  return ((void *)0);
 }
 return swvarfs->g_linkname_;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 7
5 7
6 7
7 2
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 5
18 8
19 8
20 8
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x30(%rdi),%rdi
callq  773 <xformat_set_group_systempair+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    780 <xformat_set_group_systempair+0x20>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbp,%rdi
callq  788 <xformat_set_group_systempair+0x28>
test   %eax,%eax
jne    779 <xformat_set_group_systempair+0x19>
mov    0x30(%r12),%rdi
mov    %rbp,%rsi
callq  799 <xformat_set_group_systempair+0x39>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
xformat_set_group_systempair(XFORMAT * xux, char * name)
{
 int ret;
 ret = ahs_set_group_systempair(xux->ahsM, name);
 if (ret && is_all_digits(name) == 0) {
  ahs_set_tar_groupname(xux->ahsM, name);
 }
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 4
10 5
11 9
12 9
13 9
14 9
15 9
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
movzbl 0x19(%rdx),%eax
mov    %rcx,%r10
mov    %eax,%ecx
and    $0xf,%ecx
cmp    $0xc,%cl
ja     a5 <CDB___db_pgout+0x35>
mov    $0x1,%r8d
shl    %cl,%r8
test   $0x12f8,%r8d
jne    b8 <CDB___db_pgout+0x48>
test   $0x105,%r8d
jne    d0 <CDB___db_pgout+0x60>
test   $0xc00,%r8d
jne    c0 <CDB___db_pgout+0x50>
movzbl %al,%edx
mov    $0x0,%esi
jmpq   b2 <CDB___db_pgout+0x42>
nopw   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   c0 <CDB___db_pgout+0x50>
mov    %r10,%rcx
jmpq   c8 <CDB___db_pgout+0x58>
nopl   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   d8 <CDB___db_pgout+0x68>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_pgout(dbenv, pg, pp, cookie)
 DB_ENV *dbenv;
 db_pgno_t pg;
 void *pp;
 DBT *cookie;
{
 switch (((((PAGE *)pp)->type) & 0x0f)) {
 case 2:
 case 8:
 case 0:
  return (CDB___ham_pgout(dbenv, pg, pp, cookie));
 case 9:
 case 3:
 case 4:
 case 5:
 case 12:
 case 6:
 case 7:
  return (CDB___bam_pgout(dbenv, pg, pp, cookie));
 case 10:
 case 11:
  return (CDB___qam_pgin_out(dbenv, pg, pp, cookie));
 default:
  break;
 }
 return (CDB___db_unknown_type(dbenv, "CDB___db_pgout", ((PAGE *)pp)->type));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 26
16 26
17 26
18 26
19 19
20 19
21 22
22 22
23 22
24 11
25 11
26 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # c7 <write_stdout+0x7>
retq   
<<<sep_in_sample>>>
write_stdout (void)
{
  FILE * output_file = stdout;
  return output_file;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     10 <__ris+0x10>
cmp    %rsi,(%rdi)
sete   %al
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
__ris (__dhp bpx, __pty p)
{
  if (bpx == 0L || bpx->pp != p)
    return (0);
  return (1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 6
<<<sep_out_sample>>>
mov    (%rdi),%rsi
mov    0x8(%rdi),%rcx
xor    %eax,%eax
fldt   0x8(%rsp)
mov    0x10(%rdi),%rdx
shl    $0x4,%rcx
test   %rsi,%rsi
je     1164 <gsl_vector_long_double_set_all+0x34>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
fld    %st(0)
fstpt  (%rdx)
add    %rcx,%rdx
cmp    %rsi,%rax
jne    1150 <gsl_vector_long_double_set_all+0x20>
fstp   %st(0)
jmp    1170 <gsl_vector_long_double_set_all+0x40>
fstp   %st(0)
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_set_all (gsl_vector_long_double * v, long double x)
{
  long double * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long double *) (data + 1 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
jmpq   5e5 <has_blank_mbchars+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
has_blank_mbchars(const char *s)
{
    ((void) (0));
 return has_blank_chars(s);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
movzbl 0x5e0(%rdi),%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dfaisfast (struct dfa const *d)
{
  return d->fast;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 98a <gsl_matrix_const_ptr+0xa>
test   %eax,%eax
je     999 <gsl_matrix_const_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    9b0 <gsl_matrix_const_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    9d0 <gsl_matrix_const_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x151,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9c9 <gsl_matrix_const_ptr+0x49>
xor    %eax,%eax
jmp    9a9 <gsl_matrix_const_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x155,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9e9 <gsl_matrix_const_ptr+0x69>
xor    %eax,%eax
jmp    9a9 <gsl_matrix_const_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_double.h", 337, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_double.h", 341, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (const double *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    0x50(%rdi),%rbp
test   %rbp,%rbp
je     c38 <amd_destroy+0x98>
mov    %rbp,%rdi
xor    %ebx,%ebx
callq  b20 <amd_pool_flush>
mov    0x40(%r12),%rdi
callq  bc8 <amd_destroy+0x28>
cmpq   $0x0,0x68(%rbp)
je     bf8 <amd_destroy+0x58>
nop
mov    0x78(%rbp),%rax
mov    (%rax,%rbx,8),%rsi
lea    0x38(%rsi),%rdi
callq  be1 <amd_destroy+0x41>
mov    0x78(%rbp),%rax
mov    (%rax,%rbx,8),%rdi
add    $0x1,%rbx
callq  bf2 <amd_destroy+0x52>
cmp    %rbx,0x68(%rbp)
ja     bd0 <amd_destroy+0x30>
mov    0x78(%rbp),%rdi
callq  c01 <amd_destroy+0x61>
mov    0x90(%rbp),%rdi
test   %rdi,%rdi
je     c12 <amd_destroy+0x72>
callq  c12 <amd_destroy+0x72>
mov    %rbp,%rdi
callq  c1a <amd_destroy+0x7a>
movq   $0x0,0x50(%r12)
mov    0x40(%r12),%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c31 <amd_destroy+0x91>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
amd_destroy (mu_mailbox_t mailbox)
{
  struct _amd_data *amd = mailbox->data;
  size_t i;
  if (!amd)
    return;
  amd_pool_flush (amd);
  mu_monitor_wrlock (mailbox->monitor);
  for (i = 0; i < amd->msg_count; i++)
    {
      mu_message_destroy (&amd->msg_array[i]->message, amd->msg_array[i]);
      free (amd->msg_array[i]);
    }
  free (amd->msg_array);
  if (amd->name)
    free (amd->name);
  free (amd);
  mailbox->data = ((void *)0);
  mu_monitor_unlock (mailbox->monitor);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 5
8 7
9 9
10 7
11 8
12 8
13 9
14 9
15 9
16 11
17 11
18 11
19 11
20 12
21 12
22 9
23 12
24 9
25 9
26 14
27 14
28 15
29 15
30 15
31 16
32 17
33 17
34 18
35 19
36 20
37 20
38 20
39 19
40 19
41 20
42 20
43 20
44 20
45 20
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0x1,(%rdi)
je     2f60 <dis_shouldTransmitPDUs+0x10>
repz retq 
nopl   0x0(%rax)
mov    0x4(%rdi),%edx
cmp    $0x1,%edx
je     2f80 <dis_shouldTransmitPDUs+0x30>
cmp    $0x2,%edx
jne    2f57 <dis_shouldTransmitPDUs+0x7>
mov    0x18(%rdi),%edx
xor    %eax,%eax
test   %edx,%edx
setne  %al
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dis_shouldTransmitPDUs ( Entity_t *e )
{
 int result = 0;
 if (e->local == 1) {
  if ( e->state == 1 ) {
   result = 1;
  }
  else if ( e->state == 2 &&
      e->emit_while_frozen ) {
   result = 1;
  }
 }
 return result;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 14
5 14
6 5
7 5
8 5
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 6
18 14
19 14
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    0x8(%rsi),%rdx
mov    (%rdi),%rdi
mov    (%rsi),%rsi
addq   $0x1,0x0(%rip)        # 566 <compare_rev_prefix+0x16>
mov    0x10(%rax),%rax
mov    0x10(%rdx),%rdx
cmp    %rax,%rdx
cmova  %rax,%rdx
jmpq   57a <compare_rev_prefix+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
compare_rev_prefix(const void *a, const void *b)
{
    const struct rev_entry *pkey = a;
    const struct rev_entry *pelt = b;
    size_t wordlen = pkey->ptr->wordlen;
    if (pelt->ptr->wordlen < wordlen)
 wordlen = pelt->ptr->wordlen;
    compare_count++;
    return utf8_strncasecmp(pkey->word, pelt->word, wordlen);
}
<<<sep_in_sample>>>
1 5
2 6
3 9
4 9
5 8
6 5
7 6
8 6
9 6
10 9
11 9
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %edi,%esi
xor    %edi,%edi
jmpq   125c <quotearg_style+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
quotearg_style (enum quoting_style s, char const *arg)
{
  return quotearg_n_style (0, s, arg);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdi
callq  631d <dfamustfree+0xd>
mov    %rbx,%rdi
pop    %rbx
jmpq   6326 <dfamustfree+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dfamustfree (struct dfamust *dm)
{
  free (dm->must);
  free (dm);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzwl (%rdi),%edx
cmp    $0x1,%dx
je     565 <prepare_sa+0x25>
cmp    $0x2,%dx
jne    570 <prepare_sa+0x30>
mov    0x4(%rdi),%edi
callq  562 <prepare_sa+0x22>
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%bpl
pop    %rbx
mov    %ebp,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
prepare_sa (struct sockaddr *sa)
{
  switch (sa->sa_family)
    {
    case 2:
      {
 struct sockaddr_in *s_in = (struct sockaddr_in *)sa;
 s_in->sin_addr.s_addr = ntohl (s_in->sin_addr.s_addr);
 break;
      }
    case 1:
      break;
    default:
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 16
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 8
12 8
13 8
14 17
15 17
16 17
17 17
18 17
19 17
20 17
21 14
22 17
23 17
24 17
25 17
26 17
<<<sep_out_sample>>>
push   %rbp
and    $0x7fff,%esi
mov    %rdi,%rbp
mov    %esi,%ecx
push   %rbx
mov    $0x1,%ebx
shl    %cl,%rbx
sub    $0x8,%rsp
mov    0x38(%rdi),%rax
test   %rbx,0x20(%rax)
je     9200 <_jit_unget_reg+0x70>
testb  $0x8,0x10(%rax)
je     9220 <_jit_unget_reg+0x90>
movslq %esi,%rdx
mov    0xc0(%rax),%rax
mov    %rdx,%rcx
shl    $0x4,%rcx
testb  $0x20,0x0(%rcx)
mov    0x38(%rax),%rax
movslq (%rax,%rdx,4),%rcx
mov    $0xf,%edx
je     9210 <_jit_unget_reg+0x80>
callq  91e5 <_jit_unget_reg+0x55>
mov    0x38(%rbp),%rax
not    %rbx
and    %rbx,0x20(%rax)
and    %rbx,0x18(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
not    %rbx
and    %rbx,0x18(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
callq  9215 <_jit_unget_reg+0x85>
jmp    91e5 <_jit_unget_reg+0x55>
nopw   0x0(%rax,%rax,1)
callq  9225 <_jit_unget_reg+0x95>
jmp    91e5 <_jit_unget_reg+0x55>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_unget_reg(jit_state_t *_jit, jit_int32_t regno)
{
    regno = ((regno) & 0x00007fff);
    if ((*(&_jit->comp->regsav) & (1LL << (regno)))) {
 if (_jit->comp->emit) {
     if (((_rvs[regno].spec) & 0xffff0000) & 0x20000000)
  _emit_ldxi(_jit, regno, _RBP, _jit->comp->function->regoff[regno]);
     else
  _emit_ldxi_d(_jit, regno, _RBP, _jit->comp->function->regoff[regno]);
 }
 else
     _jit_load(_jit, regno);
 (*(&_jit->comp->regsav) &= ~(1LL << (regno)));
    }
    ((void) (0));
    (*(&_jit->comp->regarg) &= ~(1LL << (regno)));
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 2
6 4
7 4
8 2
9 4
10 4
11 4
12 5
13 5
14 6
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 6
23 7
24 13
25 13
26 13
27 16
28 17
29 17
30 17
31 17
32 17
33 17
34 16
35 17
36 17
37 17
38 17
39 17
40 9
41 9
42 9
43 12
44 12
45 12
<<<sep_out_sample>>>
push   %rbx
mov    0x20(%rdi),%eax
mov    %rdi,%rbx
test   $0x8,%al
je     a58 <wordsplit_init0+0x38>
test   $0x1,%al
je     a78 <wordsplit_init0+0x58>
movl   $0x0,0x88(%rbx)
movq   $0x0,0x98(%rbx)
movq   $0x0,0x90(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
movq   $0x0,0x8(%rdi)
movq   $0x0,(%rdi)
movq   $0x0,0x18(%rdi)
jmp    a2f <wordsplit_init0+0xf>
nopl   0x0(%rax)
callq  a7d <wordsplit_init0+0x5d>
jmp    a2f <wordsplit_init0+0xf>
nop
<<<sep_in_sample>>>
wordsplit_init0 (struct wordsplit *wsp)
{
  if (wsp->ws_flags & 0x00000008)
    {
      if (!(wsp->ws_flags & 0x00000001))
 wordsplit_free_words (wsp);
    }
  else
    {
      wsp->ws_wordv = ((void *)0);
      wsp->ws_wordc = 0;
      wsp->ws_wordn = 0;
    }
  wsp->ws_errno = 0;
  wsp->ws_head = wsp->ws_tail = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 5
7 5
8 14
9 15
10 15
11 16
12 16
13 16
14 10
15 11
16 12
17 12
18 12
19 6
20 6
21 6
<<<sep_out_sample>>>
xor    %esi,%esi
mov    $0x2,%edi
jmpq   3bc <critical_region_begin+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
critical_region_begin(void)
{
 swgp_signal_block(2, (sigset_t *)((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <rpmErrorCode+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmErrorCode(void)
{
    return errorRec.code;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  2bd2 <istrstr+0x12>
cmpb   $0x0,(%rbx)
mov    %rax,%r12
jne    2be9 <istrstr+0x29>
jmp    2c08 <istrstr+0x48>
nopl   0x0(%rax)
add    $0x1,%rbx
cmpb   $0x0,(%rbx)
je     2c08 <istrstr+0x48>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  2bf7 <istrstr+0x37>
test   %eax,%eax
jne    2be0 <istrstr+0x20>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
<<<sep_in_sample>>>
istrstr (char const *lookin, char const *lookfor)
{
  char const *cp;
  size_t len;
  len = strlen(lookfor);
  for (cp = lookin; *cp != '\0'; ++cp)
    if (strncmp(cp, lookfor, len) == 0)
      return (char *) cp;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 9
31 10
32 10
33 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  8f9 <yy_scan_string+0x9>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   905 <yy_scan_string+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  80b <do_end+0xb>
mov    0x0(%rip),%rbx        # 812 <do_end+0x12>
mov    %rax,%rbp
mov    0x20(%rbx),%rax
mov    (%rax),%rdi
callq  821 <do_end+0x21>
mov    %rax,0x30(%rbx)
callq  82a <do_end+0x2a>
mov    %rax,0x38(%rbx)
mov    0x0(%rip),%rax        # 835 <do_end+0x35>
mov    %rbp,%rdi
mov    0x38(%rax),%rsi
callq  841 <do_end+0x41>
test   %al,%al
jne    850 <do_end+0x50>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 857 <do_end+0x57>
mov    0x30(%rax),%rsi
mov    0x20(%rax),%rdi
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   86a <do_end+0x6a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_end(void)
{
    size_t was_column = xplustabs();
    openfile->current_x = strlen(openfile->current->data);
    openfile->placewewant = xplustabs();
    if (need_horizontal_scroll(was_column, openfile->placewewant))
 update_line(openfile->current, openfile->current_x);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 4
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 8
22 8
23 8
24 7
25 7
26 7
27 8
28 8
29 8
30 7
31 7
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
jmpq   16f3 <quotearg_custom_mem+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
mov    $0x40800000,%esi
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  e0c4 <_x87_bunordi_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r12d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  ccd0 <_x87_movi_f>
mov    0x0(%rbp),%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0xa,%esi
and    $0x7fff,%r8d
callq  a0 <_x87jcc2>
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  e119 <_x87_bunordi_f+0x79>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_x87_bunordi_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc2(_jit, 0xa, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30 <gsasl_check_version+0x30>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <gsasl_check_version+0x13>
xor    %edx,%edx
test   %eax,%eax
mov    $0x0,%eax
cmovle %rax,%rdx
add    $0x8,%rsp
mov    %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
gsasl_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.8.0") <= 0)
    return "1.8.0";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 4
15 6
16 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    %rdx,%rsi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  314 <insert_primary_withpred+0x14>
mov    0x8(%rbx),%rdx
mov    %rbp,(%rax)
movq   $0x0,0x38(%rax)
movl   $0x1,0x10(%rax)
movl   $0x0,0x14(%rax)
mov    %rdx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
insert_primary_withpred (const struct parser_table *entry,
    PRED_FUNC pred_func,
    const char *arg)
{
  struct predicate *new_pred;
  new_pred = get_new_pred_chk_op (entry, arg);
  new_pred->pred_func = pred_func;
  new_pred->p_name = entry->parser_name;
  new_pred->args.str = ((void *)0);
  new_pred->p_type = PRIMARY_TYPE;
  new_pred->p_prec = NO_PREC;
  return new_pred;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 4
5 4
6 4
7 6
8 8
9 7
10 9
11 10
12 11
13 8
14 13
15 13
16 13
17 13
18 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
movq   $0x0,(%rsp)
callq  b99 <grecs_print_value+0x19>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_print_value(struct grecs_value *val, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_value(val, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
8 5
<<<sep_out_sample>>>
push   %r14
mov    %rcx,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
test   %rsi,%rsi
je     290 <mu_nntp_body+0x80>
mov    $0x80,%edi
mov    %r8,0x8(%rsp)
callq  23c <mu_nntp_body+0x2c>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     282 <mu_nntp_body+0x72>
mov    %rbx,%rcx
mov    $0x0,%edx
mov    $0x7f,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  260 <mu_nntp_body+0x50>
mov    0x8(%rsp),%r8
mov    %r14,%rcx
mov    %r13,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  276 <mu_nntp_body+0x66>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  280 <mu_nntp_body+0x70>
mov    %ebx,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
add    $0x10,%rsp
xor    %esi,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
jmpq   2a3 <mu_nntp_body+0x93>
<<<sep_in_sample>>>
mu_nntp_body (mu_nntp_t nntp, unsigned long number, unsigned long *pnum, char **mid, mu_stream_t *pstream)
{
  int status;
  char *message_id = ((void *)0);
  if (number != 0)
    {
      message_id = malloc (128);
      if (message_id == ((void *)0))
 {
   return 12;
 }
      snprintf (message_id, 127, "%lu", number);
    }
  status = mu_nntp_body_id (nntp, message_id, pnum, mid, pstream);
  if (message_id)
    {
      free (message_id);
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 7
14 7
15 7
16 7
17 10
18 8
19 8
20 12
21 12
22 12
23 12
24 12
25 12
26 14
27 14
28 14
29 14
30 14
31 14
32 17
33 14
34 17
35 14
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 14
46 20
47 20
48 20
49 20
50 20
51 14
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
flip_execute_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbx
xor    %esi,%esi
mov    %edi,%ebx
callq  fa <restore_stdin+0xa>
mov    %ebx,%edi
pop    %rbx
jmpq   102 <restore_stdin+0x12>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
restore_stdin (s)
     int s;
{
  dup2 (s, 0);
  close (s);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 4a7 <gpath_nextkey+0x7>
je     4b0 <gpath_nextkey+0x10>
mov    0x0(%rip),%eax        # 4af <gpath_nextkey+0xf>
retq   
push   %rax
mov    $0x0,%ecx
mov    $0xfb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4ca <gpath_nextkey+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_nextkey(void)
{
 ((_mode != 1) ? (void) (0) : __assert_fail ("_mode != 1", "gpathop.c", 251, __PRETTY_FUNCTION__));
 return _nextkey;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 2
6 3
7 3
8 3
9 3
10 3
11 3
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     20 <gsl_eigen_gensymm_free+0x20>
mov    0x8(%rdi),%rdi
test   %rdi,%rdi
je     17 <gsl_eigen_gensymm_free+0x17>
callq  17 <gsl_eigen_gensymm_free+0x17>
mov    %rbx,%rdi
pop    %rbx
jmpq   20 <gsl_eigen_gensymm_free+0x20>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_gensymm_free (gsl_eigen_gensymm_workspace * w)
{
  if (!w) { return ; };
  if (w->symm_workspace_p)
    gsl_eigen_symm_free(w->symm_workspace_p);
  free(w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 7
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
movsd  %xmm0,(%rdi)
movsd  %xmm1,0x8(%rdi)
movsd  %xmm2,0x10(%rdi)
retq   
nop
<<<sep_in_sample>>>
DISSetDRThresholds(dis_dr_parameters * dr, double time, double location, double orientation)
{
 dr->timeThreshold = time;
 dr->locationThreshold = location;
 dr->orientationThreshold = orientation;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x20,%edi
callq  29e <swicat_sq_create+0xe>
movl   $0x0,0x8(%rax)
movb   $0x0,0xc(%rax)
movb   $0x0,0xd(%rax)
movq   $0x0,(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
swicat_sq_create(void)
{
 SWICAT_SQ * sq;
 sq = (SWICAT_SQ *)malloc(sizeof(SWICAT_SQ));
 sq->numberM = 0;
 sq->levelM[0] = '\0';
 sq->levelM[1] = '\0';
 sq->lineM = ((void *)0);
 sq->swspec_stringM = ((void *)0);
 sq->swspecM = ((void *)0);
 return sq;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 12
11 12
12 12
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  1211 <input_data+0x11>
mov    %rax,%r13
nopl   0x0(%rax)
mov    %ebp,%edi
callq  121f <input_data+0x1f>
mov    0x0(%r13),%rdx
movslq %eax,%rcx
testb  $0x20,0x1(%rdx,%rcx,2)
jne    1218 <input_data+0x18>
xor    %ebx,%ebx
jmp    1245 <input_data+0x45>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    $0xff,%rbx
je     1280 <input_data+0x80>
mov    %ebp,%edi
mov    %al,0x0(%rbx)
lea    0x1(%rbx),%r12d
callq  1256 <input_data+0x56>
mov    0x0(%r13),%rcx
movslq %eax,%rsi
testb  $0x20,0x1(%rcx,%rsi,2)
je     1238 <input_data+0x38>
movslq %r12d,%r12
mov    $0x0,%eax
movb   $0x0,0x0(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
movb   $0x0,0x0(%rip)        # 1293 <input_data+0x93>
callq  1298 <input_data+0x98>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
input_data(int channel)
{
      static char str[255+1];
      int len = 0, c;
      for (;;)
      { c = inchar(channel);
         if (!((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace)) break;
      }
      while (!((*__ctype_b_loc ())[(int) ((c))] & (unsigned short int) _ISspace))
      { if (len == sizeof(str) - 1)
         { str[len] = '\0';
            fault("input data item `%.12s...' too long", str);
         }
         str[len++] = (char)c;
         c = inchar(channel);
      }
      str[len] = '\0';
      return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 10
21 10
22 15
23 14
24 14
25 15
26 9
27 9
28 9
29 9
30 17
31 19
32 17
33 19
34 19
35 19
36 19
37 19
38 19
39 12
40 12
41 12
42 11
43 12
44 12
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
jmp    1a <nonintr_close+0x1a>
nopw   0x0(%rax,%rax,1)
callq  15 <nonintr_close+0x15>
cmpl   $0x4,(%rax)
jne    27 <nonintr_close+0x27>
mov    %ebp,%edi
callq  21 <nonintr_close+0x21>
test   %eax,%eax
mov    %eax,%ebx
js     10 <nonintr_close+0x10>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nonintr_close (int fd)
{
  int retval;
  do
    retval = close (fd);
  while (retval < 0 && (*__errno_location ()) == 4);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 5
11 5
12 6
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2576 <maybe_emit_oob_warning+0x6>
test   %eax,%eax
je     2580 <maybe_emit_oob_warning+0x10>
repz retq 
nopl   0x0(%rax)
jmpq   0 <maybe_emit_oob_warning.part.2>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maybe_emit_oob_warning (void)
{
  static bool warning_written = false;
  if (!warning_written)
    {
      fprintf (stderr, "%s: one or more out-of-bounds output values are approximated\n", progname);
      warning_written = true;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
push   %r13
mov    %rdx,%r13
push   %r12
lea    0x28(%rdi),%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    0x28(%rdi),%rbx
cmp    %r12,%rbx
jne    18e <gl_linked_sortedlist_indexof+0x2e>
jmp    19d <gl_linked_sortedlist_indexof+0x3d>
nop
je     1b0 <gl_linked_sortedlist_indexof+0x50>
mov    (%rbx),%rbx
add    $0x1,%rbp
cmp    %r12,%rbx
je     19d <gl_linked_sortedlist_indexof+0x3d>
mov    0x10(%rbx),%rdi
mov    %r13,%rsi
callq  *%r14
cmp    $0x0,%eax
jle    180 <gl_linked_sortedlist_indexof+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffffffffffff,%rax
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_linked_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,
         const void *elt)
{
  gl_list_node_t node;
  size_t index;
  for (node = list->root.next, index = 0;
       node != &list->root;
       node = node->next, index++)
    {
      int cmp = compar (node->value, elt);
      if (cmp > 0)
 break;
      if (cmp == 0)
 return index;
    }
  return (size_t)(-1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 3
8 6
9 3
10 6
11 6
12 6
13 6
14 6
15 13
16 8
17 8
18 6
19 6
20 10
21 10
22 10
23 11
24 11
25 17
26 17
27 17
28 17
29 16
30 17
31 17
32 17
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 17
<<<sep_out_sample>>>
mov    %edi,%esi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  10 <stackoverflow_handler>
<<<sep_in_sample>>>
stackoverflow_handler_continuation (void *arg1, void *arg2, void *arg3)
{
  int arg = (int) (long) arg1;
  longjmp (mainloop, arg);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     160 <grecs_version_info_free+0x20>
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     157 <grecs_version_info_free+0x17>
callq  157 <grecs_version_info_free+0x17>
mov    %rbx,%rdi
pop    %rbx
jmpq   160 <grecs_version_info_free+0x20>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_version_info_free(struct grecs_version_info *pv)
{
 if (pv) {
  if (pv->buffer)
   grecs_free(pv->buffer);
  free(pv);
 }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 8
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x8,%esi
lea    0x38(%rdi),%rsi
sete   %al
mov    %edx,%ecx
mov    $0x8,%r8d
mov    %eax,%edx
jmpq   34b <__osip_ist_need_timer_i_event+0x1b>
<<<sep_in_sample>>>
__osip_ist_need_timer_i_event (osip_ist_t * ist, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (ist, &ist->timer_i_start, state == IST_CONFIRMED, transactionid, TIMEOUT_I);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
test   $0xff000,%edx
mov    (%rdi),%eax
jne    194 <Barcode_Print+0x14>
mov    %eax,%ecx
and    $0xff000,%ecx
or     %ecx,%edx
test   $0x1,%dh
jne    1a3 <Barcode_Print+0x23>
mov    %eax,%ecx
and    $0x100,%ecx
or     %ecx,%edx
test   $0x100000,%edx
jne    1b5 <Barcode_Print+0x35>
mov    %eax,%ecx
and    $0x100000,%ecx
or     %ecx,%edx
and    $0x1ff100,%edx
and    $0xffe00eff,%eax
or     %eax,%edx
test   $0x40,%dh
mov    %edx,(%rdi)
jne    1e8 <Barcode_Print+0x68>
and    $0x10000,%edx
jne    1e0 <Barcode_Print+0x60>
jmpq   1d6 <Barcode_Print+0x56>
nopw   %cs:0x0(%rax,%rax,1)
jmpq   1e5 <Barcode_Print+0x65>
nopl   (%rax)
jmpq   1ed <Barcode_Print+0x6d>
nopl   (%rax)
<<<sep_in_sample>>>
Barcode_Print(struct Barcode_Item *bc, FILE *f, int flags)
{
    int validbits = 0x000ff000 | 0x00000100
 | 0x00100000;
    if (!(flags & 0x000ff000))
 flags |= bc->flags & 0x000ff000;
    if (!(flags & 0x00000100))
 flags |= bc->flags & 0x00000100;
    if (!(flags & 0x00100000))
 flags |= bc->flags & 0x00100000;
    flags = bc->flags = (flags & validbits) | (bc->flags & ~validbits);
    if (bc->flags & 0x00004000)
       return Barcode_pcl_print(bc, f);
    if (bc->flags & 0x00010000)
       return Barcode_svg_print(bc, f);
    return Barcode_ps_print(bc, f);
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 6
5 6
6 6
7 7
8 7
9 8
10 8
11 8
12 9
13 9
14 10
15 10
16 10
17 11
18 11
19 11
20 12
21 11
22 12
23 14
24 14
25 16
26 16
27 15
28 15
29 13
30 13
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
test   %rdx,%rdx
je     2d <__gmpf_get_d+0x2d>
mov    %rdx,%rax
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rdi
sar    $0x3f,%rax
mov    %rax,%rsi
xor    %rdx,%rsi
sub    %rax,%rsi
sub    %rsi,%rcx
shl    $0x6,%rcx
jmpq   2d <__gmpf_get_d+0x2d>
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
__gmpf_get_d (mpf_srcptr src)
{
  mp_size_t size, abs_size;
  long exp;
  size = ((src)->_mp_size);
  if (__builtin_expect ((size == 0) != 0, 0))
    return 0.0;
  abs_size = ((size) >= 0 ? (size) : -(size));
  exp = (((src)->_mp_exp) - abs_size) * (64 - 0);
  return __gmpn_get_d (((src)->_mp_d), abs_size, size, exp);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 8
5 9
6 10
7 8
8 8
9 8
10 8
11 9
12 9
13 10
14 11
15 11
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     216 <mu_tcp_server_set_backlog+0x16>
mov    0x18(%rdi),%eax
test   %eax,%eax
je     220 <mu_tcp_server_set_backlog+0x20>
mov    $0x16,%eax
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %esi,0x50(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_tcp_server_set_backlog (mu_ip_server_t srv, int backlog)
{
  if (!srv || srv->type != 0)
    return 22;
  srv->v.tcp_data.backlog = backlog;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 4
8 7
9 7
10 5
11 6
12 6
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     2201 <gsl_matrix_short_fread+0x91>
lea    (%r15,%r15,1),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    21be <gsl_matrix_short_fread+0x4e>
jmp    21f0 <gsl_matrix_short_fread+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     21f0 <gsl_matrix_short_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  21d5 <gsl_matrix_short_fread+0x65>
test   %eax,%eax
je     21b0 <gsl_matrix_short_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   2224 <gsl_matrix_short_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_fread (FILE * stream, gsl_matrix_short * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_short_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_short_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  18 <CDB___os_set_errno+0x8>
mov    %ebx,(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___os_set_errno(evalue)
 int evalue;
{
 (*__errno_location ()) = evalue;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <clear_stats+0x7>
movq   $0x0,0x0(%rip)        # 12 <clear_stats+0x12>
add    %rax,0x0(%rip)        # 19 <clear_stats+0x19>
mov    0x0(%rip),%rax        # 20 <clear_stats+0x20>
movq   $0x0,0x0(%rip)        # 2b <clear_stats+0x2b>
add    %rax,0x0(%rip)        # 32 <clear_stats+0x32>
mov    0x0(%rip),%rax        # 39 <clear_stats+0x39>
movq   $0x0,0x0(%rip)        # 44 <clear_stats+0x44>
add    %rax,0x0(%rip)        # 4b <clear_stats+0x4b>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
clear_stats()
{
    total_stat.defines += current_stat.defines;
    total_stat.matches += current_stat.matches;
    total_stat.compares += current_stat.compares;
    memset(&current_stat, 0, sizeof(current_stat));
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 4
5 6
6 4
7 5
8 6
9 5
10 6
11 6
<<<sep_out_sample>>>
mov    0xd8(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_timeout (mu_m_server_t srv)
{
  return srv->timeout;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <delegate_hash_1+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0xf,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <delegate_hash_1+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
delegate_hash_1 (void const *key)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((((const struct delegation *) key)->contract)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0xf)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rdx,%r12
shr    $0x6,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rcx,%rbx
lea    (%rcx,%r12,8),%rcx
mov    %rbx,%rdi
sub    $0x8,%rsp
callq  26 <__gmpn_bsqrt+0x26>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %r12,%rcx
mov    %r13,%rdi
pop    %r12
pop    %r13
jmpq   41 <__gmpn_bsqrt+0x41>
<<<sep_in_sample>>>
__gmpn_bsqrt (mp_ptr rp, mp_srcptr ap, mp_bitcnt_t nb, mp_ptr tp)
{
  mp_ptr sp;
  mp_size_t n;
  do {} while (0);
  n = nb / (64 - 0);
  sp = tp + n;
  __gmpn_bsqrtinv (tp, ap, nb, sp);
  __gmpn_mullo_n (rp, tp, ap, n);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
6 2
7 2
8 2
9 2
10 7
11 8
12 2
13 8
14 10
15 9
16 9
17 10
18 10
19 9
20 9
21 10
22 10
23 9
<<<sep_out_sample>>>
test   %rdi,%rdi
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0x6666666666666667,%rsi
js     58 <imaxtostr+0x58>
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %rsi
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    20 <imaxtostr+0x20>
mov    %rcx,%rax
retq   
nopl   0x0(%rax)
mov    %rsi,%r8
mov    $0x30,%esi
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %r8
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
test   %rdx,%rdx
mov    %rdx,%rdi
mov    %al,(%rcx)
jne    60 <imaxtostr+0x60>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
imaxtostr (intmax_t i, char *buf)
{
  char *p = buf + ((sizeof (intmax_t) * 8 - (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1)) + 1);
  *p = 0;
  if (i < 0)
    {
      do
 *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 5
2 3
3 4
4 15
5 5
6 5
7 15
8 15
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 16
19 15
20 16
21 16
22 19
23 19
24 19
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 9
38 9
39 8
40 9
41 8
42 10
43 10
44 19
45 19
<<<sep_out_sample>>>
cmp    %rsi,(%rdi)
jbe    60 <gsl_histogram_get_range+0x20>
mov    0x8(%rdi),%rax
movsd  (%rax,%rsi,8),%xmm0
movsd  %xmm0,(%rdx)
movsd  0x8(%rax,%rsi,8),%xmm0
xor    %eax,%eax
movsd  %xmm0,(%rcx)
retq   
nop
sub    $0x8,%rsp
mov    $0x1,%ecx
mov    $0x30,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7d <gsl_histogram_get_range+0x3d>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_get_range (const gsl_histogram * h, size_t i,
                         double *lower, double *upper)
{
  const size_t n = h->n;
  if (i >= n)
    {
      do { gsl_error ("index lies outside valid range of 0 .. n - 1", "get.c", 48, GSL_EDOM) ; return GSL_EDOM ; } while (0);
    }
  *lower = h->range[i];
  *upper = h->range[i + 1];
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 9
4 9
5 9
6 10
7 11
8 10
9 11
10 11
11 3
12 7
13 7
14 7
15 7
16 7
17 7
18 12
19 12
20 12
<<<sep_out_sample>>>
push   %rbx
mov    $0x32,%edi
callq  1db <dummy_catalog_response+0xb>
mov    $0x0,%edx
mov    %rax,%rbx
mov    %rax,%rdi
xor    %esi,%esi
xor    %eax,%eax
callq  1ef <dummy_catalog_response+0x1f>
mov    %rbx,%rdi
pop    %rbx
jmpq   1f8 <dummy_catalog_response+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dummy_catalog_response(void)
{
 STROB * tmp;
 tmp = strob_open(50);
 ;
 strob_sprintf(tmp, 0,
  "Q0:P:foo,r<1\n"
  "R0:P:...:\n"
  "Q1:P:foo,r==1\n"
  "R1:P:...:\n"
  "Q2:P:foo,r>1\n"
  "R2:P:...:\n");
 ;
 return strob_release(tmp);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 4
6 6
7 6
8 6
9 6
10 14
11 15
12 14
13 14
<<<sep_out_sample>>>
push   %rbp
push   %rbx
movslq %edi,%rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 9c0 <saveCutDir+0x10>
cmp    $0x14,%eax
jg     a28 <saveCutDir+0x78>
mov    0x0(%rip),%rsi        # 9cc <saveCutDir+0x1c>
mov    0x0(,%rax,8),%rdi
callq  9d9 <saveCutDir+0x29>
movslq 0x0(%rip),%rax        # 9e0 <saveCutDir+0x30>
mov    0x0(,%rax,8),%rbp
mov    %rbp,%rdi
callq  9f0 <saveCutDir+0x40>
mov    $0x2f,%edx
mov    %dx,0x0(%rbp,%rax,1)
movslq 0x0(%rip),%rax        # a01 <saveCutDir+0x51>
mov    0x0(,%rbx,8),%rsi
mov    0x0(,%rax,8),%rdi
callq  a16 <saveCutDir+0x66>
addl   $0x1,0x0(%rip)        # a1d <saveCutDir+0x6d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x1,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a3c <saveCutDir+0x8c>
mov    0x0(,%rbx,8),%rdx
mov    0x0(%rip),%rdi        # a4b <saveCutDir+0x9b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
mov    $0x0,%esi
xor    %eax,%eax
jmpq   a5d <saveCutDir+0xad>
nopl   (%rax)
<<<sep_in_sample>>>
saveCutDir(int i)
{
  if(numCutDirs > 20)
  {
    msgBox("Unable to perform operation.\nClipboard is full.", 1, ERROR);
    fprintf(log_file, "Unable to cut dir '%s'.. Clipboard is full\n", files[i]);
    return;
  }
  strcpy(cutDirs[numCutDirs], cwd);
  strcat(cutDirs[numCutDirs], "/");
  strcat(cutDirs[numCutDirs], dirs[i]);
  strcat(cutDirs[numCutDirs++], "\0");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 11
18 11
19 11
20 11
21 12
22 13
23 13
24 13
25 13
26 13
27 5
28 5
29 5
30 5
31 6
32 6
33 13
34 13
35 13
36 6
37 6
38 6
39 6
<<<sep_out_sample>>>
mov    $0x90,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
jit_get_max_instr(void)
{
    return (43 >= 144 ? 43 : 144);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     250 <data_in_list+0x30>
mov    0x8(%rsi),%rax
test   %rax,%rax
jne    238 <data_in_list+0x18>
jmp    250 <data_in_list+0x30>
mov    (%rax),%rax
test   %rax,%rax
je     248 <data_in_list+0x28>
cmp    %rdi,0x18(%rax)
jne    230 <data_in_list+0x10>
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
data_in_list(void *data, struct linked_list *list)
{
     struct linked_list_entry *p;
     for (p = ((list) ? (list)->head : ((void *)0)); p; p = p->next)
   if (p->data == data)
        return 1;
     return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
12 6
13 8
14 8
15 8
16 8
17 7
18 7
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x10,%rsp
test   %rdx,%rdx
movss  (%rdi),%xmm1
movss  %xmm1,0xc(%rsp)
je     a0a <gsl_stats_float_max_index+0x6a>
lea    0x0(,%rsi,4),%r13
movss  0xc(%rsp),%xmm0
xor    %ebx,%ebx
xor    %r14d,%r14d
lea    (%rdi,%r13,1),%rbp
jmp    a01 <gsl_stats_float_max_index+0x61>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    %r12,%rbx
je     a20 <gsl_stats_float_max_index+0x80>
movss  0x0(%rbp),%xmm0
ucomiss 0xc(%rsp),%xmm0
jbe    9fe <gsl_stats_float_max_index+0x5e>
movss  %xmm0,0xc(%rsp)
mov    %rbx,%r14
add    %r13,%rbp
callq  a06 <gsl_stats_float_max_index+0x66>
test   %eax,%eax
je     9e0 <gsl_stats_float_max_index+0x40>
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
add    $0x10,%rsp
mov    %r14,%rbx
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_float_max_index (const float data[], const size_t stride,
                                const size_t n)
{
  float max = data[0 * stride];
  size_t i, max_index = 0;
  for (i = 0; i < n; i++)
    {
      float xi = data[i * stride];
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          return i;
        }
    }
  return max_index;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 5
8 3
9 6
10 4
11 4
12 6
13 8
14 8
15 6
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 8
24 9
25 9
26 8
27 8
28 8
29 14
30 14
31 14
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
<<<sep_out_sample>>>
push   %r15
mov    %edx,%r15d
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
test   %edx,%edx
jle    30c <GetNNumbers+0x7c>
mov    %rdi,%r13
mov    %rsi,%rbp
mov    %rcx,%r14
xor    %r12d,%r12d
mov    $0x6,%edx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  2c1 <GetNNumbers+0x31>
test   %eax,%eax
mov    %eax,%ebx
je     2e0 <GetNNumbers+0x50>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
add    $0x1,%r12d
callq  2ec <GetNNumbers+0x5c>
cmp    %r12d,%r15d
movsd  %xmm0,(%r14)
jle    2c7 <GetNNumbers+0x37>
mov    $0x2c,%edx
mov    %rbp,%rsi
mov    %r13,%rdi
callq  306 <GetNNumbers+0x76>
add    $0x8,%r14
jmp    2b1 <GetNNumbers+0x21>
xor    %ebx,%ebx
jmp    2c7 <GetNNumbers+0x37>
<<<sep_in_sample>>>
GetNNumbers (PINPUTBUF pibIn, PSTR szLex, int nNumbers, PDOUBLE rgd)
{
  BOOL bErr = 0;
  int i;
  for (i = 0; i < nNumbers && !bErr; i++) {
    if (i)
      GetOptPunct (pibIn, szLex, ',');
    if (!(bErr = ENextLex (pibIn, szLex, (0x0002 | 0x0004))))
      rgd[i] = atof(szLex);
  }
  return bErr;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 9
33 5
34 9
35 5
36 9
37 5
38 7
39 7
40 7
41 7
42 7
43 7
44 3
45 3
<<<sep_out_sample>>>
movzbl 0x10(%rdi),%eax
mov    0x8(%rdi),%rdx
test   %eax,%eax
je     58 <function_table_entry_hash_1+0x58>
cmp    $0x1,%eax
je     58 <function_table_entry_hash_1+0x58>
movzbl (%rdx),%esi
test   %sil,%sil
je     70 <function_table_entry_hash_1+0x70>
lea    -0x2(%rax),%r8d
xor    %eax,%eax
add    %rdx,%r8
jmp    34 <function_table_entry_hash_1+0x34>
nopl   0x0(%rax)
test   %sil,%sil
lea    0x1(%rdx),%rcx
je     68 <function_table_entry_hash_1+0x68>
mov    %rcx,%rdx
movzbl %sil,%edi
movzbl 0x1(%rdx),%esi
mov    %esi,%ecx
and    $0xf,%ecx
shl    %cl,%edi
movslq %edi,%rdi
add    %rdi,%rax
cmp    %r8,%rdx
jne    28 <function_table_entry_hash_1+0x28>
add    %rsi,%rax
retq   
nopw   0x0(%rax,%rax,1)
movzbl (%rdx),%esi
xor    %eax,%eax
add    %rsi,%rax
retq   
nopl   0x0(%rax)
movzbl 0x2(%rdx),%esi
add    %rsi,%rax
retq   
movzbl 0x1(%rdx),%esi
xor    %eax,%eax
jmp    4e <function_table_entry_hash_1+0x4e>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
function_table_entry_hash_1 (const void *keyv)
{
  const struct function_table_entry *key = keyv;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((key->name)) - 1; int _n_ = ((key->len)); if (_n_) while (--_n_ && *++_key_) (_result_) += (*_key_ << (_key_[1] & 0xf)); (_result_) += *++_key_; } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 5
30 5
31 5
32 4
33 4
34 5
35 5
36 5
37 4
38 5
39 5
40 4
41 4
42 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x40,%rsp
mov    0x28(%rdi),%rbx
movq   $0x0,(%rsi)
cmpq   $0x0,0x100(%rbx)
je     7a <__db_metabegin+0x7a>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  30 <__db_metabegin+0x30>
test   %eax,%eax
je     40 <__db_metabegin+0x40>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    0x8(%rsp),%esi
lea    0xc(%rsp),%rax
lea    0x10(%rsp),%rcx
xor    %edx,%edx
mov    %r12,%r9
mov    $0x2,%r8d
mov    %rbx,%rdi
movl   $0x0,0xc(%rsp)
mov    %rax,0x10(%rsp)
movl   $0x4,0x18(%rsp)
callq  76 <__db_metabegin+0x76>
test   %eax,%eax
jne    34 <__db_metabegin+0x34>
lea    0x68(%rbp),%rdx
mov    %rbx,%rdi
xor    %ecx,%ecx
xor    %esi,%esi
callq  8a <__db_metabegin+0x8a>
add    $0x40,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__db_metabegin(dbp, lockp)
 DB *dbp;
 DB_LOCK *lockp;
{
 DB_ENV *dbenv;
 DBT dbplock;
 u_int32_t locker, lockval;
 int ret;
 dbenv = dbp->dbenv;
 lockp->off = 0;
 if (((dbenv)->lk_handle != ((void *)0))) {
  if ((ret = CDB_lock_id(dbenv, &locker)) != 0)
   return (ret);
  lockval = 0;
  dbplock.data = &lockval;
  dbplock.size = sizeof(lockval);
  if ((ret = CDB_lock_get(dbenv,
      locker, 0, &dbplock, DB_LOCK_WRITE, lockp)) != 0)
   return(ret);
 }
 return (CDB_txn_begin(dbenv, ((void *)0), &dbp->open_txn, 0));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 9
8 10
9 11
10 11
11 12
12 12
13 12
14 12
15 12
16 22
17 22
18 22
19 22
20 22
21 22
22 17
23 15
24 17
25 17
26 17
27 17
28 17
29 14
30 15
31 16
32 17
33 17
34 17
35 21
36 21
37 21
38 21
39 21
40 22
41 22
42 22
43 22
44 22
45 22
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
movzbl (%rdi),%ecx
mov    %rdi,%rax
test   %cl,%cl
je     5d0 <tail+0x50>
lea    0x1(%rdi),%rdx
mov    $0x2f,%edi
nopl   0x0(%rax,%rax,1)
cmp    $0x2f,%cl
je     5b0 <tail+0x30>
movzbl (%rdx),%ecx
add    $0x1,%rdx
test   %cl,%cl
jne    598 <tail+0x18>
repz retq 
nopw   0x0(%rax,%rax,1)
movzbl (%rdx),%esi
test   %sil,%sil
je     5d0 <tail+0x50>
cmp    $0x2f,%sil
mov    %edi,%ecx
cmovne %esi,%ecx
cmovne %rdx,%rax
add    $0x1,%rdx
jmp    598 <tail+0x18>
nopl   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tail (register const char *fn)
{
  register const char *p;
  for (p = fn; *p != 0; p++)
    if (*p == '/' && p[1] != '\0' && p[1] != '/')
      fn = &p[1];
  return fn;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 5
24 5
25 5
26 8
27 8
<<<sep_out_sample>>>
jmpq   a0 <_gsasl_step64>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
jmpq   85 <username_completion_function+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
username_completion_function (s, i)
     const char *s;
     int i;
{
  return rl_username_completion_function (s, i);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_ostream__flush (file_ostream_t stream)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
jmpq   4f5 <lastpipe_cleanup+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lastpipe_cleanup (s)
     int s;
{
  unfreeze_jobs_list ();
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     840 <gsl_odeiv2_evolve_set_driver+0x10>
mov    %rsi,0x40(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x3,%ecx
mov    $0x181,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  85d <gsl_odeiv2_evolve_set_driver+0x2d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_odeiv2_evolve_set_driver (gsl_odeiv2_evolve * e,
                              const gsl_odeiv2_driver * d)
{
  if (d != ((void *)0))
    {
      e->driver = d;
    }
  else
    {
      do { gsl_error ("driver pointer is null", "evolve.c", 385, GSL_EFAULT) ; return 0 ; } while (0);
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 13
5 13
6 13
7 3
8 10
9 10
10 10
11 10
12 10
13 13
14 13
15 13
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
mov    %rcx,%rsi
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  260 <cdio_charset_to_utf8+0x20>
mov    %r13,%rcx
mov    %rax,%rbx
mov    %r12d,%edx
mov    %rbp,%rsi
xor    %r8d,%r8d
mov    %rax,%rdi
callq  0 <do_convert>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  281 <cdio_charset_to_utf8+0x41>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
cdio_charset_to_utf8(const char *src, size_t src_len, cdio_utf8_t **dst,
                          const char * src_charset)
  {
  iconv_t ic;
  unsigned char result;
  ic = iconv_open("UTF-8", src_charset);
  result = do_convert(ic, src, src_len, dst, ((void *)0));
  iconv_close(ic);
  return result;
  }
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 3
7 3
8 6
9 3
10 3
11 6
12 7
13 6
14 7
15 7
16 7
17 7
18 7
19 8
20 7
21 8
22 10
23 10
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 1cd <incomplete_line+0xd>
mov    %rbx,%rdi
callq  1d5 <incomplete_line+0x15>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  1e0 <incomplete_line+0x20>
cmp    $0x5c,%eax
je     205 <incomplete_line+0x45>
mov    0x0(%rip),%rdi        # 1ec <incomplete_line+0x2c>
mov    %rbp,%rsi
xor    %edx,%edx
callq  1f6 <incomplete_line+0x36>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nop
cmp    $0xffffffff,%eax
je     212 <incomplete_line+0x52>
mov    %rbx,%rdi
callq  20d <incomplete_line+0x4d>
cmp    $0xa,%eax
jne    200 <incomplete_line+0x40>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
incomplete_line (void)
{
  FILE *fp = pfp;
  int c;
  file_offset line_beginning = ftell (fp);
  if (_IO_getc (fp) == '\\')
    {
      while ((c = _IO_getc (fp)) != '\n' && c != (-1))
                  ;
      return 1;
    }
  else
    {
      Fseek (pfp, line_beginning, 0);
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 5
6 5
7 6
8 5
9 6
10 6
11 6
12 14
13 14
14 14
15 14
16 17
17 15
18 17
19 17
20 17
21 17
22 8
23 8
24 8
25 8
26 8
27 8
28 17
29 10
30 17
31 17
32 17
33 17
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8c0 <mu_url_is_scheme+0x30>
test   %rsi,%rsi
je     8c0 <mu_url_is_scheme+0x30>
mov    0x8(%rdi),%rdi
xor    %eax,%eax
test   %rdi,%rdi
je     8ba <mu_url_is_scheme+0x2a>
sub    $0x8,%rsp
callq  8ae <mu_url_is_scheme+0x1e>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
repz retq 
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_is_scheme (mu_url_t url, const char *scheme)
{
  if (url && scheme && url->scheme
      && mu_c_strcasecmp (url->scheme, scheme) == 0)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 3
8 3
9 2
10 4
11 4
12 4
13 7
14 4
15 7
16 7
17 6
18 6
19 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 16 <handle_sigwinch+0x6>
add    $0x1,%eax
mov    %eax,0x0(%rip)        # 1f <handle_sigwinch+0xf>
retq   
<<<sep_in_sample>>>
handle_sigwinch(int signal)
{
    sigwinch_counter++;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  bc9 <rec_db_type_p+0x9>
test   %rax,%rax
setne  %al
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_db_type_p (rec_db_t db,
               const char *type)
{
  return (rec_db_get_rset_by_type (db, type) != ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 5
6 5
7 5
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_get_version (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->version;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x848(%rdi),%eax
test   %eax,%eax
je     4b0 <OpenMCFiles+0x40>
mov    0x838(%rdi),%rax
mov    %rax,0xeb0(%rdi)
mov    0xeb8(%rbx),%rdi
xor    %ebp,%ebp
test   %rdi,%rdi
je     4d0 <OpenMCFiles+0x60>
mov    %rbx,%rsi
callq  4a7 <OpenMCFiles+0x37>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
cmpq   $0x0,0xeb0(%rdi)
jne    491 <OpenMCFiles+0x21>
movq   $0x0,0xeb0(%rdi)
jmp    491 <OpenMCFiles+0x21>
nopw   0x0(%rax,%rax,1)
mov    0xeb0(%rbx),%rdi
mov    $0x0,%esi
callq  4e1 <OpenMCFiles+0x71>
test   %rax,%rax
mov    %rax,0xeb8(%rbx)
mov    %rax,%rdi
jne    49f <OpenMCFiles+0x2f>
mov    0xeb0(%rbx),%rdx
mov    $0x0,%ecx
mov    $0x8003,%esi
mov    $0x1,%bpl
callq  509 <OpenMCFiles+0x99>
mov    0xeb8(%rbx),%rdi
jmp    49f <OpenMCFiles+0x2f>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
OpenMCFiles (PANALYSIS panal)
{
  int iErr = 0;
  PMONTECARLO pmc = &panal->mc;
  if (panal->bCommandLineSpec)
    pmc->szMCOutfilename = panal->szOutfilename;
  else
    if (!(pmc->szMCOutfilename))
      pmc->szMCOutfilename = vszDefMCOutFilename;
  if (!pmc->pfileMCOut
      && !(pmc->pfileMCOut = fopen (pmc->szMCOutfilename, "w"))) {
    iErr++;
    ReportError (((void *)0), 0x8000 | 0x0003, pmc->szMCOutfilename,
                 "OpenMCFiles()");
  }
  WriteMCHeader (pmc->pfileMCOut, panal);
  return (iErr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 6
9 6
10 10
11 3
12 10
13 10
14 16
15 16
16 18
17 18
18 18
19 18
20 18
21 8
22 8
23 9
24 9
25 9
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 13
34 13
35 13
36 12
37 13
38 13
39 13
40 13
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  46d <_rl_arg_callback+0xd>
test   %eax,%eax
mov    %eax,%ebx
js     4d0 <_rl_arg_callback+0x70>
mov    0x0(%rip),%eax        # 479 <_rl_arg_callback+0x19>
test   $0x4,%al
jne    4a0 <_rl_arg_callback+0x40>
mov    %ebx,%esi
mov    %ebp,%edi
xor    %eax,%eax
callq  488 <_rl_arg_callback+0x28>
cmp    $0x1,%eax
setne  %al
add    $0x8,%rsp
pop    %rbx
movzbl %al,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
and    $0xfffffffb,%eax
mov    %eax,0x0(%rip)        # 4a9 <_rl_arg_callback+0x49>
callq  4ae <_rl_arg_callback+0x4e>
callq  4b3 <_rl_arg_callback+0x53>
mov    %ebx,%edi
andq   $0xfffffffffffffbff,0x0(%rip)        # 4c0 <_rl_arg_callback+0x60>
callq  4c5 <_rl_arg_callback+0x65>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_arg_callback (cxt)
     _rl_arg_cxt cxt;
{
  int c, r;
  c = _rl_arg_getchar ();
  if (c < 0)
    return (1);
  if (_rl_argcxt & 0x04)
    {
      _rl_argcxt &= ~0x04;
      rl_restore_prompt ();
      rl_clear_message ();
      (rl_readline_state &= ~(0x0000400));
      rl_execute_next (c);
      return 0;
    }
  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 5
8 6
9 8
10 8
11 8
12 17
13 17
14 17
15 17
16 18
17 18
18 19
19 19
20 18
21 19
22 19
23 19
24 10
25 10
26 11
27 12
28 14
29 13
30 14
31 19
32 15
33 19
34 19
35 19
36 19
37 19
38 7
39 19
40 19
41 19
42 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # 80c <set_hunkmax+0xc>
je     850 <set_hunkmax+0x50>
cmpq   $0x0,0x0(%rip)        # 816 <set_hunkmax+0x16>
je     870 <set_hunkmax+0x70>
cmpq   $0x0,0x0(%rip)        # 820 <set_hunkmax+0x20>
je     830 <set_hunkmax+0x30>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 837 <set_hunkmax+0x37>
callq  83c <set_hunkmax+0x3c>
mov    %rax,0x0(%rip)        # 843 <set_hunkmax+0x43>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 857 <set_hunkmax+0x57>
lea    0x0(,%rax,8),%rdi
callq  864 <set_hunkmax+0x64>
mov    %rax,0x0(%rip)        # 86b <set_hunkmax+0x6b>
jmp    80e <set_hunkmax+0xe>
nopl   (%rax)
mov    0x0(%rip),%rax        # 877 <set_hunkmax+0x77>
lea    0x0(,%rax,8),%rdi
callq  884 <set_hunkmax+0x84>
mov    %rax,0x0(%rip)        # 88b <set_hunkmax+0x8b>
jmp    818 <set_hunkmax+0x18>
nopl   (%rax)
<<<sep_in_sample>>>
set_hunkmax (void)
{
    if (!p_line)
 p_line = (char **) xmalloc (hunkmax * sizeof *p_line);
    if (!p_len)
 p_len = (size_t *) xmalloc (hunkmax * sizeof *p_len);
    if (!p_Char)
 p_Char = xmalloc (hunkmax * sizeof *p_Char);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 7
7 7
8 9
9 9
10 9
11 8
12 8
13 8
14 9
15 9
16 9
17 4
18 4
19 4
20 4
21 4
22 4
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     5c0 <make_lowercase+0x40>
movzbl (%rdi),%edx
mov    %rdi,%rbx
test   %dl,%dl
je     5b6 <make_lowercase+0x36>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%edi
add    $0x1,%rbx
callq  5ac <make_lowercase+0x2c>
mov    %al,-0x1(%rbx)
movzbl (%rbx),%edx
test   %dl,%dl
jne    5a0 <make_lowercase+0x20>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    5b9 <make_lowercase+0x39>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_lowercase (char *s)
{
  unsigned char *p;
  if (!s)
    return ((void *)0);
  for (p = (unsigned char*) s; *p; p++)
    *p = tolower (*p);
  return s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 7
16 6
17 6
18 6
19 5
20 9
21 9
22 9
23 9
24 5
25 5
26 5
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
jmpq   1369 <xformat_u_readlink+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_u_readlink(XFORMAT * xux, char * path, char * buf, size_t bufsize)
{
 ;
 return swvarfs_u_readlink(xux->swvarfsM, path, buf, bufsize);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    %edx,%esi
callq  3ecb <define_builtin+0xb>
movzbl 0x8(%rbx),%ecx
movzbl 0x8(%rax),%edx
movl   $0x2,0x18(%rax)
lea    (%rcx,%rcx,1),%esi
mov    %ecx,%edi
and    $0xfffffff3,%edx
lea    (%rdi,%rdi,1),%ecx
and    $0x4,%esi
and    $0x8,%ecx
or     %esi,%edx
or     %ecx,%edx
mov    %dl,0x8(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x20(%rax)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
define_builtin (const char *name, const builtin *bp, symbol_lookup mode)
{
  symbol *sym;
  sym = lookup_symbol (name, mode);
  (((&(sym)->data)->type)) = TOKEN_FUNC;
  ((sym)->macro_args) = bp->groks_macro_args;
  ((sym)->blind_no_args) = bp->blind_if_no_args;
  (((&(sym)->data)->u.func)) = bp->func;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 5
8 6
9 7
10 6
11 7
12 6
13 7
14 7
15 7
16 7
17 8
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remote_setup (void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4_order (void *vstate)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x1,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x38,%esi
push   %rbx
callq  589 <gcide_result_list_append+0x19>
test   %rax,%rax
mov    %rax,%rbx
je     627 <gcide_result_list_append+0xb7>
mov    0x0(%rbp),%rax
mov    %rax,(%rbx)
mov    0x8(%rbp),%rax
mov    %rax,0x8(%rbx)
mov    0x10(%rbp),%rax
mov    %rax,0x10(%rbx)
mov    0x18(%rbp),%rax
mov    %rax,0x18(%rbx)
mov    0x20(%rbp),%rax
mov    %rax,0x20(%rbx)
mov    0x28(%rbp),%rax
mov    %rax,0x28(%rbx)
mov    0x30(%rbp),%rax
mov    %rax,0x30(%rbx)
mov    0x30(%rbp),%rdi
callq  5d5 <gcide_result_list_append+0x65>
test   %rax,%rax
mov    %rax,0x30(%rbx)
je     600 <gcide_result_list_append+0x90>
mov    %rbx,%rsi
mov    %r12,%rdi
callq  5e9 <gcide_result_list_append+0x79>
test   %eax,%eax
je     5fb <gcide_result_list_append+0x8b>
callq  5f2 <gcide_result_list_append+0x82>
mov    (%rax),%esi
cmp    $0xc,%esi
je     607 <gcide_result_list_append+0x97>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  605 <gcide_result_list_append+0x95>
mov    (%rax),%esi
xor    %eax,%eax
mov    $0x0,%edx
mov    $0x4,%edi
callq  618 <gcide_result_list_append+0xa8>
mov    %rbx,%rdi
callq  620 <gcide_result_list_append+0xb0>
mov    $0xffffffff,%eax
jmp    5fb <gcide_result_list_append+0x8b>
callq  62c <gcide_result_list_append+0xbc>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
mov    $0x4,%edi
callq  63f <gcide_result_list_append+0xcf>
mov    $0xffffffff,%eax
jmp    5fb <gcide_result_list_append+0x8b>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gcide_result_list_append(dico_list_t list, struct gcide_ref *ref)
{
    struct gcide_ref *copy = calloc(1,sizeof(*copy));
    if (!copy) {
 dico_log(4, (*__errno_location ()), "gcide_result_list_append");
 return -1;
    }
    *copy = *ref;
    copy->ref_headword = strdup(ref->ref_headword);
    if (!copy->ref_headword ||
 (dico_list_append(list, copy) && (*__errno_location ()) == 12)) {
 dico_log(4, (*__errno_location ()), "gcide_result_list_append");
 free(copy);
 return -1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 3
9 4
10 3
11 4
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 9
27 9
28 10
29 9
30 10
31 11
32 11
33 11
34 10
35 10
36 11
37 11
38 11
39 11
40 16
41 17
42 17
43 17
44 17
45 17
46 17
47 12
48 12
49 12
50 12
51 13
52 13
53 14
54 14
55 5
56 5
57 5
58 5
59 5
60 5
61 6
62 6
63 6
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 10e7 <end_block+0x7>
jne    10f8 <end_block+0x18>
movsbl %sil,%esi
jmpq   5f0 <end_block.part.3>
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
end_block (char *rtname, char codeclass)
{
  if (yaccerror)
    return;
  switch (cblock->quant.kind)
    {
    case 'F':
    case 'I':
    case 'O':
      break;
    default:
      if (codeclass)
 {
   cblock->rtname = rtname;
   cblock->codeclass = codeclass;
 }
      cblev--;
    }
  cblock = cblock->quant.encl;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edx,%edx
xor    %esi,%esi
callq  cd <sbsgetc+0xd>
cmp    $0xa,%eax
jne    d9 <sbsgetc+0x19>
addl   $0x1,0x0(%rip)        # d9 <sbsgetc+0x19>
add    $0x8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
sbsgetc(FILE *sbsfile)
{
  int c;
  c = dgetc(sbsfile, ((void *)0), 0);
  if (c == '\n')
    sbslineno++;
  return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 8
9 8
10 8
<<<sep_out_sample>>>
mov    (%rdi),%r9
cmp    0x8(%rdi),%r9
je     4010 <gsl_matrix_short_transpose+0x30>
sub    $0x8,%rsp
mov    $0x14,%ecx
mov    $0x9a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4006 <gsl_matrix_short_transpose+0x26>
mov    $0x14,%eax
add    $0x8,%rsp
retq   
test   %r9,%r9
je     4070 <gsl_matrix_short_transpose+0x90>
xor    %eax,%eax
lea    0x1(%rax),%r11
cmp    %r9,%r11
je     4070 <gsl_matrix_short_transpose+0x90>
mov    0x10(%rdi),%rdx
mov    %rax,%rsi
mov    0x18(%rdi),%rcx
imul   %rdx,%rsi
lea    (%rdx,%rdx,1),%r10
add    %rsi,%rdx
add    %rdx,%rax
lea    (%rcx,%rax,2),%rdx
lea    (%rcx,%rsi,2),%rcx
mov    %r11,%rax
nopl   0x0(%rax)
movzwl (%rdx),%r8d
movzwl (%rcx,%rax,2),%esi
mov    %r8w,(%rcx,%rax,2)
add    $0x1,%rax
mov    %si,(%rdx)
add    %r10,%rdx
cmp    %r9,%rax
jne    4048 <gsl_matrix_short_transpose+0x68>
mov    %r11,%rax
lea    0x1(%rax),%r11
cmp    %r9,%r11
jne    4020 <gsl_matrix_short_transpose+0x40>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_transpose (gsl_matrix_short * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  size_t i, j, k;
  if (size1 != size2)
    {
      do { gsl_error ("matrix must be square to take transpose", "swap_source.c", 154, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  for (i = 0; i < size1; i++)
    {
      for (j = i + 1 ; j < size2 ; j++)
        {
          for (k = 0; k < 1; k++)
            {
              size_t e1 = (i * m->tda + j) * 1 + k ;
              size_t e2 = (j * m->tda + i) * 1 + k ;
              {
                short tmp = m->data[e1] ;
                m->data[e1] = m->data[e2] ;
                m->data[e2] = tmp ;
              }
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 2
5 8
6 8
7 8
8 8
9 8
10 8
11 27
12 27
13 10
14 10
15 10
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 20
31 19
32 20
33 12
34 21
35 21
36 12
37 12
38 12
39 12
40 12
41 12
42 26
43 27
44 27
<<<sep_out_sample>>>
mov    (%rdx),%rdx
mov    $0x4,%r8d
jmpq   172e <strategy_deny_length_gt_cb+0xe>
xchg   %ax,%ax
<<<sep_in_sample>>>
strategy_deny_length_gt_cb(enum grecs_callback_command cmd,
      grecs_locus_t *locus,
      void *varptr,
      grecs_value_t *value,
      void *cb_data)
{
    return strategy_deny_length(cmd, locus, *(dico_list_t*) varptr,
    value, cmp_gt);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
<<<sep_out_sample>>>
jmpq   885 <meta1free+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1free (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r14
test   $0x10000000,%edx
mov    $0x0,%eax
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    $0x0,%ebp
cmove  %rax,%rbp
push   %rbx
mov    %rsi,%rbx
callq  *%rbp
test   %eax,%eax
sete   %r14b
test   $0x40000000,%r13d
jne    138 <exclude_fnmatch+0x88>
movzbl (%rbx),%ecx
test   %cl,%cl
je     138 <exclude_fnmatch+0x88>
add    $0x1,%rbx
test   %r14b,%r14b
je     108 <exclude_fnmatch+0x58>
jmp    132 <exclude_fnmatch+0x82>
nopl   0x0(%rax,%rax,1)
test   %cl,%cl
je     138 <exclude_fnmatch+0x88>
add    $0x1,%rbx
cmp    $0x2f,%cl
movzbl (%rbx),%ecx
jne    100 <exclude_fnmatch+0x50>
cmp    $0x2f,%cl
je     104 <exclude_fnmatch+0x54>
mov    %rbx,%rsi
mov    %r13d,%edx
mov    %r12,%rdi
callq  *%rbp
movzbl (%rbx),%ecx
test   %eax,%eax
sete   %sil
test   %cl,%cl
je     144 <exclude_fnmatch+0x94>
test   %sil,%sil
je     104 <exclude_fnmatch+0x54>
mov    $0x1,%r14d
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14d,%eax
pop    %r14
retq   
mov    %esi,%r14d
jmp    138 <exclude_fnmatch+0x88>
nopl   0x0(%rax)
<<<sep_in_sample>>>
exclude_fnmatch (char const *pattern, char const *f, int options)
{
  int (*matcher) (char const *, char const *, int) =
    (options & (1 << 28)
     ? fnmatch
     : fnmatch_no_wildcards);
  _Bool matched = ((*matcher) (pattern, f, options) == 0);
  char const *p;
  if (! (options & (1 << 30)))
    for (p = f; *p && ! matched; p++)
      if (*p == '/' && p[1] != '/')
 matched = ((*matcher) (pattern, p + 1, options) == 0);
  return matched;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 2
12 2
13 7
14 7
15 7
16 9
17 9
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 11
30 11
31 11
32 11
33 11
34 12
35 12
36 12
37 12
38 10
39 12
40 12
41 10
42 10
43 10
44 10
45 12
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 12
54 12
55 12
<<<sep_out_sample>>>
mov    0x260(%rdi),%rax
mov    0x8c(%rdi),%edx
movl   $0x0,0x48(%rax)
mov    %edx,0x50(%rax)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
  upsample->spare_full = 0;
  upsample->rows_to_go = cinfo->output_height;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x88(%rdi),%rdi
test   %rdi,%rdi
je     58 <mu_nntp_send+0x58>
mov    0x8(%rbx),%r12
mov    (%rbx),%rbp
cmp    %rbp,%r12
jbe    5b <mu_nntp_send+0x5b>
mov    0x70(%rbx),%edx
movq   $0x0,0x8(%rsp)
test   %edx,%edx
je     70 <mu_nntp_send+0x70>
mov    $0x2,%esi
callq  3d <mu_nntp_send+0x3d>
mov    %eax,%edx
mov    $0x6e,%eax
test   %edx,%edx
je     61 <mu_nntp_send+0x61>
mov    (%rbx),%rsi
mov    0x88(%rbx),%rdi
jmp    73 <mu_nntp_send+0x73>
nopl   0x0(%rax)
mov    (%rbx),%rbp
mov    %rbp,0x8(%rbx)
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rsi
sub    %rbp,%r12
lea    0x8(%rsp),%r8
xor    %ecx,%ecx
mov    %r12,%rdx
callq  85 <mu_nntp_send+0x85>
mov    0x8(%rsp),%rsi
mov    %eax,%ebp
test   %rsi,%rsi
jne    a0 <mu_nntp_send+0xa0>
mov    %ebp,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    (%rbx),%rdi
mov    %r12,%rdx
sub    %rsi,%rdx
add    %rdi,%rsi
callq  b1 <mu_nntp_send+0xb1>
mov    0x8(%rsp),%rax
sub    %rax,0x8(%rbx)
mov    %ebp,%eax
jmp    93 <mu_nntp_send+0x93>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_nntp_send (mu_nntp_t nntp)
{
  int status = 0;
  if (nntp->carrier && (nntp->io.ptr > nntp->io.buf))
    {
      size_t n = 0;
      size_t len = nntp->io.ptr - nntp->io.buf;
      if (nntp->timeout)
 {
   int ready = mu_nntp_carrier_is_ready (nntp->carrier,
      0x2,
      nntp->timeout);
   if (ready == 0)
     return 110;
 }
      status = mu_stream_write (nntp->carrier, nntp->io.buf, len, 0, &n);
      if (n)
 {
   memmove (nntp->io.buf, nntp->io.buf + n, len - n);
   nntp->io.ptr -= n;
 }
    }
  else
    nntp->io.ptr = nntp->io.buf;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 8
14 6
15 8
16 8
17 10
18 10
19 10
20 14
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 24
29 3
30 26
31 26
32 26
33 26
34 26
35 26
36 26
37 7
38 16
39 16
40 16
41 16
42 17
43 16
44 17
45 17
46 16
47 26
48 26
49 26
50 26
51 26
52 26
53 19
54 19
55 19
56 19
57 19
58 20
59 20
60 16
61 16
62 16
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 27 <close_stdout+0x7>
push   %rbx
callq  2d <close_stdout+0xd>
test   %eax,%eax
je     44 <close_stdout+0x24>
cmpb   $0x0,0x0(%rip)        # 38 <close_stdout+0x18>
je     56 <close_stdout+0x36>
callq  3f <close_stdout+0x1f>
cmpl   $0x20,(%rax)
jne    56 <close_stdout+0x36>
mov    0x0(%rip),%rdi        # 4b <close_stdout+0x2b>
callq  50 <close_stdout+0x30>
test   %eax,%eax
jne    88 <close_stdout+0x68>
pop    %rbx
retq   
mov    0x0(%rip),%rdi        # 5d <close_stdout+0x3d>
test   %rdi,%rdi
je     93 <close_stdout+0x73>
callq  67 <close_stdout+0x47>
mov    %rax,%rbx
callq  6f <close_stdout+0x4f>
mov    (%rax),%esi
mov    $0x0,%r8d
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  88 <close_stdout+0x68>
mov    0x0(%rip),%edi        # 8e <close_stdout+0x6e>
callq  93 <close_stdout+0x73>
callq  98 <close_stdout+0x78>
mov    (%rax),%esi
mov    $0x0,%ecx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  ad <close_stdout+0x8d>
jmp    88 <close_stdout+0x68>
<<<sep_in_sample>>>
close_stdout (void)
{
  if (close_stream (stdout) != 0
      && !(ignore_EPIPE && (*__errno_location ()) == 32))
    {
      char const *write_error = ((const char *) ("write error"));
      if (file_name)
        error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
               write_error);
      else
        error (0, (*__errno_location ()), "%s", write_error);
      _exit (exit_failure);
    }
   if (close_stream (stderr) != 0)
     _exit (exit_failure);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 14
12 14
13 14
14 14
15 16
16 16
17 7
18 7
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 15
31 15
32 11
33 11
34 11
35 11
36 11
37 11
38 11
39 11
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  72 <dir_name+0x12>
test   %rax,%rax
lea    0x1(%rax),%r13
mov    %rax,%rbx
sete   %bpl
movzbl %bpl,%edi
add    %r13,%rdi
callq  8c <dir_name+0x2c>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  9a <dir_name+0x3a>
test   %bpl,%bpl
mov    %rax,%rcx
je     a9 <dir_name+0x49>
movb   $0x2e,(%rax,%rbx,1)
mov    %r13,%rbx
movb   $0x0,(%rcx,%rbx,1)
add    $0x8,%rsp
mov    %rcx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dir_name (char const *file)
{
  size_t length = dir_len (file);
  _Bool append_dot = (length == 0
       || (0
    && length == 0
    && file[2] != '\0' && ! ((file[2]) == '/')));
  char *dir = xmalloc (length + append_dot + 1);
  memcpy (dir, file, length);
  if (append_dot)
    dir[length++] = '.';
  dir[length] = '\0';
  return dir;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 8
10 3
11 4
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 10
20 9
21 10
22 11
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  bc <io_read+0xc>
test   %eax,%eax
jne    c8 <io_read+0x18>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    (%rbx),%rdi
mov    %rdi,0x10(%rbx)
pop    %rbx
jmpq   d5 <io_read+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
io_read(void *data, char *buf, size_t size, size_t *pret)
{
    struct _iostr *p = data;
    if (dico_stream_read(p->in, buf, size, pret)) {
 p->last_err = p->in;
 return dico_stream_last_error(p->in);
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 9
8 9
9 9
10 9
11 5
12 5
13 9
14 6
15 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    $0x0,%ebx
sub    $0x10,%rsp
mov    0x90(%r12),%rdi
mov    (%rbx),%rsi
xor    %edx,%edx
callq  9c2 <maildir_create+0x22>
mov    %rax,%rbp
mov    0x128(%r12),%rax
mov    $0x1,%esi
mov    0x30(%rax),%edi
callq  9da <maildir_create+0x3a>
lea    0x8(%rsp),%rdi
mov    %eax,%edx
mov    %rbp,%rsi
or     $0x1c0,%edx
callq  350 <maildir_opendir>
test   %eax,%eax
jne    a14 <maildir_create+0x74>
mov    0x8(%rsp),%rdi
add    $0x8,%rbx
callq  a01 <maildir_create+0x61>
mov    %rbp,%rdi
callq  a09 <maildir_create+0x69>
cmp    $0x0,%rbx
jne    9b0 <maildir_create+0x10>
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
maildir_create (struct _amd_data *amd, int flags)
{
  static char *dirs[] = { "tmp", "new", "cur" };
  int i;
  for (i = 0; i < 3; i++)
    {
      DIR *dir;
      char *tmpname = maildir_mkfilename (amd->name, dirs[i], ((void *)0));
      int rc = maildir_opendir (&dir, tmpname,
    0700 |
    mu_stream_flags_to_mode (amd->mailbox->flags,
        1));
      if (rc)
 return rc;
      closedir (dir);
      free (tmpname);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 8
8 8
9 8
10 8
11 8
12 11
13 11
14 11
15 11
16 9
17 11
18 9
19 9
20 9
21 13
22 13
23 15
24 15
25 15
26 16
27 16
28 5
29 5
30 18
31 19
32 19
33 19
34 19
35 19
36 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 35b <ds_warranty+0xb>
mov    $0x0,%edi
callq  365 <ds_warranty+0x15>
mov    $0xa,%edi
callq  36f <ds_warranty+0x1f>
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
add    $0x8,%rsp
jmpq   384 <ds_warranty+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_warranty(int argc, char **argv)
{
    grecs_print_version_only(&proginfo, stdout);
    putchar('\n');
    printf("%s", gplv3_text);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 5
10 6
11 5
12 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  5c89 <remove_backslashes+0x9>
lea    0x1(%rax),%rdi
mov    $0xdaa,%edx
mov    $0x0,%esi
callq  5c9c <remove_backslashes+0x1c>
test   %rbx,%rbx
je     5ce3 <remove_backslashes+0x63>
movzbl (%rbx),%ecx
mov    %rax,%rdx
test   %cl,%cl
jne    5ccb <remove_backslashes+0x4b>
jmp    5cde <remove_backslashes+0x5e>
nopl   (%rax)
mov    %rbx,%rsi
add    $0x1,%rdx
mov    %cl,-0x1(%rdx)
add    $0x1,%rsi
je     5cde <remove_backslashes+0x5e>
movzbl 0x1(%rbx),%ecx
test   %cl,%cl
je     5cde <remove_backslashes+0x5e>
mov    %rsi,%rbx
cmp    $0x5c,%cl
sete   %cl
movzbl %cl,%ecx
add    %rcx,%rbx
movzbl (%rbx),%ecx
test   %cl,%cl
jne    5cb0 <remove_backslashes+0x30>
movb   $0x0,(%rdx)
pop    %rbx
retq   
mov    %rax,%rdx
jmp    5cde <remove_backslashes+0x5e>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remove_backslashes (string)
     char *string;
{
  char *r, *ret, *s;
  r = ret = (char *)sh_xmalloc((strlen (string) + 1), "subst.c", 3498);
  for (s = string; s && *s; )
    {
      if (*s == '\\')
 s++;
      if (*s == 0)
 break;
      *r++ = *s++;
    }
  *r = '\0';
  return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 5
12 6
13 6
14 6
15 6
16 6
17 12
18 12
19 6
20 6
21 6
22 6
23 6
24 12
25 9
26 9
27 9
28 9
29 10
30 10
31 10
32 14
33 16
34 16
35 5
36 5
37 5
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r11
cmp    (%rdi),%r11
mov    0x8(%rdi),%rax
je     29f0 <gsl_matrix_uint_div_elements+0x40>
mov    $0x13,%ecx
mov    $0x73,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  29dd <gsl_matrix_uint_div_elements+0x2d>
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%r10
cmp    %rax,%r10
jne    29c4 <gsl_matrix_uint_div_elements+0x14>
test   %r11,%r11
mov    0x10(%rdi),%r14
mov    0x10(%rsi),%r13
je     2a56 <gsl_matrix_uint_div_elements+0xa6>
shl    $0x2,%r14
shl    $0x2,%r13
xor    %r12d,%r12d
xor    %ebp,%ebp
xor    %ebx,%ebx
nopl   (%rax)
test   %r10,%r10
je     2a47 <gsl_matrix_uint_div_elements+0x97>
mov    %rbp,%r9
mov    %r12,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %ecx,%ecx
nopl   (%rax)
mov    (%r9,%rcx,4),%eax
xor    %edx,%edx
divl   (%r8,%rcx,4)
mov    %eax,(%r9,%rcx,4)
add    $0x1,%rcx
cmp    %r10,%rcx
jne    2a30 <gsl_matrix_uint_div_elements+0x80>
add    $0x1,%rbx
add    %r14,%rbp
add    %r13,%r12
cmp    %r11,%rbx
jne    2a18 <gsl_matrix_uint_div_elements+0x68>
xor    %eax,%eax
jmp    29e2 <gsl_matrix_uint_div_elements+0x32>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_div_elements (gsl_matrix_uint * a, const gsl_matrix_uint * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 115, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] /= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 18
45 18
46 18
47 18
48 16
49 16
50 16
51 14
52 14
53 14
54 14
55 14
56 21
57 21
58 21
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <newlabel+0x6>
lea    0x1(%rax),%edx
mov    %edx,0x0(%rip)        # f <newlabel+0xf>
retq   
<<<sep_in_sample>>>
newlabel (void )
{
  return (lediglabel++);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2529 <ssh_scan_string+0x9>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   2534 <ssh_scan_string+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ssh_scan_string (const char * yystr )
{
 return ssh_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     46f <gsl_vector_int_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  465 <gsl_vector_int_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     4a3 <gsl_vector_int_memcpy+0x63>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%esi
add    $0x1,%rax
add    %r10,%rcx
mov    %esi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    490 <gsl_vector_int_memcpy+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_memcpy (gsl_vector_int * dest,
                               const gsl_vector_int * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
lea    (%rsi,%rdx,1),%eax
sub    $0x8,%rsp
cmp    %ecx,%eax
jb     220 <gsl_cdf_hypergeometric_P+0x70>
cmp    %esi,%edi
jb     1d0 <gsl_cdf_hypergeometric_P+0x20>
movsd  0x0(%rip),%xmm0        # 1c7 <gsl_cdf_hypergeometric_P+0x17>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
cmp    %ecx,%edi
jae    1bf <gsl_cdf_hypergeometric_P+0xf>
mov    %esi,%eax
cvtsi2sd %rax,%xmm2
mov    %ecx,%eax
cvtsi2sd %rax,%xmm0
mov    %edx,%eax
cvtsi2sd %rax,%xmm1
mov    %edi,%eax
mulsd  %xmm2,%xmm0
addsd  %xmm2,%xmm1
divsd  %xmm1,%xmm0
cvtsi2sd %rax,%xmm1
ucomisd %xmm0,%xmm1
jb     250 <gsl_cdf_hypergeometric_P+0xa0>
callq  0 <upper_tail>
movapd %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 213 <gsl_cdf_hypergeometric_P+0x63>
add    $0x8,%rsp
subsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    $0x1,%ecx
mov    $0x77,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  239 <gsl_cdf_hypergeometric_P+0x89>
movsd  0x0(%rip),%xmm0        # 241 <gsl_cdf_hypergeometric_P+0x91>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
add    $0x8,%rsp
jmpq   c0 <lower_tail>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_cdf_hypergeometric_P (const unsigned int k,
                          const unsigned int n1,
                          const unsigned int n2, const unsigned int t)
{
  double P;
  if (t > (n1 + n2))
    {
      do { gsl_error ("t larger than population size", "hypergeometric.c", 119, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  else if (k >= n1 || k >= t)
    {
      P = 1.0;
    }
  else if (k < 0.0)
    {
      P = 0.0;
    }
  else
    {
      double midpoint = ((double)t * n1) / ((double)n1 + (double)n2);
      if (k >= midpoint)
        {
          P = 1 - upper_tail (k, n1, n2, t);
        }
      else
        {
          P = lower_tail (k, n1, n2, t);
        }
    }
  return P;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
5 10
6 10
7 12
8 31
9 31
10 31
11 10
12 10
13 20
14 20
15 20
16 20
17 20
18 20
19 21
20 20
21 20
22 20
23 21
24 21
25 21
26 23
27 23
28 23
29 31
30 23
31 31
32 31
33 8
34 8
35 8
36 8
37 8
38 8
39 31
40 31
41 31
42 31
43 27
44 27
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
test   %rbx,%rbx
je     96 <_gdbm_full_write+0x36>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  80 <_gdbm_full_write+0x20>
cmp    $0xffffffffffffffff,%rax
je     a0 <_gdbm_full_write+0x40>
test   %rax,%rax
je     b8 <_gdbm_full_write+0x58>
sub    %rax,%rbx
add    %rax,%rbp
test   %rbx,%rbx
jne    72 <_gdbm_full_write+0x12>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   (%rax)
callq  a5 <_gdbm_full_write+0x45>
cmpl   $0x4,(%rax)
je     6d <_gdbm_full_write+0xd>
pop    %rbx
pop    %rbp
mov    $0x4,%eax
pop    %r12
retq   
nopl   0x0(%rax)
callq  bd <_gdbm_full_write+0x5d>
movl   $0x1c,(%rax)
jmp    aa <_gdbm_full_write+0x4a>
<<<sep_in_sample>>>
_gdbm_full_write (GDBM_FILE dbf, void *buffer, size_t size)
{
  char *ptr = buffer;
  while (size)
    {
      ssize_t wrbytes = _gdbm_mapped_write(dbf, ptr, size);
      if (wrbytes == -1)
 {
   if ((*__errno_location ()) == 4)
     continue;
   return 4;
 }
      if (wrbytes == 0)
 {
   (*__errno_location ()) = 28;
   return 4;
 }
      ptr += wrbytes;
      size -= wrbytes;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 6
10 6
11 6
12 6
13 7
14 7
15 13
16 13
17 19
18 18
19 4
20 4
21 22
22 22
23 21
24 22
25 22
26 22
27 9
28 9
29 9
30 22
31 22
32 16
33 22
34 22
35 22
36 15
37 15
38 15
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
cmp    %rsi,0x18(%rdi)
mov    %rsi,%rbx
ja     5e8 <smtp_reply_has_string+0x18>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %rdx,%r12
mov    %rcx,%rbp
callq  5f3 <smtp_reply_has_string+0x23>
lea    0x4(%rax),%rdi
mov    %r12,%rsi
callq  5ff <smtp_reply_has_string+0x2f>
test   %rax,%rax
je     5dd <smtp_reply_has_string+0xd>
test   %rbp,%rbp
je     620 <smtp_reply_has_string+0x50>
mov    %rbx,0x0(%rbp)
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
jmp    5df <smtp_reply_has_string+0xf>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_reply_has_string (ANUBIS_SMTP_REPLY reply, size_t index,
         const char *key, size_t *pind)
{
  if (index < reply->line_count)
    if (strstr (smtp_reply_line (reply, index) + 4, key) != ((void *)0))
      {
 if (pind)
   *pind = index;
 return 1;
      }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 3
6 4
7 11
8 12
9 12
10 12
11 12
12 12
13 12
14 12
15 5
16 5
17 5
18 5
19 5
20 5
21 7
22 7
23 8
24 9
25 12
26 12
27 12
28 12
29 12
30 9
31 9
32 9
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x0,%eax
movb   $0x0,0x0(%rip)        # f <flags_to_string+0xf>
cmovne %rsi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
flags_to_string (u_int flags, char *def)
{
  static char string[128];
  char *prefix;
  string[0] = '\0';
  prefix = ((void *)0);
  return (prefix == ((void *)0) && def != ((void *)0) ? def : string);
}
<<<sep_in_sample>>>
1 7
2 7
3 5
4 7
5 8
6 8
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     d3d <SkipComment+0x3d>
mov    0x18(%rdi),%rax
cmpb   $0x0,(%rax)
je     d70 <SkipComment+0x70>
add    $0x1,%rax
jmp    d2a <SkipComment+0x2a>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
cmpb   $0x0,-0x1(%rax)
je     d40 <SkipComment+0x40>
mov    %rax,0x18(%rbx)
cmpb   $0xa,-0x1(%rax)
jne    d20 <SkipComment+0x20>
addl   $0x1,0x20(%rbx)
cmpb   $0x0,(%rax)
je     d60 <SkipComment+0x60>
pop    %rbx
retq   
nop
mov    $0x1000,%esi
mov    %rbx,%rdi
callq  d4d <SkipComment+0x4d>
cmp    $0xffffffff,%eax
mov    0x18(%rbx),%rax
jne    d12 <SkipComment+0x12>
jmp    d34 <SkipComment+0x34>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    $0x1000,%esi
pop    %rbx
jmpq   d6e <SkipComment+0x6e>
xchg   %ax,%ax
mov    $0x1000,%esi
callq  d7a <SkipComment+0x7a>
mov    0x18(%rbx),%rax
jmp    d12 <SkipComment+0x12>
<<<sep_in_sample>>>
SkipComment (PINPUTBUF pibIn)
{
  if (!pibIn)
    return;
  if (!*pibIn->pbufCur)
    FillBuffer (pibIn, 0x1000);
  while (*pibIn->pbufCur++ != ('\n'))
    if (!*pibIn->pbufCur)
      if (FillBuffer (pibIn, 0x1000) == (-1))
    break;
  pibIn->iLineNum++;
  if (!*pibIn->pbufCur)
    FillBuffer (pibIn, 0x1000);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 8
13 8
14 7
15 7
16 7
17 11
18 12
19 12
20 14
21 14
22 14
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 13
32 13
33 14
34 13
35 13
36 6
37 6
38 6
39 6
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 1fc6 <sv_terminal+0x6>
test   %edx,%edx
je     1fd4 <sv_terminal+0x14>
mov    0x0(%rip),%eax        # 1fd0 <sv_terminal+0x10>
test   %eax,%eax
je     1fe0 <sv_terminal+0x20>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1fee <sv_terminal+0x2e>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   1ffa <sv_terminal+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_terminal (name)
     char *name;
{
  if (interactive_shell && no_line_editing == 0)
    rl_reset_terminal (get_string_value ("TERM"));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 3
10 5
11 5
12 6
13 5
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  803 <sv_editmode+0x13>
test   %eax,%eax
je     840 <sv_editmode+0x50>
mov    $0x5,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  819 <sv_editmode+0x29>
test   %eax,%eax
jne    838 <sv_editmode+0x48>
movq   $0x0,0x0(%rip)        # 828 <sv_editmode+0x38>
movl   $0x1,0x0(%rip)        # 832 <sv_editmode+0x42>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
nop
movq   $0x0,0x0(%rip)        # 84b <sv_editmode+0x5b>
movl   $0x0,0x0(%rip)        # 855 <sv_editmode+0x65>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_editmode (value)
     const char *value;
{
  if (strncasecmp (value, "vi", 2) == 0)
    {
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = 0;
      return 0;
    }
  else if (strncasecmp (value, "emacs", 5) == 0)
    {
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = 1;
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 3
5 4
6 4
7 4
8 10
9 10
10 10
11 10
12 10
13 10
14 12
15 13
16 17
17 17
18 17
19 16
20 17
21 17
22 17
23 6
24 7
25 17
26 17
27 17
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %r8,%r14
push   %r13
mov    %esi,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %r9d,%ebp
push   %rbx
mov    %ecx,%ebx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # 6cd7 <us_ne_hdy+0x27>
movl   $0x0,0x0(%rip)        # 6ce1 <us_ne_hdy+0x31>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  6ced <us_ne_hdy+0x3d>
mov    0x0(%rip),%edi        # 6cf3 <us_ne_hdy+0x43>
mov    %ebx,%edx
xor    %r8d,%r8d
mov    $0x5,%ecx
mov    $0x4,%esi
callq  6d07 <us_ne_hdy+0x57>
mov    0x0(%rip),%rdi        # 6d0e <us_ne_hdy+0x5e>
mov    0x0(%rip),%r15        # 6d15 <us_ne_hdy+0x65>
mov    %eax,0x2c(%rsp)
callq  6d1e <us_ne_hdy+0x6e>
mov    0x70(%rsp),%ecx
mov    0x2c(%rsp),%r9d
mov    %r13d,%esi
mov    (%r12),%edi
mov    %ebp,0x18(%rsp)
mov    $0x0,%r8d
mov    %r14,0x10(%rsp)
mov    %ebx,0x8(%rsp)
mov    %rax,%rdx
mov    %ecx,0x20(%rsp)
movl   $0x4,(%rsp)
mov    %r15,%rcx
callq  6d57 <us_ne_hdy+0xa7>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
us_ne_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "US_NE";
  observe_us_hdy = 0;
  us_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (dvec[4 - 1], 4, year, 5, (!(0==0)));
  holiday (*init_data, detected, gettext(hd_text[27].ht_text),
    ptr_cc_id, "+", day, 4, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 12
15 13
16 13
17 13
18 14
19 14
20 14
21 14
22 14
23 14
24 15
25 15
26 14
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 17
42 17
43 17
44 17
45 17
46 17
47 17
48 17
49 17
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   828 <ahs_set_from_new_cpio_header+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahs_set_from_new_cpio_header(AHS * xhs, void *vfh) {
 ;
 taru_filehdr2filehdr((struct new_cpio_header*)(ahs_vfile_hdr(xhs)), (struct new_cpio_header*)(vfh));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
movsbq (%rdi),%rbx
test   %bl,%bl
je     60 <is_blank_line+0x60>
cmp    $0x3a,%bl
je     60 <is_blank_line+0x60>
cmp    $0xa,%bl
je     60 <is_blank_line+0x60>
nopl   0x0(%rax,%rax,1)
callq  25 <is_blank_line+0x25>
mov    (%rax),%rax
jmp    47 <is_blank_line+0x47>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
movsbq 0x0(%rbp),%rbx
test   %bl,%bl
je     60 <is_blank_line+0x60>
cmp    $0x3a,%bl
je     60 <is_blank_line+0x60>
cmp    $0xa,%bl
je     60 <is_blank_line+0x60>
testb  $0x20,0x1(%rax,%rbx,2)
jne    30 <is_blank_line+0x30>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
is_blank_line(char * s)
{
 while(*s && *s != ':' && *s != '\n') {
  if (
   ((*__ctype_b_loc ())[(int) ((*s))] & (unsigned short int) _ISspace)
  ) {
   ;
  } else {
   return 0;
  }
  s++;
 }
 return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 11
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 4
26 4
27 14
28 9
29 14
30 14
31 14
32 14
33 14
34 13
35 14
36 14
37 14
38 14
<<<sep_out_sample>>>
lea    0x1(%rdi,%rdi,1),%eax
sub    $0x38,%rsp
movapd %xmm0,%xmm7
sqrtsd %xmm0,%xmm0
cvtsi2sd %eax,%xmm5
ucomisd %xmm0,%xmm0
movapd %xmm5,%xmm2
mulsd  %xmm5,%xmm2
movapd %xmm2,%xmm6
mulsd  %xmm2,%xmm6
movapd %xmm6,%xmm1
mulsd  %xmm2,%xmm1
jp     1a2 <asymptotic+0x1a2>
movapd %xmm0,%xmm3
mulsd  0x0(%rip),%xmm7        # 42 <asymptotic+0x42>
movsd  0x0(%rip),%xmm4        # 4a <asymptotic+0x4a>
addsd  %xmm0,%xmm3
movsd  0x0(%rip),%xmm11        # 57 <asymptotic+0x57>
movsd  0x0(%rip),%xmm12        # 60 <asymptotic+0x60>
mulsd  %xmm2,%xmm12
mulsd  %xmm3,%xmm4
movapd %xmm7,%xmm0
mulsd  %xmm5,%xmm3
movapd %xmm5,%xmm7
mulsd  %xmm11,%xmm7
movapd %xmm4,%xmm10
addsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 8b <asymptotic+0x8b>
mulsd  %xmm4,%xmm10
addsd  %xmm2,%xmm3
movapd %xmm10,%xmm9
mulsd  0x0(%rip),%xmm3        # a1 <asymptotic+0xa1>
mulsd  %xmm4,%xmm9
movapd %xmm9,%xmm8
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # b7 <asymptotic+0xb7>
mulsd  %xmm4,%xmm8
addsd  %xmm2,%xmm3
mulsd  %xmm7,%xmm3
divsd  %xmm4,%xmm3
mulsd  %xmm8,%xmm4
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # d9 <asymptotic+0xd9>
mulsd  %xmm6,%xmm3
addsd  %xmm12,%xmm3
addsd  0x0(%rip),%xmm3        # ea <asymptotic+0xea>
mulsd  %xmm11,%xmm3
divsd  %xmm10,%xmm3
movsd  0x0(%rip),%xmm10        # fd <asymptotic+0xfd>
mulsd  %xmm2,%xmm10
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 10e <asymptotic+0x10e>
mulsd  %xmm6,%xmm3
addsd  %xmm10,%xmm3
addsd  0x0(%rip),%xmm3        # 11f <asymptotic+0x11f>
mulsd  %xmm7,%xmm3
movsd  0x0(%rip),%xmm7        # 12b <asymptotic+0x12b>
mulsd  %xmm6,%xmm7
divsd  %xmm9,%xmm3
mulsd  0x0(%rip),%xmm6        # 13c <asymptotic+0x13c>
subsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm3        # 148 <asymptotic+0x148>
mulsd  %xmm1,%xmm3
mulsd  0x0(%rip),%xmm1        # 154 <asymptotic+0x154>
addsd  %xmm7,%xmm3
movsd  0x0(%rip),%xmm7        # 160 <asymptotic+0x160>
mulsd  %xmm2,%xmm7
mulsd  0x0(%rip),%xmm2        # 16c <asymptotic+0x16c>
addsd  %xmm6,%xmm1
addsd  %xmm7,%xmm3
addsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm3        # 180 <asymptotic+0x180>
addsd  0x0(%rip),%xmm1        # 188 <asymptotic+0x188>
add    $0x38,%rsp
divsd  %xmm8,%xmm3
mulsd  %xmm5,%xmm1
subsd  %xmm3,%xmm0
divsd  %xmm4,%xmm1
subsd  %xmm1,%xmm0
retq   
movapd %xmm7,%xmm0
movsd  %xmm1,0x28(%rsp)
movsd  %xmm6,0x20(%rsp)
movsd  %xmm2,0x18(%rsp)
movsd  %xmm5,0x10(%rsp)
movsd  %xmm7,0x8(%rsp)
callq  1c9 <asymptotic+0x1c9>
movsd  0x28(%rsp),%xmm1
movsd  0x20(%rsp),%xmm6
movsd  0x18(%rsp),%xmm2
movsd  0x10(%rsp),%xmm5
movsd  0x8(%rsp),%xmm7
jmpq   36 <asymptotic+0x36>
nopl   0x0(%rax)
<<<sep_in_sample>>>
asymptotic(int order, double qq)
{
  double asymp;
  double nn, n2, n4, n6;
  double hh, ah, ah2, ah3, ah4, ah5;
  nn = 2*order + 1;
  n2 = nn*nn;
  n4 = n2*n2;
  n6 = n4*n2;
  hh = 2*sqrt(qq);
  ah = 16*hh;
  ah2 = ah*ah;
  ah3 = ah2*ah;
  ah4 = ah3*ah;
  ah5 = ah4*ah;
  asymp = -2*qq + nn*hh - 0.125*(n2 + 1);
  asymp -= 0.25*nn*( n2 + 3)/ah;
  asymp -= 0.25* ( 5*n4 + 34*n2 + 9)/ah2;
  asymp -= 0.25*nn*( 33*n4 + 410*n2 + 405)/ah3;
  asymp -= ( 63*n6 + 1260*n4 + 2943*n2 + 486)/ah4;
  asymp -= nn*(527*n6 + 15617*n4 + 69001*n2 + 41607)/ah5;
  return asymp;
}
<<<sep_in_sample>>>
1 6
2 2
3 2
4 10
5 6
6 10
7 7
8 7
9 8
10 8
11 9
12 9
13 10
14 10
15 16
16 11
17 10
18 17
19 18
20 18
21 11
22 16
23 16
24 17
25 17
26 12
27 16
28 16
29 12
30 16
31 13
32 16
33 13
34 14
35 16
36 17
37 14
38 17
39 17
40 17
41 15
42 17
43 18
44 18
45 18
46 18
47 18
48 18
49 19
50 19
51 18
52 19
53 19
54 19
55 19
56 19
57 20
58 20
59 19
60 21
61 19
62 20
63 20
64 21
65 20
66 20
67 20
68 21
69 21
70 20
71 21
72 20
73 21
74 23
75 20
76 21
77 20
78 21
79 21
80 23
81 10
82 10
83 10
84 10
85 10
86 10
87 10
88 10
89 10
90 10
91 10
92 10
93 10
94 10
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 1d <close_stdin+0xd>
mov    %rbx,%rdi
callq  25 <close_stdin+0x15>
test   %rax,%rax
mov    %rbx,%rdi
jne    90 <close_stdin+0x80>
callq  32 <close_stdin+0x22>
test   %eax,%eax
je     c6 <close_stdin+0xb6>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  4a <close_stdin+0x3a>
mov    0x0(%rip),%rdi        # 51 <close_stdin+0x41>
mov    %rax,%rbx
test   %rdi,%rdi
je     d8 <close_stdin+0xc8>
callq  5e <close_stdin+0x4e>
mov    %rax,%rbp
callq  66 <close_stdin+0x56>
mov    (%rax),%esi
mov    %rbx,%r8
mov    %rbp,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  7c <close_stdin+0x6c>
callq  81 <close_stdin+0x71>
mov    0x0(%rip),%edi        # 87 <close_stdin+0x77>
callq  8c <close_stdin+0x7c>
nopl   0x0(%rax)
xor    %esi,%esi
mov    $0x1,%edx
callq  9c <close_stdin+0x8c>
test   %eax,%eax
mov    0x0(%rip),%rdi        # a5 <close_stdin+0x95>
jne    2d <close_stdin+0x1d>
callq  ac <close_stdin+0x9c>
mov    0x0(%rip),%rdi        # b3 <close_stdin+0xa3>
mov    %eax,%ebx
callq  ba <close_stdin+0xaa>
test   %eax,%eax
jne    40 <close_stdin+0x30>
test   %ebx,%ebx
jne    40 <close_stdin+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   d1 <close_stdin+0xc1>
nopl   0x0(%rax)
callq  dd <close_stdin+0xcd>
mov    (%rax),%esi
mov    %rbx,%rcx
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  f0 <close_stdin+0xe0>
jmp    7c <close_stdin+0x6c>
<<<sep_in_sample>>>
close_stdin (void)
{
  _Bool fail = 0;
  if (freadahead (stdin) > 0)
    {
      if (rpl_fseeko (stdin, 0, 1) == 0 && rpl_fflush (stdin) != 0)
        fail = 1;
    }
  if (close_stream (stdin) != 0)
    fail = 1;
  if (fail)
    {
      char const *close_error = gettext ("error closing file");
      if (file_name)
        error (0, (*__errno_location ()), "%s: %s", quotearg_colon (file_name),
               close_error);
      else
        error (0, (*__errno_location ()), "%s", close_error);
    }
  close_stdout ();
  if (fail)
    _exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 4
9 4
10 9
11 9
12 9
13 9
14 13
15 13
16 14
17 13
18 14
19 14
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 15
29 15
30 20
31 22
32 22
33 22
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 9
42 6
43 9
44 9
45 9
46 11
47 11
48 23
49 23
50 23
51 20
52 20
53 18
54 18
55 18
56 18
57 18
58 18
59 18
60 18
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%rbx
test   %rbx,%rbx
je     409 <align+0x29>
mov    %rbx,%rdi
callq  3f9 <align+0x19>
lea    0x1(%rax),%rsi
mov    %rbx,%rdi
callq  405 <align+0x25>
mov    %rax,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
align(char **str)
{
    ((void) (0));
    if (*str != ((void *)0))
 *str = (char *)nrealloc(*str, (strlen(*str) + 1) * sizeof(char));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1e6 <cdio_audio_stop+0x26>
mov    0x40(%rdi),%rax
test   %rax,%rax
je     1e0 <cdio_audio_stop+0x20>
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
<<<sep_in_sample>>>
cdio_audio_stop (CdIo_t *p_cdio)
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (p_cdio->op.audio_stop) {
    return p_cdio->op.audio_stop(p_cdio->env);
  } else {
    return DRIVER_OP_UNSUPPORTED;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 7
10 9
11 3
12 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
callq  776f <checkmatch+0xf>
mov    %rbx,%rdi
mov    %rax,%r12
callq  777a <checkmatch+0x1a>
xor    %edx,%edx
cmp    %rax,%r12
ja     7796 <checkmatch+0x36>
mov    %r12,%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  778f <checkmatch+0x2f>
xor    %edx,%edx
test   %eax,%eax
sete   %dl
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
checkmatch(const char *text,const char *unit)
{
  return strlen(text)<=strlen(unit) && !strncmp(text,unit,strlen(text));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 4
21 4
22 4
23 4
24 4
25 4
<<<sep_out_sample>>>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    0x0(%rax),%edx
add    $0x4,%rax
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
cmp    $0x18,%rax
jne    58 <resetColors+0x8>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
resetColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    FG_COLOR[i] = oldFGColors[i];
    BG_COLOR[i] = oldBGColors[i];
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 7
7 7
8 4
9 4
10 9
11 9
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  548f <set_option_num+0xf>
xor    %edx,%edx
mov    %rax,%rbx
xor    %esi,%esi
movl   $0x0,(%rax)
mov    %rbp,%rdi
callq  54a4 <set_option_num+0x24>
mov    (%rbx),%edx
test   %edx,%edx
jne    54c0 <set_option_num+0x40>
test   %rax,%rax
jle    54c0 <set_option_num+0x40>
pop    %rbx
pop    %rbp
mov    %eax,(%r12)
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  54ca <set_option_num+0x4a>
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdi
xor    %eax,%eax
jmpq   54d8 <set_option_num+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_option_num(int *pnum, const char *value)
{
 long n;
 (*__errno_location ()) = 0;
 n = strtol(value, ((void *)0), 0);
 if ((*__errno_location ()) == 0 && n > 0)
  *pnum = n;
 else
  d_error(gettext("invalid number"));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 4
9 5
10 4
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 7
21 10
22 10
23 10
24 9
25 9
26 10
27 10
28 10
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1f6 <taruib_set_fd+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taruib_set_fd(int fd)
{
 g_taruib_gst_fdM = fd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  69 <echo_free_db+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
echo_free_db(dico_handle_t hp)
{
    free(hp);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 7cb <grecs_include_path_clear+0xb>
test   %rdi,%rdi
je     7d5 <grecs_include_path_clear+0x15>
callq  7d5 <grecs_include_path_clear+0x15>
mov    0x0(%rip),%rdi        # 7dc <grecs_include_path_clear+0x1c>
test   %rdi,%rdi
je     7f0 <grecs_include_path_clear+0x30>
add    $0x8,%rsp
jmpq   7ea <grecs_include_path_clear+0x2a>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_include_path_clear()
{
 if (grecs_usr_include_path)
  grecs_list_clear(grecs_usr_include_path);
 if (grecs_std_include_path)
  grecs_list_clear(grecs_std_include_path);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     31f <gsl_vector_ulong_memcpy+0x2f>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x1d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  315 <gsl_vector_ulong_memcpy+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
mov    0x8(%rsi),%r10
mov    0x8(%rdi),%r9
je     355 <gsl_vector_ulong_memcpy+0x65>
mov    0x10(%rsi),%rcx
mov    0x10(%rdi),%rdx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %eax,%eax
xchg   %ax,%ax
mov    (%rcx),%rsi
add    $0x1,%rax
add    %r10,%rcx
mov    %rsi,(%rdx)
add    %r9,%rdx
cmp    %r8,%rax
jne    340 <gsl_vector_ulong_memcpy+0x50>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_memcpy (gsl_vector_ulong * dest,
                               const gsl_vector_ulong * src)
{
  const size_t src_size = src->size;
  const size_t dest_size = dest->size;
  if (src_size != dest_size)
    {
      do { gsl_error ("vector lengths are not equal", "copy_source.c", 29, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  {
    const size_t src_stride = src->stride ;
    const size_t dest_stride = dest->stride ;
    size_t j;
    for (j = 0; j < src_size; j++)
      {
        size_t k;
        for (k = 0; k < 1; k++)
          {
            dest->data[1 * dest_stride * j + k]
              = src->data[1 * src_stride * j + k];
          }
      }
  }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 3
5 8
6 8
7 8
8 8
9 8
10 8
11 25
12 25
13 14
14 11
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 20
24 14
25 14
26 20
27 20
28 14
29 14
30 24
31 25
32 25
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1c9 <xcalloc+0x9>
test   %rax,%rax
je     1d3 <xcalloc+0x13>
add    $0x8,%rsp
retq   
callq  1d8 <xcalloc+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  if ((! HAVE_GNU_CALLOC && ((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 8
6 8
7 6
8 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rdi,%rax
push   %rbx
mov    %rdx,%rbx
mov    %rsi,%rdi
mov    %rax,%rdx
mov    %rbx,%rsi
callq  8e0 <insert_num>
test   %rax,%rax
je     b50 <parse_gid+0x40>
cmpq   $0x63,0x40(%rax)
movss  0x0(%rip),%xmm0        # b37 <parse_gid+0x27>
ja     b41 <parse_gid+0x31>
movss  0x0(%rip),%xmm0        # b41 <parse_gid+0x31>
movss  %xmm0,0x24(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
subl   $0x1,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *p = insert_num (argv, arg_ptr, entry);
  if (p)
    {
      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
      return 1;
    }
  else
    {
      --*arg_ptr;
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 7
16 14
17 14
18 14
19 11
20 12
21 14
22 14
23 14
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # b07 <print_total_stats+0x7>
mov    $0xa,%ecx
mov    $0xa,%edx
mov    $0x0,%esi
jmpq   b1b <print_total_stats+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_total_stats (void)
{
  format_total_stats (stderr, default_total_format, '\n', '\n');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 597 <do_statusbar_right+0x7>
mov    0x0(%rip),%rsi        # 59e <do_statusbar_right+0xe>
cmpb   $0x0,(%rdi,%rsi,1)
jne    5b0 <do_statusbar_right+0x20>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
callq  5b9 <do_statusbar_right+0x29>
mov    %rax,0x0(%rip)        # 5c0 <do_statusbar_right+0x30>
add    $0x8,%rsp
jmpq   5c9 <do_statusbar_right+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
do_statusbar_right(void)
{
    if (answer[statusbar_x] != '\0') {
 statusbar_x = move_mbright(answer, statusbar_x);
 update_the_statusbar();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 2
8 4
9 4
10 7
11 5
12 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     74 <rec_sex_parser_destroy+0x14>
xor    %eax,%eax
callq  74 <rec_sex_parser_destroy+0x14>
mov    (%rbx),%rdi
callq  7c <rec_sex_parser_destroy+0x1c>
mov    %rbx,%rdi
pop    %rbx
jmpq   85 <rec_sex_parser_destroy+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_parser_destroy (rec_sex_parser_t parser)
{
  if (parser->scanner)
    {
      sexlex_destroy (parser->scanner);
    }
  free (parser->in);
  free (parser);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 7
9 7
10 8
11 9
12 8
13 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %rsi,%rsi
mov    %rdx,%rcx
setne  %al
mov    %rsi,0x8(%rsp)
lea    0x8(%rsp),%rsi
movzbl %al,%eax
mov    %rax,%rdx
callq  22 <__gmpz_ui_pow_ui+0x22>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmpz_ui_pow_ui (mpz_ptr r, unsigned long b, unsigned long e)
{
    {
      __gmpz_n_pow_ui (r, &b, (mp_size_t) (b != 0), e);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 2
6 4
7 4
8 4
9 4
10 6
11 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 76b <yypop_buffer_state+0xb>
test   %rbx,%rbx
je     7b7 <yypop_buffer_state+0x57>
mov    0x0(%rip),%rbp        # 777 <yypop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     7b7 <yypop_buffer_state+0x57>
callq  789 <yypop_buffer_state+0x29>
test   %rbp,%rbp
movq   $0x0,(%r12)
je     7b7 <yypop_buffer_state+0x57>
sub    $0x1,%rbp
cmpq   $0x0,(%rbx,%rbp,8)
mov    %rbp,0x0(%rip)        # 7a6 <yypop_buffer_state+0x46>
je     7b7 <yypop_buffer_state+0x57>
callq  d0 <yy_load_buffer_state>
movl   $0x1,0x0(%rip)        # 7b7 <yypop_buffer_state+0x57>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
yypop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 yy_delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  yy_load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 7
14 6
15 7
16 8
17 9
18 8
19 9
20 10
21 11
22 13
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
sub    0x8(%rdx),%rcx
mov    (%rsi),%rax
sub    (%rdx),%rax
test   %rcx,%rcx
mov    %rcx,0x8(%rdi)
mov    %rax,(%rdi)
jns    77c <rec_timespec_subtract+0x2c>
sub    $0x1,%rax
add    $0x3b9aca00,%rcx
mov    %rax,(%rdi)
mov    %rcx,0x8(%rdi)
shr    $0x3f,%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_timespec_subtract (struct timespec *result,
                       struct timespec *x,
                       struct timespec *y)
{
  result->tv_sec = x->tv_sec - y->tv_sec;
  result->tv_nsec = x->tv_nsec - y->tv_nsec;
  if (result->tv_nsec < 0)
    {
      result->tv_sec--;
      result->tv_nsec += 1000000000;
    }
  return (result->tv_sec < 0);
}
<<<sep_in_sample>>>
1 6
2 6
3 5
4 5
5 7
6 6
7 5
8 7
9 9
10 10
11 9
12 10
13 12
14 13
15 13
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xb0(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_iterator_next (gl_list_iterator_t *iterator,
         const void **eltp, gl_list_node_t *nodep)
{
  return iterator->vtable->iterator_next (iterator, eltp, nodep);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
movzbl (%rsi),%edx
mov    %rdi,%rax
test   %dl,%dl
je     f71 <osip_str_append+0x21>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rsi
mov    %dl,(%rax)
add    $0x1,%rax
movzbl (%rsi),%edx
test   %dl,%dl
jne    f60 <osip_str_append+0x10>
movb   $0x0,(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_str_append (char *dst, const char *src)
{
  while (*src != '\0') {
    *dst = *src;
    src++;
    dst++;
  }
  *dst = '\0';
  return dst;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 5
7 4
8 6
9 3
10 3
11 3
12 8
13 10
14 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 427 <il_forward_char+0x7>
mov    0x18(%rax),%rdx
cmp    0x38(%rax),%rdx
jae    440 <il_forward_char+0x20>
add    $0x1,%rdx
movl   $0x2,0x10(%rax)
mov    %rdx,0x18(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_forward_char()
{
    if (il->point < il->length)
    {
 il->point++;
 il->last_operation = 2;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 6
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x24,%edi
callq  8ee <clone_quoting_options+0xe>
test   %rbx,%rbx
mov    $0x0,%edx
cmovne %rbx,%rdx
mov    (%rdx),%rcx
mov    %rcx,(%rax)
mov    0x8(%rdx),%rcx
mov    %rcx,0x8(%rax)
mov    0x10(%rdx),%rcx
mov    %rcx,0x10(%rax)
mov    0x18(%rdx),%rcx
mov    %rcx,0x18(%rax)
mov    0x20(%rdx),%edx
mov    %edx,0x20(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
clone_quoting_options (struct quoting_options *o)
{
  struct quoting_options *p
    = (struct quoting_options *) xmalloc (sizeof (struct quoting_options));
  *p = *(o ? o : &default_quoting_options);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 7
19 7
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
movzbl %sil,%esi
sub    %eax,%esi
movslq %esi,%rsi
lea    (%rsi,%rsi,4),%rax
lea    (%rsi,%rax,2),%rax
mov    0x163c(%rdi,%rax,8),%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_track_channels_image(const void *p_user_data, track_t i_track)
{
  const _img_private_t *p_env = p_user_data;
  return ( p_env->tocent[i_track-p_env->gen.i_first_track].flags
   & FOUR_CHANNEL_AUDIO ) ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
test   %rax,%rax
je     515 <dict_read_reply+0x15>
movb   $0x0,(%rax)
mov    0x8(%rbx),%rdi
lea    0x38(%rbx),%rcx
lea    0x30(%rbx),%rdx
lea    0x28(%rbx),%rsi
callq  52a <dict_read_reply+0x2a>
test   %eax,%eax
mov    %eax,%ebp
jne    53d <dict_read_reply+0x3d>
mov    0x28(%rbx),%rdi
callq  539 <dict_read_reply+0x39>
mov    %rax,0x38(%rbx)
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dict_read_reply(struct dict_connection *conn)
{
    int rc;
    if (conn->buf)
 conn->buf[0] = 0;
    rc = dico_stream_getline(conn->str, &conn->buf, &conn->size,
        &conn->level);
    if (rc == 0)
 conn->level = dico_trim_nl(conn->buf);
    return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 6
10 6
11 6
12 6
13 6
14 8
15 6
16 8
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 11
25 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 1327 <gen_thunk_array+0x7>
push   %rbx
mov    $0xc,%edx
mov    %rdi,%rbx
mov    $0x1,%esi
mov    $0x0,%edi
callq  133f <gen_thunk_array+0x1f>
mov    0x20(%rbx),%rdi
callq  1348 <gen_thunk_array+0x28>
pop    %rbx
mov    0x0(%rip),%rcx        # 1350 <gen_thunk_array+0x30>
mov    $0xa,%edx
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   1364 <gen_thunk_array+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gen_thunk_array (exp_t *rex)
{
  fprintf (ccode, "__er=(__dhp)");
  genvalue (rex->left);
  fprintf (ccode, ";__reth();");
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 2
5 3
6 3
7 3
8 4
9 4
10 6
11 5
12 5
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  c9e <err_unboundvar+0xe>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
jmpq   cac <err_unboundvar+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
err_unboundvar (s)
     const char *s;
{
  report_error (gettext("%s: unbound variable"), s);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
push   %r13
mov    %ecx,%r8d
mov    %edx,%r13d
push   %r12
mov    %ecx,%r12d
mov    %edx,%ecx
mov    %esi,%edx
push   %rbp
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12d,%ecx
mov    %r13d,%r8d
xor    %r9d,%r9d
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0x8b,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   ad0 <_rx.isra.34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_ldxr_l(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r0, r1, r2);
    *_jit->pc.uc++ = 0x8b;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 2
9 2
10 3
11 2
12 2
13 2
14 3
15 4
16 5
17 5
18 5
19 5
20 5
21 4
22 4
23 4
24 6
25 6
26 6
27 6
28 6
29 5
30 5
31 5
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%rbx
xor    %ecx,%ecx
callq  2b <_def_write+0xb>
test   %eax,%eax
js     40 <_def_write+0x20>
cltq   
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  45 <_def_write+0x25>
pop    %rbx
mov    (%rax),%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_def_write (void *sd, const char *data, size_t size, size_t * nbytes)
{
  int rc = send ((int) sd, data, size, 0);
  if (rc >= 0)
    {
      *nbytes = rc;
      return 0;
    }
  return (*__errno_location ());
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 6
9 7
10 10
11 10
12 10
13 9
14 10
15 9
16 10
17 10
<<<sep_out_sample>>>
jmpq   35 <vplob_shallow_close+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vplob_shallow_close(VPLOB * vplob)
{
 CPLOB * cplob = (CPLOB*)vplob;
 free(cplob);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    (%rdi),%rdi
mov    0x20(%rsp),%r10
mov    0x48(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %r10,0x8(%rsp)
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  0 <interp2d_eval>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_eval_deriv_yy_e (const gsl_interp2d * interp, const double xarr[],
                              const double yarr[], const double zarr[],
                              const double x, const double y,
                              gsl_interp_accel * xa, gsl_interp_accel * ya, double * z)
{
  return interp2d_eval(interp->type->eval_deriv_yy, interp,
                       xarr, yarr, zarr, x, y, xa, ya, z);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rdi
test   %rdi,%rdi
je     d2 <gsl_rstat_free+0x12>
callq  d2 <gsl_rstat_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   db <gsl_rstat_free+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_rstat_free(gsl_rstat_workspace *w)
{
  if (w->median_workspace_p)
    gsl_rstat_quantile_free(w->median_workspace_p);
  free(w);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%rbp        # 141f <put_end_of_line+0xf>
callq  1424 <put_end_of_line+0x14>
mov    %rax,%rdi
mov    %rbp,%rsi
callq  142f <put_end_of_line+0x1f>
mov    0x0(%rip),%ecx        # 1435 <put_end_of_line+0x25>
test   %ecx,%ecx
jne    14e0 <put_end_of_line+0xd0>
mov    0x0(%rip),%edx        # 1443 <put_end_of_line+0x33>
test   %edx,%edx
jne    1503 <put_end_of_line+0xf3>
mov    0x0(%rip),%rbp        # 1452 <put_end_of_line+0x42>
mov    $0x0,%edi
callq  145c <put_end_of_line+0x4c>
mov    %rax,%rdi
mov    %rbp,%rsi
callq  1467 <put_end_of_line+0x57>
mov    $0x0,%edi
callq  1471 <put_end_of_line+0x61>
mov    0x0(%rip),%eax        # 1477 <put_end_of_line+0x67>
test   %eax,%eax
jne    1520 <put_end_of_line+0x110>
mov    0x0(%rip),%rdi        # 1486 <put_end_of_line+0x76>
test   %rdi,%rdi
je     1578 <put_end_of_line+0x168>
cmpl   $0x2,0x0(%rip)        # 1496 <put_end_of_line+0x86>
je     1560 <put_end_of_line+0x150>
mov    0x0(%rip),%rsi        # 14a3 <put_end_of_line+0x93>
mov    $0xa,%edi
callq  14ad <put_end_of_line+0x9d>
cmpl   $0x3,0x0(%rip)        # 14b4 <put_end_of_line+0xa4>
je     1540 <put_end_of_line+0x130>
movq   $0x0,0x0(%rip)        # 14c5 <put_end_of_line+0xb5>
mov    %ebx,0x0(%rip)        # 14cb <put_end_of_line+0xbb>
movl   $0x0,0x0(%rip)        # 14d5 <put_end_of_line+0xc5>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 14e7 <put_end_of_line+0xd7>
mov    %ebx,%edx
xor    %eax,%eax
mov    $0x0,%esi
callq  14f5 <put_end_of_line+0xe5>
mov    0x0(%rip),%edx        # 14fb <put_end_of_line+0xeb>
test   %edx,%edx
je     144b <put_end_of_line+0x3b>
mov    0x0(%rip),%rsi        # 150a <put_end_of_line+0xfa>
mov    0x0(%rip),%rdi        # 1511 <put_end_of_line+0x101>
callq  1516 <put_end_of_line+0x106>
jmpq   144b <put_end_of_line+0x3b>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 1527 <put_end_of_line+0x117>
mov    0x0(%rip),%rdi        # 152e <put_end_of_line+0x11e>
callq  1533 <put_end_of_line+0x123>
jmpq   147f <put_end_of_line+0x6f>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 1547 <put_end_of_line+0x137>
mov    0x0(%rip),%rdi        # 154e <put_end_of_line+0x13e>
callq  1553 <put_end_of_line+0x143>
jmpq   14ba <put_end_of_line+0xaa>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 1567 <put_end_of_line+0x157>
callq  156c <put_end_of_line+0x15c>
jmpq   149c <put_end_of_line+0x8c>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 157f <put_end_of_line+0x16f>
mov    $0xa,%dil
callq  1587 <put_end_of_line+0x177>
jmpq   14c5 <put_end_of_line+0xb5>
nopl   0x0(%rax)
<<<sep_in_sample>>>
put_end_of_line(int lineno)
{
 fputs(gen_name_number(lineno), out);
        if (nflag)
                fprintf(out, lineno_format, lineno);
 if (warned)
  fputs(warned_line_begin, out);
 fputs(strbuf_value(outbuf), out);
 strbuf_reset(outbuf);
 if (warned)
  fputs(warned_line_end, out);
 if (guide == ((void *)0))
  fputc('\n', out);
 else {
  if (definition_header == 2)
   fputs(guide, out);
  fputc('\n', out);
  if (definition_header == 3) {
   fputs_nl(guide, out);
  }
  guide = ((void *)0);
 }
 warned = 0;
 last_lineno = lineno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 6
14 6
15 6
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 9
24 10
25 10
26 10
27 12
28 12
29 12
30 15
31 15
32 17
33 17
34 17
35 18
36 18
37 21
38 24
39 23
40 25
41 25
42 25
43 25
44 25
45 5
46 5
47 5
48 5
49 5
50 6
51 6
52 6
53 7
54 7
55 7
56 7
57 7
58 11
59 11
60 11
61 11
62 11
63 19
64 19
65 19
66 19
67 19
68 16
69 16
70 16
71 16
72 13
73 13
74 13
75 13
76 13
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x38,%edi
push   %rbx
sub    $0x10,%rsp
callq  18 <gsl_wavelet_alloc+0x18>
test   %rax,%rax
mov    %rax,%rbx
je     80 <gsl_wavelet_alloc+0x80>
mov    %rbp,(%rax)
lea    0x8(%rax),%rdi
lea    0x20(%rax),%rcx
lea    0x18(%rax),%rdx
lea    0x10(%rax),%rsi
mov    %r12,(%rsp)
lea    0x30(%rax),%r9
lea    0x28(%rax),%r8
callq  *0x8(%rbp)
test   %eax,%eax
mov    %rbx,%rdi
jne    58 <gsl_wavelet_alloc+0x58>
add    $0x10,%rsp
mov    %rdi,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
callq  5d <gsl_wavelet_alloc+0x5d>
mov    $0x0,%edi
mov    $0x4,%ecx
mov    $0x2e,%edx
mov    $0x0,%esi
callq  76 <gsl_wavelet_alloc+0x76>
xor    %edi,%edi
jmp    49 <gsl_wavelet_alloc+0x49>
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
mov    $0x8,%ecx
mov    $0x23,%edx
mov    $0x0,%esi
callq  99 <gsl_wavelet_alloc+0x99>
xor    %edi,%edi
jmp    49 <gsl_wavelet_alloc+0x49>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_wavelet_alloc (const gsl_wavelet_type * T, size_t k)
{
  int status;
  gsl_wavelet *w = (gsl_wavelet *) malloc (sizeof (gsl_wavelet));
  if (w == ((void *)0))
    {
      do { gsl_error ("failed to allocate space for wavelet struct",
 "wavelet.c"
      ,
 35
      , GSL_ENOMEM) ; return 0 ; } while (0)
                                   ;
    };
  w->type = T;
  status = (T->init) (&(w->h1), &(w->g1), &(w->h2), &(w->g2),
                      &(w->nc), &(w->offset), k);
  if (status)
    {
      free (w);
      do { gsl_error ("invalid wavelet member", "wavelet.c", 46, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return w;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 4
9 5
10 4
11 5
12 14
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 17
22 17
23 17
24 23
25 23
26 23
27 23
28 23
29 23
30 23
31 19
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 7
41 7
42 7
43 7
44 7
45 11
46 11
47 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  8de <locateCraftByDISEntityID+0xe>
mov    %rax,%rbx
callq  8e6 <locateCraftByDISEntityID+0x16>
test   %rax,%rax
js     930 <locateCraftByDISEntityID+0x60>
movzwl 0x0(%rbp),%ecx
xor    %edx,%edx
jmp    908 <locateCraftByDISEntityID+0x38>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdx
add    $0x3a8,%rbx
cmp    %rdx,%rax
jl     930 <locateCraftByDISEntityID+0x60>
cmp    %cx,0x32(%rbx)
jne    8f8 <locateCraftByDISEntityID+0x28>
movzwl 0x2(%rbp),%esi
cmp    %si,0x34(%rbx)
jne    8f8 <locateCraftByDISEntityID+0x28>
movzwl 0x4(%rbp),%edi
cmp    %di,0x36(%rbx)
jne    8f8 <locateCraftByDISEntityID+0x28>
mov    0x20(%rbx),%rax
jmp    932 <locateCraftByDISEntityID+0x62>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
locateCraftByDISEntityID ( dis_entity_id *id )
{
 Entity_t *e = dis_getEntityTable();
 long top = dis_getEntityTop();
 long i;
 craft *result = ((void *)0);
 for (i=0; i<=top; ++i) {
  if ( e->entityId.sim_id.site_id == id->sim_id.site_id &&
    e->entityId.sim_id.application_id == id->sim_id.application_id &&
    e->entityId.entity_id == id->entity_id ) {
   result = e->c;
   break;
  }
  ++ e;
 }
 return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 14
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 9
24 9
25 9
26 11
27 12
28 12
29 6
30 17
31 17
32 17
33 17
34 17
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  865 <gsl_stats_int_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  878 <gsl_stats_int_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  895 <gsl_stats_int_ttest+0x55>
test   %rbp,%rbp
js     8f8 <gsl_stats_int_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 8a7 <gsl_stats_int_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     918 <gsl_stats_int_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     932 <gsl_stats_int_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    89f <gsl_stats_int_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    8b9 <gsl_stats_int_ttest+0x79>
test   %rbp,%rbp
js     96c <gsl_stats_int_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     983 <gsl_stats_int_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  963 <gsl_stats_int_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   8d7 <gsl_stats_int_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    93c <gsl_stats_int_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    94e <gsl_stats_int_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_int_ttest (const int data1[],
                           const size_t stride1, const size_t n1,
                           const int data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_int_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_int_mean (data2, stride2, n2);
  const double pv = gsl_stats_int_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
push   %r15
mov    %r8,%rax
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
xor    %edx,%edx
div    %rbx
sub    $0x18,%rsp
mov    %rdi,0x8(%rsp)
mov    0x50(%rsp),%r13
test   %rdx,%rdx
jne    90 <nettle_cbc_encrypt+0x90>
mov    %r8,%r14
mov    %rsi,%r15
mov    %rcx,%r12
sub    %rbx,%r14
test   %r8,%r8
mov    %r9,%rbp
jne    43 <nettle_cbc_encrypt+0x43>
jmp    81 <nettle_cbc_encrypt+0x81>
xchg   %ax,%ax
mov    %rax,%r14
mov    %r13,%rsi
mov    %rbx,%rdx
mov    %r12,%rdi
callq  51 <nettle_cbc_encrypt+0x51>
mov    %rbp,%rdx
mov    %r12,%rcx
mov    %rbx,%rsi
mov    0x8(%rsp),%rdi
add    %rbx,%r13
callq  *%r15
mov    %rbp,%rsi
mov    %rbx,%rdx
mov    %r12,%rdi
callq  73 <nettle_cbc_encrypt+0x73>
mov    %r14,%rax
add    %rbx,%rbp
sub    %rbx,%rax
test   %r14,%r14
jne    40 <nettle_cbc_encrypt+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
lea    0x0(%rip),%rcx        # 97 <nettle_cbc_encrypt+0x97>
lea    0x0(%rip),%rsi        # 9e <nettle_cbc_encrypt+0x9e>
lea    0x0(%rip),%rdi        # a5 <nettle_cbc_encrypt+0xa5>
mov    $0x35,%edx
callq  af <nettle_cbc_encrypt+0xaf>
nop
<<<sep_in_sample>>>
nettle_cbc_encrypt(const void *ctx, nettle_cipher_func *f,
     size_t block_size, uint8_t *iv,
     size_t length, uint8_t *dst,
     const uint8_t *src)
{
  ((!(length % block_size)) ? (void) (0) : __assert_fail ("!(length % block_size)", "cbc.c", 53, __PRETTY_FUNCTION__));
  for ( ; length; length -= block_size, src += block_size, dst += block_size)
    {
      nettle_memxor(iv, src, block_size);
      f(ctx, block_size, dst, iv);
      memcpy(iv, dst, block_size);
    }
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 5
12 5
13 5
14 6
15 6
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 7
35 10
36 11
37 11
38 11
39 11
40 11
41 7
42 7
43 7
44 7
45 13
46 13
47 13
48 13
49 13
50 13
51 13
52 13
53 6
54 6
55 6
56 6
57 6
58 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_body (MESSAGE msg)
{
  return msg->body;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x4,%edx
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  216 <xdr_simx_session_handle+0x16>
xor    %edx,%edx
test   %eax,%eax
je     22f <xdr_simx_session_handle+0x2f>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  228 <xdr_simx_session_handle+0x28>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_simx_session_handle (XDR *xdrs, simx_session_handle *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_opaque (xdrs, objp->data, 4))
		 return FALSE;
	 if (!xdr_dis_simulation_addr (xdrs, &objp->address))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 6
8 7
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
21 11
22 11
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  1b12 <add_to_environment+0x12>
test   %rax,%rax
je     1b20 <add_to_environment+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %rbp,%rbp
je     1b48 <add_to_environment+0x48>
mov    %rbp,%rdi
callq  1b2d <add_to_environment+0x2d>
test   %rax,%rax
mov    %rax,%rsi
je     1b48 <add_to_environment+0x48>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1b41 <add_to_environment+0x41>
nopl   0x0(%rax)
mov    %rbx,%rdi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1b57 <add_to_environment+0x57>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
add_to_environment(variable, alternate_variable, value)
    char *variable;
    char *alternate_variable;
    char *value;
{
    char *alternate_value;
    if (getenv(variable) == ((void *)0))
    {
 if (alternate_variable && (alternate_value=getenv(alternate_variable)))
     xsetenv(variable, alternate_value);
 else
     xsetenv(variable, value);
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 14
11 14
12 14
13 14
14 14
15 9
16 9
17 9
18 9
19 9
20 10
21 9
22 12
23 14
24 14
25 14
26 12
27 12
28 12
29 12
30 14
31 14
32 14
33 12
34 12
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
mov    0x8(%rdi),%esi
cmp    $0x1c,%esi
je     50 <CDB___lock_ohash+0x10>
mov    (%rdi),%rdi
jmpq   50 <CDB___lock_ohash+0x10>
mov    (%rdi),%rax
movzbl 0x4(%rax),%edx
xor    (%rax),%dl
mov    %dl,-0xc(%rsp)
movzbl 0x5(%rax),%edx
xor    0x1(%rax),%dl
mov    %dl,-0xb(%rsp)
movzbl 0x6(%rax),%edx
xor    0x2(%rax),%dl
mov    %dl,-0xa(%rsp)
movzbl 0x7(%rax),%edx
xor    0x3(%rax),%dl
mov    %dl,-0x9(%rsp)
mov    -0xc(%rsp),%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___lock_ohash(dbt)
 const DBT *dbt;
{
 if (dbt->size == sizeof(DB_LOCK_ILOCK))
  { u_int32_t __h; u_int8_t *__cp, *__hp; __hp = (u_int8_t *)&__h; __cp = (u_int8_t *)(dbt->data); __hp[0] = __cp[0] ^ __cp[4]; __hp[1] = __cp[1] ^ __cp[5]; __hp[2] = __cp[2] ^ __cp[6]; __hp[3] = __cp[3] ^ __cp[7]; return (__h); };
 return (CDB___ham_func5(dbt->data, dbt->size));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 7
21 7
<<<sep_out_sample>>>
xor    %ecx,%ecx
jmpq   577 <nettle_arctwo_set_key_gutmann+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_arctwo_set_key_gutmann (struct arctwo_ctx *ctx,
   size_t length, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, length, key, 0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30 <gsasl_check_version+0x30>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  13 <gsasl_check_version+0x13>
xor    %edx,%edx
test   %eax,%eax
mov    $0x0,%eax
cmovle %rax,%rdx
add    $0x8,%rsp
mov    %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
mov    %rdx,%rax
retq   
<<<sep_in_sample>>>
gsasl_check_version (const char *req_version)
{
  if (!req_version || strverscmp (req_version, "1.8.0") <= 0)
    return "1.8.0";
  return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 4
15 6
16 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 47a <gsl_matrix_complex_float_get+0xa>
test   %eax,%eax
je     489 <gsl_matrix_complex_float_get+0x19>
cmp    %rsi,(%rdi)
jbe    4a0 <gsl_matrix_complex_float_get+0x30>
cmp    %rdx,0x8(%rdi)
jbe    4c8 <gsl_matrix_complex_float_get+0x58>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
movq   (%rax,%rdx,8),%xmm0
add    $0x8,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x113,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b9 <gsl_matrix_complex_float_get+0x49>
pxor   %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x117,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4e1 <gsl_matrix_complex_float_get+0x71>
pxor   %xmm0,%xmm0
jmp    49a <gsl_matrix_complex_float_get+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_float_get(const gsl_matrix_complex_float * m,
                     const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      gsl_complex_float zero = {{0,0}};
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_complex_float.h", 275, GSL_EINVAL) ; return zero ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_complex_float.h", 279, GSL_EINVAL) ; return zero ; } while (0) ;
        }
    }
  return *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 7
6 7
7 11
8 11
9 16
10 16
11 16
12 16
13 17
14 17
15 17
16 9
17 9
18 9
19 9
20 9
21 9
22 17
23 17
24 17
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x68(%rdi),%rax
retq   
<<<sep_in_sample>>>
__rpline (__bs6FILE *p)
{
  return (p->line);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    (%rdi),%rdi
xor    %ebx,%ebx
test   %rdi,%rdi
je     a2d <bc_args_exceed_testing_limit+0x2d>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbx
callq  a21 <bc_args_exceed_testing_limit+0x21>
mov    (%r12,%rbx,8),%rdi
add    %rax,%rbp
test   %rdi,%rdi
jne    a18 <bc_args_exceed_testing_limit+0x18>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  10 <exceeds>
test   %eax,%eax
mov    $0x1,%edx
jne    a55 <bc_args_exceed_testing_limit+0x55>
mov    %rbp,%rsi
mov    $0x0,%edi
callq  10 <exceeds>
test   %eax,%eax
setne  %dl
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
<<<sep_in_sample>>>
bc_args_exceed_testing_limit (char **argv)
{
  size_t chars, args;
  for (chars=args=0; *argv; ++argv)
    {
      ++args;
      chars += strlen(*argv);
    }
  return (exceeds ("__GNU_FINDUTILS_EXEC_ARG_COUNT_LIMIT", args) ||
   exceeds ("__GNU_FINDUTILS_EXEC_ARG_LENGTH_LIMIT", chars));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 4
9 4
10 4
11 6
12 7
13 4
14 7
15 4
16 4
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 9
27 9
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     11b2 <gsl_vector_long_double_set_zero+0x32>
fldz   
shl    $0x4,%rsi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
add    $0x1,%rax
fstpt  (%rdx)
fldt   (%rdx)
add    %rsi,%rdx
cmp    %rcx,%rax
jne    11a0 <gsl_vector_long_double_set_zero+0x20>
fstp   %st(0)
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_set_zero (gsl_vector_long_double * v)
{
  long double * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const long double zero = 0.0L ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long double *) (data + 1 * i * stride) = zero;
    }
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 10
13 10
14 8
15 8
16 8
17 8
18 8
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x10(%rdi),%r9
mov    0x8(%rdi),%r11
test   %r10,%r10
mov    (%r9),%ecx
je     103e <gsl_vector_uint_minmax+0x3e>
shl    $0x2,%r11
mov    %ecx,%edi
xor    %r8d,%r8d
nopl   0x0(%rax)
mov    (%r9),%eax
cmp    %eax,%edi
cmova  %eax,%edi
cmp    %eax,%ecx
cmovb  %eax,%ecx
add    $0x1,%r8
add    %r11,%r9
cmp    %r10,%r8
jne    1020 <gsl_vector_uint_minmax+0x20>
mov    %edi,(%rsi)
mov    %ecx,(%rdx)
retq   
mov    %ecx,%edi
jmp    1039 <gsl_vector_uint_minmax+0x39>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_minmax (const gsl_vector_uint * v,
                             unsigned int * min_out,
                             unsigned int * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned int max = v->data[0 * stride];
  unsigned int min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned int x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 7
3 6
4 10
5 7
6 10
7 10
8 8
9 10
10 10
11 12
12 12
13 12
14 12
15 12
16 10
17 10
18 10
19 10
20 22
21 23
22 23
23 8
24 8
25 8
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdx),%rax
cmp    0x8(%rdx),%rax
je     1950 <gsl_blas_cher+0x30>
mov    $0x14,%ecx
mov    $0x460,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1946 <gsl_blas_cher+0x26>
mov    $0x14,%eax
add    $0x18,%rsp
retq   
cmp    (%rsi),%rax
je     1980 <gsl_blas_cher+0x60>
mov    $0x13,%ecx
mov    $0x464,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  196e <gsl_blas_cher+0x4e>
mov    $0x13,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x18(%rdx),%r9
mov    0x10(%rdx),%rdx
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rcx
mov    %edi,%esi
mov    $0x65,%edi
mov    %edx,(%rsp)
mov    %eax,%edx
callq  19a1 <gsl_blas_cher+0x81>
xor    %eax,%eax
jmp    194b <gsl_blas_cher+0x2b>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
               const gsl_vector_complex_float * X,
               gsl_matrix_complex_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 1120, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (X->size != N)
    {
      do { gsl_error ("invalid length", "blas.c", 1124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_cher (CblasRowMajor, Uplo, ((int)(M)), alpha, X->data, ((int)(X->stride)),
              A->data, ((int)(A->tda)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 18
12 18
13 11
14 11
15 13
16 13
17 13
18 13
19 13
20 13
21 18
22 18
23 18
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 17
34 17
35 17
<<<sep_out_sample>>>
mov    0x10(%rdx),%r8
cmp    $0x5,%r8
jbe    61f0 <_jit_getarg_c+0x20>
movslq %esi,%rdx
mov    $0xf,%ecx
mov    $0x65,%esi
jmpq   61ec <_jit_getarg_c+0x1c>
nopl   0x0(%rax)
mov    $0xd,%ecx
movslq %esi,%rdx
mov    $0x4d,%esi
sub    %r8,%rcx
jmpq   6205 <_jit_getarg_c+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_getarg_c(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_extr_c,u,_RDI - v->u.w);
    else
 _jit_new_node_www(_jit,jit_code_ldxi_c,u,_RBP,v->u.w);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 7
7 7
8 7
9 5
10 5
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x4,%edi
mov    %rsi,%rbx
callq  e <_gsasl_login_client_start+0xe>
mov    %rax,%rdx
mov    $0x7,%eax
test   %rdx,%rdx
je     26 <_gsasl_login_client_start+0x26>
movl   $0x0,(%rdx)
xor    %al,%al
mov    %rdx,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_login_client_start (Gsasl_session * sctx, void **mech_data)
{
  struct _Gsasl_login_client_state *state;
  state = malloc (sizeof (*state));
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  state->step = 0;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 6
7 5
8 5
9 7
10 9
11 8
12 10
13 10
14 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x0,%r9d
mov    $0x0,%r8d
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
mov    $0x0,%ecx
xor    %edx,%edx
callq  12fd <dicod_define_word_first+0x2d>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_define_word_first(dico_stream_t stream, const char *word)
{
    dicod_word_first(stream, word, ((void *)0),
       "150 %lu definitions found: list follows\n",
       "250 Command complete",
       print_definitions, ((void *)0), "define");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 7
10 7
11 7
<<<sep_out_sample>>>
mov    0x1020(%rdi),%rdi
mov    %ecx,%r8d
mov    $0x1,%ecx
jmpq   6d4 <read_audio_sectors_linux+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_audio_sectors_linux (void *p_user_data, void *p_buf, lsn_t i_lsn,
                           uint32_t i_blocks)
{
  _img_private_t *p_env = p_user_data;
  return mmc_read_sectors( p_env->gen.cdio, p_buf, i_lsn,
                           CDIO_MMC_READ_TYPE_CDDA, i_blocks);
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
test   %r10,%r10
movzbl (%rdi),%r8d
je     194e <gsl_vector_char_minmax_index+0x4e>
mov    %r8d,%r9d
xor    %eax,%eax
xor    %ebx,%ebx
xor    %ebp,%ebp
nop
movzbl (%rdi),%ecx
cmp    %r9b,%cl
jge    192e <gsl_vector_char_minmax_index+0x2e>
mov    %ecx,%r9d
mov    %rax,%rbp
cmp    %r8b,%cl
jle    1939 <gsl_vector_char_minmax_index+0x39>
mov    %ecx,%r8d
mov    %rax,%rbx
add    $0x1,%rax
add    %r11,%rdi
cmp    %r10,%rax
jne    1920 <gsl_vector_char_minmax_index+0x20>
mov    %rbp,(%rsi)
mov    %rbx,(%rdx)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    1945 <gsl_vector_char_minmax_index+0x45>
<<<sep_in_sample>>>
gsl_vector_char_minmax_index (const gsl_vector_char * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  char max = v->data[0 * stride];
  char min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      char x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 11
7 8
8 11
9 9
10 11
11 7
12 7
13 7
14 13
15 14
16 14
17 14
18 14
19 19
20 19
21 19
22 19
23 11
24 11
25 11
26 11
27 25
28 26
29 27
30 27
31 27
32 7
33 7
34 7
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_opaque (osip_www_authenticate_t * www_authenticate, char *opaque)
{
  www_authenticate->opaque = (char *) opaque;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    $0x1005,%eax
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     2a3 <mu_debug_create+0x43>
mov    %rsi,%rbp
mov    $0x48,%edi
mov    $0x1,%esi
callq  285 <mu_debug_create+0x25>
mov    %rax,%rdx
mov    $0xc,%eax
test   %rdx,%rdx
je     2a3 <mu_debug_create+0x43>
movq   $0x0,0x38(%rdx)
mov    %rbp,0x10(%rdx)
xor    %al,%al
mov    %rdx,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_debug_create (mu_debug_t *pdebug, void *owner)
{
  mu_debug_t debug;
  if (pdebug == ((void *)0))
    return (0x1000 +5);
  debug = calloc (sizeof (*debug), 1);
  if (debug == ((void *)0))
    return 12;
  debug->printer = ((void *)0);
  debug->owner = owner;
  *pdebug = debug;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 8
14 7
15 7
16 9
17 10
18 12
19 11
20 13
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
mov    %r8,%r9
mov    $0x1,%r8d
jmpq   33e <gsl_wavelet_transform_forward+0xe>
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_wavelet_transform_forward (const gsl_wavelet * w,
                               double *data, size_t stride, size_t n,
                               gsl_wavelet_workspace * work)
{
  return gsl_wavelet_transform (w, data, stride, n, gsl_wavelet_forward, work);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gcide_idx_headwords(struct gcide_idx_file *file)
{
    return file->header.ihdr_num_headwords;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  2c0c <gsl_sf_doublefact+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    2c20 <gsl_sf_doublefact+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x66c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c36 <gsl_sf_doublefact+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_doublefact(const unsigned int n)
{
  gsl_sf_result result; int status = gsl_sf_doublefact_e(n, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_doublefact_e(n, &result)", "gamma.c", 1644, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
lea    0x8(%rsi),%rax
mov    0x4(%rsi),%esi
mov    %rdx,%rcx
mov    $0xffffffff,%r8d
mov    %rax,%rdx
jmpq   0 <__gmpz_cfdiv_q_2exp.isra.0>
<<<sep_in_sample>>>
__gmpz_fdiv_q_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt)
{
  __gmpz_cfdiv_q_2exp (w,u,cnt,-1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    0x68(%rdi),%rdx
lea    0x0(,%rsi,8),%rax
mov    0x78(%rdi),%rcx
mov    %rdi,%rbx
sub    %rsi,%rdx
imul   (%rdi),%rdx
lea    (%rcx,%rax,1),%rsi
lea    -0x8(%rcx,%rax,1),%rdi
callq  1cc9 <amd_array_shrink+0x29>
subq   $0x1,0x68(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
amd_array_shrink (struct _amd_data *amd, size_t index)
{
  memmove (&amd->msg_array[index-1], &amd->msg_array[index],
    (amd->msg_count-index) * amd->msg_size);
  amd->msg_count--;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 3
5 2
6 4
7 3
8 3
9 3
10 3
11 5
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
cmp    $0x35,%rsi
mov    $0x35,%eax
cmovae %rsi,%rax
add    $0x7f,%rax
shr    $0x6,%rax
mov    %eax,(%rdi)
retq   
<<<sep_in_sample>>>
__gmpf_set_prec_raw (mpf_ptr x, mp_bitcnt_t prec_in_bits)
{
  x->_mp_prec = ((mp_size_t) ((((53) > (prec_in_bits) ? (53) : (prec_in_bits)) + 2 * (64 - 0) - 1) / (64 - 0)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
orl    $0x2,(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_itemlist_dirty (it)
     ITEMLIST *it;
{
  it->flags |= 0x002;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 22b <restore_lastcom+0xb>
test   %rdi,%rdi
je     23f <restore_lastcom+0x1f>
mov    $0x5f,%edx
mov    $0x0,%esi
callq  23f <restore_lastcom+0x1f>
mov    %rbx,0x0(%rip)        # 246 <restore_lastcom+0x26>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
restore_lastcom (x)
     char *x;
{
  do { if (the_printed_command_except_trap) sh_xfree((the_printed_command_except_trap), "evalstring.c", 95); } while (0);
  the_printed_command_except_trap = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
xor    %esi,%esi
sub    $0x8,%rsp
callq  54 <pump_from_tmp+0x14>
cmp    $0xffffffffffffffff,%rax
jne    88 <pump_from_tmp+0x48>
jmp    d0 <pump_from_tmp+0x90>
nopl   0x0(%rax)
test   %eax,%eax
js     a8 <pump_from_tmp+0x68>
je     dc <pump_from_tmp+0x9c>
movslq %eax,%rsi
mov    %rbx,%rcx
mov    $0x1,%edx
mov    $0x0,%edi
callq  7b <pump_from_tmp+0x3b>
test   %rax,%rax
je     c0 <pump_from_tmp+0x80>
mov    %rbx,%rdi
callq  88 <pump_from_tmp+0x48>
mov    $0x2000,%edx
mov    $0x0,%esi
mov    %ebp,%edi
callq  99 <pump_from_tmp+0x59>
cmp    $0xffffffff,%eax
jne    60 <pump_from_tmp+0x20>
callq  a3 <pump_from_tmp+0x63>
cmpl   $0x4,(%rax)
je     88 <pump_from_tmp+0x48>
add    $0x8,%rsp
mov    $0x0,%edi
pop    %rbx
pop    %rbp
jmpq   b8 <pump_from_tmp+0x78>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x0,%edi
pop    %rbx
pop    %rbp
jmpq   d0 <pump_from_tmp+0x90>
mov    $0x0,%edi
callq  da <pump_from_tmp+0x9a>
jmp    88 <pump_from_tmp+0x48>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pump_from_tmp (int from, FILE *to)
{
  static char buffer[8192];
  if (lseek (from, 0, 0) == -1)
    perror ("lseek()");
  while (1)
    {
      int len;
      while (((len)=read (from, buffer, sizeof (buffer)))==-1 && (*__errno_location ())==4);
      if (len < 0)
        perror ("read()");
      if (len <= 0)
        break;
      if (fwrite (buffer, len, 1, to) < 1)
        {
          perror ("fwrite()");
          break;
        }
      fflush (to);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 2
8 4
9 4
10 4
11 4
12 4
13 10
14 10
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 14
23 19
24 19
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 21
35 11
36 21
37 21
38 11
39 11
40 21
41 16
42 21
43 21
44 16
45 5
46 5
47 5
48 21
49 21
50 21
51 21
52 21
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   43d <read_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
read_error (char const *name)
{
  call_arg_error ("read", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
cmp    $0x2,%edi
je     24 <main+0x24>
mov    (%rsi),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  19 <main+0x19>
mov    $0x1,%eax
add    $0x20,%rsp
pop    %rbx
retq   
mov    0x8(%rsi),%rdi
callq  2d <main+0x2d>
mov    $0x0,%r9d
movzwl %ax,%esi
mov    $0x0,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x819,%edi
movl   $0x0,0x10(%rsp)
movl   $0x78,0x8(%rsp)
xor    %eax,%eax
movl   $0x3,(%rsp)
callq  63 <main+0x63>
mov    0x0(%rip),%rdi        # 6a <main+0x6a>
mov    %rax,%rbx
callq  72 <main+0x72>
mov    %rbx,%rdi
callq  7a <main+0x7a>
xor    %eax,%eax
jmp    1e <main+0x1e>
<<<sep_in_sample>>>
main (int argc, char *const *argv)
{
  struct MHD_Daemon *d;
  if (argc != 2)
    {
      printf ("%s PORT\n", argv[0]);
      return 1;
    }
  d = MHD_start_daemon (MHD_USE_SELECT_INTERNALLY | MHD_USE_DEBUG | MHD_USE_DUAL_STACK,
   atoi (argv[1]),
   ((void *)0), ((void *)0), &ahc_echo, "<html><head><title>libmicrohttpd demo</title></head><body>libmicrohttpd demo</body></html>",
   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,
   MHD_OPTION_END);
  (void) _IO_getc (stdin);
  MHD_stop_daemon (d);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 6
6 6
7 6
8 6
9 7
10 17
11 17
12 17
13 10
14 10
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 14
27 9
28 14
29 15
30 15
31 16
32 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
mulsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
mulsd  %xmm1,%xmm0
mulsd  %xmm1,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_pow_6(const double x) { double x2 = x*x; return x2*x2*x2; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
<<<sep_out_sample>>>
movsd  0x18(%rdi),%xmm0
mov    %rdi,%rax
addsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x18(%rdi)
movsd  0x38(%rdi),%xmm0
addsd  0x10(%rsp),%xmm0
movsd  %xmm0,0x38(%rdi)
movsd  0x58(%rdi),%xmm0
addsd  0x18(%rsp),%xmm0
movsd  %xmm0,0x58(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
VTranslatePoint(VMatrix * Mt, VPoint loc)
{
 Mt->m[0][3] += loc.x;
 Mt->m[1][3] += loc.y;
 Mt->m[2][3] += loc.z;
 return Mt;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
cmp    %rsi,0x68(%rdi)
jl     40 <__rdblocate+0x40>
test   %rsi,%rsi
jle    40 <__rdblocate+0x40>
cmp    %rsi,0x60(%rbx)
je     37 <__rdblocate+0x37>
mov    0x48(%rbx),%rdi
mov    %rsi,0x60(%rbx)
xor    %edx,%edx
sub    $0x1,%rsi
xor    %eax,%eax
callq  2e <__rdblocate+0x2e>
cmp    $0xffffffff,%eax
je     60 <__rdblocate+0x60>
movb   $0x2,0x79(%rbx)
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
mov    $0x0,%edi
mov    %rsi,0x8(%rsp)
callq  4f <__rdblocate+0x4f>
mov    0x8(%rsp),%rsi
jmp    13 <__rdblocate+0x13>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  6a <__rdblocate+0x6a>
jmp    33 <__rdblocate+0x33>
<<<sep_in_sample>>>
__rdblocate (__bs10FILE *p, long i)
{
  if ((i < 1) | (i > p->maxloc))
    __rerror ("Locate: Parameter out of range");
  if (p->loc != i)
    {
      p->loc = i;
      if (fseek (((__bs1FILE *) p)->file, i - 1, 0) == (-1))
 __rerror ("Locate: Not possible to seek");
      p->lastop = 2;
    }
  return ((__dhp) p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 5
9 5
10 8
11 7
12 8
13 8
14 8
15 8
16 8
17 8
18 10
19 13
20 13
21 13
22 13
23 4
24 4
25 4
26 4
27 4
28 4
29 9
30 9
31 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
jmp    103 <all_upper+0x23>
nopl   0x0(%rax,%rax,1)
callq  f5 <all_upper+0x15>
mov    (%rax),%rax
add    $0x1,%rbx
testb  $0x2,0x1(%rax,%rbp,2)
jne    120 <all_upper+0x40>
movsbq (%rbx),%rbp
test   %bpl,%bpl
jne    f0 <all_upper+0x10>
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
all_upper (char *str)
{
  while (*str)
    if (((*__ctype_b_loc ())[(int) ((*str++))] & (unsigned short int) _ISlower))
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 3
13 3
14 3
15 7
16 6
17 7
18 7
19 7
20 7
21 7
22 5
23 7
24 7
25 7
26 7
<<<sep_out_sample>>>
xor    %eax,%eax
testb  $0x4,0x0(%rip)        # c29 <globals_only+0x9>
sete   %al
retq   
nopl   (%rax)
<<<sep_in_sample>>>
globals_only()
{
     return !(symbol_map & 0x0004);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rsi
mov    0x38(%rdi),%rdx
xor    %eax,%eax
mov    $0x0,%edi
jmpq   *%rdx
<<<sep_in_sample>>>
parser(const struct parser_param *param)
{
 param->warning("nop parser: %s", param->file);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
push   %rbx
mov    $0xe8,%edi
callq  7db <taru_exatt_create+0xb>
mov    $0x16,%edi
mov    %rax,%rbx
mov    $0x4858,%eax
mov    %ax,(%rbx)
movb   $0x0,0x2(%rbx)
callq  7f4 <taru_exatt_create+0x24>
mov    $0x16,%edi
mov    %rax,0xd0(%rbx)
callq  805 <taru_exatt_create+0x35>
mov    %rbx,%rdi
mov    %rax,0xd8(%rbx)
callq  814 <taru_exatt_create+0x44>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
taru_exatt_create(void) {
 EXATT * hnew;
 hnew = malloc(sizeof(EXATT));
 strcpy(hnew->magicM, "XH");
 hnew->attrnameM = strob_open(22);
 hnew->attrvalueM = strob_open(22);
 taru_exatt_init(hnew);
 return hnew;
}
<<<sep_in_sample>>>
1 1
2 3
3 3
4 5
5 3
6 4
7 4
8 4
9 5
10 6
11 5
12 6
13 7
14 6
15 7
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  293 <get_tz+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     2d8 <get_tz+0x58>
mov    %rax,%rdi
callq  2a3 <get_tz+0x23>
lea    0x1(%rax),%rdx
cmp    $0x64,%rdx
ja     2c0 <get_tz+0x40>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2be <get_tz+0x3e>
xchg   %ax,%ax
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <get_tz+0x51>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_tz (char tzbuf[TZBUFSIZE])
{
  char *tz = getenv ("TZ");
  if (tz)
    {
      size_t tzsize = strlen (tz) + 1;
      tz = (tzsize <= TZBUFSIZE
            ? memcpy (tzbuf, tz, tzsize)
            : xmemdup (tz, tzsize));
    }
  return tz;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 12
16 7
17 7
18 12
19 12
20 7
21 7
22 12
23 7
24 7
25 12
26 12
27 7
28 7
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  4cd9 <sv_tz+0x9>
test   %eax,%eax
jne    4ce8 <sv_tz+0x18>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
jmpq   4cf1 <sv_tz+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_tz (name)
     char *name;
{
  if (chkexport (name))
    tzset ();
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 5
10 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  2b9c <headerFreeIterator+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   2ba5 <headerFreeIterator+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
headerFreeIterator(HeaderIterator iter)
{
    headerFree(iter->h);
    free(iter);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     1e6 <gsl_matrix_complex_long_double_ispos+0x76>
shl    $0x5,%rax
mov    $0x10,%esi
xor    %r8d,%r8d
mov    %rax,%r10
test   %rcx,%rcx
je     1da <gsl_matrix_complex_long_double_ispos+0x6a>
fldz   
mov    %rsi,%rax
xor    %edx,%edx
add    0x18(%rdi),%rax
jmp    1bf <gsl_matrix_complex_long_double_ispos+0x4f>
nopl   0x0(%rax)
fldt   (%rax)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jae    1d0 <gsl_matrix_complex_long_double_ispos+0x60>
add    $0x1,%rdx
add    $0x20,%rax
cmp    %rcx,%rdx
je     1d8 <gsl_matrix_complex_long_double_ispos+0x68>
fldt   -0x10(%rax)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
jb     1a8 <gsl_matrix_complex_long_double_ispos+0x38>
fstp   %st(0)
jmp    1d2 <gsl_matrix_complex_long_double_ispos+0x62>
xchg   %ax,%ax
fstp   %st(0)
xor    %eax,%eax
retq   
nopl   (%rax)
fstp   %st(0)
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    18f <gsl_matrix_complex_long_double_ispos+0x1f>
mov    $0x1,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_ispos (const gsl_matrix_complex_long_double * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 13
13 13
14 9
15 9
16 9
17 9
18 13
19 13
20 13
21 13
22 13
23 9
24 9
25 9
26 9
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 15
37 15
38 15
39 15
40 7
41 7
42 7
43 7
44 20
45 20
46 20
<<<sep_out_sample>>>
push   %rbp
lea    (%rdx,%rdx,1),%r10
xor    %edx,%edx
test   %rcx,%rcx
push   %rbx
mov    %rsi,%rbx
je     1986 <gsl_permute_short+0x76>
mov    (%rdi,%rdx,8),%rax
cmp    %rax,%rdx
jae    1939 <gsl_permute_short+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%rdx
jb     1930 <gsl_permute_short+0x20>
cmp    %rax,%rdx
ja     197a <gsl_permute_short+0x6a>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     197a <gsl_permute_short+0x6a>
movzwl (%rbx),%ebp
jmp    1956 <gsl_permute_short+0x46>
nopl   0x0(%rax)
mov    %r8,%rax
mov    %r9,%r8
mov    %r10,%r11
imul   %r8,%r11
imul   %r10,%rax
add    %rsi,%r11
movzwl (%r11),%r9d
mov    %r9w,(%rsi,%rax,1)
mov    (%rdi,%r8,8),%r9
cmp    %r9,%rdx
jne    1950 <gsl_permute_short+0x40>
mov    %bp,(%r11)
add    $0x1,%rdx
add    %r10,%rbx
cmp    %rcx,%rdx
jne    1920 <gsl_permute_short+0x10>
pop    %rbx
xor    %eax,%eax
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_short (const size_t * p, short * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        short t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                short r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 2
6 2
7 4
8 6
9 7
10 7
11 7
12 8
13 7
14 7
15 9
16 9
17 11
18 12
19 12
20 18
21 18
22 18
23 18
24 27
25 23
26 23
27 24
28 23
29 23
30 24
31 27
32 19
33 19
34 30
35 4
36 4
37 4
38 4
39 34
40 34
41 34
42 34
43 34
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %rdi,%r12
push   %rbp
push   %rbx
je     60d <rec_fex_destroy+0x6d>
mov    (%rdi),%eax
test   %eax,%eax
jle    5f7 <rec_fex_destroy+0x57>
xor    %ebp,%ebp
nopl   0x0(%rax)
movslq %ebp,%rax
add    $0x1,%ebp
lea    (%r12,%rax,8),%rbx
mov    0x10(%rbx),%rax
mov    0x10(%rax),%rdi
callq  5cf <rec_fex_destroy+0x2f>
mov    0x10(%rbx),%rax
mov    0x8(%rax),%rdi
callq  5dc <rec_fex_destroy+0x3c>
mov    0x10(%rbx),%rax
mov    (%rax),%rdi
callq  5e8 <rec_fex_destroy+0x48>
mov    0x10(%rbx),%rdi
callq  5f1 <rec_fex_destroy+0x51>
cmp    %ebp,(%r12)
jg     5b8 <rec_fex_destroy+0x18>
mov    0x8(%r12),%rdi
callq  601 <rec_fex_destroy+0x61>
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
jmpq   60d <rec_fex_destroy+0x6d>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_fex_destroy (rec_fex_t fex)
{
  int i;
  if (fex)
    {
      for (i = 0; i < fex->num_elems; i++)
        {
          free (fex->elems[i]->rewrite_to);
          free (fex->elems[i]->field_name);
          free (fex->elems[i]->str);
          free (fex->elems[i]);
        }
      free (fex->str);
      free (fex);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 8
16 8
17 8
18 9
19 9
20 9
21 10
22 10
23 10
24 11
25 11
26 6
27 6
28 13
29 13
30 16
31 16
32 14
33 16
34 14
35 16
36 16
37 16
38 16
39 16
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
mov    $0x40800000,%esi
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  de84 <_x87_bltgti_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r12d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  ccd0 <_x87_movi_f>
mov    0x0(%rbp),%r8d
mov    %r14d,%ecx
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0x5,%esi
and    $0x7fff,%r8d
callq  a0 <_x87jcc2>
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  ded9 <_x87_bltgti_f+0x79>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_x87_bltgti_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc2(_jit, 0x5, i0, r0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff))); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <CDB___os_closehandle+0x7>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%edi
test   %rax,%rax
je     40 <CDB___os_closehandle+0x40>
callq  *%rax
andb   $0xfd,0x8(%rbx)
test   %eax,%eax
movl   $0xffffffff,(%rbx)
jne    30 <CDB___os_closehandle+0x30>
xor    %eax,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
jmpq   36 <CDB___os_closehandle+0x36>
nopw   %cs:0x0(%rax,%rax,1)
callq  45 <CDB___os_closehandle+0x45>
jmp    14 <CDB___os_closehandle+0x14>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___os_closehandle(fhp)
 DB_FH *fhp;
{
 int ret;
 ((void)0);
 ret = CDB___db_jump.j_close != ((void *)0) ?
     CDB___db_jump.j_close(fhp->fd) : close(fhp->fd);
 fhp->fd = -1;
 (fhp)->flags &= ~(0x02);
 return (ret == 0 ? 0 : CDB___os_get_errno());
}
<<<sep_in_sample>>>
1 6
2 3
3 3
4 7
5 7
6 7
7 7
8 9
9 10
10 8
11 10
12 11
13 11
14 11
15 11
16 11
17 10
18 10
19 7
20 7
21 7
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmbis_io_write_hdrindexes(RPMBIS * rpmbis, int ofd)
{
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
xor    %r8d,%r8d
mov    %esi,%edi
mov    $0x3,%ecx
mov    $0xc,%edx
add    $0x7c,%rax
mov    %rax,%rsi
jmpq   70f <etar_set_size+0x1f>
nop
<<<sep_in_sample>>>
etar_set_size(ETAR * etar, unsigned int val)
{
        off_to_chars (val, ((struct tar_header *)((etar)->tar_hdrM))->size, sizeof (((struct tar_header *)((etar)->tar_hdrM))->size), POSIX_FORMAT, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
test   %rcx,%rcx
movsd  (%rdx),%xmm0
je     c5 <gsl_histogram_min_val+0x35>
lea    0x8(%rdx),%rax
lea    (%rdx,%rcx,8),%rdx
jmp    c0 <gsl_histogram_min_val+0x30>
nopw   0x0(%rax,%rax,1)
movsd  (%rax),%xmm1
add    $0x8,%rax
minsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
cmp    %rdx,%rax
jne    b0 <gsl_histogram_min_val+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram_min_val (const gsl_histogram * h)
{
  size_t i;
  double min = h->bin[0];
  for (i = 0; i < h->n; i++)
    {
      if (h->bin[i] < min)
        {
          min = h->bin[i];
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 4
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 5
15 5
16 13
17 13
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_mset (rec_rset_t rset)
{
  return rset->mset;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x8,0x0(%rip)        # 186b <close_and_go+0xb>
je     1885 <close_and_go+0x25>
mov    0x0(%rip),%rax        # 1874 <close_and_go+0x14>
mov    0x90(%rax),%rdi
test   %rdi,%rdi
je     1885 <close_and_go+0x25>
callq  1885 <close_and_go+0x25>
callq  188a <close_and_go+0x2a>
test   %al,%al
je     1893 <close_and_go+0x33>
add    $0x8,%rsp
retq   
callq  1898 <close_and_go+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_and_go(void)
{
    if (((flags[((LOCKING) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((LOCKING) % (sizeof(unsigned) * 8)))) != 0) && openfile->lock_filename)
 delete_lockfile(openfile->lock_filename);
    if (!close_buffer())
 finish();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 5
10 5
11 5
12 7
13 7
14 6
15 6
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
sub    $0x2010,%rsp
mov    0x18(%rsi),%rdi
mov    %ebx,%esi
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
callq  2888 <discard_stream+0x28>
nopl   0x0(%rax,%rax,1)
mov    $0x2000,%edx
mov    %rsp,%rsi
mov    %ebx,%edi
callq  289f <discard_stream+0x3f>
cmp    $0x0,%eax
jg     2890 <discard_stream+0x30>
je     28b2 <discard_stream+0x52>
callq  28ab <discard_stream+0x4b>
cmpl   $0x4,(%rax)
xchg   %ax,%ax
je     2890 <discard_stream+0x30>
xor    %edi,%edi
callq  28b9 <discard_stream+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
discard_stream (int s, struct servtab *sep)
{
  int ret;
  char buffer[8192];
  set_proc_title (sep->se_service, s);
  while (1)
    {
      while ((ret = read (s, buffer, sizeof buffer)) > 0)
 ;
      if (ret == 0 || (*__errno_location ()) != 4)
 break;
    }
  exit (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 2
7 2
8 2
9 5
10 5
11 8
12 8
13 8
14 8
15 8
16 8
17 10
18 10
19 10
20 10
21 10
22 13
23 13
24 13
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
push   %rbp
xor    %ebp,%ebp
push   %rbx
sub    $0x90,%rsp
callq  17 <m4_fopen+0x17>
test   %rax,%rax
mov    %rax,%rbx
je     5c <m4_fopen+0x5c>
mov    %rax,%rdi
callq  27 <m4_fopen+0x27>
mov    %rsp,%rsi
mov    %eax,%edi
mov    %eax,%r12d
callq  34 <m4_fopen+0x34>
test   %eax,%eax
jne    48 <m4_fopen+0x48>
mov    0x18(%rsp),%eax
and    $0xf000,%eax
cmp    $0x4000,%eax
je     8b <m4_fopen+0x8b>
mov    $0x1,%esi
mov    %r12d,%edi
callq  55 <m4_fopen+0x55>
test   %eax,%eax
jne    70 <m4_fopen+0x70>
mov    %rbx,%rbp
add    $0x90,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  75 <m4_fopen+0x75>
mov    0x0(%rip),%edi        # 7b <m4_fopen+0x7b>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
callq  89 <m4_fopen+0x89>
jmp    59 <m4_fopen+0x59>
mov    %rbx,%rdi
callq  93 <m4_fopen+0x93>
callq  98 <m4_fopen+0x98>
movl   $0x15,(%rax)
jmp    5c <m4_fopen+0x5c>
<<<sep_in_sample>>>
m4_fopen (const char *file)
{
  FILE *fp = fopen_safer (file, "r");
  if (fp)
    {
      struct stat st;
      int fd = fileno (fp);
      if (fstat (fd, &st) == 0 && ((((st.st_mode)) & 0170000) == (0040000)))
        {
          rpl_fclose (fp);
          (*__errno_location ()) = 21;
          return ((void *)0);
        }
      if (set_cloexec_flag (fd, 1) != 0)
        (m4_error (warning_status, (*__errno_location ()), "Warning: cannot protect input file across forks"))
                                                                     ;
    }
  return fp;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 4
5 2
6 2
7 3
8 4
9 3
10 4
11 7
12 7
13 8
14 8
15 7
16 8
17 8
18 8
19 8
20 8
21 8
22 8
23 14
24 14
25 14
26 14
27 14
28 14
29 19
30 19
31 19
32 19
33 19
34 19
35 19
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 10
44 10
45 11
46 11
47 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
test   %rdi,%rdi
cmovne %rdi,%rsi
mov    $0x1,%edi
callq  56a <ck_malloc+0x1a>
test   %rax,%rax
je     574 <ck_malloc+0x24>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  57e <ck_malloc+0x2e>
xchg   %ax,%ax
<<<sep_in_sample>>>
ck_malloc(size)
  size_t size;
{
  void *ret = calloc(1, size ? size : 1);
  if (!ret)
    panic("couldn't allocate memory");
  return ret;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 8
10 8
11 6
12 6
13 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rdi
cmp    %rsi,%rcx
jbe    1680 <gsl_vector_set_basis+0x50>
shl    $0x3,%rdi
xor    %eax,%eax
test   %rcx,%rcx
mov    %r8,%rdx
je     1663 <gsl_vector_set_basis+0x33>
xchg   %ax,%ax
add    $0x1,%rax
movq   $0x0,(%rdx)
add    %rdi,%rdx
cmp    %rcx,%rax
jne    1650 <gsl_vector_set_basis+0x20>
imul   %rsi,%rdi
movsd  0x0(%rip),%xmm0        # 166f <gsl_vector_set_basis+0x3f>
xor    %eax,%eax
movsd  %xmm0,(%r8,%rdi,1)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  169d <gsl_vector_set_basis+0x6d>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_set_basis (gsl_vector * v, size_t i)
{
  double * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  const double zero = 0.0 ;
  const double one = 1.0;
  size_t k;
  if (i >= n)
    {
      do { gsl_error ("index out of range", "init_source.c", 220, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (k = 0; k < n; k++)
    {
      *(double *) (data + 1 * k * stride) = zero;
    }
  *(double *) (data + 1 * i * stride) = one;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 9
5 9
6 9
7 13
8 13
9 13
10 13
11 13
12 13
13 15
14 15
15 13
16 13
17 17
18 17
19 18
20 17
21 18
22 18
23 2
24 11
25 11
26 11
27 11
28 11
29 11
30 19
31 19
32 19
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edx,%ebp
xor    0x0(%rip),%ebp        # 6b <doJoystickEvent+0xb>
push   %rbx
mov    %edx,%ebx
je     8d <doJoystickEvent+0x2d>
test   $0x1,%bpl
mov    %rdi,%r12
je     83 <doJoystickEvent+0x23>
test   $0x1,%dl
je     a0 <doJoystickEvent+0x40>
callq  83 <doJoystickEvent+0x23>
and    $0x2,%ebp
je     8d <doJoystickEvent+0x2d>
test   $0x2,%bl
jne    b0 <doJoystickEvent+0x50>
mov    %ebx,0x0(%rip)        # 93 <doJoystickEvent+0x33>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
callq  a5 <doJoystickEvent+0x45>
and    $0x2,%ebp
jne    88 <doJoystickEvent+0x28>
jmp    8d <doJoystickEvent+0x2d>
nopl   0x0(%rax)
mov    %r12,%rdi
callq  b8 <doJoystickEvent+0x58>
mov    %ebx,0x0(%rip)        # be <doJoystickEvent+0x5e>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doJoystickEvent(craft * c, viewer * u, double throttle, int switches)
{
 int switch_xor = switches ^ last_switches;
 if (switch_xor != 0) {
  if (switch_xor & 1) {
   if (switches & 1) {
    fireWeapon(c);
   }
   else {
    ceaseFireWeapon(c);
   }
  }
  if (switch_xor & 2) {
   if (switches & 2) {
    selectWeapon(c);
   }
  }
 }
 last_switches = switches;
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 2
6 2
7 4
8 5
9 5
10 5
11 6
12 6
13 7
14 13
15 13
16 14
17 14
18 19
19 21
20 21
21 21
22 21
23 21
24 21
25 10
26 13
27 13
28 13
29 13
30 15
31 15
32 19
33 21
34 21
35 21
36 21
37 21
38 21
<<<sep_out_sample>>>
mov    0x40(%rdi),%rsi
cmp    %rsi,0x58(%rdi)
cmovbe 0x58(%rdi),%rsi
mov    0x30(%rdi),%rax
cmp    %rax,%rsi
jbe    4e <re_string_translate_buffer+0x4e>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rax,%rdx
add    (%rdi),%rdx
mov    0x78(%rdi),%rcx
add    0x28(%rdi),%rdx
movzbl (%rdx),%edx
movzbl (%rcx,%rdx,1),%ecx
mov    0x8(%rdi),%rdx
mov    %cl,(%rdx,%rax,1)
add    $0x1,%rax
cmp    %rsi,%rax
jne    20 <re_string_translate_buffer+0x20>
mov    %rsi,0x30(%rdi)
mov    %rsi,0x38(%rdi)
retq   
mov    %rax,%rsi
jmp    45 <re_string_translate_buffer+0x45>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
re_string_translate_buffer (re_string_t *pstr)
{
  Idx buf_idx, end_idx;
  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)
    {
      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];
      pstr->mbs[buf_idx] = pstr->trans[ch];
    }
  pstr->valid_len = buf_idx;
  pstr->valid_raw_len = buf_idx;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 5
17 5
18 5
19 10
20 11
21 11
22 5
23 5
24 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     10a6 <gsl_vector_int_isneg+0x36>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x2,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdl (%rdx),%xmm0
ucomisd %xmm1,%xmm0
jae    10ac <gsl_vector_int_isneg+0x3c>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    1090 <gsl_vector_int_isneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_isneg (const gsl_vector_int * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] >= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
21 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  d49 <is_a_bg_command+0x9>
sub    $0x1,%eax
js     d86 <is_a_bg_command+0x46>
movslq %eax,%rcx
movzbl (%rbx,%rcx,1),%edx
cmp    $0x26,%dl
je     d90 <is_a_bg_command+0x50>
cmp    $0x9,%dl
jne    da9 <is_a_bg_command+0x69>
lea    -0x1(%rbx,%rcx,1),%rdx
jmp    d81 <is_a_bg_command+0x41>
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdx),%ecx
cmp    $0x26,%cl
je     d90 <is_a_bg_command+0x50>
sub    $0x1,%rdx
cmp    $0x9,%cl
jne    da0 <is_a_bg_command+0x60>
sub    $0x1,%eax
jns    d70 <is_a_bg_command+0x30>
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
cmp    $0x20,%cl
je     d81 <is_a_bg_command+0x41>
xor    %eax,%eax
jmp    d88 <is_a_bg_command+0x48>
cmp    $0x20,%dl
je     d5f <is_a_bg_command+0x1f>
xor    %eax,%eax
jmp    d88 <is_a_bg_command+0x48>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_a_bg_command(cmd)
    char *cmd;
{
    int i;
    for (i = strlen(cmd) - 1; i >= 0; i--)
    {
 if (cmd[i] == '&')
     return 1;
 if (cmd[i] != ' ' && cmd[i] != 0x09)
     return 0;
    }
    return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 7
16 7
17 7
18 7
19 9
20 9
21 5
22 5
23 12
24 13
25 13
26 13
27 8
28 13
29 13
30 13
31 9
32 9
33 12
34 12
35 9
36 9
37 12
38 12
39 12
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 2618 <sin_func+0x8>
movapd %xmm0,%xmm2
mulsd  %xmm0,%xmm1
mulsd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 262c <sin_func+0x1c>
subsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 2638 <sin_func+0x28>
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
subsd  %xmm1,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
sin_func (double x)
{
  return -1.0 - (7.0/60.0)*x*x - (31.0/2520.0)*x*x*x*x;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
test   %edx,%edx
jne    430 <get_delegate_command+0x10>
mov    0x10(%rdi),%rax
retq   
nopl   0x0(%rax)
jmpq   130 <get_delegate_command.part.0>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_delegate_command (struct delegation *contract,
        struct file_job *file,
        int evaluate)
{
  if (evaluate)
    return (char *) expand_user_string (job, file,
     (const unsigned char *) "delegating command",
     (const unsigned char *) contract->command);
  else
    return contract->command;
}
<<<sep_in_sample>>>
1 5
2 5
3 10
4 11
5 11
6 11
7 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # 90 <gsl_cdf_binomial_Q+0x10>
ucomisd %xmm1,%xmm0
ja     d0 <gsl_cdf_binomial_Q+0x50>
xorpd  %xmm0,%xmm0
ucomisd %xmm3,%xmm0
ja     d0 <gsl_cdf_binomial_Q+0x50>
cmp    %esi,%edi
jae    f1 <gsl_cdf_binomial_Q+0x71>
mov    %edi,%edi
mov    %esi,%esi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm0
cvtsi2sd %rsi,%xmm2
addsd  %xmm0,%xmm1
subsd  %xmm0,%xmm2
movapd %xmm3,%xmm0
jmpq   c7 <gsl_cdf_binomial_Q+0x47>
nopw   0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x5d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e9 <gsl_cdf_binomial_Q+0x69>
movsd  0x0(%rip),%xmm0        # f1 <gsl_cdf_binomial_Q+0x71>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_cdf_binomial_Q (const unsigned int k, const double p, const unsigned int n)
{
  double Q;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "binomial.c", 93, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (k >= n)
    {
      Q = 0.0;
    }
  else
    {
      a = (double) k + 1.0;
      b = (double) n - k;
      Q = gsl_cdf_beta_P (p, a, b);
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 6
7 6
8 6
9 10
10 10
11 16
12 17
13 21
14 16
15 17
16 18
17 18
18 18
19 18
20 18
21 8
22 8
23 8
24 8
25 8
26 8
27 21
28 21
<<<sep_out_sample>>>
mov    %rsi,0x78(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
msbdf_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msbdf_state_t *state = (msbdf_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # a18 <dicod_init_command_tab+0x8>
push   %rbx
mov    $0x0,%ebx
je     a32 <dicod_init_command_tab+0x22>
mov    %rbx,%rdi
add    $0x28,%rbx
callq  a2c <dicod_init_command_tab+0x1c>
cmpq   $0x0,(%rbx)
jne    a20 <dicod_init_command_tab+0x10>
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_init_command_tab()
{
    struct dicod_command *p;
    for (p = command_tab; p->keyword; p++)
 dicod_add_command(p);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 5
6 4
7 5
8 4
9 4
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzwl 0x8(%rdi),%edi
add    $0x1,%edi
callq  15 <__rcopytexttoc+0x15>
mov    %rax,%rbp
movzwl 0xc(%rbx),%eax
mov    (%rbx),%rcx
movzwl 0x8(%rbx),%edx
mov    %rbp,%rdi
sub    $0x1,%eax
cltq   
lea    0x18(%rcx,%rax,1),%rsi
callq  35 <__rcopytexttoc+0x35>
movzwl 0x8(%rbx),%eax
movb   $0x0,0x0(%rbp,%rax,1)
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__rcopytexttoc (__txtvp t)
{
  char *p;
  p = (char *) xmalloc ((unsigned) t->length + 1);
  (void) strncpy (p, &t->obj->string[t->start - 1], t->length);
  p[t->length] = '\0';
  return (p);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x10,%rsp
test   %rsi,%rsi
je     7f5 <assign_lineno+0x15>
cmpb   $0x0,(%rsi)
jne    810 <assign_lineno+0x30>
xor    %edx,%edx
mov    %edx,0x0(%rip)        # 7fd <assign_lineno+0x1d>
mov    %edx,0x0(%rip)        # 803 <assign_lineno+0x23>
add    $0x10,%rsp
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax)
lea    0x8(%rsp),%rsi
callq  81a <assign_lineno+0x3a>
test   %eax,%eax
je     7f5 <assign_lineno+0x15>
mov    0x8(%rsp),%edx
jmp    7f7 <assign_lineno+0x17>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
assign_lineno (var, value, unused, key)
     SHELL_VAR *var;
     char *value;
     arrayind_t unused;
     char *key;
{
  intmax_t new_value;
  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  line_number = line_number_base = new_value;
  return var;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 8
6 8
7 8
8 8
9 6
10 10
11 10
12 12
13 12
14 12
15 12
16 12
17 8
18 8
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   573 <gsl_vector_ushort_fscanf+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fscanf (FILE * stream, gsl_vector_ushort * v)
{
  int status = gsl_block_ushort_raw_fscanf (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %rdi,%r9
mov    $0x40,%r10d
test   $0x1,%r9b
jne    78 <ring_init+0x78>
test   $0x2,%dil
jne    90 <ring_init+0x90>
test   $0x4,%dil
jne    b0 <ring_init+0xb0>
mov    %r10d,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%r10b
rep stos %rax,%es:(%rdi)
je     3a <ring_init+0x3a>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%r10b
je     4a <ring_init+0x4a>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%r10d
je     53 <ring_init+0x53>
movb   $0x0,(%rdi)
mov    %edx,0x28(%r9)
movslq %edx,%rdx
mov    %rsi,0x10(%r9)
mov    %rsi,(%r9)
mov    %rsi,0x8(%r9)
add    %rdx,%rsi
mov    %rsi,0x18(%r9)
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
lea    0x1(%r9),%rdi
movb   $0x0,(%r9)
mov    $0x3f,%r10b
test   $0x2,%dil
je     15 <ring_init+0x15>
nopl   0x0(%rax)
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%r10d
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     1f <ring_init+0x1f>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%r10d
add    $0x4,%rdi
jmpq   1f <ring_init+0x1f>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ring_init (Ring * ring, unsigned char *buffer, int count)
{
  memset ((char *) ring, 0, sizeof *ring);
  ring->size = count;
  ring->supply = ring->consume = ring->bottom = buffer;
  ring->top = ring->bottom + ring->size;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 4
26 6
27 5
28 5
29 5
30 6
31 6
32 8
33 8
34 8
35 3
36 3
37 3
38 3
39 3
40 3
41 3
42 3
43 3
44 3
45 3
46 3
47 3
48 3
49 3
50 3
51 3
52 3
<<<sep_out_sample>>>
mov    %rsi,0xc8(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_maxbuf_set (Gsasl * ctx,
      Gsasl_server_callback_maxbuf cb)
{
  ctx->cbs_maxbuf = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%rsi
test   %rsi,%rsi
je     6d5 <domfind+0x45>
mov    %rdi,%rbp
add    $0x8,%rbx
jmp    6bd <domfind+0x2d>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rbx
mov    -0x8(%rbx),%rsi
test   %rsi,%rsi
je     6ce <domfind+0x3e>
mov    %rbp,%rdi
callq  6c5 <domfind+0x35>
test   %eax,%eax
je     6b0 <domfind+0x20>
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %eax,%eax
jmp    6ce <domfind+0x3e>
nopl   0x0(%rax)
<<<sep_in_sample>>>
domfind (const char *dom, const char *tldlist[])
{
  int i;
  for (i = 0; tldlist[i]; i++)
    if (domcmp (dom, tldlist[i]))
      return 1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 5
20 6
21 8
22 8
23 8
24 8
25 7
26 7
27 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x2,%edx
mov    $0xa,%esi
mov    $0x0,%edi
callq  19d5 <deleteMarked+0x15>
cmp    $0x8,%eax
je     1a8a <deleteMarked+0xca>
mov    0x0(%rip),%edx        # 19e4 <deleteMarked+0x24>
test   %edx,%edx
jle    1a28 <deleteMarked+0x68>
xor    %ebx,%ebx
jmp    19ff <deleteMarked+0x3f>
nopl   0x0(%rax)
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %eax,0x0(%rip)        # 19fd <deleteMarked+0x3d>
jle    1a28 <deleteMarked+0x68>
cmpb   $0x2a,0x0(%rbx)
jne    19f0 <deleteMarked+0x30>
mov    0x0(,%rbx,8),%rdi
callq  1a15 <deleteMarked+0x55>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %eax,0x0(%rip)        # 1a22 <deleteMarked+0x62>
jg     19ff <deleteMarked+0x3f>
nopl   0x0(%rax)
mov    0x0(%rip),%eax        # 1a2e <deleteMarked+0x6e>
test   %eax,%eax
jle    1a80 <deleteMarked+0xc0>
xor    %ebx,%ebx
jmp    1a4f <deleteMarked+0x8f>
nopw   %cs:0x0(%rax,%rax,1)
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %eax,0x0(%rip)        # 1a4d <deleteMarked+0x8d>
jle    1a80 <deleteMarked+0xc0>
cmpb   $0x2a,0x0(%rbx)
jne    1a40 <deleteMarked+0x80>
mov    0x0(,%rbx,8),%rdi
xor    %esi,%esi
callq  1a67 <deleteMarked+0xa7>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    %eax,0x0(%rip)        # 1a74 <deleteMarked+0xb4>
jg     1a4f <deleteMarked+0x8f>
nopw   %cs:0x0(%rax,%rax,1)
movl   $0x0,0x0(%rip)        # 1a8a <deleteMarked+0xca>
pop    %rbx
retq   
<<<sep_in_sample>>>
deleteMarked()
{
    int i;
    i = msgBox("Delete all selected files/dirs?", 2|8, CONFIRM);
    if(i == 8) return;
    for(i = 0; i < totalFiles; i++)
    {
      if(fileStar[i] == '*')
      {
 remove(files[i]);
      }
    }
    for(i = 0; i < totalDirs; i++)
    {
      if(dirStar[i] == '*')
      {
 deleteThisDir(dirs[i], 0);
      }
    }
  numStarred = 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 8
19 8
20 10
21 10
22 10
23 10
24 6
25 6
26 6
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 15
38 15
39 17
40 17
41 17
42 17
43 17
44 13
45 13
46 13
47 20
48 21
49 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,0x0(%rip)        # 3df8 <dfaparse+0x8>
mov    $0x3,%edi
mov    %rdx,%rbx
mov    %rdx,0x0(%rip)        # 3e07 <dfaparse+0x17>
mov    %esi,0x0(%rip)        # 3e0d <dfaparse+0x1d>
movl   $0xffffffff,0x0(%rip)        # 3e17 <dfaparse+0x27>
movl   $0x1,0x0(%rip)        # 3e21 <dfaparse+0x31>
movl   $0x0,0x0(%rip)        # 3e2b <dfaparse+0x3b>
callq  3e30 <dfaparse+0x40>
movzbl %al,%eax
mov    %eax,0x0(%rip)        # 3e39 <dfaparse+0x49>
callq  3e3e <dfaparse+0x4e>
cmp    $0x1,%rax
jbe    3e59 <dfaparse+0x69>
movl   $0x0,0x0(%rip)        # 3e4e <dfaparse+0x5e>
movq   $0x0,0x0(%rip)        # 3e59 <dfaparse+0x69>
cmpq   $0x0,0x0(%rip)        # 3e61 <dfaparse+0x71>
je     3ec7 <dfaparse+0xd7>
callq  b40 <lex>
mov    %eax,0x0(%rip)        # 3e6e <dfaparse+0x7e>
mov    0x20(%rbx),%eax
mov    %eax,0x0(%rip)        # 3e77 <dfaparse+0x87>
callq  3d80 <regexp>
cmpl   $0xffffffff,0x0(%rip)        # 3e83 <dfaparse+0x93>
jne    3eb5 <dfaparse+0xc5>
mov    0x28(%rbx),%edi
not    %edi
callq  3610 <addtok>
mov    $0x10c,%edi
callq  3610 <addtok>
mov    0x28(%rbx),%eax
test   %eax,%eax
je     3ead <dfaparse+0xbd>
mov    $0x10d,%edi
callq  3610 <addtok>
mov    0x28(%rbx),%eax
add    $0x1,%eax
mov    %eax,0x28(%rbx)
pop    %rbx
retq   
mov    $0x0,%edi
callq  3ebf <dfaparse+0xcf>
mov    %rax,%rdi
callq  3ec7 <dfaparse+0xd7>
mov    $0x0,%edi
callq  3ed1 <dfaparse+0xe1>
mov    %rax,%rdi
callq  3ed9 <dfaparse+0xe9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dfaparse (char const *s, size_t len, struct dfa *d)
{
  dfa = d;
  lexptr = s;
  lexleft = len;
  lasttok = END;
  laststart = 1;
  parens = 0;
  hard_LC_COLLATE = hard_locale (3);
  if ((__ctype_get_mb_cur_max ()) > 1)
    {
      cur_mb_len = 0;
      memset(&mbs, 0, sizeof mbs);
    }
  if (! syntax_bits_set)
    dfaerror(gettext ("no syntax specified"));
  tok = lex();
  depth = d->depth;
  regexp();
  if (tok != END)
    dfaerror(gettext ("unbalanced )"));
  addtok(END - d->nregexps);
  addtok(CAT);
  if (d->nregexps)
    addtok(OR);
  ++d->nregexps;
}
<<<sep_in_sample>>>
1 2
2 4
3 9
4 2
5 3
6 5
7 6
8 7
9 8
10 9
11 9
12 9
13 10
14 10
15 10
16 12
17 13
18 15
19 15
20 17
21 17
22 18
23 18
24 19
25 20
26 20
27 22
28 22
29 22
30 23
31 23
32 24
33 24
34 24
35 25
36 25
37 25
38 26
39 26
40 27
41 27
42 21
43 21
44 21
45 21
46 16
47 16
48 16
49 16
50 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 26b <pre_input+0xb>
callq  270 <pre_input+0x10>
mov    0x0(%rip),%rdi        # 277 <pre_input+0x17>
callq  27c <pre_input+0x1c>
movq   $0x0,0x0(%rip)        # 287 <pre_input+0x27>
callq  28c <pre_input+0x2c>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pre_input (void)
{
    rl_insert_text(pre_input_line);
    free(pre_input_line);
    rl_pre_input_hook = ((void *)0);
    rl_redisplay();
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 6
8 8
9 8
10 8
11 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # b0 <gsl_complex_logabs+0x10>
andpd  %xmm0,%xmm2
andpd  %xmm1,%xmm0
ucomisd %xmm0,%xmm2
jae    100 <gsl_complex_logabs+0x60>
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm1
movsd  %xmm1,0x8(%rsp)
callq  d1 <gsl_complex_logabs+0x31>
movsd  0x8(%rsp),%xmm1
movsd  %xmm0,(%rsp)
movapd %xmm1,%xmm3
mulsd  %xmm1,%xmm3
movapd %xmm3,%xmm0
callq  ed <gsl_complex_logabs+0x4d>
mulsd  0x0(%rip),%xmm0        # f5 <gsl_complex_logabs+0x55>
addsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
nop
movapd %xmm0,%xmm1
movapd %xmm2,%xmm0
divsd  %xmm2,%xmm1
jmp    c6 <gsl_complex_logabs+0x26>
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_complex_logabs (gsl_complex z)
{
  double xabs = fabs (((z).dat[0]));
  double yabs = fabs (((z).dat[1]));
  double max, u;
  if (xabs >= yabs)
    {
      max = xabs;
      u = yabs / xabs;
    }
  else
    {
      max = yabs;
      u = xabs / yabs;
    }
  return log (max) + 0.5 * log1p (u * u);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 6
7 6
8 14
9 14
10 14
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 17
21 17
22 17
23 9
24 8
25 9
26 9
27 9
<<<sep_out_sample>>>
cmp    %edi,%esi
jl     6e0 <tokdel+0x10>
jmpq   5d0 <tokdel.part.2>
nopl   0x0(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tokdel(int beg, int end)
{
     if (end >= beg) {
   if (end < tos)
        memmove(token_stack + beg, token_stack + end + 1,
         (end - beg + 1) * sizeof(token_stack[0]));
   tos -= (end - beg + 1);
     }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movb   $0x0,0x20(%rdi)
retq   
<<<sep_in_sample>>>
digest_md5_free_finish (digest_md5_finish * f)
{
  memset (f, 0, sizeof (*f));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x9,%dil
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_parse822_is_htab (char c)
{
  return c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  660 <free_db>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mod_free_db(dico_handle_t hp)
{
    struct dictdb *db = (struct dictdb *) hp;
    free_db(db);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 6
4 6
5 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    %rax,0x0(%rip)        # 6ba <history_set_history_state+0xa>
mov    0x8(%rdi),%eax
mov    %eax,0x0(%rip)        # 6c3 <history_set_history_state+0x13>
mov    0xc(%rdi),%eax
mov    %eax,0x0(%rip)        # 6cc <history_set_history_state+0x1c>
mov    0x10(%rdi),%eax
mov    %eax,0x0(%rip)        # 6d5 <history_set_history_state+0x25>
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
history_set_history_state (state)
     HISTORY_STATE *state;
{
  the_history = state->entries;
  history_offset = state->offset;
  history_length = state->length;
  history_size = state->size;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 6
6 6
7 7
8 7
9 7
10 7
<<<sep_out_sample>>>
mov    0xc(%rdi),%eax
retq   
<<<sep_in_sample>>>
window_columns(window)
    window_t *window;
{
    return window->columns;
}
<<<sep_in_sample>>>
1 4
2 5
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
test   %rdx,%rdx
jle    60 <__gmpf_fits_slong_p+0x60>
xor    %eax,%eax
cmp    $0x1,%rdx
movslq 0x4(%rdi),%rcx
mov    0x10(%rdi),%rsi
je     20 <__gmpf_fits_slong_p+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %rcx,%rdx
sar    $0x3f,%rdx
mov    %rdx,%rax
xor    %rcx,%rax
sub    %rdx,%rax
test   %rcx,%rcx
movabs $0x7fffffffffffffff,%rdx
movabs $0x8000000000000000,%rcx
cmovs  %rcx,%rdx
cmp    -0x8(%rsi,%rax,8),%rdx
setae  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
__gmpf_fits_slong_p (mpf_srcptr f)
{
  mp_size_t fs, fn;
  mp_srcptr fp;
  mp_exp_t exp;
  mp_limb_t fl;
  exp = ((f)->_mp_exp);
  if (exp < 1)
    return 1;
  fs = ((f)->_mp_size);
  fp = ((f)->_mp_d);
  fn = ((fs) >= 0 ? (fs) : -(fs));
  if (exp == 1)
    {
      fl = fp[fn-1];
    }
  else
    return 0;
  return fl <= (fs >= 0 ? (mp_limb_t) 9223372036854775807L : - (mp_limb_t) (-9223372036854775807L - 1L));
}
<<<sep_in_sample>>>
1 7
2 8
3 8
4 18
5 13
6 10
7 11
8 13
9 20
10 20
11 12
12 12
13 12
14 12
15 12
16 19
17 19
18 19
19 19
20 19
21 19
22 19
23 19
24 19
25 9
26 20
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     440 <gsl_monte_plain_free+0x20>
mov    0x8(%rdi),%rdi
callq  432 <gsl_monte_plain_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   43b <gsl_monte_plain_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
<<<sep_in_sample>>>
gsl_monte_plain_free (gsl_monte_plain_state * s)
{
  if (!s) { return ; };
  free (s->x);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     680 <gsl_block_free+0x20>
mov    0x8(%rdi),%rdi
callq  672 <gsl_block_free+0x12>
mov    %rbx,%rdi
pop    %rbx
jmpq   67b <gsl_block_free+0x1b>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_free (gsl_block * b)
{
  if (!b) { return ; };
  free (b->data);
  free (b);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 5
10 5
11 6
12 6
13 6
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
sub    $0x38,%rsp
xorpd  %xmm0,%xmm0
mov    %fs:0x28,%rax
mov    %rax,0x28(%rsp)
xor    %eax,%eax
ucomisd %xmm2,%xmm0
jae    e40 <LogNormalRandom+0xe0>
movsd  0x0(%rip),%xmm0        # d8e <LogNormalRandom+0x2e>
ucomisd %xmm1,%xmm0
ja     de8 <LogNormalRandom+0x88>
movapd %xmm1,%xmm0
movsd  %xmm2,0x8(%rsp)
callq  da3 <LogNormalRandom+0x43>
movsd  0x8(%rsp),%xmm2
movsd  %xmm0,(%rsp)
movapd %xmm2,%xmm0
callq  db7 <LogNormalRandom+0x57>
movsd  (%rsp),%xmm1
callq  dc1 <LogNormalRandom+0x61>
callq  dc6 <LogNormalRandom+0x66>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
jne    e91 <LogNormalRandom+0x131>
add    $0x38,%rsp
xchg   %ax,%ax
retq   
nopl   0x0(%rax)
movapd %xmm1,%xmm0
lea    0x10(%rsp),%rdi
mov    $0x0,%esi
mov    $0x1,%eax
movsd  %xmm2,0x8(%rsp)
movsd  %xmm1,(%rsp)
callq  e0b <LogNormalRandom+0xab>
lea    0x10(%rsp),%rcx
mov    $0x0,%r8d
mov    $0x0,%edx
mov    $0x8302,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  e29 <LogNormalRandom+0xc9>
movsd  0x8(%rsp),%xmm2
movsd  (%rsp),%xmm1
jmpq   d94 <LogNormalRandom+0x34>
nopl   0x0(%rax)
movapd %xmm2,%xmm0
lea    0x10(%rsp),%rdi
mov    $0x0,%esi
mov    $0x1,%eax
movsd  %xmm1,0x8(%rsp)
movsd  %xmm2,(%rsp)
callq  e63 <LogNormalRandom+0x103>
lea    0x10(%rsp),%rcx
mov    $0x0,%r8d
mov    $0x0,%edx
mov    $0x8303,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  e81 <LogNormalRandom+0x121>
movsd  (%rsp),%xmm2
movsd  0x8(%rsp),%xmm1
jmpq   d94 <LogNormalRandom+0x34>
callq  e96 <LogNormalRandom+0x136>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
LogNormalRandom (double dMean, double dStdDev)
{
  if (dMean <= 0) {
    char str[10];
    sprintf(str, "%5.2e", dMean);
    ReportRunTimeError(((void *)0), 0x0303 | 0x8000,
                       "", str, "LogNormalRandom");
  }
  else
    if (dStdDev < 1) {
      char str[10];
      sprintf(str, "%5.2e", dStdDev);
      ReportRunTimeError(((void *)0), 0x0302 | 0x8000,
                         "", str, "LogNormalRandom");
    }
  return exp (NormalRandom (log (dMean), log (dStdDev)));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 10
10 10
11 10
12 16
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 13
47 5
48 5
49 5
50 5
51 5
52 5
53 5
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 6
62 6
63 6
64 17
65 17
<<<sep_out_sample>>>
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
cmpq   $0x0,0x0(,%rdx,8)
mov    %edx,%eax
je     5b74 <number_of_args+0x24>
add    $0x1,%rdx
cmp    $0x9,%rdx
jne    5b58 <number_of_args+0x8>
mov    $0x9,%eax
mov    0x0(%rip),%rdx        # 5b7b <number_of_args+0x2b>
test   %rdx,%rdx
je     5b8b <number_of_args+0x3b>
mov    (%rdx),%rdx
add    $0x1,%eax
test   %rdx,%rdx
jne    5b80 <number_of_args+0x30>
repz retq 
nopl   (%rax)
<<<sep_in_sample>>>
number_of_args ()
{
  register WORD_LIST *list;
  int n;
  for (n = 0; n < 9 && dollar_vars[n+1]; n++)
    ;
  for (list = rest_of_args; list; list = list->next)
    n++;
  return n;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 8
15 7
16 7
17 10
18 10
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3bb <_wsplt_error+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rsi
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # 3d2 <_wsplt_error+0x72>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3f6 <_wsplt_error+0x96>
mov    0x0(%rip),%rsi        # 3fd <_wsplt_error+0x9d>
mov    $0xa,%edi
callq  407 <_wsplt_error+0xa7>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
_wsplt_error (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vfprintf (stderr, fmt, ap);
  __builtin_va_end(ap);
  fputc ('\n', stderr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 2
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 7
28 7
29 7
30 8
31 8
32 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     e <__rct+0xe>
callq  e <__rct+0xe>
mov    $0x50,%edi
callq  18 <__rct+0x18>
mov    0x0(%rip),%rdx        # 1f <__rct+0x1f>
movq   $0x7,(%rax)
mov    %rdx,0x30(%rax)
mov    0x0(%rip),%rdx        # 31 <__rct+0x31>
mov    %rax,0x0(%rip)        # 38 <__rct+0x38>
mov    %rdx,0x10(%rax)
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
__rct (long as)
{
  __dhp x;
  if (as)
    __rss (as);
  x = __ralloc ((long) sizeof (__thunk));
  x->pp = (__pty) 7;
  x->sl = __sl;
  x->dl = __pb;
  __pb = x;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 6
7 8
8 7
9 8
10 9
11 10
12 9
13 11
14 11
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # 6eb <rterrors+0x1b>
mov    0x0(%rip),%rdx        # 6f2 <rterrors+0x22>
mov    0x0(%rip),%rdi        # 6f9 <rterrors+0x29>
jne    72b <rterrors+0x5b>
callq  700 <rterrors+0x30>
mov    0x0(%rip),%rdi        # 707 <rterrors+0x37>
mov    %rbx,%rsi
mov    %rbp,%rdx
xor    %eax,%eax
callq  714 <rterrors+0x44>
mov    0x0(%rip),%rsi        # 71b <rterrors+0x4b>
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   72b <rterrors+0x5b>
callq  730 <rterrors+0x60>
mov    0x0(%rip),%rdi        # 737 <rterrors+0x67>
mov    %rbp,%rdx
mov    %rbx,%rsi
xor    %eax,%eax
callq  744 <rterrors+0x74>
mov    0x0(%rip),%rdi        # 74b <rterrors+0x7b>
mov    0x0(%rip),%rcx        # 752 <rterrors+0x82>
mov    $0x0,%esi
mov    $0x20,%edx
xor    %eax,%eax
callq  763 <rterrors+0x93>
mov    $0x1,%esi
mov    $0x0,%edi
callq  772 <rterrors+0xa2>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rterrors (const char *fmt, const char *s)
{
  if (fsp != ((void *)0))
    {
      fprintf (stderr, "%s: ", progname);
      fprintf (stderr, fmt, s);
      fprintf (stderr, " while calculating %.*s'\n", 32, fsp->sy_name);
      longjmp (mark, 1);
    }
  else
    {
      fprintf (stderr, "%s: ", progname);
      fprintf (stderr, fmt, s);
      fprintf (stderr, "\n");
    }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 3
9 5
10 5
11 3
12 12
13 13
14 13
15 13
16 13
17 13
18 14
19 16
20 14
21 16
22 16
23 14
24 5
25 6
26 6
27 6
28 6
29 6
30 7
31 7
32 7
33 7
34 7
35 7
36 8
37 8
38 8
39 8
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_sec_add_1_itch (mp_size_t n)
{
  return n;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x20,%edi
callq  8e <add_segment+0xe>
mov    0x60(%rbx),%rdx
movq   $0x0,(%rax)
test   %rdx,%rdx
je     b0 <add_segment+0x30>
mov    %rax,(%rdx)
addq   $0x1,0x68(%rbx)
mov    %rax,0x60(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
addq   $0x1,0x68(%rbx)
mov    %rax,0x58(%rbx)
mov    %rax,0x60(%rbx)
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
add_segment (struct transform *tf)
{
  struct replace_segm *segm = xmalloc (sizeof *segm);
  segm->next = ((void *)0);
  if (tf->repl_tail)
    tf->repl_tail->next = segm;
  else
    tf->repl_head = segm;
  tf->repl_tail = segm;
  tf->segm_count++;
  return segm;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 4
7 5
8 5
9 6
10 10
11 9
12 12
13 12
14 12
15 10
16 8
17 9
18 12
19 12
20 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  352c <gsl_sf_hyperg_2F1_conj_renorm+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3540 <gsl_sf_hyperg_2F1_conj_renorm+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x3c3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3556 <gsl_sf_hyperg_2F1_conj_renorm+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_2F1_conj_renorm(double aR, double aI, double c, double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_2F1_conj_renorm_e(aR, aI, c, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_2F1_conj_renorm_e(aR, aI, c, x, &result)", "hyperg_2F1.c", 963, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 27c <StoreDelayed+0xc>
add    $0x1,%eax
cmp    $0x3e8,%eax
je     2f0 <StoreDelayed+0x80>
mov    %eax,0x0(%rip)        # 28c <StoreDelayed+0x1c>
cltq   
shl    $0x3,%rax
mov    0x0(%rip),%rdx        # 299 <StoreDelayed+0x29>
xor    %ebx,%ebx
movsd  %xmm0,(%rdx,%rax,1)
jmp    2da <StoreDelayed+0x6a>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 2af <StoreDelayed+0x3f>
cmpq   $0x0,(%rax,%rbx,8)
je     2d6 <StoreDelayed+0x66>
mov    0x0(%rip),%rax        # 2bd <StoreDelayed+0x4d>
movslq 0x0(%rip),%rdx        # 2c4 <StoreDelayed+0x54>
movsd  0x0(,%rbp,8),%xmm0
mov    (%rax,%rbx,8),%rax
movsd  %xmm0,(%rax,%rdx,8)
add    $0x1,%rbx
callq  2df <StoreDelayed+0x6f>
cmp    %eax,%ebx
movslq %ebx,%rbp
jl     2a8 <StoreDelayed+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
movl   $0x0,0x0(%rip)        # 2fa <StoreDelayed+0x8a>
xor    %eax,%eax
jmp    292 <StoreDelayed+0x22>
<<<sep_in_sample>>>
StoreDelayed (double t)
{
  int i;
  iCurrentTime++;
  if (iCurrentTime == 1000)
    iCurrentTime = 0;
  rgdTime[iCurrentTime] = t;
  for (i = 0; i < GetNModelVars(); i++)
    if (rgiVars[i]) {
      pdVar[i][iCurrentTime] = vrgModelVars[i];
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 5
7 5
8 4
9 4
10 4
11 7
12 8
13 7
14 8
15 8
16 9
17 9
18 9
19 10
20 10
21 10
22 10
23 10
24 10
25 8
26 8
27 8
28 8
29 12
30 12
31 12
32 12
33 12
34 6
35 6
36 6
<<<sep_out_sample>>>
test   %rsi,%rsi
je     5b10 <_jit_get_data+0x10>
mov    0x38(%rdi),%rax
mov    0x70(%rax),%rax
mov    %rax,(%rsi)
test   %rdx,%rdx
je     5b23 <_jit_get_data+0x23>
mov    0x38(%rdi),%rax
mov    0x110(%rax),%rax
mov    %rax,(%rdx)
mov    0x18(%rdi),%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_get_data(jit_state_t *_jit, jit_word_t *data_size, jit_word_t *note_size)
{
    ((void) (0));
    if (data_size)
 *data_size = _jit->comp->data.offset;
    if (note_size)
 *note_size = _jit->comp->note.size;
    return (_jit->data.ptr);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 6
7 6
8 7
9 7
10 7
11 8
12 9
13 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     fa <mu_mailcap_destroy+0x9a>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rdi),%r13
test   %r13,%r13
je     f0 <mu_mailcap_destroy+0x90>
cmpq   $0x0,0x8(%r13)
je     f0 <mu_mailcap_destroy+0x90>
mov    $0x1,%r12d
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
mov    0x0(%r13),%rax
mov    $0x1,%ebx
mov    (%rax,%rdx,8),%rbp
mov    0x0(%rbp),%rdi
callq  a6 <mu_mailcap_destroy+0x46>
mov    0x8(%rbp),%rdi
callq  af <mu_mailcap_destroy+0x4f>
xor    %eax,%eax
cmpq   $0x0,0x18(%rbp)
jne    c6 <mu_mailcap_destroy+0x66>
jmp    dd <mu_mailcap_destroy+0x7d>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rdx,%rbx
mov    0x10(%rbp),%rdx
mov    (%rdx,%rax,8),%rdi
callq  d3 <mu_mailcap_destroy+0x73>
cmp    %rbx,0x18(%rbp)
lea    0x1(%rbx),%rdx
ja     c0 <mu_mailcap_destroy+0x60>
cmp    %r12,0x8(%r13)
lea    0x1(%r12),%rax
jbe    f0 <mu_mailcap_destroy+0x90>
mov    %r12,%rdx
mov    %rax,%r12
jmp    90 <mu_mailcap_destroy+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_mailcap_destroy (mu_mailcap_t * pmailcap)
{
  if (pmailcap != ((void *)0) && *pmailcap != ((void *)0))
    {
      int i;
      mu_mailcap_t mailcap = *pmailcap;
      for (i = 0; i < mailcap->entries_count; i++)
 {
   int j;
   mu_mailcap_entry_t entry = mailcap->entries[i];
   free (entry->typefield);
   free (entry->viewcommand);
   for (j = 0; j < entry->fields_count; j++)
     {
       free (entry->fields[j]);
     }
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 7
12 7
13 7
14 7
15 7
16 10
17 13
18 10
19 11
20 11
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 15
33 13
34 13
35 13
36 7
37 7
38 7
39 7
40 7
41 7
42 19
43 19
44 19
45 19
46 19
47 19
48 19
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 2576 <sshget_leng+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sshget_leng (void)
{
        return sshleng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 4f66 <_rl_clean_up_for_exit+0x6>
test   %eax,%eax
je     4fa8 <_rl_clean_up_for_exit+0x48>
sub    $0x8,%rsp
mov    0x0(%rip),%edi        # 4f74 <_rl_clean_up_for_exit+0x14>
test   %edi,%edi
jle    4f7d <_rl_clean_up_for_exit+0x1d>
callq  4f7d <_rl_clean_up_for_exit+0x1d>
mov    0x0(%rip),%rdi        # 4f84 <_rl_clean_up_for_exit+0x24>
movl   $0x0,0x0(%rip)        # 4f8e <_rl_clean_up_for_exit+0x2e>
callq  4f93 <_rl_clean_up_for_exit+0x33>
xor    %esi,%esi
mov    $0x1,%edi
add    $0x8,%rsp
jmpq   4fa3 <_rl_clean_up_for_exit+0x43>
nopl   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_clean_up_for_exit ()
{
  if (_rl_echoing_p)
    {
      if (_rl_vis_botlin > 0)
 _rl_move_vert (_rl_vis_botlin);
      _rl_vis_botlin = 0;
      fflush (rl_outstream);
      rl_restart_output (1, 0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 5
7 5
8 6
9 8
10 7
11 8
12 9
13 9
14 11
15 9
16 9
17 9
18 9
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     2e <medium_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    10 <medium_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
medium_hash_2 (void const *key)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((((const struct medium *)key)->name)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x20,%rsp
mov    %r8,0x18(%rsp)
callq  30eb <mbox_body_readline+0x1b>
mov    %rax,%rdi
callq  30f3 <mbox_body_readline+0x23>
mov    %rax,%rdi
callq  30fb <mbox_body_readline+0x2b>
mov    0x18(%rax),%rdx
lea    0x48(%rax),%rdi
mov    0x18(%rsp),%r8
mov    %r12,%rcx
mov    %rbx,%rsi
mov    $0x1,%r9d
mov    %rdx,0x8(%rsp)
mov    0x10(%rax),%rax
mov    %rbp,%rdx
mov    %rax,(%rsp)
callq  2f50 <mbox_readstream.isra.1>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_body_readline (mu_stream_t is, char *buffer, size_t buflen,
      mu_off_t off, size_t *pnread)
{
  mu_body_t body = mu_stream_get_owner (is);
  mu_message_t msg = mu_body_get_owner (body);
  mbox_message_t mum = mu_message_get_owner (msg);
  return mbox_readstream (mum, buffer, buflen, off, pnread, 1,
     mum->body, mum->body_end);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
push   %r13
xor    %r13d,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x8,%rsp
cmpq   $0x0,0x0(%rip)        # 3ab <hack_all_symbols+0x1b>
je     3e6 <hack_all_symbols+0x56>
nopl   (%rax)
mov    0x0(%rip),%rax        # 3b7 <hack_all_symbols+0x27>
mov    (%rax,%r13,8),%rdi
test   %rdi,%rdi
jne    3cb <hack_all_symbols+0x3b>
jmp    3d9 <hack_all_symbols+0x49>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    (%rdi),%rbx
mov    %rbp,%rsi
callq  *%r12
test   %rbx,%rbx
jne    3c8 <hack_all_symbols+0x38>
add    $0x1,%r13
cmp    %r13,0x0(%rip)        # 3e4 <hack_all_symbols+0x54>
ja     3b0 <hack_all_symbols+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
hack_all_symbols (hack_symbol *func, void *data)
{
  size_t h;
  symbol *sym;
  symbol *next;
  for (h = 0; h < hash_table_size; h++)
    {
      for (sym = symtab[h]; sym != ((void *)0); sym = next)
        {
          next = ((sym)->next);
          func (sym, data);
        }
    }
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 2
9 6
10 6
11 6
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 10
20 11
21 11
22 8
23 8
24 6
25 6
26 6
27 14
28 14
29 14
30 14
31 14
32 14
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
movsd  (%rax),%xmm0
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_histogram2d_xmin (const gsl_histogram2d * h)
{
  return h->xrange[0];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     55a <yy_grecs_flush_buffer+0x4a>
mov    0x8(%rdi),%rax
movl   $0x0,0x20(%rdi)
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
movl   $0x1,0x2c(%rdi)
movl   $0x0,0x3c(%rdi)
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 548 <yy_grecs_flush_buffer+0x38>
test   %rax,%rax
je     55a <yy_grecs_flush_buffer+0x4a>
mov    0x0(%rip),%rdx        # 554 <yy_grecs_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
je     560 <yy_grecs_flush_buffer+0x50>
repz retq 
nopl   0x0(%rax)
jmpq   d0 <yy_grecs_load_buffer_state>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_grecs_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_grecs_n_chars = 0;
 b->yy_grecs_ch_buf[0] = 0;
 b->yy_grecs_ch_buf[1] = 0;
 b->yy_grecs_buf_pos = &b->yy_grecs_ch_buf[0];
 b->yy_grecs_at_bol = 1;
 b->yy_grecs_buffer_status = 0;
 if ( b == ( (yy_grecs_buffer_stack) ? (yy_grecs_buffer_stack)[(yy_grecs_buffer_stack_top)] : ((void *)0)) )
  yy_grecs_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 6
6 7
7 7
8 8
9 9
10 10
11 8
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
mov    %rdi,0x90(%rsi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_lval (YYSTYPE * yylval_param , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yylval_r = yylval_param;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r13
mov    %esi,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
movslq %edx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rdi),%rcx
mov    0x18(%rdi),%rsi
lea    0x0(%rbp,%rcx,1),%rdx
cmp    %rdx,%rsi
jbe    b0 <__gmp_asprintf_reps+0x50>
mov    0x8(%rdi),%rdi
mov    %rbp,%rdx
mov    %r13d,%esi
add    %rcx,%rdi
callq  9a <__gmp_asprintf_reps+0x3a>
add    %rbp,0x10(%rbx)
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
add    %rdx,%rdx
mov    %rdx,0x18(%rdi)
mov    0x8(%rdi),%rdi
callq  *0x0(%rip)        # c1 <__gmp_asprintf_reps+0x61>
mov    0x10(%rbx),%rcx
mov    %rax,0x8(%rbx)
mov    %rax,%rdi
jmp    8c <__gmp_asprintf_reps+0x2c>
xchg   %ax,%ax
<<<sep_in_sample>>>
__gmp_asprintf_reps (struct gmp_asprintf_t *d, int c, int reps)
{
  do { size_t alloc, newsize, newalloc; do {} while (0); alloc = (d)->alloc; newsize = (d)->size + (reps); if (alloc <= newsize) { newalloc = 2*newsize; (d)->alloc = newalloc; (d)->buf = ((char *) (*__gmp_reallocate_func) ((d)->buf, (alloc) * sizeof (char), (newalloc) * sizeof (char))); } } while (0);
  memset (d->buf + d->size, c, reps);
  d->size += reps;
  return reps;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 2
9 2
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
18 4
19 4
20 5
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 3
30 3
31 3
32 3
33 3
34 3
35 3
36 3
37 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,(%rsp)
mov    %rsi,0x8(%rsp)
mov    $0x0,%edi
mov    %rsp,%rsi
callq  1a <__gmp_vsnprintf+0x1a>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
__gmp_vsnprintf (char *buf, size_t size, const char *fmt, va_list ap)
{
  struct gmp_snprintf_t d;
  do {} while (0);
  d.buf = buf;
  d.size = size;
  return __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 7
5 7
6 7
7 8
8 8
<<<sep_out_sample>>>
push   %r12
mov    $0x2,%ecx
mov    %edx,%r12d
mov    $0x2,%edx
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
sub    $0x10,%rsp
mov    (%rsi),%rax
mov    %ebx,%esi
lea    0x8(%rax),%rdi
callq  c70 <bad_argc.isra.0>
test   %al,%al
jne    1379 <include+0x69>
cmp    $0x1,%ebx
mov    $0x0,%edi
jle    134e <include+0x3e>
mov    0x8(%rbp),%rax
mov    0x8(%rax),%rdi
lea    0x8(%rsp),%rsi
callq  1358 <include+0x48>
test   %rax,%rax
je     1388 <include+0x78>
mov    0x8(%rsp),%rsi
mov    %rax,%rdi
mov    $0x1,%edx
callq  136f <include+0x5f>
mov    0x8(%rsp),%rdi
callq  1379 <include+0x69>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
test   %r12b,%r12b
jne    1379 <include+0x69>
cmp    $0x1,%ebx
mov    $0x0,%r12d
jle    13a0 <include+0x90>
mov    0x8(%rbp),%rax
mov    0x8(%rax),%r12
callq  13a5 <include+0x95>
mov    0x0(%rip),%edi        # 13ab <include+0x9b>
mov    (%rax),%esi
mov    %r12,%rcx
mov    $0x0,%edx
xor    %eax,%eax
callq  13bc <include+0xac>
movl   $0x1,0x0(%rip)        # 13c6 <include+0xb6>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
<<<sep_in_sample>>>
include (int argc, token_data **argv, _Bool silent)
{
  FILE *fp;
  char *name;
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  fp = m4_path_search ((argc > (1) ? ((argv[1])->u.u_t.text) : ""), &name);
  if (fp == ((void *)0))
    {
      if (!silent)
        {
          (m4_error (warning_status, (*__errno_location ()), "cannot open `%s'", (argc > (1) ? ((argv[1])->u.u_t.text) : "")));
          retcode = 1;
        }
      return;
    }
  push_file (fp, name, 1);
  free (name);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 2
6 2
7 2
8 2
9 2
10 2
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 8
24 8
25 17
26 17
27 17
28 17
29 18
30 18
31 19
32 19
33 19
34 19
35 19
36 19
37 10
38 10
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
48 12
49 12
50 12
51 13
52 19
53 19
54 19
55 19
56 19
57 19
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    (%rsi),%rdx
sub    $0x1,%rcx
sub    $0x1,%rdx
jmp    74 <printer_hash_cmp+0x14>
cmp    (%rdx),%al
jne    85 <printer_hash_cmp+0x25>
add    $0x1,%rcx
movzbl (%rcx),%eax
add    $0x1,%rdx
test   %al,%al
jne    70 <printer_hash_cmp+0x10>
xor    %eax,%eax
movzbl (%rdx),%edx
sub    %edx,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_hash_cmp (struct printer *x, struct printer *y)
{
  do { int result; do { unsigned char const *xx = (unsigned char const *) (x->key) - 1; unsigned char const *yy = (unsigned char const *) (y->key) - 1; do { if (*++xx == '\0') { yy++; break; } } while (*xx == *++yy); (result) = *xx - *yy; } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %r12
movzbl %dl,%edx
mov    %ecx,%r12d
movzbl %sil,%esi
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  1cd6 <cpio_safer_name_suffix+0x16>
test   %r12b,%r12b
mov    %rax,%rbx
je     1d20 <cpio_safer_name_suffix+0x60>
mov    $0x0,%edi
mov    $0x3,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     1d20 <cpio_safer_name_suffix+0x60>
movzbl (%rax),%eax
cmp    $0x2e,%al
jne    1d20 <cpio_safer_name_suffix+0x60>
nopw   %cs:0x0(%rax,%rax,1)
cmpb   $0x2f,0x1(%rbx)
jne    1d20 <cpio_safer_name_suffix+0x60>
add    $0x1,%rbx
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%eax
cmp    $0x2f,%al
je     1d10 <cpio_safer_name_suffix+0x50>
cmp    $0x2e,%al
je     1d00 <cpio_safer_name_suffix+0x40>
nop
cmp    %rbp,%rbx
je     1d40 <cpio_safer_name_suffix+0x80>
mov    %rbx,%rdi
callq  1d2d <cpio_safer_name_suffix+0x6d>
mov    %rbx,%rsi
mov    %rbp,%rdi
lea    0x1(%rax),%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1d40 <cpio_safer_name_suffix+0x80>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpio_safer_name_suffix (char *name, _Bool link_target, _Bool absolute_names,
   _Bool strip_leading_dots)
{
  char *p = safer_name_suffix (name, link_target, absolute_names);
  if (strip_leading_dots && strcmp (p, "./"))
    while (*p == '.' && *(p + 1) == '/')
      {
 ++p;
 while (*p == '/')
   ++p;
      }
  if (p != name)
    memmove (name, p, (size_t)(strlen (p) + 1));
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 3
6 3
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 8
24 8
25 10
26 9
27 9
28 9
29 6
30 6
31 6
32 12
33 12
34 13
35 13
36 13
37 13
38 13
39 14
40 14
41 14
42 13
43 14
44 14
45 14
46 14
47 14
<<<sep_out_sample>>>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    0x0(%rax),%edx
add    $0x4,%rax
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
cmp    $0x18,%rax
jne    58 <resetColors+0x8>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
resetColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    FG_COLOR[i] = oldFGColors[i];
    BG_COLOR[i] = oldBGColors[i];
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 7
7 7
8 4
9 4
10 9
11 9
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   67d <savedir_warn+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
savedir_warn (char const *name)
{
  call_arg_warn ("savedir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x18,%edi
callq  b <strar_open+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     46 <strar_open+0x46>
mov    $0x84,%edi
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
callq  2a <strar_open+0x2a>
mov    $0xa,%edi
mov    %rax,0x10(%rbx)
callq  38 <strar_open+0x38>
xor    %esi,%esi
mov    %rax,%rdi
mov    %rax,0x8(%rbx)
callq  46 <strar_open+0x46>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strar_open(void)
{
 STRAR * strb;
 strb = (STRAR *)malloc(sizeof(STRAR));
 if (strb == (STRAR *)(((void *)0)))
  return (STRAR *)(((void *)0));
 strb->lenM = 0;
 strb->nsM = 0;
 strb->storageM = strob_open(132);
 strb->listM = cplob_open(10);
 cplob_add_nta(strb->listM, ((void *)0));
 return strb;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 9
8 7
9 8
10 9
11 10
12 9
13 10
14 11
15 11
16 10
17 11
18 13
19 13
20 13
21 13
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x3,%esi
lea    0x38(%rdi),%rsi
sete   %al
mov    %edx,%ecx
mov    $0x2,%r8d
mov    %eax,%edx
jmpq   5ab <__osip_ict_need_timer_d_event+0x1b>
<<<sep_in_sample>>>
__osip_ict_need_timer_d_event (osip_ict_t * ict, state_t state, int transactionid)
{
  return __osip_transaction_need_timer_x_event (ict, &ict->timer_d_start, state == ICT_COMPLETED, transactionid, TIMEOUT_D);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %r12
mov    $0x16,%eax
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
mov    0x10(%rdi),%rdx
test   %rdx,%rdx
je     22d <_mapfile_read+0x4d>
mov    0x20(%rbp),%rax
mov    0x18(%rbp),%r8
mov    %rsi,%rdi
mov    %rcx,%r12
lea    (%rbx,%rax,1),%rsi
mov    %r8,%rcx
sub    %rax,%rcx
cmp    %r8,%rsi
lea    (%rdx,%rax,1),%rsi
cmova  %rcx,%rbx
mov    %rbx,%rdx
callq  223 <_mapfile_read+0x43>
add    %rbx,0x20(%rbp)
xor    %eax,%eax
mov    %rbx,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_read(void *data, char *buf, size_t size, size_t *pret)
{
    struct _mapfile_stream *mfs = data;
    size_t n;
    if (mfs->start == ((void *)0))
 return 22;
    n = (mfs->offset + size > mfs->size) ? mfs->size - mfs->offset : size;
    memcpy(buf, mfs->start + mfs->offset, n);
    mfs->offset += n;
    *pret = n;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 7
20 8
21 8
22 9
23 11
24 10
25 12
26 12
27 12
28 12
29 12
<<<sep_out_sample>>>
cmp    $0x1,%edi
push   %rbx
je     f48 <ds_show_info+0x58>
mov    0x8(%rsi),%rbx
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     f54 <ds_show_info+0x64>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     f30 <ds_show_info+0x40>
callq  f21 <ds_show_info+0x31>
test   %eax,%eax
je     f70 <ds_show_info+0x80>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  f3a <ds_show_info+0x4a>
pop    %rbx
mov    %rax,%rdi
xor    %eax,%eax
jmpq   f45 <ds_show_info+0x55>
nopl   (%rax)
mov    0x0(%rip),%rbx        # f4f <ds_show_info+0x5f>
test   %rbx,%rbx
jne    efa <ds_show_info+0xa>
mov    $0x0,%edi
callq  f5e <ds_show_info+0x6e>
pop    %rbx
mov    %rax,%rdi
xor    %eax,%eax
jmpq   f69 <ds_show_info+0x79>
nopl   0x0(%rax)
mov    %rbx,%rdx
mov    0x0(%rip),%rdi        # f7a <ds_show_info+0x8a>
mov    $0x0,%ecx
pop    %rbx
mov    $0x0,%esi
jmpq   f8a <ds_show_info+0x9a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_show_info(int argc, char **argv)
{
    const char *dbname;
    if (argc == 1)
 dbname = dico_url.req.database ? dico_url.req.database : "!";
    else
 dbname = argv[1];
    if (strcmp(dbname, "!") == 0)
 printf(gettext ("Search all of the databases until a match is found,\n" "and display all matches in that database.\n")
                                                 );
    else if (strcmp(dbname, "*") == 0)
 printf(gettext ("Search all of the databases and display all matches."));
    else {
 if (ensure_connection())
     return;
 dict_run_single_command(conn, "SHOW INFO", dbname, "112");
    }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 7
5 8
6 8
7 8
8 8
9 8
10 11
11 11
12 11
13 11
14 11
15 14
16 14
17 14
18 18
19 18
20 18
21 12
22 12
23 18
24 12
25 12
26 12
27 12
28 5
29 5
30 5
31 9
32 12
33 18
34 12
35 12
36 12
37 12
38 16
39 16
40 16
41 18
42 16
43 16
44 16
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b90 <urlIsURL+0x10>
cmpb   $0x0,(%rdi)
je     b90 <urlIsURL+0x10>
jmpq   20 <urlIsURL.part.2>
nop
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
urlIsURL(const char * url) {
    struct urlstring *us;
    if (url && *url) {
 for (us = urlstrings; us->leadin != ((void *)0); us++) {
     if (strncmp(url, us->leadin, strlen(us->leadin)))
  continue;
     return us->ret;
 }
    }
    return URL_IS_UNKNOWN;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 11
8 11
9 11
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdi,%r12
mov    %rsi,%rdi
push   %rbp
mov    %rdx,%rbp
mov    $0xa,%edx
push   %rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rsi
callq  1c54 <getnum+0x24>
mov    0x8(%rsp),%rbx
mov    %rax,%r14
movsbq (%rbx),%r13
test   %r13b,%r13b
jne    1c88 <getnum+0x58>
test   %rbp,%rbp
je     1c6e <getnum+0x3e>
mov    %rbx,0x0(%rbp)
mov    %r14d,(%r12)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
callq  1c8d <getnum+0x5d>
mov    (%rax),%rdx
movzwl (%rdx,%r13,2),%esi
test   $0x2000,%si
jne    1cea <getnum+0xba>
mov    $0x0,%esi
mov    $0x0,%edi
callq  1cab <getnum+0x7b>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  1cb8 <getnum+0x88>
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
lea    0x1(%rbx),%rcx
mov    %rcx,0x8(%rsp)
movsbq 0x1(%rbx),%rsi
test   %sil,%sil
je     1d00 <getnum+0xd0>
movzwl (%rdx,%rsi,2),%esi
mov    %rcx,%rbx
test   $0x2000,%si
jne    1cd0 <getnum+0xa0>
test   %rbp,%rbp
je     1c9c <getnum+0x6c>
mov    %rbx,0x0(%rbp)
jmpq   1c6e <getnum+0x3e>
nop
mov    %rcx,%rbx
jmpq   1c65 <getnum+0x35>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getnum (int *pnum, char *arg, char **endp)
{
  char *p;
  unsigned long x = strtoul (arg, &p, 10);
  if (*p && !((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISspace))
    {
      printf (dgettext ("gdbm", "not a number (stopped near %s)\n"), p);
      return 1;
    }
  while (*p && ((*__ctype_b_loc ())[(int) ((*p))] & (unsigned short int) _ISspace))
    p++;
  if (endp)
    *endp = p;
  else if (*p)
    {
      printf (dgettext ("gdbm", "not a number (stopped near %s)\n"), p);
      return 1;
    }
  *pnum = x;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 2
10 2
11 4
12 4
13 5
14 4
15 5
16 5
17 5
18 12
19 12
20 13
21 19
22 21
23 20
24 21
25 21
26 21
27 21
28 21
29 21
30 21
31 5
32 5
33 5
34 5
35 5
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 21
44 17
45 21
46 21
47 21
48 21
49 21
50 21
51 21
52 11
53 11
54 10
55 10
56 10
57 10
58 11
59 10
60 10
61 12
62 12
63 13
64 13
65 13
66 11
67 11
68 11
<<<sep_out_sample>>>
sub    $0x78,%rsp
mov    0x18(%rdi),%rax
mov    $0x15,%r8d
lea    0xc(%rsp),%rcx
mov    %esi,0xc(%rsp)
movq   $0x0,0x18(%rsp)
movq   $0x0,0x48(%rsp)
mov    %rdx,0x40(%rsp)
xor    %esi,%esi
mov    %rcx,0x10(%rsp)
lea    0x10(%rsp),%rdx
movq   $0x0,0x20(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x30(%rsp)
lea    0x40(%rsp),%rcx
movq   $0x0,0x50(%rsp)
movq   $0x0,0x58(%rsp)
mov    %rax,%rdi
movq   $0x0,0x60(%rsp)
movl   $0x4,0x18(%rsp)
movl   $0x20,0x48(%rsp)
callq  *0x148(%rax)
xor    %edx,%edx
cmp    $0xffff86eb,%eax
cmovne %eax,%edx
add    $0x78,%rsp
mov    %edx,%eax
retq   
nop
<<<sep_in_sample>>>
CDB___db_vrfy_childput(vdp, pgno, cip)
 VRFY_DBINFO *vdp;
 db_pgno_t pgno;
 VRFY_CHILDINFO *cip;
{
 DBT key, data;
 DB *cdbp;
 int ret;
 cdbp = vdp->cdbp;
 memset(&key, 0, sizeof(DBT));
 memset(&data, 0, sizeof(DBT));
 key.data = &pgno;
 key.size = sizeof(db_pgno_t);
 data.data = cip;
 data.size = sizeof(VRFY_CHILDINFO);
 ret = cdbp->put(cdbp, ((void *)0), &key, &data, 21);
 return (ret == (-30997) ? 0 : ret);
}
<<<sep_in_sample>>>
1 5
2 9
3 16
4 12
5 5
6 10
7 11
8 14
9 16
10 12
11 16
12 10
13 10
14 10
15 16
16 11
17 11
18 16
19 11
20 13
21 15
22 16
23 17
24 17
25 17
26 18
27 18
28 18
29 18
<<<sep_out_sample>>>
push   %rbx
cmpb   $0x0,0x9(%rdi)
mov    %rdi,%rbx
je     750 <get_first_track_num_generic+0x10>
movzbl 0x1c(%rbx),%eax
pop    %rbx
retq   
mov    0x1020(%rdi),%rax
callq  *0x158(%rax)
cmpb   $0x0,0x9(%rbx)
jne    74a <get_first_track_num_generic+0xa>
mov    $0xffffffff,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_first_track_num_generic(void *p_user_data)
{
  const generic_img_private_t *p_env = p_user_data;
  if (!p_env->toc_init)
    p_env->cdio->op.read_toc (p_user_data);
  return p_env->toc_init ? p_env->i_first_track : CDIO_INVALID_TRACK;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 6
6 7
7 7
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  72c <topsf_set_psf_prefix+0xc>
mov    %rax,(%rbx)
pop    %rbx
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topsf_set_psf_prefix(TOPSF * topsf, char * p)
{
 topsf->prefix_=swlib_strdup(p);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
mov    %rdi,%rsi
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0xe8(%rdx),%rax
mov    %rdi,%rbx
mov    (%rax),%rdi
callq  130 <is_ok>
test   %al,%al
jne    bc0 <pred_ok+0x30>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rdi
mov    %rbp,%rdx
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   bd2 <pred_ok+0x42>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_ok (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    return impl_pred_exec (pathname, stat_buf, pred_ptr);
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 2
9 3
10 3
11 3
12 3
13 7
14 7
15 7
16 7
17 7
18 7
19 4
20 4
21 4
22 7
23 7
24 7
25 4
26 4
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    $0x28,%edx
mov    $0x0,%esi
shl    $0x3,%rdi
jmpq   26 <strvec_create+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strvec_create (n)
     int n;
{
  return ((char **)sh_xmalloc(((n) * sizeof (char *)), "stringvec.c", 40));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rcx
lea    (%rcx,%rcx,1),%rdi
lea    0x1(%rdi),%r8
add    %rcx,%rdi
lea    0x0(,%r8,8),%r10
mov    %r8,%r9
shl    $0x4,%r9
mov    -0x8(%rsi,%r10,1),%rax
mov    -0x8(%rsi,%r9,1),%r9
mov    %rax,%rbx
cmp    %rax,%r9
cmovge %r9,%rbx
add    %rbx,%rbx
lea    0x3(%rbx,%rdi,4),%rdi
lea    0x2(%rcx,%rcx,8),%rbx
add    %rbx,%rax
add    %rax,%r9
mov    (%rsi,%rcx,8),%rax
lea    0x1(%rcx,%r8,1),%rcx
sub    (%rsi),%rax
add    -0x8(%rsi,%rcx,8),%rax
sub    (%rsi,%r10,1),%rax
pop    %rbx
add    %r9,%rax
sub    %rax,%rdi
xor    %eax,%eax
test   %rdi,%rdi
cmovns %rdi,%rax
mov    %rax,(%rdx)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
adjlr_(long *n, long *isp, long *ldif)
{
  long lnfc, lsfc, nzlu, jlmax, jumax, ip;
  --isp;
  ip = (*n << 1) + 1;
  jlmax = isp[ip];
  jumax = isp[ip + ip];
  nzlu = isp[*n + 1] - isp[1] + isp[ip + *n + 1] - isp[ip + 1];
  lsfc = *n * 12 + 3 + (((jlmax) >= (jumax) ? (jlmax) : (jumax)) << 1);
  lnfc = *n * 9 + 2 + jlmax + jumax + nzlu;
  *ldif = lsfc - lnfc;
  if (*ldif < 0) *ldif = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 9
6 6
7 7
8 7
9 6
10 7
11 9
12 9
13 9
14 9
15 9
16 10
17 10
18 10
19 8
20 8
21 8
22 8
23 8
24 14
25 10
26 11
27 11
28 11
29 11
30 11
31 14
32 14
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rcx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%rdi
test   %r9,%r9
je     3c0d <gsl_matrix_short_set_zero+0x4d>
lea    (%r8,%r8,1),%r10
add    %rdi,%rdi
xor    %esi,%esi
nopl   (%rax)
test   %r8,%r8
je     3c01 <gsl_matrix_short_set_zero+0x41>
lea    (%rcx,%r10,1),%rdx
mov    %rcx,%rax
nopl   0x0(%rax)
xor    %r11d,%r11d
add    $0x2,%rax
mov    %r11w,-0x2(%rax)
cmp    %rdx,%rax
jne    3bf0 <gsl_matrix_short_set_zero+0x30>
add    $0x1,%rsi
add    %rdi,%rcx
cmp    %r9,%rsi
jne    3be0 <gsl_matrix_short_set_zero+0x20>
repz retq 
nop
<<<sep_in_sample>>>
gsl_matrix_short_set_zero (gsl_matrix_short * m)
{
  size_t i, j;
  short * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const short zero = 0;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(short *) (data + 1 * (i * tda + j)) = zero;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 11
12 11
13 11
14 11
15 11
16 13
17 13
18 13
19 11
20 11
21 9
22 9
23 9
24 9
25 9
26 9
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 378 <progcomp_create+0x8>
je     380 <progcomp_create+0x10>
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x100,%edi
callq  38e <progcomp_create+0x1e>
mov    %rax,0x0(%rip)        # 395 <progcomp_create+0x25>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
progcomp_create ()
{
  if (prog_completes == 0)
    prog_completes = hash_create (256);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 2
6 4
7 4
8 4
9 5
10 5
11 5
<<<sep_out_sample>>>
mov    %rsi,0xc8(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_maxbuf_set (Gsasl * ctx,
      Gsasl_server_callback_maxbuf cb)
{
  ctx->cbs_maxbuf = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     233 <copy_redirects+0x43>
xor    %ebp,%ebp
jmp    20b <copy_redirects+0x1b>
nopw   0x0(%rax,%rax,1)
mov    %rax,%rbp
mov    %rbx,%rdi
callq  213 <copy_redirects+0x23>
mov    %rbp,(%rax)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    208 <copy_redirects+0x18>
test   %rbp,%rbp
je     235 <copy_redirects+0x45>
add    $0x8,%rsp
mov    %rax,%rdi
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   233 <copy_redirects+0x43>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
copy_redirects (list)
     REDIRECT *list;
{
  REDIRECT *new_list, *temp;
  for (new_list = (REDIRECT *)((void *)0); list; list = list->next)
    {
      temp = copy_redirect (list);
      temp->next = new_list;
      new_list = temp;
    }
  return (((new_list && new_list->next) ? (REDIRECT *)list_reverse ((GENERIC_LIST *)new_list) : (REDIRECT *)(new_list)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 7
12 7
13 8
14 5
15 5
16 5
17 11
18 11
19 12
20 11
21 11
22 12
23 12
24 11
25 5
26 12
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_search_atleast (gl_oset_t set,
                        gl_setelement_threshold_fn threshold_fn,
                        const void *threshold, const void **eltp)
{
  return ((const struct gl_oset_impl_base *) set)->vtable
         ->search_atleast (set, threshold_fn, threshold, eltp);
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 5
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
jmp    1a <nonintr_close+0x1a>
nopw   0x0(%rax,%rax,1)
callq  15 <nonintr_close+0x15>
cmpl   $0x4,(%rax)
jne    27 <nonintr_close+0x27>
mov    %ebp,%edi
callq  21 <nonintr_close+0x21>
test   %eax,%eax
mov    %eax,%ebx
js     10 <nonintr_close+0x10>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nonintr_close (int fd)
{
  int retval;
  do
    retval = close (fd);
  while (retval < 0 && (*__errno_location ()) == 4);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 5
11 5
12 6
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  (void) (args_info);
  (void) (prog_name);
  return 0;
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_os2 (void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
sigsegv_reset_onstack_flag (void)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mac_format_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 136 <report_current_timing+0x6>
test   %eax,%eax
jne    140 <report_current_timing+0x10>
repz retq 
nopl   0x0(%rax)
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  14c <report_current_timing+0x1c>
mov    %rbx,%rdi
mov    %rax,%rsi
mov    $0x0,%edx
callq  15c <report_current_timing+0x2c>
pop    %rbx
xor    %eax,%eax
jmpq   164 <report_current_timing+0x34>
<<<sep_in_sample>>>
report_current_timing(dico_stream_t stream, const char *name)
{
    if (timing_option) {
 xdico_timer_t t = timer_stop(name);
 report_timing(stream, t, &current_stat);
 clear_stats();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 5
14 8
15 6
16 6
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   $0x7,%sil
jne    3e1 <openssl_cast_decrypt+0x51>
test   %rsi,%rsi
mov    %rdi,%r13
mov    %rdx,%rbp
mov    %rcx,%r12
je     3d6 <openssl_cast_decrypt+0x46>
nopl   0x0(%rax)
xor    %ecx,%ecx
mov    %rbp,%rsi
mov    %r12,%rdi
mov    %r13,%rdx
add    $0x8,%rbp
add    $0x8,%r12
callq  3d0 <openssl_cast_decrypt+0x40>
sub    $0x8,%rbx
jne    3b8 <openssl_cast_decrypt+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x0,%ecx
mov    $0x13e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3fa <openssl_cast_decrypt+0x6a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openssl_cast_decrypt(const void *ctx, size_t length,
       uint8_t *dst, const uint8_t *src)
{
  ((!(length % 8)) ? (void) (0) : __assert_fail ("!(length % 8)", "nettle-openssl.c", 318, __PRETTY_FUNCTION__));
  while (length)
    {
      CAST_ecb_encrypt(src, dst, ctx, 0);
      length -= 8;
      dst += 8;
      src += 8;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 9
20 10
21 7
22 5
23 5
24 12
25 12
26 12
27 12
28 12
29 12
30 4
31 4
32 4
33 4
34 4
35 4
<<<sep_out_sample>>>
jmpq   a0 <_gsasl_step64>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_step_base64 (Gsasl_session * sctx,
     const char *b64input,
     char *b64output, size_t b64output_len)
{
  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    0x0(%rax),%edx
add    $0x4,%rax
mov    %edx,0x0(%rax)
mov    0x0(%rax),%edx
mov    %edx,0x0(%rax)
cmp    $0x18,%rax
jne    58 <resetColors+0x8>
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
resetColors()
{
  int i;
  for(i = 0; i < 6; i++)
  {
    FG_COLOR[i] = oldFGColors[i];
    BG_COLOR[i] = oldBGColors[i];
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 6
6 7
7 7
8 4
9 4
10 9
11 9
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %r15
mov    %rcx,%r15
push   %r14
mov    %edx,%r14d
push   %r13
mov    %rsi,%r13
mov    $0x40800000,%esi
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d344 <_x87_blei_f+0x24>
mov    %eax,%ebp
mov    %r15,%rdx
mov    %rbx,%rdi
and    $0x7fff,%ebp
mov    %eax,%r12d
shl    $0x4,%rbp
mov    0x0(%rbp),%esi
and    $0x7fff,%esi
callq  ccd0 <_x87_movi_f>
mov    0x0(%rbp),%ecx
mov    %r14d,%r8d
mov    %r13,%rdx
mov    %rbx,%rdi
mov    $0x3,%esi
and    $0x7fff,%ecx
callq  0 <_x87jcc>
mov    %r12d,%esi
mov    %rbx,%rdi
mov    %rax,%rbp
callq  d397 <_x87_blei_f+0x77>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_x87_blei_f(jit_state_t *_jit, jit_word_t i0, jit_int32_t r0, jit_float32_t *i1) { jit_word_t word; jit_int32_t reg = _jit_get_reg(_jit,0x40000000| 0x00800000); ((void) (0)); _x87_movi_f(_jit,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),i1); word = _x87jcc(_jit, 0x3, i0, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), r0); _jit_unget_reg(_jit,reg); return (word); }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
push   %rbx
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    %ebx,%edi
callq  134f <init_btowc_cache+0xf>
mov    %eax,0x0(,%rbx,4)
add    $0x1,%rbx
cmp    $0xff,%rbx
jne    1348 <init_btowc_cache+0x8>
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_btowc_cache()
{
 int i;
 for (i = 0; i < 255; i++) {
  btowc_cache[i] = btowc(i);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 4
9 4
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
xor    %edi,%edi
sub    $0x10,%rsp
callq  17c <print_data_base+0xc>
mov    %rax,0x8(%rsp)
callq  90 <print_version>
lea    0x8(%rsp),%rdi
callq  190 <print_data_base+0x20>
mov    $0x0,%edi
mov    %rax,%rbx
callq  19d <print_data_base+0x2d>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  1aa <print_data_base+0x3a>
callq  1af <print_data_base+0x3f>
callq  1b4 <print_data_base+0x44>
callq  1b9 <print_data_base+0x49>
callq  1be <print_data_base+0x4e>
xchg   %ax,%ax
callq  1c5 <print_data_base+0x55>
mov    $0x0,%edi
callq  1cf <print_data_base+0x5f>
xor    %edi,%edi
callq  1d6 <print_data_base+0x66>
lea    0x8(%rsp),%rdi
mov    %rax,0x8(%rsp)
callq  1e5 <print_data_base+0x75>
mov    $0x0,%edi
mov    %rax,%rbx
callq  1f2 <print_data_base+0x82>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  1ff <print_data_base+0x8f>
add    $0x10,%rsp
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_data_base (void)
{
  time_t when = time ((time_t *) 0);
  print_version ();
  printf (gettext ("\n# Make data base, printed on %s"), ctime (&when));
  print_variable_data_base ();
  print_dir_data_base ();
  print_rule_data_base ();
  print_file_data_base ();
  print_vpath_data_base ();
  strcache_print_stats ("#");
  when = time ((time_t *) 0);
  printf (gettext ("\n# Finished Make data base on %s\n"), ctime (&when));
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 6
17 7
18 8
19 9
20 9
21 10
22 11
23 11
24 12
25 12
26 13
27 12
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 14
37 14
38 14
39 14
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x38,%rsp
callq  c68 <xformat_write_by_name+0x18>
xor    %r8d,%r8d
mov    %r12,%rcx
xor    %edx,%edx
mov    %r13,%rsi
mov    %rax,%rdi
mov    %rax,%rbp
callq  c7e <xformat_write_by_name+0x2e>
mov    0x68(%rbx),%rdi
mov    0x40(%rbx),%r9
xor    %edx,%edx
mov    0x38(%rbx),%r8
mov    %r12,%rsi
mov    %rbp,%rcx
mov    0x14(%rdi),%eax
mov    %eax,0x20(%rsp)
mov    0xc(%rbx),%eax
movl   $0xffffffff,0x10(%rsp)
mov    %eax,0x18(%rsp)
mov    0x4(%rbx),%eax
mov    %eax,0x8(%rsp)
mov    0x48(%rbx),%rax
mov    %rax,(%rsp)
callq  cbc <xformat_write_by_name+0x6c>
test   %rax,%rax
mov    %rax,%r12
jle    cc8 <xformat_write_by_name+0x78>
add    %rax,0x18(%rbx)
mov    %rbp,%rdi
callq  cd0 <xformat_write_by_name+0x80>
add    $0x38,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
xformat_write_by_name(XFORMAT * xux, char * name, struct stat *st)
{
 intmax_t ret;
        struct new_cpio_header * hdr0 = ahsStaticCreateFilehdr();
 ;
 taru_statbuf2filehdr(hdr0, st, (char*)((void *)0), name, (char*)((void *)0));
 ret = taru_write_archive_member(xux->taruM, name,
     (struct stat*)(((void *)0)) ,
     hdr0,
     xux->link_recordM,
     xux->deferM,
     xux->use_false_inodesM,
     xux->ofdM,
     -1,
     xux->output_format_codeM,
     xux->taruM->taru_tarheaderflagsM
     );
 if (ret > 0) xux->bytes_writtenM += ret;
 ;
 ahsStaticDeleteFilehdr(hdr0);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 6
11 6
12 6
13 6
14 6
15 4
16 6
17 16
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 18
34 7
35 18
36 18
37 20
38 20
39 22
40 22
41 22
42 22
43 22
44 22
45 22
46 22
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
and    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
signal_is_trapped (sig)
     int sig;
{
  return (sigmodes[sig] & 0x1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  1a0 <version_control_value+0x10>
mov    %rax,%rbp
mov    $0x3,%eax
test   %rbp,%rbp
je     1b3 <version_control_value+0x23>
cmpb   $0x0,0x0(%rbp)
jne    1c0 <version_control_value+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 1c7 <version_control_value+0x37>
test   %rsi,%rsi
je     200 <version_control_value+0x70>
mov    $0x0,%ebx
jmp    1e5 <version_control_value+0x55>
nopl   0x0(%rax,%rax,1)
add    $0x10,%rbx
mov    0x8(%rbx),%rsi
test   %rsi,%rsi
je     200 <version_control_value+0x70>
mov    %rbp,%rdi
callq  1ed <version_control_value+0x5d>
test   %eax,%eax
jne    1d8 <version_control_value+0x48>
mov    (%rbx),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
version_control_value(void)
{
    char * version = getenv("VERSION_CONTROL");
    version_control_values_ty * v;
    backup_mode_ty ret = unknown;
    if ((version == ((void *)0)) || (*version == 0))
    {
        ret = numbered_existing;
    }
    else
    {
        v = &values[0];
        while (v->name)
        {
            if (strcmp(version, v->name) == 0)
            {
                ret = v->value;
                break;
            }
            else
            {
                v++;
            }
        }
    }
    return ret;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 3
6 3
7 8
8 6
9 6
10 6
11 6
12 27
13 27
14 27
15 27
16 27
17 13
18 13
19 13
20 13
21 13
22 13
23 22
24 13
25 13
26 13
27 15
28 15
29 15
30 15
31 17
32 27
33 27
34 27
35 27
36 27
37 27
38 5
39 27
40 27
41 27
42 27
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdx
lea    -0x1(%rsi),%rax
cmp    %rdx,%rax
jae    2ab <gl_array_next_node+0x1b>
lea    0x1(%rsi),%rcx
xor    %eax,%eax
cmp    %rdx,%rsi
cmovb  %rcx,%rax
retq   
push   %rax
callq  2b1 <gl_array_next_node+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_next_node (gl_list_t list, gl_list_node_t node)
{
  unsigned long index = ((unsigned long)(node) - 1);
  if (!(index < list->count))
    abort ();
  index++;
  if (index < list->count)
    return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
  else
    return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 8
6 8
7 8
8 8
9 11
10 2
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%ebx        # 16f <imap_authenticate+0xf>
test   %ebx,%ebx
je     1b8 <imap_authenticate+0x58>
mov    0x0(%rip),%eax        # 179 <imap_authenticate+0x19>
test   %eax,%eax
je     198 <imap_authenticate+0x38>
mov    %rbp,%rdi
mov    $0x1,%ebx
callq  18a <imap_authenticate+0x2a>
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  1a2 <imap_authenticate+0x42>
mov    0x0(%rip),%rdi        # 1a9 <imap_authenticate+0x49>
mov    %rax,%rsi
xor    %eax,%eax
callq  1b3 <imap_authenticate+0x53>
jmp    17d <imap_authenticate+0x1d>
nopl   (%rax)
mov    %rdi,%rdx
lea    0x8(%rsp),%rdi
xor    %eax,%eax
mov    $0x0,%esi
callq  1cc <imap_authenticate+0x6c>
test   %eax,%eax
js     18a <imap_authenticate+0x2a>
mov    0x8(%rsp),%rdi
callq  1da <imap_authenticate+0x7a>
mov    0x8(%rsp),%rdi
mov    %eax,%ebx
callq  1e6 <imap_authenticate+0x86>
test   %ebx,%ebx
setne  %bl
add    $0x18,%rsp
movzbl %bl,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
imap_authenticate (const char *mech)
{
  if (args_info.server_flag)
    {
      if (!args_info.quiet_given)
 fprintf (stderr, gettext ("Using mechanism:\n"));
      puts (mech);
    }
  else
    {
      char *buf;
      int rc;
      int len;
      len = asprintf (&buf, ". AUTHENTICATE %s", mech);
      if (len < 0)
 return 0;
      rc = writeln (buf);
      free (buf);
      if (!rc)
 return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 7
12 22
13 7
14 23
15 23
16 23
17 23
18 23
19 23
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 14
29 14
30 14
31 14
32 14
33 15
34 15
35 17
36 17
37 18
38 17
39 18
40 22
41 22
42 23
43 22
44 23
45 23
46 23
47 23
48 23
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
mov    (%rcx),%eax
je     1163 <gsl_vector_int_max+0x33>
lea    0x0(,%rdx,4),%rdi
xor    %edx,%edx
nopl   0x0(%rax)
mov    (%rcx),%esi
cmp    %esi,%eax
cmovl  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    1150 <gsl_vector_int_max+0x20>
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_max (const gsl_vector_int * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  int max = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      int x = v->data[i*stride];
      if (x > max)
        max = x;
    }
  return max;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  2e <outline_init+0xe>
mov    $0x0,%edi
callq  38 <outline_init+0x18>
mov    $0x0,%edi
callq  42 <outline_init+0x22>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
outline_init(int argc, char **argv)
{
    int i;
    for (i = 0; i < (sizeof(strat_tab)/sizeof((strat_tab)[0])); i++)
 dico_strategy_add(&strat_tab[i].strat);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
test   %rdx,%rdx
je     2e4 <hash_load+0x34>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rsi
mov    %r13,%rdi
add    %r12,%rbp
callq  2de <hash_load+0x2e>
sub    $0x1,%rbx
jne    2d0 <hash_load+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
<<<sep_in_sample>>>
hash_load (struct hash_table_s* ht, void *item_table, unsigned long cardinality, unsigned long size)
{
  char *items = (char *) item_table;
  while (cardinality--)
    {
      hash_insert (ht, items);
      items += size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 2
10 4
11 4
12 4
13 6
14 6
15 7
16 6
17 4
18 4
19 9
20 9
21 9
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %rbx
mov    0x8(%rdi),%rdx
mov    %rsi,%rbx
mov    (%rdi),%rdi
mov    %rsi,%rcx
mov    $0x12,%esi
callq  18 <cdt2stream+0x18>
mov    %rbx,%rsi
xor    %edi,%edi
pop    %rbx
jmpq   23 <cdt2stream+0x23>
<<<sep_in_sample>>>
cdt2stream (const struct cdt *cdt, FILE *stream)
{
  ((cdt != ((void *)0)) ? (void) (0) : __assert_fail ("cdt != ((void *)0)", "cdt.c", 38, __PRETTY_FUNCTION__));
  ((stream != ((void *)0)) ? (void) (0) : __assert_fail ("stream != ((void *)0)", "cdt.c", 41, __PRETTY_FUNCTION__));
  xfwrite (cdt->entry, sizeof (*cdt->entry), cdt->entries, stream);
  xputc (0, stream);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 5
5 5
6 5
7 5
8 6
9 6
10 7
11 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
lea    0x8(%rdi),%rdi
xor    %esi,%esi
callq  4ff <close_space+0xf>
movq   $0x0,0x68(%rbx)
movq   $0x0,0x60(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   518 <close_space+0x28>
<<<sep_in_sample>>>
close_space (struct divvy *divvy)
{
  __extension__ ({ struct obstack *__o = (&divvy->space); void *__obj = (void *) (((void *)0)); if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit) __o->next_free = __o->object_base = (char *) __obj; else _obstack_free (__o, __obj); });
  divvy->count = 0;
  divvy->first = ((void *)0);
  free (divvy);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 6
9 7
10 6
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     31f6 <rpmExpandNumeric+0x46>
push   %rbp
xor    %esi,%esi
push   %rbx
sub    $0x18,%rsp
callq  31c4 <rpmExpandNumeric+0x14>
test   %rax,%rax
mov    %rax,%rbx
je     3228 <rpmExpandNumeric+0x78>
movzbl (%rax),%eax
xor    %ebp,%ebp
cmp    $0x25,%al
je     31e6 <rpmExpandNumeric+0x36>
and    $0xffffffdf,%eax
mov    $0x1,%bpl
cmp    $0x59,%al
je     31e6 <rpmExpandNumeric+0x36>
xor    %bpl,%bpl
cmp    $0x4e,%al
jne    3200 <rpmExpandNumeric+0x50>
mov    %rbx,%rdi
callq  31ee <rpmExpandNumeric+0x3e>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
repz retq 
nopl   0x0(%rax,%rax,1)
lea    0x8(%rsp),%rsi
xor    %edx,%edx
mov    %rbx,%rdi
callq  320f <rpmExpandNumeric+0x5f>
mov    0x8(%rsp),%rdx
test   %rdx,%rdx
je     31e6 <rpmExpandNumeric+0x36>
cmpb   $0x0,(%rdx)
cmove  %eax,%ebp
jmp    31e6 <rpmExpandNumeric+0x36>
nopl   0x0(%rax)
mov    %rbx,%rdi
xor    %ebp,%ebp
callq  3232 <rpmExpandNumeric+0x82>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
jmp    31f6 <rpmExpandNumeric+0x46>
nopl   0x0(%rax)
<<<sep_in_sample>>>
rpmExpandNumeric(const char *arg)
{
    const char *val;
    int rc;
    if (arg == ((void *)0))
 return 0;
    val = rpmExpand(arg, ((void *)0));
    if (!(val && *val != '%'))
 rc = 0;
    else if (*val == 'Y' || *val == 'y')
 rc = 1;
    else if (*val == 'N' || *val == 'n')
 rc = 0;
    else {
 char *end;
 rc = strtol(val, &end, 0);
 if (!(end && *end == '\0'))
     rc = 0;
    }
    free((void *)val);
    return rc;
}
<<<sep_in_sample>>>
1 6
2 5
3 5
4 2
5 7
6 2
7 2
8 7
9 8
10 7
11 8
12 8
13 9
14 8
15 8
16 10
17 11
18 10
19 10
20 9
21 12
22 12
23 20
24 20
25 22
26 21
27 22
28 22
29 22
30 22
31 16
32 16
33 16
34 16
35 17
36 17
37 17
38 16
39 16
40 16
41 16
42 20
43 9
44 20
45 22
46 21
47 22
48 22
49 22
50 22
<<<sep_out_sample>>>
mov    (%rdi),%rdx
test   %rdx,%rdx
je     410 <gsl_monte_plain_init+0x20>
mov    0x8(%rdi),%rax
lea    (%rax,%rdx,8),%rdx
movq   $0x0,(%rax)
add    $0x8,%rax
cmp    %rdx,%rax
jne    400 <gsl_monte_plain_init+0x10>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_monte_plain_init (gsl_monte_plain_state * s)
{
  size_t i;
  for (i = 0; i < s->dim; i++)
    {
      s->x[i] = 0.0;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 6
7 6
8 4
9 4
10 9
11 9
12 9
<<<sep_out_sample>>>
push   %r15
mov    %rdx,%r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
cmp    %r8,%rcx
mov    %rcx,0x28(%rsp)
mov    %r8,0x20(%rsp)
jge    f46 <DoVariance+0x106>
xorpd  %xmm4,%xmm4
lea    0x0(,%rcx,8),%rbx
mov    %rdi,%rbp
mov    %rsi,%r12
mov    %rcx,%r13
movsd  %xmm4,0x10(%rsp)
nop
test   %rbp,%rbp
jle    f07 <DoVariance+0xc7>
movq   $0x0,0x8(%rsp)
xor    %r14d,%r14d
nopl   (%rax)
mov    (%r15,%r14,8),%rcx
movsd  (%r12,%r14,8),%xmm2
add    $0x1,%r14
movsd  %xmm2,0x18(%rsp)
movsd  (%rcx,%rbx,1),%xmm0
callq  eb6 <DoVariance+0x76>
mulsd  0x18(%rsp),%xmm0
cmp    %rbp,%r14
addsd  0x8(%rsp),%xmm0
movsd  %xmm0,0x8(%rsp)
jne    e98 <DoVariance+0x58>
xor    %r14d,%r14d
mov    (%r15,%r14,8),%rcx
movsd  (%rcx,%rbx,1),%xmm0
callq  ede <DoVariance+0x9e>
subsd  0x8(%rsp),%xmm0
movsd  (%r12,%r14,8),%xmm1
add    $0x1,%r14
cmp    %rbp,%r14
mulsd  %xmm0,%xmm1
mulsd  %xmm0,%xmm1
addsd  0x10(%rsp),%xmm1
movsd  %xmm1,0x10(%rsp)
jne    ed0 <DoVariance+0x90>
add    $0x1,%r13
add    $0x8,%rbx
cmp    0x20(%rsp),%r13
jne    e80 <DoVariance+0x40>
mov    0x20(%rsp),%r14
sub    0x28(%rsp),%r14
movsd  0x10(%rsp),%xmm3
add    $0x38,%rsp
pop    %rbx
pop    %rbp
cvtsi2sd %r14,%xmm0
pop    %r12
pop    %r13
pop    %r14
pop    %r15
divsd  %xmm0,%xmm3
movapd %xmm3,%xmm0
retq   
xorpd  %xmm5,%xmm5
movsd  %xmm5,0x10(%rsp)
jmp    f1a <DoVariance+0xda>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
DoVariance (long nDim, double *pdIR, double **pdX,
                   long istart, long ifinish)
{
  long i, j;
  register double ave, ss, dTmp;
  ss = 0;
  for (i = istart; i < ifinish; i++) {
    ave = 0;
    for (j = 0; j < nDim; j++) {
      ave = ave + pdIR[j] * log(pdX[j][i]);
    }
    for (j = 0; j < nDim; j++) {
      dTmp = log(pdX[j][i]) - ave;
      ss = ss + pdIR[j] * dTmp * dTmp;
    }
  }
  return (ss / (double) (ifinish - istart));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 7
10 3
11 3
12 7
13 6
14 6
15 6
16 6
17 7
18 6
19 6
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 9
28 10
29 10
30 10
31 10
32 9
33 10
34 10
35 9
36 9
37 13
38 13
39 13
40 13
41 14
42 12
43 12
44 14
45 14
46 14
47 14
48 12
49 7
50 7
51 7
52 7
53 17
54 17
55 17
56 18
57 18
58 18
59 17
60 18
61 18
62 18
63 18
64 17
65 17
66 18
67 6
68 6
69 6
70 6
<<<sep_out_sample>>>
test   %rdx,%rdx
je     bf0 <csv_write+0xc0>
test   %rdi,%rdi
je     be0 <csv_write+0xb0>
test   %rsi,%rsi
je     b4e <csv_write+0x1e>
movb   $0x22,(%rdi)
add    $0x1,%rdi
test   %rcx,%rcx
je     bf3 <csv_write+0xc3>
add    %rdx,%rcx
mov    $0x1,%r8d
jmp    b8c <csv_write+0x5c>
nopw   0x0(%rax,%rax,1)
cmp    %rsi,%r8
jae    b77 <csv_write+0x47>
movzbl (%rdx),%eax
add    $0x1,%rdi
mov    %al,-0x1(%rdi)
xor    %eax,%eax
cmp    $0xffffffffffffffff,%r8
setne  %al
add    $0x1,%rdx
add    %rax,%r8
cmp    %rcx,%rdx
je     bc0 <csv_write+0x90>
cmpb   $0x22,(%rdx)
jne    b68 <csv_write+0x38>
cmp    %rsi,%r8
jae    ba8 <csv_write+0x78>
movb   $0x22,(%rdi)
add    $0x1,%rdi
add    $0x1,%r8
jmp    b68 <csv_write+0x38>
nopl   0x0(%rax,%rax,1)
cmp    $0xffffffffffffffff,%r8
jne    b9d <csv_write+0x6d>
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    b8c <csv_write+0x5c>
nopw   0x0(%rax,%rax,1)
cmp    %rsi,%r8
jae    bc8 <csv_write+0x98>
movb   $0x22,(%rdi)
mov    $0xffffffffffffffff,%rax
lea    0x1(%r8),%rdx
cmp    %rax,%r8
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
xor    %esi,%esi
jmpq   b4e <csv_write+0x1e>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
mov    $0x1,%r8d
jmp    bc0 <csv_write+0x90>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_write (void *dest, size_t dest_size, const void *src, size_t src_size)
{
  unsigned char *cdest = dest;
  const unsigned char *csrc = src;
  size_t chars = 0;
  if (src == ((void *)0))
    return 0;
  if (cdest == ((void *)0))
    dest_size = 0;
  if (dest_size > 0)
    *cdest++ = '"';
  chars++;
  while (src_size) {
    if (*csrc == '"') {
      if (dest_size > chars)
        *cdest++ = '"';
      if (chars < ((size_t)-1)) chars++;
    }
    if (dest_size > chars)
      *cdest++ = *csrc;
    if (chars < ((size_t)-1)) chars++;
    src_size--;
    csrc++;
  }
  if (dest_size > chars)
    *cdest = '"';
  if (chars < ((size_t)-1)) chars++;
  return chars;
}
<<<sep_in_sample>>>
1 6
2 6
3 8
4 8
5 10
6 10
7 11
8 11
9 13
10 13
11 13
12 13
13 13
14 13
15 19
16 19
17 20
18 20
19 20
20 21
21 21
22 21
23 23
24 21
25 13
26 13
27 14
28 14
29 15
30 15
31 16
32 16
33 17
34 17
35 17
36 17
37 17
38 23
39 13
40 13
41 13
42 25
43 25
44 26
45 26
46 27
47 27
48 27
49 27
50 27
51 9
52 9
53 9
54 7
55 29
56 13
57 13
58 13
<<<sep_out_sample>>>
mov    (%rdi),%eax
mov    0x10(%rdi),%rdi
lea    0x1(%rax),%esi
mov    0x0(%rip),%rax        # 10 <__gmpf_clear+0x10>
movslq %esi,%rsi
shl    $0x3,%rsi
jmpq   *%rax
<<<sep_in_sample>>>
__gmpf_clear (mpf_ptr x)
{
  (*__gmp_free_func) (((x)->_mp_d), (((x)->_mp_prec) + 1) * sizeof (mp_limb_t));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  13c9 <da_str_printnl+0x9>
mov    %rbx,%rsi
mov    $0xa,%edi
pop    %rbx
jmpq   13d7 <da_str_printnl+0x17>
<<<sep_in_sample>>>
da_str_printnl (const char * s1, FILE * stream)
{
  fputs ((const char *) s1, stream);
  _IO_putc ('\n', stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
lea    0x0(%rip),%rdi        # 591c <showconformabilityerr+0xc>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
callq  5930 <showconformabilityerr+0x20>
mov    0x0(%rip),%rbx        # 5937 <showconformabilityerr+0x27>
mov    0x1c(%rbx),%eax
cmp    $0x2,%eax
je     5990 <showconformabilityerr+0x80>
cmp    $0x1,%eax
je     59a8 <showconformabilityerr+0x98>
mov    %r12,%rdi
callq  594c <showconformabilityerr+0x3c>
mov    0x1c(%rbx),%eax
cmp    $0x2,%eax
je     59b8 <showconformabilityerr+0xa8>
cmp    $0x1,%eax
je     5980 <showconformabilityerr+0x70>
mov    $0xa,%edi
callq  5963 <showconformabilityerr+0x53>
mov    %rbp,%rdi
callq  596b <showconformabilityerr+0x5b>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
mov    $0xa,%edi
jmpq   597d <showconformabilityerr+0x6d>
nopl   (%rax)
lea    0x0(%rip),%rdi        # 5987 <showconformabilityerr+0x77>
callq  598c <showconformabilityerr+0x7c>
jmp    5963 <showconformabilityerr+0x53>
xchg   %ax,%ax
lea    0x0(%rip),%rdi        # 5997 <showconformabilityerr+0x87>
mov    %r14,%rsi
xor    %eax,%eax
callq  59a1 <showconformabilityerr+0x91>
jmp    5944 <showconformabilityerr+0x34>
nopl   0x0(%rax,%rax,1)
mov    $0x9,%edi
callq  59b2 <showconformabilityerr+0xa2>
jmp    5944 <showconformabilityerr+0x34>
nopl   0x0(%rax)
lea    0x0(%rip),%rdi        # 59bf <showconformabilityerr+0xaf>
mov    %r13,%rsi
xor    %eax,%eax
callq  59c9 <showconformabilityerr+0xb9>
jmp    5963 <showconformabilityerr+0x53>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
showconformabilityerr(char *havestr,struct unittype *have,
                      char *wantstr,struct unittype *want)
{
  logputs("conformability error\n");
  if (flags.verbose==2)
    logprintf("\t%s = ",havestr);
  else if (flags.verbose==1)
    logputchar('\t');
  showunit(have);
  if (flags.verbose==2)
    logprintf("\n\t%s = ",wantstr);
  else if (flags.verbose==1)
    logputs("\n\t");
  else
    logputchar('\n');
  showunit(want);
  logputchar('\n');
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 4
12 5
13 5
14 5
15 5
16 7
17 7
18 9
19 9
20 10
21 10
22 10
23 12
24 12
25 15
26 15
27 16
28 16
29 18
30 18
31 18
32 18
33 18
34 17
35 17
36 17
37 13
38 13
39 13
40 13
41 6
42 6
43 6
44 6
45 6
46 6
47 8
48 8
49 8
50 8
51 11
52 11
53 11
54 11
55 11
56 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
movzbl (%rdi),%edx
mov    %rdi,%rax
test   %dl,%dl
je     295 <nextelement+0x35>
cmp    $0x20,%dl
je     2c0 <nextelement+0x60>
cmp    $0x9,%dl
jne    28a <nextelement+0x2a>
jmp    2c0 <nextelement+0x60>
nopw   0x0(%rax,%rax,1)
cmp    $0x9,%dl
je     2c0 <nextelement+0x60>
cmp    $0x20,%dl
je     2c0 <nextelement+0x60>
add    $0x1,%rax
movzbl (%rax),%edx
test   %dl,%dl
jne    280 <nextelement+0x20>
mov    $0x0,%edi
xor    %eax,%eax
callq  2a1 <nextelement+0x41>
nopl   0x0(%rax)
cmp    $0x20,%dl
jne    2dc <nextelement+0x7c>
add    $0x1,%rax
movzbl (%rax),%edx
test   %dl,%dl
je     2d0 <nextelement+0x70>
nopl   0x0(%rax,%rax,1)
cmp    $0x9,%dl
jne    2a8 <nextelement+0x48>
add    $0x1,%rax
movzbl (%rax),%edx
test   %dl,%dl
jne    2c0 <nextelement+0x60>
mov    $0x0,%edi
xor    %eax,%eax
callq  2dc <nextelement+0x7c>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
nextelement(const char *s)
{
 while (*s && !((*s) == ' ' || (*s) == '\t'))
  s++;
 if (!*s)
  die("nextelement: unexpected end of string(1).");
 while (*s && ((*s) == ' ' || (*s) == '\t'))
  s++;
 if (!*s)
  die("nextelement: unexpected end of string(2).");
 return s;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 3
18 3
19 3
20 6
21 6
22 6
23 6
24 7
25 7
26 8
27 7
28 7
29 7
30 7
31 7
32 7
33 8
34 7
35 7
36 7
37 10
38 10
39 10
40 12
41 12
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 10b <_rl_vi_callback_set_mark+0xb>
movl   $0x1,0x0(%rip)        # 115 <_rl_vi_callback_set_mark+0x15>
jmp    b0 <_rl_vi_set_mark>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_callback_set_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  return (_rl_vi_set_mark ());
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
sub    $0x18,%rsp
movq   $0x0,(%rdx)
callq  e2 <CDB___os_strdup+0x22>
lea    0x1(%rax),%r12
lea    0x8(%rsp),%rcx
xor    %edx,%edx
mov    %rbx,%rdi
mov    %r12,%rsi
callq  f8 <CDB___os_strdup+0x38>
test   %eax,%eax
mov    %eax,%ebx
jne    117 <CDB___os_strdup+0x57>
mov    0x8(%rsp),%rdi
mov    %r12,%rdx
mov    %r13,%rsi
callq  10e <CDB___os_strdup+0x4e>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___os_strdup(dbenv, str, storep)
 DB_ENV *dbenv;
 const char *str;
 void *storep;
{
 size_t size;
 int ret;
 void *p;
 *(void **)storep = ((void *)0);
 size = strlen(str) + 1;
 if ((ret = CDB___os_malloc(dbenv, size, ((void *)0), &p)) != 0)
  return (ret);
 memcpy(p, str, size);
 *(void **)storep = p;
 return (0);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 10
9 5
10 9
11 10
12 10
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 13
22 13
23 13
24 13
25 14
26 14
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     948 <ds_strategy+0x18>
mov    0x8(%rsi),%rsi
mov    $0x0,%edi
jmpq   943 <ds_strategy+0x13>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 94f <ds_strategy+0x1f>
jmpq   954 <ds_strategy+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_strategy(int argc, char **argv)
{
    if (argc == 1) {
 printf("%s\n", dico_url.req.strategy);
    } else
 xdico_assign_string(&dico_url.req.strategy, argv[1]);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 4
8 4
9 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7b7 <remove_magicline+0x7>
mov    0x10(%rax),%rdx
mov    (%rdx),%rcx
cmpb   $0x0,(%rcx)
jne    7fa <remove_magicline+0x4a>
cmp    0x8(%rax),%rdx
je     7fa <remove_magicline+0x4a>
sub    $0x8,%rsp
mov    0x18(%rdx),%rdx
mov    0x10(%rdx),%rdi
mov    %rdx,0x10(%rax)
callq  7de <remove_magicline+0x2e>
mov    0x0(%rip),%rax        # 7e5 <remove_magicline+0x35>
mov    0x10(%rax),%rdx
movq   $0x0,0x10(%rdx)
subq   $0x1,0x28(%rax)
add    $0x8,%rsp
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
remove_magicline(void)
{
    if (openfile->filebot->data[0] == '\0' &&
  openfile->filebot != openfile->fileage) {
 ((void) (0))
                                         ;
 openfile->filebot = openfile->filebot->prev;
 free_filestruct(openfile->filebot->next);
 openfile->filebot->next = ((void *)0);
 openfile->totsize--;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 2
9 7
10 8
11 7
12 8
13 9
14 9
15 9
16 10
17 12
18 12
19 12
<<<sep_out_sample>>>
push   %r14
mov    %rcx,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
mov    $0x80,%esi
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
callq  b83 <mu_header_create+0x23>
mov    %rax,%rbx
mov    $0xc,%eax
test   %rbx,%rbx
je     ba5 <mu_header_create+0x45>
mov    %r13d,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
mov    %r14,(%rbx)
callq  1e0 <header_parse>
mov    %rbx,0x0(%rbp)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_header_create (mu_header_t *ph, const char *blurb, size_t len, void *owner)
{
  mu_header_t header;
  int status = 0;
  header = calloc (1, sizeof (*header));
  if (header == ((void *)0))
    return 12;
  header->owner = owner;
  status = header_parse (header, blurb, len);
  *ph = header;
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 2
9 2
10 5
11 2
12 5
13 5
14 7
15 6
16 6
17 9
18 9
19 9
20 8
21 9
22 10
23 12
24 12
25 12
26 12
27 12
28 12
29 12
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  160 <swi_com_fatal_error+0x10>
mov    0x0(%rip),%rdi        # 167 <swi_com_fatal_error+0x17>
mov    %rax,%rdx
mov    %ebp,%r8d
mov    %rbx,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  17c <swi_com_fatal_error+0x2c>
mov    $0x2,%edi
callq  186 <swi_com_fatal_error+0x36>
xor    %edi,%edi
callq  18d <swi_com_fatal_error+0x3d>
mov    $0x1,%edi
callq  197 <swi_com_fatal_error+0x47>
mov    $0xa,%edi
callq  1a1 <swi_com_fatal_error+0x51>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_com_fatal_error(char * msg, int msg2)
{
 fprintf(stderr, "%s: fatal error : %s [%d]\n", swlib_utilname_get(), msg, msg2);
 close(2);
 close(0);
 close(1);
 exit(10);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 4
15 4
16 5
17 5
18 6
19 6
20 7
21 7
22 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
movq   $0x0,(%rsi)
je     480 <osip_call_id_clone+0x80>
cmpq   $0x0,(%rdi)
je     480 <osip_call_id_clone+0x80>
lea    0x8(%rsp),%rdi
callq  42a <osip_call_id_clone+0x2a>
test   %eax,%eax
je     440 <osip_call_id_clone+0x40>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
mov    0x8(%rsp),%r12
callq  44d <osip_call_id_clone+0x4d>
mov    0x8(%rbx),%rdi
mov    %rax,(%r12)
test   %rdi,%rdi
je     468 <osip_call_id_clone+0x68>
mov    0x8(%rsp),%rbx
callq  464 <osip_call_id_clone+0x64>
mov    %rax,0x8(%rbx)
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    $0xfffffffe,%eax
jmp    42e <osip_call_id_clone+0x2e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_call_id_clone (const osip_call_id_t * callid, osip_call_id_t ** dest)
{
  int i;
  osip_call_id_t *ci;
  *dest = ((void *)0);
  if (callid == ((void *)0))
    return -2;
  if (callid->number == ((void *)0))
    return -2;
  i = osip_call_id_init (&ci);
  if (i != 0)
    return i;
  ci->number = osip_strdup (callid->number);
  if (callid->host != ((void *)0))
    ci->host = osip_strdup (callid->host);
  *dest = ci;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 5
9 6
10 8
11 8
12 10
13 10
14 11
15 11
16 18
17 18
18 18
19 18
20 18
21 18
22 13
23 13
24 13
25 14
26 13
27 14
28 14
29 15
30 15
31 15
32 16
33 16
34 18
35 17
36 18
37 18
38 18
39 18
40 18
41 7
42 7
43 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   1c49 <xformat_get_filesize+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_get_filesize (XFORMAT * xux)
{
 ;
 return ahs_get_filesize(xux->ahsM);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%edi
mov    %rsi,%rbx
callq  1de <libunistring_gl_locale_name_environ+0xe>
test   %rax,%rax
je     1e8 <libunistring_gl_locale_name_environ+0x18>
cmpb   $0x0,(%rax)
jne    215 <libunistring_gl_locale_name_environ+0x45>
mov    %rbx,%rdi
callq  1f0 <libunistring_gl_locale_name_environ+0x20>
test   %rax,%rax
je     1fa <libunistring_gl_locale_name_environ+0x2a>
cmpb   $0x0,(%rax)
jne    215 <libunistring_gl_locale_name_environ+0x45>
mov    $0x0,%edi
callq  204 <libunistring_gl_locale_name_environ+0x34>
mov    %rax,%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     215 <libunistring_gl_locale_name_environ+0x45>
cmpb   $0x0,(%rdx)
cmovne %rdx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
libunistring_gl_locale_name_environ (int category, const char *categoryname)
{
  const char *retval;
  retval = getenv ("LC_ALL");
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != ((void *)0) && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != ((void *)0) && retval[0] != '\0')
    {
        return retval;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 5
6 5
7 5
8 5
9 7
10 7
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 15
19 11
20 11
21 15
22 15
23 16
24 16
25 16
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
mov    $0x10,%edi
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
sub    $0x8,%rsp
callq  5ad <message_add_header+0x1d>
mov    %r12,%rdi
mov    %rax,%rbx
callq  5b8 <message_add_header+0x28>
mov    %rbp,%rdi
mov    %rax,(%rbx)
callq  5c3 <message_add_header+0x33>
mov    0x18(%r13),%rdi
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   5dd <message_add_header+0x4d>
nopl   (%rax)
<<<sep_in_sample>>>
message_add_header (MESSAGE msg, char *hdr, char *value)
{
  ASSOC *asc = xmalloc (sizeof (*asc));
  asc->key = strdup (hdr);
  asc->value = strdup (value);
  list_append (msg->header, asc);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 3
13 4
14 5
15 4
16 5
17 6
18 5
19 7
20 6
21 7
22 7
23 7
24 7
25 6
26 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  7b2 <gsl_stats_sd+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   7c4 <gsl_stats_sd+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_sd (const double data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_mean (data, stride, n);
  return gsl_stats_sd_m (data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  99c <gsl_sf_beta_inc+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    9b0 <gsl_sf_beta_inc+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xd1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  9c6 <gsl_sf_beta_inc+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_beta_inc(const double a, const double b, const double x)
{
  gsl_sf_result result; int status = gsl_sf_beta_inc_e(a, b, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_beta_inc_e(a, b, x, &result)", "beta_inc.c", 209, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    %rsi,%rdx
xor    %esi,%esi
jmpq   14ba <inputBox+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
inputBox(char *msg, char *title)
{
  return inputBoxI(msg, ((void *)0), title);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movzbl (%rdi),%eax
sub    $0x30,%eax
cmp    $0x9,%al
jbe    bc0 <valid_brace_expansion_word+0x50>
test   %esi,%esi
je     b98 <valid_brace_expansion_word+0x28>
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %esi,%esi
mov    %rbx,%rdi
callq  ba2 <valid_brace_expansion_word+0x32>
test   %eax,%eax
jne    b86 <valid_brace_expansion_word+0x16>
mov    %rbx,%rdi
callq  bae <valid_brace_expansion_word+0x3e>
test   %eax,%eax
setne  %al
add    $0x10,%rsp
movzbl %al,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %esi,0xc(%rsp)
callq  bc9 <valid_brace_expansion_word+0x59>
test   %eax,%eax
mov    0xc(%rsp),%esi
je     b82 <valid_brace_expansion_word+0x12>
jmp    b86 <valid_brace_expansion_word+0x16>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
valid_brace_expansion_word (name, var_is_special)
     char *name;
     int var_is_special;
{
  if (((*name) >= '0' && (*name) <= '9') && all_digits (name))
    return 1;
  else if (var_is_special)
    return 1;
  else if (valid_array_reference (name, 0))
    return 1;
  else if (legal_identifier (name))
    return 1;
  else
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 15
11 6
12 15
13 15
14 15
15 9
16 9
17 9
18 9
19 9
20 11
21 11
22 11
23 11
24 15
25 11
26 15
27 15
28 15
29 15
30 5
31 5
32 5
33 5
34 5
35 5
<<<sep_out_sample>>>
mov    0x240(%rdi),%rax
movq   $0x0,(%rax)
retq   
nop
<<<sep_in_sample>>>
finish_input_pass (j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
je     8a0 <debug_set_output+0x80>
cmpb   $0x0,(%rdi)
je     870 <debug_set_output+0x50>
mov    $0x0,%esi
callq  835 <debug_set_output+0x15>
mov    %rax,%rbx
xor    %eax,%eax
test   %rbx,%rbx
je     864 <debug_set_output+0x44>
mov    %rbx,%rdi
callq  847 <debug_set_output+0x27>
mov    $0x1,%esi
mov    %eax,%edi
callq  853 <debug_set_output+0x33>
test   %eax,%eax
jne    880 <debug_set_output+0x60>
mov    %rbx,%rdi
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %edi,%edi
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
xchg   %ax,%ax
callq  885 <debug_set_output+0x65>
mov    0x0(%rip),%edi        # 88b <debug_set_output+0x6b>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %eax,%eax
callq  899 <debug_set_output+0x79>
jmp    857 <debug_set_output+0x37>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 8a7 <debug_set_output+0x87>
callq  0 <debug_set_file>
mov    $0x1,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
debug_set_output (const char *name)
{
  FILE *fp;
  if (name == ((void *)0))
    debug_set_file (stderr);
  else if (*name == '\0')
    debug_set_file (((void *)0));
  else
    {
      fp = fopen_safer (name, "a");
      if (fp == ((void *)0))
        return 0;
      if (set_cloexec_flag (fileno (fp), 1) != 0)
        (m4_error (warning_status, (*__errno_location ()), "Warning: cannot protect debug file across forks"))
                                                                     ;
      debug_set_file (fp);
    }
  return 1;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 6
5 6
6 10
7 10
8 10
9 12
10 11
11 11
12 13
13 13
14 13
15 13
16 13
17 13
18 13
19 16
20 16
21 18
22 19
23 19
24 19
25 7
26 7
27 18
28 19
29 19
30 19
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 5
40 5
41 18
42 19
43 19
44 19
<<<sep_out_sample>>>
movq   $0x1,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbx_first (void *owner)
{
  struct mailbox_iterator *itr = owner;
  itr->idx = 1;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
deleteThisFile(char *fileName)
{
  if(strcmp(fileName, "(Empty folder)") == 0)
    return;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    $0x1105,%eax
cmove  %rax,%rsi
xor    %r10d,%r10d
nop
mov    $0x20,%ecx
mov    $0x80000000,%edx
xor    %eax,%eax
nopl   0x0(%rax)
imul   $0x10dcd,%rsi,%r8
mov    %rax,%r9
or     %rdx,%r9
test   $0x80000000,%r8d
mov    %r8d,%esi
cmovne %r9,%rax
shr    %rdx
sub    $0x1,%ecx
jne    80 <gfsr4_set+0x20>
mov    %rax,0x8(%rdi,%r10,1)
add    $0x8,%r10
cmp    $0x20000,%r10
jne    70 <gfsr4_set+0x10>
xor    %eax,%eax
mov    $0xffffffff,%esi
mov    $0x80000000,%ecx
nopl   0x0(%rax)
mov    %rsi,%rdx
and    0x40(%rdi,%rax,1),%rdx
shr    %rsi
or     %rcx,%rdx
shr    %rcx
mov    %rdx,0x40(%rdi,%rax,1)
add    $0x18,%rax
cmp    $0x300,%rax
jne    c8 <gfsr4_set+0x68>
movl   $0x20,(%rdi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gfsr4_set (void *vstate, unsigned long int s)
{
  gfsr4_state_t *state = (gfsr4_state_t *) vstate;
  int i, j;
  unsigned long int msb = 0x80000000UL;
  unsigned long int mask = 0xffffffffUL;
  if (s == 0)
    s = 4357;
  for (i = 0; i <= 16383; i++)
    {
      unsigned long t = 0 ;
      unsigned long bit = msb ;
      for (j = 0; j < 32; j++)
        {
          s = ((69069 * s) & 0xffffffffUL) ;
          if (s & msb)
            t |= bit ;
          bit >>= 1 ;
        }
      state->ra[i] = t ;
    }
  for (i=0; i<32; ++i) {
      int k=7+i*3;
      state->ra[k] &= mask;
      state->ra[k] |= msb;
      mask >>= 1;
      msb >>= 1;
  }
  state->nd = i;
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 8
6 8
7 8
8 8
9 8
10 15
11 17
12 17
13 17
14 15
15 17
16 18
17 13
18 13
19 20
20 20
21 9
22 9
23 9
24 9
25 9
26 9
27 24
28 24
29 26
30 25
31 27
32 25
33 25
34 22
35 22
36 29
37 29
38 29
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv_step_name(const gsl_odeiv_step * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    $0x5,%esi
push   %rbx
mov    %rdx,%rbx
je     438 <filter_ioctl+0x38>
cmp    $0x6,%esi
jne    420 <filter_ioctl+0x20>
mov    (%rdi),%rdi
callq  416 <filter_ioctl+0x16>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
callq  425 <filter_ioctl+0x25>
movl   $0x16,(%rax)
mov    $0xffffffff,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rdi),%rdi
callq  440 <filter_ioctl+0x40>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filter_ioctl(void *data, int code, void *call_data)
{
    struct filter_stream *fs = data;
    switch (code) {
    case 5:
 *(off_t*)call_data = dico_stream_bytes_in(fs->transport);
 break;
    case 6:
 *(off_t*)call_data = dico_stream_bytes_out(fs->transport);
 break;
    default:
 (*__errno_location ()) = 22;
 return -1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 4
6 4
7 9
8 9
9 9
10 15
11 16
12 16
13 16
14 12
15 12
16 13
17 16
18 16
19 16
20 6
21 6
22 6
23 6
24 16
25 16
26 16
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x428,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x418(%rsp)
xor    %eax,%eax
cmpl   $0xfffffffd,0x8(%rsi)
je     2d0 <_fprintPwd+0x110>
mov    (%rsi),%rdi
mov    %ecx,%ebx
lea    0x2c(%r12),%r13
callq  1ff <_fprintPwd+0x3f>
mov    %ebx,%ecx
mov    $0x1,%edx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  1c0 <_fprintPwd>
test   %ebx,%ebx
je     2a0 <_fprintPwd+0xe0>
mov    $0x0,%esi
mov    %r13,%rdi
mov    %r13,%rbx
callq  229 <_fprintPwd+0x69>
test   %rax,%rax
je     2a0 <_fprintPwd+0xe0>
mov    %rbp,%rsi
mov    $0x2f,%edi
callq  23b <_fprintPwd+0x7b>
mov    0x2c(%r12),%esi
test   %esi,%esi
je     278 <_fprintPwd+0xb8>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  252 <_fprintPwd+0x92>
test   %rax,%rax
je     264 <_fprintPwd+0xa4>
mov    %rbp,%rsi
mov    $0x5c,%edi
callq  264 <_fprintPwd+0xa4>
mov    (%rbx),%edi
mov    %rbp,%rsi
add    $0x4,%rbx
callq  272 <_fprintPwd+0xb2>
mov    (%rbx),%esi
test   %esi,%esi
jne    248 <_fprintPwd+0x88>
mov    0x418(%rsp),%rax
xor    %fs:0x28,%rax
jne    312 <_fprintPwd+0x152>
add    $0x428,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
lea    0x10(%rsp),%rsi
mov    %r13,%rdi
mov    $0xff,%edx
callq  2b2 <_fprintPwd+0xf2>
lea    0x10(%rsp),%rdx
mov    $0x0,%esi
mov    %rbp,%rdi
xor    %eax,%eax
callq  2c6 <_fprintPwd+0x106>
jmp    278 <_fprintPwd+0xb8>
nopl   0x0(%rax,%rax,1)
mov    (%rsi),%rdi
mov    %edx,0xc(%rsp)
callq  2dc <_fprintPwd+0x11c>
mov    %rbp,%rsi
movsbl %al,%edi
callq  2e7 <_fprintPwd+0x127>
mov    %rbp,%rsi
mov    $0x3a,%edi
callq  2f4 <_fprintPwd+0x134>
mov    0xc(%rsp),%edx
test   %edx,%edx
jne    278 <_fprintPwd+0xb8>
mov    %rbp,%rsi
mov    $0x2f,%edi
callq  30d <_fprintPwd+0x14d>
jmpq   278 <_fprintPwd+0xb8>
callq  317 <_fprintPwd+0x157>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_fprintPwd(FILE *f, direntry_t *entry, int recurs, int escape)
{
 if(entry->entry == -3) {
  _IO_putc (getDrive(entry->Dir), f);
  _IO_putc (':', f);
  if(!recurs)
   _IO_putc ('/', f);
 } else {
  _fprintPwd(f, getDirentry(entry->Dir), 1, escape);
  if (escape && wcspbrk(entry->name, L"\"$\\")) {
   wchar_t *ptr;
   _IO_putc ('/', f);
   for(ptr = entry->name; *ptr; ptr++) {
    if (wcschr(L"\"$\\", *ptr))
     _IO_putc ('\\', f);
    putwc(*ptr, f);
   }
  } else {
   char tmp[4*(255)+1];
   wchar_to_native(entry->name,tmp,(255));
   fprintf(f, "/%s", tmp);
  }
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 3
13 9
14 9
15 10
16 9
17 9
18 9
19 9
20 9
21 9
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 12
31 12
32 12
33 13
34 13
35 13
36 13
37 14
38 14
39 14
40 14
41 15
42 15
43 15
44 16
45 16
46 13
47 16
48 13
49 13
50 13
51 24
52 24
53 24
54 24
55 24
56 24
57 24
58 24
59 24
60 24
61 20
62 20
63 20
64 20
65 21
66 21
67 21
68 21
69 21
70 21
71 21
72 4
73 4
74 4
75 4
76 4
77 4
78 5
79 5
80 5
81 6
82 6
83 6
84 7
85 7
86 7
87 7
88 24
89 24
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
cmp    $0xffffffff,%edi
je     ec <rec_buf_putc+0x2c>
mov    0x10(%rsi),%rcx
mov    %rsi,%rbx
mov    0x8(%rsi),%rsi
lea    0x1(%rcx),%rdx
cmp    %rsi,%rdx
ja     f8 <rec_buf_putc+0x38>
mov    (%rbx),%rax
mov    %rdx,0x10(%rbx)
mov    %bpl,(%rax,%rcx,1)
mov    %ebp,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    (%rbx),%rdi
add    $0x200,%rsi
mov    %rsi,0x8(%rbx)
callq  10b <rec_buf_putc+0x4b>
mov    %rax,%rsi
mov    %rax,(%rbx)
mov    $0xffffffff,%eax
test   %rsi,%rsi
je     ee <rec_buf_putc+0x2e>
mov    0x10(%rbx),%rcx
mov    %rsi,%rax
lea    0x1(%rcx),%rdx
jmp    e4 <rec_buf_putc+0x24>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_putc (int c, rec_buf_t buf)
{
  unsigned int ret;
  if (c == (-1))
    {
      return (-1);
    }
  ret = (unsigned int) c;
  if ((buf->used + 1) > buf->size)
    {
      buf->size = buf->size + 512;
      buf->data = realloc (buf->data, buf->size);
      if (!buf->data)
        {
          ret = (-1);
        }
    }
  if (ret != (-1))
    {
      buf->data[buf->used++] = (char) c;
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 20
15 20
16 20
17 23
18 23
19 23
20 23
21 23
22 12
23 11
24 11
25 12
26 12
27 12
28 12
29 13
30 13
31 13
32 13
33 13
34 13
35 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 7 <my_bug_report_address+0x7>
push   %rbx
mov    %rdi,%rbx
callq  10 <my_bug_report_address+0x10>
mov    $0x0,%edi
callq  1a <my_bug_report_address+0x1a>
mov    0x0(%rip),%rdi        # 21 <my_bug_report_address+0x21>
mov    $0x0,%edx
mov    %rax,%rsi
xor    %eax,%eax
callq  30 <my_bug_report_address+0x30>
mov    0x0(%rip),%rsi        # 37 <my_bug_report_address+0x37>
mov    %rbx,%rdi
callq  3f <my_bug_report_address+0x3f>
mov    $0x0,%edi
callq  49 <my_bug_report_address+0x49>
mov    0x0(%rip),%rdi        # 50 <my_bug_report_address+0x50>
mov    $0x0,%edx
mov    %rax,%rsi
xor    %eax,%eax
callq  5f <my_bug_report_address+0x5f>
mov    0x0(%rip),%rsi        # 66 <my_bug_report_address+0x66>
mov    %rbx,%rdi
callq  6e <my_bug_report_address+0x6e>
mov    $0x0,%edi
callq  78 <my_bug_report_address+0x78>
mov    0x0(%rip),%rdi        # 7f <my_bug_report_address+0x7f>
mov    %rax,%rsi
mov    $0x0,%edx
xor    %eax,%eax
callq  8e <my_bug_report_address+0x8e>
mov    %rbx,%rdi
mov    0x0(%rip),%rsi        # 98 <my_bug_report_address+0x98>
pop    %rbx
jmpq   9e <my_bug_report_address+0x9e>
xchg   %ax,%ax
<<<sep_in_sample>>>
my_bug_report_address (fp)
     FILE *fp;
{
  print_text (fp, s1);
  sprintf (s1, gettext("Email bug reports to <%s>"), "bug-gcal@gnu.org");
  print_text (fp, s1);
  sprintf (s1, gettext("GNU gcal home page: <%s>"), "http://www.gnu.org/software/gcal");
  print_text (fp, s1);
  sprintf (s1, gettext("General help using GNU software: <%s>"), "http://www.gnu.org/gethelp/");
  print_text (fp, s1);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 10
33 10
34 11
35 10
36 10
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1199 <xpipe+0x9>
test   %eax,%eax
js     11a2 <xpipe+0x12>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  11ac <xpipe+0x1c>
mov    $0x0,%edi
mov    %rax,%rsi
callq  11b9 <xpipe+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xpipe (int fd[2])
{
  if (pipe (fd) < 0)
    call_arg_fatal ("pipe", gettext ("interprocess channel"));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 4
8 4
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
cmp    $0x56,%edi
je     360 <argp_version_parser+0x10>
mov    $0x7,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 367 <argp_version_parser+0x17>
push   %rbx
mov    %rdx,%rbx
test   %rax,%rax
je     388 <argp_version_parser+0x38>
mov    0x50(%rdx),%rdi
mov    %rdx,%rsi
callq  *%rax
testb  $0x20,0x1c(%rbx)
je     3d0 <argp_version_parser+0x80>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdx        # 38f <argp_version_parser+0x3f>
test   %rdx,%rdx
je     3b0 <argp_version_parser+0x60>
mov    0x50(%rbx),%rdi
mov    $0x0,%esi
xor    %eax,%eax
callq  3a4 <argp_version_parser+0x54>
jmp    379 <argp_version_parser+0x29>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rax
mov    $0x0,%esi
mov    0x30(%rax),%rdi
callq  3c1 <argp_version_parser+0x71>
mov    %rbx,%rdi
mov    %rax,%rsi
xor    %eax,%eax
callq  3ce <argp_version_parser+0x7e>
jmp    379 <argp_version_parser+0x29>
xor    %edi,%edi
callq  3d7 <argp_version_parser+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_version_parser (int key, char *arg, struct argp_state *state)
{
  switch (key)
    {
    case 'V':
      if (argp_program_version_hook)
 (*argp_program_version_hook) (state->out_stream, state);
      else if (argp_program_version)
 fprintf (state->out_stream, "%s\n", argp_program_version);
      else
 argp_error (state, dgettext (state->root_argp->argp_domain,
           "(PROGRAM ERROR) No version known!?"));
      if (! (state->flags & 0x20))
 exit (0);
      break;
    default:
      return 7;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 17
4 20
5 20
6 6
7 2
8 2
9 6
10 6
11 7
12 7
13 7
14 13
15 13
16 13
17 20
18 20
19 20
20 8
21 8
22 8
23 9
24 9
25 9
26 9
27 9
28 9
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 11
38 14
39 14
40 14
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_residual (const gsl_multifit_nlinear_workspace * w)
{
  return w->f;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     3b0 <tld_check_4tz+0x30>
mov    (%rdi),%r8d
test   %r8d,%r8d
je     3b6 <tld_check_4tz+0x36>
mov    %rdi,%rax
add    $0x4,%rax
mov    (%rax),%ecx
test   %ecx,%ecx
jne    390 <tld_check_4tz+0x10>
sub    %rdi,%rax
sar    $0x2,%rax
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   3af <tld_check_4tz+0x2f>
nop
mov    $0x2,%eax
retq   
xor    %eax,%eax
jmp    3a1 <tld_check_4tz+0x21>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tld_check_4tz (const uint32_t * in, size_t * errpos, const Tld_table * tld)
{
  const uint32_t *ipos = in;
  if (!ipos)
    return TLD_NODATA;
  while (*ipos)
    ipos++;
  return tld_check_4t (in, ipos - in, errpos, tld);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
7 7
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 6
21 6
22 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmmalloca+0x9>
test   %rax,%rax
je     13 <xmmalloca+0x13>
add    $0x8,%rsp
retq   
callq  18 <xmmalloca+0x18>
<<<sep_in_sample>>>
xmmalloca (size_t n)
{
  void *p;
  p = mmalloca (n);
  if (p == ((void *)0))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 8
6 8
7 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 707 <terminal_ring_bell+0x7>
test   %rdx,%rdx
je     710 <terminal_ring_bell+0x10>
xor    %eax,%eax
jmpq   *%rdx
mov    0x0(%rip),%edx        # 716 <terminal_ring_bell+0x16>
test   %edx,%edx
je     724 <terminal_ring_bell+0x24>
mov    0x0(%rip),%eax        # 720 <terminal_ring_bell+0x20>
test   %eax,%eax
jne    740 <terminal_ring_bell+0x40>
mov    0x0(%rip),%rdi        # 72b <terminal_ring_bell+0x2b>
test   %rdi,%rdi
je     74c <terminal_ring_bell+0x4c>
mov    $0x0,%edx
mov    $0x1,%esi
jmpq   73f <terminal_ring_bell+0x3f>
nop
mov    0x0(%rip),%rdi        # 747 <terminal_ring_bell+0x47>
test   %rdi,%rdi
jne    730 <terminal_ring_bell+0x30>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
terminal_ring_bell (void)
{
  if (terminal_ring_bell_hook)
    (*terminal_ring_bell_hook) ();
  else
    {
      if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)
        do { if (visible_bell) tputs (visible_bell, 1, output_character_function); } while (0);
      else
        do { if (audible_bell) tputs (audible_bell, 1, output_character_function); } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 7
7 7
8 7
9 7
10 7
11 7
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 8
20 8
21 8
22 8
23 8
<<<sep_out_sample>>>
push   %r13
push   %r12
xor    %r12d,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmp    %esi,(%rdi)
jle    ad <rec_mset_elem_new+0x3d>
mov    $0x20,%edi
mov    %rdx,%r13
callq  93 <rec_mset_elem_new+0x23>
test   %rax,%rax
je     ad <rec_mset_elem_new+0x3d>
mov    %ebp,(%rax)
mov    %r13,0x8(%rax)
mov    %rax,%r12
mov    %rbx,0x18(%rax)
movq   $0x0,0x10(%rax)
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_mset_elem_new (rec_mset_t mset,
                   rec_mset_type_t type,
                   void *data)
{
  rec_mset_elem_t new;
  if (type >= mset->ntypes)
    {
      return ((void *)0);
    }
  new = malloc (sizeof (struct rec_mset_elem_s));
  if (new)
    {
      new->type = type;
      new->data = data;
      new->mset = mset;
      new->list_node = ((void *)0);
    }
  return new;
}
<<<sep_in_sample>>>
1 4
2 4
3 8
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 10
12 10
13 10
14 11
15 11
16 13
17 14
18 16
19 15
20 16
21 19
22 19
23 19
24 19
25 19
26 19
27 19
28 19
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  4bc <gsl_sf_hydrogenicR_1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    4d0 <gsl_sf_hydrogenicR_1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x71,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4e6 <gsl_sf_hydrogenicR_1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hydrogenicR_1(const double Z, const double r)
{
  gsl_sf_result result; int status = gsl_sf_hydrogenicR_1_e(Z, r, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hydrogenicR_1_e(Z, r, &result)", "coulomb_bound.c", 113, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %r8d,%r8d
xor    %edx,%edx
mov    $0x0,%ecx
mov    $0x800,%esi
mov    $0x0,%edi
callq  bd <_tmpfn+0x1d>
test   %eax,%eax
js     e2 <_tmpfn+0x42>
xor    %esi,%esi
mov    $0x0,%edi
callq  cd <_tmpfn+0x2d>
test   %eax,%eax
js     e2 <_tmpfn+0x42>
mov    %eax,%edi
callq  d8 <_tmpfn+0x38>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
xor    %eax,%eax
jmp    dd <_tmpfn+0x3d>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_tmpfn ()
{
  int fd;
  if (path_search (__buftmpfn, sizeof (__buftmpfn), ((void *)0), "gcal", 0) < 0)
    return ((void *)0);
  fd = mkostemp (__buftmpfn, 0);
  if (fd < 0)
    return ((void *)0);
  close (fd);
  return __buftmpfn;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 7
14 7
15 9
16 9
17 10
18 11
19 11
20 5
21 5
22 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 40 <shell_quote_length+0x10>
test   %rbx,%rbx
je     68 <shell_quote_length+0x38>
mov    %rbp,%rdi
callq  4d <shell_quote_length+0x1d>
add    $0x8,%rsp
mov    %rbx,%r8
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %rax,%rcx
xor    %esi,%esi
xor    %edi,%edi
jmpq   65 <shell_quote_length+0x35>
nopl   (%rax)
callq  0 <init_sh_quoting_options>
mov    0x0(%rip),%rbx        # 74 <shell_quote_length+0x44>
jmp    45 <shell_quote_length+0x15>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
shell_quote_length (const char *string)
{
  if (sh_quoting_options == ((void *)0))
    init_sh_quoting_options ();
  return quotearg_buffer (((void *)0), 0, string, strlen (string),
                           sh_quoting_options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 7
11 5
12 5
13 7
14 7
15 5
16 5
17 5
18 5
19 5
20 4
21 4
22 4
23 4
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 1e <__gmpz_init_set_str+0x1e>
movl   $0x0,0x4(%rbx)
mov    %rax,0x8(%rbx)
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rsi
mov    %r12d,%edx
pop    %rbp
pop    %r12
jmpq   3b <__gmpz_init_set_str+0x3b>
<<<sep_in_sample>>>
__gmpz_init_set_str (mpz_ptr x, const char *str, int base)
{
  ((x)->_mp_alloc) = 1;
  ((x)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  ((x)->_mp_size) = 0;
  return __gmpz_set_str (x, str, base);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 5
11 4
12 6
13 7
14 6
15 6
16 7
17 7
18 6
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     d57 <gsl_vector_long_ispos+0x37>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x3,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdq (%rdx),%xmm0
ucomisd %xmm0,%xmm1
jae    d5d <gsl_vector_long_ispos+0x3d>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    d40 <gsl_vector_long_ispos+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_vector_long_ispos (const gsl_vector_long * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] <= 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
<<<sep_out_sample>>>
movslq 0x0(%rip),%rax        # 527 <tty_writes+0x7>
push   %r12
mov    %rdi,%r12
push   %rbp
lea    (%rax,%rsi,1),%ebp
push   %rbx
mov    %esi,%ebx
cmp    $0x3ff,%ebp
jle    54c <tty_writes+0x2c>
xor    %eax,%eax
callq  542 <tty_writes+0x22>
movslq 0x0(%rip),%rax        # 549 <tty_writes+0x29>
lea    (%rbx,%rax,1),%ebp
lea    0x0(%rax),%rdi
movslq %ebx,%rdx
mov    %r12,%rsi
callq  55e <tty_writes+0x3e>
mov    %ebx,%eax
mov    %ebp,0x0(%rip)        # 566 <tty_writes+0x46>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_writes(s, len)
    char *s;
    int len;
{
    if (tty_index + len >= 1024)
 tty_flush();
    memcpy(tty_cache + tty_index, s, len);
    tty_index += len;
    return len;
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 4
5 4
6 4
7 4
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 10
19 8
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
lea    0x100(%rdi),%rdi
push   %rbx
mov    %rdx,%rbx
callq  b9 <nettle_des3_decrypt+0x19>
lea    0x80(%rbp),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %r12,%rsi
callq  ce <nettle_des3_decrypt+0x2e>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
mov    %r12,%rsi
pop    %r12
jmpq   e3 <nettle_des3_decrypt+0x43>
<<<sep_in_sample>>>
nettle_des3_decrypt(const struct des3_ctx *ctx,
      size_t length, uint8_t *dst,
      const uint8_t *src)
{
  nettle_des_decrypt(&ctx->des[2],
       length, dst, src);
  nettle_des_encrypt(&ctx->des[1],
       length, dst, dst);
  nettle_des_decrypt(&ctx->des[0],
       length, dst, dst);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 4
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 11
18 11
19 9
20 11
21 9
<<<sep_out_sample>>>
movzbl (%rdi),%eax
mov    %al,0x0(%rip)        # c69 <tty_restore+0x9>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_restore(status)
    tty_status_t *status;
{
    tty_current_attribute = *status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     3f8 <localtime_rz+0x78>
callq  280 <set_tz>
test   %rax,%rax
mov    %rax,%r12
je     3d8 <localtime_rz+0x58>
mov    %rbp,%rsi
mov    %r13,%rdi
callq  3b0 <localtime_rz+0x30>
test   %rax,%rax
je     3e8 <localtime_rz+0x68>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  140 <save_abbr>
test   %al,%al
je     3e8 <localtime_rz+0x68>
mov    %r12,%rdi
callq  50 <revert_tz>
mov    %eax,%edx
mov    %rbp,%rax
test   %dl,%dl
jne    3da <localtime_rz+0x5a>
nopl   (%rax)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    %r12,%rdi
callq  50 <revert_tz>
jmp    3d8 <localtime_rz+0x58>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %r13,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   40d <localtime_rz+0x8d>
nopl   (%rax)
<<<sep_in_sample>>>
localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
{
  if (!tz)
    return gmtime_r (t, tm);
  else
    {
      timezone_t old_tz = set_tz (tz);
      if (old_tz)
        {
          _Bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);
          if (revert_tz (old_tz) && abbr_saved)
            return tm;
        }
      return ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 7
12 8
13 7
14 8
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 11
26 11
27 11
28 12
29 11
30 11
31 11
32 14
33 16
34 16
35 16
36 16
37 16
38 16
39 16
40 11
41 11
42 11
43 11
44 16
45 4
46 4
47 16
48 16
49 16
50 16
51 4
52 4
<<<sep_out_sample>>>
push   %rbx
mov    0x34(%rdi),%ecx
mov    %rsi,%rbx
mov    0x8(%rdi),%rax
xor    %r8d,%r8d
lea    -0x1(%rcx),%edx
sub    0x48(%rsi),%edx
mov    $0x1,%ecx
mov    0x40(%rsi),%rsi
callq  *0x38(%rax)
addl   $0x1,0x48(%rbx)
mov    %rax,0x20(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
get_memory_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  tga_source_ptr source = (tga_source_ptr) sinfo;
  JDIMENSION source_row;
  source_row = cinfo->image_height - source->current_row - 1;
  source->pub.buffer = (*cinfo->mem->access_virt_sarray)
    ((j_common_ptr) cinfo, source->whole_image,
     source_row, (JDIMENSION) 1, 0);
  source->current_row++;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 7
5 7
6 5
7 5
8 7
9 7
10 7
11 9
12 6
13 11
14 11
15 11
16 11
<<<sep_out_sample>>>
test   %edi,%edi
je     700 <code_ns_fraction+0xe0>
mov    %edi,%eax
mov    $0x66666667,%edx
movb   $0x2e,(%rsi)
imul   %edx
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
jne    706 <code_ns_fraction+0xe6>
mov    $0x9,%r8d
mov    $0x66666667,%ecx
jmp    663 <code_ns_fraction+0x43>
nopw   0x0(%rax,%rax,1)
mov    %r9d,%r8d
mov    %edi,%eax
sar    $0x1f,%edi
lea    -0x1(%r8),%r9d
imul   %ecx
sar    $0x2,%edx
sub    %edi,%edx
mov    %edx,%eax
mov    %edx,%edi
imul   %ecx
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
je     660 <code_ns_fraction+0x40>
sub    $0x2,%r8d
add    $0x30,%edx
movslq %r9d,%r9
movslq %r8d,%rax
test   %r8d,%r8d
movb   $0x0,0x1(%rsi,%r9,1)
mov    %dl,0x1(%rsi,%rax,1)
je     704 <code_ns_fraction+0xe4>
lea    -0x1(%rsi,%rax,1),%r9
lea    (%rsi,%rax,1),%rcx
lea    -0x1(%r8),%eax
mov    $0x66666667,%esi
sub    %rax,%r9
nop
mov    %edi,%eax
sar    $0x1f,%edi
sub    $0x1,%rcx
imul   %esi
sar    $0x2,%edx
sub    %edi,%edx
mov    %edx,%eax
mov    %edx,%edi
imul   %esi
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
mov    %edi,%edx
add    %eax,%eax
sub    %eax,%edx
mov    %edx,%eax
add    $0x30,%eax
mov    %al,0x1(%rcx)
cmp    %r9,%rcx
jne    6c0 <code_ns_fraction+0xa0>
repz retq 
nopl   0x0(%rax,%rax,1)
movb   $0x0,(%rsi)
retq   
repz retq 
add    $0x30,%edx
movb   $0x0,0xa(%rsi)
mov    $0x8,%r8d
mov    %dl,0x9(%rsi)
mov    $0x8,%eax
jmp    6aa <code_ns_fraction+0x8a>
nopl   (%rax)
<<<sep_in_sample>>>
code_ns_fraction (int ns, char *p)
{
  if (ns == 0)
    *p = '\0';
  else
    {
      int i = 9;
      *p++ = '.';
      while (ns % 10 == 0)
 {
   ns /= 10;
   i--;
 }
      p[i] = '\0';
      for (;;)
 {
   p[--i] = '0' + ns % 10;
   if (i == 0)
     break;
   ns /= 10;
 }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 9
4 9
5 8
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 7
17 11
18 11
19 11
20 12
21 11
22 11
23 12
24 11
25 11
26 11
27 9
28 11
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 17
40 17
41 14
42 17
43 18
44 14
45 17
46 18
47 18
48 18
49 18
50 20
51 20
52 20
53 20
54 20
55 20
56 20
57 20
58 20
59 17
60 20
61 17
62 17
63 17
64 17
65 17
66 17
67 17
68 17
69 17
70 17
71 17
72 17
73 18
74 18
75 18
76 18
77 4
78 4
79 4
80 17
81 14
82 17
83 17
84 17
85 17
86 17
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x20(%rsi),%rax
mov    (%rax),%rbx
mov    0x30(%rdi),%eax
test   %eax,%eax
je     12d <get_16bit_row+0x6d>
sub    $0x1,%eax
lea    0x3(%rax,%rax,2),%r12
add    %rbx,%r12
mov    %rbp,%rdi
add    $0x3,%rbx
callq  *0x50(%rbp)
movzbl 0x59(%rbp),%eax
movzbl 0x58(%rbp),%edx
shl    $0x8,%eax
add    %edx,%eax
mov    %eax,%edx
and    $0x1f,%edx
movzbl 0x0(%rdx),%edx
mov    %dl,-0x1(%rbx)
mov    %eax,%edx
sar    $0xa,%eax
sar    $0x5,%edx
and    $0x1f,%eax
and    $0x1f,%edx
movzbl 0x0(%rax),%eax
movzbl 0x0(%rdx),%edx
mov    %al,-0x3(%rbx)
mov    %dl,-0x2(%rbx)
cmp    %r12,%rbx
jne    e0 <get_16bit_row+0x20>
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_16bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
{
  tga_source_ptr source = (tga_source_ptr) sinfo;
  register int t;
  register JSAMPROW ptr;
  register JDIMENSION col;
  ptr = source->pub.buffer[0];
  for (col = cinfo->image_width; col > 0; col--) {
    (*source->read_pixel) (source);
    t = ((int) (source->tga_pixel[0]));
    t += ((int) (source->tga_pixel[1])) << 8;
    ptr[2] = (JSAMPLE) c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[1] = (JSAMPLE) c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[0] = (JSAMPLE) c5to8bits[t & 0x1F];
    ptr += 3;
  }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 9
14 17
15 9
16 11
17 10
18 11
19 11
20 12
21 12
22 12
23 12
24 13
25 15
26 13
27 16
28 14
29 16
30 14
31 16
32 14
33 8
34 8
35 20
36 20
37 20
38 20
39 20
40 20
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     710 <gsl_block_complex_raw_fread+0x90>
shl    $0x4,%rcx
xor    %ebp,%ebp
test   %rdx,%rdx
mov    %rcx,%r14
mov    %rsi,%rbx
jne    6bc <gsl_block_complex_raw_fread+0x3c>
jmp    700 <gsl_block_complex_raw_fread+0x80>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     700 <gsl_block_complex_raw_fread+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x10,%esi
mov    %rbx,%rdi
callq  6d1 <gsl_block_complex_raw_fread+0x51>
cmp    $0x1,%rax
je     6b0 <gsl_block_complex_raw_fread+0x30>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6f0 <gsl_block_complex_raw_fread+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x10,%esi
callq  71d <gsl_block_complex_raw_fread+0x9d>
cmp    %r12,%rax
je     700 <gsl_block_complex_raw_fread+0x80>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  73b <gsl_block_complex_raw_fread+0xbb>
mov    $0x5,%eax
jmp    6f5 <gsl_block_complex_raw_fread+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_raw_fread (FILE * stream, double * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 2 * sizeof (double), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 2 * i * stride,
                               2 * sizeof (double), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 4
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 15
23 17
24 17
25 17
26 17
27 17
28 19
29 19
30 21
31 21
32 21
33 21
34 21
35 21
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 26
47 25
48 26
49 26
50 26
51 6
52 6
53 6
54 7
55 7
56 9
57 9
58 9
59 9
60 9
61 9
62 9
63 9
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_get_mime_header (MESSAGE msg)
{
  return msg->mime_hdr;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x40(%rdi),%rsi
cmp    %rsi,0x58(%rdi)
cmovbe 0x58(%rdi),%rsi
mov    0x30(%rdi),%rax
cmp    %rax,%rsi
jbe    4e <re_string_translate_buffer+0x4e>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rax,%rdx
add    (%rdi),%rdx
mov    0x78(%rdi),%rcx
add    0x28(%rdi),%rdx
movzbl (%rdx),%edx
movzbl (%rcx,%rdx,1),%ecx
mov    0x8(%rdi),%rdx
mov    %cl,(%rdx,%rax,1)
add    $0x1,%rax
cmp    %rsi,%rax
jne    20 <re_string_translate_buffer+0x20>
mov    %rsi,0x30(%rdi)
mov    %rsi,0x38(%rdi)
retq   
mov    %rax,%rsi
jmp    45 <re_string_translate_buffer+0x45>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
re_string_translate_buffer (re_string_t *pstr)
{
  Idx buf_idx, end_idx;
  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)
    {
      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];
      pstr->mbs[buf_idx] = pstr->trans[ch];
    }
  pstr->valid_len = buf_idx;
  pstr->valid_raw_len = buf_idx;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 5
17 5
18 5
19 10
20 11
21 11
22 5
23 5
24 5
<<<sep_out_sample>>>
mov    %rsi,0x28(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_set_stale (osip_www_authenticate_t * www_authenticate, char *stale)
{
  www_authenticate->stale = (char *) stale;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigsegv_init (sigsegv_dispatcher *dispatcher)
{
  dispatcher->tree = ((node_t *) 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     320 <mu_vartab_count+0x10>
mov    (%rdi),%rdi
jmpq   31d <mu_vartab_count+0xd>
nopl   (%rax)
mov    $0x16,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_vartab_count (mu_vartab_t vt, size_t *pcount)
{
  if (!vt)
    return 22;
  return mu_assoc_count (vt->assoc, pcount);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
mov    0x0(%rip),%rax        # f <__gmpf_init_set_d+0xf>
movsd  %xmm0,0x8(%rsp)
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 25 <__gmpf_init_set_d+0x25>
movsd  0x8(%rsp),%xmm0
mov    %rax,0x10(%rbx)
add    $0x10,%rsp
mov    %rbx,%rdi
pop    %rbx
jmpq   3c <__gmpf_init_set_d+0x3c>
<<<sep_in_sample>>>
__gmpf_init_set_d (mpf_ptr r, double val)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
  __gmpf_set_d (r, val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 4
7 5
8 5
9 6
10 5
11 7
12 6
13 7
14 6
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   b47 <iso9660_name_translate+0x7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_name_translate(const char *psz_oldname, char *psz_newname)
{
  return iso9660_name_translate_ext(psz_oldname, psz_newname, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
jmp    cb7 <set_archive_format+0x27>
nopl   (%rax)
add    $0x10,%rbx
mov    (%rbx),%rax
test   %rax,%rax
je     cd3 <set_archive_format+0x43>
mov    %rax,%rdi
mov    %rbp,%rsi
callq  cbf <set_archive_format+0x2f>
test   %eax,%eax
jne    ca8 <set_archive_format+0x18>
mov    0x8(%rbx),%eax
mov    %eax,0x0(%rip)        # ccc <set_archive_format+0x3c>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%rax        # cda <set_archive_format+0x4a>
test   %rax,%rax
je     ce1 <set_archive_format+0x51>
callq  *%rax
mov    %rbp,%rdi
callq  ce9 <set_archive_format+0x59>
mov    $0x0,%edi
mov    %rax,%rbx
callq  cf6 <set_archive_format+0x66>
xor    %edi,%edi
mov    %rax,%rdx
mov    %rbx,%rcx
xor    %esi,%esi
xor    %eax,%eax
callq  d07 <set_archive_format+0x77>
mov    $0x2,%edi
callq  d11 <set_archive_format+0x81>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_archive_format (char const *name)
{
  struct fmttab const *p;
  for (p = fmttab; strcmp (p->name, name) != 0; )
    if (! (++p)->name)
      do { if (error_hook) error_hook (); error (0, 0, gettext ("%s: Invalid archive format"), quotearg_colon (name)); usage (2); } while (0)
                             ;
  archive_format = p->fmt;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 2
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 4
15 4
16 4
17 4
18 8
19 8
20 9
21 9
22 9
23 9
24 6
25 6
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 6
41 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%edi
callq  35c <anubis_regex_print+0xc>
mov    (%rbx),%rsi
mov    $0x0,%edi
xor    %eax,%eax
pop    %rbx
jmpq   36c <anubis_regex_print+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
anubis_regex_print (RC_REGEX *re)
{
  regex_print_flags (re->flags);
  printf (" [%s]", anubis_regex_source (re));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  2ff <gss_indicate_mechs+0xf>
test   $0xffff0000,%eax
je     310 <gss_indicate_mechs+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  31b <gss_indicate_mechs+0x2b>
mov    %eax,%r12d
and    $0xffff0000,%eax
jne    338 <gss_indicate_mechs+0x48>
test   %rbx,%rbx
je     306 <gss_indicate_mechs+0x16>
movl   $0x0,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
mov    %rbp,%rsi
xor    %edi,%edi
callq  342 <gss_indicate_mechs+0x52>
mov    %r12d,%eax
jmp    306 <gss_indicate_mechs+0x16>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_indicate_mechs (OM_uint32 * minor_status, gss_OID_set * mech_set)
{
  OM_uint32 maj_stat;
  maj_stat = gss_create_empty_oid_set (minor_status, mech_set);
  if ((maj_stat & ((0377ul << 24) | (0377ul << 16))))
    return maj_stat;
  maj_stat = _gss_indicate_mechs1 (minor_status, mech_set);
  if ((maj_stat & ((0377ul << 24) | (0377ul << 16))))
    {
      gss_release_oid_set (((void *)0), mech_set);
      return maj_stat;
    }
  if (minor_status)
    *minor_status = 0;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 16
10 16
11 16
12 16
13 16
14 7
15 7
16 7
17 7
18 8
19 8
20 13
21 13
22 14
23 16
24 16
25 16
26 16
27 16
28 10
29 10
30 10
31 11
32 11
33 11
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %edi,%r12d
mov    %rsi,%rdi
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  4018 <spotlight+0x18>
movslq 0x0(%rip),%rbx        # 401f <spotlight+0x1f>
mov    %rax,%rbp
callq  4027 <spotlight+0x27>
mov    %rax,%rdi
callq  402f <spotlight+0x2f>
add    %rax,%rbx
callq  4037 <spotlight+0x37>
sub    %rax,%rbx
cmp    %rbp,%rbx
sbb    $0x0,%rbx
callq  4046 <spotlight+0x46>
mov    0x0(%rip),%rdi        # 404d <spotlight+0x4d>
callq  4052 <spotlight+0x52>
test   %r12b,%r12b
jne    40e0 <spotlight+0xe0>
test   %rbp,%rbp
jne    4088 <spotlight+0x88>
mov    0x0(%rip),%rdi        # 4067 <spotlight+0x67>
mov    $0x20,%esi
callq  4071 <spotlight+0x71>
test   %r12b,%r12b
jne    40bf <spotlight+0xbf>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rsi
mov    %r13,%rdi
callq  4093 <spotlight+0x93>
mov    0x0(%rip),%rdi        # 409a <spotlight+0x9a>
mov    %eax,%edx
mov    %r13,%rsi
callq  40a4 <spotlight+0xa4>
cmp    %rbp,%rbx
jae    4071 <spotlight+0x71>
mov    0x0(%rip),%rdi        # 40b0 <spotlight+0xb0>
mov    $0x24,%esi
callq  40ba <spotlight+0xba>
test   %r12b,%r12b
je     4076 <spotlight+0x76>
movslq 0x0(%rip),%rsi        # 40c6 <spotlight+0xc6>
mov    0x0(%rip),%rdi        # 40cd <spotlight+0xcd>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   40de <spotlight+0xde>
xchg   %ax,%ax
movslq 0x0(%rip),%rsi        # 40e7 <spotlight+0xe7>
mov    0x0(%rip),%rdi        # 40ee <spotlight+0xee>
xor    %edx,%edx
callq  40f5 <spotlight+0xf5>
jmpq   405b <spotlight+0x5b>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
spotlight(_Bool active, const char *word)
{
    size_t word_len = strlenpt(word), room;
    room = COLS + get_page_start(xplustabs()) - xplustabs();
    ((void) (0));
    if (word_len > room)
 room--;
    reset_cursor();
    wnoutrefresh(edit);
    if (active)
 wattr_on(edit, (attr_t)(hilite_attribute), ((void *)0));
    if (word_len == 0)
 waddch(edit, ' ');
    else
 waddnstr(edit, word, actual_x(word, room));
    if (word_len > room)
 waddch(edit, '$');
    if (active)
 wattr_off(edit, (attr_t)(hilite_attribute), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 4
14 4
15 4
16 4
17 4
18 7
19 7
20 8
21 9
22 9
23 10
24 10
25 12
26 12
27 13
28 13
29 13
30 18
31 18
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 16
47 16
48 17
49 17
50 17
51 18
52 18
53 19
54 19
55 20
56 20
57 20
58 20
59 20
60 19
61 19
62 19
63 11
64 11
65 11
66 11
67 11
68 11
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  8a0 <gsasl_md5pwd_get_password+0x20>
mov    %rax,%rdi
mov    $0x5,%eax
test   %rdi,%rdi
je     8fe <gsasl_md5pwd_get_password+0x7e>
callq  8b2 <gsasl_md5pwd_get_password+0x32>
lea    0x8(%rsp),%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  8c2 <gsasl_md5pwd_get_password+0x42>
test   %eax,%eax
jne    8fe <gsasl_md5pwd_get_password+0x7e>
mov    0x8(%rsp),%rbx
mov    %rbx,%rdi
callq  8d3 <gsasl_md5pwd_get_password+0x53>
lea    0x1(%rax),%rdx
cmp    %rdx,(%r12)
jb     910 <gsasl_md5pwd_get_password+0x90>
test   %r13,%r13
mov    %rax,(%r12)
je     8f4 <gsasl_md5pwd_get_password+0x74>
mov    %rax,%rdx
mov    %rbx,%rsi
mov    %r13,%rdi
callq  8f4 <gsasl_md5pwd_get_password+0x74>
mov    %rbx,%rdi
callq  8fc <gsasl_md5pwd_get_password+0x7c>
xor    %eax,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  918 <gsasl_md5pwd_get_password+0x98>
add    $0x18,%rsp
mov    $0x4,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_md5pwd_get_password (const char *filename,
      const char *username, char *key, size_t * keylen)
{
  char *tmp;
  size_t tmplen;
  int res;
  FILE *fh;
  fh = fopen (filename, "r");
  if (fh == ((void *)0))
    return GSASL_FOPEN_ERROR;
  fclose (fh);
  res = gsasl_simple_getpass (filename, username, &tmp);
  if (res != GSASL_OK)
    return res;
  tmplen = strlen (tmp);
  if (*keylen < tmplen + 1)
    {
      free (tmp);
      return GSASL_TOO_SMALL_BUFFER;
    }
  *keylen = tmplen;
  if (key)
    memcpy (key, tmp, tmplen);
  free (tmp);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 3
9 3
10 3
11 8
12 8
13 10
14 9
15 9
16 11
17 12
18 12
19 12
20 12
21 13
22 13
23 15
24 15
25 15
26 16
27 16
28 16
29 22
30 21
31 22
32 23
33 23
34 23
35 23
36 24
37 24
38 25
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 18
47 18
48 26
49 19
50 26
51 26
52 26
53 26
54 26
55 26
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
mov    %r8,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
callq  529 <_mapfile_readline+0x19>
mov    0x8(%rax),%rsi
mov    %rax,%r9
mov    $0x16,%eax
cmp    $0xffffffffffffffff,%rsi
je     592 <_mapfile_readline+0x82>
mov    0x10(%r9),%rdx
xor    %ebx,%ebx
cmp    %rbp,%rdx
jle    587 <_mapfile_readline+0x77>
sub    %rbp,%rdx
add    %rsi,%rbp
mov    $0xa,%esi
mov    %rbp,%rdi
sub    $0x1,%r14
mov    %rdx,%rbx
callq  560 <_mapfile_readline+0x50>
test   %rax,%rax
je     56c <_mapfile_readline+0x5c>
sub    %rbp,%rax
lea    0x1(%rax),%rbx
cmp    %r14,%rbx
mov    %rbp,%rsi
mov    %r13,%rdi
cmova  %r14,%rbx
mov    %rbx,%rdx
callq  581 <_mapfile_readline+0x71>
movb   $0x0,0x0(%r13,%rbx,1)
test   %r12,%r12
je     5a0 <_mapfile_readline+0x90>
mov    %rbx,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    592 <_mapfile_readline+0x82>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_readline (mu_stream_t stream, char *optr, size_t osize,
  mu_off_t offset, size_t *nbytes)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  char *nl;
  size_t n = 0;
  if (mfs->ptr == ((void *) -1))
    return 22;
  if (offset < (mu_off_t)mfs->size)
    {
      osize--;
      nl = memchr (mfs->ptr + offset, '\n', mfs->size - offset);
      n = (nl) ? (size_t)(nl - (mfs->ptr + offset) + 1) : mfs->size - offset;
      n = (n > osize) ? osize : n;
      memcpy (optr, mfs->ptr + offset, n);
      optr[n] = '\0';
    }
  if (nbytes)
    *nbytes = n;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 7
12 4
13 8
14 7
15 7
16 9
17 6
18 9
19 9
20 12
21 12
22 12
23 12
24 11
25 12
26 12
27 13
28 13
29 13
30 13
31 14
32 15
33 15
34 14
35 15
36 15
37 16
38 18
39 18
40 19
41 20
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 20
50 20
51 20
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    %rdx,%r9
mov    %rcx,(%rsp)
mov    0x0(%rip),%rcx        # c5 <nettle_gcm_aes128_decrypt+0x15>
lea    0x1040(%rdi),%rdx
lea    0x1000(%rdi),%rdi
mov    %rsi,%r8
mov    %rax,%rsi
callq  de <nettle_gcm_aes128_decrypt+0x2e>
add    $0x18,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_aes128_decrypt(struct gcm_aes128_ctx *ctx,
     size_t length, uint8_t *dst, const uint8_t *src)
{
  (0 ? (nettle_aes128_encrypt)(&(ctx)->cipher, ~(size_t) 0, (uint8_t *) 0, (const uint8_t *) 0) : nettle_gcm_decrypt(&(ctx)->gcm, &(ctx)->key, &(ctx)->cipher, (nettle_cipher_func *) (nettle_aes128_encrypt), (length), (dst), (src)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 3
9 4
10 4
11 5
12 5
13 5
<<<sep_out_sample>>>
mov    0x10(%rsi),%rax
cmp    %rax,0x8(%rsi)
jg     6f0 <search+0x10>
jmpq   6ef <search+0xf>
nop
jmpq   6f5 <search+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
search (char *string, SEARCH_BINDING *binding, long *poff)
{
  enum search_result result;
  if (binding->start > binding->end)
    result = search_backward (string, binding, poff);
  else
    result = search_forward (string, binding, poff);
  return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 5
7 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
movq   $0x0,(%rsi)
je     410 <osip_cseq_clone+0x90>
cmpq   $0x0,(%rdi)
je     410 <osip_cseq_clone+0x90>
cmpq   $0x0,0x8(%rdi)
je     410 <osip_cseq_clone+0x90>
lea    0x8(%rsp),%rdi
callq  3b1 <osip_cseq_clone+0x31>
test   %eax,%eax
mov    %eax,%r12d
jne    3f0 <osip_cseq_clone+0x70>
mov    0x8(%rsp),%r12
mov    (%rbx),%rdi
callq  3c5 <osip_cseq_clone+0x45>
mov    0x8(%rbx),%rdi
mov    %rax,(%r12)
mov    0x8(%rsp),%r12
callq  3d7 <osip_cseq_clone+0x57>
mov    %rax,0x8(%r12)
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    0x8(%rsp),%rdi
callq  3fa <osip_cseq_clone+0x7a>
add    $0x10,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
jmp    3e7 <osip_cseq_clone+0x67>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_cseq_clone (const osip_cseq_t * cseq, osip_cseq_t ** dest)
{
  int i;
  osip_cseq_t *cs;
  *dest = ((void *)0);
  if (cseq == ((void *)0))
    return -2;
  if (cseq->method == ((void *)0))
    return -2;
  if (cseq->number == ((void *)0))
    return -2;
  i = osip_cseq_init (&cs);
  if (i != 0) {
    osip_cseq_free (cs);
    return i;
  }
  cs->method = osip_strdup (cseq->method);
  cs->number = osip_strdup (cseq->number);
  *dest = cs;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 5
9 6
10 8
11 8
12 10
13 10
14 12
15 12
16 13
17 12
18 13
19 17
20 17
21 17
22 18
23 17
24 18
25 18
26 18
27 19
28 19
29 20
30 21
31 21
32 21
33 21
34 21
35 14
36 14
37 21
38 15
39 21
40 21
41 21
42 21
43 21
44 7
45 7
46 7
<<<sep_out_sample>>>
mov    (%rsi),%rdx
mov    (%rdi),%rax
mov    (%rdx),%rsi
mov    (%rax),%rdi
jmpq   101 <printer_hash_qcmp+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printer_hash_qcmp (struct printer **x, struct printer **y)
{
  return strverscmp ((*x)->key, (*y)->key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # fb <create_output_stream+0xb>
callq  100 <create_output_stream+0x10>
mov    $0x1,%edx
mov    $0x2,%esi
mov    %eax,%edi
add    $0x8,%rsp
jmpq   115 <create_output_stream+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_output_stream()
{
    return dico_fd_stream_create(fileno(stdout), 0x02, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 3
9 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1eb7 <cpp_get_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cpp_get_out (void)
{
        return cpp_out;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
lea    0x16d(%rsi),%r8d
xor    %eax,%eax
cmp    %edi,%r8d
jl     e30 <doy2date+0x60>
test   %edi,%edi
jle    e30 <doy2date+0x60>
xor    %r9d,%r9d
test   %esi,%esi
je     df1 <doy2date+0x21>
cmp    0x0(%rip),%edi        # def <doy2date+0x1f>
jg     e38 <doy2date+0x68>
xor    %eax,%eax
jmp    dfa <doy2date+0x2a>
nopl   (%rax)
mov    %esi,%edi
mov    %edi,%esi
sub    0x0(,%rax,4),%esi
lea    0x1(%rax),%r8d
test   %esi,%esi
jle    e58 <doy2date+0x88>
add    $0x1,%rax
cmp    $0xb,%rax
jne    df8 <doy2date+0x28>
mov    $0xc,%r8d
test   %r9d,%r9d
mov    %r8d,(%rcx)
mov    $0x1,%eax
mov    %esi,(%rdx)
je     e30 <doy2date+0x60>
cmpl   $0x2,(%rcx)
je     e48 <doy2date+0x78>
nop
repz retq 
nopw   0x0(%rax,%rax,1)
sub    $0x1,%edi
mov    $0x1,%r9d
jmp    df1 <doy2date+0x21>
nopl   0x0(%rax,%rax,1)
cmp    $0x1c,%esi
jne    e30 <doy2date+0x60>
movl   $0x1d,(%rdx)
retq   
nopl   0x0(%rax)
mov    %edi,%esi
jmp    e1b <doy2date+0x4b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
doy2date (doy, is_leap_year, day, month)
     int doy;
     const int is_leap_year;
     int *day;
     int *month;
{
  register int i;
  auto Bool decrement_date;
  if (doy > 365 + is_leap_year || doy < 1)
    return ((!(0==0)));
  decrement_date = (Bool) (is_leap_year && (doy > mvec[2]));
  if (decrement_date)
    doy--;
  for (i = 1; i < 12; i++)
    {
      doy -= dvec[i - 1];
      if (doy <= 0)
 {
   doy += dvec[i - 1];
   break;
 }
    }
  *month = i;
  *day = doy;
  if (decrement_date && (*month == 2) && (*day == 28))
    (*day)++;
  return ((0==0));
}
<<<sep_in_sample>>>
1 9
2 10
3 9
4 9
5 9
6 9
7 9
8 11
9 11
10 11
11 11
12 14
13 14
14 14
15 14
16 16
17 16
18 16
19 17
20 17
21 17
22 14
23 14
24 14
25 25
26 23
27 27
28 24
29 25
30 25
31 25
32 25
33 28
34 28
35 13
36 11
37 11
38 11
39 25
40 25
41 26
42 26
43 26
44 26
45 26
46 26
<<<sep_out_sample>>>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     21d0 <print_file_variables+0x20>
mov    0x8(%rax),%rdi
mov    $0x1,%edx
mov    $0x0,%esi
jmpq   240 <print_variable_set>
nopl   0x0(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_file_variables (const struct file *file)
{
  if (file->variables != 0)
    print_variable_set (file->variables->set, "# ", 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
test   %rdi,%rdi
je     12d0 <iso9660_ifs_get_joliet_level+0x10>
movzbl 0x10(%rdi),%eax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_ifs_get_joliet_level(iso9660_t *p_iso)
{
  if (!p_iso) return 0;
  return p_iso->u_joliet_level;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 3
7 5
8 5
<<<sep_out_sample>>>
mov    $0x20,%esi
jmpq   54a <mu_attribute_unset_read+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_unset_read (mu_attribute_t attr)
{
  return mu_attribute_unset_flags (attr, 0x20);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     668 <osip_transaction_add_event+0x28>
test   %rdi,%rdi
je     668 <osip_transaction_add_event+0x28>
sub    $0x8,%rsp
mov    0x8(%rdi),%eax
mov    0x10(%rdi),%rdi
mov    %eax,0x4(%rsi)
callq  65d <osip_transaction_add_event+0x1d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0xfffffffe,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
osip_transaction_add_event (osip_transaction_t * transaction, osip_event_t * evt)
{
  if (evt == ((void *)0))
    return -2;
  if (transaction == ((void *)0))
    return -2;
  evt->transactionid = transaction->transactionid;
  osip_fifo_add (transaction->transactionff, evt);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 2
6 7
7 8
8 7
9 8
10 9
11 10
12 10
13 10
14 4
15 4
16 4
<<<sep_out_sample>>>
push   %r15
mov    %r9d,%r15d
push   %r14
mov    %r8,%r14
push   %r13
mov    %ecx,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # a1da <ca_nw_hdy+0x2a>
mov    0x50(%rsp),%eax
mov    %eax,(%rsp)
mov    %eax,0xc(%rsp)
callq  a1ea <ca_nw_hdy+0x3a>
mov    0xc(%rsp),%eax
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12d,%edx
mov    %r13d,%ecx
mov    %r14,%r8
mov    %r15d,%r9d
mov    %eax,0x50(%rsp)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   0 <ca_base_hdy>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ca_nw_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CA_NW";
  ca_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  ca_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 10
15 9
16 11
17 11
18 11
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 12
35 12
<<<sep_out_sample>>>
xor    %r8d,%r8d
jmpq   1148 <asn1_read_value+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asn1_read_value (asn1_node root, const char *name, void *ivalue, int *len)
{
  return asn1_read_value_type (root, name, ivalue, len, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x4,%edi
mov    %rsi,%rbx
callq  e <_gsasl_login_client_start+0xe>
mov    %rax,%rdx
mov    $0x7,%eax
test   %rdx,%rdx
je     26 <_gsasl_login_client_start+0x26>
movl   $0x0,(%rdx)
xor    %al,%al
mov    %rdx,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_login_client_start (Gsasl_session * sctx, void **mech_data)
{
  struct _Gsasl_login_client_state *state;
  state = malloc (sizeof (*state));
  if (state == ((void *)0))
    return GSASL_MALLOC_ERROR;
  state->step = 0;
  *mech_data = state;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 6
7 5
8 5
9 7
10 9
11 8
12 10
13 10
14 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1d9 <string_to_security_class+0x9>
movl   $0x5f,(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_to_security_class (char const *name)
  { (*__errno_location ()) = 95; return 0; }
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     40 <gsl_eigen_nonsymm_free+0x40>
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     17 <gsl_eigen_nonsymm_free+0x17>
callq  17 <gsl_eigen_nonsymm_free+0x17>
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     25 <gsl_eigen_nonsymm_free+0x25>
callq  25 <gsl_eigen_nonsymm_free+0x25>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     33 <gsl_eigen_nonsymm_free+0x33>
callq  33 <gsl_eigen_nonsymm_free+0x33>
mov    %rbx,%rdi
pop    %rbx
jmpq   3c <gsl_eigen_nonsymm_free+0x3c>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_nonsymm_free (gsl_eigen_nonsymm_workspace * w)
{
  if (!w) { return ; };
  if (w->tau)
    gsl_vector_free(w->tau);
  if (w->diag)
    gsl_vector_free(w->diag);
  if (w->francis_workspace_p)
    gsl_eigen_francis_free(w->francis_workspace_p);
  free(w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 6
12 7
13 8
14 8
15 8
16 9
17 10
18 11
19 10
20 10
21 11
22 11
23 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  110c <pslex_dump+0xc>
mov    %rbx,0x0(%rip)        # 1113 <pslex_dump+0x13>
mov    %rax,0x0(%rip)        # 111a <pslex_dump+0x1a>
pop    %rbx
jmpq   1120 <pslex_dump+0x20>
<<<sep_in_sample>>>
pslex_dump (FILE *stream, const char *filename)
{
  psin = xrfopen (filename);
  psout = stream;
  pslex ();
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 3
7 6
8 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 2f57 <flush_read+0x7>
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
flush_read (void)
{
  flush_read_ptr ();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
callq  586 <xalloc_die+0x6>
mov    (%rax),%edi
callq  58d <xalloc_die+0xd>
mov    $0x0,%edi
mov    %rax,%rbx
callq  59a <xalloc_die+0x1a>
mov    %rbx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  5a7 <xalloc_die+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xalloc_die (void)
{
 r_fatal(gettext ("xalloc: malloc failed: %s"), strerror((*__errno_location ())));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    (%rdi),%rbx
mov    0x20(%rdi),%rax
lea    (%rbx,%rax,8),%rbp
cmp    %rbp,%rbx
jae    52d <hash_map+0x3d>
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     524 <hash_map+0x34>
cmp    0x0(%rip),%rdi        # 51f <hash_map+0x2f>
je     524 <hash_map+0x34>
callq  *%r12
add    $0x8,%rbx
cmp    %rbx,%rbp
ja     510 <hash_map+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_map (struct hash_table *ht, hash_map_func_t map)
{
  void **slot;
  void **end = &ht->ht_vec[ht->ht_size];
  for (slot = ht->ht_vec; slot < end; slot++)
    {
      if (!((*slot) == 0 || (void *) (*slot) == hash_deleted_item))
 (*map) (*slot);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 8
17 5
18 5
19 5
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     120 <str_append+0x30>
mov    %rdi,%rbp
mov    %rsi,%rdi
callq  109 <str_append+0x19>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
mov    %rax,%rdx
jmpq   50 <str_append_n>
nopl   (%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
str_append (char **to, const char *from)
{
  if (!from)
    return 0;
  return str_append_n (to, from, strlen (from));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 6
11 5
12 5
13 6
14 6
15 5
16 5
17 5
18 6
19 6
20 6
21 6
22 6
23 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     828 <mu_url_to_string+0x18>
mov    (%rdi),%rdx
mov    $0x0,%eax
test   %rdx,%rdx
cmovne %rdx,%rax
retq   
nopl   (%rax)
mov    $0x0,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_url_to_string (const mu_url_t url)
{
  if (url == ((void *)0) || url->name == ((void *)0))
    return "";
  return url->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x8(%rsi),%rax
jne    e30 <gsl_vector_uint_equal+0x50>
test   %r8,%r8
je     e25 <gsl_vector_uint_equal+0x45>
mov    0x10(%rsi),%rdx
mov    0x10(%rdi),%rcx
shl    $0x2,%r9
lea    0x0(,%rax,4),%rdi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
mov    (%rdx),%esi
cmp    %esi,(%rcx)
jne    e54 <gsl_vector_uint_equal+0x74>
add    $0x1,%rax
add    %r9,%rcx
add    %rdi,%rdx
cmp    %r8,%rax
jne    e10 <gsl_vector_uint_equal+0x30>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e4d <gsl_vector_uint_equal+0x6d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_equal (const gsl_vector_uint * u, const gsl_vector_uint * v)
{
  const size_t n = v->size;
  const size_t stride_u = u->stride ;
  const size_t stride_v = v->stride ;
  size_t j;
  if (u->size != v->size)
    {
      do { gsl_error ("vectors must have same length", "prop_source.c", 32, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (u->data[1 * stride_u * j + k] != v->data[1 * stride_v * j + k])
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 7
3 4
4 5
5 7
6 11
7 11
8 11
9 11
10 11
11 11
12 11
13 11
14 16
15 16
16 16
17 11
18 11
19 11
20 11
21 11
22 22
23 22
24 22
25 2
26 9
27 9
28 9
29 9
30 9
31 9
32 23
33 23
34 18
35 18
36 18
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1e47 <asm_get_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_get_out (void)
{
        return asm_out;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
bindtextdomain(char * a, char * b) {
}
<<<sep_in_sample>>>
1 1
2 1
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0x7,0x0(%rip)        # 9 <is_declaration+0x9>
je     10 <is_declaration+0x10>
repz retq 
nopl   (%rax)
mov    0x0(%rip),%edx        # 16 <is_declaration+0x16>
mov    $0x1,%al
mov    %edx,%ecx
and    $0xfffffffd,%ecx
cmp    $0x20,%ecx
je     b <is_declaration+0xb>
cmp    $0x2c,%edx
je     b <is_declaration+0xb>
lea    -0x2e(%rdx),%ecx
cmp    $0x2,%ecx
jbe    b <is_declaration+0xb>
xor    %eax,%eax
cmp    $0x33,%edx
sete   %al
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_declaration(void)
{ if (((token[1].code) == 7 && token[1].delim == 32) || ((token[1].code) == 7 && token[1].delim == 34) ||
          ((token[1].code) == 7 && token[1].delim == 44) || ((token[1].code) == 7 && token[1].delim == 46) ||
          ((token[1].code) == 7 && token[1].delim == 47) || ((token[1].code) == 7 && token[1].delim == 48) ||
          ((token[1].code) == 7 && token[1].delim == 51)) return 1;
      return 0;
}
<<<sep_in_sample>>>
1 6
2 2
3 2
4 7
5 7
6 2
7 5
8 2
9 2
10 2
11 2
12 3
13 3
14 3
15 3
16 3
17 5
18 5
19 5
20 7
21 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
mov    %rsi,%rbx
mov    $0x40,%esi
sub    $0x8,%rsp
callq  202b <gdbmarg_datum+0x1b>
test   %rbx,%rbx
movq   $0x0,(%rax)
movl   $0x1,0x8(%rax)
movl   $0x1,0xc(%rax)
je     2064 <gdbmarg_datum+0x54>
mov    (%rbx),%rdx
mov    %rdx,0x10(%rax)
mov    0x8(%rbx),%rdx
mov    %rdx,0x18(%rax)
mov    0x10(%rbx),%rdx
mov    %rdx,0x20(%rax)
mov    0x18(%rbx),%rdx
mov    %rdx,0x28(%rax)
mov    0x0(%rbp),%rsi
mov    0x8(%rbp),%rdi
mov    %rsi,0x30(%rax)
mov    %rdi,0x38(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gdbmarg_datum (datum *dat, struct locus *loc)
{
  struct gdbmarg *arg = ecalloc (1, sizeof (*arg));
  arg->next = ((void *)0);
  arg->type = 1;
  arg->ref = 1;
  if (loc)
    arg->loc = *loc;
  arg->v.dat = *dat;
  return arg;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 3
9 7
10 4
11 5
12 6
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 9
23 9
24 9
25 9
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1736 <ppdget_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdget_debug (void)
{
        return ppd_flex_debug;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 7 <nettle_hmac_md5_set_key+0x7>
mov    %rsi,%r8
mov    %rdx,%r9
lea    0x60(%rdi),%rsi
lea    0xc0(%rdi),%rdx
jmpq   1d <nettle_hmac_md5_set_key+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
nettle_hmac_md5_set_key(struct hmac_md5_ctx *ctx,
   size_t key_length, const uint8_t *key)
{
  nettle_hmac_set_key( &(ctx)->outer, &(ctx)->inner, &(ctx)->state, (&nettle_md5), (key_length), (key) );
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   656a <close_pgrp_pipe+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_pgrp_pipe ()
{
  sh_closepipe (pgrp_pipe);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  2ff <hash_insert+0xf>
test   %rax,%rax
je     330 <hash_insert+0x40>
mov    (%rax),%rbx
mov    %rax,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  315 <hash_insert+0x25>
xor    %eax,%eax
test   %rbx,%rbx
je     327 <hash_insert+0x37>
cmp    0x0(%rip),%rbx        # 323 <hash_insert+0x33>
cmovne %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %r12,%rsi
mov    %rbp,%rdi
xor    %edx,%edx
callq  33d <hash_insert+0x4d>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_insert (struct hash_table* ht, void *item)
{
  void **slot = hash_find_slot (ht, item);
  void *old_item = slot ? *slot : 0;
  hash_insert_at (ht, item, slot);
  return ((((old_item) == 0 || (void *) (old_item) == hash_deleted_item)) ? 0 : old_item);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 5
25 5
26 5
27 5
28 7
29 7
30 6
31 7
32 7
33 7
<<<sep_out_sample>>>
mov    0x20(%rsi),%eax
cmp    %eax,0x20(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sys_compare_gid (struct stat *a, struct stat *b)
{
  return a->st_gid == b->st_gid;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     9a1 <gsl_matrix_long_double_fread+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    95e <gsl_matrix_long_double_fread+0x4e>
jmp    990 <gsl_matrix_long_double_fread+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     990 <gsl_matrix_long_double_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  975 <gsl_matrix_long_double_fread+0x65>
test   %eax,%eax
je     950 <gsl_matrix_long_double_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   9c4 <gsl_matrix_long_double_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_fread (FILE * stream, gsl_matrix_long_double * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_long_double_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_long_double_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    $0x4,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk4_order (void *vstate)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  state = 0;
  return 4;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
xor    %r12d,%r12d
push   %rbp
push   %rbx
cmpq   $0x0,0x670(%rdi)
jle    f6e <FindMCDependents+0x5e>
nopl   0x0(%rax,%rax,1)
mov    0x678(%r14),%rax
mov    (%rax,%r12,8),%r13
lea    0x20(%r13),%rbp
mov    %r13,%rbx
mov    0x98(%rbx),%rax
test   %rax,%rax
je     f58 <FindMCDependents+0x48>
mov    0x28(%rbx),%rdx
cmp    %rdx,0x8(%rax)
je     f80 <FindMCDependents+0x70>
add    $0x8,%rbx
cmp    %rbp,%rbx
jne    f42 <FindMCDependents+0x32>
add    $0x1,%r12
cmp    %r12,0x670(%r14)
jg     f30 <FindMCDependents+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopw   0x0(%rax,%rax,1)
mov    0xb8(%rax),%rdi
mov    %r13,%rsi
callq  f8f <FindMCDependents+0x7f>
jmp    f58 <FindMCDependents+0x48>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
FindMCDependents (PLEVEL plevel, char **args)
{
  long i, j;
  PMCVAR pMCVar;
  for (i = 0; i < plevel->nMCVars; i++) {
    pMCVar = plevel->rgpMCVars[i];
    for (j = 0; j < 4; j++)
      if ((pMCVar->pMCVParent[j] != ((void *)0)) &&
          (pMCVar->pMCVParent[j]->hvar == pMCVar->hParm[j]))
        QueueListItem(pMCVar->pMCVParent[j]->plistDependents, pMCVar);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 2
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 8
16 8
17 8
18 8
19 8
20 8
21 8
22 7
23 7
24 5
25 5
26 5
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 10
35 10
36 10
37 10
38 10
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    (%rdi),%rdi
jmpq   3a0 <gsl_blas_icamax>
<<<sep_in_sample>>>
gsl_blas_idamax (const gsl_vector * X)
{
  return cblas_idamax (((int)(X->size)), X->data, ((int)(X->stride)));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     140 <mu_ticket_get_owner+0x10>
mov    (%rdi),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ticket_get_owner (mu_ticket_t ticket)
{
  return (ticket) ? ticket->owner : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmpb   $0x31,(%rdi)
je     30 <source_version_index+0x30>
mov    $0x0,%edi
callq  13 <source_version_index+0x13>
xor    %esi,%esi
mov    %rax,%rdx
mov    $0x1,%edi
xor    %eax,%eax
callq  24 <source_version_index+0x24>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
cmpb   $0x2e,0x1(%rdi)
jne    9 <source_version_index+0x9>
movsbl 0x2(%rdi),%eax
lea    -0x33(%rax),%edx
cmp    $0x2,%dl
ja     9 <source_version_index+0x9>
sub    $0x33,%eax
cmpb   $0x0,0x3(%rdi)
jne    9 <source_version_index+0x9>
jmp    26 <source_version_index+0x26>
nopl   (%rax)
<<<sep_in_sample>>>
source_version_index (const char *source_version)
{
  if (source_version[0] == '1' && source_version[1] == '.'
      && (source_version[2] >= '3' && source_version[2] <= '5')
      && source_version[3] == '\0')
    return source_version[2] - '3';
  error (1, 0, gettext ("invalid source_version argument to compile_java_class"));
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 8
12 9
13 9
14 9
15 3
16 3
17 4
18 4
19 4
20 4
21 6
22 5
23 5
24 5
25 5
<<<sep_out_sample>>>
mov    0x4c(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swvarfs_fd(SWVARFS * swvarfs)
{
 return swvarfs->fdM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_kernel (mu_locker_t locker)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  b4c <gsl_block_uint_calloc+0xc>
test   %rax,%rax
mov    %rax,%rbx
je     b97 <gsl_block_uint_calloc+0x57>
lea    0x0(,%rbp,4),%r12
mov    0x8(%rax),%rdi
xor    %esi,%esi
mov    %r12,%rdx
callq  b6a <gsl_block_uint_calloc+0x2a>
test   %rbp,%rbp
je     b8f <gsl_block_uint_calloc+0x4f>
mov    0x8(%rbx),%rcx
lea    (%r12,%rcx,1),%rdx
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rcx)
add    $0x4,%rcx
cmp    %rdx,%rcx
jne    b80 <gsl_block_uint_calloc+0x40>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %eax,%eax
jmp    b92 <gsl_block_uint_calloc+0x52>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uint_calloc (const size_t n)
{
  size_t i;
  gsl_block_uint * b = gsl_block_uint_alloc (n);
  if (b == 0)
    return 0;
  memset(b->data, 0, 1 * n * sizeof(unsigned int));
  for (i = 0; i < 1 * n; i++)
    {
      b->data[i] = 0;
    }
  return b;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 5
9 7
10 7
11 7
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 10
20 10
21 8
22 8
23 8
24 13
25 13
26 13
27 13
28 6
29 6
30 6
<<<sep_out_sample>>>
mov    0x84(%rdi),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uinfile_get_has_leading_slash(UINFORMAT * uinformat)
{
 return uinformat->has_leading_slashM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  14 <triple_hash+0x14>
xor    0x8(%rbp),%rax
xor    %edx,%edx
add    $0x8,%rsp
div    %rbx
pop    %rbx
pop    %rbp
mov    %rdx,%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
triple_hash (void const *x, size_t table_size)
{
  struct F_triple const *p = x;
  size_t tmp = hash_pjw (p->name, table_size);
  return (tmp ^ p->st_ino) % table_size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 6
11 5
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
cmp    $0x20,%dil
sete   %al
cmp    $0x9,%dil
sete   %dl
or     %edx,%eax
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_ws (char c)
{
    return c == '\t' || c == ' ';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x68,%edi
callq  1cb <swi_control_script_create+0xb>
mov    $0xd5,%edx
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%esi
callq  1e0 <swi_control_script_create+0x20>
mov    %rbx,%rdi
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x44,%esi
callq  1f1 <swi_control_script_create+0x31>
mov    0x0(%rip),%eax        # 1f7 <swi_control_script_create+0x37>
movq   $0x0,0x50(%rbx)
movq   $0x0,0x58(%rbx)
movl   $0xffffffff,0x60(%rbx)
movl   $0xff,0x4c(%rbx)
add    $0x1,%eax
mov    %eax,0x48(%rbx)
mov    %eax,0x0(%rip)        # 221 <swi_control_script_create+0x61>
mov    %rbx,%rax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swi_control_script_create(void)
{
 static int id = 0;
 SWI_CONTROL_SCRIPT * s;
 ;
 s = (SWI_CONTROL_SCRIPT *)malloc(sizeof(SWI_CONTROL_SCRIPT));
 swi_com_assert_pointer((void*)s, "swi_afile.c", 213);
 swi_vbase_init(s, 'D', ((void *)0), ((void *)0));
 s->sidM = ++id;
 s->afileM = ((void *)0);
 s->swi_xfileM = (void*)((void *)0);
 s->INFO_offsetM = -1;
 s->resultM = 255;
 return s;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 7
5 6
6 7
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 9
15 10
16 11
17 12
18 13
19 9
20 9
21 9
22 15
23 15
24 15
25 15
<<<sep_out_sample>>>
mov    (%rdi),%ecx
test   %ecx,%ecx
jne    40 <version_null_p+0x20>
mov    0x4(%rdi),%edx
test   %edx,%edx
jne    40 <version_null_p+0x20>
mov    0x8(%rdi),%eax
test   %eax,%eax
sete   %al
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
version_null_p (version_t version)
{
  size_t n;
  for (n = 0 ; n < 3 ; n++)
    if (version[n])
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 8
14 8
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     37d <udf_get_attribute_time+0x2d>
sub    $0x10,%rsp
mov    0xa0(%rdi),%rdx
mov    0xa8(%rdi),%ecx
lea    0x8(%rsp),%rsi
mov    %rsp,%rdi
callq  375 <udf_get_attribute_time+0x25>
mov    (%rsp),%rax
add    $0x10,%rsp
repz retq 
<<<sep_in_sample>>>
udf_get_attribute_time(const udf_dirent_t *p_udf_dirent)
{
  if (p_udf_dirent) {
    time_t ret_time;
    long int usec;
    udf_stamp_to_time(&ret_time, &usec, p_udf_dirent->fe.attribute_time);
    return ret_time;
  }
  return 0;
}
<<<sep_in_sample>>>
1 9
2 3
3 3
4 2
5 6
6 6
7 6
8 6
9 6
10 7
11 10
12 10
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    0x18(%rdi),%rbp
mov    %rdi,%rbx
cmp    %rcx,%rbp
je     170 <gsl_spline_init+0x40>
mov    $0x4,%ecx
mov    $0x4a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15d <gsl_spline_init+0x2d>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x4,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
lea    0x0(,%rbp,8),%r14
mov    0x8(%rdi),%rdi
mov    %rdx,%r13
mov    %rsi,%r12
mov    %r14,%rdx
callq  18a <gsl_spline_init+0x5a>
mov    0x10(%rbx),%rdi
mov    %r14,%rdx
mov    %r13,%rsi
callq  199 <gsl_spline_init+0x69>
mov    (%rbx),%rdi
mov    %rbp,%rcx
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdx
pop    %r13
pop    %r14
jmpq   1b2 <gsl_spline_init+0x82>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline_init (gsl_spline * spline, const double x_array[], const double y_array[], size_t size)
{
  if (size != spline->size)
    {
      do { gsl_error ("data must match size of spline object", "spline.c", 74, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  memcpy (spline->x, x_array, size * sizeof(double));
  memcpy (spline->y, y_array, size * sizeof(double));
  {
    int status = gsl_interp_init (spline->interp, x_array, y_array, size);
    return status;
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 13
16 13
17 13
18 13
19 13
20 13
21 13
22 13
23 7
24 7
25 7
26 7
27 7
28 7
29 8
30 8
31 8
32 8
33 10
34 10
35 10
36 13
37 13
38 13
39 10
40 13
41 13
42 10
43 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
jne    d8c <grecs_match_next+0x1c>
jmp    da6 <grecs_match_next+0x36>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  740 <grecs_match>
test   %eax,%eax
jne    da0 <grecs_match_next+0x30>
mov    0x28(%rbx),%rdi
callq  d95 <grecs_match_next+0x25>
test   %rax,%rax
mov    %rax,0x28(%rbx)
jne    d80 <grecs_match_next+0x10>
pop    %rbx
retq   
mov    0x28(%rbx),%rax
pop    %rbx
retq   
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_match_next(struct grecs_match_buf *buf)
{
 if (!buf)
  return ((void *)0);
 while ((buf->node = grecs_next_node(buf->node)))
  if (grecs_match(buf))
   break;
 return buf->node;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 6
8 6
9 6
10 6
11 5
12 5
13 5
14 5
15 5
16 9
17 9
18 9
19 9
20 9
21 4
22 9
23 9
24 9
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
mov    0x0(%rip),%rdx        # 30b <print_version_handler+0xb>
mov    $0x0,%esi
xor    %eax,%eax
jmpq   317 <print_version_handler+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_version_handler (struct handler_param *param)
{
  fprintf (param->fp, "%s\n", gdbm_version);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x10,%rsp
mov    0x4(%rsi),%eax
mov    0x4(%rsi),%ebx
sar    $0x1f,%eax
xor    %eax,%ebx
sub    %eax,%ebx
cmp    %rdi,%rsi
movslq %ebx,%rdx
je     38 <__gmpz_abs+0x38>
movslq (%rdi),%rax
cmp    %rax,%rdx
jg     46 <__gmpz_abs+0x46>
mov    0x8(%rdi),%rdi
mov    0x8(%rbp),%rsi
callq  38 <__gmpz_abs+0x38>
mov    %ebx,0x4(%r12)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rdx,%rsi
mov    %rdx,0x8(%rsp)
callq  53 <__gmpz_abs+0x53>
mov    0x8(%rsp),%rdx
mov    %rax,%rdi
jmp    2f <__gmpz_abs+0x2f>
<<<sep_in_sample>>>
__gmpz_abs (mpz_ptr w, mpz_srcptr u)
{
  mp_ptr wp;
  mp_srcptr up;
  mp_size_t size;
  size = ((((u)->_mp_size)) >= 0 ? (((u)->_mp_size)) : -(((u)->_mp_size)));
  if (u != w)
    {
      wp = (__builtin_expect (((size) > ((w)->_mp_alloc)) != 0, 0) ? (mp_ptr) __gmpz_realloc(w,size) : ((w)->_mp_d));
      up = ((u)->_mp_d);
      do { do {} while (0); do { do {} while (0); do {} while (0); __gmpn_copyi (wp, up, size); } while (0); } while (0);
    }
  ((w)->_mp_size) = size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 7
13 6
14 7
15 9
16 9
17 9
18 9
19 11
20 11
21 13
22 14
23 14
24 14
25 14
26 14
27 9
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
test   $0x2,%dil
je     90 <wsnode_flagstr+0x90>
movb   $0x77,0x0(%rip)        # 11 <wsnode_flagstr+0x11>
mov    %edi,%eax
movb   $0x0,0x0(%rip)        # 1a <wsnode_flagstr+0x1a>
and    $0x4,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbc,%eax
add    $0x71,%eax
mov    %al,0x0(%rip)        # 2e <wsnode_flagstr+0x2e>
mov    %edi,%eax
and    $0x8,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffe8,%eax
add    $0x45,%eax
mov    %al,0x0(%rip)        # 44 <wsnode_flagstr+0x44>
mov    %edi,%eax
and    $0x10,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffc3,%eax
add    $0x6a,%eax
mov    %al,0x0(%rip)        # 5a <wsnode_flagstr+0x5a>
mov    %edi,%eax
and    $0x20,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0x40,%edi
and    $0xffffffba,%eax
add    $0x73,%eax
cmp    $0x1,%edi
mov    %al,0x0(%rip)        # 76 <wsnode_flagstr+0x76>
sbb    %eax,%eax
and    $0xffffffc9,%eax
add    $0x64,%eax
mov    %al,0x0(%rip)        # 84 <wsnode_flagstr+0x84>
mov    $0x0,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    %edi,%eax
and    $0x1,%eax
cmp    $0x1,%eax
sbb    %eax,%eax
and    $0xffffffbf,%eax
add    $0x6e,%eax
mov    %al,0x0(%rip)        # a6 <wsnode_flagstr+0xa6>
jmpq   11 <wsnode_flagstr+0x11>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_flagstr (int flags)
{
  static char retbuf[7];
  char *p = retbuf;
  if (flags & 0x02)
    *p++ = 'w';
  else if (flags & 0x01)
    *p++ = 'n';
  else
    *p++ = '-';
  if (flags & 0x04)
    *p++ = 'q';
  else
    *p++ = '-';
  if (flags & 0x08)
    *p++ = 'E';
  else
    *p++ = '-';
  if (flags & 0x10)
    *p++ = 'j';
  else
    *p++ = '-';
  if (flags & 0x20)
    *p++ = 's';
  else
    *p++ = '-';
  if (flags & 0x40)
    *p++ = 'd';
  else
    *p++ = '-';
  *p = 0;
  return retbuf;
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 11
5 31
6 11
7 12
8 12
9 12
10 12
11 12
12 15
13 15
14 16
15 16
16 16
17 16
18 16
19 19
20 19
21 20
22 20
23 20
24 20
25 20
26 23
27 23
28 24
29 24
30 27
31 24
32 24
33 28
34 24
35 28
36 28
37 28
38 28
39 33
40 33
41 33
42 7
43 7
44 8
45 8
46 8
47 8
48 8
49 8
50 8
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%eax        # de8 <quotearg_free+0x8>
mov    0x0(%rip),%r12        # def <quotearg_free+0xf>
push   %rbp
cmp    $0x1,%eax
push   %rbx
jbe    e1a <quotearg_free+0x3a>
sub    $0x2,%eax
mov    %r12,%rbx
shl    $0x4,%rax
lea    0x10(%r12,%rax,1),%rbp
nopl   (%rax)
mov    0x18(%rbx),%rdi
add    $0x10,%rbx
callq  e15 <quotearg_free+0x35>
cmp    %rbp,%rbx
jne    e08 <quotearg_free+0x28>
mov    0x8(%r12),%rdi
cmp    $0x0,%rdi
je     e43 <quotearg_free+0x63>
callq  e2d <quotearg_free+0x4d>
movq   $0x100,0x0(%rip)        # e38 <quotearg_free+0x58>
movq   $0x0,0x0(%rip)        # e43 <quotearg_free+0x63>
cmp    $0x0,%r12
je     e5f <quotearg_free+0x7f>
mov    %r12,%rdi
callq  e54 <quotearg_free+0x74>
movq   $0x0,0x0(%rip)        # e5f <quotearg_free+0x7f>
pop    %rbx
pop    %rbp
movl   $0x1,0x0(%rip)        # e6b <quotearg_free+0x8b>
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
quotearg_free (void)
{
  struct slotvec *sv = slotvec;
  unsigned int i;
  for (i = 1; i < nslots; i++)
    free (sv[i].val);
  if (sv[0].val != slot0)
    {
      free (sv[0].val);
      slotvec0.size = sizeof slot0;
      slotvec0.val = slot0;
    }
  if (sv != &slotvec0)
    {
      free (sv);
      slotvec = &slotvec0;
    }
  nslots = 1;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 2
5 5
6 2
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 6
16 5
17 5
18 7
19 7
20 7
21 9
22 10
23 11
24 13
25 13
26 15
27 15
28 16
29 19
30 19
31 18
32 19
33 19
34 19
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
movsbl (%rsi),%esi
test   %sil,%sil
je     243 <grecs_txtacc_grow_string_escape+0x63>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  202 <grecs_txtacc_grow_string_escape+0x22>
test   %rax,%rax
je     21e <grecs_txtacc_grow_string_escape+0x3e>
lea    0xf(%rsp),%rsi
mov    $0x1,%edx
mov    %rbp,%rdi
movb   $0x5c,0xf(%rsp)
callq  21e <grecs_txtacc_grow_string_escape+0x3e>
movzbl (%rbx),%eax
lea    0xf(%rsp),%rsi
add    $0x1,%rbx
mov    $0x1,%edx
mov    %rbp,%rdi
mov    %al,0xf(%rsp)
callq  23b <grecs_txtacc_grow_string_escape+0x5b>
movsbl (%rbx),%esi
test   %sil,%sil
jne    1f8 <grecs_txtacc_grow_string_escape+0x18>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_grow_string_escape(struct grecs_txtacc *acc, const char *buf)
{
 for (; *buf; buf++) {
  if (strchr(" \t\n\"\'\\", *buf))
   do { char __ch = '\\'; grecs_txtacc_grow(acc,&__ch,1); } while (0);
  do { char __ch = *buf; grecs_txtacc_grow(acc,&__ch,1); } while (0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 3
22 6
23 6
24 6
25 6
26 3
27 3
28 3
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  2ec <local_domain+0xc>
test   %rax,%rax
mov    %rax,%rbx
je     340 <local_domain+0x60>
mov    %rax,%rdi
callq  2fc <local_domain+0x1c>
mov    %rbp,%rdi
mov    %rax,%r12
callq  307 <local_domain+0x27>
test   %rax,%rax
je     338 <local_domain+0x58>
test   %r12,%r12
je     338 <local_domain+0x58>
mov    %rax,%rsi
mov    %r12,%rdi
xor    %ebp,%ebp
callq  31e <local_domain+0x3e>
test   %eax,%eax
sete   %bpl
mov    %rbx,%rdi
callq  32c <local_domain+0x4c>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x1,%ebp
jmp    324 <local_domain+0x44>
nop
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
local_domain (const char *h)
{
  char *hostname = localhost ();
  if (!hostname)
    return 0;
  else
    {
      int is_local = 0;
      const char *p1 = topdomain (hostname);
      const char *p2 = topdomain (h);
      if (p1 == ((void *)0) || p2 == ((void *)0) || !strcasecmp (p1, p2))
 is_local = 1;
      free (hostname);
      return is_local;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 9
10 9
11 10
12 9
13 10
14 11
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 13
25 13
26 16
27 14
28 16
29 16
30 16
31 16
32 12
33 12
34 12
35 16
36 16
37 5
38 16
39 16
40 16
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    0x0(%rip),%rbx        # d <getuser+0xd>
test   %rbx,%rbx
jne    21 <getuser+0x21>
jmp    40 <getuser+0x40>
nopl   0x0(%rax)
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     40 <getuser+0x40>
cmp    %ebp,(%rbx)
jne    18 <getuser+0x18>
xor    %eax,%eax
cmpb   $0x0,0x10(%rbx)
lea    0x10(%rbx),%rdx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    %ebp,%edi
mov    $0x0,%r12d
callq  4d <getuser+0x4d>
test   %rax,%rax
mov    $0x11,%edi
je     66 <getuser+0x66>
mov    (%rax),%r12
mov    %r12,%rdi
callq  62 <getuser+0x62>
lea    0x11(%rax),%rdi
callq  6b <getuser+0x6b>
lea    0x10(%rax),%rdi
mov    %ebp,(%rax)
mov    %r12,%rsi
mov    %rax,%rbx
callq  7c <getuser+0x7c>
mov    0x0(%rip),%rax        # 83 <getuser+0x83>
mov    %rbx,0x0(%rip)        # 8a <getuser+0x8a>
mov    %rax,0x8(%rbx)
jmp    25 <getuser+0x25>
<<<sep_in_sample>>>
getuser (uid_t uid)
{
  struct userid *tail;
  struct userid *match = ((void *)0);
  for (tail = user_alist; tail; tail = tail->next)
    {
      if (tail->id.u == uid)
        {
          match = tail;
          break;
        }
    }
  if (match == ((void *)0))
    {
      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : "";
      match = xmalloc (__builtin_offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
      match->next = user_alist;
      user_alist = match;
    }
  return match->name[0] ? match->name : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 23
16 23
17 23
18 24
19 24
20 24
21 23
22 24
23 24
24 15
25 16
26 15
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 17
35 19
36 18
37 19
38 17
39 19
40 20
41 21
42 20
43 20
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 3ca <_rl_reset_argument+0xa>
movl   $0x1,0x0(%rip)        # 3d4 <_rl_reset_argument+0x14>
movl   $0x0,0x0(%rip)        # 3de <_rl_reset_argument+0x1e>
movl   $0x0,0x0(%rip)        # 3e8 <_rl_reset_argument+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_reset_argument ()
{
  rl_numeric_arg = rl_arg_sign = 1;
  rl_explicit_arg = 0;
  _rl_argcxt = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  803 <sv_editmode+0x13>
test   %eax,%eax
je     840 <sv_editmode+0x50>
mov    $0x5,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  819 <sv_editmode+0x29>
test   %eax,%eax
jne    838 <sv_editmode+0x48>
movq   $0x0,0x0(%rip)        # 828 <sv_editmode+0x38>
movl   $0x1,0x0(%rip)        # 832 <sv_editmode+0x42>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
pop    %rbx
retq   
nop
movq   $0x0,0x0(%rip)        # 84b <sv_editmode+0x5b>
movl   $0x0,0x0(%rip)        # 855 <sv_editmode+0x65>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sv_editmode (value)
     const char *value;
{
  if (strncasecmp (value, "vi", 2) == 0)
    {
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = 0;
      return 0;
    }
  else if (strncasecmp (value, "emacs", 5) == 0)
    {
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = 1;
      return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 3
5 4
6 4
7 4
8 10
9 10
10 10
11 10
12 10
13 10
14 12
15 13
16 17
17 17
18 17
19 16
20 17
21 17
22 17
23 6
24 7
25 17
26 17
27 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  3c <def_free_fun+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   45 <def_free_fun+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
def_free_fun(void *p)
{
 struct grecs_syment *sym = p;
 free(sym->name);
 free(sym);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     25 <acl_errno_valid+0x25>
jle    20 <acl_errno_valid+0x20>
cmp    $0x26,%edi
je     25 <acl_errno_valid+0x25>
cmp    $0x5f,%edi
nop
je     25 <acl_errno_valid+0x25>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x10,%edi
jne    12 <acl_errno_valid+0x12>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 11
11 11
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%eax
mov    %edx,%ebx
movsd  (%rsi),%xmm0
mov    $0x0,%esi
callq  176 <f_double+0x16>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_double (FILE *fp, void *ptr, int size) { fprintf (fp, "%e", *(double*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
mov    %rdi,%rcx
mov    $0x12c,%edx
mov    $0x1,%esi
mov    $0x0,%edi
jmpq   eb7 <swc_copyright_info+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc_copyright_info(FILE * fp)
{
 fprintf(fp, "%s",
"Copyright (C) 2004,2005,2006,2007,2008,2009,2010 Jim Lowe\n"
"Portions are copyright 1985-2000 Free Software Foundation, Inc.\n"
"This software is distributed under the terms of the GNU General Public License\n"
"and comes with NO WARRANTY to the extent permitted by law.\n"
"See the file named COPYING for details.\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x30,%rsp
mov    (%rdi),%rax
cmp    %rax,0x8(%rsi)
je     18d0 <gsl_permute_matrix_ushort+0x40>
mov    $0x13,%ecx
mov    $0xaa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  18c0 <gsl_permute_matrix_ushort+0x30>
add    $0x30,%rsp
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
xor    %ebx,%ebx
cmpq   $0x0,(%rsi)
je     1903 <gsl_permute_matrix_ushort+0x73>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  18ee <gsl_permute_matrix_ushort+0x5e>
mov    %rsp,%rsi
mov    %r12,%rdi
add    $0x1,%rbx
callq  18fd <gsl_permute_matrix_ushort+0x6d>
cmp    %rbx,0x0(%rbp)
ja     18e0 <gsl_permute_matrix_ushort+0x50>
add    $0x30,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_permute_matrix_ushort (const gsl_permutation * p, gsl_matrix_ushort * A)
{
  if (A->size2 != p->size)
    {
      do { gsl_error ("matrix columns and permutation must be the same length", "permute_source.c", 170, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      size_t i;
      for (i = 0; i < A->size1; ++i)
        {
          gsl_vector_ushort_view r = gsl_matrix_ushort_row (A, i);
          gsl_permute_vector_ushort (p, &r.vector);
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 5
11 5
12 5
13 5
14 5
15 17
16 5
17 17
18 17
19 17
20 17
21 17
22 10
23 10
24 10
25 10
26 12
27 12
28 12
29 12
30 13
31 13
32 10
33 13
34 10
35 10
36 17
37 15
38 17
39 17
40 17
41 17
42 17
<<<sep_out_sample>>>
mov    $0x9,%ecx
mov    %rdi,%r9
mov    $0x0,%edi
mov    %rsi,%rdx
mov    $0x72,%eax
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %r8b
setb   %cl
cmp    %cl,%r8b
jne    1078 <swverid_get_ver_id_char+0x28>
repz retq 
nopl   (%rax)
mov    $0xd,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x61,%al
seta   %sil
setb   %cl
cmp    %cl,%sil
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0xb,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x76,%al
seta   %sil
setb   %cl
cmp    %cl,%sil
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0x9,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x6c,%al
seta   %sil
setb   %cl
cmp    %cl,%sil
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0xa,%ecx
mov    %rdx,%rsi
mov    $0x0,%edi
repz cmpsb %es:(%rdi),%ds:(%rsi)
mov    $0x71,%al
seta   %sil
setb   %cl
cmp    %cl,%sil
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0x4,%ecx
mov    $0x0,%edi
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %cl
sub    %ecx,%eax
movsbl %al,%eax
test   %eax,%eax
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %rdx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    1159 <swverid_get_ver_id_char+0x109>
mov    $0x0,%edi
mov    $0x5,%ecx
mov    %r9,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %al
setb   %dl
sub    %edx,%eax
movsbl %al,%eax
test   %eax,%eax
je     1073 <swverid_get_ver_id_char+0x23>
mov    $0x0,%edi
mov    $0xd,%ecx
mov    %r9,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
setne  %al
movzbl %al,%eax
neg    %eax
retq   
or     $0xffffffff,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
swverid_get_ver_id_char(char * object, char * attr_name)
{
 if (!strcmp(attr_name, "revision")) {
  return (*("r"));
 }
 else if (!strcmp(attr_name, "architecture")) {
  return (*("a"));
 }
 else if (!strcmp(attr_name, "vendor_tag")) {
  return (*("v"));
 }
 else if (!strcmp(attr_name, "location")) {
  return (*("l"));
 }
 else if (!strcmp(attr_name, "qualifier")) {
  return (*("q"));
 }
 else if (!strcmp(attr_name, "tag")) {
  return 0;
 }
 else if (!strcmp(attr_name, "path")) {
  if (!strcmp(object, "file") || !strcmp(object, "distribution"))
   return 0;
  else
   return -1;
 }
 else {
  return -1;
 }
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 2
5 4
6 3
7 3
8 3
9 3
10 3
11 30
12 30
13 6
14 6
15 6
16 6
17 7
18 6
19 6
20 6
21 6
22 9
23 9
24 9
25 9
26 10
27 9
28 9
29 9
30 9
31 12
32 12
33 12
34 12
35 13
36 12
37 12
38 12
39 12
40 15
41 15
42 15
43 15
44 16
45 15
46 15
47 15
48 15
49 18
50 18
51 18
52 18
53 18
54 18
55 18
56 18
57 18
58 18
59 21
60 21
61 21
62 21
63 21
64 22
65 22
66 22
67 22
68 22
69 22
70 22
71 22
72 22
73 22
74 22
75 22
76 22
77 22
78 22
79 22
80 22
81 22
82 28
83 30
84 30
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    $0x1005,%eax
mov    %rdi,%rbx
je     16a <mu_registrar_get_iterator+0x3a>
mov    $0x0,%edi
callq  148 <mu_registrar_get_iterator+0x18>
mov    0x0(%rip),%rdi        # 14f <mu_registrar_get_iterator+0x1f>
test   %rdi,%rdi
je     170 <mu_registrar_get_iterator+0x40>
mov    %rbx,%rsi
callq  15c <mu_registrar_get_iterator+0x2c>
mov    $0x0,%edi
mov    %eax,%ebx
callq  168 <mu_registrar_get_iterator+0x38>
mov    %ebx,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  17a <mu_registrar_get_iterator+0x4a>
test   %eax,%eax
jne    16a <mu_registrar_get_iterator+0x3a>
mov    0x0(%rip),%rdi        # 185 <mu_registrar_get_iterator+0x55>
jmp    154 <mu_registrar_get_iterator+0x24>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_registrar_get_iterator (mu_iterator_t *pitr)
{
  int status = 0;
  if (pitr == ((void *)0))
    return (0x1000 +5);
  mu_monitor_wrlock (&registrar_monitor);
  if (registrar_list == ((void *)0))
    {
      status = mu_list_create (&registrar_list);
      if (status)
 return status;
    }
  status = mu_list_get_iterator (registrar_list, pitr);
  mu_monitor_unlock (&registrar_monitor);
  return status;
}
<<<sep_in_sample>>>
1 4
2 2
3 5
4 2
5 4
6 6
7 6
8 7
9 7
10 7
11 13
12 13
13 14
14 13
15 14
16 14
17 16
18 16
19 16
20 9
21 9
22 10
23 10
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %r15
mov    %r9,%r15
push   %r14
mov    %rdi,%r14
lea    0x20(%rdi),%rdi
push   %r13
push   %r12
mov    %r8,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
mov    0x40(%rsp),%r13
mov    %r13,%r9
callq  50 <omac_update>
mov    %r13,0x40(%rsp)
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
mov    %rbp,%rsi
mov    %r12,%r8
lea    0x30(%r14),%rcx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
mov    %r15,%r9
mov    $0x10,%edx
pop    %r15
jmpq   30b <nettle_eax_decrypt+0x5b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_eax_decrypt (struct eax_ctx *eax, const struct eax_key *key,
      const void *cipher, nettle_cipher_func *f,
      size_t length, uint8_t *dst, const uint8_t *src)
{
  omac_update (&eax->omac_message, key, cipher, f, length, src);
  nettle_ctr_crypt (cipher, f, 16, eax->ctr.b, length, dst, src);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 5
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 6
18 7
19 6
20 7
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 6
29 6
30 7
31 6
32 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     6c0 <gsasl_server_callback_external_get+0x10>
mov    0xa8(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_external_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_external : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rdx
mov    %r9,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x10(%rbx),%r8
mov    (%rbx),%rsi
mov    0x8(%rdi),%rdi
callq  cf <polynomial_deriv+0x1f>
mov    0x8(%rbx),%rax
movsd  0x8(%rax),%xmm0
xor    %eax,%eax
movsd  %xmm0,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
polynomial_deriv (const void *vstate,
                  const double xa[], const double ya[], size_t size, double x,
                  gsl_interp_accel * acc, double *y)
{
  const polynomial_state_t *state = (const polynomial_state_t *) vstate;
  gsl_poly_dd_taylor (state->coeff, x, state->d, xa, size, state->work);
  *y = state->coeff[1];
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 9
14 7
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
xor    %edx,%edx
xor    %esi,%esi
xor    %edi,%edi
jmpq   8b <mbtowc_reset+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbtowc_reset(void)
{
    do { if (mbtowc(((void *)0), ((void *)0), 0)) {} } while(0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %r9,(%rsp)
mov    $0xffffffff,%r9d
callq  803 <gsl_wavelet2d_nstransform_inverse+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_wavelet2d_nstransform_inverse (const gsl_wavelet * w,
                                  double *data, size_t tda, size_t size1,
                                  size_t size2, gsl_wavelet_workspace * work)
{
  return gsl_wavelet2d_nstransform (w, data, tda, size1, size2, gsl_wavelet_backward, work);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 6
6 6
7 6
<<<sep_out_sample>>>
sub    $0x1e,%edi
xor    %eax,%eax
cmp    $0x11,%edi
ja     12 <findColorName+0x12>
mov    0x0(,%rdi,8),%rax
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findColorName(int c)
{
  switch(c)
  {
    case(30):case(40): return "BLACK  "; break;
    case(31):case(41): return "RED    "; break;
    case(32):case(42): return "GREEN  "; break;
    case(33):case(43): return "BROWN  "; break;
    case(34):case(44): return "BLUE   "; break;
    case(35):case(45): return "MAGENTA"; break;
    case(36):case(46): return "CYAN   "; break;
    case(37):case(47): return "WHITE  "; break;
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 15
7 15
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    0xb8(%rsi),%rdx
mov    0x30(%rsi),%rsi
mov    0x20(%rax),%rax
jmpq   *%rax
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multilarge_nlinear_rcond (double * rcond, const gsl_multilarge_nlinear_workspace * w)
{
  int status = (w->type->rcond) (rcond, w->JTJ, w->state);
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%eax
cmp    $0x1,%eax
je     330 <gc_hash_read+0x30>
cmp    $0x2,%eax
jne    328 <gc_hash_read+0x28>
lea    0x8(%rdi),%rbx
add    $0xb8,%rdi
mov    %rbx,%rsi
callq  320 <gc_hash_read+0x20>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
lea    0x8(%rdi),%rbx
add    $0x1c,%rdi
mov    %rbx,%rsi
callq  340 <gc_hash_read+0x40>
mov    %rbx,%rax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gc_hash_read (gc_hash_handle handle)
{
  _gc_hash_ctx *ctx = handle;
  const char *ret = ((void *)0);
  switch (ctx->alg)
    {
    case GC_MD5:
      md5_finish_ctx (&ctx->md5Context, ctx->hash);
      ret = ctx->hash;
      break;
    case GC_SHA1:
      sha1_finish_ctx (&ctx->sha1Context, ctx->hash);
      ret = ctx->hash;
      break;
    default:
      return ((void *)0);
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 12
8 12
9 12
10 12
11 13
12 19
13 19
14 19
15 16
16 19
17 19
18 19
19 8
20 8
21 8
22 8
23 9
24 19
25 19
26 19
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    0xc(%rsi),%eax
mov    %eax,%ecx
or     $0x1,%ecx
mov    %ecx,0xc(%rsi)
mov    0x8(%rsi),%esi
cmp    $0x4c,%esi
je     5958 <_jit_patch_at+0x58>
cmp    $0xab,%esi
jne    5940 <_jit_patch_at+0x40>
mov    %rdx,0x10(%rbx)
mov    0x28(%rdx),%rax
mov    %rax,0x28(%rbx)
mov    %rbx,0x28(%rdx)
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rdx,0x8(%rsp)
callq  594a <_jit_patch_at+0x4a>
mov    0x8(%rsp),%rdx
jmp    5923 <_jit_patch_at+0x23>
nopl   0x0(%rax)
mov    0x8(%rdx),%ecx
mov    %rdx,0x18(%rbx)
test   %ecx,%ecx
jne    5927 <_jit_patch_at+0x27>
or     $0x5,%eax
mov    %eax,0xc(%rbx)
jmp    5927 <_jit_patch_at+0x27>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_patch_at(jit_state_t *_jit, jit_node_t *instr, jit_node_t *label)
{
    jit_int32_t mask;
    ((void) (0));
    instr->flag |= 0x00000001;
    switch (instr->code) {
 case jit_code_movi:
     ((void) (0))
                                  ;
     instr->v.n = label;
     if (label->code == jit_code_data)
  instr->flag |= 0x00000004;
     break;
 case jit_code_jmpi:
     ((void) (0))
                                    ;
     instr->u.n = label;
     break;
 default:
     mask = _jit_classify(_jit, instr->code);
     ((void) (0));
     ((void) (0));
     instr->u.n = label;
     break;
    }
    instr->link = label->link;
    label->link = instr;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 23
14 26
15 26
16 27
17 28
18 28
19 28
20 28
21 28
22 20
23 23
24 23
25 23
26 11
27 10
28 11
29 11
30 12
31 12
32 12
33 12
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  139 <dico_full_file_name+0x19>
test   %rax,%rax
mov    %rax,%r12
je     200 <dico_full_file_name+0xe0>
cmpb   $0x2f,-0x1(%r14,%rax,1)
setne  %bpl
movzbl %bpl,%r15d
movzbl %bpl,%ebp
mov    %rbx,%rdi
callq  15f <dico_full_file_name+0x3f>
lea    0x2(%rbp,%r12,1),%rdi
add    %rax,%rdi
callq  16c <dico_full_file_name+0x4c>
test   %rax,%rax
mov    %rax,%rbp
je     22d <dico_full_file_name+0x10d>
lea    0x1(%r12),%r13
mov    %r14,%rsi
mov    %rax,%rdi
mov    %r13,%rdx
callq  18b <dico_full_file_name+0x6b>
test   %r15d,%r15d
jne    220 <dico_full_file_name+0x100>
test   %r12,%r12
je     1c3 <dico_full_file_name+0xa3>
cmpb   $0x2f,-0x1(%rbp,%r12,1)
lea    -0x1(%r12),%rcx
je     1be <dico_full_file_name+0x9e>
jmp    1d4 <dico_full_file_name+0xb4>
nopl   0x0(%rax,%rax,1)
cmpb   $0x2f,-0x1(%rbp,%rcx,1)
lea    -0x1(%rcx),%rdx
jne    210 <dico_full_file_name+0xf0>
mov    %rdx,%rcx
test   %rcx,%rcx
jne    1b0 <dico_full_file_name+0x90>
cmpb   $0x2f,(%rbx)
mov    $0x1,%r13d
jne    1d9 <dico_full_file_name+0xb9>
xchg   %ax,%ax
add    $0x1,%rbx
cmpb   $0x2f,(%rbx)
je     1d0 <dico_full_file_name+0xb0>
lea    0x0(%rbp,%r13,1),%rdi
mov    %rbx,%rsi
callq  1e6 <dico_full_file_name+0xc6>
mov    %rbp,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x1,%ebp
mov    $0x1,%r15d
jmpq   157 <dico_full_file_name+0x37>
lea    0x1(%rcx),%r13
jmp    1d4 <dico_full_file_name+0xb4>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x2f,%eax
mov    %ax,0x0(%rbp,%r12,1)
jmp    1d4 <dico_full_file_name+0xb4>
xor    %eax,%eax
jmp    1e9 <dico_full_file_name+0xc9>
<<<sep_in_sample>>>
dico_full_file_name(const char *dir, const char *file)
{
    size_t dirlen = strlen(dir);
    int need_slash = !(dirlen && dir[dirlen - 1] == '/');
    size_t size = dirlen + need_slash + 1 + strlen(file) + 1;
    char *buf = malloc(size);
    if (!buf)
 return ((void *)0);
    strcpy(buf, dir);
    if (need_slash)
 strcpy(buf + dirlen++, "/");
    else {
 while (dirlen > 0 && buf[dirlen-1] == '/')
     dirlen--;
 dirlen++;
    }
    while (*file == '/')
 file++;
    strcpy(buf + dirlen, file);
    return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 3
13 4
14 4
15 4
16 4
17 4
18 5
19 5
20 5
21 5
22 6
23 7
24 6
25 7
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 17
47 13
48 17
49 17
50 18
51 17
52 17
53 19
54 19
55 19
56 20
57 21
58 21
59 21
60 21
61 21
62 21
63 21
64 21
65 21
66 21
67 4
68 4
69 13
70 13
71 13
72 11
73 11
74 11
75 8
76 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 1053 <uname_to_uid+0x13>
test   %rsi,%rsi
je     1061 <uname_to_uid+0x21>
callq  105d <uname_to_uid+0x1d>
test   %eax,%eax
je     10a5 <uname_to_uid+0x65>
mov    0x0(%rip),%rsi        # 1068 <uname_to_uid+0x28>
test   %rsi,%rsi
je     1074 <uname_to_uid+0x34>
movzbl (%rsi),%eax
cmp    %al,(%rbx)
je     10b0 <uname_to_uid+0x70>
mov    %rbx,%rdi
callq  107c <uname_to_uid+0x3c>
test   %rax,%rax
je     10c0 <uname_to_uid+0x80>
mov    0x10(%rax),%edx
mov    (%rax),%rsi
mov    $0x0,%edi
mov    %edx,0x0(%rip)        # 1092 <uname_to_uid+0x52>
callq  1097 <uname_to_uid+0x57>
mov    0x0(%rip),%eax        # 109d <uname_to_uid+0x5d>
mov    %eax,0x0(%rbp)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  10b8 <uname_to_uid+0x78>
test   %eax,%eax
je     1097 <uname_to_uid+0x57>
jmp    1074 <uname_to_uid+0x34>
xchg   %ax,%ax
mov    %rbx,%rsi
mov    $0x0,%edi
callq  10cd <uname_to_uid+0x8d>
xor    %eax,%eax
jmp    10a5 <uname_to_uid+0x65>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uname_to_uid (char const *uname, uid_t *uidp)
{
  struct passwd *passwd;
  if (cached_no_such_uname
      && strcmp (uname, cached_no_such_uname) == 0)
    return 0;
  if (!cached_uname
      || uname[0] != cached_uname[0]
      || strcmp (uname, cached_uname) != 0)
    {
      passwd = getpwnam (uname);
      if (passwd)
 {
   cached_uid = passwd->pw_uid;
   assign_string (&cached_uname, passwd->pw_name);
 }
      else
 {
   assign_string (&cached_no_such_uname, uname);
   return 0;
 }
    }
  *uidp = cached_uid;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 7
13 7
14 7
15 8
16 8
17 8
18 11
19 11
20 12
21 12
22 14
23 15
24 15
25 14
26 15
27 23
28 23
29 24
30 25
31 25
32 25
33 25
34 25
35 9
36 9
37 9
38 9
39 9
40 9
41 19
42 19
43 19
44 20
45 20
46 20
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
imul   (%rdi),%rdx
test   %rdx,%rdx
je     2f <gsl_histogram2d_sum+0x2f>
mov    0x20(%rdi),%rax
xorpd  %xmm0,%xmm0
lea    (%rax,%rdx,8),%rdx
nopl   0x0(%rax)
addsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rdx,%rax
jne    20 <gsl_histogram2d_sum+0x20>
repz retq 
xorpd  %xmm0,%xmm0
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_sum (const gsl_histogram2d * h)
{
  const size_t n = h->nx * h->ny;
  double sum = 0;
  size_t i = 0;
  while (i < n)
    sum += h->bin[i++];
  return sum;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 4
7 4
8 4
9 7
10 7
11 6
12 6
13 6
14 4
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a9 <_rl_abort_internal+0x9>
callq  ae <_rl_abort_internal+0xe>
callq  b3 <_rl_abort_internal+0x13>
callq  b8 <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # c3 <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # cb <_rl_abort_internal+0x2b>
je     df <_rl_abort_internal+0x3f>
nopl   (%rax)
callq  d5 <_rl_abort_internal+0x35>
cmpq   $0x0,0x0(%rip)        # dd <_rl_abort_internal+0x3d>
jne    d0 <_rl_abort_internal+0x30>
mov    $0x1,%esi
mov    $0x0,%edi
andq   $0xffffffffffdfffff,0x0(%rip)        # f4 <_rl_abort_internal+0x54>
movq   $0x0,0x0(%rip)        # ff <_rl_abort_internal+0x5f>
callq  104 <_rl_abort_internal+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 8
12 8
13 12
14 12
15 10
16 11
17 12
18 12
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1a10 <gsl_vector_int_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a2f <gsl_vector_int_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_const_view_array (const int * base, size_t n)
{
  _gsl_vector_int_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = (int *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     33f9 <argp_state_help+0x69>
mov    0x1c(%rdi),%eax
test   $0x2,%al
jne    33e0 <argp_state_help+0x50>
test   %rsi,%rsi
je     33e0 <argp_state_help+0x50>
mov    %ebp,%edx
mov    0x40(%rbx),%r8
mov    (%rbx),%rdi
or     $0x80,%dl
test   $0x40,%al
cmovne %edx,%ebp
mov    %rsi,%rdx
mov    %rbx,%rsi
mov    %ebp,%ecx
callq  1fc0 <_help>
testb  $0x20,0x1c(%rbx)
jne    33e0 <argp_state_help+0x50>
test   $0x100,%ebp
jne    33ee <argp_state_help+0x5e>
and    $0x200,%ebp
jne    33e7 <argp_state_help+0x57>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xor    %edi,%edi
callq  33ee <argp_state_help+0x5e>
mov    0x0(%rip),%edi        # 33f4 <argp_state_help+0x64>
callq  33f9 <argp_state_help+0x69>
test   %rsi,%rsi
je     33e0 <argp_state_help+0x50>
mov    0x0(%rip),%r8        # 3405 <argp_state_help+0x75>
mov    %rsi,%rdx
mov    %ebp,%ecx
xor    %esi,%esi
xor    %edi,%edi
callq  1fc0 <_help>
jmp    33d0 <argp_state_help+0x40>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)
{
  if ((!state || ! (state->flags & 0x02)) && stream)
    {
      if (state && (state->flags & 0x40))
        flags |= 0x80;
      _help (state ? state->root_argp : 0, state, stream, flags,
             state ? state->name : (program_invocation_short_name));
      if (!state || ! (state->flags & 0x20))
        {
          if (flags & 0x100)
            exit (argp_err_exit_status);
          if (flags & 0x200)
            exit (0);
        }
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 6
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 9
24 9
25 11
26 11
27 13
28 13
29 17
30 17
31 17
32 17
33 14
34 14
35 12
36 12
37 3
38 3
39 7
40 7
41 7
42 7
43 7
44 7
45 7
46 7
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 16f7 <ppdget_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdget_text (void)
{
        return ppdtext;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    0x30(%rdi),%rbp
mov    %rdi,%rbx
cmp    %rbp,0x38(%rdi)
je     a78 <gl_array_nx_add_first+0x48>
test   %rbp,%rbp
mov    0x28(%rbx),%rdx
mov    %rbp,%rax
je     a5f <gl_array_nx_add_first+0x2f>
mov    -0x8(%rdx,%rax,8),%rcx
mov    %rcx,(%rdx,%rax,8)
sub    $0x1,%rax
jne    a50 <gl_array_nx_add_first+0x20>
add    $0x1,%rbp
mov    %r12,(%rdx)
mov    $0x1,%eax
mov    %rbp,0x30(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
lea    0x38(%rdi),%rsi
lea    0x28(%rdi),%rdi
callq  730 <grow.isra.2>
test   %eax,%eax
jns    a44 <gl_array_nx_add_first+0x14>
xor    %eax,%eax
jmp    a6f <gl_array_nx_add_first+0x3f>
<<<sep_in_sample>>>
gl_array_nx_add_first (gl_list_t list, const void *elt)
{
  size_t count = list->count;
  const void **elements;
  size_t i;
  if (count == list->allocated)
    if (grow (list) < 0)
      return ((void *)0);
  elements = list->elements;
  for (i = count; i > 0; i--)
    elements[i] = elements[i - 1];
  elements[0] = elt;
  list->count = count + 1;
  return (gl_list_node_t)(unsigned long)(size_t)((0) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 6
8 6
9 10
10 9
11 10
12 10
13 11
14 11
15 10
16 10
17 13
18 12
19 14
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 7
29 7
30 7
31 8
32 8
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
sub    0x8(%rdx),%rax
mov    (%rsi),%rcx
sub    (%rdx),%rcx
test   %rax,%rax
mov    %rax,0x8(%rdi)
mov    %rcx,(%rdi)
js     2140 <tvsub+0x20>
repz retq 
nopl   0x0(%rax)
sub    $0x1,%rcx
add    $0xf4240,%rax
mov    %rcx,(%rdi)
mov    %rax,0x8(%rdi)
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tvsub (struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
{
  tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
  tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
  if (tdiff->tv_usec < 0)
    tdiff->tv_sec--, tdiff->tv_usec += 1000000;
}
<<<sep_in_sample>>>
1 4
2 4
3 3
4 3
5 5
6 4
7 3
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
lea    0x0(,%rsi,8),%ecx
jmpq   56c <nettle_arctwo_set_key+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_arctwo_set_key (struct arctwo_ctx *ctx, size_t length, const uint8_t *key)
{
  nettle_arctwo_set_key_ekb (ctx, length, key, 8 * length);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1106 <gsl_vector_char_set+0x6>
test   %eax,%eax
je     110f <gsl_vector_char_set+0xf>
cmp    %rsi,(%rdi)
jbe    1120 <gsl_vector_char_set+0x20>
imul   0x8(%rdi),%rsi
mov    0x10(%rdi),%rax
mov    %dl,(%rax,%rsi,1)
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   1139 <gsl_vector_char_set+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_char_set (gsl_vector_char * v, const size_t i, char x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_char.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 5
12 5
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
mov    0x30(%rsi),%rsi
mov    0x30(%rdi),%rdi
jmpq   56d <compare_ref+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
compare_ref(const void *a, void *b)
{
    struct gcide_ref const *aref = a;
    struct gcide_ref const *bref = b;
    return utf8_strcasecmp(aref->ref_headword, bref->ref_headword);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%r13d        # 5c5 <removeCutDir+0x15>
test   %r13d,%r13d
jne    5e0 <removeCutDir+0x30>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rbp
mov    %rbp,%rdi
callq  5f3 <removeCutDir+0x43>
mov    0x0(%rip),%r15        # 5fa <removeCutDir+0x4a>
mov    %rax,%r14
mov    %r15,%rdi
callq  605 <removeCutDir+0x55>
lea    0x2(%r14,%rax,1),%rdi
mov    %rax,%rbx
callq  612 <removeCutDir+0x62>
test   %rax,%rax
mov    %rax,%r12
je     6d0 <removeCutDir+0x120>
mov    %rbx,%rdx
mov    %r15,%rsi
mov    %rax,%rdi
callq  62c <removeCutDir+0x7c>
lea    0x1(%r12,%rbx,1),%rdi
lea    0x1(%r14),%rdx
mov    %rbp,%rsi
movb   $0x2f,(%r12,%rbx,1)
callq  642 <removeCutDir+0x92>
test   %r13d,%r13d
jle    6b5 <removeCutDir+0x105>
sub    $0x1,%r13d
xor    %ebx,%ebx
mov    %r13d,%r14d
add    $0x1,%r14
jmp    669 <removeCutDir+0xb9>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%rbx
cmp    %r14,%rbx
je     6b5 <removeCutDir+0x105>
mov    0x0(,%rbx,8),%rsi
mov    %r12,%rdi
movslq %ebx,%rbp
callq  67c <removeCutDir+0xcc>
test   %eax,%eax
jne    660 <removeCutDir+0xb0>
cmp    %r13d,%ebp
jl     693 <removeCutDir+0xe3>
jmp    6ae <removeCutDir+0xfe>
nopw   0x0(%rax,%rax,1)
movslq %edx,%rbp
lea    0x1(%rbp),%edx
movslq %edx,%rax
cmp    %r13d,%edx
mov    0x0(,%rax,8),%rax
mov    %rax,0x0(,%rbp,8)
jne    690 <removeCutDir+0xe0>
mov    %r13d,0x0(%rip)        # 6b5 <removeCutDir+0x105>
add    $0x8,%rsp
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   6cb <removeCutDir+0x11b>
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x1,%edx
mov    $0x1,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
mov    $0x0,%edi
jmpq   6f2 <removeCutDir+0x142>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
removeCutDir(int i)
{
  if(numCutDirs == 0) return;
  int j, k;
  char *str = (char *) malloc(strlen(dirs[i])+strlen(cwd)+2);
  if(!str) { msgBox("Insufficient memory", 1, ERROR); return; }
  strcpy(str, cwd);
  strcat(str, "/");
  strcat(str, dirs[i]);
  strcat(str, "\0");
  for(j = 0; j < numCutDirs; j++)
  {
    if(strcmp(str, cutDirs[j]) == 0)
    {
      for(k = j; k < numCutDirs-1; k++)
      {
 cutDirs[k] = cutDirs[k+1];
      }
      numCutDirs--;
      free(str);
      return;
    }
  }
  free(str);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 3
10 3
11 25
12 25
13 25
14 25
15 25
16 25
17 25
18 25
19 25
20 5
21 5
22 5
23 5
24 5
25 5
26 5
27 5
28 5
29 5
30 5
31 6
32 5
33 6
34 7
35 7
36 7
37 7
38 9
39 9
40 9
41 8
42 9
43 11
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 11
52 11
53 11
54 13
55 13
56 13
57 13
58 13
59 13
60 15
61 15
62 15
63 15
64 15
65 17
66 17
67 15
68 17
69 17
70 15
71 19
72 25
73 24
74 25
75 25
76 25
77 25
78 25
79 25
80 24
81 24
82 25
83 6
84 6
85 25
86 25
87 25
88 25
89 25
90 25
91 6
92 6
93 6
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     19a1 <gsl_matrix_uint_fwrite+0x91>
lea    0x0(,%r15,4),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    195e <gsl_matrix_uint_fwrite+0x4e>
jmp    1990 <gsl_matrix_uint_fwrite+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     1990 <gsl_matrix_uint_fwrite+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  1975 <gsl_matrix_uint_fwrite+0x65>
test   %eax,%eax
je     1950 <gsl_matrix_uint_fwrite+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   19c4 <gsl_matrix_uint_fwrite+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_fwrite (FILE * stream, const gsl_matrix_uint * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uint_raw_fwrite (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uint_raw_fwrite (stream,
                                                     m->data + i * 1 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
sub    $0x88,%rsp
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  402 <nettle_openssl_des_is_weak_key+0x12>
test   %eax,%eax
sete   %al
add    $0x88,%rsp
movzbl %al,%eax
retq   
<<<sep_in_sample>>>
nettle_openssl_des_is_weak_key(des_cblock *key)
{
  struct des_ctx ctx;
  return !nettle_des_set_key(&ctx, *key);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 4
9 5
<<<sep_out_sample>>>
mov    0x58(%rdi),%rdi
jmpq   389 <name_hash+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
name_hash (void const *entry, size_t n_buckets)
{
  struct name const *name = entry;
  return hash_string (name->caname, n_buckets);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %esi,%ecx
mov    $0x0,%edx
lea    0x8(%rsp),%r8
mov    $0x0,%esi
movq   $0x0,0x8(%rsp)
callq  80 <find_lsn_recurse>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
iso9660_find_fs_lsn(CdIo_t *p_cdio, lsn_t i_lsn)
{
  char *psz_full_filename = ((void *)0);
  return find_lsn_recurse (p_cdio, (iso9660_readdir_t *) iso9660_fs_readdir,
      "/", i_lsn, &psz_full_filename);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 3
7 4
8 6
9 6
10 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   43d <read_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
read_error (char const *name)
{
  call_arg_error ("read", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1d0 <osip_uri_get_port+0x10>
mov    0x20(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_uri_get_port (osip_uri_t * url)
{
  if (url == ((void *)0))
    return ((void *)0);
  return url->port;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 197 <echoc+0x7>
cmp    0x0(%rip),%rax        # 19e <echoc+0xe>
push   %rbx
mov    %edi,%ebx
jb     1b6 <echoc+0x26>
xor    %esi,%esi
mov    $0x0,%edi
callq  1af <echoc+0x1f>
mov    0x0(%rip),%rax        # 1b6 <echoc+0x26>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 1c1 <echoc+0x31>
mov    %bl,(%rax)
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echoc(int c)
{
        do { if (outbuf->curp >= outbuf->endp) __strbuf_expandbuf(outbuf, 0); *outbuf->curp++ = c;} while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 2
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
15 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rax
mov    %rsi,%rbx
mov    0x10(%rax),%rdx
test   %rdx,%rdx
je     118 <opitr_destroy+0x28>
sub    $0x1,%rdx
mov    %rbx,%rdi
mov    %rdx,0x10(%rax)
callq  110 <opitr_destroy+0x20>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
callq  127 <opitr_destroy+0x37>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  136 <opitr_destroy+0x46>
mov    %rbx,%rdi
callq  13e <opitr_destroy+0x4e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
opitr_destroy (mu_iterator_t iterator, void *data)
{
  struct opool_iterator *itr = data;
  if (itr->opool->itr_count == 0)
    {
      mu_error (dgettext ("mailutils", "%s: INTERNAL ERROR: zero reference count"),
  "opool_destroy");
    }
  else
    itr->opool->itr_count--;
  free (data);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 10
8 11
9 10
10 11
11 13
12 13
13 13
14 13
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 11
23 11
24 13
25 13
26 13
27 13
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1656 <yyset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_lineno (int line_number )
{
    yylineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   1483 <gsl_sort_vector_short_smallest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_short_smallest (short * dest, const size_t k,
                                     const gsl_vector_short * v)
{
  return gsl_sort_short_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
subl   $0x1,0x14(%rdi)
jne    2b88 <headerFree+0x58>
mov    0x8(%rdi),%eax
xor    %ebp,%ebp
xor    %ebx,%ebx
test   %eax,%eax
jle    2b6c <headerFree+0x3c>
nopl   0x0(%rax,%rax,1)
mov    (%r12),%rax
add    $0x1,%ebx
mov    0x10(%rax,%rbp,1),%rdi
add    $0x20,%rbp
callq  2b65 <headerFree+0x35>
cmp    %ebx,0x8(%r12)
jg     2b50 <headerFree+0x20>
mov    (%r12),%rdi
callq  2b75 <headerFree+0x45>
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
jmpq   2b81 <headerFree+0x51>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
headerFree(Header h)
{
    int i;
    if (--h->usageCount) return;
    for (i = 0; i < h->indexUsed; i++)
 free(h->index[i].data);
    free(h->index);
                         free(h);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 5
15 6
16 6
17 6
18 5
19 5
20 7
21 7
22 9
23 9
24 8
25 9
26 8
27 8
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
push   %rbx
mov    0xa8(%rdi),%eax
mov    %rdi,%rbx
test   %eax,%eax
jne    130 <poly1305_pad+0x10>
pop    %rbx
retq   
lea    0x98(%rdi,%rax,1),%rdi
mov    $0x10,%edx
xor    %esi,%esi
sub    %eax,%edx
callq  146 <poly1305_pad+0x26>
lea    0x98(%rbx),%rsi
lea    0x40(%rbx),%rdi
mov    $0x1,%edx
callq  15b <poly1305_pad+0x3b>
movl   $0x0,0xa8(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
poly1305_pad (struct chacha_poly1305_ctx *ctx)
{
  if (ctx->index)
    {
      memset (ctx->block + ctx->index, 0,
       16 - ctx->index);
      _nettle_poly1305_block(&ctx->poly1305, ctx->block, 1);
      ctx->index = 0;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 10
7 10
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 7
16 7
17 8
18 10
19 10
20 10
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 9ca <set_print0+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_print0(void)
{
 newline = '\0';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  251 <scram_print_server_final+0x11>
test   %al,%al
je     280 <scram_print_server_final+0x40>
mov    (%rbx),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %rbp,%rdi
callq  267 <scram_print_server_final+0x27>
test   %eax,%eax
jle    280 <scram_print_server_final+0x40>
xor    %eax,%eax
cmpq   $0x0,0x0(%rbp)
sete   %al
add    $0x8,%rsp
pop    %rbx
neg    %eax
pop    %rbp
retq   
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
scram_print_server_final (struct scram_server_final *sl, char **out)
{
  int n;
  if (!scram_valid_server_final (sl))
    return -1;
  n = asprintf (out, "v=%s", sl->verifier);
  if (n <= 0 || *out == ((void *)0))
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 7
22 10
23 10
24 10
25 10
26 5
27 10
28 10
29 10
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x18,%rsp
mov    (%rsi),%rbp
mov    0x8(%rsi),%r12
test   %rbp,%rbp
jne    19f9 <gsl_block_fscanf+0x29>
jmp    1a50 <gsl_block_fscanf+0x80>
nopl   (%rax)
add    $0x1,%rbx
cmp    %rbp,%rbx
je     1a50 <gsl_block_fscanf+0x80>
lea    0x8(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  1a0d <gsl_block_fscanf+0x3d>
movsd  0x8(%rsp),%xmm0
cmp    $0x1,%eax
movsd  %xmm0,(%r12,%rbx,8)
je     19f0 <gsl_block_fscanf+0x20>
mov    $0x5,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a37 <gsl_block_fscanf+0x67>
add    $0x18,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_block_fscanf (FILE * stream, gsl_block * b)
{
  size_t n = b->size ;
  double * data = b->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          double tmp ;
          int status = fscanf (stream, "%lg", &tmp) ;
          data [1 * i + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 90, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 3
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 12
18 12
19 12
20 12
21 12
22 13
23 14
24 13
25 14
26 16
27 16
28 16
29 16
30 16
31 21
32 16
33 21
34 21
35 21
36 21
37 21
38 21
39 21
40 20
41 21
42 21
43 21
44 21
45 21
46 21
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
mov    %rdx,%rsi
mov    %rcx,%rdx
push   %rbx
mov    %rcx,%rbx
sub    $0x8,%rsp
callq  1a <AAllocColor+0x1a>
test   %eax,%eax
je     3e <AAllocColor+0x3e>
mov    0x1820(%rbp),%rdx
mov    (%rbx),%rcx
mov    %rcx,0x1020(%rbp,%rdx,8)
mov    %rdx,(%rbx)
add    $0x1,%rdx
mov    %rdx,0x1820(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
AAllocColor(AWindow *a, Display *display, Colormap colormap, XColor *c)
{
 int result;
 result = XAllocColor (display, colormap, c);
 if (result) {
  a->color_to_pixel_map[a->color_to_pixel_map_top] = c->pixel;
  c->pixel = a->color_to_pixel_map_top;
  a->color_to_pixel_map_top++;
 }
 return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 2
9 4
10 5
11 5
12 6
13 6
14 6
15 7
16 8
17 8
18 11
19 11
20 11
21 11
<<<sep_out_sample>>>
push   %rbx
mov    0x38(%rdi),%rax
mov    %esi,%edx
and    $0x7fff,%edx
mov    $0x3,%esi
mov    0x78(%rax),%rax
lea    (%rax,%rdx,8),%rbx
callq  4c5f <_jit_save+0x1f>
mov    %rax,(%rbx)
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_save(jit_state_t *_jit, jit_int32_t reg)
{
    reg = ((reg) & 0x00007fff);
    ((void) (0));
    _jit->comp->spill[reg] = _jit_new_node_w(_jit,jit_code_save,reg);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%esi
mov    $0x0,%edi
sub    $0x10,%rsp
callq  7f6 <close_all+0x14>
lea    0xf(%rsp),%rdi
callq  800 <close_all+0x1e>
mov    0x0(%rip),%rax        # 807 <close_all+0x25>
mov    0xe0(%rax),%edi
cmp    $0xffffffff,%edi
je     828 <close_all+0x46>
callq  817 <close_all+0x35>
mov    0x0(%rip),%rax        # 81e <close_all+0x3c>
movl   $0xffffffff,0xe0(%rax)
mov    0x0(%rip),%rbx        # 82f <close_all+0x4d>
test   %rbx,%rbx
je     852 <close_all+0x70>
mov    0x10(%rbx),%rax
test   %rax,%rax
je     84c <close_all+0x6a>
mov    (%rbx),%edi
cmp    $0xffffffff,%edi
je     84c <close_all+0x6a>
callq  *%rax
movl   $0xffffffff,(%rbx)
mov    0x28(%rbx),%rbx
jmp    82f <close_all+0x4d>
callq  857 <close_all+0x75>
xor    %edi,%edi
callq  85e <close_all+0x7c>
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
close_all()
{
 _Bool stdio_problem;
 struct command_source *cs;
 (void) nextfile(& curfile, 1);
 (void) close_io(& stdio_problem);
 if (cur_srcfile->fd != (-1)) {
  close(cur_srcfile->fd);
  cur_srcfile->fd = (-1);
 }
 for (cs = cmd_src; cs != ((void *)0); cs = cs->next) {
  if (cs->close_func && cs->fd != (-1)) {
   cs->close_func(cs->fd);
   cs->fd = (-1);
  }
 }
 close_extensions();
 set_gawk_output(((void *)0));
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 5
6 6
7 6
8 7
9 7
10 7
11 7
12 8
13 9
14 9
15 11
16 11
17 11
18 12
19 12
20 12
21 12
22 12
23 12
24 13
25 14
26 11
27 11
28 17
29 18
30 18
31 19
32 19
33 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     11c0 <gsl_permute_vector_long+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  11b5 <gsl_permute_vector_long+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  11d1 <gsl_permute_vector_long+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_long (const gsl_permutation * p, gsl_vector_long * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_long (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
movsbl (%rsi),%eax
mov    %rsi,%rbx
test   %al,%al
je     2c0 <strbuf_puts_withterm+0x60>
mov    %rdi,%rbp
mov    %edx,%r12d
jmp    299 <strbuf_puts_withterm+0x39>
nopw   %cs:0x0(%rax,%rax,1)
lea    0x1(%rax),%rcx
add    $0x1,%rbx
mov    %rcx,0x18(%rbp)
movzbl -0x1(%rbx),%ecx
mov    %cl,(%rax)
movsbl (%rbx),%eax
test   %al,%al
je     2c0 <strbuf_puts_withterm+0x60>
cmp    %r12d,%eax
je     2c0 <strbuf_puts_withterm+0x60>
mov    0x18(%rbp),%rax
cmp    0x10(%rbp),%rax
jb     280 <strbuf_puts_withterm+0x20>
xor    %esi,%esi
mov    %rbp,%rdi
callq  2b2 <strbuf_puts_withterm+0x52>
mov    0x18(%rbp),%rax
jmp    280 <strbuf_puts_withterm+0x20>
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strbuf_puts_withterm(STRBUF *sb, const char *s, int c)
{
 while (*s && *s != c) {
  if (sb->curp >= sb->endp)
   __strbuf_expandbuf(sb, 0);
  *sb->curp++ = *s++;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 6
13 6
14 6
15 6
16 6
17 3
18 3
19 3
20 3
21 3
22 4
23 4
24 4
25 5
26 5
27 5
28 5
29 5
30 5
31 8
32 8
33 8
34 8
35 8
<<<sep_out_sample>>>
movzbl (%rdi),%eax
cmp    $0x2f,%al
je     2b8b <filename_is_safe+0x7b>
test   %al,%al
je     2b5f <filename_is_safe+0x4f>
nopl   0x0(%rax,%rax,1)
cmp    $0x2e,%al
je     2b68 <filename_is_safe+0x58>
test   %al,%al
je     2b57 <filename_is_safe+0x47>
cmp    $0x2f,%al
jne    2b3c <filename_is_safe+0x2c>
nopl   0x0(%rax)
jmp    2b57 <filename_is_safe+0x47>
nopw   0x0(%rax,%rax,1)
test   %al,%al
je     2b57 <filename_is_safe+0x47>
add    $0x1,%rdi
movzbl (%rdi),%eax
cmp    $0x2f,%al
jne    2b38 <filename_is_safe+0x28>
cmp    $0x2f,%al
jne    2b17 <filename_is_safe+0x7>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rdi
movzbl (%rdi),%eax
cmp    $0x2f,%al
je     2b50 <filename_is_safe+0x40>
test   %al,%al
jne    2b20 <filename_is_safe+0x10>
mov    $0x1,%eax
retq   
nopl   (%rax)
movzbl 0x1(%rdi),%eax
cmp    $0x2e,%al
je     2b76 <filename_is_safe+0x66>
add    $0x1,%rdi
jmp    2b24 <filename_is_safe+0x14>
movzbl 0x2(%rdi),%eax
lea    0x2(%rdi),%rdx
test   %al,%al
je     2b8b <filename_is_safe+0x7b>
cmp    $0x2f,%al
je     2b8b <filename_is_safe+0x7b>
mov    %rdx,%rdi
jmp    2b3c <filename_is_safe+0x2c>
xor    %eax,%eax
nopl   (%rax)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filename_is_safe (char const *name)
{
  if (((((name)[0]) == '/') || 0 != 0))
    return 0;
  while (*name)
    {
      if (*name == '.' && *++name == '.'
   && ( ! *++name || ((*name) == '/')))
 return 0;
      while (*name && ! ((*name) == '/'))
 name++;
      while (((*name) == '/'))
 name++;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 7
8 7
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 11
19 10
20 10
21 10
22 12
23 12
24 12
25 13
26 12
27 12
28 12
29 5
30 5
31 15
32 15
33 15
34 7
35 7
36 7
37 7
38 7
39 8
40 8
41 8
42 8
43 8
44 8
45 8
46 8
47 4
48 4
49 16
50 16
<<<sep_out_sample>>>
mov    (%rdi),%edx
mov    %rsi,%rax
mov    %edx,(%rsi)
mov    0x4(%rdi),%edx
mov    %edx,0x4(%rsi)
mov    0x8(%rdi),%edx
mov    %edx,0x8(%rsi)
mov    0xc(%rdi),%edx
mov    %edx,0xc(%rsi)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_md5_read_ctx (const struct mu_md5_ctx *ctx, void *resbuf)
{
  ((uint32_t *) resbuf)[0] = (ctx->A);
  ((uint32_t *) resbuf)[1] = (ctx->B);
  ((uint32_t *) resbuf)[2] = (ctx->C);
  ((uint32_t *) resbuf)[3] = (ctx->D);
  return resbuf;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 8
11 8
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     f00 <mu_udp_server_get_rdata+0x10>
cmpl   $0x1,0x18(%rdi)
je     f08 <mu_udp_server_get_rdata+0x18>
repz retq 
nopw   0x0(%rax,%rax,1)
mov    0x50(%rdi),%rax
mov    %rax,(%rsi)
mov    0x60(%rdi),%rax
mov    %rax,(%rdx)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_udp_server_get_rdata (mu_ip_server_t srv, char **pbuf, size_t *pbufsize)
{
  if (!srv || srv->type != 1)
    return 22;
  *pbuf = srv->v.udp_data.buf;
  *pbufsize = srv->v.udp_data.rdsize;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 8
7 8
8 5
9 5
10 6
11 6
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 389 <panicn+0x19>
mov    0x0(%rip),%rdi        # 390 <panicn+0x20>
callq  395 <panicn+0x25>
mov    0x0(%rip),%rdi        # 39c <panicn+0x2c>
mov    %ebp,%edx
mov    %rbx,%rsi
xor    %eax,%eax
callq  3a8 <panicn+0x38>
mov    0x0(%rip),%rsi        # 3af <panicn+0x3f>
mov    $0xa,%edi
callq  3b9 <panicn+0x49>
mov    $0x1,%edi
callq  3c3 <panicn+0x53>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panicn (const char *fmt, int n)
{
  fprintf (stderr, "%s panic: ", progname);
  fprintf (stderr, fmt, n);
  fprintf (stderr, "\n");
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 2
8 3
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 5
17 5
18 5
19 6
20 6
21 6
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cgst_preloop(const void * vtrust_state, void * vstate)
{
  (void)vtrust_state;
  (void)vstate;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movb   $0x0,0x20(%rdi)
retq   
<<<sep_in_sample>>>
digest_md5_free_finish (digest_md5_finish * f)
{
  memset (f, 0, sizeof (*f));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
mpfr_unset(NODE *n)
{
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
movl   $0x2a,0x678(%rdi)
retq   
<<<sep_in_sample>>>
crasher (unsigned long p)
{
  *(volatile int *) (p + 0x678) = 42;
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <osip_uri_init+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x50,%edi
test   %rax,%rax
je     80 <osip_uri_init+0x80>
callq  *%rax
test   %rax,%rax
mov    %rax,(%rbx)
je     90 <osip_uri_init+0x90>
movq   $0x0,(%rax)
mov    (%rbx),%rax
movq   $0x0,0x8(%rax)
mov    (%rbx),%rax
movq   $0x0,0x10(%rax)
mov    (%rbx),%rax
movq   $0x0,0x18(%rax)
mov    (%rbx),%rax
movq   $0x0,0x20(%rax)
mov    (%rbx),%rax
lea    0x28(%rax),%rdi
callq  5e <osip_uri_init+0x5e>
mov    (%rbx),%rax
lea    0x38(%rax),%rdi
callq  6a <osip_uri_init+0x6a>
mov    (%rbx),%rax
movq   $0x0,0x48(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  85 <osip_uri_init+0x85>
jmp    17 <osip_uri_init+0x17>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffc,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_uri_init (osip_uri_t ** url)
{
  *url = (osip_uri_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_uri_t)):malloc(sizeof (osip_uri_t)));
  if (*url == ((void *)0))
    return -4;
  (*url)->scheme = ((void *)0);
  (*url)->username = ((void *)0);
  (*url)->password = ((void *)0);
  (*url)->host = ((void *)0);
  (*url)->port = ((void *)0);
  osip_list_init (&(*url)->url_params);
  osip_list_init (&(*url)->url_headers);
  (*url)->string = ((void *)0);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 3
10 4
11 6
12 7
13 7
14 8
15 8
16 9
17 9
18 10
19 10
20 11
21 11
22 11
23 12
24 12
25 12
26 13
27 13
28 14
29 15
30 15
31 15
32 3
33 3
34 3
35 5
36 15
37 15
38 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  405 <emit_bug_reporting_address+0x15>
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  41b <emit_bug_reporting_address+0x2b>
mov    0x0(%rip),%rcx        # 422 <emit_bug_reporting_address+0x32>
mov    $0x3f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   43a <emit_bug_reporting_address+0x4a>
<<<sep_in_sample>>>
emit_bug_reporting_address (void)
{
  printf (((const char *) ("\nReport bugs to: %s\n")), "bug-m4@gnu.org");
  printf (((const char *) ("%s home page: <%s>\n")), "GNU M4", "http://www.gnu.org/software/m4/");
  fputs_unlocked (((const char *) ("General help using GNU software: <http://www.gnu.org/gethelp/>\n")),stdout)
                ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 7
16 5
<<<sep_out_sample>>>
movzbl 0xaa(%rdi),%eax
shr    $0x4,%al
and    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
term_ostream__get_underline (term_ostream_t stream)
{
  return stream->curr_attr.underline;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x80,%edi
callq  e <swc0_create_parser_buffer+0xe>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 18 <swc0_create_parser_buffer+0x18>
je     1f <swc0_create_parser_buffer+0x1f>
add    $0x8,%rsp
retq   
mov    0x0(%rip),%rcx        # 26 <swc0_create_parser_buffer+0x26>
mov    $0x0,%edi
mov    $0xf,%edx
mov    $0x1,%esi
callq  3a <swc0_create_parser_buffer+0x3a>
mov    $0x1,%edi
callq  44 <swc0_create_parser_buffer+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc0_create_parser_buffer() {
 yylval.strb = strob_open(128);
 if (!yylval.strb) {
  fprintf (stderr,"out of memory.\n");
  exit(1);
 }
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 3
5 2
6 3
7 7
8 7
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
<<<sep_out_sample>>>
movslq 0x126c(%rdi),%rax
imul   $0x3a8,%rax,%rax
add    0x0(%rip),%rax        # 1bb5 <dis_getBeamCount+0x15>
mov    0x290(%rax),%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     1bd8 <dis_getBeamCount+0x38>
cmpb   $0x0,0x29(%rdx)
je     1bd8 <dis_getBeamCount+0x38>
mov    0x30(%rdx),%rax
movzbl 0x1(%rax),%eax
retq   
nopw   0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dis_getBeamCount(craft * c)
{
 if (entities[c->disId].em && entities[c->disId].em->em.num_systems > 0) {
  return entities[c->disId].em->em.system[0].num_beams;
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 7
15 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    (%rdi),%rcx
mov    0x10(%rdi),%rdx
lea    0x0(,%rax,8),%r8
xor    %eax,%eax
test   %rcx,%rcx
je     233f <gsl_vector_long_set_all+0x2f>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
mov    %rsi,(%rdx)
add    %r8,%rdx
cmp    %rcx,%rax
jne    2330 <gsl_vector_long_set_all+0x20>
repz retq 
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_set_all (gsl_vector_long * v, long x)
{
  long * const data = v->data;
  const size_t n = v->size;
  const size_t stride = v->stride;
  size_t i;
  for (i = 0; i < n; i++)
    {
      *(long *) (data + 1 * i * stride) = x;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 7
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 480 <ask+0x10>
mov    %rbp,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  48f <ask+0x1f>
callq  494 <ask+0x24>
mov    %eax,%ebx
nopw   %cs:0x0(%rax,%rax,1)
callq  4a5 <ask+0x35>
cmp    $0xa,%eax
jne    4a0 <ask+0x30>
mov    %ebx,%eax
and    $0xfffffff7,%eax
cmp    $0x71,%eax
jne    4c8 <ask+0x58>
xor    %eax,%eax
cmp    $0x79,%ebx
sete   %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rcx        # 4cf <ask+0x5f>
mov    $0x12,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  4e3 <ask+0x73>
jmp    479 <ask+0x9>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ask(char *question)
{
  int c;
  do {
    fprintf(stderr, "%s? [y/q] ", question);
    c = getchar();
    while (getchar() != '\n')
      ;
    if (c != 'y' && c != 'q')
      fprintf(stderr, "Invalid response. ");
  } while (c != 'y' && c != 'q');
  return (c == 'y');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 7
16 9
17 9
18 9
19 9
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
shr    $0x3,%rax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
member_file_hash_1 (void const *key)
{
  do { unsigned long result = 0; do { (result) += ((unsigned long)((((unsigned long)(((struct member_file const *) key)->mf_link)) >> 3))); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_self (self)
     SHELL_VAR *self;
{
  return (self);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
<<<sep_out_sample>>>
movslq %esi,%rsi
sub    %rsi,0x10(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_rewind (rec_buf_t buf, int n)
{
  if ((buf->used - n) >= 0)
    {
      buf->used = buf->used - n;
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
push   %r12
cmpq   $0x0,0x0(%rip)        # 104a <pp_open+0xa>
push   %rbp
mov    %rdi,%rbp
push   %rbx
je     1058 <pp_open+0x18>
xor    %eax,%eax
callq  1058 <pp_open+0x18>
mov    0x0(%rip),%rdi        # 105f <pp_open+0x1f>
callq  1064 <pp_open+0x24>
mov    %rbp,%rdi
mov    %rax,%rbx
callq  106f <pp_open+0x2f>
mov    0x0(%rip),%rdi        # 1076 <pp_open+0x36>
lea    0x2(%rbx,%rax,1),%rbx
test   %rdi,%rdi
je     1088 <pp_open+0x48>
callq  1085 <pp_open+0x45>
add    %rax,%rbx
mov    %rbx,%rdi
callq  1090 <pp_open+0x50>
mov    0x0(%rip),%rsi        # 1097 <pp_open+0x57>
mov    %rax,%rdi
mov    %rax,%rbx
callq  10a2 <pp_open+0x62>
mov    0x0(%rip),%rsi        # 10a9 <pp_open+0x69>
test   %rsi,%rsi
je     10b6 <pp_open+0x76>
mov    %rax,%rdi
callq  10b6 <pp_open+0x76>
mov    %rbx,%rdi
callq  10be <pp_open+0x7e>
lea    0x1(%rbx,%rax,1),%rdi
movb   $0x20,(%rbx,%rax,1)
mov    %rbp,%rsi
callq  10cf <pp_open+0x8f>
mov    0x0(%rip),%eax        # 10d5 <pp_open+0x95>
test   %eax,%eax
jne    1100 <pp_open+0xc0>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  10e6 <pp_open+0xa6>
test   %rax,%rax
mov    %rax,%rbp
je     1120 <pp_open+0xe0>
mov    %rbx,%rdi
callq  10f6 <pp_open+0xb6>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
mov    $0x0,%edi
callq  110a <pp_open+0xca>
mov    0x0(%rip),%rdi        # 1111 <pp_open+0xd1>
mov    %rax,%rsi
mov    %rbx,%rdx
xor    %eax,%eax
callq  111e <pp_open+0xde>
jmp    10d9 <pp_open+0x99>
mov    $0x0,%edi
callq  112a <pp_open+0xea>
mov    %rax,%r12
callq  1132 <pp_open+0xf2>
mov    (%rax),%esi
mov    %rbx,%rcx
mov    %r12,%rdx
xor    %eax,%eax
xor    %edi,%edi
callq  1143 <pp_open+0x103>
mov    %rbx,%rdi
callq  114b <pp_open+0x10b>
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pp_open(const char *name)
{
     FILE *fp;
     char *s;
     size_t size;
     if (opt_stack)
   pp_finalize();
     size = strlen(pp_bin) + 1 + strlen(name) + 1;
     if (pp_opts)
   size += strlen(pp_opts);
     s = xmalloc(size);
     strcpy(s, pp_bin);
     if (pp_opts)
   strcat(s, pp_opts);
     strcat(s, " ");
     strcat(s, name);
     if (debug)
   fprintf(stderr, gettext("Command line: %s\n"), s);
     fp = popen(s, "r");
     if (!fp)
   error(0, (*__errno_location ()), gettext("cannot execute `%s'"), s);
     free(s);
     return fp;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 6
7 7
8 7
9 8
10 8
11 8
12 8
13 8
14 9
15 8
16 9
17 9
18 10
19 10
20 11
21 11
22 12
23 12
24 11
25 12
26 13
27 13
28 13
29 14
30 14
31 15
32 15
33 16
34 15
35 16
36 16
37 17
38 17
39 17
40 19
41 19
42 19
43 20
44 19
45 20
46 22
47 22
48 24
49 24
50 24
51 24
52 24
53 24
54 18
55 18
56 18
57 18
58 18
59 18
60 18
61 18
62 21
63 21
64 21
65 21
66 21
67 21
68 21
69 21
70 21
71 21
72 22
73 22
74 24
75 24
76 24
77 24
78 24
79 24
<<<sep_out_sample>>>
add    $0x28,%rdi
jmpq   9 <nettle_ccm_aes128_set_key+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key)
{
  nettle_aes128_set_encrypt_key(&ctx->cipher, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %rbx
and    $0x1,%esi
mov    %rdi,%rbx
shl    $0x2,%esi
sub    $0x8,%rsp
movzbl 0xaa(%rdi),%eax
movzbl 0x82(%rdi),%r9d
movzbl 0x81(%rdi),%r8d
movzbl 0x80(%rdi),%ecx
movzbl 0x79(%rdi),%edx
and    $0xfffffffb,%eax
or     %esi,%eax
movzbl 0x78(%rdi),%esi
mov    %al,0xaa(%rdi)
mov    0xa8(%rbx),%eax
mov    0x1c(%rdi),%edi
mov    %eax,(%rsp)
callq  1570 <simplify_attributes.isra.1>
mov    %eax,0xac(%rbx)
add    $0x8,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
term_ostream__set_weight (term_ostream_t stream, term_weight_t weight)
{
  stream->curr_attr.weight = weight;
  stream->simp_attr = simplify_attributes (stream, stream->curr_attr);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 3
7 4
8 4
9 4
10 4
11 3
12 3
13 4
14 3
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 5
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_index (rec_sex_ast_node_t node)
{
  return node->index;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  7f <gettext_quote+0xf>
mov    $0x0,%esi
mov    %rax,%rdi
mov    %rax,%rbx
callq  8f <gettext_quote+0x1f>
test   %eax,%eax
jne    b0 <gettext_quote+0x40>
cmpb   $0x60,0x0(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bd <gettext_quote+0x4d>
test   %eax,%eax
jne    e0 <gettext_quote+0x70>
cmpb   $0x60,0x0(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
cmp    $0x7,%r12d
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbp
cmovne %rdx,%rax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gettext_quote (char const *msgid, enum quoting_style s)
{
  char const *translation = ((const char *) (msgid));
  char const *locale_code;
  if (translation != msgid)
    return translation;
  locale_code = locale_charset ();
  if ((c_strcasecmp (locale_code, "UTF-8") == 0))
    return msgid[0] == '`' ? "\xe2\x80\x98": "\xe2\x80\x99";
  if ((c_strcasecmp (locale_code, "GB18030") == 0))
    return msgid[0] == '`' ? "\xa1\ae": "\xa1\xaf";
  return (s == clocale_quoting_style ? "\"" : "'");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 8
8 8
9 7
10 8
11 8
12 8
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 13
21 13
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 13
31 13
32 13
33 11
34 13
35 13
36 13
37 12
38 12
39 12
40 13
41 12
42 13
43 13
44 13
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    %rsi,0x38(%rax)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahs_set_filesize(AHS * xhs, intmax_t filesize) {
 ;
        ahs_vfile_hdr(xhs)->c_filesize = (uintmax_t)filesize;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
jmpq   7b9 <swicat_sc_add_sr+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swicat_sc_add_sr(SWICAT_SC * swicat_sc, SWICAT_SR * swicat_sr)
{
 vplob_add(swicat_sc->srM, swicat_sr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x10,%edi
ja     119 <cdio_is_discmode_cdrom+0x19>
mov    $0x1,%eax
mov    %edi,%ecx
shl    %cl,%rax
test   $0x1000f,%eax
setne  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_is_discmode_cdrom(discmode_t discmode)
{
  switch (discmode) {
  case CDIO_DISC_MODE_CD_DA:
  case CDIO_DISC_MODE_CD_DATA:
  case CDIO_DISC_MODE_CD_XA:
  case CDIO_DISC_MODE_CD_MIXED:
  case CDIO_DISC_MODE_NO_INFO:
    return 1;
  default:
    return 0;
  }
}
<<<sep_in_sample>>>
1 11
2 11
3 11
4 11
5 11
6 11
7 11
8 11
9 13
10 13
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
push   %r15
mov    %rdx,%r15
push   %r14
mov    %rsi,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    0x10(%rdi),%rbp
mov    (%rdi),%r12
mov    0x8(%rdi),%r13
movsd  0x0(%rbp),%xmm2
test   %r12,%r12
movapd %xmm2,%xmm1
je     5ba <gsl_vector_minmax+0x9a>
shl    $0x3,%r13
movapd %xmm2,%xmm3
add    %r13,%rbp
movapd %xmm2,%xmm1
xor    %ebx,%ebx
jmp    589 <gsl_vector_minmax+0x69>
add    $0x1,%rbx
movsd  0x10(%rsp),%xmm3
cmp    %r12,%rbx
movsd  0x18(%rsp),%xmm2
je     5d8 <gsl_vector_minmax+0xb8>
movsd  0x0(%rbp),%xmm1
add    %r13,%rbp
movapd %xmm1,%xmm5
minsd  %xmm2,%xmm5
movapd %xmm5,%xmm2
movapd %xmm1,%xmm4
movapd %xmm1,%xmm0
movsd  %xmm1,0x8(%rsp)
maxsd  %xmm3,%xmm4
movsd  %xmm2,0x18(%rsp)
movsd  %xmm4,0x10(%rsp)
callq  5ac <gsl_vector_minmax+0x8c>
test   %eax,%eax
movsd  0x8(%rsp),%xmm1
je     560 <gsl_vector_minmax+0x40>
movapd %xmm1,%xmm2
movsd  %xmm2,(%r14)
movsd  %xmm1,(%r15)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
movapd %xmm3,%xmm1
jmp    5ba <gsl_vector_minmax+0x9a>
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_minmax (const gsl_vector * v,
                             double * min_out,
                             double * max_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  double max = v->data[0 * stride];
  double min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      double x = v->data[i*stride];
      if (x < min)
        {
          min = x;
        }
      if (x > max)
        {
          max = x;
        }
      if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
        {
          min = x;
          max = x;
          break;
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 7
11 5
12 6
13 7
14 10
15 7
16 10
17 10
18 7
19 7
20 12
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 12
29 12
30 12
31 12
32 12
33 12
34 21
35 21
36 21
37 21
38 21
39 21
40 21
41 21
42 21
43 21
44 28
45 29
46 30
47 30
48 30
49 30
50 30
51 30
52 30
53 30
54 30
55 30
56 30
57 30
<<<sep_out_sample>>>
ucomisd %xmm2,%xmm0
jae    60 <gsl_ran_pareto_pdf+0x10>
xorpd  %xmm0,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm0
sub    $0x18,%rsp
movapd %xmm1,%xmm3
movsd  %xmm2,0x8(%rsp)
addsd  0x0(%rip),%xmm1        # 7a <gsl_ran_pareto_pdf+0x2a>
movsd  %xmm3,(%rsp)
callq  84 <gsl_ran_pareto_pdf+0x34>
movsd  (%rsp),%xmm3
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
add    $0x18,%rsp
divsd  %xmm2,%xmm3
movapd %xmm3,%xmm0
divsd  %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_ran_pareto_pdf (const double x, const double a, const double b)
{
  if (x >= b)
    {
      double p = (a/b) / pow (x/b, a + 1);
      return p;
    }
  else
    {
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 10
4 10
5 10
6 5
7 2
8 2
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 12
17 5
18 5
19 5
20 12
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
mov    0x8(%rdi),%rax
jne    cf9 <gsl_matrix_float_equal+0x19>
mov    0x8(%rsi),%rdx
cmp    %rax,%rdx
je     d20 <gsl_matrix_float_equal+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d12 <gsl_matrix_float_equal+0x32>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %rcx,%rcx
mov    0x10(%rdi),%r8
mov    0x10(%rsi),%rax
je     d87 <gsl_matrix_float_equal+0xa7>
lea    0x0(,%r8,4),%r12
lea    0x0(,%rax,4),%rbp
xor    %r11d,%r11d
xor    %r10d,%r10d
xor    %ebx,%ebx
test   %rdx,%rdx
je     d78 <gsl_matrix_float_equal+0x98>
mov    %r10,%r9
mov    %r11,%r8
add    0x18(%rdi),%r9
add    0x18(%rsi),%r8
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movss  (%r9,%rax,4),%xmm0
ucomiss (%r8,%rax,4),%xmm0
jp     d8e <gsl_matrix_float_equal+0xae>
jne    d8e <gsl_matrix_float_equal+0xae>
add    $0x1,%rax
cmp    %rdx,%rax
jne    d60 <gsl_matrix_float_equal+0x80>
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %rcx,%rbx
jne    d45 <gsl_matrix_float_equal+0x65>
mov    $0x1,%eax
jmp    d14 <gsl_matrix_float_equal+0x34>
xor    %eax,%eax
jmp    d14 <gsl_matrix_float_equal+0x34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_equal (const gsl_matrix_float * a, const gsl_matrix_float * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 1; k++)
                {
                  if (a->data[(i * tda_a + j) * 1 + k]
                      != b->data[(i * tda_b + j) * 1 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 30
18 30
19 30
20 30
21 30
22 14
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 16
32 16
33 16
34 16
35 16
36 16
37 16
38 16
39 20
40 20
41 20
42 20
43 16
44 16
45 16
46 14
47 14
48 14
49 14
50 14
51 29
52 29
53 23
54 23
55 23
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    %rsi,%rbx
lea    0x1(%rbx),%edi
callq  18 <get_sha1+0x18>
mov    %ebx,%edx
mov    %rax,(%r12)
mov    %rbp,%rsi
mov    %rax,%rdi
mov    %rdx,%rcx
rep movsb %ds:(%rsi),%es:(%rdi)
movb   $0x0,(%rax,%rdx,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
get_sha1(char **sha1, char const *start, char const *end)
{
  unsigned int len = end - start;
  *sha1 = xmalloc (len + 1);
  memcpy (*sha1, start, len);
  (*sha1)[len] = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 6
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6c6 <NextToken+0x6>
test   %eax,%eax
jne    6d0 <NextToken+0x10>
jmpq   50 <ReadToken>
nop
sub    $0x18,%rsp
mov    %rdx,%rdi
movl   $0x0,0x0(%rip)        # 6e1 <NextToken+0x21>
movsd  0x0(%rip),%xmm0        # 6e9 <NextToken+0x29>
mov    %rcx,(%rsp)
mov    %r8,0x8(%rsp)
movsd  %xmm0,(%rsi)
mov    $0x0,%esi
callq  700 <NextToken+0x40>
mov    0x8(%rsp),%r8
mov    $0x0,%esi
mov    %r8,%rdi
callq  712 <NextToken+0x52>
mov    0x0(%rip),%eax        # 718 <NextToken+0x58>
mov    (%rsp),%rcx
mov    %eax,(%rcx)
mov    0x0(%rip),%eax        # 724 <NextToken+0x64>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
NextToken(FILE * f, double *fp_value, char *cp_value, int * code, char *string)
{
    if (lookahead_valid) {
  lookahead_valid = 0;
  *fp_value = fp_la;
  strcpy(cp_value, cp_la);
  strcpy(string, string_la);
  *code = code_la;
  return token_id_la;
 }
    else {
  return ReadToken(f, fp_value, cp_value, code, string);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 12
5 12
6 2
7 6
8 4
9 5
10 5
11 5
12 5
13 6
14 6
15 7
16 7
17 7
18 7
19 8
20 8
21 8
22 9
23 14
24 14
25 14
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
test   %rbp,%rbp
movzbl (%r8),%edi
je     27e2 <gsl_matrix_char_max_index+0x62>
xor    %r10d,%r10d
xor    %r11d,%r11d
xor    %ebx,%ebx
nopl   0x0(%rax)
test   %r9,%r9
je     27cb <gsl_matrix_char_max_index+0x4b>
xor    %eax,%eax
nop
movzbl (%r8,%rax,1),%ecx
cmp    %dil,%cl
jle    27c2 <gsl_matrix_char_max_index+0x42>
mov    %rax,%r11
mov    %r10,%rbx
mov    %ecx,%edi
add    $0x1,%rax
cmp    %r9,%rax
jne    27b0 <gsl_matrix_char_max_index+0x30>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
jne    27a8 <gsl_matrix_char_max_index+0x28>
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_max_index (const gsl_matrix_char * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  char max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          char x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 6
6 4
7 5
8 9
9 6
10 9
11 9
12 7
13 7
14 7
15 11
16 11
17 11
18 11
19 13
20 14
21 14
22 14
23 14
24 14
25 11
26 11
27 11
28 9
29 9
30 9
31 9
32 22
33 23
34 24
35 24
36 24
37 24
38 7
39 7
40 22
41 23
42 24
43 24
44 24
45 24
46 24
<<<sep_out_sample>>>
mov    %rdi,%rsi
xor    %edx,%edx
mov    $0x2,%edi
jmpq   ef <restore_signal_mask+0xf>
nop
<<<sep_in_sample>>>
restore_signal_mask (set)
     sigset_t *set;
{
  return (sigprocmask (2, set, (sigset_t *)((void *)0)));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1b17 <mu_cfg_lexer_pool+0x7>
movq   $0x0,0x0(%rip)        # 1b22 <mu_cfg_lexer_pool+0x12>
retq   
<<<sep_in_sample>>>
mu_cfg_lexer_pool ()
{
  mu_opool_t p = pool;
  pool = ((void *)0);
  return p;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
test   %edi,%edi
jne    1c0 <tty_setsofttab+0x10>
andl   $0xffffe7ff,0x0(%rip)        # 1be <tty_setsofttab+0xe>
retq   
nop
orl    $0x1800,0x0(%rip)        # 1ca <tty_setsofttab+0x1a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_setsofttab (int on)
{
  if (on)
    {
      termbuf.c_oflag &= ~0014000;
      termbuf.c_oflag |= 0014000;
    }
  else
    {
      termbuf.c_oflag &= ~0014000;
      termbuf.c_oflag |= 0000000;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 10
4 10
5 10
6 6
7 6
8 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6b6 <gsl_matrix_long_double_set+0x6>
fldt   0x8(%rsp)
test   %eax,%eax
je     6c9 <gsl_matrix_long_double_set+0x19>
cmp    %rsi,(%rdi)
jbe    6e0 <gsl_matrix_long_double_set+0x30>
cmp    %rdx,0x8(%rdi)
jbe    700 <gsl_matrix_long_double_set+0x50>
imul   0x10(%rdi),%rsi
add    %rsi,%rdx
shl    $0x4,%rdx
add    0x18(%rdi),%rdx
fstpt  (%rdx)
retq   
nopl   0x0(%rax)
fstp   %st(0)
mov    $0x4,%ecx
mov    $0x129,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   6fb <gsl_matrix_long_double_set+0x4b>
nopl   0x0(%rax,%rax,1)
fstp   %st(0)
mov    $0x4,%ecx
mov    $0x12d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   71b <gsl_matrix_long_double_set+0x6b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_set(gsl_matrix_long_double * m, const size_t i, const size_t j, const long double x)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_long_double.h", 297, GSL_EINVAL) ; return ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_long_double.h", 301, GSL_EINVAL) ; return ; } while (0) ;
        }
    }
  m->data[i * m->tda + j] = x ;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 14
14 14
15 14
16 14
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 5507 <next_step+0x7>
je     5530 <next_step+0x30>
test   %rdi,%rdi
je     5514 <next_step+0x14>
cmpl   $0x2b,0x8(%rdi)
je     5550 <next_step+0x50>
movl   $0x1,0x0(%rip)        # 551e <next_step+0x1e>
mov    %esi,0x0(%rip)        # 5524 <next_step+0x24>
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0x0,%edi
callq  553e <next_step+0x3e>
mov    %rax,%rdi
xor    %eax,%eax
callq  5548 <next_step+0x48>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
mov    0x10(%rdi),%rax
mov    %esi,0x0(%rip)        # 555a <next_step+0x5a>
mov    %eax,0x0(%rip)        # 5560 <next_step+0x60>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
next_step(CMDARG *arg, int cmd)
{
 do { if (! prog_running) { d_error(gettext("program not running.")); return 0; } } while (0);
 if (arg != ((void *)0) && arg->type == D_int)
  stop.repeat_count = arg->value.lval;
 else
  stop.repeat_count = 1;
 stop.command = cmd;
 return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 7
8 8
9 9
10 9
11 9
12 2
13 3
14 3
15 3
16 3
17 3
18 3
19 10
20 10
21 10
22 5
23 8
24 5
25 9
26 9
27 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    0x18(%rsi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
<<<sep_in_sample>>>
__gmp_randinit_set (gmp_randstate_ptr dst, gmp_randstate_srcptr src)
{
  (*((gmp_randfnptr_t *) ((src)->_mp_algdata._mp_lc))->randiset_fn) (dst, src);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <__rerror+0x9>
mov    0x0(%rip),%rdi        # 10 <__rerror+0x10>
mov    0x0(%rip),%rdx        # 17 <__rerror+0x17>
mov    %rbx,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  26 <__rerror+0x26>
mov    $0x1,%edi
callq  30 <__rerror+0x30>
<<<sep_in_sample>>>
__rerror (char *s)
{
  __rprintfilline ();
  (void) fprintf (stderr, "%s: %s\n", __progname, s);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r13
mov    %rdi,%r13
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  2b7 <chown_error_details+0x17>
mov    (%rax),%ebx
mov    0x0(%rip),%rax        # 2c0 <chown_error_details+0x20>
test   %rax,%rax
je     2c7 <chown_error_details+0x27>
callq  *%rax
mov    %r13,%rdi
callq  2cf <chown_error_details+0x2f>
mov    $0x0,%edi
mov    %rax,%r13
callq  2dc <chown_error_details+0x3c>
mov    %r12d,%r9d
mov    %ebp,%r8d
mov    %r13,%rcx
mov    %rax,%rdx
mov    %ebx,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  2f3 <chown_error_details+0x53>
movl   $0x2,0x0(%rip)        # 2fd <chown_error_details+0x5d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chown_error_details (char const *name, uid_t uid, gid_t gid)
{
  int e = (*__errno_location ());
  do { if (error_hook) error_hook (); error (0, e, gettext ("%s: Cannot change ownership to uid %lu, gid %lu"), quotearg_colon (name), (unsigned long) uid, (unsigned long) gid); exit_status = 2; } while (0)
                                                                    ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 4
29 6
30 6
31 6
32 6
33 6
34 6
35 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     42a <yy_flush_buffer+0x4a>
mov    0x8(%rdi),%rax
movl   $0x0,0x20(%rdi)
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
movl   $0x1,0x2c(%rdi)
movl   $0x0,0x3c(%rdi)
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 418 <yy_flush_buffer+0x38>
test   %rax,%rax
je     42a <yy_flush_buffer+0x4a>
mov    0x0(%rip),%rdx        # 424 <yy_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
je     430 <yy_flush_buffer+0x50>
repz retq 
nopl   0x0(%rax)
jmpq   0 <yy_load_buffer_state>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 6
6 7
7 7
8 8
9 9
10 10
11 8
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  6c1 <xdr_dis_modulation_type+0x11>
test   %eax,%eax
jne    6d0 <xdr_dis_modulation_type+0x20>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x2(%rbp),%rsi
mov    %rbx,%rdi
callq  6dc <xdr_dis_modulation_type+0x2c>
test   %eax,%eax
je     6c5 <xdr_dis_modulation_type+0x15>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  6ec <xdr_dis_modulation_type+0x3c>
test   %eax,%eax
je     6c5 <xdr_dis_modulation_type+0x15>
lea    0x6(%rbp),%rsi
mov    %rbx,%rdi
callq  6fc <xdr_dis_modulation_type+0x4c>
test   %eax,%eax
setne  %al
movzbl %al,%eax
jmp    6c7 <xdr_dis_modulation_type+0x17>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_modulation_type(xdrs, objp)
	XDR *xdrs;
	dis_modulation_type *objp;
{
	if (!xdr_byte_u_short(xdrs, &objp->spread_spectrum)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->major_type)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->detail)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->system)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 18
11 18
12 18
13 18
14 18
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 176a <pict_page+0xa>
xor    %edx,%edx
test   %eax,%eax
jne    17c0 <pict_page+0x60>
mov    0x0(%rip),%rdi        # 1777 <pict_page+0x17>
add    $0x1,%edx
mov    $0x0,%esi
mov    %edx,%ecx
xor    %eax,%eax
mov    %edx,0x0(%rip)        # 1789 <pict_page+0x29>
callq  178e <pict_page+0x2e>
mov    0x0(%rip),%rcx        # 1795 <pict_page+0x35>
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  17a9 <pict_page+0x49>
cmpl   $0x6c,0x0(%rip)        # 17b0 <pict_page+0x50>
je     1808 <pict_page+0xa8>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%rcx        # 17c7 <pict_page+0x67>
mov    $0x3,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  17db <pict_page+0x7b>
mov    0x0(%rip),%rcx        # 17e2 <pict_page+0x82>
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  17f6 <pict_page+0x96>
mov    0x0(%rip),%edx        # 17fc <pict_page+0x9c>
jmpq   1770 <pict_page+0x10>
nopl   0x0(%rax)
mov    0x0(%rip),%ecx        # 180e <pict_page+0xae>
mov    0x0(%rip),%edx        # 1814 <pict_page+0xb4>
mov    $0x0,%esi
mov    0x0(%rip),%r8d        # 1820 <pict_page+0xc0>
mov    0x0(%rip),%rdi        # 1827 <pict_page+0xc7>
xor    %eax,%eax
add    $0x8,%rsp
mov    %ecx,%r9d
add    %ecx,%edx
neg    %r9d
neg    %r8d
jmpq   183d <pict_page+0xdd>
nopl   (%rax)
<<<sep_in_sample>>>
pict_page()
{
  if (pageno)
    {
      fputs("gr\n", pict_out);
      fputs("showpage\n", pict_out);
    }
  pageno++;
  fprintf(pict_out, "%%%%Page: %d %d\n", pageno, pageno);
  fputs("gs\n", pict_out);
  if (orient == 'l')
    fprintf(pict_out, "%d %d tr 90 rot %d %d tr\n", bboxy0 + bboxx1, bboxy0, -bboxx0, -bboxy0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 9
7 8
8 9
9 9
10 9
11 8
12 9
13 10
14 10
15 10
16 10
17 10
18 11
19 11
20 13
21 13
22 13
23 5
24 5
25 5
26 5
27 5
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 12
37 12
38 12
39 12
40 12
41 12
42 13
43 12
44 12
45 12
46 12
47 12
48 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     348 <documentation_print_plain+0x188>
push   %r12
mov    $0x0,%r9d
mov    %rsi,%r12
mov    $0x0,%r8d
mov    $0x0,%ecx
mov    $0x0,%esi
push   %rbp
xor    %eax,%eax
mov    %rdx,%rbp
mov    $0x0,%edx
push   %rbx
sub    $0xe0,%rsp
movq   $0x0,0xd8(%rsp)
movq   $0x0,0xd0(%rsp)
movq   $0x0,0xc8(%rsp)
movq   $0x0,0xc0(%rsp)
movq   $0x0,0xb8(%rsp)
movq   $0x0,0xb0(%rsp)
movq   $0x0,0xa8(%rsp)
movq   $0x0,0xa0(%rsp)
movq   $0x0,0x98(%rsp)
movq   $0x0,0x90(%rsp)
movq   $0x0,0x88(%rsp)
movq   $0x0,0x80(%rsp)
movq   $0x0,0x78(%rsp)
movq   $0x0,0x70(%rsp)
movq   $0x0,0x68(%rsp)
movq   $0x0,0x60(%rsp)
movq   $0x0,0x58(%rsp)
movq   $0x0,0x50(%rsp)
movq   $0x0,0x48(%rsp)
movq   $0x0,0x40(%rsp)
movq   $0x0,0x38(%rsp)
movq   $0x0,0x30(%rsp)
movq   $0x0,0x28(%rsp)
movq   $0x0,0x20(%rsp)
movq   $0x0,0x18(%rsp)
movq   $0x0,0x10(%rsp)
movq   $0x0,0x8(%rsp)
movq   $0x0,(%rsp)
callq  31b <documentation_print_plain+0x15b>
mov    %rbp,%rdi
mov    %rax,%rbx
mov    %rax,%rdx
mov    %r12,%rsi
xor    %eax,%eax
callq  32e <documentation_print_plain+0x16e>
add    $0xe0,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   341 <documentation_print_plain+0x181>
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
documentation_print_plain (const unsigned char * documentation,
      const char *format, FILE * stream)
{
  char *cp;
  if (!documentation)
    return;
  cp = xvstrrpl ((const char *) documentation, "url(", "", ")url(", " (", ")url", ")", "samp(", "`", ")samp", "'", "emph(", "*", ")emph", "*", "code(", "", ")code", "", "@example\n", "", "@end example\n", "", "@end example", "", "@itemize\n", "", "@end itemize", "", "@item\n", " - ", "@@", "@", ((void *)0));
  fprintf (stream, format, cp);
  free (cp);
}
<<<sep_in_sample>>>
1 5
2 5
3 3
4 7
5 7
6 7
7 7
8 7
9 3
10 7
11 7
12 7
13 3
14 3
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 7
37 7
38 7
39 7
40 7
41 7
42 7
43 7
44 8
45 7
46 8
47 8
48 8
49 8
50 10
51 9
52 10
53 10
54 10
55 9
56 9
57 9
58 9
<<<sep_out_sample>>>
lea    0x1(%rsi),%rdx
jmp    4b3 <linecpy+0x23>
nopw   %cs:0x0(%rax,%rax,1)
test   %cl,%cl
je     4c0 <linecpy+0x30>
test   %rdi,%rdi
je     4af <linecpy+0x1f>
mov    %cl,(%rdi)
add    $0x1,%rdi
add    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
lea    -0x1(%rdx),%rax
cmp    $0xa,%cl
jne    4a0 <linecpy+0x10>
test   %rdi,%rdi
je     4c8 <linecpy+0x38>
movb   $0x0,(%rdi)
sub    %rsi,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
linecpy(char *l1, char *l2)
{
  char *start;
  start = l2;
  while (*l2 && *l2 != '\n')
    {
      if (l1)
 *l1++ = *l2++;
      else
 l2++;
    }
  if (l1)
    *l1 = '\0';
  return l2 - start;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 7
7 7
8 8
9 8
10 8
11 5
12 5
13 5
14 5
15 12
16 12
17 13
18 14
19 15
20 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <hash_string_compare+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string_compare (void const *name1, void const *name2)
{
  return strcmp (name1, name2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
movsd  (%rdi),%xmm1
cmp    $0x1,%rdx
subsd  %xmm0,%xmm1
mulsd  %xmm1,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
jbe    15b <gsl_stats_lag1_autocorrelation_m+0x8b>
shl    $0x3,%rsi
fldz   
mov    $0x1,%eax
lea    (%rdi,%rsi,1),%rcx
jmp    12f <gsl_stats_lag1_autocorrelation_m+0x5f>
nopl   (%rax)
movsd  (%rdi),%xmm1
add    %rsi,%rcx
add    %rsi,%rdi
cmp    %rdx,%rax
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fmul   %st(2),%st
fsub   %st(3),%st
fdiv   %st(1),%st
faddp  %st,%st(3)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(3),%st
fdivp  %st,%st(1)
faddp  %st,%st(2)
je     160 <gsl_stats_lag1_autocorrelation_m+0x90>
movsd  (%rcx),%xmm1
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
test   %rax,%rax
subsd  %xmm0,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fildll -0x18(%rsp)
jns    100 <gsl_stats_lag1_autocorrelation_m+0x30>
fadds  0x0(%rip)        # 159 <gsl_stats_lag1_autocorrelation_m+0x89>
jmp    100 <gsl_stats_lag1_autocorrelation_m+0x30>
fldz   
nopl   (%rax)
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_lag1_autocorrelation_m (const double data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 7
3 6
4 6
5 6
6 6
7 7
8 7
9 5
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 7
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 12
29 12
30 7
31 10
32 11
33 11
34 11
35 10
36 10
37 10
38 11
39 11
40 11
41 11
42 5
43 5
44 14
45 15
46 15
47 16
48 16
<<<sep_out_sample>>>
movzbl 0x19(%rdx),%eax
mov    %rcx,%r10
mov    %eax,%ecx
and    $0xf,%ecx
cmp    $0xc,%cl
ja     35 <CDB___db_pgin+0x35>
mov    $0x1,%r8d
shl    %cl,%r8
test   $0x12f8,%r8d
jne    48 <CDB___db_pgin+0x48>
test   $0x105,%r8d
jne    60 <CDB___db_pgin+0x60>
test   $0xc00,%r8d
jne    50 <CDB___db_pgin+0x50>
movzbl %al,%edx
mov    $0x0,%esi
jmpq   42 <CDB___db_pgin+0x42>
nopw   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   50 <CDB___db_pgin+0x50>
mov    %r10,%rcx
jmpq   58 <CDB___db_pgin+0x58>
nopl   0x0(%rax,%rax,1)
mov    %r10,%rcx
jmpq   68 <CDB___db_pgin+0x68>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_pgin(dbenv, pg, pp, cookie)
 DB_ENV *dbenv;
 db_pgno_t pg;
 void *pp;
 DBT *cookie;
{
 switch (((((PAGE *)pp)->type) & 0x0f)) {
 case 2:
 case 8:
 case 0:
  return (CDB___ham_pgin(dbenv, pg, pp, cookie));
 case 9:
 case 3:
 case 4:
 case 5:
 case 12:
 case 6:
 case 7:
  return (CDB___bam_pgin(dbenv, pg, pp, cookie));
 case 10:
 case 11:
  return (CDB___qam_pgin_out(dbenv, pg, pp, cookie));
 default:
  break;
 }
 return (CDB___db_unknown_type(dbenv, "CDB___db_pgin", ((PAGE *)pp)->type));
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 26
16 26
17 26
18 26
19 19
20 19
21 22
22 22
23 22
24 11
25 11
26 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
callq  3ee9 <my_cot+0x9>
ucomisd 0x0(%rip),%xmm0        # 3ef1 <my_cot+0x11>
jnp    3f10 <my_cot+0x30>
movsd  0x0(%rip),%xmm1        # 3efb <my_cot+0x1b>
add    $0x18,%rsp
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
jne    3ef3 <my_cot+0x13>
xor    %r8d,%r8d
mov    $0x0,%ecx
mov    $0x53e,%edx
mov    $0x0,%esi
mov    $0x6e,%edi
movsd  %xmm0,0x8(%rsp)
callq  3f34 <my_cot+0x54>
movsd  0x8(%rsp),%xmm0
jmp    3ef3 <my_cot+0x13>
nopl   0x0(%rax)
<<<sep_in_sample>>>
my_cot (x)
     double x;
{
  x = tan (x);
  if (x == 0.0)
    my_error (110, "hd-astro.c", ((long) 1343) - 1L,
       "my_cot()=", 0);
  return (1.0 / x);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
5 8
6 9
7 8
8 9
9 9
10 9
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
test   %rax,%rax
je     7d0 <sexget_lineno+0x20>
mov    0x18(%rdi),%rdx
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     7d0 <sexget_lineno+0x20>
mov    0x30(%rax),%eax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexget_lineno (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (! ( yyg->yy_buffer_stack ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] : ((void *)0)))
            return 0;
    return (yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]->yy_bs_lineno);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 6
9 6
10 6
11 5
12 7
13 7
<<<sep_out_sample>>>
push   %r13
mov    %ecx,%r8d
mov    %edx,%r13d
push   %r12
mov    %ecx,%r12d
mov    %edx,%ecx
mov    %esi,%edx
push   %rbp
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %rbx,%rdi
mov    %ebp,%esi
mov    %r12d,%ecx
mov    %r13d,%r8d
xor    %r9d,%r9d
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xf,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xbe,(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %edx,%edx
jmpq   ad0 <_rx.isra.34>
nop
<<<sep_in_sample>>>
_ldxr_c(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    _rex(_jit, 0, 1, r0, r1, r2);
    *_jit->pc.uc++ = 0x0f;
    *_jit->pc.uc++ = 0xbe;
    _rx(_jit, r0, 0, r2, r1, 0x00);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 3
8 2
9 2
10 3
11 2
12 2
13 2
14 3
15 4
16 6
17 6
18 6
19 6
20 6
21 4
22 4
23 4
24 5
25 5
26 5
27 5
28 7
29 7
30 7
31 7
32 7
33 6
34 6
35 6
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   859 <xformat_set_linkname+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_set_linkname (XFORMAT * xux, char * linkname)
{
 ;
        ahs_set_linkname(xux->ahsM, linkname);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    $0x0,%esi
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    $0x0,%ebx
jmp    238 <find_string_var+0x28>
nopl   (%rax)
add    $0x18,%rbx
mov    -0x18(%rbx),%rsi
add    $0x1,%ebp
test   %rsi,%rsi
je     250 <find_string_var+0x40>
mov    %r12,%rdi
callq  240 <find_string_var+0x30>
test   %eax,%eax
jne    228 <find_string_var+0x18>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_string_var (name)
     const char *name;
{
  register int i;
  for (i = 0; string_varlist[i].name; i++)
    if (strcasecmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 3
5 5
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 8
28 9
29 9
30 9
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  3bdc <gsl_sf_ellint_P+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    3bf0 <gsl_sf_ellint_P+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x271,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3c06 <gsl_sf_ellint_P+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_ellint_P(double phi, double k, double n, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_ellint_P_e(phi, k, n, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_ellint_P_e(phi, k, n, mode, &result)", "ellint.c", 625, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
sub    $0x8,%rsp
callq  9e6 <gl_linked_nx_add_last+0x16>
test   %rax,%rax
je     a0a <gl_linked_nx_add_last+0x3a>
lea    0x28(%rbx),%rdx
mov    %rbp,0x10(%rax)
mov    %rdx,(%rax)
mov    0x30(%rbx),%rdx
mov    %rdx,0x8(%rax)
mov    %rax,(%rdx)
addq   $0x1,0x40(%rbx)
mov    %rax,0x30(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_nx_add_last (gl_list_t list, const void *elt)
{
  gl_list_node_t node =
    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));
  if (node == ((void *)0))
    return ((void *)0);
  node->value = elt;
  node->next = &list->root;
  node->prev = list->root.prev;
  node->prev->next = node;
  list->root.prev = node;
  list->count++;
  return node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 5
9 5
10 8
11 7
12 8
13 9
14 9
15 10
16 12
17 11
18 14
19 14
20 14
21 14
22 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  549 <swi_com_header_manifold_reset+0x9>
xor    %esi,%esi
mov    %rbx,%rdi
callq  553 <swi_com_header_manifold_reset+0x13>
mov    %rbx,%rdi
callq  55b <swi_com_header_manifold_reset+0x1b>
mov    %rbx,%rdi
xor    %edx,%edx
mov    %rax,%rsi
pop    %rbx
jmpq   569 <swi_com_header_manifold_reset+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swi_com_header_manifold_reset(SWHEADER * swheader)
{
 swheader_reset(swheader);
 swheader_set_current_offset_p_value(swheader, 0);
 swheader_goto_next_line(swheader,
  swheader_get_current_offset_p(swheader),
   0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 5
12 8
13 5
14 5
<<<sep_out_sample>>>
movslq 0x4(%rdi),%rdx
mov    0x8(%rdi),%rax
mov    (%rax),%rcx
mov    $0x1,%eax
test   %rdx,%rdx
je     23 <__gmpz_fits_sint_p+0x23>
cmp    $0x1,%rdx
je     40 <__gmpz_fits_sint_p+0x40>
xor    %eax,%eax
cmp    $0xffffffffffffffff,%rdx
je     28 <__gmpz_fits_sint_p+0x28>
repz retq 
nopl   (%rax)
mov    $0x80000000,%eax
cmp    %rax,%rcx
setbe  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
cmp    $0x7fffffff,%rcx
setbe  %al
retq   
<<<sep_in_sample>>>
__gmpz_fits_sint_p (mpz_srcptr z)
{
  mp_size_t n = ((z)->_mp_size);
  mp_ptr p = ((z)->_mp_d);
  mp_limb_t limb = p[0];
  if (n == 0)
    return 1;
  if (n == 1)
    return limb <= 2147483647;
  if (n == -1)
    return limb <= (- (((mp_limb_t) (((-2147483647 - 1)) + 1)) - 1));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 7
5 6
6 6
7 8
8 8
9 12
10 10
11 10
12 13
13 13
14 11
15 11
16 11
17 11
18 13
19 13
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
repz retq 
<<<sep_in_sample>>>
textdomain(char * a) {
}
<<<sep_in_sample>>>
1 1
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1950 <gsl_monte_vegas_free+0x60>
mov    0x40(%rdi),%rdi
callq  1902 <gsl_monte_vegas_free+0x12>
mov    0x28(%rbx),%rdi
callq  190b <gsl_monte_vegas_free+0x1b>
mov    0x58(%rbx),%rdi
callq  1914 <gsl_monte_vegas_free+0x24>
mov    0x18(%rbx),%rdi
callq  191d <gsl_monte_vegas_free+0x2d>
mov    0x20(%rbx),%rdi
callq  1926 <gsl_monte_vegas_free+0x36>
mov    0x30(%rbx),%rdi
callq  192f <gsl_monte_vegas_free+0x3f>
mov    0x50(%rbx),%rdi
callq  1938 <gsl_monte_vegas_free+0x48>
mov    0x48(%rbx),%rdi
callq  1941 <gsl_monte_vegas_free+0x51>
mov    %rbx,%rdi
pop    %rbx
jmpq   194a <gsl_monte_vegas_free+0x5a>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_monte_vegas_free (gsl_monte_vegas_state * s)
{
  if (!s) { return ; };
  free (s->x);
  free (s->delx);
  free (s->d);
  free (s->xi);
  free (s->xin);
  free (s->weight);
  free (s->box);
  free (s->bin);
  free (s);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 9
17 10
18 10
19 11
20 11
21 12
22 13
23 12
24 12
25 13
26 13
27 13
<<<sep_out_sample>>>
push   %r12
mov    $0x187,%edx
mov    %rsi,%r12
mov    $0x0,%esi
push   %rbp
mov    %rdi,%rbp
mov    $0x20,%edi
push   %rbx
callq  7de <make_pattern_list+0x1e>
test   %rbp,%rbp
mov    %rax,%rbx
je     820 <make_pattern_list+0x60>
cmpq   $0x0,0x0(%rbp)
mov    %rbp,%rdi
je     7fa <make_pattern_list+0x3a>
xor    %eax,%eax
callq  7f7 <make_pattern_list+0x37>
mov    %rax,%rdi
mov    %rdi,0x8(%rbx)
mov    %r12,0x10(%rbx)
mov    %rbx,%rax
movq   $0x0,(%rbx)
movl   $0x0,0x18(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
xor    %edi,%edi
jmp    7fa <make_pattern_list+0x3a>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_pattern_list (patterns, action)
     WORD_LIST *patterns;
     COMMAND *action;
{
  PATTERN_LIST *temp;
  temp = (PATTERN_LIST *)sh_xmalloc((sizeof (PATTERN_LIST)), "make_cmd.c", 391);
  temp->patterns = ((patterns && patterns->next) ? (WORD_LIST *)list_reverse ((GENERIC_LIST *)patterns) : (WORD_LIST *)(patterns));
  temp->action = action;
  temp->next = ((void *)0);
  temp->flags = 0;
  return (temp);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 4
7 6
8 4
9 6
10 7
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 8
21 12
22 9
23 10
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
lea    -0x1(%rdi),%eax
cmp    $0x6,%eax
ja     a20 <short_day_name+0x20>
movslq %edi,%rdi
mov    0x0(,%rdi,8),%rdi
jmpq   a18 <short_day_name+0x18>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
jmpq   a2a <short_day_name+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
short_day_name (day)
     const int day;
{
  static const char *name[] = {
    ("invalid day"),
    ("Mo"),
    ("Tu"),
    ("We"),
    ("Th"),
    ("Fr"),
    ("Sa"),
    ("Su")
  };
  return (((day < 1) || (day > 7)) ? gettext(name[0]) : gettext(name[day]));
}
<<<sep_in_sample>>>
1 14
2 14
3 14
4 14
5 14
6 14
7 14
8 14
9 14
10 14
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
movq   $0x0,0x0(%rip)        # 196f <find_local+0xf>
mov    %rdi,%rbx
je     1990 <find_local+0x30>
mov    0x20(%rsi),%rsi
test   %rsi,%rsi
je     1990 <find_local+0x30>
movsbl %dl,%edx
callq  1985 <find_local+0x25>
test   %rax,%rax
je     19a0 <find_local+0x40>
pop    %rbx
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
movsbl %dl,%esi
pop    %rbx
jmpq   199c <find_local+0x3c>
nopl   0x0(%rax)
mov    0x0(%rip),%rax        # 19a7 <find_local+0x47>
mov    0xa0(%rax),%rax
test   %rax,%rax
jne    19c1 <find_local+0x61>
jmp    19d0 <find_local+0x70>
nopl   (%rax)
mov    0x30(%rax),%rax
test   %rax,%rax
je     19d0 <find_local+0x70>
cmp    %rbx,(%rax)
jne    19b8 <find_local+0x58>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
pop    %rbx
jmpq   170 <newnotseen>
nopl   0x0(%rax)
<<<sep_in_sample>>>
find_local (char *ident, decl_t *rd, char virt)
{
  seenthrough = ((void *)0);
  if (rd != ((void *)0) && rd->descr != ((void *)0))
    rd = find_decl (ident, rd->descr, virt);
  else
    return (find_global (ident, virt));
  if (rd != ((void *)0))
    return (rd);
  for (rd = unknowns->parloc; rd != ((void *)0); rd = rd->next)
    if (rd->ident == ident)
      return (rd);
  return (newnotseen (ident));
}
<<<sep_in_sample>>>
1 4
2 2
3 3
4 2
5 4
6 4
7 4
8 4
9 5
10 5
11 8
12 8
13 14
14 14
15 14
16 7
17 7
18 14
19 7
20 7
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 11
31 11
32 14
33 14
34 14
35 13
36 14
37 13
38 13
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
push   %r13
mov    %rsi,%r13
mov    %r13,%rdi
push   %r12
mov    %r8,%r12
mov    %r9d,%r8d
push   %rbp
mov    %rcx,%rbp
mov    %r12,%rcx
push   %rbx
mov    %rdx,%rbx
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  10 <__argmatch_internal>
test   %eax,%eax
js     318 <__xargmatch_internal+0x38>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
mov    %eax,%edx
mov    %r13,%rsi
mov    %r14,%rdi
callq  325 <__xargmatch_internal+0x45>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  333 <__xargmatch_internal+0x53>
callq  *0x30(%rsp)
mov    $0xffffffff,%eax
jmp    30f <__xargmatch_internal+0x2f>
xchg   %ax,%ax
<<<sep_in_sample>>>
__xargmatch_internal (const char *context,
        const char *arg, const char *const *arglist,
        const char *vallist, size_t valsize,
        int case_sensitive,
        argmatch_exit_fn exit_fn)
{
  int res = __argmatch_internal (arg, arglist,
     vallist, valsize,
     case_sensitive);
  if (res >= 0)
    return res;
  argmatch_invalid (context, arg, res);
  argmatch_valid (arglist, vallist, valsize);
  (*exit_fn) ();
  return -1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 7
6 6
7 6
8 7
9 6
10 6
11 7
12 6
13 6
14 7
15 7
16 7
17 10
18 10
19 16
20 16
21 16
22 16
23 16
24 16
25 12
26 12
27 12
28 12
29 13
30 13
31 13
32 13
33 14
34 15
35 15
36 15
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  293 <get_tz+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     2d8 <get_tz+0x58>
mov    %rax,%rdi
callq  2a3 <get_tz+0x23>
lea    0x1(%rax),%rdx
cmp    $0x64,%rdx
ja     2c0 <get_tz+0x40>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2be <get_tz+0x3e>
xchg   %ax,%ax
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <get_tz+0x51>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_tz (char tzbuf[TZBUFSIZE])
{
  char *tz = getenv ("TZ");
  if (tz)
    {
      size_t tzsize = strlen (tz) + 1;
      tz = (tzsize <= TZBUFSIZE
            ? memcpy (tzbuf, tz, tzsize)
            : xmemdup (tz, tzsize));
    }
  return tz;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 12
16 7
17 7
18 12
19 12
20 7
21 7
22 12
23 7
24 7
25 12
26 12
27 7
28 7
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
sub    $0x100,%rsp
mov    %rsp,%rdi
callq  2662 <describe_pid+0x12>
mov    $0x11,%esi
mov    %rsp,%rdi
callq  266f <describe_pid+0x1f>
lea    0x80(%rsp),%rdi
callq  267c <describe_pid+0x2c>
lea    0x80(%rsp),%rdx
xor    %edi,%edi
mov    %rsp,%rsi
callq  268e <describe_pid+0x3e>
xor    %edx,%edx
xor    %esi,%esi
mov    %ebx,%edi
callq  4c0 <find_job>
cmp    $0xffffffff,%eax
je     26d8 <describe_pid+0x88>
mov    0x0(%rip),%rdi        # 26a5 <describe_pid+0x55>
lea    0x1(%rax),%edx
movslq %ebx,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  26b7 <describe_pid+0x67>
lea    0x80(%rsp),%rsi
xor    %edx,%edx
mov    $0x2,%edi
callq  26cb <describe_pid+0x7b>
add    $0x100,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
mov    $0x0,%edi
callq  26e2 <describe_pid+0x92>
movslq %ebx,%rsi
mov    %rax,%rdi
xor    %eax,%eax
callq  26ef <describe_pid+0x9f>
jmp    26b7 <describe_pid+0x67>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
describe_pid (pid)
     pid_t pid;
{
  int job;
  sigset_t set, oset;
  do { sigemptyset (&set); sigaddset (&set, 17); sigemptyset (&oset); sigprocmask (0, &set, &oset); } while (0);
  job = find_job (pid, 0, ((void *)0));
  if (job != -1)
    fprintf (stderr, "[%d] %ld\n", job + 1, (long)pid);
  else
    programming_error (gettext("describe_pid: %ld: no such pid"), (long)pid);
  sigprocmask (2, &oset, (sigset_t *) ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 7
18 7
19 8
20 8
21 9
22 9
23 9
24 9
25 9
26 9
27 12
28 12
29 12
30 12
31 13
32 13
33 13
34 13
35 11
36 11
37 11
38 11
39 11
40 11
41 11
42 11
<<<sep_out_sample>>>
mov    $0x4,%edx
jmpq   18a <in_addr_cmp+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
in_addr_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(struct in_addr)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1696 <ea_abort+0x6>
cmp    %eax,0x0(%rip)        # 169c <ea_abort+0xc>
je     16e0 <ea_abort+0x50>
sub    $0x8,%rsp
callq  16a7 <ea_abort+0x17>
mov    0x0(%rip),%eax        # 16ad <ea_abort+0x1d>
mov    0x0(%rip),%rdx        # 16b4 <ea_abort+0x24>
mov    %eax,0x0(%rip)        # 16ba <ea_abort+0x2a>
mov    %eax,0x0(%rip)        # 16c0 <ea_abort+0x30>
mov    0x0(%rip),%rax        # 16c7 <ea_abort+0x37>
cmp    %rdx,0x30(%rax)
je     16f0 <ea_abort+0x60>
add    $0x8,%rsp
jmpq   cd0 <restore_calling_window>
nopw   %cs:0x0(%rax,%rax,1)
movl   $0x1,0x0(%rip)        # 16ea <ea_abort+0x5a>
retq   
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ea_abort (WINDOW *window, int count)
{
  if (input_line_end != input_line_beg)
    {
      terminal_ring_bell ();
      input_line_end = input_line_point = input_line_beg;
      if (calling_window->node != calling_window_node)
        restore_calling_window ();
    }
  else
    info_aborted_echo_area = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 5
6 6
7 7
8 6
9 6
10 7
11 7
12 7
13 12
14 8
15 8
16 11
17 11
18 11
19 12
20 12
21 12
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  1c7c <gsl_sf_debye_2+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1c90 <gsl_sf_debye_2+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x221,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ca6 <gsl_sf_debye_2+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_debye_2(const double x)
{
  gsl_sf_result result; int status = gsl_sf_debye_2_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_debye_2_e(x, &result)", "debye.c", 545, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  199 <xstrdup+0x9>
mov    %rbx,%rdi
lea    0x1(%rax),%rsi
pop    %rbx
jmpq   1a6 <xstrdup+0x16>
<<<sep_in_sample>>>
xstrdup (char const *string)
{
  return xmemdup (string, strlen (string) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x28,%edi
push   %rbx
callq  14 <rec_buf_new+0x14>
test   %rax,%rax
mov    %rax,%rbx
je     46 <rec_buf_new+0x46>
mov    %rbp,0x18(%rax)
mov    %r12,0x20(%rax)
mov    $0x200,%edi
callq  2e <rec_buf_new+0x2e>
test   %rax,%rax
mov    %rax,(%rbx)
movq   $0x200,0x8(%rbx)
movq   $0x0,0x10(%rbx)
je     4e <rec_buf_new+0x4e>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    %rbx,%rdi
xor    %ebx,%ebx
callq  58 <rec_buf_new+0x58>
jmp    46 <rec_buf_new+0x46>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_buf_new (char **data, size_t *size)
{
  rec_buf_t new;
  new = malloc (sizeof (struct rec_buf_s));
  if (new)
    {
      new->data_pointer = data;
      new->size_pointer = size;
      new->data = malloc (512);
      new->size = 512;
      new->used = 0;
      if (!new->data)
        {
          free (new);
          new = ((void *)0);
        }
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 4
10 5
11 7
12 8
13 9
14 9
15 12
16 9
17 10
18 11
19 12
20 19
21 19
22 19
23 19
24 19
25 14
26 15
27 14
28 14
29 14
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    2570 <gsl_matrix_uint_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,4),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2592 <gsl_matrix_uint_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_row (gsl_matrix_uint * m, const size_t i)
{
  _gsl_vector_uint_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uint v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  9b <remove_watcher+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     e0 <remove_watcher+0x50>
mov    %rax,%rdi
callq  ab <remove_watcher+0x1b>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  b6 <remove_watcher+0x26>
test   %rbp,%rbp
je     d0 <remove_watcher+0x40>
add    $0x8,%rsp
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   c9 <remove_watcher+0x39>
nopl   0x0(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x0,%esi
xor    %edi,%edi
pop    %rbx
pop    %rbp
xor    %eax,%eax
jmpq   f4 <remove_watcher+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remove_watcher(const char *dir, const char *name)
{
 struct dirwatcher *dwp;
 char *fullname = mkfilename(dir, name);
 if (!fullname) {
  diag(0, "not enough memory: "
       "cannot look up a watcher to delete");
  return;
 }
 dwp = dirwatcher_lookup(fullname);
 free(fullname);
 if (dwp)
  dirwatcher_destroy(dwp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 4
7 5
8 10
9 10
10 11
11 10
12 11
13 12
14 12
15 14
16 13
17 14
18 14
19 13
20 13
21 14
22 14
23 14
24 14
25 14
26 14
27 6
28 6
29 14
30 14
31 6
32 6
33 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # ac <gsl_cdf_negative_binomial_Q+0xc>
ucomisd %xmm2,%xmm0
ja     e0 <gsl_cdf_negative_binomial_Q+0x40>
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
ja     e0 <gsl_cdf_negative_binomial_Q+0x40>
ucomisd %xmm1,%xmm3
ja     110 <gsl_cdf_negative_binomial_Q+0x70>
mov    %edi,%edi
add    $0x8,%rsp
cvtsi2sd %rdi,%xmm3
addsd  %xmm3,%xmm2
jmpq   d6 <gsl_cdf_negative_binomial_Q+0x36>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x46,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f9 <gsl_cdf_negative_binomial_Q+0x59>
movsd  0x0(%rip),%xmm0        # 101 <gsl_cdf_negative_binomial_Q+0x61>
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%ecx
mov    $0x4b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  129 <gsl_cdf_negative_binomial_Q+0x89>
movsd  0x0(%rip),%xmm0        # 131 <gsl_cdf_negative_binomial_Q+0x91>
jmp    101 <gsl_cdf_negative_binomial_Q+0x61>
<<<sep_in_sample>>>
gsl_cdf_negative_binomial_Q (const unsigned int k, const double p, const double n)
{
  double Q;
  double a;
  double b;
  if (p > 1.0 || p < 0.0)
    {
      do { gsl_error ("p < 0 or p > 1", "nbinomial.c", 70, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  if (n < 0)
    {
      do { gsl_error ("n < 0", "nbinomial.c", 75, GSL_EDOM) ; return (__builtin_nanf ("")) ; } while (0);
    }
  a = (double) n;
  b = (double) k + 1.0;
  Q = gsl_cdf_beta_Q (p, a, b);
  return Q;
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 10
9 10
10 15
11 18
12 15
13 16
14 16
15 16
16 8
17 8
18 8
19 8
20 8
21 8
22 18
23 18
24 18
25 12
26 12
27 12
28 12
29 12
30 12
31 12
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1120 <gsl_vector_float_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1115 <gsl_vector_float_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     115b <gsl_vector_float_div+0x6b>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
movss  (%rax),%xmm0
add    $0x1,%rdx
divss  (%rcx),%xmm0
add    %r9,%rcx
movss  %xmm0,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1140 <gsl_vector_float_div+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_float_div (gsl_vector_float * a, const gsl_vector_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     d0 <sdp_attribute_free+0x50>
mov    (%rdi),%rdi
test   %rdi,%rdi
je     9f <sdp_attribute_free+0x1f>
mov    0x0(%rip),%rax        # 98 <sdp_attribute_free+0x18>
test   %rax,%rax
je     e8 <sdp_attribute_free+0x68>
callq  *%rax
mov    0x8(%rbx),%rdi
test   %rdi,%rdi
je     b6 <sdp_attribute_free+0x36>
mov    0x0(%rip),%rax        # af <sdp_attribute_free+0x2f>
test   %rax,%rax
je     f0 <sdp_attribute_free+0x70>
callq  *%rax
mov    0x0(%rip),%rax        # bd <sdp_attribute_free+0x3d>
mov    %rbx,%rdi
test   %rax,%rax
je     d8 <sdp_attribute_free+0x58>
pop    %rbx
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
nopl   0x0(%rax)
jmpq   e5 <sdp_attribute_free+0x65>
nopl   (%rax)
callq  ed <sdp_attribute_free+0x6d>
jmp    9f <sdp_attribute_free+0x1f>
nop
callq  f5 <sdp_attribute_free+0x75>
jmp    b6 <sdp_attribute_free+0x36>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_attribute_free (sdp_attribute_t * attribute)
{
  if (attribute == ((void *)0))
    return;
  { if (attribute->a_att_field!=((void *)0)) { if (osip_free_func) osip_free_func(attribute->a_att_field); else free(attribute->a_att_field);} };
  { if (attribute->a_att_value!=((void *)0)) { if (osip_free_func) osip_free_func(attribute->a_att_value); else free(attribute->a_att_value);} };
  { if (attribute!=((void *)0)) { if (osip_free_func) osip_free_func(attribute); else free(attribute);} };
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 8
24 7
25 7
26 8
27 8
28 8
29 8
30 8
31 7
32 7
33 5
34 5
35 5
36 6
37 6
38 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # af7 <rl_on_new_line+0x7>
mov    (%rax),%rdx
test   %rdx,%rdx
je     b02 <rl_on_new_line+0x12>
movb   $0x0,(%rdx)
mov    0x8(%rax),%rax
movl   $0x0,0x0(%rip)        # b10 <rl_on_new_line+0x20>
movl   $0x0,0x0(%rip)        # b1a <rl_on_new_line+0x2a>
movl   $0x0,0x0(%rip)        # b24 <rl_on_new_line+0x34>
movl   $0x0,0x0(%rip)        # b2e <rl_on_new_line+0x3e>
test   %rax,%rax
je     b40 <rl_on_new_line+0x50>
movl   $0x0,0x4(%rax)
movl   $0x0,(%rax)
movl   $0x0,0x0(%rip)        # b4a <rl_on_new_line+0x5a>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
rl_on_new_line ()
{
  if ((line_state_visible->line))
    (line_state_visible->line)[0] = '\0';
  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if ((line_state_visible->lbreaks))
    (line_state_visible->lbreaks)[0] = (line_state_visible->lbreaks)[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 7
7 5
8 5
9 6
10 6
11 7
12 7
13 8
14 8
15 9
16 11
17 11
18 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rdx,%rdi
mov    $0x10,%edx
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
sub    $0x8,%rsp
callq  ce <wprepend+0x1e>
mov    %rbp,(%rax)
mov    %rbx,0x8(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
wprepend (void *x, struct wlink *ls, struct divvy *to)
{
  struct wlink *pair = alloc (to, "struct wlink", sizeof (struct wlink)); pair->entry = x; pair->next = ls; return pair;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 2
7 3
8 2
9 3
10 3
11 3
12 4
13 4
14 4
15 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmp    $0x16,%edi
je     25 <acl_errno_valid+0x25>
jle    20 <acl_errno_valid+0x20>
cmp    $0x26,%edi
je     25 <acl_errno_valid+0x25>
cmp    $0x5f,%edi
nop
je     25 <acl_errno_valid+0x25>
mov    $0x1,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0x10,%edi
jne    12 <acl_errno_valid+0x12>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
acl_errno_valid (int errnum)
{
  switch (errnum)
    {
    case 16: return 0;
    case 22: return 0;
    case 38: return 0;
    case 95: return 0;
    default: return 1;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 9
10 11
11 11
12 3
13 3
14 5
15 5
<<<sep_out_sample>>>
push   %r12
mov    $0x72,%esi
push   %rbp
push   %rbx
mov    %edi,%ebx
movslq %ebx,%rbp
callq  fc0 <connect>
mov    0x0(,%rbp,8),%rdi
callq  11a0 <inchar+0x20>
mov    0x0(,%rbp,8),%rbp
mov    %eax,%r12d
mov    %rbp,%rdi
callq  11b3 <inchar+0x33>
test   %eax,%eax
jne    11cb <inchar+0x4b>
mov    %rbp,%rdi
callq  11bf <inchar+0x3f>
test   %eax,%eax
jne    11e8 <inchar+0x68>
pop    %rbx
pop    %rbp
mov    %r12d,%eax
pop    %r12
retq   
callq  11d0 <inchar+0x50>
mov    (%rax),%edi
callq  11d7 <inchar+0x57>
mov    %ebx,%esi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  11e8 <inchar+0x68>
mov    %ebx,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  11f6 <inchar+0x76>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
inchar(int channel)
{
      int c;
      connect(channel, 'r');
      c = fgetc(stream[channel]);
      if (ferror(stream[channel]))
         fault("unable to input from channel %d - %s", channel,
            strerror((*__errno_location ())));
      if (feof(stream[channel]))
         fault("unable to input from channel %d - input request beyond "
            "end of data", channel);
      return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 5
7 4
8 5
9 5
10 6
11 5
12 6
13 6
14 6
15 6
16 9
17 9
18 9
19 9
20 13
21 13
22 13
23 13
24 13
25 8
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 10
34 10
35 10
36 10
37 10
<<<sep_out_sample>>>
push   %rbx
xor    %edx,%edx
mov    %rsi,%rbx
mov    $0x10,%esi
sub    $0x10,%rsp
lea    0x8(%rsp),%rcx
callq  b9 <CDB___db_txnlist_init+0x19>
test   %eax,%eax
jne    da <CDB___db_txnlist_init+0x3a>
mov    0x8(%rsp),%rdx
movq   $0x0,(%rdx)
movl   $0x0,0x8(%rdx)
movl   $0x1,0xc(%rdx)
mov    %rdx,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
CDB___db_txnlist_init(dbenv, retp)
 DB_ENV *dbenv;
 void *retp;
{
 DB_TXNHEAD *headp;
 int ret;
 if ((ret = CDB___os_malloc(dbenv, sizeof(DB_TXNHEAD), ((void *)0), &headp)) != 0)
  return (ret);
 { (&headp->head)->lh_first = ((void *)0); };
 headp->maxid = 0;
 headp->generation = 1;
 *(void **)retp = headp;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 7
3 4
4 7
5 4
6 7
7 7
8 7
9 7
10 9
11 9
12 10
13 11
14 12
15 14
16 14
17 14
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  295 <yy_init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%r12
mov    (%rax),%r13d
callq  2a3 <yy_init_buffer+0x23>
mov    0x0(%rip),%rax        # 2aa <yy_init_buffer+0x2a>
mov    %rbp,(%rbx)
movl   $0x1,0x3c(%rbx)
test   %rax,%rax
je     2c6 <yy_init_buffer+0x46>
mov    0x0(%rip),%rdx        # 2c0 <yy_init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     2d4 <yy_init_buffer+0x54>
movl   $0x1,0x34(%rbx)
movl   $0x0,0x38(%rbx)
xor    %eax,%eax
test   %rbp,%rbp
je     2f2 <yy_init_buffer+0x72>
mov    %rbp,%rdi
callq  2e3 <yy_init_buffer+0x63>
mov    %eax,%edi
callq  2ea <yy_init_buffer+0x6a>
test   %eax,%eax
setg   %al
movzbl %al,%eax
mov    %eax,0x2c(%rbx)
mov    %r13d,(%r12)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 yy_flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
33 11
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 13
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    $0x16,%eax
mov    %rdi,%rbx
je     50c <mu_wicket_unref+0x2c>
mov    (%rdi),%eax
test   %eax,%eax
jne    510 <mu_wicket_unref+0x30>
mov    0x18(%rbx),%rax
test   %rax,%rax
je     502 <mu_wicket_unref+0x22>
mov    %rbx,%rdi
callq  *%rax
mov    %rbx,%rdi
callq  50a <mu_wicket_unref+0x2a>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,(%rdi)
je     4f4 <mu_wicket_unref+0x14>
mov    $0x1029,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_wicket_unref (mu_wicket_t wicket)
{
  if (!wicket)
    return 22;
  if (wicket->refcnt)
    wicket->refcnt--;
  if (wicket->refcnt == 0)
    {
      if (wicket->_destroy)
 wicket->_destroy (wicket);
      free (wicket);
      return 0;
    }
  return (0x1000 +41);
}
<<<sep_in_sample>>>
1 3
2 2
3 4
4 2
5 3
6 5
7 5
8 5
9 9
10 9
11 9
12 10
13 10
14 11
15 11
16 12
17 15
18 15
19 15
20 6
21 7
22 6
23 7
24 14
25 15
26 15
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  12b <pair_table_new+0xb>
mov    $0x0,%r8d
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
callq  14b <pair_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
pair_table_new (void)
{
  struct pair_htable * res;
  res = ((struct pair_htable *) xmalloc (sizeof (struct pair_htable) * (1)));
  hash_init (res, 8,
      (hash_func_t) pair_hash_1,
      (hash_func_t) pair_hash_2,
      (hash_cmp_func_t) pair_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 5
8 5
9 5
10 5
11 10
12 10
13 10
<<<sep_out_sample>>>
xor    %esi,%esi
jmpq   0 <set_is_ieee_control_script>
<<<sep_in_sample>>>
swi_afile_is_ieee_control_script(char * pathname)
{
 int ret;
 ret = set_is_ieee_control_script(pathname, 0);
 return ret;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 316 <swlib_set_pax_header_pid+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_set_pax_header_pid(pid_t n)
{
 g_pax_header_pidG = n;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
xor    %eax,%eax
mov    %edx,%ebp
mov    %rdi,%rdx
push   %rbx
mov    %rsi,%rbx
mov    $0x0,%esi
mov    %rbx,%rdi
sub    $0x18,%rsp
callq  8d <usage+0x1d>
mov    %rbx,%rcx
mov    $0x1f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a4 <usage+0x34>
mov    %rsp,%rsi
mov    $0x0,%edi
mov    %rbx,(%rsp)
movl   $0x3d,0x8(%rsp)
callq  bd <usage+0x4d>
mov    $0x0,%edi
mov    %rbx,%rcx
mov    $0x28,%edx
mov    $0x1,%esi
callq  d4 <usage+0x64>
mov    %ebp,%edi
callq  db <usage+0x6b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
usage(const char *arg, FILE *fp, int code)
{
 struct list_helper lh;
 fprintf(fp,
  "usage: %s [-h] [-list[=type]] [-locus] [-delim=char] [-reduce] [-sort]\n",
  arg);
 fprintf(fp, "    [-nopath] [-novalue] [-type");
 lh.file = fp;
 lh.delim = '=';
 grecs_enumerate_parsers(list_parser_types, &lh);
 fprintf(fp, "] [-Idir] [-include=dir] file [file...]\n");
 exit(code);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 2
6 2
7 4
8 4
9 2
10 4
11 7
12 7
13 7
14 7
15 7
16 10
17 10
18 8
19 9
20 10
21 11
22 11
23 11
24 11
25 11
26 12
27 12
28 12
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    ed8 <gsl_matrix_long_double_column+0x38>
shl    $0x4,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  efa <gsl_matrix_long_double_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_column (gsl_matrix_long_double * m, const size_t j)
{
  _gsl_vector_long_double_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_long_double v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 83d <GetSBMLKeywordCode+0xd>
cmpb   $0x0,(%rsi)
je     872 <GetSBMLKeywordCode+0x42>
mov    %rdi,%rbp
mov    $0x0,%ebx
jmp    85c <GetSBMLKeywordCode+0x2c>
nopl   0x0(%rax)
add    $0x10,%rbx
mov    (%rbx),%rsi
cmpb   $0x0,(%rsi)
je     868 <GetSBMLKeywordCode+0x38>
mov    %rbp,%rdi
callq  864 <GetSBMLKeywordCode+0x34>
test   %eax,%eax
jne    850 <GetSBMLKeywordCode+0x20>
mov    0x8(%rbx),%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%ebx
jmp    868 <GetSBMLKeywordCode+0x38>
nopl   0x0(%rax)
<<<sep_in_sample>>>
GetSBMLKeywordCode (PSTR szKeyword)
{
  PKM pkm = &vrgSBMLKW[0];
  while (*pkm->szKeyword && strcmp (szKeyword, pkm->szKeyword))
    pkm++;
  return (pkm->iKWCode);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 4
8 3
9 3
10 3
11 5
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 6
20 7
21 7
22 7
23 7
24 3
25 3
26 3
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 95f <_rl_backspace+0xf>
test   %rax,%rax
je     9a0 <_rl_backspace+0x50>
test   %edi,%edi
jle    98d <_rl_backspace+0x3d>
mov    %rax,%rdi
xor    %ebx,%ebx
jmp    977 <_rl_backspace+0x27>
nop
mov    0x0(%rip),%rdi        # 977 <_rl_backspace+0x27>
mov    $0x0,%edx
mov    $0x1,%esi
add    $0x1,%ebx
callq  989 <_rl_backspace+0x39>
cmp    %ebp,%ebx
jne    970 <_rl_backspace+0x20>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %ebx,%ebx
test   %edi,%edi
jle    98d <_rl_backspace+0x3d>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%rsi        # 9b7 <_rl_backspace+0x67>
mov    $0x8,%edi
add    $0x1,%ebx
callq  9c4 <_rl_backspace+0x74>
cmp    %ebp,%ebx
jne    9b0 <_rl_backspace+0x60>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_backspace (count)
     int count;
{
  register int i;
  if (_rl_term_backspace)
    for (i = 0; i < count; i++)
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
  else
    for (i = 0; i < count; i++)
      _IO_putc ('\b', _rl_out_stream);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 5
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 7
16 7
17 6
18 7
19 6
20 6
21 12
22 12
23 12
24 12
25 12
26 12
27 9
28 9
29 9
30 9
31 10
32 10
33 9
34 10
35 9
36 9
37 12
38 12
39 12
40 12
41 12
42 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3970 <closure>
jmp    3d63 <branch+0x23>
nopl   0x0(%rax,%rax,1)
test   %eax,%eax
js     3d76 <branch+0x36>
callq  3970 <closure>
mov    $0x10c,%edi
callq  3610 <addtok>
mov    0x0(%rip),%eax        # 3d69 <branch+0x29>
mov    %eax,%edx
and    $0xfffffffd,%edx
cmp    $0x10d,%edx
jne    3d50 <branch+0x10>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
branch (void)
{
  closure();
  while (tok != RPAREN && tok != OR && tok >= 0)
    {
      closure();
      addtok(CAT);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 6
8 7
9 7
10 4
11 4
12 4
13 4
14 4
15 9
16 9
17 9
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    $0x16,%eax
mov    %rdi,%rbx
je     132 <mu_secret_unref+0x22>
mov    (%rdi),%eax
test   %eax,%eax
je     138 <mu_secret_unref+0x28>
sub    $0x1,%eax
test   %eax,%eax
mov    %eax,(%rdi)
je     138 <mu_secret_unref+0x28>
mov    $0x1029,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x18(%rbx),%rdi
mov    0x8(%rbx),%rdx
xor    %esi,%esi
callq  147 <mu_secret_unref+0x37>
mov    0x10(%rbx),%rdi
mov    0x8(%rbx),%rdx
xor    %esi,%esi
callq  156 <mu_secret_unref+0x46>
mov    %rbx,%rdi
callq  15e <mu_secret_unref+0x4e>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_secret_unref (mu_secret_t sec)
{
  if (sec)
    {
      if (sec->refcnt)
 sec->refcnt--;
      if (sec->refcnt == 0)
 {
   memset (sec->clptr, 0, sec->length);
   memset (sec->obptr, 0, sec->length);
   free (sec);
   return 0;
 }
      return (0x1000 +41);
    }
  return 22;
}
<<<sep_in_sample>>>
1 3
2 2
3 16
4 2
5 3
6 5
7 5
8 5
9 6
10 7
11 6
12 7
13 14
14 17
15 17
16 17
17 9
18 9
19 9
20 9
21 10
22 10
23 10
24 10
25 11
26 11
27 12
28 17
29 17
30 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%esi
mov    %rbx,%rdi
sub    $0x8,%rsp
callq  19 <__ribintext+0x19>
jmp    33 <__ribintext+0x33>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  28 <__ribintext+0x28>
mov    %rbx,%rdi
movsbl %al,%esi
callq  33 <__ribintext+0x33>
mov    %rbx,%rdi
callq  3b <__ribintext+0x3b>
movzbl 0x58(%rbp),%edx
xor    %ecx,%ecx
movsbl %al,%eax
test   %dl,%dl
sete   %cl
test   %ecx,%eax
jne    20 <__ribintext+0x20>
test   %dl,%dl
je     65 <__ribintext+0x65>
mov    %rbx,%rdi
callq  59 <__ribintext+0x59>
lea    -0x1(%rax),%rsi
mov    %rbx,%rdi
callq  65 <__ribintext+0x65>
mov    %rbx,%rdi
callq  6d <__ribintext+0x6d>
add    $0x8,%rsp
mov    %rbx,%rdi
lea    -0x1(%rax),%rdx
pop    %rbx
pop    %rbp
mov    $0x1,%esi
jmpq   84 <__ribintext+0x84>
<<<sep_in_sample>>>
__ribintext (__bs8FILE *p, __txtvp t)
{
  __rtsetpos (t, 1L);
  while (__rtmore (t) & !((__bs7FILE *) p)->endfile)
    __rtputchar (t, (char) __ribinbyte (p));
  if (((__bs7FILE *) p)->endfile)
    __rtsetpos (t, __rtpos (t) - 1);
  return (__rtsub (t, 1L, __rtpos (t) - 1));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 2
8 3
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 6
26 6
27 7
28 7
29 7
30 7
31 7
32 8
33 8
34 9
35 8
36 8
37 9
38 9
39 8
40 8
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rsi
mov    %rdi,%rbx
mov    $0x0,%edi
callq  1b1 <parse_key_style+0x11>
cmp    $0x0,%rax
je     200 <parse_key_style+0x60>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1c6 <parse_key_style+0x26>
cmp    $0x0,%rax
je     1f0 <parse_key_style+0x50>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  1db <parse_key_style+0x3b>
cmp    $0x0,%rax
jne    207 <parse_key_style+0x67>
mov    $0x3,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x2,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x1,%eax
pop    %rbx
retq   
mov    $0x0,%edi
callq  211 <parse_key_style+0x71>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
xor    %edi,%edi
xor    %eax,%eax
callq  222 <parse_key_style+0x82>
callq  227 <parse_key_style+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_key_style (char const *arg)
{
  do { char const *_s_ = ("none"); if (strstr (_s_, (arg)) == _s_) return (ks_none); } while (0);
  do { char const *_s_ = ("token"); if (strstr (_s_, (arg)) == _s_) return (ks_token); } while (0);
  do { char const *_s_ = ("pattern"); if (strstr (_s_, (arg)) == _s_) return (ks_pattern); } while (0);
  error (0, 0, gettext ("invalid `--key' style: `%s'"), arg);
  usage ();
  return ks_bogus;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 9
20 9
21 9
22 4
23 9
24 9
25 9
26 3
27 9
28 9
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 7
38 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  a9 <_rl_abort_internal+0x9>
callq  ae <_rl_abort_internal+0xe>
callq  b3 <_rl_abort_internal+0x13>
callq  b8 <_rl_abort_internal+0x18>
andq   $0xffffffffffffefff,0x0(%rip)        # c3 <_rl_abort_internal+0x23>
cmpq   $0x0,0x0(%rip)        # cb <_rl_abort_internal+0x2b>
je     df <_rl_abort_internal+0x3f>
nopl   (%rax)
callq  d5 <_rl_abort_internal+0x35>
cmpq   $0x0,0x0(%rip)        # dd <_rl_abort_internal+0x3d>
jne    d0 <_rl_abort_internal+0x30>
mov    $0x1,%esi
mov    $0x0,%edi
andq   $0xffffffffffdfffff,0x0(%rip)        # f4 <_rl_abort_internal+0x54>
movq   $0x0,0x0(%rip)        # ff <_rl_abort_internal+0x5f>
callq  104 <_rl_abort_internal+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();
  (rl_readline_state &= ~(0x0001000));
  while (rl_executing_macro)
    _rl_pop_executing_macro ();
  (rl_readline_state &= ~(0x0200000));
  rl_last_func = (rl_command_func_t *)((void *)0);
  siglongjmp((_rl_top_level), (1));
  return (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 8
9 8
10 9
11 8
12 8
13 12
14 12
15 10
16 11
17 12
18 12
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
and    $0x1,%esi
mov    %rdi,%rbx
shl    $0x4,%esi
sub    $0x8,%rsp
movzbl 0xaa(%rdi),%eax
movzbl 0x82(%rdi),%r9d
movzbl 0x81(%rdi),%r8d
movzbl 0x80(%rdi),%ecx
movzbl 0x79(%rdi),%edx
and    $0xffffffef,%eax
or     %esi,%eax
movzbl 0x78(%rdi),%esi
mov    %al,0xaa(%rdi)
mov    0xa8(%rbx),%eax
mov    0x1c(%rdi),%edi
mov    %eax,(%rsp)
callq  1570 <simplify_attributes.isra.1>
mov    %eax,0xac(%rbx)
add    $0x8,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
term_ostream__set_underline (term_ostream_t stream, term_underline_t underline)
{
  stream->curr_attr.underline = underline;
  stream->simp_attr = simplify_attributes (stream, stream->curr_attr);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 3
7 4
8 4
9 4
10 4
11 3
12 3
13 4
14 3
15 4
16 4
17 4
18 4
19 4
20 5
21 5
22 5
23 5
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
callq  3da <suspend+0xa>
lea    0x8(%rsp),%rsi
mov    %rsp,%rdi
callq  3e7 <suspend+0x17>
xor    %edi,%edi
mov    $0x14,%esi
mov    %eax,%ebx
callq  3f5 <suspend+0x25>
lea    0x18(%rsp),%rsi
lea    0x10(%rsp),%rdi
callq  404 <suspend+0x34>
test   %eax,%eax
je     426 <suspend+0x56>
mov    0x0(%rip),%eax        # 40e <suspend+0x3e>
test   %eax,%eax
je     426 <suspend+0x56>
test   %ebx,%ebx
je     421 <suspend+0x51>
mov    0x10(%rsp),%rax
cmp    %rax,(%rsp)
je     440 <suspend+0x70>
callq  426 <suspend+0x56>
callq  42b <suspend+0x5b>
xor    %edi,%edi
callq  432 <suspend+0x62>
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
mov    0x18(%rsp),%rax
cmp    %rax,0x8(%rsp)
jne    421 <suspend+0x51>
jmp    426 <suspend+0x56>
xchg   %ax,%ax
<<<sep_in_sample>>>
suspend (void)
{
  setcommandmode ();
  {
    long oldrows, oldcols, newrows, newcols, err;
    err = (TerminalWindowSize (&oldrows, &oldcols) == 0) ? 1 : 0;
    kill (0, 20);
    if (TerminalWindowSize (&newrows, &newcols) && connected &&
 (err || ((oldrows != newrows) || (oldcols != newcols))))
      {
 sendnaws ();
      }
  }
  TerminalSaveState ();
  setconnmode (0);
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 6
5 6
6 6
7 7
8 7
9 6
10 7
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 9
23 9
24 11
25 14
26 15
27 15
28 17
29 17
30 17
31 17
32 17
33 9
34 9
35 9
36 9
37 9
<<<sep_out_sample>>>
mov    (%rdi),%rax
not    %rax
sub    0x8(%rdi),%rax
sub    $0x1,%rax
retq   
nop
<<<sep_in_sample>>>
dev_ino_hash_2 (void const *key)
{
  unsigned long result = 0;
  do { (result) += ~((unsigned long)(((struct dev_ino const *) key)->di_dev)); } while (0);
  do { (result) += ~((unsigned long)(((struct dev_ino const *) key)->di_ino)); } while (0);
  return result;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
6 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  17c <hash_free_medium+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   185 <hash_free_medium+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_free_medium (struct medium * medium)
{
  free (medium->name);
  free (medium);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x28(%rdi),%rax
cmp    0x28(%rsi),%rax
je     4e0 <da_cmp_equal+0x20>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
xor    %ebx,%ebx
test   %rax,%rax
jne    4fa <da_cmp_equal+0x3a>
jmp    518 <da_cmp_equal+0x58>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    %rbx,0x28(%rbp)
jbe    518 <da_cmp_equal+0x58>
mov    0x30(%r12),%rax
mov    0x30(%rbp),%rdx
mov    (%rax,%rbx,8),%rsi
mov    (%rdx,%rbx,8),%rdi
callq  *0x40(%rbp)
test   %eax,%eax
je     4f0 <da_cmp_equal+0x30>
jmp    4d4 <da_cmp_equal+0x14>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_cmp_equal (struct darray * ar1, struct darray * ar2)
{
  size_t i;
  if (ar1->len != ar2->len)
    return 0;
  for (i = 0 ; i< ar1->len ; i++)
    if (ar1->cmp (ar1->content [i], ar2->content [i]))
      return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 10
10 10
11 5
12 10
13 10
14 10
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 10
33 10
34 9
35 10
36 10
37 10
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  100e <gen_form_begin+0xe>
mov    0x0(%rip),%rdi        # 1015 <gen_form_begin+0x15>
callq  0 <fix_attr_value>
mov    $0x0,%esi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  102e <gen_form_begin+0x2e>
mov    0x0(%rip),%eax        # 1034 <gen_form_begin+0x34>
test   %eax,%eax
je     1059 <gen_form_begin+0x59>
test   %rbx,%rbx
je     1059 <gen_form_begin+0x59>
mov    %rbx,%rdi
callq  0 <fix_attr_value>
mov    $0x0,%esi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  1059 <gen_form_begin+0x59>
mov    $0x0,%edi
mov    $0x0,%esi
callq  1068 <gen_form_begin+0x68>
pop    %rbx
mov    $0x0,%edi
jmpq   1073 <gen_form_begin+0x73>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gen_form_begin(const char *target)
{
 static STRBUF sb[1];
 strbuf_clear(sb);
 strbuf_sprintf(sb, "<form method='get' action='%s'", fix_attr_value(action));
 if (Fflag && target)
  strbuf_sprintf(sb, " target='%s'", fix_attr_value(target));
 strbuf_puts(sb, ">");
 return strbuf_value(sb);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 8
25 8
26 8
27 10
28 9
29 9
30 9
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x18,%rsp
mov    (%rsi),%rbp
mov    0x8(%rsi),%r13
test   %rbp,%rbp
jne    133 <gsl_permutation_fscanf+0x33>
jmp    178 <gsl_permutation_fscanf+0x78>
nopl   (%rax)
mov    0x8(%rsp),%rax
mov    %rax,0x0(%r13,%rbx,8)
add    $0x1,%rbx
cmp    %rbp,%rbx
je     178 <gsl_permutation_fscanf+0x78>
lea    0x8(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r12,%rdi
callq  147 <gsl_permutation_fscanf+0x47>
cmp    $0x1,%eax
je     120 <gsl_permutation_fscanf+0x20>
mov    $0x5,%ecx
mov    $0x69,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  165 <gsl_permutation_fscanf+0x65>
add    $0x18,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
gsl_permutation_fscanf (FILE * stream, gsl_permutation * p)
{
  size_t n = p->size ;
  size_t * data = p->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned long j ;
      int status = fscanf (stream, "%lu", &j);
      if (status != 1)
        {
          do { gsl_error ("fscanf failed", "file.c", 105, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
      data[i] = j;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 3
9 4
10 6
11 6
12 6
13 6
14 14
15 14
16 6
17 6
18 6
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 12
27 12
28 12
29 12
30 12
31 17
32 12
33 17
34 17
35 17
36 17
37 17
38 17
39 17
40 16
41 17
42 17
43 17
44 17
45 17
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8c0 <sdp_message_z_adjustments_get+0x10>
mov    0x98(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_z_adjustments_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->z_adjustments;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
movl   $0x0,0x0(%rip)        # 76a <set_dollar_vars_unchanged+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_dollar_vars_unchanged ()
{
  changed_dollar_vars = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 5a27 <unbind_nameref+0x7>
push   %rbx
mov    %rdi,%rbx
callq  5a30 <unbind_nameref+0x10>
test   %rax,%rax
je     5a3b <unbind_nameref+0x1b>
testb  $0x8,0x29(%rax)
jne    5a40 <unbind_nameref+0x20>
xor    %eax,%eax
pop    %rbx
retq   
nop
mov    %rbx,%rdi
mov    0x0(%rip),%rsi        # 5a4a <unbind_nameref+0x2a>
pop    %rbx
jmpq   5a50 <unbind_variable_noref>
<<<sep_in_sample>>>
unbind_nameref (name)
     const char *name;
{
  SHELL_VAR *v;
  v = var_lookup (name, shell_variables);
  if (v && ((((v)->attributes) & (0x0000800))))
    return makunbound (name, shell_variables);
  return 0;
}
<<<sep_in_sample>>>
1 5
2 3
3 3
4 5
5 6
6 6
7 6
8 6
9 9
10 9
11 9
12 9
13 7
14 7
15 9
16 7
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rsi
mov    %rdx,%rax
shl    $0xd,%rax
mov    %eax,%eax
xor    %rdx,%rax
shl    $0xc,%rdx
and    $0xffffe000,%edx
shr    $0x13,%rax
xor    %rdx,%rax
mov    0x8(%rdi),%rdx
mov    %rax,(%rdi)
lea    0x0(,%rdx,4),%rcx
mov    %ecx,%ecx
xor    %rdx,%rcx
shl    $0x4,%rdx
and    $0xffffff80,%edx
shr    $0x19,%rcx
xor    %rdx,%rcx
lea    0x0(,%rsi,8),%rdx
xor    %rcx,%rax
mov    %rcx,0x8(%rdi)
mov    %edx,%edx
xor    %rsi,%rdx
shl    $0x11,%rsi
shr    $0xb,%rdx
and    $0xffe00000,%esi
xor    %rsi,%rdx
mov    %rdx,0x10(%rdi)
xor    %rdx,%rax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taus_get (void *vstate)
{
  taus_state_t *state = (taus_state_t *) vstate;
  state->s1 = (((state->s1 &4294967294UL) <<12) &0xffffffffUL) ^ ((((state->s1 <<13) &0xffffffffUL)^state->s1) >>19);
  state->s2 = (((state->s2 &4294967288UL) <<4) &0xffffffffUL) ^ ((((state->s2 <<2) &0xffffffffUL)^state->s2) >>25);
  state->s3 = (((state->s3 &4294967280UL) <<17) &0xffffffffUL) ^ ((((state->s3 <<3) &0xffffffffUL)^state->s3) >>11);
  return (state->s1 ^ state->s2 ^ state->s3);
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 6
21 7
22 5
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 7
31 8
32 8
<<<sep_out_sample>>>
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
jmpq   1560 <quotearg_colon>
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,0x58(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk2imp_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  rk2imp_state_t *state = (rk2imp_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
lea    0x8(%rdi),%rsi
mov    %rdi,%rcx
xor    %r8d,%r8d
xor    %edx,%edx
mov    $0x2,%edi
jmpq   1586 <set_capability+0x16>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_capability(grecs_value_t *value, void *data)
{
    return enable_capability(grecs_callback_set_value,
        &value->locus, ((void *)0), value, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
test   %rdi,%rdi
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0x6666666666666667,%rsi
js     58 <offtostr+0x58>
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %rsi
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    20 <offtostr+0x20>
mov    %rcx,%rax
retq   
nopl   0x0(%rax)
mov    %rsi,%r8
mov    $0x30,%esi
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %r8
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
test   %rdx,%rdx
mov    %rdx,%rdi
mov    %al,(%rcx)
jne    60 <offtostr+0x60>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
offtostr (off_t i, char *buf)
{
  char *p = buf + ((sizeof (off_t) * 8 - (! ((__typeof__ (off_t)) 0 < (__typeof__ (off_t)) -1))) * 146 / 485 + (! ((__typeof__ (off_t)) 0 < (__typeof__ (off_t)) -1)) + 1);
  *p = 0;
  extern int (* verify_function__ (void)) [(!!sizeof (struct { unsigned int verify_error_if_negative_size__: ((! ((off_t) 0 < (off_t) -1)) == 1) ? 1 : -1; }))];
  if (i < 0)
    {
      do
 *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 6
2 3
3 4
4 16
5 6
6 6
7 16
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 16
17 16
18 17
19 16
20 17
21 17
22 20
23 20
24 20
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 10
38 10
39 9
40 10
41 9
42 11
43 11
44 20
45 20
<<<sep_out_sample>>>
mov    0x8(%rsi),%rcx
mov    %rdi,%rax
cmp    %rdx,%rcx
jbe    2c38 <gsl_matrix_int_superdiagonal+0x48>
mov    0x18(%rsi),%rdi
sub    %rdx,%rcx
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdx,4),%r8
mov    0x10(%rsi),%rdi
mov    (%rsi),%rdx
mov    %r8,0x10(%rax)
lea    0x1(%rdi),%r9
mov    0x20(%rsi),%rdi
cmp    %rdx,%rcx
cmova  %rdx,%rcx
mov    %rcx,(%rax)
mov    %r9,0x8(%rax)
mov    %rdi,0x18(%rax)
retq   
nopl   0x0(%rax)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x76,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2c5a <gsl_matrix_int_superdiagonal+0x6a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_superdiagonal (gsl_matrix_int * m,
                                      const size_t k)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (k >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 118, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + k * 1;
    v.size = ((m->size1) < (m->size2 - k) ? (m->size1) : (m->size2 - k));
    v.stride = m->tda + 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 11
6 12
7 17
8 11
9 13
10 12
11 17
12 13
13 14
14 12
15 12
16 17
17 17
18 17
19 17
20 17
21 3
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 19
35 19
36 19
<<<sep_out_sample>>>
mov    0x50(%rdi),%rdi
xor    %edx,%edx
jmpq   55b <exact_match+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
exact_match(struct gcide_db *db, const char *hw)
{
    return gcide_idx_locate(db->idx, (char*)hw, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x0,%esi
jmpq   20c <destroy_string_list+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
destroy_string_list (ANUBIS_LIST * plist)
{
  list_destroy (plist, anubis_free_list_item, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
movsd  0x250(%rdi),%xmm0
xorpd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm0        # 14 <magHeading+0x14>
ucomisd %xmm0,%xmm1
ja     20 <magHeading+0x20>
repz retq 
nopl   0x0(%rax)
addsd  0x0(%rip),%xmm0        # 28 <magHeading+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
magHeading(craft * c)
{
 register double h = c->curHeading + mag_var;
 return (h < 0.0) ? h + 2.0 * 3.14159265358979323846 : h;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 4
6 5
7 5
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_size (gl_list_t list)
{
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4d0 <mu_folder_open+0x10>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     4d0 <mu_folder_open+0x10>
jmpq   *%rax
mov    $0x26,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_folder_open (mu_folder_t folder, int flags)
{
  if (folder == ((void *)0) || folder->_open == ((void *)0))
    return 38;
  return folder->_open (folder, flags);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    $0x16,%eax
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     a62 <mu_list_get+0x62>
test   %rdx,%rdx
mov    %rdx,%r12
mov    $0x1005,%ax
je     a62 <mu_list_get+0x62>
mov    0x20(%rdi),%rdi
mov    %rsi,%rbp
callq  a29 <mu_list_get+0x29>
mov    0x8(%rbx),%rax
cmp    %rbx,%rax
je     a52 <mu_list_get+0x52>
xor    %ecx,%ecx
test   %rbp,%rbp
jne    a45 <mu_list_get+0x45>
jmp    a70 <mu_list_get+0x70>
nopl   0x0(%rax,%rax,1)
cmp    %rbp,%rcx
je     a70 <mu_list_get+0x70>
mov    0x8(%rax),%rax
add    $0x1,%rcx
cmp    %rbx,%rax
jne    a40 <mu_list_get+0x40>
mov    $0x1028,%ebp
mov    0x20(%rbx),%rdi
callq  a60 <mu_list_get+0x60>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rax),%rax
xor    %ebp,%ebp
mov    %rax,(%r12)
jmp    a57 <mu_list_get+0x57>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_get (mu_list_t list, size_t indx, void **pitem)
{
  struct list_data *current;
  size_t count;
  int status = (0x1000 +40);
  if (list == ((void *)0))
    return 22;
  if (pitem == ((void *)0))
    return (0x1000 +5);
  mu_monitor_rdlock (list->monitor);
  for (current = list->head.next, count = 0; current != &list->head;
       current = current->next, count++)
    {
      if (count == indx)
        {
          *pitem = current->item;
   status = 0;
   break;
        }
    }
  mu_monitor_unlock (list->monitor);
  return status;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 2
5 2
6 2
7 6
8 8
9 8
10 9
11 8
12 10
13 10
14 10
15 11
16 11
17 11
18 11
19 14
20 14
21 14
22 14
23 14
24 14
25 12
26 12
27 11
28 11
29 5
30 21
31 21
32 22
33 23
34 23
35 23
36 23
37 23
38 16
39 17
40 16
41 18
42 18
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
movzwl (%rcx),%eax
je     1355 <gsl_vector_ushort_min+0x35>
lea    (%rdx,%rdx,1),%rdi
xor    %edx,%edx
nopl   0x0(%rax)
movzwl (%rcx),%esi
cmp    %si,%ax
cmova  %esi,%eax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    1340 <gsl_vector_ushort_min+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_min (const gsl_vector_ushort * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned short min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned short x = v->data[i*stride];
      if (x < min)
        min = x;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # 168b <find_global_variable_noref+0xb>
callq  1690 <find_global_variable_noref+0x10>
test   %rax,%rax
je     16b0 <find_global_variable_noref+0x30>
mov    0x18(%rax),%rdx
test   %rdx,%rdx
je     16b8 <find_global_variable_noref+0x38>
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   *%rdx
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
find_global_variable_noref (name)
     const char *name;
{
  SHELL_VAR *var;
  var = var_lookup (name, global_variables);
  if (var == 0)
    return ((SHELL_VAR *)((void *)0));
  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 6
5 6
6 8
7 8
8 8
9 8
10 9
11 8
12 8
13 7
14 7
15 9
16 9
17 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  e9 <swheaderline_get_type+0x9>
test   %rax,%rax
je     100 <swheaderline_get_type+0x20>
movzbl (%rax),%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swheaderline_get_type(char *output_line)
{
 char * p = swheaderline_get_type_pointer(output_line);
 if (p) return *p; else return (char)(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 4
10 5
11 5
12 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  25be <display_cursor_at_point+0xe>
mov    %eax,%ebx
sub    0x38(%rbp),%ebx
mov    %rbp,%rdi
add    0x20(%rbp),%ebx
callq  25ce <display_cursor_at_point+0x1e>
mov    %eax,%edi
mov    %ebx,%esi
callq  25d7 <display_cursor_at_point+0x27>
mov    0x0(%rip),%rdi        # 25de <display_cursor_at_point+0x2e>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   25e9 <display_cursor_at_point+0x39>
<<<sep_in_sample>>>
display_cursor_at_point (WINDOW *window)
{
  int vpos, hpos;
  vpos = window_line_of_point (window) - window->pagetop + window->first_row;
  hpos = window_get_cursor_column (window);
  terminal_goto_xy (hpos, vpos);
  fflush (stdout);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 5
9 4
10 5
11 6
12 6
13 6
14 7
15 8
16 8
17 8
18 7
<<<sep_out_sample>>>
mov    (%rdi),%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicat_req_get_pre_result(SWICAT_REQ * req)
{
 return req->pre_resultM;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    (%rdi),%rdi
movslq 0x8(%rsi),%rdx
add    $0xc,%rsi
jmpq   83 <restore_variable+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
restore_variable (sv)
     SAVED_VAR *sv;
{
  __builtin_memcpy ((sv->variable), (sv->desired_setting), (sv->size));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x20(%rsi),%rsi
mov    (%rax),%rdx
jmpq   19f <nettle_buffer_copy+0xf>
<<<sep_in_sample>>>
nettle_buffer_copy(struct nettle_buffer *dst,
     const struct nettle_buffer *src)
{
  return nettle_buffer_write(dst, src->size, src->contents);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rax
test   %rcx,%rcx
mov    (%rax),%rsi
je     24a <gsl_permutation_canonical_cycles+0x3a>
lea    0x8(%rax),%rdx
lea    (%rax,%rcx,8),%rdi
mov    $0x1,%eax
jmp    243 <gsl_permutation_canonical_cycles+0x33>
xchg   %ax,%ax
mov    (%rdx),%rcx
cmp    %rcx,%rsi
jbe    23f <gsl_permutation_canonical_cycles+0x2f>
add    $0x1,%rax
mov    %rcx,%rsi
add    $0x8,%rdx
cmp    %rdi,%rdx
jne    230 <gsl_permutation_canonical_cycles+0x20>
repz retq 
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
gsl_permutation_canonical_cycles (const gsl_permutation * p)
{
  size_t i;
  size_t count = 1;
  size_t min = p->data[0];
  for (i = 0; i < p->size; i++)
    {
      if (p->data[i] < min)
        {
          min = p->data[i];
          count++;
        }
    }
  return count;
}
<<<sep_in_sample>>>
1 6
2 5
3 6
4 5
5 6
6 6
7 6
8 4
9 4
10 4
11 8
12 8
13 8
14 11
15 11
16 11
17 6
18 6
19 6
20 4
21 15
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  fe <string_htable_free+0xe>
mov    %rbx,%rdi
pop    %rbx
jmpq   107 <string_htable_free+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_htable_free (struct string_htable * table)
{
  hash_free (table, (hash_map_func_t) free);
  free (table);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1797 <mu_cfg_get_debug+0x7>
test   %rax,%rax
je     17a0 <mu_cfg_get_debug+0x10>
retq   
nopl   (%rax)
sub    $0x8,%rsp
xor    %esi,%esi
mov    $0x0,%edi
callq  17b0 <mu_cfg_get_debug+0x20>
mov    0x0(%rip),%rdi        # 17b7 <mu_cfg_get_debug+0x27>
xor    %edx,%edx
mov    $0x0,%esi
callq  17c3 <mu_cfg_get_debug+0x33>
mov    $0x0,%edi
callq  17cd <mu_cfg_get_debug+0x3d>
mov    0x0(%rip),%rdi        # 17d4 <mu_cfg_get_debug+0x44>
mov    %eax,%esi
callq  17db <mu_cfg_get_debug+0x4b>
mov    0x0(%rip),%rax        # 17e2 <mu_cfg_get_debug+0x52>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_get_debug ()
{
  if (!_mu_cfg_debug)
    {
      mu_debug_create (&_mu_cfg_debug, ((void *)0));
      mu_debug_set_print (_mu_cfg_debug, _cfg_default_printer, ((void *)0));
      mu_debug_set_level (_mu_cfg_debug, mu_global_debug_level ("config"));
    }
  return _mu_cfg_debug;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 10
5 10
6 2
7 5
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 7
16 7
17 7
18 7
19 7
20 10
21 10
22 10
<<<sep_out_sample>>>
jmpq   5 <idn_free+0x5>
<<<sep_in_sample>>>
idn_free (void *ptr)
{
  free (ptr);
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
cmp    $0xa9,%rdx
jle    810 <__gmpn_invertappr+0x10>
jmpq   80e <__gmpn_invertappr+0xe>
xchg   %ax,%ax
jmpq   0 <mpn_bc_invertappr>
<<<sep_in_sample>>>
__gmpn_invertappr (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr scratch)
{
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do {} while (0);
  if ((! ((__builtin_constant_p (170) && (170) == 0) || (!(__builtin_constant_p (170) && (170) == 9223372036854775807L) && (n) >= (170)))))
    return mpn_bc_invertappr (ip, dp, n, scratch);
  else
    return __gmpn_ni_invertappr (ip, dp, n, scratch);
}
<<<sep_in_sample>>>
1 8
2 8
3 11
4 11
5 9
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdi
jmpq   7d9 <xformat_set_gid+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_set_gid (XFORMAT * xux, gid_t gid)
{
 ;
        ahs_set_gid(xux->ahsM, gid);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
mov    %rsi,0x30(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_digest (osip_authorization_t * authorization, char *digest)
{
  authorization->digest = (char *) digest;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
mov    (%rsi),%rax
mov    (%rdi),%rdx
mov    0x8(%rax),%rax
sub    0x8(%rdx),%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
pack_compare_fn(first, second)
    const void *first;
    const void *second;
{
    return (*(const dir_entry_t * const *)second)->size -
    (*(const dir_entry_t * const *)first)->size;
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 5
5 7
6 7
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_set_opaque (osip_authentication_info_t *
       authentication_info, char *opaque)
{
  authentication_info->opaque = (char *) opaque;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
mov    %rdi,%r12
push   %rbp
push   %rbx
je     b58 <array_to_word_list+0x68>
mov    0x10(%rdi),%eax
test   %eax,%eax
je     b58 <array_to_word_list+0x68>
mov    0x18(%rdi),%rax
mov    0x10(%rax),%rbx
cmp    %rbx,%rax
je     b58 <array_to_word_list+0x68>
xor    %ebp,%ebp
nopw   0x0(%rax,%rax,1)
mov    0x8(%rbx),%rdi
callq  b21 <array_to_word_list+0x31>
mov    %rbp,%rsi
mov    %rax,%rdi
callq  b2c <array_to_word_list+0x3c>
mov    0x10(%rbx),%rbx
cmp    %rbx,0x18(%r12)
mov    %rax,%rbp
jne    b18 <array_to_word_list+0x28>
test   %rax,%rax
je     b58 <array_to_word_list+0x68>
cmpq   $0x0,(%rax)
je     b5a <array_to_word_list+0x6a>
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdi
xor    %eax,%eax
jmpq   b53 <array_to_word_list+0x63>
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
<<<sep_in_sample>>>
array_to_word_list(a)
ARRAY *a;
{
 WORD_LIST *list;
 ARRAY_ELEMENT *ae;
 if (a == 0 || ((a)->num_elements == 0))
  return((WORD_LIST *)((void *)0));
 list = (WORD_LIST *)((void *)0);
 for (ae = ((a->head)->next); ae != a->head; ae = ((ae)->next))
  list = make_word_list (make_bare_word(((ae)->value)), list);
 return (((list && list->next) ? (WORD_LIST *)list_reverse ((GENERIC_LIST *)list) : (WORD_LIST *)(list)));
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 3
5 3
6 6
7 6
8 6
9 6
10 9
11 9
12 9
13 9
14 8
15 8
16 10
17 10
18 10
19 10
20 10
21 9
22 9
23 10
24 9
25 11
26 11
27 11
28 11
29 12
30 12
31 12
32 11
33 11
34 11
35 11
36 7
37 12
38 12
39 12
40 12
41 12
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 1366 <getKey+0x6>
xor    %eax,%eax
test   %edx,%edx
jne    1378 <getKey+0x18>
jmpq   1371 <getKey+0x11>
nopl   0x0(%rax)
jmpq   137d <getKey+0x1d>
<<<sep_in_sample>>>
getKey()
{
  if(X_IS_RUNNING) return getKeyUnderX();
  else return getKeyUnderConsole();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 3
<<<sep_out_sample>>>
cmp    $0x1,%edi
jle    c40 <modecmd+0xe0>
push   %r12
cmp    $0x2,%edi
mov    %rsi,%r12
push   %rbp
push   %rbx
je     be0 <modecmd+0x80>
mov    (%r12),%rsi
xor    %eax,%eax
mov    $0x0,%edi
mov    $0x0,%ebp
mov    $0x0,%ebx
mov    $0x0,%r12d
callq  b95 <modecmd+0x35>
mov    0x0(%rip),%rdx        # b9c <modecmd+0x3c>
test   %rdx,%rdx
je     bcb <modecmd+0x6b>
nopl   0x0(%rax)
mov    %rbx,%rsi
xor    %eax,%eax
mov    $0x0,%edi
callq  bb7 <modecmd+0x57>
cmpb   $0x20,(%rbx)
cmove  %r12,%rbx
add    $0x10,%rbp
mov    0x0(%rbp),%rdx
test   %rdx,%rdx
jne    ba8 <modecmd+0x48>
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x0,%edi
jmpq   bd9 <modecmd+0x79>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # be7 <modecmd+0x87>
mov    0x8(%r12),%rbp
test   %rsi,%rsi
je     c28 <modecmd+0xc8>
mov    $0x0,%ebx
jmp    c0c <modecmd+0xac>
nopl   0x0(%rax,%rax,1)
add    $0x10,%rbx
mov    (%rbx),%rsi
test   %rsi,%rsi
je     c28 <modecmd+0xc8>
mov    %rbp,%rdi
callq  c14 <modecmd+0xb4>
test   %eax,%eax
jne    c00 <modecmd+0xa0>
mov    0x8(%rbx),%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   b00 <settftpmode>
nopl   (%rax)
mov    %rbp,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  c37 <modecmd+0xd7>
jmpq   b75 <modecmd+0x15>
nopl   0x0(%rax)
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
jmpq   c51 <modecmd+0xf1>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
modecmd (int argc, char *argv[])
{
  register struct modes *p;
  char *sep;
  if (argc < 2)
    {
      printf ("Using %s mode to transfer files.\n", mode);
      return;
    }
  if (argc == 2)
    {
      for (p = modes; p->m_name; p++)
 if (strcmp (argv[1], p->m_name) == 0)
   break;
      if (p->m_name)
 {
   settftpmode (p->m_mode);
   return;
 }
      printf ("%s: unknown mode\n", argv[1]);
    }
  printf ("usage: %s [", argv[0]);
  sep = " ";
  for (p = modes; p->m_name; p++)
    {
      printf ("%s%s", sep, p->m_name);
      if (*sep == ' ')
 sep = " | ";
    }
  printf (" ]\n");
  return;
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 10
5 10
6 2
7 2
8 10
9 22
10 22
11 22
12 24
13 23
14 28
15 22
16 24
17 24
18 24
19 24
20 26
21 26
22 26
23 26
24 28
25 28
26 24
27 24
28 24
29 24
30 32
31 32
32 32
33 30
34 30
35 30
36 12
37 12
38 12
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 13
48 13
49 13
50 13
51 17
52 32
53 32
54 32
55 17
56 17
57 20
58 20
59 20
60 20
61 20
62 20
63 7
64 7
65 7
66 7
67 7
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   468 <rec_sex_ast_print+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_print (rec_sex_ast_t ast)
{
  rec_sex_ast_print_node (ast->top);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x40(%rdi),%rsi
cmp    %rsi,0x58(%rdi)
cmovbe 0x58(%rdi),%rsi
mov    0x30(%rdi),%rax
cmp    %rax,%rsi
jbe    4e <re_string_translate_buffer+0x4e>
nopw   %cs:0x0(%rax,%rax,1)
mov    %rax,%rdx
add    (%rdi),%rdx
mov    0x78(%rdi),%rcx
add    0x28(%rdi),%rdx
movzbl (%rdx),%edx
movzbl (%rcx,%rdx,1),%ecx
mov    0x8(%rdi),%rdx
mov    %cl,(%rdx,%rax,1)
add    $0x1,%rax
cmp    %rsi,%rax
jne    20 <re_string_translate_buffer+0x20>
mov    %rsi,0x30(%rdi)
mov    %rsi,0x38(%rdi)
retq   
mov    %rax,%rsi
jmp    45 <re_string_translate_buffer+0x45>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
re_string_translate_buffer (re_string_t *pstr)
{
  Idx buf_idx, end_idx;
  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)
    {
      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];
      pstr->mbs[buf_idx] = pstr->trans[ch];
    }
  pstr->valid_len = buf_idx;
  pstr->valid_raw_len = buf_idx;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 8
13 8
14 8
15 8
16 5
17 5
18 5
19 10
20 11
21 11
22 5
23 5
24 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_len (Buffer *buffer)
{
  return buffer->len;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <__rsystemerror+0x9>
mov    0x0(%rip),%rdi        # 10 <__rsystemerror+0x10>
mov    %rbx,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  1f <__rsystemerror+0x1f>
mov    $0x1,%edi
callq  29 <__rsystemerror+0x29>
<<<sep_in_sample>>>
__rsystemerror (char *s)
{
  __rprintfilline ();
  (void) fprintf (stderr, "SYSTEM-ERROR: %s\n", s);
  exit (1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r12
test   %edx,%edx
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
jne    7f8 <dosetenv+0x28>
callq  7e3 <dosetenv+0x13>
xor    %edx,%edx
test   %rax,%rax
je     7f8 <dosetenv+0x28>
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
mov    %rbx,%rdi
callq  800 <dosetenv+0x30>
mov    %r12,%rdi
mov    %rax,%rbp
callq  80b <dosetenv+0x3b>
lea    0x2(%rbp,%rax,1),%edi
movslq %edi,%rdi
callq  817 <dosetenv+0x47>
test   %rax,%rax
mov    %rax,%rbp
je     848 <dosetenv+0x78>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  82a <dosetenv+0x5a>
lea    0x1(%rax),%rdi
mov    %r12,%rsi
movb   $0x3d,(%rax)
callq  839 <dosetenv+0x69>
pop    %rbx
mov    %rbp,%rdi
pop    %rbp
pop    %r12
jmpq   845 <dosetenv+0x75>
nopl   (%rax)
callq  84d <dosetenv+0x7d>
test   %rax,%rax
mov    %rax,%rbp
jne    81f <dosetenv+0x4f>
mov    $0x1,%edx
jmp    7ea <dosetenv+0x1a>
nopl   0x0(%rax)
<<<sep_in_sample>>>
dosetenv(const char *name, const char *value, int overwrite)
{
    int i;
    char * a;
    if (!overwrite && getenv(name)) return 0;
    i = strlen(name) + strlen(value) + 2;
    a = (malloc(i) ? : vmefail());
    if (!a) return 1;
    strcpy(a, name);
    strcat(a, "=");
    strcat(a, value);
    return putenv(a);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 5
12 13
13 13
14 13
15 13
16 13
17 13
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 9
30 9
31 9
32 11
33 11
34 10
35 11
36 13
37 12
38 13
39 13
40 12
41 12
42 7
43 8
44 7
45 8
46 8
47 8
48 8
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rdi,%r9
and    $0x3,%edi
shr    $0x2,%r9
test   %r9,%r9
je     72 <_nettle_write_le32+0x72>
lea    (%rsi,%r9,4),%r8
mov    %rdx,%rax
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rax),%ecx
add    $0x4,%rsi
add    $0x4,%rax
shr    $0x18,%ecx
mov    %cl,-0x1(%rsi)
mov    -0x4(%rax),%ecx
shr    $0x10,%ecx
mov    %cl,-0x2(%rsi)
mov    -0x4(%rax),%ecx
shr    $0x8,%ecx
mov    %cl,-0x3(%rsi)
mov    -0x4(%rax),%ecx
mov    %cl,-0x4(%rsi)
cmp    %r8,%rsi
jne    20 <_nettle_write_le32+0x20>
test   %edi,%edi
je     70 <_nettle_write_le32+0x70>
mov    (%rdx,%r9,4),%eax
lea    -0x1(%rdi),%edx
lea    0x1(%r8,%rdx,1),%rdx
nopl   (%rax)
add    $0x1,%r8
mov    %al,-0x1(%r8)
shr    $0x8,%eax
cmp    %rdx,%r8
jne    60 <_nettle_write_le32+0x60>
repz retq 
mov    %rsi,%r8
jmp    4d <_nettle_write_le32+0x4d>
<<<sep_in_sample>>>
_nettle_write_le32(size_t length, uint8_t *dst,
     uint32_t *src)
{
  size_t i;
  size_t words;
  unsigned leftover;
  words = length / 4;
  leftover = length % 4;
  for (i = 0; i < words; i++, dst += 4)
    do { (dst)[3] = ((src[i]) >> 24) & 0xff; (dst)[2] = ((src[i]) >> 16) & 0xff; (dst)[1] = ((src[i]) >> 8) & 0xff; (dst)[0] = (src[i]) & 0xff; } while(0);
  if (leftover)
    {
      uint32_t word;
      word = src[i];
      do
 {
   *dst++ = word & 0xff;
   word >>= 8;
 }
      while (--leftover);
    }
}
<<<sep_in_sample>>>
1 7
2 8
3 7
4 9
5 9
6 9
7 9
8 9
9 10
10 9
11 9
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 9
23 9
24 11
25 11
26 14
27 14
28 14
29 14
30 17
31 17
32 18
33 20
34 20
35 20
36 9
37 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
jmpq   16f3 <quotearg_custom_mem+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,0xc(%rsp)
mov    0xc(%rsp),%edi
lea    0xc(%rsp),%rsi
callq  d6 <recurse+0x16>
mov    (%rax),%eax
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
recurse (volatile int n)
{
  return *recurse_1 (n, &n);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 11b6 <blank_edit+0x6>
push   %rbx
xor    %ebx,%ebx
test   %eax,%eax
jle    11e1 <blank_edit+0x31>
nopl   (%rax)
mov    0x0(%rip),%ecx        # 11c6 <blank_edit+0x16>
mov    0x0(%rip),%rdi        # 11cd <blank_edit+0x1d>
xor    %edx,%edx
mov    %ebx,%esi
add    $0x1,%ebx
callq  11d9 <blank_edit+0x29>
cmp    %ebx,0x0(%rip)        # 11df <blank_edit+0x2f>
jg     11c0 <blank_edit+0x10>
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
blank_edit(void)
{
    int i;
    for (i = 0; i < editwinrows; i++)
 blank_line(edit, i, 0, COLS);
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 5
10 5
11 4
12 5
13 4
14 4
15 6
16 6
17 6
<<<sep_out_sample>>>
test   %rdi,%rdi
lea    0x14(%rsi),%rcx
movb   $0x0,0x14(%rsi)
movabs $0x6666666666666667,%rsi
js     58 <imaxtostr+0x58>
nopw   0x0(%rax,%rax,1)
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %rsi
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
add    %rax,%rax
sub    %rax,%rdi
add    $0x30,%edi
test   %rdx,%rdx
mov    %dil,(%rcx)
mov    %rdx,%rdi
jne    20 <imaxtostr+0x20>
mov    %rcx,%rax
retq   
nopl   0x0(%rax)
mov    %rsi,%r8
mov    $0x30,%esi
mov    %rdi,%rax
sub    $0x1,%rcx
imul   %r8
mov    %rdi,%rax
sar    $0x3f,%rax
sar    $0x2,%rdx
sub    %rax,%rdx
lea    (%rdx,%rdx,4),%rax
lea    (%rsi,%rax,2),%eax
sub    %edi,%eax
test   %rdx,%rdx
mov    %rdx,%rdi
mov    %al,(%rcx)
jne    60 <imaxtostr+0x60>
mov    %rcx,%rax
sub    $0x1,%rcx
movb   $0x2d,-0x1(%rax)
mov    %rcx,%rax
retq   
<<<sep_in_sample>>>
imaxtostr (intmax_t i, char *buf)
{
  char *p = buf + ((sizeof (intmax_t) * 8 - (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1))) * 146 / 485 + (! ((__typeof__ (intmax_t)) 0 < (__typeof__ (intmax_t)) -1)) + 1);
  *p = 0;
  if (i < 0)
    {
      do
 *--p = '0' - i % 10;
      while ((i /= 10) != 0);
      *--p = '-';
    }
  else
    {
      do
 *--p = '0' + i % 10;
      while ((i /= 10) != 0);
    }
  return p;
}
<<<sep_in_sample>>>
1 5
2 3
3 4
4 15
5 5
6 5
7 15
8 15
9 15
10 15
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 16
19 15
20 16
21 16
22 19
23 19
24 19
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 8
35 8
36 8
37 9
38 9
39 8
40 9
41 8
42 10
43 10
44 19
45 19
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x18(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
fd_ostream_write_mem (fd_ostream_t first_arg, const void *data, size_t len)
{
  const struct fd_ostream_implementation *vtable =
    ((struct fd_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->write_mem (first_arg,data,len);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  7ac <gsl_sf_hyperg_0F1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    7c0 <gsl_sf_hyperg_0F1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xb1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  7d6 <gsl_sf_hyperg_0F1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_0F1(const double c, const double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_0F1_e(c, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_0F1_e(c, x, &result)", "hyperg_0F1.c", 177, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdx,%rax
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    %rax,%rsi
sub    $0x30,%rsp
mov    %rsp,%rdx
mov    %fs:0x28,%rcx
mov    %rcx,0x28(%rsp)
xor    %ecx,%ecx
callq  49 <time_to_env+0x29>
mov    $0x1,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  59 <time_to_env+0x39>
test   %eax,%eax
je     62 <time_to_env+0x42>
callq  62 <time_to_env+0x42>
mov    0x28(%rsp),%rax
xor    %fs:0x28,%rax
je     77 <time_to_env+0x57>
callq  77 <time_to_env+0x57>
add    $0x30,%rsp
pop    %rbx
retq   
<<<sep_in_sample>>>
time_to_env (char const *envar, struct timespec t)
{
  char buf[TIMESPEC_STRSIZE_BOUND];
  if (setenv (envar, code_timespec (t, buf), 1) != 0)
    xalloc_die ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 2
9 2
10 2
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 5
19 6
20 6
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     908 <ds_database+0x18>
mov    0x8(%rsi),%rsi
mov    $0x0,%edi
jmpq   903 <ds_database+0x13>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rax        # 90f <ds_database+0x1f>
mov    $0x0,%edi
test   %rax,%rax
cmovne %rax,%rdi
jmpq   920 <ds_compl_database>
<<<sep_in_sample>>>
ds_database(int argc, char **argv)
{
    if (argc == 1) {
 printf("%s\n", dico_url.req.database ? dico_url.req.database : "!");
    } else
 xdico_assign_string(&dico_url.req.database, argv[1]);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 4
8 4
9 4
10 4
11 4
<<<sep_out_sample>>>
mov    $0xffffffff,%edx
xor    %esi,%esi
jmpq   a8c <read_history+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
read_history (filename)
     const char *filename;
{
  return (read_history_range (filename, 0, -1));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %rbx
xor    %ecx,%ecx
xor    %esi,%esi
mov    $0x2,%edx
mov    %rdi,%rbx
sub    $0x10,%rsp
callq  3a6 <getkey+0x16>
mov    0x0(%rip),%eax        # 3ac <getkey+0x1c>
test   %eax,%eax
jne    3b9 <getkey+0x29>
cmp    0x0(%rip),%rbx        # 3b7 <getkey+0x27>
je     408 <getkey+0x78>
lea    0xf(%rsp),%rdi
mov    %rbx,%rcx
mov    $0x1,%edx
mov    $0x1,%esi
callq  3d0 <getkey+0x40>
test   %rax,%rax
jne    3f8 <getkey+0x68>
callq  3da <getkey+0x4a>
cmpl   $0x4,(%rax)
sete   %al
add    $0x10,%rsp
movzbl %al,%eax
lea    0x4(,%rax,8),%rax
pop    %rbx
retq   
nopl   0x0(%rax)
movzbl 0xf(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  40d <getkey+0x7d>
jmp    3b9 <getkey+0x29>
<<<sep_in_sample>>>
getkey(FILE * stream)
{
  Cell result;
  unsigned char c;
  setvbuf(stream, ((void *)0), 2, 0);
  if(!terminal_prepped && stream == stdin)
    prep_terminal();
  result = fread(&c, sizeof(c), 1, stream);
  return result==0 ? ((*__errno_location ()) == 4 ? 12 : 4) : c;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 2
6 2
7 5
8 6
9 6
10 6
11 6
12 6
13 8
14 8
15 8
16 8
17 8
18 9
19 9
20 9
21 9
22 9
23 10
24 9
25 9
26 10
27 10
28 10
29 9
30 10
31 10
32 10
33 10
34 7
35 7
<<<sep_out_sample>>>
mov    %edi,%edi
shl    $0x5,%rdi
add    0x0(%rip),%rdi        # 33d <get_file_modified_time+0xd>
cmpq   $0x0,0x18(%rdi)
je     350 <get_file_modified_time+0x20>
add    $0x18,%rdi
jmpq   34d <get_file_modified_time+0x1d>
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_file_modified_time(unsigned int this_file_number)
{
  if (files[this_file_number].modified == 0)
    return ((void *)0);
  return localtime(&files[this_file_number].modified);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 6
10 6
11 6
<<<sep_out_sample>>>
test   %r8,%r8
mov    %rcx,%rsi
mov    %r8,%rdx
jle    4d <hgcd_hook+0x4d>
lea    0x0(,%r8,8),%r8
cmpq   $0x0,-0x8(%rcx,%r8,1)
jne    53 <hgcd_hook+0x53>
lea    -0x1(%rdx),%rax
lea    0x0(,%rax,8),%r10
jmp    43 <hgcd_hook+0x43>
nopl   0x0(%rax)
cmpq   $0x0,-0x8(%rsi,%r10,1)
lea    -0x8(%r10),%r11
jne    50 <hgcd_hook+0x50>
mov    %r11,%r10
sub    $0x1,%rax
test   %rax,%rax
mov    %rax,%rdx
jne    30 <hgcd_hook+0x30>
repz retq 
repz retq 
nop
mov    %r10,%r8
add    %rsi,%r8
mov    %r9d,%ecx
jmpq   5e <hgcd_hook+0x5e>
xchg   %ax,%ax
<<<sep_in_sample>>>
hgcd_hook (void *p, mp_srcptr gp, mp_size_t gn,
    mp_srcptr qp, mp_size_t qn, int d)
{
  do {} while (0);
  do {} while (0);
  do {} while (0);
  do { while ((qn) > 0) { if ((qp)[(qn) - 1] != 0) break; (qn)--; } } while (0);
  if (qn > 0)
    {
      struct hgcd_matrix *M = (struct hgcd_matrix *) p;
      mp_ptr tp = (mp_ptr) qp + qn;
      __gmpn_hgcd_matrix_update_q (M, qp, qn, d, tp);
    }
}
<<<sep_in_sample>>>
1 7
2 3
3 3
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 12
25 12
26 12
27 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  329 <file_error+0x9>
mov    (%rax),%edi
callq  330 <file_error+0x10>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
pop    %rbx
xor    %eax,%eax
jmpq   343 <file_error+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_error (filename)
     const char *filename;
{
  report_error ("%s: %s", filename, strerror ((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 4
11 4
12 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
xor    %esi,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x50(%rdi),%rbp
callq  1050 <mbox_messages_count>
test   %eax,%eax
jne    10df <mbox_uidnext+0x2f>
cmpq   $0x0,0x10(%rbp)
je     10e8 <mbox_uidnext+0x38>
test   %r12,%r12
je     10dd <mbox_uidnext+0x2d>
mov    0x28(%rbp),%rax
mov    %rax,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
xor    %ecx,%ecx
xor    %edx,%edx
mov    $0x1,%esi
mov    %rbx,%rdi
callq  10f9 <mbox_uidnext+0x49>
test   %eax,%eax
jne    10df <mbox_uidnext+0x2f>
test   %r12,%r12
jne    10d5 <mbox_uidnext+0x25>
jmp    10dd <mbox_uidnext+0x2d>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_uidnext (mu_mailbox_t mailbox, size_t *puidnext)
{
  mbox_data_t mud = mailbox->data;
  int status = mbox_messages_count (mailbox, ((void *)0));
  if (status != 0)
    return status;
  if (mud->messages_count == 0)
    {
      status = mbox_scan0 (mailbox, 1, ((void *)0), 0);
      if (status != 0)
 return status;
    }
  if (puidnext)
    *puidnext = mud->uidnext;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 3
8 4
9 5
10 5
11 7
12 7
13 13
14 13
15 14
16 14
17 15
18 16
19 16
20 16
21 16
22 16
23 9
24 9
25 9
26 9
27 9
28 10
29 10
30 13
31 13
32 13
33 13
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 1660 <find_component_keyword+0x10>
test   %rdi,%rdi
je     1698 <find_component_keyword+0x48>
mov    $0x0,%ebx
jmp    167c <find_component_keyword+0x2c>
nopl   0x0(%rax)
add    $0x48,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     1698 <find_component_keyword+0x48>
mov    %rbp,%rsi
callq  1684 <find_component_keyword+0x34>
test   %eax,%eax
jne    1670 <find_component_keyword+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_component_keyword (const char *ident)
{
  struct grecs_keyword *kwp;
  for (kwp = component_keywords; kwp->ident; kwp++)
    if (strcmp (kwp->ident, ident) == 0)
      return kwp;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 8
29 8
30 8
<<<sep_out_sample>>>
mov    %esi,0x18(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
output_to_void (struct output * out, int forget)
{
  out->to_void = forget;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
jmpq   5 <file_free_callback+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
file_free_callback (void *cls)
{
  FILE *file = cls;
  fclose (file);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movslq (%rdi),%rax
movl   $0x1,0x0(,%rax,4)
mov    $0x1,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fire_aim120(craft * c)
{
 hasFired[c->pIndex] = 1;
 return 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    %esi,%eax
and    $0x1,%eax
mov    %eax,(%rdi)
mov    %esi,%eax
and    $0x8,%esi
shr    %al
and    $0x1,%eax
cmp    $0x1,%sil
mov    %eax,0x4(%rdi)
sbb    %eax,%eax
and    $0xfffffffe,%eax
add    $0x4,%eax
mov    %eax,0x8(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_track_flags(track_flags_t *p_track_flag, uint8_t i_flag)
{
  p_track_flag->preemphasis = ( i_flag & CDIO_TRACK_FLAG_PRE_EMPHASIS )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->copy_permit = ( i_flag & CDIO_TRACK_FLAG_COPY_PERMITTED )
    ? CDIO_TRACK_FLAG_TRUE : CDIO_TRACK_FLAG_FALSE;
  p_track_flag->channels = ( i_flag & CDIO_TRACK_FLAG_FOUR_CHANNEL_AUDIO )
    ? 4 : 2;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 7
6 6
7 6
8 8
9 5
10 8
11 8
12 8
13 7
14 7
15 7
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %r12
mov    $0x8,%ecx
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
mov    %rsi,%rbx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     79 <fatFreeWithDir+0x29>
mov    $0x0,%edi
mov    $0x8,%ecx
mov    %rbx,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
jne    8b <fatFreeWithDir+0x3b>
lea    0x8(%rbx),%rsi
mov    $0x0,%edi
mov    $0x3,%ecx
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     d0 <fatFreeWithDir+0x80>
movzbl 0x1b(%rbx),%eax
movzbl 0x1a(%rbx),%r12d
mov    %rbp,%rdi
shl    $0x8,%eax
add    %r12d,%eax
movzwl %ax,%r12d
callq  a6 <fatFreeWithDir+0x56>
test   %eax,%eax
je     bd <fatFreeWithDir+0x6d>
movzbl 0x15(%rbx),%eax
movzbl 0x14(%rbx),%edx
shl    $0x8,%eax
add    %edx,%eax
shl    $0x10,%eax
or     %eax,%r12d
pop    %rbx
mov    %rbp,%rdi
mov    %r12d,%esi
pop    %rbp
pop    %r12
jmpq   cc <fatFreeWithDir+0x7c>
nopl   0x0(%rax)
mov    0x0(%rip),%rcx        # d7 <fatFreeWithDir+0x87>
mov    $0x1f,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  eb <fatFreeWithDir+0x9b>
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fatFreeWithDir(Stream_t *Dir, struct directory *dir)
{
 unsigned int first;
 if((!strncmp(dir->name,".      ",8) ||
     !strncmp(dir->name,"..     ",8)) &&
    !strncmp(dir->ext,"   ",3)) {
  fprintf(stderr,"Trying to remove . or .. entry\n");
  return -1;
 }
 first = (((unsigned short)((unsigned char)((dir)->start)[0] + (((unsigned char)((dir)->start)[1]) << 8))));
   if(fat32RootCluster(Dir))
  first |= (((unsigned short)((unsigned char)((dir)->startHi)[0] + (((unsigned char)((dir)->startHi)[1]) << 8)))) << 16;
 return fat_free(Dir, first);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 2
7 2
8 4
9 4
10 5
11 5
12 5
13 4
14 4
15 6
16 6
17 6
18 5
19 5
20 10
21 10
22 11
23 10
24 10
25 10
26 11
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 12
35 14
36 13
37 13
38 14
39 14
40 13
41 13
42 7
43 7
44 7
45 7
46 7
47 14
48 14
49 14
50 14
51 14
52 14
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,(%rdi)
mov    %rdi,%rbx
je     4c8 <meta_free+0x38>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     4be <meta_free+0x2e>
callq  4ae <meta_free+0x1e>
movq   $0x0,0x18(%rbx)
movq   $0x0,0x8(%rbx)
add    $0x28,%rbx
cmpq   $0x0,(%rbx)
jne    4a0 <meta_free+0x10>
pop    %rbx
retq   
<<<sep_in_sample>>>
meta_free (struct metadef *def)
{
  for (; def->kw; def++)
    {
      if (def->storage)
 {
   free (def->storage);
   def->value = def->storage = ((void *)0);
 }
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 5
7 5
8 5
9 7
10 8
11 8
12 3
13 3
14 3
15 11
16 11
<<<sep_out_sample>>>
mov    0x0(%rip),%r9d        # 37 <count_columns+0x7>
mov    %edx,%r8d
nopw   0x0(%rax,%rax,1)
movzbl (%rsi),%ecx
movsbl %cl,%eax
cmp    %r8d,%eax
je     70 <count_columns+0x40>
test   %cl,%cl
je     70 <count_columns+0x40>
add    $0x1,%rsi
cmp    $0x9,%cl
je     98 <count_columns+0x68>
jg     78 <count_columns+0x48>
cmp    $0x8,%cl
jne    90 <count_columns+0x60>
movzbl (%rsi),%ecx
sub    $0x1,%edi
movsbl %cl,%eax
cmp    %r8d,%eax
jne    4b <count_columns+0x1b>
nopl   (%rax)
mov    %edi,%eax
retq   
nopl   0x0(%rax,%rax,1)
cmp    $0xa,%cl
je     82 <count_columns+0x52>
cmp    $0xc,%cl
jne    90 <count_columns+0x60>
mov    $0x1,%edi
jmp    40 <count_columns+0x10>
nopl   0x0(%rax)
add    $0x1,%edi
jmp    40 <count_columns+0x10>
nopl   (%rax)
lea    -0x1(%rdi),%eax
cltd   
idiv   %r9d
mov    %r9d,%eax
sub    %edx,%eax
add    %eax,%edi
jmp    40 <count_columns+0x10>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
count_columns (
    int column,
    char *bp,
    int stop_char)
{
    while (*bp != stop_char && *bp != '\0')
    {
        switch (*bp++)
        {
        case '\n':
        case '\f':
            column = 1;
            break;
        case '\t':
            column += settings.tabsize - (column - 1) % settings.tabsize;
            break;
        case 010:
            --column;
            break;
        default:
            ++column;
            break;
        }
    }
    return column;
}
<<<sep_in_sample>>>
1 15
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 8
12 8
13 8
14 8
15 8
16 6
17 18
18 6
19 6
20 6
21 6
22 26
23 26
24 26
25 8
26 8
27 8
28 8
29 12
30 12
31 12
32 21
33 22
34 22
35 15
36 15
37 15
38 15
39 15
40 15
41 16
42 16
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  1903 <mu_url_aget_host+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    1927 <mu_url_aget_host+0x37>
mov    0x8(%rsp),%rdi
test   %rdi,%rdi
je     1930 <mu_url_aget_host+0x40>
callq  1918 <mu_url_aget_host+0x28>
test   %rax,%rax
mov    %rax,0x0(%rbp)
mov    $0xc,%eax
cmove  %eax,%ebx
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
movq   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_aget_host (mu_url_t url, char **buf) { const char *str; int status = mu_url_sget_host (url, &str); if (status) return status; if (str) { *buf = strdup (str); if (!*buf) status = 12; } else *buf = ((void *)0); return status; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <cache_open+0x9>
mov    %rax,0x0(%rip)        # 10 <cache_open+0x10>
callq  15 <cache_open+0x15>
mov    0x0(%rip),%edx        # 1b <cache_open+0x1b>
mov    %rax,0x0(%rip)        # 22 <cache_open+0x22>
xor    %eax,%eax
test   %edx,%edx
je     2d <cache_open+0x2d>
callq  2d <cache_open+0x2d>
mov    %rax,0x0(%rip)        # 34 <cache_open+0x34>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cache_open(void)
{
 assoc[1] = assoc_open();
 assoc[2] = assoc_open();
 assoc[3] = symbol ? assoc_open() : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 4
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
lea    0xc(%rsp),%rdx
callq  a25 <GetPunct+0x15>
xor    %eax,%eax
cmpl   $0x8,0xc(%rsp)
je     a38 <GetPunct+0x28>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
xor    %eax,%eax
cmp    %bpl,(%rbx)
sete   %al
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetPunct (PINPUTBUF pibIn, PSTR szLex, char chPunct)
{
  int iType;
  NextLex (pibIn, szLex, &iType);
  return ((iType == 0x0008) && szLex[0] == chPunct);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 5
9 5
10 5
11 6
12 6
13 6
14 6
15 6
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     40 <ecopy+0x40>
callq  13 <ecopy+0x13>
lea    0x1(%rax),%rbp
mov    %rbp,%rdi
callq  1f <ecopy+0x1f>
test   %rax,%rax
je     44 <ecopy+0x44>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  32 <ecopy+0x32>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    32 <ecopy+0x32>
mov    $0x0,%edi
callq  4e <ecopy+0x4e>
mov    $0x1,%edi
callq  58 <ecopy+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ecopy(char *e)
{
  char *copy;
  if (e)
    {
      if (!(copy = malloc(strlen(e) + 1)))
 {
   perror("dap");
   exit(1);
 }
      strcpy(copy, e);
      return copy;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 11
14 11
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 14
23 14
24 8
25 8
26 9
27 9
28 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 4087 <make_new_array_variable+0x7>
push   %rbx
mov    0x20(%rax),%rsi
callq  3620 <make_new_variable>
mov    %rax,%rbx
callq  4099 <make_new_array_variable+0x19>
orl    $0x4,0x28(%rbx)
mov    %rax,0x8(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_new_array_variable (name)
     char *name;
{
  SHELL_VAR *entry;
  ARRAY *array;
  entry = make_new_variable (name, global_variables->table);
  array = array_create ();
  ((entry)->value = (char *)(array));
  ((entry)->attributes |= (0x0000004));
  return entry;
}
<<<sep_in_sample>>>
1 6
2 3
3 6
4 6
5 6
6 7
7 9
8 8
9 11
10 11
11 11
12 11
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 156a <gsl_matrix_short_ptr+0xa>
test   %eax,%eax
je     1579 <gsl_matrix_short_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    1590 <gsl_matrix_short_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    15b0 <gsl_matrix_short_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,2),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15a9 <gsl_matrix_short_ptr+0x49>
xor    %eax,%eax
jmp    1589 <gsl_matrix_short_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  15c9 <gsl_matrix_short_ptr+0x69>
xor    %eax,%eax
jmp    1589 <gsl_matrix_short_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_short_ptr(gsl_matrix_short * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_short.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_short.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (short *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
mov    0x204(%rdi),%eax
movl   $0x0,0x4(%rsi)
mov    $0x1,%edx
mov    %eax,0x8(%rsi)
mov    (%rsi),%eax
orl    $0x2,0x27c(%rdi)
mov    %eax,0x204(%rdi)
mov    (%rdi),%rdi
jmpq   2c <__bt_free+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__bt_free(t, h)
 BTREE *t;
 PAGE *h;
{
 h->prevpg = 0;
 h->nextpg = t->bt_free;
 t->bt_free = h->pgno;
 (t)->flags |= (0x00002);
 return (mpool_put(t->bt_mp, h, 0x01));
}
<<<sep_in_sample>>>
1 6
2 5
3 9
4 6
5 7
6 8
7 7
8 9
9 9
10 9
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    0x868(%rdi),%ebp
lea    0x1(%rbp),%ebx
jmp    123 <selectWeapon+0x43>
nopw   0x0(%rax,%rax,1)
movslq %ebx,%rax
lea    0x0(,%rax,8),%rdx
shl    $0x6,%rax
sub    %rdx,%rax
mov    0x0(%rax),%rax
test   %rax,%rax
je     120 <selectWeapon+0x40>
mov    %r12,%rdi
callq  *%rax
cmp    $0x1,%eax
je     140 <selectWeapon+0x60>
add    $0x1,%ebx
mov    %ebx,%eax
sar    $0x1f,%eax
shr    $0x1e,%eax
add    %eax,%ebx
and    $0x3,%ebx
sub    %eax,%ebx
cmp    %ebx,%ebp
jne    f8 <selectWeapon+0x18>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   (%rax)
mov    %ebx,0x868(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
selectWeapon(craft * c)
{
 register int n, m;
 m = c->curWeapon;
 n = (c->curWeapon + 1) % 4;
 for (; n != m; n = (n + 1) % 4) {
  if (wtbl[n].select != ((void *)0))
   if ((*wtbl[n].select) (c) == 1) {
    c->curWeapon = n;
    return 1;
   }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 5
8 5
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 8
20 6
21 5
22 5
23 5
24 5
25 5
26 5
27 6
28 6
29 14
30 14
31 13
32 14
33 14
34 14
35 9
36 14
37 14
38 14
39 14
40 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x7,%edi
xor    %eax,%eax
callq  c00 <tty_beep+0x10>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   c0b <tty_beep+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
tty_beep()
{
    tty_writec(7);
    tty_flush();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 4
8 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
js     380 <gsl_stats_ulong_lag1_autocorrelation_m+0x100>
cvtsi2sd %rax,%xmm1
subsd  %xmm0,%xmm1
cmp    $0x1,%rdx
mulsd  %xmm1,%xmm1
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
jbe    36b <gsl_stats_ulong_lag1_autocorrelation_m+0xeb>
shl    $0x3,%rsi
fldz   
mov    $0x1,%eax
lea    (%rdi,%rsi,1),%r8
jmp    31d <gsl_stats_ulong_lag1_autocorrelation_m+0x9d>
xchg   %ax,%ax
cvtsi2sd %rcx,%xmm1
subsd  %xmm0,%xmm1
add    $0x1,%rax
mov    %rax,-0x18(%rsp)
test   %rax,%rax
movsd  %xmm1,-0x20(%rsp)
fldl   -0x20(%rsp)
fildll -0x18(%rsp)
js     360 <gsl_stats_ulong_lag1_autocorrelation_m+0xe0>
mov    (%rdi),%rcx
test   %rcx,%rcx
js     340 <gsl_stats_ulong_lag1_autocorrelation_m+0xc0>
cvtsi2sd %rcx,%xmm1
subsd  %xmm0,%xmm1
fld    %st(1)
add    %rsi,%rdi
add    %rsi,%r8
cmp    %rdx,%rax
movsd  %xmm1,-0x20(%rsp)
fmull  -0x20(%rsp)
fsub   %st(3),%st
fdiv   %st(1),%st
faddp  %st,%st(3)
fxch   %st(1)
fmul   %st(0),%st
fsub   %st(3),%st
fdivp  %st,%st(1)
faddp  %st,%st(2)
je     370 <gsl_stats_ulong_lag1_autocorrelation_m+0xf0>
mov    (%r8),%rcx
test   %rcx,%rcx
jns    2c0 <gsl_stats_ulong_lag1_autocorrelation_m+0x40>
mov    %rcx,%r9
and    $0x1,%ecx
shr    %r9
or     %rcx,%r9
cvtsi2sd %r9,%xmm1
addsd  %xmm1,%xmm1
jmp    2c5 <gsl_stats_ulong_lag1_autocorrelation_m+0x45>
nopl   0x0(%rax)
mov    %rcx,%r9
and    $0x1,%ecx
shr    %r9
or     %rcx,%r9
cvtsi2sd %r9,%xmm1
addsd  %xmm1,%xmm1
jmp    2f2 <gsl_stats_ulong_lag1_autocorrelation_m+0x72>
nopw   0x0(%rax,%rax,1)
fadds  0x0(%rip)        # 366 <gsl_stats_ulong_lag1_autocorrelation_m+0xe6>
jmpq   2e5 <gsl_stats_ulong_lag1_autocorrelation_m+0x65>
fldz   
nopl   (%rax)
fdivp  %st,%st(1)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
nopl   (%rax)
mov    %rax,%rcx
and    $0x1,%eax
shr    %rcx
or     %rax,%rcx
cvtsi2sd %rcx,%xmm1
addsd  %xmm1,%xmm1
jmpq   291 <gsl_stats_ulong_lag1_autocorrelation_m+0x11>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ulong_lag1_autocorrelation_m (const unsigned long data[], const size_t stride, const size_t size, const double mean)
{
  size_t i;
  long double r1 ;
  long double q = 0 ;
  long double v = (data[0 * stride] - mean) * (data[0 * stride] - mean) ;
  for (i = 1; i < size ; i++)
    {
      const long double delta0 = (data[(i-1) * stride] - mean);
      const long double delta1 = (data[i * stride] - mean);
      q += (delta0 * delta1 - q)/(i + 1);
      v += (delta1 * delta1 - v)/(i + 1);
    }
  r1 = q / v ;
  return r1;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 7
7 6
8 6
9 6
10 7
11 7
12 5
13 7
14 7
15 7
16 7
17 10
18 10
19 11
20 11
21 11
22 10
23 10
24 11
25 11
26 9
27 9
28 9
29 9
30 9
31 11
32 11
33 11
34 7
35 9
36 11
37 11
38 11
39 11
40 11
41 12
42 12
43 12
44 12
45 7
46 10
47 10
48 10
49 10
50 10
51 10
52 10
53 10
54 10
55 10
56 10
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 11
66 11
67 5
68 5
69 14
70 15
71 15
72 16
73 16
74 6
75 6
76 6
77 6
78 6
79 6
80 6
81 6
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%r8
mov    %rdx,%rbx
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
callq  47 <gsasl_base64_from+0x17>
test   %al,%al
mov    $0x8,%esi
jne    58 <gsasl_base64_from+0x28>
mov    %esi,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
cmpq   $0x1,(%rbx)
pop    %rbx
sbb    %esi,%esi
and    $0x7,%esi
mov    %esi,%eax
retq   
<<<sep_in_sample>>>
gsasl_base64_from (const char *in, size_t inlen, char **out, size_t * outlen)
{
  int ok = base64_decode_alloc_ctx (((void *)0), in, inlen, out, outlen);
  if (!ok)
    return GSASL_BASE64_ERROR;
  if (*out == ((void *)0))
    return GSASL_MALLOC_ERROR;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 4
12 9
13 9
14 9
15 9
16 7
17 9
18 7
19 7
20 9
21 9
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 246 <defalt+0x6>
movsd  0x0(%rip),%xmm0        # 24e <defalt+0xe>
test   %edx,%edx
jne    25a <defalt+0x1a>
movsd  %xmm0,0x0(%rip)        # 25a <defalt+0x1a>
mov    0x0(%rip),%eax        # 260 <defalt+0x20>
test   %eax,%eax
jne    26e <defalt+0x2e>
movl   $0x1,0x0(%rip)        # 26e <defalt+0x2e>
movsd  0x0(%rip),%xmm1        # 276 <defalt+0x36>
ucomisd %xmm1,%xmm0
jbe    2b0 <defalt+0x70>
movsd  0x0(%rip),%xmm2        # 284 <defalt+0x44>
ucomisd 0x0(%rip),%xmm2        # 28c <defalt+0x4c>
jbe    2b0 <defalt+0x70>
movsd  0x0(%rip),%xmm0        # 296 <defalt+0x56>
xorpd  %xmm0,%xmm2
movsd  %xmm2,0x0(%rip)        # 2a2 <defalt+0x62>
movl   $0x0,0x0(%rip)        # 2ac <defalt+0x6c>
retq   
nopl   (%rax)
ucomisd %xmm0,%xmm1
jbe    2a2 <defalt+0x62>
xorpd  %xmm1,%xmm1
movsd  0x0(%rip),%xmm0        # 2c2 <defalt+0x82>
ucomisd %xmm0,%xmm1
jbe    2a2 <defalt+0x62>
movsd  0x0(%rip),%xmm1        # 2d0 <defalt+0x90>
movl   $0x0,0x0(%rip)        # 2da <defalt+0x9a>
xorpd  %xmm1,%xmm0
movsd  %xmm0,0x0(%rip)        # 2e6 <defalt+0xa6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
defalt (void)
{
  if (!sawfrom)
    tfrom = tstart;
  if (!sawevery)
    tevery = 1;
  if (tstart>tstop && tstep>0)
    tstep = -tstep;
  else if (tstart<tstop && tstep<0)
    tstep = -tstep;
  printnum = false;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 4
6 5
7 5
8 5
9 6
10 7
11 7
12 7
13 7
14 7
15 7
16 8
17 8
18 8
19 11
20 11
21 11
22 9
23 9
24 9
25 9
26 9
27 9
28 10
29 11
30 10
31 10
32 11
33 11
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
callq  f5 <strtotok+0x15>
mov    %rbx,%rsi
mov    %rbp,%rdi
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
mov    %rax,%rdx
jmpq   10a <strtotok+0x2a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strtotok (struct tokendef *tab, const char *str, int *pres)
{
  return strtotok_len (tab, str, strlen (str), pres);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 2
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 3
16 3
17 3
<<<sep_out_sample>>>
jmpq   a5 <zreadintr+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
zreadintr (fd, buf, len)
     int fd;
     char *buf;
     size_t len;
{
  return (read (fd, buf, len));
}
<<<sep_in_sample>>>
1 6
2 6
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     32 <lm_free+0x12>
callq  32 <lm_free+0x12>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     40 <lm_free+0x20>
callq  40 <lm_free+0x20>
mov    0x10(%rbx),%rdi
test   %rdi,%rdi
je     4e <lm_free+0x2e>
callq  4e <lm_free+0x2e>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     5c <lm_free+0x3c>
callq  5c <lm_free+0x3c>
mov    0x20(%rbx),%rdi
test   %rdi,%rdi
je     6a <lm_free+0x4a>
callq  6a <lm_free+0x4a>
mov    0x28(%rbx),%rdi
test   %rdi,%rdi
je     78 <lm_free+0x58>
callq  78 <lm_free+0x58>
mov    %rbx,%rdi
pop    %rbx
jmpq   81 <lm_free+0x61>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_free(void *vstate)
{
  lm_state_t *state = (lm_state_t *) vstate;
  if (state->workp)
    gsl_vector_free(state->workp);
  if (state->workn)
    gsl_vector_free(state->workn);
  if (state->fvv)
    gsl_vector_free(state->fvv);
  if (state->vel)
    gsl_vector_free(state->vel);
  if (state->acc)
    gsl_vector_free(state->acc);
  if (state->JTfvv)
    gsl_vector_free(state->JTfvv);
  free(state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 14
25 14
26 15
27 16
28 17
29 16
30 16
<<<sep_out_sample>>>
cmp    $0x7f,%rdi
jbe    1e0 <asn1_length_der+0x10>
jmpq   130 <asn1_length_der.part.4>
nopl   0x0(%rax,%rax,1)
test   %rsi,%rsi
je     1e8 <asn1_length_der+0x18>
mov    %dil,(%rsi)
movl   $0x1,(%rdx)
retq   
nop
<<<sep_in_sample>>>
asn1_length_der (unsigned long int len, unsigned char *der, int *der_len)
{
  int k;
  unsigned char temp[9];
  if (len < 128)
    {
      if (der != ((void *)0))
 der[0] = (unsigned char) len;
      *der_len = 1;
    }
  else
    {
      k = 0;
      while (len)
 {
   temp[k++] = len & 0xFF;
   len = len >> 8;
 }
      *der_len = k + 1;
      if (der != ((void *)0))
 {
   der[0] = ((unsigned char) k & 0x7F) + 128;
   while (k--)
     der[*der_len - 1 - k] = temp[k];
 }
    }
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 7
6 7
7 8
8 9
9 9
10 9
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3dc <error+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rbx
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  410 <error+0x90>
lea    0x8(%rsp),%rcx
mov    %rbx,%rdx
mov    %rax,%rsi
xor    %edi,%edi
callq  422 <error+0xa2>
add    $0xd0,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
error(const char *mesg, ...)
{
 va_list args;
 __builtin_va_start(args,mesg);
 err(0, gettext("error: "), mesg, args);
 __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 4
19 2
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 5
28 5
29 5
30 5
31 5
32 7
33 7
34 7
35 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x438,%rsp
mov    %rdx,0x8(%rsp)
lea    0x20(%rsp),%rsi
lea    0x1c(%rsp),%rdx
lea    0x8(%rsp),%rdi
mov    %fs:0x28,%rax
mov    %rax,0x428(%rsp)
xor    %eax,%eax
callq  55b <EvaluateExpression+0x3b>
cmpb   $0x0,0x20(%rsp)
je     5a0 <EvaluateExpression+0x80>
lea    0x1c(%rsp),%r8
lea    0x20(%rsp),%rcx
lea    0x8(%rsp),%rdx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  57c <EvaluateExpression+0x5c>
mov    0x428(%rsp),%rbx
xor    %fs:0x28,%rbx
jne    5bb <EvaluateExpression+0x9b>
add    $0x438,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdx
mov    $0x0,%ecx
mov    $0x8011,%esi
mov    %rbx,%rdi
callq  5b7 <EvaluateExpression+0x97>
xor    %eax,%eax
jmp    57c <EvaluateExpression+0x5c>
callq  5c0 <InitBuffer>
<<<sep_in_sample>>>
EvaluateExpression (PINPUTBUF pibIn, long index, PSTR szExpress)
{
  PSTRLEX szToken;
  int iType;
  GetToken (&szExpress, szToken, &iType);
  if (!*szToken) {
    ReportError (pibIn, 0x0011 | 0x8000, szExpress,
                 "(While parsing bracketed expression)");
    return (0);
  }
  else
    return EvalSum (pibIn, index, &szExpress, szToken, &iType);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 2
11 2
12 2
13 5
14 6
15 6
16 12
17 12
18 12
19 12
20 12
21 12
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 7
31 7
32 7
33 7
34 7
35 9
36 9
37 13
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rbx        # 10a7 <progman_lookup_tcpmux+0x17>
test   %rbx,%rbx
je     1108 <progman_lookup_tcpmux+0x78>
nopl   0x0(%rax)
mov    0x10(%rbx),%eax
test   %eax,%eax
jne    1100 <progman_lookup_tcpmux+0x70>
mov    0x30(%rbx),%rbp
mov    0x48(%rbp),%eax
test   $0x18,%al
je     1100 <progman_lookup_tcpmux+0x70>
test   $0x1,%al
jne    1100 <progman_lookup_tcpmux+0x70>
mov    0xa0(%rbp),%rdi
test   %rdi,%rdi
je     1100 <progman_lookup_tcpmux+0x70>
mov    %r12,%rsi
callq  10da <progman_lookup_tcpmux+0x4a>
test   %eax,%eax
jne    1100 <progman_lookup_tcpmux+0x70>
mov    0xc8(%rbp),%rdi
test   %rdi,%rdi
je     1100 <progman_lookup_tcpmux+0x70>
mov    %r13,%rsi
callq  10f2 <progman_lookup_tcpmux+0x62>
test   %eax,%eax
je     110a <progman_lookup_tcpmux+0x7a>
nopw   %cs:0x0(%rax,%rax,1)
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    10b0 <progman_lookup_tcpmux+0x20>
xor    %ebp,%ebp
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
progman_lookup_tcpmux (const char *service, const char *master)
{
  struct prog *prog;
  for (prog = proghead; prog; prog = prog->next)
    if (((prog)->type == TYPE_COMPONENT)
 && ((prog->v.p.comp->flags) & (0x08 | 0x10))
 && !(prog->v.p.comp->flags & 0x01)
 && prog->v.p.comp->service
 && strcasecmp (prog->v.p.comp->service, service) == 0
 && prog->v.p.comp->tcpmux
 && strcmp (prog->v.p.comp->tcpmux, master) == 0)
      return prog->v.p.comp;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 7
20 7
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 10
29 10
30 10
31 11
32 11
33 11
34 11
35 11
36 4
37 4
38 4
39 13
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x20,%edi
callq  78e <create_index_record+0xe>
test   %rax,%rax
je     7b2 <create_index_record+0x32>
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
create_index_record ()
{
  df_index_record *return_record;
  return_record = malloc (sizeof (df_index_record));
  if (return_record == ((void *)0))
    return ((void *)0);
  bzero (return_record, sizeof (df_index_record));
  return return_record;
  }
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4e0 <mu_mailer_close+0x10>
mov    0x50(%rdi),%rax
test   %rax,%rax
je     4e0 <mu_mailer_close+0x10>
jmpq   *%rax
mov    $0x26,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailer_close (mu_mailer_t mailer)
{
  if (mailer == ((void *)0) || mailer->_close == ((void *)0))
    return 38;
  return mailer->_close (mailer);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 7cb <grecs_include_path_clear+0xb>
test   %rdi,%rdi
je     7d5 <grecs_include_path_clear+0x15>
callq  7d5 <grecs_include_path_clear+0x15>
mov    0x0(%rip),%rdi        # 7dc <grecs_include_path_clear+0x1c>
test   %rdi,%rdi
je     7f0 <grecs_include_path_clear+0x30>
add    $0x8,%rsp
jmpq   7ea <grecs_include_path_clear+0x2a>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_include_path_clear()
{
 if (grecs_usr_include_path)
  grecs_list_clear(grecs_usr_include_path);
 if (grecs_std_include_path)
  grecs_list_clear(grecs_std_include_path);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    (%rsi),%rdi
test   %rdi,%rdi
jne    138 <find_index_in_alist+0x38>
jmp    180 <find_index_in_alist+0x80>
nop
movzbl (%rdi),%eax
cmp    %al,(%r12)
je     160 <find_index_in_alist+0x60>
add    $0x10,%rbx
mov    (%rbx),%rdi
add    $0x1,%ebp
test   %rdi,%rdi
je     180 <find_index_in_alist+0x80>
test   %r13d,%r13d
je     120 <find_index_in_alist+0x20>
mov    $0x20,%edx
mov    %r12,%rsi
callq  14a <find_index_in_alist+0x4a>
cmp    $0x1,%eax
je     129 <find_index_in_alist+0x29>
nop
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    %rdi,%rsi
mov    %r12,%rdi
callq  16b <find_index_in_alist+0x6b>
test   %eax,%eax
je     150 <find_index_in_alist+0x50>
add    $0x10,%rbx
mov    (%rbx),%rdi
add    $0x1,%ebp
test   %rdi,%rdi
jne    138 <find_index_in_alist+0x38>
xchg   %ax,%ax
add    $0x8,%rsp
mov    $0xffffffff,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
find_index_in_alist (string, alist, flags)
     char *string;
     STRING_INT_ALIST *alist;
     int flags;
{
  register int i;
  int r;
  for (i = r = 0; alist[i].word; i++)
    {
      if (flags)
 r = strmatch (alist[i].word, string, (1 << 5)) != 1;
      else
 r = ((string)[0] == (alist[i].word)[0] && strcmp(string, alist[i].word) == 0);
      if (r)
 return (i);
    }
  return -1;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 8
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 13
16 13
17 13
18 13
19 8
20 8
21 8
22 8
23 10
24 10
25 11
26 11
27 11
28 14
29 14
30 14
31 18
32 18
33 18
34 18
35 18
36 18
37 18
38 18
39 13
40 13
41 13
42 13
43 13
44 13
45 8
46 8
47 8
48 8
49 8
50 18
51 17
52 18
53 18
54 18
55 18
56 18
<<<sep_out_sample>>>
sub    $0x8,%rsp
test   %rdi,%rdi
je     13fe <fdGetCpioPos+0x1e>
cmpl   $0xbeefdead,0x8(%rdi)
jne    13fe <fdGetCpioPos+0x1e>
mov    0x128(%rdi),%rax
add    $0x8,%rsp
retq   
mov    $0x0,%ecx
mov    $0x19a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1417 <fdGetCpioPos+0x37>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fdGetCpioPos(FD_t fd) {
    ((fd && fd->magic == 0xbeefdead) ? (void) (0) : __assert_fail ("fd && fd->magic == 0xbeefdead", "rpmio.c", 410, __PRETTY_FUNCTION__));
    return fd->fd_cpioPos;
}
<<<sep_in_sample>>>
1 1
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 2
10 2
11 2
12 2
13 2
14 2
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%rbx
mov    %rdi,%rcx
mov    0x8(%rsi),%rdi
mov    $0x8,%esi
mov    %rbx,%rdx
callq  c58 <gsl_block_complex_float_fwrite+0x18>
xor    %edx,%edx
cmp    %rbx,%rax
je     c7a <gsl_block_complex_float_fwrite+0x3a>
mov    $0x30,%dl
mov    $0x5,%ecx
mov    $0x0,%esi
mov    $0x0,%edi
callq  c75 <gsl_block_complex_float_fwrite+0x35>
mov    $0x5,%edx
mov    %edx,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_block_complex_float_fwrite (FILE * stream, const gsl_block_complex_float * b)
{
  size_t n = b->size ;
  float * data = b->data ;
  size_t items = fwrite (data, 2 * sizeof (float), n, stream);
  if (items != n)
    {
      do { gsl_error ("fwrite failed", "fwrite_source.c", 48, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 5
5 5
6 5
7 5
8 10
9 6
10 6
11 8
12 8
13 8
14 8
15 8
16 8
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    $0xffffffff,%ecx
mov    %rsi,%rdx
mov    %edi,%esi
mov    %ecx,%edi
jmpq   1d1 <taru_read_amount+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_read_amount(int suction_fd, intmax_t amount)
{
 return taru_pump_amount2(-1, suction_fd, amount, -1);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     109d <mu_address_get_count+0x1d>
nopw   0x0(%rax,%rax,1)
mov    0x38(%rdi),%rdi
add    $0x1,%rax
test   %rdi,%rdi
jne    1090 <mu_address_get_count+0x10>
test   %rsi,%rsi
je     10a5 <mu_address_get_count+0x25>
mov    %rax,(%rsi)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_address_get_count (mu_address_t addr, size_t *pcount)
{
  size_t j;
  for (j = 0; addr; addr = addr->next, j++)
    ;
  if (pcount)
    *pcount = j;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 6
10 6
11 7
12 9
13 9
14 9
<<<sep_out_sample>>>
push   %r12
xor    %edx,%edx
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    0x5f8(%rsi),%rax
xor    %esi,%esi
mov    0x58(%rax),%rdi
callq  52b <dump_requirements+0x1b>
cmpq   $0x0,(%rax)
mov    %rax,%r12
je     58b <dump_requirements+0x7b>
mov    $0x10,%edx
mov    %rbp,%rcx
mov    $0x1,%esi
mov    $0x0,%edi
mov    %r12,%rbx
callq  54e <dump_requirements+0x3e>
mov    (%r12),%rdx
test   %rdx,%rdx
je     57e <dump_requirements+0x6e>
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rdx
xor    %eax,%eax
add    $0x8,%rbx
mov    $0x0,%esi
mov    %rbp,%rdi
callq  576 <dump_requirements+0x66>
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    560 <dump_requirements+0x50>
mov    %rbp,%rsi
mov    $0xa,%edi
callq  58b <dump_requirements+0x7b>
pop    %rbx
pop    %rbp
mov    %r12,%rdi
pop    %r12
jmpq   597 <dump_requirements+0x87>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dump_requirements (FILE * stream, struct a2ps_job * job)
{
  dict_entry ** entries = ((void *)0);
  dict_entry ** entry;
  entries = (dict_entry **) hash_dump (job->status->pagedevice, ((void *)0), ((void *)0));
  if (*entries)
    {
      fputs ("%%Requirements: ", stream);
      for (entry = entries ; *entry ; entry++)
 fprintf (stream, "%s ", (*entry)->key);
      _IO_putc ('\n', stream);
    }
  free (entries);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 6
11 5
12 6
13 8
14 8
15 8
16 8
17 9
18 8
19 9
20 9
21 9
22 9
23 10
24 10
25 9
26 10
27 10
28 10
29 9
30 9
31 9
32 11
33 11
34 11
35 14
36 14
37 13
38 14
39 13
40 13
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x9,%dil
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_tab (char c)
{
  return c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
test   %eax,%eax
jle    62f <anubis_url_get_arg+0x4f>
push   %r12
sub    $0x1,%eax
shl    $0x4,%rax
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x30(%rdi),%rbx
lea    0x10(%rbx,%rax,1),%r12
jmp    609 <anubis_url_get_arg+0x29>
add    $0x10,%rbx
cmp    %r12,%rbx
je     628 <anubis_url_get_arg+0x48>
mov    (%rbx),%rdi
mov    %rbp,%rsi
callq  614 <anubis_url_get_arg+0x34>
test   %eax,%eax
jne    600 <anubis_url_get_arg+0x20>
mov    0x8(%rbx),%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
anubis_url_get_arg (ANUBIS_URL * url, const char *argname)
{
  int i;
  for (i = 0; i < url->argc; i++)
    {
      if (strcasecmp (url->argv[i].key, argname) == 0)
 return url->argv[i].value;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 4
15 4
16 6
17 6
18 6
19 6
20 6
21 7
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 9
30 10
31 10
32 9
33 10
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0xa,%edi
push   %rbx
callq  1e4 <process_vcwd+0x14>
mov    $0x0,%esi
mov    %r12,%rdi
mov    %rax,%rbx
callq  1f4 <process_vcwd+0x24>
cmp    %r12,%rax
je     23b <process_vcwd+0x6b>
mov    $0x0,%edx
mov    %r12,%rsi
mov    %rbx,%rdi
callq  209 <process_vcwd+0x39>
test   %rax,%rax
je     22f <process_vcwd+0x5f>
xchg   %ax,%ax
mov    %rax,%rsi
mov    %rbp,%rdi
callq  21b <process_vcwd+0x4b>
xor    %esi,%esi
mov    $0x0,%edx
mov    %rbx,%rdi
callq  22a <process_vcwd+0x5a>
test   %rax,%rax
jne    210 <process_vcwd+0x40>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   23b <process_vcwd+0x6b>
mov    %r12,%rsi
mov    %rbp,%rdi
add    $0x2,%r12
callq  24a <process_vcwd+0x7a>
movb   $0x0,-0x1(%r12)
jmp    1f9 <process_vcwd+0x29>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
process_vcwd(STRAR * pathcomps, char * source)
{
 char * s, *pc;
 STROB * tmp = strob_open(10);
 if (strstr(source, "//") == source) {
  strar_add(pathcomps, source);
  *(source+1) = '\0';
  s = source + 2;
 } else {
  s = source;
 }
 pc = strob_strtok(tmp, s, "/");
 while (pc) {
  strar_add(pathcomps, pc);
  pc = strob_strtok(tmp, (char*)((void *)0), "/");
 }
 strob_close(tmp);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 5
10 4
11 5
12 5
13 5
14 12
15 12
16 12
17 12
18 13
19 13
20 13
21 14
22 14
23 14
24 15
25 15
26 15
27 15
28 13
29 13
30 17
31 19
32 19
33 19
34 17
35 6
36 6
37 8
38 6
39 7
40 7
41 7
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
movq   $0x0,(%r9)
movq   $0x0,(%r8)
push   %rbp
push   %rbx
mov    %rdx,%rbx
je     40 <_gsasl_external_server_step+0x40>
mov    %rcx,%rdx
xor    %esi,%esi
mov    %rdi,%r12
mov    %rbx,%rdi
mov    %rcx,%rbp
callq  2d <_gsasl_external_server_step+0x2d>
test   %rax,%rax
mov    $0x1e,%edx
je     50 <_gsasl_external_server_step+0x50>
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
xchg   %ax,%ax
pop    %rbx
mov    $0x1,%edx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
test   %rbp,%rbp
jne    80 <_gsasl_external_server_step+0x80>
xor    %edx,%edx
mov    $0x2,%esi
mov    %r12,%rdi
callq  64 <_gsasl_external_server_step+0x64>
pop    %rbx
pop    %rbp
mov    %r12,%rsi
mov    $0x1f5,%edx
xor    %edi,%edi
pop    %r12
jmpq   77 <_gsasl_external_server_step+0x77>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    $0x2,%esi
mov    %r12,%rdi
callq  93 <_gsasl_external_server_step+0x93>
jmp    64 <_gsasl_external_server_step+0x64>
<<<sep_in_sample>>>
_gsasl_external_server_step (Gsasl_session * sctx,
        void *mech_data,
        const char *input, size_t input_len,
        char **output, size_t * output_len)
{
  *output_len = 0;
  *output = ((void *)0);
  if (!input)
    return GSASL_NEEDS_MORE;
  if (memchr (input, '\0', input_len))
    return GSASL_MECHANISM_PARSE_ERROR;
  if (input_len > 0)
    gsasl_property_set_raw (sctx, GSASL_AUTHZID, input, input_len);
  else
    gsasl_property_set (sctx, GSASL_AUTHZID, ((void *)0));
  return gsasl_callback (((void *)0), sctx, GSASL_VALIDATE_EXTERNAL);
}
<<<sep_in_sample>>>
1 5
2 8
3 6
4 7
5 5
6 5
7 5
8 8
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 10
18 17
19 17
20 17
21 17
22 17
23 17
24 17
25 9
26 17
27 17
28 17
29 17
30 17
31 12
32 12
33 15
34 15
35 15
36 15
37 17
38 17
39 16
40 16
41 16
42 17
43 16
44 16
45 13
46 13
47 13
48 13
49 13
50 13
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  e5c <gsl_sf_bessel_j1+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    e70 <gsl_sf_bessel_j1+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x179,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e86 <gsl_sf_bessel_j1+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_j1(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_j1_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_j1_e(x, &result)", "bessel_j.c", 377, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
test   %rdx,%rdx
push   %rbx
lea    -0x1(%rdx),%r8
je     7a <strlcat+0x7a>
cmpb   $0x0,(%rdi)
mov    %rdi,%rcx
je     92 <strlcat+0x92>
xor    %eax,%eax
jmp    29 <strlcat+0x29>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
cmpb   $0x0,(%rcx)
je     32 <strlcat+0x32>
add    $0x1,%rcx
cmp    %rax,%r8
jne    20 <strlcat+0x20>
mov    %rcx,%rbx
sub    %rdi,%rbx
sub    %rbx,%rdx
je     80 <strlcat+0x80>
movzbl (%rsi),%r9d
mov    %rsi,%r8
test   %r9b,%r9b
je     8d <strlcat+0x8d>
nopl   0x0(%rax)
cmp    $0x1,%rdx
je     61 <strlcat+0x61>
mov    %r9b,(%rcx)
sub    $0x1,%rdx
add    $0x1,%rcx
add    $0x1,%r8
movzbl (%r8),%r9d
test   %r9b,%r9b
jne    50 <strlcat+0x50>
sub    %rsi,%r8
lea    (%r8,%rbx,1),%rax
movb   $0x0,(%rcx)
pop    %rbx
retq   
xor    %ebx,%ebx
nopl   0x0(%rax)
mov    %rsi,%rdi
callq  88 <strlcat+0x88>
add    %rbx,%rax
pop    %rbx
retq   
xor    %r8d,%r8d
jmp    71 <strlcat+0x71>
xor    %ebx,%ebx
jmp    3d <strlcat+0x3d>
<<<sep_in_sample>>>
strlcat(char *dst, const char *src, size_t siz)
{
 register char *d = dst;
 register const char *s = src;
 register size_t n = siz;
 size_t dlen;
 while (n-- != 0 && *d != '\0')
  d++;
 dlen = d - dst;
 n = siz - dlen;
 if (n == 0)
  return(dlen + strlen(s));
 while (*s != '\0') {
  if (n != 1) {
   *d++ = *s;
   n--;
  }
  s++;
 }
 *d = '\0';
 return(dlen + (s - src));
}
<<<sep_in_sample>>>
1 7
2 2
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 8
15 7
16 7
17 7
18 7
19 11
20 11
21 13
22 13
23 13
24 13
25 13
26 14
27 14
28 15
29 16
30 15
31 18
32 13
33 13
34 13
35 13
36 21
37 20
38 22
39 22
40 7
41 7
42 12
43 12
44 12
45 22
46 22
47 13
48 13
49 7
50 7
<<<sep_out_sample>>>
test   %rdx,%rdx
je     356 <gsl_stats_float_absdev_m+0x76>
xorpd  %xmm2,%xmm2
shl    $0x2,%rsi
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 2f7 <gsl_stats_float_absdev_m+0x17>
nopw   0x0(%rax,%rax,1)
movss  (%rdi),%xmm1
add    $0x1,%rax
add    %rsi,%rdi
cmp    %rdx,%rax
cvtps2pd %xmm1,%xmm1
subsd  %xmm0,%xmm1
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
jne    300 <gsl_stats_float_absdev_m+0x20>
test   %rax,%rax
js     338 <gsl_stats_float_absdev_m+0x58>
cvtsi2sd %rdx,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm0
addsd  %xmm0,%xmm0
divsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
retq   
xorpd  %xmm2,%xmm2
jmp    324 <gsl_stats_float_absdev_m+0x44>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_stats_float_absdev_m (const float data[],
                              const size_t stride,
                              const size_t n,
                              const double mean)
{
  double sum = 0, absdev;
  size_t i;
  for (i = 0; i < n; i++)
    {
      const double delta = fabs(data[i * stride] - mean);
      sum += delta;
    }
  absdev = sum / n;
  return absdev;
}
<<<sep_in_sample>>>
1 8
2 8
3 6
4 6
5 8
6 8
7 8
8 10
9 8
10 8
11 8
12 10
13 10
14 10
15 11
16 8
17 13
18 13
19 13
20 13
21 13
22 15
23 15
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 6
34 6
35 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a10 <osip_transaction_get_reserved2+0x10>
mov    0x2c48(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_get_reserved2 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved2;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    0x30(%rdi),%rdx
lea    -0x1(%rsi),%rax
cmp    %rdx,%rax
jae    2ab <gl_array_next_node+0x1b>
lea    0x1(%rsi),%rcx
xor    %eax,%eax
cmp    %rdx,%rsi
cmovb  %rcx,%rax
retq   
push   %rax
callq  2b1 <gl_array_next_node+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_array_next_node (gl_list_t list, gl_list_node_t node)
{
  unsigned long index = ((unsigned long)(node) - 1);
  if (!(index < list->count))
    abort ();
  index++;
  if (index < list->count)
    return (gl_list_node_t)(unsigned long)(size_t)((index) + 1);
  else
    return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 8
6 8
7 8
8 8
9 11
10 2
11 5
12 5
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
mov    (%rdi),%rcx
ucomisd %xmm0,%xmm2
ja     270 <gsl_multifit_test_gradient+0x60>
test   %rcx,%rcx
je     258 <gsl_multifit_test_gradient+0x48>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rdx
movsd  0x0(%rip),%xmm3        # 232 <gsl_multifit_test_gradient+0x22>
lea    0x0(,%rax,8),%rsi
xor    %eax,%eax
nopl   0x0(%rax)
movsd  (%rdx),%xmm1
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
andpd  %xmm3,%xmm1
addsd  %xmm1,%xmm2
jne    240 <gsl_multifit_test_gradient+0x30>
xor    %eax,%eax
ucomisd %xmm2,%xmm0
seta   %al
lea    -0x2(%rax,%rax,1),%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
sub    $0x8,%rsp
mov    $0xd,%ecx
mov    $0x89,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  28d <gsl_multifit_test_gradient+0x7d>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multifit_test_gradient (const gsl_vector * g, double epsabs)
{
  size_t i;
  double residual = 0;
  const size_t n = g->size;
  if (epsabs < 0.0)
    {
      do { gsl_error ("absolute tolerance is negative", "convergence.c", 137, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
    }
  for (i = 0 ; i < n ; i++)
    {
      double gi = gsl_vector_get(g, i);
      residual += fabs(gi);
    }
  if (residual < epsabs)
    {
      return GSL_SUCCESS;
    }
  return GSL_CONTINUE ;
}
<<<sep_in_sample>>>
1 6
2 5
3 6
4 6
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 13
14 10
15 10
16 10
17 13
18 13
19 10
20 19
21 19
22 19
23 19
24 19
25 19
26 2
27 8
28 8
29 8
30 8
31 8
32 8
33 20
34 20
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1be7 <java_get_text+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java_get_text (void)
{
        return java_text;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <get_homedir+0xe>
test   %rax,%rax
je     20 <get_homedir+0x20>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  25 <get_homedir+0x25>
mov    %eax,%edi
callq  2c <get_homedir+0x2c>
mov    0x20(%rax),%rax
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_homedir()
{
    char *homedir = getenv("HOME");
    if (!homedir) {
 struct passwd *pw = getpwuid(geteuid());
 homedir = pw->pw_dir;
    }
    return homedir;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 9
7 9
8 9
9 5
10 5
11 5
12 6
13 9
14 9
15 9
<<<sep_out_sample>>>
jmpq   3395 <swlib_close_memfd+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_close_memfd(int fd)
{
 return uxfio_close(fd);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taruib_get_buffer(void)
{
 return g_taruib_gst_bufferM;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  6e <rk2_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  7c <rk2_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  8a <rk2_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  98 <rk2_reset+0x48>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rk2_reset (void *vstate, size_t dim)
{
  rk2_state_t *state = (rk2_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
xor    %edi,%edi
sub    $0x8,%rsp
callq  910 <get_seconds+0x10>
sub    0x0(%rip),%rax        # 917 <get_seconds+0x17>
add    0x0(%rip),%rax        # 91e <get_seconds+0x1e>
mov    %rax,%rdi
callq  926 <get_seconds+0x26>
mov    0x8(%rbx),%rdi
mov    %rax,%rbp
test   %rdi,%rdi
je     941 <get_seconds+0x41>
mov    $0x4fc,%edx
mov    $0x0,%esi
callq  941 <get_seconds+0x41>
orl    $0x10,0x28(%rbx)
mov    %rbp,0x8(%rbx)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_seconds (var)
     SHELL_VAR *var;
{
  time_t time_since_start;
  char *p;
  time_since_start = ((time_t) time ((time_t *) 0)) - shell_start_time;
  p = itos(seconds_value_assigned + time_since_start);
  do { if (((var)->value)) sh_xfree((((var)->value)), "variables.c", 1276); } while (0);
  ((var)->attributes |= (0x0000010));
  ((var)->value = (p));
  return (var);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 3
6 6
7 6
8 7
9 7
10 7
11 8
12 7
13 8
14 8
15 8
16 8
17 8
18 9
19 10
20 12
21 12
22 12
23 12
24 12
25 12
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    5d00 <gsl_matrix_ulong_const_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    0x0(,%rdi,8),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  5d22 <gsl_matrix_ulong_const_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_const_row (const gsl_matrix_ulong * m, const size_t i)
{
  _gsl_vector_ulong_const_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ulong v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     e16 <cdio_set_blocksize+0x26>
mov    0x170(%rdi),%rax
test   %rax,%rax
je     e10 <cdio_set_blocksize+0x20>
movzwl %si,%esi
mov    0x180(%rdi),%rdi
jmpq   *%rax
nopl   (%rax)
mov    $0xfffffffe,%eax
retq   
mov    $0xfffffffd,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
cdio_set_blocksize ( const CdIo_t *p_cdio, int i_blocksize )
{
  if (!p_cdio) return DRIVER_OP_UNINIT;
  if (!p_cdio->op.set_blocksize) return DRIVER_OP_UNSUPPORTED;
  return p_cdio->op.set_blocksize(p_cdio->env, i_blocksize);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 4
11 6
12 3
13 3
14 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
push   %rax
mov    0x0(%rip),%rax        # 84 <option_conflict_error+0x10>
test   %rax,%rax
je     8b <option_conflict_error+0x17>
callq  *%rax
mov    $0x0,%edi
callq  95 <option_conflict_error+0x21>
xor    %edi,%edi
mov    %rax,%rdx
mov    %rbp,%r8
mov    %rbx,%rcx
xor    %esi,%esi
xor    %eax,%eax
callq  a9 <option_conflict_error+0x35>
mov    $0x2,%edi
callq  b3 <stdin_used_by+0x3>
<<<sep_in_sample>>>
option_conflict_error (const char *a, const char *b)
{
  do { if (error_hook) error_hook (); error (0, 0, gettext ("'%s' cannot be used with '%s'"), a, b); usage (2); } while (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
<<<sep_out_sample>>>
push   %rbx
cmp    $0x1,%edi
mov    0x0(%rip),%ebx        # 24da <site_idle+0xa>
mov    $0x0,%edx
mov    0x8(%rsi),%rsi
mov    $0x0,%eax
cmovne %rdx,%rax
movl   $0x1,0x0(%rip)        # 24f6 <site_idle+0x26>
mov    %rax,%rdi
xor    %eax,%eax
callq  2500 <site_idle+0x30>
mov    %ebx,0x0(%rip)        # 2506 <site_idle+0x36>
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
site_idle (int argc, char **argv)
{
  int oldverbose = verbose;
  verbose = 1;
  command (argc == 1 ? "SITE IDLE" : "SITE IDLE %s", argv[1]);
  verbose = oldverbose;
}
<<<sep_in_sample>>>
1 2
2 5
3 3
4 5
5 5
6 5
7 5
8 4
9 5
10 5
11 5
12 6
13 7
14 7
15 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdx,%rbx
mov    %rsi,%rdx
mov    %rbx,%rdi
mov    $0x0,%esi
sub    $0x90,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x88(%rsp)
xor    %eax,%eax
callq  3047 <countparts+0x37>
mov    %rbp,%rsi
mov    %rsp,%rdi
callq  3052 <countparts+0x42>
mov    %rbx,%rdx
mov    $0x0,%esi
mov    %r12,%rdi
movl   $0x7472732e,(%rax)
movb   $0x0,0x4(%rax)
callq  306c <countparts+0x5c>
mov    %rbx,%rcx
mov    $0x9,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3083 <countparts+0x73>
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  3095 <countparts+0x85>
mov    %rbx,%rcx
mov    $0x4d,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  30ac <countparts+0x9c>
mov    0x88(%rsp),%rax
xor    %fs:0x28,%rax
jne    30cb <countparts+0xbb>
add    $0x90,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  30d0 <sbstrans>
<<<sep_in_sample>>>
countparts(char *step, char *setname, FILE *dapfile)
{
  char sortname[127 + 4 + 1];
  fprintf(dapfile, "sort(\"%s\", \"", setname);
  strcpy(sortname, setname);
  strcat(sortname, ".srt");
  copylist(step, "by", dapfile);
  fputs("\", \"u\");\n", dapfile);
  fprintf(dapfile, "inset(\"%s\")\n{\n", sortname);
  fputs("for (_sbspictcnt_[_sbsnpicts_] = 0; step(); _sbspictcnt_[_sbsnpicts_]++)\n;\n}\n",
 dapfile);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 2
11 2
12 2
13 2
14 4
15 5
16 5
17 5
18 7
19 7
20 7
21 6
22 6
23 7
24 8
25 8
26 8
27 8
28 8
29 9
30 9
31 9
32 9
33 9
34 10
35 10
36 10
37 10
38 10
39 12
40 12
41 12
42 12
43 12
44 12
45 12
46 12
47 12
<<<sep_out_sample>>>
mov    %dl,0x0(%rip)        # b6 <set_no_of_sides+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_no_of_sides(const char *p, const char *s, char value)
{
  no_of_sides = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x10(%rdi),%rsi
mov    %rax,%rdi
jmpq   8f <lmniel_jac+0xf>
nop
<<<sep_in_sample>>>
lmniel_jac(void *vstate, gsl_matrix * J)
{
  lmniel_state_t *state = (lmniel_state_t *) vstate;
  int s = gsl_matrix_memcpy(J, state->J);
  return s;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     1ed0 <gsl_permute_vector_char_inverse+0x30>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1ec5 <gsl_permute_vector_char_inverse+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  1ee1 <gsl_permute_vector_char_inverse+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_char_inverse (const gsl_permutation * p, gsl_vector_char * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_char_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %r13
movslq %esi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
cmp    %r13d,%edi
jl     315b <move_lines_up+0x1b>
jmp    319b <move_lines_up+0x5b>
nopl   0x0(%rax)
mov    %r12d,%edi
lea    0x1(%rdi),%r12d
movslq %edi,%rbx
mov    0x0(,%rbx,8),%rdi
movslq %r12d,%rbp
mov    0x0(,%rbp,8),%rsi
callq  317a <move_lines_up+0x3a>
mov    0x0(,%rbp,4),%eax
cmp    %r13d,%r12d
mov    %eax,0x0(,%rbx,4)
mov    0x0(,%rbp,4),%eax
mov    %eax,0x0(,%rbx,4)
jne    3158 <move_lines_up+0x18>
mov    0x0(,%r13,8),%rax
movb   $0x0,(%rax)
movl   $0x0,0x0(,%r13,4)
movl   $0x0,0x0(,%r13,4)
subl   $0x1,0x0(%rip)        # 31c5 <move_lines_up+0x85>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
move_lines_up(int first, int last)
{
  int i;
  for(i = first; i < last; i++)
  {
    strcpy(lines[i], lines[i+1]);
    LINE_IS_LINKED[i] = LINE_IS_LINKED[i+1];
    totalCharsInLine[i] = totalCharsInLine[i+1];
  }
  lines[last][0] = '\0';
  LINE_IS_LINKED[last] = 0;
  totalCharsInLine[last] = 0;
  totalLines--;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 4
9 4
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 6
18 7
19 4
20 7
21 8
22 8
23 4
24 10
25 10
26 11
27 12
28 13
29 14
30 14
31 14
32 14
33 14
34 14
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     6e6 <ForAllVar+0x86>
mov    %rdi,%r13
mov    %rdx,%r15
mov    %rcx,%rbp
mov    %r8,%r14
xor    %r12d,%r12d
jmp    6a8 <ForAllVar+0x48>
nopw   0x0(%rax,%rax,1)
mov    0x10(%rbx),%rsi
and    $0xf0000,%esi
cmp    %rsi,%rbp
je     6ad <ForAllVar+0x4d>
mov    0x18(%rbx),%rbx
test   %rbx,%rbx
je     6ca <ForAllVar+0x6a>
test   %rbp,%rbp
jne    690 <ForAllVar+0x30>
test   %r15,%r15
je     6e0 <ForAllVar+0x80>
mov    %rbx,%rsi
mov    %r14,%rdx
mov    %r13,%rdi
callq  *%r15
mov    0x18(%rbx),%rbx
add    %eax,%r12d
test   %rbx,%rbx
jne    6a8 <ForAllVar+0x48>
add    $0x8,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x1,%r12d
jmp    69f <ForAllVar+0x3f>
xor    %r12d,%r12d
jmp    6ca <ForAllVar+0x6a>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ForAllVar (PFILE pfile, PVMMAPSTRCT pvm, PFI_CALLBACK pfiFunc,
               HANDLE hType, PVOID pinfo)
{
  int iTotal = 0;
  while (pvm) {
    if (hType == (0)
        || (pvm ? (pvm)->hType & 0xF0000 : 0x00000) == hType) {
      if (pfiFunc)
        iTotal += (*pfiFunc) (pfile, pvm, pinfo);
      else
        iTotal++;
    }
    pvm = pvm->pvmNextVar;
  }
  return (iTotal);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 4
16 4
17 4
18 7
19 7
20 7
21 7
22 13
23 5
24 5
25 6
26 6
27 8
28 8
29 9
30 9
31 9
32 9
33 13
34 9
35 5
36 5
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 16
47 11
48 11
49 4
50 4
51 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  139 <xscribble_get+0x9>
test   %rax,%rax
je     140 <xscribble_get+0x10>
pop    %rbx
retq   
mov    0x0(%rip),%rdi        # 147 <xscribble_get+0x17>
mov    %rbx,%rdx
mov    $0x0,%esi
callq  154 <xscribble_get+0x24>
mov    $0x1,%edi
callq  15e <xscribble_get+0x2e>
<<<sep_in_sample>>>
xscribble_get(ssize_t sz)
{
    void * p = scribble_get(sz);
    if (p == ((void *)0)) {
        fprintf(stderr, "could not allocate %u bytes of scribble space", sz);
        exit(1);
    }
    return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 9
7 9
8 5
9 5
10 5
11 5
12 6
13 6
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   8dd <write_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
write_error (char const *name)
{
  call_arg_error ("write", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <maxerr+0x7>
xorpd  %xmm0,%xmm0
mov    0x108(%rax),%rax
movsd  %xmm0,0x0(%rip)        # 1a <maxerr+0x1a>
movsd  %xmm0,0x0(%rip)        # 22 <maxerr+0x22>
movsd  %xmm0,0x0(%rip)        # 2a <maxerr+0x2a>
test   %rax,%rax
je     109 <maxerr+0x109>
movsd  0x0(%rip),%xmm5        # 3b <maxerr+0x3b>
mov    0x0(%rip),%rsi        # 42 <maxerr+0x42>
mov    0x0(%rip),%rcx        # 49 <maxerr+0x49>
movapd %xmm0,%xmm1
mov    0x0(%rip),%rdx        # 54 <maxerr+0x54>
movapd %xmm0,%xmm3
movapd %xmm0,%xmm4
jmp    64 <maxerr+0x64>
xchg   %ax,%ax
movapd %xmm0,%xmm3
movsd  0xa8(%rax),%xmm2
ucomisd %xmm4,%xmm2
jbe    79 <maxerr+0x79>
movapd %xmm2,%xmm4
mov    %rax,%rsi
movsd  0xb0(%rax),%xmm2
movapd %xmm0,%xmm6
ucomisd %xmm3,%xmm2
cmpnltsd %xmm2,%xmm3
movapd %xmm3,%xmm0
andpd  %xmm3,%xmm6
movapd %xmm5,%xmm3
andnpd %xmm2,%xmm0
cmova  %rax,%rcx
movsd  0xb8(%rax),%xmm2
cmpnltsd %xmm2,%xmm3
orpd   %xmm6,%xmm0
ucomisd %xmm5,%xmm2
andpd  %xmm3,%xmm1
movapd %xmm1,%xmm6
cmova  %rax,%rdx
movapd %xmm3,%xmm1
mov    0x108(%rax),%rax
andnpd %xmm2,%xmm1
test   %rax,%rax
orpd   %xmm6,%xmm1
jne    60 <maxerr+0x60>
movsd  %xmm4,0x0(%rip)        # e3 <maxerr+0xe3>
mov    %rsi,0x0(%rip)        # ea <maxerr+0xea>
mov    %rcx,0x0(%rip)        # f1 <maxerr+0xf1>
movsd  %xmm0,0x0(%rip)        # f9 <maxerr+0xf9>
mov    %rdx,0x0(%rip)        # 100 <maxerr+0x100>
movsd  %xmm1,0x0(%rip)        # 108 <maxerr+0x108>
retq   
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maxerr (void)
{
  struct sym *sp, *dq;
  dq = symtab->sy_link;
  ssemax = abemax = acemax = 0.0;
  for (sp = dq; sp != ((void *)0); sp = sp->sy_link)
    {
      if (ssemax < sp->sy_sserr)
 {
   ssemax = sp->sy_sserr;
   ssenam = sp->sy_name;
 }
      if (abemax < sp->sy_aberr)
 {
   abemax = sp->sy_aberr;
   abenam = sp->sy_name;
 }
      if (acmax < sp->sy_acerr)
 {
   acemax = sp->sy_acerr;
   acenam = sp->sy_name;
 }
    }
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 5
6 5
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 8
22 10
23 11
24 13
25 16
26 16
27 16
28 16
29 16
30 21
31 16
32 16
33 18
34 21
35 16
36 21
37 21
38 21
39 21
40 21
41 6
42 21
43 6
44 21
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 6
53 6
54 6
<<<sep_out_sample>>>
mov    $0x60,%edi
jmpq   64a <new_decl+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
new_decl(void)
{
  return (decl_t *) salloc (sizeof (decl_t));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <utf16be+0x7>
test   %rax,%rax
je     10 <utf16be+0x10>
retq   
nopl   (%rax)
mov    $0x0,%esi
sub    $0x8,%rsp
mov    %rsi,%rdi
callq  21 <utf16be+0x21>
cmp    $0xffffffffffffffff,%rax
je     48 <utf16be+0x48>
mov    %rax,%rdi
callq  2f <utf16be+0x2f>
movq   $0x0,0x0(%rip)        # 3a <utf16be+0x3a>
mov    $0x0,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
movq   $0x0,0x0(%rip)        # 53 <utf16be+0x53>
mov    $0x0,%eax
jmp    3f <utf16be+0x3f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
utf16be()
{
  iconv_t cd;
  static char* name = 0;
  if(name == 0) {
    if((cd = iconv_open("UTF-16BE", "UTF-16BE")) == (iconv_t)-1) {
      name = "UTF-16";
    } else {
      iconv_close(cd);
      name = "UTF-16BE";
    }
  }
  return name;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 14
5 14
6 6
7 2
8 6
9 6
10 6
11 6
12 9
13 9
14 10
15 10
16 14
17 14
18 14
19 7
20 7
21 7
22 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
callq  8d <strar_close+0xd>
mov    0x8(%rbx),%rdi
callq  96 <strar_close+0x16>
mov    %rax,%rdi
callq  9e <strar_close+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   a7 <strar_close+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
strar_close(STRAR * strar)
{
 strob_close(strar->storageM);
 free(cplob_release(strar->listM));
 free(strar);
 return;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 4
9 5
10 7
11 5
12 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rsi,%r12
push   %rbx
sub    $0x18,%rsp
mov    %fs:0x28,%rax
mov    %rax,-0x28(%rbp)
xor    %eax,%eax
callq  d6a <pw_glob_on_suffix+0x2a>
add    $0x20,%rax
mov    %r12,%rsi
and    $0xfffffffffffffff0,%rax
sub    %rax,%rsp
lea    0xf(%rsp),%rbx
and    $0xfffffffffffffff0,%rbx
lea    0x1(%rbx),%rdi
movb   $0x2a,(%rbx)
callq  d8d <pw_glob_on_suffix+0x4d>
mov    %rbx,%rsi
mov    %r13,%rdi
callq  d98 <pw_glob_on_suffix+0x58>
mov    $0x0,%esi
mov    %rax,%rdi
mov    %rax,%rbx
callq  da8 <pw_glob_on_suffix+0x68>
mov    -0x28(%rbp),%rdx
xor    %fs:0x28,%rdx
jne    dc5 <pw_glob_on_suffix+0x85>
lea    -0x18(%rbp),%rsp
mov    %rbx,%rax
pop    %rbx
pop    %r12
pop    %r13
pop    %rbp
retq   
callq  dca <pw_glob_on_suffix+0x8a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pw_glob_on_suffix (char * const * path, const char * suffix)
{
  struct darray * res;
  char * pattern;
  do { const char * _tmp1_ = (const char *) ("*"); const char * _tmp2_ = (const char *) (suffix); pattern = ((char *) __builtin_alloca (sizeof (char) * ((strlen (_tmp1_) + strlen (_tmp2_) + 1)))); do { stpcpy (stpcpy (pattern, "*"), suffix); } while (0); } while (0);
  res = pw_glob (path, pattern);
  da_map (res, (da_map_func_t) da_str_cut_suffix);
  return res;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 7
27 7
28 6
29 7
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  9e <rkck_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  ac <rkck_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  ba <rkck_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  c8 <rkck_reset+0x48>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  d6 <rkck_reset+0x56>
mov    0x28(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  e4 <rkck_reset+0x64>
mov    0x38(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  f2 <rkck_reset+0x72>
mov    0x30(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  100 <rkck_reset+0x80>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rkck_reset (void *vstate, size_t dim)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->k2),0,(dim)*sizeof(double));
  memset((state->k3),0,(dim)*sizeof(double));
  memset((state->k4),0,(dim)*sizeof(double));
  memset((state->k5),0,(dim)*sizeof(double));
  memset((state->k6),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 11
35 11
36 11
37 11
38 13
39 13
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # f6 <set_current_addr+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_current_addr( const int addr ) { current_addr_ = addr; }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdx,%r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%rbp
mov    0x10(%rsi),%r15
mov    %rdi,(%rsp)
mov    (%rsi),%r12
cmp    %rbp,%r15
je     1a69 <gsl_matrix_uint_fprintf+0x99>
lea    0x0(,%r15,4),%rax
xor    %r13d,%r13d
xor    %r15d,%r15d
test   %r12,%r12
mov    %rax,0x8(%rsp)
jne    1a26 <gsl_matrix_uint_fprintf+0x56>
jmp    1a58 <gsl_matrix_uint_fprintf+0x88>
nopw   0x0(%rax,%rax,1)
add    $0x1,%r15
add    0x8(%rsp),%r13
cmp    %r12,%r15
je     1a58 <gsl_matrix_uint_fprintf+0x88>
mov    %r13,%rsi
add    0x18(%rbx),%rsi
mov    (%rsp),%rdi
mov    %r14,%r8
mov    $0x1,%ecx
mov    %rbp,%rdx
callq  1a41 <gsl_matrix_uint_fprintf+0x71>
test   %eax,%eax
je     1a18 <gsl_matrix_uint_fprintf+0x48>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
mov    (%rsp),%rdi
add    $0x18,%rsp
pop    %rbx
pop    %rbp
mov    %r15,%rdx
mov    %r14,%r8
mov    $0x1,%ecx
imul   %r12,%rdx
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   1a93 <gsl_matrix_uint_fprintf+0xc3>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_fprintf (FILE * stream, const gsl_matrix_uint * m,
                                const char *format)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uint_raw_fprintf (stream,
                                                  m->data,
                                                  size1 * size2, 1,
                                                  format);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uint_raw_fprintf (stream,
                                                      m->data + i * 1 * tda,
                                                      size2, 1,
                                                      format);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 6
11 7
12 3
13 5
14 8
15 8
16 8
17 18
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 20
29 20
30 20
31 20
32 20
33 20
34 20
35 24
36 24
37 29
38 29
39 29
40 29
41 29
42 29
43 29
44 29
45 29
46 29
47 18
48 29
49 29
50 29
51 29
52 29
53 29
54 29
55 10
56 10
57 29
58 29
59 29
60 10
61 10
62 10
63 10
64 29
65 29
66 29
67 29
68 10
69 10
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
jmpq   1379 <xformat_u_close_file+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xformat_u_close_file(XFORMAT * xux, int fd)
{
 ;
 return swvarfs_u_close(xux->swvarfsM, fd);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x2010,%rsp
mov    0x0(%rip),%rdx        # 5c5 <read_one_line+0x15>
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
test   %rdx,%rdx
je     668 <read_one_line+0xb8>
mov    $0x2000,%esi
mov    %rsp,%rdi
xor    %ebx,%ebx
callq  5f0 <read_one_line+0x40>
test   %rax,%rax
mov    %rsp,%rbp
je     640 <read_one_line+0x90>
mov    %rsp,%rbx
mov    (%rbx),%eax
add    $0x4,%rbx
lea    -0x1010101(%rax),%ecx
not    %eax
and    %eax,%ecx
and    $0x80808080,%ecx
je     5fb <read_one_line+0x4b>
mov    %ecx,%eax
mov    %rbp,%rsi
mov    %r12,%rdi
shr    $0x10,%eax
test   $0x8080,%ecx
cmove  %eax,%ecx
lea    0x2(%rbx),%rax
cmove  %rax,%rbx
add    %cl,%cl
sbb    $0x3,%rbx
sub    %rbp,%rbx
mov    %rbx,%rdx
callq  640 <read_one_line+0x90>
mov    0x2008(%rsp),%rsi
xor    %fs:0x28,%rsi
mov    %rbx,%rax
jne    6bd <read_one_line+0x10d>
add    $0x2010,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
callq  672 <read_one_line+0xc2>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 67c <read_one_line+0xcc>
mov    %rax,%rdx
jne    5e1 <read_one_line+0x31>
callq  68a <read_one_line+0xda>
mov    (%rax),%edi
callq  691 <read_one_line+0xe1>
mov    0x0(%rip),%rdi        # 698 <read_one_line+0xe8>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  6a7 <read_one_line+0xf7>
mov    $0x1,%edi
callq  6b1 <read_one_line+0x101>
mov    0x0(%rip),%rdx        # 6b8 <read_one_line+0x108>
jmpq   5e1 <read_one_line+0x31>
callq  6c2 <read_one_line+0x112>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_one_line(int fd, void *buffer, size_t count)
{
 char buf[8192];
 if (fp == ((void *)0)) {
  fp = fdopen(fd, "r");
  if (fp == ((void *)0)) {
   fprintf(stderr, "ugh. fdopen: %s\n", strerror((*__errno_location ())));
   gawk_exit(1);
  }
 }
 if (fgets(buf, sizeof buf, fp) == ((void *)0))
  return 0;
 memcpy(buffer, buf, strlen(buf));
 return strlen(buf);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 2
8 2
9 2
10 4
11 4
12 11
13 11
14 12
15 11
16 11
17 11
18 11
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 13
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 5
51 5
52 6
53 5
54 5
55 6
56 7
57 7
58 7
59 7
60 7
61 7
62 7
63 7
64 8
65 8
66 8
67 8
68 15
69 15
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
test   %rsi,%rsi
je     58f <print_refs+0x4f>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x8(%rsi),%rbx
test   %rbx,%rbx
je     589 <print_refs+0x49>
nopw   0x0(%rax,%rax,1)
mov    0x18(%rbx),%rax
mov    0x0(%rip),%rdi        # 56b <print_refs+0x2b>
mov    %rbp,%rdx
mov    $0x0,%esi
mov    0x8(%rax),%rcx
mov    (%rax),%r8d
xor    %eax,%eax
callq  581 <print_refs+0x41>
mov    (%rbx),%rbx
test   %rbx,%rbx
jne    560 <print_refs+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_refs(char *name, struct linked_list *reflist)
{
     Ref *refptr;
     struct linked_list_entry *p;
     for (p = ((reflist) ? (reflist)->head : ((void *)0)); p; p = p->next) {
   refptr = (Ref*)p->data;
   fprintf(outfile, "%s   %s:%d\n",
    name,
    refptr->source,
    refptr->line);
     }
}
<<<sep_in_sample>>>
1 5
2 5
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 5
20 5
21 5
22 12
23 12
24 12
25 12
26 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <DISxSetProtocolVersion+0x6>
mov    %edi,0x0(%rip)        # c <DISxSetProtocolVersion+0xc>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
DISxSetProtocolVersion(int version)
{
 int result = protocol_version;
 protocol_version = version;
 return result;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
<<<sep_out_sample>>>
xorpd  %xmm2,%xmm2
ucomisd %xmm0,%xmm2
ja     c0 <gsl_ran_rayleigh_pdf+0x60>
movapd %xmm0,%xmm2
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm0        # 7a <gsl_ran_rayleigh_pdf+0x1a>
divsd  %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
xorpd  %xmm2,%xmm0
movsd  %xmm2,(%rsp)
mulsd  %xmm2,%xmm0
mulsd  0x0(%rip),%xmm0        # 99 <gsl_ran_rayleigh_pdf+0x39>
callq  9e <gsl_ran_rayleigh_pdf+0x3e>
movsd  (%rsp),%xmm2
movsd  0x8(%rsp),%xmm1
movapd %xmm0,%xmm3
add    $0x18,%rsp
divsd  %xmm1,%xmm2
movapd %xmm2,%xmm0
mulsd  %xmm3,%xmm0
retq   
xchg   %ax,%ax
movapd %xmm2,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_ran_rayleigh_pdf (const double x, const double sigma)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      double u = x / sigma ;
      double p = (u / sigma) * exp(-u * u / 2.0) ;
      return p;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 9
5 2
6 10
7 9
8 9
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 13
18 10
19 10
20 10
21 13
22 13
23 5
24 5
25 5
<<<sep_out_sample>>>
push   %rbx
callq  b6 <xstr_iconveh+0x6>
test   %rax,%rax
mov    %rax,%rbx
je     c8 <xstr_iconveh+0x18>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
callq  cd <xstr_iconveh+0x1d>
cmpl   $0xc,(%rax)
jne    be <xstr_iconveh+0xe>
callq  d7 <xstr_iconveh+0x27>
<<<sep_in_sample>>>
xstr_iconveh (const char *src,
              const char *from_codeset, const char *to_codeset,
              enum iconv_ilseq_handler handler)
{
  char *result = str_iconveh (src, from_codeset, to_codeset, handler);
  if (result == ((void *)0) && (*__errno_location ()) == 12)
    xalloc_die ();
  return result;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 5
5 6
6 9
7 9
8 9
9 9
10 6
11 6
12 6
13 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
mov    0x3880(%rdi),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_get_discmode_image (void *p_user_data)
{
  _img_private_t *p_env = p_user_data;
  return p_env->disc_mode;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  bcc <gsl_sf_synchrotron_2+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    be0 <gsl_sf_synchrotron_2+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x11c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  bf6 <gsl_sf_synchrotron_2+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_synchrotron_2(const double x)
{
  gsl_sf_result result; int status = gsl_sf_synchrotron_2_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_synchrotron_2_e(x, &result)", "synchrotron.c", 284, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_ctx_get (Gsasl_session * sctx)
{
  return sctx->ctx;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  15 <mu_make_file_name+0x15>
test   %rax,%rax
je     8b <mu_make_file_name+0x8b>
cmpb   $0x2f,-0x1(%rbp,%rax,1)
lea    -0x1(%rax),%rbx
je     3e <mu_make_file_name+0x3e>
jmp    8f <mu_make_file_name+0x8f>
nopw   0x0(%rax,%rax,1)
cmpb   $0x2f,-0x1(%rbp,%rbx,1)
lea    -0x1(%rbx),%rax
jne    43 <mu_make_file_name+0x43>
mov    %rax,%rbx
test   %rbx,%rbx
jne    30 <mu_make_file_name+0x30>
mov    %r13,%rdi
callq  4b <mu_make_file_name+0x4b>
lea    0x2(%rbx,%rax,1),%rdi
callq  55 <mu_make_file_name+0x55>
test   %rax,%rax
mov    %rax,%r12
je     7d <mu_make_file_name+0x7d>
mov    %rbp,%rsi
mov    %rax,%rdi
mov    %rbx,%rdx
callq  6b <mu_make_file_name+0x6b>
lea    0x1(%r12,%rbx,1),%rdi
movb   $0x2f,(%r12,%rbx,1)
mov    %r13,%rsi
callq  7d <mu_make_file_name+0x7d>
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %ebx,%ebx
jmp    43 <mu_make_file_name+0x43>
mov    %rax,%rbx
jmp    43 <mu_make_file_name+0x43>
<<<sep_in_sample>>>
mu_make_file_name (const char *dir, const char *file)
{
  char *tmp;
  size_t dirlen = strlen (dir);
  size_t len;
  while (dirlen > 0 && dir[dirlen-1] == '/')
    dirlen--;
  len = dirlen + 1 + strlen (file);
  tmp = mu_alloc (len + 1);
  if (tmp)
    {
      memcpy (tmp, dir, dirlen);
      tmp[dirlen++] = '/';
      strcpy (tmp + dirlen, file);
    }
  return tmp;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 8
23 8
24 9
25 9
26 10
27 9
28 10
29 12
30 12
31 12
32 12
33 14
34 13
35 14
36 14
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 6
45 6
46 6
47 6
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mod_compare_count (dico_result_t rp)
{
    struct result *res = (struct result *) rp;
    return res->compare_count;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  1c <vplob_close+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   25 <vplob_close+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vplob_close(VPLOB * vplob)
{
 CPLOB * cplob = (CPLOB*)vplob;
 free(cplob->list);
 free(cplob);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
sub    $0x58,%rsp
movapd %xmm0,%xmm5
movsd  0x0(%rip),%xmm4        # 200 <solve_cubic+0x10>
mulsd  %xmm5,%xmm0
mulsd  %xmm1,%xmm4
movsd  0x0(%rip),%xmm3        # 210 <solve_cubic+0x20>
mulsd  0x0(%rip),%xmm2        # 218 <solve_cubic+0x28>
xorpd  %xmm6,%xmm6
subsd  %xmm0,%xmm4
movapd %xmm5,%xmm0
addsd  %xmm5,%xmm0
divsd  %xmm3,%xmm4
mulsd  %xmm5,%xmm3
mulsd  %xmm5,%xmm0
mulsd  %xmm1,%xmm3
mulsd  %xmm5,%xmm0
subsd  %xmm2,%xmm3
movapd %xmm4,%xmm2
mulsd  %xmm4,%xmm2
subsd  %xmm0,%xmm3
mulsd  %xmm4,%xmm2
divsd  0x0(%rip),%xmm3        # 258 <solve_cubic+0x68>
movapd %xmm3,%xmm0
mulsd  %xmm3,%xmm0
addsd  %xmm0,%xmm2
ucomisd %xmm6,%xmm2
jb     388 <solve_cubic+0x198>
sqrtsd %xmm2,%xmm6
ucomisd %xmm6,%xmm6
movapd %xmm6,%xmm0
jp     465 <solve_cubic+0x275>
addsd  %xmm3,%xmm0
movsd  0x0(%rip),%xmm7        # 28c <solve_cubic+0x9c>
movsd  0x0(%rip),%xmm1        # 294 <solve_cubic+0xa4>
movsd  %xmm6,0x48(%rsp)
movsd  %xmm5,0x40(%rsp)
movapd %xmm0,%xmm4
movsd  %xmm0,0x30(%rsp)
movsd  %xmm2,0x38(%rsp)
andpd  %xmm7,%xmm4
movsd  %xmm3,0x20(%rsp)
movapd %xmm7,0x10(%rsp)
movapd %xmm4,%xmm0
movsd  %xmm4,0x8(%rsp)
callq  2cf <solve_cubic+0xdf>
movsd  0x8(%rsp),%xmm4
movsd  0x30(%rsp),%xmm8
movsd  0x48(%rsp),%xmm6
divsd  %xmm8,%xmm4
movapd 0x10(%rsp),%xmm7
ucomisd %xmm6,%xmm6
movsd  0x20(%rsp),%xmm3
movsd  0x38(%rsp),%xmm2
movsd  0x40(%rsp),%xmm5
mulsd  %xmm0,%xmm4
movapd %xmm6,%xmm0
jp     427 <solve_cubic+0x237>
subsd  %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # 31d <solve_cubic+0x12d>
movsd  %xmm5,0x20(%rsp)
movsd  %xmm4,0x30(%rsp)
andpd  %xmm3,%xmm7
movsd  %xmm3,0x10(%rsp)
movapd %xmm7,%xmm2
movapd %xmm2,%xmm0
movsd  %xmm2,0x8(%rsp)
callq  346 <solve_cubic+0x156>
movsd  0x8(%rsp),%xmm2
movsd  0x10(%rsp),%xmm3
movapd %xmm2,%xmm1
movsd  0x30(%rsp),%xmm4
movsd  0x20(%rsp),%xmm5
divsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
divsd  0x0(%rip),%xmm5        # 372 <solve_cubic+0x182>
addsd  %xmm1,%xmm4
add    $0x58,%rsp
movapd %xmm4,%xmm0
subsd  %xmm5,%xmm0
retq   
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm2        # 390 <solve_cubic+0x1a0>
xorpd  %xmm4,%xmm2
movapd %xmm2,%xmm0
mulsd  %xmm4,%xmm0
mulsd  %xmm4,%xmm0
sqrtsd %xmm0,%xmm1
ucomisd %xmm1,%xmm1
jp     4a3 <solve_cubic+0x2b3>
divsd  %xmm1,%xmm3
movsd  %xmm5,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movapd %xmm3,%xmm0
callq  3c7 <solve_cubic+0x1d7>
movsd  0x8(%rsp),%xmm2
movapd %xmm0,%xmm1
movsd  0x10(%rsp),%xmm5
sqrtsd %xmm2,%xmm4
ucomisd %xmm4,%xmm4
jp     4d5 <solve_cubic+0x2e5>
addsd  0x0(%rip),%xmm1        # 3ed <solve_cubic+0x1fd>
movsd  %xmm4,0x10(%rsp)
movsd  %xmm5,0x8(%rsp)
movapd %xmm1,%xmm0
divsd  0x0(%rip),%xmm0        # 405 <solve_cubic+0x215>
callq  40a <solve_cubic+0x21a>
movsd  0x10(%rsp),%xmm4
xorpd  %xmm1,%xmm1
addsd  %xmm4,%xmm4
movsd  0x8(%rsp),%xmm5
mulsd  %xmm0,%xmm4
jmpq   36a <solve_cubic+0x17a>
movapd %xmm2,%xmm0
movsd  %xmm5,0x30(%rsp)
movapd %xmm7,0x20(%rsp)
movsd  %xmm3,0x10(%rsp)
movsd  %xmm4,0x8(%rsp)
callq  448 <solve_cubic+0x258>
movsd  0x30(%rsp),%xmm5
movapd 0x20(%rsp),%xmm7
movsd  0x10(%rsp),%xmm3
movsd  0x8(%rsp),%xmm4
jmpq   311 <solve_cubic+0x121>
movapd %xmm2,%xmm0
movsd  %xmm6,0x20(%rsp)
movsd  %xmm5,0x30(%rsp)
movsd  %xmm3,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
callq  486 <solve_cubic+0x296>
movsd  0x20(%rsp),%xmm6
movsd  0x30(%rsp),%xmm5
movsd  0x10(%rsp),%xmm3
movsd  0x8(%rsp),%xmm2
jmpq   280 <solve_cubic+0x90>
movsd  %xmm5,0x30(%rsp)
movsd  %xmm2,0x10(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  4ba <solve_cubic+0x2ca>
movsd  0x30(%rsp),%xmm5
movapd %xmm0,%xmm1
movsd  0x10(%rsp),%xmm2
movsd  0x8(%rsp),%xmm3
jmpq   3ae <solve_cubic+0x1be>
movsd  %xmm0,0x8(%rsp)
movapd %xmm2,%xmm0
callq  4e4 <solve_cubic+0x2f4>
movsd  0x10(%rsp),%xmm5
movapd %xmm0,%xmm4
movsd  0x8(%rsp),%xmm1
jmpq   3e5 <solve_cubic+0x1f5>
nopl   0x0(%rax)
<<<sep_in_sample>>>
solve_cubic(double c2, double c1, double c0)
{
  double qq, rr, ww, ss, tt;
  qq = (3*c1 - c2*c2)/9;
  rr = (9*c2*c1 - 27*c0 - 2*c2*c2*c2)/54;
  ww = qq*qq*qq + rr*rr;
  if (ww >= 0)
  {
      double t1 = rr + sqrt(ww);
      ss = fabs(t1)/t1*pow(fabs(t1), 1/3.);
      t1 = rr - sqrt(ww);
      tt = fabs(t1)/t1*pow(fabs(t1), 1/3.);
  }
  else
  {
      double theta = acos(rr/sqrt(-qq*qq*qq));
      ss = 2*sqrt(-qq)*cos((theta + 4*3.14159265358979323846)/3.);
      tt = 0.0;
  }
  return (ss + tt - c2/3);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 7
9 4
10 5
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 5
21 6
22 5
23 6
24 6
25 6
26 7
27 7
28 9
29 9
30 9
31 9
32 9
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 9
42 10
43 10
44 10
45 10
46 10
47 10
48 11
49 10
50 11
51 11
52 11
53 11
54 11
55 10
56 11
57 11
58 11
59 12
60 12
61 12
62 12
63 12
64 12
65 12
66 12
67 12
68 12
69 12
70 12
71 12
72 12
73 12
74 12
75 20
76 20
77 21
78 20
79 20
80 21
81 21
82 16
83 16
84 16
85 16
86 16
87 16
88 16
89 16
90 16
91 16
92 16
93 16
94 16
95 17
96 16
97 17
98 17
99 17
100 17
101 17
102 17
103 17
104 17
105 17
106 17
107 17
108 18
109 17
110 18
111 17
112 17
113 11
114 11
115 11
116 11
117 11
118 11
119 11
120 11
121 11
122 11
123 11
124 9
125 9
126 9
127 9
128 9
129 9
130 9
131 9
132 9
133 9
134 9
135 9
136 9
137 9
138 16
139 16
140 16
141 16
142 16
143 16
144 16
145 17
146 17
147 17
148 17
149 17
150 17
151 17
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdx
addq   $0x1,0x0(%rip)        # 58c <compare_prefix+0xc>
cmp    0x10(%rsi),%rdx
ja     5a0 <compare_prefix+0x20>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   59d <compare_prefix+0x1d>
nopl   (%rax)
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
compare_prefix(const void *a, const void *b)
{
    const struct index_entry *pkey = a;
    const struct index_entry *pelt = b;
    size_t wordlen = pkey->wordlen;
    compare_count++;
    if (pelt->wordlen < wordlen)
 return -1;
    return utf8_strncasecmp(pkey->word, pelt->word, wordlen);
}
<<<sep_in_sample>>>
1 5
2 6
3 7
4 7
5 9
6 9
7 9
8 9
9 10
10 10
11 10
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    (%rcx),%rax
cmp    0x8(%rcx),%rax
je     10f0 <gsl_blas_strmv+0x30>
mov    $0x14,%ecx
mov    $0x320,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  10e6 <gsl_blas_strmv+0x26>
mov    $0x14,%eax
add    $0x28,%rsp
retq   
cmp    (%r8),%rax
je     1120 <gsl_blas_strmv+0x60>
mov    $0x13,%ecx
mov    $0x324,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  110e <gsl_blas_strmv+0x4e>
mov    $0x13,%eax
add    $0x28,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%r8),%r10
mov    0x18(%rcx),%r9
mov    %r10d,0x10(%rsp)
mov    0x10(%r8),%r8
mov    %r8,0x8(%rsp)
mov    0x10(%rcx),%rcx
mov    %eax,%r8d
mov    %ecx,(%rsp)
mov    %edx,%ecx
mov    %esi,%edx
mov    %edi,%esi
mov    $0x65,%edi
callq  1150 <gsl_blas_strmv+0x90>
xor    %eax,%eax
jmp    10eb <gsl_blas_strmv+0x2b>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 800, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (N != X->size)
    {
      do { gsl_error ("invalid length", "blas.c", 804, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_strmv (CblasRowMajor, Uplo, TransA, Diag, ((int)(N)), A->data,
               ((int)(A->tda)), X->data, ((int)(X->stride)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
5 9
6 9
7 9
8 9
9 9
10 9
11 18
12 18
13 11
14 11
15 13
16 13
17 13
18 13
19 13
20 13
21 18
22 18
23 18
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 15
37 17
38 17
39 17
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
test   %rdi,%rdi
je     3a <locale_to_utf8+0x3a>
mov    $0xe,%edi
callq  1a <locale_to_utf8+0x1a>
mov    $0x0,%edx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  2a <locale_to_utf8+0x2a>
test   %rax,%rax
mov    %rax,%rbx
je     48 <locale_to_utf8+0x48>
mov    %rbp,%rdi
callq  3a <locale_to_utf8+0x3a>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rcx        # 4f <locale_to_utf8+0x4f>
mov    $0x2e,%edx
mov    $0x1,%esi
mov    $0x0,%edi
mov    %rbp,%rbx
callq  66 <locale_to_utf8+0x66>
jmp    3a <locale_to_utf8+0x3a>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
locale_to_utf8 (char *str)
{
  if (str)
    {
      char *from = nl_langinfo (CODESET);
      char *q = str_iconv (str, from, "UTF-8");
      if (!q)
 fprintf (stderr, "warning: Could not convert string to UTF-8...\n");
      else
 {
   free (str);
   str = q;
 }
    }
  return str;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 11
18 11
19 16
20 16
21 16
22 16
23 16
24 16
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x20,%rsp
callq  c63 <s_double+0x13>
lea    0x18(%rsp),%rsi
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    %rbp,%rdi
callq  c79 <s_double+0x29>
mov    (%rbx),%eax
movsd  %xmm0,0x10(%rsp)
test   %eax,%eax
jne    c8f <s_double+0x3f>
mov    0x18(%rsp),%rdx
cmpb   $0x0,(%rdx)
je     ca0 <s_double+0x50>
add    $0x20,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
lea    0x10(%rsp),%rsi
mov    %r12,%rdi
mov    $0x8,%edx
mov    %eax,0xc(%rsp)
callq  cb6 <s_double+0x66>
mov    0xc(%rsp),%eax
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
s_double (struct xdatum *xd, char *str)
{
  double d;
  char *p;
  (*__errno_location ()) = 0;
  d = strtod (str, &p);
  if ((*__errno_location ()) || *p)
    return 1;
  xd_store (xd, &d, sizeof (d));
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 6
9 5
10 5
11 6
12 6
13 7
14 6
15 7
16 7
17 7
18 7
19 7
20 11
21 8
22 11
23 11
24 11
25 11
26 11
27 9
28 9
29 9
30 9
31 9
32 10
33 11
34 11
35 11
36 11
37 11
38 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  19fb <asm_initscan+0xb>
movl   $0x1,0x0(%rip)        # 1a05 <asm_initscan+0x15>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
asm_initscan(void)
{
 asm_restart(((void *)0));
 asm_lineno = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     b60 <ck_free+0x10>
jmpq   b5a <ck_free+0xa>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ck_free(ptr)
  void *ptr;
{
  if (ptr)
    free(ptr);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    %rdx,0x10(%rsi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_node_nx_set_value (gl_list_t list, gl_list_node_t node,
                             const void *elt)
{
  node->value = elt;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
jmpq   30 <update_diag_marquardt>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
init_diag_marquardt(const gsl_matrix * JTJ, gsl_vector * diag)
{
  return update_diag_marquardt(JTJ, diag);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %esi,0x8(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_m_server_set_type (mu_m_server_t srv, int type)
{
  srv->deftype = type;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
xor    %r10d,%r10d
test   %edx,%edx
jle    78 <cblas_zswap+0x78>
xor    %eax,%eax
test   %r8d,%r8d
jle    89 <cblas_zswap+0x89>
test   %edi,%edi
jle    71 <cblas_zswap+0x71>
add    %r10d,%r10d
lea    (%rdx,%rdx,1),%r9d
add    %eax,%eax
movslq %r10d,%r10
cltq   
lea    0x8(%rsi,%r10,8),%rdx
lea    (%r8,%r8,1),%esi
movslq %r9d,%r9
lea    0x8(%rcx,%rax,8),%rax
shl    $0x3,%r9
xor    %ecx,%ecx
movslq %esi,%rsi
shl    $0x3,%rsi
xchg   %ax,%ax
movsd  -0x8(%rax),%xmm2
add    $0x1,%ecx
movsd  -0x8(%rdx),%xmm1
movsd  %xmm2,-0x8(%rdx)
movsd  (%rdx),%xmm0
movsd  (%rax),%xmm2
movsd  %xmm2,(%rdx)
add    %r9,%rdx
movsd  %xmm1,-0x8(%rax)
movsd  %xmm0,(%rax)
add    %rsi,%rax
cmp    %edi,%ecx
jne    40 <cblas_zswap+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    $0x1,%r10b
xor    %eax,%eax
sub    %edi,%r10d
imul   %edx,%r10d
test   %r8d,%r8d
jg     e <cblas_zswap+0xe>
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   e <cblas_zswap+0xe>
<<<sep_in_sample>>>
cblas_zswap (const int N, void *X, const int incX, void *Y, const int incY)
{
{
  int i;
  int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
  int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
  for (i = 0; i < N; i++) {
    const double tmp_real = (((double *) X)[2*(ix)]);
    const double tmp_imag = (((double *) X)[2*(ix)+1]);
    (((double *) X)[2*(ix)]) = (((double *) Y)[2*(iy)]);
    (((double *) X)[2*(ix)+1]) = (((double *) Y)[2*(iy)+1]);
    (((double *) Y)[2*(iy)]) = tmp_real;
    (((double *) Y)[2*(iy)+1]) = tmp_imag;
    ix += incX;
    iy += incY;
  }
}
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 10
24 7
25 8
26 10
27 9
28 11
29 11
30 11
31 12
32 13
33 13
34 7
35 7
36 7
37 7
38 5
39 6
40 5
41 5
42 6
43 6
44 6
45 6
46 6
47 6
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1d0 <gsl_bspline_free+0x70>
mov    0x28(%rdi),%rdi
test   %rdi,%rdi
je     177 <gsl_bspline_free+0x17>
callq  177 <gsl_bspline_free+0x17>
mov    0x30(%rbx),%rdi
test   %rdi,%rdi
je     185 <gsl_bspline_free+0x25>
callq  185 <gsl_bspline_free+0x25>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     193 <gsl_bspline_free+0x33>
callq  193 <gsl_bspline_free+0x33>
mov    0x40(%rbx),%rdi
test   %rdi,%rdi
je     1a1 <gsl_bspline_free+0x41>
callq  1a1 <gsl_bspline_free+0x41>
mov    0x48(%rbx),%rdi
test   %rdi,%rdi
je     1af <gsl_bspline_free+0x4f>
callq  1af <gsl_bspline_free+0x4f>
mov    0x50(%rbx),%rdi
test   %rdi,%rdi
je     1bd <gsl_bspline_free+0x5d>
callq  1bd <gsl_bspline_free+0x5d>
mov    %rbx,%rdi
pop    %rbx
jmpq   1c6 <gsl_bspline_free+0x66>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_bspline_free (gsl_bspline_workspace * w)
{
  if (!w) { return ; };
  if (w->knots)
    gsl_vector_free (w->knots);
  if (w->deltal)
    gsl_vector_free (w->deltal);
  if (w->deltar)
    gsl_vector_free (w->deltar);
  if (w->B)
    gsl_vector_free (w->B);
  if (w->A)
    gsl_matrix_free(w->A);
  if (w->dB)
    gsl_matrix_free(w->dB);
  free (w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 6
12 7
13 8
14 8
15 8
16 9
17 10
18 10
19 10
20 11
21 12
22 12
23 12
24 13
25 14
26 14
27 14
28 15
29 16
30 17
31 16
32 16
33 17
34 17
35 17
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
goldensection_init (void * vstate, gsl_function * f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper)
{
  goldensection_state_t * state = (goldensection_state_t *) vstate;
  state = 0;
  f = 0;
  x_minimum = 0;
  f_minimum = 0;
  x_lower = 0;
  f_lower = 0;
  x_upper = 0;
  f_upper = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 13
2 13
3 13
<<<sep_out_sample>>>
mov    0x28(%rdi),%rax
movsd  0x0(%rip),%xmm0        # 1b1c <gsl_monte_miser_init+0xc>
movsd  0x0(%rip),%xmm1        # 1b24 <gsl_monte_miser_init+0x14>
movq   $0x0,0x10(%rdi)
movsd  %xmm0,0x18(%rdi)
mov    %rax,%rdx
shl    $0x9,%rax
movsd  %xmm1,0x20(%rdi)
shl    $0x4,%rdx
mov    %rax,0x8(%rdi)
xor    %eax,%eax
mov    %rdx,(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_monte_miser_init (gsl_monte_miser_state * s)
{
  s->min_calls = 16 * s->dim;
  s->min_calls_per_bisection = 32 * s->min_calls;
  s->estimate_frac = 0.1;
  s->alpha = 2.0;
  s->dither = 0.0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 5
6 3
7 4
8 6
9 3
10 4
11 9
12 3
13 9
14 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 1e9b <reread+0xb>
mov    0x0(%rip),%rdi        # 1ea2 <reread+0x12>
mov    $0x1,%r8d
mov    $0xffffffffffffffff,%rcx
mov    $0x22,%esi
callq  1eb9 <reread+0x29>
mov    0x0(%rip),%rdx        # 1ec0 <reread+0x30>
mov    0x0(%rip),%rdi        # 1ec7 <reread+0x37>
mov    $0x1,%r8d
mov    $0xffffffffffffffff,%rcx
mov    $0x22,%esi
add    $0x8,%rsp
jmpq   1ee2 <reread+0x52>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
reread()
{
    panel_action(dst_panel, 34, src_panel, (void *)-1, 1);
    panel_action(src_panel, 34, dst_panel, (void *)-1, 1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 4
11 4
12 4
13 5
14 4
15 4
<<<sep_out_sample>>>
movl   $0x69,0x0(%rip)        # 91a <_rl_vi_reset_last+0xa>
movl   $0x1,0x0(%rip)        # 924 <_rl_vi_reset_last+0x14>
movl   $0x1,0x0(%rip)        # 92e <_rl_vi_reset_last+0x1e>
movl   $0x0,0x0(%rip)        # 938 <_rl_vi_reset_last+0x28>
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
_rl_vi_reset_last ()
{
  _rl_vi_last_command = 'i';
  _rl_vi_last_repeat = 1;
  _rl_vi_last_arg_sign = 1;
  _rl_vi_last_motion = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  b <redir_exit+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
redir_exit (int sig)
{
  _exit (0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0xc(%rdi),%ecx
mov    0x8(%rdx),%rax
add    $0xf,%rax
and    $0xfffffffffffffff8,%rax
imul   %rcx,%rax
add    0x10(%rdx),%rax
cmp    %rax,%rsi
sete   %al
movzbl %al,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
curitem_p (void *owner, void *item)
{
  struct assoc_iterator *itr = owner;
  mu_assoc_t assoc = itr->assoc;
  struct _mu_assoc_elem *elem = ((struct _mu_assoc_elem*) ((char*) ((assoc)->tab) + (((((assoc)->elsize + ((size_t)&((struct _mu_assoc_elem*)0)->data))) + ((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1) & ~(((((size_t)&((struct _mu_assoc_elem_align*)0)->x))) - 1)) * itr->index));
  return elem == item;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
11 7
12 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2199 <gsl_complex_arccoth+0x9>
callq  219e <gsl_complex_arccoth+0xe>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_complex_arccoth (gsl_complex a)
{
  gsl_complex t = gsl_complex_inverse (a);
  return gsl_complex_arctanh (t);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x40(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_oset_iterator_next (gl_oset_iterator_t *iterator, const void **eltp)
{
  return iterator->vtable->iterator_next (iterator, eltp);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     a95 <gsl_matrix_long_double_isnonneg+0x55>
shl    $0x4,%rax
xor    %esi,%esi
xor    %r9d,%r9d
mov    %rax,%r10
test   %rcx,%rcx
je     a89 <gsl_matrix_long_double_isnonneg+0x49>
mov    %rsi,%rdx
fldz   
add    0x18(%rdi),%rdx
xor    %eax,%eax
nopl   0x0(%rax)
fldt   (%rdx)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
ja     a9b <gsl_matrix_long_double_isnonneg+0x5b>
add    $0x1,%rax
add    $0x10,%rdx
cmp    %rcx,%rax
jne    a70 <gsl_matrix_long_double_isnonneg+0x30>
fstp   %st(0)
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    a5c <gsl_matrix_long_double_isnonneg+0x1c>
mov    $0x1,%eax
retq   
fstp   %st(0)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
gsl_matrix_long_double_isnonneg (const gsl_matrix_long_double * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] < 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 13
14 13
15 9
16 9
17 13
18 13
19 13
20 13
21 13
22 9
23 9
24 9
25 9
26 9
27 7
28 7
29 7
30 7
31 20
32 21
33 21
34 15
35 15
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <yy_load_buffer_state+0x7>
mov    0x0(%rip),%rdx        # e <yy_load_buffer_state+0xe>
lea    (%rax,%rdx,8),%rdx
mov    (%rdx),%rax
mov    0x1c(%rax),%ecx
mov    0x10(%rax),%rax
mov    %rax,0x0(%rip)        # 23 <yy_load_buffer_state+0x23>
mov    (%rdx),%rdx
mov    %rax,0x0(%rip)        # 2d <yy_load_buffer_state+0x2d>
mov    %ecx,0x0(%rip)        # 33 <yy_load_buffer_state+0x33>
mov    (%rdx),%rdx
mov    %rdx,0x0(%rip)        # 3d <yy_load_buffer_state+0x3d>
movzbl (%rax),%eax
mov    %al,0x0(%rip)        # 46 <yy_load_buffer_state+0x46>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_load_buffer_state (void)
{
     (yy_n_chars) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_n_chars;
 (yytext) = (yy_c_buf_p) = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_buf_pos;
 yyin = (yy_buffer_stack)[(yy_buffer_stack_top)]->yy_input_file;
 (yy_hold_char) = *(yy_c_buf_p);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 3
11 5
12 5
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
xor    %edx,%edx
xor    %esi,%esi
push   %rbp
push   %rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rdi
callq  a39 <CDB___db_salvage_init+0x19>
test   %eax,%eax
mov    %eax,%ebx
je     a50 <CDB___db_salvage_init+0x30>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rax
mov    $0x400,%esi
mov    %rax,%rdi
callq  *0x1a8(%rax)
test   %eax,%eax
mov    %eax,%ebp
jne    aa0 <CDB___db_salvage_init+0x80>
mov    0x8(%rsp),%rax
xor    %r9d,%r9d
xor    %edx,%edx
xor    %esi,%esi
mov    $0x1,%r8d
mov    $0x1,%ecx
mov    %rax,%rdi
callq  *0x140(%rax)
test   %eax,%eax
mov    %eax,%ebp
jne    aa0 <CDB___db_salvage_init+0x80>
mov    0x8(%rsp),%rax
mov    %rax,0x30(%r12)
jmp    a3f <CDB___db_salvage_init+0x1f>
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rax
mov    %ebp,%ebx
xor    %esi,%esi
mov    %rax,%rdi
callq  *0xe8(%rax)
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
CDB___db_salvage_init(vdp)
 VRFY_DBINFO *vdp;
{
 DB *dbp;
 int ret;
 if ((ret = CDB_db_create(&dbp, ((void *)0), 0)) != 0)
  return (ret);
 if ((ret = dbp->set_pagesize(dbp, 1024)) != 0)
  goto err;
 if ((ret = dbp->open(dbp, ((void *)0), ((void *)0), DB_BTREE, 0x000001, 0)) != 0)
  goto err;
 vdp->salvage_pages = dbp;
 return (0);
err: (void)dbp->close(dbp, 0);
 return (ret);
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 3
6 3
7 3
8 6
9 6
10 6
11 6
12 6
13 16
14 16
15 16
16 16
17 16
18 16
19 16
20 8
21 8
22 8
23 8
24 8
25 8
26 8
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 12
39 12
40 13
41 13
42 14
43 15
44 14
45 14
46 14
47 16
48 16
49 16
50 16
51 16
52 16
53 16
<<<sep_out_sample>>>
push   %r12
cmp    %edx,%esi
mov    %rdi,%r12
push   %rbp
mov    %ecx,%ebp
push   %rbx
mov    %esi,%ebx
je     1bcb <_sse_addr_d+0x1b>
cmp    %ecx,%esi
mov    %edx,%r8d
je     1bce <_sse_addr_d+0x1e>
callq  1b90 <_sse_movr_d.part.17>
mov    %ebp,%r8d
mov    %ebx,%ecx
mov    %r12,%rdi
mov    $0x58,%edx
pop    %rbx
pop    %rbp
pop    %r12
mov    $0xf2,%esi
jmpq   1a80 <_ssexr>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_addr_d(jit_state_t *_jit, jit_int32_t r0, jit_int32_t r1, jit_int32_t r2)
{
    if (r0 == r1)
 _ssexr(_jit,0xf2,0x58,r0,r2);
    else if (r0 == r2)
 _ssexr(_jit,0xf2,0x58,r0,r1);
    else {
 _sse_movr_d(_jit,r0,r1);
 _ssexr(_jit,0xf2,0x58,r0,r2);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 2
8 3
9 5
10 6
11 5
12 5
13 9
14 9
15 9
16 9
17 11
18 11
19 11
20 9
21 9
22 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     40 <ecopy+0x40>
callq  13 <ecopy+0x13>
lea    0x1(%rax),%rbp
mov    %rbp,%rdi
callq  1f <ecopy+0x1f>
test   %rax,%rax
je     44 <ecopy+0x44>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  32 <ecopy+0x32>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    32 <ecopy+0x32>
mov    $0x0,%edi
callq  4e <ecopy+0x4e>
mov    $0x1,%edi
callq  58 <ecopy+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ecopy(char *e)
{
  char *copy;
  if (e)
    {
      if (!(copy = malloc(strlen(e) + 1)))
 {
   perror("dap");
   exit(1);
 }
      strcpy(copy, e);
      return copy;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 11
14 11
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 14
23 14
24 8
25 8
26 9
27 9
28 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     d80 <gsl_permute_vector_float+0x30>
mov    $0x13,%ecx
mov    $0x90,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  d75 <gsl_permute_vector_float+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  d91 <gsl_permute_vector_float+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_float (const gsl_permutation * p, gsl_vector_float * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 144, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_float (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    %rdi,%rax
mov    0x18(%rdi),%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    0x28(%rdi),%rdi
mov    0x20(%r8),%r9
mov    0x20(%rax),%r8
jmpq   *%r9
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multiroot_fsolver_iterate (gsl_multiroot_fsolver * s)
{
  return (s->type->iterate) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
mov    0x0(%rip),%r8        # 7 <version_etc_hook+0x7>
mov    0x0(%rip),%rsi        # e <version_etc_hook+0xe>
mov    $0x0,%ecx
mov    $0x0,%edx
jmpq   1d <version_etc_hook+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
version_etc_hook (FILE *stream, struct argp_state *state)
{
  version_etc_ar (stream, program_canonical_name, "GNU cpio", "2.12",
                  program_authors);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc_read_selections_file(void)
{
 return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     6020 <register_output_wrapper+0x40>
cmpq   $0x0,0x0(%rip)        # 5ff1 <register_output_wrapper+0x11>
movq   $0x0,0x18(%rbx)
je     6010 <register_output_wrapper+0x30>
mov    0x0(%rip),%rax        # 6002 <register_output_wrapper+0x22>
mov    %rbx,0x0(%rip)        # 6009 <register_output_wrapper+0x29>
mov    %rbx,0x18(%rax)
pop    %rbx
retq   
nop
mov    %rbx,0x0(%rip)        # 6017 <register_output_wrapper+0x37>
mov    %rbx,0x0(%rip)        # 601e <register_output_wrapper+0x3e>
pop    %rbx
retq   
mov    $0xb22,%esi
mov    $0x0,%edi
callq  602f <register_output_wrapper+0x4f>
mov    $0x0,%edi
callq  6039 <register_output_wrapper+0x59>
mov    %rax,%rdi
xor    %eax,%eax
callq  6043 <register_output_wrapper+0x63>
jmp    5fe9 <register_output_wrapper+0x9>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
register_output_wrapper(awk_output_wrapper_t *wrapper)
{
 if (wrapper == ((void *)0))
  (*(set_loc("io.c", 2850), r_fatal))(gettext("register_output_wrapper: received NULL pointer"));
 wrapper->next = ((void *)0);
 if (op_head == ((void *)0)) {
  op_head = op_tail = wrapper;
 } else {
  op_tail->next = wrapper;
  op_tail = op_tail->next;
 }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 6
6 5
7 6
8 9
9 10
10 9
11 12
12 12
13 12
14 7
15 7
16 12
17 12
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x100,%rsp
mov    0x0(%rip),%rdi        # 22f <deprep_terminal+0xf>
callq  234 <deprep_terminal+0x14>
mov    0x0(%rip),%edx        # 23a <deprep_terminal+0x1a>
test   %edx,%edx
jne    250 <deprep_terminal+0x30>
add    $0x100,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%edi
mov    %eax,%ebx
callq  259 <deprep_terminal+0x39>
test   %eax,%eax
jne    270 <deprep_terminal+0x50>
movl   $0x0,0x0(%rip)        # 267 <deprep_terminal+0x47>
add    $0x100,%rsp
pop    %rbx
retq   
mov    %rsp,%rdi
callq  278 <deprep_terminal+0x58>
lea    0x80(%rsp),%rdi
callq  285 <deprep_terminal+0x65>
mov    %rsp,%rdi
mov    $0x2,%esi
callq  292 <deprep_terminal+0x72>
lea    0x80(%rsp),%rdx
mov    %rsp,%rsi
xor    %edi,%edi
callq  2a4 <deprep_terminal+0x84>
mov    $0x0,%edx
mov    %ebx,%edi
mov    $0x1,%esi
callq  2b5 <deprep_terminal+0x95>
mov    %ebx,%edi
mov    $0x1,%esi
callq  2c1 <deprep_terminal+0xa1>
lea    0x80(%rsp),%rsi
xor    %edx,%edx
mov    $0x2,%edi
movl   $0x0,0x0(%rip)        # 2da <deprep_terminal+0xba>
callq  2df <deprep_terminal+0xbf>
jmpq   23e <deprep_terminal+0x1e>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
deprep_terminal ()
{
  int tty = fileno (stdin);
  sigset_t set, oset;
  if (!terminal_prepped)
    return;
  if (!isatty(tty)) {
    terminal_prepped = 0;
    return;
  }
  sigemptyset (&set);
  sigemptyset (&oset);
  sigaddset (&set, 2);
  sigprocmask (0, &set, &oset);
  tcsetattr (tty, 1, &otio);
  tcflow (tty, 1);
  terminal_prepped = 0;
  sigprocmask (2, &oset, (sigset_t *)((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 5
6 5
7 5
8 19
9 19
10 19
11 19
12 7
13 7
14 7
15 7
16 7
17 8
18 19
19 19
20 19
21 11
22 11
23 12
24 12
25 13
26 13
27 13
28 14
29 14
30 14
31 14
32 15
33 15
34 15
35 15
36 16
37 16
38 16
39 18
40 18
41 18
42 17
43 18
44 18
45 18
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1187 <__osip_uri_escape_password+0x7>
jmpq   118c <__osip_uri_escape_password+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
__osip_uri_escape_password (const char *string)
{
  return __osip_uri_escape_nonascii_and_nondef (string, password_def);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # b <doflush+0xb>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xff,(%rax)
callq  1d <doflush+0x1d>
mov    0x0(%rip),%rax        # 24 <doflush+0x24>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0xfd,(%rax)
callq  36 <doflush+0x36>
mov    0x0(%rip),%rax        # 3d <doflush+0x3d>
mov    $0x1,%esi
mov    $0x0,%edi
movb   $0x6,(%rax)
callq  4f <doflush+0x4f>
mov    $0x1,%edi
movl   $0x1,0x0(%rip)        # 5e <doflush+0x5e>
movl   $0x1,0x0(%rip)        # 68 <doflush+0x68>
callq  6d <doflush+0x6d>
mov    $0x6,%edx
mov    $0xfd,%esi
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   85 <doflush+0x85>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doflush (void)
{
  { { *netoring.supply = 255; ring_supplied(&netoring, 1); }; { *netoring.supply = 253; ring_supplied(&netoring, 1); }; };
  { *netoring.supply = 6; ring_supplied(&netoring, 1); };
  flushline = 1;
  flushout = 1;
  ttyflush (1);
  printoption ("SENT", 253, 6);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 4
16 4
17 7
18 5
19 6
20 7
21 8
22 8
23 8
24 9
25 8
26 8
<<<sep_out_sample>>>
push   %r14
movl   $0x0,(%rsi)
mov    %rdx,%r14
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
xor    %ebp,%ebp
cmp    $0x1,%ebp
push   %rbx
mov    %rdi,%rbx
movzbl (%rbx),%r12d
movsbl %r12b,%edi
jne    17f <split+0x4f>
nopw   %cs:0x0(%rax,%rax,1)
callq  165 <split+0x35>
test   %eax,%eax
je     1b0 <split+0x80>
movb   $0x0,(%rbx)
xor    %ebp,%ebp
add    $0x1,%rbx
movzbl (%rbx),%r12d
cmp    $0x1,%ebp
movsbl %r12b,%edi
je     160 <split+0x30>
callq  184 <split+0x54>
xor    %ebp,%ebp
test   %eax,%eax
jne    16e <split+0x3e>
test   %r12b,%r12b
js     16e <split+0x3e>
mov    0x0(%r13),%eax
mov    $0x1,%bpl
movslq %eax,%rdx
add    $0x1,%eax
mov    %rbx,(%r14,%rdx,8)
mov    %eax,0x0(%r13)
jmp    16e <split+0x3e>
nopw   %cs:0x0(%rax,%rax,1)
test   %r12b,%r12b
jne    16e <split+0x3e>
movb   $0x0,(%rbx)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
split (char *s, int *argc, char *argv[])
{
    int done = 0;
    enum state_t state = SKIPPING_SPACES;
    *argc = 0;
    for (; done == 0; ++s) {
  switch (state) {
  case SKIPPING_SPACES:
   if (isspace (*s)) {
   }
   else if (isascii (*s)) {
    argv[*argc] = s;
    (*argc)++;
    state = ARGUMENT;
   }
   else if (*s == '\0') {
    done = 1;
   }
   break;
  case ARGUMENT:
   if (isspace (*s)) {
    *s = '\0';
    state = SKIPPING_SPACES;
   }
   else if (*s == '\0') {
    *s = '\0';
    done = 1;
   }
  }
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 2
7 2
8 4
9 7
10 2
11 2
12 21
13 21
14 7
15 7
16 21
17 21
18 21
19 22
20 23
21 6
22 21
23 7
24 21
25 7
26 9
27 9
28 9
29 9
30 11
31 11
32 12
33 14
34 12
35 13
36 12
37 13
38 13
39 13
40 25
41 25
42 26
43 32
44 32
45 32
46 32
47 32
48 32
49 32
50 32
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  70 <compute_wvariance>
sqrtsd %xmm0,%xmm1
ucomisd %xmm1,%xmm1
jp     46c <gsl_stats_wsd_with_fixed_mean+0x1c>
movapd %xmm1,%xmm0
add    $0x8,%rsp
retq   
callq  471 <gsl_stats_wsd_with_fixed_mean+0x21>
movapd %xmm0,%xmm1
jmp    463 <gsl_stats_wsd_with_fixed_mean+0x13>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_wsd_with_fixed_mean (const double w[], const size_t wstride, const double data[], const size_t stride, const size_t n, const double wmean)
{
  const double wvariance = compute_wvariance (w, wstride, data, stride, n, wmean);
  const double wsd = sqrt (wvariance);
  return wsd;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 6
7 6
8 6
9 4
10 4
11 4
12 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
callq  24 <rec_field_set_name+0x14>
mov    %rbp,%rdi
callq  2c <rec_field_set_name+0x1c>
test   %rax,%rax
mov    %rax,(%rbx)
setne  %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rec_field_set_name (rec_field_t field, const char *name)
{
  free (field->name);
  field->name = strdup (name);
  return (field->name != ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 4
9 4
10 5
11 4
12 5
13 6
14 6
15 6
16 6
17 6
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
callq  270 <skip_whitespace>
mov    0x8(%rbp),%rdi
callq  3be <probe_keyword+0x1e>
cmpb   $0x0,(%r12)
je     409 <probe_keyword+0x69>
mov    %rax,%r13
movsbl 0x1(%r12),%eax
cmp    0x0(%rbp),%eax
jne    430 <probe_keyword+0x90>
xor    %ebx,%ebx
jmp    3eb <probe_keyword+0x4b>
nopw   0x0(%rax,%rax,1)
movsbl 0x1(%r12,%rbx,1),%eax
cmp    0x0(%rbp),%eax
jne    430 <probe_keyword+0x90>
mov    0x8(%rbp),%rsi
mov    %rbp,%rdi
callq  3f7 <probe_keyword+0x57>
test   %al,%al
jne    44d <probe_keyword+0xad>
movzbl (%r12),%edx
add    $0x1,%rbx
cmp    %rbx,%rdx
ja     3e0 <probe_keyword+0x40>
lea    0x1(%r12),%rax
mov    %rax,0x28(%rbp)
movzbl (%r12),%eax
mov    %rax,0x30(%rbp)
mov    $0x1,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rbp),%rdi
lea    -0x1(%r13),%rsi
callq  43d <probe_keyword+0x9d>
mov    0x8(%rbp),%rsi
mov    %rbp,%rdi
callq  449 <probe_keyword+0xa9>
test   %al,%al
je     420 <probe_keyword+0x80>
mov    %rbp,%rdi
callq  260 <eof_too_soon>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
probe_keyword (struct grok *g, struct tinysym const *kw)
{
  off_t was;
  _Bool rv = 1;
  ;
  skip_whitespace (g);
  was = fro_tello (g->from);
  for (size_t i = 0; i < kw->len; i++)
    {
      if (! (rv = (((char const *)(kw)->bytes)[i] == g->c)))
        break;
      do if (fro_try_getbyte (&(g->c), (g->from))) { eof_too_soon (g); } while (0);
    }
  if (rv)
    {
      ((g)->xrep).string = ((char const *)(kw)->bytes);
      ((g)->xrep).size = kw->len;
    }
  else
    {
      fro_move (g->from, was - 1);
      do if (fro_try_getbyte (&(g->c), (g->from))) { eof_too_soon (g); } while (0);
    }
  ;
  return rv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 7
10 7
11 8
12 8
13 8
14 10
15 10
16 10
17 8
18 8
19 8
20 10
21 10
22 10
23 12
24 12
25 12
26 12
27 12
28 8
29 8
30 8
31 8
32 16
33 16
34 17
35 17
36 17
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 21
45 21
46 21
47 22
48 22
49 22
50 22
51 22
52 12
53 12
54 12
<<<sep_out_sample>>>
mov    (%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <font_entry_hash_2+0x2e>
nopl   0x0(%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <font_entry_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
font_entry_hash_2 (struct font_entry * entry)
{
  do { unsigned long result = 0; do { unsigned char const *kk = (unsigned char const *) ((entry->key)) - 1; while (*++kk) (result) += (*kk << (kk[1] & 0x7)); } while (0); return result; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    0xc(%rdi),%eax
mov    %eax,0x14(%rdi)
mov    0x10(%rdi),%eax
mov    %eax,0x18(%rdi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
coproc_fdsave (cp)
     struct coproc *cp;
{
  cp->c_rsave = cp->c_rfd;
  cp->c_wsave = cp->c_wfd;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     30da <block_level+0x2a>
xor    %eax,%eax
cmpq   $0x0,0x8(%rdi)
je     30ca <block_level+0x1a>
jmp    30d8 <block_level+0x28>
add    $0x1,%eax
cmpq   $0x0,0x8(%rdi)
jne    30d8 <block_level+0x28>
mov    0x20(%rdi),%rdi
test   %rdi,%rdi
jne    30c0 <block_level+0x10>
repz retq 
nopl   (%rax)
repz retq 
sub    $0x8,%rsp
mov    $0x8f8,%esi
mov    $0x0,%edi
callq  3e0 <my_assert.constprop.18>
nopl   (%rax)
<<<sep_in_sample>>>
block_level(BLOCK *b)
{ int level = -1;
      for (b = b; b != ((void *)0); b = b->surr)
      { level++;
         if (b->proc != ((void *)0)) break;
      }
      ((void)((level >= 0) || (my_assert("level >= 0", "marst.c", 2296), 1)));
      return level;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 4
8 5
9 5
10 3
11 3
12 3
13 3
14 3
15 9
16 2
17 7
18 7
19 7
20 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  11c9 <TranscribeOpSymbol+0x9>
sub    $0x40,%eax
cmp    $0x4,%eax
ja     1230 <TranscribeOpSymbol+0x70>
jmpq   *0x0(,%rax,8)
nopl   0x0(%rax,%rax,1)
mov    $0x2f,%eax
mov    %ax,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movl   $0x776f70,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x2b,%esi
mov    %si,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x2d,%ecx
mov    %cx,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x2a,%edx
mov    %dx,(%rbx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%edi
mov    %rbx,%rsi
xor    %eax,%eax
callq  123f <TranscribeOpSymbol+0x7f>
xor    %edi,%edi
callq  1246 <TranscribeOpSymbol+0x86>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
TranscribeOpSymbol (PSTR szOp)
{
  switch (GetSBMLKeywordCode (szOp)) {
  case 64:
    sprintf (szOp, "%s", "+");
    break;
  case 65:
    sprintf (szOp, "%s", "-");
    break;
  case 66:
    sprintf (szOp, "%s", "*");
    break;
  case 67:
    sprintf (szOp, "%s", "/");
    break;
  case 68:
    sprintf (szOp, "%s", "pow");
    break;
  default:
    printf ("***Error: unknown mathXML operation '%s' - exiting...\n\n", szOp);
    exit (0);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 14
10 14
11 23
12 23
13 23
14 17
15 23
16 23
17 23
18 5
19 5
20 23
21 23
22 23
23 8
24 8
25 23
26 23
27 23
28 11
29 11
30 23
31 23
32 23
33 20
34 20
35 20
36 20
37 21
38 21
39 21
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_root_fsolver_name (const gsl_root_fsolver * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # a96 <yyset_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_debug (int bdebug )
{
        yy_flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rcx,%r8
mov    %rdx,%rbx
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
callq  47 <gsasl_base64_from+0x17>
test   %al,%al
mov    $0x8,%esi
jne    58 <gsasl_base64_from+0x28>
mov    %esi,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
cmpq   $0x1,(%rbx)
pop    %rbx
sbb    %esi,%esi
and    $0x7,%esi
mov    %esi,%eax
retq   
<<<sep_in_sample>>>
gsasl_base64_from (const char *in, size_t inlen, char **out, size_t * outlen)
{
  int ok = base64_decode_alloc_ctx (((void *)0), in, inlen, out, outlen);
  if (!ok)
    return GSASL_BASE64_ERROR;
  if (*out == ((void *)0))
    return GSASL_MALLOC_ERROR;
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 4
12 9
13 9
14 9
15 9
16 7
17 9
18 7
19 7
20 9
21 9
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x10(%rdi),%rcx
mov    0x8(%rdi),%rdx
test   %r8,%r8
mov    (%rcx),%rax
je     c56 <gsl_vector_ulong_max+0x36>
lea    0x0(,%rdx,8),%rdi
xor    %edx,%edx
nopl   (%rax)
mov    (%rcx),%rsi
cmp    %rsi,%rax
cmovb  %rsi,%rax
add    $0x1,%rdx
add    %rdi,%rcx
cmp    %r8,%rdx
jne    c40 <gsl_vector_ulong_max+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ulong_max (const gsl_vector_ulong * v)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  unsigned long max = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x > max)
        max = x;
    }
  return max;
}
<<<sep_in_sample>>>
1 3
2 5
3 4
4 7
5 5
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 7
14 7
15 7
16 7
17 14
18 14
<<<sep_out_sample>>>
mov    0x110(%rdi),%rax
mov    $0x80,%esi
add    0x38(%rax),%rdx
lea    0x34(%rdx),%rdi
test   $0x1,%dil
jne    3c0 <CDB___db_unmap_xid+0x60>
test   $0x2,%dil
jne    3d8 <CDB___db_unmap_xid+0x78>
test   $0x4,%dil
jne    3f0 <CDB___db_unmap_xid+0x90>
mov    %esi,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%sil
rep stos %rax,%es:(%rdi)
je     3a0 <CDB___db_unmap_xid+0x40>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%sil
je     3b0 <CDB___db_unmap_xid+0x50>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%esi
je     3b8 <CDB___db_unmap_xid+0x58>
movb   $0x0,(%rdi)
repz retq 
nopw   0x0(%rax,%rax,1)
lea    0x35(%rdx),%rdi
movb   $0x0,0x34(%rdx)
mov    $0x7f,%sil
test   $0x2,%dil
je     380 <CDB___db_unmap_xid+0x20>
nopl   0x0(%rax)
xor    %edx,%edx
add    $0x2,%rdi
sub    $0x2,%esi
mov    %dx,-0x2(%rdi)
test   $0x4,%dil
je     386 <CDB___db_unmap_xid+0x26>
nopl   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%esi
add    $0x4,%rdi
jmp    386 <CDB___db_unmap_xid+0x26>
<<<sep_in_sample>>>
CDB___db_unmap_xid(env, xid, off)
 DB_ENV *env;
 XID *xid;
 size_t off;
{ if(xid){}
 TXN_DETAIL *td;
 (xid) = (((void *)0));
 td = (TXN_DETAIL *)((void *)((u_int8_t *)((&((DB_TXNMGR *)env->tx_handle)->reginfo)->addr) + off));
 memset(td->xid, 0, sizeof(td->xid));
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  25 <gsl_stats_long_double_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  38 <gsl_stats_long_double_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  55 <gsl_stats_long_double_ttest+0x55>
test   %rbp,%rbp
js     b8 <gsl_stats_long_double_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # 67 <gsl_stats_long_double_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     d8 <gsl_stats_long_double_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     f2 <gsl_stats_long_double_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    5f <gsl_stats_long_double_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    79 <gsl_stats_long_double_ttest+0x79>
test   %rbp,%rbp
js     12c <gsl_stats_long_double_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     143 <gsl_stats_long_double_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  123 <gsl_stats_long_double_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   97 <gsl_stats_long_double_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    fc <gsl_stats_long_double_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    10e <gsl_stats_long_double_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_ttest (const long double data1[],
                           const size_t stride1, const size_t n1,
                           const long double data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_long_double_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_long_double_mean (data2, stride2, n2);
  const double pv = gsl_stats_long_double_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
xor    %edx,%edx
cmp    %rax,0x8(%rdi)
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  379 <java_reserved_word+0x9>
test   %rax,%rax
je     398 <java_reserved_word+0x28>
mov    0x8(%rax),%edx
xor    %eax,%eax
cmp    $0x7d0,%edx
cmovg  %edx,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
java_reserved_word(const char *str, int len)
{
 struct keyword *keyword;
 keyword = java_lookup(str, len);
 return (keyword && ((keyword->token) >= 2001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 5
13 6
14 6
15 6
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
xor    %edx,%edx
div    %rcx
cmp    %rsi,%rax
jb     8d <xnrealloc+0x1d>
imul   %rcx,%rsi
jmpq   8d <xnrealloc+0x1d>
push   %rax
callq  93 <xnrealloc+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 2
10 4
11 4
<<<sep_out_sample>>>
mov    $0xfffffff9,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_tray_osx (const char *psz_drive)
{
  return DRIVER_OP_NO_DRIVER;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
callq  b5e <nonaction+0xe>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  b6f <nonaction+0x1f>
test   %eax,%eax
jne    b90 <nonaction+0x40>
mov    %rbx,%rsi
mov    $0x0,%edi
callq  b80 <nonaction+0x30>
mov    $0x0,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    %rbx,%rdi
callq  b9d <nonaction+0x4d>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bae <nonaction+0x5e>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bbf <nonaction+0x6f>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bd0 <nonaction+0x80>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  be1 <nonaction+0x91>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bf2 <nonaction+0xa2>
test   %eax,%eax
je     b73 <nonaction+0x23>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  c07 <nonaction+0xb7>
test   %eax,%eax
je     b73 <nonaction+0x23>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nonaction(char *step)
{
  static char type[127 + 1];
  if (!linecmp(step, "set") || !linecmp(step, "infile") ||
      !linecmp(step, "input") || !linecmp(step, "length") ||
      !linecmp(step, "merge") || !linecmp(step, "by") ||
      !linecmp(step, "drop") || !linecmp(step, "keep") ||
      !linecmp(step, "title"))
    {
      linecpy(type, step);
      return type;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 10
13 10
14 10
15 11
16 14
17 14
18 14
19 5
20 5
21 5
22 4
23 4
24 5
25 5
26 5
27 5
28 5
29 6
30 6
31 6
32 5
33 5
34 6
35 6
36 6
37 6
38 6
39 7
40 7
41 7
42 6
43 6
44 7
45 7
46 7
47 7
48 7
49 8
50 8
51 8
52 7
53 7
54 13
55 14
56 14
57 14
<<<sep_out_sample>>>
movslq %edi,%rdi
mov    0x0(,%rdi,4),%eax
mov    0x0(,%rdi,4),%edx
mov    0x0(,%rdi,4),%esi
mov    0x0(,%rdi,4),%ecx
cmp    %edx,%eax
jge    50 <fixJoy+0x40>
cmp    %ecx,%esi
jg     70 <fixJoy+0x60>
sub    %eax,%esi
sub    %eax,%ecx
cvtsi2sd %esi,%xmm0
cvtsi2sd %ecx,%xmm1
divsd  %xmm1,%xmm0
subsd  0x0(%rip),%xmm0        # 4f <fixJoy+0x3f>
retq   
cmp    %ecx,%esi
jge    88 <fixJoy+0x78>
mov    %ecx,%eax
sub    %edx,%ecx
sub    %esi,%eax
cvtsi2sd %ecx,%xmm1
cvtsi2sd %eax,%xmm0
divsd  %xmm1,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
sub    %ecx,%esi
sub    %ecx,%edx
cvtsi2sd %esi,%xmm0
cvtsi2sd %edx,%xmm1
divsd  %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    %eax,%edx
sub    %ecx,%eax
sub    %esi,%edx
cvtsi2sd %eax,%xmm1
cvtsi2sd %edx,%xmm0
divsd  %xmm1,%xmm0
subsd  0x0(%rip),%xmm0        # a2 <fixJoy+0x92>
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fixJoy(int i)
{
  if (min[i] < max[i])
  {
    if (value[i] <= home[i])
      return (double) (value[i] - min[i]) / (double)(home[i] - min[i]) - 1.0;
    else
      return (double) (value[i] - home[i]) / (double)(max[i] - home[i]);
  }
  else
    if (value[i] >= home[i])
      return ((double)(min[i] - value[i]) / (double)(min[i] - home[i]) - 1.0);
    else
      return ((double)(home[i] - value[i]) / (double)(home[i] - max[i]));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 3
7 3
8 5
9 5
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 11
18 11
19 14
20 14
21 14
22 14
23 14
24 14
25 15
26 15
27 8
28 8
29 8
30 8
31 8
32 8
33 8
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 12
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x28,%edi
callq  29e <debpsf_create+0xe>
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movl   $0xffffffff,0x10(%rax)
movl   $0xffffffff,0x14(%rax)
movl   $0xffffffff,0x18(%rax)
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
debpsf_create(void)
{
 DEBPSF * debpsf;
 debpsf = malloc(sizeof(DEBPSF));
 debpsf->headM = ((void *)0);
 debpsf->topsfM = ((void *)0);
 debpsf->header_fdM = -1;
 debpsf->control_fdM = -1;
 debpsf->data_fdM = -1;
 return debpsf;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 6
6 7
7 8
8 9
9 11
10 11
11 11
<<<sep_out_sample>>>
mov    $0xfffffffe,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_tray_os2 (const char *psz_os2_drive)
{
  return DRIVER_OP_UNSUPPORTED;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpb   $0x0,0x0(%rip)        # 163 <compare_names+0x13>
jne    180 <compare_names+0x30>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   176 <compare_names+0x26>
nopw   %cs:0x0(%rax,%rax,1)
callq  b0 <compare_collated>
test   %eax,%eax
jne    192 <compare_names+0x42>
cmpb   $0x0,0x0(%rip)        # 190 <compare_names+0x40>
je     165 <compare_names+0x15>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
compare_names (char const *name1, char const *name2)
{
  if (locale_specific_sorting)
    {
      int diff = compare_collated (name1, name2);
      if (diff || ignore_file_name_case)
 return diff;
    }
  return strcmp (name1, name2);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 10
9 9
10 9
11 10
12 10
13 9
14 9
15 5
16 6
17 6
18 6
19 6
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # a7 <grecs_text_table+0x7>
movq   $0x0,0x0(%rip)        # b2 <grecs_text_table+0x12>
retq   
<<<sep_in_sample>>>
grecs_text_table()
{
 struct grecs_symtab *tmp = text_table;
 text_table = ((void *)0);
 return tmp;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
mov    (%rbx),%rsi
mov    %rbp,%rdi
callq  bd9 <rec_aggregate_std_p+0x19>
test   %eax,%eax
je     bf8 <rec_aggregate_std_p+0x38>
add    $0x10,%rbx
cmp    $0x0,%rbx
jne    bce <rec_aggregate_std_p+0xe>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
rec_aggregate_std_p (const char *name)
{
  _Bool found = 0;
  size_t i = 0;
  for (i = 0; i < 5; i++)
    {
      if (strcasecmp (name, std_aggregates[i].name) == 0)
        {
          found = 1;
          break;
        }
    }
  return found;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 7
8 7
9 7
10 7
11 7
12 5
13 5
14 14
15 3
16 14
17 14
18 14
19 14
20 14
21 9
22 14
23 14
24 14
<<<sep_out_sample>>>
push   %rbx
cmpq   $0x0,0x78(%rdi)
mov    %rdi,%rbx
je     10f4 <window_line_of_point+0x74>
mov    0x38(%rbx),%rax
mov    0x88(%rbx),%rcx
test   %rax,%rax
js     10a0 <window_line_of_point+0x20>
cmp    %rcx,%rax
jl     10e0 <window_line_of_point+0x60>
xor    %eax,%eax
xor    %edx,%edx
cmp    %rax,%rcx
jle    10d3 <window_line_of_point+0x53>
mov    0x78(%rbx),%rsi
movslq %edx,%rax
mov    0x40(%rbx),%rdi
cmp    %rdi,(%rsi,%rax,8)
jg     10d3 <window_line_of_point+0x53>
add    $0x1,%rax
jmp    10cb <window_line_of_point+0x4b>
add    $0x1,%rax
cmp    %rdi,-0x8(%rsi,%rax,8)
jg     10d3 <window_line_of_point+0x53>
add    $0x1,%edx
cmp    %rax,%rcx
jg     10c0 <window_line_of_point+0x40>
lea    -0x1(%rdx),%ecx
xor    %eax,%eax
test   %edx,%edx
pop    %rbx
cmovg  %ecx,%eax
retq   
nop
mov    0x78(%rbx),%rdx
mov    0x40(%rbx),%rsi
cmp    %rsi,(%rdx,%rax,8)
jg     10a0 <window_line_of_point+0x20>
mov    %eax,%edx
cltq   
jmp    10a4 <window_line_of_point+0x24>
callq  10f9 <window_line_of_point+0x79>
jmp    108b <window_line_of_point+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
window_line_of_point (WINDOW *window)
{
  register int i, start = 0;
  if (!window->line_starts)
    calculate_line_starts (window);
  if (window->pagetop > -1 && window->pagetop < window->line_count
      && window->line_starts[window->pagetop] <= window->point)
    start = window->pagetop;
  for (i = start; i < window->line_count; i++)
    {
      if (window->line_starts[i] > window->point)
        break;
    }
  if (i > 0)
    return i - 1;
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 3
13 9
14 9
15 11
16 11
17 11
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 15
29 15
30 15
31 18
32 15
33 18
34 18
35 7
36 7
37 7
38 7
39 8
40 8
41 8
42 5
43 5
44 5
<<<sep_out_sample>>>
jmpq   1565 <afmfree+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmfree (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
push   %r15
mov    %esi,%r15d
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x2018,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x2008(%rsp)
xor    %eax,%eax
test   %esi,%esi
jle    26c <taru_read_for_crc_checksum+0xcc>
lea    0x1(%rsp),%r12
mov    %edi,%ebp
mov    %rdx,%r13
xor    %ebx,%ebx
nopl   0x0(%rax,%rax,1)
mov    $0x2000,%edx
mov    %rsp,%rsi
mov    %ebp,%edi
callq  1ef <taru_read_for_crc_checksum+0x4f>
test   %eax,%eax
mov    %rax,%r14
js     248 <taru_read_for_crc_checksum+0xa8>
je     220 <taru_read_for_crc_checksum+0x80>
test   %eax,%eax
jle    218 <taru_read_for_crc_checksum+0x78>
lea    -0x1(%rax),%edx
mov    %rsp,%rcx
add    %r12,%rdx
nopl   (%rax)
movzbl (%rcx),%r8d
add    $0x1,%rcx
add    %r8,%rbx
cmp    %rdx,%rcx
jne    208 <taru_read_for_crc_checksum+0x68>
sub    %r14d,%r15d
test   %r15d,%r15d
jg     1e0 <taru_read_for_crc_checksum+0x40>
mov    0x2008(%rsp),%rsi
xor    %fs:0x28,%rsi
mov    %rbx,%rax
jne    272 <taru_read_for_crc_checksum+0xd2>
add    $0x2018,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x0(%rip),%rdi        # 24f <taru_read_for_crc_checksum+0xaf>
xor    %eax,%eax
mov    %r13,%rdx
mov    $0x0,%esi
sub    %r14d,%r15d
callq  261 <taru_read_for_crc_checksum+0xc1>
test   %r15d,%r15d
jg     1e0 <taru_read_for_crc_checksum+0x40>
jmp    220 <taru_read_for_crc_checksum+0x80>
xor    %ebx,%ebx
xchg   %ax,%ax
jmp    220 <taru_read_for_crc_checksum+0x80>
callq  277 <taru_read_for_crc_checksum+0xd7>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taru_read_for_crc_checksum (int in_file_des, int file_size, char * file_name)
{
   unsigned long crc;
   char buf[8192];
   int bytes_left;
   int bytes_read;
   int i;
   crc = 0;
   for (bytes_left = file_size; bytes_left > 0; bytes_left -= bytes_read)
   {
    bytes_read = uxfio_sfread(in_file_des, buf, 8192);
    if (bytes_read < 0)
     fprintf (stderr, "cannot read checksum for %s", file_name);
    if (bytes_read == 0)
     break;
    for (i = 0; i < bytes_read; ++i)
    crc += buf[i] & 0xff;
   }
   return crc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 9
13 9
14 9
15 9
16 9
17 8
18 8
19 11
20 11
21 11
22 11
23 12
24 11
25 12
26 14
27 16
28 16
29 16
30 16
31 16
32 16
33 17
34 17
35 17
36 16
37 16
38 9
39 9
40 9
41 20
42 20
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 20
51 20
52 20
53 13
54 13
55 13
56 13
57 9
58 13
59 9
60 9
61 9
62 8
63 8
64 8
65 20
66 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  1c0 <find_boolean_var>
test   %eax,%eax
js     21f0 <rl_variable_value+0x30>
cltq   
lea    (%rax,%rax,2),%rax
pop    %rbx
mov    0x0(,%rax,8),%rdx
mov    $0x0,%eax
mov    (%rdx),%edx
test   %edx,%edx
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
nop
mov    %rbx,%rdi
callq  210 <find_string_var>
test   %eax,%eax
js     2210 <rl_variable_value+0x50>
cltq   
lea    (%rax,%rax,2),%rax
pop    %rbx
mov    0x0(,%rax,8),%rdi
jmpq   1c40 <_rl_get_string_variable_value>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_variable_value (name)
     const char *name;
{
  register int i;
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");
  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 7
8 12
9 7
10 7
11 7
12 7
13 7
14 7
15 12
16 12
17 8
18 8
19 9
20 9
21 10
22 10
23 12
24 10
25 10
26 11
27 12
28 12
29 12
<<<sep_out_sample>>>
push   %r13
mov    $0x16,%eax
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     5cb <mu_list_append+0x6b>
mov    0x10(%rdi),%r13
mov    %rsi,%r12
mov    $0x18,%edi
mov    $0x1,%esi
callq  58d <mu_list_append+0x2d>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     5cb <mu_list_append+0x6b>
mov    0x20(%rbx),%rdi
mov    %r12,0x0(%rbp)
callq  5a7 <mu_list_append+0x47>
mov    0x10(%rbx),%rax
mov    %rbx,0x8(%rbp)
mov    0x20(%rbx),%rdi
mov    %rax,0x10(%rbp)
mov    %rbp,0x8(%r13)
addq   $0x1,0x18(%rbx)
mov    %rbp,0x10(%rbx)
callq  5c9 <mu_list_append+0x69>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_list_append (mu_list_t list, void *item)
{
  struct list_data *ldata;
  struct list_data *last;
  if (list == ((void *)0))
    return 22;
  last = list->head.prev;
  ldata = calloc (sizeof (*ldata), 1);
  if (ldata == ((void *)0))
    return 12;
  ldata->item = item;
  mu_monitor_wrlock (list->monitor);
  ldata->next = &list->head;
  ldata->prev = list->head.prev;
  last->next = ldata;
  list->head.prev = ldata;
  list->count++;
  mu_monitor_unlock (list->monitor);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 7
11 7
12 8
13 8
14 8
15 8
16 10
17 9
18 9
19 12
20 11
21 12
22 14
23 13
24 18
25 14
26 15
27 17
28 16
29 18
30 19
31 20
32 20
33 20
34 20
35 20
36 20
37 20
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x4(%rax),%eax
mov    0x0(,%rax,4),%eax
cmp    %eax,0xc(%rdi)
setae  %al
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
finished_p (void *owner)
{
  struct assoc_iterator *itr = owner;
  return itr->index >= hash_size[itr->assoc->hash_num];
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     800 <node_free+0x60>
subl   $0x1,0x4(%rdi)
jne    800 <node_free+0x60>
mov    (%rdi),%eax
cmp    $0x1,%eax
je     7e7 <node_free+0x47>
jb     800 <node_free+0x60>
cmp    $0x2,%eax
je     810 <node_free+0x70>
cmp    $0x6,%eax
jne    7f0 <node_free+0x50>
mov    0x20(%rdi),%eax
xor    %ebp,%ebp
test   %eax,%eax
je     7e7 <node_free+0x47>
mov    0x18(%rbx),%rax
mov    %ebp,%edx
add    $0x1,%ebp
mov    (%rax,%rdx,8),%rdi
callq  7e2 <node_free+0x42>
cmp    0x20(%rbx),%ebp
jb     7d0 <node_free+0x30>
mov    0x18(%rbx),%rdi
callq  7f0 <node_free+0x50>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   7fe <node_free+0x5e>
xchg   %ax,%ax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    0x18(%rdi),%rdi
callq  819 <node_free+0x79>
mov    0x48(%rbx),%rdi
callq  822 <node_free+0x82>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   830 <set_var.isra.3>
<<<sep_in_sample>>>
node_free (node)
     Node *node;
{
  unsigned int i;
  if (node == ((void *)0))
    return;
  if (--node->refcount > 0)
    return;
  switch (node->type)
    {
    case nVOID:
      return;
      break;
    case nSTRING:
      xfree (node->u.str.data);
      break;
    case nREGEXP:
      free (node->u.re.data);
      xfree (node->u.re.compiled.fastmap);
      break;
    case nINTEGER:
    case nREAL:
    case nSYMBOL:
      break;
    case nARRAY:
      for (i = 0; i < node->u.array.len; i++)
 node_free (node->u.array.array[i]);
      xfree (node->u.array.array);
      break;
    }
  xfree (node);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 5
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 26
18 26
19 26
20 26
21 27
22 27
23 26
24 27
25 27
26 26
27 26
28 15
29 15
30 32
31 31
32 32
33 32
34 31
35 31
36 32
37 32
38 32
39 32
40 32
41 18
42 18
43 19
44 19
45 32
46 31
47 32
48 32
49 31
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  a0c <gsl_sf_bessel_I1_scaled+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    a20 <gsl_sf_bessel_I1_scaled+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xfc,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a36 <gsl_sf_bessel_I1_scaled+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_I1_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_I1_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_I1_scaled_e(x, &result)", "bessel_I1.c", 252, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
test   %rbp,%rbp
mov    (%r8),%rdi
je     1602 <gsl_matrix_long_max_index+0x72>
shl    $0x3,%r12
xor    %r10d,%r10d
xor    %r11d,%r11d
xor    %ebx,%ebx
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     15eb <gsl_matrix_long_max_index+0x5b>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%r8,%rax,8),%rcx
cmp    %rdi,%rcx
jle    15e2 <gsl_matrix_long_max_index+0x52>
mov    %rax,%r11
mov    %r10,%rbx
mov    %rcx,%rdi
add    $0x1,%rax
cmp    %r9,%rax
jne    15d0 <gsl_matrix_long_max_index+0x40>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
jne    15c0 <gsl_matrix_long_max_index+0x30>
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_max_index (const gsl_matrix_long * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  long max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          long x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 6
6 4
7 5
8 9
9 6
10 9
11 9
12 9
13 7
14 7
15 7
16 11
17 11
18 11
19 11
20 13
21 14
22 14
23 14
24 14
25 14
26 11
27 11
28 11
29 9
30 9
31 9
32 9
33 22
34 23
35 24
36 24
37 24
38 24
39 7
40 7
41 22
42 23
43 24
44 24
45 24
46 24
47 24
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x20,%rsp
mov    %r8,0x18(%rsp)
callq  31bb <mbox_header_fill+0x1b>
mov    %rax,%rdi
callq  31c3 <mbox_header_fill+0x23>
mov    0x10(%rax),%rdx
lea    0x48(%rax),%rdi
mov    0x18(%rsp),%r8
mov    %r12,%rcx
mov    %rbx,%rsi
xor    %r9d,%r9d
mov    %rdx,0x8(%rsp)
mov    0x8(%rax),%rax
mov    %rbp,%rdx
mov    %rax,(%rsp)
callq  2f50 <mbox_readstream.isra.1>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
mbox_header_fill (mu_header_t header, char *buffer, size_t len,
    mu_off_t off, size_t *pnread)
{
  mu_message_t msg = mu_header_get_owner (header);
  mbox_message_t mum = mu_message_get_owner (msg);
  return mbox_readstream (mum, buffer, len, off, pnread, 0,
     mum->header_from_end, mum->body);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 487 <nettle_sha384_init+0x7>
movq   $0x0,0x48(%rdi)
movq   $0x0,0x40(%rdi)
movl   $0x0,0xd0(%rdi)
mov    %rax,(%rdi)
mov    0x0(%rip),%rax        # 4ab <nettle_sha384_init+0x2b>
mov    %rax,0x8(%rdi)
mov    0x0(%rip),%rax        # 4b6 <nettle_sha384_init+0x36>
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 4c1 <nettle_sha384_init+0x41>
mov    %rax,0x18(%rdi)
mov    0x0(%rip),%rax        # 4cc <nettle_sha384_init+0x4c>
mov    %rax,0x20(%rdi)
mov    0x0(%rip),%rax        # 4d7 <nettle_sha384_init+0x57>
mov    %rax,0x28(%rdi)
mov    0x0(%rip),%rax        # 4e2 <nettle_sha384_init+0x62>
mov    %rax,0x30(%rdi)
mov    0x0(%rip),%rax        # 4ed <nettle_sha384_init+0x6d>
mov    %rax,0x38(%rdi)
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_sha384_init(struct sha512_ctx *ctx)
{
  static const uint64_t H0[8] =
  {
    0xCBBB9D5DC1059ED8ULL, 0x629A292A367CD507ULL,
    0x9159015A3070DD17ULL, 0x152FECD8F70E5939ULL,
    0x67332667FFC00B31ULL, 0x8EB44A8768581511ULL,
    0xDB0C2E0D64F98FA7ULL, 0x47B5481DBEFA4FA4ULL,
  };
  memcpy(ctx->state, H0, sizeof(H0));
  ctx->count_low = ctx->count_high = 0;
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 10
2 11
3 11
4 12
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 12
21 12
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # a06 <maybe_emit_oob_warning+0x6>
test   %eax,%eax
je     a10 <maybe_emit_oob_warning+0x10>
repz retq 
nopl   0x0(%rax)
jmpq   0 <maybe_emit_oob_warning.part.3>
<<<sep_in_sample>>>
maybe_emit_oob_warning (void)
{
  static bool warning_written = false;
  if (!warning_written)
    {
      fprintf (stderr, "%s: one or more out-of-bounds output values are approximated\n", progname);
      warning_written = true;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
mov    $0x16,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
test   %rdi,%rdi
je     160 <mu_nntp_parse_list_distrib_pats+0x20>
cmpb   $0x0,(%rdi)
jne    178 <mu_nntp_parse_list_distrib_pats+0x38>
add    $0x28,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
mov    %rsi,%r12
mov    $0x200,%edi
mov    $0x1,%esi
mov    %rdx,%r14
mov    %rcx,%r13
mov    $0xc,%bpl
callq  193 <mu_nntp_parse_list_distrib_pats+0x53>
test   %rax,%rax
mov    %rax,%r15
je     160 <mu_nntp_parse_list_distrib_pats+0x20>
mov    $0x1,%esi
mov    $0x200,%edi
callq  1aa <mu_nntp_parse_list_distrib_pats+0x6a>
test   %rax,%rax
mov    %rax,%r9
je     1f8 <mu_nntp_parse_list_distrib_pats+0xb8>
lea    0x18(%rsp),%rax
test   %r12,%r12
mov    %r9,%r8
mov    %r15,%rcx
mov    $0x0,%esi
mov    %rbx,%rdi
cmove  %rax,%r12
xor    %eax,%eax
mov    %r9,0x8(%rsp)
mov    %r12,%rdx
callq  1db <mu_nntp_parse_list_distrib_pats+0x9b>
test   %r14,%r14
mov    0x8(%rsp),%r9
je     205 <mu_nntp_parse_list_distrib_pats+0xc5>
mov    %r15,(%r14)
test   %r13,%r13
je     214 <mu_nntp_parse_list_distrib_pats+0xd4>
mov    %r9,0x0(%r13)
xor    %ebp,%ebp
jmpq   160 <mu_nntp_parse_list_distrib_pats+0x20>
mov    %r15,%rdi
callq  200 <mu_nntp_parse_list_distrib_pats+0xc0>
jmpq   160 <mu_nntp_parse_list_distrib_pats+0x20>
mov    %r15,%rdi
callq  20d <mu_nntp_parse_list_distrib_pats+0xcd>
mov    0x8(%rsp),%r9
jmp    1e8 <mu_nntp_parse_list_distrib_pats+0xa8>
mov    %r9,%rdi
xor    %ebp,%ebp
callq  21e <mu_nntp_parse_list_distrib_pats+0xde>
jmpq   160 <mu_nntp_parse_list_distrib_pats+0x20>
<<<sep_in_sample>>>
mu_nntp_parse_list_distrib_pats (const char *buffer, unsigned long *weight, char **wildmat, char **distrib)
{
  char *w;
  char *d;
  unsigned long dummy;
  if (buffer == ((void *)0) || *buffer == '\0')
    return 22;
  w = calloc(512, 1);
  if (w == ((void *)0))
    return 12;
  d = calloc(512, 1);
  if (d == ((void *)0))
    {
      free (w);
      return 12;
    }
  if (weight == ((void *)0))
    weight = &dummy;
  sscanf (buffer, "%ld:%511s:%511s", weight, w, d);
  if (wildmat == ((void *)0))
    free (w);
  else
    *wildmat = w;
  if (distrib == ((void *)0))
    free (d);
  else
    *distrib = d;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 29
15 29
16 29
17 29
18 29
19 29
20 29
21 29
22 29
23 29
24 29
25 8
26 8
27 8
28 8
29 10
30 8
31 9
32 8
33 9
34 11
35 11
36 11
37 12
38 11
39 12
40 18
41 18
42 19
43 19
44 19
45 19
46 18
47 19
48 19
49 19
50 19
51 20
52 20
53 20
54 23
55 24
56 24
57 27
58 28
59 28
60 14
61 14
62 15
63 21
64 21
65 21
66 21
67 25
68 28
69 25
70 25
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    %rdi,%rsi
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 383 <gpath_fid2path+0x13>
callq  388 <gpath_fid2path+0x18>
mov    0x0(%rip),%edx        # 38e <gpath_fid2path+0x1e>
test   %edx,%edx
jle    3d2 <gpath_fid2path+0x62>
test   %rax,%rax
mov    %rax,%rbx
jne    3a8 <gpath_fid2path+0x38>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
test   %rbp,%rbp
je     39a <gpath_fid2path+0x2a>
mov    0x0(%rip),%rdi        # 3b4 <gpath_fid2path+0x44>
callq  3b9 <gpath_fid2path+0x49>
cmpb   $0x6f,(%rax)
sete   %al
movzbl %al,%eax
add    $0x1,%eax
mov    %eax,0x0(%rbp)
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
mov    $0x0,%ecx
mov    $0xd9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3eb <gpath_fid2path+0x7b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gpath_fid2path(const char *fid, int *type)
{
 const char *path = dbop_get(dbop, fid);
 ((opened > 0) ? (void) (0) : __assert_fail ("opened > 0", "gpathop.c", 217, __PRETTY_FUNCTION__));
 if (path && type) {
  const char *flag = dbop_getflag(dbop);
  *type = (*flag == 'o') ? 2 : 1;
 }
 return path;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 10
15 10
16 10
17 10
18 10
19 10
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 7
29 10
30 10
31 10
32 10
33 10
34 4
35 4
36 4
37 4
38 4
39 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     ff0 <gsl_vector_complex_long_double_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  100f <gsl_vector_complex_long_double_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_complex_long_double_const_view_array (const long double * base, size_t n)
{
  _gsl_vector_complex_long_double_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
    v.data = (long double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%r8d
mov    %esi,%ebp
mov    $0x28,%edx
xor    %esi,%esi
mov    $0x28,%ecx
push   %rbx
mov    %rdi,%rbx
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %ebp,%esi
and    $0x7,%esi
or     $0xffffffd0,%esi
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
movb   $0xff,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
mov    %sil,(%rax)
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
_callr(jit_state_t *_jit, jit_int32_t r0)
{
    _rex(_jit, 0, 0, _NOREG, _NOREG, r0);
    *_jit->pc.uc++ = 0xff;
    *_jit->pc.uc++ = (0x03<<6) | (0x02<<3) | ((r0) & 7);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 2
8 2
9 3
10 4
11 5
12 5
13 5
14 4
15 4
16 4
17 5
18 5
19 5
20 5
21 6
22 6
23 6
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  19 <string_compare_ci+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
string_compare_ci (void const *data1, void const *data2)
{
  char const *p1 = data1;
  char const *p2 = data2;
  return mbscasecmp (p1, p2) == 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    $0x1,%edi
push   %rbx
callq  191 <quote_system_arg+0x11>
mov    %rax,%rdi
mov    %rax,%r12
callq  19c <quote_system_arg+0x1c>
test   %rbp,%rbp
mov    %rax,%rbx
je     1b3 <quote_system_arg+0x33>
lea    0x1(%rax),%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  1b3 <quote_system_arg+0x33>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quote_system_arg (char *quoted, char const *arg)
{
  char *q = quotearg_style (shell_quoting_style, arg);
  size_t len = strlen (q);
  if (quoted)
    memcpy (quoted, q, len + 1);
  return len;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 3
7 4
8 3
9 4
10 5
11 4
12 5
13 6
14 6
15 6
16 6
17 8
18 8
19 8
20 8
21 8
22 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
xor    %r8d,%r8d
movl   $0x1,(%rsp)
xor    %ecx,%ecx
callq  fb8 <rpl_getopt+0x18>
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
rpl_getopt (int argc, char *const *argv, const char *optstring)
{
  return rpl_getopt_internal (argc, (char **) argv, optstring,
                           (const struct rpl_option *) 0,
                           (int *) 0,
                           0, POSIXLY_CORRECT);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 7
8 7
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_get_ofd(XFORMAT * xux)
{
 ;
 return xux->ofdM;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm0
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_complex_mul_real (gsl_complex a, double x)
{
  gsl_complex z;
  do {(&z)->dat[0]=(x * ((a).dat[0])); (&z)->dat[1]=(x * ((a).dat[1]));} while(0);
  return z;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
<<<sep_out_sample>>>
xor    %r10d,%r10d
test   %edx,%edx
jle    80 <cblas_drot+0x80>
xor    %eax,%eax
test   %r8d,%r8d
jle    91 <cblas_drot+0x91>
test   %edi,%edi
jle    7d <cblas_drot+0x7d>
movsd  0x0(%rip),%xmm6        # 1e <cblas_drot+0x1e>
movslq %r10d,%r10
movslq %edx,%r9
cltq   
lea    (%rsi,%r10,8),%rdx
movslq %r8d,%rsi
xorpd  %xmm1,%xmm6
lea    (%rcx,%rax,8),%rax
shl    $0x3,%r9
shl    $0x3,%rsi
xor    %ecx,%ecx
nop
movsd  (%rdx),%xmm2
add    $0x1,%ecx
movsd  (%rax),%xmm4
movapd %xmm0,%xmm3
movapd %xmm1,%xmm5
mulsd  %xmm2,%xmm3
mulsd  %xmm4,%xmm5
mulsd  %xmm6,%xmm2
mulsd  %xmm0,%xmm4
addsd  %xmm5,%xmm3
addsd  %xmm4,%xmm2
movsd  %xmm3,(%rdx)
add    %r9,%rdx
movsd  %xmm2,(%rax)
add    %rsi,%rax
cmp    %edi,%ecx
jne    40 <cblas_drot+0x40>
repz retq 
nop
mov    $0x1,%r10b
xor    %eax,%eax
sub    %edi,%r10d
imul   %edx,%r10d
test   %r8d,%r8d
jg     12 <cblas_drot+0x12>
mov    $0x1,%al
sub    %edi,%eax
imul   %r8d,%eax
jmpq   12 <cblas_drot+0x12>
<<<sep_in_sample>>>
cblas_drot (const int N, double *X, const int incX, double *Y, const int incY,
            const double c, const double s)
{
{
  int i;
  int ix = ((incX) > 0 ? 0 : ((N) - 1) * (-(incX)));
  int iy = ((incY) > 0 ? 0 : ((N) - 1) * (-(incY)));
  for (i = 0; i < N; i++) {
    const double x = X[ix];
    const double y = Y[iy];
    X[ix] = c * x + s * y;
    Y[iy] = -s * x + c * y;
    ix += incX;
    iy += incY;
  }
}
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 7
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 8
23 10
24 11
25 11
26 11
27 11
28 12
29 12
30 11
31 12
32 11
33 11
34 12
35 12
36 8
37 8
38 8
39 8
40 6
41 7
42 6
43 6
44 7
45 7
46 7
47 7
48 7
49 7
<<<sep_out_sample>>>
mov    0x40(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_num_children (rec_sex_ast_node_t node)
{
  return node->num_children;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
test   %rax,%rax
je     90 <dep_hash_2+0x40>
sub    $0x1,%rax
movzbl 0x1(%rax),%edx
lea    0x1(%rax),%rdi
xor    %eax,%eax
test   %dl,%dl
je     9d <dep_hash_2+0x4d>
nopl   0x0(%rax,%rax,1)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    70 <dep_hash_2+0x20>
repz retq 
xchg   %ax,%ax
mov    0x10(%rdi),%rax
mov    (%rax),%rax
sub    $0x1,%rax
jmp    5d <dep_hash_2+0xd>
repz retq 
nop
<<<sep_in_sample>>>
dep_hash_2 (const void *key)
{
  const struct dep *d = key;
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((d)->name ? (d)->name : (d)->file->name))) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 5
22 5
23 4
24 4
25 4
26 4
27 4
28 4
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    0x0(%rip),%rdi        # 4ea <gen_insert_header+0xa>
test   %rdi,%rdi
je     508 <gen_insert_header+0x28>
callq  4f4 <gen_insert_header+0x14>
mov    %ebx,%esi
mov    0x0(%rip),%rdi        # 4fd <gen_insert_header+0x1d>
pop    %rbx
jmpq   a0 <sed>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 50f <gen_insert_header+0x2f>
mov    $0x0,%esi
callq  519 <gen_insert_header+0x39>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 523 <gen_insert_header+0x43>
je     530 <gen_insert_header+0x50>
mov    %ebx,%esi
mov    %rax,%rdi
pop    %rbx
jmpq   a0 <sed>
mov    0x0(%rip),%rsi        # 537 <gen_insert_header+0x57>
mov    $0x0,%edi
callq  541 <gen_insert_header+0x61>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gen_insert_header(int place)
{
 static FILE *ip;
 if (ip != ((void *)0)) {
  rewind(ip);
 } else {
  ip = fopen(insert_header, "r");
  if (ip == ((void *)0))
   die("cannot open include header file '%s'.", insert_header);
 }
 return sed(ip, place);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 11
8 11
9 12
10 11
11 11
12 7
13 7
14 7
15 8
16 7
17 8
18 11
19 11
20 12
21 11
22 9
23 9
24 9
25 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  4c0 <build_hashcmd>
mov    %rbx,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
get_hashcmd (self)
     SHELL_VAR *self;
{
  build_hashcmd (self);
  return (self);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  d67 <blocking_read+0x17>
cmp    $0xffffffffffffffff,%rax
mov    %rax,%rbx
je     d80 <blocking_read+0x30>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
callq  d85 <blocking_read+0x35>
cmpl   $0xb,(%rax)
jne    d70 <blocking_read+0x20>
xor    %eax,%eax
mov    $0x3,%esi
mov    %ebp,%edi
callq  d98 <blocking_read+0x48>
test   %eax,%eax
js     d70 <blocking_read+0x20>
test   $0x8,%ah
je     d70 <blocking_read+0x20>
and    $0xf7,%ah
mov    $0x4,%esi
mov    %ebp,%edi
mov    %eax,%edx
xor    %eax,%eax
callq  db4 <blocking_read+0x64>
cmp    $0xffffffff,%eax
je     d70 <blocking_read+0x20>
add    $0x8,%rsp
mov    %ebp,%edi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdx
pop    %r13
jmpq   dd0 <blocking_write>
<<<sep_in_sample>>>
blocking_read (int fd, void *buf, size_t count)
{
  size_t bytes = safe_read (fd, buf, count);
  if (bytes == ((size_t) -1) && (*__errno_location ()) == 11)
    {
      int flags = rpl_fcntl (fd, 3);
      if (0 <= flags && flags & 04000
   && rpl_fcntl (fd, 4, flags & ~04000) != -1)
 bytes = safe_read (fd, buf, count);
    }
  return bytes;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 12
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 4
22 4
23 4
24 6
25 6
26 6
27 6
28 7
29 7
30 7
31 7
32 8
33 8
34 8
35 8
36 8
37 8
38 8
39 8
40 12
41 9
42 9
43 12
44 12
45 12
46 9
47 12
48 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x28(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
term_styled_ostream_free (term_styled_ostream_t first_arg)
{
  const struct term_styled_ostream_implementation *vtable =
    ((struct term_styled_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->free (first_arg);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     de0 <gsl_block_complex_float_raw_fwrite+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    0x0(,%rcx,8),%r14
mov    %rsi,%rbx
jne    d8c <gsl_block_complex_float_raw_fwrite+0x3c>
jmp    dd0 <gsl_block_complex_float_raw_fwrite+0x80>
nopl   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     dd0 <gsl_block_complex_float_raw_fwrite+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x8,%esi
mov    %rbx,%rdi
callq  da1 <gsl_block_complex_float_raw_fwrite+0x51>
cmp    $0x1,%rax
je     d80 <gsl_block_complex_float_raw_fwrite+0x30>
mov    $0x5,%ecx
mov    $0x6e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  dc0 <gsl_block_complex_float_raw_fwrite+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x8,%esi
callq  ded <gsl_block_complex_float_raw_fwrite+0x9d>
cmp    %r12,%rax
je     dd0 <gsl_block_complex_float_raw_fwrite+0x80>
mov    $0x5,%ecx
mov    $0x60,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  e0b <gsl_block_complex_float_raw_fwrite+0xbb>
mov    $0x5,%eax
jmp    dc5 <gsl_block_complex_float_raw_fwrite+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_complex_float_raw_fwrite (FILE * stream, const float * data,
                                  const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fwrite (data, 2 * sizeof (float), n, stream);
      if (items != n)
        {
          do { gsl_error ("fwrite failed", "fwrite_source.c", 96, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fwrite (data + 2 * i * stride,
                                2 * sizeof (float),
                                1, stream);
          if (item != 1)
            {
              do { gsl_error ("fwrite failed", "fwrite_source.c", 110, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 20
28 20
29 22
30 22
31 22
32 22
33 22
34 22
35 27
36 27
37 27
38 27
39 27
40 27
41 27
42 27
43 27
44 27
45 27
46 26
47 27
48 27
49 27
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    %rdx,%r8
mov    %rdi,%rsi
lea    0x8(%rdi),%rdx
mov    0x18(%rax),%rdi
movsd  (%r8),%xmm0
callq  *0x10(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
secant_init (void * vstate, gsl_function_fdf * fdf, double * root)
{
  secant_state_t * state = (secant_state_t *) vstate;
  const double x = *root;
  (*((fdf)->fdf))(x,(fdf)->params,(&(state->f)),(&(state->df)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 7
10 7
11 7
12 7
<<<sep_out_sample>>>
mov    0x18(%rdi),%eax
and    $0x8,%eax
jne    50 <_option_is_short+0x30>
push   %rbx
movslq 0x8(%rdi),%rbx
lea    -0x1(%rbx),%edx
cmp    $0xfe,%edx
ja     4b <_option_is_short+0x2b>
callq  3d <_option_is_short+0x1d>
mov    (%rax),%rax
movzwl (%rax,%rbx,2),%eax
shr    $0xe,%ax
and    $0x1,%eax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (127 * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 2
5 7
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 4
14 10
15 10
16 10
17 4
18 4
19 4
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1680 <gsl_vector_long_div+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x66,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1675 <gsl_vector_long_div+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     16ba <gsl_vector_long_div+0x6a>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rcx
shl    $0x3,%r10
shl    $0x3,%r9
xor    %esi,%esi
nop
mov    (%rdi),%rax
add    $0x1,%rsi
cqto   
idivq  (%rcx)
add    %r9,%rcx
mov    %rax,(%rdi)
add    %r10,%rdi
cmp    %r8,%rsi
jne    16a0 <gsl_vector_long_div+0x50>
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_vector_long_div (gsl_vector_long * a, const gsl_vector_long * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 102, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] /= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 15
31 13
32 13
33 17
34 19
35 19
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
movapd %xmm2,%xmm1
sub    $0x18,%rsp
callq  11 <gsl_cdf_weibull_P+0x11>
movsd  0x0(%rip),%xmm1        # 19 <gsl_cdf_weibull_P+0x19>
xorpd  %xmm1,%xmm0
movapd %xmm1,(%rsp)
callq  27 <gsl_cdf_weibull_P+0x27>
movapd (%rsp),%xmm1
add    $0x18,%rsp
xorpd  %xmm1,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_weibull_P (const double x, const double a, const double b)
{
  double P = -expm1 (-pow(x/a, b));
  return P;
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 5
11 3
12 5
13 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x40,%edi
callq  1eeb <swicat_req_create+0xb>
mov    %rax,%rbx
callq  1ef3 <swicat_req_create+0x13>
mov    %rax,0x10(%rbx)
callq  1efc <swicat_req_create+0x1c>
mov    %rax,0x18(%rbx)
callq  1f05 <swicat_req_create+0x25>
movl   $0x0,(%rbx)
mov    %rax,0x20(%rbx)
movl   $0x0,0x4(%rbx)
movl   $0x0,0x8(%rbx)
callq  1f22 <swicat_req_create+0x42>
mov    %rax,0x28(%rbx)
callq  1f2b <swicat_req_create+0x4b>
movq   $0x0,0x38(%rbx)
mov    %rax,0x30(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
swicat_req_create(void)
{
 SWICAT_REQ * req;
 req = (SWICAT_REQ*)malloc(sizeof(SWICAT_REQ));
 req->failed_preM = strar_open();
 req->failed_coM = strar_open();
 req->passed_exM = strar_open();
 req->pre_resultM = 0;
 req->ex_resultM = 0;
 req->co_resultM = 0;
 req->ex_set_arrayM = vplob_open();
 req->pre_set_arrayM = vplob_open();
 req->slM = ((void *)0);
 return req;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 7
12 9
13 10
14 11
15 11
16 12
17 13
18 12
19 15
20 15
21 15
22 15
<<<sep_out_sample>>>
ucomisd %xmm0,%xmm1
movsd  0x0(%rip),%xmm3        # 3c <gsl_cdf_flat_Q+0xc>
ja     58 <gsl_cdf_flat_Q+0x28>
ucomisd %xmm2,%xmm0
xorpd  %xmm3,%xmm3
ja     58 <gsl_cdf_flat_Q+0x28>
movapd %xmm2,%xmm3
subsd  %xmm1,%xmm2
subsd  %xmm0,%xmm3
divsd  %xmm2,%xmm3
movapd %xmm3,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_flat_Q (const double x, const double a, const double b)
{
  double Q;
  if (x < a)
    {
      Q = 1;
    }
  else if (x > b)
    {
      Q = 0;
    }
  else
    {
      Q = (b-x)/(b-a);
    }
  return Q;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 8
5 10
6 8
7 14
8 14
9 14
10 14
11 17
12 17
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x18,%edi
sub    $0x8,%rsp
callq  aa6 <gl_linked_add_first+0x16>
lea    0x28(%rbx),%rdx
mov    %rbp,0x10(%rax)
mov    %rdx,0x8(%rax)
mov    0x28(%rbx),%rdx
mov    %rdx,(%rax)
mov    %rax,0x8(%rdx)
mov    %rax,0x28(%rbx)
addq   $0x1,0x40(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gl_linked_add_first (gl_list_t list, const void *elt)
{
  gl_list_node_t node = ((struct gl_list_node_impl *) xmalloc (sizeof (struct gl_list_node_impl)));
  node->value = elt;
  node->prev = &list->root;
  node->next = list->root.next;
  node->next->prev = node;
  list->root.next = node;
  list->count++;
  return node;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 5
9 4
10 5
11 6
12 6
13 7
14 8
15 9
16 11
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
cmp    %rdx,(%rsi)
mov    %rdi,%rax
jbe    3350 <gsl_matrix_short_row+0x40>
mov    0x10(%rsi),%rdi
movq   $0x1,0x8(%rax)
movl   $0x0,0x20(%rax)
lea    (%rdi,%rdi,1),%rcx
imul   %rdx,%rcx
mov    0x20(%rsi),%rdx
add    0x18(%rsi),%rcx
mov    0x8(%rsi),%rsi
mov    %rdx,0x18(%rax)
mov    %rsi,(%rax)
mov    %rcx,0x10(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1b,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  3372 <gsl_matrix_short_row+0x62>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_short_row (gsl_matrix_short * m, const size_t i)
{
  _gsl_vector_short_view view = {{0, 0, 0, 0, 0}};
  if (i >= m->size1)
    {
      do { gsl_error ("row index is out of range", "rowcol_source.c", 27, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_short v = {0, 0, 0, 0, 0};
    v.data = m->data + i * 1 * m->tda;
    v.size = m->size2;
    v.stride = 1;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 16
6 16
7 10
8 10
9 13
10 10
11 16
12 16
13 16
14 16
15 16
16 16
17 2
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 6
30 18
31 18
32 18
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     458 <history_filename+0x38>
callq  431 <history_filename+0x11>
lea    0x1(%rax),%rdi
callq  43a <history_filename+0x1a>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  445 <history_filename+0x25>
test   %rax,%rax
mov    %rax,%rdx
je     458 <history_filename+0x38>
pop    %rbx
pop    %rbp
mov    %rdx,%rax
pop    %r12
retq   
nopl   (%rax)
mov    $0x0,%edi
callq  462 <history_filename+0x42>
test   %rax,%rax
mov    %rax,%rbx
je     4b8 <history_filename+0x98>
mov    %rax,%rdi
callq  472 <history_filename+0x52>
lea    0xa(%rax),%edi
movslq %eax,%rbp
lea    0x1(%rbp),%r12
movslq %edi,%rdi
callq  484 <history_filename+0x64>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  48f <history_filename+0x6f>
movb   $0x2f,(%rax,%rbp,1)
mov    %rax,%rdx
lea    (%rax,%r12,1),%rax
movabs $0x79726f747369682e,%rcx
mov    %rcx,(%rax)
movb   $0x0,0x8(%rax)
mov    %rdx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x2,%r12d
mov    $0x1,%ebp
mov    $0xb,%edi
mov    $0x0,%ebx
jmp    47f <history_filename+0x5f>
nop
<<<sep_in_sample>>>
history_filename (filename)
     char *filename;
{
  char *return_val = filename ? strcpy (xmalloc (1 + strlen (filename)), (filename)) : (char *)((void *)0);
  if (!return_val)
    {
      char *home;
      int home_len;
      home = getenv ("HOME");
      if (!home)
 home = ".";
      home_len = strlen (home);
      return_val = xmalloc (2 + home_len + 8);
      strcpy (return_val, home);
      return_val[home_len] = '/';
      strcpy (return_val + home_len + 1, ".history");
    }
  return (return_val);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 4
15 5
16 19
17 19
18 19
19 19
20 19
21 19
22 9
23 9
24 10
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 13
34 14
35 14
36 14
37 15
38 14
39 16
40 16
41 16
42 16
43 19
44 19
45 19
46 19
47 19
48 19
49 10
50 10
51 10
52 11
53 11
54 11
<<<sep_out_sample>>>
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
jmpq   7e1 <grecs_symtab_create_default+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_symtab_create_default(size_t elsize)
{
 return grecs_symtab_create(elsize,
       ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  3e85 <swc_tee_to_file+0x15>
movsbq (%rbx),%rdx
mov    (%rax),%rax
testb  $0x8,0x1(%rax,%rdx,2)
je     3ef0 <swc_tee_to_file+0x80>
lea    0xc(%rsp),%rsi
mov    %rbx,%rdi
callq  3ea0 <swc_tee_to_file+0x30>
mov    %eax,%r12d
mov    0xc(%rsp),%eax
test   %eax,%eax
jne    3f10 <swc_tee_to_file+0xa0>
test   %r12d,%r12d
mov    %r12d,%ebx
js     3ee2 <swc_tee_to_file+0x72>
mov    %rbp,%rdi
callq  3ebb <swc_tee_to_file+0x4b>
mov    %rbp,%rsi
mov    %eax,%edx
mov    %r12d,%edi
callq  3ec8 <swc_tee_to_file+0x58>
mov    %rbp,%rdi
mov    %rax,%r13
callq  3ed3 <swc_tee_to_file+0x63>
cmp    %r13d,%eax
mov    %eax,%ebx
jne    3f10 <swc_tee_to_file+0xa0>
mov    %r12d,%edi
callq  3ee2 <swc_tee_to_file+0x72>
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    $0x1a4,%edx
mov    $0x242,%esi
mov    %rbx,%rdi
xor    %eax,%eax
callq  3f04 <swc_tee_to_file+0x94>
mov    %eax,%r12d
jmp    3eab <swc_tee_to_file+0x3b>
nopl   0x0(%rax)
add    $0x18,%rsp
mov    $0xffffffff,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swc_tee_to_file(char * filename, char * buf)
{
 int ret;
 int fd;
 int res;
 if (((*__ctype_b_loc ())[(int) (((int)(*filename)))] & (unsigned short int) _ISdigit)) {
  fd = swlib_atoi(filename, &res);
  if (res) return -1;
 } else {
  fd = open(filename, 02|0100|01000, 0644);
 }
 if (fd < 0) return fd;
 ret = uxfio_unix_safe_write(fd, buf, strlen(buf));
 if (ret != (int)strlen(buf)) return -1;
 close(fd);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 13
29 14
30 13
31 14
32 14
33 14
34 14
35 15
36 15
37 17
38 17
39 17
40 17
41 17
42 17
43 17
44 17
45 10
46 10
47 10
48 10
49 10
50 10
51 10
52 10
53 17
54 8
55 17
56 17
57 17
58 17
59 17
60 17
61 17
<<<sep_out_sample>>>
mov    %rsi,0x40(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_password_set (Gsasl * ctx,
        Gsasl_client_callback_password cb)
{
  ctx->cbc_password = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
push   %r13
mov    %edi,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %r13d,%edi
callq  26 <safe_write+0x26>
test   %rax,%rax
mov    %rax,%rbp
jns    50 <safe_write+0x50>
callq  33 <safe_write+0x33>
mov    (%rax),%ecx
cmp    $0x4,%ecx
je     18 <safe_write+0x18>
cmp    $0x16,%ecx
jne    50 <safe_write+0x50>
cmp    $0x7fffe000,%rbx
jbe    50 <safe_write+0x50>
mov    $0x7fffe000,%ebx
jmp    18 <safe_write+0x18>
nop
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
safe_write (int fd, void const *buf, size_t count)
{
  enum { BUGGY_READ_MAXIMUM = 2147483647 & ~8191 };
  for (;;)
    {
      ssize_t result = write (fd, buf, count);
      if (0 <= result)
        return result;
      else if ((((*__errno_location ())) == 4))
        continue;
      else if ((*__errno_location ()) == 22 && BUGGY_READ_MAXIMUM < count)
        count = BUGGY_READ_MAXIMUM;
      else
        return result;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 6
11 6
12 6
13 6
14 7
15 6
16 7
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 16
29 16
30 16
31 16
32 16
33 16
34 16
<<<sep_out_sample>>>
mov    $0x3a,%edx
jmpq   10ba <quotearg_colon_mem+0xa>
<<<sep_in_sample>>>
quotearg_colon_mem (char const *arg, size_t argsize)
{
  return quotearg_char_mem (arg, argsize, ':');
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  f9 <xcalloc+0x9>
test   %rax,%rax
je     100 <xcalloc+0x10>
pop    %rbx
retq   
mov    %rbx,%rdi
pop    %rbx
jmpq   30 <fixup_null_alloc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xcalloc (size_t n, size_t s)
{
  void *p;
  p = calloc (n, s);
  if (p == ((void *)0))
    p = fixup_null_alloc (n);
  return p;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 5
5 5
6 8
7 8
8 6
9 8
10 6
11 6
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%edx        # 1366 <getKey+0x6>
xor    %eax,%eax
test   %edx,%edx
jne    1378 <getKey+0x18>
jmpq   1371 <getKey+0x11>
nopl   0x0(%rax)
jmpq   137d <getKey+0x1d>
<<<sep_in_sample>>>
getKey()
{
  if(X_IS_RUNNING) return getKeyUnderX();
  else return getKeyUnderConsole();
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    0x30(%rdi),%rdi
callq  670 <free_db+0x10>
lea    0x30(%rbx),%rdi
callq  679 <free_db+0x19>
cmpq   $0x0,0x10(%rbx)
je     6c0 <free_db+0x60>
mov    0x18(%rbx),%rax
mov    (%rax),%rdi
test   %rdi,%rdi
je     6c0 <free_db+0x60>
mov    $0x28,%r12d
xor    %ebp,%ebp
jmp    6b1 <free_db+0x51>
nopw   %cs:0x0(%rax,%rax,1)
mov    0x18(%rbx),%rax
mov    (%rax,%r12,1),%rdi
add    $0x28,%r12
test   %rdi,%rdi
je     6c0 <free_db+0x60>
callq  6b6 <free_db+0x56>
add    $0x1,%rbp
cmp    %rbp,0x10(%rbx)
ja     6a0 <free_db+0x40>
mov    0x20(%rbx),%rax
test   %rax,%rax
je     70b <free_db+0xab>
cmpq   $0x0,0x10(%rbx)
je     703 <free_db+0xa3>
mov    (%rax),%rdi
test   %rdi,%rdi
je     703 <free_db+0xa3>
xor    %ebp,%ebp
jmp    6f0 <free_db+0x90>
nopl   0x0(%rax)
mov    %rbp,%rdx
shl    $0x4,%rdx
mov    (%rax,%rdx,1),%rdi
test   %rdi,%rdi
je     703 <free_db+0xa3>
callq  6f5 <free_db+0x95>
add    $0x1,%rbp
cmp    %rbp,0x10(%rbx)
mov    0x20(%rbx),%rax
ja     6e0 <free_db+0x80>
mov    %rax,%rdi
callq  70b <free_db+0xab>
mov    0x18(%rbx),%rdi
callq  714 <free_db+0xb4>
mov    0x8(%rbx),%rdi
callq  71d <free_db+0xbd>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   729 <free_db+0xc9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
free_db(struct dictdb *db)
{
    size_t i;
    dico_stream_close(db->stream);
    dico_stream_destroy(&db->stream);
    for (i = 0; i < db->numwords; i++) {
 if (!db->index[i].word)
     break;
 free(db->index[i].word);
    }
    if (db->suf_index) {
 for (i = 0; i < db->numwords; i++) {
     if (!db->suf_index[i].word)
  break;
     free(db->suf_index[i].word);
 }
 free(db->suf_index);
    }
    free(db->index);
    free(db->basename);
    free(db);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 9
25 6
26 6
27 6
28 11
29 11
30 11
31 12
32 12
33 13
34 13
35 13
36 13
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 15
45 12
46 12
47 13
48 12
49 17
50 17
51 19
52 19
53 20
54 20
55 21
56 22
57 22
58 22
59 21
60 21
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x28(%rdi),%rsi
mov    %rax,%rdi
jmpq   24f <lmder_jac+0xf>
nop
<<<sep_in_sample>>>
lmder_jac (void *vstate, gsl_matrix * J)
{
  lmder_state_t *state = (lmder_state_t *) vstate;
  int s = gsl_matrix_memcpy(J, state->J);
  return s;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  3a0 <build_aliasvar>
mov    %rbx,%rax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
get_aliasvar (self)
     SHELL_VAR *self;
{
  build_aliasvar (self);
  return (self);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
mov    0x14(%rdi),%edx
xor    $0x1,%eax
movzbl %al,%r8d
add    %r8d,%edx
and    $0x3,%edx
mov    %edx,%eax
lea    (%rdi,%rax,4),%rcx
mov    (%rcx),%eax
mov    %esi,(%rcx)
mov    0x18(%rdi),%ecx
mov    %edx,0x14(%rdi)
cmp    %edx,%ecx
jne    71 <i_ring_push+0x31>
add    %r8d,%ecx
and    $0x3,%ecx
mov    %ecx,0x18(%rdi)
movb   $0x0,0x1c(%rdi)
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
i_ring_push (I_ring *ir, int val)
{
  unsigned int dest_idx = (ir->ir_front + !ir->ir_empty) % I_RING_SIZE;
  int old_val = ir->ir_data[dest_idx];
  ir->ir_data[dest_idx] = val;
  ir->ir_front = dest_idx;
  if (dest_idx == ir->ir_back)
    ir->ir_back = (ir->ir_back + !ir->ir_empty) % I_RING_SIZE;
  ir->ir_empty = 0;
  return old_val;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 7
12 6
13 7
14 7
15 8
16 8
17 8
18 9
19 11
20 11
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x3a,%esi
callq  1db <maildir_name_info_ptr+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     210 <maildir_name_info_ptr+0x40>
lea    0x1(%rax),%rdi
mov    $0x2,%edx
mov    $0x0,%esi
add    $0x3,%rbx
callq  1fa <maildir_name_info_ptr+0x2a>
xor    %edx,%edx
test   %eax,%eax
cmove  %rbx,%rdx
mov    %rdx,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
xor    %edx,%edx
jmp    202 <maildir_name_info_ptr+0x32>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maildir_name_info_ptr (char *name)
{
  char *p = strchr (name, ':');
  if (p && memcmp (p + 1, "2,", 2) == 0)
    return p + 3;
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 4
9 4
10 5
11 4
12 5
13 5
14 5
15 7
16 7
17 7
18 7
19 6
20 6
21 6
<<<sep_out_sample>>>
xorpd  %xmm4,%xmm4
sub    $0x8,%rsp
ucomisd %xmm3,%xmm4
ja     170 <gsl_root_test_delta+0x50>
ucomisd %xmm2,%xmm4
ja     198 <gsl_root_test_delta+0x78>
movsd  0x0(%rip),%xmm5        # 13c <gsl_root_test_delta+0x1c>
movapd %xmm0,%xmm4
xor    %eax,%eax
andpd  %xmm5,%xmm4
mulsd  %xmm3,%xmm4
addsd  %xmm2,%xmm4
movapd %xmm0,%xmm2
subsd  %xmm1,%xmm2
andpd  %xmm5,%xmm2
ucomisd %xmm2,%xmm4
ja     168 <gsl_root_test_delta+0x48>
ucomisd %xmm1,%xmm0
jp     1c0 <gsl_root_test_delta+0xa0>
jne    1c0 <gsl_root_test_delta+0xa0>
add    $0x8,%rsp
retq   
nopl   (%rax)
mov    $0xd,%ecx
mov    $0x41,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  189 <gsl_root_test_delta+0x69>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xd,%ecx
mov    $0x44,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1b1 <gsl_root_test_delta+0x91>
mov    $0xd,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xfffffffe,%eax
jmp    168 <gsl_root_test_delta+0x48>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_root_test_delta (double x1, double x0, double epsabs, double epsrel)
{
  const double tolerance = epsabs + epsrel * fabs(x1) ;
  if (epsrel < 0.0)
    do { gsl_error ("relative tolerance is negative", "convergence.c", 65, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
  if (epsabs < 0.0)
    do { gsl_error ("absolute tolerance is negative", "convergence.c", 68, GSL_EBADTOL) ; return GSL_EBADTOL ; } while (0);
  if (fabs(x1 - x0) < tolerance || x1 == x0)
    return GSL_SUCCESS;
  return GSL_CONTINUE ;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 4
5 6
6 6
7 3
8 3
9 9
10 3
11 3
12 3
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 11
22 11
23 11
24 5
25 5
26 5
27 5
28 5
29 5
30 11
31 11
32 11
33 7
34 7
35 7
36 7
37 7
38 7
39 11
40 11
41 11
42 10
43 10
44 10
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
je     641 <trans_toktostr+0x21>
cmp    %esi,0x8(%rdi)
jne    635 <trans_toktostr+0x15>
jmp    643 <trans_toktostr+0x23>
nop
cmp    %esi,0x8(%rdi)
je     641 <trans_toktostr+0x21>
add    $0x10,%rdi
mov    (%rdi),%rax
test   %rax,%rax
jne    630 <trans_toktostr+0x10>
repz retq 
repz retq 
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
trans_toktostr(struct transtab *tab, int tok)
{
 for (; tab->name; tab++)
  if (tab->tok == tok)
   return tab->name;
 return ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 7
15 7
16 7
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
test   %rbp,%rbp
movzbl (%r8),%edi
je     2522 <gsl_matrix_uchar_max_index+0x62>
xor    %r10d,%r10d
xor    %r11d,%r11d
xor    %ebx,%ebx
nopl   0x0(%rax)
test   %r9,%r9
je     250b <gsl_matrix_uchar_max_index+0x4b>
xor    %eax,%eax
nop
movzbl (%r8,%rax,1),%ecx
cmp    %dil,%cl
jbe    2502 <gsl_matrix_uchar_max_index+0x42>
mov    %rax,%r11
mov    %r10,%rbx
mov    %ecx,%edi
add    $0x1,%rax
cmp    %r9,%rax
jne    24f0 <gsl_matrix_uchar_max_index+0x30>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
jne    24e8 <gsl_matrix_uchar_max_index+0x28>
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_max_index (const gsl_matrix_uchar * m, size_t * imax_out, size_t *jmax_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned char max = m->data[0 * tda + 0];
  size_t imax = 0, jmax = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned char x = m->data[i * tda + j];
          if (x > max)
            {
              max = x;
              imax = i;
              jmax = j;
            }
        }
    }
  *imax_out = imax;
  *jmax_out = jmax;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 6
6 4
7 5
8 9
9 6
10 9
11 9
12 7
13 7
14 7
15 11
16 11
17 11
18 11
19 13
20 14
21 14
22 14
23 14
24 14
25 11
26 11
27 11
28 9
29 9
30 9
31 9
32 22
33 23
34 24
35 24
36 24
37 24
38 7
39 7
40 22
41 23
42 24
43 24
44 24
45 24
46 24
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1a0 <gsl_eigen_herm_free+0x30>
mov    0x18(%rdi),%rdi
callq  182 <gsl_eigen_herm_free+0x12>
mov    0x10(%rbx),%rdi
callq  18b <gsl_eigen_herm_free+0x1b>
mov    0x8(%rbx),%rdi
callq  194 <gsl_eigen_herm_free+0x24>
mov    %rbx,%rdi
pop    %rbx
jmpq   19d <gsl_eigen_herm_free+0x2d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_herm_free (gsl_eigen_herm_workspace * w)
{
  if (!w) { return ; };
  free (w->tau);
  free (w->sd);
  free (w->d);
  free(w);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 8
13 7
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  1c0 <find_boolean_var>
test   %eax,%eax
js     21f0 <rl_variable_value+0x30>
cltq   
lea    (%rax,%rax,2),%rax
pop    %rbx
mov    0x0(,%rax,8),%rdx
mov    $0x0,%eax
mov    (%rdx),%edx
test   %edx,%edx
mov    $0x0,%edx
cmove  %rdx,%rax
retq   
nop
mov    %rbx,%rdi
callq  210 <find_string_var>
test   %eax,%eax
js     2210 <rl_variable_value+0x50>
cltq   
lea    (%rax,%rax,2),%rax
pop    %rbx
mov    0x0(,%rax,8),%rdi
jmpq   1c40 <_rl_get_string_variable_value>
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_variable_value (name)
     const char *name;
{
  register int i;
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");
  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 6
5 6
6 7
7 7
8 12
9 7
10 7
11 7
12 7
13 7
14 7
15 12
16 12
17 8
18 8
19 9
20 9
21 10
22 10
23 12
24 10
25 10
26 11
27 12
28 12
29 12
<<<sep_out_sample>>>
test   %rdi,%rdi
je     190 <sdp_message_s_name_get+0x10>
mov    0x38(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_s_name_get (sdp_message_t * sdp)
{
  if (sdp == ((void *)0))
    return ((void *)0);
  return sdp->s_name;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   28 <_crlfstr_flush+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_crlfstr_flush(void *data)
{
    struct _crlfstr *s = data;
    return dico_stream_flush(s->transport);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    0x10(%rdx),%r10
mov    0x8(%rdx),%rax
mov    0x30(%rsp),%r11
mov    %r9,0x10(%rsp)
mov    %ecx,%r9d
mov    %r8,0x8(%rsp)
movq   $0x0,(%rsp)
mov    %r10,%r8
mov    %rax,%rcx
mov    %r11,0x18(%rsp)
mov    (%rdx),%rdx
callq  260 <mem_cd_iconveh_internal>
add    $0x28,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
libunistring_mem_cd_iconveh (const char *src, size_t srclen,
                const iconveh_t *cd,
                enum iconv_ilseq_handler handler,
                size_t *offsets,
                char **resultp, size_t *lengthp)
{
  return mem_cd_iconveh_internal (src, srclen, cd->cd, cd->cd1, cd->cd2,
                                  handler, 0, offsets, resultp, lengthp);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 9
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
mov    %r8,0x8(%rsp)
callq  7db <_prog_read+0x1b>
mov    0x8(%rsp),%r8
mov    0x18(%rax),%rdi
add    $0x10,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
mov    %r12,%rcx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   7fa <_prog_read+0x3a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_prog_read (mu_stream_t stream, char *optr, size_t osize,
     mu_off_t offset, size_t *pnbytes)
{
  struct _prog_stream *fs = mu_stream_get_owner (stream);
  return mu_stream_read (fs->in, optr, osize, offset, pnbytes);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 5
14 5
15 5
16 6
17 6
18 6
19 5
20 5
<<<sep_out_sample>>>
sub    $0x1e,%edi
xor    %eax,%eax
cmp    $0x11,%edi
ja     12 <findColorName+0x12>
mov    0x0(,%rdi,8),%rax
repz retq 
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
findColorName(int c)
{
  switch(c)
  {
    case(30):case(40): return "BLACK  "; break;
    case(31):case(41): return "RED    "; break;
    case(32):case(42): return "GREEN  "; break;
    case(33):case(43): return "BROWN  "; break;
    case(34):case(44): return "BLUE   "; break;
    case(35):case(45): return "MAGENTA"; break;
    case(36):case(46): return "CYAN   "; break;
    case(37):case(47): return "WHITE  "; break;
  }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 15
7 15
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%ecx        # 1fa <service_pending_signals+0xa>
test   %ecx,%ecx
jne    228 <service_pending_signals+0x38>
mov    0x0(%rip),%edx        # 204 <service_pending_signals+0x14>
test   %edx,%edx
jne    268 <service_pending_signals+0x78>
mov    0x0(%rip),%eax        # 20e <service_pending_signals+0x1e>
test   %eax,%eax
je     21c <service_pending_signals+0x2c>
movl   $0x0,0x0(%rip)        # 21c <service_pending_signals+0x2c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
callq  22f <service_pending_signals+0x3f>
callq  234 <service_pending_signals+0x44>
mov    $0x13,%esi
mov    %eax,%edi
callq  240 <service_pending_signals+0x50>
movl   $0x0,0x0(%rip)        # 24a <service_pending_signals+0x5a>
movl   $0x0,0x0(%rip)        # 254 <service_pending_signals+0x64>
movl   $0x0,0x0(%rip)        # 25e <service_pending_signals+0x6e>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
callq  26f <service_pending_signals+0x7f>
xor    %eax,%eax
callq  276 <service_pending_signals+0x86>
mov    $0x1c,%edi
callq  280 <service_pending_signals+0x90>
movl   $0x0,0x0(%rip)        # 28a <service_pending_signals+0x9a>
movl   $0x0,0x0(%rip)        # 294 <service_pending_signals+0xa4>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
service_pending_signals()
{
    if (suspend_requested)
    {
 hide();
 kill(getpid(), 19);
 suspend_requested = 0;
 refresh_requested = 0;
 alarm_requested = 0;
 return;
    }
    if (refresh_requested)
    {
 tty_defaults();
 tty_io_clear();
 refresh(28);
 refresh_requested = 0;
 alarm_requested = 0;
 return;
    }
    if (alarm_requested)
    {
 alarm_requested = 0;
 return;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 12
6 12
7 12
8 21
9 21
10 21
11 23
12 26
13 26
14 26
15 5
16 5
17 6
18 6
19 6
20 6
21 7
22 8
23 9
24 26
25 26
26 26
27 14
28 14
29 15
30 15
31 16
32 16
33 17
34 18
35 26
36 26
37 26
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # a8 <rl_free_undo_list+0x8>
mov    %rbx,%rdi
callq  b0 <rl_free_undo_list+0x10>
mov    %rbx,%rsi
xor    %edx,%edx
mov    $0xffffffff,%edi
pop    %rbx
movq   $0x0,0x0(%rip)        # c6 <rl_free_undo_list+0x26>
jmpq   cb <rl_free_undo_list+0x2b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_free_undo_list ()
{
  UNDO_LIST *release, *orig_list;
  orig_list = rl_undo_list;
  _rl_free_undo_list (rl_undo_list);
  rl_undo_list = (UNDO_LIST *)((void *)0);
  _hs_replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)((void *)0));
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 7
6 7
7 7
8 8
9 6
10 7
11 7
<<<sep_out_sample>>>
mov    (%rsi),%rax
cmp    $0xffffffffffffffff,%rax
je     96 <min_timercmp+0x26>
mov    (%rdi),%rdx
cmp    %rdx,%rax
setl   %cl
cmp    %rdx,%rax
je     a0 <min_timercmp+0x30>
test   %cl,%cl
je     96 <min_timercmp+0x26>
mov    %rax,(%rdi)
mov    0x8(%rsi),%rax
mov    %rax,0x8(%rdi)
repz retq 
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rcx
cmp    %rcx,0x8(%rdi)
setg   %cl
jmp    87 <min_timercmp+0x17>
nopl   (%rax)
<<<sep_in_sample>>>
min_timercmp (struct timeval *tv1, struct timeval *tv2)
{
  if (tv2->tv_sec == -1)
    return;
  if ((((tv1)->tv_sec == (tv2)->tv_sec) ? ((tv1)->tv_usec > (tv2)->tv_usec) : ((tv1)->tv_sec > (tv2)->tv_sec))) {
    tv1->tv_sec = tv2->tv_sec;
    tv1->tv_usec = tv2->tv_usec;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 6
12 7
13 7
14 7
15 7
16 5
17 5
18 5
19 5
20 5
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
xor    %ecx,%ecx
test   %edi,%edi
movb   $0x0,0x0(%rip)        # b <if_to_a+0xb>
mov    $0x0,%r8d
js     98 <if_to_a+0x98>
mov    $0x66666667,%r10d
jmp    23 <if_to_a+0x23>
nop
mov    %r9,%r8
mov    %edi,%eax
add    $0x1,%ecx
lea    -0x1(%r8),%r9
imul   %r10d
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
add    %eax,%eax
sub    %eax,%edi
add    $0x30,%edi
cmp    %esi,%ecx
mov    %dil,-0x1(%r8)
mov    %edx,%edi
je     115 <if_to_a+0x115>
test   %edx,%edx
jne    20 <if_to_a+0x20>
cmp    %esi,%ecx
jl     20 <if_to_a+0x20>
nopl   0x0(%rax)
test   %esi,%esi
jle    8d <if_to_a+0x8d>
movzbl 0x0(%rip),%ecx        # 6b <if_to_a+0x6b>
mov    $0x0,%edx
cmp    $0x30,%cl
jne    85 <if_to_a+0x85>
nopl   (%rax)
sub    $0x1,%rdx
movzbl -0x1(%rdx),%ecx
cmp    $0x30,%cl
je     78 <if_to_a+0x78>
cmp    $0x2e,%cl
je     f8 <if_to_a+0xf8>
movb   $0x0,(%rdx)
mov    %r9,%rax
retq   
nopl   0x0(%rax)
mov    $0x66666667,%r11d
mov    $0x30,%r9d
jmp    b3 <if_to_a+0xb3>
nopw   %cs:0x0(%rax,%rax,1)
mov    %r10,%r8
mov    %edi,%eax
add    $0x1,%ecx
lea    -0x1(%r8),%r10
imul   %r11d
mov    %edi,%eax
sar    $0x1f,%eax
sar    $0x2,%edx
sub    %eax,%edx
lea    (%rdx,%rdx,4),%eax
lea    (%r9,%rax,2),%eax
sub    %edi,%eax
cmp    %esi,%ecx
mov    %edx,%edi
mov    %al,-0x1(%r8)
je     123 <if_to_a+0x123>
test   %edx,%edx
jne    b0 <if_to_a+0xb0>
cmp    %esi,%ecx
jl     b0 <if_to_a+0xb0>
lea    -0x1(%r10),%r9
movb   $0x2d,-0x1(%r10)
jmpq   60 <if_to_a+0x60>
nopw   0x0(%rax,%rax,1)
lea    -0x1(%rdx),%rax
cmp    %rax,%r9
je     109 <if_to_a+0x109>
movb   $0x0,-0x1(%rdx)
mov    %r9,%rax
retq   
movb   $0x30,-0x1(%rdx)
movb   $0x0,(%rdx)
jmpq   8d <if_to_a+0x8d>
lea    -0x2(%r8),%r9
movb   $0x2e,-0x2(%r8)
jmpq   51 <if_to_a+0x51>
lea    -0x2(%r8),%r10
movb   $0x2e,-0x2(%r8)
jmp    dc <if_to_a+0xdc>
<<<sep_in_sample>>>
if_to_a(int i, int decimal_point)
{
  static char buf[19 + 3];
  char *p = buf + 19 + 2;
  int point = 0;
  buf[19 + 2] = '\0';
  if (i >= 0) {
    do {
      *--p = '0' + (i % 10);
      i /= 10;
      if (++point == decimal_point)
 *--p = '.';
    } while (i != 0 || point < decimal_point);
  }
  else {
    do {
      *--p = '0' - (i % 10);
      i /= 10;
      if (++point == decimal_point)
 *--p = '.';
    } while (i != 0 || point < decimal_point);
    *--p = '-';
  }
  if (decimal_point > 0) {
    char *q;
    for (q = buf + 19 + 2; q[-1] == '0'; --q)
      ;
    if (q[-1] == '.') {
      if (q - 1 == p) {
 q[-1] = '0';
 q[0] = '\0';
      }
      else
 q[-1] = '\0';
    }
    else
      *q = '\0';
  }
  return p;
}
<<<sep_in_sample>>>
1 7
2 7
3 6
4 7
5 7
6 9
7 9
8 9
9 13
10 9
11 11
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 11
23 9
24 10
25 11
26 13
27 13
28 13
29 13
30 13
31 24
32 24
33 26
34 26
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 28
43 28
44 37
45 40
46 40
47 40
48 17
49 17
50 17
51 17
52 21
53 17
54 19
55 17
56 17
57 17
58 17
59 17
60 17
61 17
62 17
63 17
64 19
65 18
66 17
67 19
68 21
69 21
70 21
71 21
72 22
73 22
74 22
75 22
76 29
77 29
78 29
79 34
80 40
81 40
82 30
83 31
84 31
85 12
86 12
87 12
88 20
89 20
90 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    $0x6,%ebx
sub    $0x30,%rsp
test   %esi,%esi
movl   $0x0,0x2c(%rsp)
jg     c18 <asn1_get_octet_der+0x28>
add    $0x30,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %rdx,%r12
lea    0x2c(%rsp),%rdx
mov    %r9,0x8(%rsp)
mov    %rdi,%rbp
mov    %r8d,0x1c(%rsp)
mov    %rcx,0x10(%rsp)
callq  c37 <asn1_get_octet_der+0x47>
mov    0x8(%rsp),%r9
test   %eax,%eax
mov    $0x4,%bl
mov    %eax,(%r9)
js     c09 <asn1_get_octet_der+0x19>
movslq 0x2c(%rsp),%rsi
mov    0x1c(%rsp),%r8d
mov    $0xc,%bl
mov    0x10(%rsp),%rcx
add    %esi,%eax
mov    %eax,(%r12)
movslq (%r9),%rdx
cmp    %r8d,%edx
jg     c09 <asn1_get_octet_der+0x19>
test   %edx,%edx
jle    c80 <asn1_get_octet_der+0x90>
xor    %bl,%bl
test   %rcx,%rcx
je     c09 <asn1_get_octet_der+0x19>
add    %rbp,%rsi
mov    %rcx,%rdi
callq  c7a <asn1_get_octet_der+0x8a>
jmp    c09 <asn1_get_octet_der+0x19>
nopl   0x0(%rax)
xor    %ebx,%ebx
jmp    c09 <asn1_get_octet_der+0x19>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asn1_get_octet_der (const unsigned char *der, int der_len,
      int *ret_len, unsigned char *str, int str_size,
      int *str_len)
{
  int len_len = 0;
  if (der_len <= 0)
    return 6;
  *str_len = asn1_get_length_der (der, der_len, &len_len);
  if (*str_len < 0)
    return 4;
  *ret_len = *str_len + len_len;
  if (str_size >= *str_len)
    {
      if (*str_len > 0 && str != ((void *)0))
        memcpy (str, der + len_len, *str_len);
    }
  else
    {
      return 12;
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 4
6 6
7 5
8 6
9 22
10 22
11 22
12 22
13 22
14 22
15 22
16 22
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 9
25 10
26 8
27 9
28 11
29 12
30 19
31 12
32 11
33 11
34 12
35 12
36 12
37 14
38 14
39 21
40 14
41 14
42 15
43 15
44 15
45 15
46 15
47 21
48 21
49 21
<<<sep_out_sample>>>
push   %rbx
mov    0x50(%rdi),%rbx
mov    $0x0,%edi
callq  41f <_wsplt_alloc_die+0xf>
mov    %rax,%rdi
xor    %eax,%eax
callq  *%rbx
callq  42b <_wsplt_alloc_die+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_wsplt_alloc_die (struct wordsplit *wsp)
{
  wsp->ws_error (gettext ("memory exhausted"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r11
test   %r9,%r9
je     1f34 <gsl_matrix_char_isnull+0x54>
xorpd  %xmm1,%xmm1
xor    %esi,%esi
xor    %r10d,%r10d
test   %r8,%r8
je     1f28 <gsl_matrix_char_isnull+0x48>
mov    0x18(%rdi),%rdx
lea    (%rdx,%rsi,1),%rax
add    %r8,%rdx
add    %rsi,%rdx
nopl   0x0(%rax)
movsbl (%rax),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm1,%xmm0
jp     1f3a <gsl_matrix_char_isnull+0x5a>
jne    1f3a <gsl_matrix_char_isnull+0x5a>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1f10 <gsl_matrix_char_isnull+0x30>
add    $0x1,%r10
add    %r11,%rsi
cmp    %r9,%r10
jne    1ef9 <gsl_matrix_char_isnull+0x19>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_char_isnull (const gsl_matrix_char * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 13
21 13
22 9
23 9
24 7
25 7
26 7
27 7
28 20
29 21
30 15
31 15
32 15
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  199 <sh_un_double_quote+0x9>
lea    0x1(%rax),%rdi
mov    $0xca,%edx
mov    $0x0,%esi
callq  1ac <sh_un_double_quote+0x1c>
test   %rbx,%rbx
je     215 <sh_un_double_quote+0x85>
movzbl (%rbx),%edx
mov    %rax,%rcx
movsbl %dl,%esi
test   %esi,%esi
je     1f5 <sh_un_double_quote+0x65>
xor    %edi,%edi
jmp    1e0 <sh_un_double_quote+0x50>
nopw   0x0(%rax,%rax,1)
mov    %dl,(%rcx)
xor    %edi,%edi
add    $0x1,%rcx
add    $0x1,%rbx
je     1f5 <sh_un_double_quote+0x65>
movzbl (%rbx),%edx
movsbl %dl,%esi
test   %esi,%esi
je     1f5 <sh_un_double_quote+0x65>
test   %edi,%edi
jne    1c8 <sh_un_double_quote+0x38>
cmp    $0x5c,%esi
je     200 <sh_un_double_quote+0x70>
mov    %dl,(%rcx)
add    $0x1,%rcx
add    $0x1,%rbx
jne    1d6 <sh_un_double_quote+0x46>
movb   $0x0,(%rcx)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
movzbl 0x1(%rbx),%esi
testb  $0x40,0x0(,%rsi,4)
je     1e9 <sh_un_double_quote+0x59>
mov    $0x1,%edi
jmp    1d0 <sh_un_double_quote+0x40>
mov    %rax,%rcx
jmp    1f5 <sh_un_double_quote+0x65>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_un_double_quote (string)
     char *string;
{
  register int c, pass_next;
  char *result, *r, *s;
  r = result = (char *)sh_xmalloc((strlen (string) + 1), "shquote.c", 202);
  for (pass_next = 0, s = string; s && (c = *s); s++)
    {
      if (pass_next)
 {
   *r++ = c;
   pass_next = 0;
   continue;
 }
      if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & 0x0040))
 {
   pass_next = 1;
   continue;
 }
      *r++ = c;
    }
  *r = '\0';
  return result;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 6
6 6
7 6
8 7
9 7
10 7
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 11
19 12
20 11
21 7
22 7
23 7
24 7
25 7
26 7
27 9
28 9
29 15
30 15
31 20
32 20
33 7
34 7
35 22
36 24
37 24
38 24
39 15
40 15
41 15
42 17
43 17
44 6
45 6
46 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 5aa <tty_start_cursorapp+0xa>
mov    0x0(%rip),%rdi        # 5b1 <tty_start_cursorapp+0x11>
mov    $0x0,%edx
lea    -0x1(%rax),%esi
callq  5be <tty_start_cursorapp+0x1e>
xor    %eax,%eax
add    $0x8,%rsp
jmpq   5c9 <tty_start_cursorapp+0x29>
nopl   0x0(%rax)
<<<sep_in_sample>>>
tty_start_cursorapp()
{
    tputs((tty_capability[15].string),tty_lines-1,tty_writec);
    tty_flush();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     4b4 <gsl_matrix_complex_ispos+0x64>
xorpd  %xmm0,%xmm0
shl    $0x4,%rax
mov    $0x8,%esi
mov    %rax,%r10
xor    %r8d,%r8d
test   %rcx,%rcx
je     4a8 <gsl_matrix_complex_ispos+0x58>
mov    %rsi,%rax
xor    %edx,%edx
add    0x18(%rdi),%rax
jmp    49b <gsl_matrix_complex_ispos+0x4b>
nopl   0x0(%rax,%rax,1)
ucomisd (%rax),%xmm0
jae    4a2 <gsl_matrix_complex_ispos+0x52>
add    $0x1,%rdx
add    $0x10,%rax
cmp    %rcx,%rdx
je     4a8 <gsl_matrix_complex_ispos+0x58>
ucomisd -0x8(%rax),%xmm0
jb     488 <gsl_matrix_complex_ispos+0x38>
xor    %eax,%eax
retq   
nopl   (%rax)
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    473 <gsl_matrix_complex_ispos+0x23>
mov    $0x1,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_ispos (const gsl_matrix_complex * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 13
19 13
20 9
21 9
22 9
23 9
24 13
25 13
26 15
27 15
28 15
29 7
30 7
31 7
32 7
33 20
34 20
35 20
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
term_source (j_decompress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # b <print_and_abort+0xb>
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  1c <print_and_abort+0x1c>
mov    0x0(%rip),%edi        # 22 <print_and_abort+0x22>
callq  27 <print_and_abort+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_and_abort (void)
{
  fprintf (stderr, "%s\n", ((const char *) ("memory exhausted")));
  exit (exit_failure);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     758 <gsl_vector_long_double_isnonneg+0x38>
mov    0x10(%rdi),%rdx
fldz   
shl    $0x4,%rsi
xor    %eax,%eax
nopl   0x0(%rax,%rax,1)
fldt   (%rdx)
fxch   %st(1)
fucomi %st(1),%st
fstp   %st(1)
ja     75e <gsl_vector_long_double_isnonneg+0x3e>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    740 <gsl_vector_long_double_isnonneg+0x20>
fstp   %st(0)
mov    $0x1,%eax
retq   
fstp   %st(0)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_isnonneg (const gsl_vector_long_double * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 11
7 11
8 6
9 6
10 11
11 11
12 11
13 11
14 11
15 6
16 6
17 6
18 6
19 6
20 17
21 18
22 18
23 13
24 13
25 13
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
je     1e3 <gss_compare_name+0x13>
movl   $0x0,(%rdi)
test   %rbx,%rbx
jne    1f8 <gss_compare_name+0x28>
mov    $0x1020000,%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %rdx,%rdx
je     1e8 <gss_compare_name+0x18>
mov    0x10(%rdx),%rsi
mov    0x10(%rbx),%rdi
mov    %rcx,0x8(%rsp)
mov    %rdx,(%rsp)
callq  213 <gss_compare_name+0x43>
mov    %eax,%esi
mov    (%rsp),%rdx
mov    $0x30000,%eax
test   %esi,%esi
mov    0x8(%rsp),%rcx
je     1ed <gss_compare_name+0x1d>
test   %rcx,%rcx
je     23c <gss_compare_name+0x6c>
mov    (%rbx),%r8
xor    %eax,%eax
cmp    (%rdx),%r8
je     240 <gss_compare_name+0x70>
mov    %eax,(%rcx)
xor    %eax,%eax
jmp    1ed <gss_compare_name+0x1d>
xor    %eax,%eax
jmp    1ed <gss_compare_name+0x1d>
mov    0x8(%rdx),%rsi
mov    0x8(%rbx),%rdi
mov    %r8,%rdx
mov    %rcx,(%rsp)
callq  254 <gss_compare_name+0x84>
test   %eax,%eax
mov    (%rsp),%rcx
sete   %al
movzbl %al,%eax
jmp    236 <gss_compare_name+0x66>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_compare_name (OM_uint32 * minor_status,
    const gss_name_t name1,
    const gss_name_t name2, int *name_equal)
{
  if (minor_status)
    *minor_status = 0;
  if (!name1 || !name2)
    return (2ul << 16) | (1ul << 24);
  if (!gss_oid_equal (name1->type, name2->type))
    return (3ul << 16);
  if (name_equal)
    *name_equal = (name1->length == name2->length) &&
      memcmp (name1->value, name2->value, name1->length) == 0;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 7
8 7
9 8
10 15
11 15
12 15
13 15
14 7
15 7
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 9
25 9
26 9
27 11
28 11
29 12
30 12
31 12
32 12
33 12
34 14
35 14
36 14
37 14
38 13
39 13
40 13
41 13
42 13
43 12
44 12
45 12
46 12
47 12
48 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  4c <polynomial_free+0xc>
mov    0x8(%rbx),%rdi
callq  55 <polynomial_free+0x15>
mov    0x10(%rbx),%rdi
callq  5e <polynomial_free+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   67 <polynomial_free+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
polynomial_free (void *vstate)
{
  polynomial_state_t *state = (polynomial_state_t *) vstate;
  free (state->d);
  free (state->coeff);
  free (state->work);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
test   %rdx,%rdx
xorpd  %xmm0,%xmm0
je     217 <gsl_stats_uint_median_from_sorted_data+0x37>
lea    -0x1(%rdx),%rax
shr    %rdx
shl    $0x2,%rsi
shr    %rax
cmp    %rdx,%rax
je     220 <gsl_stats_uint_median_from_sorted_data+0x40>
imul   %rsi,%rax
imul   %rsi,%rdx
mov    (%rdi,%rax,1),%eax
add    (%rdi,%rdx,1),%eax
cvtsi2sd %rax,%xmm0
mulsd  0x0(%rip),%xmm0        # 217 <gsl_stats_uint_median_from_sorted_data+0x37>
repz retq 
nopl   0x0(%rax)
imul   %rax,%rsi
mov    (%rdi,%rsi,1),%eax
cvtsi2sd %rax,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_stats_uint_median_from_sorted_data (const unsigned int sorted_data[],
                                             const size_t stride,
                                             const size_t n)
{
  double median ;
  const size_t lhs = (n - 1) / 2 ;
  const size_t rhs = n / 2 ;
  if (n == 0)
    return 0.0 ;
  if (lhs == rhs)
    {
      median = sorted_data[lhs * stride] ;
    }
  else
    {
      median = (sorted_data[lhs * stride] + sorted_data[rhs * stride])/2.0 ;
    }
  return median ;
}
<<<sep_in_sample>>>
1 8
2 9
3 8
4 6
5 7
6 12
7 6
8 10
9 10
10 16
11 16
12 16
13 16
14 16
15 16
16 19
17 19
18 12
19 12
20 12
21 12
22 12
<<<sep_out_sample>>>
mov    $0x0,%ecx
jmpq   a50 <quotearg_n_options>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n_mem (int n, char const *arg, size_t argsize)
{
  return quotearg_n_options (n, arg, argsize, &default_quoting_options);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
add    $0x70,%rdi
mov    $0xffffffff,%edx
jmpq   0 <ahsStaticSetTarname_i>
xchg   %ax,%ax
<<<sep_in_sample>>>
ahsStaticSetTarFilename(struct new_cpio_header * file_hdr, char * name)
{
 ;
 ahsStaticSetTarname_i((STROB**)&(file_hdr->c_name), name, -1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_accept_encoding_get_element (const osip_accept_encoding_t * ae)
{
  return ae->element;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_get_format(XFORMAT * xux)
{
 ;
 return (int)(xux->format_codeM);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
mov    %rsi,0x18(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_set_nonce (osip_authorization_t * authorization, char *nonce)
{
  authorization->nonce = (char *) nonce;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     90a <own_array+0x5a>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xf0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    $0x1,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  7f0 <make_dv>
mov    %ebp,%edi
mov    %rax,%rsi
mov    %rax,%rbx
callq  630 <array_size>
test   %eax,%eax
mov    %eax,%ebp
jne    970 <own_array+0xc0>
movq   $0x0,(%rbx)
add    $0xd8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%edi
callq  5f0 <my_malloc>
movslq %ebp,%rdx
mov    %rax,(%rbx)
xor    %esi,%esi
mov    %rax,%rdi
callq  987 <own_array+0xd7>
add    $0xd8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
own_array(int type, int n, ...)
{
      struct dv *dv;
      int size;
      va_list arg;
      __builtin_va_start(arg,n);
      dv = make_dv(1, n, arg);
      __builtin_va_end(arg);
      size = array_size(type, dv);
      dv->base = size == 0 ? ((void *)0) : my_malloc(size);
      if (size != 0) memset(dv->base, 0, size);
      return dv;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 6
20 7
21 7
22 6
23 6
24 6
25 6
26 6
27 7
28 9
29 9
30 7
31 9
32 10
33 9
34 10
35 10
36 13
37 13
38 13
39 13
40 13
41 13
42 10
43 10
44 11
45 10
46 11
47 11
48 11
49 13
50 13
51 13
52 13
53 13
54 13
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
push   %rbp
mov    %rdx,%rbp
push   %rbx
je     70 <__gmpz_cdiv_r_ui+0x70>
movslq 0x4(%rsi),%rbx
mov    %rdi,%r12
mov    %rsi,%rax
test   %rbx,%rbx
je     3c <__gmpz_cdiv_r_ui+0x3c>
mov    %rbx,%rdx
mov    0x8(%rax),%rdi
sar    $0x3f,%rdx
mov    %rdx,%rsi
xor    %rbx,%rsi
sub    %rdx,%rsi
mov    %rbp,%rdx
callq  37 <__gmpz_cdiv_r_ui+0x37>
test   %rax,%rax
jne    50 <__gmpz_cdiv_r_ui+0x50>
movl   $0x0,0x4(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%r12),%rdx
sub    %rax,%rbp
test   %rbx,%rbx
cmovns %rbp,%rax
mov    %rax,(%rdx)
movl   $0xffffffff,0x4(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  75 <__gmpz_cdiv_r_ui+0x75>
<<<sep_in_sample>>>
__gmpz_cdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)
{
  mp_size_t ns, nn;
  mp_ptr np;
  mp_limb_t rl;
  if (__builtin_expect ((divisor == 0) != 0, 0))
    __gmp_divide_by_zero ();
  ns = ((dividend)->_mp_size);
  if (ns == 0)
    {
      ((rem)->_mp_size) = 0;
      return 0;
    }
  nn = ((ns) >= 0 ? (ns) : -(ns));
  np = ((dividend)->_mp_d);
    {
      rl = __gmpn_mod_1 (np, nn, (mp_limb_t) divisor);
      if (rl == 0)
 ((rem)->_mp_size) = 0;
      else
 {
   if (ns >= 0)
     rl = divisor - rl;
   ((rem)->_mp_d)[0] = rl;
   ((rem)->_mp_size) = -1;
 }
    }
  return rl;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 6
7 8
8 8
9 8
10 9
11 9
12 14
13 17
14 14
15 14
16 14
17 14
18 17
19 17
20 18
21 18
22 11
23 12
24 29
25 29
26 29
27 29
28 29
29 24
30 23
31 23
32 23
33 24
34 25
35 29
36 29
37 29
38 29
39 7
<<<sep_out_sample>>>
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
jmpq   1560 <quotearg_colon>
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rdx
mov    (%rax),%r8
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%rdi
jmpq   147b <gsl_sort_vector2_long+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector2_long (gsl_vector_long * v1, gsl_vector_long * v2)
{
  gsl_sort2_long (v1->data, v1->stride, v2->data, v2->stride, v1->size) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  f09 <xdr_dis_repair_result+0x9>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_repair_result(xdrs, objp)
	XDR *xdrs;
	dis_repair_result *objp;
{
	if (!xdr_byte_u_char(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 9
6 5
7 9
8 9
<<<sep_out_sample>>>
testb  $0x10,0x23d(%rdi)
je     2a0 <__db_get_type+0x10>
mov    0x30(%rdi),%eax
retq   
nopl   (%rax)
mov    0x28(%rdi),%rdi
xor    %edx,%edx
mov    $0x0,%esi
jmpq   2b0 <__db_get_byteswapped>
<<<sep_in_sample>>>
__db_get_type(dbp)
 DB *dbp;
{
 if (!(((dbp))->flags & (0x01000))) return (CDB___db_mi_open(dbp->dbenv, "get_type", 0));;
 return (dbp->type);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 6
6 4
7 4
8 4
9 4
<<<sep_out_sample>>>
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %esi,%ebx
callq  2a0 <make_name>
cmpl   $0x2,0x0(%rip)        # 1257 <addname+0x17>
mov    $0x10000000,%r8d
mov    $0x0,%edx
mov    0x0(%rip),%edi        # 1268 <addname+0x28>
mov    0x0(%rip),%r9        # 126f <addname+0x2f>
movq   $0x0,(%rax)
movq   $0x0,0x30(%rax)
mov    %ebx,0x28(%rax)
movq   $0x0,0x38(%rax)
cmovne %edx,%r8d
or     0x0(%rip),%edi        # 1293 <addname+0x53>
mov    %r9,0x8(%rax)
or     0x0(%rip),%edi        # 129d <addname+0x5d>
mov    %r12,0x40(%rax)
mov    %bpl,0x24(%rax)
or     %r8d,%edi
test   %r9,%r9
mov    %edi,0x20(%rax)
je     12c0 <addname+0x80>
mov    %rax,(%r9)
mov    %rax,0x0(%rip)        # 12ba <addname+0x7a>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
pop    %rbx
pop    %rbp
mov    %rax,0x0(%rip)        # 12c9 <addname+0x89>
mov    %rax,0x0(%rip)        # 12d0 <addname+0x90>
pop    %r12
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addname (char const *string, int change_dir, _Bool cmdline, struct name *parent)
{
  struct name *name = make_name (string);
  name->prev = nametail;
  name->next = ((void *)0);
  name->found_count = 0;
  name->matching_flags = (((wildcards == enable_wildcards) ? (1 << 28) : 0) | include_anchored | matching_flags | recursion_option);
  name->change_dir = change_dir;
  name->directory = ((void *)0);
  name->parent = parent;
  name->cmdline = cmdline;
  if (nametail)
    nametail->next = name;
  else
    namelist = name;
  nametail = name;
  return name;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 7
9 7
10 7
11 7
12 4
13 5
14 6
15 8
16 9
17 7
18 7
19 4
20 7
21 10
22 11
23 7
24 12
25 7
26 12
27 13
28 16
29 18
30 18
31 18
32 18
33 18
34 18
35 18
36 15
37 16
38 18
39 18
40 18
<<<sep_out_sample>>>
movq   $0x0,0x20(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_buffer_reset(struct nettle_buffer *buffer)
{
  buffer->size = 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
jmpq   935 <yyalloc+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyalloc (yy_size_t size )
{
 return (void *) malloc( size );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1d0 <_gsasl_saml20_server_finish+0x10>
mov    %rsi,%rdi
jmpq   1cd <_gsasl_saml20_server_finish+0xd>
nopl   (%rax)
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
<<<sep_out_sample>>>
xor    %r9d,%r9d
mov    $0x0,%r8d
mov    $0x14,%ecx
mov    $0x1,%edx
mov    $0xc8,%esi
mov    $0x0,%edi
jmpq   e2 <sheets_map_new+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sheets_map_new (void)
{
  return da_new ("Sheets map", 200,
   da_linear, 20,
   (da_print_func_t) pattern_rule_self_print, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm6        # 1568 <gsl_sf_bessel_I_CF1_ser+0x8>
mov    $0x1,%eax
xorpd  %xmm3,%xmm3
movapd %xmm6,%xmm7
movapd %xmm6,%xmm5
movsd  0x0(%rip),%xmm11        # 1582 <gsl_sf_bessel_I_CF1_ser+0x22>
movsd  0x0(%rip),%xmm10        # 158b <gsl_sf_bessel_I_CF1_ser+0x2b>
movapd %xmm6,%xmm12
movsd  0x0(%rip),%xmm9        # 1599 <gsl_sf_bessel_I_CF1_ser+0x39>
movsd  0x0(%rip),%xmm8        # 15a2 <gsl_sf_bessel_I_CF1_ser+0x42>
jmp    15b2 <gsl_sf_bessel_I_CF1_ser+0x52>
nopl   0x0(%rax)
add    $0x1,%eax
cmp    $0x4e20,%eax
je     1630 <gsl_sf_bessel_I_CF1_ser+0xd0>
cvtsi2sd %eax,%xmm4
movapd %xmm1,%xmm2
addsd  %xmm6,%xmm3
addsd  %xmm0,%xmm4
divsd  %xmm4,%xmm2
addsd  %xmm6,%xmm4
mulsd  %xmm11,%xmm2
mulsd  %xmm1,%xmm2
divsd  %xmm4,%xmm2
movapd %xmm3,%xmm4
movapd %xmm2,%xmm3
mulsd  %xmm4,%xmm2
xorpd  %xmm10,%xmm3
addsd  %xmm6,%xmm2
mulsd  %xmm4,%xmm3
divsd  %xmm2,%xmm3
mulsd  %xmm3,%xmm5
addsd  %xmm5,%xmm7
movapd %xmm5,%xmm2
divsd  %xmm7,%xmm2
andpd  %xmm9,%xmm2
ucomisd %xmm2,%xmm8
jbe    15a8 <gsl_sf_bessel_I_CF1_ser+0x48>
addsd  %xmm0,%xmm12
xor    %eax,%eax
addsd  %xmm12,%xmm12
divsd  %xmm12,%xmm1
mulsd  %xmm7,%xmm1
movsd  %xmm1,(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
addsd  %xmm0,%xmm12
sub    $0x8,%rsp
mov    $0xb,%ecx
mov    $0x290,%edx
mov    $0x0,%esi
addsd  %xmm12,%xmm12
divsd  %xmm12,%xmm1
mulsd  %xmm7,%xmm1
movsd  %xmm1,(%rdi)
mov    $0x0,%edi
callq  1664 <gsl_sf_bessel_I_CF1_ser+0x104>
mov    $0xb,%eax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_sf_bessel_I_CF1_ser(const double nu, const double x, double * ratio)
{
  const int maxk = 20000;
  double tk = 1.0;
  double sum = 1.0;
  double rhok = 0.0;
  int k;
  for(k=1; k<maxk; k++) {
    double ak = 0.25 * (x/(nu+k)) * x/(nu+k+1.0);
    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
    tk *= rhok;
    sum += tk;
    if(fabs(tk/sum) < 2.2204460492503131e-16) break;
  }
  *ratio = x/(2.0*(nu+1.0)) * sum;
  if(k == maxk)
    do { gsl_error ("error", "bessel.c", 656, GSL_EMAXITER) ; return GSL_EMAXITER ; } while (0);
  else
    return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 8
3 6
4 5
5 4
6 4
7 4
8 9
9 9
10 9
11 9
12 9
13 8
14 8
15 8
16 9
17 9
18 10
19 9
20 9
21 9
22 9
23 9
24 9
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 11
33 12
34 13
35 13
36 13
37 13
38 13
39 15
40 19
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 2
49 17
50 17
51 17
52 15
53 15
54 15
55 15
56 17
57 17
58 17
59 20
60 20
61 20
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
cmp    $0x18,%rdx
je     2e50 <gl_3des_makekey+0x20>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
lea    0x10(%rsi),%r13
lea    0x8(%rsi),%r12
mov    %rsi,%rbp
mov    %r13,%rcx
mov    %r12,%rdx
callq  2e66 <gl_3des_makekey+0x36>
mov    %rbp,%rdi
callq  2e6e <gl_3des_makekey+0x3e>
test   %al,%al
mov    %eax,%ebx
je     2e88 <gl_3des_makekey+0x58>
add    $0x8,%rsp
xor    %ebx,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    %r12,%rdi
callq  2e90 <gl_3des_makekey+0x60>
test   %al,%al
jne    2e42 <gl_3des_makekey+0x12>
mov    %r13,%rdi
callq  2e9c <gl_3des_makekey+0x6c>
mov    %eax,%ebx
xor    $0x1,%ebx
jmp    2e42 <gl_3des_makekey+0x12>
<<<sep_in_sample>>>
gl_3des_makekey (gl_3des_ctx *ctx, const char * key, size_t keylen)
{
  if (keylen != 24)
    return 0;
  gl_3des_set3keys (ctx, key, key + 8, key + 16);
  return !(gl_des_is_weak_key (key)
           || gl_des_is_weak_key (key + 8)
           || gl_des_is_weak_key (key + 16));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 3
8 3
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 9
17 5
18 5
19 5
20 5
21 5
22 5
23 6
24 6
25 6
26 6
27 6
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 7
38 7
39 7
40 7
41 8
42 8
43 8
44 6
45 6
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %esi,%ecx
ror    %cl,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rotr_sz (size_t x, int n)
{
  return ((x >> n) | (x << ((8 * sizeof x) - n))) & (18446744073709551615UL);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x20(%rdi),%rdi
test   %rdi,%rdi
je     12 <swicat_sr_delete+0x12>
callq  12 <swicat_sr_delete+0x12>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     20 <swicat_sr_delete+0x20>
callq  20 <swicat_sr_delete+0x20>
mov    0x38(%rbx),%rdi
test   %rdi,%rdi
je     2e <swicat_sr_delete+0x2e>
callq  2e <swicat_sr_delete+0x2e>
mov    %rbx,%rdi
pop    %rbx
jmpq   37 <swicat_sr_delete+0x37>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicat_sr_delete(SWICAT_SR * sr)
{
 if (sr->lineM != ((void *)0)) free(sr->lineM);
 if (sr->bundleM != ((void *)0)) free(sr->bundleM);
 if (sr->swspecM != ((void *)0)) swverid_close(sr->swspecM);
 free(sr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 6
16 7
17 6
18 6
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 1eb6 <asm_set_debug+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_set_debug (int bdebug )
{
        asm__flex_debug = bdebug ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5487 <re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # 548e <re_set_syntax+0xe>
retq   
nop
<<<sep_in_sample>>>
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %esi,%esi
je     320 <srcfile_generator+0xa0>
mov    0x0(%rip),%rbx        # 29c <srcfile_generator+0x1c>
mov    0x0(%rip),%rax        # 2a3 <srcfile_generator+0x23>
mov    0x0(%rip),%r12        # 2aa <srcfile_generator+0x2a>
jmp    2c1 <srcfile_generator+0x41>
nopl   0x0(%rax)
mov    (%rax),%rax
mov    %rax,0x0(%rip)        # 2ba <srcfile_generator+0x3a>
mov    0x0(%rip),%rax        # 2c1 <srcfile_generator+0x41>
cmp    %rax,%rbx
je     310 <srcfile_generator+0x90>
mov    0x10(%rax),%edx
lea    -0x3(%rdx),%ecx
cmp    $0x1,%ecx
ja     2b0 <srcfile_generator+0x30>
mov    0x18(%rax),%r13
mov    (%rax),%rax
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %r13,%rdi
mov    %rax,0x0(%rip)        # 2e8 <srcfile_generator+0x68>
callq  2ed <srcfile_generator+0x6d>
test   %eax,%eax
jne    2ba <srcfile_generator+0x3a>
mov    %r13,%rdi
callq  2f9 <srcfile_generator+0x79>
add    $0x8,%rsp
mov    %r13,%rdi
mov    %rax,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   30e <srcfile_generator+0x8e>
xchg   %ax,%ax
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
callq  325 <srcfile_generator+0xa5>
mov    0x0(%rip),%rbx        # 32c <srcfile_generator+0xac>
mov    %rax,0x0(%rip)        # 333 <srcfile_generator+0xb3>
mov    (%rbx),%rax
mov    %rax,0x0(%rip)        # 33d <srcfile_generator+0xbd>
jmpq   2a3 <srcfile_generator+0x23>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
srcfile_generator(const char *text, int state)
{
 static size_t textlen;
 static SRCFILE *s;
 char *name;
 extern SRCFILE *srcfiles;
 if (! state) {
  textlen = strlen(text);
  s = srcfiles->next;
 }
 while (s != srcfiles) {
  if (s->stype != SRC_FILE && s->stype != SRC_INC) {
   s = s->next;
   continue;
  }
  name = s->src;
  s = s->next;
  if (strncmp(name, text, textlen) == 0)
   return estrdup(name, strlen(name));
 }
 return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 7
9 7
10 7
11 18
12 18
13 18
14 13
15 13
16 13
17 11
18 11
19 12
20 12
21 12
22 12
23 16
24 17
25 18
26 18
27 18
28 17
29 18
30 18
31 18
32 19
33 19
34 22
35 19
36 19
37 22
38 22
39 22
40 22
41 19
42 19
43 22
44 22
45 22
46 22
47 22
48 22
49 22
50 22
51 8
52 9
53 8
54 9
55 9
56 9
57 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  61 <_file_wait+0x11>
mov    (%rax),%rdi
test   %rdi,%rdi
je     88 <_file_wait+0x38>
callq  6e <_file_wait+0x1e>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdx
pop    %rbx
pop    %rbp
mov    %eax,%edi
jmpq   81 <_file_wait+0x31>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x16,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_file_wait (mu_stream_t stream, int *pflags, struct timeval *tvp)
{
  struct _file_stream *fs = mu_stream_get_owner (stream);
  if (!fs->file)
    return 22;
  return mu_fd_wait (fileno (fs->file), pflags, tvp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 6
11 7
12 6
13 6
14 7
15 7
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  2d9 <php_reserved_variable+0x9>
test   %rax,%rax
je     300 <php_reserved_variable+0x30>
mov    0x8(%rax),%edx
xor    %eax,%eax
lea    -0x3e9(%rdx),%ecx
cmp    $0x3e8,%ecx
cmovb  %edx,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
php_reserved_variable(const char *str, int len)
{
 struct keyword *keyword;
 keyword = php_lookup(str, len);
 return (keyword && ((keyword->token) >= 1001 && (keyword->token) < 2001)) ? keyword->token : 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 5
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    0x8(%rdi),%rax
je     550 <gsl_linalg_QR_svx+0x40>
mov    $0x14,%ecx
mov    $0x93,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  53b <gsl_linalg_QR_svx+0x2b>
mov    $0x14,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
cmp    (%rdx),%rax
mov    %rdx,%rbp
je     580 <gsl_linalg_QR_svx+0x70>
mov    $0x13,%ecx
mov    $0x97,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  571 <gsl_linalg_QR_svx+0x61>
add    $0x8,%rsp
mov    $0x13,%eax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
callq  585 <gsl_linalg_QR_svx+0x75>
mov    %rbp,%r8
mov    %rbx,%rcx
mov    $0x83,%edx
mov    $0x6f,%esi
mov    $0x79,%edi
callq  59f <gsl_linalg_QR_svx+0x8f>
xor    %eax,%eax
jmp    540 <gsl_linalg_QR_svx+0x30>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_linalg_QR_svx (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * x)
{
  if (QR->size1 != QR->size2)
    {
      do { gsl_error ("QR matrix must be square", "qr.c", 147, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (QR->size1 != x->size)
    {
      do { gsl_error ("matrix size must match x/rhs size", "qr.c", 151, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      gsl_linalg_QR_QTvec (QR, tau, x);
      gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, QR, x);
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 5
12 5
13 5
14 17
15 17
16 17
17 17
18 17
19 7
20 7
21 7
22 9
23 9
24 9
25 9
26 9
27 17
28 9
29 17
30 17
31 17
32 17
33 13
34 14
35 14
36 14
37 14
38 14
39 14
40 15
41 15
42 15
<<<sep_out_sample>>>
push   %rbp
mov    $0x100,%esi
push   %rbx
sub    $0x118,%rsp
mov    %rsp,%rdi
mov    %rsp,%rbp
mov    %fs:0x28,%rax
mov    %rax,0x108(%rsp)
xor    %eax,%eax
callq  55c <maildir_gethostname+0x2c>
test   %eax,%eax
js     670 <maildir_gethostname+0x140>
movzbl (%rsp),%ebx
test   %bl,%bl
je     638 <maildir_gethostname+0x108>
mov    %ebx,%eax
xor    %ecx,%ecx
mov    %rbp,%rdx
nopw   0x0(%rax,%rax,1)
cmp    $0x3a,%al
je     588 <maildir_gethostname+0x58>
cmp    $0x2f,%al
jne    58c <maildir_gethostname+0x5c>
add    $0x4,%rcx
add    $0x1,%rdx
movzbl (%rdx),%eax
test   %al,%al
jne    580 <maildir_gethostname+0x50>
test   %rcx,%rcx
je     638 <maildir_gethostname+0x108>
mov    %rbp,%rdx
mov    (%rdx),%esi
add    $0x4,%rdx
lea    -0x1010101(%rsi),%eax
not    %esi
and    %esi,%eax
and    $0x80808080,%eax
je     5a3 <maildir_gethostname+0x73>
mov    %eax,%esi
shr    $0x10,%esi
test   $0x8080,%eax
cmove  %esi,%eax
lea    0x2(%rdx),%rsi
cmove  %rsi,%rdx
add    %al,%al
sbb    $0x3,%rdx
sub    %rbp,%rdx
lea    0x1(%rcx,%rdx,1),%rdi
callq  5e2 <maildir_gethostname+0xb2>
mov    %rbp,%rdi
mov    %rax,%rdx
jmp    60e <maildir_gethostname+0xde>
nopw   0x0(%rax,%rax,1)
cmp    $0x3a,%bl
jne    660 <maildir_gethostname+0x130>
movl   $0x3237305c,(%rdx)
mov    %rdi,%rcx
add    $0x4,%rdx
movzbl 0x1(%rcx),%ebx
lea    0x1(%rcx),%rdi
test   %bl,%bl
je     62c <maildir_gethostname+0xfc>
cmp    $0x2f,%bl
jne    5f0 <maildir_gethostname+0xc0>
mov    %rdi,%rcx
movl   $0x3735305c,(%rdx)
add    $0x4,%rdx
movzbl 0x1(%rcx),%ebx
lea    0x1(%rcx),%rdi
test   %bl,%bl
jne    60e <maildir_gethostname+0xde>
movb   $0x0,(%rdx)
jmp    640 <maildir_gethostname+0x110>
nopl   0x0(%rax)
mov    %rbp,%rdi
callq  640 <maildir_gethostname+0x110>
mov    0x108(%rsp),%rsi
xor    %fs:0x28,%rsi
jne    68d <maildir_gethostname+0x15d>
add    $0x118,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %bl,(%rdx)
lea    0x1(%rdi),%rcx
add    $0x1,%rdx
jmp    602 <maildir_gethostname+0xd2>
nopl   0x0(%rax)
movabs $0x736f686c61636f6c,%rax
mov    %rax,(%rsp)
mov    $0x74,%eax
mov    %ax,0x8(%rsp)
jmpq   564 <maildir_gethostname+0x34>
callq  692 <maildir_gethostname+0x162>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
maildir_gethostname ()
{
  char hostname[256];
  char *hp;
  char *p;
  size_t s;
  if (gethostname (hostname, sizeof hostname) < 0)
    strcpy (hostname, "localhost");
  for (s = 0, p = hostname; *p; p++)
    if (*p == '/' || *p == ':')
      s += 4;
  if (s)
    {
      char *q;
      hp = malloc (strlen (hostname) + s + 1);
      for (p = hostname, q = hp; *p; p++)
 switch (*p)
   {
   case '/':
     memcpy (q, "\\057", 4);
     q += 4;
     break;
   case ':':
     memcpy (q, "\\072", 4);
     q += 4;
     break;
   default:
     *q++ = *p++;
   }
      *q = 0;
    }
  else
    hp = strdup (hostname);
  return hp;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 7
6 7
7 2
8 2
9 2
10 7
11 7
12 7
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 10
21 10
22 10
23 10
24 11
25 9
26 9
27 9
28 9
29 12
30 12
31 15
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 16
51 16
52 16
53 16
54 17
55 17
56 24
57 26
58 25
59 16
60 16
61 16
62 16
63 17
64 17
65 22
66 20
67 21
68 16
69 16
70 16
71 16
72 30
73 30
74 30
75 33
76 33
77 35
78 35
79 35
80 35
81 35
82 35
83 35
84 35
85 28
86 28
87 28
88 28
89 28
90 8
91 8
92 8
93 8
94 8
95 35
96 35
<<<sep_out_sample>>>
push   %r12
test   %rsi,%rsi
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %edx,%ebx
je     a1f <assert_grecs_value_type+0x5f>
mov    (%rsi),%edi
test   %edi,%edi
je     a18 <assert_grecs_value_type+0x58>
xor    %eax,%eax
cmp    %ebx,%edi
je     a10 <assert_grecs_value_type+0x50>
callq  9df <assert_grecs_value_type+0x1f>
mov    %ebx,%edi
mov    %rax,%r12
callq  9e9 <assert_grecs_value_type+0x29>
mov    $0x0,%edi
mov    %rax,%rbx
callq  9f6 <assert_grecs_value_type+0x36>
mov    %r12,%r8
mov    %rax,%rdx
mov    %rbx,%rcx
xor    %eax,%eax
xor    %esi,%esi
mov    %rbp,%rdi
callq  a0b <assert_grecs_value_type+0x4b>
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
cmpq   $0x0,0x8(%rsi)
jne    9d4 <assert_grecs_value_type+0x14>
mov    %ebx,%edi
callq  a26 <assert_grecs_value_type+0x66>
mov    $0x0,%edi
mov    %rax,%rbx
callq  a33 <assert_grecs_value_type+0x73>
mov    %rbx,%rcx
mov    %rax,%rdx
xor    %esi,%esi
xor    %eax,%eax
mov    %rbp,%rdi
callq  a45 <assert_grecs_value_type+0x85>
mov    $0x1,%eax
jmp    a10 <assert_grecs_value_type+0x50>
nopl   0x0(%rax)
<<<sep_in_sample>>>
assert_grecs_value_type (grecs_locus_t *locus,
    const grecs_value_t *value, int type)
{
  if ((!(value) || ((value)->type == 0 && !(value)->v.string)))
    {
      grecs_error (locus, 0, gettext("expected %s"),
     grecs_data_type_string (type));
      return 1;
    }
  if (value->type != type)
    {
      grecs_error (locus, 0, gettext("expected %s, but found %s"),
     grecs_data_type_string (type),
     grecs_data_type_string (value->type));
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 17
12 10
13 10
14 12
15 12
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 15
29 18
30 18
31 18
32 18
33 18
34 4
35 4
36 6
37 6
38 6
39 6
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
mov    %rdi,%rbx
je     1f4 <mu_pop3_sendline+0x14>
xor    %eax,%eax
callq  1f0 <mu_pop3_sendline+0x10>
test   %eax,%eax
jne    200 <mu_pop3_sendline+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   1fd <mu_pop3_sendline+0x1d>
nopl   (%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
mu_pop3_sendline (mu_pop3_t pop3, const char *line)
{
  if (line)
    {
      int status = mu_pop3_writeline (pop3, line);
      if (status)
 return status;
    }
  return mu_pop3_send (pop3);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 6
8 6
9 9
10 10
11 9
12 9
13 10
14 10
<<<sep_out_sample>>>
jmpq   45 <optionp_getfilecon+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
optionp_getfilecon (int fd, const char *name, security_context_t *p)
{
  return lgetfileconat (fd, name, p);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
shl    $0x4,%rdx
xor    %r8d,%r8d
test   %rcx,%rcx
push   %rbx
mov    %rsi,%rbx
je     872 <gsl_permute_long_double+0x72>
mov    (%rdi,%r8,8),%rax
cmp    %rax,%r8
jae    829 <gsl_permute_long_double+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rax,%r8
jb     820 <gsl_permute_long_double+0x20>
cmp    %rax,%r8
ja     866 <gsl_permute_long_double+0x66>
mov    (%rdi,%rax,8),%r9
cmp    %r8,%r9
je     866 <gsl_permute_long_double+0x66>
fldt   (%rbx)
jmp    846 <gsl_permute_long_double+0x46>
nopl   0x0(%rax,%rax,1)
mov    %r9,%rax
mov    %r10,%r9
mov    %rdx,%r11
mov    (%rdi,%r9,8),%r10
imul   %r9,%r11
imul   %rdx,%rax
add    %rsi,%r11
cmp    %r10,%r8
fldt   (%r11)
fstpt  (%rsi,%rax,1)
jne    840 <gsl_permute_long_double+0x40>
fstpt  (%r11)
add    $0x1,%r8
add    %rdx,%rbx
cmp    %rcx,%r8
jne    810 <gsl_permute_long_double+0x10>
xor    %eax,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_long_double (const size_t * p, long double * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        long double t[1];
        for (a = 0; a < 1; a++)
          t[a] = data[i*stride*1 + a];
        while (pk != i)
          {
            for (a = 0; a < 1; a++)
              {
                long double r1 = data[pk*stride*1 + a];
                data[k*stride*1 + a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 1; a++)
          data[k*stride*1 + a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 2
5 2
6 4
7 6
8 7
9 7
10 7
11 8
12 7
13 7
14 9
15 9
16 11
17 12
18 12
19 18
20 18
21 18
22 18
23 27
24 23
25 27
26 23
27 24
28 23
29 19
30 23
31 24
32 19
33 30
34 4
35 4
36 4
37 4
38 34
39 34
40 34
41 34
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x5413,%esi
xor    %edi,%edi
mov    %rsp,%rdx
xor    %eax,%eax
callq  35 <getScreenSize+0x15>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 3f <getScreenSize+0x1f>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 4a <getScreenSize+0x2a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  589 <da_includes+0x9>
cmp    $0xffffffff,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
da_includes (struct darray * arr, const void * stuff)
{
  return (da_where (arr, stuff) != -1);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 3
7 4
8 4
<<<sep_out_sample>>>
cmp    $0x773593ff,%edi
mov    %edi,%eax
jg     1900 <uxfio_getfd+0x10>
retq   
nopl   0x0(%rax,%rax,1)
push   %rbx
mov    %rsi,%rbx
mov    $0x1,%edx
sub    $0x10,%rsp
lea    0x8(%rsp),%rsi
callq  1e0 <table_find>
test   %eax,%eax
jne    1950 <uxfio_getfd+0x60>
test   %rbx,%rbx
mov    0x8(%rsp),%rax
je     193c <uxfio_getfd+0x4c>
mov    0x50(%rax),%edx
test   %edx,%edx
je     1948 <uxfio_getfd+0x58>
mov    0x20(%rax),%rcx
cmp    %rcx,0x10(%rax)
jge    1948 <uxfio_getfd+0x58>
movl   $0x0,(%rbx)
mov    (%rax),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
movl   $0x1,(%rbx)
jmp    193c <uxfio_getfd+0x4c>
mov    $0xffffffff,%eax
jmp    193e <uxfio_getfd+0x4e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
uxfio_getfd(int uxfio_fildes, int * use_next)
{
 UXFIO *uxfio;
 ;
 if (uxfio_fildes < 2000000000) {
  return uxfio_fildes;
 }
 if (table_find(uxfio_fildes, &uxfio, 1)) {
  return -1;
 }
 if (use_next) {
  if (uxfio->buffer_activeM && (uxfio->posM < uxfio->endM)) {
   *use_next=0;
  } else {
   *use_next=1;
  }
 }
 return uxfio->uxfdM;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 19
5 19
6 2
7 2
8 8
9 2
10 8
11 8
12 8
13 8
14 11
15 12
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 13
24 18
25 19
26 19
27 19
28 19
29 15
30 15
31 9
32 9
33 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  1f6 <vgetcwd+0x16>
test   %rax,%rax
je     228 <vgetcwd+0x48>
mov    $0x0,%edi
callq  205 <vgetcwd+0x25>
test   %rax,%rax
je     228 <vgetcwd+0x48>
mov    %ebp,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  217 <vgetcwd+0x37>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  233 <vgetcwd+0x53>
test   %rax,%rax
cmovne %rbx,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
vgetcwd(char *buf, size_t size) {
 char *p;
 if (getenv("GTAGSLOGICALPATH")) {
  if ((p = getenv("PWD")) != ((void *)0)) {
   strlimcpy(buf, p, size);
   return buf;
  }
 }
 if (getcwd(buf, size) != ((void *)0))
  return buf;
 return ((void *)0);
}
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 3
6 1
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 12
19 6
20 12
21 12
22 12
23 12
24 9
25 9
26 9
27 10
28 10
29 12
30 12
31 12
32 12
<<<sep_out_sample>>>
push   %rbx
movslq %edi,%rbx
cmp    $0x13,%ebx
ja     348 <nodetype2str+0x18>
mov    0x0(,%rbx,8),%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  352 <nodetype2str+0x22>
mov    %ebx,%edx
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  363 <nodetype2str+0x33>
mov    $0x0,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nodetype2str(NODETYPE type)
{
 static char buf[40];
 if (type >= Node_illegal && type <= Node_final)
  return nodetypes[(int) type];
 sprintf(buf, gettext("unknown nodetype %d"), (int) type);
 return buf;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 8
7 8
8 8
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 7
17 8
18 8
19 8
<<<sep_out_sample>>>
mov    %esi,(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swutil_set_stderr_fd(SWLOG * swutil, int fd)
{
 swutil->swu_efdM = fd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x0(%rip),%r10        # 217 <find_hunk+0x7>
push   %rbx
mov    %rdi,%rax
mov    0x18(%rdi),%rsi
mov    0x20(%rdi),%rdi
lea    0x1(%r10,%r10,1),%r11
jmp    25f <find_hunk+0x4f>
nopw   0x0(%rax,%rax,1)
cmpb   $0x0,0x28(%rdx)
mov    0x18(%rdx),%rsi
mov    %r10,%r9
mov    %rsi,%rdi
cmove  %r11,%r9
sub    %rcx,%rdi
mov    %rdi,%rcx
mov    0x20(%rdx),%rdi
mov    %rdi,%rbx
sub    %r8,%rbx
cmp    %rbx,%rcx
jne    277 <find_hunk+0x67>
cmp    %r9,%rcx
jge    275 <find_hunk+0x65>
mov    %rdx,%rax
add    0x8(%rax),%rdi
mov    (%rax),%rdx
mov    %rsi,%rcx
add    0x10(%rax),%rcx
test   %rdx,%rdx
mov    %rdi,%r8
jne    230 <find_hunk+0x20>
pop    %rbx
retq   
callq  27c <find_hunk+0x6c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
find_hunk (struct change *start)
{
  struct change *prev;
  lin top0, top1;
  lin thresh;
  lin ignorable_threshold = context;
  lin non_ignorable_threshold = 2 * context + 1;
  do
    {
      top0 = start->line0 + start->deleted;
      top1 = start->line1 + start->inserted;
      prev = start;
      start = start->link;
      thresh = (start && start->ignore
  ? ignorable_threshold
  : non_ignorable_threshold);
      if (start && start->line0 - top0 != start->line1 - top1)
 abort ();
    } while (start
      && start->line0 - top0 < thresh);
  return prev;
}
<<<sep_in_sample>>>
1 6
2 2
3 2
4 2
5 2
6 7
7 7
8 7
9 16
10 17
11 16
12 17
13 16
14 17
15 17
16 17
17 17
18 17
19 17
20 17
21 20
22 20
23 20
24 11
25 13
26 10
27 10
28 16
29 11
30 16
31 22
32 22
33 18
34 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
cmp    $0x7fffffff,%rdx
jbe    e447 <_sse_ldi_d+0x27>
lea    0x7fffffff(%rdx),%rax
cmp    $0x7ffffffe,%rax
ja     e478 <_sse_ldi_d+0x58>
mov    %ebp,(%rsp)
mov    %edx,%ecx
mov    %rbx,%rdi
mov    $0x28,%r9d
mov    $0x28,%r8d
mov    $0x10,%edx
mov    $0xf2,%esi
callq  de0 <_ssexrx.constprop.74>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    $0x20000000,%esi
mov    %rdx,0x8(%rsp)
callq  e487 <_sse_ldi_d+0x67>
mov    %eax,%r12d
mov    0x8(%rsp),%rdx
mov    %rbx,%rdi
and    $0x7fff,%r12d
mov    %eax,%r13d
shl    $0x4,%r12
mov    0x0(%r12),%esi
and    $0x7fff,%esi
callq  2b60 <_movi>
mov    0x0(%r12),%r8d
mov    %ebp,(%rsp)
mov    %rbx,%rdi
mov    $0xf2,%esi
mov    $0x28,%r9d
xor    %ecx,%ecx
mov    $0x10,%edx
and    $0x7fff,%r8d
callq  de0 <_ssexrx.constprop.74>
add    $0x18,%rsp
mov    %rbx,%rdi
mov    %r13d,%esi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   e4f4 <_sse_ldi_d+0xd4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_sse_ldi_d(jit_state_t *_jit, jit_int32_t r0, jit_word_t i0)
{
    jit_int32_t reg;
    if ((((i0) >= 0 && (long long)(i0) <= 0x7fffffffLL) || ((i0) < 0 && (long long)(i0) > -0x80000000LL)))
 _ssexrx(_jit,0xf2,0x10,i0,_NOREG,_NOREG,0x00,r0);
    else {
 reg = _jit_get_reg(_jit,0x20000000);
 _movi(_jit, (((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)), i0);
 _ssexrx(_jit,0xf2,0x10,0,(((_rvs[((reg) & 0x00007fff)].spec) & 0x00007fff)),_NOREG,0x00,r0);
 _jit_unget_reg(_jit,reg);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 5
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 7
29 7
30 7
31 8
32 8
33 8
34 8
35 7
36 8
37 8
38 8
39 8
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 9
48 9
49 12
50 10
51 10
52 12
53 12
54 12
55 12
56 10
57 10
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    %rdx,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  1b <_asn1_str_cat+0x1b>
mov    %rbp,%rdi
mov    %rax,%r13
callq  26 <_asn1_str_cat+0x26>
mov    %rbx,%rdx
sub    %rax,%rdx
cmp    %rdx,%r13
jb     58 <_asn1_str_cat+0x58>
cmp    %rax,%rbx
je     4a <_asn1_str_cat+0x4a>
sub    $0x1,%rdx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  45 <_asn1_str_cat+0x45>
movb   $0x0,-0x1(%rbp,%rbx,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
add    $0x8,%rsp
lea    0x0(%rbp,%rax,1),%rdi
mov    %r12,%rsi
pop    %rbx
pop    %rbp
pop    %r12
lea    0x1(%r13),%rdx
pop    %r13
jmpq   73 <_asn1_str_cat+0x73>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_asn1_str_cat (char *dest, size_t dest_tot_size, const char *src)
{
  size_t str_size = strlen (src);
  size_t dest_size = strlen (dest);
  if (dest_tot_size - dest_size > str_size)
    {
      strcat (dest, src);
    }
  else
    {
      if (dest_tot_size - dest_size > 0)
 {
   strncat (dest, src, (dest_tot_size - dest_size) - 1);
   dest[dest_tot_size - 1] = 0;
 }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 2
9 2
10 3
11 4
12 3
13 4
14 5
15 5
16 5
17 5
18 11
19 11
20 13
21 13
22 13
23 13
24 14
25 17
26 17
27 17
28 17
29 17
30 17
31 17
32 17
33 7
34 7
35 17
36 17
37 17
38 7
39 17
40 7
41 7
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  40b <swicat_sr_create+0xb>
mov    $0x30,%edi
mov    %rax,%rbx
movq   $0x0,0x20(%rax)
movq   $0x0,0x18(%rax)
movq   $0x0,0x28(%rax)
movq   $0x0,0x38(%rax)
callq  438 <swicat_sr_create+0x38>
movq   $0x0,0x30(%rbx)
mov    %rax,0x40(%rbx)
mov    %rbx,%rax
movl   $0x0,0x48(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
swicat_sr_create(void)
{
 SWICAT_SR * sr;
 sr = (SWICAT_SR *)malloc(sizeof(SWICAT_SR));
 sr->lineM = ((void *)0);
 sr->bundleM = ((void *)0);
 sr->entry_lineM = ((void *)0);
 sr->swspecM = ((void *)0);
 sr->catalog_entry_pathM = strob_open(48);
 sr->seM = ((void *)0);
 sr->foundM = 0;
 return sr;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 9
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 9
13 13
14 11
15 13
16 13
<<<sep_out_sample>>>
test   %rdi,%rdi
je     a30 <osip_transaction_get_reserved3+0x10>
mov    0x2c50(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_transaction_get_reserved3 (osip_transaction_t * transaction)
{
  if (transaction == ((void *)0))
    return ((void *)0);
  return transaction->reserved3;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    28 <gsasl_callback+0x18>
test   %rsi,%rsi
jne    20 <gsasl_callback+0x10>
mov    $0x33,%eax
retq   
mov    (%rsi),%rdi
nopl   0x0(%rax,%rax,1)
mov    0x20(%rdi),%rax
test   %rax,%rax
je     38 <gsasl_callback+0x28>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
jmpq   3d <gsasl_callback+0x2d>
nopl   (%rax)
<<<sep_in_sample>>>
gsasl_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)
{
  if (ctx == ((void *)0) && sctx == ((void *)0))
    return GSASL_NO_CALLBACK;
  if (ctx == ((void *)0))
    ctx = sctx->ctx;
  if (ctx->cb)
    return ctx->cb (ctx, sctx, prop);
  return _gsasl_obsolete_callback (ctx, sctx, prop);
  return GSASL_NO_CALLBACK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 11
6 11
7 6
8 6
9 7
10 7
11 7
12 8
13 8
14 9
15 9
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   128 <delegate_name_fputs+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delegate_name_fputs (struct delegation *delegation, FILE * stream)
{
  fputs (delegation->name, stream);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
test   %rdi,%rdi
jne    2f0 <mu_address_concatenate+0x20>
mov    $0x16,%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
test   %rsi,%rsi
je     2dd <mu_address_concatenate+0xd>
mov    (%rsi),%rdx
mov    $0x16,%eax
test   %rdx,%rdx
jne    30b <mu_address_concatenate+0x3b>
jmp    2e2 <mu_address_concatenate+0x12>
nopl   0x0(%rax)
mov    %rax,%rbx
mov    0x38(%rbx),%rax
test   %rax,%rax
jne    308 <mu_address_concatenate+0x38>
mov    %rdx,0x38(%rbx)
movq   $0x0,(%rsi)
mov    (%rbx),%rdi
test   %rdi,%rdi
je     333 <mu_address_concatenate+0x63>
callq  32c <mu_address_concatenate+0x5c>
movq   $0x0,(%rbx)
mov    0x38(%rbx),%rbx
xor    %eax,%eax
mov    (%rbx),%rdi
test   %rdi,%rdi
je     2e2 <mu_address_concatenate+0x12>
mov    %eax,0xc(%rsp)
callq  34a <mu_address_concatenate+0x7a>
movq   $0x0,(%rbx)
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_address_concatenate (mu_address_t to, mu_address_t *from)
{
  if (!to || !from || !*from)
    return 22;
  while (to->next)
    to = to->next;
  ((to && !to->next) ? (void) (0) : __assert_fail ("to && !to->next", "address.c", 183, __PRETTY_FUNCTION__));
  to->next = *from;
  *from = ((void *)0);
  if (to->addr)
    {
      free (to->addr);
      to->addr = ((void *)0);
    }
  to = to->next;
  if (to->addr)
    {
      free (to->addr);
      to->addr = ((void *)0);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 22
8 22
9 22
10 22
11 3
12 3
13 3
14 4
15 3
16 3
17 3
18 3
19 5
20 5
21 5
22 5
23 8
24 9
25 10
26 10
27 10
28 12
29 13
30 15
31 21
32 16
33 16
34 16
35 16
36 18
37 19
38 19
39 22
40 22
41 22
42 22
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%r10d        # 4ceb <nc_hdy+0xb>
xor    %eax,%eax
movq   $0x0,0x0(%rip)        # 4cf8 <nc_hdy+0x18>
test   %r10d,%r10d
sete   %al
mov    %eax,0x0(%rip)        # 4d04 <nc_hdy+0x24>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  4d10 <nc_hdy+0x30>
mov    0x0(%rip),%r11d        # 4d17 <nc_hdy+0x37>
xor    %eax,%eax
test   %r11d,%r11d
sete   %al
mov    %eax,0x0(%rip)        # 4d25 <nc_hdy+0x45>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nc_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "NC";
  use_other_cc = !use_other_cc;
  fr_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 11
3 11
4 10
5 11
6 11
7 11
8 12
9 12
10 12
11 13
12 13
13 13
14 13
15 13
16 14
17 14
18 14
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  7f <gettext_quote+0xf>
mov    $0x0,%esi
mov    %rax,%rdi
mov    %rax,%rbx
callq  8f <gettext_quote+0x1f>
test   %eax,%eax
jne    b0 <gettext_quote+0x40>
cmpb   $0x60,0x0(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    %rbx,%rdi
callq  bd <gettext_quote+0x4d>
test   %eax,%eax
jne    e0 <gettext_quote+0x70>
cmpb   $0x60,0x0(%rbp)
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
cmp    $0x7,%r12d
mov    $0x0,%eax
mov    $0x0,%edx
pop    %rbp
cmovne %rdx,%rax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gettext_quote (char const *msgid, enum quoting_style s)
{
  char const *translation = ((const char *) (msgid));
  char const *locale_code;
  if (translation != msgid)
    return translation;
  locale_code = locale_charset ();
  if ((c_strcasecmp (locale_code, "UTF-8") == 0))
    return msgid[0] == '`' ? "\xe2\x80\x98": "\xe2\x80\x99";
  if ((c_strcasecmp (locale_code, "GB18030") == 0))
    return msgid[0] == '`' ? "\xa1\ae": "\xa1\xaf";
  return (s == clocale_quoting_style ? "\"" : "'");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 7
7 8
8 8
9 7
10 8
11 8
12 8
13 9
14 9
15 9
16 13
17 13
18 13
19 9
20 13
21 13
22 10
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 13
31 13
32 13
33 11
34 13
35 13
36 13
37 12
38 12
39 12
40 13
41 12
42 13
43 13
44 13
<<<sep_out_sample>>>
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
callq  242 <git_addfn+0x12>
mov    (%rax),%rsi
jmp    254 <git_addfn+0x24>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%eax
movsbq %al,%rcx
testb  $0x20,0x1(%rsi,%rcx,2)
jne    250 <git_addfn+0x20>
cmp    $0x23,%al
je     288 <git_addfn+0x58>
test   %al,%al
je     288 <git_addfn+0x58>
cmp    $0x5c,%al
nopl   0x0(%rax)
je     290 <git_addfn+0x60>
mov    %rbx,%rsi
mov    %rbp,%rdi
mov    %r12d,%edx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   284 <git_addfn+0x54>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
xor    %eax,%eax
cmpb   $0x23,0x1(%rbx)
sete   %al
add    %rax,%rbx
jmp    272 <git_addfn+0x42>
xchg   %ax,%ax
<<<sep_in_sample>>>
git_addfn (struct exclude *ex, char const *pattern, int options, void *data)
{
  while (((*__ctype_b_loc ())[(int) ((*pattern))] & (unsigned short int) _ISspace))
    ++pattern;
  if (*pattern == 0 || *pattern == '#')
    return;
  if (*pattern == '\\' && pattern[1] == '#')
    ++pattern;
  add_exclude (ex, pattern, options);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 4
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 5
20 7
21 7
22 7
23 9
24 9
25 9
26 10
27 10
28 10
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 8
37 8
38 8
39 8
40 8
41 8
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   67d <savedir_warn+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
savedir_warn (char const *name)
{
  call_arg_warn ("savedir", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%rcx
mov    0x10(%rdi),%rax
test   %r9,%r9
je     43c <gsl_matrix_complex_isnull+0x6c>
xorpd  %xmm0,%xmm0
shl    $0x4,%rax
mov    $0x8,%esi
mov    %rax,%r10
xor    %r8d,%r8d
test   %rcx,%rcx
je     430 <gsl_matrix_complex_isnull+0x60>
mov    %rsi,%rax
xor    %edx,%edx
add    0x18(%rdi),%rax
jmp    41f <gsl_matrix_complex_isnull+0x4f>
nopl   0x0(%rax,%rax,1)
jne    426 <gsl_matrix_complex_isnull+0x56>
ucomisd (%rax),%xmm0
jp     426 <gsl_matrix_complex_isnull+0x56>
jne    426 <gsl_matrix_complex_isnull+0x56>
add    $0x1,%rdx
add    $0x10,%rax
cmp    %rcx,%rdx
je     430 <gsl_matrix_complex_isnull+0x60>
ucomisd -0x8(%rax),%xmm0
jnp    408 <gsl_matrix_complex_isnull+0x38>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
add    $0x1,%r8
add    %r10,%rsi
cmp    %r9,%r8
jne    3f3 <gsl_matrix_complex_isnull+0x23>
mov    $0x1,%eax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_isnull (const gsl_matrix_complex * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 2; k++)
            {
              if (m->data[(i * tda + j) * 2 + k] != 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 9
16 9
17 9
18 13
19 13
20 13
21 13
22 9
23 9
24 9
25 9
26 13
27 13
28 15
29 15
30 15
31 7
32 7
33 7
34 7
35 20
36 20
37 20
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x5413,%esi
xor    %edi,%edi
mov    %rsp,%rdx
xor    %eax,%eax
callq  35 <getScreenSize+0x15>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 3f <getScreenSize+0x1f>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 4a <getScreenSize+0x2a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0xc,%edi
callq  58d <_rl_callback_data_alloc+0xd>
mov    %ebx,(%rax)
movl   $0x0,0x8(%rax)
movl   $0x0,0x4(%rax)
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
_rl_callback_data_alloc (count)
     int count;
{
  _rl_callback_generic_arg *arg;
  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;
  arg->i1 = arg->i2 = 0;
  return arg;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 7
7 7
8 9
9 9
10 9
<<<sep_out_sample>>>
movsd  0x18(%rdi),%xmm0
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_min_fminimizer_x_lower (const gsl_min_fminimizer * s)
{
  return s->x_lower;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1e <stratall_init+0xe>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
stratall_init(int argc, char **argv)
{
    dico_strategy_add(&all_strat);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 5
6 5
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   1460 <string_to_syslog_facility>
<<<sep_in_sample>>>
string_to_syslog_priority (const char *key, int *pres)
{
  static struct tokendef tokdef_prio[] = {
    {"EMERG", 0},
    {"ALERT", 1},
    {"CRIT", 2},
    {"ERR", 3},
    {"WARNING", 4},
    {"NOTICE", 5},
    {"INFO", 6},
    {"DEBUG", 7},
    {((void *)0)}
  };
  return strtotok_ci (tokdef_prio, key, pres);
}
<<<sep_in_sample>>>
1 2
2 14
3 14
4 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x50(%rdi),%rbx
test   %rbx,%rbx
je     25a <remote_mbox_destroy+0x2a>
mov    %rbx,%rdi
callq  24a <remote_mbox_destroy+0x1a>
mov    %rbx,%rdi
callq  252 <remote_mbox_destroy+0x22>
movq   $0x0,0x50(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
remote_mbox_destroy (mu_mailbox_t mailbox)
{
  if (mailbox->data)
    {
      struct remote_mbox_data *dat = mailbox->data;
      mu_mailer_destroy (&dat->mailer);
      free (dat);
      mailbox->data = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 6
9 6
10 7
11 7
12 8
13 10
14 10
15 10
16 10
17 10
<<<sep_out_sample>>>
push   %rbp
mov    $0x2e,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  293 <parse_level+0x13>
test   %rax,%rax
je     2e0 <parse_level+0x60>
lea    0x1(%rax),%rbp
mov    %rbx,%rdi
movb   $0x0,(%rax)
mov    $0x0,%edx
mov    $0x0,%esi
callq  2b1 <parse_level+0x31>
test   %rbp,%rbp
mov    %eax,%ebx
je     2f4 <parse_level+0x74>
mov    $0x0,%edx
mov    %rbp,%rdi
mov    $0x0,%esi
callq  2ca <parse_level+0x4a>
add    $0x8,%rsp
mov    %eax,%edx
mov    %ebx,%eax
and    $0x7,%edx
and    $0x3f8,%eax
pop    %rbx
or     %edx,%eax
pop    %rbp
retq   
nop
mov    %rbx,%rdi
mov    $0x0,%edx
mov    $0x0,%esi
callq  2f2 <parse_level+0x72>
mov    %eax,%ebx
mov    %ebx,%eax
add    $0x8,%rsp
mov    $0x5,%edx
and    $0x3f8,%eax
pop    %rbx
or     %edx,%eax
pop    %rbp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
parse_level (char *str)
{
  char *p;
  int fac, prio = 5;
  p = strchr (str, '.');
  if (p)
    *p++ = 0;
  fac = decode (str, facilitynames, "facility");
  if (p)
    prio = decode (p, prioritynames, "priority");
  return (((fac) & 0x03f8) | ((prio) & 0x07));
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 5
7 6
8 6
9 7
10 8
11 7
12 8
13 8
14 8
15 9
16 8
17 9
18 10
19 10
20 10
21 10
22 12
23 10
24 11
25 11
26 11
27 12
28 11
29 12
30 12
31 12
32 8
33 8
34 8
35 8
36 8
37 11
38 12
39 8
40 11
41 12
42 11
43 12
44 12
45 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  15e9 <yy_scan_string+0x9>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   15f4 <yy_scan_string+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     7e0 <gsasl_server_callback_securid_get+0x10>
mov    0x88(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_securid_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_securid : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  19 <_dup_lang_item+0x9>
mov    %rbx,%rdi
mov    %rax,%rsi
callq  24 <_dup_lang_item+0x14>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_dup_lang_item(void *item, void *data)
{
    char *lang = item;
    dico_list_t dst = data;
    xdico_list_append(dst, xstrdup(lang));
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1wrap ()
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  95c <gsl_sf_bessel_k1_scaled+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    970 <gsl_sf_bessel_k1_scaled+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0xeb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  986 <gsl_sf_bessel_k1_scaled+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_k1_scaled(const double x)
{
  gsl_sf_result result; int status = gsl_sf_bessel_k1_scaled_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_bessel_k1_scaled_e(x, &result)", "bessel_k.c", 235, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    0x68(%rdi),%ecx
xor    %edx,%edx
xor    %eax,%eax
test   %ecx,%ecx
jle    2b35 <panel_unselect_all+0x25>
nopl   0x0(%rax,%rax,1)
mov    0x38(%rdi),%rcx
add    $0x1,%eax
movb   $0x0,0x49(%rcx,%rdx,1)
add    $0x50,%rdx
cmp    %eax,0x68(%rdi)
jg     2b20 <panel_unselect_all+0x10>
movl   $0x0,0x70(%rdi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
panel_unselect_all(this)
    panel_t *this;
{
    int entry;
    for (entry = 0; entry < this->entries; entry++)
 this->dir_entry[entry].selected = 0;
    this->selected_entries = 0;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 5
9 6
10 6
11 5
12 5
13 7
14 7
15 7
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
test   %r10,%r10
mov    (%rdi),%rax
je     1130 <gsl_matrix_ulong_max+0x60>
push   %rbx
lea    0x0(,%r9,8),%rbx
shl    $0x3,%r11
xor    %r8d,%r8d
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     1123 <gsl_matrix_ulong_max+0x53>
lea    (%rdi,%rbx,1),%rsi
mov    %rdi,%rdx
nopl   0x0(%rax)
mov    (%rdx),%rcx
cmp    %rcx,%rax
cmovb  %rcx,%rax
add    $0x8,%rdx
cmp    %rsi,%rdx
jne    1110 <gsl_matrix_ulong_max+0x40>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
jne    1100 <gsl_matrix_ulong_max+0x30>
pop    %rbx
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_max (const gsl_matrix_ulong * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned long max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned long x = m->data[i * tda + j];
          if (x > max)
            max = x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 8
6 6
7 8
8 2
9 2
10 2
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 10
23 10
24 8
25 8
26 8
27 8
28 18
29 18
30 18
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  266 <ET_main+0x16>
test   %eax,%eax
jne    2a0 <ET_main+0x50>
xor    %edx,%edx
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  0 <run>
test   %eax,%eax
je     288 <ET_main+0x38>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    $0x2,%edx
jmpq   0 <run>
xchg   %ax,%ax
callq  2a5 <ET_main+0x55>
mov    (%rax),%edi
callq  2ac <ET_main+0x5c>
mov    0x0(%rip),%rdi        # 2b3 <ET_main+0x63>
mov    %rax,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  2c2 <ET_main+0x72>
jmp    26a <ET_main+0x1a>
<<<sep_in_sample>>>
ET_main (const char *plugin_name,
  struct ProblemSet *ps)
{
  int ret;
  if (0 != putenv ("LIBEXTRACTOR_PREFIX=." ":" ".libs/"))
    fprintf (stderr,
      "Failed to update my environment, plugin loading may fail: %s\n",
      strerror ((*__errno_location ())));
  ret = run (plugin_name, ps, EXTRACTOR_OPTION_DEFAULT_POLICY);
  if (0 != ret)
    return ret;
  ret = run (plugin_name, ps, EXTRACTOR_OPTION_IN_PROCESS);
  if (0 != ret)
    return ret;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 5
6 3
7 5
8 5
9 5
10 9
11 9
12 9
13 9
14 10
15 10
16 16
17 16
18 16
19 16
20 16
21 16
22 12
23 12
24 16
25 16
26 12
27 12
28 12
29 8
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 6
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0xe0(%rdi),%rsi
mov    %rdi,%rbx
test   %rsi,%rsi
je     2ad0 <topsf_check_header_list+0x70>
mov    0xe8(%rdi),%rdi
callq  2a85 <topsf_check_header_list+0x25>
mov    0xe8(%rbx),%rdi
mov    %r12,%rsi
callq  2a94 <topsf_check_header_list+0x34>
mov    0xe8(%rbx),%rdi
callq  2aa0 <topsf_check_header_list+0x40>
mov    %rbp,%rsi
mov    %rax,%rdx
mov    %rbx,%rdi
callq  2aae <topsf_check_header_list+0x4e>
test   %eax,%eax
mov    $0x1,%edx
js     2ac6 <topsf_check_header_list+0x66>
mov    0x60(%rbx),%rdi
mov    $0x32,%dl
mov    %eax,%esi
callq  2ac4 <topsf_check_header_list+0x64>
xor    %edx,%edx
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   (%rax)
mov    %rbp,%rsi
callq  2ad8 <topsf_check_header_list+0x78>
jmp    2aae <topsf_check_header_list+0x4e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topsf_check_header_list(TOPSF * topsf, STRAR * list, char * archive_name)
{
 char *s1;
 int ret;
 int i = 0;
 if (topsf->rpmtag_default_prefixM) {
  ;
  strob_strcpy(topsf->usebuf1M, topsf->rpmtag_default_prefixM);
  swlib_unix_dircat(topsf->usebuf1M, archive_name);
  ;
  ret = topsf_search_list(topsf, list, strob_str(topsf->usebuf1M));
 } else {
  ;
  ret = topsf_search_list(topsf, list, archive_name);
 }
 if (ret >= 0) {
  strob_chr_index(topsf->file_status_arrayM, ret, 50);
  return 0;
 } else {
  return 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 6
7 2
8 6
9 6
10 8
11 8
12 9
13 9
14 9
15 11
16 11
17 11
18 11
19 11
20 11
21 16
22 20
23 16
24 17
25 17
26 17
27 17
28 18
29 22
30 22
31 22
32 22
33 22
34 22
35 14
36 14
37 14
38 14
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <hash_string_compare+0x9>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string_compare (void const *name1, void const *name2)
{
  return strcmp (name1, name2) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <_cred_free+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
_cred_free(void *item, void *data)
{
    free(item);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <getcoordinate+0x9>
xor    %ecx,%ecx
cmp    $0x1,%eax
mov    %eax,%edx
je     28 <getcoordinate+0x28>
lea    -0x20(%rdx,%rcx,1),%ecx
xor    %eax,%eax
cmp    $0x20,%edx
cmovge %ecx,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  2d <getcoordinate+0x2d>
mov    $0x5f,%ecx
mov    %eax,%edx
jmp    12 <getcoordinate+0x12>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
getcoordinate(void)
{
 int c, next;
 c = mygetch();
 next = 0;
 if (c == ('A' & 037)) {
  next = 95;
  c = mygetch();
 }
 if (c < ' ') {
  return (0);
 }
 return (next + c - ' ');
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 6
5 4
6 6
7 13
8 11
9 13
10 13
11 14
12 14
13 14
14 8
15 7
16 8
17 8
18 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%eax
test   %rdi,%rdi
cmovne %rdi,%rax
mov    %rax,%rdi
callq  a78 <newstr+0x18>
test   %rax,%rax
je     a82 <newstr+0x22>
add    $0x8,%rsp
retq   
mov    $0x3,%edi
mov    $0x0,%esi
callq  a91 <newstr+0x31>
or     $0xffffffff,%edi
callq  a99 <newstr+0x39>
nopl   0x0(%rax)
<<<sep_in_sample>>>
newstr (const char *cp)
{
  char *s;
  s = strdup (cp ? cp : "");
  if (s != ((void *)0))
    return s;
  syslog (3, "strdup: %m");
  exit (-1);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 9
10 9
11 7
12 7
13 7
14 8
15 8
16 8
<<<sep_out_sample>>>
jmpq   740 <_new_node>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_new_node_no_link(jit_state_t *_jit, jit_code_t code)
{
    ((void) (0));
    return (_new_node(_jit, code));
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x8(%rax),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_min_size(const gsl_interp2d * interp)
{
  return interp->type->min_size;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x38,%rsp
test   %rdx,%rdx
fldt   (%rdi)
je     f0 <gsl_stats_long_double_min+0x70>
shl    $0x4,%rsi
xor    %ebx,%ebx
mov    %rsi,%r13
lea    (%rdi,%rsi,1),%rbp
fld    %st(0)
jmp    c3 <gsl_stats_long_double_min+0x43>
nopl   (%rax)
fstp   %st(0)
add    $0x1,%rbx
cmp    %r12,%rbx
fldt   0x20(%rsp)
je     f0 <gsl_stats_long_double_min+0x70>
fldt   0x0(%rbp)
fxch   %st(1)
fucomi %st(1),%st
fcmovnbe %st(1),%st
add    %r13,%rbp
fstpt  0x20(%rsp)
fld    %st(0)
fstpt  (%rsp)
fstpt  0x10(%rsp)
callq  d5 <gsl_stats_long_double_min+0x55>
test   %eax,%eax
fldt   0x10(%rsp)
je     a8 <gsl_stats_long_double_min+0x28>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_long_double_min (const long double data[], const size_t stride,
                          const size_t n)
{
  long double min = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      long double xi = data[i * stride];
      if (xi < min)
        min = xi;
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        return xi;
    }
  return min;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 4
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 6
19 6
20 6
21 6
22 8
23 8
24 8
25 8
26 8
27 8
28 11
29 11
30 11
31 11
32 11
33 11
34 11
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpmErrorString(void)
{
    return errorRec.string;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
callq  851 <_mime_body_transport+0x11>
mov    %rax,%rdi
callq  859 <_mime_body_transport+0x19>
mov    %rax,%rdi
callq  861 <_mime_body_transport+0x21>
mov    %rax,%rcx
movq   $0x0,0x8(%rsp)
mov    $0x16,%eax
cmpq   $0x0,0x30(%rcx)
jne    880 <_mime_body_transport+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
cmpq   $0x0,0x48(%rcx)
je     879 <_mime_body_transport+0x39>
mov    0x50(%rcx),%rdx
mov    0x38(%rcx),%rax
lea    0x8(%rsp),%rsi
mov    (%rax,%rdx,8),%rax
mov    0x8(%rax),%rdi
callq  8a1 <_mime_body_transport+0x61>
mov    0x8(%rsp),%rdi
mov    %rbp,%rdx
mov    %rbx,%rsi
callq  8b1 <_mime_body_transport+0x71>
jmp    879 <_mime_body_transport+0x39>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mime_body_transport (mu_stream_t stream, mu_transport_t *tr1,
        mu_transport_t *tr2)
{
  mu_body_t body = mu_stream_get_owner (stream);
  mu_message_t msg = mu_body_get_owner (body);
  mu_mime_t mime = mu_message_get_owner (msg);
  mu_stream_t msg_stream = ((void *)0);
  if (mime->nmtp_parts == 0 || mime->cur_offset == 0)
    return 22;
  mu_message_get_stream (mime->mtp_parts[mime->cur_part]->msg, &msg_stream);
  return mu_stream_get_transport2 (msg_stream, tr1, tr2);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 6
11 6
12 7
13 9
14 8
15 8
16 12
17 12
18 12
19 12
20 8
21 8
22 10
23 10
24 10
25 10
26 10
27 10
28 11
29 11
30 11
31 11
32 11
33 11
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
push   %rbx
mov    %rdi,%rbx
je     12b <treedelta+0x3b>
mov    (%rdi),%rdi
mov    %esi,%ebp
mov    %rdx,%r12
callq  f0 <treedelta>
mov    0x8(%rbx),%rdi
mov    %r12,%rdx
mov    %ebp,%esi
callq  f0 <treedelta>
movzbl 0x18(%rbx),%eax
add    %rax,%r12
movzbl (%r12),%eax
cmp    %eax,%ebp
jae    12b <treedelta+0x3b>
mov    %bpl,(%r12)
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
treedelta (register struct tree const *tree,
           register unsigned int depth,
           unsigned char delta[])
{
  if (!tree)
    return;
  treedelta (tree->llink, depth, delta);
  treedelta (tree->rlink, depth, delta);
  if (depth < delta[tree->label])
    delta[tree->label] = depth;
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 4
5 4
6 5
7 7
8 7
9 7
10 7
11 8
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 9
20 10
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %esi,%ebx
sub    $0x8,%rsp
test   %esi,%esi
js     6187 <info_global_prev_node+0x37>
jne    6172 <info_global_prev_node+0x22>
jmp    6180 <info_global_prev_node+0x30>
nopl   0x0(%rax,%rax,1)
sub    $0x1,%ebx
nopl   0x0(%rax,%rax,1)
je     6180 <info_global_prev_node+0x30>
xor    %esi,%esi
mov    %rbp,%rdi
callq  4460 <backward_move_node_structure>
test   %eax,%eax
je     6168 <info_global_prev_node+0x18>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
add    $0x8,%rsp
neg    %esi
pop    %rbx
pop    %rbp
jmpq   6194 <info_global_prev_node+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_global_prev_node (WINDOW *window, int count)
{
  if (count < 0)
    info_global_next_node (window, -count);
  else
    {
      while (count)
        {
          if (backward_move_node_structure (window, 0))
            break;
          count--;
        }
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 7
9 7
10 7
11 7
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 14
20 14
21 14
22 14
23 14
24 4
25 14
26 14
27 4
28 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0xd8,%rsp
lea    0x10(%rsp),%rdi
movq   $0x0,(%rsp)
movq   $0x0,0x8(%rsp)
mov    %fs:0x28,%rax
mov    %rax,0xc8(%rsp)
xor    %eax,%eax
callq  18d <chk_sha+0x3d>
mov    %rbp,%rdi
callq  195 <chk_sha+0x45>
lea    0x10(%rsp),%rdx
mov    %rax,%rsi
mov    %rbp,%rdi
callq  1a5 <chk_sha+0x55>
lea    0xb0(%rsp),%rsi
lea    0x10(%rsp),%rdi
callq  1b7 <chk_sha+0x67>
mov    %rbx,%rdi
callq  1bf <chk_sha+0x6f>
lea    0x8(%rsp),%rdx
mov    %rsp,%rcx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  1d2 <chk_sha+0x82>
test   %eax,%eax
jne    238 <chk_sha+0xe8>
cmpq   $0x14,(%rsp)
jne    220 <chk_sha+0xd0>
mov    0x8(%rsp),%rbx
lea    0xb0(%rsp),%rdi
mov    $0x14,%edx
mov    %rbx,%rsi
callq  1f7 <chk_sha+0xa7>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  201 <chk_sha+0xb1>
mov    %ebp,%eax
mov    0xc8(%rsp),%rcx
xor    %fs:0x28,%rcx
jne    23f <chk_sha+0xef>
add    $0xd8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x8(%rsp),%rdi
callq  22a <chk_sha+0xda>
mov    $0xffffffff,%eax
jmp    203 <chk_sha+0xb3>
nopl   0x0(%rax)
mov    $0xffffffff,%eax
jmp    203 <chk_sha+0xb3>
callq  244 <chk_sha+0xf4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chk_sha(const char *db_pass, const char *pass)
{
    int rc;
    unsigned char sha1digest[20];
    struct sha1_ctx sha1context;
    size_t size = 0;
    unsigned char *buf = ((void *)0);
    sha1_init_ctx(&sha1context);
    sha1_process_bytes(pass, strlen(pass), &sha1context);
    sha1_finish_ctx(&sha1context, sha1digest);
    if (dico_base64_decode((unsigned char *)db_pass, strlen(db_pass),
      &buf, &size))
 return -1;
    if (size != 20) {
 free(buf);
 return -1;
    }
    rc = memcmp(sha1digest, buf, sizeof sha1digest);
    free(buf);
    return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 8
7 6
8 7
9 2
10 2
11 2
12 8
13 9
14 9
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 14
32 14
33 18
34 18
35 18
36 18
37 18
38 19
39 18
40 19
41 20
42 21
43 21
44 21
45 21
46 21
47 21
48 21
49 15
50 15
51 16
52 16
53 16
54 13
55 13
56 21
57 21
<<<sep_out_sample>>>
movsbl %sil,%edx
mov    $0xffffffffffffffff,%rsi
jmpq   1560 <quotearg_colon>
<<<sep_in_sample>>>
quotearg_char (char const *arg, char ch)
{
  return quotearg_char_mem (arg, ((size_t) -1), ch);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
jmpq   b50 <quotearg_n_options>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rcx,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rdx
callq  1521 <mu_header_get_field_name+0x21>
test   %eax,%eax
mov    %eax,%ebp
jne    155f <mu_header_get_field_name+0x5f>
mov    0x8(%rsp),%r15
mov    %r15,%rdi
callq  1534 <mu_header_get_field_name+0x34>
test   %r12,%r12
mov    %rax,%rbx
je     1556 <mu_header_get_field_name+0x56>
cmp    %r14,%rax
mov    %r15,%rsi
mov    %r12,%rdi
cmova  %r14,%rbx
mov    %rbx,%rdx
callq  1551 <mu_header_get_field_name+0x51>
movb   $0x0,(%r12,%rbx,1)
test   %r13,%r13
je     155f <mu_header_get_field_name+0x5f>
mov    %rbx,0x0(%r13)
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
<<<sep_in_sample>>>
mu_header_get_field_name (mu_header_t header, size_t num, char *buffer,
     size_t buflen, size_t *pn)
{
  const char *s;
  int status = mu_header_sget_field_name (header, num, &s);
  if (status == 0)
    {
      size_t slen = strlen (s);
      if (buffer)
 {
   if (slen > buflen)
     slen = buflen;
   memcpy (buffer, s, slen);
   buffer[slen] = 0;
 }
      if (pn)
 *pn = slen;
    }
  return status;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 5
12 5
13 6
14 5
15 6
16 8
17 8
18 8
19 9
20 8
21 9
22 9
23 13
24 13
25 13
26 13
27 13
28 14
29 16
30 16
31 17
32 20
33 20
34 20
35 20
36 20
37 20
38 20
39 20
40 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x8(%rsi),%rcx
cmp    0x8(%rdi),%rcx
jne    2e0 <gsl_combination_memcpy+0x40>
mov    (%rdi),%rax
cmp    %rax,(%rsi)
jne    2e0 <gsl_combination_memcpy+0x40>
test   %rcx,%rcx
je     2d9 <gsl_combination_memcpy+0x39>
mov    0x10(%rdi),%rdi
mov    0x10(%rsi),%rsi
xor    %eax,%eax
nopl   (%rax)
mov    (%rsi,%rax,8),%rdx
mov    %rdx,(%rdi,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    2c8 <gsl_combination_memcpy+0x28>
xor    %eax,%eax
add    $0x8,%rsp
retq   
mov    $0x13,%ecx
mov    $0x9f,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2f9 <gsl_combination_memcpy+0x59>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_combination_memcpy (gsl_combination * dest, const gsl_combination * src)
{
   const size_t src_n = src->n;
   const size_t src_k = src->k;
   const size_t dest_n = dest->n;
   const size_t dest_k = dest->k;
   if (src_n != dest_n || src_k != dest_k)
     {
       do { gsl_error ("combination lengths are not equal", "combination.c", 159, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
     }
   {
     size_t j;
     for (j = 0; j < src_k; j++)
       {
         dest->data[j] = src->data[j];
       }
   }
   return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 4
3 7
4 7
5 7
6 7
7 7
8 13
9 13
10 13
11 13
12 13
13 13
14 15
15 15
16 13
17 13
18 13
19 18
20 19
21 19
22 9
23 9
24 9
25 9
26 9
27 9
28 19
29 19
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x48,%rsp
lea    0x18(%rsp),%r8
lea    0x10(%rsp),%rcx
lea    0x8(%rsp),%rdx
mov    %rsp,%rsi
callq  23d <print_rcs_hunk+0x1d>
test   %eax,%eax
mov    %eax,%ebx
jne    250 <print_rcs_hunk+0x30>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  255 <print_rcs_hunk+0x35>
mov    0x8(%rsp),%rdx
mov    (%rsp),%rsi
lea    0x28(%rsp),%r8
lea    0x20(%rsp),%rcx
mov    $0x0,%edi
callq  272 <print_rcs_hunk+0x52>
test   $0x1,%bl
je     2a5 <print_rcs_hunk+0x85>
mov    0x20(%rsp),%rdx
mov    0x28(%rsp),%rax
mov    $0x1,%ecx
cmp    %rax,%rdx
jg     292 <print_rcs_hunk+0x72>
sub    %rdx,%rax
lea    0x1(%rax),%rcx
mov    0x0(%rip),%rdi        # 299 <print_rcs_hunk+0x79>
mov    $0x0,%esi
xor    %eax,%eax
callq  2a5 <print_rcs_hunk+0x85>
and    $0x2,%ebx
je     243 <print_rcs_hunk+0x23>
mov    0x18(%rsp),%rdx
mov    0x10(%rsp),%rsi
lea    0x30(%rsp),%rcx
lea    0x38(%rsp),%r8
mov    $0x0,%edi
callq  2c8 <print_rcs_hunk+0xa8>
mov    0x30(%rsp),%rax
mov    0x38(%rsp),%rdx
mov    $0x1,%ecx
cmp    %rdx,%rax
jg     2e3 <print_rcs_hunk+0xc3>
sub    %rax,%rdx
lea    0x1(%rdx),%rcx
mov    0x28(%rsp),%rdx
mov    0x0(%rip),%rdi        # 2ef <print_rcs_hunk+0xcf>
xor    %eax,%eax
mov    $0x0,%esi
callq  2fb <print_rcs_hunk+0xdb>
mov    0x10(%rsp),%rbx
cmp    0x18(%rsp),%rbx
jg     243 <print_rcs_hunk+0x23>
lea    0x0(,%rbx,8),%rbp
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rsi
add    0x0(%rip),%rsi        # 322 <print_rcs_hunk+0x102>
mov    $0x0,%edi
add    $0x1,%rbx
add    $0x8,%rbp
callq  334 <print_rcs_hunk+0x114>
cmp    %rbx,0x18(%rsp)
jge    318 <print_rcs_hunk+0xf8>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_rcs_hunk (struct change *hunk)
{
  lin i, f0, l0, f1, l1;
  long int tf0, tl0, tf1, tl1;
  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
  if (!changes)
    return;
  begin_output ();
  translate_range (&files[0], f0, l0, &tf0, &tl0);
  if (changes & OLD)
    {
      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
    }
  if (changes & NEW)
    {
      translate_range (&files[1], f1, l1, &tf1, &tl1);
      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
      for (i = f1; i <= l1; i++)
 print_1_line ("", &files[1].linbuf[i]);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 5
7 5
8 5
9 6
10 5
11 6
12 21
13 21
14 21
15 21
16 21
17 8
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 14
38 14
39 16
40 16
41 16
42 16
43 16
44 16
45 17
46 17
47 17
48 17
49 17
50 17
51 17
52 17
53 17
54 17
55 17
56 17
57 18
58 18
59 18
60 18
61 18
62 19
63 19
64 19
65 18
66 18
67 19
68 18
69 18
70 21
71 21
72 21
73 21
74 21
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_open(dico_handle_t dp)
{
    return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  e89 <sdp_message_a_att_value_get+0x9>
test   %rax,%rax
je     ea0 <sdp_message_a_att_value_get+0x20>
mov    0x8(%rax),%rax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    e92 <sdp_message_a_att_value_get+0x12>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_a_att_value_get (sdp_message_t * sdp, int pos_media, int pos)
{
  sdp_attribute_t *attr = sdp_message_attribute_get (sdp, pos_media, pos);
  if (attr == ((void *)0))
    return ((void *)0);
  return attr->a_att_value;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 6
6 7
7 7
8 7
9 5
10 5
11 5
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     d54 <gsl_vector_long_double_add_constant+0x34>
movsd  %xmm0,-0x10(%rsp)
mov    0x10(%rdi),%rax
shl    $0x4,%rsi
xor    %edx,%edx
fldl   -0x10(%rsp)
fldt   (%rax)
add    $0x1,%rdx
fadd   %st(1),%st
fstpt  (%rax)
add    %rsi,%rax
cmp    %rcx,%rdx
jne    d40 <gsl_vector_long_double_add_constant+0x20>
fstp   %st(0)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_double_add_constant (gsl_vector_long_double * a, const double x)
{
  const size_t N = a->size;
  const size_t stride = a->stride;
  size_t i;
  for (i = 0; i < N; i++)
    {
      a->data[i * stride] += x;
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 8
11 6
12 8
13 8
14 8
15 6
16 6
17 6
18 11
19 11
20 11
<<<sep_out_sample>>>
mov    $0x1,%eax
test   %rsi,%rsi
cmovne %rsi,%rax
mov    %rax,(%rdi)
retq   
<<<sep_in_sample>>>
random8_bsd_set (void *vstate, unsigned long int s)
{
  random8_state_t *state = (random8_state_t *) vstate;
  if (s == 0)
    s = 1;
  state->x = s;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 6
5 6
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # a6 <tty_israw+0x6>
shr    %eax
xor    $0x1,%eax
and    $0x1,%eax
retq   
nop
<<<sep_in_sample>>>
tty_israw (void)
{
  return !(termbuf.c_lflag & 0000002);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x0,(%rdi)
lea    0x8(%rdi),%rdi
callq  53 <sexp_compound_token_init+0x13>
lea    0x30(%rbx),%rdi
pop    %rbx
jmpq   5d <sexp_compound_token_init+0x1d>
nopl   (%rax)
<<<sep_in_sample>>>
sexp_compound_token_init(struct sexp_compound_token *token)
{
  token->type = 0;
  nettle_buffer_init(&token->display);
  nettle_buffer_init(&token->string);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 6
8 5
9 5
<<<sep_out_sample>>>
mov    0x28(%rdi),%rdi
mov    0x1a8(%rdi),%rax
jmpq   *%rax
nopl   (%rax)
<<<sep_in_sample>>>
__db_set_errpfx(dbp, errpfx)
 DB *dbp;
 const char *errpfx;
{
 dbp->dbenv->set_errpfx(dbp->dbenv, errpfx);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  269 <parse_nouser+0x9>
movl   $0x3a83126f,0x24(%rax)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_nouser (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  (void) argv;
  (void) arg_ptr;
  our_pred = insert_primary_noarg (entry);
  our_pred->est_success_rate = 1e-3;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 6
3 7
4 9
5 9
6 9
7 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
movsd  (%rbx),%xmm0
mov    %rsp,%rdi
callq  1804 <gsl_sf_angle_restrict_pos_e+0x14>
movsd  (%rsp),%xmm0
movsd  %xmm0,(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_angle_restrict_pos_e(double * theta)
{
  gsl_sf_result r;
  int stat = gsl_sf_angle_restrict_pos_err_e(*theta, &r);
  *theta = r.val;
  return stat;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 5
8 5
9 7
10 7
11 7
12 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     f9 <mu_attribute_set_modified+0x9>
orl    $0x40,0x8(%rdi)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_attribute_set_modified (mu_attribute_t attr)
{
  if (attr)
    attr->flags |= 0x40;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 6
5 6
6 6
<<<sep_out_sample>>>
push   %r14
test   %rsi,%rsi
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
jne    da0 <csv_fwrite2+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
test   %rdi,%rdi
mov    %rdi,%r12
je     d90 <csv_fwrite2+0x10>
movzbl %cl,%r14d
mov    %rdi,%rsi
mov    %rdx,%rbp
mov    %r14d,%edi
mov    %ecx,%r13d
callq  dbd <csv_fwrite2+0x3d>
cmp    $0xffffffff,%eax
je     e15 <csv_fwrite2+0x95>
test   %rbp,%rbp
jne    dea <csv_fwrite2+0x6a>
jmp    e28 <csv_fwrite2+0xa8>
nopl   0x0(%rax)
movzbl %al,%edi
mov    %r12,%rsi
callq  ddb <csv_fwrite2+0x5b>
cmp    $0xffffffff,%eax
je     e15 <csv_fwrite2+0x95>
add    $0x1,%rbx
sub    $0x1,%rbp
je     e28 <csv_fwrite2+0xa8>
movzbl (%rbx),%eax
cmp    %r13b,%al
jne    dd0 <csv_fwrite2+0x50>
mov    %r12,%rsi
mov    %r14d,%edi
callq  dfd <csv_fwrite2+0x7d>
cmp    $0xffffffff,%eax
je     e15 <csv_fwrite2+0x95>
movzbl (%rbx),%eax
mov    %r12,%rsi
movzbl %al,%edi
callq  e10 <csv_fwrite2+0x90>
cmp    $0xffffffff,%eax
jne    de0 <csv_fwrite2+0x60>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0xffffffff,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r12,%rsi
mov    %r14d,%edi
callq  e33 <csv_fwrite2+0xb3>
pop    %rbx
pop    %rbp
cmp    $0xffffffff,%eax
sete   %al
pop    %r12
movzbl %al,%eax
pop    %r13
neg    %eax
pop    %r14
retq   
<<<sep_in_sample>>>
csv_fwrite2 (FILE *fp, const void *src, size_t src_size, unsigned char quote)
{
  const unsigned char *csrc = src;
  if (fp == ((void *)0) || src == ((void *)0))
    return 0;
  if (fputc(quote, fp) == (-1))
    return (-1);
  while (src_size) {
    if (*csrc == quote) {
      if (fputc(quote, fp) == (-1))
        return (-1);
    }
    if (fputc(*csrc, fp) == (-1))
      return (-1);
    src_size--;
    csrc++;
  }
  if (fputc(quote, fp) == (-1)) {
    return (-1);
  }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 22
10 22
11 22
12 22
13 5
14 22
15 22
16 22
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 8
29 8
30 8
31 8
32 13
33 13
34 13
35 13
36 13
37 16
38 8
39 8
40 9
41 9
42 9
43 10
44 10
45 10
46 10
47 10
48 10
49 13
50 13
51 13
52 13
53 13
54 22
55 22
56 22
57 22
58 7
59 22
60 22
61 22
62 18
63 18
64 18
65 22
66 22
67 18
68 18
69 22
70 18
71 22
72 18
73 22
74 22
<<<sep_out_sample>>>
test   %rdi,%rdi
je     35a <meta1_flush_buffer+0x4a>
mov    0x8(%rdi),%rax
movl   $0x0,0x20(%rdi)
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
movl   $0x1,0x2c(%rdi)
movl   $0x0,0x3c(%rdi)
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 348 <meta1_flush_buffer+0x38>
test   %rax,%rax
je     35a <meta1_flush_buffer+0x4a>
mov    0x0(%rip),%rdx        # 354 <meta1_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
je     360 <meta1_flush_buffer+0x50>
repz retq 
nopl   0x0(%rax)
jmpq   c0 <meta1_load_buffer_state>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
meta1_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  meta1_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 6
6 7
7 7
8 8
9 9
10 10
11 8
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
mov    (%rdi),%rdx
test   %rdx,%rdx
je     1c7 <gsl_histogram_sum+0x27>
mov    0x10(%rdi),%rax
xorpd  %xmm0,%xmm0
lea    (%rax,%rdx,8),%rdx
nopl   0x0(%rax)
addsd  (%rax),%xmm0
add    $0x8,%rax
cmp    %rdx,%rax
jne    1b8 <gsl_histogram_sum+0x18>
repz retq 
xorpd  %xmm0,%xmm0
retq   
<<<sep_in_sample>>>
gsl_histogram_sum(const gsl_histogram * h)
{
  double sum=0;
  size_t i=0;
  size_t n;
  n=h->n;
  while(i < n)
    sum += h->bin[i++];
  return sum;
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 3
6 3
7 3
8 8
9 8
10 7
11 7
12 7
13 3
14 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    $0x0,%edi
callq  401 <GetVarHandle+0x11>
test   %rax,%rax
je     410 <GetVarHandle+0x20>
mov    0x10(%rax),%rax
add    $0x8,%rsp
retq   
nop
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetVarHandle (PSTR szName)
{
  PVMMAPSTRCT pvm = GetVarPtr (vrgvmGlo, szName);
  return (pvm ? pvm->hvar : 0x00000);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 5
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
callq  d <openat_save_fail+0xd>
mov    0x0(%rip),%edi        # 13 <openat_save_fail+0x13>
mov    %rax,%rdx
mov    %ebx,%esi
xor    %eax,%eax
callq  1f <openat_save_fail+0x1f>
callq  24 <openat_save_fail+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
openat_save_fail (int errnum)
{
  error (exit_failure, errnum,
         gettext ("unable to record current working directory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 3
6 3
7 3
8 3
9 3
10 5
11 5
<<<sep_out_sample>>>
push   %r14
xor    %edx,%edx
mov    %esi,%r14d
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
callq  1580 <findEntry>
test   %rax,%rax
je     3860 <headerRemoveEntry+0xd0>
mov    0x0(%r13),%rdx
cmp    %rdx,%rax
jbe    386e <headerRemoveEntry+0xde>
mov    -0x20(%rax),%ecx
mov    %rax,%rbx
cmp    %r14d,%ecx
je     37d5 <headerRemoveEntry+0x45>
jmp    37de <headerRemoveEntry+0x4e>
nopl   0x0(%rax,%rax,1)
cmp    %ecx,-0x20(%rbx)
jne    37de <headerRemoveEntry+0x4e>
sub    $0x20,%rbx
cmp    %rdx,%rbx
ja     37d0 <headerRemoveEntry+0x40>
movslq 0x8(%r13),%rbp
mov    (%rbx),%r12d
shl    $0x5,%rbp
add    %rdx,%rbp
cmp    %r14d,%r12d
jne    383f <headerRemoveEntry+0xaf>
cmp    %rbx,%rbp
ja     3805 <headerRemoveEntry+0x75>
jmp    383f <headerRemoveEntry+0xaf>
nopl   0x0(%rax,%rax,1)
cmp    %rbp,%rbx
jae    383b <headerRemoveEntry+0xab>
mov    0x10(%rbx),%rdi
sub    $0x20,%rbp
add    $0x20,%rbx
callq  3816 <headerRemoveEntry+0x86>
mov    0x0(%rbp),%rax
cmp    %r12d,(%rbx)
mov    %rax,-0x20(%rbx)
mov    0x8(%rbp),%rax
mov    %rax,-0x18(%rbx)
mov    0x10(%rbp),%rax
mov    %rax,-0x10(%rbx)
mov    0x18(%rbp),%rax
mov    %rax,-0x8(%rbx)
je     3800 <headerRemoveEntry+0x70>
mov    0x0(%r13),%rdx
sub    %rdx,%rbp
movl   $0x0,0x10(%r13)
xor    %eax,%eax
sar    $0x5,%rbp
mov    %ebp,0x8(%r13)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    $0x1,%eax
pop    %r14
retq   
mov    %rax,%rbx
jmpq   37de <headerRemoveEntry+0x4e>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
headerRemoveEntry(Header h, int_32 tag)
{
    struct indexEntry * entry, * last;
    entry = findEntry(h, tag, 0);
    if (!entry) return 1;
    while (entry > h->index && (entry - 1)->info.tag == tag)
 entry--;
    last = h->index + h->indexUsed;
    while (entry->info.tag == tag && entry < last) {
 free(entry->data);
 *(entry++) = *(--last);
    }
    h->indexUsed = last - h->index;
    h->sorted = 0;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 7
24 6
25 6
26 8
27 9
28 8
29 8
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 10
39 11
40 11
41 10
42 11
43 9
44 11
45 11
46 11
47 11
48 11
49 11
50 11
51 9
52 9
53 13
54 14
55 15
56 13
57 13
58 16
59 16
60 16
61 16
62 16
63 16
64 16
65 16
66 16
67 16
68 16
69 5
70 16
71 16
72 6
73 6
74 6
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 2b <argp_version_setup+0xb>
mov    %rdi,0x0(%rip)        # 32 <argp_version_setup+0x12>
mov    %rsi,0x0(%rip)        # 39 <argp_version_setup+0x19>
retq   
<<<sep_in_sample>>>
argp_version_setup (const char *name, const char * const *authors)
{
  argp_program_version_hook = version_etc_hook;
  program_canonical_name = name;
  program_authors = authors;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x10(%rdi),%rax
mov    (%rax),%rdx
mov    0x18(%rdi),%rax
mov    (%rax),%rax
cmp    %rax,(%rsi)
je     2b0 <gsl_multifit_fdfsolver_jac+0x40>
mov    $0x13,%ecx
mov    $0xfb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2a0 <gsl_multifit_fdfsolver_jac+0x30>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
cmp    %rdx,0x8(%rsi)
jne    287 <gsl_multifit_fdfsolver_jac+0x17>
mov    (%rdi),%rax
mov    0x40(%rdi),%rdi
mov    0x30(%rax),%rax
add    $0x8,%rsp
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fdfsolver_jac (gsl_multifit_fdfsolver * s, gsl_matrix * J)
{
  const size_t n = s->f->size;
  const size_t p = s->x->size;
  if (n != J->size1 || p != J->size2)
    {
      do { gsl_error ("Jacobian dimensions do not match solver", "fdfsolver.c", 251, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      return (s->type->jac) (s->state, J);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 3
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 13
14 13
15 13
16 13
17 5
18 5
19 11
20 11
21 11
22 13
23 11
24 11
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rcx,%r13
push   %r12
mov    %r8d,%r12d
push   %rbp
mov    %edx,%ebp
push   %rbx
callq  1580 <findEntry>
test   %rax,%rax
mov    %rax,%rbx
je     36c2 <headerAppendEntry+0x22>
cmp    $0x6,%ebp
jne    36d0 <headerAppendEntry+0x30>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   (%rax)
cmp    $0x9,%ebp
je     36c2 <headerAppendEntry+0x22>
xor    %ecx,%ecx
mov    %r12d,%edx
mov    %r13,%rsi
mov    %ebp,%edi
callq  1150 <dataLength>
mov    0x18(%rbx),%esi
mov    0x10(%rbx),%rdi
mov    %eax,%r14d
add    %eax,%esi
movslq %esi,%rsi
callq  36f8 <headerAppendEntry+0x58>
test   %rax,%rax
je     3730 <headerAppendEntry+0x90>
movslq 0x18(%rbx),%rsi
mov    %rax,0x10(%rbx)
mov    %r14d,%r8d
mov    %r12d,%ecx
mov    %r13,%rdx
mov    %ebp,%edi
add    %rax,%rsi
callq  90 <copyData>
add    %r14d,0x18(%rbx)
add    %r12d,0xc(%rbx)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
callq  3735 <headerAppendEntry+0x95>
jmp    36fd <headerAppendEntry+0x5d>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
headerAppendEntry(Header h, int_32 tag, int_32 type, void * p, int_32 c)
{
    struct indexEntry *entry;
    int length;
    entry = findEntry(h, tag, type);
    if (!entry) {
 return 0;
    }
    if (type == 6 || type == 9) {
 return 0;
    }
    length = dataLength(type, p, c, 0);
    entry->data = (realloc((entry->data), (entry->length + length)) ? : vmefail());
    copyData(type, ((char *) entry->data) + entry->length, p, c, length);
    entry->length += length;
    entry->info.count += c;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 6
11 5
12 6
13 9
14 9
15 18
16 18
17 18
18 18
19 18
20 18
21 18
22 18
23 9
24 9
25 12
26 12
27 12
28 12
29 12
30 13
31 13
32 12
33 13
34 13
35 13
36 13
37 13
38 14
39 13
40 14
41 14
42 14
43 14
44 14
45 14
46 15
47 16
48 18
49 18
50 18
51 18
52 18
53 18
54 18
55 18
56 13
57 13
58 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm2        # c <gsl_odeiv2_driver_set_hmin+0xc>
movsd  0x20(%rdi),%xmm1
andpd  %xmm2,%xmm0
andpd  %xmm2,%xmm1
ucomisd %xmm1,%xmm0
ja     38 <gsl_odeiv2_driver_set_hmin+0x38>
ucomisd 0x30(%rdi),%xmm0
ja     38 <gsl_odeiv2_driver_set_hmin+0x38>
movsd  %xmm0,0x28(%rdi)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0x71,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  51 <gsl_odeiv2_driver_set_hmin+0x51>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv2_driver_set_hmin (gsl_odeiv2_driver * d, const double hmin)
{
  if ((fabs (hmin) > fabs (d->h)) || (fabs (hmin) > d->hmax))
    {
      do { gsl_error ("hmin <= fabs(h) <= hmax required", "driver.c", 113, GSL_EINVAL) ; return 0 ; } while (0);
    }
  d->hmin = fabs (hmin);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 7
11 9
12 9
13 9
14 9
15 5
16 5
17 5
18 5
19 5
20 9
21 9
22 9
23 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x1028(%rdi),%r12d
mov    %rdi,%rbx
test   %r12d,%r12d
jne    3df8 <is_getc+0x98>
mov    0x1014(%rdi),%eax
mov    0x1010(%rdi),%ecx
cmp    %ecx,%eax
jb     3e22 <is_getc+0xc2>
mov    0x1018(%rdi),%edx
lea    0x10(%rdi),%rbp
nopl   (%rax)
test   %edx,%edx
je     3da4 <is_getc+0x44>
cmp    $0xfff,%ecx
jbe    3e18 <is_getc+0xb8>
mov    0x8(%rbx),%rcx
mov    $0x1000,%edx
mov    $0x1,%esi
mov    %rbp,%rdi
callq  3dba <is_getc+0x5a>
mov    0x1018(%rbx),%esi
test   %eax,%eax
mov    %eax,%ecx
mov    %eax,0x1010(%rbx)
movl   $0x0,0x1014(%rbx)
lea    0x1(%rsi),%edx
mov    %edx,0x1018(%rbx)
je     3d98 <is_getc+0x38>
mov    $0x1,%edx
mov    %edx,0x1014(%rbx)
movzbl 0x10(%rbx,%r12,1),%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
sub    $0x1,%r12d
mov    0x1020(%rdi),%rax
mov    %r12d,0x1028(%rdi)
pop    %rbx
pop    %rbp
movzbl (%rax,%r12,1),%eax
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
lea    0x1(%rax),%edx
mov    %eax,%r12d
jmp    3de4 <is_getc+0x84>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
is_getc (InputStream *is)
{
  int ch;
  if (is->unget_pos > 0)
    {
      ch = is->unget_ch[--is->unget_pos];
      return ch;
    }
 retry:
  if (is->bufpos >= is->data_in_buf)
    {
      if (is->nreads > 0 && is->data_in_buf < sizeof (is->buf))
 return (-1);
      is->data_in_buf = fread (is->buf, 1, sizeof (is->buf), is->fp);
      is->bufpos = 0;
      is->nreads++;
      goto retry;
    }
  return is->buf[is->bufpos++];
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 10
9 10
10 10
11 10
12 10
13 14
14 14
15 12
16 12
17 12
18 12
19 14
20 14
21 14
22 14
23 14
24 16
25 10
26 14
27 14
28 15
29 16
30 16
31 10
32 10
33 19
34 19
35 20
36 20
37 20
38 20
39 20
40 6
41 6
42 6
43 20
44 20
45 6
46 20
47 20
48 20
49 20
50 20
51 13
52 20
53 20
54 20
55 10
56 10
57 10
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
callq  11c6 <__osip_uri_unescape+0x16>
test   %rax,%rax
lea    0x1(%rax),%r12
je     126d <__osip_uri_unescape+0xbd>
mov    %r13,%rbp
xor    %ebx,%ebx
jmp    1204 <__osip_uri_unescape+0x54>
nopw   0x0(%rax,%rax,1)
mov    %dl,0x0(%r13,%rbx,1)
mov    %rax,%rdx
lea    0x1(%rbx),%r14d
add    $0x1,%rbp
add    $0x1,%rbx
sub    $0x1,%rdx
je     1288 <__osip_uri_unescape+0xd8>
mov    %rax,%r12
mov    %rdx,%rax
movzbl 0x0(%rbp),%edx
movslq %ebx,%r14
cmp    $0x25,%dl
jne    11e0 <__osip_uri_unescape+0x30>
cmp    $0x2,%rax
jbe    1270 <__osip_uri_unescape+0xc0>
lea    0x1(%rbp),%r15
lea    0xc(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r15,%rdi
callq  122e <__osip_uri_unescape+0x7e>
cmp    $0x1,%eax
jne    1270 <__osip_uri_unescape+0xc0>
movzbl 0x2(%rbp),%eax
movzbl 0xc(%rsp),%edx
test   %al,%al
je     1260 <__osip_uri_unescape+0xb0>
lea    -0x30(%rax),%ecx
cmp    $0x9,%cl
jbe    1252 <__osip_uri_unescape+0xa2>
and    $0xffffffdf,%eax
sub    $0x41,%eax
cmp    $0x5,%al
ja     1260 <__osip_uri_unescape+0xb0>
lea    -0x3(%r12),%rax
add    $0x2,%rbp
jmp    11e0 <__osip_uri_unescape+0x30>
nopl   (%rax)
lea    -0x2(%r12),%rax
mov    %r15,%rbp
jmpq   11e0 <__osip_uri_unescape+0x30>
xor    %r14d,%r14d
movb   $0x0,0x0(%r13,%r14,1)
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
movslq %r14d,%r14
jmp    1270 <__osip_uri_unescape+0xc0>
nopl   (%rax)
<<<sep_in_sample>>>
__osip_uri_unescape (char *string)
{
  size_t alloc = strlen (string) + 1;
  unsigned char in;
  int index = 0;
  unsigned int hex;
  char *ptr;
  ptr = string;
  while (--alloc > 0) {
    in = *ptr;
    if ('%' == in) {
      if (alloc > 2 && sscanf (ptr + 1, "%02X", &hex) == 1) {
        in = (unsigned char) hex;
        if (*(ptr + 2) && ((*(ptr + 2) >= '0' && *(ptr + 2) <= '9') || (*(ptr + 2) >= 'a' && *(ptr + 2) <= 'f') || (*(ptr + 2) >= 'A' && *(ptr + 2) <= 'F'))) {
          alloc -= 2;
          ptr += 2;
        }
        else {
          alloc -= 1;
          ptr += 1;
        }
      }
      else {
        break;
      }
    }
    string[index++] = in;
    ptr++;
  }
  string[index] = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 9
11 3
12 9
13 8
14 9
15 9
16 9
17 27
18 9
19 9
20 28
21 28
22 9
23 9
24 9
25 9
26 10
27 10
28 11
29 11
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
38 12
39 12
40 14
41 13
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 14
50 14
51 15
52 16
53 16
54 16
55 19
56 20
57 20
58 9
59 30
60 31
61 31
62 31
63 31
64 31
65 31
66 31
67 31
68 31
69 31
70 31
71 31
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1407 <afmget_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
afmget_out (void)
{
        return afmout;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r15
mov    %edx,%eax
push   %r14
mov    %r9d,%r14d
push   %r13
mov    %r8,%r13
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %ecx,%ebx
sub    $0x48,%rsp
movq   $0x0,0x0(%rip)        # a4c9 <ca_sa_hdy+0x29>
mov    0x80(%rsp),%r15d
mov    %eax,0x30(%rsp)
mov    %r15d,(%rsp)
callq  a4de <ca_sa_hdy+0x3e>
mov    0x30(%rsp),%eax
mov    %r14d,%r9d
mov    %r15d,(%rsp)
mov    %r13,%r8
mov    %ebx,%ecx
mov    %r12d,%esi
mov    %rbp,%rdi
mov    %eax,%edx
callq  0 <ca_base_hdy>
mov    %ebx,%edx
mov    $0x1,%r8d
mov    $0x8,%esi
mov    $0x1,%ecx
mov    $0x1,%edi
callq  a517 <ca_sa_hdy+0x77>
mov    0x0(%rip),%rcx        # a51e <ca_sa_hdy+0x7e>
mov    0x0(%rip),%rdi        # a525 <ca_sa_hdy+0x85>
mov    %eax,0x3c(%rsp)
mov    %rcx,0x30(%rsp)
callq  a533 <ca_sa_hdy+0x93>
mov    %r15d,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    %r12d,%esi
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
mov    $0x0,%r8d
movl   $0x8,(%rsp)
mov    0x3c(%rsp),%r9d
mov    %rax,%rdx
mov    0x30(%rsp),%rcx
mov    0x0(%rbp),%edi
callq  a56b <ca_sa_hdy+0xcb>
add    $0x48,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ca_sa_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "CA_SA";
  ca_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  ca_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (1, 8, year, 1, (0==0));
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "+", day, 8, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 11
15 9
16 12
17 12
18 12
19 13
20 13
21 13
22 13
23 13
24 13
25 13
26 13
27 13
28 14
29 14
30 14
31 14
32 14
33 14
34 15
35 15
36 14
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 15
49 15
50 15
51 17
52 17
53 17
54 17
55 17
56 17
57 17
58 17
59 17
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x70,%rsp
mov    0x0(%rip),%rax        # bef <ds_define_nth+0xf>
mov    %rax,(%rsp)
mov    0x0(%rip),%rax        # bfa <ds_define_nth+0x1a>
mov    %rax,0x8(%rsp)
mov    0x0(%rip),%rax        # c06 <ds_define_nth+0x26>
mov    %rax,0x10(%rsp)
mov    0x0(%rip),%rax        # c12 <ds_define_nth+0x32>
mov    %rax,0x18(%rsp)
mov    0x0(%rip),%rax        # c1e <ds_define_nth+0x3e>
mov    %rax,0x20(%rsp)
mov    0x0(%rip),%rax        # c2a <ds_define_nth+0x4a>
mov    %rax,0x28(%rsp)
mov    0x0(%rip),%rax        # c36 <ds_define_nth+0x56>
mov    %rax,0x30(%rsp)
mov    0x0(%rip),%rax        # c42 <ds_define_nth+0x62>
mov    %rax,0x38(%rsp)
mov    0x0(%rip),%rax        # c4e <ds_define_nth+0x6e>
mov    %rax,0x40(%rsp)
mov    0x0(%rip),%rax        # c5a <ds_define_nth+0x7a>
mov    %rax,0x48(%rsp)
mov    0x0(%rip),%rax        # c66 <ds_define_nth+0x86>
mov    %rax,0x50(%rsp)
mov    0x0(%rip),%rax        # c72 <ds_define_nth+0x92>
mov    %rax,0x58(%rsp)
mov    0x0(%rip),%rax        # c7e <ds_define_nth+0x9e>
mov    %rax,0x60(%rsp)
callq  c88 <ds_define_nth+0xa8>
test   %eax,%eax
jne    cb9 <ds_define_nth+0xd9>
mov    0x0(%rip),%rdi        # c93 <ds_define_nth+0xb3>
mov    0xb8(%rdi),%rax
test   %rax,%rax
je     cf0 <ds_define_nth+0x110>
cmp    %rbx,0x18(%rax)
ja     cc0 <ds_define_nth+0xe0>
mov    $0x0,%edi
callq  caf <ds_define_nth+0xcf>
mov    %rax,%rdi
xor    %eax,%eax
callq  cb9 <ds_define_nth+0xd9>
add    $0x70,%rsp
pop    %rbx
retq   
nop
movl   $0x0,0x40(%rsp)
shl    $0x4,%rbx
add    0x28(%rax),%rbx
mov    %rsp,%rsi
mov    (%rbx),%rax
mov    %rax,0x50(%rsp)
mov    0x8(%rbx),%rax
mov    %rax,0x48(%rsp)
callq  ce9 <ds_define_nth+0x109>
add    $0x70,%rsp
pop    %rbx
retq   
nop
mov    $0x0,%edi
callq  cfa <ds_define_nth+0x11a>
mov    %rax,%rdi
xor    %eax,%eax
callq  d04 <ds_define_nth+0x124>
jmp    cb9 <ds_define_nth+0xd9>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_define_nth(size_t num)
{
    struct dico_url url = dico_url;
    if (ensure_connection())
 return;
    if (!conn->match_result) {
 script_error(gettext ("No previous match"));
 return;
    }
    if (num >= conn->match_result->count) {
 script_error(gettext ("Invalid match number.  Type / to see the matches."));
 return;
    }
    url.req.type = 0;
    url.req.database = conn->match_result->set.mat[num].database;
    url.req.word = conn->match_result->set.mat[num].word;
    dict_lookup(conn, &url);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 3
19 3
20 3
21 3
22 3
23 3
24 3
25 3
26 3
27 3
28 3
29 3
30 4
31 4
32 4
33 6
34 6
35 6
36 6
37 10
38 10
39 11
40 11
41 11
42 11
43 11
44 18
45 18
46 18
47 18
48 14
49 15
50 15
51 17
52 15
53 15
54 16
55 16
56 17
57 18
58 18
59 18
60 18
61 7
62 7
63 7
64 7
65 7
66 8
67 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  17e9 <yy_scan_string+0x9>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   17f4 <yy_scan_string+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_scan_string (const char * yystr )
{
 return yy_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
xor    %edx,%edx
mov    $0x0,%esi
jmpq   25c <destroy_assoc_list+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
destroy_assoc_list (ANUBIS_LIST *plist)
{
  list_destroy (plist, _assoc_free, ((void *)0));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   5 <__rtan+0x5>
<<<sep_in_sample>>>
__rtan (double r)
{
  return (tan (r));
}
<<<sep_in_sample>>>
1 3
<<<sep_out_sample>>>
push   %r15
mov    %r8,%r15
push   %r14
mov    %ecx,%r14d
push   %r13
mov    %edx,%r13d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %r9d,%ebx
sub    $0x18,%rsp
movq   $0x0,0x0(%rip)        # b90b <ch_fr_hdy+0x2b>
mov    0x50(%rsp),%eax
mov    %eax,(%rsp)
callq  1f0 <ch_base_hdy>
mov    0x0(%rip),%eax        # b91d <ch_fr_hdy+0x3d>
xor    %edx,%edx
mov    %ebx,%r9d
mov    %r15,%r8
mov    %r14d,%ecx
mov    %r12d,%esi
mov    %rbp,%rdi
test   %eax,%eax
mov    0x50(%rsp),%eax
sete   %dl
mov    %edx,0x0(%rip)        # b93d <ch_fr_hdy+0x5d>
mov    %r13d,%edx
mov    %eax,(%rsp)
callq  b948 <ch_fr_hdy+0x68>
mov    0x0(%rip),%edx        # b94e <ch_fr_hdy+0x6e>
xor    %eax,%eax
test   %edx,%edx
sete   %al
mov    %eax,0x0(%rip)        # b95b <ch_fr_hdy+0x7b>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ch_fr_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_FR";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
  ch_ai_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  use_other_cc = !use_other_cc;
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 9
14 10
15 11
16 11
17 11
18 12
19 12
20 13
21 13
22 13
23 13
24 13
25 12
26 13
27 12
28 12
29 13
30 13
31 13
32 14
33 14
34 14
35 14
36 14
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
lea    0x1(%rsi),%edi
push   %r13
movslq %edi,%rdi
mov    %esi,%r13d
push   %r12
push   %rbp
mov    %edx,%ebp
push   %rbx
callq  21b <splitString+0x1b>
test   %rax,%rax
mov    %rax,%r12
je     2e9 <splitString+0xe9>
test   %r13d,%r13d
jle    2cc <splitString+0xcc>
xor    %ecx,%ecx
mov    $0x1,%ebx
nopw   0x0(%rax,%rax,1)
movzbl (%r14,%rcx,1),%r8d
xor    %edx,%edx
cmp    %bpl,%r8b
mov    %r8b,(%r12,%rcx,1)
sete   %dl
add    $0x1,%rcx
add    %edx,%ebx
cmp    %ecx,%r13d
jg     240 <splitString+0x40>
lea    -0x1(%r13),%eax
lea    0x1(%rbx),%edi
lea    0x1(%r12,%rax,1),%rax
movslq %edi,%rdi
shl    $0x3,%rdi
movb   $0x0,(%rax)
callq  277 <splitString+0x77>
test   %rax,%rax
je     2e2 <splitString+0xe2>
cmp    $0x1,%ebx
mov    %r12,(%rax)
je     2db <splitString+0xdb>
lea    0x1(%r12),%rcx
mov    $0x1,%edx
jmp    298 <splitString+0x98>
add    $0x1,%rcx
cmp    %ebx,%edx
jge    2b4 <splitString+0xb4>
cmp    %bpl,-0x1(%rcx)
jne    290 <splitString+0x90>
movslq %edx,%rsi
add    $0x1,%edx
mov    %rcx,(%rax,%rsi,8)
movb   $0x0,-0x1(%rcx)
add    $0x1,%rcx
cmp    %ebx,%edx
jl     298 <splitString+0x98>
movslq %edx,%rdx
shl    $0x3,%rdx
movq   $0x0,(%rax,%rdx,1)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
mov    %r12,%rax
mov    $0x10,%edi
mov    $0x1,%ebx
jmp    26f <splitString+0x6f>
mov    $0x8,%edx
jmp    2bb <splitString+0xbb>
callq  2e7 <splitString+0xe7>
jmp    27c <splitString+0x7c>
nopl   0x0(%rax)
callq  2f5 <splitString+0xf5>
mov    %rax,%r12
jmpq   227 <splitString+0x27>
nopl   (%rax)
<<<sep_in_sample>>>
splitString(const char * str, int length, char sep)
{
    const char * source;
    char * s, * dest;
    char ** list;
    int i;
    int fields;
    s = (malloc(length + 1) ? : vmefail());
    fields = 1;
    for (source = str, dest = s, i = 0; i < length; i++, source++, dest++) {
 *dest = *source;
 if (*dest == sep) fields++;
    }
    *dest = '\0';
    list = (malloc(sizeof(char *) * (fields + 1)) ? : vmefail());
    dest = s;
    list[0] = dest;
    i = 1;
    while (i < fields) {
 if (*dest == sep) {
     list[i++] = dest + 1;
     *dest = 0;
 }
 dest++;
    }
    list[i] = ((void *)0);
    return list;
}
<<<sep_in_sample>>>
1 2
2 2
3 8
4 2
5 8
6 2
7 2
8 2
9 2
10 2
11 8
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 11
21 12
22 12
23 11
24 12
25 12
26 12
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 14
35 15
36 15
37 15
38 19
39 17
40 19
41 19
42 18
43 18
44 18
45 19
46 19
47 20
48 20
49 21
50 21
51 21
52 22
53 22
54 19
55 19
56 19
57 19
58 26
59 28
60 28
61 28
62 28
63 28
64 28
65 10
66 10
67 9
68 9
69 19
70 19
71 15
72 15
73 15
74 8
75 8
76 8
77 8
<<<sep_out_sample>>>
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   8dd <write_error+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
write_error (char const *name)
{
  call_arg_error ("write", name);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1db9 <killPlayerEx+0x9>
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
killPlayerEx(craft * c,...)
{
 return killPlayer(c);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 86b <yypop_buffer_state+0xb>
test   %rbx,%rbx
je     8b7 <yypop_buffer_state+0x57>
mov    0x0(%rip),%rbp        # 877 <yypop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     8b7 <yypop_buffer_state+0x57>
callq  889 <yypop_buffer_state+0x29>
test   %rbp,%rbp
movq   $0x0,(%r12)
je     8b7 <yypop_buffer_state+0x57>
sub    $0x1,%rbp
cmpq   $0x0,(%rbx,%rbp,8)
mov    %rbp,0x0(%rip)        # 8a6 <yypop_buffer_state+0x46>
je     8b7 <yypop_buffer_state+0x57>
callq  0 <yy_load_buffer_state>
movl   $0x1,0x0(%rip)        # 8b7 <yypop_buffer_state+0x57>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
yypop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 yy_delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  yy_load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 7
14 6
15 7
16 8
17 9
18 8
19 9
20 10
21 11
22 13
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
push   %rbx
xor    %eax,%eax
mov    %rdi,%rbx
mov    $0x0,%edi
callq  580 <print_dst_unreach+0x10>
movzbl 0x1(%rbx),%esi
mov    $0x0,%eax
cmp    (%rax),%esi
je     5b0 <print_dst_unreach+0x40>
add    $0x10,%rax
cmp    $0x0,%rax
jb     589 <print_dst_unreach+0x19>
pop    %rbx
mov    $0x0,%edi
xor    %eax,%eax
jmpq   5a6 <print_dst_unreach+0x36>
nopw   %cs:0x0(%rax,%rax,1)
pop    %rbx
mov    0x8(%rax),%rdi
jmpq   5ba <print_dst_unreach+0x4a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
print_dst_unreach (struct icmp6_hdr *icmp6)
{
  struct icmp_code_descr *p;
  printf ("Destination unreachable: ");
  for (p = icmp_dest_unreach_desc;
       p < icmp_dest_unreach_desc + sizeof(icmp_dest_unreach_desc)/sizeof((icmp_dest_unreach_desc)[0]); p++)
    {
      if (p->code == icmp6->icmp6_code)
 {
   puts (p->diag);
   return;
 }
    }
  printf ("Unknown code %d\n", icmp6->icmp6_code);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 5
8 8
9 8
10 6
11 5
12 5
13 15
14 14
15 14
16 14
17 14
18 15
19 10
20 10
21 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x2,%edi
callq  63 <cgt_time_start+0x13>
test   %eax,%eax
js     6c <cgt_time_start+0x1c>
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
callq  75 <cgt_time_start+0x25>
mov    (%rax),%edi
callq  7c <cgt_time_start+0x2c>
mov    $0x0,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  8b <cgt_time_start+0x3b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cgt_time_start(void)
{
  if (clock_gettime(2, &cgt_start) < 0)
    die("clock_gettime failed: %s\n", strerror((*__errno_location ())));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 5
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
<<<sep_out_sample>>>
jmpq   2a5 <CDB___ua_memcpy+0x5>
<<<sep_in_sample>>>
CDB___ua_memcpy(dst, src, len)
 void *dst;
 const void *src;
 size_t len;
{
 return (memcpy(dst, src, len));
}
<<<sep_in_sample>>>
1 6
<<<sep_out_sample>>>
jmpq   2c5 <change_winsize+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
change_winsize(int sig)
{
  get_winsize();
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
sub    $0x58,%rsp
xorpd  %xmm0,%xmm0
movsd  %xmm2,(%rsp)
movsd  %xmm3,0x18(%rsp)
ucomisd %xmm3,%xmm0
ja     1e0 <gsl_ran_fdist_pdf+0x160>
movsd  0x0(%rip),%xmm5        # a9 <gsl_ran_fdist_pdf+0x29>
movapd %xmm1,%xmm0
movsd  %xmm1,0x28(%rsp)
mulsd  %xmm1,%xmm5
movsd  %xmm5,0x8(%rsp)
callq  c2 <gsl_ran_fdist_pdf+0x42>
movsd  (%rsp),%xmm4
movsd  0x0(%rip),%xmm6        # cf <gsl_ran_fdist_pdf+0x4f>
movsd  %xmm0,0x20(%rsp)
movapd %xmm4,%xmm0
mulsd  %xmm4,%xmm6
movsd  %xmm6,0x10(%rsp)
callq  e8 <gsl_ran_fdist_pdf+0x68>
movsd  0x28(%rsp),%xmm1
movsd  (%rsp),%xmm4
movsd  0x20(%rsp),%xmm2
addsd  %xmm1,%xmm4
mulsd  0x10(%rsp),%xmm0
movsd  %xmm1,0x40(%rsp)
mulsd  0x8(%rsp),%xmm2
mulsd  0x0(%rip),%xmm4        # 117 <gsl_ran_fdist_pdf+0x97>
addsd  %xmm0,%xmm2
movapd %xmm4,%xmm0
movsd  %xmm4,0x38(%rsp)
movsd  %xmm2,0x48(%rsp)
callq  130 <gsl_ran_fdist_pdf+0xb0>
movsd  %xmm0,0x20(%rsp)
movsd  0x8(%rsp),%xmm0
callq  141 <gsl_ran_fdist_pdf+0xc1>
movsd  %xmm0,0x28(%rsp)
movsd  0x10(%rsp),%xmm0
callq  152 <gsl_ran_fdist_pdf+0xd2>
movsd  0x18(%rsp),%xmm3
movsd  %xmm0,0x10(%rsp)
movapd %xmm3,%xmm0
movsd  %xmm3,0x30(%rsp)
callq  16d <gsl_ran_fdist_pdf+0xed>
movsd  0x40(%rsp),%xmm1
movsd  0x30(%rsp),%xmm3
movsd  %xmm0,0x18(%rsp)
mulsd  %xmm3,%xmm1
movsd  (%rsp),%xmm0
addsd  %xmm1,%xmm0
callq  191 <gsl_ran_fdist_pdf+0x111>
movsd  0x48(%rsp),%xmm2
movsd  0x20(%rsp),%xmm1
movsd  0x38(%rsp),%xmm4
addsd  %xmm2,%xmm1
movsd  0x8(%rsp),%xmm2
mulsd  %xmm4,%xmm0
subsd  0x0(%rip),%xmm2        # 1b9 <gsl_ran_fdist_pdf+0x139>
subsd  0x28(%rsp),%xmm1
mulsd  0x18(%rsp),%xmm2
subsd  0x10(%rsp),%xmm1
add    $0x58,%rsp
addsd  %xmm2,%xmm1
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
jmpq   1e0 <gsl_ran_fdist_pdf+0x160>
add    $0x58,%rsp
retq   
<<<sep_in_sample>>>
gsl_ran_fdist_pdf (const double x, const double nu1, const double nu2)
{
  if (x < 0)
    {
      return 0 ;
    }
  else
    {
      double p;
      double lglg = (nu1 / 2) * log (nu1) + (nu2 / 2) * log (nu2) ;
      double lg12 = gsl_sf_lngamma ((nu1 + nu2) / 2);
      double lg1 = gsl_sf_lngamma (nu1 / 2);
      double lg2 = gsl_sf_lngamma (nu2 / 2);
      p =
 exp (lglg + lg12 - lg1 - lg2 + (nu1 / 2 - 1) * log (x) -
      ((nu1 + nu2) / 2) * log (nu2 + nu1 * x));
      return p;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 3
6 3
7 3
8 10
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 11
22 11
23 10
24 11
25 10
26 11
27 10
28 11
29 10
30 11
31 11
32 10
33 11
34 11
35 12
36 12
37 12
38 13
39 13
40 15
41 13
42 15
43 15
44 15
45 16
46 16
47 15
48 16
49 16
50 16
51 16
52 15
53 15
54 16
55 15
56 15
57 16
58 15
59 15
60 15
61 15
62 19
63 15
64 15
65 14
66 14
67 19
68 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmmalloca+0x9>
test   %rax,%rax
je     13 <xmmalloca+0x13>
add    $0x8,%rsp
retq   
callq  18 <xmmalloca+0x18>
<<<sep_in_sample>>>
xmmalloca (size_t n)
{
  void *p;
  p = mmalloca (n);
  if (p == ((void *)0))
    xalloc_die ();
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 8
6 8
7 6
<<<sep_out_sample>>>
push   %r14
mov    %rsi,%r14
mov    $0x0,%esi
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
mov    %r14,%rdi
push   %rbx
callq  1b <locate_unset+0x1b>
mov    0x0(%rbp),%rbx
test   %rbx,%rbx
je     90 <locate_unset+0x90>
add    $0x8,%rbp
movslq %eax,%r13
jmp    3d <locate_unset+0x3d>
nopl   (%rax)
add    $0x8,%rbp
mov    -0x8(%rbp),%rbx
test   %rbx,%rbx
je     90 <locate_unset+0x90>
cmpb   $0x2d,(%rbx)
jne    30 <locate_unset+0x30>
lea    0x1(%rbx),%r12
mov    $0x0,%esi
mov    %r12,%rdi
callq  53 <locate_unset+0x53>
cmp    %rax,%r13
jne    30 <locate_unset+0x30>
mov    %r13,%rdx
mov    %r12,%rsi
mov    %r14,%rdi
callq  66 <locate_unset+0x66>
test   %eax,%eax
jne    30 <locate_unset+0x30>
lea    0x1(%rbx,%r13,1),%rsi
mov    $0x1,%al
cmpb   $0x0,(%rsi)
je     92 <locate_unset+0x92>
lea    (%r14,%r13,1),%rdi
callq  7f <locate_unset+0x7f>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    92 <locate_unset+0x92>
nopl   0x0(%rax)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
locate_unset(char **env, const char *name)
{
 int i;
 int nlen = strcspn(name, "=");
 for (i = 0; env[i]; i++) {
  if (env[i][0] == '-') {
   size_t elen = strcspn (env[i] + 1, "=");
   if (elen == nlen &&
       memcmp (name, env[i] + 1, nlen) == 0) {
    if (env[i][nlen + 1])
     return strcmp(name + nlen,
            env[i] + 1 + nlen) == 0;
    else
     return 1;
   }
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 2
8 4
9 2
10 4
11 5
12 5
13 5
14 5
15 8
16 8
17 8
18 8
19 5
20 5
21 5
22 6
23 6
24 7
25 7
26 7
27 7
28 8
29 8
30 9
31 9
32 9
33 9
34 8
35 8
36 10
37 14
38 10
39 10
40 11
41 11
42 12
43 12
44 12
45 11
46 11
47 18
48 19
49 19
50 19
51 19
52 19
53 19
54 19
<<<sep_out_sample>>>
mov    %edi,%edx
sub    $0x8,%rsp
mov    $0x1,%eax
test   %edi,%edi
cmovne %rdx,%rax
mov    %rax,%rdi
callq  269 <xmalloc+0x19>
test   %rax,%rax
je     273 <xmalloc+0x23>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  27d <xmalloc+0x2d>
xor    %esi,%esi
mov    %rax,%rdx
xor    %edi,%edi
xor    %eax,%eax
callq  28b <xmalloc+0x3b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (unsigned int size)
{
  void *result = malloc (size ? size : 1);
  if (result == 0)
    fatal((((floc *)0)), 0, (gettext ("virtual memory exhausted")));
  return result;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 7
11 7
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 5
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %edi,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
sub    $0x8,%rsp
test   %rdx,%rdx
mov    0x0(%rip),%rax        # 145c <copy_files_tape_to_disk+0x1c>
jle    14d1 <copy_files_tape_to_disk+0x91>
xchg   %ax,%ax
test   %rax,%rax
je     14e0 <copy_files_tape_to_disk+0xa0>
cmp    %r13,%rax
mov    0x0(%rip),%rdi        # 146f <copy_files_tape_to_disk+0x2f>
cmova  %r13,%rax
mov    %rax,%rbx
mov    0x0(%rip),%eax        # 147c <copy_files_tape_to_disk+0x3c>
test   %eax,%eax
je     14a7 <copy_files_tape_to_disk+0x67>
test   %rbx,%rbx
jle    14a7 <copy_files_tape_to_disk+0x67>
mov    0x0(%rip),%ecx        # 148b <copy_files_tape_to_disk+0x4b>
xor    %eax,%eax
nopl   (%rax)
movzbl (%rdi,%rax,1),%r8d
add    $0x1,%rax
add    %r8d,%ecx
cmp    %rax,%rbx
mov    %ecx,0x0(%rip)        # 14a5 <copy_files_tape_to_disk+0x65>
jne    1490 <copy_files_tape_to_disk+0x50>
mov    %rbx,%rdx
mov    %ebp,%esi
sub    %rbx,%r13
callq  14b4 <copy_files_tape_to_disk+0x74>
mov    0x0(%rip),%rax        # 14bb <copy_files_tape_to_disk+0x7b>
add    %rbx,0x0(%rip)        # 14c2 <copy_files_tape_to_disk+0x82>
sub    %rbx,%rax
test   %r13,%r13
mov    %rax,0x0(%rip)        # 14cf <copy_files_tape_to_disk+0x8f>
jg     1460 <copy_files_tape_to_disk+0x20>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%esi        # 14e6 <copy_files_tape_to_disk+0xa6>
mov    %r12d,%edi
callq  1150 <tape_fill_input_buffer>
mov    0x0(%rip),%rax        # 14f5 <copy_files_tape_to_disk+0xb5>
jmpq   1465 <copy_files_tape_to_disk+0x25>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
copy_files_tape_to_disk (int in_des, int out_des, off_t num_bytes)
{
  off_t size;
  off_t k;
  while (num_bytes > 0)
    {
      if (input_size == 0)
 tape_fill_input_buffer (in_des, io_block_size);
      size = (input_size < num_bytes) ? input_size : num_bytes;
      if (crc_i_flag)
 {
   for (k = 0; k < size; ++k)
     crc += in_buff[k] & 0xff;
 }
      disk_buffered_write (in_buff, out_des, size);
      num_bytes -= size;
      input_size -= size;
      in_buff += size;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 5
11 5
12 5
13 7
14 7
15 9
16 9
17 9
18 9
19 10
20 10
21 10
22 12
23 12
24 12
25 12
26 12
27 13
28 12
29 13
30 12
31 13
32 12
33 15
34 15
35 16
36 15
37 17
38 18
39 17
40 5
41 17
42 5
43 20
44 20
45 20
46 20
47 20
48 20
49 20
50 8
51 8
52 8
53 8
54 8
55 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x28(%rdi),%rax
cmp    %rsi,%rax
jbe    840 <gsl_interp2d_idx+0x20>
cmp    %rdx,0x30(%rdi)
jbe    860 <gsl_interp2d_idx+0x40>
imul   %rdx,%rax
add    $0x8,%rsp
add    %rsi,%rax
retq   
nop
mov    $0x2,%ecx
mov    $0x16a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  859 <gsl_interp2d_idx+0x39>
xor    %eax,%eax
add    $0x8,%rsp
retq   
mov    $0x2,%ecx
mov    $0x16e,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  879 <gsl_interp2d_idx+0x59>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_interp2d_idx(const gsl_interp2d * interp,
                 const size_t i, const size_t j)
{
  if (i >= interp->xsize)
    {
      do { gsl_error ("x index out of range", "interp2d.c", 362, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else if (j >= interp->ysize)
    {
      do { gsl_error ("y index out of range", "interp2d.c", 366, GSL_ERANGE) ; return 0 ; } while (0);
    }
  else
    {
      return ((j) * ((interp)->xsize) + (i));
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 8
6 8
7 14
8 16
9 14
10 16
11 16
12 6
13 6
14 6
15 6
16 6
17 6
18 16
19 16
20 10
21 10
22 10
23 10
24 10
25 10
26 16
27 16
<<<sep_out_sample>>>
push   %rbx
mov    $0x1ef,%edx
mov    %rdi,%rbx
mov    $0x0,%esi
mov    $0x20,%edi
callq  a08 <make_cond_command+0x18>
test   %rbx,%rbx
mov    %rbx,0x18(%rax)
movl   $0xb,(%rax)
movq   $0x0,0x10(%rax)
movl   $0x0,0x4(%rax)
je     a30 <make_cond_command+0x40>
mov    0x4(%rbx),%edx
mov    %edx,0x8(%rax)
pop    %rbx
retq   
xchg   %ax,%ax
xor    %edx,%edx
mov    %edx,0x8(%rax)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_cond_command (cond_node)
     COND_COM *cond_node;
{
  COMMAND *command;
  command = (COMMAND *)sh_xmalloc((sizeof (COMMAND)), "make_cmd.c", 495);
  command->value.Cond = cond_node;
  command->type = cm_cond;
  command->redirects = (REDIRECT *)((void *)0);
  command->flags = 0;
  command->line = cond_node ? cond_node->line : 0;
  return (command);
}
<<<sep_in_sample>>>
1 3
2 5
3 3
4 5
5 5
6 5
7 10
8 6
9 7
10 8
11 9
12 10
13 10
14 10
15 12
16 12
17 12
18 10
19 10
20 12
21 12
22 12
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    0x20(%rdi),%rcx
imul   (%rdi),%rdx
movsd  (%rcx),%xmm0
test   %rdx,%rdx
je     35 <gsl_histogram2d_max_val+0x35>
lea    0x8(%rcx),%rax
lea    (%rcx,%rdx,8),%rdx
jmp    30 <gsl_histogram2d_max_val+0x30>
nop
movsd  (%rax),%xmm1
add    $0x8,%rax
maxsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
cmp    %rdx,%rax
jne    20 <gsl_histogram2d_max_val+0x20>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_max_val (const gsl_histogram2d * h)
{
  const size_t nx = h->nx;
  const size_t ny = h->ny;
  size_t i;
  double max = h->bin[0 * ny + 0];
  for (i = 0; i < nx * ny; i++)
    {
      if (h->bin[i] > max)
        {
          max = h->bin[i];
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 6
5 7
6 7
7 7
8 7
9 7
10 7
11 9
12 9
13 9
14 9
15 7
16 7
17 15
18 15
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  61fc <gsl_sf_hyperg_U+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    6210 <gsl_sf_hyperg_U+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x6fa,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  6226 <gsl_sf_hyperg_U+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_hyperg_U(const double a, const double b, const double x)
{
  gsl_sf_result result; int status = gsl_sf_hyperg_U_e(a, b, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_hyperg_U_e(a, b, x, &result)", "hyperg_U.c", 1786, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   68 <nettle_gcm_aes192_update+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_aes192_update (struct gcm_aes192_ctx *ctx,
     size_t length, const uint8_t *data)
{
  nettle_gcm_update(&(ctx)->gcm, &(ctx)->key, (length), (data));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
mov    (%rsi),%r10
cmp    (%rdi),%r10
je     2090 <gsl_vector_uchar_add+0x30>
mov    $0x13,%ecx
mov    $0x1b,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2082 <gsl_vector_uchar_add+0x22>
mov    $0x13,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
xor    %ecx,%ecx
xor    %edx,%edx
xor    %eax,%eax
test   %r10,%r10
mov    0x8(%rdi),%rbx
mov    0x8(%rsi),%r11
je     20ca <gsl_vector_uchar_add+0x6a>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%r8
mov    0x10(%rsi),%r9
add    0x10(%rdi),%r8
add    $0x1,%rax
add    %rbx,%rdx
movzbl (%r9,%rcx,1),%r9d
add    %r11,%rcx
add    %r9b,(%r8)
cmp    %r10,%rax
jne    20a8 <gsl_vector_uchar_add+0x48>
xor    %eax,%eax
pop    %rbx
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_uchar_add (gsl_vector_uchar * a, const gsl_vector_uchar * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 27, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] += b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 13
16 13
17 13
18 10
19 11
20 13
21 13
22 15
23 15
24 15
25 13
26 13
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
35 19
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
jmpq   629 <osip_ict_lock+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_ict_lock (osip_t * osip)
{
  return osip_mutex_lock (osip->ict_fastmutex);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     160 <grecs_version_info_free+0x20>
mov    0x30(%rdi),%rdi
test   %rdi,%rdi
je     157 <grecs_version_info_free+0x17>
callq  157 <grecs_version_info_free+0x17>
mov    %rbx,%rdi
pop    %rbx
jmpq   160 <grecs_version_info_free+0x20>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_version_info_free(struct grecs_version_info *pv)
{
 if (pv) {
  if (pv->buffer)
   grecs_free(pv->buffer);
  free(pv);
 }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 8
11 6
12 8
13 8
14 8
<<<sep_out_sample>>>
movslq %edi,%rdi
xor    %eax,%eax
mov    0x0(,%rdi,8),%rdx
test   %rdx,%rdx
je     11f6 <malloc_free_blocks+0x26>
nopw   0x0(%rax,%rax,1)
mov    0x8(%rdx),%rdx
add    $0x1,%eax
test   %rdx,%rdx
jne    11e8 <malloc_free_blocks+0x18>
repz retq 
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
malloc_free_blocks (size)
     int size;
{
  int nfree;
  register union mhead *p;
  nfree = 0;
  for (p = nextf[size]; p; p = (*(union mhead **) (sizeof (char *) + (char *) (p))))
    nfree++;
  return nfree;
}
<<<sep_in_sample>>>
1 7
2 6
3 7
4 7
5 7
6 7
7 7
8 8
9 7
10 7
11 7
12 10
13 10
<<<sep_out_sample>>>
cmp    $0x5,%edi
ja     60 <custom_log_handler+0x60>
mov    %edi,%eax
jmpq   *0x0(,%rax,8)
xchg   %ax,%ax
mov    $0x0,%edi
xor    %eax,%eax
jmpq   1c <custom_log_handler+0x1c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   2c <custom_log_handler+0x2c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   3c <custom_log_handler+0x3c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   4c <custom_log_handler+0x4c>
nopl   0x0(%rax)
mov    $0x0,%edi
xor    %eax,%eax
jmpq   5c <custom_log_handler+0x5c>
nopl   0x0(%rax)
mov    %rsi,%rdx
xor    %eax,%eax
mov    %edi,%esi
mov    $0x0,%edi
jmpq   71 <custom_log_handler+0x71>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
custom_log_handler (cdio_log_level_t level, const char *message)
{
  switch(level) {
  case CDIO_LOG_DEBUG:
    printf("-- custom debug message: %s\n", message);
    return;
  case CDIO_LOG_INFO:
    printf("-- custom info message: %s\n", message);
    return;
  case CDIO_LOG_WARN:
    printf("-- custom warning message: %s\n", message);
    return;
  case CDIO_LOG_ERROR:
    printf("-- custom error message: %s\n", message);
    return;
  case CDIO_LOG_ASSERT:
    printf("-- custom assertion message: %s\n", message);
    return;
  default:
    printf("custom level %d message: %s\n", level, message);
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 17
7 17
8 17
9 17
10 5
11 5
12 5
13 5
14 8
15 8
16 8
17 8
18 11
19 11
20 11
21 11
22 14
23 14
24 14
25 14
26 20
27 20
28 20
29 20
30 20
31 20
<<<sep_out_sample>>>
cmp    $0x1,%ecx
mov    %rdi,%rax
mov    %rdx,%rdi
je     2c0 <nettle_openssl_des_ecb_encrypt+0x20>
mov    %rsi,%rdx
mov    0x0(%rip),%r8        # 2b5 <nettle_openssl_des_ecb_encrypt+0x15>
mov    %rax,%rcx
mov    $0x8,%esi
jmpq   *%r8
mov    %rsi,%rdx
mov    0x0(%rip),%r8        # 2ca <nettle_openssl_des_ecb_encrypt+0x2a>
mov    %rax,%rcx
mov    $0x8,%esi
jmpq   *%r8
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_openssl_des_ecb_encrypt(des_cblock *src, des_cblock *dst,
  des_key_schedule ctx,
  int enc)
{
  ((enc == DES_ENCRYPT) ? nettle_des_encrypt : nettle_des_decrypt)
    (ctx, 8, *dst, *src);
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 5
5 6
6 5
7 6
8 6
9 6
10 6
11 5
12 6
13 6
14 6
15 6
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   d63 <gsl_sort_vector_uint_smallest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_uint_smallest (unsigned int * dest, const size_t k,
                                     const gsl_vector_uint * v)
{
  return gsl_sort_uint_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 9ca <in_local_domain+0xa>
callq  9cf <in_local_domain+0xf>
test   %rax,%rax
je     9f0 <in_local_domain+0x30>
mov    0x0(%rip),%rsi        # 9db <in_local_domain+0x1b>
mov    %rax,%rdi
callq  9e3 <in_local_domain+0x23>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
in_local_domain (char *hostname)
{
  char *p = topdomain (hostname, local_dot_count);
  return p && strcasecmp (p, local_domain_name) == 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 4
15 5
16 5
17 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  2d7e <xalloc_die+0xe>
mov    $0x2,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  2d8d <xalloc_die+0x1d>
callq  2d92 <xalloc_die+0x22>
<<<sep_in_sample>>>
xalloc_die ()
{
  logmsg (2, gettext("not enough memory"));
  abort ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
<<<sep_out_sample>>>
test   %edi,%edi
jne    307e <env_default+0x3e>
mov    0x0(%rip),%rax        # 304b <env_default+0xb>
test   %rax,%rax
je     307b <env_default+0x3b>
mov    (%rax),%rax
test   %rax,%rax
je     3070 <env_default+0x30>
mov    0x20(%rax),%edx
test   %edx,%edx
je     3050 <env_default+0x10>
cmp    %esi,0x24(%rax)
jne    3050 <env_default+0x10>
mov    %rax,0x0(%rip)        # 306b <env_default+0x2b>
mov    0x10(%rax),%rax
retq   
movq   $0x0,0x0(%rip)        # 307b <env_default+0x3b>
xor    %eax,%eax
retq   
movq   $0x0,0x0(%rip)        # 3089 <env_default+0x49>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
env_default (int init, int welldefined)
{
  static struct env_lst *nep = ((void *)0);
  if (init)
    {
      nep = &envlisthead;
      return ((void *)0);
    }
  if (nep)
    {
      while ((nep = nep->next))
 {
   if (nep->export && (nep->welldefined == welldefined))
     return (nep->var);
 }
    }
  return (((void *)0));
}
<<<sep_in_sample>>>
1 4
2 4
3 9
4 9
5 9
6 11
7 11
8 11
9 13
10 13
11 13
12 13
13 13
14 13
15 14
16 14
17 14
18 17
19 17
20 6
21 7
22 7
23 7
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_pin_set (Gsasl * ctx, Gsasl_client_callback_pin cb)
{
  ctx->cbc_pin = cb;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r14
mov    %rdi,%r14
push   %r13
lea    0x28(%rdi),%r13
push   %r12
push   %rbp
push   %rbx
mov    0x28(%rdi),%rbx
mov    0x18(%rdi),%r12
cmp    %r13,%rbx
jne    6f3 <gl_linked_list_free+0x23>
jmp    70f <gl_linked_list_free+0x3f>
xchg   %ax,%ax
mov    %rbp,%rbx
test   %r12,%r12
mov    (%rbx),%rbp
je     702 <gl_linked_list_free+0x32>
mov    0x10(%rbx),%rdi
callq  *%r12
mov    %rbx,%rdi
callq  70a <gl_linked_list_free+0x3a>
cmp    %r13,%rbp
jne    6f0 <gl_linked_list_free+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14,%rdi
pop    %r14
jmpq   71f <gl_linked_list_free+0x4f>
nop
<<<sep_in_sample>>>
gl_linked_list_free (gl_list_t list)
{
  gl_listelement_dispose_fn dispose = list->base.dispose_fn;
  gl_list_node_t node;
  for (node = list->root.next; node != &list->root; )
    {
      gl_list_node_t next = node->next;
      if (dispose != ((void *)0))
 dispose (node->value);
      free (node);
      node = next;
    }
  free (list);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 2
6 2
7 2
8 5
9 3
10 5
11 5
12 5
13 5
14 11
15 8
16 7
17 8
18 9
19 9
20 10
21 10
22 5
23 5
24 14
25 14
26 14
27 14
28 13
29 14
30 13
31 13
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %edx,%r12d
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  9c8 <GetOptPunct+0x18>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  9d2 <GetOptPunct+0x22>
cmp    %r12b,%al
je     9e8 <GetOptPunct+0x38>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
lea    0xc(%rsp),%rdx
mov    %r13,%rsi
mov    %rbx,%rdi
mov    $0x1,%ebp
callq  9fd <GetOptPunct+0x4d>
add    $0x18,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
GetOptPunct (PINPUTBUF pibIn, PSTR szLex, char chPunct)
{
  int iReturn, iType;
  iReturn = SkipWhitespace (pibIn);
  if (NextChar (pibIn) == chPunct) {
    iReturn = 1;
    NextLex (pibIn, szLex, &iType);
  }
  return (iReturn);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 4
10 5
11 4
12 5
13 5
14 5
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 7
24 7
25 7
26 6
27 7
28 10
29 10
30 10
31 10
32 10
33 10
34 10
35 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
callq  de <termprep+0xe>
movl   $0x0,0x0(%rip)        # e8 <termprep+0x18>
add    $0x8,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
termprep(int sig)
{
  bsd_signal(sig,termprep);
  terminal_prepped=0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 5
6 5
7 5
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <xmalloc+0x9>
test   %rax,%rax
je     13 <xmalloc+0x13>
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  1d <xmalloc+0x1d>
mov    $0x1,%edi
callq  27 <xmalloc+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmalloc (size_t length)
{
  void * p;
  p = (void *) malloc (length);
  if (p == (void *) ((void *)0))
    {
      perror ("out of memory");
      exit (1);
    }
  return p;
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 11
6 11
7 7
8 7
9 8
10 8
11 8
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  33e <ck_fflush+0xe>
mov    %rbx,%rdi
callq  346 <ck_fflush+0x16>
cmp    $0xffffffff,%eax
je     358 <ck_fflush+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  35d <ck_fflush+0x2d>
mov    (%rax),%edi
cmp    $0x9,%edi
je     34b <ck_fflush+0x1b>
callq  369 <ck_fflush+0x39>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  374 <ck_fflush+0x44>
mov    %rbp,%rdx
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  386 <ck_fflush+0x56>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ck_fflush(stream)
  FILE *stream;
{
  clearerr(stream);
  if (fflush(stream) == (-1) && (*__errno_location ()) != 9)
    panic("couldn't flush %s: %s", utils_fp_name(stream), strerror((*__errno_location ())));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 5
7 5
8 5
9 5
10 7
11 7
12 7
13 7
14 7
15 5
16 5
17 5
18 5
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%rax
mov    %rdi,%rbx
add    $0x1,%rax
cmp    %rsi,%rax
jb     208 <ds_resize+0x18>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %rsi,0x18(%rdi)
mov    0x28(%rdi),%rdi
callq  215 <ds_resize+0x25>
mov    %rax,0x28(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_resize (struct dstring *string, size_t size)
{
  if (string->len + 1 < size)
    {
      string->size = size;
      string->content = ((char *) xrealloc ((void *) (string->content), sizeof (char) * (size)));
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 8
8 8
9 8
10 5
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
jmpq   219 <swacfl_get_archive_name+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swacfl_get_archive_name(swacfl_entry * en)
{
 return strob_str(en->archiveNameM);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x20(%rsi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_node_value (gl_list_t list, gl_list_node_t node)
{
  return node->value;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1470 <gsl_vector_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  148f <gsl_vector_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_const_view_array (const double * base, size_t n)
{
  _gsl_vector_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector v = {0, 0, 0, 0, 0};
    v.data = (double *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
test   %rdx,%rdx
movzwl (%rdi),%eax
je     1178 <gsl_stats_ushort_max+0x28>
add    %rsi,%rsi
xor    %ecx,%ecx
nopl   (%rax)
movzwl (%rdi),%r8d
cmp    %r8w,%ax
cmovb  %r8d,%eax
add    $0x1,%rcx
add    %rsi,%rdi
cmp    %rdx,%rcx
jne    1160 <gsl_stats_ushort_max+0x10>
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ushort_max (const unsigned short data[], const size_t stride,
                          const size_t n)
{
  unsigned short max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned short xi = data[i * stride];
      if (xi > max)
        max = xi;
    }
  return max;
}
<<<sep_in_sample>>>
1 6
2 4
3 6
4 6
5 6
6 6
7 8
8 8
9 8
10 6
11 6
12 6
13 6
14 13
15 13
<<<sep_out_sample>>>
push   %rbx
mov    $0x1,%edi
callq  336b <dump_funcs+0xb>
xor    %edx,%edx
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%esi
callq  337d <dump_funcs+0x1d>
mov    %rbx,%rdi
pop    %rbx
jmpq   3386 <dump_funcs+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dump_funcs()
{
 NODE **funcs;
 funcs = function_list(1);
 (void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) pp_func, (void *) 0);
 free(funcs);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 5
8 5
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
sub    $0x100,%rsp
mov    %rsp,%rdi
callq  1eb0 <cleanup_the_pipeline+0x10>
mov    $0x11,%esi
mov    %rsp,%rdi
callq  1ebd <cleanup_the_pipeline+0x1d>
lea    0x80(%rsp),%rdi
callq  1eca <cleanup_the_pipeline+0x2a>
lea    0x80(%rsp),%rdx
xor    %edi,%edi
mov    %rsp,%rsi
callq  1edc <cleanup_the_pipeline+0x3c>
mov    0x0(%rip),%rbx        # 1ee3 <cleanup_the_pipeline+0x43>
lea    0x80(%rsp),%rsi
xor    %edx,%edx
mov    $0x2,%edi
movq   $0x0,0x0(%rip)        # 1efd <cleanup_the_pipeline+0x5d>
callq  1f02 <cleanup_the_pipeline+0x62>
test   %rbx,%rbx
je     1f0f <cleanup_the_pipeline+0x6f>
mov    %rbx,%rdi
callq  1f0f <cleanup_the_pipeline+0x6f>
add    $0x100,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cleanup_the_pipeline ()
{
  PROCESS *disposer;
  sigset_t set, oset;
  do { sigemptyset (&set); sigaddset (&set, 17); sigemptyset (&oset); sigprocmask (0, &set, &oset); } while (0);
  disposer = the_pipeline;
  the_pipeline = (PROCESS *)((void *)0);
  sigprocmask (2, &oset, (sigset_t *) ((void *)0));
  if (disposer)
    discard_pipeline (disposer);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 8
16 8
17 8
18 7
19 8
20 9
21 9
22 10
23 10
24 11
25 11
26 11
27 11
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
test   %r10,%r10
je     1e41 <gsl_matrix_float_add_constant+0x71>
push   %rbx
lea    0x0(,%r9,4),%rbx
shl    $0x2,%r11
xor    %ecx,%ecx
xor    %esi,%esi
nopl   0x0(%rax)
test   %r9,%r9
je     1e31 <gsl_matrix_float_add_constant+0x61>
mov    0x18(%rdi),%rdx
lea    (%rcx,%rbx,1),%r8
lea    (%rdx,%rcx,1),%rax
add    %r8,%rdx
nopl   0x0(%rax)
movss  (%rax),%xmm1
add    $0x4,%rax
cvtps2pd %xmm1,%xmm1
addsd  %xmm0,%xmm1
unpcklpd %xmm1,%xmm1
cvtpd2ps %xmm1,%xmm2
movss  %xmm2,-0x4(%rax)
cmp    %rdx,%rax
jne    1e10 <gsl_matrix_float_add_constant+0x40>
add    $0x1,%rsi
add    %r11,%rcx
cmp    %r10,%rsi
jne    1df8 <gsl_matrix_float_add_constant+0x28>
xor    %eax,%eax
pop    %rbx
retq   
xor    %eax,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_add_constant (gsl_matrix_float * a, const double x)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  const size_t tda = a->tda;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          a->data[i * tda + j] += x;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 2
7 2
8 2
9 7
10 7
11 7
12 9
13 9
14 9
15 9
16 9
17 9
18 9
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 9
27 9
28 7
29 7
30 7
31 7
32 15
33 15
34 15
35 15
36 15
37 15
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # d56 <gsl_vector_ushort_set+0x6>
test   %eax,%eax
je     d5f <gsl_vector_ushort_set+0xf>
cmp    %rsi,(%rdi)
jbe    d78 <gsl_vector_ushort_set+0x28>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rcx
add    %rax,%rax
imul   %rsi,%rax
mov    %dx,(%rcx,%rax,1)
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xc1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   d91 <gsl_vector_ushort_set+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_set (gsl_vector_ushort * v, const size_t i, unsigned short x)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_ushort.h", 193, GSL_EINVAL) ; return ; } while (0);
    }
  v->data[i * v->stride] = x;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 5
14 5
15 5
16 5
17 5
18 5
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r13d
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %edi,%ebp
mov    $0xa,%edi
push   %rbx
sub    $0x8,%rsp
callq  b3c <swextopt_writeExtendedOptions+0x1c>
xor    %ecx,%ecx
mov    %rax,%rbx
mov    %r12,%rsi
mov    %r13d,%edx
mov    %rax,%rdi
callq  b4f <swextopt_writeExtendedOptions+0x2f>
mov    %rbx,%rdi
callq  b57 <swextopt_writeExtendedOptions+0x37>
mov    %rbx,%rdi
mov    %rax,%r12
callq  b62 <swextopt_writeExtendedOptions+0x42>
mov    %r12,%rcx
mov    %ebp,%esi
mov    %rax,%rdx
mov    $0x0,%edi
mov    $0xffffffff,%ebp
callq  b79 <swextopt_writeExtendedOptions+0x59>
mov    %rbx,%rdi
mov    %rax,%r12
callq  b84 <swextopt_writeExtendedOptions+0x64>
cmp    %r12d,%eax
jne    b93 <swextopt_writeExtendedOptions+0x73>
mov    %rbx,%rdi
mov    %eax,%ebp
callq  b93 <swextopt_writeExtendedOptions+0x73>
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
swextopt_writeExtendedOptions(int ofd, struct extendedOptions * eop, int SWC_FLAG)
{
 int ret;
 STROB * tmp = strob_open(10);
 swextopt_writeExtendedOptions_strob(tmp, eop, SWC_FLAG, 0);
 ret = atomicio((ssize_t (*)(int, void *, size_t))write, ofd, strob_str(tmp), strob_strlen(tmp));
 if (ret != (int)strob_strlen(tmp)) return -1;
 strob_close(tmp);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 4
8 2
9 2
10 4
11 5
12 4
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 6
28 7
29 6
30 7
31 7
32 7
33 8
34 8
35 8
36 10
37 10
38 10
39 10
40 10
41 10
42 10
<<<sep_out_sample>>>
mov    (%rdi),%r8
cmp    (%rsi),%r8
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
mov    0x8(%rdi),%rdi
mov    0x8(%rsi),%rcx
je     8cf <gsl_vector_float_swap+0x3f>
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x20,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  8c5 <gsl_vector_float_swap+0x35>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
test   %r8,%r8
je     907 <gsl_vector_float_swap+0x77>
lea    0x0(,%rcx,4),%rsi
shl    $0x2,%rdi
xor    %ecx,%ecx
nopw   0x0(%rax,%rax,1)
movss  (%rdx),%xmm0
add    $0x1,%rcx
movss  (%rax),%xmm1
movss  %xmm1,(%rdx)
add    %rdi,%rdx
movss  %xmm0,(%rax)
add    %rsi,%rax
cmp    %r8,%rcx
jne    8e8 <gsl_vector_float_swap+0x58>
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_float_swap (gsl_vector_float * v, gsl_vector_float * w)
{
  float * d1 = v->data ;
  float * d2 = w->data ;
  const size_t size = v->size ;
  const size_t s1 = 1 * v->stride ;
  const size_t s2 = 1 * w->stride ;
  size_t i, k ;
  if (v->size != w->size)
    {
      do { gsl_error ("vector lengths must be equal", "swap_source.c", 32, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      for (k = 0; k < 1; k++)
        {
          float tmp = d1[i*s1 + k];
          d1[i*s1+k] = d2[i*s2 + k];
          d2[i*s2+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 9
3 3
4 4
5 6
6 7
7 9
8 2
9 11
10 11
11 11
12 11
13 11
14 11
15 23
16 23
17 13
18 13
19 13
20 13
21 13
22 13
23 17
24 13
25 18
26 18
27 18
28 19
29 19
30 13
31 13
32 22
33 23
34 23
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    %rsi,%rdi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  62 <argp_fmtstream_puts+0x12>
mov    %rax,%rbx
xor    %eax,%eax
test   %rbx,%rbx
je     85 <argp_fmtstream_puts+0x35>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  7a <argp_fmtstream_puts+0x2a>
cmp    %rax,%rbx
setne  %al
movzbl %al,%eax
neg    %eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)
{
  size_t __len = strlen (__str);
  if (__len)
    {
      size_t __wrote = argp_fmtstream_write (__fs, __str, __len);
      return __wrote == __len ? 0 : -1;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 10
10 4
11 4
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 11
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x10,%edi
sub    $0x8,%rsp
callq  362a <swlib_altfnmatch+0x1a>
mov    $0x10,%edi
mov    %rax,%r12
callq  3637 <swlib_altfnmatch+0x27>
mov    $0x0,%edx
mov    %rax,%rbp
mov    %rbx,%rsi
mov    %r12,%rdi
callq  364a <swlib_altfnmatch+0x3a>
test   %rax,%rax
mov    %rax,%rbx
je     36c1 <swlib_altfnmatch+0xb1>
mov    $0x0,%edx
mov    %r13,%rsi
mov    %rbp,%rdi
callq  3662 <swlib_altfnmatch+0x52>
test   %rax,%rax
jne    3684 <swlib_altfnmatch+0x74>
jmp    36b8 <swlib_altfnmatch+0xa8>
nopl   0x0(%rax)
xor    %esi,%esi
mov    $0x0,%edx
mov    %rbp,%rdi
callq  367f <swlib_altfnmatch+0x6f>
test   %rax,%rax
je     36b8 <swlib_altfnmatch+0xa8>
xor    %edx,%edx
mov    %rax,%rsi
mov    %rbx,%rdi
callq  3691 <swlib_altfnmatch+0x81>
cmp    $0x1,%eax
je     3670 <swlib_altfnmatch+0x60>
mov    %r12,%rdi
callq  369e <swlib_altfnmatch+0x8e>
mov    %rbp,%rdi
callq  36a6 <swlib_altfnmatch+0x96>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edx
xor    %esi,%esi
jmp    3642 <swlib_altfnmatch+0x32>
mov    %r12,%rdi
callq  36c9 <swlib_altfnmatch+0xb9>
mov    %rbp,%rdi
callq  36d1 <swlib_altfnmatch+0xc1>
mov    $0x1,%eax
jmp    36a8 <swlib_altfnmatch+0x98>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_altfnmatch(char * s1, char * s2)
{
 STROB * tmp1;
 STROB * tmp2;
 char * t1;
 char * t2;
 tmp1 = strob_open(16);
 tmp2 = strob_open(16);
 t1 = strob_strtok(tmp1, s1, "|\n\r");
 while(t1) {
  t2 = strob_strtok(tmp2, s2, "|\n\r");
  while(t2) {
   if (fnmatch(t1, t2, 0) != 1) {
    strob_close(tmp1);
    strob_close(tmp2);
    return 0;
   }
   t2 = strob_strtok(tmp2, ((void *)0), "|\n\r");
  }
  t1 = strob_strtok(tmp1, ((void *)0), "|\n\r");
 }
 strob_close(tmp1);
 strob_close(tmp2);
 return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 2
9 7
10 8
11 7
12 8
13 9
14 8
15 9
16 9
17 9
18 10
19 9
20 10
21 11
22 11
23 11
24 11
25 12
26 12
27 12
28 12
29 18
30 18
31 18
32 18
33 12
34 12
35 13
36 13
37 13
38 13
39 13
40 13
41 14
42 14
43 15
44 15
45 16
46 25
47 25
48 25
49 25
50 25
51 25
52 25
53 20
54 20
55 20
56 22
57 22
58 23
59 23
60 24
61 24
62 24
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%r9
mov    %rdx,%r8
shr    %r8
je     113b <gsl_vector_ushort_reverse+0x4b>
lea    -0x2(%rdx,%rdx,1),%rdx
mov    %r9,%r10
xor    %ecx,%ecx
neg    %r10
imul   %r9,%rdx
add    %r10,%r10
add    %r9,%r9
add    %rax,%rdx
nopl   (%rax)
movzwl (%rdx),%esi
movzwl (%rax),%edi
add    $0x1,%rcx
mov    %di,(%rdx)
mov    %si,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    1120 <gsl_vector_ushort_reverse+0x30>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_ushort_reverse (gsl_vector_ushort * v)
{
  unsigned short * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          unsigned short tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 15
18 8
19 15
20 16
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x218,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
callq  6c <a2ps_common_finalize+0x2c>
test   %rax,%rax
je     90 <a2ps_common_finalize+0x50>
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
jne    b5 <a2ps_common_finalize+0x75>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    $0x2f,%ecx
mov    %rbp,%rdx
mov    $0x0,%esi
mov    %rsp,%rdi
callq  a5 <a2ps_common_finalize+0x65>
mov    (%rbx),%rdi
mov    %rsp,%rsi
callq  b0 <a2ps_common_finalize+0x70>
mov    %rax,(%rbx)
jmp    71 <a2ps_common_finalize+0x31>
callq  ba <a2ps_common_finalize+0x7a>
<<<sep_in_sample>>>
a2ps_common_finalize (struct a2ps_common_s * common, const char * home)
{
  char buf [512];
  if (! getenv ("NO_HOME_CONF"))
    {
      sprintf (buf, "%s%c.a2ps", home, '/');
      common->path = pw_prepend_string_to_path (common->path, buf);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 2
8 2
9 2
10 4
11 4
12 4
13 9
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 7
29 7
30 7
31 9
<<<sep_out_sample>>>
test   %esi,%esi
js     338 <cplob_val+0x18>
cmp    0xc(%rdi),%esi
jg     338 <cplob_val+0x18>
mov    (%rdi),%rax
movslq %esi,%rsi
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cplob_val(CPLOB * lob, int index)
{
 if (index < 0) {
  return ((void *)0);
 }
 if (index > lob->nused) return ((void *)0);
 return *(lob->list + (index));
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 6
5 7
6 7
7 7
8 7
9 7
10 4
11 8
12 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movl   $0x1,(%rdi)
mov    $0x8,%edi
callq  *0x0(%rip)        # 15 <__gmpz_init+0x15>
movl   $0x0,0x4(%rbx)
mov    %rax,0x8(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
__gmpz_init (mpz_ptr x)
{
  ((x)->_mp_alloc) = 1;
  ((x)->_mp_d) = ((mp_limb_t *) (*__gmp_allocate_func) ((1) * sizeof (mp_limb_t)));
  ((x)->_mp_size) = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 5
7 4
8 6
9 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x238(%rdi),%rax
mov    %rsi,%r8
mov    %ecx,(%rsp)
mov    %rdx,%r9
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
callq  *0x8(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
process_data_crank_post (j_decompress_ptr cinfo,
    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
    JDIMENSION out_rows_avail)
{
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) ((void *)0),
         (JDIMENSION *) ((void *)0), (JDIMENSION) 0,
         output_buf, out_row_ctr, out_rows_avail);
}
<<<sep_in_sample>>>
1 4
2 5
3 4
4 5
5 4
6 5
7 5
8 5
9 5
10 8
11 8
12 8
<<<sep_out_sample>>>
push   %rbp
xorpd  %xmm2,%xmm2
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 13 <alarmCheck+0x13>
movsd  0x0(%rip),%xmm3        # 1b <alarmCheck+0x1b>
jmp    2a <alarmCheck+0x2a>
nopl   (%rax)
movapd %xmm2,%xmm0
mov    %rax,%rbx
mov    %rdx,%rax
test   %rax,%rax
je     60 <alarmCheck+0x60>
ucomisd %xmm2,%xmm0
jbe    a0 <alarmCheck+0xa0>
movsd  0x8(%rax),%xmm1
subsd  %xmm0,%xmm1
ucomisd %xmm1,%xmm2
jb     b0 <alarmCheck+0xb0>
mov    (%rax),%rdx
mov    %rbx,(%rax)
jbe    20 <alarmCheck+0x20>
movapd %xmm1,%xmm0
xorpd  %xmm3,%xmm0
jmp    24 <alarmCheck+0x24>
nopw   %cs:0x0(%rax,%rax,1)
movq   $0x0,0x0(%rip)        # 6b <alarmCheck+0x6b>
test   %rbx,%rbx
jne    7b <alarmCheck+0x7b>
jmp    98 <alarmCheck+0x98>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rbx
xor    %eax,%eax
mov    0x28(%rbx),%rsi
mov    0x20(%rbx),%rdi
callq  *0x18(%rbx)
mov    (%rbx),%rbp
mov    %rbx,%rdi
callq  93 <alarmCheck+0x93>
test   %rbp,%rbp
jne    78 <alarmCheck+0x78>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    %rax,0x0(%rip)        # a7 <alarmCheck+0xa7>
jmp    6b <alarmCheck+0x6b>
nopl   0x0(%rax)
mov    %rax,0x0(%rip)        # b7 <alarmCheck+0xb7>
movsd  %xmm1,0x8(%rax)
jmp    6b <alarmCheck+0x6b>
xchg   %ax,%ax
<<<sep_in_sample>>>
alarmCheck(double delta)
{
 double d = delta;
 alarm_descriptor_t *p, *list = ((void *)0), *list1;
 while (alarm_list != (alarm_descriptor_t *) ((void *)0) && d > 0.0) {
  if ((d = alarm_list->delta - d) <= 0.0) {
   p = alarm_list;
   alarm_list = alarm_list->next;
   if (list) {
    p->next = list;
    list = p;
   }
   else {
    p->next = ((void *)0);
    list = p;
   }
   d = (d < 0.0) ? -d : 0.0;
  }
  else {
   alarm_list->delta = d;
   break;
  }
 }
 while (list) {
  (*list->proc) (list->arg1, list->arg2);
  list1 = list->next;
  free((char *) list);
  list = list1;
 }
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 4
5 2
6 2
7 17
8 5
9 5
10 17
11 17
12 17
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 6
21 8
22 10
23 17
24 17
25 17
26 17
27 17
28 17
29 24
30 24
31 24
32 24
33 28
34 25
35 25
36 25
37 25
38 26
39 27
40 27
41 24
42 24
43 30
44 30
45 30
46 30
47 30
48 30
49 30
50 30
51 30
52 20
53 21
54 21
<<<sep_out_sample>>>
mov    (%rdi),%ecx
mov    0x4(%rdi),%edx
mov    0x8(%rdi),%rsi
mov    %ecx,%eax
mov    %edx,%r9d
lea    (%rdi,%rax,8),%r8
mov    0x10(%r8),%rax
sub    0x10(%rdi,%r9,8),%rax
lea    0x1000000(%rax),%r9
test   %rax,%rax
cmovs  %r9,%rax
lea    -0x1(%rcx),%r9d
test   %ecx,%ecx
mov    %rax,0x10(%r8)
mov    $0x60,%r8d
mov    %r9d,%ecx
cmove  %r8d,%ecx
test   %edx,%edx
mov    %ecx,(%rdi)
lea    -0x1(%rdx),%ecx
mov    %rsi,%rdx
cmovne %ecx,%r8d
sub    $0x74cbb1,%rdx
mov    %r8d,0x4(%rdi)
js     80 <ranmar_get+0x80>
sub    %rdx,%rax
mov    %rdx,0x8(%rdi)
js     70 <ranmar_get+0x70>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1000000,%rax
retq   
nopw   0x0(%rax,%rax,1)
lea    0x8b344c(%rsi),%rdx
jmp    5b <ranmar_get+0x5b>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ranmar_get (void *vstate)
{
  ranmar_state_t *state = (ranmar_state_t *) vstate;
  unsigned int i = state->i;
  unsigned int j = state->j;
  long int carry = state->carry;
  long int delta = state->u[i] - state->u[j];
  if (delta < 0)
    delta += two24 ;
  state->u[i] = delta;
  if (i == 0)
    {
      i = 96;
    }
  else
    {
      i--;
    }
  state->i = i;
  if (j == 0)
    {
      j = 96;
    }
  else
    {
      j--;
    }
  state->j = j;
  carry += - 7654321 ;
  if (carry < 0)
    carry += two24 - 3;
  state->carry = carry ;
  delta += - carry ;
  if (delta < 0)
    delta += two24 ;
  return delta;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 17
13 17
14 10
15 17
16 17
17 17
18 26
19 19
20 26
21 30
22 26
23 30
24 28
25 30
26 34
27 32
28 34
29 37
30 37
31 35
32 37
33 37
34 31
35 31
36 31
<<<sep_out_sample>>>
mov    %rdi,%rsi
sub    $0x8,%rsp
mov    $0x0,%edi
callq  5a1 <read_fatal+0x11>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_fatal (char const *name)
{
  call_arg_fatal ("read", name);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
movsd  0x0(%rip),%xmm1        # 160c <erfc+0xc>
andpd  %xmm3,%xmm1
ucomisd 0x0(%rip),%xmm1        # 1618 <erfc+0x18>
jbe    1630 <erfc+0x30>
xorpd  %xmm0,%xmm0
movsd  0x0(%rip),%xmm1        # 1626 <erfc+0x26>
cmplesd %xmm3,%xmm0
andnpd %xmm1,%xmm0
retq   
sub    $0x18,%rsp
movsd  %xmm0,0x8(%rsp)
movsd  0x0(%rip),%xmm0        # 1642 <erfc+0x42>
movsd  0x0(%rip),%xmm2        # 164a <erfc+0x4a>
mulsd  %xmm1,%xmm0
addsd  %xmm2,%xmm0
divsd  %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 165e <erfc+0x5e>
xorpd  %xmm1,%xmm0
movsd  %xmm2,(%rsp)
mulsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 1673 <erfc+0x73>
mulsd  %xmm2,%xmm1
subsd  0x0(%rip),%xmm0        # 167f <erfc+0x7f>
subsd  0x0(%rip),%xmm1        # 1687 <erfc+0x87>
mulsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 1693 <erfc+0x93>
mulsd  %xmm2,%xmm1
subsd  0x0(%rip),%xmm1        # 169f <erfc+0x9f>
mulsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 16ab <erfc+0xab>
mulsd  %xmm2,%xmm1
subsd  0x0(%rip),%xmm1        # 16b7 <erfc+0xb7>
mulsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 16c3 <erfc+0xc3>
mulsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 16cf <erfc+0xcf>
mulsd  %xmm2,%xmm1
addsd  0x0(%rip),%xmm1        # 16db <erfc+0xdb>
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
callq  16e8 <erfc+0xe8>
movsd  0x8(%rsp),%xmm3
movsd  (%rsp),%xmm2
ucomisd 0x0(%rip),%xmm3        # 16fb <erfc+0xfb>
mulsd  %xmm2,%xmm0
jb     1710 <erfc+0x110>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm1        # 1718 <erfc+0x118>
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
jmp    1705 <erfc+0x105>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
erfc (double x)
{
  double dAbsX, t, dVal;
  dAbsX = fabs(x);
  if (dAbsX > 20) {
    return ( x >= 0 ? 0 : 2 );
  }
  else {
    t = 1 / (1 + 0.5 * dAbsX);
    dVal = t * exp(-dAbsX*dAbsX - 1.26551223 + t*(1.00002368 + t*(0.37409196 +
           t*(0.09678418 + t*(-0.18628806 + t*(0.27886807 + t*(-1.13520398 +
           t*(1.48851587 + t*(-0.82215223 + t*(0.17087277))))))))));
    return ( x >= 0 ? dVal : 2 - dVal );
  }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 6
7 6
8 6
9 6
10 15
11 2
12 2
13 9
14 9
15 9
16 9
17 9
18 10
19 10
20 10
21 10
22 12
23 12
24 10
25 12
26 12
27 12
28 12
29 11
30 11
31 11
32 11
33 11
34 11
35 11
36 11
37 10
38 10
39 10
40 10
41 10
42 10
43 13
44 13
45 13
46 13
47 13
48 15
49 15
50 15
51 13
52 13
53 13
54 13
55 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 657 <do_statusbar_backspace+0x7>
test   %rsi,%rsi
jne    660 <do_statusbar_backspace+0x10>
repz retq 
xchg   %ax,%ax
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 66b <do_statusbar_backspace+0x1b>
callq  670 <do_statusbar_backspace+0x20>
mov    %rax,0x0(%rip)        # 677 <do_statusbar_backspace+0x27>
add    $0x8,%rsp
jmpq   680 <do_statusbar_cut_text>
<<<sep_in_sample>>>
do_statusbar_backspace(void)
{
    if (statusbar_x > 0) {
 statusbar_x = move_mbleft(answer, statusbar_x);
 do_statusbar_delete();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 2
7 4
8 4
9 4
10 7
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %edi,%edi
callq  343b <do_writeout_void+0xb>
cmp    $0x2,%eax
je     3448 <do_writeout_void+0x18>
add    $0x8,%rsp
retq   
nopl   (%rax)
add    $0x8,%rsp
jmpq   3451 <do_writeout_void+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_writeout_void(void)
{
    if (do_writeout(0) == 2)
 close_and_go();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 5
7 5
8 5
9 5
10 4
11 4
<<<sep_out_sample>>>
mov    %rsi,0x68(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
msadams_set_driver (void *vstate, const gsl_odeiv2_driver * d)
{
  msadams_state_t *state = (msadams_state_t *) vstate;
  state->driver = d;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 6
3 6
4 6
<<<sep_out_sample>>>
push   %r13
xor    %r13d,%r13d
push   %r12
mov    %edx,%r12d
movsbl %dl,%edx
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  138e <EGetPunct+0x1e>
test   %eax,%eax
sete   %r13b
jne    13ac <EGetPunct+0x3c>
mov    %r12b,0x1(%rbx)
xor    %ecx,%ecx
mov    %rbx,%rdx
mov    $0x13,%esi
mov    %rbp,%rdi
callq  13ac <EGetPunct+0x3c>
add    $0x8,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
EGetPunct (PINPUTBUF pibIn, PSTR szLex, char chPunct)
{
  int iReturn;
  iReturn = !GetPunct (pibIn, szLex, chPunct);
  if (iReturn) {
    szLex[1] = chPunct;
    ReportError (pibIn, 0x0013, szLex, ((void *)0));
  }
  return (iReturn);
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 4
6 2
7 2
8 2
9 2
10 2
11 4
12 5
13 5
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
<<<sep_out_sample>>>
test   %edi,%edi
je     68 <madir_to_string+0x28>
cmp    $0x1,%edi
jne    58 <madir_to_string+0x18>
mov    $0x0,%edi
jmpq   53 <madir_to_string+0x13>
nopl   0x0(%rax,%rax,1)
sub    $0x8,%rsp
callq  61 <madir_to_string+0x21>
nopl   0x0(%rax)
mov    $0x0,%edi
jmpq   72 <madir_to_string+0x32>
<<<sep_in_sample>>>
madir_to_string (madir_t madir)
{
  switch (madir)
    {
    case madir_rows:
      return gettext ("rows first");
    case madir_columns:
      return gettext ("columns first");
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 8
6 8
7 8
8 2
9 10
10 10
11 6
12 6
<<<sep_out_sample>>>
push   %r14
mov    %rcx,%r14
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  2d9 <get_args+0x19>
mov    %rbp,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
mov    %rax,%rbx
callq  2ec <get_args+0x2c>
mov    $0x20,%eax
mov    %r12,%rsi
mov    $0x0,%edi
mov    %ax,0x0(%rbx)
xor    %eax,%eax
callq  307 <get_args+0x47>
mov    0x0(%rip),%rdx        # 30e <get_args+0x4e>
mov    $0xc7,%esi
lea    0x0(%rbx),%rdi
sub    %ebx,%esi
callq  321 <get_args+0x61>
test   %rax,%rax
je     348 <get_args+0x88>
callq  210 <makeargv>
pop    %rbx
mov    0x0(%rip),%eax        # 332 <get_args+0x72>
pop    %rbp
pop    %r12
mov    %eax,0x0(%r13)
movq   $0x0,(%r14)
pop    %r13
pop    %r14
retq   
nopl   (%rax)
mov    (%r14),%rax
mov    %rbp,(%rax)
movl   $0x1,0x0(%r13)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
get_args (char *arg0, char *prompt, int *argc, char ***argv)
{
  size_t arg0_len = strlen (arg0);
  strcpy (line, arg0);
  strcat (line, " ");
  printf ("%s", prompt);
  if (fgets (line + arg0_len + 1, sizeof line - arg0_len - 1, stdin))
    {
      makeargv ();
      *argc = margc;
      *argv = margv;
    }
  else
    {
      *argv[0] = arg0;
      *argc = 1;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 4
13 4
14 3
15 4
16 5
17 6
18 6
19 5
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 9
30 18
31 10
32 18
33 18
34 10
35 11
36 18
37 18
38 18
39 18
40 15
41 15
42 16
43 18
44 18
45 18
46 18
47 18
48 18
49 18
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     ecb <gsl_matrix_complex_float_set_identity+0x5b>
shl    $0x3,%r9
mov    %rax,%rdi
xor    %ecx,%ecx
nopl   (%rax)
test   %rsi,%rsi
je     ebf <gsl_matrix_complex_float_set_identity+0x4f>
mov    %rdi,%rdx
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cmp    %rax,%rcx
je     ecd <gsl_matrix_complex_float_set_identity+0x5d>
movl   $0x0,(%rdx)
movl   $0x0,0x4(%rdx)
add    $0x1,%rax
add    $0x8,%rdx
cmp    %rsi,%rax
jne    ea0 <gsl_matrix_complex_float_set_identity+0x30>
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    e90 <gsl_matrix_complex_float_set_identity+0x20>
repz retq 
movl   $0x3f800000,(%rdx)
movl   $0x0,0x4(%rdx)
jmp    eb2 <gsl_matrix_complex_float_set_identity+0x42>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_complex_float_set_identity (gsl_matrix_complex_float * m)
{
  size_t i, j;
  float * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex_float zero = {{0.0F,0.0F}};
  const gsl_complex_float one = {{1.0F,0.0F}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex_float *) (data + 2 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 10
11 12
12 12
13 12
14 12
15 12
16 14
17 14
18 14
19 14
20 12
21 12
22 12
23 12
24 10
25 10
26 10
27 10
28 10
29 14
30 14
31 14
32 14
<<<sep_out_sample>>>
push   %r14
cmp    $0x1,%rcx
push   %r13
mov    %rdi,%r13
mov    %rsi,%rdi
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
je     3a90 <gsl_block_short_raw_fread+0x90>
xor    %ebp,%ebp
test   %rdx,%rdx
lea    (%rcx,%rcx,1),%r14
mov    %rsi,%rbx
jne    3a3c <gsl_block_short_raw_fread+0x3c>
jmp    3a80 <gsl_block_short_raw_fread+0x80>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     3a80 <gsl_block_short_raw_fread+0x80>
mov    %r13,%rcx
mov    $0x1,%edx
mov    $0x2,%esi
mov    %rbx,%rdi
callq  3a51 <gsl_block_short_raw_fread+0x51>
cmp    $0x1,%rax
je     3a30 <gsl_block_short_raw_fread+0x30>
mov    $0x5,%ecx
mov    $0x4d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3a70 <gsl_block_short_raw_fread+0x70>
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
xchg   %ax,%ax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
xor    %eax,%eax
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    %r13,%rcx
mov    $0x2,%esi
callq  3a9d <gsl_block_short_raw_fread+0x9d>
cmp    %r12,%rax
je     3a80 <gsl_block_short_raw_fread+0x80>
mov    $0x5,%ecx
mov    $0x40,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3abb <gsl_block_short_raw_fread+0xbb>
mov    $0x5,%eax
jmp    3a75 <gsl_block_short_raw_fread+0x75>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_raw_fread (FILE * stream, short * data,
                                 const size_t n, const size_t stride)
{
  if (stride == 1)
    {
      size_t items = fread (data, 1 * sizeof (short), n, stream);
      if (items != n)
        {
          do { gsl_error ("fread failed", "fwrite_source.c", 64, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
        }
    }
  else
    {
      size_t i;
      for (i = 0; i < n; i++)
        {
          size_t item = fread (data + 1 * i * stride,
                               1 * sizeof (short), 1, stream);
          if (item != 1)
            {
              do { gsl_error ("fread failed", "fwrite_source.c", 77, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 15
12 15
13 15
14 15
15 15
16 15
17 15
18 15
19 15
20 15
21 15
22 17
23 17
24 17
25 17
26 17
27 19
28 19
29 21
30 21
31 21
32 21
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 26
46 25
47 26
48 26
49 26
50 6
51 6
52 6
53 7
54 7
55 9
56 9
57 9
58 9
59 9
60 9
61 9
62 9
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  1982 <gsl_stats_uint_sd+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   1994 <gsl_stats_uint_sd+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uint_sd (const unsigned int data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_uint_mean (data, stride, n);
  return gsl_stats_uint_sd_m (data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  179e <version+0xe>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  17ad <version+0x1d>
mov    $0x0,%edi
callq  17b7 <version+0x27>
mov    $0x0,%edi
callq  17c1 <version+0x31>
mov    $0x0,%esi
mov    %rax,%rdi
xor    %eax,%eax
callq  17d0 <version+0x40>
mov    $0x0,%edi
callq  17da <version+0x4a>
mov    %rax,%rdi
xor    %eax,%eax
callq  17e4 <version+0x54>
mov    $0x0,%edi
callq  17ee <version+0x5e>
mov    %rax,%rdi
xor    %eax,%eax
callq  17f8 <version+0x68>
mov    $0x0,%edi
xor    %eax,%eax
callq  1804 <version+0x74>
mov    $0x0,%edi
xor    %eax,%eax
callq  1810 <version+0x80>
mov    $0xa,%edi
add    $0x8,%rsp
jmpq   181e <version+0x8e>
xchg   %ax,%ax
<<<sep_in_sample>>>
version(void)
{
    printf(gettext(" GNU nano, version %s\n"), "2.7.0");
    printf(" (C) 1999..2016 Free Software Foundation, Inc.\n");
    printf(gettext(" (C) 2014..%s the contributors to nano\n"), "2016");
    printf(
 gettext(" Email: nano@nano-editor.org	Web: https://nano-editor.org/"));
    printf(gettext("\n Compiled options:"));
    printf(" --disable-libmagic");
    printf(" --disable-utf8");
    printf("\n");
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 4
9 4
10 5
11 5
12 5
13 5
14 5
15 5
16 7
17 7
18 6
19 6
20 6
21 8
22 8
23 8
24 8
25 8
26 9
27 9
28 9
29 10
30 10
31 10
32 11
33 12
34 11
35 11
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 9e7 <check_step+0x7>
cmp    %rax,0x0(%rip)        # 9ee <check_step+0xe>
je     a28 <check_step+0x48>
mov    %rax,0x0(%rip)        # 9f7 <check_step+0x17>
mov    0x0(%rip),%eax        # 9fd <check_step+0x1d>
movb   $0x1,0x0(%rip)        # a04 <check_step+0x24>
mov    %eax,0x0(%rip)        # a0a <check_step+0x2a>
mov    0x0(%rip),%rax        # a11 <check_step+0x31>
mov    %rax,0x0(%rip)        # a18 <check_step+0x38>
xor    %eax,%eax
subl   $0x1,0x0(%rip)        # a21 <check_step+0x41>
sete   %al
retq   
nopl   (%rax)
mov    0x0(%rip),%rax        # a2f <check_step+0x4f>
cmp    %rax,0x0(%rip)        # a36 <check_step+0x56>
je     a60 <check_step+0x80>
mov    %rax,0x0(%rip)        # a3f <check_step+0x5f>
mov    0x0(%rip),%eax        # a45 <check_step+0x65>
mov    %eax,0x0(%rip)        # a4b <check_step+0x6b>
xor    %eax,%eax
subl   $0x1,0x0(%rip)        # a54 <check_step+0x74>
sete   %al
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # a66 <check_step+0x86>
cmp    %eax,0x0(%rip)        # a6c <check_step+0x8c>
jne    a45 <check_step+0x65>
xor    %eax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_step(INSTRUCTION **pi)
{
 if (fcall_count != stop.fcall_count) {
  stop.fcall_count = fcall_count;
  stop.sourceline = sourceline;
  stop.source = source;
  stop.print_frame = 1;
  return (--stop.repeat_count == 0);
 }
 if (source != stop.source) {
  stop.source = source;
  stop.sourceline = sourceline;
  return (--stop.repeat_count == 0);
 }
 if (sourceline != stop.sourceline) {
  stop.sourceline = sourceline;
  return (--stop.repeat_count == 0);
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 5
6 7
7 5
8 6
9 6
10 17
11 17
12 17
13 17
14 17
15 10
16 10
17 10
18 11
19 12
20 16
21 17
22 17
23 17
24 17
25 17
26 15
27 15
28 15
29 19
30 20
31 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <sys_fatal+0x9>
mov    (%rax),%edi
callq  10 <sys_fatal+0x10>
mov    %rbx,%rsi
xor    %ecx,%ecx
mov    %rax,%rdx
pop    %rbx
mov    $0x0,%edi
jmpq   23 <sys_fatal+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sys_fatal(const char *s)
{
  c_fatal("%1: %2", s, strerror((*__errno_location ())), (char *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 3
11 3
12 3
<<<sep_out_sample>>>
mov    %edi,%edi
sub    $0x48,%rsp
cvtsi2sd %rdi,%xmm3
movsd  %xmm0,0x10(%rsp)
movsd  %xmm1,0x18(%rsp)
movapd %xmm3,%xmm4
movsd  %xmm3,0x8(%rsp)
addsd  %xmm1,%xmm4
movapd %xmm4,%xmm0
callq  7e <gsl_ran_negative_binomial_pdf+0x2e>
movsd  0x18(%rsp),%xmm1
movsd  %xmm0,0x38(%rsp)
movapd %xmm1,%xmm0
movsd  %xmm1,0x30(%rsp)
callq  99 <gsl_ran_negative_binomial_pdf+0x49>
movsd  0x8(%rsp),%xmm5
movsd  %xmm0,0x18(%rsp)
addsd  0x0(%rip),%xmm5        # ad <gsl_ran_negative_binomial_pdf+0x5d>
movapd %xmm5,%xmm0
callq  b6 <gsl_ran_negative_binomial_pdf+0x66>
movsd  %xmm0,0x20(%rsp)
movsd  0x10(%rsp),%xmm0
callq  c7 <gsl_ran_negative_binomial_pdf+0x77>
movsd  0x10(%rsp),%xmm6
movsd  %xmm0,0x28(%rsp)
movsd  0x0(%rip),%xmm0        # db <gsl_ran_negative_binomial_pdf+0x8b>
xorpd  %xmm0,%xmm6
movapd %xmm6,%xmm0
callq  e8 <gsl_ran_negative_binomial_pdf+0x98>
movsd  0x38(%rsp),%xmm2
movsd  0x30(%rsp),%xmm1
subsd  0x18(%rsp),%xmm2
mulsd  0x8(%rsp),%xmm0
mulsd  0x28(%rsp),%xmm1
subsd  0x20(%rsp),%xmm2
add    $0x48,%rsp
addsd  %xmm1,%xmm2
addsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
jmpq   121 <gsl_ran_negative_binomial_pdf+0xd1>
<<<sep_in_sample>>>
gsl_ran_negative_binomial_pdf (const unsigned int k, const double p, double n)
{
  double P;
  double f = gsl_sf_lngamma (k + n) ;
  double a = gsl_sf_lngamma (n) ;
  double b = gsl_sf_lngamma (k + 1.0) ;
  P = exp(f - a - b + n * log(p) + k * log1p(-p));
  return P;
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 5
15 5
16 6
17 5
18 6
19 6
20 6
21 6
22 7
23 7
24 7
25 7
26 7
27 7
28 7
29 7
30 7
31 7
32 7
33 7
34 7
35 7
36 9
37 7
38 7
39 7
40 7
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fixbounds(const char *r)
{
    return r;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm3
movapd %xmm1,%xmm0
movapd %xmm3,%xmm1
divsd  %xmm2,%xmm1
xorpd  %xmm2,%xmm2
ucomisd %xmm3,%xmm2
jae    98 <gsl_cdf_gamma_Q+0x48>
ucomisd %xmm1,%xmm0
jbe    90 <gsl_cdf_gamma_Q+0x40>
sub    $0x8,%rsp
callq  79 <gsl_cdf_gamma_Q+0x29>
movsd  0x0(%rip),%xmm1        # 81 <gsl_cdf_gamma_Q+0x31>
add    $0x8,%rsp
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
xchg   %ax,%ax
jmpq   95 <gsl_cdf_gamma_Q+0x45>
nopl   (%rax)
movsd  0x0(%rip),%xmm1        # a0 <gsl_cdf_gamma_Q+0x50>
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_gamma_Q (const double x, const double a, const double b)
{
  double Q;
  double y = x / b;
  if (x <= 0.0)
    {
      return 1.0;
    }
  if (y < a)
    {
      Q = 1 - gsl_sf_gamma_inc_P (a, y);
    }
  else
    {
      Q = gsl_sf_gamma_inc_Q (a, y);
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 5
8 9
9 9
10 2
11 11
12 11
13 18
14 11
15 18
16 18
17 18
18 15
19 15
20 7
21 18
22 18
<<<sep_out_sample>>>
mov    %rsi,0x50(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_pin_set (Gsasl * ctx, Gsasl_client_callback_pin cb)
{
  ctx->cbc_pin = cb;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
mov    %rdi,%r13
mov    $0x0,%edi
push   %r12
xor    %r12d,%r12d
push   %rbp
mov    %rdx,%rbp
push   %rbx
xor    %ebx,%ebx
sub    $0x18,%rsp
mov    %rsi,0x8(%rsp)
callq  218 <argmatch_valid+0x28>
mov    0x0(%rip),%rdi        # 21f <argmatch_valid+0x2f>
mov    %rax,%rsi
xor    %eax,%eax
callq  229 <argmatch_valid+0x39>
mov    0x0(%r13),%r15
xor    %eax,%eax
test   %r15,%r15
jne    280 <argmatch_valid+0x90>
jmpq   2c0 <argmatch_valid+0xd0>
nopl   0x0(%rax)
lea    (%rcx,%rax,1),%r14
mov    %rbp,%rdx
mov    %r12,%rdi
mov    %r14,%rsi
callq  252 <argmatch_valid+0x62>
test   %eax,%eax
je     298 <argmatch_valid+0xa8>
mov    %r14,%r12
mov    0x0(%rip),%rdi        # 260 <argmatch_valid+0x70>
mov    %r15,%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  26f <argmatch_valid+0x7f>
lea    0x1(%rbx),%rax
mov    0x0(%r13,%rax,8),%r15
test   %r15,%r15
je     2c0 <argmatch_valid+0xd0>
mov    %rax,%rbx
imul   %rbp,%rax
test   %ebx,%ebx
mov    0x8(%rsp),%rcx
jne    240 <argmatch_valid+0x50>
lea    (%rcx,%rax,1),%r12
jmp    259 <argmatch_valid+0x69>
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rdi        # 29f <argmatch_valid+0xaf>
mov    %r15,%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  2ae <argmatch_valid+0xbe>
lea    0x1(%rbx),%rax
mov    0x0(%r13,%rax,8),%r15
test   %r15,%r15
jne    27d <argmatch_valid+0x8d>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 2c7 <argmatch_valid+0xd7>
add    $0x18,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
jmpq   2df <argmatch_valid+0xef>
nop
<<<sep_in_sample>>>
argmatch_valid (const char *const *arglist,
  const char *vallist, size_t valsize)
{
  int i;
  const char *last_val = ((void *)0);
  fprintf (stderr, gettext ("Valid arguments are:"));
  for (i = 0; arglist[i]; i++)
    if ((i == 0)
 || memcmp (last_val, vallist + valsize * i, valsize))
      {
 fprintf (stderr, "\n  - `%s'", arglist[i]);
 last_val = vallist + valsize * i;
      }
    else
      {
 fprintf (stderr, ", `%s'", arglist[i]);
      }
  _IO_putc ('\n', stderr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 6
6 3
7 5
8 3
9 3
10 3
11 7
12 3
13 3
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 7
23 7
24 7
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 11
34 11
35 11
36 11
37 11
38 11
39 7
40 7
41 7
42 7
43 7
44 8
45 8
46 8
47 8
48 8
49 8
50 16
51 16
52 16
53 16
54 16
55 16
56 7
57 7
58 7
59 7
60 18
61 19
62 18
63 19
64 19
65 19
66 19
67 19
68 19
69 18
70 18
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  11 <_mapfile_get_transport2+0x11>
test   %rbp,%rbp
je     1e <_mapfile_get_transport2+0x1e>
movq   $0x0,0x0(%rbp)
test   %rbx,%rbx
je     29 <_mapfile_get_transport2+0x29>
movslq (%rax),%rax
mov    %rax,(%rbx)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mapfile_get_transport2 (mu_stream_t stream, mu_transport_t *pin, mu_transport_t *pout)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  if (pout)
    *pout = ((void *)0);
  if (pin)
    *pin = (mu_transport_t) mfs->fd;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 5
10 6
11 6
12 7
13 7
14 9
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
push   %rbp
mov    %rsp,%rbp
push   %r15
mov    %r8,%r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
mov    %rdx,%r12
mov    %r12,%rdi
push   %rbx
mov    %rcx,%rbx
sub    $0x28,%rsp
mov    %rsi,-0x48(%rbp)
mov    0xc(%rcx),%esi
mov    %fs:0x28,%rax
mov    %rax,-0x38(%rbp)
xor    %eax,%eax
mov    %r9,-0x50(%rbp)
lea    0x1e(%rsi),%rax
shr    $0x4,%rax
shl    $0x4,%rax
sub    %rax,%rsp
lea    0xf(%rsp),%r13
and    $0xfffffffffffffff0,%r13
mov    %r13,%rdx
callq  *0x28(%rcx)
mov    0x8(%rbx),%edx
mov    %r14,%rsi
mov    %r12,%rdi
callq  206 <nettle_hmac_digest+0x66>
mov    0xc(%rbx),%esi
mov    %r13,%rdx
mov    %r12,%rdi
callq  *0x20(%rbx)
mov    -0x50(%rbp),%r9
mov    %r15,%rsi
mov    %r12,%rdi
mov    %r9,%rdx
callq  *0x28(%rbx)
mov    0x8(%rbx),%edx
mov    -0x48(%rbp),%rsi
mov    %r12,%rdi
callq  231 <nettle_hmac_digest+0x91>
mov    -0x38(%rbp),%rax
xor    %fs:0x28,%rax
jne    24f <nettle_hmac_digest+0xaf>
lea    -0x28(%rbp),%rsp
pop    %rbx
pop    %r12
pop    %r13
pop    %r14
pop    %r15
pop    %rbp
retq   
callq  254 <nettle_hmac_digest+0xb4>
<<<sep_in_sample>>>
nettle_hmac_digest(const void *outer, const void *inner, void *state,
     const struct nettle_hash *hash,
     size_t length, uint8_t *dst)
{
  uint8_t *digest;
  (digest = __builtin_alloca (sizeof (*digest) * (hash->digest_size)));
  hash->digest(state, hash->digest_size, digest);
  memcpy(state, outer, hash->context_size);
  hash->update(state, hash->digest_size, digest);
  hash->digest(state, length, dst);
  memcpy(state, inner, hash->context_size);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 7
11 4
12 4
13 4
14 4
15 6
16 4
17 4
18 4
19 4
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 8
29 8
30 8
31 8
32 9
33 9
34 9
35 9
36 10
37 10
38 10
39 10
40 10
41 11
42 11
43 11
44 11
45 12
46 12
47 12
48 12
49 12
50 12
51 12
52 12
53 12
54 12
55 12
56 12
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x88,%rsp
mov    %rsp,%rdi
callq  c86 <swgp_signal_block+0x16>
mov    %ebp,%esi
mov    %rsp,%rdi
callq  c90 <swgp_signal_block+0x20>
mov    %rbx,%rdx
xor    %edi,%edi
mov    %rsp,%rsi
callq  c9d <swgp_signal_block+0x2d>
test   %eax,%eax
mov    %eax,%ebx
js     cb0 <swgp_signal_block+0x40>
add    $0x88,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nop
callq  cb5 <swgp_signal_block+0x45>
mov    (%rax),%edi
callq  cbc <swgp_signal_block+0x4c>
mov    0x0(%rip),%rdi        # cc3 <swgp_signal_block+0x53>
mov    %rax,%rcx
mov    %ebp,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  cd4 <swgp_signal_block+0x64>
add    $0x88,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
swgp_signal_block(int signo, sigset_t * oset)
{
 int ret;
 sigset_t newmask;
 sigemptyset(&newmask);
 sigaddset(&newmask, signo);
 if ((ret=sigprocmask(0, &newmask, oset)) < 0)
  fprintf(stderr,
   "swgp_signal_block error, signal=%d: %s\n",
    signo, strerror((*__errno_location ())));
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 6
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 12
19 12
20 12
21 12
22 12
23 12
24 10
25 8
26 8
27 8
28 8
29 8
30 8
31 8
32 8
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    (%rdi),%r10
mov    0x8(%rdi),%r11
mov    0x10(%rdi),%rdi
test   %r10,%r10
mov    (%rdi),%r8
je     dc6 <gsl_vector_ulong_minmax_index+0x56>
shl    $0x3,%r11
mov    %r8,%r9
xor    %eax,%eax
xor    %ebx,%ebx
xor    %ebp,%ebp
nopw   0x0(%rax,%rax,1)
mov    (%rdi),%rcx
cmp    %r9,%rcx
jae    da6 <gsl_vector_ulong_minmax_index+0x36>
mov    %rcx,%r9
mov    %rax,%rbp
cmp    %r8,%rcx
jbe    db1 <gsl_vector_ulong_minmax_index+0x41>
mov    %rcx,%r8
mov    %rax,%rbx
add    $0x1,%rax
add    %r11,%rdi
cmp    %r10,%rax
jne    d98 <gsl_vector_ulong_minmax_index+0x28>
mov    %rbp,(%rsi)
mov    %rbx,(%rdx)
pop    %rbx
pop    %rbp
retq   
xor    %ebx,%ebx
xor    %ebp,%ebp
jmp    dbd <gsl_vector_ulong_minmax_index+0x4d>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_ulong_minmax_index (const gsl_vector_ulong * v,
                                   size_t * imin_out,
                                   size_t * imax_out)
{
  const size_t N = v->size ;
  const size_t stride = v->stride ;
  size_t imin = 0, imax = 0;
  unsigned long max = v->data[0 * stride];
  unsigned long min = v->data[0 * stride];
  size_t i;
  for (i = 0; i < N; i++)
    {
      unsigned long x = v->data[i*stride];
      if (x < min)
        {
          min = x;
          imin = i;
        }
      if (x > max)
        {
          max = x;
          imax = i;
        }
    }
  *imin_out = imin;
  *imax_out = imax;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 6
5 8
6 11
7 8
8 11
9 11
10 9
11 11
12 7
13 7
14 7
15 13
16 14
17 14
18 14
19 14
20 19
21 19
22 19
23 19
24 11
25 11
26 11
27 11
28 25
29 26
30 27
31 27
32 27
33 7
34 7
35 7
36 7
<<<sep_out_sample>>>
mov    0x14(%rdi),%eax
mov    %eax,0xc(%rdi)
mov    0x18(%rdi),%eax
mov    %eax,0x10(%rdi)
retq   
nopl   (%rax)
<<<sep_in_sample>>>
coproc_fdrestore (cp)
     struct coproc *cp;
{
  cp->c_rfd = cp->c_rsave;
  cp->c_wfd = cp->c_wsave;
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
testb  $0x4,0x20(%rdi)
jne    c7e <wordsplit_free_envbuf+0x5e>
mov    0x68(%rdi),%rdi
test   %rdi,%rdi
je     c7e <wordsplit_free_envbuf+0x5e>
mov    (%rdi),%rax
test   %rax,%rax
je     c61 <wordsplit_free_envbuf+0x41>
mov    $0x8,%ebx
nopl   (%rax)
mov    %rax,%rdi
callq  c50 <wordsplit_free_envbuf+0x30>
mov    0x68(%rbp),%rdi
mov    (%rdi,%rbx,1),%rax
add    $0x8,%rbx
test   %rax,%rax
jne    c48 <wordsplit_free_envbuf+0x28>
callq  c66 <wordsplit_free_envbuf+0x46>
movq   $0x0,0x78(%rbp)
movq   $0x0,0x70(%rbp)
movq   $0x0,0x68(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_envbuf (struct wordsplit *ws)
{
  if (ws->ws_flags & 0x00000004)
    return;
  if (ws->ws_envbuf)
    {
      size_t i;
      for (i = 0; ws->ws_envbuf[i]; i++)
 free (ws->ws_envbuf[i]);
      free (ws->ws_envbuf);
      ws->ws_envidx = ws->ws_envsiz = 0;
      ws->ws_envbuf = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 8
18 8
19 8
20 8
21 8
22 10
23 11
24 11
25 12
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    0x0(%rip),%rbp        # a <finopen+0xa>
push   %rbx
mov    0x28(%rdi),%rax
mov    %rdi,%rbx
cmpb   $0x0,(%rax)
je     80 <finopen+0x80>
movzbl 0x8(%rdi),%r12d
mov    0x0(%rip),%rbp        # 23 <finopen+0x23>
test   %r12b,%r12b
je     70 <finopen+0x70>
mov    %rbx,%rdi
callq  *(%rbx)
mov    %rax,0x190(%rbp)
mov    0x0(%rip),%rax        # 3b <finopen+0x3b>
cmpq   $0x0,0x190(%rax)
je     88 <finopen+0x88>
callq  4a <finopen+0x4a>
mov    (%rax),%edx
mov    $0x1,%eax
mov    0x10(%rbx),%rsi
mov    0x18(%rbx),%rdi
mov    %edx,0x40(%rbx)
mov    %rsi,0x28(%rbx)
mov    %rdi,0x30(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0xd8(%rbp),%eax
mov    $0x1,%r12d
test   %eax,%eax
jns    28 <finopen+0x28>
xor    %r12d,%r12d
jmp    28 <finopen+0x28>
nopl   (%rax)
callq  8d <finopen+0x8d>
mov    (%rax),%edx
mov    $0x1,%eax
cmp    $0x2,%edx
jne    51 <finopen+0x51>
xor    %eax,%eax
test   %r12b,%r12b
jne    64 <finopen+0x64>
jmp    51 <finopen+0x51>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
finopen (struct maybe *m)
{
  _Bool interesting, preferold;
  preferold = m->bestfit.string[0] && (m->mustread || 0 <= (top->repository. fd_lock));
  (top->flow. from) = (m->open) (m);
  interesting = (top->flow. from) || (*__errno_location ()) != 2;
  if (interesting || !preferold)
    {
      m->eno = (*__errno_location ());
      m->bestfit = m->tentative;
    }
  return interesting;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 6
17 6
18 6
19 6
20 6
21 6
22 10
23 10
24 9
25 10
26 10
27 13
28 13
29 13
30 13
31 13
32 4
33 4
34 4
35 4
36 4
37 4
38 4
39 6
40 6
41 6
42 6
43 6
44 6
45 7
46 7
47 7
48 7
<<<sep_out_sample>>>
jmpq   35 <rec_record_comment_disp_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_comment_disp_fn (void *data)
{
  rec_comment_destroy ((rec_comment_t) data);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     5e0 <gsl_histogram2d_free+0x30>
mov    0x10(%rdi),%rdi
callq  5c2 <gsl_histogram2d_free+0x12>
mov    0x18(%rbx),%rdi
callq  5cb <gsl_histogram2d_free+0x1b>
mov    0x20(%rbx),%rdi
callq  5d4 <gsl_histogram2d_free+0x24>
mov    %rbx,%rdi
pop    %rbx
jmpq   5dd <gsl_histogram2d_free+0x2d>
nopl   (%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_histogram2d_free (gsl_histogram2d * h)
{
  if (!h) { return ; };
  free (h->xrange);
  free (h->yrange);
  free (h->bin);
  free (h);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 8
13 7
14 7
15 8
16 8
17 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
mov    $0x0,%ebx
sub    $0x8,%rsp
jmp    3d84 <find_builtin_by_name+0x24>
nopl   (%rax)
add    $0x18,%rbx
mov    (%rbx),%rdi
test   %rdi,%rdi
je     3da0 <find_builtin_by_name+0x40>
mov    %rbp,%rsi
callq  3d8c <find_builtin_by_name+0x2c>
test   %eax,%eax
jne    3d78 <find_builtin_by_name+0x18>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
lea    0x18(%rbx),%rax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_builtin_by_name (const char *name)
{
  const builtin *bp;
  for (bp = &builtin_tab[0]; bp->name != ((void *)0); bp++)
    if ((strcmp (bp->name, name) == 0))
      return bp;
  return bp + 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 4
6 2
7 2
8 2
9 4
10 4
11 4
12 4
13 5
14 5
15 5
16 5
17 8
18 8
19 8
20 8
21 8
22 8
23 8
24 7
25 8
26 8
27 8
28 8
<<<sep_out_sample>>>
mulsd  %xmm0,%xmm0
mulsd  %xmm0,%xmm0
mulsd  %xmm0,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
gsl_pow_8(const double x) { double x2 = x*x; double x4 = x2*x2; return x4*x4; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
mov    0x0(%rip),%edx        # 11 <do_set_limit+0x11>
test   %edx,%edx
je     30 <do_set_limit+0x30>
mov    0x0(%rip),%eax        # 1b <do_set_limit+0x1b>
test   %eax,%eax
jne    80 <do_set_limit+0x80>
mov    %rbx,%rdx
mov    %ebp,%esi
mov    $0x0,%edi
xor    %eax,%eax
callq  30 <do_set_limit+0x30>
mov    %rsp,%rsi
mov    %ebp,%edi
mov    %rbx,(%rsp)
mov    %rbx,0x8(%rsp)
callq  43 <do_set_limit+0x43>
test   %eax,%eax
je     77 <do_set_limit+0x77>
callq  4c <do_set_limit+0x4c>
mov    (%rax),%edi
callq  53 <do_set_limit+0x53>
mov    $0x0,%edi
mov    %rax,%rbx
callq  60 <do_set_limit+0x60>
mov    %rbx,%rdx
mov    %rax,%rsi
mov    $0x5,%edi
xor    %eax,%eax
callq  72 <do_set_limit+0x72>
mov    $0x1,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    $0x0,%r8d
mov    $0x35,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
mov    $0x7,%edi
xor    %eax,%eax
callq  a1 <do_set_limit+0xa1>
jmpq   1f <do_set_limit+0x1f>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_set_limit (int rlimit, rlim_t limit)
{
  struct rlimit rlim;
  do if (debug_level >= 1) { if (source_info_option) logmsg_printf (7, "%s:%lu:%s: ", "limits.c", 53, __FUNCTION__); debug_msg ("setting limit %d to %lu", rlimit, (unsigned long) limit); } while (0);
  rlim.rlim_cur = limit;
  rlim.rlim_max = limit;
  if (setrlimit(rlimit, &rlim))
    {
      logmsg (5, gettext("error setting limit: %s"),
       strerror ((*__errno_location ())));
      return 1;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 7
18 7
19 5
20 6
21 7
22 7
23 7
24 10
25 9
26 9
27 9
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 14
37 14
38 14
39 14
40 14
41 4
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
<<<sep_out_sample>>>
mov    %rdx,%rcx
xor    %edx,%edx
jmpq   10ea <quotearg_alloc+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_alloc (char const *arg, size_t argsize,
                struct quoting_options const *o)
{
  return quotearg_alloc_mem (arg, argsize, ((void *)0), o);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x28(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
csv_error(struct csv_parser *p)
{
  return p->status;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r11
cmp    (%rdi),%r11
mov    0x8(%rdi),%rax
je     3d10 <gsl_matrix_char_mul_elements+0x40>
mov    $0x13,%ecx
mov    $0x56,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3cfd <gsl_matrix_char_mul_elements+0x2d>
mov    $0x13,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsi),%rbp
cmp    %rax,%rbp
jne    3ce4 <gsl_matrix_char_mul_elements+0x14>
test   %r11,%r11
mov    0x10(%rdi),%r13
mov    0x10(%rsi),%r14
je     3d77 <gsl_matrix_char_mul_elements+0xa7>
sub    %r13,%r14
xor    %r9d,%r9d
xor    %ebx,%ebx
xor    %r12d,%r12d
nopl   0x0(%rax)
test   %rbp,%rbp
je     3d68 <gsl_matrix_char_mul_elements+0x98>
lea    (%rbx,%rbp,1),%r10
mov    %rbx,%rdx
nopl   0x0(%rax)
mov    %rdx,%rcx
add    0x18(%rdi),%rcx
mov    %rdx,%r8
add    0x18(%rsi),%r8
add    $0x1,%rdx
movzbl (%rcx),%eax
mulb   (%r8,%r9,1)
cmp    %r10,%rdx
mov    %al,(%rcx)
jne    3d48 <gsl_matrix_char_mul_elements+0x78>
add    $0x1,%r12
add    %r13,%rbx
add    %r14,%r9
cmp    %r11,%r12
jne    3d38 <gsl_matrix_char_mul_elements+0x68>
xor    %eax,%eax
jmp    3d02 <gsl_matrix_char_mul_elements+0x32>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_mul_elements (gsl_matrix_char * a, const gsl_matrix_char * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 86, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 16
36 16
37 16
38 16
39 16
40 18
41 18
42 18
43 18
44 18
45 18
46 18
47 16
48 18
49 16
50 14
51 14
52 14
53 14
54 14
55 21
56 21
57 21
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
mov    $0x0,%esi
push   %rbp
mov    %rdx,%rbp
mov    $0x2,%edx
push   %rbx
mov    %rdi,%rbx
callq  9c <report_timing+0x1c>
test   %rbp,%rbp
je     bc <report_timing+0x3c>
mov    0x8(%rbp),%rcx
mov    0x10(%rbp),%r8
mov    $0x0,%esi
mov    0x0(%rbp),%rdx
mov    %rbx,%rdi
xor    %eax,%eax
callq  bc <report_timing+0x3c>
mov    %r12,%rdi
callq  c4 <report_timing+0x44>
mov    %rbx,%rdi
callq  cc <report_timing+0x4c>
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  de <report_timing+0x5e>
mov    %r12,%rdi
callq  e6 <report_timing+0x66>
mov    %rbx,%rdi
callq  ee <report_timing+0x6e>
mov    $0x2,%edx
mov    $0x0,%esi
mov    %rbx,%rdi
callq  100 <report_timing+0x80>
mov    %r12,%rdi
callq  108 <report_timing+0x88>
mov    %rbx,%rdi
callq  110 <report_timing+0x90>
mov    %rbx,%rdi
mov    $0x2,%edx
mov    $0x0,%esi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   126 <report_timing+0xa6>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
report_timing(dico_stream_t stream, xdico_timer_t t, struct dico_stat *sp)
{
    dico_stream_write(stream, " [", 2);
    if (sp)
 stream_printf(stream, "d/m/c = %lu/%lu/%lu ",
        (unsigned long) sp->defines,
        (unsigned long) sp->matches,
        (unsigned long) sp->compares);
    timer_format_time(stream, timer_get_real(t));
    dico_stream_write(stream, "r ", 2);
    timer_format_time(stream, timer_get_user(t));
    dico_stream_write(stream, "u ", 2);
    timer_format_time(stream, timer_get_system(t));
    dico_stream_write(stream, "s]", 2);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 2
9 3
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 13
36 13
37 13
38 13
39 14
40 14
41 14
42 15
43 15
44 15
45 14
46 14
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
callq  e3e <initialize_terminal_and_keymaps+0xe>
mov    %rax,%rdi
callq  e46 <initialize_terminal_and_keymaps+0x16>
mov    %rbx,%rdi
pop    %rbx
jmpq   e4f <initialize_terminal_and_keymaps+0x1f>
nop
<<<sep_in_sample>>>
initialize_terminal_and_keymaps (char *init_file)
{
  char *term_name = getenv ("TERM");
  terminal_initialize_terminal (term_name);
  read_init_file (init_file);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %r8,%r12
push   %rbp
mov    %rcx,%rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
callq  4ab <_mapfile_read+0x1b>
mov    0x8(%rax),%rsi
mov    %rax,%rdx
mov    $0x16,%eax
cmp    $0xffffffffffffffff,%rsi
je     4d3 <_mapfile_read+0x43>
mov    0x10(%rdx),%rax
cmp    %rbp,%rax
jg     4e0 <_mapfile_read+0x50>
xor    %ebx,%ebx
test   %r12,%r12
je     508 <_mapfile_read+0x78>
mov    %rbx,(%r12)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
lea    0x0(%rbp,%rbx,1),%rcx
mov    %rax,%rdx
mov    %r13,%rdi
sub    %rbp,%rdx
cmp    %rcx,%rax
cmovb  %rdx,%rbx
add    %rbp,%rsi
mov    %rbx,%rdx
callq  500 <_mapfile_read+0x70>
jmp    4c8 <_mapfile_read+0x38>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
jmp    4d3 <_mapfile_read+0x43>
nopl   0x0(%rax)
<<<sep_in_sample>>>
_mapfile_read (mu_stream_t stream, char *optr, size_t osize,
        mu_off_t offset, size_t *nbytes)
{
  struct _mapfile_stream *mfs = mu_stream_get_owner (stream);
  size_t n = 0;
  if (mfs->ptr == ((void *) -1))
    return 22;
  if (offset < (mu_off_t)mfs->size)
    {
      n = ((offset + osize) > mfs->size) ? mfs->size - offset : osize;
      memcpy (optr, mfs->ptr + offset, n);
    }
  if (nbytes)
    *nbytes = n;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 4
11 6
12 4
13 7
14 6
15 6
16 8
17 8
18 8
19 5
20 13
21 13
22 14
23 15
24 16
25 16
26 16
27 16
28 16
29 16
30 16
31 10
32 10
33 11
34 10
35 10
36 10
37 11
38 11
39 11
40 11
41 11
42 15
43 15
44 15
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rcx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r10
test   %r9,%r9
je     2d8f <gsl_matrix_uint_set_all+0x4f>
lea    0x0(,%r8,4),%r11
shl    $0x2,%r10
xor    %edi,%edi
nopw   0x0(%rax,%rax,1)
test   %r8,%r8
je     2d83 <gsl_matrix_uint_set_all+0x43>
lea    (%rcx,%r11,1),%rdx
mov    %rcx,%rax
nopl   0x0(%rax)
mov    %esi,(%rax)
add    $0x4,%rax
cmp    %rdx,%rax
jne    2d78 <gsl_matrix_uint_set_all+0x38>
add    $0x1,%rdi
add    %r10,%rcx
cmp    %r9,%rdi
jne    2d68 <gsl_matrix_uint_set_all+0x28>
repz retq 
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_set_all (gsl_matrix_uint * m, unsigned int x)
{
  size_t i, j;
  unsigned int * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(unsigned int *) (data + 1 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 10
13 10
14 10
15 10
16 12
17 12
18 10
19 10
20 8
21 8
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
push   %r12
cmp    %esi,%ecx
push   %rbp
mov    %esi,%ebp
push   %rbx
jae    150 <_nettle_sha3_pad+0x40>
lea    0x1(%rcx),%eax
mov    %rdx,%rbx
mov    %ecx,%ecx
mov    %rdi,%r12
movb   $0x6,(%rdx,%rcx,1)
mov    %esi,%edx
lea    (%rbx,%rax,1),%rdi
sub    %eax,%edx
xor    %esi,%esi
callq  138 <_nettle_sha3_pad+0x28>
lea    -0x1(%rbp),%eax
mov    %rbx,%rdx
mov    %ebp,%esi
mov    %r12,%rdi
orb    $0x80,(%rbx,%rax,1)
pop    %rbx
pop    %rbp
pop    %r12
jmpq   0 <sha3_absorb>
lea    0x0(%rip),%rcx        # 157 <_nettle_sha3_pad+0x47>
lea    0x0(%rip),%rsi        # 15e <_nettle_sha3_pad+0x4e>
lea    0x0(%rip),%rdi        # 165 <_nettle_sha3_pad+0x55>
mov    $0x60,%edx
callq  16f <_nettle_sha3_pad+0x5f>
<<<sep_in_sample>>>
_nettle_sha3_pad (struct sha3_state *state,
    unsigned block_size, uint8_t *block, unsigned pos)
{
  ((pos < block_size) ? (void) (0) : __assert_fail ("pos < block_size", "sha3.c", 96, __PRETTY_FUNCTION__));
  block[pos++] = 6;
  memset (block + pos, 0, block_size - pos);
  block[block_size - 1] |= 0x80;
  sha3_absorb (state, block_size, block);
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 3
5 3
6 4
7 5
8 5
9 5
10 5
11 5
12 6
13 6
14 6
15 6
16 6
17 7
18 8
19 8
20 8
21 7
22 9
23 9
24 9
25 8
26 4
27 4
28 4
29 4
30 4
<<<sep_out_sample>>>
xorpd  %xmm1,%xmm1
ucomisd %xmm0,%xmm1
ja     260 <nabs+0x10>
repz retq 
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm1        # 268 <nabs+0x18>
xorpd  %xmm1,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
nabs (double a)
{
  return (a < 0) ? -a : a;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 3
8 4
9 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
lea    0x5c(%rdi),%rdi
sub    $0x8,%rsp
callq  15 <nettle_poly1305_aes_set_key+0x15>
lea    0x10(%rbp),%rsi
mov    %rbx,%rdi
callq  21 <nettle_poly1305_aes_set_key+0x21>
movl   $0x0,0x48(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
nettle_poly1305_aes_set_key (struct poly1305_aes_ctx *ctx, const uint8_t * key)
{
  nettle_aes128_set_encrypt_key(&ctx->aes, (key));
  nettle_poly1305_set_key(&ctx->pctx, (key+16));
  ctx->index = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 4
9 4
10 4
11 5
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
push   %rbp
mov    $0x34,%edx
mov    %edi,%ebp
mov    $0x0,%esi
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  1c <hash_create+0x1c>
test   %ebp,%ebp
mov    %rax,%rbx
je     78 <hash_create+0x78>
movslq %ebp,%rdi
mov    $0x39,%edx
mov    $0x0,%esi
shl    $0x3,%rdi
callq  39 <hash_create+0x39>
test   %ebp,%ebp
mov    %rax,(%rbx)
mov    %ebp,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    %rax,%rcx
jle    6b <hash_create+0x6b>
xor    %edx,%edx
jmp    5b <hash_create+0x5b>
nopl   0x0(%rax)
mov    (%rbx),%rcx
movq   $0x0,(%rcx,%rdx,8)
add    $0x1,%rdx
cmp    %edx,%ebp
jg     58 <hash_create+0x58>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    $0x39,%edx
mov    $0x0,%esi
mov    $0x400,%edi
callq  8c <hash_create+0x8c>
mov    $0x80,%ebp
mov    %rax,(%rbx)
movl   $0x80,0x8(%rbx)
movl   $0x0,0xc(%rbx)
mov    %rax,%rcx
jmp    4d <hash_create+0x4d>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_create (buckets)
     int buckets;
{
  HASH_TABLE *new_table;
  register int i;
  new_table = (HASH_TABLE *)sh_xmalloc((sizeof (HASH_TABLE)), "hashlib.c", 52);
  if (buckets == 0)
    buckets = 128;
  new_table->bucket_array =
    (BUCKET_CONTENTS **)sh_xmalloc((buckets * sizeof (BUCKET_CONTENTS *)), "hashlib.c", 57);
  new_table->nbuckets = buckets;
  new_table->nentries = 0;
  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)((void *)0);
  return (new_table);
}
<<<sep_in_sample>>>
1 3
2 6
3 3
4 6
5 6
6 3
7 3
8 6
9 7
10 6
11 7
12 10
13 10
14 10
15 10
16 10
17 13
18 9
19 11
20 12
21 13
22 13
23 3
24 3
25 3
26 3
27 14
28 14
29 13
30 13
31 16
32 16
33 16
34 16
35 16
36 16
37 10
38 10
39 10
40 10
41 8
42 9
43 11
44 12
45 12
46 12
47 12
<<<sep_out_sample>>>
push   %r13
mov    $0x22,%edi
push   %r12
push   %rbp
push   %rbx
mov    $0x22,%ebx
sub    $0x8,%rsp
callq  19 <xgethostname+0x19>
mov    %rax,%rbp
callq  21 <xgethostname+0x21>
mov    %rax,%r13
jmp    48 <xgethostname+0x48>
nopw   %cs:0x0(%rax,%rax,1)
cmpb   $0x0,(%r12)
je     90 <xgethostname+0x90>
add    %rbx,%rbx
mov    %rbp,%rdi
mov    %rbx,%rsi
callq  45 <xgethostname+0x45>
mov    %rax,%rbp
lea    -0x2(%rbx),%r12d
movl   $0x0,0x0(%r13)
xor    %eax,%eax
mov    %rbx,%rsi
mov    %rbp,%rdi
movslq %r12d,%r12
add    %rbp,%r12
movb   $0x0,(%r12)
callq  6c <xgethostname+0x6c>
test   %eax,%eax
je     30 <xgethostname+0x30>
mov    0x0(%r13),%esi
cmp    $0x24,%esi
je     37 <xgethostname+0x37>
test   %esi,%esi
je     37 <xgethostname+0x37>
mov    $0x0,%edx
mov    $0x1,%edi
xor    %eax,%eax
callq  8e <xgethostname+0x8e>
jmp    37 <xgethostname+0x37>
add    $0x8,%rsp
mov    %rbp,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
xgethostname ()
{
  char *hostname;
  size_t size;
  int err;
  size = 34;
  hostname = ((char *) xmalloc (sizeof (char) * (size)));
  while (1)
    {
      int k = size - 2;
      (*__errno_location ()) = 0;
      hostname[k] = '\0';
      err = gethostname (hostname, size);
      if (err == 0 && hostname[k] == '\0')
 break;
      else if (err != 0 && (*__errno_location ()) != 36 && (*__errno_location ()) != 0)
 error (1, (*__errno_location ()), "gethostname");
      size *= 2;
      hostname = ((char *) xrealloc ((void *) (hostname), sizeof (char) * (size)));
    }
  return hostname;
}
<<<sep_in_sample>>>
1 2
2 7
3 2
4 2
5 2
6 6
7 2
8 7
9 7
10 7
11 7
12 7
13 7
14 14
15 14
16 18
17 19
18 19
19 19
20 19
21 10
22 11
23 13
24 13
25 13
26 12
27 12
28 12
29 13
30 14
31 14
32 16
33 16
34 16
35 16
36 16
37 17
38 17
39 17
40 17
41 17
42 22
43 22
44 22
45 22
46 22
47 22
48 22
<<<sep_out_sample>>>
movsbl %sil,%esi
xor    %edx,%edx
jmpq   cb <indexof+0xb>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
indexof(str string, char chr)
{
 return __do_indexof(string, chr, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   2c9a <delete_all_variables+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delete_all_variables (hashed_vars)
     HASH_TABLE *hashed_vars;
{
  hash_flush (hashed_vars, free_variable_hash_data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
xor    %edx,%edx
mov    %esi,%ebx
mov    $0x4,%esi
callq  11af <unknown_preprocessing_directive+0xf>
mov    0x0(%rip),%rcx        # 11b6 <unknown_preprocessing_directive+0x16>
mov    %rax,%rsi
mov    %ebx,%edx
xor    %eax,%eax
mov    $0x0,%edi
callq  11c7 <unknown_preprocessing_directive+0x27>
mov    0x0(%rip),%eax        # 11cd <unknown_preprocessing_directive+0x2d>
test   %eax,%eax
je     11db <unknown_preprocessing_directive+0x3b>
movl   $0x1,0x0(%rip)        # 11db <unknown_preprocessing_directive+0x3b>
pop    %rbx
retq   
nopl   (%rax)
<<<sep_in_sample>>>
unknown_preprocessing_directive(const char *word, int lineno)
{
 word = strtrim(word, 4, ((void *)0));
 warning("unknown preprocessing directive '%s'. [+%d %s]", word, lineno, curpfile);
 if (colorize_warned_line)
  warned = 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 7
17 7
18 7
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 13 <__gmpf_init_set_si+0x13>
mov    %eax,(%rdi)
lea    0x8(,%rax,8),%rdi
callq  *0x0(%rip)        # 23 <__gmpf_init_set_si+0x23>
test   %rbp,%rbp
mov    %rax,0x10(%rbx)
js     50 <__gmpf_init_set_si+0x50>
mov    %rbp,(%rax)
setne  %al
movzbl %al,%edx
movzbl %al,%eax
mov    %rdx,0x8(%rbx)
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
neg    %rbp
mov    %rbp,(%rax)
mov    $0xffffffff,%eax
movq   $0x1,0x8(%rbx)
mov    %eax,0x4(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmpf_init_set_si (mpf_ptr r, long int val)
{
  mp_size_t prec = __gmp_default_fp_limb_precision;
  mp_size_t size;
  mp_limb_t vl;
  r->_mp_prec = prec;
  r->_mp_d = ((mp_limb_t *) (*__gmp_allocate_func) ((prec + 1) * sizeof (mp_limb_t)));
  vl = (mp_limb_t) ((val) >= 0 ? ((unsigned long int) (val)) : (- (((unsigned long int) ((val) + 1)) - 1)));
  r->_mp_d[0] = vl & ((~ ((mp_limb_t) (0))) >> 0);
  size = vl != 0;
  r->_mp_exp = size;
  r->_mp_size = val >= 0 ? size : -size;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 6
8 7
9 7
10 8
11 7
12 8
13 9
14 10
15 10
16 12
17 10
18 12
19 13
20 13
21 13
22 13
23 13
24 8
25 8
26 12
27 11
28 12
29 13
30 13
31 13
32 13
<<<sep_out_sample>>>
mov    %edi,%edi
mov    0x0(,%rdi,4),%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_is_trace_level_activate (osip_trace_level_t level)
{
  return tracing_table[level];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1e1 <xdr_dis_entity_type+0x11>
test   %eax,%eax
jne    1f0 <xdr_dis_entity_type+0x20>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
lea    0x1(%rbp),%rsi
mov    %rbx,%rdi
callq  1fc <xdr_dis_entity_type+0x2c>
test   %eax,%eax
je     1e5 <xdr_dis_entity_type+0x15>
lea    0x2(%rbp),%rsi
mov    %rbx,%rdi
callq  20c <xdr_dis_entity_type+0x3c>
test   %eax,%eax
je     1e5 <xdr_dis_entity_type+0x15>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  21c <xdr_dis_entity_type+0x4c>
test   %eax,%eax
je     1e5 <xdr_dis_entity_type+0x15>
lea    0x5(%rbp),%rsi
mov    %rbx,%rdi
callq  22c <xdr_dis_entity_type+0x5c>
test   %eax,%eax
je     1e5 <xdr_dis_entity_type+0x15>
lea    0x6(%rbp),%rsi
mov    %rbx,%rdi
callq  23c <xdr_dis_entity_type+0x6c>
mov    %eax,%edx
xor    %eax,%eax
test   %edx,%edx
je     1e7 <xdr_dis_entity_type+0x17>
lea    0x7(%rbp),%rsi
mov    %rbx,%rdi
callq  250 <xdr_dis_entity_type+0x80>
test   %eax,%eax
setne  %al
movzbl %al,%eax
jmp    1e7 <xdr_dis_entity_type+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_entity_type(xdrs, objp)
	XDR *xdrs;
	dis_entity_type *objp;
{
	if (!xdr_byte_u_char(xdrs, &objp->kind)) {
		return (FALSE);
	}
	if (!xdr_byte_u_char(xdrs, &objp->domain)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->country)) {
		return (FALSE);
	}
	if (!xdr_byte_u_char(xdrs, &objp->category)) {
		return (FALSE);
	}
	if (!xdr_byte_u_char(xdrs, &objp->subcategory)) {
		return (FALSE);
	}
	if (!xdr_byte_u_char(xdrs, &objp->specific)) {
		return (FALSE);
	}
	if (!xdr_byte_u_char(xdrs, &objp->extra)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 6
10 27
11 27
12 27
13 27
14 27
15 8
16 8
17 8
18 8
19 8
20 11
21 11
22 11
23 11
24 11
25 14
26 14
27 14
28 14
29 14
30 17
31 17
32 17
33 17
34 17
35 20
36 20
37 20
38 20
39 21
40 20
41 20
42 23
43 23
44 23
45 23
46 23
47 23
48 23
49 23
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  21d2 <gsl_stats_ushort_variance+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   21e4 <gsl_stats_ushort_variance+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ushort_variance (const unsigned short data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_ushort_mean (data, stride, n);
  return gsl_stats_ushort_variance_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     24a <yy_flush_buffer+0x4a>
mov    0x8(%rdi),%rax
movl   $0x0,0x1c(%rdi)
movb   $0x0,(%rax)
mov    0x8(%rdi),%rax
movb   $0x0,0x1(%rax)
mov    0x8(%rdi),%rax
movl   $0x1,0x28(%rdi)
movl   $0x0,0x38(%rdi)
mov    %rax,0x10(%rdi)
mov    0x0(%rip),%rax        # 238 <yy_flush_buffer+0x38>
test   %rax,%rax
je     24a <yy_flush_buffer+0x4a>
mov    0x0(%rip),%rdx        # 244 <yy_flush_buffer+0x44>
cmp    (%rax,%rdx,8),%rdi
je     250 <yy_flush_buffer+0x50>
repz retq 
nopl   0x0(%rax)
jmpq   0 <yy_load_buffer_state>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yy_flush_buffer (YY_BUFFER_STATE b )
{
     if ( ! b )
  return;
 b->yy_n_chars = 0;
 b->yy_ch_buf[0] = 0;
 b->yy_ch_buf[1] = 0;
 b->yy_buf_pos = &b->yy_ch_buf[0];
 b->yy_at_bol = 1;
 b->yy_buffer_status = 0;
 if ( b == ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) )
  yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 5
5 6
6 7
7 7
8 8
9 9
10 10
11 8
12 11
13 11
14 11
15 11
16 11
17 11
18 11
19 11
20 12
21 12
<<<sep_out_sample>>>
xor    %ecx,%ecx
jmpq   2ba0 <do_parse_xmin>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_amin (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return do_parse_xmin (entry, argv, arg_ptr, XVAL_ATIME);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yywrap ()
{
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x20(%rdi),%rdi
mov    0x0(%rip),%rsi        # 16 <print_function_name+0x16>
callq  1b <print_function_name+0x1b>
mov    0x74(%rbx),%ecx
test   %ecx,%ecx
js     3d <print_function_name+0x3d>
mov    0x0(%rip),%rcx        # 29 <print_function_name+0x29>
mov    $0x2,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  3d <print_function_name+0x3d>
mov    0x68(%rbx),%rdx
test   %rdx,%rdx
je     61 <print_function_name+0x61>
mov    0x48(%rbx),%rcx
mov    0x50(%rbx),%r8d
mov    $0x0,%esi
mov    0x0(%rip),%rdi        # 5a <print_function_name+0x5a>
xor    %eax,%eax
callq  61 <print_function_name+0x61>
mov    0x38(%rbx),%edx
test   %edx,%edx
jne    a8 <print_function_name+0xa8>
mov    0x78(%rbx),%edx
test   %edx,%edx
jne    88 <print_function_name+0x88>
mov    0x0(%rip),%eax        # 75 <print_function_name+0x75>
test   %eax,%eax
jne    7d <print_function_name+0x7d>
test   %ebp,%ebp
jne    c8 <print_function_name+0xc8>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    0x0(%rip),%rcx        # 8f <print_function_name+0x8f>
mov    $0x4,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  a3 <print_function_name+0xa3>
jmp    6f <print_function_name+0x6f>
nopl   (%rax)
mov    0x0(%rip),%rdi        # af <print_function_name+0xaf>
add    $0x8,%rsp
sub    $0x1,%edx
pop    %rbx
pop    %rbp
mov    $0x0,%esi
xor    %eax,%eax
jmpq   c4 <print_function_name+0xc4>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # cf <print_function_name+0xcf>
add    $0x8,%rsp
mov    $0x3a,%edi
pop    %rbx
pop    %rbp
jmpq   df <print_function_name+0xdf>
nop
<<<sep_in_sample>>>
print_function_name(Symbol *sym, int has_subtree)
{
     fprintf(outfile, "%s", sym->name);
     if (sym->arity >= 0)
   fprintf(outfile, "()");
     if (sym->decl)
   fprintf(outfile, " <%s at %s:%d>",
    sym->decl,
    sym->source,
    sym->def_line);
     if (sym->active) {
   fprintf(outfile, " (recursive: see %d)", sym->active-1);
   return;
     }
     if (sym->recursive)
   fprintf(outfile, " (R)");
     if (!print_as_tree && has_subtree)
   fprintf(outfile, ":");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 5
16 5
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 7
26 11
27 11
28 11
29 15
30 15
31 15
32 17
33 17
34 17
35 17
36 17
37 19
38 19
39 19
40 19
41 19
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 12
50 19
51 12
52 19
53 19
54 12
55 12
56 12
57 12
58 18
59 19
60 18
61 19
62 19
63 18
64 18
<<<sep_out_sample>>>
mov    0x14(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ip_server_get_fd (mu_ip_server_t srv)
{
  return srv->fd;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     4020 <gsl_fft_complex_wavetable_float_free+0x30>
mov    0x410(%rdi),%rdi
callq  4005 <gsl_fft_complex_wavetable_float_free+0x15>
movq   $0x0,0x410(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   4019 <gsl_fft_complex_wavetable_float_free+0x29>
nopl   0x0(%rax)
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_wavetable_float_free (gsl_fft_complex_wavetable_float * wavetable)
{
  if (!wavetable) { return ; };
  free (wavetable->trig);
  wavetable->trig = ((void *)0);
  free (wavetable) ;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
mov    $0x1370,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sobol_state_size(unsigned int dimension)
{
  return sizeof(sobol_state_t);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 10db <grecs_preproc_done+0xb>
callq  10e0 <grecs_preproc_done+0x10>
mov    0x0(%rip),%rdi        # 10e7 <grecs_preproc_done+0x17>
movq   $0x0,0x0(%rip)        # 10f2 <grecs_preproc_done+0x22>
callq  10f7 <grecs_preproc_done+0x27>
mov    0x0(%rip),%rdi        # 10fe <grecs_preproc_done+0x2e>
movq   $0x0,0x0(%rip)        # 1109 <grecs_preproc_done+0x39>
movq   $0x0,0x0(%rip)        # 1114 <grecs_preproc_done+0x44>
callq  1119 <grecs_preproc_done+0x49>
mov    0x0(%rip),%rdi        # 1120 <grecs_preproc_done+0x50>
movq   $0x0,0x0(%rip)        # 112b <grecs_preproc_done+0x5b>
movq   $0x0,0x0(%rip)        # 1136 <grecs_preproc_done+0x66>
movq   $0x0,0x0(%rip)        # 1141 <grecs_preproc_done+0x71>
callq  1146 <grecs_preproc_done+0x76>
movq   $0x0,0x0(%rip)        # 1151 <grecs_preproc_done+0x81>
movq   $0x0,0x0(%rip)        # 115c <grecs_preproc_done+0x8c>
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_preproc_done()
{
 grecs_symtab_free(incl_sources);
 incl_sources = ((void *)0);
 grecs_free(linebuf);
 linebuf = ((void *)0);
 bufsize = 0;
 grecs_free(putback_buffer);
 putback_buffer = ((void *)0);
 putback_size = putback_max = 0;
 free(linebufbase);
 linebufbase = ((void *)0);
 linebufsize = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 4
6 5
7 8
8 6
9 7
10 8
11 11
12 9
13 10
14 10
15 11
16 12
17 13
18 14
19 14
20 14
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
mov    %edx,%ebp
push   %rbx
mov    %rsi,%rbx
sub    $0xa8,%rsp
mov    0x8(%rdi),%rsi
mov    %rbx,%rdi
callq  aaa <_mbox_is_scheme+0x1a>
test   %eax,%eax
je     ac0 <_mbox_is_scheme+0x30>
mov    %ebp,%eax
and    $0x2,%eax
add    $0xa8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %rbx,%rdi
callq  ac8 <_mbox_is_scheme+0x38>
test   %eax,%eax
je     ab3 <_mbox_is_scheme+0x23>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
callq  ad9 <_mbox_is_scheme+0x49>
mov    0x8(%rsp),%rdi
lea    0x10(%rsp),%rsi
callq  ae8 <_mbox_is_scheme+0x58>
test   %eax,%eax
js     b30 <_mbox_is_scheme+0xa0>
mov    0x28(%rsp),%edx
and    $0xf000,%edx
cmp    $0x2000,%edx
je     b08 <_mbox_is_scheme+0x78>
xor    %eax,%eax
cmp    $0x8000,%edx
jne    b1b <_mbox_is_scheme+0x8b>
mov    %ebp,%ecx
mov    $0x2,%eax
and    $0x2,%ecx
cmpq   $0x0,0x40(%rsp)
cmovne %ecx,%eax
and    $0x1,%ebp
je     ab3 <_mbox_is_scheme+0x23>
mov    %eax,%ecx
or     $0x1,%ecx
cmp    $0x4000,%edx
cmove  %ecx,%eax
jmp    ab3 <_mbox_is_scheme+0x23>
xor    %eax,%eax
jmpq   ab3 <_mbox_is_scheme+0x23>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_mbox_is_scheme (mu_record_t record, mu_url_t url, int flags)
{
  int rc = 0;
  if (mu_url_is_scheme (url, record->scheme))
    return 0x002 & flags;
  if (mu_scheme_autodetect_p (url))
    {
      struct stat st;
      const char *path;
      mu_url_sget_path (url, &path);
      if (stat (path, &st) < 0)
 return 0;
      if (((((st.st_mode)) & 0170000) == (0100000)) || ((((st.st_mode)) & 0170000) == (0020000)))
 {
   if (st.st_size == 0)
     {
       rc |= 0x002;
     }
   else if (flags & 0x002)
     {
       rc |= 0x002;
     }
 }
      if ((flags & 0x001)
   && ((((st.st_mode)) & 0170000) == (0040000)))
 rc |= 0x001;
    }
  return rc;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 29
14 29
15 29
16 29
17 29
18 6
19 6
20 6
21 6
22 10
23 10
24 10
25 11
26 11
27 11
28 11
29 11
30 13
31 13
32 13
33 13
34 3
35 13
36 13
37 3
38 17
39 3
40 3
41 3
42 24
43 24
44 26
45 26
46 26
47 26
48 26
49 12
50 12
51 12
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
mov    0x10(%rax),%rdi
jmpq   9d <dwname_hash+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
dwname_hash(void *data, unsigned long hashsize)
{
 struct dwref *sym = data;
 return hash_string(sym->dw->dirname, hashsize);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authentication_info_get_rspauth (osip_authentication_info_t * authentication_info)
{
  return authentication_info->rspauth;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0xffffffffffffffff,%rsi
je     aec <setmtime+0x2c>
sub    $0x18,%rsp
mov    0x0(%rip),%rax        # ad3 <setmtime+0x13>
mov    %rsi,0x8(%rsp)
mov    %rsp,%rsi
mov    0x50(%rax),%rax
mov    %rax,(%rsp)
callq  ae8 <setmtime+0x28>
add    $0x18,%rsp
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
setmtime (char const *file, time_t mtime)
{
  struct utimbuf amtime;
  if (mtime == -1)
    return 0;
  amtime.actime = (top->behavior. now);
  amtime.modtime = mtime;
  return utime (file, &amtime);
}
<<<sep_in_sample>>>
1 5
2 4
3 4
4 2
5 6
6 7
7 8
8 6
9 6
10 8
11 9
12 9
13 9
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
cmpl   $0x13,0x64(%rdi)
jle    1db7 <panel_update_path+0x17>
cmpb   $0x0,0x6d(%rdi)
jne    1dc0 <panel_update_path+0x20>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
lea    0xf(%rsp),%rdi
callq  1dca <panel_update_path+0x2a>
movslq 0x64(%rbx),%rdx
mov    0x20(%rbx),%rdi
mov    $0x20,%esi
lea    -0x13(%rdx),%ebp
callq  1ddf <panel_update_path+0x3f>
mov    0x20(%rbx),%rsi
mov    0x18(%rbx),%rdi
mov    %ebp,%edx
movslq %ebp,%r12
callq  1df1 <panel_update_path+0x51>
mov    0x20(%rbx),%rdi
mov    %r12,%rsi
callq  1dfd <panel_update_path+0x5d>
mov    0x0(%rip),%edx        # 1e03 <panel_update_path+0x63>
mov    0x0(%rip),%esi        # 1e09 <panel_update_path+0x69>
mov    0x0(%rip),%edi        # 1e0f <panel_update_path+0x6f>
callq  1e14 <panel_update_path+0x74>
mov    0x8(%rbx),%rdi
mov    $0x2,%edx
xor    %esi,%esi
callq  1e24 <panel_update_path+0x84>
mov    0x20(%rbx),%rsi
mov    0x8(%rbx),%rdi
lea    0x1(%rbp),%edx
callq  1e34 <panel_update_path+0x94>
lea    0xf(%rsp),%rdi
callq  1e3e <panel_update_path+0x9e>
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
panel_update_path(this)
    panel_t *this;
{
    size_t len;
    tty_status_t status;
    if (this->columns < (1 + 1 + 1 + 1 + 14 + 1 + 1))
 return;
    if (!this->visible)
 return;
    tty_save(&status);
    len = this->columns - (1 + 1 + 1 + 14 + 1 + 1);
    memset(this->temp, ' ', this->columns);
    truncate_long_name(this->path, this->temp, len);
    toprintable(this->temp, len);
    tty_colors(PanelColors[13], PanelColors[12], PanelColors[0]);
    window_goto(this->window, 0, 2);
    window_puts(this->window, this->temp, len + 1);
    tty_restore(&status);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 6
7 6
8 8
9 8
10 19
11 19
12 19
13 19
14 19
15 10
16 10
17 11
18 12
19 12
20 11
21 12
22 13
23 13
24 13
25 11
26 13
27 14
28 14
29 14
30 15
31 15
32 15
33 15
34 16
35 16
36 16
37 16
38 17
39 17
40 17
41 17
42 18
43 18
44 19
45 19
46 19
47 19
48 19
49 19
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x60(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
term_ostream_set_weight (term_ostream_t first_arg, term_weight_t weight)
{
  const struct term_ostream_implementation *vtable =
    ((struct term_ostream_representation_header *) (struct any_ostream_representation *) first_arg)->vtable;
  vtable->set_weight (first_arg,weight);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rsp,%rdi
callq  e3c <dico_shell+0xc>
mov    0x0(%rip),%ecx        # e42 <dico_shell+0x12>
test   %ecx,%ecx
jne    e80 <dico_shell+0x50>
mov    0x0(%rip),%eax        # e4c <dico_shell+0x1c>
test   %eax,%eax
jne    e5a <dico_shell+0x2a>
movl   $0x2e,0x0(%rip)        # e5a <dico_shell+0x2a>
mov    %rsp,%rdx
mov    $0x0,%esi
xor    %edi,%edi
callq  e69 <dico_shell+0x39>
mov    %rsp,%rdi
callq  e71 <dico_shell+0x41>
add    $0x28,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x0,%esi
mov    $0x0,%edi
callq  e8f <dico_shell+0x5f>
mov    0x0(%rip),%edx        # e95 <dico_shell+0x65>
test   %edx,%edx
jne    e46 <dico_shell+0x16>
callq  e9e <dico_shell+0x6e>
jmp    e46 <dico_shell+0x16>
<<<sep_in_sample>>>
dico_shell()
{
    struct init_script dat;
    shell_init(&dat);
    if (interactive) {
 xdico_assign_string(&prompt, "dico> ");
 if (!quiet_option)
     shell_banner();
    }
    if (!cmdprefix)
 cmdprefix = '.';
    parse_script_file(((void *)0), shell_getline, &dat);
    shell_finish(&dat);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 10
8 10
9 10
10 11
11 12
12 12
13 12
14 12
15 13
16 13
17 14
18 14
19 14
20 6
21 6
22 6
23 7
24 7
25 7
26 8
27 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    $0x250,%edi
callq  8e <stream_create+0xe>
mov    %rax,(%rbx)
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stream_create (struct net_stream **str)
{
  *str = xzalloc (sizeof **str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%r9
mov    %rdx,%r8
shr    %r8
je     cf3 <gsl_vector_long_reverse+0x53>
lea    -0x8(,%rdx,8),%rdx
mov    %r9,%r10
xor    %ecx,%ecx
neg    %r10
imul   %r9,%rdx
shl    $0x3,%r10
shl    $0x3,%r9
add    %rax,%rdx
nopw   0x0(%rax,%rax,1)
mov    (%rdx),%rsi
mov    (%rax),%rdi
add    $0x1,%rcx
mov    %rdi,(%rdx)
mov    %rsi,(%rax)
add    %r10,%rdx
add    %r9,%rax
cmp    %r8,%rcx
jne    cd8 <gsl_vector_long_reverse+0x38>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_reverse (gsl_vector_long * v)
{
  long * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 1 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 1; k++)
        {
          long tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 5
4 8
5 8
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 14
17 15
18 8
19 15
20 16
21 16
22 16
23 8
24 8
25 20
26 20
27 20
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     4e0 <gsl_permutation_mul+0x30>
mov    $0x4,%ecx
mov    $0xee,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4d5 <gsl_permutation_mul+0x25>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nop
cmp    (%rdx),%rcx
je     510 <gsl_permutation_mul+0x60>
mov    $0x4,%ecx
mov    $0xf3,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4fe <gsl_permutation_mul+0x4e>
mov    $0x4,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
test   %rcx,%rcx
je     53d <gsl_permutation_mul+0x8d>
mov    0x8(%rdi),%r8
mov    0x8(%rsi),%rsi
xor    %eax,%eax
mov    0x8(%rdx),%rdi
nopl   0x0(%rax,%rax,1)
mov    (%rsi,%rax,8),%rdx
mov    (%rdi,%rdx,8),%rdx
mov    %rdx,(%r8,%rax,8)
add    $0x1,%rax
cmp    %rcx,%rax
jne    528 <gsl_permutation_mul+0x78>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permutation_mul (gsl_permutation * p, const gsl_permutation * pa, const gsl_permutation * pb)
{
  size_t i;
  const size_t size = p->size;
  if (pa->size != size)
    {
      do { gsl_error ("size of result does not match size of pa", "permutation.c", 238, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  if (pb->size != size)
    {
      do { gsl_error ("size of result does not match size of pb", "permutation.c", 243, GSL_EINVAL) ; return GSL_EINVAL ; } while (0);
    }
  for (i = 0; i < size; i++)
    {
      p->data[i] = pb->data[pa->data[i]];
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 7
11 18
12 18
13 18
14 9
15 9
16 11
17 11
18 11
19 11
20 11
21 11
22 18
23 18
24 18
25 13
26 13
27 13
28 13
29 13
30 13
31 13
32 15
33 15
34 15
35 13
36 13
37 13
38 17
39 18
40 18
41 18
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    (%rdx),%rax
cmp    0x8(%rdx),%rax
je     1c00 <gsl_blas_ssyr+0x30>
mov    $0x14,%ecx
mov    $0x4c1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1bf6 <gsl_blas_ssyr+0x26>
mov    $0x14,%eax
add    $0x18,%rsp
retq   
cmp    (%rsi),%rax
je     1c30 <gsl_blas_ssyr+0x60>
mov    $0x13,%ecx
mov    $0x4c5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1c1e <gsl_blas_ssyr+0x4e>
mov    $0x13,%eax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x18(%rdx),%r9
mov    0x10(%rdx),%rdx
mov    0x8(%rsi),%r8
mov    0x10(%rsi),%rcx
mov    %edi,%esi
mov    $0x65,%edi
mov    %edx,(%rsp)
mov    %eax,%edx
callq  1c51 <gsl_blas_ssyr+0x81>
xor    %eax,%eax
jmp    1bfb <gsl_blas_ssyr+0x2b>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
               gsl_matrix_float * A)
{
  const size_t M = A->size1;
  const size_t N = A->size2;
  if (M != N)
    {
      do { gsl_error ("matrix must be square", "blas.c", 1217, GSL_ENOTSQR) ; return GSL_ENOTSQR ; } while (0);
    }
  else if (X->size != N)
    {
      do { gsl_error ("invalid length", "blas.c", 1221, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  cblas_ssyr (CblasRowMajor, Uplo, ((int)(N)), alpha, X->data, ((int)(X->stride)),
              A->data, ((int)(A->tda)));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 8
6 8
7 8
8 8
9 8
10 8
11 17
12 17
13 10
14 10
15 12
16 12
17 12
18 12
19 12
20 12
21 17
22 17
23 17
24 14
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rsi
callq  202c <gsl_sf_airy_Bi+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    2040 <gsl_sf_airy_Bi+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x35d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  2056 <gsl_sf_airy_Bi+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_airy_Bi(const double x, gsl_mode_t mode)
{
  gsl_sf_result result; int status = gsl_sf_airy_Bi_e(x, mode, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_airy_Bi_e(x, mode, &result)", "airy.c", 861, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
callq  2c9 <closepipe+0x9>
lea    0xc(%rsp),%rsi
xor    %edx,%edx
mov    $0xffffffff,%edi
xor    %eax,%eax
callq  2dc <closepipe+0x1c>
add    $0x18,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
closepipe(int handle)
{
  int statloc;
  close(handle);
  waitpid(-1, &statloc, 0);
}
<<<sep_in_sample>>>
1 2
2 4
3 5
4 5
5 5
6 5
7 5
8 6
9 6
10 6
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0x88,%edx
mov    $0x1b,%esi
mov    $0x0,%edi
jmpq   1e19 <sort_commands+0x19>
nopl   0x0(%rax)
<<<sep_in_sample>>>
sort_commands ()
{
  qsort (command_tab, sizeof (command_tab) / sizeof (command_tab[0]) - 1,
  sizeof (command_tab[0]), cmdcmp);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  cfe <mu_auth_finish_setup+0xe>
mov    $0x0,%edi
callq  d08 <mu_auth_finish_setup+0x18>
mov    $0x0,%edi
callq  d12 <mu_auth_finish_setup+0x22>
mov    0x0(%rip),%rax        # d19 <mu_auth_finish_setup+0x29>
movq   $0x0,0x0(%rip)        # d24 <mu_auth_finish_setup+0x34>
mov    %rax,0x0(%rip)        # d2b <mu_auth_finish_setup+0x3b>
mov    0x0(%rip),%rax        # d32 <mu_auth_finish_setup+0x42>
movq   $0x0,0x0(%rip)        # d3d <mu_auth_finish_setup+0x4d>
mov    %rax,0x0(%rip)        # d44 <mu_auth_finish_setup+0x54>
mov    0x0(%rip),%rax        # d4b <mu_auth_finish_setup+0x5b>
movq   $0x0,0x0(%rip)        # d56 <mu_auth_finish_setup+0x66>
mov    %rax,0x0(%rip)        # d5d <mu_auth_finish_setup+0x6d>
add    $0x8,%rsp
jmpq   d66 <mu_auth_finish_setup+0x76>
<<<sep_in_sample>>>
mu_auth_finish_setup ()
{
  mu_list_destroy (&mu_authenticate_list);
  mu_list_destroy (&mu_auth_by_name_list);
  mu_list_destroy (&mu_auth_by_uid_list);
  mu_authenticate_list = _tmp_authenticate_list;
  _tmp_authenticate_list = ((void *)0);
  mu_auth_by_name_list = _tmp_auth_by_name_list;
  _tmp_auth_by_name_list = ((void *)0);
  mu_auth_by_uid_list = _tmp_auth_by_uid_list;
  _tmp_auth_by_uid_list = ((void *)0);
  mu_auth_begin_setup ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 5
7 5
8 6
9 7
10 6
11 8
12 9
13 8
14 10
15 11
16 10
17 13
18 12
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm1        # 48 <sign+0x8>
movsd  0x0(%rip),%xmm1        # 50 <sign+0x10>
andpd  %xmm1,%xmm0
jb     60 <sign+0x20>
repz retq 
nopl   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm1        # 68 <sign+0x28>
xorpd  %xmm1,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
sign(double a,double b)
{
 if(b>=0.) return(+1.*fabs(a));
 else return(-1.*fabs(a));
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    %rsp,%rsi
callq  1753 <mu_url_is_same_auth+0x13>
test   %eax,%eax
mov    %eax,%ebx
setne  %bpl
cmp    $0x1028,%eax
je     1778 <mu_url_is_same_auth+0x38>
test   %bpl,%bpl
je     1778 <mu_url_is_same_auth+0x38>
xor    %eax,%eax
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
lea    0x8(%rsp),%rsi
mov    %r12,%rdi
callq  1785 <mu_url_is_same_auth+0x45>
cmp    $0x1028,%eax
jne    17b8 <mu_url_is_same_auth+0x78>
cmp    %eax,%ebx
jne    179a <mu_url_is_same_auth+0x5a>
test   %bpl,%bpl
mov    $0x1,%eax
jne    1769 <mu_url_is_same_auth+0x29>
mov    0x8(%rsp),%rsi
mov    (%rsp),%rdi
callq  17a8 <mu_url_is_same_auth+0x68>
test   %eax,%eax
sete   %al
movzbl %al,%eax
jmp    1769 <mu_url_is_same_auth+0x29>
nopw   0x0(%rax,%rax,1)
test   %eax,%eax
je     178c <mu_url_is_same_auth+0x4c>
jmp    1767 <mu_url_is_same_auth+0x27>
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_url_is_same_auth (mu_url_t url1, mu_url_t url2) { const char *s1, *s2; int status1, status2; status1 = mu_url_sget_auth (url1, &s1); if (status1 && status1 != (0x1000 +40)) return 0; status2 = mu_url_sget_auth (url2, &s2); if (status2 && status2 != (0x1000 +40)) return 0; if (status1 && status1 == status2) return 1; return mu_c_strcasecmp (s1, s2) == 0; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
30 1
31 1
32 1
33 1
34 1
35 1
36 1
37 1
38 1
39 1
40 1
41 1
42 1
43 1
<<<sep_out_sample>>>
push   %r14
push   %r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
sub    $0x10,%rsp
test   %rdx,%rdx
je     16e0 <gsl_block_long_double_raw_fscanf+0x80>
shl    $0x4,%rcx
mov    %rdi,%r13
mov    %rsi,%rbx
mov    %rcx,%r14
xor    %ebp,%ebp
jmp    1694 <gsl_block_long_double_raw_fscanf+0x34>
nopl   (%rax)
add    $0x1,%rbp
add    %r14,%rbx
cmp    %r12,%rbp
je     16e0 <gsl_block_long_double_raw_fscanf+0x80>
xor    %eax,%eax
mov    %rsp,%rdx
mov    $0x0,%esi
mov    %r13,%rdi
callq  16a6 <gsl_block_long_double_raw_fscanf+0x46>
fldt   (%rsp)
cmp    $0x1,%eax
fstpt  (%rbx)
je     1688 <gsl_block_long_double_raw_fscanf+0x28>
mov    $0x5,%ecx
mov    $0xa5,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  16c9 <gsl_block_long_double_raw_fscanf+0x69>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax,%rax,1)
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
gsl_block_long_double_raw_fscanf (FILE * stream,
                                  long double * data,
                                  const size_t n,
                                  const size_t stride)
{
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 1; k++)
        {
          long double tmp;
          int status = fscanf (stream, "%Lg", &tmp) ;
          data [1 * i * stride + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 165, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 7
20 7
21 13
22 13
23 13
24 13
25 13
26 14
27 15
28 14
29 15
30 17
31 17
32 17
33 17
34 17
35 22
36 17
37 22
38 22
39 22
40 22
41 22
42 22
43 22
44 22
45 21
46 22
47 22
48 22
49 22
50 22
51 22
52 22
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%edx        # 6e0a <info_toggle_regexp+0xa>
xor    %eax,%eax
test   %edx,%edx
sete   %al
test   %eax,%eax
mov    %eax,0x0(%rip)        # 6e19 <info_toggle_regexp+0x19>
jne    6e38 <info_toggle_regexp+0x38>
mov    $0x0,%edi
callq  6e25 <info_toggle_regexp+0x25>
add    $0x8,%rsp
mov    %rax,%rdi
xor    %eax,%eax
jmpq   6e33 <info_toggle_regexp+0x33>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  6e42 <info_toggle_regexp+0x42>
add    $0x8,%rsp
mov    %rax,%rdi
xor    %eax,%eax
jmpq   6e50 <wipe_seen_flags>
<<<sep_in_sample>>>
info_toggle_regexp (WINDOW *window, int count)
{
  use_regex = !use_regex;
  window_message_in_echo_area (use_regex
                               ? gettext ("Using regular expressions for searches.")
                               : gettext ("Using literal strings for searches."));
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 3
8 4
9 4
10 4
11 7
12 4
13 4
14 4
15 4
16 4
17 4
18 7
19 4
20 4
21 4
<<<sep_out_sample>>>
mov    $0x10b06,%edx
jmpq   2a <Gcompile+0xa>
<<<sep_in_sample>>>
Gcompile (char const *pattern, size_t size)
{
  GEAcompile (pattern, size, ((((unsigned long int) 1) << 1) | ((((unsigned long int) 1) << 1) << 1) | ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdi
xor    %eax,%eax
movzbl (%rdi),%edx
test   %dl,%dl
je     5e <file_hash_2+0x2e>
nopl   (%rax)
movzbl %dl,%esi
movzbl 0x1(%rdi),%edx
add    $0x1,%rdi
mov    %edx,%ecx
and    $0x7,%ecx
shl    %cl,%esi
movslq %esi,%rsi
add    %rsi,%rax
test   %dl,%dl
jne    40 <file_hash_2+0x10>
repz retq 
repz retq 
<<<sep_in_sample>>>
file_hash_2 (const void *key)
{
  do { unsigned long _result_ = 0; do { unsigned char const *_key_ = (unsigned char const *) ((((struct file const *) key)->hname)) - 1; while (*++_key_) (_result_) += (*_key_ << (_key_[1] & 0x7)); } while (0); return _result_; } while (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 3
18 4
<<<sep_out_sample>>>
mov    (%rsi),%edx
cmp    %edx,(%rdi)
mov    $0x1,%eax
jg     38 <gdbm_version_cmp+0x38>
jl     30 <gdbm_version_cmp+0x30>
mov    0x4(%rsi),%ecx
cmp    %ecx,0x4(%rdi)
jg     38 <gdbm_version_cmp+0x38>
jl     30 <gdbm_version_cmp+0x30>
mov    0x8(%rsi),%ecx
cmp    %ecx,0x8(%rdi)
jg     38 <gdbm_version_cmp+0x38>
setl   %al
movzbl %al,%eax
neg    %eax
retq   
nopl   0x0(%rax,%rax,1)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
<<<sep_in_sample>>>
gdbm_version_cmp (int const a[], int const b[])
{
  if (a[0] > b[0])
    return 1;
  else if (a[0] < b[0])
    return -1;
  if (a[1] > b[1])
    return 1;
  else if (a[1] < b[1])
    return -1;
  if (a[2] > b[2])
    return 1;
  else if (a[2] < b[2])
    return -1;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 5
6 7
7 7
8 7
9 9
10 11
11 11
12 11
13 13
14 13
15 13
16 13
17 13
18 6
19 6
20 16
<<<sep_out_sample>>>
mov    $0x4,%edx
jmpq   18a <in_addr_cmp+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
in_addr_cmp(const void *elt1, const void *elt2) { return memcmp(elt1, elt2, sizeof(struct in_addr)); }
<<<sep_in_sample>>>
1 1
2 1
3 1
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     578 <sh_quote_reusable+0x98>
cmpb   $0x0,(%rdi)
jne    520 <sh_quote_reusable+0x40>
mov    $0x142,%edx
mov    $0x0,%esi
mov    $0x3,%edi
callq  50b <sh_quote_reusable+0x2b>
movb   $0x27,0x1(%rax)
movb   $0x27,(%rax)
movb   $0x0,0x2(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   (%rax)
mov    %esi,%ebp
callq  527 <sh_quote_reusable+0x47>
test   %eax,%eax
jne    560 <sh_quote_reusable+0x80>
test   %ebp,%ebp
je     550 <sh_quote_reusable+0x70>
add    $0x8,%rsp
mov    %rbx,%rdi
mov    $0x1,%edx
pop    %rbx
pop    %rbp
xor    %esi,%esi
xor    %eax,%eax
jmpq   546 <sh_quote_reusable+0x66>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %rbx,%rdi
xor    %eax,%eax
pop    %rbx
pop    %rbp
jmpq   560 <sh_quote_reusable+0x80>
add    $0x8,%rsp
mov    %rbx,%rdi
xor    %edx,%edx
pop    %rbx
pop    %rbp
xor    %esi,%esi
jmpq   572 <sh_quote_reusable+0x92>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sh_quote_reusable (s, flags)
     char *s;
     int flags;
{
  char *ret;
  if (s == 0)
    return s;
  else if (*s == 0)
    {
      ret = (char *)sh_xmalloc((3), "shquote.c", 322);
      ret[0] = ret[1] = '\'';
      ret[2] = '\0';
    }
  else if (ansic_shouldquote (s))
    ret = ansic_quote (s, 0, (int *)0);
  else if (flags)
    ret = sh_backslash_quote (s, 0, 1);
  else
    ret = sh_single_quote (s);
  return ret;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 6
7 8
8 8
9 10
10 10
11 10
12 10
13 11
14 11
15 12
16 21
17 21
18 21
19 21
20 21
21 21
22 14
23 14
24 14
25 16
26 16
27 21
28 17
29 17
30 21
31 21
32 17
33 17
34 17
35 17
36 21
37 19
38 19
39 21
40 21
41 19
42 21
43 15
44 15
45 21
46 21
47 15
48 15
49 15
50 21
51 21
52 21
53 21
54 21
55 21
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
callq  104 <stratcl_add_word+0x14>
mov    %r12,%rdi
mov    %rax,%rbx
movl   $0x1,(%rax)
callq  115 <stratcl_add_word+0x25>
mov    %rbx,%rsi
mov    %rax,0x8(%rbx)
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   128 <stratcl_add_word+0x38>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stratcl_add_word(dico_list_t list, const char *word)
{
    struct stratcl *sp = xmalloc(sizeof(*sp));
    sp->type = stratcl_word;
    sp->v.word = xstrdup(word);
    xdico_list_append(list, sp);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 3
8 5
9 3
10 4
11 5
12 6
13 5
14 6
15 7
16 7
17 7
18 6
19 6
<<<sep_out_sample>>>
mov    (%rdi),%r10
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r11
mov    0x18(%rdi),%rdi
test   %r10,%r10
mov    (%rdi),%eax
je     17cd <gsl_matrix_uint_max+0x5d>
push   %rbx
lea    0x0(,%r9,4),%rbx
shl    $0x2,%r11
xor    %r8d,%r8d
nopw   %cs:0x0(%rax,%rax,1)
test   %r9,%r9
je     17c0 <gsl_matrix_uint_max+0x50>
lea    (%rdi,%rbx,1),%rsi
mov    %rdi,%rdx
nopl   0x0(%rax)
mov    (%rdx),%ecx
cmp    %ecx,%eax
cmovb  %ecx,%eax
add    $0x4,%rdx
cmp    %rsi,%rdx
jne    17b0 <gsl_matrix_uint_max+0x40>
add    $0x1,%r8
add    %r11,%rdi
cmp    %r10,%r8
jne    17a0 <gsl_matrix_uint_max+0x30>
pop    %rbx
repz retq 
nop
<<<sep_in_sample>>>
gsl_matrix_uint_max (const gsl_matrix_uint * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned int max = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned int x = m->data[i * tda + j];
          if (x > max)
            max = x;
        }
    }
  return max;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 8
6 6
7 8
8 2
9 2
10 2
11 8
12 8
13 10
14 10
15 10
16 10
17 10
18 12
19 12
20 12
21 12
22 10
23 10
24 8
25 8
26 8
27 8
28 18
29 18
30 18
<<<sep_out_sample>>>
jmpq   65 <vplob_val+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vplob_val(VPLOB * vplob, int index)
{
 CPLOB * cplob = (CPLOB*)vplob;
 return (void*) cplob_val(cplob, index);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x48(%rsi),%rdi
mov    0x50(%rsi),%rax
sub    0x68(%rsi),%rdi
sub    0x70(%rsi),%rax
mov    %rax,%rsi
jns    f84 <pred_used+0x24>
add    $0x3b9aca00,%rsi
sub    $0x1,%rdi
mov    $0x15180,%ecx
callq  60 <pred_timewindow>
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_used (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  struct timespec delta, at, ct;
  (void) pathname;
  at = get_stat_atime (stat_buf);
  ct = get_stat_ctime (stat_buf);
  delta.tv_sec = at.tv_sec - ct.tv_sec;
  delta.tv_nsec = at.tv_nsec - ct.tv_nsec;
  if (delta.tv_nsec < 0)
    {
      delta.tv_nsec += 1000000000;
      delta.tv_sec -= 1;
    }
  return pred_timewindow (delta, pred_ptr, 86400);
}
<<<sep_in_sample>>>
1 2
2 7
3 8
4 7
5 9
6 9
7 9
8 11
9 12
10 14
11 14
12 15
13 15
14 15
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (unsigned long) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              if (*chain == p)
                {
                  char *p_begin = (char *) p - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max);
                  *chain = ((struct header *) p_begin)->next;
                  free (p_begin);
                  return;
                }
              chain = &((struct header *) ((char *) *chain - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)))->next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 9
30 18
31 14
32 13
33 14
34 15
35 8
36 8
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  4f72 <showdefinition+0x12>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 4f7c <showdefinition+0x1c>
mov    (%rax),%rdi
callq  4f84 <showdefinition+0x24>
mov    %rbx,%rdi
mov    $0x1,%esi
callq  4f91 <showdefinition+0x31>
test   %rax,%rax
mov    %rax,%rbx
je     5028 <showdefinition+0xc8>
mov    0x0(%rip),%r12        # 4fa4 <showdefinition+0x44>
jmp    500c <showdefinition+0xac>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x21,%esi
mov    %rbx,%rdi
callq  4fbd <showdefinition+0x5d>
test   %rax,%rax
jne    5028 <showdefinition+0xc8>
mov    0x0(%rip),%rax        # 4fc9 <showdefinition+0x69>
mov    %rbx,%rsi
mov    (%rax),%rdi
callq  4fd4 <showdefinition+0x74>
mov    0x0(%rip),%rax        # 4fdb <showdefinition+0x7b>
mov    (%rax),%rdi
test   %rdi,%rdi
je     4feb <showdefinition+0x8b>
mov    %rbx,%rsi
callq  4feb <showdefinition+0x8b>
lea    0x0(%rip),%rdi        # 4ff2 <showdefinition+0x92>
callq  4ff7 <showdefinition+0x97>
mov    %rbx,%rdi
mov    $0x1,%esi
callq  5004 <showdefinition+0xa4>
test   %rax,%rax
mov    %rax,%rbx
je     5028 <showdefinition+0xc8>
mov    (%r12),%rsi
mov    %rbx,%rdi
callq  5018 <showdefinition+0xb8>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  5023 <showdefinition+0xc3>
cmp    %rax,%rbp
jne    4fb0 <showdefinition+0x50>
mov    %r13,%rdi
callq  5030 <showdefinition+0xd0>
add    $0x8,%rsp
mov    $0xa,%edi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   5044 <showdefinition+0xe4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
showdefinition(char *unitstr, struct unittype *theunit)
{
  unitstr = removepadding(unitstr);
  logputs(deftext);
  unitstr = lookupunit(unitstr,1);
  while(unitstr && strspn(unitstr,digits) != strlen(unitstr) &&
        !strchr(unitstr,'!')) {
    tightprint(stdout,unitstr);
    if (logfile) tightprint(logfile,unitstr);
    logputs(" = ");
    unitstr=lookupunit(unitstr,1);
  }
  showunit(theunit);
  logputchar('\n');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 3
9 4
10 4
11 4
12 5
13 5
14 5
15 6
16 5
17 6
18 6
19 6
20 6
21 7
22 7
23 7
24 6
25 6
26 8
27 8
28 8
29 8
30 9
31 9
32 9
33 9
34 9
35 9
36 10
37 10
38 11
39 11
40 11
41 6
42 11
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 6
51 6
52 13
53 13
54 15
55 14
56 15
57 15
58 15
59 15
60 14
61 14
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x0(%rip),%ebx        # 1cf <smtp_authenticate+0xf>
test   %ebx,%ebx
je     218 <smtp_authenticate+0x58>
mov    0x0(%rip),%eax        # 1d9 <smtp_authenticate+0x19>
test   %eax,%eax
je     1f8 <smtp_authenticate+0x38>
mov    %rbp,%rdi
mov    $0x1,%ebx
callq  1ea <smtp_authenticate+0x2a>
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  202 <smtp_authenticate+0x42>
mov    0x0(%rip),%rdi        # 209 <smtp_authenticate+0x49>
mov    %rax,%rsi
xor    %eax,%eax
callq  213 <smtp_authenticate+0x53>
jmp    1dd <smtp_authenticate+0x1d>
nopl   (%rax)
mov    %rdi,%rdx
lea    0x8(%rsp),%rdi
xor    %eax,%eax
mov    $0x0,%esi
callq  22c <smtp_authenticate+0x6c>
test   %eax,%eax
js     1ea <smtp_authenticate+0x2a>
mov    0x8(%rsp),%rdi
callq  23a <smtp_authenticate+0x7a>
mov    0x8(%rsp),%rdi
mov    %eax,%ebx
callq  246 <smtp_authenticate+0x86>
test   %ebx,%ebx
setne  %bl
add    $0x18,%rsp
movzbl %bl,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
smtp_authenticate (const char *mech)
{
  if (args_info.server_flag)
    {
      if (!args_info.quiet_given)
 fprintf (stderr, gettext ("Using mechanism:\n"));
      puts (mech);
    }
  else
    {
      char *buf;
      int rc;
      int len;
      len = asprintf (&buf, "AUTH %s", mech);
      if (len < 0)
 return 0;
      rc = writeln (buf);
      free (buf);
      if (!rc)
 return 0;
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 5
9 5
10 5
11 7
12 22
13 7
14 23
15 23
16 23
17 23
18 23
19 23
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 14
29 14
30 14
31 14
32 14
33 15
34 15
35 17
36 17
37 18
38 17
39 18
40 22
41 22
42 23
43 22
44 23
45 23
46 23
47 23
48 23
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1376 <ea_beg_of_line+0x6>
mov    %eax,0x0(%rip)        # 137c <ea_beg_of_line+0xc>
retq   
nopl   (%rax)
<<<sep_in_sample>>>
ea_beg_of_line (WINDOW *window, int count)
{
  input_line_point = input_line_beg;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x18(%rdi),%rax
mov    0x8(%rdi),%rsi
mov    0x10(%rdi),%r9
test   %r8,%r8
je     44a <gsl_matrix_complex_long_double_set_identity+0x5a>
lea    0x10(%rax),%rdi
fldz   
shl    $0x5,%r9
xor    %ecx,%ecx
test   %rsi,%rsi
je     43c <gsl_matrix_complex_long_double_set_identity+0x4c>
mov    %rdi,%rdx
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cmp    %rax,%rcx
je     44c <gsl_matrix_complex_long_double_set_identity+0x5c>
fstpt  -0x10(%rdx)
fldt   -0x10(%rdx)
fstpt  (%rdx)
fldt   (%rdx)
add    $0x1,%rax
add    $0x20,%rdx
cmp    %rsi,%rax
jne    420 <gsl_matrix_complex_long_double_set_identity+0x30>
add    $0x1,%rcx
add    %r9,%rdi
cmp    %r8,%rcx
jne    410 <gsl_matrix_complex_long_double_set_identity+0x20>
fstp   %st(0)
repz retq 
fld1   
fstpt  -0x10(%rdx)
fstpt  (%rdx)
fldt   (%rdx)
jmp    42f <gsl_matrix_complex_long_double_set_identity+0x3f>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_set_identity (gsl_matrix_complex_long_double * m)
{
  size_t i, j;
  long double * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  const gsl_complex_long_double zero = {{0.0L,0.0L}};
  const gsl_complex_long_double one = {{1.0L,0.0L}};
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(gsl_complex_long_double *) (data + 2 * (i * tda + j)) = ((i == j) ? one : zero);
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 10
6 10
7 10
8 10
9 10
10 10
11 12
12 12
13 12
14 12
15 12
16 14
17 14
18 14
19 14
20 14
21 14
22 12
23 12
24 12
25 12
26 10
27 10
28 10
29 10
30 10
31 10
32 14
33 14
34 14
35 14
36 14
37 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     10 <rec_comment_new+0x10>
jmpq   a <rec_comment_new+0xa>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_new (char *text)
{
  if (!text)
    {
      return ((void *)0);
    }
  return strdup (text);
}
<<<sep_in_sample>>>
1 3
2 3
3 7
4 7
5 8
6 8
7 8
<<<sep_out_sample>>>
mov    %rsi,%r8
mov    %rdx,%r9
mov    0x50(%rdi),%rcx
mov    0x48(%rdi),%rdx
mov    0x40(%rdi),%rsi
jmpq   2d7 <gsl_spline2d_eval_deriv_y+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_spline2d_eval_deriv_y(const gsl_spline2d * interp, const double x,
                          const double y, gsl_interp_accel * xa, gsl_interp_accel * ya)
{
  return gsl_interp2d_eval_deriv_y(&(interp->interp_object), interp->xarr, interp->yarr,
                                   interp->zarr, x, y, xa, ya);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
push   %rbx
movapd %xmm0,%xmm4
mov    %rdi,%rbx
mov    $0x0,%edx
mov    $0x1,%eax
sub    $0x10,%rsp
subsd  0x0(%rip),%xmm4        # 14e <lngamma_lanczos+0x1e>
movsd  0x0(%rip),%xmm3        # 156 <lngamma_lanczos+0x26>
nopw   %cs:0x0(%rax,%rax,1)
cvtsi2sd %eax,%xmm2
add    $0x1,%eax
movsd  (%rdx),%xmm1
add    $0x8,%rdx
cmp    $0x9,%eax
addsd  %xmm4,%xmm2
divsd  %xmm2,%xmm1
addsd  %xmm1,%xmm3
jne    160 <lngamma_lanczos+0x30>
movapd %xmm4,%xmm0
movsd  %xmm3,0x8(%rsp)
movsd  %xmm4,(%rsp)
addsd  0x0(%rip),%xmm0        # 197 <lngamma_lanczos+0x67>
divsd  0x0(%rip),%xmm0        # 19f <lngamma_lanczos+0x6f>
callq  1a4 <lngamma_lanczos+0x74>
movsd  (%rsp),%xmm4
movsd  0x8(%rsp),%xmm3
addsd  0x0(%rip),%xmm4        # 1b7 <lngamma_lanczos+0x87>
mulsd  %xmm0,%xmm4
movapd %xmm3,%xmm0
movsd  %xmm4,(%rsp)
callq  1c9 <lngamma_lanczos+0x99>
addsd  0x0(%rip),%xmm0        # 1d1 <lngamma_lanczos+0xa1>
xor    %eax,%eax
movsd  0x0(%rip),%xmm3        # 1db <lngamma_lanczos+0xab>
movsd  0x0(%rip),%xmm2        # 1e3 <lngamma_lanczos+0xb3>
movsd  (%rsp),%xmm4
movapd %xmm0,%xmm1
andpd  %xmm2,%xmm0
subsd  %xmm3,%xmm1
addsd  %xmm4,%xmm1
andpd  %xmm2,%xmm4
addsd  %xmm0,%xmm4
movsd  %xmm1,(%rbx)
andpd  %xmm2,%xmm1
addsd  %xmm3,%xmm4
mulsd  0x0(%rip),%xmm1        # 214 <lngamma_lanczos+0xe4>
mulsd  0x0(%rip),%xmm4        # 21c <lngamma_lanczos+0xec>
addsd  %xmm1,%xmm4
movsd  %xmm4,0x8(%rbx)
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lngamma_lanczos(double x, gsl_sf_result * result)
{
  int k;
  double Ag;
  double term1, term2;
  x -= 1.0;
  Ag = lanczos_7_c[0];
  for(k=1; k<=8; k++) { Ag += lanczos_7_c[k]/(x+k); }
  term1 = (x+0.5)*log((x+7.5)/2.7182818284590452354);
  term2 = 0.9189385332046727418 + log(Ag);
  result->val = term1 + (term2 - 7.0);
  result->err = 2.0 * 2.2204460492503131e-16 * (fabs(term1) + fabs(term2) + 7.0);
  result->err += 2.2204460492503131e-16 * fabs(result->val);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 8
6 2
7 6
8 7
9 7
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 10
27 9
28 9
29 10
30 9
31 10
32 10
33 15
34 11
35 12
36 11
37 11
38 12
39 11
40 11
41 12
42 12
43 11
44 13
45 12
46 13
47 12
48 13
49 13
50 15
51 15
52 15
53 15
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x40(%rdi),%rdi
callq  2f3d <mbox_cleanup+0xd>
mov    0x18(%rbx),%rdi
pop    %rbx
jmpq   2f47 <mbox_cleanup+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_cleanup (void *arg)
{
  mu_mailbox_t mailbox = arg;
  mu_monitor_unlock (mailbox->monitor);
  mu_locker_unlock (mailbox->locker);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
push   %r12
mov    $0x20,%esi
push   %rbp
mov    $0xc,%ebp
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edi
sub    $0x10,%rsp
callq  3f <rfc822_init+0x1f>
test   %rax,%rax
mov    %rax,0x20(%rbx)
je     8e <rfc822_init+0x6e>
mov    0x8(%rbx),%rdi
lea    0x8(%rsp),%rsi
movq   $0x0,0x28(%rbx)
movq   $0x0,0x30(%rbx)
movq   $0x0,0x40(%rbx)
callq  6e <rfc822_init+0x4e>
test   %eax,%eax
mov    %eax,%ebp
je     a0 <rfc822_init+0x80>
mov    $0x1,%r12d
mov    0x20(%rbx),%rdi
mov    %r12d,%ebp
callq  86 <rfc822_init+0x66>
movq   $0x0,0x20(%rbx)
add    $0x10,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    0x8(%rsp),%rdi
mov    $0x1,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
callq  b9 <rfc822_init+0x99>
test   %eax,%eax
mov    %eax,%r12d
jne    7a <rfc822_init+0x5a>
add    $0x10,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rfc822_init (mu_filter_t filter)
{
  mu_property_t property;
  int status;
  filter->data = calloc (1, sizeof (struct rfc822));
  if (filter->data == ((void *)0))
    return 12;
  filter->_read = rfc822_read;
  filter->_readline = rfc822_readline;
  filter->_destroy = rfc822_destroy;
  if ((status = mu_stream_get_property (filter->filter_stream, &property) != 0)
      || (status = mu_property_set_value (property, "LINES", "0", 1)) != 0)
    {
      free (filter->data);
      filter->data = ((void *)0);
      return status;
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 7
5 2
6 2
7 5
8 2
9 5
10 6
11 5
12 6
13 11
14 11
15 8
16 9
17 10
18 11
19 11
20 11
21 11
22 11
23 14
24 16
25 14
26 15
27 19
28 19
29 19
30 19
31 19
32 19
33 19
34 12
35 12
36 12
37 12
38 12
39 12
40 12
41 12
42 19
43 19
44 19
45 19
46 19
47 19
48 19
<<<sep_out_sample>>>
mov    $0xffffffffffffffff,%rcx
jmpq   0 <__gmpz_aorsmul>
<<<sep_in_sample>>>
__gmpz_submul (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)
{
  __gmpz_aorsmul (w,u,v,(mp_size_t) -1);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmp    $0x0,%rdi
mov    $0x1,%eax
jle    10 <__rsigni+0x10>
repz retq 
nopl   (%rax)
setne  %al
movzbl %al,%eax
neg    %rax
retq   
<<<sep_in_sample>>>
__rsigni (long i)
{
  return ((i > 0) ? 1 : (i < 0) ? -1 : 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 3
8 3
9 4
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
xor    %eax,%eax
push   %rbp
mov    %esi,%ebp
mov    $0x8915,%esi
push   %rbx
mov    %rdi,%rbx
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%edi
callq  9bf <fh_addr+0x1f>
test   %eax,%eax
js     9e0 <fh_addr+0x40>
mov    0x8(%rbx),%rax
mov    %rbx,%rdi
mov    %ebp,%esi
pop    %rbx
pop    %rbp
mov    %r12,%rdx
lea    0x10(%rax),%rcx
pop    %r12
jmpq   9dc <fh_addr+0x3c>
nopl   0x0(%rax)
callq  9e5 <fh_addr+0x45>
mov    0x8(%rbx),%rcx
mov    (%rax),%esi
mov    $0x0,%edx
pop    %rbx
pop    %rbp
pop    %r12
mov    $0x1,%edi
xor    %eax,%eax
jmpq   a00 <fh_netmask>
<<<sep_in_sample>>>
fh_addr (format_data_t form, int argc, char *argv[])
{
  if (rpl_ioctl (form->sfd, 0x8915, form->ifr) < 0)
    error (1, (*__errno_location ()),
    "SIOCGIFADDR failed for interface `%s'",
    form->ifr->ifr_ifrn.ifrn_name);
  else
    put_addr (form, argc, argv, &form->ifr->ifr_ifru.ifru_addr);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 8
15 8
16 8
17 9
18 9
19 8
20 8
21 9
22 8
23 8
24 4
25 4
26 4
27 4
28 9
29 9
30 9
31 4
32 4
33 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdx,%rbx
sub    %rsi,%rbx
lea    0x1(%rbx),%rdi
callq  19 <alloc_string+0x19>
mov    %rbx,%rdx
mov    %rax,0x0(%rbp)
mov    %r12,%rsi
mov    %rax,%rdi
callq  2b <alloc_string+0x2b>
mov    0x0(%rbp),%rax
movb   $0x0,(%rax,%rbx,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
alloc_string (char **sptr, char *start, char *end)
{
  size_t len = end - start;
  *sptr = xmalloc (len + 1);
  memcpy (*sptr, start, len);
  (*sptr)[len] = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 5
11 4
12 5
13 5
14 5
15 6
16 6
17 7
18 7
19 7
20 7
21 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  2699 <c__scan_string+0x9>
mov    %rbx,%rdi
mov    %rax,%rsi
pop    %rbx
jmpq   26a5 <c__scan_string+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c__scan_string (const char * yystr )
{
 return c__scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
mov    $0x20,%edi
push   %rbx
callq  10c4 <debpsf_write_psf+0x14>
mov    %rbp,%rdi
mov    %rax,%rsi
mov    %rax,%rbx
callq  10d2 <debpsf_write_psf+0x22>
test   %eax,%eax
js     10fc <debpsf_write_psf+0x4c>
mov    (%rbx),%rbp
mov    %rbp,%rdi
callq  10e1 <debpsf_write_psf+0x31>
mov    %rbp,%rsi
mov    %rax,%rdx
mov    %r12d,%edi
callq  10ef <debpsf_write_psf+0x3f>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  10fa <debpsf_write_psf+0x4a>
mov    %ebp,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
debpsf_write_psf(void * v_topsf, int ofd)
{
 int ret;
 STROB * psf;
 psf = strob_open(32);
 ret = debpsf_write_psf_buf(v_topsf, psf);
 if (ret < 0) return ret;
 ret = uxfio_write(ofd, psf->str_, strlen((char*)(psf->str_)));
 strob_close(psf);
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 5
8 6
9 6
10 5
11 6
12 7
13 7
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 9
22 8
23 9
24 10
25 11
26 11
27 11
28 11
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_dest(const char *p, const char *o, char *value)
{
  return;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x28,%rsp
mov    %rdi,(%rsp)
movq   $0x100,0x18(%rsp)
mov    $0x100,%edi
callq  *0x0(%rip)        # e4 <__gmp_vasprintf+0x24>
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    %rsp,%rsi
mov    $0x0,%edi
mov    %rax,0x8(%rsp)
movq   $0x0,0x10(%rsp)
callq  105 <__gmp_vasprintf+0x45>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
__gmp_vasprintf (char **result, const char *fmt, va_list ap)
{
  struct gmp_asprintf_t d;
  do { (d).result = (result); (d).alloc = 256; (d).buf = (char *) (*__gmp_allocate_func) ((d).alloc); (d).size = 0; } while (0);
  return __gmp_doprnt (&__gmp_asprintf_funs, &d, fmt, ap);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 4
15 4
16 5
17 6
18 6
19 6
20 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 539 <mu_cfg_yyrestart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     570 <mu_cfg_yyrestart+0x40>
mov    0x0(%rip),%rdx        # 54a <mu_cfg_yyrestart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     570 <mu_cfg_yyrestart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  440 <mu_cfg_yy_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   c0 <mu_cfg_yy_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  240 <mu_cfg_yyensure_buffer_stack>
mov    0x0(%rip),%rbp        # 57c <mu_cfg_yyrestart+0x4c>
mov    0x0(%rip),%rax        # 583 <mu_cfg_yyrestart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 58f <mu_cfg_yyrestart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  599 <mu_cfg_yyrestart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    553 <mu_cfg_yyrestart+0x23>
jmp    556 <mu_cfg_yyrestart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_yyrestart (FILE * input_file )
{
 if ( ! ( (mu_cfg_yy_buffer_stack) ? (mu_cfg_yy_buffer_stack)[(mu_cfg_yy_buffer_stack_top)] : ((void *)0)) ){
        mu_cfg_yyensure_buffer_stack ();
  (mu_cfg_yy_buffer_stack)[(mu_cfg_yy_buffer_stack_top)] =
            mu_cfg_yy_create_buffer(mu_cfg_yyin,16384 );
 }
 mu_cfg_yy_init_buffer(( (mu_cfg_yy_buffer_stack) ? (mu_cfg_yy_buffer_stack)[(mu_cfg_yy_buffer_stack_top)] : ((void *)0)),input_file );
 mu_cfg_yy_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
test   %r8,%r8
je     26c <gsl_stats_float_wskew_m_sd+0x7c>
xorps  %xmm4,%xmm4
shl    $0x2,%rsi
shl    $0x2,%rcx
xor    %eax,%eax
movss  %xmm4,-0x18(%rsp)
flds   -0x18(%rsp)
fld    %st(0)
xchg   %ax,%ax
movss  (%rdi),%xmm3
ucomiss %xmm4,%xmm3
jbe    250 <gsl_stats_float_wskew_m_sd+0x60>
movss  (%rdx),%xmm2
cvtps2pd %xmm2,%xmm2
subsd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,-0x18(%rsp)
fldl   -0x18(%rsp)
movss  %xmm3,-0x18(%rsp)
flds   -0x18(%rsp)
fadd   %st,%st(2)
fld    %st(1)
fmul   %st(2),%st
fmulp  %st,%st(2)
fxch   %st(1)
fsub   %st(3),%st
fxch   %st(1)
fdiv   %st(2),%st
fmulp  %st,%st(1)
faddp  %st,%st(2)
add    $0x1,%rax
add    %rsi,%rdi
add    %rcx,%rdx
cmp    %r8,%rax
jne    210 <gsl_stats_float_wskew_m_sd+0x20>
fstp   %st(0)
fstpl  -0x10(%rsp)
movsd  -0x10(%rsp),%xmm0
retq   
xorpd  %xmm0,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_float_wskew_m_sd (const float w[], const size_t wstride,
                                const float data[],
                                const size_t stride, const size_t n,
                                const double wmean, const double wsd)
{
  long double wskew = 0;
  long double W = 0;
  size_t i;
  for (i = 0; i < n; i++)
    {
      float wi = w[i * wstride];
      if (wi > 0) {
        const long double x = (data[i * stride] - wmean) / wsd;
        W += wi ;
        wskew += (x * x * x - wskew) * (wi / W);
      }
    }
  return wskew;
}
<<<sep_in_sample>>>
1 9
2 9
3 7
4 7
5 13
6 9
7 7
8 7
9 7
10 7
11 11
12 12
13 12
14 13
15 13
16 13
17 13
18 13
19 13
20 14
21 14
22 14
23 15
24 15
25 15
26 15
27 15
28 15
29 15
30 15
31 15
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 19
43 19
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  4f1 <xdr_dis_event_id+0x11>
xor    %edx,%edx
test   %eax,%eax
je     50a <xdr_dis_event_id+0x2a>
lea    0x4(%rbp),%rsi
mov    %rbx,%rdi
callq  503 <xdr_dis_event_id+0x23>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_event_id(xdrs, objp)
	XDR *xdrs;
	dis_event_id *objp;
{
	if (!xdr_dis_simulation_addr(xdrs, &objp->sim_id)) {
		return (FALSE);
	}
	if (!xdr_byte_u_short(xdrs, &objp->event_id)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 6
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 8
16 12
17 12
18 12
19 12
20 12
21 12
<<<sep_out_sample>>>
push   %rbp
movapd %xmm1,%xmm2
mov    %rdi,%rbp
push   %rbx
sub    $0x28,%rsp
lea    0x10(%rsp),%rdi
movsd  %xmm2,0x8(%rsp)
callq  2fd <gsl_sf_bessel_Knu_e+0x1d>
movsd  0x8(%rsp),%xmm2
mov    %rbp,%rdi
movsd  0x0(%rip),%xmm0        # 30e <gsl_sf_bessel_Knu_e+0x2e>
mov    %eax,%ebx
xorpd  %xmm1,%xmm1
xorpd  %xmm2,%xmm0
movsd  0x18(%rsp),%xmm3
movsd  0x10(%rsp),%xmm2
callq  329 <gsl_sf_bessel_Knu_e+0x49>
test   %eax,%eax
cmove  %ebx,%eax
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_bessel_Knu_e(const double nu, const double x, gsl_sf_result * result)
{
  gsl_sf_result b;
  int stat_K = gsl_sf_bessel_Knu_scaled_e(nu, x, &b);
  int stat_e = gsl_sf_exp_mult_err_e(-x, 0.0, b.val, b.err, result);
  return ((stat_e) != GSL_SUCCESS ? (stat_e) : ((stat_K) != GSL_SUCCESS ? (stat_K) : GSL_SUCCESS));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 5
10 5
11 5
12 4
13 5
14 5
15 5
16 5
17 5
18 6
19 6
20 7
21 7
22 7
23 7
24 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
testb  $0x8,0x0(%rip)        # 68b <do_statusbar_cut_text+0xb>
mov    0x0(%rip),%rsi        # 692 <do_statusbar_cut_text+0x12>
jne    6a1 <do_statusbar_cut_text+0x21>
movq   $0x0,0x0(%rip)        # 69f <do_statusbar_cut_text+0x1f>
xor    %esi,%esi
mov    $0x0,%edi
callq  6ab <do_statusbar_cut_text+0x2b>
add    $0x8,%rsp
jmpq   6b4 <do_statusbar_cut_text+0x34>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_statusbar_cut_text(void)
{
    if (!((flags[((CUT_TO_END) / (sizeof(unsigned) * 8))] & ((unsigned)1 << ((CUT_TO_END) % (sizeof(unsigned) * 8)))) != 0))
 statusbar_x = 0;
    null_at(&answer, statusbar_x);
    update_the_statusbar();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 5
8 5
9 7
10 6
11 6
<<<sep_out_sample>>>
mov    0x30(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_nlinear_jac (const gsl_multifit_nlinear_workspace * w)
{
  return w->J;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x38(%rdi),%rdi
callq  1d <rkck_free+0xd>
mov    0x30(%rbx),%rdi
callq  26 <rkck_free+0x16>
mov    0x28(%rbx),%rdi
callq  2f <rkck_free+0x1f>
mov    0x20(%rbx),%rdi
callq  38 <rkck_free+0x28>
mov    0x18(%rbx),%rdi
callq  41 <rkck_free+0x31>
mov    0x10(%rbx),%rdi
callq  4a <rkck_free+0x3a>
mov    0x8(%rbx),%rdi
callq  53 <rkck_free+0x43>
mov    (%rbx),%rdi
callq  5b <rkck_free+0x4b>
mov    %rbx,%rdi
pop    %rbx
jmpq   64 <rkck_free+0x54>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rkck_free (void *vstate)
{
  rkck_state_t *state = (rkck_state_t *) vstate;
  free (state->ytmp);
  free (state->y0);
  free (state->k6);
  free (state->k5);
  free (state->k4);
  free (state->k3);
  free (state->k2);
  free (state->k1);
  free (state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 8
13 9
14 9
15 10
16 10
17 11
18 11
19 12
20 13
21 12
22 12
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
new_buffer_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x28,%rsp
mov    (%rdi),%r13
mov    0x18(%rdi),%rbx
mov    %rdx,0x10(%rsp)
mov    0x8(%rdi),%rbp
mov    0x10(%rdi),%rax
movss  (%rbx),%xmm4
test   %r13,%r13
movss  %xmm4,0x4(%rsp)
je     d9a <gsl_matrix_float_minmax+0xfa>
shl    $0x2,%rax
movss  %xmm4,0x8(%rsp)
xor    %r12d,%r12d
mov    %rax,0x18(%rsp)
test   %rbp,%rbp
je     d60 <gsl_matrix_float_minmax+0xc0>
xor    %r14d,%r14d
jmp    d01 <gsl_matrix_float_minmax+0x61>
nopl   0x0(%rax)
add    $0x1,%r14
cmp    %rbp,%r14
je     d60 <gsl_matrix_float_minmax+0xc0>
movss  (%rbx,%r14,4),%xmm1
movaps %xmm1,%xmm2
movaps %xmm1,%xmm3
movaps %xmm1,%xmm0
movss  %xmm1,0xc(%rsp)
minss  0x4(%rsp),%xmm2
maxss  0x8(%rsp),%xmm3
movss  %xmm2,0x4(%rsp)
movss  %xmm3,0x8(%rsp)
callq  d33 <gsl_matrix_float_minmax+0x93>
test   %eax,%eax
movss  0xc(%rsp),%xmm1
je     cf8 <gsl_matrix_float_minmax+0x58>
mov    0x10(%rsp),%rax
movss  %xmm1,(%r15)
movss  %xmm1,(%rax)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopw   0x0(%rax,%rax,1)
add    $0x1,%r12
add    0x18(%rsp),%rbx
cmp    %r13,%r12
jne    cea <gsl_matrix_float_minmax+0x4a>
movss  0x8(%rsp),%xmm6
movss  0x4(%rsp),%xmm0
movss  %xmm6,0x4(%rsp)
mov    0x10(%rsp),%rax
movss  0x4(%rsp),%xmm5
movss  %xmm0,(%r15)
movss  %xmm5,(%rax)
jmp    d4b <gsl_matrix_float_minmax+0xab>
movss  0x4(%rsp),%xmm0
jmp    d84 <gsl_matrix_float_minmax+0xe4>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_minmax (const gsl_matrix_float * m,
                               float * min_out,
                               float * max_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  float max = m->data[0 * tda + 0];
  float min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          float x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
            }
          if (x > max)
            {
              max = x;
            }
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            {
              *min_out = x;
              *max_out = x;
              return;
            }
        }
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 8
11 4
12 6
13 7
14 8
15 11
16 8
17 11
18 11
19 8
20 11
21 11
22 13
23 13
24 13
25 13
26 13
27 13
28 13
29 13
30 15
31 15
32 15
33 24
34 24
35 15
36 15
37 15
38 15
39 24
40 24
41 24
42 24
43 27
44 26
45 27
46 34
47 34
48 34
49 34
50 34
51 34
52 34
53 34
54 34
55 11
56 11
57 11
58 11
59 11
60 11
61 11
62 33
63 33
64 32
65 33
66 33
67 9
68 9
69 9
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  278 <transform_name+0x18>
mov    %r13,%rdi
mov    %rax,%rbp
callq  283 <transform_name+0x23>
mov    %ebp,%esi
mov    %rbx,%rdi
sub    %eax,%esi
callq  28f <transform_name+0x2f>
mov    %r12,%rdi
callq  297 <transform_name+0x37>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   2a6 <transform_name+0x46>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
transform_name(char *name, char *fromsuffix, char *tosuffix)
{
  newstr_grown (name, strlen(name) - strlen(fromsuffix));
  newstr_grow1 (tosuffix);
  return newstr_finish ();
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 3
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 5
25 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %edi,%eax
xor    %r8d,%r8d
mov    %rdx,0x8(%rsp)
lea    0x8(%rsp),%rdx
mov    %esi,%edi
mov    $0x0,%r9d
mov    $0xffffffff,%ecx
mov    %eax,%esi
callq  2397 <swlib_pump_amount+0x27>
mov    $0xffffffffffffffff,%rdx
test   %rax,%rax
cmove  0x8(%rsp),%rdx
add    $0x18,%rsp
mov    %rdx,%rax
retq   
nop
<<<sep_in_sample>>>
swlib_pump_amount(int discharge_fd, int suction_fd, intmax_t amount)
{
 intmax_t i = amount;
 if (swlib_i_pipe_pump(suction_fd, discharge_fd, &i,
   -1, ((void *)0), uxfio_read)) {
  return -1;
 }
 return i;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 3
5 4
6 2
7 4
8 4
9 4
10 4
11 8
12 8
13 8
14 9
15 9
16 9
17 9
<<<sep_out_sample>>>
cmpb   $0x0,0x0(%rip)        # 277 <load_casetable+0x7>
jne    282 <load_casetable+0x12>
testb  $0x8,0x0(%rip)        # 280 <load_casetable+0x10>
je     288 <load_casetable+0x18>
retq   
nopl   0x0(%rax,%rax,1)
push   %r12
xor    %esi,%esi
xor    %edi,%edi
movb   $0x1,0x0(%rip)        # 295 <load_casetable+0x25>
push   %rbp
push   %rbx
callq  29c <load_casetable+0x2c>
test   %rax,%rax
je     320 <load_casetable+0xb0>
mov    $0x0,%edi
mov    $0x2,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     320 <load_casetable+0xb0>
mov    $0x0,%edi
mov    $0x6,%ecx
mov    %rax,%rsi
repz cmpsb %es:(%rdi),%ds:(%rsi)
je     320 <load_casetable+0xb0>
callq  2c8 <load_casetable+0x58>
xor    %ebp,%ebp
mov    %rax,%r12
mov    $0x80,%ebx
jmp    2ed <load_casetable+0x7d>
nopl   0x0(%rax)
mov    %bl,0x0(%rbp)
add    $0x1,%ebx
add    $0x1,%rbp
cmp    $0x100,%ebx
je     320 <load_casetable+0xb0>
mov    (%r12),%rdx
movzwl 0x100(%rdx,%rbp,2),%edx
and    $0x600,%dx
cmp    $0x600,%dx
jne    2d8 <load_casetable+0x68>
mov    %ebx,%edi
callq  30c <load_casetable+0x9c>
cmp    %ebx,%eax
je     2d8 <load_casetable+0x68>
mov    %al,0x0(%rbp)
jmp    2de <load_casetable+0x6e>
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
load_casetable(void)
{
 int i;
 char *cp;
 static _Bool loaded = 0;
 if (loaded || (do_flags & DO_TRADITIONAL))
  return;
 loaded = 1;
 cp = setlocale(0, ((void *)0));
 if (cp == ((void *)0) || strcmp(cp, "C") == 0 || strcmp(cp, "POSIX") == 0)
  return;
 for (i = 0200; i <= 0377; i++) {
  if (((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalpha) && ((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISlower) && i != toupper(i))
   casetable[i] = toupper(i);
  else
   casetable[i] = i;
 }
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 18
6 18
7 2
8 9
9 9
10 8
11 2
12 2
13 9
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 16
33 12
34 12
35 12
36 12
37 13
38 13
39 13
40 13
41 13
42 13
43 13
44 13
45 13
46 14
47 14
48 14
49 18
50 18
51 18
52 18
53 18
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  505 <java__init_buffer+0x15>
mov    %rbx,%rdi
mov    %rax,%rbp
mov    (%rax),%r13d
callq  513 <java__init_buffer+0x23>
mov    0x0(%rip),%rax        # 51a <java__init_buffer+0x2a>
mov    %r12,(%rbx)
movl   $0x1,0x3c(%rbx)
test   %rax,%rax
je     536 <java__init_buffer+0x46>
mov    0x0(%rip),%rdx        # 530 <java__init_buffer+0x40>
cmp    (%rax,%rdx,8),%rbx
je     544 <java__init_buffer+0x54>
movl   $0x1,0x34(%rbx)
movl   $0x0,0x38(%rbx)
movl   $0x0,0x2c(%rbx)
mov    %r13d,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
java__init_buffer (YY_BUFFER_STATE b, FILE * file )
{
 int oerrno = (*__errno_location ());
 java__flush_buffer(b );
 b->yy_input_file = file;
 b->yy_fill_buffer = 1;
    if (b != ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }
        b->yy_is_interactive = 0;
 (*__errno_location ()) = oerrno;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 3
9 4
10 3
11 3
12 4
13 7
14 5
15 6
16 7
17 7
18 7
19 7
20 7
21 8
22 9
23 11
24 12
25 13
26 13
27 13
28 13
29 13
30 13
31 13
<<<sep_out_sample>>>
ucomisd 0x0(%rip),%xmm0        # 68 <gsl_sf_gegenpoly_2_e+0x8>
jnp    c0 <gsl_sf_gegenpoly_2_e+0x60>
movsd  0x0(%rip),%xmm3        # 72 <gsl_sf_gegenpoly_2_e+0x12>
movapd %xmm0,%xmm2
xor    %eax,%eax
addsd  %xmm3,%xmm2
addsd  %xmm2,%xmm2
mulsd  %xmm1,%xmm2
mulsd  %xmm1,%xmm2
movsd  0x0(%rip),%xmm1        # 90 <gsl_sf_gegenpoly_2_e+0x30>
subsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
andpd  %xmm1,%xmm0
movsd  %xmm2,(%rdi)
andpd  %xmm1,%xmm2
addsd  %xmm2,%xmm2
addsd  %xmm0,%xmm2
mulsd  0x0(%rip),%xmm2        # b4 <gsl_sf_gegenpoly_2_e+0x54>
movsd  %xmm2,0x8(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
jne    6a <gsl_sf_gegenpoly_2_e+0xa>
movapd %xmm1,%xmm0
movsd  0x0(%rip),%xmm3        # ce <gsl_sf_gegenpoly_2_e+0x6e>
movsd  0x0(%rip),%xmm2        # d6 <gsl_sf_gegenpoly_2_e+0x76>
xor    %eax,%eax
addsd  %xmm1,%xmm0
mulsd  %xmm1,%xmm0
movapd %xmm0,%xmm1
andpd  %xmm3,%xmm0
subsd  0x0(%rip),%xmm1        # f0 <gsl_sf_gegenpoly_2_e+0x90>
mulsd  %xmm2,%xmm0
movsd  %xmm1,(%rdi)
andpd  %xmm3,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sf_gegenpoly_2_e(double lambda, double x, gsl_sf_result * result)
{
  if(lambda == 0.0) {
    const double txx = 2.0*x*x;
    result->val = -1.0 + txx;
    result->err = 2.0 * 2.2204460492503131e-16 * fabs(txx);
    result->err += 2.0 * 2.2204460492503131e-16 * fabs(result->val);
    return GSL_SUCCESS;
  }
  else {
    result->val = lambda*(-1.0 + 2.0*(1.0+lambda)*x*x);
    result->err = 2.2204460492503131e-16 * (2.0 * fabs(result->val) + fabs(lambda));
    return GSL_SUCCESS;
  }
}
<<<sep_in_sample>>>
1 3
2 3
3 11
4 11
5 15
6 11
7 11
8 11
9 11
10 12
11 11
12 11
13 12
14 11
15 12
16 12
17 12
18 12
19 12
20 15
21 15
22 3
23 4
24 6
25 6
26 15
27 4
28 4
29 5
30 6
31 5
32 6
33 5
34 7
35 7
36 7
37 7
38 15
39 15
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %r9d,%r14d
push   %r13
mov    %r8,%r13
push   %r12
mov    %ecx,%r12d
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # c567 <ch_sg_hdy+0x27>
mov    0x70(%rsp),%r15d
mov    %r15d,(%rsp)
callq  1f0 <ch_base_hdy>
mov    0x0(%rip),%rcx        # c57c <ch_sg_hdy+0x3c>
mov    0x0(%rip),%rdi        # c583 <ch_sg_hdy+0x43>
mov    %rcx,0x28(%rsp)
callq  c58d <ch_sg_hdy+0x4d>
mov    0x28(%rsp),%rcx
mov    (%rbx),%edi
mov    %ebp,%esi
mov    %r15d,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    $0x1,%r9d
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
mov    $0x0,%r8d
mov    %rax,%rdx
movl   $0xb,(%rsp)
callq  c5c5 <ch_sg_hdy+0x85>
mov    0x0(%rip),%rcx        # c5cc <ch_sg_hdy+0x8c>
mov    0x0(%rip),%rdi        # c5d3 <ch_sg_hdy+0x93>
mov    %rcx,0x28(%rsp)
callq  c5dd <ch_sg_hdy+0x9d>
mov    0x28(%rsp),%rcx
mov    (%rbx),%edi
mov    %ebp,%esi
mov    %r15d,0x20(%rsp)
mov    %r14d,0x18(%rsp)
mov    $0x10,%r9d
mov    %r13,0x10(%rsp)
mov    %r12d,0x8(%rsp)
mov    $0x0,%r8d
movl   $0xa,(%rsp)
mov    %rax,%rdx
callq  c615 <ch_sg_hdy+0xd5>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ch_sg_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "CH_SG";
  ch_base_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[11].ht_text),
    ptr_cc_id, "+", 1, 11, year, hd_elems, fday, count);
  holiday (*init_data, detected, gettext(hd_text[71].ht_text),
    ptr_cc_id, "+", 16, 10, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 10
14 9
15 11
16 11
17 12
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 14
49 16
50 16
51 16
52 16
53 16
54 16
55 16
56 16
57 16
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     1040 <gsl_vector_float_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1035 <gsl_vector_float_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     107b <gsl_vector_float_sub+0x6b>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
movss  (%rax),%xmm0
add    $0x1,%rdx
subss  (%rcx),%xmm0
add    %r9,%rcx
movss  %xmm0,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1060 <gsl_vector_float_sub+0x50>
xor    %eax,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_vector_float_sub (gsl_vector_float * a, const gsl_vector_float * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 15
25 13
26 15
27 15
28 15
29 15
30 13
31 13
32 17
33 19
34 19
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     706 <ds_unsafe_cat_sprintf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rdx
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  737 <ds_unsafe_cat_sprintf+0x87>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
ds_unsafe_cat_sprintf (struct dstring * ds, const char *format, ...)
{
  va_list args;
  __builtin_va_start(args,format);
  ds_unsafe_cat_vsprintf (ds,
     format, args);
  __builtin_va_end(args);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 4
17 5
18 4
19 4
20 4
21 4
22 4
23 5
24 8
25 8
26 8
<<<sep_out_sample>>>
mov    (%rdi),%rcx
mov    0x8(%rdi),%rsi
test   %rcx,%rcx
je     10e6 <gsl_vector_int_isnonneg+0x36>
mov    0x10(%rdi),%rdx
xorpd  %xmm1,%xmm1
shl    $0x2,%rsi
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
cvtsi2sdl (%rdx),%xmm0
ucomisd %xmm0,%xmm1
ja     10ec <gsl_vector_int_isnonneg+0x3c>
add    $0x1,%rax
add    %rsi,%rdx
cmp    %rcx,%rax
jne    10d0 <gsl_vector_int_isnonneg+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nop
<<<sep_in_sample>>>
gsl_vector_int_isnonneg (const gsl_vector_int * v)
{
  const size_t n = v->size;
  const size_t stride = v->stride ;
  size_t j;
  for (j = 0; j < n; j++)
    {
      size_t k;
      for (k = 0; k < 1; k++)
        {
          if (v->data[1 * stride * j + k] < 0.0)
            {
              return 0;
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 11
11 11
12 11
13 6
14 6
15 6
16 6
17 17
18 18
19 13
20 13
21 13
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 3986 <info_move_to_window_line+0x6>
test   %eax,%eax
jne    398f <info_move_to_window_line+0xf>
cmp    $0x1,%esi
je     39f0 <info_move_to_window_line+0x70>
test   %esi,%esi
js     39e0 <info_move_to_window_line+0x60>
mov    0x38(%rdi),%rax
mov    0x18(%rdi),%rcx
add    %eax,%esi
movslq %esi,%rdx
mov    %rdx,%r8
sub    %rax,%r8
cmp    %rcx,%r8
jl     39b2 <info_move_to_window_line+0x32>
lea    -0x1(%rax,%rcx,1),%esi
movslq %esi,%rdx
cmp    %rdx,%rax
jle    39bc <info_move_to_window_line+0x3c>
mov    %eax,%esi
movslq %eax,%rdx
mov    0x88(%rdi),%rax
lea    -0x1(%rax),%ecx
cmp    %rdx,%rax
mov    0x78(%rdi),%rax
cmovle %ecx,%esi
movslq %esi,%rsi
mov    (%rax,%rsi,8),%rax
mov    %rax,0x40(%rdi)
jmpq   3c0 <info_show_point>
mov    0x18(%rdi),%rcx
mov    0x38(%rdi),%rax
lea    (%rax,%rcx,1),%edx
add    %edx,%esi
jmp    399d <info_move_to_window_line+0x1d>
nop
mov    0x18(%rdi),%rcx
mov    0x38(%rdi),%rax
mov    %rcx,%rsi
shr    $0x3f,%rsi
add    %rcx,%rsi
sar    %rsi
add    %eax,%esi
jmp    399d <info_move_to_window_line+0x1d>
nopl   0x0(%rax)
<<<sep_in_sample>>>
info_move_to_window_line (WINDOW *window, int count)
{
  int line;
  if (!info_explicit_arg && count == 1)
    line = (window->height / 2) + window->pagetop;
  else
    {
      if (count < 0)
        line = (window->height + count) + window->pagetop;
      else
        line = window->pagetop + count;
    }
  if (line - window->pagetop >= window->height)
    line = window->pagetop + (window->height - 1);
  if (line < window->pagetop)
    line = window->pagetop;
  if (line >= window->line_count)
    line = window->line_count - 1;
  window->point = window->line_starts[line];
  info_show_point (window);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 11
9 11
10 11
11 13
12 13
13 13
14 13
15 13
16 14
17 14
18 15
19 15
20 16
21 16
22 17
23 18
24 18
25 19
26 18
27 19
28 19
29 19
30 20
31 9
32 9
33 9
34 9
35 9
36 9
37 5
38 5
39 5
40 5
41 5
42 5
43 5
44 5
45 5
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
sub    $0x38,%rsp
movabs $0x6765c793fa10079d,%rax
imul   (%rdi),%rax
movsd  %xmm0,(%rsp)
movsd  0x0(%rip),%xmm4        # 1f <__rnormal+0x1f>
or     $0x1,%rax
mov    %rax,(%rdi)
shr    %rax
cvtsi2sd %rax,%xmm0
addsd  %xmm4,%xmm0
mulsd  0x0(%rip),%xmm0        # 3a <__rnormal+0x3a>
ucomisd %xmm4,%xmm0
movsd  %xmm0,0x0(%rip)        # 46 <__rnormal+0x46>
jbe    168 <__rnormal+0x168>
movsd  0x0(%rip),%xmm3        # 54 <__rnormal+0x54>
movapd %xmm3,%xmm6
subsd  %xmm0,%xmm6
movapd %xmm6,%xmm0
movsd  %xmm6,0x0(%rip)        # 68 <__rnormal+0x68>
mulsd  %xmm0,%xmm0
movsd  %xmm3,0x18(%rsp)
movsd  %xmm4,0x10(%rsp)
movsd  %xmm1,0x8(%rsp)
callq  83 <__rnormal+0x83>
movsd  0x0(%rip),%xmm5        # 8b <__rnormal+0x8b>
xorpd  %xmm5,%xmm0
movapd %xmm5,0x20(%rsp)
callq  9a <__rnormal+0x9a>
movsd  %xmm0,0x0(%rip)        # a2 <__rnormal+0xa2>
movsd  0x0(%rip),%xmm2        # aa <__rnormal+0xaa>
movsd  0x18(%rsp),%xmm3
mulsd  %xmm0,%xmm2
movsd  0x10(%rsp),%xmm4
movsd  0x8(%rsp),%xmm1
ucomisd 0x0(%rip),%xmm4        # c8 <__rnormal+0xc8>
subsd  0x0(%rip),%xmm2        # d0 <__rnormal+0xd0>
mulsd  %xmm0,%xmm2
subsd  0x0(%rip),%xmm2        # dc <__rnormal+0xdc>
mulsd  %xmm0,%xmm2
subsd  %xmm3,%xmm2
movsd  0x0(%rip),%xmm3        # ec <__rnormal+0xec>
mulsd  %xmm0,%xmm3
mulsd  %xmm0,%xmm2
addsd  0x0(%rip),%xmm3        # fc <__rnormal+0xfc>
subsd  0x0(%rip),%xmm2        # 104 <__rnormal+0x104>
mulsd  %xmm0,%xmm3
addsd  0x0(%rip),%xmm3        # 110 <__rnormal+0x110>
mulsd  %xmm0,%xmm3
addsd  0x0(%rip),%xmm3        # 11c <__rnormal+0x11c>
mulsd  %xmm0,%xmm3
addsd  0x0(%rip),%xmm3        # 128 <__rnormal+0x128>
divsd  %xmm3,%xmm2
addsd  %xmm0,%xmm2
movsd  %xmm2,0x0(%rip)        # 138 <__rnormal+0x138>
movapd %xmm2,%xmm0
jbe    154 <__rnormal+0x154>
movapd 0x20(%rsp),%xmm5
xorpd  %xmm5,%xmm2
movapd %xmm2,%xmm0
movsd  %xmm0,0x0(%rip)        # 154 <__rnormal+0x154>
mulsd  %xmm1,%xmm0
addsd  (%rsp),%xmm0
add    $0x38,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movsd  %xmm0,0x0(%rip)        # 170 <__rnormal+0x170>
movsd  0x0(%rip),%xmm3        # 178 <__rnormal+0x178>
jmpq   68 <__rnormal+0x68>
<<<sep_in_sample>>>
__rnormal (double a, double b, long *U)
{
  static double y,
    x,
    p,
    u;
  u = ((((double)(((unsigned long)(*U= (*U*7450580596923828125L)|1))>>1))+0.5)/((double)((~(1L<<63)))+1.0));
  if (u > 0.5)
    p = 1.0 - u;
  else
    p = u;
  y = __rsqrt (-__rln (p * p));
  x = y + ((((y * (-0.0000453642210148) + (-0.0204231210245)) * y + (-0.342242088547)) * y + (-1)) * y + (-0.322232431088))
    / ((((y * 0.0038560700634 + 0.10353775285) * y + 0.531103462366) * y + 0.588581570495) * y + 0.099348462606);
  if (u < 0.5)
    x = -x;
  return (b * x + a);
}
<<<sep_in_sample>>>
1 2
2 7
3 7
4 2
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 8
13 7
14 8
15 9
16 9
17 9
18 9
19 9
20 12
21 12
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 12
30 13
31 13
32 13
33 15
34 15
35 15
36 13
37 13
38 13
39 13
40 13
41 14
42 14
43 13
44 14
45 13
46 14
47 14
48 14
49 14
50 14
51 14
52 14
53 13
54 13
55 13
56 15
57 16
58 16
59 16
60 16
61 17
62 17
63 18
64 18
65 18
66 11
67 11
68 11
<<<sep_out_sample>>>
jmpq   17b5 <Barcode_upc_encode+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
Barcode_upc_encode(struct Barcode_Item *bc)
{
    return Barcode_ean_encode(bc);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rsi),%r9
cmp    (%rdi),%r9
mov    0x8(%rdi),%rax
jne    309 <gsl_matrix_complex_equal+0x19>
mov    0x8(%rsi),%r8
cmp    %rax,%r8
je     330 <gsl_matrix_complex_equal+0x40>
mov    $0x13,%ecx
mov    $0x1c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  322 <gsl_matrix_complex_equal+0x32>
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
test   %r9,%r9
mov    0x10(%rdi),%rdx
mov    0x10(%rsi),%rax
je     3b7 <gsl_matrix_complex_equal+0xc7>
shl    $0x4,%rdx
shl    $0x4,%rax
mov    $0x8,%r11d
mov    %rdx,%r12
mov    %rax,%rbp
mov    $0x8,%r10d
xor    %ebx,%ebx
test   %r8,%r8
je     3a8 <gsl_matrix_complex_equal+0xb8>
mov    %r10,%rdx
mov    %r11,%rax
add    0x18(%rdi),%rdx
add    0x18(%rsi),%rax
xor    %ecx,%ecx
jmp    38f <gsl_matrix_complex_equal+0x9f>
jne    39b <gsl_matrix_complex_equal+0xab>
movsd  (%rdx),%xmm0
ucomisd (%rax),%xmm0
jp     39b <gsl_matrix_complex_equal+0xab>
jne    39b <gsl_matrix_complex_equal+0xab>
add    $0x1,%rcx
add    $0x10,%rdx
add    $0x10,%rax
cmp    %r8,%rcx
je     3a8 <gsl_matrix_complex_equal+0xb8>
movsd  -0x8(%rdx),%xmm0
ucomisd -0x8(%rax),%xmm0
jnp    370 <gsl_matrix_complex_equal+0x80>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
add    %r12,%r10
add    %rbp,%r11
cmp    %r9,%rbx
jne    359 <gsl_matrix_complex_equal+0x69>
mov    $0x1,%eax
jmpq   324 <gsl_matrix_complex_equal+0x34>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_equal (const gsl_matrix_complex * a, const gsl_matrix_complex * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "prop_source.c", 28, GSL_EBADLEN) ; return 0 ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j, k;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              for (k = 0; k < 2; k++)
                {
                  if (a->data[(i * tda_a + j) * 2 + k]
                      != b->data[(i * tda_b + j) * 2 + k])
                    {
                      return 0;
                    }
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 5
6 4
7 5
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 7
16 7
17 30
18 30
19 30
20 30
21 30
22 14
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 16
34 16
35 16
36 16
37 16
38 16
39 16
40 16
41 20
42 20
43 20
44 20
45 20
46 16
47 16
48 16
49 16
50 16
51 20
52 20
53 20
54 30
55 30
56 23
57 30
58 30
59 30
60 14
61 14
62 14
63 14
64 14
65 29
66 29
67 29
<<<sep_out_sample>>>
sub    $0x28,%rsp
add    $0x28,%rdi
mov    0x40(%rsp),%rax
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    0x0(%rip),%rsi        # 134 <nettle_ccm_aes256_decrypt_message+0x24>
mov    %rax,0x18(%rsp)
mov    0x38(%rsp),%rax
mov    %rax,0x10(%rsp)
mov    0x30(%rsp),%rax
mov    %rax,0x8(%rsp)
callq  152 <nettle_ccm_aes256_decrypt_message+0x42>
add    $0x28,%rsp
retq   
<<<sep_in_sample>>>
nettle_ccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,
      size_t nlength, const uint8_t *nonce,
      size_t alength, const uint8_t *adata,
      size_t tlength,
      size_t mlength, uint8_t *dst, const uint8_t *src)
{
  return nettle_ccm_decrypt_message(&ctx->cipher, (nettle_cipher_func *) nettle_aes256_encrypt,
        nlength, nonce, alength, adata,
        tlength, mlength, dst, src);
}
<<<sep_in_sample>>>
1 6
2 7
3 7
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 10
17 10
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     848 <gsl_fft_complex_workspace_free+0x28>
mov    0x8(%rdi),%rdi
callq  832 <gsl_fft_complex_workspace_free+0x12>
movq   $0x0,0x8(%rbx)
mov    %rbx,%rdi
pop    %rbx
jmpq   843 <gsl_fft_complex_workspace_free+0x23>
nopl   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_workspace_free (gsl_fft_complex_workspace * workspace)
{
  if (!workspace) { return ; };
  free (workspace->scratch);
  workspace->scratch = ((void *)0);
  free (workspace) ;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 5
8 6
9 7
10 6
11 6
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
sub    $0x8,%rsp
callq  80 <add_segment>
mov    $0x2,%edi
mov    %rax,%rbx
movl   $0x0,0x8(%rax)
callq  e1 <add_char_segment+0x21>
mov    %rax,0x10(%rbx)
mov    %bpl,(%rax)
mov    0x10(%rbx),%rax
movb   $0x0,0x1(%rax)
movq   $0x1,0x18(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
add_char_segment (struct transform *tf, int chr)
{
  struct replace_segm *segm = add_segment (tf);
  segm->type = segm_literal;
  segm->v.literal.ptr = xmalloc (2);
  segm->v.literal.ptr[0] = chr;
  segm->v.literal.ptr[1] = 0;
  segm->v.literal.size = 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 5
7 3
8 4
9 5
10 5
11 6
12 7
13 7
14 8
15 9
16 9
17 9
18 9
19 9
<<<sep_out_sample>>>
test   %rdx,%rdx
je     838 <gsl_stats_uchar_quantile_from_sorted_data+0x68>
sub    $0x1,%rdx
js     840 <gsl_stats_uchar_quantile_from_sorted_data+0x70>
cvtsi2sd %rdx,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
je     867 <gsl_stats_uchar_quantile_from_sorted_data+0x97>
test   %rax,%rax
js     878 <gsl_stats_uchar_quantile_from_sorted_data+0xa8>
cvtsi2sd %rax,%xmm1
imul   %rsi,%rax
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # 80d <gsl_stats_uchar_quantile_from_sorted_data+0x3d>
subsd  %xmm1,%xmm2
movzbl (%rdi,%rax,1),%edx
add    %rdi,%rax
movzbl (%rax,%rsi,1),%eax
subsd  %xmm2,%xmm0
cvtsi2sd %edx,%xmm1
mulsd  %xmm1,%xmm0
cvtsi2sd %eax,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   (%rax)
xorpd  %xmm0,%xmm0
retq   
nopl   (%rax)
mov    %rdx,%rax
mov    %rdx,%rcx
shr    %rax
and    $0x1,%ecx
or     %rcx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
mulsd  %xmm1,%xmm0
cvttsd2si %xmm0,%eax
cltq   
cmp    %rax,%rdx
jne    7ef <gsl_stats_uchar_quantile_from_sorted_data+0x1f>
imul   %rsi,%rdx
movzbl (%rdi,%rdx,1),%eax
cvtsi2sd %eax,%xmm0
retq   
nopl   0x0(%rax)
mov    %rax,%rdx
mov    %rax,%rcx
shr    %rdx
and    $0x1,%ecx
or     %rcx,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   7fd <gsl_stats_uchar_quantile_from_sorted_data+0x2d>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uchar_quantile_from_sorted_data (const unsigned char sorted_data[],
                                               const size_t stride,
                                               const size_t n,
                                               const double f)
{
  const double index = f * (n - 1) ;
  const size_t lhs = (int)index ;
  const double delta = index - lhs ;
  double result;
  if (n == 0)
    return 0.0 ;
  if (lhs == n - 1)
    {
      result = sorted_data[lhs * stride] ;
    }
  else
    {
      result = (1 - delta) * sorted_data[lhs * stride] + delta * sorted_data[(lhs + 1) * stride] ;
    }
  return result ;
}
<<<sep_in_sample>>>
1 10
2 10
3 6
4 6
5 6
6 6
7 7
8 7
9 12
10 12
11 8
12 8
13 8
14 18
15 8
16 18
17 8
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 18
27 18
28 18
29 11
30 21
31 21
32 6
33 6
34 6
35 6
36 6
37 6
38 6
39 6
40 7
41 7
42 12
43 12
44 14
45 14
46 14
47 14
48 14
49 8
50 8
51 8
52 8
53 8
54 8
55 8
56 8
57 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    $0x1,%ebx
sub    $0x8,%rsp
cmpq   $0x0,0x40(%rdi)
je     410 <rec_sex_ast_node_unfix+0x30>
mov    0x20(%rbp,%rbx,8),%rdi
callq  3ff <rec_sex_ast_node_unfix+0x1f>
cmp    %rbx,0x40(%rbp)
lea    0x1(%rbx),%rax
jbe    410 <rec_sex_ast_node_unfix+0x30>
mov    %rax,%rbx
jmp    3f5 <rec_sex_ast_node_unfix+0x15>
xchg   %ax,%ax
movb   $0x0,0x1c(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_ast_node_unfix (rec_sex_ast_node_t node)
{
  int i;
  for (i = 0; i < node->num_children; i++)
    {
      rec_sex_ast_node_unfix (node->children[i]);
    }
  node->fixed = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 6
9 6
10 4
11 4
12 4
13 4
14 4
15 4
16 8
17 9
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    0x8(%rdi),%rcx
mov    0x28(%rdi),%rdx
mov    0x30(%rdi),%eax
mov    0x20(%rcx),%rsi
jmp    3ec <job_next_command+0x2c>
nopl   0x0(%rax)
mov    0x20(%rdi),%rdx
lea    0x1(%rax),%ecx
mov    %ecx,0x30(%rdi)
mov    (%rdx,%rax,8),%rdx
mov    %ecx,%eax
mov    %rdx,0x28(%rdi)
test   %rdx,%rdx
je     3f6 <job_next_command+0x36>
cmpb   $0x0,(%rdx)
jne    418 <job_next_command+0x58>
movzwl 0x30(%rsi),%edx
cmp    %eax,%edx
jne    3d8 <job_next_command+0x18>
movq   $0x0,0x28(%rdi)
xor    %eax,%eax
movq   $0x0,0x10(%rsi)
retq   
nopl   0x0(%rax)
sub    $0x1,%eax
mov    %rax,0x10(%rsi)
mov    $0x1,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
job_next_command (struct child *child)
{
  while (child->command_ptr == 0 || *child->command_ptr == '\0')
    {
      if (child->command_line == child->file->cmds->ncommand_lines)
        {
          child->command_ptr = 0;
          child->file->cmds->fileinfo.offset = 0;
          return 0;
        }
      else
        child->command_ptr = child->command_lines[child->command_line++];
    }
  child->file->cmds->fileinfo.offset = child->command_line - 1;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 12
8 12
9 12
10 12
11 12
12 12
13 3
14 3
15 3
16 3
17 5
18 5
19 5
20 7
21 9
22 8
23 9
24 9
25 14
26 14
27 14
28 16
29 16
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %esi,%ebp
push   %rbx
callq  31b <savedir+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     350 <savedir+0x40>
mov    %ebp,%esi
mov    %rax,%rdi
callq  32d <savedir+0x1d>
mov    %rbx,%rdi
mov    %rax,%rbp
callq  338 <savedir+0x28>
test   %eax,%eax
mov    %rbp,%rbx
jne    358 <savedir+0x48>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
xor    %ebx,%ebx
jmp    33f <savedir+0x2f>
nopl   0x0(%rax)
callq  35d <savedir+0x4d>
mov    (%rax),%r12d
mov    %rax,%rbp
mov    %rbx,%rdi
callq  36b <savedir+0x5b>
xor    %ebx,%ebx
mov    %r12d,0x0(%rbp)
jmp    33f <savedir+0x2f>
<<<sep_in_sample>>>
savedir (char const *dir, enum savedir_option option)
{
  DIR *dirp = opendir_safer (dir);
  if (! dirp)
    return ((void *)0);
  else
    {
      char *name_space = streamsavedir (dirp, option);
      if (closedir (dirp) != 0)
        {
          int closedir_errno = (*__errno_location ());
          free (name_space);
          (*__errno_location ()) = closedir_errno;
          return ((void *)0);
        }
      return name_space;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 8
10 8
11 8
12 9
13 8
14 9
15 9
16 16
17 9
18 18
19 18
20 18
21 18
22 18
23 18
24 5
25 5
26 5
27 11
28 11
29 11
30 12
31 12
32 14
33 13
34 14
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 667 <mlocation_dump_table+0x7>
xor    %eax,%eax
jmpq   0 <_location_dump_table>
xchg   %ax,%ax
<<<sep_in_sample>>>
mlocation_dump_table ()
{
  _location_dump_table (stderr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbx
cmpl   $0xffffffff,0x70(%rdi)
mov    $0x1,%eax
mov    %rdi,%rbx
mov    %ax,0x38(%rdi)
je     fd8 <servent_setup+0x18>
pop    %rbx
retq   
nopl   (%rax)
callq  fdd <servent_setup+0x1d>
test   %eax,%eax
nop
jne    fd3 <servent_setup+0x13>
cmpl   $0x1,0x20(%rbx)
je     1050 <servent_setup+0x90>
mov    0x70(%rbx),%eax
lea    0x3f(%rax),%edx
test   %eax,%eax
cmovns %eax,%edx
addl   $0x1,0x0(%rip)        # ffa <servent_setup+0x3a>
sar    $0x6,%edx
movslq %edx,%rsi
cltd   
shr    $0x1a,%edx
lea    (%rax,%rdx,1),%ecx
and    $0x3f,%ecx
sub    %edx,%ecx
mov    $0x1,%edx
shl    %cl,%rdx
or     %rdx,0x0(,%rsi,8)
cmp    0x0(%rip),%eax        # 1022 <servent_setup+0x62>
jle    102a <servent_setup+0x6a>
mov    %eax,0x0(%rip)        # 102a <servent_setup+0x6a>
cmpb   $0x0,0x0(%rip)        # 1031 <servent_setup+0x71>
je     fd3 <servent_setup+0x13>
mov    0x58(%rbx),%rdx
mov    0x0(%rip),%rdi        # 103e <servent_setup+0x7e>
mov    %eax,%ecx
pop    %rbx
mov    $0x0,%esi
xor    %eax,%eax
jmpq   104d <servent_setup+0x8d>
nopl   (%rax)
mov    0x70(%rbx),%edi
mov    $0xa,%esi
callq  105d <servent_setup+0x9d>
jmp    fe8 <servent_setup+0x28>
nop
<<<sep_in_sample>>>
servent_setup (struct servtab *sep)
{
  sep->se_checked = 1;
  if (sep->se_fd == -1 && setup (sep) == 0)
    {
      if (sep->se_socktype == SOCK_STREAM)
 listen (sep->se_fd, 10);
      ((void) (((&allsock)->fds_bits)[((sep->se_fd) / (8 * (int) sizeof (__fd_mask)))] |= ((__fd_mask) 1 << ((sep->se_fd) % (8 * (int) sizeof (__fd_mask))))));
      nsock++;
      if (sep->se_fd > maxsock)
 maxsock = sep->se_fd;
      if (debug)
 fprintf (stderr, "registered %s on %d\n", sep->se_server, sep->se_fd);
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 3
4 2
5 3
6 4
7 15
8 15
9 15
10 4
11 4
12 4
13 4
14 6
15 6
16 8
17 8
18 8
19 8
20 9
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 8
29 8
30 8
31 10
32 10
33 11
34 12
35 12
36 13
37 13
38 13
39 15
40 13
41 13
42 13
43 13
44 7
45 7
46 7
47 7
48 7
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (unsigned long) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              if (*chain == p)
                {
                  char *p_begin = (char *) p - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max);
                  *chain = ((struct header *) p_begin)->next;
                  free (p_begin);
                  return;
                }
              chain = &((struct header *) ((char *) *chain - (((sizeof (struct preliminary_header) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)))->next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 9
26 9
27 9
28 9
29 9
30 18
31 14
32 13
33 14
34 15
35 8
36 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # f36 <gsl_vector_short_const_ptr+0x6>
test   %eax,%eax
je     f3f <gsl_vector_short_const_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    f50 <gsl_vector_short_const_ptr+0x20>
mov    0x8(%rdi),%rax
add    %rax,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
nop
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xdb,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  f6d <gsl_vector_short_const_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_short_const_ptr (const gsl_vector_short * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_short.h", 219, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (const short *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 7
12 2
13 5
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    7018 <gsl_matrix_ushort_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,2),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  703a <gsl_matrix_ushort_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ushort_const_column (const gsl_matrix_ushort * m, const size_t j)
{
  _gsl_vector_ushort_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_ushort v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    %rsi,%rdi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  62 <argp_fmtstream_puts+0x12>
mov    %rax,%rbx
xor    %eax,%eax
test   %rbx,%rbx
je     85 <argp_fmtstream_puts+0x35>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r12,%rdi
callq  7a <argp_fmtstream_puts+0x2a>
cmp    %rax,%rbx
setne  %al
movzbl %al,%eax
neg    %eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)
{
  size_t __len = strlen (__str);
  if (__len)
    {
      size_t __wrote = argp_fmtstream_write (__fs, __str, __len);
      return __wrote == __len ? 0 : -1;
    }
  else
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 10
10 4
11 4
12 6
13 6
14 6
15 6
16 7
17 7
18 7
19 7
20 11
21 11
22 11
23 11
24 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdi,%rax
mov    (%rdi),%rdi
mov    0x20(%rsp),%r10
mov    0x38(%rdi),%rdi
mov    %r9,(%rsp)
mov    %r8,%r9
mov    %r10,0x8(%rsp)
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
callq  0 <interp2d_eval>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp2d_eval_deriv_xx_e (const gsl_interp2d * interp, const double xarr[],
                              const double yarr[], const double zarr[],
                              const double x, const double y,
                              gsl_interp_accel * xa, gsl_interp_accel * ya, double * z)
{
  return interp2d_eval(interp->type->eval_deriv_xx, interp,
                       xarr, yarr, zarr, x, y, xa, ya, z);
}
<<<sep_in_sample>>>
1 5
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 6
13 6
14 8
15 8
16 8
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
jmpq   1540 <insert_exec_ok>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_exec (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_exec_ok ("-exec", entry, argv, arg_ptr);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
mov    %rsi,%rdx
xor    %esi,%esi
jmpq   14ba <inputBox+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
inputBox(char *msg, char *title)
{
  return inputBoxI(msg, ((void *)0), title);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x30(%rdi),%rsi
lea    0x10(%rbp),%rdi
callq  e39 <match_key+0x19>
test   %eax,%eax
je     e51 <match_key+0x31>
mov    0x8(%rbp),%rdi
mov    %rbx,%rsi
callq  570 <gcide_result_list_append>
test   %eax,%eax
setne  %al
movzbl %al,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
match_key(struct gcide_ref *ref, void *data)
{
    struct match_closure *clos = data;
    if (dico_key_match(&clos->key, ref->ref_headword)) {
 if (gcide_result_list_append(clos->list, ref))
     return 1;
    }
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 4
8 4
9 4
10 4
11 5
12 5
13 5
14 5
15 5
16 5
17 9
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 4517 <maybe_make_readline_line+0x7>
push   %rbx
mov    %rdi,%rbx
callq  4520 <maybe_make_readline_line+0x10>
test   %eax,%eax
jne    4530 <maybe_make_readline_line+0x20>
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 4536 <maybe_make_readline_line+0x26>
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x2,%edi
mov    %eax,0x0(%rip)        # 4547 <maybe_make_readline_line+0x37>
callq  454c <maybe_make_readline_line+0x3c>
mov    0x0(%rip),%esi        # 4552 <maybe_make_readline_line+0x42>
xor    %edi,%edi
callq  4559 <maybe_make_readline_line+0x49>
mov    %rbx,%rdi
movl   $0x0,0x0(%rip)        # 4566 <maybe_make_readline_line+0x56>
movl   $0x0,0x0(%rip)        # 4570 <maybe_make_readline_line+0x60>
movl   $0x0,0x0(%rip)        # 457a <maybe_make_readline_line+0x6a>
callq  457f <maybe_make_readline_line+0x6f>
pop    %rbx
xor    %ecx,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x3,%edi
jmpq   4590 <shell_expand_line>
<<<sep_in_sample>>>
maybe_make_readline_line (new_line)
     char *new_line;
{
  if (strcmp (new_line, rl_line_buffer) != 0)
    {
      rl_point = rl_end;
      rl_add_undo (UNDO_BEGIN, 0, 0, 0);
      rl_delete_text (0, rl_point);
      rl_point = rl_end = rl_mark = 0;
      rl_insert_text (new_line);
      rl_add_undo (UNDO_END, 0, 0, 0);
    }
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 4
5 4
6 4
7 13
8 13
9 13
10 6
11 7
12 7
13 7
14 7
15 6
16 7
17 8
18 8
19 8
20 10
21 9
22 9
23 9
24 10
25 13
26 11
27 11
28 11
29 11
30 11
<<<sep_out_sample>>>
mov    $0x1,%ecx
mov    $0x1,%edx
jmpq   0 <domd5>
<<<sep_in_sample>>>
mdfileBroken(const char *fn, unsigned char *digest) {
    return domd5(fn, digest, 1, 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 737 <decl_reinit+0x7>
cmp    0x0(%rip),%rsi        # 73e <decl_reinit+0xe>
jbe    749 <decl_reinit+0x19>
cmp    0x0(%rip),%rsi        # 747 <decl_reinit+0x17>
jb     758 <decl_reinit+0x28>
mov    $0x0,%edi
jmpq   753 <decl_reinit+0x23>
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x0(%rip)        # 75f <decl_reinit+0x2f>
mov    %rsi,0x0(%rip)        # 766 <decl_reinit+0x36>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
decl_reinit (void)
{
   __extension__ ({ struct obstack *__o = (&os_pref); void *__obj = (first_object_allocated_ptr_pref); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
<<<sep_out_sample>>>
push   %r15
mov    %rdi,%r15
push   %r14
push   %r13
mov    %rdx,%r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    (%rdi),%r12
mov    (%rsi),%rbp
mov    %rsi,0x8(%rsp)
test   %r12,%r12
je     68f <grecs_getline+0xbf>
xor    %ebx,%ebx
jmp    62b <grecs_getline+0x5b>
nopl   0x0(%rax)
lea    (%r12,%rbx,1),%r14
mov    %ebp,%esi
mov    %r13,%rdx
sub    %ebx,%esi
mov    %r14,%rdi
callq  613 <grecs_getline+0x43>
test   %rax,%rax
je     658 <grecs_getline+0x88>
mov    %r14,%rdi
callq  620 <grecs_getline+0x50>
add    %rax,%rbx
cmpb   $0xa,-0x1(%r12,%rbx,1)
je     666 <grecs_getline+0x96>
lea    -0x1(%rbp),%rax
cmp    %rax,%rbx
jne    600 <grecs_getline+0x30>
lea    0x0(%rbp,%rbp,1),%r14
cmp    %r14,%rbp
ja     688 <grecs_getline+0xb8>
mov    %r12,%rdi
mov    %r14,%rsi
mov    %r14,%rbp
callq  64c <grecs_getline+0x7c>
mov    %rax,%r12
jmp    600 <grecs_getline+0x30>
nopl   0x0(%rax)
test   %rbx,%rbx
mov    $0xffffffffffffffff,%rax
cmove  %rax,%rbx
mov    0x8(%rsp),%rax
mov    %r12,(%r15)
mov    %rbp,(%rax)
add    $0x18,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
callq  68d <grecs_getline+0xbd>
jmp    63e <grecs_getline+0x6e>
mov    $0x1,%edi
mov    $0x1,%ebp
callq  69e <grecs_getline+0xce>
mov    %rax,%r12
jmpq   5f8 <grecs_getline+0x28>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_getline(char **pbuf, size_t *psize, FILE *fp)
{
 char *buf = *pbuf;
 size_t size = *psize;
 ssize_t off = 0;
 if (!buf) {
  size = 1;
  buf = grecs_malloc(size);
 }
 do {
  if (off == size - 1) {
   size_t nsize = 2 * size;
   if (nsize < size)
    grecs_alloc_die();
   buf = grecs_realloc(buf, nsize);
   size = nsize;
  }
  if (!fgets(buf + off, size - off, fp)) {
   if (off == 0)
    off = -1;
   break;
  }
  off += strlen(buf + off);
 } while (buf[off - 1] != '\n');
 *pbuf = buf;
 *psize = size;
 return off;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 3
11 4
12 2
13 6
14 6
15 7
16 7
17 7
18 18
19 18
20 18
21 18
22 18
23 18
24 18
25 18
26 23
27 23
28 23
29 24
30 24
31 11
32 11
33 11
34 12
35 13
36 13
37 15
38 15
39 12
40 15
41 15
42 15
43 15
44 20
45 20
46 20
47 26
48 25
49 26
50 28
51 28
52 28
53 28
54 28
55 28
56 28
57 28
58 28
59 28
60 14
61 14
62 8
63 7
64 8
65 8
66 8
67 8
<<<sep_out_sample>>>
test   %edi,%edi
jle    b8 <cblas_snrm2+0xb8>
test   %edx,%edx
jle    b8 <cblas_snrm2+0xb8>
cmp    $0x1,%edi
je     c0 <cblas_snrm2+0xc0>
xorps  %xmm0,%xmm0
movslq %edx,%rdx
xor    %eax,%eax
movss  0x0(%rip),%xmm6        # 29 <cblas_snrm2+0x29>
shl    $0x2,%rdx
movaps %xmm6,%xmm2
movss  0x0(%rip),%xmm4        # 38 <cblas_snrm2+0x38>
movaps %xmm0,%xmm3
movaps %xmm0,%xmm5
jmp    5d <cblas_snrm2+0x5d>
divss  %xmm1,%xmm3
mulss  %xmm3,%xmm2
mulss  %xmm3,%xmm2
movaps %xmm1,%xmm3
addss  %xmm6,%xmm2
add    $0x1,%eax
add    %rdx,%rsi
cmp    %eax,%edi
jle    89 <cblas_snrm2+0x89>
movss  (%rsi),%xmm1
ucomiss %xmm0,%xmm1
jp     6b <cblas_snrm2+0x6b>
ucomiss %xmm5,%xmm1
je     53 <cblas_snrm2+0x53>
andps  %xmm4,%xmm1
ucomiss %xmm3,%xmm1
ja     40 <cblas_snrm2+0x40>
divss  %xmm3,%xmm1
add    $0x1,%eax
add    %rdx,%rsi
cmp    %eax,%edi
mulss  %xmm1,%xmm1
addss  %xmm1,%xmm2
jg     5d <cblas_snrm2+0x5d>
unpcklps %xmm2,%xmm2
sub    $0x18,%rsp
cvtps2pd %xmm2,%xmm2
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     d0 <cblas_snrm2+0xd0>
unpcklps %xmm3,%xmm3
add    $0x18,%rsp
cvtps2pd %xmm3,%xmm3
mulsd  %xmm0,%xmm3
unpcklpd %xmm3,%xmm3
cvtpd2ps %xmm3,%xmm0
retq   
nopl   0x0(%rax)
xorps  %xmm0,%xmm0
retq   
nopl   0x0(%rax)
movss  0x0(%rip),%xmm1        # c8 <cblas_snrm2+0xc8>
movss  (%rsi),%xmm0
andps  %xmm1,%xmm0
retq   
movapd %xmm2,%xmm0
movss  %xmm3,0xc(%rsp)
callq  df <cblas_snrm2+0xdf>
movss  0xc(%rsp),%xmm3
jmp    9d <cblas_snrm2+0x9d>
<<<sep_in_sample>>>
cblas_snrm2 (const int N, const float *X, const int incX)
{
{
  float scale = 0.0;
  float ssq = 1.0;
  int i;
  int ix = 0;
  if (N <= 0 || incX <= 0) {
    return 0;
  } else if (N == 1) {
    return fabs(X[0]);
  }
  for (i = 0; i < N; i++) {
    const float x = X[ix];
    if (x != 0.0) {
      const float ax = fabs(x);
      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
        scale = ax;
      } else {
        ssq += (ax / scale) * (ax / scale);
      }
    }
    ix += incX;
  }
  return scale * sqrt(ssq);
}
}
<<<sep_in_sample>>>
1 8
2 8
3 8
4 8
5 10
6 10
7 10
8 10
9 10
10 10
11 10
12 10
13 16
14 10
15 15
16 15
17 18
18 18
19 18
20 19
21 18
22 13
23 13
24 13
25 13
26 14
27 15
28 15
29 15
30 15
31 16
32 17
33 17
34 21
35 13
36 13
37 13
38 21
39 21
40 13
41 26
42 2
43 26
44 26
45 26
46 26
47 26
48 28
49 26
50 26
51 26
52 26
53 28
54 28
55 9
56 9
57 9
58 11
59 11
60 11
61 11
62 26
63 26
64 26
65 26
66 26
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
jmp    1a <nonintr_close+0x1a>
nopw   0x0(%rax,%rax,1)
callq  15 <nonintr_close+0x15>
cmpl   $0x4,(%rax)
jne    27 <nonintr_close+0x27>
mov    %ebp,%edi
callq  21 <nonintr_close+0x21>
test   %eax,%eax
mov    %eax,%ebx
js     10 <nonintr_close+0x10>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nonintr_close (int fd)
{
  int retval;
  do
    retval = close (fd);
  while (retval < 0 && (*__errno_location ()) == 4);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 5
11 5
12 6
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x48(%rdi),%eax
test   %eax,%eax
je     188c <swvarfs_set_ahs+0x1c>
mov    0x40(%rdi),%rdi
callq  188c <swvarfs_set_ahs+0x1c>
mov    %rbp,0x40(%rbx)
movl   $0x0,0x48(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
swvarfs_set_ahs(SWVARFS * swvarfs, AHS * ahs)
{
 if (swvarfs->do_close_ahsM)
  ahs_close(swvarfs->ahsM);
 swvarfs->ahsM = ahs;
 swvarfs->do_close_ahsM = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 6
13 7
14 7
15 7
16 7
17 7
<<<sep_out_sample>>>
mov    %rsi,0x40(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_password_set (Gsasl * ctx,
        Gsasl_client_callback_password cb)
{
  ctx->cbc_password = cb;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
xor    %r9d,%r9d
movl   $0x0,(%rsp)
callq  13 <rpl_getopt_long+0x13>
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rpl_getopt_long (int argc, char * *argv, const char *options,
             const struct rpl_option *long_options, int *opt_index)
{
  return rpl_getopt_internal (argc, (char **) argv, options, long_options,
                           opt_index, 0, 0);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 6
6 6
7 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x1,%esi
mov    $0x12,%edi
callq  673 <logout+0x13>
callq  678 <logout+0x18>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
logout (void)
{
  send_do (18, 1);
  netflush ();
  return 1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 6
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdx,%rbx
sub    $0x8,%rsp
test   %rdx,%rdx
je     71 <full_write+0x71>
mov    %edi,%r13d
mov    %rsi,%rbp
xor    %r12d,%r12d
jmp    30 <full_write+0x30>
nopl   (%rax)
test   %rax,%rax
je     58 <full_write+0x58>
add    %rax,%r12
add    %rax,%rbp
sub    %rax,%rbx
je     44 <full_write+0x44>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %r13d,%edi
callq  3e <full_write+0x3e>
cmp    $0xffffffffffffffff,%rax
jne    20 <full_write+0x20>
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
callq  5d <full_write+0x5d>
movl   $0x1c,(%rax)
add    $0x8,%rsp
mov    %r12,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xor    %r12d,%r12d
jmp    44 <full_write+0x44>
<<<sep_in_sample>>>
full_write (int fd, const void *buf, size_t count)
{
  size_t total = 0;
  const char *ptr = (const char *) buf;
  while (count > 0)
    {
      size_t n_rw = safe_write (fd, ptr, count);
      if (n_rw == (size_t) -1)
 break;
      if (n_rw == 0)
 {
   (*__errno_location ()) = 28;
   break;
 }
      total += n_rw;
      ptr += n_rw;
      count -= n_rw;
    }
  return total;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 5
10 5
11 3
12 3
13 3
14 10
15 10
16 15
17 16
18 5
19 5
20 7
21 7
22 7
23 7
24 8
25 8
26 20
27 20
28 20
29 20
30 20
31 20
32 20
33 20
34 12
35 12
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 3
44 3
<<<sep_out_sample>>>
mov    %rsi,0x20(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
via_set_comment (osip_via_t * via, char *comment)
{
  via->comment = comment;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movq   $0x0,0x0(%rip)        # 10b <_rl_vi_callback_set_mark+0xb>
movl   $0x1,0x0(%rip)        # 115 <_rl_vi_callback_set_mark+0x15>
jmp    b0 <_rl_vi_set_mark>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_callback_set_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
  return (_rl_vi_set_mark ());
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0xc(%rdi),%eax
add    $0x1,%eax
mov    %eax,0xc(%rdi)
imul   0x8(%rdi),%eax
mov    (%rdi),%rdi
movslq %eax,%rsi
callq  74 <xstack_push+0x24>
movslq 0x8(%rbx),%rdx
mov    0xc(%rbx),%ecx
mov    %rbp,%rsi
mov    %rax,(%rbx)
add    $0x8,%rsp
pop    %rbx
sub    $0x1,%ecx
imul   %edx,%ecx
pop    %rbp
movslq %ecx,%rcx
lea    (%rax,%rcx,1),%rdi
jmpq   99 <xstack_push+0x49>
nopl   0x0(%rax)
<<<sep_in_sample>>>
xstack_push(stack, data)
    xstack_t *stack;
    void *data;
{
    stack->data = (void *)xrealloc(stack->data, ++stack->point * stack->esize);
    memcpy(((char *)stack->data) + (stack->point - 1) * stack->esize,
    data,
    stack->esize);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 8
14 6
15 6
16 5
17 9
18 9
19 6
20 6
21 9
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <osip_authorization_init+0x7>
push   %rbx
mov    %rdi,%rbx
mov    $0x90,%edi
test   %rax,%rax
je     a0 <osip_authorization_init+0xa0>
callq  *%rax
test   %rax,%rax
mov    %rax,(%rbx)
je     f0 <osip_authorization_init+0xf0>
test   $0x1,%al
mov    %rax,%rdi
mov    $0x90,%edx
jne    b0 <osip_authorization_init+0xb0>
test   $0x2,%dil
jne    c0 <osip_authorization_init+0xc0>
test   $0x4,%dil
jne    d8 <osip_authorization_init+0xd8>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
jne    88 <osip_authorization_init+0x88>
test   $0x2,%dl
jne    70 <osip_authorization_init+0x70>
and    $0x1,%edx
jne    68 <osip_authorization_init+0x68>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
movb   $0x0,(%rdi)
xor    %eax,%eax
jmp    62 <osip_authorization_init+0x62>
nop
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     60 <osip_authorization_init+0x60>
jmp    68 <osip_authorization_init+0x68>
nopl   0x0(%rax)
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     5b <osip_authorization_init+0x5b>
jmp    70 <osip_authorization_init+0x70>
nopl   0x0(%rax)
callq  a5 <osip_authorization_init+0xa5>
jmpq   1b <osip_authorization_init+0x1b>
nopw   0x0(%rax,%rax,1)
movb   $0x0,(%rax)
add    $0x1,%rdi
mov    $0x8f,%dl
jmpq   33 <osip_authorization_init+0x33>
xchg   %ax,%ax
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
jmpq   3d <osip_authorization_init+0x3d>
nopw   0x0(%rax,%rax,1)
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmpq   47 <osip_authorization_init+0x47>
nopw   0x0(%rax,%rax,1)
mov    $0xfffffffc,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_authorization_init (osip_authorization_t ** dest)
{
  *dest = (osip_authorization_t *) (osip_malloc_func?osip_malloc_func(sizeof (osip_authorization_t)):malloc(sizeof (osip_authorization_t)));
  if (*dest == ((void *)0))
    return -4;
  memset (*dest, 0, sizeof (osip_authorization_t));
  return 0;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 3
8 4
9 3
10 4
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 7
30 8
31 8
32 8
33 6
34 7
35 7
36 7
37 6
38 6
39 6
40 6
41 6
42 6
43 6
44 6
45 6
46 6
47 6
48 6
49 6
50 3
51 3
52 3
53 6
54 6
55 6
56 6
57 6
58 6
59 6
60 6
61 6
62 6
63 6
64 6
65 6
66 6
67 6
68 6
69 5
70 8
71 8
72 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 10db <grecs_preproc_done+0xb>
callq  10e0 <grecs_preproc_done+0x10>
mov    0x0(%rip),%rdi        # 10e7 <grecs_preproc_done+0x17>
movq   $0x0,0x0(%rip)        # 10f2 <grecs_preproc_done+0x22>
callq  10f7 <grecs_preproc_done+0x27>
mov    0x0(%rip),%rdi        # 10fe <grecs_preproc_done+0x2e>
movq   $0x0,0x0(%rip)        # 1109 <grecs_preproc_done+0x39>
movq   $0x0,0x0(%rip)        # 1114 <grecs_preproc_done+0x44>
callq  1119 <grecs_preproc_done+0x49>
mov    0x0(%rip),%rdi        # 1120 <grecs_preproc_done+0x50>
movq   $0x0,0x0(%rip)        # 112b <grecs_preproc_done+0x5b>
movq   $0x0,0x0(%rip)        # 1136 <grecs_preproc_done+0x66>
movq   $0x0,0x0(%rip)        # 1141 <grecs_preproc_done+0x71>
callq  1146 <grecs_preproc_done+0x76>
movq   $0x0,0x0(%rip)        # 1151 <grecs_preproc_done+0x81>
movq   $0x0,0x0(%rip)        # 115c <grecs_preproc_done+0x8c>
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_preproc_done()
{
 grecs_symtab_free(incl_sources);
 incl_sources = ((void *)0);
 grecs_free(linebuf);
 linebuf = ((void *)0);
 bufsize = 0;
 grecs_free(putback_buffer);
 putback_buffer = ((void *)0);
 putback_size = putback_max = 0;
 free(linebufbase);
 linebufbase = ((void *)0);
 linebufsize = 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 5
5 4
6 5
7 8
8 6
9 7
10 8
11 11
12 9
13 10
14 10
15 11
16 12
17 13
18 14
19 14
20 14
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
xor    %edx,%edx
div    %rcx
cmp    %rsi,%rax
jb     8d <xnrealloc+0x1d>
imul   %rcx,%rsi
jmpq   8d <xnrealloc+0x1d>
push   %rax
callq  93 <xnrealloc+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 2
10 4
11 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 1857 <extspec_reinit+0x7>
cmp    0x0(%rip),%rsi        # 185e <extspec_reinit+0xe>
jbe    1869 <extspec_reinit+0x19>
cmp    0x0(%rip),%rsi        # 1867 <extspec_reinit+0x17>
jb     1878 <extspec_reinit+0x28>
mov    $0x0,%edi
jmpq   1873 <extspec_reinit+0x23>
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x0(%rip)        # 187f <extspec_reinit+0x2f>
mov    %rsi,0x0(%rip)        # 1886 <extspec_reinit+0x36>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
extspec_reinit (void)
{
  __extension__ ({ struct obstack *__o = (&os_extspec); void *__obj = (first_object_allocated_ptr_extspec); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rax
cmp    (%rsi),%rax
je     1b0 <gsl_blas_cdotu+0x30>
mov    $0x13,%ecx
mov    $0x7c,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1a5 <gsl_blas_cdotu+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rdi),%r10
mov    0x10(%rdi),%rdi
mov    %rdx,%r9
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%r8d
mov    %r10d,%edx
mov    %rdi,%rsi
mov    %eax,%edi
callq  1d0 <gsl_blas_cdotu+0x50>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_blas_cdotu (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
{
  if (X->size == Y->size)
    {
      cblas_cdotu_sub (((int)(X->size)), X->data, ((int)(X->stride)), Y->data,
                       ((int)(Y->stride)), ((dotu)->dat));
      return GSL_SUCCESS;
    }
  else
    {
      do { gsl_error ("invalid length", "blas.c", 124, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 12
6 12
7 12
8 12
9 12
10 12
11 14
12 14
13 14
14 6
15 6
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 8
24 14
25 14
26 14
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %esi,%ebp
mov    $0x28,%esi
push   %rbx
mov    %rdi,%rbx
mov    0xe0(%rdi),%rdi
mov    (%rdi),%r12
callq  dd <__xa_close+0x1d>
movq   $0x0,0xe0(%rbx)
mov    %rbx,%rdi
mov    %ebp,%esi
pop    %rbx
pop    %rbp
mov    %r12,%rax
pop    %r12
jmpq   *%rax
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__xa_close(dbp, flags)
 DB *dbp;
 u_int32_t flags;
{
 int (*real_close) (DB *, u_int32_t);
 real_close = ((XA_METHODS *)dbp->xa_internal)->close;
 CDB___os_free(dbp->xa_internal, sizeof(XA_METHODS));
 dbp->xa_internal = ((void *)0);
 return (real_close(dbp, flags));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 4
6 4
7 6
8 6
9 7
10 8
11 9
12 9
13 10
14 10
15 9
16 10
17 9
18 9
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   533 <gsl_vector_ushort_fwrite+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_ushort_fwrite (FILE * stream, const gsl_vector_ushort * v)
{
  int status = gsl_block_ushort_raw_fwrite (stream,
                                                 v->data,
                                                 v->size,
                                                 v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
lea    0x0(,%rsi,8),%rbx
xor    %esi,%esi
sub    $0x8,%rsp
mov    (%rdi),%rdi
mov    %rbx,%rdx
callq  7e <rk4_reset+0x1e>
mov    0x8(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  8c <rk4_reset+0x2c>
mov    0x10(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  9a <rk4_reset+0x3a>
mov    0x18(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  a8 <rk4_reset+0x48>
mov    0x20(%rbp),%rdi
mov    %rbx,%rdx
xor    %esi,%esi
callq  b6 <rk4_reset+0x56>
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
nop
<<<sep_in_sample>>>
rk4_reset (void *vstate, size_t dim)
{
  rk4_state_t *state = (rk4_state_t *) vstate;
  memset((state->k),0,(dim)*sizeof(double));
  memset((state->k1),0,(dim)*sizeof(double));
  memset((state->y0),0,(dim)*sizeof(double));
  memset((state->ytmp),0,(dim)*sizeof(double));
  memset((state->y_onestep),0,(dim)*sizeof(double));
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 2
7 4
8 4
9 4
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 7
19 7
20 7
21 7
22 8
23 8
24 8
25 8
26 10
27 10
28 10
29 10
30 10
31 10
<<<sep_out_sample>>>
push   %r15
mov    %rsi,%r15
push   %r14
mov    %rdi,%r14
push   %r13
mov    %r8,%r13
push   %r12
mov    %rcx,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %r9,%rbx
sub    $0x18,%rsp
callq  9c5 <gsl_stats_ushort_ttest+0x25>
mov    %rbx,%rdx
mov    %r13,%rsi
mov    %r12,%rdi
movsd  %xmm0,(%rsp)
callq  9d8 <gsl_stats_ushort_ttest+0x38>
mov    %rbx,%r9
mov    %r13,%r8
mov    %r12,%rcx
mov    %rbp,%rdx
mov    %r15,%rsi
mov    %r14,%rdi
movsd  %xmm0,0x8(%rsp)
callq  9f5 <gsl_stats_ushort_ttest+0x55>
test   %rbp,%rbp
js     a58 <gsl_stats_ushort_ttest+0xb8>
cvtsi2sd %rbp,%xmm1
movsd  0x0(%rip),%xmm2        # a07 <gsl_stats_ushort_ttest+0x67>
test   %rbx,%rbx
movapd %xmm2,%xmm3
divsd  %xmm1,%xmm3
js     a78 <gsl_stats_ushort_ttest+0xd8>
cvtsi2sd %rbx,%xmm1
movapd %xmm2,%xmm4
divsd  %xmm1,%xmm4
movapd %xmm4,%xmm1
addsd  %xmm3,%xmm1
mulsd  %xmm0,%xmm1
sqrtsd %xmm1,%xmm1
ucomisd %xmm1,%xmm1
jp     a92 <gsl_stats_ushort_ttest+0xf2>
movsd  (%rsp),%xmm0
subsd  0x8(%rsp),%xmm0
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
divsd  %xmm1,%xmm0
pop    %r15
retq   
nopl   (%rax)
mov    %rbp,%rax
mov    %rbp,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    9ff <gsl_stats_ushort_ttest+0x5f>
nopw   0x0(%rax,%rax,1)
mov    %rbx,%rax
mov    %rbx,%rdx
shr    %rax
and    $0x1,%edx
or     %rdx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    a19 <gsl_stats_ushort_ttest+0x79>
test   %rbp,%rbp
js     acc <gsl_stats_ushort_ttest+0x12c>
cvtsi2sd %rbp,%xmm1
movapd %xmm2,%xmm3
test   %rbx,%rbx
divsd  %xmm1,%xmm3
js     ae3 <gsl_stats_ushort_ttest+0x143>
cvtsi2sd %rbx,%xmm1
divsd  %xmm1,%xmm2
addsd  %xmm3,%xmm2
mulsd  %xmm0,%xmm2
movapd %xmm2,%xmm0
callq  ac3 <gsl_stats_ushort_ttest+0x123>
movapd %xmm0,%xmm1
jmpq   a37 <gsl_stats_ushort_ttest+0x97>
mov    %rbp,%rax
and    $0x1,%ebp
shr    %rax
or     %rbp,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    a9c <gsl_stats_ushort_ttest+0xfc>
mov    %rbx,%rax
and    $0x1,%ebx
shr    %rax
or     %rbx,%rax
cvtsi2sd %rax,%xmm1
addsd  %xmm1,%xmm1
jmp    aae <gsl_stats_ushort_ttest+0x10e>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ushort_ttest (const unsigned short data1[],
                           const size_t stride1, const size_t n1,
                           const unsigned short data2[],
                           const size_t stride2, const size_t n2)
{
  const double mean1 = gsl_stats_ushort_mean (data1, stride1, n1);
  const double mean2 = gsl_stats_ushort_mean (data2, stride2, n2);
  const double pv = gsl_stats_ushort_pvariance (data1, stride1, n1, data2, stride2, n2);
  const double t = (mean1 - mean2) / (sqrt (pv * ((1.0 / n1) + (1.0 / n2))));
  return t;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 5
14 6
15 7
16 7
17 7
18 6
19 7
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 9
29 9
30 9
31 9
32 9
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 9
41 9
42 9
43 9
44 9
45 9
46 9
47 11
48 11
49 11
50 11
51 11
52 11
53 9
54 11
55 11
56 11
57 9
58 9
59 9
60 9
61 9
62 9
63 9
64 9
65 9
66 9
67 9
68 9
69 9
70 9
71 9
72 9
73 9
74 9
75 9
76 9
77 9
78 9
79 9
80 9
81 9
82 9
83 9
84 9
85 9
86 9
87 9
88 9
89 9
90 9
91 9
92 9
93 9
94 9
95 9
96 9
97 9
98 9
99 9
100 9
101 9
102 9
103 9
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     19df <mu_string_unfold+0xbf>
movzbl (%rdi),%eax
test   %al,%al
je     19ef <mu_string_unfold+0xcf>
mov    %rdi,%rdx
mov    %rdi,%r8
xor    %ecx,%ecx
jmp    197b <mu_string_unfold+0x5b>
nopl   0x0(%rax,%rax,1)
jb     19d0 <mu_string_unfold+0xb0>
cmp    $0x2,%ecx
jne    1970 <mu_string_unfold+0x50>
cmp    $0x20,%al
je     1970 <mu_string_unfold+0x50>
and    $0xfffffffb,%eax
cmp    $0x9,%al
je     1970 <mu_string_unfold+0x50>
movb   $0x20,(%r8)
movzbl (%rdx),%eax
add    $0x2,%r8
xor    %ecx,%ecx
mov    %al,-0x1(%r8)
nop
add    $0x1,%rdx
movzbl (%rdx),%eax
test   %al,%al
je     19b0 <mu_string_unfold+0x90>
cmp    $0x1,%ecx
jne    1948 <mu_string_unfold+0x28>
cmp    $0x20,%al
mov    $0x2,%ecx
je     1970 <mu_string_unfold+0x50>
mov    %eax,%r9d
and    $0xfffffffb,%r9d
cmp    $0x9,%r9b
je     1970 <mu_string_unfold+0x50>
add    $0x1,%rdx
mov    %al,(%r8)
xor    %cl,%cl
movzbl (%rdx),%eax
add    $0x1,%r8
test   %al,%al
jne    197b <mu_string_unfold+0x5b>
nopw   0x0(%rax,%rax,1)
test   %rsi,%rsi
lea    0x1(%r8),%rax
movb   $0x0,(%r8)
je     19dd <mu_string_unfold+0xbd>
sub    %rdi,%rax
mov    %rax,(%rsi)
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
cmp    $0xa,%al
je     19e8 <mu_string_unfold+0xc8>
mov    %al,(%r8)
add    $0x1,%r8
jmp    1970 <mu_string_unfold+0x50>
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
mov    $0x1,%ecx
jmp    1970 <mu_string_unfold+0x50>
mov    %rdi,%r8
jmp    19b0 <mu_string_unfold+0x90>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_string_unfold (char *text, size_t *plen)
{
  char *p, *q;
  enum uf_state { uf_init, uf_nl, uf_fold } state = uf_init;
  if (!text)
    return 22;
  for (p = q = text; *q; q++)
    {
      switch (state)
 {
 case uf_init:
   if (*q == '\n')
     state = uf_nl;
   else
     *p++ = *q;
   break;
 case uf_nl:
   if ((*q == '\r' || *q == ' ' || *q == '\t'))
     state = uf_fold;
   else
     {
       state = uf_init;
       *p++ = *q;
     }
   break;
 case uf_fold:
   if (!(*q == '\r' || *q == ' ' || *q == '\t'))
     {
       *p++ = ' ';
       *p++ = *q;
       state = uf_init;
     }
   break;
 }
    }
  *p++ = 0;
  if (plen)
    *plen = p - text;
  return 0;
}
<<<sep_in_sample>>>
1 5
2 6
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 27
16 27
17 27
18 27
19 27
20 29
21 30
22 30
23 31
24 30
25 30
26 7
27 7
28 7
29 7
30 9
31 9
32 18
33 19
34 18
35 18
36 18
37 18
38 18
39 7
40 23
41 22
42 7
43 23
44 7
45 7
46 7
47 37
48 36
49 36
50 37
51 38
52 38
53 39
54 39
55 39
56 12
57 12
58 15
59 15
60 15
61 39
62 40
63 40
64 13
65 13
66 7
67 7
68 7
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    (%rsi),%r9
cmp    (%rdi),%r9
mov    0x8(%rdi),%rax
je     1410 <gsl_matrix_long_double_mul_elements+0x40>
mov    $0x13,%ecx
mov    $0x56,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  13ff <gsl_matrix_long_double_mul_elements+0x2f>
mov    $0x13,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    0x8(%rsi),%rbp
cmp    %rax,%rbp
jne    13e6 <gsl_matrix_long_double_mul_elements+0x16>
test   %r9,%r9
mov    0x10(%rdi),%r12
mov    0x10(%rsi),%r13
je     147e <gsl_matrix_long_double_mul_elements+0xae>
mov    %rbp,%r8
shl    $0x4,%r13
shl    $0x4,%r12
shl    $0x4,%r8
xor    %ebx,%ebx
xor    %r11d,%r11d
xor    %r10d,%r10d
nopl   (%rax)
test   %rbp,%rbp
je     146f <gsl_matrix_long_double_mul_elements+0x9f>
mov    %rbx,%rdx
mov    %r11,%rcx
add    0x18(%rdi),%rdx
add    0x18(%rsi),%rcx
xor    %eax,%eax
nopl   (%rax)
fldt   (%rdx)
add    $0x10,%rdx
fldt   (%rcx,%rax,1)
add    $0x10,%rax
fmulp  %st,%st(1)
fstpt  -0x10(%rdx)
cmp    %r8,%rax
jne    1458 <gsl_matrix_long_double_mul_elements+0x88>
add    $0x1,%r10
add    %r13,%r11
add    %r12,%rbx
cmp    %r9,%r10
jne    1440 <gsl_matrix_long_double_mul_elements+0x70>
xor    %eax,%eax
jmp    1404 <gsl_matrix_long_double_mul_elements+0x34>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_double_mul_elements (gsl_matrix_long_double * a, const gsl_matrix_long_double * b)
{
  const size_t M = a->size1;
  const size_t N = a->size2;
  if (b->size1 != M || b->size2 != N)
    {
      do { gsl_error ("matrices must have same dimensions", "oper_source.c", 86, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t tda_a = a->tda;
      const size_t tda_b = b->tda;
      size_t i, j;
      for (i = 0; i < M; i++)
        {
          for (j = 0; j < N; j++)
            {
              a->data[i * tda_a + j] *= b->data[i * tda_b + j];
            }
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 4
9 5
10 7
11 7
12 7
13 7
14 7
15 7
16 23
17 23
18 23
19 23
20 23
21 23
22 23
23 5
24 5
25 5
26 14
27 11
28 12
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 16
46 18
47 18
48 18
49 18
50 18
51 18
52 16
53 16
54 14
55 14
56 14
57 14
58 14
59 21
60 21
61 21
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x16,%eax
je     4d1 <mu_ticket_set_data+0x11>
cmp    %rdx,(%rdi)
mov    $0xd,%al
je     4d8 <mu_ticket_set_data+0x18>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x30(%rdi)
xor    %al,%al
retq   
<<<sep_in_sample>>>
mu_ticket_set_data (mu_ticket_t ticket, void *data, void *owner)
{
  if (ticket == ((void *)0))
    return 22;
  if (ticket->owner != owner)
    return 13;
  ticket->data = data;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 9
8 9
9 7
10 8
11 9
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r13
mov    %rdi,0x8(%rsp)
mov    (%rsi),%r14
cmp    %r12,%r13
je     24f1 <gsl_matrix_uchar_fread+0x81>
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r14,%r14
jne    24b4 <gsl_matrix_uchar_fread+0x44>
jmp    24e0 <gsl_matrix_uchar_fread+0x70>
nopw   0x0(%rax,%rax,1)
add    $0x1,%r15
add    %r13,%rbx
cmp    %r14,%r15
je     24e0 <gsl_matrix_uchar_fread+0x70>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    0x8(%rsp),%rdi
mov    $0x1,%ecx
mov    %r12,%rdx
callq  24cd <gsl_matrix_uchar_fread+0x5d>
test   %eax,%eax
je     24a8 <gsl_matrix_uchar_fread+0x38>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
mov    0x8(%rsp),%rdi
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
mov    %r13,%rdx
mov    $0x1,%ecx
pop    %r13
imul   %r14,%rdx
pop    %r14
pop    %r15
jmpq   2519 <gsl_matrix_uchar_fread+0xa9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_matrix_uchar_fread (FILE * stream, gsl_matrix_uchar * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uchar_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uchar_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 6
11 2
12 4
13 7
14 7
15 16
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 18
26 18
27 18
28 18
29 18
30 18
31 21
32 21
33 26
34 26
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 16
43 26
44 26
45 26
46 26
47 26
48 26
49 26
50 9
51 9
52 26
53 26
54 26
55 26
56 9
57 9
58 26
59 9
60 26
61 26
62 9
63 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     169 <jit_free+0x19>
callq  *0x0(%rip)        # 162 <jit_free+0x12>
movq   $0x0,(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
jit_free(jit_pointer_t *ptr)
{
    if (*ptr) {
 (*jit_free_ptr)(*ptr);
 *ptr = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 5
8 7
9 7
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
lea    0xcc(%rdi),%rdx
push   %rbp
mov    %rsi,%rbp
mov    $0x48,%esi
push   %rbx
mov    0xc8(%rdi),%ecx
mov    %rdi,%rbx
callq  e4 <nettle_sha3_512_digest+0x24>
mov    %rbp,%rdi
mov    %rbx,%rdx
mov    %r12,%rsi
callq  f2 <nettle_sha3_512_digest+0x32>
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
pop    %r12
jmpq   fe <nettle_sha3_512_digest+0x3e>
<<<sep_in_sample>>>
nettle_sha3_512_digest(struct sha3_512_ctx *ctx,
  size_t length,
  uint8_t *digest)
{
  _nettle_sha3_pad (&ctx->state, 72, ctx->block, ctx->index);
  _nettle_write_le64 (length, digest, ctx->state.a);
  nettle_sha3_512_init (ctx);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 4
5 4
6 5
7 4
8 5
9 4
10 5
11 6
12 6
13 6
14 6
15 7
16 8
17 8
18 8
19 7
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicat_r_get_installed_catalog(GB * G, VPLOB * swspecs, char * target_path)
{
        return -1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x10,%rsp
mov    0x50(%rdi),%r12
mov    0x20(%rdi),%rdi
lea    0x8(%rsp),%rsi
movq   $0x0,0x8(%rsp)
callq  e76 <mbox_is_updated+0x26>
test   %eax,%eax
mov    %eax,%ebx
jne    ea0 <mbox_is_updated+0x50>
mov    0x8(%rsp),%rax
cmp    %rax,0x18(%r12)
jg     eb0 <mbox_is_updated+0x60>
sete   %bl
add    $0x10,%rsp
movzbl %bl,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
add    $0x10,%rsp
mov    $0x1,%ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
mov    0x0(%rbp),%rdi
mov    %rbp,%rdx
mov    $0x40,%esi
callq  ec1 <mbox_is_updated+0x71>
mov    $0x0,%esi
mov    $0x0,%edi
callq  ed0 <mbox_is_updated+0x80>
xor    %edi,%edi
mov    %rax,%rsi
xor    %eax,%eax
callq  edc <mbox_is_updated+0x8c>
add    $0x10,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_is_updated (mu_mailbox_t mailbox)
{
  mu_off_t size = 0;
  mbox_data_t mud = mailbox->data;
  if (mu_stream_size (mailbox->stream, &size) != 0)
    return 1;
  if (size < mud->size)
    {
      mu_observable_notify (mailbox->observable, 0x040,
       mailbox);
      mu_diag_output (0, dgettext ("mailutils", "mailbox corrupted, shrank in size"));
      return 0;
    }
  return (mud->size == size);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 4
7 5
8 5
9 3
10 5
11 5
12 5
13 5
14 7
15 7
16 7
17 14
18 15
19 14
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 6
28 15
29 15
30 15
31 15
32 15
33 9
34 9
35 9
36 9
37 11
38 11
39 11
40 11
41 11
42 11
43 11
44 15
45 15
46 15
47 15
48 15
49 15
50 15
<<<sep_out_sample>>>
push   %rbx
mov    (%rdi),%eax
cmp    $0x1,%eax
je     330 <gc_hash_read+0x30>
cmp    $0x2,%eax
jne    328 <gc_hash_read+0x28>
lea    0x8(%rdi),%rbx
add    $0xb8,%rdi
mov    %rbx,%rsi
callq  320 <gc_hash_read+0x20>
mov    %rbx,%rax
pop    %rbx
retq   
nopl   (%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
lea    0x8(%rdi),%rbx
add    $0x1c,%rdi
mov    %rbx,%rsi
callq  340 <gc_hash_read+0x40>
mov    %rbx,%rax
pop    %rbx
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gc_hash_read (gc_hash_handle handle)
{
  _gc_hash_ctx *ctx = handle;
  const char *ret = ((void *)0);
  switch (ctx->alg)
    {
    case GC_MD5:
      md5_finish_ctx (&ctx->md5Context, ctx->hash);
      ret = ctx->hash;
      break;
    case GC_SHA1:
      sha1_finish_ctx (&ctx->sha1Context, ctx->hash);
      ret = ctx->hash;
      break;
    default:
      return ((void *)0);
    }
  return ret;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 5
7 12
8 12
9 12
10 12
11 13
12 19
13 19
14 19
15 16
16 19
17 19
18 19
19 8
20 8
21 8
22 8
23 9
24 19
25 19
26 19
<<<sep_out_sample>>>
mov    0x10(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_www_authenticate_get_domain (osip_www_authenticate_t * www_authenticate)
{
  return www_authenticate->domain;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
test   %sil,%sil
push   %rbx
mov    %rdi,%rbx
je     1ef <check_normalization+0xf>
cmpl   $0x3,0x10(%rdi)
jne    222 <check_normalization+0x42>
mov    0x110(%rbx),%rdi
test   %rdi,%rdi
je     208 <check_normalization+0x28>
cmpl   $0x3,0x10(%rdi)
jne    23b <check_normalization+0x5b>
xor    %esi,%esi
callq  1e0 <check_normalization>
mov    0x118(%rbx),%rdi
test   %rdi,%rdi
je     220 <check_normalization+0x40>
pop    %rbx
xor    %esi,%esi
jmp    1e0 <check_normalization>
nopl   0x0(%rax)
pop    %rbx
retq   
mov    $0x0,%ecx
mov    $0x4d6,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  23b <check_normalization+0x5b>
mov    $0x0,%ecx
mov    $0x4db,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  254 <check_normalization+0x74>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
check_normalization (struct predicate *p, _Bool at_root)
{
  if (at_root)
    {
      ((BI_OP == p->p_type) ? (void) (0) : __assert_fail ("BI_OP == p->p_type", "tree.c", 1238, __PRETTY_FUNCTION__));
    }
  if (p->pred_left)
    {
      ((BI_OP == p->pred_left->p_type) ? (void) (0) : __assert_fail ("BI_OP == p->pred_left->p_type", "tree.c", 1243, __PRETTY_FUNCTION__));
      check_normalization(p->pred_left, 0);
    }
  if (p->pred_right)
    {
      check_normalization (p->pred_right, 0);
    }
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 5
6 5
7 7
8 7
9 7
10 9
11 9
12 10
13 10
14 12
15 12
16 12
17 16
18 14
19 14
20 14
21 16
22 16
23 5
24 5
25 5
26 5
27 5
28 9
29 9
30 9
31 9
32 9
33 9
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cmpl   $0x1,0x0(%rip)        # 7 <sigwinch_handler+0x7>
je     10 <sigwinch_handler+0x10>
repz retq 
nopl   0x0(%rax,%rax,1)
mov    $0x19a,%edi
jmpq   1a <sigwinch_handler+0x1a>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sigwinch_handler(int sig, siginfo_t *info, void *unused)
{
    (void) sig;
    (void) info;
    (void) unused;
    if(incurses == YES)
        ungetch(0632);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 7
6 7
7 7
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
callq  3a9 <fputs_nl+0x9>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  3b6 <fputs_nl+0x16>
xor    %eax,%eax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fputs_nl(const char *s, FILE *op)
{
 fputs(s, op);
 _IO_putc ('\n', op);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 6
9 6
10 6
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x418,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x408(%rsp)
xor    %eax,%eax
movabs $0x203a78696e756d76,%rax
movb   $0x0,0x8(%rsp)
lea    0x400(%rsp),%rbp
mov    %rax,(%rsp)
movzbl (%rdi),%eax
test   %al,%al
je     1a8d <printsys+0xad>
nopl   0x0(%rax)
cmp    $0x3c,%al
je     1ab0 <printsys+0xd0>
movzbl (%rbx),%edx
mov    $0x7,%ecx
mov    $0x2,%edi
test   %dl,%dl
je     1afc <printsys+0x11c>
add    $0x1,%rbx
cmp    $0xa,%dl
lea    0x8(%rsp),%rax
jne    1a66 <printsys+0x86>
jmp    1a74 <printsys+0x94>
nopl   (%rax)
add    $0x1,%rbx
cmp    $0xa,%dl
je     1a74 <printsys+0x94>
cmp    %rbp,%rax
jae    1a74 <printsys+0x94>
add    $0x1,%rax
mov    %dl,-0x1(%rax)
movzbl (%rbx),%edx
test   %dl,%dl
jne    1a58 <printsys+0x78>
mov    0x0(%rip),%rdx        # 1a7b <printsys+0x9b>
movb   $0x0,(%rax)
mov    %rsp,%rsi
callq  1a86 <printsys+0xa6>
movzbl (%rbx),%eax
test   %al,%al
jne    1a28 <printsys+0x48>
mov    0x408(%rsp),%rax
xor    %fs:0x28,%rax
jne    1b10 <printsys+0x130>
add    $0x418,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
callq  1ab5 <printsys+0xd5>
mov    %rbx,%rsi
mov    (%rax),%rcx
xor    %edi,%edi
jmp    1aca <printsys+0xea>
nop
lea    (%rdi,%rdi,4),%eax
mov    %rbx,%rsi
lea    -0x30(%rdx,%rax,2),%edi
add    $0x1,%rbx
movsbl (%rbx),%edx
movsbq %dl,%rax
testb  $0x8,0x1(%rcx,%rax,2)
jne    1ac0 <printsys+0xe0>
cmp    $0x3e,%dl
je     1b06 <printsys+0x126>
test   $0xfffffc00,%edi
mov    $0x2,%eax
mov    $0x6,%ecx
cmovne %eax,%edi
test   %dl,%dl
jne    1a45 <printsys+0x65>
lea    0x8(%rsp),%rax
jmpq   1a74 <printsys+0x94>
lea    0x2(%rsi),%rbx
movzbl 0x2(%rsi),%edx
jmp    1ae1 <printsys+0x101>
callq  1b15 <printsys+0x135>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
printsys (const char *msg)
{
  int c, pri, flags;
  char *lp, *q, line[1024 + 1];
  const char *p;
  strcpy (line, "vmunix: ");
  lp = line + strlen (line);
  for (p = msg; *p != '\0';)
    {
      flags = 0x002 | 0x004;
      pri = ((0<<3)|2);
      if (*p == '<')
 {
   pri = 0;
   while (((*__ctype_b_loc ())[(int) ((*++p))] & (unsigned short int) _ISdigit))
     pri = 10 * pri + (*p - '0');
   if (*p == '>')
     ++p;
 }
      else
 {
   flags |= 0x001;
 }
      if (pri & ~(0x03f8 | 0x07))
 pri = ((0<<3)|2);
      q = lp;
      while (*p != '\0' && (c = *p++) != '\n' && q < &line[1024])
 *q++ = c;
      *q = '\0';
      logmsg (pri, line, LocalHostName, flags);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 6
10 27
11 6
12 8
13 8
14 8
15 8
16 12
17 12
18 12
19 22
20 11
21 27
22 27
23 27
24 27
25 26
26 27
27 27
28 27
29 27
30 27
31 27
32 27
33 27
34 28
35 28
36 27
37 27
38 27
39 30
40 29
41 30
42 30
43 8
44 8
45 8
46 32
47 32
48 32
49 32
50 32
51 32
52 32
53 32
54 32
55 12
56 12
57 12
58 12
59 12
60 16
61 15
62 16
63 15
64 15
65 15
66 15
67 15
68 17
69 17
70 17
71 17
72 17
73 17
74 27
75 27
76 26
77 26
78 18
79 18
80 18
81 32
82 32
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rdi
test   %rdi,%rdi
je     288 <folder_set_auth_method+0x28>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
jmpq   285 <folder_set_auth_method+0x25>
nopl   (%rax)
xor    %esi,%esi
mov    %rbx,%rdx
mov    %rbx,%rdi
callq  295 <folder_set_auth_method+0x35>
test   %eax,%eax
jne    2a0 <folder_set_auth_method+0x40>
mov    (%rbx),%rdi
jmp    274 <folder_set_auth_method+0x14>
xchg   %ax,%ax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
folder_set_auth_method (mu_folder_t folder, auth_method_t method)
{
  if (!folder->authority)
    {
      int status = mu_authority_create (&folder->authority, ((void *)0), folder);
      if (status)
 return status;
    }
  return mu_authority_set_authenticate (folder->authority, method, folder);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 10
10 9
11 9
12 10
13 10
14 9
15 9
16 5
17 5
18 5
19 5
20 6
21 6
22 6
23 6
24 6
25 10
26 10
27 10
28 10
29 10
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
libunistring_c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
mov    %rdi,%rbp
push   %rbx
je     420 <ltrim+0x70>
callq  3c1 <ltrim+0x11>
lea    0x1(%rax),%r12
mov    %rax,%rbx
mov    %r12,%rdi
callq  3d0 <ltrim+0x20>
test   %rax,%rax
je     420 <ltrim+0x70>
mov    %r12,%rdx
mov    %rbp,%rsi
mov    %rax,%rdi
callq  3e3 <ltrim+0x33>
xor    %edx,%edx
mov    %rax,%rcx
cmp    %rbx,%rdx
mov    %edx,%r8d
mov    %rdx,%rax
je     40a <ltrim+0x5a>
movzbl (%rcx,%rdx,1),%esi
add    $0x1,%rdx
lea    -0x9(%rsi),%edi
cmp    $0x1,%dil
jbe    3e8 <ltrim+0x38>
cmp    $0x20,%sil
je     3e8 <ltrim+0x38>
add    %rcx,%rax
test   %r8d,%r8d
cmove  %rcx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    414 <ltrim+0x64>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ltrim(str string)
{
  if(!string) return ((void *)0);
  str _s = (str) malloc(strlen(string)+1);
  if(!_s) return ((void *)0);
  strcpy(_s, string);
  int i;
  for(i = 0; i < strlen(_s); i++)
    if(_s[i] == ' ' || _s[i] == '\t' || _s[i] == '\n') continue;
    else break;
  if(i == 0) return _s;
  else return _s+i;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 6
15 6
16 6
17 6
18 8
19 6
20 8
21 8
22 8
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 9
31 12
32 12
33 12
34 13
35 13
36 13
37 13
38 13
39 3
40 3
41 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     320 <mu_attribute_is_userflag+0x10>
mov    0xc(%rdi),%eax
and    %esi,%eax
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_attribute_is_userflag (mu_attribute_t attr, int flag)
{
  if (attr == ((void *)0))
    return 0;
  return attr->user_flags & flag;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 5
7 4
8 6
9 6
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   3e3 <gsl_sort_vector_smallest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_smallest (double * dest, const size_t k,
                                     const gsl_vector * v)
{
  return gsl_sort_smallest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
xorpd  %xmm3,%xmm3
movapd %xmm0,%xmm4
ucomisd %xmm3,%xmm0
jp     38 <gsl_poly_solve_quadratic+0x38>
jne    38 <gsl_poly_solve_quadratic+0x38>
ucomisd %xmm3,%xmm1
jnp    d0 <gsl_poly_solve_quadratic+0xd0>
movsd  0x0(%rip),%xmm0        # 22 <gsl_poly_solve_quadratic+0x22>
mov    $0x1,%eax
xorpd  %xmm0,%xmm2
divsd  %xmm1,%xmm2
movsd  %xmm2,(%rdi)
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm0        # 40 <gsl_poly_solve_quadratic+0x40>
movapd %xmm1,%xmm5
mulsd  %xmm4,%xmm0
mulsd  %xmm1,%xmm5
mulsd  %xmm2,%xmm0
subsd  %xmm0,%xmm5
ucomisd %xmm3,%xmm5
jbe    110 <gsl_poly_solve_quadratic+0x110>
sub    $0x48,%rsp
ucomisd %xmm3,%xmm1
jnp    e0 <gsl_poly_solve_quadratic+0xe0>
cmpltsd %xmm1,%xmm3
movsd  0x0(%rip),%xmm0        # 75 <gsl_poly_solve_quadratic+0x75>
movsd  0x0(%rip),%xmm6        # 7d <gsl_poly_solve_quadratic+0x7d>
andpd  %xmm3,%xmm0
andnpd %xmm6,%xmm3
orpd   %xmm0,%xmm3
sqrtsd %xmm5,%xmm0
ucomisd %xmm0,%xmm0
jp     16e <gsl_poly_solve_quadratic+0x16e>
mulsd  %xmm0,%xmm3
addsd  %xmm1,%xmm3
mulsd  0x0(%rip),%xmm3        # a7 <gsl_poly_solve_quadratic+0xa7>
movapd %xmm3,%xmm0
divsd  %xmm3,%xmm2
divsd  %xmm4,%xmm0
ucomisd %xmm0,%xmm2
jbe    130 <gsl_poly_solve_quadratic+0x130>
movsd  %xmm0,(%rdi)
mov    $0x2,%eax
movsd  %xmm2,(%rsi)
add    $0x48,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%eax
jne    1a <gsl_poly_solve_quadratic+0x1a>
repz retq 
nopl   (%rax)
jne    68 <gsl_poly_solve_quadratic+0x68>
movsd  0x0(%rip),%xmm3        # ea <gsl_poly_solve_quadratic+0xea>
xorpd  %xmm3,%xmm2
divsd  %xmm4,%xmm2
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     143 <gsl_poly_solve_quadratic+0x143>
xorpd  %xmm0,%xmm3
mov    $0x2,%eax
movsd  %xmm3,(%rdi)
movsd  %xmm0,(%rsi)
jmp    c6 <gsl_poly_solve_quadratic+0xc6>
nop
jp     140 <gsl_poly_solve_quadratic+0x140>
jne    140 <gsl_poly_solve_quadratic+0x140>
mulsd  0x0(%rip),%xmm1        # 11c <gsl_poly_solve_quadratic+0x11c>
mov    $0x2,%eax
divsd  %xmm4,%xmm1
movsd  %xmm1,(%rdi)
movsd  %xmm1,(%rsi)
retq   
xchg   %ax,%ax
movsd  %xmm2,(%rdi)
mov    $0x2,%eax
movsd  %xmm0,(%rsi)
jmp    c6 <gsl_poly_solve_quadratic+0xc6>
nop
xor    %eax,%eax
retq   
movapd %xmm2,%xmm0
mov    %rsi,0x20(%rsp)
movapd %xmm3,0x10(%rsp)
mov    %rdi,0x8(%rsp)
callq  15c <gsl_poly_solve_quadratic+0x15c>
movapd 0x10(%rsp),%xmm3
mov    0x20(%rsp),%rsi
mov    0x8(%rsp),%rdi
jmp    fc <gsl_poly_solve_quadratic+0xfc>
movapd %xmm5,%xmm0
mov    %rsi,0x38(%rsp)
mov    %rdi,0x30(%rsp)
movsd  %xmm2,0x28(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm4,0x20(%rsp)
movsd  %xmm3,0x8(%rsp)
callq  199 <gsl_poly_solve_quadratic+0x199>
mov    0x38(%rsp),%rsi
mov    0x30(%rsp),%rdi
movsd  0x28(%rsp),%xmm2
movsd  0x10(%rsp),%xmm1
movsd  0x20(%rsp),%xmm4
movsd  0x8(%rsp),%xmm3
jmpq   97 <gsl_poly_solve_quadratic+0x97>
<<<sep_in_sample>>>
gsl_poly_solve_quadratic (double a, double b, double c,
                          double *x0, double *x1)
{
  if (a == 0)
    {
      if (b == 0)
        {
          return 0;
        }
      else
        {
          *x0 = -c / b;
          return 1;
        };
    }
  {
    double disc = b * b - 4 * a * c;
    if (disc > 0)
      {
        if (b == 0)
          {
            double r = sqrt (-c / a);
            *x0 = -r;
            *x1 = r;
          }
        else
          {
            double sgnb = (b > 0 ? 1 : -1);
            double temp = -0.5 * (b + sgnb * sqrt (disc));
            double r1 = temp / a ;
            double r2 = c / temp ;
            if (r1 < r2)
              {
                *x0 = r1 ;
                *x1 = r2 ;
              }
            else
              {
                *x0 = r2 ;
                  *x1 = r1 ;
              }
          }
        return 2;
      }
    else if (disc == 0)
      {
        *x0 = -0.5 * b / a ;
        *x1 = -0.5 * b / a ;
        return 2 ;
      }
    else
      {
        return 0;
      }
  }
}
<<<sep_in_sample>>>
1 4
2 3
3 4
4 4
5 4
6 6
7 6
8 12
9 13
10 12
11 12
12 12
13 13
14 13
15 17
16 17
17 17
18 17
19 17
20 17
21 18
22 18
23 3
24 20
25 20
26 28
27 28
28 28
29 28
30 28
31 28
32 29
33 29
34 29
35 29
36 29
37 29
38 30
39 31
40 30
41 32
42 32
43 34
44 43
45 35
46 56
47 56
48 56
49 8
50 6
51 56
52 56
53 20
54 22
55 22
56 22
57 22
58 22
59 22
60 23
61 43
62 23
63 24
64 24
65 24
66 45
67 45
68 47
69 49
70 47
71 47
72 48
73 49
74 49
75 39
76 43
77 40
78 40
79 40
80 8
81 8
82 22
83 22
84 22
85 22
86 22
87 22
88 22
89 22
90 22
91 29
92 29
93 29
94 29
95 29
96 29
97 29
98 29
99 29
100 29
101 29
102 29
103 29
104 29
105 29
<<<sep_out_sample>>>
test   %rdi,%rdi
je     e8 <mu_observer_action+0x18>
mov    0x10(%rdi),%rax
test   %rax,%rax
je     f0 <mu_observer_action+0x20>
mov    0x18(%rdi),%rcx
jmpq   *%rax
nopl   0x0(%rax)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_observer_action (mu_observer_t observer, size_t type, void *data)
{
  if (observer == ((void *)0))
    return 22;
  if (observer->_action)
    return observer->_action (observer, type, data, observer->_action_data);
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
9 4
10 4
11 4
12 7
13 8
14 8
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rbx
mov    0x28(%rsi),%rsi
test   %rsi,%rsi
je     12 <auth_pass+0x12>
cmpb   $0x0,(%rsi)
jne    20 <auth_pass+0x20>
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
callq  25 <auth_pass+0x25>
test   %rax,%rax
je     12 <auth_pass+0x12>
mov    0x28(%rbx),%rsi
mov    %rax,%rdi
callq  36 <auth_pass+0x36>
test   %eax,%eax
setne  %al
movzbl %al,%eax
pop    %rbx
retq   
<<<sep_in_sample>>>
auth_pass (const char *passwd, struct credentials *pcred)
{
  switch (pcred->auth_type)
    {
    case 0:
    default:
      {
 char *xpasswd;
 char *salt = pcred->passwd;
 if (pcred->passwd == ((void *)0) || *pcred->passwd == '\0')
   return 1;
 xpasswd = crypt (passwd, salt);
 return (!xpasswd || strcmp (xpasswd, pcred->passwd) != 0);
      }
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 2
3 9
4 10
5 10
6 10
7 10
8 11
9 17
10 17
11 17
12 12
13 13
14 13
15 13
16 13
17 13
18 13
19 13
20 13
21 17
22 17
<<<sep_out_sample>>>
mov    $0x0,%esi
jmpq   1a <rec_field_name_p+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_field_name_p (const char *str)
{
  return rec_match (str, "^" "[a-zA-Z%][a-zA-Z0-9_]*" "$");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x50(%rdi),%rdi
callq  bd <free_directory+0xd>
mov    0x58(%rbx),%rdi
callq  c6 <free_directory+0x16>
mov    %rbx,%rdi
pop    %rbx
jmpq   cf <free_directory+0x1f>
nop
<<<sep_in_sample>>>
free_directory (struct directory *dir)
{
  free (dir->caname);
  free (dir->name);
  free (dir);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %edi,%ebx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  15 <main+0x15>
mov    %ebx,%edi
mov    %rbp,%rsi
callq  1f <main+0x1f>
mov    0x0(%rip),%rdi        # 26 <main+0x26>
callq  2b <main+0x2b>
test   %rax,%rax
mov    %rax,%rbx
je     88 <main+0x88>
mov    %rbx,%rdi
callq  3b <main+0x3b>
mov    0x0(%rip),%rdi        # 42 <main+0x42>
callq  47 <main+0x47>
test   %al,%al
je     63 <main+0x63>
mov    0x0(%rip),%rsi        # 52 <main+0x52>
mov    %rbx,%rdi
callq  5a <main+0x5a>
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    0x0(%rip),%rbx        # 6a <main+0x6a>
mov    $0x0,%edi
callq  74 <main+0x74>
mov    %rax,%rdi
xor    %eax,%eax
mov    %rbx,%rsi
callq  81 <main+0x81>
mov    $0x1,%eax
jmp    5c <main+0x5c>
callq  8d <main+0x8d>
mov    %rax,%rbx
jmp    33 <main+0x33>
<<<sep_in_sample>>>
main (int argc, char *argv[])
{
  rec_db_t db;
  recutl_init ("recins");
  recins_parse_args (argc, argv);
  db = recutl_read_db_from_file (recins_file);
  if (!db)
    {
      db = rec_db_new ();
    }
  recins_add_new_record (db);
  if (!recutl_file_is_writable (recins_file))
    {
      recutl_error (gettext ("file %s is not writable.\n"), recins_file);
      return 1;
    }
  recutl_write_db_to_file (db, recins_file);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 5
9 5
10 5
11 6
12 6
13 7
14 6
15 7
16 11
17 11
18 12
19 12
20 12
21 12
22 17
23 17
24 17
25 18
26 19
27 19
28 19
29 19
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 15
38 15
39 9
40 9
41 9
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
mov    %rdx,%rbp
push   %rbx
movq   $0x0,(%rdx)
je     48 <osip_message_get_via+0x48>
lea    0x160(%rdi),%r12
mov    %esi,%ebx
mov    %r12,%rdi
callq  24 <osip_message_get_via+0x24>
cmp    %ebx,%eax
mov    $0xffffffff,%edx
jle    3d <osip_message_get_via+0x3d>
mov    %ebx,%esi
mov    %r12,%rdi
callq  37 <osip_message_get_via+0x37>
mov    %ebx,%edx
mov    %rax,0x0(%rbp)
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
mov    $0xfffffffe,%edx
jmp    3d <osip_message_get_via+0x3d>
nop
<<<sep_in_sample>>>
osip_message_get_via (const osip_message_t * sip, int pos, osip_via_t ** dest)
{
  *dest = ((void *)0);
  if (sip == ((void *)0))
    return -2;
  if (osip_list_size (&sip->vias) <= pos)
    return -1;
  *dest = (osip_via_t *) osip_list_get (&sip->vias, pos);
  return pos;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 3
7 4
8 6
9 6
10 6
11 6
12 6
13 7
14 6
15 8
16 8
17 8
18 9
19 8
20 10
21 10
22 10
23 10
24 10
25 10
26 5
27 5
28 5
<<<sep_out_sample>>>
push   %r12
mov    0x0(%rip),%rax        # 359 <ppdrestart+0x9>
push   %rbp
test   %rax,%rax
push   %rbx
mov    %rdi,%rbx
je     390 <ppdrestart+0x40>
mov    0x0(%rip),%rdx        # 36a <ppdrestart+0x1a>
mov    (%rax,%rdx,8),%rax
test   %rax,%rax
je     390 <ppdrestart+0x40>
mov    %rax,%rdi
mov    %rbx,%rsi
callq  260 <ppd_init_buffer>
pop    %rbx
pop    %rbp
pop    %r12
jmpq   0 <ppd_load_buffer_state>
nopw   0x0(%rax,%rax,1)
callq  80 <ppdensure_buffer_stack>
mov    0x0(%rip),%rbp        # 39c <ppdrestart+0x4c>
mov    0x0(%rip),%rax        # 3a3 <ppdrestart+0x53>
mov    $0x4000,%esi
mov    0x0(%rip),%rdi        # 3af <ppdrestart+0x5f>
lea    0x0(%rbp,%rax,8),%r12
callq  3b9 <ppdrestart+0x69>
xor    %edi,%edi
test   %rbp,%rbp
mov    %rax,(%r12)
jne    373 <ppdrestart+0x23>
jmp    376 <ppdrestart+0x26>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppdrestart (FILE * input_file )
{
 if ( ! ( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) ){
        ppdensure_buffer_stack ();
  (yy_buffer_stack)[(yy_buffer_stack_top)] =
            ppd_create_buffer(ppdin,16384 );
 }
 ppd_init_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)),input_file );
 ppd_load_buffer_state( );
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 8
13 8
14 8
15 10
16 10
17 10
18 9
19 9
20 4
21 5
22 5
23 6
24 6
25 5
26 6
27 8
28 8
29 5
30 8
31 8
32 8
<<<sep_out_sample>>>
mov    $0x1000,%eax
test   %edx,%edx
mov    %rdi,0x0(%rip)        # 4cae <urlSetCallback+0xe>
cmovns %edx,%eax
mov    %rsi,0x0(%rip)        # 4cb8 <urlSetCallback+0x18>
mov    %eax,0x0(%rip)        # 4cbe <urlSetCallback+0x1e>
retq   
nop
<<<sep_in_sample>>>
urlSetCallback(rpmCallbackFunction notify, void *notifyData, int notifyCount) {
    urlNotify = notify;
    urlNotifyData = notifyData;
    urlNotifyCount = (notifyCount >= 0) ? notifyCount : 4096;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 4
5 3
6 4
7 4
8 4
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
cdio_have_os2 (void)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 267 <CDB___os_free+0x7>
test   %rax,%rax
je     270 <CDB___os_free+0x10>
jmpq   *%rax
xchg   %ax,%ax
jmpq   275 <CDB___os_free+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___os_free(ptr, size)
 void *ptr;
 size_t size;
{ if(size){}
 (size) = (0);
 if (CDB___db_jump.j_free != ((void *)0))
  CDB___db_jump.j_free(ptr);
 else
  free(ptr);
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 7
5 7
6 9
7 9
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
sub    $0x38,%rsp
test   %rdx,%rdx
je     40 <__gmpf_sub_ui+0x40>
mov    %rdx,0x8(%rsp)
lea    0x8(%rsp),%rax
lea    0x10(%rsp),%rdx
movl   $0x1,0x14(%rsp)
movq   $0x1,0x18(%rsp)
mov    %rax,0x20(%rsp)
callq  33 <__gmpf_sub_ui+0x33>
add    $0x38,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  45 <__gmpf_sub_ui+0x45>
add    $0x38,%rsp
retq   
<<<sep_in_sample>>>
__gmpf_sub_ui (mpf_ptr sum, mpf_srcptr u, unsigned long int v)
{
  __mpf_struct vv;
  mp_limb_t vl;
  if (v == 0)
    {
      __gmpf_set (sum, u);
      return;
    }
  vl = v;
  vv._mp_size = 1;
  vv._mp_d = &vl;
  vv._mp_exp = 1;
  __gmpf_sub (sum, u, &vv);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 10
5 12
6 14
7 11
8 13
9 12
10 14
11 15
12 15
13 15
14 7
15 15
16 15
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
test   $0x1,%al
jne    6f8 <wsnode_len+0x28>
test   $0x2,%al
jne    6e8 <wsnode_len+0x18>
mov    0x20(%rdi),%rax
sub    0x18(%rdi),%rax
retq   
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
jmpq   6f1 <wsnode_len+0x21>
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_len (struct wordsplit_node *p)
{
  if (p->flags & 0x01)
    return 0;
  else if (p->flags & 0x02)
    return strlen (p->v.word);
  else
    return p->v.segm.end - p->v.segm.beg;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 8
7 8
8 8
9 8
10 6
11 6
12 6
13 4
14 9
15 9
<<<sep_out_sample>>>
mov    (%rdi),%eax
test   %eax,%eax
js     1d9c <apply_conf_override+0xc>
mov    %eax,0x0(%rip)        # 1d9c <apply_conf_override+0xc>
repz retq 
<<<sep_in_sample>>>
apply_conf_override(struct dicod_conf_override *ovr)
{
    if (ovr->transcript >= 0)
 transcript = ovr->transcript;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    %rdx,%rcx
mov    $0xffffffffffffffff,%rax
xor    %edx,%edx
div    %rcx
cmp    %rsi,%rax
jb     8d <xnrealloc+0x1d>
imul   %rcx,%rsi
jmpq   8d <xnrealloc+0x1d>
push   %rax
callq  93 <xnrealloc+0x23>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xnrealloc (void *p, size_t n, size_t s)
{
  if (((size_t) (sizeof (ptrdiff_t) <= sizeof (size_t) ? -1 : -2) / (s) < (n)))
    xalloc_die ();
  return xrealloc (p, n * s);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 5
8 5
9 2
10 4
11 4
<<<sep_out_sample>>>
push   %r14
mov    %rdx,%r14
push   %r13
lea    -0x1(%rsi),%r13
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
xor    %ebx,%ebx
test   %rsi,%rsi
jle    b8 <WriteArrayExp+0x58>
nopl   0x0(%rax)
movsd  (%r14,%rbx,8),%xmm0
callq  8b <WriteArrayExp+0x2b>
mov    $0x0,%esi
mov    %rbp,%rdi
mov    $0x1,%eax
callq  9d <WriteArrayExp+0x3d>
cmp    %rbx,%r13
jle    af <WriteArrayExp+0x4f>
mov    %rbp,%rsi
mov    $0x9,%edi
callq  af <WriteArrayExp+0x4f>
add    $0x1,%rbx
cmp    %r12,%rbx
jne    80 <WriteArrayExp+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
WriteArrayExp (FILE *pfile, long cElems, double *rg)
{
  register long i;
  register long cElems_minus_1 = cElems - 1;
  for (i = 0; i < cElems; i++) {
    fprintf(pfile, "%g", exp(rg[i]));
    if (i < cElems_minus_1) fputc ('\t', pfile);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 2
7 2
8 2
9 2
10 5
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 6
20 7
21 7
22 7
23 7
24 7
25 5
26 5
27 5
28 9
29 9
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
push   %r12
test   %rdi,%rdi
push   %rbp
mov    %rdi,%rbp
push   %rbx
je     2dac <addlists+0x4c>
test   %rsi,%rsi
je     2dac <addlists+0x4c>
mov    (%rsi),%rbx
test   %rbx,%rbx
je     2db8 <addlists+0x58>
lea    0x8(%rsi),%r12
jmp    2d8e <addlists+0x2e>
nop
add    $0x8,%r12
mov    -0x8(%r12),%rbx
test   %rbx,%rbx
je     2db8 <addlists+0x58>
mov    %rbx,%rdi
callq  2d96 <addlists+0x36>
mov    %rbp,%rdi
mov    %rax,%rdx
mov    %rbx,%rsi
callq  2c10 <enlist>
test   %rax,%rax
mov    %rax,%rbp
jne    2d80 <addlists+0x20>
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
mov    %rbp,%rax
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
addlists (char **old, char **new)
{
  int i;
  if (old == ((void *)0) || new == ((void *)0))
    return ((void *)0);
  for (i = 0; new[i] != ((void *)0); ++i)
    {
      old = enlist(old, new[i], strlen(new[i]));
      if (old == ((void *)0))
        break;
    }
  return old;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 4
7 4
8 4
9 6
10 6
11 6
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 8
20 8
21 8
22 8
23 8
24 8
25 9
26 8
27 9
28 13
29 13
30 5
31 13
32 13
33 13
34 13
35 8
36 13
37 13
38 13
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_uchar_size (const gsl_block_uchar * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
movsd  0xa0(%rdi),%xmm0
movsd  %xmm0,(%rsi)
movsd  0xa8(%rdi),%xmm0
movsd  %xmm0,(%rdx)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_monte_vegas_runval (const gsl_monte_vegas_state * s, double * result, double * sigma)
{
  *result = s->result;
  *sigma = s->sigma;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rdi
callq  a03 <mu_cfg_create_node_list+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    a21 <mu_cfg_create_node_list+0x31>
mov    0x8(%rsp),%rdi
mov    $0x0,%esi
callq  a18 <mu_cfg_create_node_list+0x28>
mov    0x8(%rsp),%rax
mov    %rax,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_cfg_create_node_list (mu_list_t *plist)
{
  int rc;
  mu_list_t list;
  rc = mu_list_create (&list);
  if (rc)
    return rc;
  mu_list_set_destroy_item (list, free_node_item);
  *plist = list;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 6
8 5
9 6
10 8
11 8
12 8
13 9
14 9
15 11
16 11
17 11
18 11
19 11
20 11
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  ac26 <macro_meta_sequences_list_short+0x16>
mov    %rbx,%rdi
mov    %rax,%rsi
xor    %eax,%eax
callq  ac33 <macro_meta_sequences_list_short+0x23>
mov    %rbx,%rsi
mov    $0xa,%edi
callq  ac40 <macro_meta_sequences_list_short+0x30>
mov    0x5f0(%rbp),%rdi
add    $0x8,%rsp
mov    %rbx,%rsi
pop    %rbx
pop    %rbp
jmpq   ac55 <macro_meta_sequences_list_short+0x45>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
macro_meta_sequences_list_short (struct a2ps_job * job, FILE * stream)
{
  fprintf (stream, gettext ("Known Variables"));
  _IO_putc ('\n', stream);
  pair_table_list_short (job->macro_meta_sequences, stream);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 4
13 4
14 4
15 5
16 6
17 5
18 6
19 6
20 5
21 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rdx        # 2c7 <min_id+0x7>
mov    (%rdx),%rax
add    $0x8,%rdx
mov    %rdx,0x0(%rip)        # 2d5 <min_id+0x15>
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
min_id(void)
{
  char *x;
  memmove (&x,mpointer,sizeof(char *));
  mpointer += sizeof(char *);
  return(x);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 7
6 7
<<<sep_out_sample>>>
mov    (%rdi),%rdx
mov    0x10(%rdi),%rax
mov    0x8(%rdi),%rdi
mov    %rdx,%rsi
shr    %rsi
lea    (%rdi,%rdi,1),%rcx
je     3a3 <gsl_vector_complex_reverse+0x73>
lea    -0x8(,%rdx,8),%rdx
mov    %rcx,%r8
shl    $0x4,%rdi
neg    %r8
imul   %rcx,%rdx
shl    $0x3,%r8
xor    %ecx,%ecx
add    %rax,%rdx
nopw   %cs:0x0(%rax,%rax,1)
movsd  (%rdx),%xmm0
add    $0x1,%rcx
movsd  (%rax),%xmm1
movsd  %xmm1,(%rdx)
movsd  %xmm0,(%rax)
movsd  0x8(%rax),%xmm1
movsd  0x8(%rdx),%xmm0
movsd  %xmm1,0x8(%rdx)
add    %r8,%rdx
movsd  %xmm0,0x8(%rax)
add    %rdi,%rax
cmp    %rsi,%rcx
jne    370 <gsl_vector_complex_reverse+0x40>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_complex_reverse (gsl_vector_complex * v)
{
  double * data = v->data ;
  const size_t size = v->size ;
  const size_t stride = v->stride ;
  const size_t s = 2 * stride ;
  size_t i ;
  for (i = 0 ; i < (size / 2) ; i++)
    {
      size_t j = size - i - 1 ;
      size_t k;
      for (k = 0; k < 2; k++)
        {
          double tmp = data[j*s + k];
          data[j*s+k] = data[i*s + k];
          data[i*s+k] = tmp;
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 4
2 3
3 6
4 8
5 8
6 6
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 14
18 8
19 15
20 15
21 16
22 15
23 14
24 15
25 15
26 16
27 16
28 8
29 8
30 20
31 20
32 20
<<<sep_out_sample>>>
sub    $0x18,%rsp
test   %rdi,%rdi
mov    $0x0,%eax
mov    %rdi,0x8(%rsp)
je     35e <dev_gnu_name+0x3e>
mov    0x0(%rip),%rdi        # 33a <dev_gnu_name+0x1a>
test   %rdi,%rdi
je     390 <dev_gnu_name+0x70>
lea    0x8(%rsp),%rsi
mov    $0x8,%edx
callq  34e <dev_gnu_name+0x2e>
test   %rax,%rax
je     368 <dev_gnu_name+0x48>
mov    %rax,%rdi
callq  35b <dev_gnu_name+0x3b>
mov    (%rax),%rax
add    $0x18,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdx
mov    $0x0,%esi
mov    $0x0,%edi
xor    %eax,%eax
movzbl %dl,%ecx
movzbl %dh,%edx
callq  384 <dev_gnu_name+0x64>
mov    $0x0,%eax
add    $0x18,%rsp
retq   
xchg   %ax,%ax
mov    $0x8,%dil
callq  398 <dev_gnu_name+0x78>
mov    $0x0,%edi
mov    %rax,0x0(%rip)        # 3a4 <dev_gnu_name+0x84>
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    $0x0,%edi
callq  0 <setup_devices>
mov    0x0(%rip),%rdi        # 3ce <dev_gnu_name+0xae>
jmpq   33f <dev_gnu_name+0x1f>
<<<sep_in_sample>>>
dev_gnu_name(long dev_num)
{
  struct hashtab_elem *he;
  static char devstr [20];
  if (dev_num == 0)
    return "__";
  if (dev_table == ((void *)0))
    {
      dev_table = hashtab_init (sizeof (long));
      setup_devices ("/dev");
      setup_devices ("/dev/pty");
      setup_devices ("/dev/ptym");
      setup_devices ("/dev/pts");
    }
  he = hashtab_find (dev_table, (void *) &dev_num, (unsigned int)sizeof (dev_num));
  if (he != ((void *)0))
    {
      struct dev_data *dd = hashtab_get_value (he);
      return dd->name;
    }
  sprintf (devstr, "[%d,%d]",
           (int) ((dev_num & 0xFF00) >> 8), (int) (dev_num & 0x00FF));
  return devstr;
}
<<<sep_in_sample>>>
1 2
2 5
3 6
4 2
5 5
6 7
7 7
8 7
9 15
10 15
11 15
12 16
13 16
14 18
15 18
16 19
17 24
18 24
19 24
20 21
21 21
22 21
23 21
24 21
25 22
26 21
27 23
28 24
29 24
30 24
31 9
32 9
33 10
34 9
35 10
36 11
37 11
38 12
39 12
40 13
41 13
42 13
43 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
add    $0xb8,%rdi
callq  fd0 <sdp_message_m_number_of_port_get+0x10>
test   %rax,%rax
je     fe0 <sdp_message_m_number_of_port_get+0x20>
mov    0x10(%rax),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
xor    %eax,%eax
jmp    fd9 <sdp_message_m_number_of_port_get+0x19>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sdp_message_m_number_of_port_get (sdp_message_t * sdp, int pos_media)
{
  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);
  if (med == ((void *)0))
    return ((void *)0);
  return med->m_number_of_port;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 6
7 7
8 7
9 7
10 5
11 5
12 5
<<<sep_out_sample>>>
jmp    831 <window_mark_chain+0x11>
nopw   0x0(%rax,%rax,1)
or     %esi,0x98(%rdi)
mov    (%rdi),%rdi
test   %rdi,%rdi
jne    828 <window_mark_chain+0x8>
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
window_mark_chain (WINDOW *chain, int flag)
{
  register WINDOW *win;
  for (win = chain; win; win = win->next)
    win->flags |= flag;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 4
5 4
6 4
7 4
8 4
<<<sep_out_sample>>>
mov    %rsi,0x8(%rdi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_generic_param_set_value (osip_generic_param_t * fparam, char *value)
{
  fparam->gvalue = value;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   $0xf,%sil
jne    c3 <nettle_aes192_decrypt+0x23>
mov    %rdx,%r8
lea    0x0(%rip),%rdx        # b0 <nettle_aes192_decrypt+0x10>
mov    %rcx,%r9
mov    %rsi,%rcx
mov    %rdi,%rsi
mov    $0xc,%edi
jmpq   c3 <nettle_aes192_decrypt+0x23>
lea    0x0(%rip),%rcx        # ca <nettle_aes192_decrypt+0x2a>
push   %rax
lea    0x0(%rip),%rsi        # d2 <nettle_aes192_decrypt+0x32>
lea    0x0(%rip),%rdi        # d9 <nettle_aes192_decrypt+0x39>
mov    $0x174,%edx
callq  e3 <nettle_aes192_decrypt+0x43>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_aes192_decrypt(const struct aes192_ctx *ctx,
        size_t length, uint8_t *dst,
        const uint8_t *src)
{
  ((!(length % 16)) ? (void) (0) : __assert_fail ("!(length % 16)", "aes-decrypt.c", 372, __PRETTY_FUNCTION__));
  _nettle_aes_decrypt(12, ctx->keys, &_aes_decrypt_table,
        length, dst, src);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 6
5 6
6 6
7 6
8 6
9 6
10 5
11 4
12 5
13 5
14 5
15 5
16 5
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %esi,%ebp
mov    %rbp,%rsi
push   %rbx
mov    0x10(%rdi),%rdi
mov    %rdx,%rbx
callq  18 <des_compat_des3_decrypt+0x18>
mov    0x8(%r12),%rdi
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
callq  2b <des_compat_des3_decrypt+0x2b>
mov    %rbx,%rcx
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    (%r12),%rdi
pop    %r12
jmpq   41 <des_compat_des3_decrypt+0x41>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
des_compat_des3_decrypt(struct des_compat_des3 *ctx,
   uint32_t length, uint8_t *dst, const uint8_t *src)
{
  nettle_des_decrypt(ctx->keys[2], length, dst, src);
  nettle_des_encrypt(ctx->keys[1], length, dst, dst);
  nettle_des_decrypt(ctx->keys[0], length, dst, dst);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 3
7 4
8 3
9 4
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 7
19 7
20 6
21 7
22 6
23 6
<<<sep_out_sample>>>
mov    $0xffffffff,%ecx
jmpq   3aea <gsl_fft_complex_radix2_dif_forward+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_fft_complex_radix2_dif_forward (gsl_complex_packed_array data,
                                              const size_t stride,
                                              const size_t n)
{
  gsl_fft_direction sign = gsl_fft_forward;
  int status = gsl_fft_complex_radix2_dif_transform (data, stride, n, sign);
  return status;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     d0 <filename_pattern_match+0x90>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    (%rdi),%rbx
test   %rbx,%rbx
jne    93 <filename_pattern_match+0x53>
jmp    b8 <filename_pattern_match+0x78>
nopw   0x0(%rax,%rax,1)
cmp    $0x1,%edx
jne    78 <filename_pattern_match+0x38>
lea    0x8(%rbp),%rdi
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
mov    %r12,%rsi
callq  78 <filename_pattern_match+0x38>
mov    0x4(%rbp),%edx
test   %edx,%edx
je     87 <filename_pattern_match+0x47>
test   %eax,%eax
sete   %al
movzbl %al,%eax
test   %eax,%eax
je     c8 <filename_pattern_match+0x88>
mov    (%rbx),%rbx
test   %rbx,%rbx
je     b8 <filename_pattern_match+0x78>
mov    0x10(%rbx),%rbp
mov    0x0(%rbp),%edx
test   %edx,%edx
jne    60 <filename_pattern_match+0x20>
mov    0x8(%rbp),%rdi
mov    $0x1,%edx
mov    %r12,%rsi
callq  af <filename_pattern_match+0x6f>
jmp    78 <filename_pattern_match+0x38>
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0x1,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nop
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
filename_pattern_match(struct grecs_list *lp, const char *name)
{
 struct grecs_list_entry *ep;
 if (!lp)
  return 0;
 for (ep = lp->head; ep; ep = ep->next) {
  struct filename_pattern *pat = ep->data;
  int rc;
  switch (pat->type) {
  case 0:
   rc = fnmatch(pat->v.glob, name, (1 << 0));
   break;
  case 1:
   rc = regexec(&pat->v.re, name, 0, ((void *)0), 0);
   break;
  }
  if (pat->neg)
   rc = !rc;
  if (rc == 0)
   return 0;
 }
 return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 6
11 6
12 9
13 9
14 14
15 14
16 14
17 14
18 14
19 14
20 17
21 17
22 17
23 18
24 18
25 18
26 19
27 19
28 6
29 6
30 6
31 7
32 9
33 9
34 9
35 11
36 11
37 11
38 11
39 12
40 12
41 23
42 23
43 22
44 23
45 23
46 23
47 23
48 23
49 5
50 23
51 23
52 23
53 5
54 23
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  af9 <xdr_dis_capabilities+0x9>
test   %eax,%eax
setne  %al
add    $0x8,%rsp
movzbl %al,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_dis_capabilities(xdrs, objp)
	XDR *xdrs;
	dis_capabilities *objp;
{
	if (!xdr_byte_u_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 9
6 5
7 9
8 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x40(%rdi),%rbx
test   %rbx,%rbx
je     204 <folder_imap_destroy+0x44>
mov    0x80(%rbx),%rdi
test   %rdi,%rdi
je     1e3 <folder_imap_destroy+0x23>
callq  1e3 <folder_imap_destroy+0x23>
mov    0x20(%rbx),%rsi
test   %rsi,%rsi
je     1f4 <folder_imap_destroy+0x34>
mov    0x28(%rbx),%edi
callq  1f4 <folder_imap_destroy+0x34>
mov    %rbx,%rdi
callq  1fc <folder_imap_destroy+0x3c>
movq   $0x0,0x40(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
folder_imap_destroy (mu_folder_t folder)
{
  if (folder->data)
    {
      f_imap_t f_imap = folder->data;
      if (f_imap->buffer)
 free (f_imap->buffer);
      if (f_imap->capav)
 mu_argcv_free (f_imap->capac, f_imap->capav);
      free (f_imap);
      folder->data = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 6
9 6
10 6
11 7
12 8
13 8
14 8
15 9
16 9
17 10
18 10
19 11
20 13
21 13
22 13
23 13
24 13
<<<sep_out_sample>>>
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
os_devopen(const char *name, int flag)
{
 return (-1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%ecx
mov    $0xffffffffffffffff,%rdx
jmpq   bf0 <quotearg_n_options>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_n (int n, char const *arg)
{
  return quotearg_n_options (n, arg, ((size_t) -1), &default_quoting_options);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
jmpq   565 <_rl_keyseq_cxt_dispose+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_keyseq_cxt_dispose (cxt)
    _rl_keyseq_cxt *cxt;
{
  xfree (cxt);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
cmp    $0xd,%edi
mov    %edi,%eax
ja     221 <signal_throw+0x41>
mov    %edi,%edx
jmpq   *0x0(,%rdx,8)
mov    $0xffffffc9,%edi
nopl   0x0(%rax)
callq  205 <signal_throw+0x25>
mov    $0xfffffff7,%edi
jmp    200 <signal_throw+0x20>
mov    $0xfffff7ff,%edi
jmp    200 <signal_throw+0x20>
mov    $0xffffffe4,%edi
jmp    200 <signal_throw+0x20>
mov    $0xffffffe9,%edi
jmp    200 <signal_throw+0x20>
mov    $0xffffff00,%edi
sub    %eax,%edi
jmp    200 <signal_throw+0x20>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
signal_throw(int sig)
{
  int code;
  switch (sig) {
  case 2: code=-28; break;
  case 8: code=-55; break;
  case 7: code=-23; break;
  case 11: code=-9; break;
  case 13: code=-2049; break;
  default: code=-256-sig; break;
  }
  throw(code);
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 6
8 6
9 12
10 8
11 8
12 9
13 9
14 5
15 5
16 7
17 7
18 10
19 10
20 10
21 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 407 <sys_detect_dev_null_output+0x7>
mov    $0xa,%ecx
mov    $0x0,%edi
mov    (%rax),%rsi
mov    $0x1,%eax
repz cmpsb %es:(%rdi),%ds:(%rsi)
seta   %cl
setb   %dl
cmp    %dl,%cl
je     445 <sys_detect_dev_null_output+0x45>
cmpl   $0x3fffffff,0x0(%rip)        # 42f <sys_detect_dev_null_output+0x2f>
jg     443 <sys_detect_dev_null_output+0x43>
mov    0x0(%rip),%eax        # 437 <sys_detect_dev_null_output+0x37>
and    $0xf000,%eax
cmp    $0x2000,%eax
je     450 <sys_detect_dev_null_output+0x50>
xor    %eax,%eax
mov    %al,0x0(%rip)        # 44b <sys_detect_dev_null_output+0x4b>
retq   
nopl   0x0(%rax)
sub    $0x98,%rsp
mov    $0x0,%edi
mov    %rsp,%rsi
callq  464 <sys_detect_dev_null_output+0x64>
test   %eax,%eax
jne    490 <sys_detect_dev_null_output+0x90>
mov    (%rsp),%rax
cmp    %rax,0x0(%rip)        # 473 <sys_detect_dev_null_output+0x73>
jne    490 <sys_detect_dev_null_output+0x90>
mov    0x8(%rsp),%rax
cmp    %rax,0x0(%rip)        # 481 <sys_detect_dev_null_output+0x81>
sete   %al
jmp    492 <sys_detect_dev_null_output+0x92>
nopw   %cs:0x0(%rax,%rax,1)
xor    %eax,%eax
mov    %al,0x0(%rip)        # 498 <sys_detect_dev_null_output+0x98>
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
sys_detect_dev_null_output (void)
{
  static char const dev_null[] = "/dev/null";
  struct stat dev_null_stat;
  dev_null_output = (strcmp (archive_name_array[0], dev_null) == 0
       || (! ((archive) >= (1 << 30))
    && ((((archive_stat.st_mode)) & 0170000) == (0020000))
    && stat (dev_null, &dev_null_stat) == 0
    && archive_stat.st_dev == dev_null_stat.st_dev
    && archive_stat.st_ino == dev_null_stat.st_ino));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 5
9 6
10 6
11 6
12 6
13 7
14 7
15 7
16 7
17 7
18 5
19 5
20 5
21 2
22 8
23 8
24 8
25 8
26 8
27 9
28 9
29 9
30 10
31 10
32 10
33 10
34 10
35 10
36 5
37 11
38 11
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1d0 <_gsasl_saml20_server_finish+0x10>
mov    %rsi,%rdi
jmpq   1cd <_gsasl_saml20_server_finish+0xd>
nopl   (%rax)
repz retq 
<<<sep_in_sample>>>
_gsasl_saml20_server_finish (Gsasl_session * sctx, void *mech_data)
{
  struct saml20_server_state *state = mech_data;
  if (!state)
    return;
  free (state);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 6
5 6
6 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  b9 <cplob_shallow_close+0x9>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
cplob_shallow_close(CPLOB * lob)
{
 free(lob);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 5
4 5
5 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # 480 <ask+0x10>
mov    %rbp,%rdx
mov    $0x0,%esi
xor    %eax,%eax
callq  48f <ask+0x1f>
callq  494 <ask+0x24>
mov    %eax,%ebx
nopw   %cs:0x0(%rax,%rax,1)
callq  4a5 <ask+0x35>
cmp    $0xa,%eax
jne    4a0 <ask+0x30>
mov    %ebx,%eax
and    $0xfffffff7,%eax
cmp    $0x71,%eax
jne    4c8 <ask+0x58>
xor    %eax,%eax
cmp    $0x79,%ebx
sete   %al
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    0x0(%rip),%rcx        # 4cf <ask+0x5f>
mov    $0x12,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  4e3 <ask+0x73>
jmp    479 <ask+0x9>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ask(char *question)
{
  int c;
  do {
    fprintf(stderr, "%s? [y/q] ", question);
    c = getchar();
    while (getchar() != '\n')
      ;
    if (c != 'y' && c != 'q')
      fprintf(stderr, "Invalid response. ");
  } while (c != 'y' && c != 'q');
  return (c == 'y');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 6
11 6
12 6
13 7
14 7
15 7
16 9
17 9
18 9
19 9
20 12
21 12
22 12
23 13
24 13
25 13
26 13
27 13
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    0x38(%rdi),%rax
mov    0x20(%rax),%rax
mov    %rsi,0x98(%rax)
retq   
<<<sep_in_sample>>>
regwhen (block_t *rb, decl_t *rd)
{
  rb->quant.prefqual->descr->when= rd;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    (%rdi),%rax
test   %rax,%rax
je     10 <__rtconstant+0x10>
movzbl 0x10(%rax),%eax
retq   
nopl   (%rax)
mov    $0x1,%eax
retq   
<<<sep_in_sample>>>
__rtconstant (__txtvp t)
{
  if (t->obj == 0L)
    return (1);
  else
    return (t->obj->h.konstant);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 6
5 6
6 6
7 4
8 7
<<<sep_out_sample>>>
push   %r13
mov    %rdx,%r13
push   %r12
mov    %rsi,%r12
mov    $0x3a,%esi
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  82d <parse_mtaport+0x1d>
test   %rax,%rax
je     878 <parse_mtaport+0x68>
lea    0x1(%rax),%rbp
mov    $0x0,%esi
mov    %rbp,%rdi
callq  843 <parse_mtaport+0x33>
test   %rax,%rax
je     890 <parse_mtaport+0x80>
movzwl 0x10(%rax),%edi
callq  851 <parse_mtaport+0x41>
movzwl %ax,%eax
mov    %eax,0x0(%r13)
add    $0x8,%rsp
sub    %rbx,%rbp
mov    %rbx,%rsi
pop    %rbx
lea    -0x1(%rbp),%rdx
mov    %r12,%rdi
pop    %rbp
pop    %r12
pop    %r13
jmpq   874 <parse_mtaport+0x64>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %r12,%rdi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   88d <parse_mtaport+0x7d>
nopl   (%rax)
mov    %rbp,%rsi
mov    %r13,%rdi
callq  80 <get_port_number>
jmp    858 <parse_mtaport+0x48>
nopl   (%rax)
<<<sep_in_sample>>>
parse_mtaport (char *opt, char **host, unsigned int *port)
{
  struct servent *p;
  char *port_tmp = ((void *)0);
  if ((port_tmp = strrchr (opt, ':')))
    {
      port_tmp++;
      if ((p = getservbyname (port_tmp, "tcp")))
 *port = ntohs (p->s_port);
      else
        get_port_number (port, port_tmp);
      assign_string_n (host, opt, port_tmp - opt - 1);
    }
  else
    assign_string (host, opt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 2
7 2
8 2
9 2
10 5
11 5
12 5
13 7
14 8
15 8
16 8
17 8
18 8
19 9
20 9
21 9
22 9
23 16
24 12
25 12
26 16
27 12
28 12
29 16
30 16
31 16
32 12
33 12
34 16
35 15
36 15
37 16
38 16
39 16
40 16
41 15
42 15
43 11
44 11
45 11
46 11
47 11
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    $0x1,%r12d
sub    %edi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x5c(%rdi),%eax
mov    0x18(%rdi),%r13
test   %eax,%eax
jle    2ac <read_non_rle_pixel+0x3c>
mov    %r13,%rdi
callq  29c <read_non_rle_pixel+0x2c>
mov    %al,0x58(%rbx)
lea    (%r12,%rbx,1),%eax
add    $0x1,%rbx
cmp    %eax,0x5c(%rbp)
jg     294 <read_non_rle_pixel+0x24>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
read_non_rle_pixel (tga_source_ptr sinfo)
{
  register FILE *infile = sinfo->pub.input_file;
  register int i;
  for (i = 0; i < sinfo->pixel_size; i++) {
    sinfo->tga_pixel[i] = (U_CHAR) _IO_getc (infile);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 5
9 2
10 5
11 3
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 5
20 5
21 8
22 8
23 8
24 8
25 8
26 8
27 8
<<<sep_out_sample>>>
mov    0x4(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
finished_process (void *item, void *data)
{
  struct process_status *ps = item;
  return ps->running;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
xor    %esi,%esi
callq  1450 <find_variable_internal>
test   %rax,%rax
je     1616 <find_variable_notempenv+0x16>
testb  $0x8,0x29(%rax)
jne    1620 <find_variable_notempenv+0x20>
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rax,%rdi
add    $0x8,%rsp
jmpq   162c <find_variable_notempenv+0x2c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
find_variable_notempenv (name)
     const char *name;
{
  SHELL_VAR *var;
  var = find_variable_internal (name, 0);
  if (var && ((((var)->attributes) & (0x0000800))))
    var = find_variable_nameref (var);
  return (var);
}
<<<sep_in_sample>>>
1 3
2 5
3 5
4 6
5 6
6 6
7 6
8 9
9 9
10 9
11 7
12 9
13 7
14 7
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x28,%rsp
movzbl (%rdi),%eax
mov    0x0(%rip),%ebp        # 6f52 <scan_troff_mandoc+0x12>
movl   $0x1,0x0(%rip)        # 6f5c <scan_troff_mandoc+0x1c>
cmp    $0xa,%al
jne    6f73 <scan_troff_mandoc+0x33>
jmp    6f77 <scan_troff_mandoc+0x37>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rbx
movzbl (%rbx),%eax
cmp    $0xa,%al
je     6f77 <scan_troff_mandoc+0x37>
test   %al,%al
jne    6f68 <scan_troff_mandoc+0x28>
lea    0x2(%rdi),%rax
cmp    %rax,%rbx
jbe    6faf <scan_troff_mandoc+0x6f>
mov    %rdx,0x18(%rsp)
mov    %esi,0x14(%rsp)
mov    %rdi,0x8(%rsp)
callq  6f93 <scan_troff_mandoc+0x53>
movsbq -0x1(%rbx),%rcx
mov    (%rax),%rax
mov    0x8(%rsp),%rdi
mov    0x14(%rsp),%esi
mov    0x18(%rsp),%rdx
testb  $0x4,(%rax,%rcx,2)
jne    6fc8 <scan_troff_mandoc+0x88>
callq  5bd0 <scan_troff>
mov    %ebp,0x0(%rip)        # 6fba <scan_troff_mandoc+0x7a>
add    $0x28,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
movzbl -0x2(%rbx),%ecx
movsbq %cl,%r8
testb  $0x20,0x1(%rax,%r8,2)
je     6faf <scan_troff_mandoc+0x6f>
cmp    $0xa,%cl
je     6faf <scan_troff_mandoc+0x6f>
movb   $0xa,-0x2(%rbx)
callq  5bd0 <scan_troff>
movzbl -0x1(%rbx),%edx
movb   $0x20,-0x1(%rbx)
mov    %dl,-0x2(%rbx)
jmp    6fb4 <scan_troff_mandoc+0x74>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
scan_troff_mandoc(char *c, int san, char **result)
{
 char *ret, *end = c;
 int oldval = mandoc_line;
 mandoc_line = 1;
 while (*end && *end != '\n') {
  end++;
 }
 if (end > c + 2
     && ((*__ctype_b_loc ())[(int) ((*(end - 1)))] & (unsigned short int) _ISpunct)
     && ((*__ctype_b_loc ())[(int) ((*(end - 2)))] & (unsigned short int) _ISspace) && *(end - 2) != '\n') {
  *(end - 2) = '\n';
  ret = scan_troff(c, san, result);
  *(end - 2) = *(end - 1);
  *(end - 1) = ' ';
 } else {
  ret = scan_troff(c, san, result);
 }
 mandoc_line = oldval;
 return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 2
5 6
6 4
7 5
8 6
9 6
10 6
11 6
12 7
13 6
14 6
15 6
16 6
17 6
18 9
19 9
20 9
21 9
22 9
23 9
24 10
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 17
33 19
34 21
35 21
36 21
37 21
38 21
39 11
40 11
41 11
42 11
43 11
44 11
45 12
46 13
47 14
48 15
49 14
50 15
51 15
<<<sep_out_sample>>>
xor    %eax,%eax
cmpb   $0x72,(%rdi)
mov    $0x100,%edx
cmove  %edx,%eax
mov    %eax,%edx
or     $0x80,%dl
cmpb   $0x77,0x1(%rdi)
cmove  %edx,%eax
mov    %eax,%edx
or     $0x20,%edx
cmpb   $0x72,0x2(%rdi)
cmove  %edx,%eax
mov    %eax,%edx
or     $0x10,%edx
cmpb   $0x77,0x3(%rdi)
cmove  %edx,%eax
mov    %eax,%edx
or     $0x4,%edx
cmpb   $0x72,0x4(%rdi)
cmove  %edx,%eax
mov    %eax,%edx
or     $0x2,%edx
cmpb   $0x77,0x5(%rdi)
cmove  %edx,%eax
retq   
<<<sep_in_sample>>>
CDB___db_omode(perm)
 const char *perm;
{
 int mode;
 mode = 0;
 if (perm[0] == 'r')
  mode |= 0400;
 if (perm[1] == 'w')
  mode |= 0200;
 if (perm[2] == 'r')
  mode |= (0400 >> 3);
 if (perm[3] == 'w')
  mode |= (0200 >> 3);
 if (perm[4] == 'r')
  mode |= ((0400 >> 3) >> 3);
 if (perm[5] == 'w')
  mode |= ((0200 >> 3) >> 3);
 return (mode);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 9
6 9
7 9
8 9
9 11
10 11
11 11
12 11
13 13
14 13
15 13
16 13
17 15
18 15
19 15
20 15
21 17
22 17
23 17
24 17
25 19
<<<sep_out_sample>>>
cmpl   $0x4,0x0(%rip)        # 457 <fd_is_bash_input+0x7>
je     478 <fd_is_bash_input+0x28>
mov    0x0(%rip),%edx        # 45f <fd_is_bash_input+0xf>
xor    %eax,%eax
test   %edx,%edx
jne    488 <fd_is_bash_input+0x38>
xor    %eax,%eax
cmp    0x0(%rip),%edi        # 46d <fd_is_bash_input+0x1d>
sete   %al
retq   
nopl   0x0(%rax)
cmp    %edi,0x0(%rip)        # 47e <fd_is_bash_input+0x2e>
jne    459 <fd_is_bash_input+0x9>
mov    $0x1,%eax
nopl   (%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fd_is_bash_input (fd)
     int fd;
{
  if (bash_input.type == st_bstream && bash_input.location.buffered_fd == fd)
    return 1;
  else if (interactive_shell == 0 && default_buffered_input == fd)
    return 1;
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 8
5 6
6 6
7 6
8 6
9 6
10 6
11 6
12 4
13 4
14 5
15 5
16 9
17 9
<<<sep_out_sample>>>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
movzbl (%rsi,%rax,1),%edx
mov    %dl,0x1a(%rdi,%rax,1)
add    $0x1,%rax
cmp    $0x6,%rax
jne    f8 <mc_net_info_set_mac+0x8>
sub    $0x8,%rsp
lea    0x8(%rdi),%rdx
mov    (%rdi),%edi
xor    %eax,%eax
mov    $0x8924,%esi
callq  120 <mc_net_info_set_mac+0x30>
test   %eax,%eax
js     12b <mc_net_info_set_mac+0x3b>
xor    %eax,%eax
add    $0x8,%rsp
retq   
mov    $0x0,%edi
callq  135 <mc_net_info_set_mac+0x45>
mov    $0xffffffff,%eax
jmp    126 <mc_net_info_set_mac+0x36>
nopl   0x0(%rax)
<<<sep_in_sample>>>
mc_net_info_set_mac (net_info_t *net, const mac_t *mac)
{
 int i;
 for (i=0; i<6; i++) {
  net->dev.ifr_ifru.ifru_hwaddr.sa_data[i] = mac->byte[i];
 }
 if (ioctl(net->sock, 0x8924, &net->dev) < 0) {
  perror ("[ERROR] Could not change MAC: interface up or insufficient permissions");
  return -1;
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 4
7 4
8 2
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 11
17 12
18 12
19 8
20 8
21 9
22 9
23 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x10,%rsp
callq  431d <completereduce+0xd>
test   %eax,%eax
jne    4339 <completereduce+0x29>
mov    %rbx,%rdi
mov    %eax,0xc(%rsp)
callq  432d <completereduce+0x1d>
mov    %rbx,%rdi
callq  4335 <completereduce+0x25>
mov    0xc(%rsp),%eax
add    $0x10,%rsp
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
completereduce(struct unittype *unit)
{
   int err;
   if ((err=reduceunit(unit)))
     return err;
   sortunit(unit);
   cancelunit(unit);
   return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 4
7 6
8 6
9 6
10 7
11 7
12 7
13 9
14 9
15 9
16 9
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rsi,%rax
mov    0x20(%rdi),%rsi
xor    %edx,%edx
mov    %rax,%rdi
callq  3e5 <visit_globmatch_nofold+0x15>
cmp    $0x1,%eax
sbb    %eax,%eax
add    $0x8,%rsp
and    $0xfffffffe,%eax
add    $0x4,%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
visit_globmatch_nofold (struct process_data *procdata, void *context)
{
  const char *glob = context;
  if (fnmatch (glob, procdata->munged_filename, 0) != 0)
    return VISIT_REJECTED;
  else
    return VISIT_ACCEPTED;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 4
7 5
8 5
9 8
10 5
11 5
12 8
13 8
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 77 <close_debugfile+0x7>
jmpq   7c <close_debugfile+0xc>
nopl   0x0(%rax)
<<<sep_in_sample>>>
close_debugfile (void)
{
  fclose (debug_file);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
mov    %esi,(%rdi)
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_set_ifd(XFORMAT * xux, int fd)
{
 ;
 xux->ifdM = fd;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     1040 <internal_info_node_p+0x10>
mov    0x38(%rdi),%eax
shr    $0x4,%eax
and    $0x1,%eax
retq   
nop
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
internal_info_node_p (NODE *node)
{
  return (node != ((void *)0)) && (node->flags & 0x10);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 4
10 4
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x28(%rdi),%rdi
mov    %esi,%edx
xor    %eax,%eax
mov    $0x0,%esi
callq  556 <CDB___db_pgfmt+0x16>
mov    0x28(%rbx),%rdi
mov    $0x16,%esi
pop    %rbx
jmpq   565 <CDB___db_pgfmt+0x25>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
CDB___db_pgfmt(dbp, pgno)
 DB *dbp;
 db_pgno_t pgno;
{
 CDB___db_err(dbp->dbenv,
     "page %lu: illegal page type or format", (u_long)pgno);
 return (CDB___db_panic(dbp->dbenv, 22));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 8
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  d9 <grecs_strdup+0x9>
lea    0x1(%rax),%rdi
callq  e2 <grecs_strdup+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
pop    %rbx
jmpq   ee <grecs_strdup+0x1e>
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_strdup(const char *str)
{
 char *newstr = grecs_malloc(strlen(str) + 1);
 return strcpy(newstr, str);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 5
9 4
10 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%esi        # 12aa <pict_newstr+0xa>
mov    0x0(%rip),%r9        # 12b1 <pict_newstr+0x11>
movslq %esi,%rax
add    %r9,%rax
test   %rdi,%rdi
je     130f <pict_newstr+0x6f>
movzbl (%rdi),%ecx
test   %cl,%cl
je     130f <pict_newstr+0x6f>
cmp    0x0(%rip),%esi        # 12c9 <pict_newstr+0x29>
jge    131b <pict_newstr+0x7b>
add    $0x1,%esi
xor    %edx,%edx
jmp    12e8 <pict_newstr+0x48>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rdx
add    $0x1,%esi
cmp    %r8d,0x0(%rip)        # 12e6 <pict_newstr+0x46>
jle    1314 <pict_newstr+0x74>
mov    %cl,(%rax,%rdx,1)
movzbl 0x1(%rdi,%rdx,1),%ecx
mov    %esi,%r8d
test   %cl,%cl
jne    12d8 <pict_newstr+0x38>
movslq %esi,%rdx
add    %rdx,%r9
add    $0x1,%esi
movb   $0x0,(%r9)
mov    %esi,0x0(%rip)        # 130a <pict_newstr+0x6a>
add    $0x8,%rsp
retq   
mov    %rax,%r9
jmp    12fd <pict_newstr+0x5d>
mov    %r8d,0x0(%rip)        # 131b <pict_newstr+0x7b>
mov    0x0(%rip),%rcx        # 1322 <pict_newstr+0x82>
mov    $0x0,%edi
mov    $0x23,%edx
mov    $0x1,%esi
callq  1336 <pict_newstr+0x96>
mov    $0x1,%edi
callq  1340 <pict_init>
<<<sep_in_sample>>>
pict_newstr(char *str)
{
  int s;
  char *s0;
  s0 = charbuf + charnext;
  if (str)
    {
      for (s = 0; str[s]; s++)
 {
   if (charnext < dap_maxchar)
     charbuf[charnext++] = str[s];
   else
     {
       fputs("(pict_newstr) Too many characters.\n", dap_err);
       exit(1);
     }
 }
    }
  charbuf[charnext++] = '\0';
  return s0;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 6
7 6
8 8
9 8
10 8
11 10
12 10
13 10
14 10
15 10
16 10
17 10
18 10
19 10
20 10
21 11
22 8
23 11
24 8
25 8
26 8
27 8
28 19
29 19
30 19
31 21
32 21
33 21
34 21
35 21
36 14
37 14
38 14
39 14
40 14
41 15
42 15
<<<sep_out_sample>>>
test   %rdi,%rdi
je     7e0 <gsasl_server_callback_securid_get+0x10>
mov    0x88(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_securid_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_securid : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %edi,%ebp
push   %rbx
mov    0x0(%rip),%rbx        # d <getuser+0xd>
test   %rbx,%rbx
jne    21 <getuser+0x21>
jmp    40 <getuser+0x40>
nopl   0x0(%rax)
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
je     40 <getuser+0x40>
cmp    %ebp,(%rbx)
jne    18 <getuser+0x18>
xor    %eax,%eax
cmpb   $0x0,0x10(%rbx)
lea    0x10(%rbx),%rdx
pop    %rbx
pop    %rbp
pop    %r12
cmovne %rdx,%rax
retq   
nopl   0x0(%rax,%rax,1)
mov    %ebp,%edi
mov    $0x0,%r12d
callq  4d <getuser+0x4d>
test   %rax,%rax
mov    $0x11,%edi
je     66 <getuser+0x66>
mov    (%rax),%r12
mov    %r12,%rdi
callq  62 <getuser+0x62>
lea    0x11(%rax),%rdi
callq  6b <getuser+0x6b>
lea    0x10(%rax),%rdi
mov    %ebp,(%rax)
mov    %r12,%rsi
mov    %rax,%rbx
callq  7c <getuser+0x7c>
mov    0x0(%rip),%rax        # 83 <getuser+0x83>
mov    %rbx,0x0(%rip)        # 8a <getuser+0x8a>
mov    %rax,0x8(%rbx)
jmp    25 <getuser+0x25>
<<<sep_in_sample>>>
getuser (uid_t uid)
{
  struct userid *tail;
  struct userid *match = ((void *)0);
  for (tail = user_alist; tail; tail = tail->next)
    {
      if (tail->id.u == uid)
        {
          match = tail;
          break;
        }
    }
  if (match == ((void *)0))
    {
      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : "";
      match = xmalloc (__builtin_offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
      match->next = user_alist;
      user_alist = match;
    }
  return match->name[0] ? match->name : ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 7
14 7
15 23
16 23
17 23
18 24
19 24
20 24
21 23
22 24
23 24
24 15
25 16
26 15
27 16
28 16
29 16
30 16
31 16
32 16
33 16
34 17
35 19
36 18
37 19
38 17
39 19
40 20
41 21
42 20
43 20
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
callq  c <close_stream+0xc>
mov    %rbp,%rdi
mov    %rax,%r12
callq  17 <close_stream+0x17>
mov    %rbp,%rdi
mov    %eax,%ebx
callq  21 <close_stream+0x21>
test   %eax,%eax
setne  %dl
test   %ebx,%ebx
jne    40 <close_stream+0x40>
test   %dl,%dl
je     38 <close_stream+0x38>
test   %r12,%r12
mov    $0xffffffff,%ebx
je     60 <close_stream+0x60>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nop
test   %dl,%dl
mov    $0xffffffff,%ebx
jne    38 <close_stream+0x38>
callq  4e <close_stream+0x4e>
movl   $0x0,(%rax)
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
callq  65 <close_stream+0x65>
xor    %ebx,%ebx
cmpl   $0x9,(%rax)
setne  %bl
neg    %ebx
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
close_stream (FILE *stream)
{
  const _Bool some_pending = (__fpending (stream) != 0);
  const _Bool prev_fail = (ferror_unlocked (stream) != 0);
  const _Bool fclose_fail = (fclose (stream) != 0);
  if (prev_fail || (fclose_fail && (some_pending || (*__errno_location ()) != 9)))
    {
      if (! fclose_fail)
        (*__errno_location ()) = 0;
      return (-1);
    }
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 4
7 3
8 4
9 5
10 4
11 5
12 5
13 5
14 6
15 6
16 6
17 6
18 6
19 10
20 6
21 13
22 13
23 13
24 13
25 13
26 13
27 8
28 10
29 8
30 9
31 9
32 13
33 13
34 13
35 13
36 13
37 13
38 6
39 6
40 6
41 6
42 6
43 13
44 13
45 13
46 13
47 13
<<<sep_out_sample>>>
sub    $0x818,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x808(%rsp)
xor    %eax,%eax
cmpq   $0x0,0x0(%rip)        # 9d2 <terminaltypeok+0x22>
mov    $0x1,%al
je     9e9 <terminaltypeok+0x39>
mov    %rdi,%rsi
mov    %rsp,%rdi
callq  9e1 <terminaltypeok+0x31>
test   %eax,%eax
setne  %al
movzbl %al,%eax
mov    0x808(%rsp),%rdx
xor    %fs:0x28,%rdx
jne    a04 <terminaltypeok+0x54>
add    $0x818,%rsp
retq   
callq  a09 <terminaltypeok+0x59>
nopl   0x0(%rax)
<<<sep_in_sample>>>
terminaltypeok (char *s)
{
  char buf[2048];
  if (terminaltype == ((void *)0))
    return 1;
  if (tgetent (buf, s) == 0)
    return 0;
  return 1;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 5
7 4
8 6
9 6
10 6
11 6
12 6
13 6
14 9
15 9
16 9
17 9
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  c9 <is_alnum_mbchar+0x9>
movzbl (%rbx),%edx
mov    (%rax),%rax
pop    %rbx
movzwl (%rax,%rdx,2),%eax
shr    $0x3,%ax
and    $0x1,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
is_alnum_mbchar(const char *c)
{
    ((void) (0));
 return ((*__ctype_b_loc ())[(int) (((unsigned char)*c))] & (unsigned short int) _ISalnum);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    %rdi,%rax
lea    0x1000(%rdi),%rdi
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rax,%rsi
jmpq   48 <nettle_gcm_camellia128_set_iv+0x18>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_gcm_camellia128_set_iv (struct gcm_camellia128_ctx *ctx,
   size_t length, const uint8_t *iv)
{
  nettle_gcm_set_iv(&(ctx)->gcm, &(ctx)->key, (length), (iv));
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
sub    $0x38,%rsp
mov    %rdi,(%rsp)
mov    %esi,0x28(%rsp)
mov    %rdx,%rdi
mov    %rsp,%rsi
callq  c97 <lookup_variable_in_set+0x17>
add    $0x38,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
lookup_variable_in_set (const char *name, unsigned int length,
                        const struct variable_set *set)
{
  struct variable var_key;
  var_key.name = (char *) name;
  var_key.length = length;
  return (struct variable *) hash_find_item ((struct hash_table *) &set->table, &var_key);
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 7
5 7
6 7
7 8
8 8
9 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x10(%rsi),%rsi
test   %rsi,%rsi
je     166 <append_symbol+0x26>
mov    0x10(%rsi),%rdi
callq  15e <append_symbol+0x1e>
movq   $0x0,0x10(%rbx)
mov    0x0(%rbp),%rsi
mov    %rbx,%rdi
callq  172 <append_symbol+0x32>
test   %eax,%eax
jne    18d <append_symbol+0x4d>
mov    %rbx,%rsi
mov    %rbp,%rdi
callq  181 <append_symbol+0x41>
mov    0x0(%rbp),%rax
mov    0x10(%rax),%rax
mov    %rax,0x10(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
append_symbol(struct linked_list **plist, Symbol *sp)
{
     if (sp->entry) {
   linked_list_unlink(sp->entry->list, sp->entry);
   sp->entry = ((void *)0);
     }
     if (!data_in_list(sp, *plist)) {
   linked_list_append(plist, sp);
   sp->entry = (*plist)->tail;
     }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 4
11 5
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 8
20 9
21 9
22 9
23 11
24 11
25 11
26 11
27 11
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    0x0(%rip),%eax        # e2a <rpl_getopt_internal+0xa>
movq   $0x0,0x8(%rsp)
mov    %eax,0x0(%rip)        # e39 <rpl_getopt_internal+0x19>
mov    0x0(%rip),%eax        # e3f <rpl_getopt_internal+0x1f>
mov    %eax,0x0(%rip)        # e45 <rpl_getopt_internal+0x25>
mov    0x20(%rsp),%eax
mov    %eax,(%rsp)
callq  e51 <rpl_getopt_internal+0x31>
mov    0x0(%rip),%edx        # e57 <rpl_getopt_internal+0x37>
mov    %edx,0x0(%rip)        # e5d <rpl_getopt_internal+0x3d>
mov    0x0(%rip),%rdx        # e64 <rpl_getopt_internal+0x44>
mov    %rdx,0x0(%rip)        # e6b <rpl_getopt_internal+0x4b>
mov    0x0(%rip),%edx        # e71 <rpl_getopt_internal+0x51>
mov    %edx,0x0(%rip)        # e77 <rpl_getopt_internal+0x57>
add    $0x18,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
rpl_getopt_internal (int argc, char **argv, const char *optstring,
    const struct rpl_option *longopts, int *longind,
    int long_only, int posixly_correct)
{
  int result;
  getopt_data.rpl_optind = rpl_optind;
  getopt_data.rpl_opterr = rpl_opterr;
  result = _getopt_internal_r (argc, argv, optstring, longopts, longind,
          long_only, posixly_correct, &getopt_data);
  rpl_optind = getopt_data.rpl_optind;
  rpl_optarg = getopt_data.rpl_optarg;
  rpl_optopt = getopt_data.rpl_optopt;
  return result;
}
<<<sep_in_sample>>>
1 4
2 6
3 8
4 6
5 7
6 7
7 8
8 8
9 8
10 10
11 10
12 11
13 11
14 12
15 12
16 14
17 14
18 14
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  1d31 <vwindow_message_in_echo_area+0x11>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  1d3c <vwindow_message_in_echo_area+0x1c>
mov    0x0(%rip),%rdi        # 1d43 <vwindow_message_in_echo_area+0x23>
mov    %rax,%rsi
mov    %rax,0x0(%rip)        # 1d4d <vwindow_message_in_echo_area+0x2d>
callq  1d52 <vwindow_message_in_echo_area+0x32>
mov    0x0(%rip),%rdi        # 1d59 <vwindow_message_in_echo_area+0x39>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
jmpq   1d64 <vwindow_message_in_echo_area+0x44>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
vwindow_message_in_echo_area (const char *format, va_list ap)
{
  free_echo_area ();
  echo_area_node = build_message_node (format, ap);
  window_set_node_of_window (the_echo_area, echo_area_node);
  display_update_one_window (the_echo_area);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 5
11 5
12 4
13 5
14 6
15 7
16 7
17 7
18 6
19 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  3260 <just_dump>
mov    $0x1,%edi
callq  32b3 <dump_and_exit+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dump_and_exit(int signum)
{
 just_dump(signum);
 final_exit(1);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
<<<sep_out_sample>>>
test   %rsi,%rsi
mov    (%rdi),%rax
je     c8 <rpmfd_setfd+0x28>
mov    0x20(%rsi),%edx
mov    %edx,0x20(%rax)
mov    0x38(%rsi),%edx
mov    %edx,0x38(%rax)
mov    0x50(%rsi),%edx
mov    %edx,0x50(%rax)
mov    0x68(%rsi),%edx
mov    %edx,0x68(%rax)
retq   
nopl   0x0(%rax)
mov    %edx,0x20(%rax)
retq   
<<<sep_in_sample>>>
rpmfd_setfd(RPMFD * rpmfd, FD_t fd, int fd_fd)
{
 if (fd) {
  rpmfd->fd_t_->fps[0].fdno=fd->fps[0].fdno;
  rpmfd->fd_t_->fps[1].fdno=fd->fps[1].fdno;
  rpmfd->fd_t_->fps[2].fdno=fd->fps[2].fdno;
  rpmfd->fd_t_->fps[3].fdno=fd->fps[3].fdno;
 }
 else {
  rpmfd->fd_t_->fps[0].fdno=fd_fd;
 }
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 4
5 4
6 5
7 5
8 6
9 6
10 7
11 7
12 7
13 7
14 10
15 10
<<<sep_out_sample>>>
movl   $0x1,0x0(%rip)        # 2a <setdebug+0xa>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
setdebug(void)
{
 debug = 1;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
sub    $0x8,%rsp
callq  72 <dir_name+0x12>
test   %rax,%rax
lea    0x1(%rax),%r13
mov    %rax,%rbx
sete   %bpl
movzbl %bpl,%edi
add    %r13,%rdi
callq  8c <dir_name+0x2c>
mov    %rbx,%rdx
mov    %r12,%rsi
mov    %rax,%rdi
callq  9a <dir_name+0x3a>
test   %bpl,%bpl
mov    %rax,%rcx
je     a9 <dir_name+0x49>
movb   $0x2e,(%rax,%rbx,1)
mov    %r13,%rbx
movb   $0x0,(%rcx,%rbx,1)
add    $0x8,%rsp
mov    %rcx,%rax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
dir_name (char const *file)
{
  size_t length = dir_len (file);
  _Bool append_dot = (length == 0
       || (0
    && length == 0
    && file[2] != '\0' && ! ((file[2]) == '/')));
  char *dir = xmalloc (length + append_dot + 1);
  memcpy (dir, file, length);
  if (append_dot)
    dir[length++] = '.';
  dir[length] = '\0';
  return dir;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 8
10 3
11 4
12 8
13 8
14 8
15 9
16 9
17 9
18 9
19 10
20 9
21 10
22 11
23 11
24 12
25 14
26 14
27 14
28 14
29 14
30 14
31 14
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
push   %r12
mov    $0x2,%esi
mov    %r9,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
callq  14 <_gsasl_external_client_step+0x14>
test   %rax,%rax
mov    %rax,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %rbx,%rdi
callq  2b <_gsasl_external_client_step+0x2b>
mov    %rax,%rdx
mov    %rax,0x0(%rbp)
mov    $0x7,%eax
test   %rdx,%rdx
je     4a <_gsasl_external_client_step+0x4a>
mov    %rbx,%rdi
callq  44 <_gsasl_external_client_step+0x44>
mov    %rax,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_gsasl_external_client_step (Gsasl_session * sctx,
        void *mech_data,
        const char *input, size_t input_len,
        char **output, size_t * output_len)
{
  const char *p;
  p = gsasl_property_get (sctx, GSASL_AUTHZID);
  if (!p)
    p = "";
  *output = strdup (p);
  if (!*output)
    return GSASL_MALLOC_ERROR;
  *output_len = strlen (p);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 5
5 5
6 5
7 7
8 9
9 7
10 9
11 9
12 10
13 10
14 10
15 10
16 12
17 11
18 11
19 13
20 13
21 13
22 14
23 15
24 15
25 15
26 15
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   493 <gsl_vector_int_fread+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_int_fread (FILE * stream, gsl_vector_int * v)
{
  int status = gsl_block_int_raw_fread (stream,
                                                v->data,
                                                v->size,
                                                v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     56 <__gmp_obstack_printf+0x56>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
lea    0x8(%rsp),%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0x0,%edi
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x10,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  92 <__gmp_obstack_printf+0x92>
add    $0xd8,%rsp
retq   
<<<sep_in_sample>>>
__gmp_obstack_printf (struct obstack *ob, const char *fmt, ...)
{
  va_list ap;
  int ret;
  __builtin_va_start(ap,fmt);
  do {} while (0)
                                               ;
  ret = __gmp_doprnt (&__gmp_obstack_printf_funs, ob, fmt, ap);
  __builtin_va_end(ap);
  return ret;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 5
17 8
18 2
19 8
20 8
21 5
22 5
23 5
24 5
25 5
26 8
27 11
28 11
<<<sep_out_sample>>>
sub    $0x98,%rsp
mov    %rsp,%rsi
callq  f <isdir+0xf>
xor    %edx,%edx
test   %eax,%eax
jne    28 <isdir+0x28>
mov    0x18(%rsp),%eax
xor    %edx,%edx
and    $0xf000,%eax
cmp    $0x4000,%eax
sete   %dl
mov    %edx,%eax
add    $0x98,%rsp
retq   
<<<sep_in_sample>>>
isdir (const char *path)
{
  struct stat stats;
  return stat (path, &stats) == 0 && ((((stats.st_mode)) & 0170000) == (0040000));
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   8 <ostream_flush+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ostream_flush(void *data)
{
    struct ostream *ostr = data;
    return dico_stream_flush(ostr->transport);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rdx,0x8(%rsp)
mov    %rsp,%rdx
movq   $0x0,(%rsp)
callq  b99 <grecs_print_value+0x19>
add    $0x18,%rsp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
grecs_print_value(struct grecs_value *val, int flags, FILE *fp)
{
 struct grecs_format_closure clos = { file_fmt, fp };
 grecs_format_value(val, flags, &clos);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 5
7 5
8 5
<<<sep_out_sample>>>
mov    %rcx,%r8
mov    %rdx,%rcx
mov    %rsi,%rdx
mov    %rdi,%rsi
xor    %edi,%edi
jmpq   16f3 <quotearg_custom_mem+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
quotearg_custom_mem (char const *left_quote, char const *right_quote,
                     char const *arg, size_t argsize)
{
  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,
                                argsize);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # c17 <setup_output+0x7>
mov    %rsi,0x0(%rip)        # c1e <setup_output+0xe>
mov    %dl,0x0(%rip)        # c24 <setup_output+0x14>
movq   $0x0,0x0(%rip)        # c2f <setup_output+0x1f>
retq   
<<<sep_in_sample>>>
setup_output (char const *name0, char const *name1, _Bool recursive)
{
  current_name0 = name0;
  current_name1 = name1;
  currently_recursive = recursive;
  outfile = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 6
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dummy_free(void *vstate)
{
  (void) vstate;
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    %edi,%eax
sub    $0x8,%rsp
mov    %rsi,%rdi
mov    %eax,%esi
callq  fc0 <swextopt_is_option_false+0x10>
add    $0x8,%rsp
mov    %rax,%rdi
jmpq   fcc <swextopt_is_option_false+0x1c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
swextopt_is_option_false(enum eOpts nopt, struct extendedOptions * options)
{
 char * val;
 val = get_opta(options, nopt);
 return swextopt_is_value_false(val);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 4
6 6
7 5
8 5
9 5
<<<sep_out_sample>>>
cmp    $0x20,%rsi
push   %rbx
ja     698 <nettle_sha512_256_digest+0x18>
mov    %rdi,%rbx
callq  0 <sha512_write_digest>
mov    %rbx,%rdi
pop    %rbx
jmpq   698 <nettle_sha512_256_digest+0x18>
lea    0x0(%rip),%rcx        # 69f <nettle_sha512_256_digest+0x1f>
lea    0x0(%rip),%rsi        # 6a6 <nettle_sha512_256_digest+0x26>
lea    0x0(%rip),%rdi        # 6ad <nettle_sha512_256_digest+0x2d>
mov    $0x135,%edx
callq  6b7 <nettle_sha512_256_digest+0x37>
<<<sep_in_sample>>>
nettle_sha512_256_digest(struct sha512_ctx *ctx,
       size_t length,
       uint8_t *digest)
{
  ((length <= 32) ? (void) (0) : __assert_fail ("length <= 32", "sha512.c", 309, __PRETTY_FUNCTION__));
  sha512_write_digest(ctx, length, digest);
  nettle_sha512_256_init(ctx);
}
<<<sep_in_sample>>>
1 5
2 4
3 5
4 5
5 6
6 7
7 8
8 7
9 5
10 5
11 5
12 5
13 5
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 8b7 <_rl_settracefp+0x7>
retq   
<<<sep_in_sample>>>
_rl_settracefp (fp)
     FILE *fp;
{
  _rl_tracefp = fp;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0xc8(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_sortedlist_search_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)
{
  return ((const struct gl_list_impl_base *) list)->vtable
  ->sortedlist_search_from_to (list, compar, start_index, end_index,
          elt);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
<<<sep_out_sample>>>
mov    %rsi,%rdx
xor    %esi,%esi
jmpq   14ba <inputBox+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
inputBox(char *msg, char *title)
{
  return inputBoxI(msg, ((void *)0), title);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
push   %rbp
push   %rbx
mov    %rdx,%rbx
je     3d9 <pw_fprintf_path+0x39>
mov    (%rdx),%rdx
mov    %rdi,%rbp
mov    %rsi,%r12
test   %rdx,%rdx
je     3d9 <pw_fprintf_path+0x39>
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
add    $0x8,%rbx
mov    %r12,%rsi
mov    %rbp,%rdi
callq  3d1 <pw_fprintf_path+0x31>
mov    (%rbx),%rdx
test   %rdx,%rdx
jne    3c0 <pw_fprintf_path+0x20>
pop    %rbx
pop    %rbp
pop    %r12
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
pw_fprintf_path (FILE * stream, const char * format, char * const * path)
{
  if (path)
    while (*path) {
      fprintf (stream, format, *path);
      path++;
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 6
15 5
16 5
17 5
18 4
19 4
20 4
21 8
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  79 <filter_flush+0x9>
mov    (%rax),%rdi
add    $0x8,%rsp
jmpq   85 <filter_flush+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
filter_flush (mu_stream_t stream)
{
  mu_filter_t filter = mu_stream_get_owner(stream);
  return mu_stream_flush (filter->stream);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 4
6 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%ecx
test   %esi,%esi
mov    $0x0,%eax
mov    0x0(%rip),%rdi        # 17 <mu_debug_stderr_printer+0x17>
mov    $0x0,%esi
cmovne %rcx,%rax
mov    %rdx,%rcx
mov    %rax,%rdx
xor    %eax,%eax
callq  2d <mu_debug_stderr_printer+0x2d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
mu_debug_stderr_printer (void *unused, mu_log_level_t level, const char *str)
{
  fprintf (stderr, "%s: %s",
    (level == 0) ? "ERROR" : "DEBUG",
    str);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 7
13 7
14 7
<<<sep_out_sample>>>
push   %r15
push   %r14
push   %r13
push   %r12
push   %rbp
push   %rbx
sub    $0x18,%rsp
mov    0x18(%rdi),%rbp
mov    (%rdi),%r14
mov    0x8(%rdi),%r12
mov    0x10(%rdi),%r15
movsd  0x0(%rbp),%xmm3
test   %r14,%r14
movsd  %xmm3,(%rsp)
je     6fc <gsl_matrix_min+0x9c>
shl    $0x3,%r15
xor    %r13d,%r13d
test   %r12,%r12
je     6f0 <gsl_matrix_min+0x90>
xor    %ebx,%ebx
jmp    6a9 <gsl_matrix_min+0x49>
nopl   0x0(%rax)
add    $0x1,%rbx
cmp    %r12,%rbx
je     6f0 <gsl_matrix_min+0x90>
movsd  0x0(%rbp,%rbx,8),%xmm1
movapd %xmm1,%xmm2
movsd  %xmm1,0x8(%rsp)
movapd %xmm1,%xmm0
minsd  (%rsp),%xmm2
movsd  %xmm2,(%rsp)
callq  6cc <gsl_matrix_min+0x6c>
test   %eax,%eax
movsd  0x8(%rsp),%xmm1
je     6a0 <gsl_matrix_min+0x40>
add    $0x18,%rsp
movapd %xmm1,%xmm0
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax)
add    $0x1,%r13
add    %r15,%rbp
cmp    %r14,%r13
jne    693 <gsl_matrix_min+0x33>
movsd  (%rsp),%xmm1
jmp    6d6 <gsl_matrix_min+0x76>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_min (const gsl_matrix * m)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  double min = m->data[0 * tda + 0];
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          double x = m->data[i * tda + j];
          if (x < min)
            min = x;
          if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x)))
            return x;
        }
    }
  return min;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 6
9 3
10 4
11 5
12 6
13 8
14 6
15 8
16 8
17 8
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 10
26 12
27 12
28 15
29 15
30 12
31 12
32 15
33 15
34 15
35 15
36 20
37 20
38 20
39 20
40 20
41 20
42 20
43 20
44 20
45 20
46 8
47 8
48 8
49 8
50 8
51 8
52 8
<<<sep_out_sample>>>
mov    (%rsi),%r8
cmp    (%rdi),%r8
je     17e0 <gsl_vector_uint_sub+0x30>
sub    $0x8,%rsp
mov    $0x13,%ecx
mov    $0x34,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  17d5 <gsl_vector_uint_sub+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
test   %r8,%r8
mov    0x8(%rdi),%r10
mov    0x8(%rsi),%r9
je     1813 <gsl_vector_uint_sub+0x63>
mov    0x10(%rdi),%rax
mov    0x10(%rsi),%rcx
shl    $0x2,%r10
shl    $0x2,%r9
xor    %edx,%edx
nop
add    $0x1,%rdx
mov    (%rcx),%esi
add    %r9,%rcx
sub    %esi,(%rax)
add    %r10,%rax
cmp    %r8,%rdx
jne    1800 <gsl_vector_uint_sub+0x50>
xor    %eax,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uint_sub (gsl_vector_uint * a, const gsl_vector_uint * b)
{
  const size_t N = a->size;
  if (b->size != N)
    {
      do { gsl_error ("vectors must have same length", "oper_source.c", 52, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  else
    {
      const size_t stride_a = a->stride;
      const size_t stride_b = b->stride;
      size_t i;
      for (i = 0; i < N; i++)
        {
          a->data[i * stride_a] -= b->data[i * stride_b];
        }
      return GSL_SUCCESS;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 2
5 6
6 6
7 6
8 6
9 6
10 6
11 19
12 19
13 19
14 13
15 10
16 11
17 13
18 13
19 13
20 13
21 13
22 13
23 13
24 13
25 15
26 15
27 15
28 15
29 13
30 13
31 17
32 19
33 19
<<<sep_out_sample>>>
mov    $0x0,%ecx
jmpq   92a <ds_compl_database+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ds_compl_database(int argc, char **argv, int ws)
{
    return dict_completion_matches(argc, argv, ws, db_generator);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     b10 <dupstr+0x20>
callq  b01 <dupstr+0x11>
mov    %rbx,%rdi
lea    0x1(%rax),%rsi
pop    %rbx
jmpq   b0e <dupstr+0x1e>
xchg   %ax,%ax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dupstr (char **pstr)
{
  if (*pstr)
    dupmem ((void**)pstr, strlen (*pstr) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 4
8 4
9 5
10 4
11 4
12 5
13 5
14 5
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x18(%rdi),%rcx
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r10
test   %r9,%r9
je     2890 <gsl_matrix_long_set_all+0x50>
lea    0x0(,%r8,8),%r11
shl    $0x3,%r10
xor    %edi,%edi
nopw   0x0(%rax,%rax,1)
test   %r8,%r8
je     2884 <gsl_matrix_long_set_all+0x44>
lea    (%rcx,%r11,1),%rdx
mov    %rcx,%rax
nopl   0x0(%rax)
mov    %rsi,(%rax)
add    $0x8,%rax
cmp    %rdx,%rax
jne    2878 <gsl_matrix_long_set_all+0x38>
add    $0x1,%rdi
add    %r10,%rcx
cmp    %r9,%rdi
jne    2868 <gsl_matrix_long_set_all+0x28>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_long_set_all (gsl_matrix_long * m, long x)
{
  size_t i, j;
  long * const data = m->data;
  const size_t p = m->size1 ;
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
  for (i = 0; i < p; i++)
    {
      for (j = 0; j < q; j++)
        {
          *(long *) (data + 1 * (i * tda + j)) = x;
        }
    }
}
<<<sep_in_sample>>>
1 5
2 4
3 6
4 7
5 8
6 8
7 8
8 8
9 8
10 8
11 10
12 10
13 10
14 10
15 10
16 12
17 12
18 10
19 10
20 8
21 8
22 8
23 8
24 8
25 8
<<<sep_out_sample>>>
mov    %rdi,0x10(%rsi)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sexset_out (FILE * out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyg->yyout_r = out_str ;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    0x10(%rdi),%rdx
mov    %rdi,%rbx
lea    0x0(%rbp,%rdx,1),%rax
lea    0x1(%rax),%rcx
cmp    0x8(%rdi),%rcx
jae    4788 <buffer_append_len+0x48>
mov    (%rdi),%rdi
add    %rdx,%rdi
mov    %r12,%rsi
mov    %rbp,%rdx
callq  4771 <buffer_append_len+0x31>
add    0x10(%rbx),%rbp
mov    (%rbx),%rax
mov    %rbp,0x10(%rbx)
movb   $0x0,(%rax,%rbp,1)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
lea    0x400(%rax),%rsi
mov    %rsi,0x8(%rdi)
mov    (%rdi),%rdi
callq  479b <buffer_append_len+0x5b>
mov    0x10(%rbx),%rdx
mov    %rax,(%rbx)
mov    %rax,%rdi
jmp    4763 <buffer_append_len+0x23>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
buffer_append_len (Buffer *buffer, const char *data, size_t len)
{
  if (buffer->len + len + 1 >= buffer->allocated)
    {
      buffer->allocated = buffer->len + len + 1024;
      buffer->data = xrealloc (buffer->data, buffer->allocated);
    }
  memcpy (buffer->data + buffer->len, data, len);
  buffer->len += len;
  buffer->data[buffer->len] = '\0';
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 2
8 3
9 3
10 3
11 3
12 3
13 8
14 8
15 8
16 8
17 9
18 10
19 9
20 10
21 11
22 11
23 11
24 11
25 11
26 5
27 5
28 6
29 6
30 6
31 6
32 6
33 6
34 6
<<<sep_out_sample>>>
test   %rdi,%rdi
mov    $0x1009,%eax
je     dfa <mu_locker_get_flags+0x1a>
test   %rsi,%rsi
mov    $0x16,%ax
je     dfa <mu_locker_get_flags+0x1a>
mov    0x10(%rdi),%eax
mov    %eax,(%rsi)
xor    %eax,%eax
repz retq 
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_locker_get_flags (mu_locker_t locker, int *flags)
{
  if (!locker)
    return (0x1000 +9);
  if (!flags)
    return 22;
  *flags = locker->flags;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 3
4 5
5 6
6 5
7 7
8 7
9 8
10 9
11 9
<<<sep_out_sample>>>
test   %rsi,%rsi
je     1428 <_argp_input+0x38>
mov    0x58(%rsi),%rdx
mov    0x50(%rdx),%rax
mov    0x58(%rdx),%rdx
cmp    %rdx,%rax
jb     1419 <_argp_input+0x29>
jmp    1428 <_argp_input+0x38>
nopl   0x0(%rax,%rax,1)
add    $0x48,%rax
cmp    %rdx,%rax
jae    1428 <_argp_input+0x38>
cmp    %rdi,0x8(%rax)
jne    1410 <_argp_input+0x20>
mov    0x30(%rax),%rax
retq   
nopl   0x0(%rax)
xor    %eax,%eax
retq   
<<<sep_in_sample>>>
_argp_input (const struct argp *argp, const struct argp_state *state)
{
  if (state)
    {
      struct group *group;
      struct parser *parser = state->pstate;
      for (group = parser->groups; group < parser->egroup; group++)
        if (group->argp == argp)
          return group->input;
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 7
5 7
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 8
14 8
15 9
16 9
17 9
18 11
19 12
<<<sep_out_sample>>>
jmpq   565 <_rl_keyseq_cxt_dispose+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_keyseq_cxt_dispose (cxt)
    _rl_keyseq_cxt *cxt;
{
  xfree (cxt);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    0x838(%rdi),%rax
mov    %rdi,%rbx
test   %rax,%rax
je     26 <mpool_write+0x26>
mov    0x20(%rsi),%rdx
mov    0x840(%rdi),%rdi
mov    0x28(%rsi),%esi
callq  *%rax
mov    0x28(%rbp),%r12d
mov    0x828(%rbx),%edi
xor    %edx,%edx
imul   0x820(%rbx),%r12
mov    %r12,%rsi
callq  42 <mpool_write+0x42>
cmp    %r12,%rax
jne    78 <mpool_write+0x78>
mov    0x820(%rbx),%rdx
mov    0x20(%rbp),%rsi
mov    0x828(%rbx),%edi
callq  5d <mpool_write+0x5d>
cmp    0x820(%rbx),%rax
jne    78 <mpool_write+0x78>
andb   $0xfe,0x2c(%rbp)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
pop    %rbx
pop    %rbp
mov    $0xffffffff,%eax
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mpool_write(mp, bp)
 MPOOL *mp;
 BKT *bp;
{
 off_t off;
 if (mp->pgout)
  (mp->pgout)(mp->pgcookie, bp->pgno, bp->page);
 off = mp->pagesize * bp->pgno;
 if (lseek(mp->fd, off, 0) != off)
  return (-1);
 if (write(mp->fd, bp->page, mp->pagesize) != mp->pagesize)
  return (-1);
 bp->flags &= ~0x01;
 return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 6
6 4
7 6
8 6
9 7
10 7
11 7
12 7
13 8
14 9
15 9
16 8
17 9
18 9
19 9
20 9
21 11
22 11
23 11
24 11
25 11
26 11
27 13
28 14
29 15
30 15
31 15
32 15
33 15
34 15
35 15
36 10
37 15
38 15
39 15
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  11e0 <input>
lea    -0x30(%rax),%edx
cmp    $0x48,%edx
ja     1605 <backslash+0x25>
jmpq   *0x0(,%rdx,8)
nopl   0x0(%rax,%rax,1)
mov    $0x9,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x8,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xc,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xa,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0xd,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x2,%esi
mov    $0x10,%edi
add    $0x8,%rsp
jmpq   1310 <getnum>
nopl   0x0(%rax,%rax,1)
mov    $0x3,%esi
mov    $0x8,%edi
add    $0x8,%rsp
jmpq   1310 <getnum>
nopl   0x0(%rax,%rax,1)
mov    $0x7,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
backslash()
{
     int c;
     switch (c = input()) {
     case 'a': return '\a';
     case 'b': return '\b';
     case 'f': return '\f';
     case 'n': return '\n';
     case 'r': return '\r';
     case 't': return '\t';
     case 'x': return getnum(16,2);
     case '0': return getnum(8,3);
     }
     return c;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 10
9 15
10 15
11 15
12 6
13 15
14 15
15 15
16 7
17 15
18 15
19 15
20 8
21 15
22 15
23 15
24 9
25 15
26 15
27 15
28 11
29 11
30 15
31 11
32 11
33 12
34 12
35 15
36 12
37 12
38 5
39 15
40 15
41 15
<<<sep_out_sample>>>
jmpq   10e5 <psfree+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
psfree (void * ptr )
{
 free( (char *) ptr );
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  39 <nettle_aes_set_decrypt_key+0x9>
mov    %rbx,%rsi
mov    %rbx,%rdi
pop    %rbx
jmpq   45 <nettle_aes_set_decrypt_key+0x15>
<<<sep_in_sample>>>
nettle_aes_set_decrypt_key(struct aes_ctx *ctx,
      size_t keysize, const uint8_t *key)
{
  nettle_aes_set_encrypt_key(ctx, keysize, key);
  nettle_aes_invert_key(ctx, ctx);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 6
7 5
<<<sep_out_sample>>>
mov    %rsi,%rax
xor    %esi,%esi
cmpb   $0x2f,(%rdi)
sete   %sil
add    %rdi,%rsi
mov    %rax,%rdi
jmpq   17 <mu_folder_match+0x17>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_folder_match (const char *name, void *pattern, int flags)
{
  return fnmatch (pattern, name[0] == '/' ? name + 1 : name, flags);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
test   %esi,%esi
js     3b8 <strob_get_char+0x18>
cmp    0x10(%rdi),%esi
jge    3b8 <strob_get_char+0x18>
mov    (%rdi),%rax
movslq %esi,%rsi
movzbl (%rax,%rsi,1),%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
strob_get_char(STROB * strb, int index)
{
 if (index < 0) return -1;
 if (index >= strb->length_) return -1;
 return (int) strb->str_[index];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 5
7 5
8 5
9 5
10 3
11 6
12 6
<<<sep_out_sample>>>
movzbl 0x1c(%rdi),%eax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
i_ring_empty (I_ring const *ir)
{
  return ir->ir_empty;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rcx
xor    %eax,%eax
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x0,%edi
callq  175a <grecs_grecs_error+0x1a>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_grecs_error(char const *s)
{
 grecs_error(&grecs_grecs_lloc, 0, "%s", s);
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 3
8 5
9 5
10 5
11 5
<<<sep_out_sample>>>
test   %rsi,%rsi
je     38 <parse_context+0x38>
movslq (%rdx),%rax
cmpq   $0x0,(%rsi,%rax,8)
je     38 <parse_context+0x38>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  1d <parse_context+0x1d>
xor    %esi,%esi
mov    %rax,%rdx
mov    $0x1,%edi
xor    %eax,%eax
callq  2e <parse_context+0x2e>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
parse_context (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  struct predicate *our_pred;
  if ((argv == ((void *)0)) || (argv[*arg_ptr] == ((void *)0)))
    return 0;
  if (0 <= 0)
    {
      error (1, 0,
      gettext ("invalid predicate -context: SELinux is not enabled."));
      return 0;
    }
  our_pred = insert_primary (entry, ((void *)0));
  our_pred->est_success_rate = 0.01f;
  our_pred->need_stat = 0;
  our_pred->args.scontext = argv[*arg_ptr];
  (*arg_ptr)++;
  return 1;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 2
7 9
8 9
9 8
10 8
11 8
12 8
13 8
14 18
15 18
16 18
17 18
18 18
19 18
20 18
<<<sep_out_sample>>>
cmpq   $0x0,0x0(%rip)        # 128 <mu_diag_set_debug+0x8>
push   %rbx
mov    %rdi,%rbx
je     13a <mu_diag_set_debug+0x1a>
xor    %esi,%esi
mov    $0x0,%edi
callq  13a <mu_diag_set_debug+0x1a>
mov    %rbx,0x0(%rip)        # 141 <mu_diag_set_debug+0x21>
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_diag_set_debug (mu_debug_t debug)
{
  if (mu_diag_debug)
    mu_debug_destroy (&mu_diag_debug, ((void *)0));
  mu_diag_debug = debug;
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 5
9 6
10 6
11 6
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%edi
push   %rbx
sub    $0x18,%rsp
callq  570 <sys_spawn_shell+0x10>
test   %rax,%rax
mov    %rax,%rbp
mov    $0x0,%eax
cmove  %rax,%rbp
callq  584 <sys_spawn_shell+0x24>
test   %eax,%eax
mov    %eax,%ebx
jne    59a <sys_spawn_shell+0x3a>
jmp    5c7 <sys_spawn_shell+0x67>
nopl   0x0(%rax)
callq  595 <sys_spawn_shell+0x35>
cmpl   $0x4,(%rax)
jne    5b8 <sys_spawn_shell+0x58>
lea    0xc(%rsp),%rsi
xor    %edx,%edx
mov    %ebx,%edi
callq  5a8 <sys_spawn_shell+0x48>
cmp    $0xffffffff,%eax
je     590 <sys_spawn_shell+0x30>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    %rbp,%rdi
callq  5c0 <sys_spawn_shell+0x60>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
mov    %rbp,%rdi
xor    %ecx,%ecx
mov    $0x0,%edx
mov    $0x0,%esi
xor    %eax,%eax
callq  5dd <sys_spawn_shell+0x7d>
mov    %rbp,%rdi
callq  5e5 <sys_spawn_shell+0x85>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sys_spawn_shell (void)
{
  pid_t child;
  const char *shell = getenv ("SHELL");
  if (! shell)
    shell = "/bin/sh";
  child = xfork ();
  if (child == 0)
    {
      priv_set_restore_linkdir ();
      execlp (shell, "-sh", "-i", ((void *)0));
      exec_fatal (shell);
    }
  else
    {
      int wait_status;
      while (waitpid (child, &wait_status, 0) == -1)
 if ((*__errno_location ()) != 4)
   {
     waitpid_error (shell);
     break;
   }
    }
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 4
6 6
7 4
8 6
9 6
10 7
11 8
12 7
13 8
14 8
15 8
16 18
17 18
18 18
19 17
20 17
21 17
22 17
23 17
24 17
25 24
26 24
27 24
28 24
29 24
30 20
31 20
32 24
33 24
34 24
35 24
36 11
37 11
38 11
39 11
40 11
41 11
42 12
43 12
44 12
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    0x28(%rdi),%rdi
test   %rdi,%rdi
je     1d69 <xformat_set_tarheader_flags+0x19>
callq  1d69 <xformat_set_tarheader_flags+0x19>
mov    0x68(%rbx),%rax
mov    %ebp,0x14(%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_set_tarheader_flags(XFORMAT * xux, int flags)
{
 if (xux->swvarfsM)
  swvarfs_set_tarheader_flags(xux->swvarfsM, flags);
 xux->taruM->taru_tarheaderflagsM = flags;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 4
10 5
11 5
12 6
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 7 <__rargv+0x7>
retq   
<<<sep_in_sample>>>
__rargv (void)
{
  return (__argv);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
xorpd  %xmm2,%xmm2
movsd  (%rdi),%xmm1
movsd  0x8(%rdi),%xmm3
ucomisd %xmm2,%xmm1
jp     8df <heading+0x1f>
jne    8df <heading+0x1f>
ucomisd %xmm2,%xmm3
jnp    900 <heading+0x40>
movapd %xmm3,%xmm0
movsd  %xmm2,0x8(%rsp)
callq  8ee <heading+0x2e>
movsd  0x8(%rsp),%xmm2
ucomisd %xmm0,%xmm2
ja     910 <heading+0x50>
add    $0x18,%rsp
retq   
nop
movapd %xmm2,%xmm0
jne    8df <heading+0x1f>
jmp    8fa <heading+0x3a>
nopl   0x0(%rax,%rax,1)
addsd  0x0(%rip),%xmm0        # 918 <heading+0x58>
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
heading(VPoint * x)
{
 double m;
 if (x->x == 0.0 && x->y == 0.0)
  return 0.0;
 if ((m = atan2(x->y, x->x)) < 0.0)
  return (3.14159265358979323846 * 2.0 + m);
 else
  return m;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 6
11 6
12 6
13 6
14 6
15 6
16 10
17 10
18 10
19 5
20 4
21 4
22 4
23 7
24 10
25 10
26 10
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
cmp    $0x1f,%esi
je     8cb0 <_jit_retval_d+0x20>
movslq %esi,%rdx
mov    $0x1f,%ecx
mov    $0x12f,%esi
jmpq   8ca7 <_jit_retval_d+0x17>
nopw   0x0(%rax,%rax,1)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_retval_d(jit_state_t *_jit, jit_int32_t r0)
{
    if (r0 != _XMM0)
 _jit_new_node_ww(_jit,jit_code_movr_d,r0,_XMM0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
<<<sep_out_sample>>>
mov    %rdx,%r8
mov    $0x1,%ecx
mov    $0x0,%edx
jmpq   210 <common_match>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
prefix_match(struct dictdb *db, const char *word, struct result *res)
{
    return common_match(db, word, compare_prefix, 1, res);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
mov    %r8d,%eax
mov    %edx,%r8d
mov    %eax,%edx
jmpq   105d <gsl_sf_coupling_6j_INCORRECT_e+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_sf_coupling_6j_INCORRECT_e(int two_ja, int two_jb, int two_jc,
                               int two_jd, int two_je, int two_jf,
                               gsl_sf_result * result)
{
  return gsl_sf_coupling_6j_e(two_ja, two_jb, two_je, two_jd, two_jc, two_jf, result);
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 5
5 5
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
jmpq   19 <html_styled_ostream__begin_use_class+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
html_styled_ostream__begin_use_class (html_styled_ostream_t stream,
                                      const char *classname)
{
  html_ostream_begin_span (stream->html_destination, classname);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
sub    $0x10,%rsp
callq  a <echo_finish+0xa>
mov    0x0(%rip),%rcx        # 11 <echo_finish+0x11>
xor    %edx,%edx
mov    0xb0(%rcx),%rax
test   %rax,%rax
je     2c <echo_finish+0x2c>
cmpq   $0xf,0x0(%rip)        # 27 <echo_finish+0x27>
mov    %rax,%rdx
ja     40 <echo_finish+0x40>
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
add    0xb8(%rcx),%rax
mov    0x68(%rcx),%rbx
js     c8 <echo_finish+0xc8>
cvtsi2sd %rax,%xmm1
movsd  0x10(%rbx),%xmm4
movsd  0x18(%rbx),%xmm0
divsd  %xmm1,%xmm4
divsd  %xmm1,%xmm0
movapd %xmm4,%xmm1
movsd  %xmm4,0x8(%rsp)
mulsd  %xmm4,%xmm1
subsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 7e <echo_finish+0x7e>
callq  83 <echo_finish+0x83>
movsd  0x8(%rsp),%xmm4
mov    $0x0,%edi
movapd %xmm0,%xmm3
mov    $0x4,%eax
movsd  0x8(%rbx),%xmm2
movsd  (%rbx),%xmm0
movapd %xmm4,%xmm1
callq  a9 <echo_finish+0xa9>
mov    0x0(%rip),%rax        # b0 <echo_finish+0xb0>
mov    0xb0(%rax),%rdx
xor    %eax,%eax
test   %rdx,%rdx
sete   %al
add    $0x10,%rsp
pop    %rbx
retq   
nopl   (%rax)
mov    %rax,%rdx
and    $0x1,%eax
shr    %rdx
or     %rax,%rdx
cvtsi2sd %rdx,%xmm1
addsd  %xmm1,%xmm1
jmpq   52 <echo_finish+0x52>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
echo_finish (void)
{
  ping_finish ();
  if (ping->ping_num_recv && ((data_length) >= sizeof (struct timeval)))
    {
      struct ping_stat *ping_stat = (struct ping_stat *) ping->ping_closure;
      double total = ping->ping_num_recv + ping->ping_num_rept;
      double avg = ping_stat->tsum / total;
      double vari = ping_stat->tsumsq / total - avg * avg;
      printf ("round-trip min/avg/max/stddev = %.3f/%.3f/%.3f/%.3f ms\n",
       ping_stat->tmin, avg, ping_stat->tmax, nsqrt (vari, 0.0005));
    }
  return (ping->ping_num_recv == 0);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 13
13 13
14 13
15 14
16 14
17 14
18 14
19 7
20 6
21 7
22 7
23 8
24 9
25 8
26 9
27 9
28 9
29 9
30 9
31 10
32 10
33 10
34 10
35 10
36 10
37 10
38 10
39 10
40 10
41 10
42 10
43 13
44 13
45 13
46 14
47 14
48 14
49 14
50 7
51 7
52 7
53 7
54 7
55 7
56 7
57 7
<<<sep_out_sample>>>
push   %rbx
mov    %edx,%ebx
mov    (%rsi),%rdx
xor    %eax,%eax
mov    $0x0,%esi
callq  212 <f_long+0x12>
mov    %ebx,%eax
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
f_long (FILE *fp, void *ptr, int size) { fprintf (fp, "%ld", *(long*) ptr); return size; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    $0x5413,%esi
xor    %edi,%edi
mov    %rsp,%rdx
xor    %eax,%eax
callq  35 <getScreenSize+0x15>
movzwl (%rsp),%eax
mov    %eax,0x0(%rip)        # 3f <getScreenSize+0x1f>
movzwl 0x2(%rsp),%eax
mov    %eax,0x0(%rip)        # 4a <getScreenSize+0x2a>
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
getScreenSize()
{
 struct winsize w;
 ioctl(0, 0x5413, &w);
 SCREEN_H = w.ws_row;
 SCREEN_W = w.ws_col;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 5
8 5
9 6
10 6
11 7
12 7
13 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x820,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x818(%rsp)
xor    %eax,%eax
mov    0x30(%rdi),%rax
movl   $0x0,0xc(%rsp)
movl   $0x2,(%rax)
mov    0x18(%rdi),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x22,-0x2(%rax)
jne    1860 <ReadRule+0x40>
lea    0x10(%rsp),%rsi
mov    %rbx,%rdi
callq  187b <ReadRule+0x5b>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1888 <ReadRule+0x68>
mov    $0x3e,%edx
mov    $0xa,%esi
mov    %rbx,%rdi
callq  18a8 <ReadRule+0x88>
lea    0x410(%rsp),%rdx
lea    0xc(%rsp),%rsi
mov    %rbx,%rdi
callq  18bd <ReadRule+0x9d>
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  18d6 <ReadRule+0xb6>
lea    0x410(%rsp),%rdx
lea    0x10(%rsp),%rsi
mov    $0x14,%ecx
mov    %rbx,%rdi
callq  18f0 <ReadRule+0xd0>
mov    0x18(%rbx),%rax
add    $0x1,%rax
nopl   0x0(%rax,%rax,1)
mov    %rax,0x18(%rbx)
add    $0x1,%rax
cmpb   $0x3e,-0x2(%rax)
jne    1900 <ReadRule+0xe0>
mov    0x818(%rsp),%rax
xor    %fs:0x28,%rax
jne    192a <ReadRule+0x10a>
add    $0x820,%rsp
pop    %rbx
retq   
callq  192f <ReadRule+0x10f>
nop
<<<sep_in_sample>>>
ReadRule (PINPUTBUF pibIn)
{
  PSTRLEX szRName;
  PSTREQN szEqn;
  int bInited = 0;
  PINPUTINFO pinfo = (PINPUTINFO) pibIn->pInfo;
  pinfo->wContext = 0x0002;
  while (*pibIn->pbufCur++ != '"');
  GetIdentifier (pibIn, szRName);
  while (*pibIn->pbufCur++ != '>');
  GetSBMLLex (pibIn, 10, 62);
  ReadApply (pibIn, &bInited, szEqn);
  printf ("rate for %s = %s\n", szRName, szEqn);
  DefineVariable (pibIn, szRName, szEqn, 20);
  while (*pibIn->pbufCur++ != '>');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 7
8 5
9 7
10 7
11 7
12 7
13 8
14 8
15 8
16 8
17 9
18 9
19 9
20 9
21 9
22 9
23 10
24 10
25 10
26 10
27 11
28 11
29 11
30 11
31 12
32 12
33 12
34 12
35 13
36 13
37 13
38 13
39 13
40 14
41 14
42 14
43 14
44 14
45 14
46 14
47 14
48 15
49 15
50 15
51 15
52 16
53 16
54 16
55 16
56 16
57 16
58 16
59 16
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  9ee <set_default_lang+0xe>
mov    $0x0,%edi
mov    %rax,%rsi
callq  9fb <set_default_lang+0x1b>
mov    $0x0,%edi
callq  a05 <set_default_lang+0x25>
mov    $0x0,%edi
mov    %rax,%rsi
add    $0x8,%rsp
jmpq   a16 <set_default_lang+0x36>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_default_lang ()
{
  char *v;
  v = get_string_value ("LC_ALL");
  set_locale_var ("LC_ALL", v);
  v = get_string_value ("LANG");
  set_lang ("LANG", v);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 5
6 5
7 6
8 6
9 7
10 7
11 8
12 7
13 7
<<<sep_out_sample>>>
cmpl   $0x1,0x118(%rdi)
jne    e <a2ps_print_char+0xe>
jmpq   e <a2ps_print_char+0xe>
push   %rax
callq  14 <a2ps_print_char+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
a2ps_print_char (a2ps_job * job, int c, enum face_e new_face)
{
  switch (job->output_format)
    {
    case ps:
      ps_print_char (job, c, new_face);
      break;
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 6
4 2
5 9
6 9
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
cmpq   $0x0,0x90(%rdi)
jne    249 <nettle_chacha_poly1305_update+0x29>
mov    %rsi,%rbp
callq  0 <poly1305_update>
add    %rbp,0x88(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
lea    0x0(%rip),%rcx        # 250 <nettle_chacha_poly1305_update+0x30>
lea    0x0(%rip),%rsi        # 257 <nettle_chacha_poly1305_update+0x37>
lea    0x0(%rip),%rdi        # 25e <nettle_chacha_poly1305_update+0x3e>
mov    $0x74,%edx
callq  268 <nettle_chacha_poly1305_update+0x48>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
nettle_chacha_poly1305_update (struct chacha_poly1305_ctx *ctx,
   size_t length, const uint8_t *data)
{
  ((ctx->data_size == 0) ? (void) (0) : __assert_fail ("ctx->data_size == 0", "chacha-poly1305.c", 116, __PRETTY_FUNCTION__));
  poly1305_update (ctx, length, data);
  ctx->auth_size += length;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 6
10 7
11 7
12 7
13 7
14 4
15 4
16 4
17 4
18 4
19 4
<<<sep_out_sample>>>
xor    %eax,%eax
cmp    $0x0,%rdi
sete   %al
retq   
<<<sep_in_sample>>>
Ambiguous (char *s)
{
  return ((char **) s == &ambiguous);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  1c9 <hash_find_item+0x9>
mov    (%rax),%rdx
xor    %eax,%eax
test   %rdx,%rdx
je     1de <hash_find_item+0x1e>
cmp    0x0(%rip),%rdx        # 1da <hash_find_item+0x1a>
cmovne %rdx,%rax
add    $0x8,%rsp
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_find_item (struct hash_table *ht, const void *key)
{
  void **slot = hash_find_slot (ht, key);
  return ((((*slot) == 0 || (void *) (*slot) == hash_deleted_item)) ? 0 : *slot);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x3c(%rdx),%eax
test   %eax,%eax
jne    a4d <pred_newer+0x2d>
mov    %rsi,%rax
mov    0x48(%rdx),%rcx
mov    0x60(%rsi),%rsi
mov    0x58(%rax),%rdi
mov    0x40(%rdx),%rdx
callq  0 <compare_ts>
test   %eax,%eax
setg   %al
add    $0x8,%rsp
retq   
mov    $0x0,%ecx
mov    $0x2b1,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a66 <pred_newer+0x46>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_newer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  ((COMP_GT == pred_ptr->args.reftime.kind) ? (void) (0) : __assert_fail ("COMP_GT == pred_ptr->args.reftime.kind", "pred.c", 689, __PRETTY_FUNCTION__));
  return compare_ts (get_stat_mtime(stat_buf), pred_ptr->args.reftime.ts) > 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 4
16 4
17 4
18 4
19 4
20 4
<<<sep_out_sample>>>
sub    $0x28,%rsp
lea    0x10(%rsp),%rax
mov    %rax,(%rsp)
callq  1792 <gsl_sf_coupling_RacahW+0x12>
test   %eax,%eax
movsd  0x10(%rsp),%xmm0
jne    17a8 <gsl_sf_coupling_RacahW+0x28>
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
mov    %eax,%ecx
mov    $0x1b9,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  17be <gsl_sf_coupling_RacahW+0x3e>
movsd  0x10(%rsp),%xmm0
add    $0x28,%rsp
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_sf_coupling_RacahW(int two_ja, int two_jb, int two_jc,
                          int two_jd, int two_je, int two_jf)
{
  gsl_sf_result result; int status = gsl_sf_coupling_RacahW_e(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_coupling_RacahW_e(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, &result)",
 "coupling.c"
  ,
 441
  , status) ; return result.val ; } while (0); } ; return result.val;
                                               ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 8
7 4
8 10
9 10
10 10
11 4
12 4
13 4
14 4
15 4
16 8
17 10
18 10
19 10
<<<sep_out_sample>>>
jmpq   5 <cdio_realpath+0x5>
<<<sep_in_sample>>>
cdio_realpath (const char *psz_src_path, char *psz_resolved_path) {
  psz_resolved_path = realpath(psz_src_path, psz_resolved_path);
  return psz_resolved_path;
}
<<<sep_in_sample>>>
1 2
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 91a <gsl_matrix_ptr+0xa>
test   %eax,%eax
je     929 <gsl_matrix_ptr+0x19>
cmp    %rsi,(%rdi)
jbe    940 <gsl_matrix_ptr+0x30>
cmp    %rdx,0x8(%rdi)
jbe    960 <gsl_matrix_ptr+0x50>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
lea    (%rax,%rdx,8),%rax
add    $0x8,%rsp
retq   
xchg   %ax,%ax
mov    $0x4,%ecx
mov    $0x13d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  959 <gsl_matrix_ptr+0x49>
xor    %eax,%eax
jmp    939 <gsl_matrix_ptr+0x29>
nopl   (%rax)
mov    $0x4,%ecx
mov    $0x141,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  979 <gsl_matrix_ptr+0x69>
xor    %eax,%eax
jmp    939 <gsl_matrix_ptr+0x29>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_double.h", 317, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_double.h", 321, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return (double *) (m->data + (i * m->tda + j)) ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 7
23 7
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %rbp
xor    %edx,%edx
xor    %eax,%eax
mov    %esi,%ebp
mov    $0x1,%esi
push   %rbx
mov    %edi,%ebx
sub    $0x8,%rsp
callq  18 <set_cloexec_flag+0x18>
test   %eax,%eax
mov    %eax,%ecx
js     50 <set_cloexec_flag+0x50>
mov    %eax,%edx
and    $0xfffffffe,%eax
or     $0x1,%edx
test   %bpl,%bpl
cmove  %eax,%edx
xor    %eax,%eax
cmp    %ecx,%edx
je     49 <set_cloexec_flag+0x49>
mov    $0x2,%esi
mov    %ebx,%edi
callq  3e <set_cloexec_flag+0x3e>
cmp    $0xffffffff,%eax
sete   %al
movzbl %al,%eax
neg    %eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
mov    $0xffffffff,%eax
jmp    49 <set_cloexec_flag+0x49>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
set_cloexec_flag (int desc, _Bool value)
{
  int flags = rpl_fcntl (desc, 1, 0);
  if (0 <= flags)
    {
      int newflags = (value ? flags | 1 : flags & ~1);
      if (flags == newflags
          || rpl_fcntl (desc, 2, newflags) != -1)
        return 0;
    }
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 2
5 3
6 2
7 2
8 2
9 3
10 4
11 3
12 4
13 6
14 6
15 6
16 6
17 6
18 9
19 7
20 7
21 8
22 8
23 8
24 8
25 8
26 8
27 8
28 12
29 12
30 12
31 12
32 11
33 11
34 11
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rcx,%rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rdx
callq  ba <_gsasl_step64+0x1a>
cmp    $0x1,%eax
jbe    d0 <_gsasl_step64+0x30>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%r13
mov    %eax,%r12d
mov    %r13,%rdi
callq  e0 <_gsasl_step64+0x40>
cmp    %rbx,%rax
jae    110 <_gsasl_step64+0x70>
test   %rbp,%rbp
je     f9 <_gsasl_step64+0x59>
lea    0x1(%rax),%rdx
mov    %r13,%rsi
mov    %rbp,%rdi
callq  f9 <_gsasl_step64+0x59>
mov    %r13,%rdi
callq  101 <_gsasl_step64+0x61>
add    $0x18,%rsp
mov    %r12d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nop
mov    %r13,%rdi
callq  118 <_gsasl_step64+0x78>
add    $0x18,%rsp
mov    $0x4,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_gsasl_step64 (Gsasl_session * sctx,
        const char *b64input, char *b64output, size_t b64output_len)
{
  char *tmp;
  int rc;
  rc = gsasl_step64 (sctx, b64input, &tmp);
  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)
    {
      if (b64output_len <= strlen (tmp))
 {
   free (tmp);
   return GSASL_TOO_SMALL_BUFFER;
 }
      if (b64output)
 strcpy (b64output, tmp);
      free (tmp);
    }
  return rc;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 6
9 6
10 7
11 7
12 19
13 19
14 19
15 19
16 19
17 19
18 19
19 9
20 9
21 9
22 9
23 9
24 9
25 14
26 14
27 15
28 15
29 15
30 15
31 16
32 16
33 19
34 16
35 19
36 19
37 19
38 19
39 19
40 19
41 11
42 11
43 19
44 12
45 19
46 19
47 19
48 19
49 19
50 19
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    58f8 <gsl_matrix_float_const_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  591a <gsl_matrix_float_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_const_column (const gsl_matrix_float * m, const size_t j)
{
  _gsl_vector_float_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_float v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    %rdi,%rax
mov    0x18(%rdi),%rcx
mov    0x10(%rdi),%rdx
mov    0x8(%rdi),%rsi
mov    0x28(%rdi),%rdi
mov    0x20(%r8),%r9
mov    0x20(%rax),%r8
jmpq   *%r9
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * s)
{
  return (s->type->iterate) (s->state, s->function, s->x, s->f, s->dx);
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
cmpq   $0x0,0x670(%rdi)
jg     36e6 <SetModelVars+0x26>
jmp    3728 <SetModelVars+0x68>
nopl   (%rax)
add    $0x1,%rbx
cmp    %rbx,0x670(%r12)
jle    3728 <SetModelVars+0x68>
mov    0x678(%r12),%rax
mov    (%rax,%rbx,8),%rbp
mov    0xd4(%rbp),%eax
test   %eax,%eax
jne    36d8 <SetModelVars+0x18>
mov    0x8(%rbp),%rdi
callq  3705 <SetModelVars+0x45>
test   %eax,%eax
je     36d8 <SetModelVars+0x18>
mov    0x8(%rbp),%rdi
movsd  0x10(%rbp),%xmm0
add    $0x1,%rbx
callq  371b <SetModelVars+0x5b>
cmp    %rbx,0x670(%r12)
jg     36e6 <SetModelVars+0x26>
nopl   (%rax)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
SetModelVars(PLEVEL plevel)
{
  long n;
  PMCVAR pMCVar;
  for (n = 0; n < plevel->nMCVars; n++) {
    pMCVar = plevel->rgpMCVars[n];
    if (!(pMCVar->bIsFixed) && (IsParm (pMCVar->hvar)))
      SetVar (pMCVar->hvar, pMCVar->dVal);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 5
9 5
10 5
11 5
12 5
13 6
14 6
15 7
16 7
17 7
18 7
19 7
20 7
21 7
22 8
23 8
24 5
25 8
26 5
27 5
28 5
29 10
30 10
31 10
32 10
33 10
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 237 <min+0x7>
cmp    0x0(%rip),%rax        # 23e <min+0xe>
jae    250 <min+0x20>
lea    0x1(%rax),%rdx
mov    %rdx,0x0(%rip)        # 24b <min+0x1b>
movzbl (%rax),%eax
retq   
nop
mov    $0xffffffff,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
min(void)
{
  unsigned char x;
  if (mpointer>=last_object_allocated_ptr_mell) return -1;
  x= *(mpointer++);
  return (x);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 6
7 6
8 6
9 4
10 7
11 7
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  e <do_nothing+0xe>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_nothing(const char *name)
{
  (void) name;
  printf("stdin is buffered in the default way\n");
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 6
5 6
6 6
7 6
<<<sep_out_sample>>>
mov    0x1258(%rdi),%eax
cmp    $0xf,%eax
jg     1290 <addRadarInfo+0x70>
movslq %esi,%r8
movslq %eax,%rcx
add    $0x1,%eax
lea    (%r8,%r8,2),%r8
shl    $0x6,%rcx
add    %rdi,%rcx
lea    0x400(%rdi,%r8,8),%r8
mov    0x8(%r8),%r9
mov    %r9,0xa60(%rcx)
mov    0x10(%r8),%r9
mov    0x18(%r8),%r8
movsd  %xmm0,0xa78(%rcx)
mov    %esi,0xa80(%rcx)
movl   $0x0,0xa58(%rcx)
movl   $0x0,0xa84(%rcx)
mov    %r9,0xa68(%rcx)
mov    %r8,0xa70(%rcx)
mov    %eax,0x1258(%rdi)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addRadarInfo(craft * c, int i, int beam, double d)
{
 if (c->rtop < 16) {
  c->rinfo[c->rtop].rel = c->relPos[i];
  c->rinfo[c->rtop].d = d;
  c->rinfo[c->rtop].targetID = i;
  c->rinfo[c->rtop].beamID = 0;
  c->rinfo[c->rtop].locked = 0;
  ++c->rtop;
 }
 return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 9
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 6
17 7
18 8
19 4
20 4
21 9
22 12
23 12
24 12
<<<sep_out_sample>>>
mov    (%rdi),%rdx
test   %rdx,%rdx
je     400 <mu_iterator_detach+0x20>
cmp    %rsi,%rdx
jne    3f8 <mu_iterator_detach+0x18>
jmp    411 <mu_iterator_detach+0x31>
nop
cmp    %rax,%rsi
je     408 <mu_iterator_detach+0x28>
mov    %rax,%rdx
mov    (%rdx),%rax
test   %rax,%rax
jne    3f0 <mu_iterator_detach+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rsi),%rax
mov    %rax,(%rdx)
xor    %eax,%eax
retq   
mov    (%rdx),%rax
mov    %rax,(%rdi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_iterator_detach (mu_iterator_t *root, mu_iterator_t iterator)
{
  mu_iterator_t itr, prev;
  for (itr = *root, prev = ((void *)0); itr; prev = itr, itr = itr->next_itr)
    if (iterator == itr)
      break;
  if (itr)
    {
      if (prev)
 prev->next_itr = itr->next_itr;
      else
 *root = itr->next_itr;
    }
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
6 5
7 5
8 5
9 5
10 5
11 4
12 4
13 4
14 15
15 15
16 15
17 10
18 10
19 15
20 15
21 12
22 12
23 15
24 15
25 15
<<<sep_out_sample>>>
add    $0x88,%rdi
mov    $0xffffffff,%edx
jmpq   0 <ahsStaticSetTarname_i>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ahsStaticSetTarGroupname(struct new_cpio_header * file_hdr, char * name)
{
 ;
 ahsStaticSetTarname_i((STROB**)&(file_hdr->c_groupname), name, -1);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm1
sub    $0x18,%rsp
xorpd  %xmm0,%xmm0
ucomisd %xmm1,%xmm0
jae    2ed <ExpRandom+0x3d>
movsd  %xmm1,0x8(%rsp)
callq  2cd <ExpRandom+0x1d>
callq  2d2 <ExpRandom+0x22>
movsd  0x0(%rip),%xmm2        # 2da <ExpRandom+0x2a>
movsd  0x8(%rsp),%xmm1
add    $0x18,%rsp
xorpd  %xmm2,%xmm0
divsd  %xmm1,%xmm0
retq   
mov    $0x0,%edi
callq  2f7 <ExpRandom+0x47>
xor    %edi,%edi
callq  2fe <ExpRandom+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
ExpRandom (double beta)
{
  if (beta <= 0) {
    printf ("Error: negative or null inverse scale for an exponential variate "
            "- Exiting\n\n");
    exit (0);
  }
  return -log(Randoms()) / beta;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 8
8 8
9 8
10 8
11 9
12 8
13 8
14 9
15 4
16 4
17 6
18 6
19 6
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  0x0(%rip),%xmm1        # 13bc <gsl_complex_arccos_real+0xc>
movsd  0x0(%rip),%xmm2        # 13c4 <gsl_complex_arccos_real+0x14>
andpd  %xmm0,%xmm1
ucomisd %xmm1,%xmm2
jae    1420 <gsl_complex_arccos_real+0x70>
xorpd  %xmm3,%xmm3
ucomisd %xmm0,%xmm3
ja     13f0 <gsl_complex_arccos_real+0x40>
callq  13dd <gsl_complex_arccos_real+0x2d>
movapd %xmm0,%xmm1
xorpd  %xmm0,%xmm0
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
movsd  0x0(%rip),%xmm2        # 13f8 <gsl_complex_arccos_real+0x48>
xorpd  %xmm2,%xmm0
movapd %xmm2,(%rsp)
callq  1406 <gsl_complex_arccos_real+0x56>
movapd %xmm0,%xmm1
movapd (%rsp),%xmm2
movsd  0x0(%rip),%xmm0        # 1417 <gsl_complex_arccos_real+0x67>
add    $0x18,%rsp
xorpd  %xmm2,%xmm1
retq   
callq  1425 <gsl_complex_arccos_real+0x75>
xorpd  %xmm1,%xmm1
jmp    13e5 <gsl_complex_arccos_real+0x35>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_arccos_real (double a)
{
  gsl_complex z;
  if (fabs (a) <= 1.0)
    {
      do {(&z)->dat[0]=(acos (a)); (&z)->dat[1]=(0);} while(0);
    }
  else
    {
      if (a < 0.0)
        {
          do {(&z)->dat[0]=(3.14159265358979323846); (&z)->dat[1]=(-acosh (-a));} while(0);
        }
      else
        {
          do {(&z)->dat[0]=(0); (&z)->dat[1]=(acosh (a));} while(0);
        }
    }
  return z;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
7 10
8 10
9 10
10 16
11 16
12 16
13 20
14 20
15 20
16 12
17 12
18 12
19 12
20 12
21 12
22 12
23 20
24 12
25 20
26 6
27 6
28 6
29 6
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
<<<sep_in_sample>>>
__gmpz_limbs_read (mpz_srcptr x)
{
  return ((x)->_mp_d);
}
<<<sep_in_sample>>>
1 3
2 4
<<<sep_out_sample>>>
cmp    $0xe,%rdi
jle    a8 <__gmpn_matrix22_mul_itch+0x18>
cmp    $0xe,%rsi
jle    a8 <__gmpn_matrix22_mul_itch+0x18>
add    %rsi,%rdi
lea    0x5(%rdi,%rdi,2),%rax
retq   
nopl   (%rax)
lea    (%rdi,%rdi,2),%rax
lea    (%rax,%rsi,2),%rax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmpn_matrix22_mul_itch (mp_size_t rn, mp_size_t mn)
{
  if ((! ((__builtin_constant_p (15) && (15) == 0) || (!(__builtin_constant_p (15) && (15) == 9223372036854775807L) && (rn) >= (15))))
      || (! ((__builtin_constant_p (15) && (15) == 0) || (!(__builtin_constant_p (15) && (15) == 9223372036854775807L) && (mn) >= (15)))))
    return 3*rn + 2*mn;
  else
    return 3*(rn + mn) + 5;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 7
6 7
7 8
8 8
9 5
10 5
11 5
12 5
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    (%rdi),%rbp
mov    0x18(%rdi),%r8
mov    0x8(%rdi),%r9
mov    0x10(%rdi),%r12
test   %rbp,%rbp
mov    (%r8),%rdi
je     1342 <gsl_matrix_ulong_min_index+0x72>
shl    $0x3,%r12
xor    %r10d,%r10d
xor    %r11d,%r11d
xor    %ebx,%ebx
nopw   0x0(%rax,%rax,1)
test   %r9,%r9
je     132b <gsl_matrix_ulong_min_index+0x5b>
xor    %eax,%eax
nopw   0x0(%rax,%rax,1)
mov    (%r8,%rax,8),%rcx
cmp    %rdi,%rcx
jae    1322 <gsl_matrix_ulong_min_index+0x52>
mov    %rax,%r11
mov    %r10,%rbx
mov    %rcx,%rdi
add    $0x1,%rax
cmp    %r9,%rax
jne    1310 <gsl_matrix_ulong_min_index+0x40>
add    $0x1,%r10
add    %r12,%r8
cmp    %rbp,%r10
jne    1300 <gsl_matrix_ulong_min_index+0x30>
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
xor    %ebx,%ebx
xor    %r11d,%r11d
mov    %rbx,(%rsi)
mov    %r11,(%rdx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_ulong_min_index (const gsl_matrix_ulong * m, size_t * imin_out, size_t *jmin_out)
{
  const size_t M = m->size1;
  const size_t N = m->size2;
  const size_t tda = m->tda;
  unsigned long min = m->data[0 * tda + 0];
  size_t imin = 0, jmin = 0;
  size_t i, j;
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          unsigned long x = m->data[i * tda + j];
          if (x < min)
            {
              min = x;
              imin = i;
              jmin = j;
            }
        }
    }
  *imin_out = imin;
  *jmin_out = jmin;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 6
6 4
7 5
8 9
9 6
10 9
11 9
12 9
13 7
14 7
15 7
16 11
17 11
18 11
19 11
20 13
21 14
22 14
23 14
24 14
25 14
26 11
27 11
28 11
29 9
30 9
31 9
32 9
33 22
34 23
35 24
36 24
37 24
38 24
39 7
40 7
41 22
42 23
43 24
44 24
45 24
46 24
47 24
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     18e1 <gsl_matrix_uint_fread+0x91>
lea    0x0(,%r15,4),%rax
xor    %ebx,%ebx
xor    %r15d,%r15d
test   %r13,%r13
mov    %rax,0x8(%rsp)
jne    189e <gsl_matrix_uint_fread+0x4e>
jmp    18d0 <gsl_matrix_uint_fread+0x80>
nopl   (%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     18d0 <gsl_matrix_uint_fread+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  18b5 <gsl_matrix_uint_fread+0x65>
test   %eax,%eax
je     1890 <gsl_matrix_uint_fread+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   1904 <gsl_matrix_uint_fread+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uint_fread (FILE * stream, gsl_matrix_uint * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_uint_raw_fread (stream,
                                                m->data,
                                                size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_uint_raw_fread (stream,
                                                    m->data + i * 1 * tda,
                                                    size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
jmpq   25 <rec_record_comment_dup_fn+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_record_comment_dup_fn (void *data)
{
  rec_comment_t copy;
  copy = rec_comment_dup ((rec_comment_t) data);
  return (void *) copy;
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
push   %rbp
mov    %rdx,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     3f8 <localtime_rz+0x78>
callq  280 <set_tz>
test   %rax,%rax
mov    %rax,%r12
je     3d8 <localtime_rz+0x58>
mov    %rbp,%rsi
mov    %r13,%rdi
callq  3b0 <localtime_rz+0x30>
test   %rax,%rax
je     3e8 <localtime_rz+0x68>
mov    %rbp,%rsi
mov    %rbx,%rdi
callq  140 <save_abbr>
test   %al,%al
je     3e8 <localtime_rz+0x68>
mov    %r12,%rdi
callq  50 <revert_tz>
mov    %eax,%edx
mov    %rbp,%rax
test   %dl,%dl
jne    3da <localtime_rz+0x5a>
nopl   (%rax)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
mov    %r12,%rdi
callq  50 <revert_tz>
jmp    3d8 <localtime_rz+0x58>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
mov    %r13,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
jmpq   40d <localtime_rz+0x8d>
nopl   (%rax)
<<<sep_in_sample>>>
localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
{
  if (!tz)
    return gmtime_r (t, tm);
  else
    {
      timezone_t old_tz = set_tz (tz);
      if (old_tz)
        {
          _Bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);
          if (revert_tz (old_tz) && abbr_saved)
            return tm;
        }
      return ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 3
10 3
11 7
12 8
13 7
14 8
15 10
16 10
17 10
18 10
19 10
20 10
21 10
22 10
23 10
24 10
25 11
26 11
27 11
28 12
29 11
30 11
31 11
32 14
33 16
34 16
35 16
36 16
37 16
38 16
39 16
40 11
41 11
42 11
43 11
44 16
45 4
46 4
47 16
48 16
49 16
50 16
51 4
52 4
<<<sep_out_sample>>>
push   %r15
xor    %eax,%eax
push   %r14
mov    %r9d,%r14d
push   %r13
mov    %r8,%r13
mov    %r14d,%r8d
push   %r12
mov    %esi,%r12d
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %ecx,%ebx
mov    %r13,%rcx
sub    $0x38,%rsp
mov    0x0(%rip),%edx        # 3efa <il_hdy+0x2a>
movq   $0x0,0x0(%rip)        # 3f05 <il_hdy+0x35>
mov    0x70(%rsp),%r9d
movq   $0x0,(%rsp)
test   %edx,%edx
mov    %ebx,%edx
sete   %al
mov    %eax,0x0(%rip)        # 3f1f <il_hdy+0x4f>
callq  3f24 <il_hdy+0x54>
mov    0x0(%rip),%ecx        # 3f2a <il_hdy+0x5a>
xor    %eax,%eax
test   %ecx,%ecx
sete   %al
cmp    $0x7cf,%ebx
mov    %eax,0x0(%rip)        # 3f3d <il_hdy+0x6d>
jle    3f8c <il_hdy+0xbc>
mov    0x0(%rip),%rdi        # 3f46 <il_hdy+0x76>
mov    0x0(%rip),%r15        # 3f4d <il_hdy+0x7d>
callq  3f52 <il_hdy+0x82>
mov    0x70(%rsp),%edx
mov    %r14d,0x18(%rsp)
mov    $0x9,%r9d
mov    %r13,0x10(%rsp)
mov    %ebx,0x8(%rsp)
mov    $0x0,%r8d
movl   $0x5,(%rsp)
mov    %r15,%rcx
mov    %r12d,%esi
mov    %edx,0x20(%rsp)
mov    0x0(%rbp),%edi
mov    %rax,%rdx
callq  3f8c <il_hdy+0xbc>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  ptr_cc_id = "IL";
  use_other_cc = !use_other_cc;
  hebrew_hdy (init_data, detected, year, hd_elems, fday, count, ptr_cc_id);
  use_other_cc = !use_other_cc;
  if (year > 1999)
    holiday (*init_data, detected, gettext(hd_text[277].ht_text),
      ptr_cc_id, "-", 9, 5, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 11
3 9
4 9
5 9
6 9
7 12
8 9
9 9
10 9
11 9
12 9
13 9
14 12
15 9
16 11
17 10
18 12
19 12
20 11
21 12
22 11
23 11
24 12
25 13
26 13
27 13
28 13
29 14
30 13
31 14
32 15
33 15
34 15
35 15
36 15
37 15
38 15
39 15
40 15
41 15
42 15
43 15
44 15
45 15
46 15
47 15
48 17
49 17
50 17
51 17
52 17
53 17
54 17
55 17
56 17
<<<sep_out_sample>>>
xor    %r9d,%r9d
jmpq   350 <hybrid_iterate_impl>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hybrid_iterate (void *vstate, gsl_multiroot_function * func, gsl_vector * x,
                gsl_vector * f, gsl_vector * dx)
{
  int status = hybrid_iterate_impl (vstate, func, x, f, dx, 0);
  return status;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%ecx        # 27c6 <parse_iregex+0x6>
mov    %rdi,%rax
mov    %rsi,%rdi
mov    %rdx,%rsi
mov    %rax,%rdx
or     $0x400000,%ecx
jmpq   2690 <insert_regex>
nopl   (%rax)
<<<sep_in_sample>>>
parse_iregex (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_regex (argv, arg_ptr, entry, ((((((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)|options.regex_options);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 2
5 3
6 3
7 3
8 3
<<<sep_out_sample>>>
push   %r13
mov    $0x1005,%eax
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     1d0 <mu_observable_create+0x60>
mov    %rsi,%r12
mov    $0x10,%edi
mov    $0x1,%esi
callq  199 <mu_observable_create+0x29>
mov    %rax,%rbp
mov    $0xc,%eax
test   %rbp,%rbp
je     1d0 <mu_observable_create+0x60>
lea    0x8(%rbp),%rdi
callq  1af <mu_observable_create+0x3f>
test   %eax,%eax
mov    %eax,%r13d
jne    1e0 <mu_observable_create+0x70>
mov    0x8(%rbp),%rdi
mov    $0x0,%esi
callq  1c4 <mu_observable_create+0x54>
mov    %r12,0x0(%rbp)
xor    %eax,%eax
mov    %rbp,(%rbx)
nopl   (%rax)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  1e8 <mu_observable_create+0x78>
add    $0x8,%rsp
mov    %r13d,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_observable_create (mu_observable_t *pobservable, void *owner)
{
  mu_observable_t observable;
  int status;
  if (pobservable == ((void *)0))
    return (0x1000 +5);
  observable = calloc (sizeof (*observable), 1);
  if (observable == ((void *)0))
    return 12;
  status = mu_list_create (&observable->list);
  if (status != 0 )
    {
      free (observable);
      return status;
    }
  mu_list_set_destroy_item (observable->list, _free_event);
  observable->owner = owner;
  *pobservable = observable;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 2
7 2
8 5
9 5
10 5
11 7
12 7
13 7
14 7
15 9
16 8
17 8
18 10
19 10
20 11
21 10
22 11
23 16
24 16
25 16
26 17
27 19
28 18
29 18
30 20
31 20
32 20
33 20
34 20
35 20
36 20
37 13
38 13
39 20
40 14
41 20
42 20
43 20
44 20
45 20
46 20
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
callq  12c <s2s+0xc>
mov    %rax,(%rbx)
xor    %eax,%eax
pop    %rbx
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
s2s (union value *vp, void *val, int flags)
{
  vp->string = estrdup (val);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 5
7 5
8 5
9 5
<<<sep_out_sample>>>
push   %r14
push   %r13
mov    %rdi,%r13
push   %r12
xor    %r12d,%r12d
push   %rbp
push   %rbx
sub    $0x10,%rsp
mov    (%rsi),%r14
mov    0x8(%rsi),%rbp
add    $0x8,%rbp
test   %r14,%r14
jne    f8e <gsl_block_complex_float_fscanf+0x3e>
jmp    fe0 <gsl_block_complex_float_fscanf+0x90>
nopl   0x0(%rax)
add    $0x4,%rbx
cmp    %rbp,%rbx
jne    f92 <gsl_block_complex_float_fscanf+0x42>
add    $0x1,%r12
add    $0x8,%rbp
cmp    %r14,%r12
je     fe0 <gsl_block_complex_float_fscanf+0x90>
lea    -0x8(%rbp),%rbx
lea    0xc(%rsp),%rdx
xor    %eax,%eax
mov    $0x0,%esi
mov    %r13,%rdi
callq  fa6 <gsl_block_complex_float_fscanf+0x56>
movss  0xc(%rsp),%xmm0
cmp    $0x1,%eax
movss  %xmm0,(%rbx)
je     f78 <gsl_block_complex_float_fscanf+0x28>
mov    $0x5,%ecx
mov    $0x5a,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  fce <gsl_block_complex_float_fscanf+0x7e>
add    $0x10,%rsp
mov    $0x5,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
add    $0x10,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
<<<sep_in_sample>>>
gsl_block_complex_float_fscanf (FILE * stream, gsl_block_complex_float * b)
{
  size_t n = b->size ;
  float * data = b->data ;
  size_t i;
  for (i = 0; i < n; i++)
    {
      int k;
      for (k = 0; k < 2; k++)
        {
          float tmp ;
          int status = fscanf (stream, "%g", &tmp) ;
          data [2 * i + k] = tmp;
          if (status != 1)
            {
              do { gsl_error ("fscanf failed", "fprintf_source.c", 90, GSL_EFAILED) ; return GSL_EFAILED ; } while (0);
            }
        }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 6
6 2
7 2
8 2
9 3
10 4
11 4
12 6
13 6
14 6
15 6
16 6
17 9
18 9
19 6
20 6
21 6
22 6
23 2
24 12
25 12
26 12
27 12
28 12
29 13
30 14
31 13
32 14
33 16
34 16
35 16
36 16
37 16
38 21
39 16
40 21
41 21
42 21
43 21
44 21
45 21
46 21
47 20
48 21
49 21
50 21
51 21
52 21
53 21
54 21
<<<sep_out_sample>>>
mov    %rsi,%rax
mov    0x8(%rsi),%rcx
mov    0x10(%rsi),%rsi
mov    (%rax),%rdx
jmpq   613 <gsl_vector_uchar_fread+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_uchar_fread (FILE * stream, gsl_vector_uchar * v)
{
  int status = gsl_block_uchar_raw_fread (stream,
                                                v->data,
                                                v->size,
                                                v->stride);
  return status;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    %rsi,%rdx
mov    %rdi,%rsi
mov    $0xe,%edi
jmpq   10 <nettle_aes256_set_decrypt_key>
<<<sep_in_sample>>>
nettle_aes256_invert_key (struct aes256_ctx *dst, const struct aes256_ctx *src)
{
  _nettle_aes_invert (14, dst->keys, src->keys);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
movzbl (%rdi),%eax
cmp    $0x3a,%al
je     350 <swssh_determine_target_path+0x80>
sub    $0x2d,%eax
cmp    $0x2,%al
jbe    350 <swssh_determine_target_path+0x80>
mov    $0x3a,%esi
callq  2f4 <swssh_determine_target_path+0x24>
test   %rax,%rax
je     360 <swssh_determine_target_path+0x90>
add    $0x1,%rax
mov    %rax,0x0(%rbp)
test   %rax,%rax
je     370 <swssh_determine_target_path+0xa0>
mov    %rbx,%rdi
callq  30e <swssh_determine_target_path+0x3e>
lea    (%rbx,%rax,1),%rdi
mov    $0x0,%esi
mov    $0xffffffff,%ebx
mov    %rdi,0x0(%rbp)
callq  325 <swssh_determine_target_path+0x55>
test   %rax,%rax
je     356 <swssh_determine_target_path+0x86>
mov    0x0(%rip),%rcx        # 331 <swssh_determine_target_path+0x61>
mov    $0x21,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  345 <swssh_determine_target_path+0x75>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
mov    %rbx,0x0(%rbp)
xor    %ebx,%ebx
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
nop
mov    0x0(%rbp),%rax
jmp    301 <swssh_determine_target_path+0x31>
nopw   %cs:0x0(%rax,%rax,1)
xor    %ebx,%ebx
jmp    356 <swssh_determine_target_path+0x86>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swssh_determine_target_path(char * target, char ** path)
{
 char * ds;
 char * p;
 if (*target == ':' || *target == '/' || *target == '.' || *target == '-' ) {
  *path = target;
  target = target + strlen(*path);
 } else {
  ds = target;
  p = strrchr(ds, ':');
  if (p) {
   (*path) = ++p;
  } else if (!p) {
   if (ds && (*ds == '/' || *ds == '.' ||
       *ds == '-')) {
    *path = ds;
   }
  } else {
   ;
  }
  if (*path) {
   *path = target + strlen(target);
   if (strstr(*path, "@@")) {
    fprintf(stderr,
    "target path not at terminal host\n");
    return -1;
   } else {
    return -1;
   }
  }
 }
 return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 5
7 5
8 5
9 5
10 5
11 5
12 10
13 10
14 11
15 11
16 12
17 12
18 21
19 21
20 22
21 22
22 22
23 23
24 28
25 22
26 23
27 23
28 23
29 24
30 24
31 24
32 24
33 24
34 33
35 33
36 33
37 33
38 33
39 33
40 6
41 32
42 33
43 33
44 33
45 33
46 33
47 33
48 33
49 33
50 33
51 32
52 32
53 32
<<<sep_out_sample>>>
push   %r13
test   %r8d,%r8d
push   %r12
mov    %ecx,%r12d
push   %rbp
push   %rbx
mov    0x4c(%rdi),%ecx
mov    0x30(%rdi),%r9d
jle    479 <null_convert+0x79>
lea    (%r8,%r12,1),%r13d
mov    %rdx,%rbp
movslq %ecx,%r11
test   %ecx,%ecx
jle    46c <null_convert+0x6c>
mov    %r12d,%ebx
xor    %edx,%edx
shl    $0x3,%rbx
nopl   0x0(%rax)
mov    0x0(%rbp,%rdx,8),%rax
mov    %rdx,%rdi
add    (%rsi),%rdi
mov    (%rax,%rbx,1),%r10
xor    %eax,%eax
test   %r9d,%r9d
je     464 <null_convert+0x64>
nopw   %cs:0x0(%rax,%rax,1)
movzbl (%rdi),%r8d
add    %r11,%rdi
mov    %r8b,(%r10,%rax,1)
add    $0x1,%rax
cmp    %eax,%r9d
ja     450 <null_convert+0x50>
add    $0x1,%rdx
cmp    %edx,%ecx
jg     430 <null_convert+0x30>
add    $0x1,%r12d
add    $0x8,%rsi
cmp    %r13d,%r12d
jne    41f <null_convert+0x1f>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
<<<sep_in_sample>>>
null_convert (j_compress_ptr cinfo,
       JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
       JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  register int ci;
  int nc = cinfo->num_components;
  JDIMENSION num_cols = cinfo->image_width;
  while (--num_rows >= 0) {
    for (ci = 0; ci < nc; ci++) {
      inptr = *input_buf;
      outptr = output_buf[ci][output_row];
      for (col = 0; col < num_cols; col++) {
 outptr[col] = inptr[ci];
 inptr += nc;
      }
    }
    input_buf++;
    output_row++;
  }
}
<<<sep_in_sample>>>
1 4
2 11
3 4
4 4
5 4
6 4
7 9
8 10
9 11
10 11
11 11
12 11
13 12
14 12
15 12
16 12
17 12
18 12
19 14
20 14
21 14
22 14
23 15
24 15
25 15
26 15
27 16
28 16
29 16
30 16
31 15
32 15
33 15
34 12
35 12
36 21
37 20
38 11
39 11
40 23
41 23
42 23
43 23
44 23
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 1c6 <gsl_vector_complex_long_double_set+0x6>
test   %eax,%eax
je     1cf <gsl_vector_complex_long_double_set+0xf>
cmp    %rsi,(%rdi)
jbe    210 <gsl_vector_complex_long_double_set+0x50>
mov    0x8(%rdi),%rax
mov    0x10(%rdi),%rdx
mov    0x8(%rsp),%rcx
shl    $0x5,%rax
imul   %rsi,%rax
mov    %rcx,(%rdx,%rax,1)
mov    0x10(%rsp),%rcx
mov    %rcx,0x8(%rdx,%rax,1)
mov    0x18(%rsp),%rcx
mov    %rcx,0x10(%rdx,%rax,1)
mov    0x20(%rsp),%rcx
mov    %rcx,0x18(%rdx,%rax,1)
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x4,%ecx
mov    $0xd4,%edx
mov    $0x0,%esi
mov    $0x0,%edi
jmpq   229 <gsl_vector_complex_long_double_set+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
gsl_vector_complex_long_double_set (gsl_vector_complex_long_double * v,
                              const size_t i, gsl_complex_long_double z)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_complex_long_double.h", 212, GSL_EINVAL) ; return ; } while (0);
    }
  *((gsl_complex_long_double*)&((v)->data[2*(i)*(v)->stride])) = z;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 8
7 8
8 8
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 6
21 6
22 6
23 6
24 6
25 6
<<<sep_out_sample>>>
test   %rdi,%rdi
jne    28 <gsasl_callback+0x18>
test   %rsi,%rsi
jne    20 <gsasl_callback+0x10>
mov    $0x33,%eax
retq   
mov    (%rsi),%rdi
nopl   0x0(%rax,%rax,1)
mov    0x20(%rdi),%rax
test   %rax,%rax
je     38 <gsasl_callback+0x28>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
jmpq   3d <gsasl_callback+0x2d>
nopl   (%rax)
<<<sep_in_sample>>>
gsasl_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)
{
  if (ctx == ((void *)0) && sctx == ((void *)0))
    return GSASL_NO_CALLBACK;
  if (ctx == ((void *)0))
    ctx = sctx->ctx;
  if (ctx->cb)
    return ctx->cb (ctx, sctx, prop);
  return _gsasl_obsolete_callback (ctx, sctx, prop);
  return GSASL_NO_CALLBACK;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 11
6 11
7 6
8 6
9 7
10 7
11 7
12 8
13 8
14 9
15 9
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
xor    %ebx,%ebx
jmp    772 <skip_past_00+0x12>
nopl   0x0(%rax,%rax,1)
mov    %ebp,%ebx
mov    %r12,%rdi
lea    0x1(%rbx),%ebp
callq  77d <skip_past_00+0x1d>
test   %eax,%eax
jg     770 <skip_past_00+0x10>
mov    %r12,%rdi
add    $0x2,%ebx
callq  78c <skip_past_00+0x2c>
test   %eax,%eax
jg     772 <skip_past_00+0x12>
mov    %ebx,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
skip_past_00 (FILE *input_FILE)
{
  int skipped = 0;
  do
    {
      do
 skipped++;
      while (_IO_getc (input_FILE) > 0);
      skipped++;
    }
  while (_IO_getc (input_FILE) > 0);
  return skipped;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 7
9 8
10 7
11 8
12 8
13 8
14 11
15 9
16 11
17 11
18 11
19 13
20 13
21 13
22 13
23 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    %rdi,%rsi
mov    0x0(%rip),%rdi        # be <dicod_capa_add+0xe>
callq  c3 <dicod_capa_add+0x13>
test   %rax,%rax
je     e0 <dicod_capa_add+0x30>
movl   $0x1,0x20(%rax)
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dicod_capa_add(const char *name)
{
    struct dicod_capa *cp = dico_list_locate(capa_list, (void*)name);
    if (cp == ((void *)0))
 return 1;
    cp->enabled = 1;
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 6
8 7
9 8
10 8
11 8
12 5
13 8
14 8
15 8
<<<sep_out_sample>>>
mov    0xc(%rdi),%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cplob_get_nused(CPLOB * lob)
{
 return lob->nused;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rdi
jmpq   18 <_cmp_capa_name+0x8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_cmp_capa_name(const void *item, void *data)
{
    const struct dicod_capa *cp = item;
    return strcmp(cp->name, (char*)data);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdx,%rdx
mov    %rdi,%rax
je     1d70 <gsl_vector_uchar_const_view_array+0x30>
mov    %rdx,(%rdi)
movq   $0x1,0x8(%rdi)
mov    %rsi,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movl   $0x0,0x20(%rdi)
retq   
nopw   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x1c,%dl
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  1d8f <gsl_vector_uchar_const_view_array+0x4f>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nop
<<<sep_in_sample>>>
gsl_vector_uchar_const_view_array (const unsigned char * base, size_t n)
{
  _gsl_vector_uchar_const_view view = {{0, 0, 0, 0, 0}};
  if (n == 0)
    {
      do { gsl_error ("vector length n must be positive integer",
 "view_source.c"
      ,
 28
      , GSL_EINVAL) ; return view ; } while (0)
                                      ;
    }
  {
    gsl_vector_uchar v = {0, 0, 0, 0, 0};
    v.data = (unsigned char *)base ;
    v.size = n;
    v.stride = 1;
    v.block = 0;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 21
5 21
6 21
7 21
8 21
9 21
10 21
11 2
12 6
13 6
14 6
15 6
16 6
17 6
18 10
19 10
20 10
21 10
22 10
23 10
24 23
25 23
26 23
<<<sep_out_sample>>>
sub    $0x18,%rsp
movsd  %xmm0,(%rsp)
movapd %xmm2,%xmm0
movsd  %xmm1,0x8(%rsp)
callq  78 <gsl_cdf_gumbel1_Q+0x18>
movsd  0x8(%rsp),%xmm1
mulsd  (%rsp),%xmm1
subsd  %xmm0,%xmm1
xorpd  0x0(%rip),%xmm1        # 8f <gsl_cdf_gumbel1_Q+0x2f>
movapd %xmm1,%xmm0
movsd  %xmm1,(%rsp)
callq  9d <gsl_cdf_gumbel1_Q+0x3d>
xorpd  0x0(%rip),%xmm0        # a5 <gsl_cdf_gumbel1_Q+0x45>
callq  aa <gsl_cdf_gumbel1_Q+0x4a>
movsd  0x0(%rip),%xmm2        # b2 <gsl_cdf_gumbel1_Q+0x52>
movsd  (%rsp),%xmm1
ucomisd %xmm0,%xmm2
jbe    d8 <gsl_cdf_gumbel1_Q+0x78>
movsd  0x0(%rip),%xmm1        # c5 <gsl_cdf_gumbel1_Q+0x65>
add    $0x18,%rsp
subsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
retq   
nopw   0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
callq  e1 <gsl_cdf_gumbel1_Q+0x81>
xorpd  0x0(%rip),%xmm0        # e9 <gsl_cdf_gumbel1_Q+0x89>
callq  ee <gsl_cdf_gumbel1_Q+0x8e>
movapd %xmm0,%xmm1
xorpd  0x0(%rip),%xmm1        # fa <gsl_cdf_gumbel1_Q+0x9a>
add    $0x18,%rsp
movapd %xmm1,%xmm0
retq   
<<<sep_in_sample>>>
gsl_cdf_gumbel1_Q (const double x, const double a, const double b)
{
  double u = a * x - log (b);
  double Q;
  double P = exp (-exp (-u));
  if (P < 0.5)
    {
      Q = 1 - P;
    }
  else
    {
      Q = -expm1 (-exp (-u));
    }
  return Q;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 3
6 3
7 3
8 3
9 5
10 5
11 5
12 5
13 5
14 5
15 6
16 6
17 6
18 6
19 8
20 15
21 8
22 15
23 15
24 15
25 12
26 12
27 12
28 12
29 12
30 12
31 15
32 15
33 15
<<<sep_out_sample>>>
push   %r14
mov    %ecx,%r14d
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    0x8(%rdi),%rbp
mov    %rdx,%rbx
test   %rbp,%rbp
je     6ba <topsf_add_fl_entry+0x3a>
mov    %rbp,%rsi
mov    %rdx,%rdi
callq  6a8 <topsf_add_fl_entry+0x28>
test   %rax,%rax
je     6ba <topsf_add_fl_entry+0x3a>
mov    %rbp,%rdi
callq  6b5 <topsf_add_fl_entry+0x35>
lea    -0x1(%rbx,%rax,1),%rbx
mov    %rbx,%rdx
mov    0x10(%r12),%rdi
mov    %r13,%rsi
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
mov    %r14d,%ecx
pop    %r14
jmpq   6d5 <topsf_add_fl_entry+0x55>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
topsf_add_fl_entry(TOPSF * topsf, char * to_name, char * from_name, int source_code)
{
 ;
 ;
 if (topsf->cwd_prefix_) {
  if (!strstr(from_name, topsf->cwd_prefix_)) {
   ;
  } else {
   from_name+=strlen(topsf->cwd_prefix_);
   from_name--;
  }
 }
 ;
 swacfl_add(topsf->swacfl_, to_name, from_name, source_code);
 ;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 5
10 2
11 5
12 5
13 6
14 6
15 6
16 6
17 6
18 9
19 9
20 10
21 14
22 14
23 14
24 16
25 16
26 16
27 16
28 14
29 16
30 14
31 14
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # ddb <pspop_buffer_state+0xb>
test   %rbx,%rbx
je     e27 <pspop_buffer_state+0x57>
mov    0x0(%rip),%rbp        # de7 <pspop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     e27 <pspop_buffer_state+0x57>
callq  df9 <pspop_buffer_state+0x29>
test   %rbp,%rbp
movq   $0x0,(%r12)
je     e27 <pspop_buffer_state+0x57>
sub    $0x1,%rbp
cmpq   $0x0,(%rbx,%rbp,8)
mov    %rbp,0x0(%rip)        # e16 <pspop_buffer_state+0x46>
je     e27 <pspop_buffer_state+0x57>
callq  d0 <ps_load_buffer_state>
movl   $0x1,0x0(%rip)        # e27 <pspop_buffer_state+0x57>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
pspop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 ps_delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  ps_load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 7
14 6
15 7
16 8
17 9
18 8
19 9
20 10
21 11
22 13
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
push   %rbp
mov    %edi,%ebp
push   %rbx
sub    $0x8,%rsp
jmp    1a <nonintr_close+0x1a>
nopw   0x0(%rax,%rax,1)
callq  15 <nonintr_close+0x15>
cmpl   $0x4,(%rax)
jne    27 <nonintr_close+0x27>
mov    %ebp,%edi
callq  21 <nonintr_close+0x21>
test   %eax,%eax
mov    %eax,%ebx
js     10 <nonintr_close+0x10>
add    $0x8,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
<<<sep_in_sample>>>
nonintr_close (int fd)
{
  int retval;
  do
    retval = close (fd);
  while (retval < 0 && (*__errno_location ()) == 4);
  return retval;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 6
10 5
11 5
12 6
13 5
14 6
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rax        # 860 <aliaslookup+0x10>
mov    (%rax),%rbx
test   %rbx,%rbx
jne    879 <aliaslookup+0x29>
jmp    898 <aliaslookup+0x48>
nopw   0x0(%rax,%rax,1)
mov    0x10(%rbx),%rbx
test   %rbx,%rbx
je     898 <aliaslookup+0x48>
mov    (%rbx),%rdi
mov    %rbp,%rsi
callq  884 <aliaslookup+0x34>
test   %eax,%eax
jne    870 <aliaslookup+0x20>
add    $0x8,%rsp
mov    %rbx,%rax
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
aliaslookup(const char *str)
{
  struct wantalias *aliasptr;
  for(aliasptr = firstalias; aliasptr; aliasptr=aliasptr->next)
    if (!strcmp(aliasptr->name, str))
      return aliasptr;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 7
27 8
28 8
29 8
30 8
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%esi
mov    $0x1,%edi
callq  33 <catch_fatal_signals+0x13>
mov    $0x0,%esi
mov    $0x2,%edi
callq  42 <catch_fatal_signals+0x22>
mov    $0x0,%esi
mov    $0xf,%edi
add    $0x8,%rsp
jmpq   55 <catch_fatal_signals+0x35>
<<<sep_in_sample>>>
catch_fatal_signals(void)
{
  signal(1, handle_fatal_signal);
  signal(2, handle_fatal_signal);
  signal(15, handle_fatal_signal);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 4
6 4
7 4
8 5
9 5
10 6
11 5
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  45c <gsl_sf_Shi+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    470 <gsl_sf_Shi+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x81,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  486 <gsl_sf_Shi+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_Shi(const double x)
{
  gsl_sf_result result; int status = gsl_sf_Shi_e(x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_Shi_e(x, &result)", "shint.c", 129, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  12e3 <mu_url_aget_scheme+0x13>
test   %eax,%eax
mov    %eax,%ebx
jne    1307 <mu_url_aget_scheme+0x37>
mov    0x8(%rsp),%rdi
test   %rdi,%rdi
je     1310 <mu_url_aget_scheme+0x40>
callq  12f8 <mu_url_aget_scheme+0x28>
test   %rax,%rax
mov    %rax,0x0(%rbp)
mov    $0xc,%eax
cmove  %eax,%ebx
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
movq   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    %ebx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_url_aget_scheme (mu_url_t url, char **buf) { const char *str; int status = mu_url_sget_scheme (url, &str); if (status) return status; if (str) { *buf = strdup (str); if (!*buf) status = 12; } else *buf = ((void *)0); return status; }
<<<sep_in_sample>>>
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 1
16 1
17 1
18 1
19 1
20 1
21 1
22 1
23 1
24 1
25 1
26 1
27 1
28 1
29 1
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%r12        # a8b <garpd_loop+0xb>
test   %r12,%r12
je     aee <garpd_loop+0x6e>
mov    0x510(%r12),%edx
test   %edx,%edx
jle    ad4 <garpd_loop+0x54>
lea    0x410(%r12),%rbp
xor    %ebx,%ebx
nopw   %cs:0x0(%rax,%rax,1)
movslq 0x0(%rbp),%rax
mov    %r12,%rsi
add    $0x1,%ebx
add    $0x4,%rbp
mov    0x0(,%rax,4),%edi
callq  aca <garpd_loop+0x4a>
cmp    %ebx,0x510(%r12)
jg     ab0 <garpd_loop+0x30>
mov    0x0(%rip),%ecx        # ada <garpd_loop+0x5a>
mov    (%r12),%r12
imul   $0x3e8,%ecx,%edi
callq  ae9 <garpd_loop+0x69>
test   %r12,%r12
jne    a90 <garpd_loop+0x10>
cmpb   $0x2,0x0(%rip)        # af5 <garpd_loop+0x75>
je     b0d <garpd_loop+0x8d>
mov    0x0(%rip),%eax        # afd <garpd_loop+0x7d>
imul   $0x3e8,%eax,%edi
callq  b08 <garpd_loop+0x88>
jmpq   a84 <garpd_loop+0x4>
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
garpd_loop ()
{
  struct map *inf;
  while (1) {
    inf = garpd_list;
    while (inf)
      {
 int i;
 for (i = 0; i < inf->count; i++)
   {
     send_garpd (iface_sock_map[inf->index[i]], inf);
   }
 inf = inf->next;
 usleep (interval_delay * 1000);
      }
    if (mode == 2) return;
    usleep (batch_delay * 1000);
  }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 5
5 6
6 6
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 11
15 9
16 9
17 11
18 11
19 9
20 9
21 14
22 13
23 14
24 14
25 6
26 6
27 16
28 16
29 17
30 17
31 17
32 18
33 19
34 19
35 19
36 19
<<<sep_out_sample>>>
mov    (%rdi),%r8
mov    0x8(%rdi),%rdx
mov    0x10(%rdi),%rax
test   %r8,%r8
je     e4b <gsl_matrix_float_ispos+0x4b>
xorps  %xmm0,%xmm0
lea    0x0(,%rax,4),%r10
xor    %esi,%esi
xor    %r9d,%r9d
test   %rdx,%rdx
je     e3f <gsl_matrix_float_ispos+0x3f>
mov    %rsi,%rcx
add    0x18(%rdi),%rcx
xor    %eax,%eax
xchg   %ax,%ax
ucomiss (%rcx,%rax,4),%xmm0
jae    e51 <gsl_matrix_float_ispos+0x51>
add    $0x1,%rax
cmp    %rdx,%rax
jne    e30 <gsl_matrix_float_ispos+0x30>
add    $0x1,%r9
add    %r10,%rsi
cmp    %r8,%r9
jne    e20 <gsl_matrix_float_ispos+0x20>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_ispos (const gsl_matrix_float * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] <= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 9
19 9
20 9
21 7
22 7
23 7
24 7
25 20
26 21
27 15
28 15
29 15
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm1        # 2598 <sinh_func+0x8>
movapd %xmm0,%xmm2
mulsd  %xmm0,%xmm1
mulsd  %xmm0,%xmm1
movsd  0x0(%rip),%xmm0        # 25ac <sinh_func+0x1c>
subsd  %xmm1,%xmm0
movsd  0x0(%rip),%xmm1        # 25b8 <sinh_func+0x28>
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm1
addsd  %xmm1,%xmm0
retq   
nopl   (%rax)
<<<sep_in_sample>>>
sinh_func (double x)
{
  return 1.0 - (7.0/60.0)*x*x + (31.0/2520.0)*x*x*x*x;
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 3
13 4
14 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  79 <mt_lseek+0x9>
add    $0x8,%rsp
sar    $0x3f,%rax
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mt_lseek(int fd, mt_off_t where, int whence)
{
 if(lseek64(fd, where, whence) >= 0)
  return 0;
 else
  return -1;
}
<<<sep_in_sample>>>
1 2
2 3
3 7
4 3
5 7
6 7
<<<sep_out_sample>>>
push   %rbp
mov    $0x8,%edx
mov    $0x0,%ecx
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  ab <xdr_simx_entity_type_attr+0x1b>
xor    %edx,%edx
test   %eax,%eax
je     c8 <xdr_simx_entity_type_attr+0x38>
lea    0x8(%rbp),%rsi
mov    $0x100,%dx
mov    %rbx,%rdi
callq  c1 <xdr_simx_entity_type_attr+0x31>
xor    %edx,%edx
test   %eax,%eax
setne  %dl
add    $0x8,%rsp
mov    %edx,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xdr_simx_entity_type_attr (XDR *xdrs, simx_entity_type_attr *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->type, sizeof (dis_entity_type), (xdrproc_t) xdr_dis_entity_type))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->attr, 256))
		 return FALSE;
	return TRUE;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 2
7 2
8 5
9 6
10 5
11 5
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 10
20 10
21 10
22 10
23 10
24 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x0,%edi
callq  49e <killed+0xe>
mov    0x0(%rip),%edi        # 4a4 <killed+0x14>
mov    $0x2,%esi
callq  4ae <killed+0x1e>
mov    0x0(%rip),%edi        # 4b4 <killed+0x24>
callq  4b9 <killed+0x29>
callq  4be <killed+0x2e>
xor    %edi,%edi
callq  4c5 <killed+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
killed(int i)
{
 printf("\ninterrupt\n");
 shutdown(listen_socket, 2);
 close(listen_socket);
 dis_close();
 exit(0);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 5
9 6
10 7
11 7
12 7
<<<sep_out_sample>>>
push   %rbx
sub    $0x20,%rsp
mov    0x0(%rip),%rdi        # 34c <gsl_odeiv2_control_standard_new+0xc>
movsd  %xmm0,0x18(%rsp)
movsd  %xmm1,0x10(%rsp)
movsd  %xmm2,0x8(%rsp)
movsd  %xmm3,(%rsp)
callq  368 <gsl_odeiv2_control_standard_new+0x28>
movsd  (%rsp),%xmm3
mov    %rax,%rdi
movsd  0x8(%rsp),%xmm2
mov    %rax,%rbx
movsd  0x10(%rsp),%xmm1
movsd  0x18(%rsp),%xmm0
callq  38a <gsl_odeiv2_control_standard_new+0x4a>
test   %eax,%eax
mov    %rbx,%rdi
jne    3a0 <gsl_odeiv2_control_standard_new+0x60>
add    $0x20,%rsp
mov    %rdi,%rax
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,(%rsp)
callq  3a8 <gsl_odeiv2_control_standard_new+0x68>
mov    (%rsp),%eax
mov    $0x0,%edi
mov    $0xc7,%edx
mov    $0x0,%esi
mov    %eax,%ecx
callq  3c1 <gsl_odeiv2_control_standard_new+0x81>
xor    %edi,%edi
jmp    391 <gsl_odeiv2_control_standard_new+0x51>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_odeiv2_control_standard_new (double eps_abs, double eps_rel,
                                 double a_y, double a_dydt)
{
  gsl_odeiv2_control *c =
    gsl_odeiv2_control_alloc (gsl_odeiv2_control_standard);
  int status = gsl_odeiv2_control_init (c, eps_abs, eps_rel, a_y, a_dydt);
  if (status != GSL_SUCCESS)
    {
      gsl_odeiv2_control_free (c);
      do { gsl_error ("error trying to initialize control", "cstd.c", 199, status) ; return 0 ; } while (0);
    }
  return c;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 3
5 3
6 3
7 3
8 4
9 6
10 6
11 6
12 4
13 6
14 6
15 6
16 7
17 12
18 7
19 13
20 13
21 13
22 13
23 13
24 13
25 9
26 10
27 10
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %al
cmp    $0x20,%edi
sete   %dl
or     %edx,%eax
retq   
nop
<<<sep_in_sample>>>
c_isblank (int c)
{
  return c == ' ' || c == '\t';
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 4
7 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    $0x0,%ebp
push   %rbx
mov    $0x0,%ebx
jmp    38e <locate_handler+0x3e>
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  370 <locate_handler+0x20>
mov    %r12,%rsi
mov    %rax,%rdx
mov    %rbp,%rdi
callq  37e <locate_handler+0x2e>
test   %eax,%eax
je     3a3 <locate_handler+0x53>
add    $0x20,%rbx
mov    (%rbx),%rbp
test   %rbp,%rbp
je     3b0 <locate_handler+0x60>
cmpb   $0x0,0x1c(%rbx)
jne    368 <locate_handler+0x18>
mov    %r12,%rsi
mov    %rbp,%rdi
callq  39f <locate_handler+0x4f>
test   %eax,%eax
jne    382 <locate_handler+0x32>
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
pop    %rbx
pop    %rbp
xor    %eax,%eax
pop    %r12
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
locate_handler (char const *keyword)
{
  struct xhdr_tab const *p;
  for (p = xhdr_tab; p->keyword; p++)
    if (p->prefix)
      {
        if (strncmp (p->keyword, keyword, strlen(p->keyword)) == 0)
          return p;
      }
    else
      {
        if (strcmp (p->keyword, keyword) == 0)
          return p;
      }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 2
6 4
7 4
8 4
9 7
10 7
11 7
12 7
13 7
14 7
15 7
16 7
17 4
18 4
19 4
20 4
21 5
22 5
23 12
24 12
25 12
26 12
27 12
28 12
29 16
30 16
31 16
32 16
33 16
34 16
35 16
36 15
37 16
38 16
39 16
<<<sep_out_sample>>>
cmp    $0x1,%edi
ja     4d <system_quote+0xd>
mov    %rsi,%rdi
jmpq   4d <system_quote+0xd>
push   %rax
callq  53 <system_quote+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
system_quote (enum system_command_interpreter interpreter,
              const char *string)
{
  switch (interpreter)
    {
    case SCI_SYSTEM:
    case SCI_POSIX_SH:
      return shell_quote (string);
    default:
      abort ();
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 8
4 8
5 3
6 10
7 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rsi),%rcx
cmp    (%rdi),%rcx
je     ba0 <gsl_permute_vector_inverse+0x30>
mov    $0x13,%ecx
mov    $0x9d,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  b95 <gsl_permute_vector_inverse+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  bb1 <gsl_permute_vector_inverse+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_vector_inverse (const gsl_permutation * p, gsl_vector * v)
{
  if (v->size != p->size)
    {
      do { gsl_error ("vector and permutation must be the same length", "permute_source.c", 157, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_permute_inverse (p->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  11e9 <swlib_squash_all_dot_slash+0x9>
jmp    11f8 <swlib_squash_all_dot_slash+0x18>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%rdi
callq  11f8 <swlib_squash_all_dot_slash+0x18>
mov    $0x0,%esi
mov    %rbx,%rdi
callq  1205 <swlib_squash_all_dot_slash+0x25>
test   %rax,%rax
jne    11f0 <swlib_squash_all_dot_slash+0x10>
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
swlib_squash_all_dot_slash(char *path)
{
 char * s;
 swlib_squash_leading_dot_slash(path);
 s = strstr(path, "/./");
 while(s) {
  swlib_squash_embedded_dot_slash(path);
  s = strstr(path, "/./");
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 7
7 7
8 5
9 5
10 5
11 6
12 6
13 10
14 10
15 10
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
test   %rsi,%rsi
je     70 <gss_get_mic+0x70>
mov    (%rsi),%rdi
mov    %r8,0x8(%rsp)
mov    %edx,%r12d
mov    %rcx,%r13
callq  28 <gss_get_mic+0x28>
test   %rax,%rax
mov    0x8(%rsp),%r8
je     50 <gss_get_mic+0x50>
mov    0x70(%rax),%rax
add    $0x18,%rsp
mov    %rbx,%rsi
pop    %rbx
mov    %rbp,%rdi
mov    %r12d,%edx
mov    %r13,%rcx
pop    %rbp
pop    %r12
pop    %r13
jmpq   *%rax
xchg   %ax,%ax
test   %rbp,%rbp
je     90 <gss_get_mic+0x90>
movl   $0x0,0x0(%rbp)
add    $0x18,%rsp
mov    $0x10000,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax)
test   %rdi,%rdi
je     a0 <gss_get_mic+0xa0>
movl   $0x0,(%rdi)
mov    $0x80000,%eax
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x10000,%eax
jmp    80 <gss_get_mic+0x80>
nopw   0x0(%rax,%rax,1)
mov    $0x80000,%eax
jmp    80 <gss_get_mic+0x80>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_get_mic (OM_uint32 * minor_status,
      const gss_ctx_id_t context_handle,
      gss_qop_t qop_req,
      const gss_buffer_t message_buffer, gss_buffer_t message_token)
{
  _gss_mech_api_t mech;
  if (!context_handle)
    {
      if (minor_status)
 *minor_status = 0;
      return (8ul << 16);
    }
  mech = _gss_find_mech (context_handle->mech);
  if (mech == ((void *)0))
    {
      if (minor_status)
 *minor_status = 0;
      return (1ul << 16);
    }
  return mech->get_mic (minor_status, context_handle, qop_req,
   message_buffer, message_token);
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 5
8 7
9 7
10 13
11 13
12 13
13 13
14 13
15 14
16 14
17 14
18 20
19 22
20 20
21 22
22 20
23 20
24 20
25 22
26 22
27 22
28 20
29 20
30 16
31 16
32 17
33 22
34 18
35 22
36 22
37 22
38 22
39 22
40 22
41 9
42 9
43 10
44 11
45 22
46 22
47 22
48 22
49 22
50 22
51 22
52 18
53 18
54 18
55 11
56 11
57 11
<<<sep_out_sample>>>
sub    $0x48,%rsp
mov    $0x2b,%edx
mov    %rsp,%rsi
mov    %fs:0x28,%rax
mov    %rax,0x38(%rsp)
xor    %eax,%eax
callq  a51 <cachedir_file_p+0x21>
xor    %edx,%edx
cmp    $0x2b,%rax
je     a70 <cachedir_file_p+0x40>
mov    0x38(%rsp),%rcx
xor    %fs:0x28,%rcx
mov    %edx,%eax
jne    a89 <cachedir_file_p+0x59>
add    $0x48,%rsp
retq   
mov    $0x2b,%edx
mov    $0x0,%esi
mov    %rsp,%rdi
callq  a82 <cachedir_file_p+0x52>
test   %eax,%eax
sete   %dl
jmp    a59 <cachedir_file_p+0x29>
callq  a8e <cachedir_file_p+0x5e>
xchg   %ax,%ax
<<<sep_in_sample>>>
cachedir_file_p (int fd)
{
  char tagbuf[(sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)];
  return
    (read (fd, tagbuf, (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)) == (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)
     && memcmp (tagbuf, "Signature: 8a477f597d28d172789f06886806bc55", (sizeof "Signature: 8a477f597d28d172789f06886806bc55" - 1)) == 0);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 2
5 2
6 2
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 7
25 7
<<<sep_out_sample>>>
jmpq   775 <gsl_eigen_genhermv_sort+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_eigen_genhermv_sort (gsl_vector * eval, gsl_matrix_complex * evec,
                         gsl_eigen_sort_t sort_type)
{
  int s;
  s = gsl_eigen_hermv_sort(eval, evec, sort_type);
  return s;
}
<<<sep_in_sample>>>
1 5
2 5
<<<sep_out_sample>>>
push   %rbx
mov    0x0(%rip),%rbx        # 1f58 <doViews+0x8>
test   %rbx,%rbx
je     1f75 <doViews+0x25>
nopl   (%rax)
mov    0x20(%rbx),%rdi
mov    %rbx,%rsi
callq  1f6c <doViews+0x1c>
mov    0x10(%rbx),%rbx
test   %rbx,%rbx
jne    1f60 <doViews+0x10>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
doViews(void)
{
 viewer *u;
 for (u = vl_head; u != ((void *)0); u=u->vl_next ) {
  renderCockpitView( u->c, u );
 }
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 4
10 4
11 4
12 7
13 7
14 7
<<<sep_out_sample>>>
xor    %eax,%eax
cmpl   $0xfffffffe,0x8(%rdi)
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
isNotFound(direntry_t *entry)
{
 return entry->entry == -2;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1877 <asm_get_leng+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
asm_get_leng (void)
{
        return asm_leng;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%r9
mov    0x8(%rdi),%r8
mov    0x10(%rdi),%r11
test   %r9,%r9
je     1ff2 <gsl_matrix_char_isneg+0x52>
xorpd  %xmm1,%xmm1
xor    %esi,%esi
xor    %r10d,%r10d
test   %r8,%r8
je     1fe6 <gsl_matrix_char_isneg+0x46>
mov    0x18(%rdi),%rdx
lea    (%rdx,%rsi,1),%rax
add    %r8,%rdx
add    %rsi,%rdx
nopl   0x0(%rax)
movsbl (%rax),%ecx
cvtsi2sd %ecx,%xmm0
ucomisd %xmm1,%xmm0
jae    1ff8 <gsl_matrix_char_isneg+0x58>
add    $0x1,%rax
cmp    %rdx,%rax
jne    1fd0 <gsl_matrix_char_isneg+0x30>
add    $0x1,%r10
add    %r11,%rsi
cmp    %r9,%r10
jne    1fb9 <gsl_matrix_char_isneg+0x19>
mov    $0x1,%eax
retq   
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_char_isneg (const gsl_matrix_char * m)
{
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda ;
  size_t i, j, k;
  for (i = 0; i < size1 ; i++)
    {
      for (j = 0; j < size2; j++)
        {
          for (k = 0; k < 1; k++)
            {
              if (m->data[(i * tda + j) * 1 + k] >= 0.0)
                {
                  return 0;
                }
            }
        }
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 7
5 7
6 7
7 7
8 7
9 9
10 9
11 9
12 9
13 9
14 9
15 9
16 13
17 13
18 13
19 13
20 13
21 9
22 9
23 7
24 7
25 7
26 7
27 20
28 21
29 15
30 15
31 15
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x10,%esi
push   %rbx
mov    %rdi,%rbx
mov    $0x1,%edi
sub    $0x8,%rsp
callq  7b <list_append+0x1b>
mov    0x8(%rbx),%rdx
mov    %rbp,0x8(%rax)
test   %rdx,%rdx
je     a0 <list_append+0x40>
mov    %rax,(%rdx)
mov    %rax,0x8(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rax,0x8(%rbx)
mov    %rax,(%rbx)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
list_append (list, data)
     List *list;
     void *data;
{
  ListItem *item;
  item = (ListItem *) xcalloc (1, sizeof (*item));
  item->data = data;
  if (list->tail)
    list->tail->next = item;
  else
    list->head = item;
  list->tail = item;
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 4
5 4
6 6
7 4
8 6
9 8
10 7
11 8
12 8
13 9
14 12
15 13
16 13
17 13
18 13
19 13
20 12
21 11
22 13
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
mov    %edi,%eax
and    $0x7f,%eax
add    $0x1,%eax
cmp    $0x1,%al
jle    960 <process_exit_status+0x20>
and    $0x7f,%edi
lea    0x80(%rdi),%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
mov    %rdi,%rax
cmp    $0x7f,%dil
movzbl %ah,%edx
mov    $0x0,%eax
cmovne %edx,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
process_exit_status (status)
     WAIT status;
{
  if ((((signed char) ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) + 1) >> 1) > 0))
    return (128 + (((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f));
  else if (((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0xff) == 0x7f) == 0)
    return (((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0xff00) >> 8));
  else
    return (0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 5
7 5
8 5
9 5
10 7
11 6
12 7
13 7
14 7
15 10
16 10
<<<sep_out_sample>>>
push   %r12
mov    %esi,%r12d
mov    %edx,%esi
mov    %r12d,%edi
push   %rbp
push   %rbx
callq  c1 <etar_emit_data_from_fd+0x11>
test   %eax,%eax
mov    %eax,%ebx
js     11d <etar_emit_data_from_fd+0x6d>
and    $0x1ff,%eax
jne    e0 <etar_emit_data_from_fd+0x30>
xor    %ebp,%ebp
lea    (%rbx,%rbp,1),%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
test   %ebx,%ebx
je     ce <etar_emit_data_from_fd+0x1e>
mov    $0x200,%ebp
mov    %r12d,%edi
sub    %eax,%ebp
mov    %ebp,%esi
callq  f5 <etar_emit_data_from_fd+0x45>
test   %eax,%eax
jns    d0 <etar_emit_data_from_fd+0x20>
callq  fe <etar_emit_data_from_fd+0x4e>
mov    0x0(%rip),%rdi        # 105 <etar_emit_data_from_fd+0x55>
mov    %rax,%rdx
mov    %ebx,%ecx
mov    $0x0,%esi
xor    %eax,%eax
callq  116 <etar_emit_data_from_fd+0x66>
mov    $0xfffffffe,%eax
jmp    d3 <etar_emit_data_from_fd+0x23>
callq  122 <etar_emit_data_from_fd+0x72>
mov    0x0(%rip),%rdi        # 129 <etar_emit_data_from_fd+0x79>
mov    %rax,%rdx
mov    %ebx,%ecx
mov    $0x0,%esi
xor    %eax,%eax
callq  13a <etar_emit_data_from_fd+0x8a>
mov    $0xffffffff,%eax
jmp    d3 <etar_emit_data_from_fd+0x23>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
etar_emit_data_from_fd(ETAR * etar, int ofd, int ifd)
{
 int ret;
 int ret1;
 int remains;
 ret = swlib_pipe_pump(ofd, ifd);
 if (ret < 0) {
  fprintf(stderr, "%s: etar_emit_data_from_fd(): loc=1: ret = %d\n",
   swlib_utilname_get(), ret);
  return -1;
 }
 remains = ret % 512;
 if (ret && remains > 0) {
  remains = 512 - remains;
  ret1 = swlib_pad_amount(ofd, remains);
  if (ret1 < 0) {
   fprintf(stderr, "%s: etar_emit_data_from_fd(): loc=2: ret = %d\n",
    swlib_utilname_get(), ret);
   return -2;
  }
 } else {
  remains = 0;
 }
 return ret + remains;
}
<<<sep_in_sample>>>
1 2
2 2
3 6
4 6
5 2
6 2
7 6
8 7
9 6
10 7
11 13
12 13
13 22
14 24
15 25
16 25
17 25
18 25
19 25
20 13
21 13
22 14
23 15
24 14
25 15
26 15
27 16
28 16
29 17
30 17
31 17
32 17
33 17
34 17
35 17
36 19
37 19
38 8
39 8
40 8
41 8
42 8
43 8
44 8
45 10
46 10
47 10
<<<sep_out_sample>>>
mov    %rsi,%rdi
mov    %rdx,%rsi
mov    $0x0,%edx
jmpq   27e0 <insert_depthspec.isra.10>
<<<sep_in_sample>>>
parse_mindepth (const struct parser_table* entry, char **argv, int *arg_ptr)
{
  return insert_depthspec (entry, argv, arg_ptr, &options.mindepth);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
callq  6a0 <net_create_stream+0x10>
mov    (%rbx),%rdi
movslq %ebp,%rsi
movq   $0x0,(%rsp)
xor    %r9d,%r9d
xor    %r8d,%r8d
xor    %ecx,%ecx
xor    %edx,%edx
callq  6bd <net_create_stream+0x2d>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
net_create_stream (NET_STREAM * str, int fd)
{
  stream_create (str);
  stream_set_io (*str, (void *) fd, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0));
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 5
16 5
17 5
18 5
19 5
<<<sep_out_sample>>>
jmpq   440 <g_ucs4_to_utf8>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stringprep_ucs4_to_utf8 (const uint32_t * str, ssize_t len,
    size_t * items_read, size_t * items_written)
{
  return g_ucs4_to_utf8 (str, len, (long *) items_read,
    (long *) items_written);
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    2aa8 <gsl_matrix_int_column+0x38>
mov    0x18(%rsi),%rcx
mov    0x10(%rsi),%rdi
movl   $0x0,0x20(%rax)
lea    (%rcx,%rdx,4),%rcx
mov    0x20(%rsi),%rdx
mov    (%rsi),%rsi
mov    %rdi,0x8(%rax)
mov    %rcx,0x10(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  2aca <gsl_matrix_int_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_int_column (gsl_matrix_int * m, const size_t j)
{
  _gsl_vector_int_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_int v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 16
7 10
8 13
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
mov    0x60(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_size (gl_list_t list)
{
  return list->count;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %rbx
sub    $0xd0,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     acc <fatal+0x5c>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
mov    %rdi,%rbx
mov    $0x0,%esi
xor    %eax,%eax
mov    0x0(%rip),%rdx        # add <fatal+0x6d>
mov    0x0(%rip),%rdi        # ae4 <fatal+0x74>
callq  ae9 <fatal+0x79>
lea    0xe0(%rsp),%rax
mov    0x0(%rip),%rdi        # af8 <fatal+0x88>
lea    0x8(%rsp),%rdx
mov    %rbx,%rsi
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
mov    %rax,0x18(%rsp)
callq  b24 <fatal+0xb4>
mov    0x0(%rip),%rsi        # b2b <fatal+0xbb>
mov    $0xa,%edi
callq  b35 <fatal+0xc5>
mov    0x0(%rip),%rdi        # b3c <fatal+0xcc>
callq  b41 <fatal+0xd1>
xor    %edi,%edi
callq  b48 <fatal+0xd8>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
fatal (char const *format, ...)
{
  va_list args;
  fprintf (stderr, "%s: **** ", program_name);
  __builtin_va_start(args,format);
  vfprintf (stderr, format, args);
  __builtin_va_end(args);
  _IO_putc ('\n', stderr);
  fflush (stderr);
  fatal_exit (0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 2
18 2
19 4
20 4
21 4
22 4
23 4
24 5
25 6
26 6
27 6
28 5
29 5
30 5
31 5
32 5
33 6
34 8
35 8
36 8
37 9
38 9
39 10
40 10
41 10
<<<sep_out_sample>>>
test   %esi,%esi
jle    ad8 <lm_will+0x68>
sub    $0x8,%rsp
movb   $0xfe,0x0(%rip)        # a7f <lm_will+0xf>
movzbl (%rdi),%eax
mov    $0x0,%edi
mov    %al,0x0(%rip)        # a8d <lm_will+0x1d>
callq  a92 <lm_will+0x22>
cmp    $0x7,%eax
jg     aa8 <lm_will+0x38>
mov    $0x0,%edi
add    $0x8,%rsp
jmpq   aa5 <lm_will+0x35>
nopl   (%rax)
mov    $0x7,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  abc <lm_will+0x4c>
mov    $0x5,%edx
mov    $0x0,%esi
mov    $0x3e,%edi
add    $0x8,%rsp
jmpq   ad4 <lm_will+0x64>
nopl   0x0(%rax)
mov    $0x0,%edi
jmpq   ae2 <lm_will+0x72>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lm_will (unsigned char *cmd, int len)
{
  if (len < 1)
    {
             printf ("lm_will: no command!!!\n");
      return;
    }
  switch (cmd[0])
    {
    case 2:
    default:
      str_lm[3] = 254;
      str_lm[4] = cmd[0];
      if ((ring_empty_count(&netoring)) > (int) sizeof (str_lm))
 {
   ring_supply_data (&netoring, str_lm, sizeof (str_lm));
   printsub ('>', &str_lm[2], sizeof (str_lm) - 2);
 }
      else
 printf ("lm_will: not enough room in buffer\n");
      break;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 2
4 12
5 13
6 14
7 13
8 14
9 14
10 14
11 20
12 23
13 20
14 20
15 16
16 16
17 16
18 16
19 17
20 17
21 17
22 23
23 17
24 17
25 5
26 5
27 5
<<<sep_out_sample>>>
mov    %rdi,%rax
mov    %rsi,%rdx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
make_timespec (time_t s, long int ns)
{
  struct timespec r;
  r.tv_sec = s;
  r.tv_nsec = ns;
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 7
4 7
<<<sep_out_sample>>>
movapd %xmm0,%xmm2
movsd  0x0(%rip),%xmm0        # c <xhypot+0xc>
andpd  %xmm0,%xmm2
andpd  %xmm0,%xmm1
ucomisd %xmm2,%xmm1
jbe    26 <xhypot+0x26>
movapd %xmm1,%xmm0
movapd %xmm2,%xmm1
movapd %xmm0,%xmm2
ucomisd 0x0(%rip),%xmm1        # 2e <xhypot+0x2e>
jp     40 <xhypot+0x40>
movapd %xmm2,%xmm0
jne    40 <xhypot+0x40>
repz retq 
nopl   0x0(%rax,%rax,1)
divsd  %xmm2,%xmm1
mulsd  %xmm1,%xmm1
addsd  0x0(%rip),%xmm1        # 50 <xhypot+0x50>
sqrtsd %xmm1,%xmm0
ucomisd %xmm0,%xmm0
jp     5f <xhypot+0x5f>
mulsd  %xmm2,%xmm0
retq   
movapd %xmm1,%xmm0
sub    $0x18,%rsp
movsd  %xmm2,0x8(%rsp)
callq  72 <xhypot+0x72>
movsd  0x8(%rsp),%xmm2
add    $0x18,%rsp
mulsd  %xmm2,%xmm0
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xhypot (const double x, const double y)
{
  double xabs = fabs(x) ;
  double yabs = fabs(y) ;
  double min, max;
  if (xabs < yabs) {
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
    max = xabs ;
  }
  if (min == 0)
    {
      return max ;
    }
  {
    double u = min / max ;
    return max * sqrt (1 + u * u) ;
  }
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 6
6 6
7 6
8 7
9 8
10 13
11 13
12 15
13 13
14 21
15 21
16 18
17 19
18 19
19 19
20 19
21 19
22 19
23 21
24 19
25 2
26 2
27 19
28 19
29 21
30 19
31 21
32 21
<<<sep_out_sample>>>
lea    -0x41(%rdi),%edx
lea    0x20(%rdi),%eax
cmp    $0x19,%edx
cmova  %edi,%eax
retq   
nopl   (%rax)
<<<sep_in_sample>>>
c_tolower (int c)
{
  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
user_access (void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
mov    0x18(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_get_type_reg (rec_rset_t rset)
{
  return rset->type_reg;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x20,%rsp
mov    0x18(%rdi),%rdi
callq  5f7 <message_remove_headers+0x17>
mov    %rax,%rdi
mov    %rax,0x10(%rsp)
callq  604 <message_remove_headers+0x24>
test   %rax,%rax
mov    %rax,%rbx
jne    62a <message_remove_headers+0x4a>
jmp    678 <message_remove_headers+0x98>
xchg   %ax,%ax
mov    0xc(%rsp),%eax
test   %eax,%eax
jne    662 <message_remove_headers+0x82>
mov    0x10(%rsp),%rdi
callq  622 <message_remove_headers+0x42>
test   %rax,%rax
mov    %rax,%rbx
je     678 <message_remove_headers+0x98>
mov    (%rbx),%rsi
lea    0x18(%rsp),%rcx
lea    0xc(%rsp),%rdx
mov    %rbp,%rdi
callq  63f <message_remove_headers+0x5f>
test   %eax,%eax
je     610 <message_remove_headers+0x30>
mov    0x18(%r12),%rdi
xor    %edx,%edx
mov    %rbx,%rsi
callq  652 <message_remove_headers+0x72>
mov    %rbx,%rdi
callq  65a <message_remove_headers+0x7a>
mov    0xc(%rsp),%eax
test   %eax,%eax
je     618 <message_remove_headers+0x38>
mov    0x18(%rsp),%rsi
mov    $0xffffffff,%edi
callq  671 <message_remove_headers+0x91>
jmp    618 <message_remove_headers+0x38>
nopl   0x0(%rax,%rax,1)
lea    0x10(%rsp),%rdi
callq  682 <message_remove_headers+0xa2>
add    $0x20,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
message_remove_headers (MESSAGE msg, RC_REGEX *regex)
{
  ASSOC *asc;
  ITERATOR itr;
  itr = iterator_create (msg->header);
  for (asc = iterator_first (itr); asc; asc = iterator_next (itr))
    {
      char **rv;
      int rc;
      if (anubis_regex_match (regex, asc->key, &rc, &rv))
 {
   list_remove (msg->header, asc, ((void *)0));
   assoc_free (asc);
 }
      if (rc)
 argcv_free (-1, rv);
    }
  iterator_destroy (&itr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 5
8 5
9 6
10 5
11 6
12 6
13 6
14 6
15 6
16 6
17 15
18 15
19 15
20 6
21 6
22 6
23 6
24 6
25 10
26 10
27 10
28 10
29 10
30 10
31 10
32 12
33 12
34 12
35 12
36 13
37 13
38 15
39 15
40 15
41 16
42 16
43 16
44 16
45 16
46 18
47 18
48 19
49 19
50 19
51 19
52 19
53 19
<<<sep_out_sample>>>
sub    $0x8,%rsp
jmp    345 <rl_digit_loop+0x35>
nopw   %cs:0x0(%rax,%rax,1)
callq  325 <rl_digit_loop+0x15>
test   %eax,%eax
js     360 <rl_digit_loop+0x50>
mov    0x0(%rip),%edi        # 32f <rl_digit_loop+0x1f>
mov    %eax,%esi
xor    %eax,%eax
callq  338 <rl_digit_loop+0x28>
test   %eax,%eax
jle    353 <rl_digit_loop+0x43>
testb  $0x4,0x0(%rip)        # 343 <rl_digit_loop+0x33>
je     353 <rl_digit_loop+0x43>
callq  34a <rl_digit_loop+0x3a>
test   %eax,%eax
je     320 <rl_digit_loop+0x10>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
callq  365 <rl_digit_loop+0x55>
mov    $0xffffffff,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
rl_digit_loop ()
{
  int c, r;
  while (1)
    {
      if (_rl_arg_overflow ())
 return 1;
      c = _rl_arg_getchar ();
      if (c < 0)
 {
   _rl_abort_internal ();
   return -1;
 }
      r = _rl_arg_dispatch (_rl_argcxt, c);
      if (r <= 0 || ((rl_readline_state & (0x0000400)) == 0))
        break;
    }
  return r;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 8
5 9
6 9
7 14
8 14
9 14
10 14
11 15
12 15
13 15
14 15
15 6
16 6
17 6
18 7
19 19
20 19
21 19
22 11
23 12
24 19
25 19
26 19
<<<sep_out_sample>>>
push   %r15
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x18,%rsp
mov    0x8(%rsi),%r12
mov    0x10(%rsi),%r15
mov    (%rsi),%r13
cmp    %r12,%r15
je     5d1 <gsl_matrix_complex_fscanf+0x91>
shl    $0x4,%r15
xor    %ebx,%ebx
mov    %r15,0x8(%rsp)
xor    %r15d,%r15d
test   %r13,%r13
jne    58e <gsl_matrix_complex_fscanf+0x4e>
jmp    5c0 <gsl_matrix_complex_fscanf+0x80>
nopl   0x0(%rax)
add    $0x1,%r15
add    0x8(%rsp),%rbx
cmp    %r13,%r15
je     5c0 <gsl_matrix_complex_fscanf+0x80>
mov    %rbx,%rsi
add    0x18(%rbp),%rsi
mov    $0x1,%ecx
mov    %r12,%rdx
mov    %r14,%rdi
callq  5a5 <gsl_matrix_complex_fscanf+0x65>
test   %eax,%eax
je     580 <gsl_matrix_complex_fscanf+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   0x0(%rax,%rax,1)
add    $0x18,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    0x18(%rsi),%rsi
add    $0x18,%rsp
mov    %r15,%rdx
pop    %rbx
pop    %rbp
pop    %r12
imul   %r13,%rdx
mov    $0x1,%ecx
pop    %r13
pop    %r14
pop    %r15
jmpq   5f4 <gsl_matrix_complex_fscanf+0xb4>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_fscanf (FILE * stream, gsl_matrix_complex * m)
{
  int status = 0;
  const size_t size1 = m->size1;
  const size_t size2 = m->size2;
  const size_t tda = m->tda;
  if (tda == size2)
    {
      status = gsl_block_complex_raw_fscanf (stream,
                                                 m->data,
                                                 size1 * size2, 1);
    }
  else
    {
      size_t i;
      for (i = 0 ; i < size1 ; i++)
        {
          status = gsl_block_complex_raw_fscanf (stream,
                                                     m->data + i * 2 * tda,
                                                     size2, 1);
          if (status)
            break;
        }
    }
  return status;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 5
11 6
12 4
13 7
14 7
15 7
16 16
17 16
18 16
19 16
20 16
21 16
22 16
23 16
24 16
25 16
26 16
27 18
28 18
29 18
30 18
31 18
32 18
33 21
34 21
35 26
36 26
37 26
38 26
39 26
40 26
41 26
42 26
43 26
44 26
45 16
46 26
47 26
48 26
49 26
50 26
51 26
52 26
53 9
54 26
55 9
56 26
57 26
58 26
59 9
60 9
61 26
62 26
63 26
64 9
65 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rsi        # 2997 <parser_reinit+0x7>
cmp    0x0(%rip),%rsi        # 299e <parser_reinit+0xe>
jbe    29a9 <parser_reinit+0x19>
cmp    0x0(%rip),%rsi        # 29a7 <parser_reinit+0x17>
jb     29b8 <parser_reinit+0x28>
mov    $0x0,%edi
jmpq   29b3 <parser_reinit+0x23>
nopl   0x0(%rax,%rax,1)
mov    %rsi,0x0(%rip)        # 29bf <parser_reinit+0x2f>
mov    %rsi,0x0(%rip)        # 29c6 <parser_reinit+0x36>
retq   
<<<sep_in_sample>>>
parser_reinit (void)
{
  __extension__ ({ struct obstack *__o = (&os_block); void *__obj = (first_object_allocated_ptr_block); if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit) __o->next_free = __o->object_base = __obj; else (obstack_free) (__o, __obj); });
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
<<<sep_out_sample>>>
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
initdiffcmd (register struct diffcmd *dc)
{
  dc->adprev = 0;
  dc->dafter = 0;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1847 <show_sys_info_p+0x7>
test   %rdi,%rdi
je     1860 <show_sys_info_p+0x20>
mov    $0x1,%esi
jmpq   1856 <show_sys_info_p+0x16>
nopw   %cs:0x0(%rax,%rax,1)
mov    $0x1,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
show_sys_info_p()
{
    if (!show_sys_info)
 return 1;
    return dicod_acl_check(show_sys_info, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 5
7 6
8 6
9 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
movsbl (%rdi),%edi
test   %dil,%dil
je     314 <osip_tolower+0x24>
nopl   0x0(%rax)
callq  305 <osip_tolower+0x15>
add    $0x1,%rbx
mov    %al,-0x1(%rbx)
movsbl (%rbx),%edi
test   %dil,%dil
jne    300 <osip_tolower+0x10>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
osip_tolower (char *word)
{
  for (; *word; word++)
    *word = (char) tolower (*word);
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 3
7 4
8 3
9 4
10 3
11 3
12 3
13 6
14 6
15 6
16 6
<<<sep_out_sample>>>
mov    0x4(%rdi),%ecx
cmp    $0x1,%ecx
je     4a0 <swutil_do_log_is_true+0x30>
xor    %eax,%eax
cmp    $0x2,%ecx
je     488 <swutil_do_log_is_true+0x18>
repz retq 
nopl   0x0(%rax)
cmp    $0x6,%edx
mov    $0x1,%al
jle    47f <swutil_do_log_is_true+0xf>
xor    %eax,%eax
cmp    $0x7,%esi
setg   %al
retq   
nopl   0x0(%rax,%rax,1)
xor    %eax,%eax
cmp    $0x5,%edx
setle  %al
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
swutil_do_log_is_true(struct sw_logspec * logspec, int verbose_level, int write_at_level)
{
 if (
  (
   logspec->logfdM == 1 &&
   (write_at_level < 6)
  ) ||
  ( logspec->logfdM == 2 &&
   (write_at_level < 7)
  ) ||
  ( logspec->logfdM == 2 &&
   (verbose_level > 7)
  )
 ) {
  return 1;
 } else {
  return 0;
 }
}
<<<sep_in_sample>>>
1 5
2 3
3 3
4 17
5 7
6 7
7 19
8 19
9 8
10 15
11 8
12 11
13 11
14 11
15 19
16 19
17 5
18 5
19 5
20 5
21 5
<<<sep_out_sample>>>
xor    %edx,%edx
cmp    $0x1,%edi
mov    0x0(%rip),%eax        # fb <malloc_set_trace+0xb>
setg   %dl
mov    %edi,0x0(%rip)        # 104 <malloc_set_trace+0x14>
mov    %edx,0x0(%rip)        # 10a <malloc_set_trace+0x1a>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
malloc_set_trace (n)
     int n;
{
  int old;
  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}
<<<sep_in_sample>>>
1 7
2 7
3 5
4 7
5 6
6 7
7 9
8 9
<<<sep_out_sample>>>
mov    %rsi,0xc0(%rdi)
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_qop_set (Gsasl * ctx, Gsasl_server_callback_qop cb)
{
  ctx->cbs_qop = cb;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
je     430 <gsasl_client_callback_authentication_id_get+0x10>
mov    0x38(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_authentication_id_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_authentication_id : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%rdi
jmpq   69 <html_styled_ostream__write_mem+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
html_styled_ostream__write_mem (html_styled_ostream_t stream,
                                const void *data, size_t len)
{
  html_ostream_write_mem (stream->html_destination, data, len);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    (%rdi),%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_float_size (const gsl_block_float * b)
{
  return b->size ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
lea    (%rdx,%rdx,1),%r10
xor    %edx,%edx
test   %rcx,%rcx
je     6d0 <gsl_permute_complex_float_inverse+0xc0>
nop
mov    (%rdi,%rdx,8),%rax
cmp    %rdx,%rax
jbe    639 <gsl_permute_complex_float_inverse+0x29>
nopl   0x0(%rax)
mov    (%rdi,%rax,8),%rax
cmp    %rdx,%rax
ja     630 <gsl_permute_complex_float_inverse+0x20>
cmp    %rax,%rdx
ja     6c3 <gsl_permute_complex_float_inverse+0xb3>
mov    (%rdi,%rax,8),%r8
cmp    %rdx,%r8
je     6c3 <gsl_permute_complex_float_inverse+0xb3>
imul   %r10,%rax
movss  (%rsi,%rax,4),%xmm3
movss  0x4(%rsi,%rax,4),%xmm2
jmp    666 <gsl_permute_complex_float_inverse+0x56>
nopl   0x0(%rax)
movaps %xmm1,%xmm3
movaps %xmm0,%xmm2
mov    %r8,%rax
mov    (%rdi,%r8,8),%r8
imul   %r10,%rax
cmp    %r8,%rdx
lea    (%rsi,%rax,4),%r9
lea    0x4(%rsi,%rax,4),%rax
movss  (%r9),%xmm1
movss  %xmm3,(%r9)
movss  (%rax),%xmm0
movss  %xmm2,(%rax)
jne    660 <gsl_permute_complex_float_inverse+0x50>
movss  %xmm1,-0xc(%rsp)
mov    -0xc(%rsp),%eax
movss  %xmm0,-0xc(%rsp)
mov    -0xc(%rsp),%r8d
mov    %eax,%eax
shl    $0x20,%r8
or     %r8,%rax
mov    %rdx,%r8
imul   %r10,%r8
mov    %eax,(%rsi,%r8,4)
shr    $0x20,%rax
mov    %eax,0x4(%rsi,%r8,4)
add    $0x1,%rdx
cmp    %rcx,%rdx
jne    620 <gsl_permute_complex_float_inverse+0x10>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_permute_complex_float_inverse (const size_t * p, float * data, const size_t stride, const size_t n)
{
  size_t i, k, pk;
  for (i = 0; i < n; i++)
    {
      k = p[i];
      while (k > i)
        k = p[k];
      if (k < i)
        continue ;
      pk = p[k];
      if (pk == i)
        continue ;
      {
        unsigned int a;
        float t[2];
        for (a = 0; a < 2; a++)
          t[a] = data[k*stride*2 +a];
        while (pk != i)
          {
            for (a = 0; a < 2; a++)
              {
                float r1 = data[pk*stride*2 + a];
                data[pk*stride*2 + a] = t[a];
                t[a] = r1;
              }
            k = pk;
            pk = p[k];
          };
        for (a = 0; a < 2; a++)
          data[pk*stride*2 +a] = t[a];
      }
    }
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 18
2 4
3 4
4 4
5 4
6 6
7 7
8 7
9 7
10 8
11 7
12 7
13 9
14 9
15 11
16 12
17 12
18 18
19 18
20 18
21 18
22 18
23 18
24 25
25 25
26 28
27 28
28 19
29 23
30 23
31 23
32 24
33 23
34 24
35 19
36 19
37 19
38 19
39 19
40 19
41 19
42 19
43 31
44 31
45 31
46 31
47 31
48 4
49 4
50 4
51 35
52 35
53 35
<<<sep_out_sample>>>
push   %rbx
mov    $0x28,%edi
callq  b <rec_sex_parser_new+0xb>
test   %rax,%rax
mov    %rax,%rbx
je     3f <rec_sex_parser_new+0x3f>
lea    0x10(%rax),%rdi
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movb   $0x0,0x18(%rax)
xor    %eax,%eax
callq  31 <rec_sex_parser_new+0x31>
mov    0x10(%rbx),%rsi
mov    %rbx,%rdi
xor    %eax,%eax
callq  3f <rec_sex_parser_new+0x3f>
mov    %rbx,%rax
pop    %rbx
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_sex_parser_new (void)
{
  rec_sex_parser_t new;
  new = malloc (sizeof (struct rec_sex_parser_s));
  if (new)
    {
      new->in = ((void *)0);
      new->index = 0;
      new->case_insensitive = 0;
      sexlex_init (&(new->scanner));
      sexset_extra (new, new->scanner);
    }
  return new;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 5
5 4
6 5
7 10
8 7
9 8
10 9
11 10
12 10
13 11
14 11
15 11
16 11
17 14
18 14
19 14
20 14
<<<sep_out_sample>>>
push   %r13
mov    %edx,%r8d
mov    %esi,%r13d
mov    $0x1,%esi
or     $0x1,%r13d
push   %r12
mov    %edx,%r12d
push   %rbp
mov    %ecx,%ebp
mov    $0x28,%ecx
mov    %ebp,%edx
and    $0x7,%ebp
push   %rbx
mov    %rdi,%rbx
shl    $0x3,%ebp
callq  d90 <_rex.isra.4.constprop.75>
mov    (%rbx),%rax
mov    %r12d,%r8d
and    $0x7,%r8d
or     $0xffffffc0,%r8d
lea    0x1(%rax),%rdx
or     %ebp,%r8d
mov    %rdx,(%rbx)
mov    %r13b,(%rax)
mov    (%rbx),%rax
lea    0x1(%rax),%rdx
mov    %rdx,(%rbx)
mov    %r8b,(%rax)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
_alur(jit_state_t *_jit, jit_int32_t code, jit_int32_t r0, jit_int32_t r1)
{
    _rex(_jit, 0, 1, r1, _NOREG, r0);
    *_jit->pc.uc++ = code | 0x01;
    *_jit->pc.uc++ = (0x03<<6) | (((r1) & 7)<<3) | ((r0) & 7);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 4
6 2
7 2
8 2
9 2
10 3
11 3
12 5
13 2
14 2
15 5
16 3
17 4
18 5
19 5
20 5
21 4
22 5
23 4
24 4
25 5
26 5
27 5
28 5
29 6
30 6
31 6
32 6
33 6
34 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  9 <savestring+0x9>
lea    0x1(%rax),%rdi
callq  12 <savestring+0x12>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  1d <savestring+0x1d>
pop    %rbx
retq   
<<<sep_in_sample>>>
savestring (s)
     const char *s;
{
  char *ret;
  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
  return ret;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 6
9 8
10 8
<<<sep_out_sample>>>
mov    $0x2000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
taruib_get_nominal_reserve(void)
{
 return taruib_get_reserve() - 512;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x10(%rdi),%eax
test   $0x1,%al
jne    6f8 <wsnode_len+0x28>
test   $0x2,%al
jne    6e8 <wsnode_len+0x18>
mov    0x20(%rdi),%rax
sub    0x18(%rdi),%rax
retq   
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
jmpq   6f1 <wsnode_len+0x21>
nopl   0x0(%rax)
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wsnode_len (struct wordsplit_node *p)
{
  if (p->flags & 0x01)
    return 0;
  else if (p->flags & 0x02)
    return strlen (p->v.word);
  else
    return p->v.segm.end - p->v.segm.beg;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 5
5 5
6 8
7 8
8 8
9 8
10 6
11 6
12 6
13 4
14 9
15 9
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    %rsi,%rdi
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
callq  194 <xmemdup+0x14>
add    $0x8,%rsp
mov    %rbx,%rdx
mov    %rbp,%rsi
pop    %rbx
pop    %rbp
mov    %rax,%rdi
jmpq   1a8 <xmemdup+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xmemdup (void const *p, size_t s)
{
  return memcpy (xmalloc (s), p, s);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 4
9 3
10 3
11 4
12 4
13 3
14 3
15 3
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    $0x4,%edi
callq  44e <do_cut_till_eof+0xe>
xor    %edi,%edi
mov    $0x1,%esi
callq  45a <do_cut_till_eof+0x1a>
mov    $0x4,%edi
add    $0x8,%rsp
jmpq   468 <do_cut_till_eof+0x28>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_cut_till_eof(void)
{
    add_undo(CUT_EOF);
    do_cut_text(0, 1);
    update_undo(CUT_EOF);
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 4
6 4
7 5
8 6
9 5
10 5
<<<sep_out_sample>>>
test   %rdi,%rdi
je     4b0 <mu_ticket_get_data+0x10>
mov    0x30(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_ticket_get_data (mu_ticket_t ticket)
{
  if (!ticket)
    return ((void *)0);
  return ticket->data;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 4
7 6
8 6
<<<sep_out_sample>>>
cvtsi2sd %edi,%xmm4
push   %rbx
mov    %edi,%ebx
sub    $0x30,%rsp
movsd  %xmm0,(%rsp)
movapd %xmm4,%xmm0
movsd  %xmm4,0x8(%rsp)
callq  1a9f <chisqpoint+0x1f>
movsd  0x8(%rsp),%xmm4
movapd %xmm0,%xmm3
xorpd  %xmm1,%xmm1
movapd %xmm4,%xmm5
movsd  0x0(%rip),%xmm0        # 1ab9 <chisqpoint+0x39>
addsd  %xmm4,%xmm5
jmpq   1b74 <chisqpoint+0xf4>
nopw   0x0(%rax,%rax,1)
movapd %xmm1,%xmm0
mov    %ebx,%edi
movsd  %xmm6,0x28(%rsp)
movsd  %xmm5,0x20(%rsp)
movsd  %xmm3,0x18(%rsp)
movsd  %xmm4,0x10(%rsp)
movsd  %xmm1,0x8(%rsp)
callq  1af1 <chisqpoint+0x71>
movsd  0x28(%rsp),%xmm6
movapd %xmm0,%xmm7
movsd  0x18(%rsp),%xmm3
movapd %xmm0,%xmm2
subsd  %xmm6,%xmm7
movsd  0x10(%rsp),%xmm4
subsd  %xmm3,%xmm2
movsd  0x8(%rsp),%xmm1
movsd  0x20(%rsp),%xmm5
movapd %xmm7,%xmm6
andpd  0x0(%rip),%xmm2        # 1b2b <chisqpoint+0xab>
andpd  0x0(%rip),%xmm6        # 1b33 <chisqpoint+0xb3>
cmpltsd %xmm6,%xmm2
andpd  %xmm2,%xmm3
andpd  %xmm2,%xmm4
movapd %xmm3,%xmm6
movapd %xmm2,%xmm3
andnpd %xmm0,%xmm3
orpd   %xmm6,%xmm3
movapd %xmm4,%xmm6
movapd %xmm2,%xmm4
andnpd %xmm1,%xmm4
orpd   %xmm6,%xmm4
movapd %xmm1,%xmm6
andpd  %xmm2,%xmm6
andnpd %xmm5,%xmm2
movapd %xmm2,%xmm5
orpd   %xmm6,%xmm5
subsd  (%rsp),%xmm0
andpd  0x0(%rip),%xmm0        # 1b81 <chisqpoint+0x101>
ucomisd 0x0(%rip),%xmm0        # 1b89 <chisqpoint+0x109>
jbe    1c20 <chisqpoint+0x1a0>
movapd %xmm5,%xmm0
mov    %ebx,%edi
movsd  %xmm3,0x18(%rsp)
movsd  %xmm4,0x10(%rsp)
movsd  %xmm5,0x8(%rsp)
callq  1bac <chisqpoint+0x12c>
movsd  0x8(%rsp),%xmm5
movapd %xmm0,%xmm6
movsd  0x10(%rsp),%xmm4
movsd  0x18(%rsp),%xmm3
movapd %xmm5,%xmm1
movsd  (%rsp),%xmm0
xorpd  %xmm7,%xmm7
subsd  %xmm3,%xmm0
subsd  %xmm4,%xmm1
mulsd  %xmm0,%xmm1
movapd %xmm6,%xmm0
subsd  %xmm3,%xmm0
divsd  %xmm0,%xmm1
addsd  %xmm4,%xmm1
ucomisd %xmm1,%xmm7
jbe    1ac8 <chisqpoint+0x48>
ucomisd %xmm4,%xmm5
movsd  0x0(%rip),%xmm1        # 1c01 <chisqpoint+0x181>
jbe    1c10 <chisqpoint+0x190>
mulsd  %xmm4,%xmm1
jmpq   1ac8 <chisqpoint+0x48>
nopl   0x0(%rax)
mulsd  %xmm5,%xmm1
jmpq   1ac8 <chisqpoint+0x48>
nopl   0x0(%rax)
add    $0x30,%rsp
movapd %xmm1,%xmm0
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
chisqpoint(double p, int df)
{
  double pt0, pr0;
  double pt1, pr1;
  double pt2, pr2;
  pt2 = 0.0;
  pt0 = (double) df;
  pr0 = probchisq(pt0, df);
  pt1 = 2.0 * pt0;
  pr2 = 1.0;
  while (fabs(pr2 - p) > dap_prtol)
    {
      pr1 = probchisq(pt1, df);
      pt2 = pt0 + (pt1 - pt0) * (p - pr0) / (pr1 - pr0);
      if (pt2 < 0.0)
 {
   if (pt0 < pt1)
     pt2 = 0.5 * pt0;
   else
     pt2 = 0.5 * pt1;
 }
      pr2 = probchisq(pt2, df);
      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))
 {
   pr1 = pr2;
   pt1 = pt2;
 }
      else
 {
   pr0 = pr2;
   pt0 = pt2;
 }
    }
  return pt2;
}
<<<sep_in_sample>>>
1 7
2 2
3 2
4 2
5 2
6 8
7 8
8 8
9 9
10 8
11 6
12 9
13 10
14 9
15 11
16 11
17 22
18 22
19 22
20 22
21 22
22 22
23 22
24 22
25 23
26 23
27 23
28 23
29 23
30 30
31 23
32 30
33 30
34 23
35 23
36 23
37 30
38 30
39 30
40 30
41 30
42 30
43 30
44 30
45 30
46 30
47 30
48 30
49 30
50 30
51 30
52 30
53 11
54 11
55 11
56 11
57 13
58 13
59 13
60 13
61 13
62 13
63 14
64 13
65 14
66 14
67 14
68 14
69 15
70 14
71 14
72 14
73 14
74 14
75 14
76 14
77 15
78 15
79 17
80 18
81 17
82 18
83 18
84 18
85 20
86 20
87 20
88 35
89 35
90 35
91 35
92 35
<<<sep_out_sample>>>
push   %rbx
callq  af6 <write_eot+0x6>
test   $0x1,%al
mov    %rax,%rsi
mov    %rax,%rdi
mov    $0x200,%edx
jne    b80 <write_eot+0x90>
test   $0x2,%dil
jne    b98 <write_eot+0xa8>
test   $0x4,%dil
jne    bb0 <write_eot+0xc0>
mov    %edx,%ecx
xor    %eax,%eax
shr    $0x3,%ecx
test   $0x4,%dl
rep stos %rax,%es:(%rdi)
je     b32 <write_eot+0x42>
movl   $0x0,(%rdi)
add    $0x4,%rdi
test   $0x2,%dl
je     b41 <write_eot+0x51>
xor    %eax,%eax
add    $0x2,%rdi
mov    %ax,-0x2(%rdi)
and    $0x1,%edx
je     b49 <write_eot+0x59>
movb   $0x0,(%rdi)
mov    %rsi,%rdi
callq  b51 <write_eot+0x61>
callq  b56 <write_eot+0x66>
mov    %rax,%rbx
mov    %rax,%rdi
callq  b61 <write_eot+0x71>
mov    %rbx,%rdi
mov    %rax,%rdx
xor    %esi,%esi
callq  b6e <write_eot+0x7e>
mov    %rbx,%rdi
pop    %rbx
jmpq   b77 <write_eot+0x87>
nopw   0x0(%rax,%rax,1)
lea    0x1(%rax),%rdi
movb   $0x0,(%rax)
mov    $0x1ff,%dx
test   $0x2,%dil
je     b0f <write_eot+0x1f>
nopl   (%rax)
xor    %ecx,%ecx
add    $0x2,%rdi
sub    $0x2,%edx
mov    %cx,-0x2(%rdi)
test   $0x4,%dil
je     b19 <write_eot+0x29>
nop
movl   $0x0,(%rdi)
sub    $0x4,%edx
add    $0x4,%rdi
jmpq   b19 <write_eot+0x29>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
write_eot (void)
{
  union block *pointer = find_next_block ();
  memset (pointer->buffer, 0, 512);
  set_next_block_after (pointer);
  pointer = find_next_block ();
  memset (pointer->buffer, 0, available_space_after (pointer));
  set_next_block_after (pointer);
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 4
7 4
8 4
9 4
10 4
11 4
12 4
13 4
14 4
15 4
16 4
17 4
18 4
19 4
20 4
21 4
22 4
23 4
24 4
25 4
26 4
27 4
28 5
29 5
30 6
31 6
32 7
33 7
34 7
35 7
36 7
37 7
38 8
39 9
40 8
41 8
42 4
43 4
44 4
45 4
46 4
47 4
48 4
49 4
50 4
51 4
52 4
53 4
54 4
55 4
56 4
57 4
58 4
59 4
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    7940 <gsl_matrix_uchar_const_column+0x30>
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nop
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  7962 <gsl_matrix_uchar_const_column+0x52>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_uchar_const_column (const gsl_matrix_uchar * m, const size_t j)
{
  _gsl_vector_uchar_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_uchar v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 1;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 12
6 13
7 16
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 2
16 6
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 18
29 18
30 18
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     562 <info_copy_references+0xa2>
cmpq   $0x0,(%rdi)
je     557 <info_copy_references+0x97>
lea    0x8(%rdi),%rax
xor    %edx,%edx
nopw   0x0(%rax,%rax,1)
add    $0x8,%rax
add    $0x1,%edx
cmpq   $0x0,-0x8(%rax)
jne    4e8 <info_copy_references+0x28>
lea    0x1(%rdx),%edi
movslq %edi,%rdi
shl    $0x3,%rdi
callq  505 <info_copy_references+0x45>
mov    0x0(%rbp),%rdi
mov    %rax,%r13
test   %rdi,%rdi
je     55e <info_copy_references+0x9e>
mov    $0x8,%ebx
xor    %r12d,%r12d
jmp    526 <info_copy_references+0x66>
nopl   0x0(%rax,%rax,1)
mov    %rbx,%r12
mov    %rcx,%rbx
add    %r13,%r12
callq  52e <info_copy_references+0x6e>
mov    %rax,(%r12)
mov    0x0(%rbp,%rbx,1),%rdi
lea    0x8(%rbx),%rcx
test   %rdi,%rdi
jne    520 <info_copy_references+0x60>
movq   $0x0,0x0(%r13,%rbx,1)
mov    %r13,%rax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
mov    $0x8,%edi
jmp    500 <info_copy_references+0x40>
xor    %ebx,%ebx
jmp    540 <info_copy_references+0x80>
xor    %eax,%eax
jmp    54c <info_copy_references+0x8c>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_copy_references (REFERENCE **ref1)
{
  int i;
  REFERENCE **result;
  int size;
  if (!ref1)
    return 0;
  for (i = 0; ref1[i]; i++);
  size = i;
  result = xmalloc ((1 + size) * sizeof (REFERENCE *));
  for (i = 0; ref1[i]; i++)
    result[i] = info_copy_reference (ref1[i]);
  result[i] = ((void *)0);
  return result;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 6
8 6
9 8
10 8
11 8
12 8
13 8
14 8
15 8
16 8
17 8
18 8
19 8
20 8
21 10
22 11
23 10
24 11
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 12
33 12
34 12
35 11
36 11
37 11
38 11
39 13
40 14
41 15
42 15
43 15
44 15
45 15
46 15
47 8
48 8
49 11
50 11
51 7
52 7
53 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
testb  $0x4,0x20(%rdi)
jne    c7e <wordsplit_free_envbuf+0x5e>
mov    0x68(%rdi),%rdi
test   %rdi,%rdi
je     c7e <wordsplit_free_envbuf+0x5e>
mov    (%rdi),%rax
test   %rax,%rax
je     c61 <wordsplit_free_envbuf+0x41>
mov    $0x8,%ebx
nopl   (%rax)
mov    %rax,%rdi
callq  c50 <wordsplit_free_envbuf+0x30>
mov    0x68(%rbp),%rdi
mov    (%rdi,%rbx,1),%rax
add    $0x8,%rbx
test   %rax,%rax
jne    c48 <wordsplit_free_envbuf+0x28>
callq  c66 <wordsplit_free_envbuf+0x46>
movq   $0x0,0x78(%rbp)
movq   $0x0,0x70(%rbp)
movq   $0x0,0x68(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
wordsplit_free_envbuf (struct wordsplit *ws)
{
  if (ws->ws_flags & 0x00000004)
    return;
  if (ws->ws_envbuf)
    {
      size_t i;
      for (i = 0; ws->ws_envbuf[i]; i++)
 free (ws->ws_envbuf[i]);
      free (ws->ws_envbuf);
      ws->ws_envidx = ws->ws_envsiz = 0;
      ws->ws_envbuf = ((void *)0);
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 5
8 5
9 5
10 8
11 8
12 8
13 8
14 8
15 9
16 9
17 8
18 8
19 8
20 8
21 8
22 10
23 11
24 11
25 12
26 14
27 14
28 14
29 14
30 14
<<<sep_out_sample>>>
mov    %esi,0x18(%rdi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swicol_set_verbose_level(SWICOL * swicol, int level)
{
 swicol->verbose_levelM = level;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
callq  541 <space+0x11>
add    %rax,%rbp
cmp    0x10(%rbx),%rbp
mov    $0xa,%esi
jae    554 <space+0x24>
mov    $0x20,%esi
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   562 <space+0x32>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
space (argp_fmtstream_t stream, size_t ensure)
{
  if (argp_fmtstream_point (stream) + ensure
      >= ((stream)->rmargin))
    argp_fmtstream_putc (stream, '\n');
  else
    argp_fmtstream_putc (stream, ' ');
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 5
10 3
11 7
12 8
13 7
14 8
15 8
16 7
17 7
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
mov    $0xc,%edi
callq  58d <_rl_callback_data_alloc+0xd>
mov    %ebx,(%rax)
movl   $0x0,0x8(%rax)
movl   $0x0,0x4(%rax)
pop    %rbx
retq   
nop
<<<sep_in_sample>>>
_rl_callback_data_alloc (count)
     int count;
{
  _rl_callback_generic_arg *arg;
  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;
  arg->i1 = arg->i2 = 0;
  return arg;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 6
6 7
7 7
8 9
9 9
10 9
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     6f0 <_log_handler+0x40>
cmp    $0x2,%edi
je     6d8 <_log_handler+0x28>
cmp    $0x3,%edi
jne    6c9 <_log_handler+0x19>
mov    0x0(%rip),%eax        # 6c5 <_log_handler+0x15>
test   %eax,%eax
jne    6e8 <_log_handler+0x38>
mov    0x0(%rip),%rax        # 6d0 <_log_handler+0x20>
jmpq   *%rax
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%edx        # 6de <_log_handler+0x2e>
test   %edx,%edx
jne    6c9 <_log_handler+0x19>
repz retq 
nopl   0x0(%rax)
repz retq 
nopw   0x0(%rax,%rax,1)
cmpl   $0x1,0x0(%rip)        # 6f7 <_log_handler+0x47>
ja     6c9 <_log_handler+0x19>
repz retq 
<<<sep_in_sample>>>
_log_handler (cdio_log_level_t level, const char message[])
{
  if (level == CDIO_LOG_DEBUG && opts.debug_level < 2)
    return;
  if (level == CDIO_LOG_INFO && opts.debug_level < 1)
    return;
  if (level == CDIO_LOG_WARN && opts.silent)
    return;
  gl_default_cdio_log_handler (level, message);
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 5
14 5
15 5
16 5
17 5
18 5
19 5
20 3
21 3
22 3
<<<sep_out_sample>>>
push   %rbx
mov    0xf8(%rsi),%rcx
mov    %rsi,%rdx
mov    0x158(%rsi),%r8
mov    %rsi,%r9
xor    %esi,%esi
mov    %rdi,%rbx
callq  820 <__osip_dialog_init>
test   %eax,%eax
jne    d30 <osip_dialog_init_as_uac+0x40>
mov    (%rbx),%rax
movl   $0x0,0x54(%rax)
movl   $0xffffffff,0x34(%rax)
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
movq   $0x0,(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
osip_dialog_init_as_uac (osip_dialog_t ** dialog, osip_message_t * response)
{
  int i;
  i = __osip_dialog_init (dialog, ((void *)0), response, response->from, response->to, response);
  if (i != 0) {
    *dialog = ((void *)0);
    return i;
  }
  (*dialog)->type = CALLER;
  (*dialog)->remote_cseq = -1;
  return 0;
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 4
5 4
6 4
7 2
8 4
9 5
10 5
11 9
12 9
13 10
14 11
15 12
16 12
17 12
18 6
19 12
20 12
21 12
<<<sep_out_sample>>>
push   %rbp
push   %rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rdi        # dcd <checkaccesslist+0xd>
mov    0x170(%rdi),%rax
mov    0x18(%rax),%rbx
test   %rbx,%rbx
je     ded <checkaccesslist+0x2d>
add    $0xe0,%rdi
callq  de9 <checkaccesslist+0x29>
test   %al,%al
je     e00 <checkaccesslist+0x40>
mov    $0x1,%ebp
add    $0x8,%rsp
mov    %ebp,%eax
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  e0a <checkaccesslist+0x4a>
test   %al,%al
jne    ded <checkaccesslist+0x2d>
xchg   %ax,%ax
mov    (%rbx),%rdi
callq  e18 <checkaccesslist+0x58>
test   %al,%al
mov    %eax,%ebp
jne    ded <checkaccesslist+0x2d>
mov    0x8(%rbx),%rbx
test   %rbx,%rbx
jne    e10 <checkaccesslist+0x50>
callq  e2c <checkaccesslist+0x6c>
mov    0x0(%rip),%rdx        # e33 <checkaccesslist+0x73>
mov    $0x0,%esi
mov    0xd0(%rdx),%rdi
mov    %rax,%rdx
xor    %eax,%eax
callq  e49 <checkaccesslist+0x89>
jmp    df2 <checkaccesslist+0x32>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
checkaccesslist (void)
{
  struct link *ls = ((top->repository. r)-> access);
  if (!ls || stat_mine_p (&(top->repository. stat)) || caller_login_p ("root"))
    return 1;
  for (; ls; ls = ls->next)
    if (caller_login_p (ls->entry))
      return 1;
  generic_error ((top->repository. filename), "user %s not on the access list", getcaller ());
  return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 4
8 4
9 4
10 4
11 4
12 4
13 5
14 11
15 11
16 11
17 11
18 11
19 11
20 4
21 4
22 4
23 4
24 4
25 7
26 7
27 7
28 7
29 7
30 6
31 6
32 6
33 9
34 9
35 9
36 9
37 9
38 9
39 9
40 10
41 10
<<<sep_out_sample>>>
cmp    %rdx,%rdi
jl     28 <timespec_cmp+0x18>
mov    $0x1,%eax
jg     30 <timespec_cmp+0x20>
mov    %esi,%eax
sub    %ecx,%eax
retq   
nopl   0x0(%rax)
mov    $0xffffffff,%eax
nopl   (%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timespec_cmp (struct timespec a, struct timespec b)
{
  return (a.tv_sec < b.tv_sec ? -1
          : a.tv_sec > b.tv_sec ? 1
          : (int) (a.tv_nsec - b.tv_nsec));
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 5
9 4
10 4
11 6
12 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  1699 <ppd_scan_string+0x9>
mov    %rbx,%rdi
mov    %eax,%esi
pop    %rbx
jmpq   16a4 <ppd_scan_string+0x14>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ppd_scan_string (const char * yystr )
{
 return ppd_scan_bytes(yystr,strlen(yystr) );
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 3
6 4
7 3
8 3
<<<sep_out_sample>>>
push   %rbx
mov    $0x0,%esi
mov    %rdi,%rbx
sub    $0x10,%rsp
callq  a2 <str2port+0x12>
test   %rax,%rax
je     c0 <str2port+0x30>
movzwl 0x10(%rax),%edi
callq  b0 <str2port+0x20>
movzwl %ax,%eax
add    $0x10,%rsp
pop    %rbx
retq   
nopl   0x0(%rax)
lea    0x8(%rsp),%rsi
xor    %edx,%edx
mov    %rbx,%rdi
callq  cf <str2port+0x3f>
mov    %rax,%rdx
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
mov    $0xffffffff,%eax
jne    b3 <str2port+0x23>
cmp    $0xffff,%rdx
cmovbe %edx,%eax
jmp    b3 <str2port+0x23>
nopl   (%rax)
<<<sep_in_sample>>>
str2port (char *str)
{
  struct servent *serv;
  char *p;
  int port;
  serv = getservbyname (str, "tcp");
  if (serv != ((void *)0))
    port = ntohs(serv->s_port);
  else
    {
      unsigned long l;
      l = strtoul (str, &p, 0);
      if (*p || l < 0 || l > (32767 * 2 + 1))
 return -1;
      port = l;
    }
  return port;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 6
6 7
7 7
8 8
9 8
10 8
11 18
12 18
13 18
14 18
15 12
16 12
17 12
18 12
19 12
20 13
21 13
22 14
23 13
24 15
25 15
26 15
27 15
<<<sep_out_sample>>>
push   %rbx
mov    0x20(%rdi),%eax
mov    %rdi,%rbx
test   $0x8,%al
je     a58 <wordsplit_init0+0x38>
test   $0x1,%al
je     a78 <wordsplit_init0+0x58>
movl   $0x0,0x88(%rbx)
movq   $0x0,0x98(%rbx)
movq   $0x0,0x90(%rbx)
pop    %rbx
retq   
nopl   0x0(%rax)
movq   $0x0,0x8(%rdi)
movq   $0x0,(%rdi)
movq   $0x0,0x18(%rdi)
jmp    a2f <wordsplit_init0+0xf>
nopl   0x0(%rax)
callq  a7d <wordsplit_init0+0x5d>
jmp    a2f <wordsplit_init0+0xf>
nop
<<<sep_in_sample>>>
wordsplit_init0 (struct wordsplit *wsp)
{
  if (wsp->ws_flags & 0x00000008)
    {
      if (!(wsp->ws_flags & 0x00000001))
 wordsplit_free_words (wsp);
    }
  else
    {
      wsp->ws_wordv = ((void *)0);
      wsp->ws_wordc = 0;
      wsp->ws_wordn = 0;
    }
  wsp->ws_errno = 0;
  wsp->ws_head = wsp->ws_tail = ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 5
7 5
8 14
9 15
10 15
11 16
12 16
13 16
14 10
15 11
16 12
17 12
18 12
19 6
20 6
21 6
<<<sep_out_sample>>>
push   %r12
push   %rbp
push   %rbx
mov    0x0(%rip),%rbx        # 146b <yypop_buffer_state+0xb>
test   %rbx,%rbx
je     14b7 <yypop_buffer_state+0x57>
mov    0x0(%rip),%rbp        # 1477 <yypop_buffer_state+0x17>
lea    (%rbx,%rbp,8),%r12
mov    (%r12),%rdi
test   %rdi,%rdi
je     14b7 <yypop_buffer_state+0x57>
callq  1489 <yypop_buffer_state+0x29>
test   %rbp,%rbp
movq   $0x0,(%r12)
je     14b7 <yypop_buffer_state+0x57>
sub    $0x1,%rbp
cmpq   $0x0,(%rbx,%rbp,8)
mov    %rbp,0x0(%rip)        # 14a6 <yypop_buffer_state+0x46>
je     14b7 <yypop_buffer_state+0x57>
callq  0 <yy_load_buffer_state>
movl   $0x1,0x0(%rip)        # 14b7 <yypop_buffer_state+0x57>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
yypop_buffer_state (void)
{
     if (!( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)))
  return;
 yy_delete_buffer(( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0)) );
 (yy_buffer_stack)[(yy_buffer_stack_top)] = ((void *)0);
 if ((yy_buffer_stack_top) > 0)
  --(yy_buffer_stack_top);
 if (( (yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : ((void *)0))) {
  yy_load_buffer_state( );
  (yy_did_buffer_switch_on_eof) = 1;
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 3
7 3
8 3
9 3
10 3
11 3
12 5
13 7
14 6
15 7
16 8
17 9
18 8
19 9
20 10
21 11
22 13
23 13
24 13
25 13
26 13
<<<sep_out_sample>>>
push   %rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     40 <ecopy+0x40>
callq  13 <ecopy+0x13>
lea    0x1(%rax),%rbp
mov    %rbp,%rdi
callq  1f <ecopy+0x1f>
test   %rax,%rax
je     44 <ecopy+0x44>
mov    %rbp,%rdx
mov    %rbx,%rsi
mov    %rax,%rdi
callq  32 <ecopy+0x32>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
xor    %eax,%eax
jmp    32 <ecopy+0x32>
mov    $0x0,%edi
callq  4e <ecopy+0x4e>
mov    $0x1,%edi
callq  58 <ecopy+0x58>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
ecopy(char *e)
{
  char *copy;
  if (e)
    {
      if (!(copy = malloc(strlen(e) + 1)))
 {
   perror("dap");
   exit(1);
 }
      strcpy(copy, e);
      return copy;
    }
  return ((void *)0);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 4
7 6
8 6
9 6
10 6
11 6
12 6
13 11
14 11
15 11
16 11
17 15
18 15
19 15
20 15
21 15
22 14
23 14
24 8
25 8
26 9
27 9
28 9
<<<sep_out_sample>>>
push   %r12
mov    %edi,%r12d
mov    $0x20,%edi
push   %rbp
mov    %rsi,%rbp
push   %rbx
callq  14 <addcmd+0x14>
mov    %rax,%rbx
mov    0x0(%rip),%rax        # 1e <addcmd+0x1e>
test   %rax,%rax
je     60 <addcmd+0x60>
mov    %rbx,0x8(%rax)
mov    %rbx,0x0(%rip)        # 2e <addcmd+0x2e>
movq   $0x0,0x8(%rbx)
mov    %rax,(%rbx)
mov    %r12d,0x10(%rbx)
mov    %rbp,%rdi
callq  45 <addcmd+0x45>
mov    %rax,0x18(%rbx)
movq   $0x0,0x0(%rip)        # 54 <addcmd+0x54>
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
mov    %rbx,0x0(%rip)        # 67 <addcmd+0x67>
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
jmp    39 <addcmd+0x39>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
addcmd(int f, char *s)
{
 struct cmd *h;
 h = mymalloc(sizeof(struct cmd));
 if( tail) {
  tail->next = h;
  h->next = 0;
  h->prev = tail;
  tail = h;
 } else {
  tail = h;
  h->next = h->prev = 0;
 }
 h->field = f;
 h->text = my_strdup( s);
 current = 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 2
5 2
6 2
7 4
8 4
9 5
10 5
11 5
12 6
13 9
14 7
15 8
16 14
17 15
18 15
19 15
20 16
21 17
22 17
23 17
24 17
25 17
26 11
27 12
28 12
29 12
30 12
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyerror (const char *s)
{
  return 0;
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    0x0(%rip),%rdi        # 1c7 <check_stdout+0x7>
push   %rbx
callq  1cd <check_stdout+0xd>
test   %eax,%eax
jne    20c <check_stdout+0x4c>
mov    0x0(%rip),%rdi        # 1d8 <check_stdout+0x18>
callq  1dd <check_stdout+0x1d>
test   %eax,%eax
jne    1e3 <check_stdout+0x23>
pop    %rbx
retq   
mov    $0x0,%edi
callq  1ed <check_stdout+0x2d>
mov    %rax,%rbx
callq  1f5 <check_stdout+0x35>
mov    %rbx,%rcx
mov    (%rax),%esi
mov    $0x0,%edx
pop    %rbx
mov    $0x2,%edi
xor    %eax,%eax
jmpq   20c <check_stdout+0x4c>
mov    $0x0,%edi
callq  216 <check_stdout+0x56>
pop    %rbx
mov    %rax,%rcx
mov    $0x0,%edx
xor    %esi,%esi
mov    $0x2,%edi
xor    %eax,%eax
jmpq   22d <check_stdout+0x6d>
<<<sep_in_sample>>>
check_stdout (void)
{
  if (ferror_unlocked (stdout))
    error (2, 0, "%s", gettext ("write failed"));
  else if (fclose (stdout) != 0)
    error (2, (*__errno_location ()), "%s", gettext ("standard output"));
}
<<<sep_in_sample>>>
1 3
2 2
3 3
4 3
5 3
6 5
7 5
8 5
9 5
10 7
11 7
12 6
13 6
14 6
15 6
16 6
17 6
18 6
19 7
20 6
21 6
22 6
23 4
24 4
25 7
26 4
27 4
28 4
29 4
30 4
31 4
<<<sep_out_sample>>>
push   %r13
mov    %rsi,%r13
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rdi,%rbp
mov    $0x18,%edi
push   %rbx
sub    $0x8,%rsp
callq  12d <xheader_list_append+0x1d>
mov    %r13,%rdi
mov    %rax,%rbx
callq  138 <xheader_list_append+0x28>
mov    %rax,0x8(%rbx)
xor    %eax,%eax
test   %r12,%r12
je     14b <xheader_list_append+0x3b>
mov    %r12,%rdi
callq  14b <xheader_list_append+0x3b>
mov    %rax,0x10(%rbx)
mov    0x0(%rbp),%rax
mov    %rax,(%rbx)
mov    %rbx,0x0(%rbp)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xheader_list_append (struct keyword_list **root, char const *kw,
       char const *value)
{
  struct keyword_list *kp = xmalloc (sizeof *kp);
  kp->pattern = xstrdup (kw);
  kp->value = value ? xstrdup (value) : ((void *)0);
  kp->next = *root;
  *root = kp;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 3
9 3
10 4
11 5
12 4
13 5
14 5
15 6
16 6
17 6
18 6
19 6
20 6
21 7
22 7
23 8
24 9
25 9
26 9
27 9
28 9
29 9
30 9
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%rdi
test   %rdi,%rdi
je     92 <dogleg_free+0x12>
callq  92 <dogleg_free+0x12>
mov    0x18(%rbx),%rdi
test   %rdi,%rdi
je     a0 <dogleg_free+0x20>
callq  a0 <dogleg_free+0x20>
mov    0x40(%rbx),%rdi
test   %rdi,%rdi
je     ae <dogleg_free+0x2e>
callq  ae <dogleg_free+0x2e>
mov    0x48(%rbx),%rdi
test   %rdi,%rdi
je     bc <dogleg_free+0x3c>
callq  bc <dogleg_free+0x3c>
mov    0x50(%rbx),%rdi
test   %rdi,%rdi
je     ca <dogleg_free+0x4a>
callq  ca <dogleg_free+0x4a>
mov    %rbx,%rdi
pop    %rbx
jmpq   d3 <dogleg_free+0x53>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
dogleg_free(void *vstate)
{
  dogleg_state_t *state = (dogleg_state_t *) vstate;
  if (state->dx_gn)
    gsl_vector_free(state->dx_gn);
  if (state->dx_sd)
    gsl_vector_free(state->dx_sd);
  if (state->workp1)
    gsl_vector_free(state->workp1);
  if (state->workp2)
    gsl_vector_free(state->workp2);
  if (state->workn)
    gsl_vector_free(state->workn);
  free(state);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 4
6 5
7 6
8 6
9 6
10 7
11 8
12 8
13 8
14 9
15 10
16 10
17 10
18 11
19 12
20 12
21 12
22 13
23 14
24 15
25 14
26 14
<<<sep_out_sample>>>
push   %r12
test   %rdx,%rdx
movq   $0x0,(%r9)
movq   $0x0,(%r8)
push   %rbp
push   %rbx
mov    %rdx,%rbx
je     40 <_gsasl_external_server_step+0x40>
mov    %rcx,%rdx
xor    %esi,%esi
mov    %rdi,%r12
mov    %rbx,%rdi
mov    %rcx,%rbp
callq  2d <_gsasl_external_server_step+0x2d>
test   %rax,%rax
mov    $0x1e,%edx
je     50 <_gsasl_external_server_step+0x50>
pop    %rbx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
xchg   %ax,%ax
pop    %rbx
mov    $0x1,%edx
pop    %rbp
mov    %edx,%eax
pop    %r12
retq   
nopl   0x0(%rax)
test   %rbp,%rbp
jne    80 <_gsasl_external_server_step+0x80>
xor    %edx,%edx
mov    $0x2,%esi
mov    %r12,%rdi
callq  64 <_gsasl_external_server_step+0x64>
pop    %rbx
pop    %rbp
mov    %r12,%rsi
mov    $0x1f5,%edx
xor    %edi,%edi
pop    %r12
jmpq   77 <_gsasl_external_server_step+0x77>
nopw   0x0(%rax,%rax,1)
mov    %rbp,%rcx
mov    %rbx,%rdx
mov    $0x2,%esi
mov    %r12,%rdi
callq  93 <_gsasl_external_server_step+0x93>
jmp    64 <_gsasl_external_server_step+0x64>
<<<sep_in_sample>>>
_gsasl_external_server_step (Gsasl_session * sctx,
        void *mech_data,
        const char *input, size_t input_len,
        char **output, size_t * output_len)
{
  *output_len = 0;
  *output = ((void *)0);
  if (!input)
    return GSASL_NEEDS_MORE;
  if (memchr (input, '\0', input_len))
    return GSASL_MECHANISM_PARSE_ERROR;
  if (input_len > 0)
    gsasl_property_set_raw (sctx, GSASL_AUTHZID, input, input_len);
  else
    gsasl_property_set (sctx, GSASL_AUTHZID, ((void *)0));
  return gsasl_callback (((void *)0), sctx, GSASL_VALIDATE_EXTERNAL);
}
<<<sep_in_sample>>>
1 5
2 8
3 6
4 7
5 5
6 5
7 5
8 8
9 10
10 10
11 10
12 10
13 10
14 10
15 10
16 11
17 10
18 17
19 17
20 17
21 17
22 17
23 17
24 17
25 9
26 17
27 17
28 17
29 17
30 17
31 12
32 12
33 15
34 15
35 15
36 15
37 17
38 17
39 16
40 16
41 16
42 17
43 16
44 16
45 13
46 13
47 13
48 13
49 13
50 13
<<<sep_out_sample>>>
sub    $0x30,%edi
cmp    $0x9,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isdigit (int c)
{
  switch (c)
    {
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 6
3 6
4 10
5 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # e5a <close_info_session+0xa>
xor    %edi,%edi
lea    -0x1(%rax),%esi
callq  e64 <close_info_session+0x14>
callq  e69 <close_info_session+0x19>
mov    0x0(%rip),%rdi        # e70 <close_info_session+0x20>
callq  e75 <close_info_session+0x25>
callq  e7a <close_info_session+0x2a>
add    $0x8,%rsp
jmpq   e83 <close_info_session+0x33>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
close_info_session (void)
{
  terminal_goto_xy (0, screenheight - 1);
  terminal_clear_to_eol ();
  fflush (stdout);
  terminal_unprep_terminal ();
  close_dribble_file ();
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 4
7 5
8 5
9 6
10 8
11 7
12 7
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
goto_dir_void(void)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
test   %rdi,%rdi
je     61c1 <regfree+0x11>
callq  61c1 <regfree+0x11>
mov    0x20(%rbx),%rdi
movq   $0x0,(%rbx)
movq   $0x0,0x8(%rbx)
movq   $0x0,0x10(%rbx)
test   %rdi,%rdi
je     61e6 <regfree+0x36>
callq  61e6 <regfree+0x36>
mov    0x28(%rbx),%rdi
andb   $0xf7,0x38(%rbx)
movq   $0x0,0x20(%rbx)
test   %rdi,%rdi
je     6200 <regfree+0x50>
callq  6200 <regfree+0x50>
movq   $0x0,0x28(%rbx)
pop    %rbx
retq   
<<<sep_in_sample>>>
regfree (preg)
    regex_t *preg;
{
  if (preg->buffer != ((void *)0))
    free (preg->buffer);
  preg->buffer = ((void *)0);
  preg->allocated = 0;
  preg->used = 0;
  if (preg->fastmap != ((void *)0))
    free (preg->fastmap);
  preg->fastmap = ((void *)0);
  preg->fastmap_accurate = 0;
  if (preg->translate != ((void *)0))
    free (preg->translate);
  preg->translate = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 5
7 9
8 6
9 7
10 8
11 9
12 9
13 10
14 13
15 12
16 11
17 13
18 13
19 14
20 15
21 16
22 16
<<<sep_out_sample>>>
mov    $0xa,%eax
sub    $0x8,%rsp
or     %edi,0x0(%rip)        # f <__gmp_exception+0xf>
cltd   
idivl  0x0(%rip)        # 16 <__gmp_exception+0x16>
mov    %eax,0x0(%rip)        # 1c <__gmp_exception+0x1c>
callq  21 <__gmp_exception+0x21>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
__gmp_exception (int error_bit)
{
  __gmp_errno |= error_bit;
  __gmp_junk = 10 / __gmp_0;
  abort ();
}
<<<sep_in_sample>>>
1 4
2 2
3 3
4 4
5 4
6 4
7 5
8 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  3c <def_free_fun+0xc>
mov    %rbx,%rdi
pop    %rbx
jmpq   45 <def_free_fun+0x15>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
def_free_fun(void *p)
{
 struct grecs_syment *sym = p;
 free(sym->name);
 free(sym);
}
<<<sep_in_sample>>>
1 2
2 2
3 4
4 4
5 5
6 6
7 5
8 5
<<<sep_out_sample>>>
mov    %rdi,0x0(%rip)        # 1677 <yyset_out+0x7>
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
yyset_out (FILE * out_str )
{
        yyout = out_str ;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
movq   $0x0,(%rdi)
movq   $0x0,0x8(%rdi)
movq   $0x0,0x10(%rdi)
movq   $0x0,0x18(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x28(%rdi)
movq   $0x0,0x30(%rdi)
movq   $0x0,0x38(%rdi)
retq   
<<<sep_in_sample>>>
debpsf_deb_attributes_init(DEB_ATTRIBUTES * da)
{
 da->Package = ((void *)0);
 da->Version = ((void *)0);
 da->Version_epoch = ((void *)0);
 da->Version_revision = ((void *)0);
 da->Version_release = ((void *)0);
 da->Architecture = ((void *)0);
 da->Maintainer = ((void *)0);
 da->Description = ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 4
3 5
4 6
5 7
6 8
7 9
8 10
9 10
<<<sep_out_sample>>>
xor    %edx,%edx
jmpq   15a0 <info_node_of_tag_ext>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_node_of_tag (FILE_BUFFER *fb, TAG **tag_ptr)
{
  return info_node_of_tag_ext (fb, tag_ptr, 0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
mov    0x20(%rsi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gl_linked_node_value (gl_list_t list, gl_list_node_t node)
{
  return node->value;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rdx        # 3b <do_mark+0xb>
xorb   $0x1,0x58(%rdx)
jne    78 <do_mark+0x48>
mov    $0x0,%edi
callq  4b <do_mark+0x1b>
mov    %rax,%rdi
callq  53 <do_mark+0x23>
mov    0x0(%rip),%rax        # 5a <do_mark+0x2a>
movq   $0x0,0x60(%rax)
movq   $0x0,0x68(%rax)
add    $0x8,%rsp
jmpq   73 <do_mark+0x43>
nopl   0x0(%rax,%rax,1)
mov    $0x0,%edi
callq  82 <do_mark+0x52>
mov    %rax,%rdi
callq  8a <do_mark+0x5a>
mov    0x0(%rip),%rax        # 91 <do_mark+0x61>
mov    0x20(%rax),%rdx
movl   $0x1,0x70(%rax)
mov    %rdx,0x60(%rax)
mov    0x30(%rax),%rdx
mov    %rdx,0x68(%rax)
add    $0x8,%rsp
jmpq   b1 <do_mark+0x81>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
do_mark(void)
{
    openfile->mark_set = !openfile->mark_set;
    if (openfile->mark_set) {
 statusbar(gettext("Mark Set"));
 openfile->mark_begin = openfile->current;
 openfile->mark_begin_x = openfile->current_x;
 openfile->kind_of_mark = HARDMARK;
    } else {
 statusbar(gettext("Mark Unset"));
 openfile->mark_begin = ((void *)0);
 openfile->mark_begin_x = 0;
    }
    edit_refresh();
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 4
5 10
6 10
7 10
8 10
9 11
10 11
11 12
12 15
13 14
14 14
15 5
16 5
17 5
18 5
19 6
20 6
21 8
22 6
23 7
24 7
25 15
26 14
27 14
<<<sep_out_sample>>>
addq   $0x1,0x0(%rip)        # 98 <compare_entry+0x8>
mov    (%rsi),%rsi
mov    (%rdi),%rdi
jmpq   a3 <compare_entry+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
compare_entry(const void *a, const void *b)
{
    const struct index_entry *epa = a;
    const struct index_entry *epb = b;
    compare_count++;
    return utf8_strcasecmp(epa->word, epb->word);
}
<<<sep_in_sample>>>
1 5
2 6
3 6
4 6
5 6
<<<sep_out_sample>>>
cmpq   $0x2,0x8(%rsp)
mov    $0xffffffff,%eax
jne    39 <haar_init+0x39>
movq   $0x0,(%rdi)
xor    %eax,%eax
movq   $0x0,(%rsi)
movq   $0x0,(%rdx)
movq   $0x0,(%rcx)
movq   $0x2,(%r8)
movq   $0x0,(%r9)
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
haar_init (const double **h1, const double **g1, const double **h2,
           const double **g2, size_t * nc, size_t * offset,
           const size_t member)
{
  if (member != 2)
    {
      return GSL_FAILURE;
    }
  *h1 = ch_2;
  *g1 = cg_2;
  *h2 = ch_2;
  *g2 = cg_2;
  *nc = 2;
  *offset = 0;
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 9
5 15
6 10
7 11
8 12
9 13
10 14
11 16
12 16
<<<sep_out_sample>>>
mov    0x8(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_block_short_data (const gsl_block_short * b)
{
  return b->data ;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
mov    $0x1,%edi
push   %rbp
mov    %rsi,%rbp
mov    $0x8,%esi
push   %rbx
callq  199 <cdio_charset_converter_create+0x19>
mov    %r12,%rsi
mov    %rax,%rbx
mov    %rbp,%rdi
callq  1a7 <cdio_charset_converter_create+0x27>
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
pop    %rbp
pop    %r12
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_charset_converter_create(const char * src_charset,
                              const char * dst_charset)
  {
  cdio_charset_coverter_t * ret;
  ret = calloc(1, sizeof(*ret));
  ret->ic = iconv_open(dst_charset, src_charset);
  return ret;
  }
<<<sep_in_sample>>>
1 3
2 3
3 5
4 3
5 3
6 5
7 3
8 5
9 6
10 5
11 6
12 6
13 6
14 8
15 8
16 8
17 8
18 8
19 8
<<<sep_out_sample>>>
push   %r12
mov    %rdi,%r12
push   %rbp
xor    %ebp,%ebp
push   %rbx
mov    $0x0,%ebx
movsbl (%rbx),%esi
mov    %r12,%rdi
callq  29 <info_to_flags+0x19>
test   %rax,%rax
je     31 <info_to_flags+0x21>
or     0x4(%rbx),%ebp
add    $0x8,%rbx
cmp    $0x0,%rbx
jb     1e <info_to_flags+0xe>
pop    %rbx
mov    %ebp,%eax
pop    %rbp
pop    %r12
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_to_flags (char *buf)
{
  int flags = 0;
  struct info_map *p;
  for (p = info_map; p < info_map + (sizeof (info_map) / sizeof (info_map[0])); p++)
    if (strchr (buf, p->letter))
      flags |= p->flag;
  return flags;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 2
6 5
7 6
8 6
9 6
10 6
11 6
12 7
13 5
14 5
15 5
16 9
17 9
18 9
19 9
20 9
21 9
<<<sep_out_sample>>>
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_devices_osx(void)
{
  return ((void *)0);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     6e0 <mu_mailbox_messages_recent+0x20>
mov    0x88(%rdi),%rdx
test   %rdx,%rdx
je     6e0 <mu_mailbox_messages_recent+0x20>
testb  $0x8,0x31(%rdi)
mov    $0x1033,%eax
je     6f0 <mu_mailbox_messages_recent+0x30>
repz retq 
xchg   %ax,%ax
mov    $0x1003,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
jmpq   *%rdx
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mu_mailbox_messages_recent (mu_mailbox_t mbox, size_t *num)
{
  if (mbox == ((void *)0) || mbox->_messages_recent == ((void *)0))
    return (0x1000 +3);
  if (mbox->flags & 0x00000800)
    return (0x1000 +51);
  return mbox->_messages_recent (mbox, num);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 5
7 6
8 5
9 8
10 8
11 4
12 8
13 8
14 7
15 7
<<<sep_out_sample>>>
mov    $0x1,%esi
jmpq   1f40 <mbox_expunge0>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
mbox_expunge (mu_mailbox_t mailbox)
{
  return mbox_expunge0 (mailbox, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %r12
mov    %rdx,%r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
callq  3b2 <gsl_stats_ulong_lag1_autocorrelation+0x12>
mov    %rbx,%rdi
mov    %rbp,%rsi
mov    %r12,%rdx
pop    %rbx
pop    %rbp
pop    %r12
jmpq   3c4 <gsl_stats_ulong_lag1_autocorrelation+0x24>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_ulong_lag1_autocorrelation (const unsigned long data[], const size_t stride, const size_t n)
{
  const double mean = gsl_stats_ulong_mean (data, stride, n);
  return gsl_stats_ulong_lag1_autocorrelation_m(data, stride, n, mean);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 3
8 4
9 4
10 4
11 5
12 5
13 5
14 4
15 4
<<<sep_out_sample>>>
movapd %xmm0,%xmm4
movapd %xmm1,%xmm5
mulsd  %xmm2,%xmm1
mulsd  %xmm2,%xmm4
mulsd  %xmm3,%xmm5
mulsd  %xmm0,%xmm3
subsd  %xmm5,%xmm4
addsd  %xmm3,%xmm1
movapd %xmm4,%xmm0
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_complex_mul (gsl_complex a, gsl_complex b)
{
  double ar = ((a).dat[0]), ai = ((a).dat[1]);
  double br = ((b).dat[0]), bi = ((b).dat[1]);
  gsl_complex z;
  do {(&z)->dat[0]=(ar * br - ai * bi); (&z)->dat[1]=(ar * bi + ai * br);} while(0);
  return z;
}
<<<sep_in_sample>>>
1 6
2 6
3 6
4 6
5 6
6 6
7 6
8 8
9 8
10 8
11 8
<<<sep_out_sample>>>
jmpq   35 <rec_comment_dup+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_dup (rec_comment_t comment)
{
  return strdup (comment);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
sub    $0x28,%rsp
mov    %rsi,%rdx
lea    0x20(%rsi),%r11
xor    %ecx,%ecx
xor    %r8d,%r8d
mov    %rsp,%rsi
nopl   0x0(%rax,%rax,1)
movzbl 0x3(%rdx),%eax
movzbl 0x2(%rdx),%r9d
xor    %r10d,%r10d
shl    $0x10,%r9d
shl    $0x18,%eax
or     %r9d,%eax
movzbl (%rdx),%r9d
or     %r9d,%eax
movzbl 0x1(%rdx),%r9d
shl    $0x8,%r9d
or     %r9d,%eax
add    0x20(%rdi,%rcx,1),%r8d
mov    %eax,(%rsi,%rcx,1)
lea    (%rax,%r8,1),%r9d
setb   %r10b
xor    %r8d,%r8d
cmp    %r9d,%eax
mov    %r9d,0x20(%rdi,%rcx,1)
seta   %r8b
add    $0x4,%rdx
add    $0x4,%rcx
add    %r10d,%r8d
cmp    %r11,%rdx
jne    1248 <gost_compute_sum_and_hash+0x18>
callq  0 <gost_block_compress>
add    $0x28,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block)
{
    uint32_t block_le[8];
    unsigned i, carry;
    for (i = carry = 0; i < 8; i++, block += 4)
      {
   block_le[i] = ( (((uint32_t) (block)[3]) << 24) | (((uint32_t) (block)[2]) << 16) | (((uint32_t) (block)[1]) << 8) | ((uint32_t) (block)[0]));
          ctx->sum[i] += carry;
   carry = (ctx->sum[i] < carry);
          ctx->sum[i] += block_le[i];
          carry += (ctx->sum[i] < block_le[i]);
      }
    gost_block_compress (ctx, block_le);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 5
6 5
7 5
8 7
9 7
10 9
11 7
12 7
13 7
14 7
15 7
16 7
17 7
18 7
19 9
20 7
21 10
22 9
23 11
24 11
25 10
26 11
27 5
28 5
29 11
30 5
31 5
32 13
33 14
34 14
35 14
<<<sep_out_sample>>>
mov    %esi,%ecx
lea    0x8(%rdi),%rdx
lea    0x68(%rdi),%rsi
add    $0x40,%rdi
jmpq   0 <internal_set_format.isra.1>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
xformat_set_format (XFORMAT * xux, int format)
{
 ;
 internal_set_format(xux, (int*)(&(xux->format_codeM)), format);
}
<<<sep_in_sample>>>
1 2
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
push   %rbx
mov    0xc(%rdi),%eax
mov    %rdi,%rbx
add    $0x1,%eax
cmp    0x0(%rip),%eax        # 560 <smtp_client_quit+0x10>
mov    %eax,0xc(%rdi)
jge    570 <smtp_client_quit+0x20>
movl   $0x2,0x8(%rdi)
pop    %rbx
retq   
xchg   %ax,%ax
mov    0x0(%rip),%rsi        # 577 <smtp_client_quit+0x27>
xor    %edi,%edi
mov    $0x0,%edx
callq  583 <smtp_client_quit+0x33>
mov    0x18(%rbx),%rdx
mov    0x0(%rip),%rsi        # 58e <smtp_client_quit+0x3e>
xor    %edi,%edi
callq  595 <smtp_client_quit+0x45>
mov    0x18(%rbx),%rdi
mov    $0x0,%esi
callq  5a3 <smtp_client_quit+0x53>
test   %eax,%eax
je     5b0 <smtp_client_quit+0x60>
movl   $0x6,0x8(%rbx)
pop    %rbx
retq   
mov    %rbx,%rdi
pop    %rbx
jmpq   5b9 <smtp_client_quit+0x69>
nopl   0x0(%rax)
<<<sep_in_sample>>>
smtp_client_quit (struct smtp_client_context *ctx)
{
  if (++ctx->rcpt < x_argc)
    {
      ctx->state = smtp_client_state_mail;
    }
  else
    {
      swrite (0, remote_server, "QUIT""\r\n");
      smtp_reply_get (0, remote_server, ctx->reply);
      if (smtp_reply_code_eq (ctx->reply, "2"))
 ctx->state = smtp_client_state_stop;
      else
 smtp_client_failure (ctx);
    }
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 3
5 3
6 3
7 3
8 5
9 16
10 16
11 16
12 9
13 9
14 9
15 9
16 10
17 10
18 10
19 10
20 11
21 11
22 11
23 11
24 11
25 12
26 16
27 16
28 14
29 16
30 14
31 14
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x1,%edx
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
lea    0x8(%rsp),%rsi
callq  a8b <il_history_add_entry+0x1b>
test   %rax,%rax
je     ab0 <il_history_add_entry+0x40>
mov    0x8(%rsp),%rdi
mov    %rbp,%rsi
callq  a9d <il_history_add_entry+0x2d>
test   %eax,%eax
jne    ab0 <il_history_add_entry+0x40>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbp,%rdi
callq  ab8 <il_history_add_entry+0x48>
lea    0x8(%rsp),%rsi
mov    %rbx,%rdi
mov    %rax,0x8(%rsp)
callq  aca <il_history_add_entry+0x5a>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
il_history_add_entry(history, text)
    xstack_t *history;
    char *text;
{
    char *history_text;
    if (xstack_preview(history, &history_text, 1) &&
 strcmp(history_text, text) == 0)
 return;
    history_text = xstrdup(text);
    xstack_push(history, &history_text);
}
<<<sep_in_sample>>>
1 4
2 4
3 6
4 4
5 4
6 4
7 6
8 6
9 6
10 6
11 7
12 7
13 7
14 6
15 6
16 11
17 11
18 11
19 11
20 11
21 9
22 9
23 10
24 10
25 9
26 10
27 11
28 11
29 11
30 11
31 11
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x1a0(%rdi),%rdi
test   %rdi,%rdi
je     2880 <tar_stat_close+0x50>
callq  2845 <tar_stat_close+0x15>
mov    %eax,%edx
test   %edx,%edx
movq   $0x0,0x1a0(%rbx)
movl   $0x0,0x1a8(%rbx)
mov    $0x1,%eax
jne    2870 <tar_stat_close+0x40>
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    (%rbx),%rdi
callq  2878 <tar_stat_close+0x48>
xor    %eax,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
mov    0x1a8(%rbx),%edi
test   %edi,%edi
jle    2898 <tar_stat_close+0x68>
callq  288f <tar_stat_close+0x5f>
mov    %eax,%edx
jmp    2847 <tar_stat_close+0x17>
nopl   0x0(%rax,%rax,1)
movl   $0x0,0x1a8(%rbx)
mov    $0x1,%eax
pop    %rbx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
tar_stat_close (struct tar_stat_info *st)
{
  int status = (st->dirstream ? closedir (st->dirstream)
  : 0 < st->fd ? close (st->fd)
  : 0);
  st->dirstream = 0;
  st->fd = 0;
  if (status == 0)
    return 1;
  else
    {
      close_diag (st->orig_file_name);
      return 0;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 4
8 8
9 6
10 7
11 9
12 8
13 15
14 15
15 15
16 12
17 12
18 13
19 15
20 15
21 15
22 4
23 5
24 5
25 5
26 5
27 5
28 5
29 7
30 9
31 15
32 15
33 15
<<<sep_out_sample>>>
mov    $0xd0000,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gss_wrap_size_limit (OM_uint32 * minor_status,
       const gss_ctx_id_t context_handle,
       int conf_req_flag,
       gss_qop_t qop_req,
       OM_uint32 req_output_size, OM_uint32 * max_input_size)
{
  return (13ul << 16);
}
<<<sep_in_sample>>>
1 8
2 8
3 8
<<<sep_out_sample>>>
sub    $0x18,%rsp
movl   $0x1,(%rsp)
callq  1e30 <set>
add    $0x18,%rsp
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
lmsder_set (void *vstate, const gsl_vector * swts,
            gsl_multifit_function_fdf * fdf, gsl_vector * x,
            gsl_vector * f, gsl_vector * dx)
{
  int status = set (vstate, swts, fdf, x, f, dx, 1);
  return status ;
}
<<<sep_in_sample>>>
1 4
2 5
3 5
4 7
5 7
6 7
<<<sep_out_sample>>>
push   %r15
push   %r14
xor    %r14d,%r14d
push   %r13
push   %r12
xor    %r12d,%r12d
push   %rbp
push   %rbx
mov    %r8,%rbx
sub    $0x28,%rsp
test   %r8,%r8
movss  (%rdx),%xmm3
mov    %rdi,0x10(%rsp)
mov    %rsi,0x18(%rsp)
movss  %xmm3,0x8(%rsp)
je     b81 <gsl_stats_float_minmax_index+0xa1>
lea    0x0(,%rcx,4),%rbp
movss  0x8(%rsp),%xmm2
movss  %xmm2,0xc(%rsp)
movaps %xmm2,%xmm0
lea    (%rdx,%rbp,1),%r15
xor    %r12d,%r12d
xor    %r14d,%r14d
xor    %r13d,%r13d
jmp    b65 <gsl_stats_float_minmax_index+0x85>
nopw   %cs:0x0(%rax,%rax,1)
add    $0x1,%r14
cmp    %rbx,%r14
je     ba0 <gsl_stats_float_minmax_index+0xc0>
movss  (%r15),%xmm0
movss  0x8(%rsp),%xmm1
ucomiss %xmm0,%xmm1
jbe    b62 <gsl_stats_float_minmax_index+0x82>
movss  %xmm0,0x8(%rsp)
mov    %r14,%r13
add    %rbp,%r15
ucomiss 0xc(%rsp),%xmm0
jbe    b75 <gsl_stats_float_minmax_index+0x95>
movss  %xmm0,0xc(%rsp)
mov    %r14,%r12
callq  b7a <gsl_stats_float_minmax_index+0x9a>
test   %eax,%eax
je     b40 <gsl_stats_float_minmax_index+0x60>
mov    %r14,%r12
mov    0x10(%rsp),%rax
mov    %r14,(%rax)
mov    0x18(%rsp),%rax
mov    %r12,(%rax)
add    $0x28,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
mov    %r13,%r14
jmp    b81 <gsl_stats_float_minmax_index+0xa1>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_float_minmax_index (size_t * min_index_out,
                                   size_t * max_index_out, const float data[],
                                   const size_t stride, const size_t n)
{
  float min = data[0 * stride];
  float max = data[0 * stride];
  size_t i, min_index = 0, max_index = 0;
  for (i = 0; i < n; i++)
    {
      float xi = data[i * stride];
      if (xi < min)
        {
          min = xi;
          min_index = i;
        }
      if (xi > max)
        {
          max = xi;
          max_index = i;
        }
      if ((sizeof (xi) == sizeof (float) ? __isnanf (xi) : sizeof (xi) == sizeof (double) ? __isnan (xi) : __isnanl (xi)))
        {
          min_index = i;
          max_index = i;
          break;
        }
    }
  *min_index_out = min_index;
  *max_index_out = max_index;
}
<<<sep_in_sample>>>
1 4
2 4
3 7
4 4
5 4
6 7
7 4
8 4
9 4
10 4
11 8
12 5
13 4
14 4
15 5
16 8
17 10
18 6
19 6
20 10
21 10
22 7
23 8
24 7
25 7
26 7
27 8
28 8
29 8
30 10
31 11
32 11
33 11
34 10
35 10
36 10
37 16
38 16
39 16
40 16
41 21
42 21
43 21
44 21
45 28
46 28
47 29
48 29
49 30
50 30
51 30
52 30
53 30
54 30
55 30
56 30
57 30
58 30
59 30
<<<sep_out_sample>>>
testb  $0x1,(%rdx)
jne    17e0 <system_configure+0x10>
xor    %eax,%eax
retq   
nopl   0x0(%rax,%rax,1)
push   %rbx
mov    0x4(%rdx),%eax
mov    %rsi,%rbx
mov    %rsi,%rdx
mov    %eax,0x10(%rsi)
xor    %eax,%eax
mov    $0x8943,%esi
callq  17f9 <system_configure+0x29>
test   %eax,%eax
js     1820 <system_configure+0x50>
mov    0x0(%rip),%eax        # 1803 <system_configure+0x33>
test   %eax,%eax
je     1819 <system_configure+0x49>
mov    0x10(%rbx),%edx
mov    %rbx,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  1819 <system_configure+0x49>
xor    %eax,%eax
pop    %rbx
retq   
nopl   (%rax)
callq  1825 <system_configure+0x55>
mov    (%rax),%esi
mov    $0x0,%edx
xor    %edi,%edi
xor    %eax,%eax
callq  1835 <system_configure+0x65>
jmp    17fd <system_configure+0x2d>
<<<sep_in_sample>>>
system_configure (int sfd, struct ifreq *ifr, struct system_ifconfig *ifs)
{
  if (ifs->valid & 0x1)
    {
      int err = 0;
      ifr->ifr_ifru.ifru_ivalue = ifs->txqlen;
      err = rpl_ioctl (sfd, 0x8943, ifr);
      if (err < 0)
 error (0, (*__errno_location ()), "SIOCSIFTXQLEN failed");
      if (verbose)
 printf ("Set txqlen value of `%s' to `%i'.\n",
  ifr->ifr_ifrn.ifrn_name, ifr->ifr_ifru.ifru_ivalue);
    }
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 15
4 15
5 15
6 2
7 6
8 6
9 7
10 6
11 7
12 7
13 7
14 8
15 8
16 10
17 10
18 10
19 11
20 11
21 11
22 11
23 11
24 15
25 15
26 15
27 15
28 9
29 9
30 9
31 9
32 9
33 9
34 9
<<<sep_out_sample>>>
mov    0x0(%rip),%edi        # 226 <swlib_tty_atexit+0x6>
test   %edi,%edi
js     230 <swlib_tty_atexit+0x10>
jmpq   22f <swlib_tty_atexit+0xf>
nop
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
swlib_tty_atexit(void)
{
 if (ttysavefd >= 0)
  swlib_tty_reset(ttysavefd);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
6 4
7 4
<<<sep_out_sample>>>
mov    %edi,%eax
retq   
<<<sep_in_sample>>>
CDB___lock_locker_hash(locker)
 u_int32_t locker;
{
 return (locker);
}
<<<sep_in_sample>>>
1 3
2 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 797 <stop_all+0x7>
test   %rax,%rax
je     7f1 <stop_all+0x61>
mov    0x0(%rip),%edx        # 7a2 <stop_all+0x12>
test   %edx,%edx
je     7f1 <stop_all+0x61>
push   %rbp
mov    %edi,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x8,%rsp
jmp    7ce <stop_all+0x3e>
nopw   0x0(%rax,%rax,1)
mov    0x0(%rip),%eax        # 7be <stop_all+0x2e>
add    $0x1,%rbx
cmp    %rbx,%rax
jbe    7eb <stop_all+0x5b>
mov    0x0(%rip),%rax        # 7ce <stop_all+0x3e>
mov    (%rax,%rbx,4),%esi
test   %esi,%esi
je     7b8 <stop_all+0x28>
mov    %ebp,%edi
add    $0x1,%rbx
callq  7e0 <stop_all+0x50>
mov    0x0(%rip),%eax        # 7e6 <stop_all+0x56>
cmp    %rbx,%rax
ja     7c7 <stop_all+0x37>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
repz retq 
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
stop_all(int sig)
{
    unsigned long i;
    if (!childtab)
 return;
    for (i = 0; i < max_children; i++)
 if (childtab[i])
     kill(sig, childtab[i]);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 6
5 6
6 6
7 2
8 2
9 2
10 6
11 2
12 2
13 2
14 6
15 6
16 6
17 6
18 6
19 7
20 7
21 7
22 8
23 6
24 8
25 6
26 6
27 6
28 9
29 9
30 9
31 9
32 9
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
test   %rsi,%rsi
je     1938 <internal_strmatch+0x58>
test   %rdi,%rdi
mov    %rdi,%rbp
je     1938 <internal_strmatch+0x58>
mov    %rsi,%rdi
mov    %edx,%r12d
callq  1905 <internal_strmatch+0x25>
mov    %rbp,%rdi
mov    %rax,%r13
callq  1910 <internal_strmatch+0x30>
add    $0x8,%rsp
lea    (%rbx,%r13,1),%rsi
mov    %rbx,%rdi
pop    %rbx
lea    0x0(%rbp,%rax,1),%rcx
mov    %rbp,%rdx
mov    %r12d,%r8d
pop    %rbp
pop    %r12
pop    %r13
jmpq   500 <gmatch.part.1>
nopl   0x0(%rax)
add    $0x8,%rsp
mov    $0x1,%eax
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
internal_strmatch (pattern, string, flags)
     unsigned char *pattern;
     unsigned char *string;
     int flags;
{
  unsigned char *se, *pe;
  if (string == 0 || pattern == 0)
    return 1;
  se = string + strlen((char *)string);
  pe = pattern + strlen((char *)pattern);
  return (gmatch (string, se, pattern, pe, flags));
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 7
8 7
9 7
10 7
11 7
12 9
13 9
14 9
15 10
16 9
17 10
18 12
19 9
20 9
21 12
22 10
23 10
24 10
25 12
26 12
27 12
28 12
29 12
30 12
31 12
32 12
33 12
34 12
35 12
36 12
37 12
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
push   %rbx
mov    $0x5d,%edx
mov    $0x0,%esi
mov    $0x20,%edi
callq  315 <array_create+0x15>
mov    $0xffffffffffffffff,%rdi
mov    %rax,%rbx
movl   $0x0,(%rax)
mov    %rdi,0x8(%rax)
movl   $0x0,0x10(%rax)
xor    %esi,%esi
callq  337 <array_create+0x37>
mov    %rax,0x10(%rax)
mov    %rax,0x18(%rax)
mov    %rax,0x18(%rbx)
mov    %rbx,%rax
pop    %rbx
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
array_create()
{
 ARRAY *r;
 ARRAY_ELEMENT *head;
 r =(ARRAY *)sh_xmalloc((sizeof(ARRAY)), "array.c", 93);
 r->type = array_indexed;
 r->max_index = -1;
 r->num_elements = 0;
 head = array_create_element(-1, (char *)((void *)0));
 head->prev = head->next = head;
 r->head = head;
 return(r);
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 5
6 7
7 5
8 6
9 7
10 8
11 9
12 9
13 10
14 10
15 11
16 13
17 13
18 13
19 13
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     619 <get_page_start+0x29>
mov    0x0(%rip),%edx        # 5fd <get_page_start+0xd>
lea    -0x1(%rdx),%ecx
movslq %ecx,%rcx
cmp    %rcx,%rdi
jb     619 <get_page_start+0x29>
cmp    $0x8,%edx
jg     620 <get_page_start+0x30>
sub    $0x2,%edx
mov    %rdi,%rax
movslq %edx,%rdx
sub    %rdx,%rax
repz retq 
nopl   0x0(%rax,%rax,1)
sub    $0x7,%rdi
sub    $0x8,%edx
movslq %edx,%rcx
mov    %rdi,%rax
xor    %edx,%edx
div    %rcx
mov    %rdi,%rax
sub    %rdx,%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_page_start(size_t column)
{
    if (column == 0 || column < COLS - 1)
 return 0;
    else if (COLS > 8)
 return column - 7 - (column - 7) % (COLS - 8);
    else
 return column - (COLS - 2);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3
5 3
6 3
7 3
8 3
9 5
10 5
11 8
12 8
13 8
14 8
15 9
16 9
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x0(%rip),%rdi        # 564b <bash_re_edit+0xb>
test   %rdi,%rdi
je     565f <bash_re_edit+0x1f>
mov    $0x29d,%edx
mov    $0x0,%esi
callq  565f <bash_re_edit+0x1f>
mov    %rbx,%rdi
callq  5667 <bash_re_edit+0x27>
lea    0x1(%rax),%rdi
mov    $0x29f,%edx
mov    $0x0,%esi
callq  567a <bash_re_edit+0x3a>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  5685 <bash_re_edit+0x45>
mov    %rax,0x0(%rip)        # 568c <bash_re_edit+0x4c>
mov    0x0(%rip),%rax        # 5693 <bash_re_edit+0x53>
pop    %rbx
movq   $0x0,0x0(%rip)        # 569f <bash_re_edit+0x5f>
mov    %rax,0x0(%rip)        # 56a6 <bash_re_edit+0x66>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
bash_re_edit (line)
     char *line;
{
  do { if (push_to_readline) sh_xfree((push_to_readline), "bashline.c", 669); } while (0);
  push_to_readline = (char *)strcpy (sh_xmalloc((1 + strlen (line)), "bashline.c", 671), (line));
  old_rl_startup_hook = rl_startup_hook;
  rl_startup_hook = bash_push_line;
  return (0);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
11 5
12 5
13 5
14 5
15 5
16 5
17 5
18 5
19 6
20 9
21 7
22 6
23 9
24 9
25 9
<<<sep_out_sample>>>
mov    %rdi,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
find_reverse_change (struct change *start)
{
  return start;
}
<<<sep_in_sample>>>
1 2
2 4
3 4
<<<sep_out_sample>>>
movsd  0x18(%rdi),%xmm0
addsd  0x28(%rdi),%xmm0
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
timer_get_system(xdico_timer_t t)
{
    return t->self_system + t->children_system;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6 <gsl_multiset_get+0x6>
test   %eax,%eax
je     10 <gsl_multiset_get+0x10>
cmp    %rsi,0x8(%rdi)
jbe    20 <gsl_multiset_get+0x20>
mov    0x10(%rdi),%rax
mov    (%rax,%rsi,8),%rax
retq   
nopl   0x0(%rax)
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0x53,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  3d <gsl_multiset_get+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
<<<sep_in_sample>>>
gsl_multiset_get (const gsl_multiset * c, const size_t i)
{
  if ((gsl_check_range && (i >= c->k)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_multiset.h", 83, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return c->data[i];
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 2
11 5
12 5
13 5
14 5
15 5
16 5
17 8
18 8
<<<sep_out_sample>>>
divsd  %xmm1,%xmm0
sub    $0x8,%rsp
movsd  0x0(%rip),%xmm1        # 10 <gsl_cdf_cauchy_P+0x10>
ucomisd %xmm1,%xmm0
jbe    30 <gsl_cdf_cauchy_P+0x30>
callq  1b <gsl_cdf_cauchy_P+0x1b>
divsd  0x0(%rip),%xmm0        # 23 <gsl_cdf_cauchy_P+0x23>
addsd  0x0(%rip),%xmm0        # 2b <gsl_cdf_cauchy_P+0x2b>
add    $0x8,%rsp
retq   
divsd  %xmm0,%xmm1
movapd %xmm1,%xmm0
callq  3d <gsl_cdf_cauchy_P+0x3d>
divsd  0x0(%rip),%xmm0        # 45 <gsl_cdf_cauchy_P+0x45>
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_cdf_cauchy_P (const double x, const double a)
{
  double P;
  double u = x / a;
  if (u > -1)
    {
      P = 0.5 + atan (u) / 3.14159265358979323846;
    }
  else
    {
      P = atan(-1/u) / 3.14159265358979323846;
    }
  return P;
}
<<<sep_in_sample>>>
1 4
2 2
3 5
4 5
5 5
6 7
7 7
8 7
9 14
10 14
11 11
12 11
13 11
14 11
15 14
16 14
17 14
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
mov    0x10(%rsi),%rcx
mov    0x8(%rsi),%rdx
mov    %rdi,%rax
cmp    %rdx,(%rsi)
mov    0x18(%rsi),%rdi
cmovbe (%rsi),%rdx
movl   $0x0,0x20(%rax)
lea    0x1(%rcx),%r8
mov    0x20(%rsi),%rcx
mov    %rdi,0x10(%rax)
mov    %r8,0x8(%rax)
mov    %rdx,(%rax)
mov    %rcx,0x18(%rax)
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_long_double_diagonal (gsl_matrix_complex_long_double * m)
{
  _gsl_vector_complex_long_double_view view = {{0, 0, 0, 0, 0}};
  gsl_vector_complex_long_double v = {0, 0, 0, 0, 0};
  v.data = m->data;
  v.size = ((m->size1) < (m->size2) ? (m->size1) : (m->size2));
  v.stride = m->tda + 1;
  v.block = m->block;
  v.owner = 0;
  view.vector = v;
  return view;
}
<<<sep_in_sample>>>
1 7
2 6
3 2
4 6
5 5
6 6
7 11
8 7
9 8
10 11
11 11
12 11
13 11
14 12
15 12
<<<sep_out_sample>>>
mov    %rdx,%rax
mov    0x8(%rdx),%rcx
mov    0x10(%rdx),%rdx
mov    (%rax),%r8
jmpq   9d3 <gsl_sort_vector_ulong_largest+0x13>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_ulong_largest (unsigned long * dest, const size_t k,
                                    const gsl_vector_ulong * v)
{
  return gsl_sort_ulong_largest (dest, k, v->data, v->stride, v->size);
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
5 4
6 4
<<<sep_out_sample>>>
mov    %esi,%eax
test   %rsi,%rsi
mov    $0x1105,%edx
cmovne %rax,%rdx
xor    %eax,%eax
mov    %rdx,(%rdi)
jmp    22c <mt_1998_set+0x1c>
nopl   (%rax)
mov    (%rdi,%rax,1),%rdx
imul   $0x10dcd,%edx,%edx
mov    %rdx,0x8(%rdi,%rax,1)
add    $0x8,%rax
cmp    $0x1378,%rax
jne    228 <mt_1998_set+0x18>
movl   $0x270,0x1380(%rdi)
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mt_1998_set (void *vstate, unsigned long int s)
{
  mt_state_t *state = (mt_state_t *) vstate;
  int i;
  if (s == 0)
    s = 4357;
  state->mt[0] = s & 0xffffffffUL;
  for (i = 1; i < 624; i++)
    state->mt[i] = ((69069 * state->mt[i - 1]) & 0xffffffffUL);
  state->mti = i;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 7
6 7
7 7
8 7
9 7
10 9
11 9
12 9
13 8
14 8
15 10
16 10
17 10
<<<sep_out_sample>>>
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
start_pass_downsample (j_compress_ptr cinfo)
{
}
<<<sep_in_sample>>>
1 2
2 2
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
xor    %edi,%edi
callq  235a <tty_init+0xa>
test   %eax,%eax
je     23e7 <tty_init+0x97>
mov    $0x1,%edi
callq  236c <tty_init+0x1c>
test   %eax,%eax
je     23e7 <tty_init+0x97>
mov    $0x1,%edi
callq  237a <tty_init+0x2a>
test   %rax,%rax
mov    %rax,0x0(%rip)        # 2384 <tty_init+0x34>
je     240b <tty_init+0xbb>
mov    $0x0,%esi
mov    $0x1,%edi
callq  2399 <tty_init+0x49>
mov    $0x40,%edi
callq  23a3 <tty_init+0x53>
mov    0x0(%rip),%rdi        # 23aa <tty_init+0x5a>
mov    %ebx,0x0(%rip)        # 23b0 <tty_init+0x60>
mov    %rax,0x0(%rip)        # 23b7 <tty_init+0x67>
mov    %rax,0x0(%rip)        # 23be <tty_init+0x6e>
movq   $0x0,0x0(%rip)        # 23c9 <tty_init+0x79>
movq   $0x0,0x0(%rip)        # 23d4 <tty_init+0x84>
callq  23d9 <tty_init+0x89>
pop    %rbx
mov    %eax,0x0(%rip)        # 23e0 <tty_init+0x90>
xor    %eax,%eax
jmpq   23e7 <tty_init+0x97>
mov    0x0(%rip),%rdi        # 23ee <tty_init+0x9e>
mov    0x0(%rip),%rdx        # 23f5 <tty_init+0xa5>
mov    $0x0,%esi
xor    %eax,%eax
callq  2401 <tty_init+0xb1>
mov    $0x1,%edi
callq  240b <tty_init+0xbb>
mov    0x0(%rip),%rdi        # 2412 <tty_init+0xc2>
mov    0x0(%rip),%rdx        # 2419 <tty_init+0xc9>
mov    $0x0,%esi
callq  2423 <tty_init+0xd3>
mov    $0x1,%edi
callq  242d <tty_init+0xdd>
nopl   (%rax)
<<<sep_in_sample>>>
tty_init(kbd_mode)
    int kbd_mode;
{
    if (!isatty(0) || !isatty(1))
    {
 fprintf(stderr, "%s: only stderr can be redirected.\n", g_program);
 exit(1);
    }
    if ((tty_device = ttyname(1)) == ((void *)0))
    {
 fprintf(stderr, "%s: can't get terminal name.\n", g_program);
 exit(1);
    }
    tcgetattr(1, &old_term);
    default_key.key_seq = tty_key_seq = (unsigned char *)xmalloc(64);
    default_key.aux_data = ((void *)0);
    default_key.next = ((void *)0);
    tty_kbdmode = kbd_mode;
    tty_device_length = strlen(tty_device);
    tty_get_capabilities();
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 4
10 4
11 9
12 9
13 9
14 9
15 9
16 14
17 14
18 14
19 15
20 15
21 19
22 18
23 15
24 15
25 16
26 17
27 19
28 21
29 19
30 20
31 20
32 6
33 6
34 6
35 6
36 6
37 7
38 7
39 11
40 11
41 11
42 11
43 12
44 12
45 12
<<<sep_out_sample>>>
push   %r14
test   %rdi,%rdi
push   %r13
push   %r12
push   %rbp
push   %rbx
mov    %rdi,%rbx
jne    100 <AddEquation+0x20>
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nopl   0x0(%rax)
test   %rsi,%rsi
mov    %rsi,%r12
je     f0 <AddEquation+0x10>
mov    $0x20,%edi
mov    %rdx,%r14
mov    %rcx,%r13
callq  118 <AddEquation+0x38>
test   %rax,%rax
mov    %rax,%rbp
je     150 <AddEquation+0x70>
mov    %r12,%rdi
callq  128 <AddEquation+0x48>
mov    %r14,%rdi
mov    %rax,0x0(%rbp)
callq  134 <AddEquation+0x54>
mov    %rax,0x8(%rbp)
mov    (%rbx),%rax
mov    %r13,0x10(%rbp)
mov    %rax,0x18(%rbp)
mov    %rbp,(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
retq   
nop
pop    %rbx
pop    %rbp
mov    %r12,%rdx
mov    $0x0,%ecx
mov    $0x8004,%esi
pop    %r12
pop    %r13
pop    %r14
xor    %edi,%edi
jmpq   16c <AddEquation+0x8c>
nopl   0x0(%rax)
<<<sep_in_sample>>>
AddEquation (PVMMAPSTRCT *ppvm, PSTR szName, PSTR szEqn, HANDLE hType)
{
  PVMMAPSTRCT pvmNew;
  if (!ppvm || !szName)
    return;
  if ((pvmNew = (PVMMAPSTRCT) malloc (sizeof(VMMAPSTRCT)))) {
    pvmNew->szName = CopyString (szName);
    pvmNew->szEqn = CopyString (szEqn);
    pvmNew->hType = hType;
    pvmNew->pvmNextVar = *ppvm;
    *ppvm = pvmNew;
  }
  else
    ReportError (((void *)0), 0x0004 | 0x8000, szName,
                 "* .. creating new equation in AddEquation");
}
<<<sep_in_sample>>>
1 2
2 4
3 2
4 2
5 2
6 2
7 2
8 4
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 4
17 4
18 4
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 7
27 7
28 8
29 7
30 8
31 8
32 10
33 9
34 10
35 11
36 16
37 16
38 16
39 16
40 16
41 16
42 16
43 16
44 16
45 14
46 14
47 14
48 16
49 16
50 16
51 14
52 14
53 14
<<<sep_out_sample>>>
mov    0x10(%rdx),%r8
cmp    $0x5,%r8
jbe    62b0 <_jit_getarg_us+0x20>
movslq %esi,%rdx
mov    $0xf,%ecx
mov    $0x6b,%esi
jmpq   62ac <_jit_getarg_us+0x1c>
nopl   0x0(%rax)
mov    $0xd,%ecx
movslq %esi,%rdx
mov    $0x50,%esi
sub    %r8,%rcx
jmpq   62c5 <_jit_getarg_us+0x35>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_jit_getarg_us(jit_state_t *_jit, jit_int32_t u, jit_node_t *v)
{
    ((void) (0));
    if (((v->u.w) >= 0 && (v->u.w) < 6))
 _jit_new_node_ww(_jit,jit_code_extr_us,u,_RDI - v->u.w);
    else
 _jit_new_node_www(_jit,jit_code_ldxi_us,u,_RBP,v->u.w);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 7
5 7
6 7
7 7
8 7
9 5
10 5
11 5
12 5
13 5
14 5
<<<sep_out_sample>>>
push   %rbp
push   %rbx
movslq %edi,%rbx
sub    $0x8,%rsp
movslq 0x0(%rip),%rax        # 910 <saveCopyFile+0x10>
cmp    $0x14,%eax
jg     978 <saveCopyFile+0x78>
mov    0x0(%rip),%rsi        # 91c <saveCopyFile+0x1c>
mov    0x0(,%rax,8),%rdi
callq  929 <saveCopyFile+0x29>
movslq 0x0(%rip),%rax        # 930 <saveCopyFile+0x30>
mov    0x0(,%rax,8),%rbp
mov    %rbp,%rdi
callq  940 <saveCopyFile+0x40>
mov    $0x2f,%edx
mov    %dx,0x0(%rbp,%rax,1)
movslq 0x0(%rip),%rax        # 951 <saveCopyFile+0x51>
mov    0x0(,%rbx,8),%rsi
mov    0x0(,%rax,8),%rdi
callq  966 <saveCopyFile+0x66>
addl   $0x1,0x0(%rip)        # 96d <saveCopyFile+0x6d>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax)
mov    $0x1,%edx
mov    $0x1,%esi
mov    $0x0,%edi
callq  98c <saveCopyFile+0x8c>
mov    0x0(,%rbx,8),%rdx
mov    0x0(%rip),%rdi        # 99b <saveCopyFile+0x9b>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
mov    $0x0,%esi
xor    %eax,%eax
jmpq   9ad <saveCopyFile+0xad>
nopl   (%rax)
<<<sep_in_sample>>>
saveCopyFile(int i)
{
  if(numCopyFiles > 20)
  {
    msgBox("Unable to perform operation.\nClipboard is full.", 1, ERROR);
    fprintf(log_file, "Unable to copy file '%s'.. Clipboard is full\n", files[i]);
    return;
  }
  strcpy(copyFiles[numCopyFiles], cwd);
  strcat(copyFiles[numCopyFiles], "/");
  strcat(copyFiles[numCopyFiles], files[i]);
  strcat(copyFiles[numCopyFiles++], "\0");
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 3
7 3
8 9
9 9
10 9
11 10
12 10
13 10
14 10
15 10
16 10
17 11
18 11
19 11
20 11
21 12
22 13
23 13
24 13
25 13
26 13
27 5
28 5
29 5
30 5
31 6
32 6
33 13
34 13
35 13
36 6
37 6
38 6
39 6
<<<sep_out_sample>>>
test   %rdi,%rdi
je     8e <freea+0xe>
cmpl   $0x1415fb4a,-0x4(%rdi)
je     90 <freea+0x10>
repz retq 
mov    %rdi,%rax
movabs $0xff00ff00ff00ff01,%rdx
mul    %rdx
shr    $0x8,%rdx
mov    %rdx,%rax
shl    $0x8,%rax
add    %rax,%rdx
mov    %rdi,%rax
sub    %rdx,%rax
mov    0x0(,%rax,8),%rcx
test   %rcx,%rcx
je     8e <freea+0xe>
cmp    %rcx,%rdi
jne    d8 <freea+0x58>
jmp    fc <freea+0x7c>
nopl   0x0(%rax,%rax,1)
cmp    %rdx,%rdi
je     e8 <freea+0x68>
mov    %rdx,%rcx
mov    -0x10(%rcx),%rdx
test   %rdx,%rdx
jne    d0 <freea+0x50>
jmp    8e <freea+0xe>
nopl   0x0(%rax,%rax,1)
sub    $0x10,%rcx
mov    -0x10(%rdi),%rax
sub    $0x10,%rdi
mov    %rax,(%rcx)
jmpq   fc <freea+0x7c>
lea    0x0(,%rax,8),%rcx
jmp    ec <freea+0x6c>
<<<sep_in_sample>>>
freea (void *p)
{
  if (p != ((void *)0))
    {
      if (((int *) p)[-1] == 0x1415fb4a)
        {
          size_t slot = (uintptr_t) p % 257;
          void **chain = &mmalloca_results[slot];
          for (; *chain != ((void *)0);)
            {
              union header *h = p;
              if (*chain == p)
                {
                  union header *p_begin = h - 1;
                  *chain = p_begin->next;
                  free (p_begin);
                  return;
                }
              h = *chain;
              chain = &h[-1].next;
            }
        }
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 7
7 7
8 7
9 7
10 7
11 7
12 7
13 7
14 7
15 9
16 9
17 9
18 12
19 12
20 12
21 12
22 12
23 12
24 12
25 9
26 9
27 9
28 9
29 9
30 20
31 15
32 14
33 15
34 16
35 8
36 8
<<<sep_out_sample>>>
cmp    $0x9,%edi
sete   %dl
cmp    $0x20,%edi
sete   %al
or     %dl,%al
jne    e9 <c_isspace+0x19>
sub    $0xa,%edi
cmp    $0x3,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isspace (int c)
{
  return (c == ' ' || c == '\t'
          || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 4
6 4
7 4
8 4
9 4
10 5
11 5
<<<sep_out_sample>>>
mov    0x58(%rdi),%rax
mov    0x60(%rdi),%rdx
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
get_stat_mtime (struct stat const *st)
{
  return ((st)->st_mtim);
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    (%rdi),%rcx
cmp    (%rsi),%rcx
je     4c0 <gsl_sort_vector_index+0x30>
mov    $0x13,%ecx
mov    $0x64,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  4b5 <gsl_sort_vector_index+0x25>
mov    $0x13,%eax
add    $0x8,%rsp
retq   
nop
mov    0x8(%rsi),%rdx
mov    0x8(%rdi),%rdi
mov    0x10(%rsi),%rsi
callq  4d1 <gsl_sort_vector_index+0x41>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_sort_vector_index (gsl_permutation * permutation, const gsl_vector * v)
{
  if (permutation->size != v->size)
    {
      do { gsl_error ("permutation and vector lengths are not equal", "sortvecind_source.c", 100, GSL_EBADLEN) ; return GSL_EBADLEN ; } while (0);
    }
  gsl_sort_index (permutation->data, v->data, v->stride, v->size) ;
  return GSL_SUCCESS ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 5
8 5
9 5
10 5
11 9
12 9
13 9
14 7
15 7
16 7
17 7
18 8
19 9
20 9
21 9
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 6706 <set_directory_hook+0x6>
test   %eax,%eax
jne    6728 <set_directory_hook+0x28>
movq   $0x0,0x0(%rip)        # 6715 <set_directory_hook+0x15>
movq   $0x0,0x0(%rip)        # 6720 <set_directory_hook+0x20>
retq   
nopl   0x0(%rax)
movq   $0x0,0x0(%rip)        # 6733 <set_directory_hook+0x33>
movq   $0x0,0x0(%rip)        # 673e <set_directory_hook+0x3e>
retq   
nop
<<<sep_in_sample>>>
set_directory_hook ()
{
  if (dircomplete_expand)
    {
      rl_directory_completion_hook = bash_directory_completion_hook;
      rl_directory_rewrite_hook = (rl_icppfunc_t *)0;
    }
  else
    {
      rl_directory_rewrite_hook = bash_directory_completion_hook;
      rl_directory_completion_hook = (rl_icppfunc_t *)0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 10
5 11
6 11
7 11
8 5
9 6
10 6
11 6
<<<sep_out_sample>>>
test   %edi,%edi
js     8e <c_iscntrl+0xe>
cmp    $0x1f,%edi
jle    98 <c_iscntrl+0x18>
cmp    $0x7f,%edi
je     98 <c_iscntrl+0x18>
xor    %eax,%eax
retq   
nopl   0x0(%rax)
mov    $0x1,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
c_iscntrl (int c)
{
  switch (c)
    {
    case '\a': case '\b': case '\f': case '\n': case '\r': case '\t': case '\v': case '\x00': case '\x01': case '\x02': case '\x03': case '\x04': case '\x05': case '\x06': case '\x0e': case '\x0f': case '\x10': case '\x11': case '\x12': case '\x13': case '\x14': case '\x15': case '\x16': case '\x17': case '\x18': case '\x19': case '\x1a': case '\x1b': case '\x1c': case '\x1d': case '\x1e': case '\x1f': case '\x7f':
      return 1;
    default:
      return 0;
    }
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 8
8 10
9 10
10 6
11 6
12 6
<<<sep_out_sample>>>
push   %rbp
mov    $0x0,%eax
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x8,%rsp
mov    0x0(%rip),%rcx        # 23c8 <pty_output_datalen+0x18>
sub    %rcx,%rax
cmp    %rsi,%rax
jbe    23dc <pty_output_datalen+0x2c>
callq  23d5 <pty_output_datalen+0x25>
mov    0x0(%rip),%rcx        # 23dc <pty_output_datalen+0x2c>
mov    %rbx,%rdx
mov    %rbp,%rsi
mov    %rcx,%rdi
callq  23ea <pty_output_datalen+0x3a>
add    %rax,%rbx
mov    %rbx,0x0(%rip)        # 23f4 <pty_output_datalen+0x44>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pty_output_datalen (const void *data, size_t len)
{
  if ((size_t) (&ptyobuf[8192] - pfrontp) > len)
    ptyflush ();
  memcpy (pfrontp, data, len);
  pfrontp += len;
}
<<<sep_in_sample>>>
1 2
2 3
3 2
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 4
12 4
13 5
14 5
15 5
16 5
17 6
18 6
19 7
20 7
21 7
22 7
23 7
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    (%rdi),%rdi
callq  ec <delegate_free+0xc>
mov    0x8(%rbx),%rdi
callq  f5 <delegate_free+0x15>
mov    0x10(%rbx),%rdi
callq  fe <delegate_free+0x1e>
mov    %rbx,%rdi
pop    %rbx
jmpq   107 <delegate_free+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
delegate_free (struct delegation *delegation)
{
  free (delegation->name);
  free (delegation->contract);
  free (delegation->command);
  free (delegation);
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 3
5 4
6 4
7 5
8 5
9 6
10 7
11 6
12 6
<<<sep_out_sample>>>
mov    $0x0,%eax
retq   
<<<sep_in_sample>>>
unac_version(void)
{
  return "1.5.0";
}
<<<sep_in_sample>>>
1 4
2 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     430 <gsasl_client_callback_authentication_id_get+0x10>
mov    0x38(%rdi),%rax
retq   
nopw   0x0(%rax,%rax,1)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_client_callback_authentication_id_get (Gsasl * ctx)
{
  return ctx ? ctx->cbc_authentication_id : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     3d28 <gsl_vector_char_free+0x38>
mov    0x20(%rdi),%eax
test   %eax,%eax
jne    3d10 <gsl_vector_char_free+0x20>
mov    %rbx,%rdi
pop    %rbx
jmpq   3d09 <gsl_vector_char_free+0x19>
nopl   0x0(%rax)
mov    0x18(%rdi),%rdi
callq  3d19 <gsl_vector_char_free+0x29>
mov    %rbx,%rdi
pop    %rbx
jmpq   3d22 <gsl_vector_char_free+0x32>
nopw   0x0(%rax,%rax,1)
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_char_free (gsl_vector_char * v)
{
  if (!v) { return ; };
  if (v->owner)
    {
      gsl_block_char_free (v->block) ;
    }
  free (v);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 4
6 4
7 4
8 8
9 9
10 8
11 8
12 6
13 6
14 8
15 9
16 8
17 8
18 9
19 9
20 9
<<<sep_out_sample>>>
push   %r12
xor    %r12d,%r12d
push   %rbp
mov    %edi,%ebp
push   %rbx
xor    %ebx,%ebx
sub    $0x10010,%rsp
mov    %fs:0x28,%rax
mov    %rax,0x10008(%rsp)
xor    %eax,%eax
nopl   (%rax)
mov    $0x10000,%edx
mov    %rsp,%rsi
mov    %ebp,%edi
callq  77 <swlib_cksum+0x37>
test   %rax,%rax
jle    d0 <swlib_cksum+0x90>
add    %rax,%r12
mov    %rsp,%rdx
add    %rsp,%rax
nopl   (%rax)
add    $0x1,%rdx
mov    %rbx,%rcx
shr    $0x18,%rbx
xor    -0x1(%rdx),%bl
shl    $0x8,%rcx
movzbl %bl,%ebx
xor    0x0(,%rbx,8),%rcx
cmp    %rax,%rdx
mov    %rcx,%rbx
jne    88 <swlib_cksum+0x48>
jmp    68 <swlib_cksum+0x28>
nop
mov    %rbx,%rax
shr    $0x18,%rbx
xor    %r12,%rbx
shl    $0x8,%rax
sar    $0x8,%r12
movzbl %bl,%ebx
xor    0x0(,%rbx,8),%rax
mov    %rax,%rbx
test   %r12,%r12
jne    b0 <swlib_cksum+0x70>
mov    0x10008(%rsp),%rsi
xor    %fs:0x28,%rsi
mov    %ebx,%eax
not    %eax
jne    f8 <swlib_cksum+0xb8>
add    $0x10010,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
callq  fd <swlib_cksum+0xbd>
<<<sep_in_sample>>>
swlib_cksum (int uxfio_fd)
{
  unsigned char buf[(1 << 16)];
  unsigned long crc = 0;
  long file_length = 0;
  long bytes_read;
  while ((bytes_read = uxfio_read (uxfio_fd, buf, (1 << 16))) > 0)
    {
      unsigned char *cp = buf;
      file_length += bytes_read;
      while (bytes_read--)
 crc = (crc << 8) ^ crctab[((crc >> 24) ^ *(cp++)) & 0xFF];
    }
  bytes_read = file_length;
  while (bytes_read > 0)
    {
      crc = (crc << 8) ^ crctab[((crc >> 24) ^ bytes_read) & 0xFF];
      bytes_read >>= 8;
    }
  crc = ~crc & 0xFFFFFFFF;
  return crc;
}
<<<sep_in_sample>>>
1 2
2 5
3 2
4 2
5 2
6 4
7 2
8 2
9 2
10 2
11 2
12 7
13 7
14 7
15 7
16 7
17 7
18 10
19 9
20 9
21 9
22 12
23 12
24 12
25 12
26 12
27 12
28 12
29 11
30 12
31 11
32 11
33 11
34 17
35 17
36 17
37 17
38 18
39 17
40 17
41 17
42 15
43 15
44 22
45 22
46 20
47 20
48 22
49 22
50 22
51 22
52 22
53 22
54 22
<<<sep_out_sample>>>
movzbl (%rdx),%r9d
test   %r8,%r8
mov    %r9d,%r10d
je     14fd <gsl_stats_uchar_minmax+0x2d>
xor    %r11d,%r11d
nop
movzbl (%rdx),%eax
cmp    %al,%r9b
cmova  %eax,%r9d
cmp    %al,%r10b
cmovb  %eax,%r10d
add    $0x1,%r11
add    %rcx,%rdx
cmp    %r8,%r11
jne    14e0 <gsl_stats_uchar_minmax+0x10>
mov    %r9b,(%rdi)
mov    %r10b,(%rsi)
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_stats_uchar_minmax (unsigned char * min_out, unsigned char * max_out,
                             const unsigned char data[], const size_t stride,
                             const size_t n)
{
  unsigned char min = data[0 * stride];
  unsigned char max = data[0 * stride];
  size_t i;
  for (i = 0; i < n; i++)
    {
      unsigned char xi = data[i * stride];
      if (xi < min)
        min = xi;
      if (xi > max)
        max = xi;
    }
  *min_out = min;
  *max_out = max;
}
<<<sep_in_sample>>>
1 5
2 8
3 6
4 8
5 8
6 8
7 10
8 10
9 10
10 10
11 10
12 8
13 8
14 8
15 8
16 16
17 17
18 17
19 17
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  0 <clear_yank_buffer>
callq  83e <close_sbuf+0xe>
mov    0x0(%rip),%rdi        # 845 <close_sbuf+0x15>
test   %rdi,%rdi
je     85e <close_sbuf+0x2e>
callq  84f <close_sbuf+0x1f>
test   %eax,%eax
jne    880 <close_sbuf+0x50>
movq   $0x0,0x0(%rip)        # 85e <close_sbuf+0x2e>
movq   $0x0,0x0(%rip)        # 869 <close_sbuf+0x39>
movl   $0x0,0x0(%rip)        # 873 <close_sbuf+0x43>
mov    $0x1,%eax
add    $0x8,%rsp
retq   
nopl   (%rax)
callq  885 <close_sbuf+0x55>
mov    (%rax),%esi
xor    %edi,%edi
callq  88e <close_sbuf+0x5e>
mov    $0x0,%edi
callq  898 <close_sbuf+0x68>
xor    %eax,%eax
add    $0x8,%rsp
retq   
nop
<<<sep_in_sample>>>
close_sbuf( void )
  {
  clear_yank_buffer();
  clear_undo_stack();
  if( sfp )
    {
    if( fclose( sfp ) != 0 )
      {
      show_strerror( 0, (*__errno_location ()) );
      set_error_msg( "Cannot close temp file" );
      return false;
      }
    sfp = 0;
    }
  sfpos = 0;
  seek_write = false;
  return true;
  }
<<<sep_in_sample>>>
1 2
2 3
3 4
4 5
5 5
6 5
7 7
8 7
9 7
10 13
11 15
12 16
13 17
14 18
15 18
16 18
17 9
18 9
19 9
20 9
21 10
22 10
23 11
24 18
25 18
26 18
<<<sep_out_sample>>>
mov    (%rdi),%rax
movzbl %r8b,%r8d
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_create_empty (gl_list_implementation_t implementation,
        gl_listelement_equals_fn equals_fn,
        gl_listelement_hashcode_fn hashcode_fn,
        gl_listelement_dispose_fn dispose_fn,
        _Bool allow_duplicates)
{
  return implementation->create_empty (implementation, equals_fn, hashcode_fn,
           dispose_fn, allow_duplicates);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
cmp    $0x1,%edi
je     7b7 <archive_format_string+0x27>
mov    $0x0,%edx
jmp    7a5 <archive_format_string+0x15>
nopl   0x0(%rax)
cmp    %edi,0x8(%rdx)
je     7c0 <archive_format_string+0x30>
add    $0x10,%rdx
mov    (%rdx),%rax
test   %rax,%rax
jne    7a0 <archive_format_string+0x10>
mov    $0x0,%eax
retq   
mov    $0x0,%eax
nopl   0x0(%rax)
repz retq 
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
archive_format_string (enum archive_format fmt)
{
  struct fmttab const *p;
  for (p = fmttab; p->name; p++)
    if (p->fmt == fmt)
      return p->name;
  return "unknown?";
}
<<<sep_in_sample>>>
1 5
2 5
3 4
4 4
5 4
6 5
7 5
8 4
9 4
10 4
11 4
12 7
13 7
14 4
15 4
16 8
17 8
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%r8
xor    %ecx,%ecx
xor    %edi,%edi
mov    $0xa,%edx
sub    $0x10,%rsp
lea    0x8(%rsp),%rsi
callq  1b <__gmpf_dump+0x1b>
cmpb   $0x2d,(%rax)
mov    %rax,%rbx
je     58 <__gmpf_dump+0x58>
mov    0x8(%rsp),%rdx
mov    %rax,%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  37 <__gmpf_dump+0x37>
mov    %rbx,%rdi
callq  3f <__gmpf_dump+0x3f>
mov    %rbx,%rdi
lea    0x1(%rax),%rsi
callq  *0x0(%rip)        # 4c <__gmpf_dump+0x4c>
add    $0x10,%rsp
pop    %rbx
retq   
nopw   0x0(%rax,%rax,1)
mov    0x8(%rsp),%rdx
lea    0x1(%rax),%rsi
mov    $0x0,%edi
xor    %eax,%eax
callq  6d <__gmpf_dump+0x6d>
jmp    37 <__gmpf_dump+0x37>
<<<sep_in_sample>>>
__gmpf_dump (mpf_srcptr u)
{
  mp_exp_t exp;
  char *str;
  str = __gmpf_get_str (0, &exp, 10, 0, u);
  if (str[0] == '-')
    printf ("-0.%se%ld\n", str + 1, exp);
  else
    printf ("0.%se%ld\n", str, exp);
  (*__gmp_free_func) (str, strlen (str) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 5
4 5
5 5
6 2
7 5
8 5
9 6
10 5
11 6
12 9
13 9
14 9
15 9
16 9
17 10
18 10
19 10
20 10
21 10
22 11
23 11
24 11
25 11
26 7
27 7
28 7
29 7
30 7
31 7
<<<sep_out_sample>>>
jmpq   25 <rec_comment_destroy+0x5>
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_comment_destroy (rec_comment_t comment)
{
  free (comment);
}
<<<sep_in_sample>>>
1 3
2 3
<<<sep_out_sample>>>
cmp    $0x5b,%edi
je     3358 <rl_vi_bracktype+0x58>
jle    3330 <rl_vi_bracktype+0x30>
cmp    $0x7b,%edi
mov    $0x3,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x7d,%edi
mov    $0xfffffffd,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x5d,%edi
mov    $0xfe,%al
je     3350 <rl_vi_bracktype+0x50>
xor    %eax,%eax
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
cmp    $0x28,%edi
mov    $0x1,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x29,%edi
mov    $0xffffffff,%eax
jne    3322 <rl_vi_bracktype+0x22>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x2,%eax
nopl   (%rax)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_vi_bracktype (c)
     int c;
{
  switch (c)
    {
    case '(': return 1;
    case ')': return -1;
    case '[': return 2;
    case ']': return -2;
    case '{': return 3;
    case '}': return -3;
    default: return 0;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 10
6 4
7 4
8 11
9 4
10 4
11 9
12 4
13 12
14 14
15 14
16 4
17 6
18 4
19 4
20 7
21 4
22 14
23 14
24 14
25 14
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
mov    %edi,0x0(%rip)        # 2596 <sshset_lineno+0x6>
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
sshset_lineno (int line_number )
{
    sshlineno = line_number;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    0x10(%rdi),%edi
test   %edi,%edi
js     138f <coproc_wclose+0xf>
cmp    %esi,%edi
je     1398 <coproc_wclose+0x18>
pop    %rbx
retq   
nopl   0x0(%rax)
callq  139d <coproc_wclose+0x1d>
movl   $0xffffffff,0x10(%rbx)
pop    %rbx
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
coproc_wclose (cp, fd)
     struct coproc *cp;
     int fd;
{
  if (cp->c_wfd >= 0 && cp->c_wfd == fd)
    {
      close (cp->c_wfd);
      cp->c_wfd = -1;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
5 5
6 5
7 5
8 10
9 10
10 10
11 7
12 8
13 10
14 10
15 10
<<<sep_out_sample>>>
test   %rdi,%rdi
je     6c0 <gsasl_server_callback_external_get+0x10>
mov    0xa8(%rdi),%rax
retq   
nopl   (%rax)
xor    %eax,%eax
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsasl_server_callback_external_get (Gsasl * ctx)
{
  return ctx ? ctx->cbs_external : ((void *)0);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 4
8 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     c0a <dbop_lastdat+0xa>
mov    0x18(%rdi),%eax
mov    %eax,(%rsi)
mov    0x10(%rdi),%rax
retq   
nop
<<<sep_in_sample>>>
dbop_lastdat(DBOP *dbop, int *size)
{
 if (size)
  *size = dbop->lastsize;
 return dbop->lastdat;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 5
6 6
7 6
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
push   %rbx
mov    %rdi,%rbx
sub    $0x8,%rsp
mov    (%rdi),%rax
callq  *0x10(%rax)
mov    (%rbx),%rdx
mov    %rbx,%rdi
mov    %rbp,%rcx
xor    %esi,%esi
mov    0x50(%rdx),%r8
add    $0x8,%rsp
mov    %rax,%rdx
pop    %rbx
pop    %rbp
jmpq   *%r8
nopl   (%rax)
<<<sep_in_sample>>>
gl_list_indexof (gl_list_t list, const void *elt)
{
  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);
  return ((const struct gl_list_impl_base *) list)->vtable
         ->indexof_from_to (list, 0, size, elt);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 5
9 4
10 4
11 4
12 4
13 6
14 4
15 6
16 6
17 4
18 4
<<<sep_out_sample>>>
movsd  0x0(%rip),%xmm0        # 4d8 <gsl_linalg_COD_decomp+0x8>
jmpq   4dd <gsl_linalg_COD_decomp+0xd>
nopl   (%rax)
<<<sep_in_sample>>>
gsl_linalg_COD_decomp(gsl_matrix * A, gsl_vector * tau_Q, gsl_vector * tau_Z,
                      gsl_permutation * p, size_t * rank, gsl_vector * work)
{
  return gsl_linalg_COD_decomp_e(A, tau_Q, tau_Z, p, -1.0, rank, work);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
sub    $0x18,%rsp
lea    0xb(%rsp),%rdx
lea    0xc(%rsp),%rsi
callq  340 <tarui_get_filetypes>
movsbl 0xb(%rsp),%eax
add    $0x18,%rsp
retq   
nopl   (%rax)
<<<sep_in_sample>>>
taru_get_tar_filetype (mode_t mode)
{
 char c;
 int cm;
 tarui_get_filetypes(mode, &cm, &c);
 return (int)c;
}
<<<sep_in_sample>>>
1 2
2 5
3 5
4 5
5 6
6 7
7 7
8 7
<<<sep_out_sample>>>
push   %rbp
mov    %esi,%ebp
push   %rbx
mov    %rdi,%rbx
mov    $0x0,%edi
sub    $0x8,%rsp
callq  115 <describe_command+0x15>
mov    %rbx,%rsi
mov    %rax,%rdi
callq  120 <describe_command+0x20>
test   %rax,%rax
mov    %rax,%rbx
je     170 <describe_command+0x70>
cmpb   $0x0,(%rax)
je     154 <describe_command+0x54>
mov    %rax,%rdi
callq  135 <describe_command+0x35>
test   %rax,%rax
je     168 <describe_command+0x68>
mov    %rax,%rdi
callq  142 <describe_command+0x42>
mov    %rbx,%rsi
mov    %rax,%rdx
mov    $0x0,%edi
xor    %eax,%eax
callq  154 <describe_command+0x54>
add    $0x8,%rsp
mov    %rbx,%rdi
pop    %rbx
pop    %rbp
jmpq   162 <describe_command+0x62>
nopw   0x0(%rax,%rax,1)
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nop
mov    0x0(%rip),%rdi        # 177 <describe_command+0x77>
add    $0x8,%rsp
mov    %ebp,%esi
pop    %rbx
pop    %rbp
jmpq   184 <describe_command+0x84>
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
describe_command (WINDOW *window, int count)
{
  char *line;
  line = read_function_name (gettext ("Describe command: "), window);
  if (!line)
    {
      info_abort_key (active_window, count);
      return;
    }
  if (*line)
    {
      InfoCommand *cmd = named_function (line);
      if (!cmd)
        return;
      window_message_in_echo_area ("%s: %s.",
                                   line, function_documentation (cmd));
    }
  free (line);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 4
6 2
7 4
8 4
9 4
10 4
11 5
12 4
13 5
14 10
15 10
16 12
17 12
18 13
19 13
20 15
21 15
22 15
23 15
24 15
25 15
26 15
27 19
28 18
29 19
30 19
31 18
32 18
33 19
34 19
35 19
36 19
37 19
38 7
39 19
40 7
41 19
42 19
43 7
44 7
<<<sep_out_sample>>>
mov    $0x0,%ecx
jmpq   0 <authors_print.constprop.0>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
authors_print_plain (const unsigned char * authors, FILE * stream,
       const char *before)
{
  authors_print (authors, stream,
   before, "%s <%s>", ", ", ".\n");
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
mov    $0x0,%edi
jmpq   1a <cdio_get_default_device_netbsd+0xa>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cdio_get_default_device_netbsd()
{
  return strdup("/dev/rcd0c");
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
orl    $0x1,0x48(%rdi)
mov    %rsi,0x40(%rdi)
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
mu_auth_data_set_quota (struct mu_auth_data *ptr, mu_off_t q)
{
  ptr->flags |= 0x1;
  ptr->quota = q;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
4 4
<<<sep_out_sample>>>
push   %r12
mov    $0x2,%esi
mov    %r9,%r12
push   %rbp
mov    %r8,%rbp
push   %rbx
callq  14 <_gsasl_external_client_step+0x14>
test   %rax,%rax
mov    %rax,%rbx
mov    $0x0,%eax
cmove  %rax,%rbx
mov    %rbx,%rdi
callq  2b <_gsasl_external_client_step+0x2b>
mov    %rax,%rdx
mov    %rax,0x0(%rbp)
mov    $0x7,%eax
test   %rdx,%rdx
je     4a <_gsasl_external_client_step+0x4a>
mov    %rbx,%rdi
callq  44 <_gsasl_external_client_step+0x44>
mov    %rax,(%r12)
xor    %eax,%eax
pop    %rbx
pop    %rbp
pop    %r12
retq   
<<<sep_in_sample>>>
_gsasl_external_client_step (Gsasl_session * sctx,
        void *mech_data,
        const char *input, size_t input_len,
        char **output, size_t * output_len)
{
  const char *p;
  p = gsasl_property_get (sctx, GSASL_AUTHZID);
  if (!p)
    p = "";
  *output = strdup (p);
  if (!*output)
    return GSASL_MALLOC_ERROR;
  *output_len = strlen (p);
  return GSASL_OK;
}
<<<sep_in_sample>>>
1 5
2 7
3 5
4 5
5 5
6 5
7 7
8 9
9 7
10 9
11 9
12 10
13 10
14 10
15 10
16 12
17 11
18 11
19 13
20 13
21 13
22 14
23 15
24 15
25 15
26 15
<<<sep_out_sample>>>
push   %r12
mov    %rsi,%r12
push   %rbp
push   %rbx
mov    0x30(%rdi),%rbp
mov    %rdi,%rbx
cmp    %rbp,0x38(%rdi)
je     a78 <gl_array_nx_add_first+0x48>
test   %rbp,%rbp
mov    0x28(%rbx),%rdx
mov    %rbp,%rax
je     a5f <gl_array_nx_add_first+0x2f>
mov    -0x8(%rdx,%rax,8),%rcx
mov    %rcx,(%rdx,%rax,8)
sub    $0x1,%rax
jne    a50 <gl_array_nx_add_first+0x20>
add    $0x1,%rbp
mov    %r12,(%rdx)
mov    $0x1,%eax
mov    %rbp,0x30(%rbx)
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   0x0(%rax)
lea    0x38(%rdi),%rsi
lea    0x28(%rdi),%rdi
callq  730 <grow.isra.2>
test   %eax,%eax
jns    a44 <gl_array_nx_add_first+0x14>
xor    %eax,%eax
jmp    a6f <gl_array_nx_add_first+0x3f>
<<<sep_in_sample>>>
gl_array_nx_add_first (gl_list_t list, const void *elt)
{
  size_t count = list->count;
  const void **elements;
  size_t i;
  if (count == list->allocated)
    if (grow (list) < 0)
      return ((void *)0);
  elements = list->elements;
  for (i = count; i > 0; i--)
    elements[i] = elements[i - 1];
  elements[0] = elt;
  list->count = count + 1;
  return (gl_list_node_t)(unsigned long)(size_t)((0) + 1);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 3
6 2
7 6
8 6
9 10
10 9
11 10
12 10
13 11
14 11
15 10
16 10
17 13
18 12
19 14
20 13
21 15
22 15
23 15
24 15
25 15
26 15
27 15
28 7
29 7
30 7
31 8
32 8
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x10,%edi
push   %rbx
sub    $0x8,%rsp
callq  4f3 <get_input_string+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     548 <get_input_string+0x68>
mov    %rbp,%rdi
callq  503 <get_input_string+0x23>
cmpq   $0x0,0x0(%rip)        # 50b <get_input_string+0x2b>
mov    %rax,(%rbx)
je     538 <get_input_string+0x58>
mov    0x0(%rip),%rax        # 517 <get_input_string+0x37>
mov    %rbx,0x0(%rip)        # 51e <get_input_string+0x3e>
mov    %rbx,0x8(%rax)
movq   $0x0,0x8(%rbx)
xor    %eax,%eax
add    $0x8,%rsp
pop    %rbx
pop    %rbp
retq   
nopl   0x0(%rax,%rax,1)
mov    %rbx,0x0(%rip)        # 53f <get_input_string+0x5f>
mov    %rbx,0x0(%rip)        # 546 <get_input_string+0x66>
jmp    522 <get_input_string+0x42>
callq  54d <get_input_string+0x6d>
mov    (%rax),%edi
callq  554 <get_input_string+0x74>
mov    0x0(%rip),%rdx        # 55b <get_input_string+0x7b>
mov    0x0(%rip),%rdi        # 562 <get_input_string+0x82>
mov    %rax,%rcx
mov    $0x0,%esi
xor    %eax,%eax
callq  571 <get_input_string+0x91>
mov    $0xfffffffe,%eax
jmp    52c <get_input_string+0x4c>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_input_string(void *arg)
{
    struct encode_item *item = malloc(sizeof(*item));
    if (!item) {
 fprintf(stderr, "%s: malloc: %s\n", prgname, strerror((*__errno_location ())));
 return -2;
    }
    item->string = strdup(arg);
    if (!list_head) {
 list_head = list_tail = item;
    } else {
 list_tail->next = item;
 list_tail = item;
    }
    item->next = ((void *)0);
    return 0;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 8
11 8
12 9
13 8
14 9
15 12
16 13
17 12
18 15
19 16
20 17
21 17
22 17
23 17
24 17
25 10
26 10
27 10
28 5
29 5
30 5
31 5
32 5
33 5
34 5
35 5
36 5
37 5
38 5
39 5
<<<sep_out_sample>>>
mov    %rsi,(%rdi)
mov    %edx,0x8(%rdi)
movq   $0x0,0x10(%rdi)
mov    %ecx,0x1c(%rdi)
movq   $0x0,0x20(%rdi)
movq   $0x0,0x28(%rdi)
movl   $0x0,0x40(%rdi)
movl   $0x0,0x44(%rdi)
retq   
<<<sep_in_sample>>>
sexp_output_init(struct sexp_output *output, FILE *f,
   unsigned width, int prefer_hex)
{
  output->f = f;
  output->line_width = width;
  output->coding = ((void *)0);
  output->prefer_hex = prefer_hex;
  output->hash = ((void *)0);
  output->ctx = ((void *)0);
  output->pos = 0;
  output->soft_newline = 0;
}
<<<sep_in_sample>>>
1 4
2 5
3 6
4 7
5 8
6 9
7 10
8 11
9 11
<<<sep_out_sample>>>
test   %rsi,%rsi
push   %rbx
mov    %rdi,%rbx
je     11 <__rcp+0x11>
mov    %rsi,%rdi
callq  11 <__rcp+0x11>
movswq 0x4(%rbx),%rdi
callq  1b <__rcp+0x1b>
mov    0x0(%rip),%rdx        # 22 <__rcp+0x22>
mov    %rbx,(%rax)
movb   $0x1,0x18(%rax)
movq   $0x0,0x0(%rip)        # 34 <__rcp+0x34>
mov    %rdx,0x30(%rax)
mov    0x0(%rip),%rdx        # 3f <__rcp+0x3f>
mov    %rax,0x0(%rip)        # 46 <__rcp+0x46>
mov    %rdx,0x10(%rax)
pop    %rbx
retq   
<<<sep_in_sample>>>
__rcp (__pty ppx, long as)
{
  __dhp x;
  if (as)
    __rss (as);
  x = __ralloc ((long) ppx->size);
  x->pm = 1;
  x->pp = ppx;
  x->sl = __sl;
  __sl = 0L;
  x->dl = __pb;
  __pb = x;
}
<<<sep_in_sample>>>
1 4
2 2
3 2
4 4
5 5
6 5
7 6
8 6
9 9
10 8
11 7
12 10
13 9
14 11
15 12
16 11
17 13
18 13
<<<sep_out_sample>>>
mov    0x0(%rip),%rcx        # 127 <pe_package_name+0x7>
mov    $0x1,%edx
mov    $0x4,%esi
mov    $0x0,%edi
jmpq   13b <pe_package_name+0x1b>
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pe_package_name (struct prompt_exp *p)
{
  fwrite ("gdbm", sizeof ("gdbm") - 1, 1, stdout);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
<<<sep_out_sample>>>
sub    $0xd8,%rsp
test   %al,%al
mov    %rsi,0x28(%rsp)
mov    %rdx,0x30(%rsp)
mov    %rcx,0x38(%rsp)
mov    %r8,0x40(%rsp)
mov    %r9,0x48(%rsp)
je     3bb <_wsplt_error+0x5b>
movaps %xmm0,0x50(%rsp)
movaps %xmm1,0x60(%rsp)
movaps %xmm2,0x70(%rsp)
movaps %xmm3,0x80(%rsp)
movaps %xmm4,0x90(%rsp)
movaps %xmm5,0xa0(%rsp)
movaps %xmm6,0xb0(%rsp)
movaps %xmm7,0xc0(%rsp)
lea    0xe0(%rsp),%rax
mov    %rdi,%rsi
lea    0x8(%rsp),%rdx
mov    0x0(%rip),%rdi        # 3d2 <_wsplt_error+0x72>
mov    %rax,0x10(%rsp)
lea    0x20(%rsp),%rax
movl   $0x8,0x8(%rsp)
movl   $0x30,0xc(%rsp)
mov    %rax,0x18(%rsp)
callq  3f6 <_wsplt_error+0x96>
mov    0x0(%rip),%rsi        # 3fd <_wsplt_error+0x9d>
mov    $0xa,%edi
callq  407 <_wsplt_error+0xa7>
add    $0xd8,%rsp
retq   
nop
<<<sep_in_sample>>>
_wsplt_error (const char *fmt, ...)
{
  va_list ap;
  __builtin_va_start(ap,fmt);
  vfprintf (stderr, fmt, ap);
  __builtin_va_end(ap);
  fputc ('\n', stderr);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 2
12 2
13 2
14 2
15 2
16 2
17 4
18 2
19 5
20 5
21 4
22 4
23 4
24 4
25 4
26 5
27 7
28 7
29 7
30 8
31 8
32 8
<<<sep_out_sample>>>
push   %r13
push   %r12
push   %rbp
mov    %rdi,%rbp
push   %rbx
sub    $0x8,%rsp
test   %rdi,%rdi
je     7e2 <strlist_print+0x52>
mov    0xc(%rdi),%eax
test   %eax,%eax
jle    7e2 <strlist_print+0x52>
mov    %rsi,%r12
xor    %ebx,%ebx
mov    $0x0,%r13d
nopl   0x0(%rax)
mov    0x0(%rbp),%rax
test   %r12,%r12
mov    %r13,%rsi
cmovne %r12,%rsi
mov    $0x0,%edi
mov    (%rax,%rbx,8),%rdx
xor    %eax,%eax
callq  7d6 <strlist_print+0x46>
lea    0x1(%rbx),%eax
add    $0x1,%rbx
cmp    0xc(%rbp),%eax
jl     7b8 <strlist_print+0x28>
add    $0x8,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
retq   
nopl   (%rax)
<<<sep_in_sample>>>
strlist_print (sl, prefix)
     STRINGLIST *sl;
     char *prefix;
{
  register int i;
  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 4
6 4
7 6
8 6
9 8
10 8
11 8
12 8
13 8
14 9
15 9
16 9
17 9
18 9
19 9
20 9
21 9
22 9
23 9
24 9
25 9
26 8
27 8
28 10
29 10
30 10
31 10
32 10
33 10
34 10
<<<sep_out_sample>>>
push   %r15
mov    %edx,%r15d
push   %r14
mov    %rdi,%r14
push   %r13
push   %r12
push   %rbp
mov    %rsi,%rbp
push   %rbx
sub    $0x218,%rsp
mov    (%rsi),%r12
mov    %fs:0x28,%rax
mov    %rax,0x208(%rsp)
xor    %eax,%eax
cmpb   $0x20,(%r12)
mov    %r12,%rax
je     49 <put_standard_format+0x49>
nopw   0x0(%rax,%rax,1)
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    40 <put_standard_format+0x40>
cmpb   $0x20,0x1(%rax)
lea    0x1(%rax),%r13
movb   $0x0,(%rax)
mov    %r13,%rbx
je     69 <put_standard_format+0x69>
nopl   0x0(%rax)
add    $0x1,%rbx
cmpb   $0x20,(%rbx)
jne    60 <put_standard_format+0x60>
test   $0x8,%r15b
movb   $0x0,(%rbx)
jne    f8 <put_standard_format+0xf8>
mov    0x0(%rip),%eax        # 7c <put_standard_format+0x7c>
mov    $0x0,%r8d
test   %eax,%eax
jne    a3 <put_standard_format+0xa3>
cmpb   $0x20,0x1(%rbx)
lea    0x1(%rbx),%rax
je     99 <put_standard_format+0x99>
add    $0x1,%rax
cmpb   $0x20,(%rax)
jne    90 <put_standard_format+0x90>
and    $0x2,%r15d
lea    0x1(%rax),%r8
jne    e0 <put_standard_format+0xe0>
mov    0x18(%rbp),%ecx
mov    0x8(%rbp),%rdx
mov    %r12,%r9
mov    %r13,%rsi
mov    %r14,%rdi
callq  b8 <put_standard_format+0xb8>
mov    0x208(%rsp),%rax
xor    %fs:0x28,%rax
jne    11c <put_standard_format+0x11c>
add    $0x218,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
nopl   (%rax)
mov    0x10(%rbp),%rsi
mov    %r8,%rdi
callq  ec <put_standard_format+0xec>
mov    %rax,%r8
jmp    a3 <put_standard_format+0xa3>
nopl   0x0(%rax)
mov    0x10(%rbp),%rsi
mov    %r13,%rdi
mov    %rsp,%r13
callq  107 <put_standard_format+0x107>
mov    $0x200,%edx
mov    %rax,%rsi
mov    %rsp,%rdi
callq  117 <put_standard_format+0x117>
jmpq   76 <put_standard_format+0x76>
callq  121 <put_standard_format+0x121>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
put_standard_format(CONVERT *cv, GTP *gtp, int flags)
{
 char *p = (char *)gtp->tagline;
 char namebuf[512];
 const char *fid, *tagname, *image;
 fid = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 tagname = p;
 while (*p != ' ')
  p++;
 *p++ = '\0';
 if (flags & 8) {
  strlimcpy(namebuf, (char *)uncompress(tagname, gtp->tag), sizeof(namebuf));
  tagname = namebuf;
 }
 if (nosource) {
  image = " ";
 } else {
  while (*p != ' ')
   p++;
  image = p + 1;
  if (flags & 2)
   image = (char *)uncompress(image, gtp->tag);
 }
 convert_put_using(cv, tagname, gtp->path, gtp->lineno, image, fid);
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 2
7 2
8 2
9 2
10 2
11 3
12 2
13 2
14 2
15 7
16 7
17 7
18 7
19 8
20 7
21 7
22 11
23 9
24 9
25 9
26 11
27 11
28 12
29 11
30 11
31 14
32 13
33 14
34 18
35 19
36 18
37 18
38 21
39 13
40 21
41 22
42 21
43 21
44 24
45 23
46 24
47 27
48 27
49 27
50 27
51 27
52 27
53 28
54 28
55 28
56 28
57 28
58 28
59 28
60 28
61 28
62 28
63 28
64 28
65 25
66 25
67 25
68 25
69 25
70 25
71 15
72 15
73 16
74 15
75 15
76 15
77 15
78 15
79 15
80 28
81 28
<<<sep_out_sample>>>
cmp    $0x5b,%edi
je     3358 <rl_vi_bracktype+0x58>
jle    3330 <rl_vi_bracktype+0x30>
cmp    $0x7b,%edi
mov    $0x3,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x7d,%edi
mov    $0xfffffffd,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x5d,%edi
mov    $0xfe,%al
je     3350 <rl_vi_bracktype+0x50>
xor    %eax,%eax
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
cmp    $0x28,%edi
mov    $0x1,%eax
je     3324 <rl_vi_bracktype+0x24>
cmp    $0x29,%edi
mov    $0xffffffff,%eax
jne    3322 <rl_vi_bracktype+0x22>
repz retq 
nopw   %cs:0x0(%rax,%rax,1)
repz retq 
nopw   0x0(%rax,%rax,1)
mov    $0x2,%eax
nopl   (%rax)
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rl_vi_bracktype (c)
     int c;
{
  switch (c)
    {
    case '(': return 1;
    case ')': return -1;
    case '[': return 2;
    case ']': return -2;
    case '{': return 3;
    case '}': return -3;
    default: return 0;
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 4
5 10
6 4
7 4
8 11
9 4
10 4
11 9
12 4
13 12
14 14
15 14
16 4
17 6
18 4
19 4
20 7
21 4
22 14
23 14
24 14
25 14
26 8
27 8
28 8
29 8
<<<sep_out_sample>>>
push   %r15
mov    %r9d,%r15d
push   %r14
mov    %r8,%r14
push   %r13
mov    %esi,%r13d
push   %r12
mov    %rdi,%r12
push   %rbp
push   %rbx
mov    %ecx,%ebx
sub    $0x38,%rsp
movq   $0x0,0x0(%rip)        # 5a47 <gb_en_hdy+0x27>
mov    0x70(%rsp),%eax
mov    %eax,(%rsp)
callq  5a53 <gb_en_hdy+0x33>
mov    %ebx,%edx
mov    $0x1,%r8d
mov    $0x6,%esi
mov    $0x6,%ecx
mov    $0x1,%edi
callq  5a6f <gb_en_hdy+0x4f>
mov    0x0(%rip),%rcx        # 5a76 <gb_en_hdy+0x56>
mov    0x0(%rip),%rdi        # 5a7d <gb_en_hdy+0x5d>
mov    %eax,%ebp
mov    %rcx,0x28(%rsp)
callq  5a89 <gb_en_hdy+0x69>
mov    %rax,%rdx
mov    0x70(%rsp),%eax
mov    0x28(%rsp),%rcx
mov    (%r12),%edi
lea    0x7(%rbp),%r9d
mov    %r15d,0x18(%rsp)
mov    %r14,0x10(%rsp)
mov    %ebx,0x8(%rsp)
mov    %r13d,%esi
mov    %eax,0x20(%rsp)
movl   $0x6,(%rsp)
mov    $0x0,%r8d
callq  5ac4 <gb_en_hdy+0xa4>
add    $0x38,%rsp
pop    %rbx
pop    %rbp
pop    %r12
pop    %r13
pop    %r14
pop    %r15
retq   
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gb_en_hdy (init_data, detected, easter, year, hd_elems, fday, count)
     Bool *init_data;
     const Bool detected;
     int easter;
     const int year;
     int *hd_elems;
     const int fday;
     const int count;
{
  register int day;
  ptr_cc_id = "GB_EN";
  gb_hdy (init_data, detected, easter, year, hd_elems, fday, count);
  day = eval_holiday (1, 6, year, 6, (0==0)) + 7;
  holiday (*init_data, detected, gettext(hd_text[267].ht_text),
    ptr_cc_id, "-", day, 6, year, hd_elems, fday, count);
}
<<<sep_in_sample>>>
1 9
2 9
3 9
4 9
5 9
6 9
7 9
8 9
9 9
10 9
11 9
12 9
13 11
14 12
15 12
16 12
17 13
18 13
19 13
20 13
21 13
22 13
23 14
24 14
25 13
26 14
27 14
28 14
29 14
30 14
31 14
32 14
33 14
34 14
35 14
36 14
37 14
38 14
39 14
40 14
41 16
42 16
43 16
44 16
45 16
46 16
47 16
48 16
49 16
<<<sep_out_sample>>>
sub    $0x18,%rsp
mov    %rsp,%rdi
callq  136c <gsl_sf_lnpoch+0xc>
test   %eax,%eax
movsd  (%rsp),%xmm0
jne    1380 <gsl_sf_lnpoch+0x20>
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
mov    %eax,%ecx
mov    $0x1c6,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  1396 <gsl_sf_lnpoch+0x36>
movsd  (%rsp),%xmm0
add    $0x18,%rsp
retq   
<<<sep_in_sample>>>
gsl_sf_lnpoch(const double a, const double x)
{
  gsl_sf_result result; int status = gsl_sf_lnpoch_e(a, x, &result); if (status != GSL_SUCCESS) { do { gsl_error ("gsl_sf_lnpoch_e(a, x, &result)", "poch.c", 454, status) ; return result.val ; } while (0); } ; return result.val;;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 3
6 3
7 4
8 4
9 4
10 3
11 3
12 3
13 3
14 3
15 3
16 4
17 4
<<<sep_out_sample>>>
test   %rsi,%rsi
je     330f <list_dumpdir+0x8f>
push   %r12
xor    %r12d,%r12d
push   %rbp
lea    -0x1(%rsi),%rbp
push   %rbx
lea    0x1(%rdi),%rbx
jmp    32d5 <list_dumpdir+0x55>
nopw   0x0(%rax,%rax,1)
cmp    $0x44,%dil
je     3318 <list_dumpdir+0x98>
cmp    $0x4e,%dil
je     3318 <list_dumpdir+0x98>
test   %dil,%dil
jne    32f2 <list_dumpdir+0x72>
mov    0x0(%rip),%rsi        # 32b8 <list_dumpdir+0x38>
mov    $0xa,%edi
xor    %r12d,%r12d
callq  32c5 <list_dumpdir+0x45>
add    $0x1,%rbx
test   %rbp,%rbp
lea    -0x1(%rbp),%rax
je     330b <list_dumpdir+0x8b>
mov    %rax,%rbp
movsbl -0x1(%rbx),%edi
cmp    $0x52,%dil
je     3318 <list_dumpdir+0x98>
jle    32a0 <list_dumpdir+0x20>
cmp    $0x54,%dil
je     3318 <list_dumpdir+0x98>
jl     32f2 <list_dumpdir+0x72>
lea    -0x58(%rdi),%eax
cmp    $0x1,%al
xchg   %ax,%ax
jbe    3318 <list_dumpdir+0x98>
mov    0x0(%rip),%rsi        # 32f9 <list_dumpdir+0x79>
add    $0x1,%rbx
callq  3302 <list_dumpdir+0x82>
test   %rbp,%rbp
lea    -0x1(%rbp),%rax
jne    32d2 <list_dumpdir+0x52>
pop    %rbx
pop    %rbp
pop    %r12
repz retq 
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 331f <list_dumpdir+0x9f>
callq  3324 <list_dumpdir+0xa4>
test   %r12d,%r12d
je     3338 <list_dumpdir+0xb8>
mov    $0x1,%r12d
jmp    32c5 <list_dumpdir+0x45>
nopl   0x0(%rax)
mov    0x0(%rip),%rsi        # 333f <list_dumpdir+0xbf>
mov    $0x20,%edi
callq  3349 <list_dumpdir+0xc9>
jmp    3329 <list_dumpdir+0xa9>
<<<sep_in_sample>>>
list_dumpdir (char *buffer, size_t size)
{
  int state = 0;
  while (size)
    {
      switch (*buffer)
 {
 case 'Y':
 case 'N':
 case 'D':
 case 'R':
 case 'T':
 case 'X':
   fprintf (stdlis, "%c", *buffer);
   if (state == 0)
     {
       fprintf (stdlis, " ");
       state = 1;
     }
   buffer++;
   size--;
   break;
 case 0:
   fputc_unlocked ('\n',stdlis);
   buffer++;
   size--;
   state = 0;
   break;
 default:
   fputc_unlocked (*buffer,stdlis);
   buffer++;
   size--;
 }
    }
}
<<<sep_in_sample>>>
1 4
2 4
3 2
4 3
5 2
6 2
7 2
8 2
9 2
10 2
11 6
12 6
13 6
14 6
15 6
16 6
17 24
18 24
19 27
20 24
21 24
22 4
23 4
24 4
25 4
26 6
27 6
28 6
29 6
30 6
31 6
32 6
33 6
34 6
35 6
36 6
37 30
38 30
39 30
40 4
41 4
42 4
43 35
44 35
45 35
46 35
47 35
48 14
49 14
50 15
51 15
52 22
53 22
54 22
55 17
56 17
57 17
58 17
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <_rl_vi_stuff_insert+0x8>
test   %ebx,%ebx
je     21 <_rl_vi_stuff_insert+0x21>
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 17 <_rl_vi_stuff_insert+0x17>
callq  1c <_rl_vi_stuff_insert+0x1c>
sub    $0x1,%ebx
jne    10 <_rl_vi_stuff_insert+0x10>
pop    %rbx
jmpq   27 <_rl_vi_stuff_insert+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_stuff_insert (count)
     int count;
{
  rl_begin_undo_group ();
  while (count--)
    rl_insert_text (vi_insert_buffer);
  rl_end_undo_group ();
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 6
8 6
9 5
10 5
11 8
12 7
13 7
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  293 <get_tz+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     2d8 <get_tz+0x58>
mov    %rax,%rdi
callq  2a3 <get_tz+0x23>
lea    0x1(%rax),%rdx
cmp    $0x64,%rdx
ja     2c0 <get_tz+0x40>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2be <get_tz+0x3e>
xchg   %ax,%ax
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <get_tz+0x51>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_tz (char tzbuf[TZBUFSIZE])
{
  char *tz = getenv ("TZ");
  if (tz)
    {
      size_t tzsize = strlen (tz) + 1;
      tz = (tzsize <= TZBUFSIZE
            ? memcpy (tzbuf, tz, tzsize)
            : xmemdup (tz, tzsize));
    }
  return tz;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 12
16 7
17 7
18 12
19 12
20 7
21 7
22 12
23 7
24 7
25 12
26 12
27 7
28 7
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
mov    %rsi,%rdi
mov    0x10(%rbx),%rsi
callq  *0x30(%rbx)
cmp    0x10(%rbx),%rax
jae    dd <safe_hasher+0x1d>
shl    $0x4,%rax
add    (%rbx),%rax
pop    %rbx
retq   
callq  e2 <safe_hasher+0x22>
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
safe_hasher (const Hash_table *table, const void *key)
{
  size_t n = table->hasher (key, table->n_buckets);
  if (! (n < table->n_buckets))
    abort ();
  return table->bucket + n;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 3
5 3
6 4
7 4
8 6
9 6
10 7
11 7
12 5
13 5
<<<sep_out_sample>>>
add    $0x28,%rdi
jmpq   9 <nettle_ccm_aes256_set_key+0x9>
nopl   0x0(%rax)
<<<sep_in_sample>>>
nettle_ccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key)
{
  nettle_aes256_set_encrypt_key(&ctx->cipher, key);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
<<<sep_out_sample>>>
test   %rdi,%rdi
push   %rbx
mov    %rdi,%rbx
je     1945 <free_history_node+0x45>
testb  $0x10,0x38(%rdi)
je     1945 <free_history_node+0x45>
mov    0x18(%rdi),%rdi
callq  1918 <free_history_node+0x18>
mov    0x40(%rbx),%rdi
callq  1921 <free_history_node+0x21>
mov    0x58(%rbx),%rdi
callq  192a <free_history_node+0x2a>
mov    0x50(%rbx),%rdi
callq  1933 <free_history_node+0x33>
mov    0x48(%rbx),%rdi
callq  193c <free_history_node+0x3c>
mov    0x10(%rbx),%rdi
callq  1945 <free_history_node+0x45>
mov    %rbx,%rdi
pop    %rbx
jmpq   194e <free_history_node+0x4e>
xchg   %ax,%ax
<<<sep_in_sample>>>
free_history_node (NODE *n)
{
  if (n && (n->flags & 0x10))
    {
      free (n->contents);
      info_free_references (n->references);
      free (n->next); free (n->prev); free (n->up);
      free (n->nodename);
    }
  free (n);
}
<<<sep_in_sample>>>
1 3
2 2
3 2
4 3
5 3
6 3
7 5
8 5
9 6
10 6
11 7
12 7
13 7
14 7
15 7
16 7
17 8
18 8
19 10
20 11
21 10
22 10
<<<sep_out_sample>>>
cmp    %rsi,%rdi
sete   %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rec_rset_record_equal_fn (void *data1,
                          void *data2)
{
  return (data1 == data2);
}
<<<sep_in_sample>>>
1 4
2 4
3 5
4 5
<<<sep_out_sample>>>
lea    -0x30(%rdi),%edx
mov    $0x1,%eax
cmp    $0x9,%edx
jbe    119 <c_isxdigit+0x19>
and    $0xffffffdf,%edi
sub    $0x41,%edi
cmp    $0x5,%edi
setbe  %al
repz retq 
nopl   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isxdigit (int c)
{
  return ((c >= '0' && c <= '9')
          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
5 4
6 4
7 4
8 4
9 5
10 5
<<<sep_out_sample>>>
mov    0x8(%rsi),%rax
xor    %edx,%edx
cmp    %rax,0x8(%rdi)
mov    $0xffffffff,%eax
seta   %dl
cmovae %edx,%eax
retq   
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
direntry_cmp_inode (void const *a, void const *b)
{
  direntry_t const *dea = a;
  direntry_t const *deb = b;
  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;
}
<<<sep_in_sample>>>
1 5
2 5
3 5
4 5
5 5
6 5
7 6
8 6
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
sub    $0x20,%rsp
testb  $0x2,0x2d0(%rdi)
mov    0x320(%rdi),%rax
movsd  0x1a0(%rdi),%xmm0
jne    6f0 <genericThrust+0xd0>
mov    0x208(%rax),%rdi
callq  650 <genericThrust+0x30>
unpcklps %xmm0,%xmm0
mov    0x320(%rbx),%rax
cvtps2pd %xmm0,%xmm1
mulsd  0x1f0(%rax),%xmm1
movsd  0x0(%rip),%xmm0        # 66d <genericThrust+0x4d>
cvtsi2sdl 0x2a8(%rbx),%xmm2
mulsd  0x0(%rip),%xmm2        # 67d <genericThrust+0x5d>
movsd  %xmm1,0x18(%rsp)
divsd  0x218(%rax),%xmm0
movsd  %xmm2,0x10(%rsp)
movsd  0x2b0(%rbx),%xmm3
subsd  %xmm2,%xmm3
movsd  %xmm3,0x8(%rsp)
callq  6a8 <genericThrust+0x88>
movsd  0x8(%rsp),%xmm3
movsd  0x10(%rsp),%xmm2
mulsd  %xmm3,%xmm0
movsd  0x18(%rsp),%xmm1
addsd  %xmm2,%xmm0
mulsd  %xmm0,%xmm1
movsd  %xmm0,0x2b0(%rbx)
mulsd  %xmm0,%xmm1
mulsd  0x190(%rbx),%xmm1
divsd  0x0(%rip),%xmm1        # 6e2 <genericThrust+0xc2>
add    $0x20,%rsp
pop    %rbx
movapd %xmm1,%xmm0
retq   
nopl   0x0(%rax)
mov    0x210(%rax),%rdi
callq  6fc <genericThrust+0xdc>
unpcklps %xmm0,%xmm0
mov    0x320(%rbx),%rax
cvtps2pd %xmm0,%xmm1
mulsd  0x1f8(%rax),%xmm1
jmpq   665 <genericThrust+0x45>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
genericThrust( craft * c )
{
 register double t, ts;
 if (c->flags & (1<<1)) {
  t = interpolate(c->cinfo->ABThrust, c->mach) * c->cinfo->maxABThrust;
 }
 else {
  t = interpolate(c->cinfo->Thrust, c->mach) * c->cinfo->maxThrust;
 }
 ts = c->throttle / 32768.0;
 c->rpm = (c->rpm - ts) * exp(deltaT / c->cinfo->engineLag) + ts;
 return t * c->rpm * c->rpm * c->rho / 0.002377;
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 4
5 5
6 5
7 4
8 8
9 8
10 8
11 8
12 8
13 8
14 11
15 10
16 10
17 10
18 11
19 11
20 11
21 11
22 11
23 11
24 11
25 11
26 11
27 12
28 11
29 12
30 11
31 12
32 12
33 12
34 13
35 13
36 13
37 13
38 13
39 5
40 5
41 5
42 5
43 5
44 5
45 5
46 5
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x38,%rsp
movsd  %xmm0,0x18(%rsp)
callq  237 <cgst_calc_tau+0x17>
mov    %rbx,%rdi
movsd  %xmm0,0x10(%rsp)
callq  245 <cgst_calc_tau+0x25>
lea    0x28(%rsp),%rdx
mov    %rbx,%rsi
mov    %rbp,%rdi
movsd  %xmm0,0x8(%rsp)
callq  25b <cgst_calc_tau+0x3b>
movsd  0x8(%rsp),%xmm3
movsd  0x28(%rsp),%xmm2
movapd %xmm3,%xmm0
movsd  0x18(%rsp),%xmm6
movapd %xmm2,%xmm4
mulsd  %xmm3,%xmm0
movapd %xmm6,%xmm1
movsd  0x10(%rsp),%xmm5
addsd  %xmm5,%xmm1
divsd  %xmm0,%xmm4
subsd  %xmm5,%xmm6
mulsd  %xmm6,%xmm1
mulsd  %xmm4,%xmm2
addsd  %xmm1,%xmm2
sqrtsd %xmm2,%xmm0
ucomisd %xmm0,%xmm0
jp     2b4 <cgst_calc_tau+0x94>
divsd  %xmm3,%xmm0
add    $0x38,%rsp
pop    %rbx
pop    %rbp
subsd  %xmm4,%xmm0
retq   
movapd %xmm2,%xmm0
movsd  %xmm4,0x10(%rsp)
callq  2c3 <cgst_calc_tau+0xa3>
movsd  0x10(%rsp),%xmm4
movsd  0x8(%rsp),%xmm3
jmp    2a5 <cgst_calc_tau+0x85>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
cgst_calc_tau(const gsl_vector * p, const gsl_vector * d,
              const double delta)
{
  double norm_p, norm_d, u;
  double t1, t2, tau;
  norm_p = gsl_blas_dnrm2(p);
  norm_d = gsl_blas_dnrm2(d);
  gsl_blas_ddot(p, d, &u);
  t1 = u / (norm_d * norm_d);
  t2 = t1*u + (delta + norm_p) * (delta - norm_p);
  tau = -t1 + sqrt(t2) / norm_d;
  return tau;
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 6
8 7
9 6
10 7
11 8
12 8
13 8
14 7
15 8
16 9
17 9
18 9
19 10
20 9
21 9
22 10
23 10
24 10
25 9
26 10
27 10
28 10
29 10
30 11
31 11
32 11
33 11
34 13
35 13
36 13
37 11
38 13
39 11
40 11
41 11
42 11
43 11
44 11
45 11
<<<sep_out_sample>>>
add    %rsi,%rdi
mov    $0xffffffffffffffff,%rax
cmovae %rdi,%rax
retq   
nop
<<<sep_in_sample>>>
xsum (size_t size1, size_t size2)
{
  size_t sum = size1 + size2;
  return (sum >= size1 ? sum : (18446744073709551615UL));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
4 5
5 5
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 5487 <re_set_syntax+0x7>
mov    %rdi,0x0(%rip)        # 548e <re_set_syntax+0xe>
retq   
nop
<<<sep_in_sample>>>
re_set_syntax (syntax)
    reg_syntax_t syntax;
{
  reg_syntax_t ret = re_syntax_options;
  re_syntax_options = syntax;
  return ret;
}
<<<sep_in_sample>>>
1 4
2 5
3 7
4 7
<<<sep_out_sample>>>
sub    $0x5,%edi
xor    %eax,%eax
cmp    $0x1,%edi
seta   %al
retq   
<<<sep_in_sample>>>
arf_stores_inode_p (enum archive_format arf)
{
  switch (arf)
    {
    case arf_tar:
    case arf_ustar:
      return 0;
    default:
      break;
    }
  return 1;
}
<<<sep_in_sample>>>
1 3
2 7
3 7
4 7
5 12
<<<sep_out_sample>>>
push   %rbx
mov    %edi,%ebx
callq  8 <_rl_vi_stuff_insert+0x8>
test   %ebx,%ebx
je     21 <_rl_vi_stuff_insert+0x21>
nopl   0x0(%rax)
mov    0x0(%rip),%rdi        # 17 <_rl_vi_stuff_insert+0x17>
callq  1c <_rl_vi_stuff_insert+0x1c>
sub    $0x1,%ebx
jne    10 <_rl_vi_stuff_insert+0x10>
pop    %rbx
jmpq   27 <_rl_vi_stuff_insert+0x27>
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
_rl_vi_stuff_insert (count)
     int count;
{
  rl_begin_undo_group ();
  while (count--)
    rl_insert_text (vi_insert_buffer);
  rl_end_undo_group ();
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 5
5 5
6 5
7 6
8 6
9 5
10 5
11 8
12 7
13 7
<<<sep_out_sample>>>
push   %r12
xor    %edx,%edx
mov    %rdi,%r12
push   %rbp
mov    %rsi,%rbp
mov    %rbp,%rdi
push   %rbx
sub    $0x10,%rsp
lea    0x8(%rsp),%rsi
callq  9d <get_port_number+0x1d>
mov    %rax,%rbx
mov    0x8(%rsp),%rax
cmpb   $0x0,(%rax)
jne    b2 <get_port_number+0x32>
movzwl %bx,%eax
cmp    %rbx,%rax
je     d0 <get_port_number+0x50>
mov    $0x0,%edi
callq  bc <get_port_number+0x3c>
mov    %rbp,%rcx
mov    %rax,%rdx
xor    %esi,%esi
mov    $0x1,%edi
xor    %eax,%eax
callq  d0 <get_port_number+0x50>
mov    %ebx,(%r12)
add    $0x10,%rsp
pop    %rbx
pop    %rbp
pop    %r12
retq   
nopl   (%rax)
<<<sep_in_sample>>>
get_port_number (unsigned *port, char *str)
{
  char *p;
  unsigned short sp;
  unsigned long lp;
  sp = lp = strtoul (str, &p, 0);
  if (*p || sp != lp)
    anubis_error (1, 0, gettext("Invalid port number: %s"), str);
  *port = (unsigned) lp;
}
<<<sep_in_sample>>>
1 2
2 6
3 2
4 2
5 2
6 6
7 2
8 2
9 6
10 6
11 6
12 7
13 7
14 7
15 7
16 7
17 7
18 8
19 8
20 8
21 8
22 8
23 8
24 8
25 8
26 9
27 10
28 10
29 10
30 10
31 10
32 10
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%rsi        # d1b <pred_readable+0xb>
mov    0x0(%rip),%edi        # d21 <pred_readable+0x11>
xor    %ecx,%ecx
mov    $0x4,%edx
callq  d2d <pred_readable+0x1d>
test   %eax,%eax
sete   %al
add    $0x8,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
pred_readable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
{
  (void) pathname;
  (void) stat_buf;
  (void) pred_ptr;
  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, 4, 0);
}
<<<sep_in_sample>>>
1 2
2 6
3 6
4 6
5 6
6 6
7 6
8 6
9 7
10 7
11 7
<<<sep_out_sample>>>
sub    $0xffffffffffffff80,%rdi
jmpq   a0 <ahsStaticGetTarname_i>
nopl   0x0(%rax)
<<<sep_in_sample>>>
ahsStaticGetTarUsername(struct new_cpio_header * file_hdr)
{
 ;
 return ahsStaticGetTarname_i((STROB**)&(file_hdr->c_username));
}
<<<sep_in_sample>>>
1 4
2 4
3 4
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
mov    $0x0,%edi
push   %rbx
sub    $0x8,%rsp
callq  293 <get_tz+0x13>
test   %rax,%rax
mov    %rax,%rbx
je     2d8 <get_tz+0x58>
mov    %rax,%rdi
callq  2a3 <get_tz+0x23>
lea    0x1(%rax),%rdx
cmp    $0x64,%rdx
ja     2c0 <get_tz+0x40>
add    $0x8,%rsp
mov    %rbx,%rsi
mov    %rbp,%rdi
pop    %rbx
pop    %rbp
jmpq   2be <get_tz+0x3e>
xchg   %ax,%ax
add    $0x8,%rsp
mov    %rbx,%rdi
mov    %rdx,%rsi
pop    %rbx
pop    %rbp
jmpq   2d1 <get_tz+0x51>
nopl   0x0(%rax)
add    $0x8,%rsp
xor    %eax,%eax
pop    %rbx
pop    %rbp
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
get_tz (char tzbuf[TZBUFSIZE])
{
  char *tz = getenv ("TZ");
  if (tz)
    {
      size_t tzsize = strlen (tz) + 1;
      tz = (tzsize <= TZBUFSIZE
            ? memcpy (tzbuf, tz, tzsize)
            : xmemdup (tz, tzsize));
    }
  return tz;
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 3
7 4
8 3
9 4
10 6
11 6
12 6
13 7
14 7
15 12
16 7
17 7
18 12
19 12
20 7
21 7
22 12
23 7
24 7
25 12
26 12
27 7
28 7
29 12
30 12
31 12
32 12
33 12
34 12
<<<sep_out_sample>>>
push   %rbx
mov    %rsi,%rcx
mov    %rsi,%rbx
mov    $0x1,%edx
sub    $0x10,%rsp
lea    0xf(%rsp),%rsi
mov    %dil,0xf(%rsp)
xor    %edi,%edi
callq  21 <brlen+0x21>
mov    %rax,%rdx
cmp    $0xffffffff,%edx
je     30 <brlen+0x30>
add    $0x10,%rsp
pop    %rbx
retq   
nop
movq   $0x0,(%rbx)
add    $0x10,%rsp
mov    $0x1,%eax
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
brlen (ch, cur_stat)
     int ch;
     mbstate_t *cur_stat;
{
  char c = ch;
  int result = mbrtowc(((void *)0), &c, 1, cur_stat);
  if (result == -1)
    {
      memset (cur_stat, 0, sizeof (mbstate_t));
      return 1;
    }
  return result;
}
<<<sep_in_sample>>>
1 4
2 6
3 4
4 6
5 4
6 6
7 5
8 6
9 6
10 6
11 7
12 7
13 13
14 13
15 13
16 13
17 9
18 13
19 10
20 13
21 13
22 13
<<<sep_out_sample>>>
sub    $0x8,%rsp
mov    0x0(%rip),%eax        # 9fa <gsl_matrix_float_get+0xa>
test   %eax,%eax
je     a09 <gsl_matrix_float_get+0x19>
cmp    %rsi,(%rdi)
jbe    a20 <gsl_matrix_float_get+0x30>
cmp    %rdx,0x8(%rdi)
jbe    a48 <gsl_matrix_float_get+0x58>
imul   0x10(%rdi),%rsi
mov    0x18(%rdi),%rax
add    %rsi,%rdx
movss  (%rax,%rdx,4),%xmm0
add    $0x8,%rsp
retq   
nop
mov    $0x4,%ecx
mov    $0x115,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a39 <gsl_matrix_float_get+0x49>
xorps  %xmm0,%xmm0
add    $0x8,%rsp
retq   
nopl   0x0(%rax)
mov    $0x4,%ecx
mov    $0x119,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a61 <gsl_matrix_float_get+0x71>
xorps  %xmm0,%xmm0
jmp    a1a <gsl_matrix_float_get+0x2a>
nopw   %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_float_get(const gsl_matrix_float * m, const size_t i, const size_t j)
{
  if ((gsl_check_range && (1)))
    {
      if (i >= m->size1)
        {
          do { gsl_error ("first index out of range", "../gsl/gsl_matrix_float.h", 277, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
      else if (j >= m->size2)
        {
          do { gsl_error ("second index out of range", "../gsl/gsl_matrix_float.h", 281, GSL_EINVAL) ; return 0 ; } while (0) ;
        }
    }
  return m->data[i * m->tda + j] ;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 3
5 5
6 5
7 9
8 9
9 14
10 14
11 14
12 14
13 15
14 15
15 15
16 7
17 7
18 7
19 7
20 7
21 7
22 15
23 15
24 15
25 11
26 11
27 11
28 11
29 11
30 11
31 11
32 11
<<<sep_out_sample>>>
mov    $0x1,%ecx
mov    $0x1,%edx
xor    %esi,%esi
jmpq   5140 <info_menu_or_ref_item>
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
info_xref_item (WINDOW *window, int count)
{
  info_menu_or_ref_item (window, 0, 1, 1);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
<<<sep_out_sample>>>
xor    %eax,%eax
test   %rdi,%rdi
je     31d <udf_get_modification_time+0x2d>
sub    $0x10,%rsp
mov    0x94(%rdi),%rdx
mov    0x9c(%rdi),%ecx
lea    0x8(%rsp),%rsi
mov    %rsp,%rdi
callq  315 <udf_get_modification_time+0x25>
mov    (%rsp),%rax
add    $0x10,%rsp
repz retq 
nop
<<<sep_in_sample>>>
udf_get_modification_time(const udf_dirent_t *p_udf_dirent)
{
  if (p_udf_dirent) {
    time_t ret_time;
    long int usec;
    udf_stamp_to_time(&ret_time, &usec, p_udf_dirent->fe.modification_time);
    return ret_time;
  }
  return 0;
}
<<<sep_in_sample>>>
1 9
2 3
3 3
4 2
5 6
6 6
7 6
8 6
9 6
10 7
11 10
12 10
13 10
<<<sep_out_sample>>>
push   %rbx
mov    $0x50,%edi
callq  158b <font_info_table_new+0xb>
mov    $0x0,%r8d
mov    %rax,%rbx
mov    %rax,%rdi
mov    $0x0,%ecx
mov    $0x0,%edx
mov    $0x8,%esi
callq  15ab <font_info_table_new+0x2b>
mov    %rbx,%rax
pop    %rbx
retq   
<<<sep_in_sample>>>
font_info_table_new (void)
{
  struct hash_table_s *(res) = ((struct hash_table_s *) xmalloc (sizeof (struct hash_table_s) * (1)));
  hash_init (res, 8,
      (hash_func_t) font_info_hash_1,
      (hash_func_t) font_info_hash_2,
      (hash_cmp_func_t) font_info_hash_cmp);
  return res;
}
<<<sep_in_sample>>>
1 2
2 3
3 3
4 4
5 3
6 4
7 4
8 4
9 4
10 4
11 9
12 9
13 9
<<<sep_out_sample>>>
mov    0x0(%rip),%rax        # 1177 <pch_line_len+0x7>
mov    (%rax,%rdi,8),%rax
retq   
nopl   0x0(%rax)
<<<sep_in_sample>>>
pch_line_len (lin line)
{
    return p_len[line];
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
mov    0x8(%rdi),%rdx
mov    (%rdi),%rcx
test   %rdx,%rdx
je     15c <gsl_multiset_init_last+0x2c>
mov    0x10(%rdi),%rax
sub    $0x1,%rcx
lea    (%rax,%rdx,8),%rdx
nopl   0x0(%rax,%rax,1)
mov    %rcx,(%rax)
add    $0x8,%rax
cmp    %rdx,%rax
jne    150 <gsl_multiset_init_last+0x20>
repz retq 
xchg   %ax,%ax
<<<sep_in_sample>>>
gsl_multiset_init_last (gsl_multiset * c)
{
  const size_t k = c->k ;
  size_t i;
  size_t n = c->n;
  for (i = 0; i < k; i++)
    {
      c->data[i] = n - 1;
    }
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 6
5 6
6 6
7 6
8 6
9 8
10 8
11 6
12 6
13 6
14 6
<<<sep_out_sample>>>
sub    $0x8,%rsp
callq  9 <acm_rand+0x9>
add    $0x8,%rsp
movzwl %ax,%eax
retq   
data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
acm_rand(void)
{
 return rand() & 0xffff;
}
<<<sep_in_sample>>>
1 2
2 3
3 4
4 3
5 4
6 4
<<<sep_out_sample>>>
mov    $0x0,%r8d
mov    $0x0,%ecx
xor    %edx,%edx
xor    %esi,%esi
mov    $0x0,%edi
jmpq   19 <init_newstr+0x19>
nopl   0x0(%rax)
<<<sep_in_sample>>>
init_newstr (void)
{
  _obstack_begin ((&os_newstr), 0, 0, (void *(*) (long)) xmalloc, (void (*) (void *)) free);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 3
7 3
<<<sep_out_sample>>>
push   %rbp
mov    %rdi,%rbp
push   %rbx
mov    %rsi,%rbx
sub    $0x18,%rsp
movsbl (%rsi),%esi
test   %sil,%sil
je     243 <grecs_txtacc_grow_string_escape+0x63>
nopl   0x0(%rax)
mov    $0x0,%edi
callq  202 <grecs_txtacc_grow_string_escape+0x22>
test   %rax,%rax
je     21e <grecs_txtacc_grow_string_escape+0x3e>
lea    0xf(%rsp),%rsi
mov    $0x1,%edx
mov    %rbp,%rdi
movb   $0x5c,0xf(%rsp)
callq  21e <grecs_txtacc_grow_string_escape+0x3e>
movzbl (%rbx),%eax
lea    0xf(%rsp),%rsi
add    $0x1,%rbx
mov    $0x1,%edx
mov    %rbp,%rdi
mov    %al,0xf(%rsp)
callq  23b <grecs_txtacc_grow_string_escape+0x5b>
movsbl (%rbx),%esi
test   %sil,%sil
jne    1f8 <grecs_txtacc_grow_string_escape+0x18>
add    $0x18,%rsp
pop    %rbx
pop    %rbp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
grecs_txtacc_grow_string_escape(struct grecs_txtacc *acc, const char *buf)
{
 for (; *buf; buf++) {
  if (strchr(" \t\n\"\'\\", *buf))
   do { char __ch = '\\'; grecs_txtacc_grow(acc,&__ch,1); } while (0);
  do { char __ch = *buf; grecs_txtacc_grow(acc,&__ch,1); } while (0);
 }
}
<<<sep_in_sample>>>
1 2
2 2
3 2
4 2
5 2
6 3
7 3
8 3
9 3
10 4
11 4
12 4
13 4
14 5
15 5
16 5
17 5
18 5
19 6
20 6
21 3
22 6
23 6
24 6
25 6
26 3
27 3
28 3
29 8
30 8
31 8
32 8
33 8
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    (%rax),%rax
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_multimin_fdfminimizer_name (const gsl_multimin_fdfminimizer * s)
{
  return s->type->name;
}
<<<sep_in_sample>>>
1 3
2 3
3 4
4 4
<<<sep_out_sample>>>
test   %rdi,%rdi
je     808 <mu_url_get_port+0x28>
mov    0x98(%rdi),%rax
test   %rax,%rax
je     7f8 <mu_url_get_port+0x18>
jmpq   *%rax
nopl   0x0(%rax,%rax,1)
mov    0x30(%rdi),%rax
mov    %rax,(%rsi)
xor    %eax,%eax
retq   
nopw   0x0(%rax,%rax,1)
mov    $0x16,%eax
retq   
xchg   %ax,%ax
<<<sep_in_sample>>>
mu_url_get_port (const mu_url_t url, long *pport)
{
  if (url == ((void *)0))
    return 22;
  if (url->_get_port)
    return url->_get_port (url, pport);
  *pport = url->port;
  return 0;
}
<<<sep_in_sample>>>
1 3
2 3
3 5
4 5
5 5
6 6
7 6
8 7
9 7
10 8
11 8
12 8
13 4
14 9
15 9
<<<sep_out_sample>>>
addsd  %xmm0,%xmm0
movapd %xmm1,%xmm4
movsd  0x0(%rip),%xmm2        # f0 <gsl_sf_bessel_asymp_thetanu_corr_e+0x10>
xor    %eax,%eax
mulsd  %xmm1,%xmm4
movsd  0x0(%rip),%xmm3        # fe <gsl_sf_bessel_asymp_thetanu_corr_e+0x1e>
divsd  %xmm1,%xmm0
divsd  %xmm4,%xmm2
divsd  %xmm4,%xmm3
mulsd  %xmm0,%xmm0
movapd %xmm0,%xmm5
subsd  %xmm3,%xmm0
subsd  %xmm2,%xmm5
movapd %xmm5,%xmm2
mulsd  %xmm1,%xmm2
movsd  0x0(%rip),%xmm1        # 12a <gsl_sf_bessel_asymp_thetanu_corr_e+0x4a>
mulsd  %xmm2,%xmm0
mulsd  %xmm2,%xmm1
divsd  0x0(%rip),%xmm0        # 13a <gsl_sf_bessel_asymp_thetanu_corr_e+0x5a>
subsd  0x0(%rip),%xmm1        # 142 <gsl_sf_bessel_asymp_thetanu_corr_e+0x62>
addsd  %xmm0,%xmm1
movsd  %xmm1,(%rdi)
retq   
<<<sep_in_sample>>>
gsl_sf_bessel_asymp_thetanu_corr_e(const double nu, const double x, double * result)
{
  const double r = 2.0*nu/x;
  const double r2 = r*r;
  const double x2 = x*x;
  const double term1 = x*(r2 - 1.0/x2)/8.0;
  const double term2 = x*(r2 - 1.0/x2)*(r2 - 25.0/x2)/384.0;
  *result = (-0.25*3.14159265358979323846 + term1 + term2);
  return GSL_SUCCESS;
}
<<<sep_in_sample>>>
1 3
2 5
3 6
4 10
5 5
6 7
7 3
8 6
9 7
10 4
11 6
12 7
13 6
14 6
15 6
16 6
17 7
18 6
19 7
20 8
21 8
22 8
23 10
<<<sep_out_sample>>>
push   %rbp
mov    %rsi,%rbp
mov    $0x0,%esi
push   %rbx
mov    %rdi,%rbx
sub    $0x18,%rsp
mov    0x20(%rdi),%rax
mov    0x18(%rdi),%r9
mov    0x10(%rdi),%r8
mov    0x8(%rdi),%rcx
mov    %rax,(%rsp)
mov    (%rdi),%rdx
xor    %eax,%eax
mov    %rbp,%rdi
callq  752 <putpfent+0x32>
mov    0x28(%rbx),%rdx
test   %rdx,%rdx
je     770 <putpfent+0x50>
add    $0x18,%rsp
mov    %rbp,%rdi
mov    $0x0,%esi
pop    %rbx
pop    %rbp
xor    %eax,%eax
jmpq   770 <putpfent+0x50>
add    $0x18,%rsp
mov    %rbp,%rsi
mov    $0xa,%edi
pop    %rbx
pop    %rbp
jmpq   783 <putpfent+0x63>
data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
putpfent (register const struct pfile *pf, register FILE * f)
{
  fprintf (f, "%s %s %s %s %s", pf->p_osid, pf->p_nsid,
           pf->p_user, pf->p_date, pf->p_time);
  if (pf->p_aux != ((void *)0))
    fprintf (f, " %s", pf->p_aux);
  else
    fprintf (f, "\n");
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 2
5 2
6 2
7 3
8 3
9 3
10 3
11 3
12 3
13 3
14 3
15 3
16 5
17 5
18 5
19 9
20 6
21 6
22 9
23 9
24 6
25 6
26 9
27 8
28 8
29 9
30 9
31 8
32 8
<<<sep_out_sample>>>
cmp    %rdx,0x8(%rsi)
mov    %rdi,%rax
jbe    4658 <gsl_matrix_complex_const_column+0x38>
shl    $0x4,%rdx
add    0x18(%rsi),%rdx
mov    0x10(%rsi),%rdi
mov    0x20(%rsi),%rcx
mov    (%rsi),%rsi
movl   $0x0,0x20(%rax)
mov    %rdi,0x8(%rax)
mov    %rsi,(%rax)
mov    %rdx,0x10(%rax)
mov    %rcx,0x18(%rax)
retq   
nopl   0x0(%rax,%rax,1)
sub    $0x18,%rsp
mov    $0x4,%ecx
mov    $0x33,%edx
mov    %rdi,0x8(%rsp)
mov    $0x0,%esi
mov    $0x0,%edi
callq  467a <gsl_matrix_complex_const_column+0x5a>
mov    0x8(%rsp),%rax
movq   $0x0,(%rax)
movq   $0x0,0x8(%rax)
movq   $0x0,0x10(%rax)
movq   $0x0,0x18(%rax)
movl   $0x0,0x20(%rax)
add    $0x18,%rsp
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_matrix_complex_const_column (const gsl_matrix_complex * m, const size_t j)
{
  _gsl_vector_complex_const_view view = {{0, 0, 0, 0, 0}};
  if (j >= m->size2)
    {
      do { gsl_error ("column index is out of range", "rowcol_source.c", 51, GSL_EINVAL) ; return view ; } while (0);
    }
  {
    gsl_vector_complex v = {0, 0, 0, 0, 0};
    v.data = m->data + j * 2;
    v.size = m->size1;
    v.stride = m->tda;
    v.block = m->block;
    v.owner = 0;
    view.vector = v;
    return view;
  }
}
<<<sep_in_sample>>>
1 4
2 2
3 4
4 10
5 10
6 12
7 13
8 16
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 2
17 6
18 6
19 6
20 6
21 6
22 6
23 6
24 6
25 6
26 6
27 6
28 6
29 18
30 18
31 18
<<<sep_out_sample>>>
push   %rbx
mov    %rdi,%rbx
callq  8b9 <rename_file+0x9>
test   %rbx,%rbx
je     8d0 <rename_file+0x20>
xchg   %ax,%ax
mov    0x8(%rbx),%rax
mov    %rax,(%rbx)
mov    0x38(%rbx),%rbx
test   %rbx,%rbx
jne    8c0 <rename_file+0x10>
pop    %rbx
retq   
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
rename_file (struct file *from_file, const char *to_hname)
{
  rehash_file (from_file, to_hname);
  while (from_file)
    {
      from_file->name = from_file->hname;
      from_file = from_file->prev;
    }
}
<<<sep_in_sample>>>
1 2
2 2
3 3
4 4
5 4
6 4
7 6
8 6
9 7
10 4
11 4
12 9
13 9
14 9
<<<sep_out_sample>>>
mov    0x20(%rdi),%rax
retq   
data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_get_n_entries (const Hash_table *table)
{
  return table->n_entries;
}
<<<sep_in_sample>>>
1 3
2 4
3 4
<<<sep_out_sample>>>
sub    $0x21,%edi
cmp    $0x5d,%edi
setbe  %al
retq   
nopw   0x0(%rax,%rax,1)
<<<sep_in_sample>>>
c_isgraph (int c)
{
  return (c >= '!' && c <= '~');
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 4
5 4
<<<sep_out_sample>>>
movzbl (%rdi),%r8d
xor    %edx,%edx
test   %r8b,%r8b
je     800 <hash_string+0x30>
nopl   0x0(%rax,%rax,1)
mov    %rdx,%rcx
add    $0x1,%rdi
shl    $0x5,%rcx
sub    %rdx,%rcx
xor    %edx,%edx
lea    (%r8,%rcx,1),%rax
movzbl (%rdi),%r8d
div    %rsi
test   %r8b,%r8b
jne    7e0 <hash_string+0x10>
mov    %rdx,%rax
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
hash_string (const char *string, size_t n_buckets)
{
  size_t value = 0;
  unsigned char ch;
  for (; (ch = *string); string++)
    value = (value * 31 + ch) % n_buckets;
  return value;
}
<<<sep_in_sample>>>
1 5
2 3
3 5
4 5
5 5
6 6
7 5
8 6
9 6
10 6
11 6
12 5
13 6
14 5
15 5
16 8
17 8
18 8
<<<sep_out_sample>>>
mov    0x0(%rip),%eax        # 9e6 <gsl_vector_long_ptr+0x6>
test   %eax,%eax
je     9ef <gsl_vector_long_ptr+0xf>
cmp    %rsi,(%rdi)
jbe    a00 <gsl_vector_long_ptr+0x20>
mov    0x8(%rdi),%rax
shl    $0x3,%rax
imul   %rsi,%rax
add    0x10(%rdi),%rax
retq   
sub    $0x8,%rsp
mov    $0x4,%ecx
mov    $0xce,%edx
mov    $0x0,%esi
mov    $0x0,%edi
callq  a1d <gsl_vector_long_ptr+0x3d>
xor    %eax,%eax
add    $0x8,%rsp
retq   
data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_vector_long_ptr (gsl_vector_long * v, const size_t i)
{
  if ((gsl_check_range && (i >= v->size)))
    {
      do { gsl_error ("index out of range", "../gsl/gsl_vector_long.h", 206, GSL_EINVAL) ; return 0 ; } while (0);
    }
  return (long *) (v->data + i * v->stride);
}
<<<sep_in_sample>>>
1 3
2 3
3 3
4 3
5 3
6 7
7 7
8 7
9 7
10 7
11 2
12 5
13 5
14 5
15 5
16 5
17 5
18 8
19 8
20 8
<<<sep_out_sample>>>
ucomisd %xmm1,%xmm0
ja     4c0 <gsl_interp_eval_integ_e+0x30>
movsd  0x8(%rdi),%xmm2
ucomisd %xmm0,%xmm2
ja     4c0 <gsl_interp_eval_integ_e+0x30>
ucomisd 0x10(%rdi),%xmm1
ja     4c0 <gsl_interp_eval_integ_e+0x30>
ucomisd %xmm1,%xmm0
jp     4d8 <gsl_interp_eval_integ_e+0x48>
xchg   %ax,%ax
jne    4d8 <gsl_interp_eval_integ_e+0x48>
movq   $0x0,(%r8)
xor    %eax,%eax
retq   
nopl   0x0(%rax)
movsd  0x0(%rip),%xmm3        # 4c8 <gsl_interp_eval_integ_e+0x38>
mov    $0x1,%eax
movsd  %xmm3,(%r8)
retq   
nopl   0x0(%rax,%rax,1)
mov    (%rdi),%rax
mov    0x18(%rdi),%r10
mov    %r8,%r9
mov    0x20(%rdi),%rdi
mov    %rcx,%r8
mov    0x38(%rax),%rax
mov    %r10,%rcx
jmpq   *%rax
data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
<<<sep_in_sample>>>
gsl_interp_eval_integ_e (const gsl_interp * interp,
                         const double xa[], const double ya[],
                         double a, double b,
                         gsl_interp_accel * acc,
                         double * result)
{
  if (a > b || a < interp->xmin || b > interp->xmax)
    {
      *result = (__builtin_nanf (""));
      return GSL_EDOM;
    }
  else if(a == b)
    {
      *result = 0.0;
      return GSL_SUCCESS;
    }
  return interp->type->eval_integ (interp->state, xa, ya, interp->size, acc, a, b, result);
}
<<<sep_in_sample>>>
1 7
2 7
3 7
4 7
5 7
6 7
7 7
8 12
9 12
10 12
11 12
12 14
13 15
14 15
15 15
16 9
17 10
18 9
19 10
20 10
21 17
22 17
23 17
24 17
25 17
26 17
27 17
28 17
29 17
<<<sep_out_sample>>>
mov    (%rdi),%rax
mov    0x10(%rax),%rax
jmpq   *%rax
nopl   0x0(%rax)
<<<sep_in_sample>>>
gl_list_size (gl_list_t list)
{
  return ((const struct gl_list_impl_base *) list)->vtable
         ->size (list);
}
<<<sep_in_sample>>>
1 4
2 3
3 3
4 3